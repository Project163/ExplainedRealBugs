diff --git a/crates/next-api/src/app.rs b/crates/next-api/src/app.rs
index 6227e55a1a..5d4ad2780d 100644
--- a/crates/next-api/src/app.rs
+++ b/crates/next-api/src/app.rs
@@ -67,9 +67,7 @@ use turbopack_core::{
 use turbopack_ecmascript::resolve::cjs_resolve;
 
 use crate::{
-    dynamic_imports::{
-        collect_next_dynamic_chunks, DynamicImportedChunks, NextDynamicChunkAvailability,
-    },
+    dynamic_imports::{collect_next_dynamic_chunks, NextDynamicChunkAvailability},
     font::create_font_manifest,
     loadable_manifest::create_react_loadable_manifest,
     module_graph::get_reduced_graphs_for_endpoint,
@@ -917,17 +915,15 @@ impl AppEndpoint {
 
         let app_entry = self.app_endpoint_entry().await?;
 
-        let (process_client_components, process_client_assets, process_ssr, emit_manifests) =
-            match this.ty {
-                AppEndpointType::Page { ty, .. } => (
-                    true,
-                    true,
-                    matches!(ty, AppPageEndpointType::Html),
-                    matches!(ty, AppPageEndpointType::Html),
-                ),
-                AppEndpointType::Route { .. } => (true, false, false, true),
-                AppEndpointType::Metadata { .. } => (false, false, false, true),
-            };
+        let (process_client_assets, process_ssr, emit_manifests) = match this.ty {
+            AppEndpointType::Page { ty, .. } => (
+                true,
+                matches!(ty, AppPageEndpointType::Html),
+                matches!(ty, AppPageEndpointType::Html),
+            ),
+            AppEndpointType::Route { .. } => (false, false, true),
+            AppEndpointType::Metadata { .. } => (false, false, true),
+        };
 
         let node_root = this.app_project.project().node_root();
 
@@ -960,223 +956,197 @@ impl AppEndpoint {
             None
         };
 
-        let (next_dynamic_imports, client_references, client_references_chunks) =
-            if process_client_components {
-                let client_shared_chunk_group = get_app_client_shared_chunk_group(
-                    AssetIdent::from_path(this.app_project.project().project_path())
-                        .with_modifier(client_shared_chunks_modifier()),
-                    this.app_project.client_runtime_entries(),
-                    client_chunking_context,
-                )
-                .await?;
-
-                let mut client_shared_chunks = vec![];
-                for chunk in client_shared_chunk_group.assets.await?.iter().copied() {
-                    client_assets.insert(chunk);
+        let client_shared_chunk_group = get_app_client_shared_chunk_group(
+            AssetIdent::from_path(this.app_project.project().project_path())
+                .with_modifier(client_shared_chunks_modifier()),
+            this.app_project.client_runtime_entries(),
+            client_chunking_context,
+        )
+        .await?;
 
-                    let chunk_path = chunk.ident().path().await?;
-                    if chunk_path.extension_ref() == Some("js") {
-                        client_shared_chunks.push(chunk);
-                    }
-                }
-                let client_shared_availability_info = client_shared_chunk_group.availability_info;
+        let mut client_shared_chunks = vec![];
+        for chunk in client_shared_chunk_group.assets.await?.iter().copied() {
+            client_assets.insert(chunk);
 
-                let reduced_graphs =
-                    get_reduced_graphs_for_endpoint(this.app_project.project(), *rsc_entry);
-                let next_dynamic_imports = reduced_graphs
-                    .get_next_dynamic_imports_for_endpoint(*rsc_entry)
-                    .await?;
+            let chunk_path = chunk.ident().path().await?;
+            if chunk_path.extension_ref() == Some("js") {
+                client_shared_chunks.push(chunk);
+            }
+        }
+        let client_shared_availability_info = client_shared_chunk_group.availability_info;
 
-                let client_references_cell =
-                    reduced_graphs.get_client_references_for_endpoint(*rsc_entry);
-
-                let client_references_chunks = get_app_client_references_chunks(
-                    client_references_cell,
-                    client_chunking_context,
-                    Value::new(client_shared_availability_info),
-                    ssr_chunking_context,
-                );
-                let client_references_chunks_ref = client_references_chunks.await?;
-
-                let mut entry_client_chunks = FxIndexSet::default();
-                // TODO(alexkirsz) In which manifest does this go?
-                let mut entry_ssr_chunks = FxIndexSet::default();
-                for chunks in client_references_chunks_ref
-                    .layout_segment_client_chunks
-                    .values()
-                {
-                    entry_client_chunks.extend(chunks.await?.iter().copied());
-                }
-                for (chunks, _) in client_references_chunks_ref
-                    .client_component_client_chunks
-                    .values()
-                {
-                    client_assets.extend(chunks.await?.iter().copied());
-                }
-                for (chunks, _) in client_references_chunks_ref
-                    .client_component_ssr_chunks
-                    .values()
-                {
-                    entry_ssr_chunks.extend(chunks.await?.iter().copied());
-                }
+        let reduced_graphs =
+            get_reduced_graphs_for_endpoint(this.app_project.project(), *rsc_entry);
+        let next_dynamic_imports = reduced_graphs
+            .get_next_dynamic_imports_for_endpoint(*rsc_entry)
+            .await?;
 
-                client_assets.extend(entry_client_chunks.iter().copied());
-                server_assets.extend(entry_ssr_chunks.iter().copied());
+        let client_references = reduced_graphs.get_client_references_for_endpoint(*rsc_entry);
+
+        let client_references_chunks = get_app_client_references_chunks(
+            client_references,
+            client_chunking_context,
+            Value::new(client_shared_availability_info),
+            ssr_chunking_context,
+        );
+        let client_references_chunks_ref = client_references_chunks.await?;
+
+        let mut entry_client_chunks = FxIndexSet::default();
+        // TODO(alexkirsz) In which manifest does this go?
+        let mut entry_ssr_chunks = FxIndexSet::default();
+        for chunks in client_references_chunks_ref
+            .layout_segment_client_chunks
+            .values()
+        {
+            entry_client_chunks.extend(chunks.await?.iter().copied());
+        }
+        for (chunks, _) in client_references_chunks_ref
+            .client_component_client_chunks
+            .values()
+        {
+            client_assets.extend(chunks.await?.iter().copied());
+        }
+        for (chunks, _) in client_references_chunks_ref
+            .client_component_ssr_chunks
+            .values()
+        {
+            entry_ssr_chunks.extend(chunks.await?.iter().copied());
+        }
 
-                let manifest_path_prefix = &app_entry.original_name;
+        client_assets.extend(entry_client_chunks.iter().copied());
+        server_assets.extend(entry_ssr_chunks.iter().copied());
 
-                if emit_manifests {
-                    let app_build_manifest = AppBuildManifest {
-                        pages: fxindexmap!(
-                            app_entry.original_name.clone() => Vc::cell(entry_client_chunks
-                                .iter()
-                                .chain(client_shared_chunks.iter())
-                                .copied()
-                                .collect())
-                        ),
-                    };
-                    let app_build_manifest_output =
-                        app_build_manifest
-                            .build_output(
-                                node_root.join(
-                                    format!(
-                                        "server/app{manifest_path_prefix}/app-build-manifest.json",
-                                    )
-                                    .into(),
-                                ),
-                                client_relative_path,
-                            )
-                            .await?
-                            .to_resolved()
-                            .await?;
+        let manifest_path_prefix = &app_entry.original_name;
 
-                    server_assets.insert(app_build_manifest_output);
-                }
+        if emit_manifests {
+            let app_build_manifest = AppBuildManifest {
+                pages: fxindexmap!(
+                    app_entry.original_name.clone() => Vc::cell(entry_client_chunks
+                        .iter()
+                        .chain(client_shared_chunks.iter())
+                        .copied()
+                        .collect())
+                ),
+            };
+            let app_build_manifest_output = app_build_manifest
+                .build_output(
+                    node_root.join(
+                        format!("server/app{manifest_path_prefix}/app-build-manifest.json",).into(),
+                    ),
+                    client_relative_path,
+                )
+                .await?
+                .to_resolved()
+                .await?;
 
-                // polyfill-nomodule.js is a pre-compiled asset distributed as part of next,
-                // load it as a RawModule.
-                let next_package = get_next_package(this.app_project.project().project_path());
-                let polyfill_source = FileSource::new(
-                    next_package.join("dist/build/polyfills/polyfill-nomodule.js".into()),
-                );
-                let polyfill_output_path =
-                    client_chunking_context.chunk_path(polyfill_source.ident(), ".js".into());
-                let polyfill_output_asset = ResolvedVc::upcast(
-                    RawOutput::new(polyfill_output_path, Vc::upcast(polyfill_source))
-                        .to_resolved()
-                        .await?,
-                );
-                client_assets.insert(polyfill_output_asset);
+            server_assets.insert(app_build_manifest_output);
+        }
 
-                if emit_manifests {
-                    if *this
-                        .app_project
-                        .project()
-                        .should_create_webpack_stats()
-                        .await?
-                    {
-                        let webpack_stats =
-                            generate_webpack_stats(app_entry.original_name.clone(), &client_assets)
-                                .await?;
-                        let stats_output = VirtualOutputAsset::new(
-                            node_root.join(
-                                format!("server/app{manifest_path_prefix}/webpack-stats.json",)
-                                    .into(),
-                            ),
-                            AssetContent::file(
-                                File::from(serde_json::to_string_pretty(&webpack_stats)?).into(),
-                            ),
-                        )
-                        .to_resolved()
-                        .await?;
-                        server_assets.insert(ResolvedVc::upcast(stats_output));
-                    }
+        // polyfill-nomodule.js is a pre-compiled asset distributed as part of next,
+        // load it as a RawModule.
+        let next_package = get_next_package(this.app_project.project().project_path());
+        let polyfill_source =
+            FileSource::new(next_package.join("dist/build/polyfills/polyfill-nomodule.js".into()));
+        let polyfill_output_path =
+            client_chunking_context.chunk_path(polyfill_source.ident(), ".js".into());
+        let polyfill_output_asset = ResolvedVc::upcast(
+            RawOutput::new(polyfill_output_path, Vc::upcast(polyfill_source))
+                .to_resolved()
+                .await?,
+        );
+        client_assets.insert(polyfill_output_asset);
 
-                    let build_manifest = BuildManifest {
-                        root_main_files: client_shared_chunks,
-                        polyfill_files: vec![polyfill_output_asset],
-                        ..Default::default()
-                    };
-                    let build_manifest_output =
-                        ResolvedVc::upcast(
-                            build_manifest
-                                .build_output(
-                                    node_root.join(
-                                        format!(
-                                            "server/app{manifest_path_prefix}/build-manifest.json",
-                                        )
-                                        .into(),
-                                    ),
-                                    client_relative_path,
-                                )
-                                .await?
-                                .to_resolved()
-                                .await?,
-                        );
-                    server_assets.insert(build_manifest_output);
-                }
+        if emit_manifests {
+            if *this
+                .app_project
+                .project()
+                .should_create_webpack_stats()
+                .await?
+            {
+                let webpack_stats =
+                    generate_webpack_stats(app_entry.original_name.clone(), &client_assets).await?;
+                let stats_output = VirtualOutputAsset::new(
+                    node_root.join(
+                        format!("server/app{manifest_path_prefix}/webpack-stats.json",).into(),
+                    ),
+                    AssetContent::file(
+                        File::from(serde_json::to_string_pretty(&webpack_stats)?).into(),
+                    ),
+                )
+                .to_resolved()
+                .await?;
+                server_assets.insert(ResolvedVc::upcast(stats_output));
+            }
 
-                if runtime == NextRuntime::Edge {
-                    // as the edge runtime doesn't support chunk loading we need to add all client
-                    // references to the middleware manifest so they get loaded during runtime
-                    // initialization
-                    let client_references_chunks = &*client_references_chunks.await?;
+            let build_manifest = BuildManifest {
+                root_main_files: client_shared_chunks,
+                polyfill_files: vec![polyfill_output_asset],
+                ..Default::default()
+            };
+            let build_manifest_output = ResolvedVc::upcast(
+                build_manifest
+                    .build_output(
+                        node_root.join(
+                            format!("server/app{manifest_path_prefix}/build-manifest.json",).into(),
+                        ),
+                        client_relative_path,
+                    )
+                    .await?
+                    .to_resolved()
+                    .await?,
+            );
+            server_assets.insert(build_manifest_output);
+        }
 
-                    for (ssr_chunks, _) in client_references_chunks
-                        .client_component_ssr_chunks
-                        .values()
-                    {
-                        let ssr_chunks = ssr_chunks.await?;
+        if runtime == NextRuntime::Edge {
+            // as the edge runtime doesn't support chunk loading we need to add all client
+            // references to the middleware manifest so they get loaded during runtime
+            // initialization
+            let client_references_chunks = &*client_references_chunks.await?;
 
-                        middleware_assets.extend(ssr_chunks);
-                    }
-                }
+            for (ssr_chunks, _) in client_references_chunks
+                .client_component_ssr_chunks
+                .values()
+            {
+                let ssr_chunks = ssr_chunks.await?;
 
-                (
-                    Some(next_dynamic_imports),
-                    Some(client_references_cell),
-                    Some(client_references_chunks),
-                )
-            } else {
-                (None, None, None)
-            };
+                middleware_assets.extend(ssr_chunks);
+            }
+        }
 
-        let server_action_manifest_loader = if process_client_components {
-            let reduced_graphs =
-                get_reduced_graphs_for_endpoint(this.app_project.project(), *rsc_entry);
-            let actions = reduced_graphs.get_server_actions_for_endpoint(
-                *rsc_entry,
-                match runtime {
-                    NextRuntime::Edge => Vc::upcast(this.app_project.edge_rsc_module_context()),
-                    NextRuntime::NodeJs => Vc::upcast(this.app_project.rsc_module_context()),
-                },
-            );
+        let reduced_graphs =
+            get_reduced_graphs_for_endpoint(this.app_project.project(), *rsc_entry);
+        let actions = reduced_graphs.get_server_actions_for_endpoint(
+            *rsc_entry,
+            match runtime {
+                NextRuntime::Edge => Vc::upcast(this.app_project.edge_rsc_module_context()),
+                NextRuntime::NodeJs => Vc::upcast(this.app_project.rsc_module_context()),
+            },
+        );
+
+        let server_action_manifest = create_server_actions_manifest(
+            actions,
+            this.app_project.project().project_path(),
+            node_root,
+            app_entry.original_name.clone(),
+            runtime,
+            match runtime {
+                NextRuntime::Edge => Vc::upcast(this.app_project.edge_rsc_module_context()),
+                NextRuntime::NodeJs => Vc::upcast(this.app_project.rsc_module_context()),
+            },
+            this.app_project
+                .project()
+                .runtime_chunking_context(process_client_assets, runtime),
+        )
+        .await?;
+        server_assets.insert(server_action_manifest.manifest);
 
-            let server_action_manifest = create_server_actions_manifest(
-                actions,
-                this.app_project.project().project_path(),
-                node_root,
-                app_entry.original_name.clone(),
-                runtime,
-                match runtime {
-                    NextRuntime::Edge => Vc::upcast(this.app_project.edge_rsc_module_context()),
-                    NextRuntime::NodeJs => Vc::upcast(this.app_project.rsc_module_context()),
-                },
-                this.app_project
-                    .project()
-                    .runtime_chunking_context(process_client_assets, runtime),
-            )
-            .await?;
-            server_assets.insert(server_action_manifest.manifest);
-            Some(server_action_manifest.loader)
-        } else {
-            None
-        };
+        let server_action_manifest_loader = server_action_manifest.loader;
 
         let (app_entry_chunks, app_entry_chunks_availability) = &*self
             .app_entry_chunks(
                 client_references,
-                server_action_manifest_loader.map(|v| *v),
+                *server_action_manifest_loader,
                 server_path,
                 process_client_assets,
             )
@@ -1192,31 +1162,27 @@ impl AppEndpoint {
         let mut client_reference_manifest = None;
 
         if emit_manifests {
-            if let (Some(client_references), Some(client_references_chunks)) =
-                (client_references, client_references_chunks)
-            {
-                let entry_manifest = ClientReferenceManifest::build_output(
-                    node_root,
-                    client_relative_path,
-                    app_entry.original_name.clone(),
-                    client_references,
-                    client_references_chunks,
-                    **app_entry_chunks,
-                    Value::new(*app_entry_chunks_availability),
-                    client_chunking_context,
-                    ssr_chunking_context,
-                    this.app_project.project().next_config(),
-                    runtime,
-                    this.app_project.project().next_mode(),
-                )
-                .to_resolved()
-                .await?;
-                server_assets.insert(entry_manifest);
-                if runtime == NextRuntime::Edge {
-                    middleware_assets.push(entry_manifest);
-                }
-                client_reference_manifest = Some(entry_manifest)
+            let entry_manifest = ClientReferenceManifest::build_output(
+                node_root,
+                client_relative_path,
+                app_entry.original_name.clone(),
+                client_references,
+                client_references_chunks,
+                **app_entry_chunks,
+                Value::new(*app_entry_chunks_availability),
+                client_chunking_context,
+                ssr_chunking_context,
+                this.app_project.project().next_config(),
+                runtime,
+                this.app_project.project().next_mode(),
+            )
+            .to_resolved()
+            .await?;
+            server_assets.insert(entry_manifest);
+            if runtime == NextRuntime::Edge {
+                middleware_assets.push(entry_manifest);
             }
+            client_reference_manifest = Some(entry_manifest);
 
             let next_font_manifest_output = create_font_manifest(
                 this.app_project.project().client_root(),
@@ -1266,21 +1232,15 @@ impl AppEndpoint {
                 let entry_file = "app-edge-has-no-entrypoint".into();
 
                 if emit_manifests {
-                    let dynamic_import_entries =
-                        if let (Some(next_dynamic_imports), Some(client_references_chunks)) =
-                            (next_dynamic_imports, client_references_chunks)
-                        {
-                            collect_next_dynamic_chunks(
-                                Vc::upcast(client_chunking_context),
-                                next_dynamic_imports,
-                                NextDynamicChunkAvailability::ClientReferences(
-                                    &*(client_references_chunks.await?),
-                                ),
-                            )
-                            .await?
-                        } else {
-                            DynamicImportedChunks::default().resolved_cell()
-                        };
+                    let dynamic_import_entries = collect_next_dynamic_chunks(
+                        Vc::upcast(client_chunking_context),
+                        next_dynamic_imports,
+                        NextDynamicChunkAvailability::ClientReferences(
+                            &*(client_references_chunks.await?),
+                        ),
+                    )
+                    .await?;
+
                     let loadable_manifest_output = create_react_loadable_manifest(
                         *dynamic_import_entries,
                         client_relative_path,
@@ -1294,6 +1254,7 @@ impl AppEndpoint {
                         NextRuntime::Edge,
                     )
                     .await?;
+
                     server_assets.extend(loadable_manifest_output.iter().copied());
                     file_paths_from_root.extend(
                         get_js_paths_from_root(&node_root_value, &loadable_manifest_output).await?,
@@ -1385,21 +1346,15 @@ impl AppEndpoint {
                     server_assets.insert(app_paths_manifest_output);
 
                     // create react-loadable-manifest for next/dynamic
-                    let dynamic_import_entries =
-                        if let (Some(next_dynamic_imports), Some(client_references_chunks)) =
-                            (next_dynamic_imports, client_references_chunks)
-                        {
-                            collect_next_dynamic_chunks(
-                                Vc::upcast(client_chunking_context),
-                                next_dynamic_imports,
-                                NextDynamicChunkAvailability::ClientReferences(
-                                    &*(client_references_chunks.await?),
-                                ),
-                            )
-                            .await?
-                        } else {
-                            DynamicImportedChunks::default().resolved_cell()
-                        };
+                    let dynamic_import_entries = collect_next_dynamic_chunks(
+                        Vc::upcast(client_chunking_context),
+                        next_dynamic_imports,
+                        NextDynamicChunkAvailability::ClientReferences(
+                            &*(client_references_chunks.await?),
+                        ),
+                    )
+                    .await?;
+
                     let loadable_manifest_output = create_react_loadable_manifest(
                         *dynamic_import_entries,
                         client_relative_path,
@@ -1413,6 +1368,7 @@ impl AppEndpoint {
                         NextRuntime::NodeJs,
                     )
                     .await?;
+
                     server_assets.extend(loadable_manifest_output.iter().copied());
                     Some(loadable_manifest_output)
                 } else {
@@ -1459,8 +1415,8 @@ impl AppEndpoint {
     #[turbo_tasks::function]
     async fn app_entry_chunks(
         self: Vc<Self>,
-        client_references: Option<Vc<ClientReferenceGraphResult>>,
-        server_action_manifest_loader: Option<Vc<Box<dyn EvaluatableAsset>>>,
+        client_references: Vc<ClientReferenceGraphResult>,
+        server_action_manifest_loader: ResolvedVc<Box<dyn EvaluatableAsset>>,
         server_path: Vc<FileSystemPath>,
         process_client_assets: bool,
     ) -> Result<Vc<OutputAssetsWithAvailability>> {
@@ -1484,10 +1440,7 @@ impl AppEndpoint {
                     .await?
                     .context("Entry module must be evaluatable")?;
                 evaluatable_assets.push(evaluatable);
-
-                if let Some(server_action_manifest_loader) = server_action_manifest_loader {
-                    evaluatable_assets.push(server_action_manifest_loader.to_resolved().await?);
-                }
+                evaluatable_assets.push(server_action_manifest_loader);
 
                 {
                     let _span = tracing::info_span!("Server Components");
@@ -1508,9 +1461,7 @@ impl AppEndpoint {
                 let mut evaluatable_assets =
                     this.app_project.rsc_runtime_entries().await?.clone_value();
 
-                if let Some(server_action_manifest_loader) = server_action_manifest_loader {
-                    evaluatable_assets.push(server_action_manifest_loader.to_resolved().await?);
-                }
+                evaluatable_assets.push(server_action_manifest_loader);
 
                 let EntryChunkGroupResult {
                     asset: rsc_chunk,
@@ -1518,20 +1469,54 @@ impl AppEndpoint {
                 } = *(async {
                     let mut current_chunks = OutputAssets::empty();
                     let mut current_availability_info = AvailabilityInfo::Root;
-                    if let Some(client_references) = client_references {
-                        let client_references = client_references.await?;
-                        let span = tracing::trace_span!("server utils");
-                        async {
-                            let utils_module = IncludeModulesModule::new(
-                                AssetIdent::from_path(this.app_project.project().project_path())
-                                    .with_modifier(server_utils_modifier()),
-                                client_references.server_utils.iter().map(|v| **v).collect(),
-                            );
 
+                    let client_references = client_references.await?;
+                    let span = tracing::trace_span!("server utils");
+                    async {
+                        let utils_module = IncludeModulesModule::new(
+                            AssetIdent::from_path(this.app_project.project().project_path())
+                                .with_modifier(server_utils_modifier()),
+                            client_references.server_utils.iter().map(|v| **v).collect(),
+                        );
+
+                        let chunk_group = chunking_context
+                            .chunk_group(
+                                utils_module.ident(),
+                                Vc::upcast(utils_module),
+                                Value::new(current_availability_info),
+                            )
+                            .await?;
+
+                        current_chunks = current_chunks
+                            .concatenate(*chunk_group.assets)
+                            .resolve()
+                            .await?;
+                        current_availability_info = chunk_group.availability_info;
+
+                        anyhow::Ok(())
+                    }
+                    .instrument(span)
+                    .await?;
+                    for server_component in client_references
+                        .server_component_entries
+                        .iter()
+                        .copied()
+                        .take(
+                            client_references
+                                .server_component_entries
+                                .len()
+                                .saturating_sub(1),
+                        )
+                    {
+                        let span = tracing::trace_span!(
+                            "layout segment",
+                            name = server_component.ident().to_string().await?.as_str()
+                        );
+                        async {
                             let chunk_group = chunking_context
                                 .chunk_group(
-                                    utils_module.ident(),
-                                    Vc::upcast(utils_module),
+                                    server_component.ident(),
+                                    *ResolvedVc::upcast(server_component),
                                     Value::new(current_availability_info),
                                 )
                                 .await?;
@@ -1546,42 +1531,8 @@ impl AppEndpoint {
                         }
                         .instrument(span)
                         .await?;
-                        for server_component in client_references
-                            .server_component_entries
-                            .iter()
-                            .copied()
-                            .take(
-                                client_references
-                                    .server_component_entries
-                                    .len()
-                                    .saturating_sub(1),
-                            )
-                        {
-                            let span = tracing::trace_span!(
-                                "layout segment",
-                                name = server_component.ident().to_string().await?.as_str()
-                            );
-                            async {
-                                let chunk_group = chunking_context
-                                    .chunk_group(
-                                        server_component.ident(),
-                                        *ResolvedVc::upcast(server_component),
-                                        Value::new(current_availability_info),
-                                    )
-                                    .await?;
-
-                                current_chunks = current_chunks
-                                    .concatenate(*chunk_group.assets)
-                                    .resolve()
-                                    .await?;
-                                current_availability_info = chunk_group.availability_info;
-
-                                anyhow::Ok(())
-                            }
-                            .instrument(span)
-                            .await?;
-                        }
                     }
+
                     chunking_context
                         .entry_chunk_group(
                             server_path.join(
diff --git a/packages/next/src/build/webpack-config.ts b/packages/next/src/build/webpack-config.ts
index 884be1b1f6..af8bcd9dcd 100644
--- a/packages/next/src/build/webpack-config.ts
+++ b/packages/next/src/build/webpack-config.ts
@@ -1309,6 +1309,17 @@ export default async function getBaseWebpackConfig(
                     },
                   ],
                 },
+                resourceQuery: {
+                  // Do not apply next-flight-loader to imports generated by the
+                  // next-metadata-image-loader, to avoid generating unnecessary
+                  // and conflicting entries in the flight client entry plugin.
+                  // These are already covered by the next-metadata-route-loader
+                  // entries.
+                  not: [
+                    new RegExp(WEBPACK_RESOURCE_QUERIES.metadata),
+                    new RegExp(WEBPACK_RESOURCE_QUERIES.metadataImageMeta),
+                  ],
+                },
                 resolve: {
                   mainFields: getMainField(compilerType, true),
                   conditionNames: reactServerCondition,
diff --git a/packages/next/src/build/webpack/plugins/flight-client-entry-plugin.ts b/packages/next/src/build/webpack/plugins/flight-client-entry-plugin.ts
index d917c1c344..7268afdd1a 100644
--- a/packages/next/src/build/webpack/plugins/flight-client-entry-plugin.ts
+++ b/packages/next/src/build/webpack/plugins/flight-client-entry-plugin.ts
@@ -4,7 +4,7 @@ import type {
 } from '../loaders/next-flight-client-entry-loader'
 
 import { webpack } from 'next/dist/compiled/webpack/webpack'
-import { stringify } from 'querystring'
+import { parse, stringify } from 'querystring'
 import path from 'path'
 import { sources } from 'next/dist/compiled/webpack/webpack'
 import {
@@ -13,7 +13,10 @@ import {
   EntryTypes,
   getEntryKey,
 } from '../../../server/dev/on-demand-entry-handler'
-import { WEBPACK_LAYERS } from '../../../lib/constants'
+import {
+  WEBPACK_LAYERS,
+  WEBPACK_RESOURCE_QUERIES,
+} from '../../../lib/constants'
 import {
   APP_CLIENT_INTERNALS,
   BARREL_OPTIMIZATION_PREFIX,
@@ -41,6 +44,7 @@ import { PAGE_TYPES } from '../../../lib/page-types'
 import { getModuleBuildInfo } from '../loaders/get-module-build-info'
 import { getAssumedSourceType } from '../loaders/next-flight-loader'
 import { isAppRouteRoute } from '../../../lib/is-app-route-route'
+import { isMetadataRoute } from '../../../lib/metadata/is-metadata-route'
 
 interface Options {
   dev: boolean
@@ -296,10 +300,14 @@ export class FlightClientEntryPlugin {
         compilation.moduleGraph
       )) {
         // Entry can be any user defined entry files such as layout, page, error, loading, etc.
-        const entryRequest = (
+        let entryRequest = (
           connection.dependency as unknown as webpack.NormalModule
         ).request
 
+        if (entryRequest.endsWith(WEBPACK_RESOURCE_QUERIES.metadataRoute)) {
+          entryRequest = getMetadataRouteResource(entryRequest)
+        }
+
         const { clientComponentImports, actionImports, cssImports } =
           this.collectComponentInfoFromServerEntryDependency({
             entryRequest,
@@ -332,10 +340,16 @@ export class FlightClientEntryPlugin {
           : entryRequest
 
         // Replace file suffix as `.js` will be added.
-        const bundlePath = normalizePathSep(
+        let bundlePath = normalizePathSep(
           relativeRequest.replace(/\.[^.\\/]+$/, '').replace(/^src[\\/]/, '')
         )
 
+        // For metadata routes, the entry name can be used as the bundle path,
+        // as it has been normalized already.
+        if (isMetadataRoute(bundlePath)) {
+          bundlePath = name
+        }
+
         Object.assign(mergedCSSimports, cssImports)
         clientEntriesToInject.push({
           compiler,
@@ -1094,5 +1108,16 @@ function getModuleResource(mod: webpack.NormalModule): string {
   if (mod.matchResource?.startsWith(BARREL_OPTIMIZATION_PREFIX)) {
     modResource = mod.matchResource + ':' + modResource
   }
+
+  if (mod.resource === `?${WEBPACK_RESOURCE_QUERIES.metadataRoute}`) {
+    return getMetadataRouteResource(mod.rawRequest)
+  }
+
   return modResource
 }
+
+function getMetadataRouteResource(request: string): string {
+  const query = request.split('next-metadata-route-loader?')[1]
+
+  return parse(query).filePath as string
+}
diff --git a/packages/next/src/build/webpack/plugins/flight-manifest-plugin.ts b/packages/next/src/build/webpack/plugins/flight-manifest-plugin.ts
index c6e62cf27d..be012833e6 100644
--- a/packages/next/src/build/webpack/plugins/flight-manifest-plugin.ts
+++ b/packages/next/src/build/webpack/plugins/flight-manifest-plugin.ts
@@ -26,7 +26,6 @@ import {
 } from '../utils'
 import type { ChunkGroup } from 'webpack'
 import { encodeURIPath } from '../../../shared/lib/encode-uri-path'
-import { isMetadataRoute } from '../../../lib/metadata/is-metadata-route'
 import type { ModuleInfo } from './flight-client-entry-plugin'
 
 interface Options {
@@ -559,9 +558,9 @@ export class ClientReferenceManifestPlugin {
         manifestEntryFiles.push(entryName.replace(/\/page(\.[^/]+)?$/, '/page'))
       }
 
-      // We also need to create manifests for route handler entrypoints
-      // (excluding metadata route handlers) to enable `'use cache'`.
-      if (/\/route$/.test(entryName) && !isMetadataRoute(entryName)) {
+      // We also need to create manifests for route handler entrypoints to
+      // enable `'use cache'`.
+      if (/\/route$/.test(entryName)) {
         manifestEntryFiles.push(entryName)
       }
 
diff --git a/packages/next/src/build/webpack/plugins/next-trace-entrypoints-plugin.ts b/packages/next/src/build/webpack/plugins/next-trace-entrypoints-plugin.ts
index 8d2056380c..38dba137b1 100644
--- a/packages/next/src/build/webpack/plugins/next-trace-entrypoints-plugin.ts
+++ b/packages/next/src/build/webpack/plugins/next-trace-entrypoints-plugin.ts
@@ -19,7 +19,6 @@ import picomatch from 'next/dist/compiled/picomatch'
 import { getModuleBuildInfo } from '../loaders/get-module-build-info'
 import { getPageFilePath } from '../../entries'
 import { resolveExternal } from '../../handle-externals'
-import { isMetadataRoute } from '../../../lib/metadata/is-metadata-route'
 
 const PLUGIN_NAME = 'TraceEntryPointsPlugin'
 export const TRACE_IGNORES = [
@@ -243,18 +242,15 @@ export class TraceEntryPointsPlugin implements webpack.WebpackPluginInstance {
         )
 
         if (entrypoint.name.startsWith('app/')) {
-          // Include the client reference manifest for pages and route handlers,
-          // excluding metadata route handlers.
-          const clientManifestsForEntrypoint = isMetadataRoute(entrypoint.name)
-            ? null
-            : nodePath.join(
-                outputPath,
-                outputPrefix,
-                entrypoint.name.replace(/%5F/g, '_') +
-                  '_' +
-                  CLIENT_REFERENCE_MANIFEST +
-                  '.js'
-              )
+          // include the client reference manifest
+          const clientManifestsForEntrypoint = nodePath.join(
+            outputPath,
+            outputPrefix,
+            entrypoint.name.replace(/%5F/g, '_') +
+              '_' +
+              CLIENT_REFERENCE_MANIFEST +
+              '.js'
+          )
 
           if (clientManifestsForEntrypoint !== null) {
             entryFiles.add(clientManifestsForEntrypoint)
diff --git a/packages/next/src/build/webpack/utils.ts b/packages/next/src/build/webpack/utils.ts
index 9815598710..0ea11a65bb 100644
--- a/packages/next/src/build/webpack/utils.ts
+++ b/packages/next/src/build/webpack/utils.ts
@@ -7,7 +7,6 @@ import type {
   ModuleGraph,
 } from 'webpack'
 import type { ModuleGraphConnection } from 'webpack'
-import { isMetadataRoute } from '../../lib/metadata/is-metadata-route'
 
 export function traverseModules(
   compilation: Compilation,
@@ -48,11 +47,7 @@ export function forEachEntryModule(
 ) {
   for (const [name, entry] of compilation.entries.entries()) {
     // Skip for entries under pages/
-    if (
-      name.startsWith('pages/') ||
-      // Skip for metadata route handlers
-      (name.startsWith('app/') && isMetadataRoute(name))
-    ) {
+    if (name.startsWith('pages/')) {
       continue
     }
 
diff --git a/packages/next/src/server/load-components.ts b/packages/next/src/server/load-components.ts
index 499f6afcaf..40c6f6d670 100644
--- a/packages/next/src/server/load-components.ts
+++ b/packages/next/src/server/load-components.ts
@@ -32,7 +32,6 @@ import { wait } from '../lib/wait'
 import { setReferenceManifestsSingleton } from './app-render/encryption-utils'
 import { createServerModuleMap } from './app-render/action-utils'
 import type { DeepReadonly } from '../shared/lib/deep-readonly'
-import { isMetadataRoute } from '../lib/metadata/is-metadata-route'
 import { normalizePagePath } from '../shared/lib/page-path/normalize-page-path'
 
 export type ManifestItem = {
@@ -169,9 +168,6 @@ async function loadComponentsImpl<N = any>({
     ])
   }
 
-  // Make sure to avoid loading the manifest for metadata route handlers.
-  const hasClientManifest = isAppPath && !isMetadataRoute(page)
-
   // In dev mode we retry loading a manifest file to handle a race condition
   // that can occur while app and pages are compiling at the same time, and the
   // build-manifest is still being written to disk while an app path is
@@ -227,7 +223,7 @@ async function loadComponentsImpl<N = any>({
           join(distDir, `${DYNAMIC_CSS_MANIFEST}.json`),
           manifestLoadAttempts
         ).catch(() => undefined),
-    hasClientManifest
+    isAppPath
       ? tryLoadClientReferenceManifest(
           join(
             distDir,
diff --git a/test/e2e/app-dir/use-cache-metadata-route-handler/app/icon.tsx b/test/e2e/app-dir/use-cache-metadata-route-handler/app/icon.tsx
new file mode 100644
index 0000000000..7a1a1cca16
--- /dev/null
+++ b/test/e2e/app-dir/use-cache-metadata-route-handler/app/icon.tsx
@@ -0,0 +1,38 @@
+import { ImageResponse } from 'next/og'
+import { setTimeout } from 'timers/promises'
+
+export const size = { width: 32, height: 32 }
+export const contentType = 'image/png'
+
+async function fetchIconLetter() {
+  'use cache'
+
+  // Simulate I/O
+  await setTimeout(100)
+
+  return 'N'
+}
+
+export default async function Icon() {
+  const letter = await fetchIconLetter()
+
+  return new ImageResponse(
+    (
+      <div
+        style={{
+          fontSize: 24,
+          background: 'black',
+          width: '100%',
+          height: '100%',
+          display: 'flex',
+          alignItems: 'center',
+          justifyContent: 'center',
+          color: 'white',
+        }}
+      >
+        {letter}
+      </div>
+    ),
+    { ...size }
+  )
+}
diff --git a/test/e2e/app-dir/use-cache-metadata-route-handler/app/manifest.ts b/test/e2e/app-dir/use-cache-metadata-route-handler/app/manifest.ts
new file mode 100644
index 0000000000..138a6ba1b4
--- /dev/null
+++ b/test/e2e/app-dir/use-cache-metadata-route-handler/app/manifest.ts
@@ -0,0 +1,12 @@
+import type { MetadataRoute } from 'next'
+import { getSentinelValue } from './sentinel'
+import { setTimeout } from 'timers/promises'
+
+export default async function manifest(): Promise<MetadataRoute.Manifest> {
+  'use cache'
+
+  // Simulate I/O
+  await setTimeout(100)
+
+  return { name: getSentinelValue() }
+}
diff --git a/test/e2e/app-dir/use-cache-metadata-route-handler/app/opengraph-image.tsx b/test/e2e/app-dir/use-cache-metadata-route-handler/app/opengraph-image.tsx
new file mode 100644
index 0000000000..1913162fbc
--- /dev/null
+++ b/test/e2e/app-dir/use-cache-metadata-route-handler/app/opengraph-image.tsx
@@ -0,0 +1,38 @@
+import { ImageResponse } from 'next/og'
+
+export const alt = 'About Acme'
+export const size = { width: 1200, height: 630 }
+export const contentType = 'image/png'
+
+async function fetchPostData() {
+  'use cache'
+
+  return { title: 'Test', created: Date.now() }
+}
+
+export default async function Image() {
+  const post = await fetchPostData()
+
+  return new ImageResponse(
+    (
+      <div
+        style={{
+          fontSize: 48,
+          background: 'white',
+          width: '100%',
+          height: '100%',
+          display: 'flex',
+          alignItems: 'center',
+          justifyContent: 'center',
+          flexDirection: 'column',
+        }}
+      >
+        <h1>{post.title}</h1>
+        <p style={{ fontSize: 32 }}>
+          {new Date(post.created).toLocaleTimeString()}
+        </p>
+      </div>
+    ),
+    size
+  )
+}
diff --git a/test/e2e/app-dir/use-cache-metadata-route-handler/app/products/sitemap.ts b/test/e2e/app-dir/use-cache-metadata-route-handler/app/products/sitemap.ts
new file mode 100644
index 0000000000..147ed3deb9
--- /dev/null
+++ b/test/e2e/app-dir/use-cache-metadata-route-handler/app/products/sitemap.ts
@@ -0,0 +1,20 @@
+import type { MetadataRoute } from 'next'
+import { getSentinelValue } from '../sentinel'
+import { setTimeout } from 'timers/promises'
+
+export async function generateSitemaps() {
+  return [{ id: 0 }, { id: 1 }]
+}
+
+export default async function sitemap({
+  id,
+}: {
+  id: number
+}): Promise<MetadataRoute.Sitemap> {
+  'use cache'
+
+  // Simulate I/O
+  await setTimeout(100)
+
+  return [{ url: `https://acme.com/${id}?sentinel=${getSentinelValue()}` }]
+}
diff --git a/test/e2e/app-dir/use-cache-metadata-route-handler/app/robots.ts b/test/e2e/app-dir/use-cache-metadata-route-handler/app/robots.ts
new file mode 100644
index 0000000000..f48d0d95bb
--- /dev/null
+++ b/test/e2e/app-dir/use-cache-metadata-route-handler/app/robots.ts
@@ -0,0 +1,14 @@
+import type { MetadataRoute } from 'next'
+import { getSentinelValue } from './sentinel'
+import { setTimeout } from 'timers/promises'
+
+export default async function robots(): Promise<MetadataRoute.Robots> {
+  'use cache'
+
+  // Simulate I/O
+  await setTimeout(100)
+
+  return {
+    rules: { userAgent: '*', allow: `/${getSentinelValue()}` },
+  }
+}
diff --git a/test/e2e/app-dir/use-cache-metadata-route-handler/app/sentinel.ts b/test/e2e/app-dir/use-cache-metadata-route-handler/app/sentinel.ts
new file mode 100644
index 0000000000..4571ba8f47
--- /dev/null
+++ b/test/e2e/app-dir/use-cache-metadata-route-handler/app/sentinel.ts
@@ -0,0 +1,7 @@
+const { PHASE_PRODUCTION_BUILD } = require('next/constants')
+
+export function getSentinelValue() {
+  return process.env.NEXT_PHASE === PHASE_PRODUCTION_BUILD
+    ? 'buildtime'
+    : 'runtime'
+}
diff --git a/test/e2e/app-dir/use-cache-metadata-route-handler/app/sitemap.ts b/test/e2e/app-dir/use-cache-metadata-route-handler/app/sitemap.ts
new file mode 100644
index 0000000000..05ccea5bbf
--- /dev/null
+++ b/test/e2e/app-dir/use-cache-metadata-route-handler/app/sitemap.ts
@@ -0,0 +1,12 @@
+import type { MetadataRoute } from 'next'
+import { getSentinelValue } from './sentinel'
+import { setTimeout } from 'timers/promises'
+
+export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
+  'use cache'
+
+  // Simulate I/O
+  await setTimeout(100)
+
+  return [{ url: `https://acme.com?sentinel=${getSentinelValue()}` }]
+}
diff --git a/test/e2e/app-dir/use-cache-metadata-route-handler/next.config.js b/test/e2e/app-dir/use-cache-metadata-route-handler/next.config.js
new file mode 100644
index 0000000000..ac4afcf432
--- /dev/null
+++ b/test/e2e/app-dir/use-cache-metadata-route-handler/next.config.js
@@ -0,0 +1,10 @@
+/**
+ * @type {import('next').NextConfig}
+ */
+const nextConfig = {
+  experimental: {
+    dynamicIO: true,
+  },
+}
+
+module.exports = nextConfig
diff --git a/test/e2e/app-dir/use-cache-metadata-route-handler/use-cache-metadata-route-handler.test.ts b/test/e2e/app-dir/use-cache-metadata-route-handler/use-cache-metadata-route-handler.test.ts
new file mode 100644
index 0000000000..3c144e42f2
--- /dev/null
+++ b/test/e2e/app-dir/use-cache-metadata-route-handler/use-cache-metadata-route-handler.test.ts
@@ -0,0 +1,134 @@
+import { nextTestSetup } from 'e2e-utils'
+
+describe('use-cache-metadata-route-handler', () => {
+  const { next, isNextDev, isNextStart } = nextTestSetup({
+    files: __dirname,
+  })
+
+  it('should generate an opengraph image with a metadata route handler that uses "use cache"', async () => {
+    const res = await next.fetch('/opengraph-image')
+    expect(res.status).toBe(200)
+    expect(res.headers.get('content-type')).toBe('image/png')
+
+    if (isNextStart) {
+      const [buildStatus] = next.cliOutput.match(/. \/opengraph-image/)
+
+      // TODO: Should always be `○ /opengraph-image`.
+      expect(buildStatus).toBeOneOf([
+        '○ /opengraph-image',
+        'ƒ /opengraph-image',
+      ])
+    }
+  })
+
+  it('should generate an icon image with a metadata route handler that uses "use cache"', async () => {
+    const res = await next.fetch('/icon')
+    expect(res.status).toBe(200)
+    expect(res.headers.get('content-type')).toBe('image/png')
+
+    if (isNextStart) {
+      const [buildStatus] = next.cliOutput.match(/. \/icon/)
+
+      // TODO: Should always be `○ /icon`.
+      expect(buildStatus).toBeOneOf(['○ /icon', 'ƒ /icon'])
+    }
+  })
+
+  it('should generate sitemaps with a metadata route handler that uses "use cache"', async () => {
+    const res = await next.fetch('/sitemap.xml')
+    expect(res.status).toBe(200)
+    expect(res.headers.get('content-type')).toBe('application/xml')
+
+    const body = await res.text()
+
+    if (isNextDev) {
+      expect(body).toMatchInlineSnapshot(`
+       "<?xml version="1.0" encoding="UTF-8"?>
+       <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
+       <url>
+       <loc>https://acme.com?sentinel=runtime</loc>
+       </url>
+       </urlset>
+       "
+      `)
+    } else {
+      expect(body).toMatchInlineSnapshot(`
+       "<?xml version="1.0" encoding="UTF-8"?>
+       <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
+       <url>
+       <loc>https://acme.com?sentinel=buildtime</loc>
+       </url>
+       </urlset>
+       "
+      `)
+    }
+  })
+
+  it('should generate multiple sitemaps with a metadata route handler that uses "use cache"', async () => {
+    const res = await next.fetch('/products/sitemap/1.xml')
+    expect(res.status).toBe(200)
+    expect(res.headers.get('content-type')).toBe('application/xml')
+
+    const body = await res.text()
+
+    if (isNextDev) {
+      expect(body).toMatchInlineSnapshot(`
+       "<?xml version="1.0" encoding="UTF-8"?>
+       <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
+       <url>
+       <loc>https://acme.com/1?sentinel=runtime</loc>
+       </url>
+       </urlset>
+       "
+      `)
+    } else {
+      expect(body).toMatchInlineSnapshot(`
+       "<?xml version="1.0" encoding="UTF-8"?>
+       <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
+       <url>
+       <loc>https://acme.com/1?sentinel=buildtime</loc>
+       </url>
+       </urlset>
+       "
+      `)
+    }
+  })
+
+  it('should generate robots.txt with a metadata route handler that uses "use cache"', async () => {
+    const res = await next.fetch('/robots.txt')
+    expect(res.status).toBe(200)
+    expect(res.headers.get('content-type')).toBe('text/plain')
+
+    const body = await res.text()
+
+    if (isNextDev) {
+      expect(body).toMatchInlineSnapshot(`
+        "User-Agent: *
+        Allow: /runtime
+        
+        "
+        `)
+    } else {
+      expect(body).toMatchInlineSnapshot(`
+       "User-Agent: *
+       Allow: /buildtime
+
+       "
+      `)
+    }
+  })
+
+  it('should generate manifest.json with a metadata route handler that uses "use cache"', async () => {
+    const res = await next.fetch('/manifest.webmanifest')
+    expect(res.status).toBe(200)
+    expect(res.headers.get('content-type')).toBe('application/manifest+json')
+
+    const body = await res.json()
+
+    if (isNextDev) {
+      expect(body).toEqual({ name: 'runtime' })
+    } else {
+      expect(body).toEqual({ name: 'buildtime' })
+    }
+  })
+})
