diff --git a/packages/next/src/lib/generate-interception-routes-rewrites.test.ts b/packages/next/src/lib/generate-interception-routes-rewrites.test.ts
index b20854e78f..cdb3377dc5 100644
--- a/packages/next/src/lib/generate-interception-routes-rewrites.test.ts
+++ b/packages/next/src/lib/generate-interception-routes-rewrites.test.ts
@@ -36,16 +36,48 @@ describe('generateInterceptionRoutesRewrites', () => {
       // - / (root)
       // - /nested-link (any root-level route)
       // - /foo (any other root-level route)
-      // But NOT:
-      // - /foo/bar (nested routes)
+      // - /foo/bar (nested routes - any descendant of root)
+      // Since the intercepting route is at root, it should match when navigating
+      // FROM root or any of its descendants
       const { headerRegex } = getRewriteMatchers(rewrite)
-      expect(headerRegex.source).toMatchInlineSnapshot(`"^(\\/[^/]+)?\\/?$"`)
+      expect(headerRegex.source).toMatchInlineSnapshot(`"^\\/.*$"`)
 
       expect(headerRegex.test('/')).toBe(true)
       expect(headerRegex.test('/nested-link')).toBe(true)
       expect(headerRegex.test('/foo')).toBe(true)
-      expect(headerRegex.test('/foo/bar')).toBe(false)
-      expect(headerRegex.test('/a/b/c')).toBe(false)
+      expect(headerRegex.test('/foo/bar')).toBe(true)
+      expect(headerRegex.test('/a/b/c')).toBe(true)
+    })
+
+    it('should generate rewrite for root-level slot intercepting nested route with dynamic segments', () => {
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/@modal/(.)groups/[id]/new',
+      ])
+
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      // Source should be the intercepted route
+      expect(rewrite.source).toBe('/groups/:nxtPid/new')
+
+      // Destination should be the intercepting route path
+      expect(rewrite.destination).toBe('/@modal/(.)groups/:nxtPid/new')
+
+      // The Next-Url header should match routes at root level and all descendants
+      // This is the bug fix: should match /groups/123 (nested route) in addition to / and /groups
+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+      expect(headerRegex.source).toMatchInlineSnapshot(`"^\\/.*$"`)
+
+      // Source should match the target URL with dynamic parameter
+      expect(sourceRegex.test('/groups/123/new')).toBe(true)
+      expect(sourceRegex.test('/groups/abc/new')).toBe(true)
+
+      // Header should match when navigating FROM root or any descendant
+      expect(headerRegex.test('/')).toBe(true) // From root
+      expect(headerRegex.test('/groups')).toBe(true) // From /groups
+      expect(headerRegex.test('/groups/123')).toBe(true) // From /groups/123 (THE BUG FIX!)
+      expect(headerRegex.test('/groups/123/settings')).toBe(true) // From any nested route
+      expect(headerRegex.test('/other/route/deep')).toBe(true) // From any other route
     })
 
     it('should generate rewrite for nested route intercepting sibling', () => {
@@ -67,7 +99,7 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify the regex in the rewrite can match actual URLs
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/intercepting\\-routes\\/feed(\\/[^/]+)?\\/?$"`
+        `"^\\/intercepting\\-routes\\/feed(?:\\/.*)?$"`
       )
 
       expect(sourceRegex.test('/intercepting-routes/feed/photos/123')).toBe(
@@ -78,15 +110,15 @@ describe('generateInterceptionRoutesRewrites', () => {
       )
 
       // The Next-Url header should match routes at /intercepting-routes/feed level
-      // Should match routes at the same level
+      // Should match routes at the same level and ALL descendants
       expect(headerRegex.test('/intercepting-routes/feed')).toBe(true)
       expect(headerRegex.test('/intercepting-routes/feed/nested')).toBe(true)
-
-      // Should NOT match parent or deeper nested routes
-      expect(headerRegex.test('/intercepting-routes')).toBe(false)
       expect(headerRegex.test('/intercepting-routes/feed/nested/deep')).toBe(
-        false
+        true
       )
+
+      // Should NOT match parent routes
+      expect(headerRegex.test('/intercepting-routes')).toBe(false)
     })
 
     it('should handle (.) with dynamic parameters in intercepting route', () => {
@@ -97,24 +129,26 @@ describe('generateInterceptionRoutesRewrites', () => {
       expect(rewrites).toHaveLength(1)
       const rewrite = rewrites[0]
 
-      // Source should have the [id] parameter with nxtP prefix (from intercepted route)
+      // Source should have the [id] parameter with nxtI prefix (adjacent to interception marker)
       // Destination uses the same prefix for parameter substitution
-      expect(rewrite.source).toBe('/intercepting-siblings/:nxtPid')
+      expect(rewrite.source).toBe('/intercepting-siblings/:nxtIid')
       expect(rewrite.destination).toBe(
-        '/intercepting-siblings/@modal/(.):nxtPid'
+        '/intercepting-siblings/@modal/(.):nxtIid'
       )
 
       // Verify the source regex matches actual URLs
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/intercepting\\-siblings(\\/[^/]+)?\\/?$"`
+        `"^\\/intercepting\\-siblings(?:\\/.*)?$"`
       )
 
       expect(sourceRegex.test('/intercepting-siblings/123')).toBe(true)
       expect(sourceRegex.test('/intercepting-siblings/user-abc')).toBe(true)
 
-      // Should match routes at /intercepting-siblings level
+      // Should match routes at /intercepting-siblings level and all descendants
       expect(headerRegex.test('/intercepting-siblings')).toBe(true)
+      expect(headerRegex.test('/intercepting-siblings/123')).toBe(true)
+      expect(headerRegex.test('/intercepting-siblings/123/nested')).toBe(true)
     })
 
     it('should handle (.) with multiple dynamic parameters', () => {
@@ -125,19 +159,19 @@ describe('generateInterceptionRoutesRewrites', () => {
       expect(rewrites).toHaveLength(1)
       const rewrite = rewrites[0]
 
-      // Source should have both parameters with nxtP prefix (from intercepted route)
+      // Source should have nxtI prefix for author (adjacent to marker), nxtP for id
       // Both source and destination use the same prefixes for proper substitution
       expect(rewrite.source).toBe(
-        '/intercepting-routes-dynamic/photos/:nxtPauthor/:nxtPid'
+        '/intercepting-routes-dynamic/photos/:nxtIauthor/:nxtPid'
       )
       expect(rewrite.destination).toBe(
-        '/intercepting-routes-dynamic/photos/(.):nxtPauthor/:nxtPid'
+        '/intercepting-routes-dynamic/photos/(.):nxtIauthor/:nxtPid'
       )
 
       // Verify the source regex matches actual URLs with both parameters
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/intercepting\\-routes\\-dynamic\\/photos(\\/[^/]+)?\\/?$"`
+        `"^\\/intercepting\\-routes\\-dynamic\\/photos(?:\\/.*)?$"`
       )
 
       expect(
@@ -147,8 +181,14 @@ describe('generateInterceptionRoutesRewrites', () => {
         sourceRegex.test('/intercepting-routes-dynamic/photos/jane/post-456')
       ).toBe(true)
 
-      // Should match the parent directory
+      // Should match the parent directory and all descendants
       expect(headerRegex.test('/intercepting-routes-dynamic/photos')).toBe(true)
+      expect(headerRegex.test('/intercepting-routes-dynamic/photos/john')).toBe(
+        true
+      )
+      expect(
+        headerRegex.test('/intercepting-routes-dynamic/photos/john/123')
+      ).toBe(true)
     })
 
     it('should handle (.) with optional catchall in intercepting route', () => {
@@ -169,7 +209,7 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify source regex matches actual URLs with 0 or more catchall segments
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^(?:\\/(?<nxtPlocale>.+?))?(\\/[^/]+)?\\/?$"`
+        `"^(?:\\/(?<nxtPlocale>.+?))?(?:\\/.*)?$"`
       )
 
       expect(sourceRegex.test('/settings')).toBe(true)
@@ -197,6 +237,74 @@ describe('generateInterceptionRoutesRewrites', () => {
   })
 
   describe('(..) one-level-up interception', () => {
+    it('should handle (..) from exactly 2 levels deep', () => {
+      // Boundary: /foo/bar with (..) goes to /foo (not root)
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/foo/bar/(..)target',
+      ])
+
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      expect(rewrite.source).toBe('/foo/target')
+      expect(rewrite.destination).toBe('/foo/bar/(..)target')
+
+      const { headerRegex } = getRewriteMatchers(rewrite)
+
+      // Should match at /foo/bar level
+      expect(headerRegex.test('/foo/bar')).toBe(true)
+      expect(headerRegex.test('/foo/bar/nested')).toBe(true)
+
+      // Should NOT match at /foo level (that's the parent)
+      expect(headerRegex.test('/foo')).toBe(false)
+    })
+
+    it('should handle (..) with dynamic segment at boundary (2 levels to 1)', () => {
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/[locale]/dashboard/(..)settings',
+      ])
+
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      // (..) from /[locale]/dashboard goes to /[locale]
+      expect(rewrite.source).toBe('/:nxtPlocale/settings')
+      expect(rewrite.destination).toBe('/:nxtPlocale/dashboard/(..)settings')
+
+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+      expect(sourceRegex.test('/en/settings')).toBe(true)
+      expect(sourceRegex.test('/fr/settings')).toBe(true)
+
+      // Header should match at /[locale]/dashboard level
+      expect(headerRegex.test('/en/dashboard')).toBe(true)
+      expect(headerRegex.test('/fr/dashboard')).toBe(true)
+    })
+
+    it('should handle (..) with catchall at boundary', () => {
+      // /[...all]/item with (..) removes one segment, leaving /[...all]
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/[...all]/item/(..)target',
+      ])
+
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      // (..) from /[...all]/item removes one segment, leaving /[...all]
+      expect(rewrite.source).toBe('/:nxtPall+/target')
+      expect(rewrite.destination).toBe('/:nxtPall+/item/(..)target')
+
+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+      expect(sourceRegex.test('/a/target')).toBe(true)
+      expect(sourceRegex.test('/a/b/target')).toBe(true)
+
+      // Header should match from /[...all]/item at any depth
+      expect(headerRegex.test('/a/item')).toBe(true)
+      expect(headerRegex.test('/a/b/item')).toBe(true)
+      expect(headerRegex.test('/a/b/c/item')).toBe(true)
+    })
+
     it('should generate header regex that matches child routes for (..) marker', () => {
       // Test WITHOUT catchall sibling - should only match exact level
       const rewritesWithoutCatchall = generateInterceptionRoutesRewrites([
@@ -215,13 +323,13 @@ describe('generateInterceptionRoutesRewrites', () => {
         rewriteWithoutCatchall
       )
       expect(headerWithoutCatchall.source).toMatchInlineSnapshot(
-        `"^\\/templates$"`
+        `"^\\/templates(?:\\/.*)?$"`
       )
 
-      // Without catchall sibling: should match exact level only
+      // Now matches all descendants (consistent with other markers)
       expect(headerWithoutCatchall.test('/templates')).toBe(true)
-      expect(headerWithoutCatchall.test('/templates/multi')).toBe(false)
-      expect(headerWithoutCatchall.test('/templates/multi/slug')).toBe(false)
+      expect(headerWithoutCatchall.test('/templates/multi')).toBe(true)
+      expect(headerWithoutCatchall.test('/templates/multi/slug')).toBe(true)
 
       // Test WITH catchall sibling - should match exact level AND catchall paths
       const rewritesWithCatchall = generateInterceptionRoutesRewrites([
@@ -235,7 +343,7 @@ describe('generateInterceptionRoutesRewrites', () => {
       const { headerRegex: headerWithCatchall } =
         getRewriteMatchers(rewriteWithCatchall)
       expect(headerWithCatchall.source).toMatchInlineSnapshot(
-        `"^\\/templates(\\/.+)?$"`
+        `"^\\/templates(?:\\/.*)?$"`
       )
 
       // With catchall sibling: should match exact level AND catchall paths
@@ -273,7 +381,7 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify source regex matches actual photo URLs
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/intercepting\\-parallel\\-modal\\/(?<nxtPusername>[^/]+?)$"`
+        `"^\\/intercepting\\-parallel\\-modal\\/(?<nxtPusername>[^/]+?)(?:\\/.*)?$"`
       )
 
       expect(sourceRegex.test('/intercepting-parallel-modal/photo/123')).toBe(
@@ -283,18 +391,18 @@ describe('generateInterceptionRoutesRewrites', () => {
         true
       )
 
-      // The (..) marker generates a pattern that matches the intercepting route level and its children
+      // The (..) marker matches the intercepting route level and all descendants
       // Should match the intercepting route itself with actual dynamic segment values
       expect(headerRegex.test('/intercepting-parallel-modal/john')).toBe(true)
       expect(headerRegex.test('/intercepting-parallel-modal/jane')).toBe(true)
 
-      // Should not match child routes
+      // Should also match all descendants
       expect(headerRegex.test('/intercepting-parallel-modal/john/child')).toBe(
-        false
+        true
       )
       expect(
         headerRegex.test('/intercepting-parallel-modal/jane/deep/nested')
-      ).toBe(false)
+      ).toBe(true)
 
       // Should NOT match parent routes without the required parameter
       expect(headerRegex.test('/intercepting-parallel-modal')).toBe(false)
@@ -317,19 +425,18 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify source regex matches actual URLs
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/(?<nxtPlang>[^/]+?)\\/foo$"`
+        `"^\\/(?<nxtPlang>[^/]+?)\\/foo(?:\\/.*)?$"`
       )
 
       expect(sourceRegex.test('/en/photos')).toBe(true)
       expect(sourceRegex.test('/es/photos')).toBe(true)
       expect(sourceRegex.test('/fr/photos')).toBe(true)
 
-      // Should match child routes of /[lang]/foo with actual parameter values
-      // Since the route ends with a static segment (foo), children are required
+      // Should match routes at /[lang]/foo level and all descendants
       expect(headerRegex.test('/en/foo')).toBe(true)
       expect(headerRegex.test('/es/foo')).toBe(true)
-
-      expect(headerRegex.test('/en/foo/bar')).toBe(false)
+      expect(headerRegex.test('/en/foo/bar')).toBe(true)
+      expect(headerRegex.test('/es/foo/nested/deep')).toBe(true)
     })
 
     it('should handle (..) with optional catchall in intercepting route', () => {
@@ -349,7 +456,7 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify source regex matches actual URLs with 0 or more catchall segments
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^(?:\\/(?<nxtPlocale>.+?))?\\/dashboard$"`
+        `"^(?:\\/(?<nxtPlocale>.+?))?\\/dashboard(?:\\/.*)?$"`
       )
 
       expect(sourceRegex.test('/settings')).toBe(true)
@@ -378,7 +485,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       const { headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^(?:\\/(?<nxtPlocale>.+?))?\\/dashboard(\\/.+)?$"`
+        `"^(?:\\/(?<nxtPlocale>.+?))?\\/dashboard(?:\\/.*)?$"`
       )
 
       // With catchall sibling: should match exact level AND catchall paths
@@ -409,7 +516,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^(?:\\/(?<nxtPlocale>.+?))?\\/(?<nxtPuserId>[^/]+?)$"`
+        `"^(?:\\/(?<nxtPlocale>.+?))?\\/(?<nxtPuserId>[^/]+?)(?:\\/.*)?$"`
       )
 
       // Source should match with 0 or more locale segments
@@ -445,19 +552,18 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify source regex matches actual URLs
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/(?<nxtPlocale>[^/]+?)\\/example(?:\\/)?$"`
+        `"^\\/(?<nxtIlocale>[^/]+?)\\/example(?:\\/.*)?$"`
       )
 
       expect(sourceRegex.test('/en/intercepted')).toBe(true)
       expect(sourceRegex.test('/es/intercepted')).toBe(true)
 
-      // Should match routes at the intercepting route level
+      // Should match routes at the intercepting route level and all descendants
       // The intercepting route is /[locale]/example
       expect(headerRegex.test('/en/example')).toBe(true)
       expect(headerRegex.test('/es/example')).toBe(true)
-
-      // Should NOT match deeper routes
-      expect(headerRegex.test('/en/example/nested')).toBe(false)
+      expect(headerRegex.test('/en/example/nested')).toBe(true)
+      expect(headerRegex.test('/es/example/nested/deep')).toBe(true)
     })
 
     it('should generate rewrite for (...) in basepath context', () => {
@@ -479,14 +585,15 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify source regex matches actual URLs
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/(?<nxtPfoo_id>[^/]+?)\\/(?<nxtPbar_id>[^/]+?)(?:\\/)?$"`
+        `"^\\/(?<nxtPfoo_id>[^/]+?)\\/(?<nxtPbar_id>[^/]+?)(?:\\/.*)?$"`
       )
 
       expect(sourceRegex.test('/baz_id/123')).toBe(true)
       expect(sourceRegex.test('/baz_id/abc')).toBe(true)
 
-      // Should match the intercepting route level
+      // Should match the intercepting route level and all descendants
       expect(headerRegex.test('/foo/bar')).toBe(true)
+      expect(headerRegex.test('/foo/bar/nested')).toBe(true)
     })
 
     it('should handle (...) with optional catchall in intercepted route', () => {
@@ -506,8 +613,11 @@ describe('generateInterceptionRoutesRewrites', () => {
       )
 
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+      expect(sourceRegex.source).toMatchInlineSnapshot(
+        `"^(?:\\/(?<nxtIlocale>.+?))?\\/intercepted(?:\\/)?$"`
+      )
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^(?:\\/(?<nxtPlocale>.+?))?\\/dashboard(?:\\/)?$"`
+        `"^(?:\\/(?<nxtIlocale>.+?))?\\/dashboard(?:\\/.*)?$"`
       )
 
       // Source should match with 0 or more locale segments
@@ -541,17 +651,18 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify source regex matches actual URLs
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/foo\\/bar(?:\\/)?$"`
+        `"^\\/foo\\/bar(?:\\/.*)?$"`
       )
 
       expect(sourceRegex.test('/hoge')).toBe(true)
 
-      // Should match routes at /foo/bar level (two levels below root)
+      // Should match routes at /foo/bar level and all descendants
       expect(headerRegex.test('/foo/bar')).toBe(true)
+      expect(headerRegex.test('/foo/bar/baz')).toBe(true)
+      expect(headerRegex.test('/foo/bar/baz/deep')).toBe(true)
 
-      // Should NOT match parent or deeper routes
+      // Should NOT match parent routes
       expect(headerRegex.test('/foo')).toBe(false)
-      expect(headerRegex.test('/foo/bar/baz')).toBe(false)
     })
 
     it('should handle (..)(..) with optional catchall in intercepting route', () => {
@@ -570,7 +681,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^(?:\\/(?<nxtPlocale>.+?))?\\/foo\\/bar(?:\\/)?$"`
+        `"^(?:\\/(?<nxtPlocale>.+?))?\\/foo\\/bar(?:\\/.*)?$"`
       )
 
       // Source should match with 0 or more locale segments
@@ -578,19 +689,107 @@ describe('generateInterceptionRoutesRewrites', () => {
       expect(sourceRegex.test('/en/hoge')).toBe(true)
       expect(sourceRegex.test('/en/us/hoge')).toBe(true)
 
-      // Header should match routes at /[[...locale]]/foo/bar level
+      // Header should match routes at /[[...locale]]/foo/bar level and all descendants
       expect(headerRegex.test('/foo/bar')).toBe(true)
       expect(headerRegex.test('/en/foo/bar')).toBe(true)
       expect(headerRegex.test('/en/us/foo/bar')).toBe(true)
+      expect(headerRegex.test('/foo/bar/baz')).toBe(true)
+      expect(headerRegex.test('/en/foo/bar/baz')).toBe(true)
+      expect(headerRegex.test('/en/us/foo/bar/nested/deep')).toBe(true)
 
-      // Should NOT match parent or deeper routes
+      // Should NOT match parent routes
       expect(headerRegex.test('/foo')).toBe(false)
       expect(headerRegex.test('/en/foo')).toBe(false)
-      expect(headerRegex.test('/foo/bar/baz')).toBe(false)
     })
   })
 
   describe('catchall and optional catchall segments', () => {
+    it('should handle interception from within a required catchall route', () => {
+      // Blog pattern: /blog/[...category] can have many levels
+      // User at /blog/tech/nextjs/latest intercepts /blog/post/123
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/blog/[...category]/@modal/(.)post/[id]',
+      ])
+
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      // Source is the intercepted route
+      expect(rewrite.source).toBe('/blog/:nxtPcategory+/post/:nxtPid')
+
+      // Destination includes the catchall from intercepting route
+      expect(rewrite.destination).toBe(
+        '/blog/:nxtPcategory+/@modal/(.)post/:nxtPid'
+      )
+
+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+      // Source should match the target URL
+      expect(sourceRegex.test('/blog/tech/post/123')).toBe(true)
+      expect(sourceRegex.test('/blog/tech/nextjs/post/123')).toBe(true)
+      expect(sourceRegex.test('/blog/tech/nextjs/latest/post/123')).toBe(true)
+
+      // Header should match from the catchall route at any depth
+      expect(headerRegex.test('/blog/tech')).toBe(true)
+      expect(headerRegex.test('/blog/tech/nextjs')).toBe(true)
+      expect(headerRegex.test('/blog/tech/nextjs/latest')).toBe(true)
+      expect(headerRegex.test('/blog/tech/nextjs/latest/nested')).toBe(true)
+    })
+
+    it('should handle interception from optional catchall at deep nesting', () => {
+      // i18n pattern: user at /en/US/dashboard intercepts /en/US/dashboard/settings
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/[[...locale]]/dashboard/@modal/(.)settings',
+      ])
+
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      expect(rewrite.source).toBe('/:nxtPlocale*/dashboard/settings')
+      expect(rewrite.destination).toBe(
+        '/:nxtPlocale*/dashboard/@modal/(.)settings'
+      )
+
+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+      // Source should match with various locale depths
+      expect(sourceRegex.test('/dashboard/settings')).toBe(true)
+      expect(sourceRegex.test('/en/dashboard/settings')).toBe(true)
+      expect(sourceRegex.test('/en/US/dashboard/settings')).toBe(true)
+      expect(sourceRegex.test('/en/US/CA/dashboard/settings')).toBe(true)
+
+      // Header should match from dashboard at any locale depth
+      expect(headerRegex.test('/dashboard')).toBe(true)
+      expect(headerRegex.test('/en/dashboard')).toBe(true)
+      expect(headerRegex.test('/en/US/dashboard')).toBe(true)
+      expect(headerRegex.test('/en/US/CA/dashboard')).toBe(true)
+      expect(headerRegex.test('/en/US/dashboard/nested')).toBe(true)
+    })
+
+    it('should handle (..) interception from within catchall with deep navigation', () => {
+      // Docs site: user at /docs/api/reference/components navigates one level up
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/docs/[...slug]/@modal/(..)related',
+      ])
+
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      // (..) goes one level up from /docs/[...slug], which is /docs
+      expect(rewrite.source).toBe('/docs/related')
+      expect(rewrite.destination).toBe('/docs/:nxtPslug+/@modal/(..)related')
+
+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+      expect(sourceRegex.test('/docs/related')).toBe(true)
+
+      // Header should match from any depth within the docs catchall
+      expect(headerRegex.test('/docs/api')).toBe(true)
+      expect(headerRegex.test('/docs/api/reference')).toBe(true)
+      expect(headerRegex.test('/docs/api/reference/components')).toBe(true)
+      expect(headerRegex.test('/docs/guide/getting-started/intro')).toBe(true)
+    })
+
     it('should generate path-to-regexp format with + suffix for catchall parameters', () => {
       const rewrites = generateInterceptionRoutesRewrites([
         '/templates/(..)showcase/[...catchAll]',
@@ -656,7 +855,7 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify source regex matches catchall URLs
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/intercepting\\-routes\\-dynamic\\-catchall\\/photos(\\/[^/]+)?\\/?$"`
+        `"^\\/intercepting\\-routes\\-dynamic\\-catchall\\/photos(?:\\/.*)?$"`
       )
 
       expect(
@@ -675,10 +874,16 @@ describe('generateInterceptionRoutesRewrites', () => {
         )
       ).toBe(true)
 
-      // Should match the parent level
+      // Should match the parent level and all descendants
       expect(
         headerRegex.test('/intercepting-routes-dynamic-catchall/photos')
       ).toBe(true)
+      expect(
+        headerRegex.test('/intercepting-routes-dynamic-catchall/photos/foo')
+      ).toBe(true)
+      expect(
+        headerRegex.test('/intercepting-routes-dynamic-catchall/photos/foo/bar')
+      ).toBe(true)
     })
 
     it('should handle (.) with optional catchall segments', () => {
@@ -702,7 +907,7 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Verify source regex matches both with and without segments
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/intercepting\\-routes\\-dynamic\\-catchall\\/photos(\\/[^/]+)?\\/?$"`
+        `"^\\/intercepting\\-routes\\-dynamic\\-catchall\\/photos(?:\\/.*)?$"`
       )
 
       expect(
@@ -721,10 +926,16 @@ describe('generateInterceptionRoutesRewrites', () => {
         )
       ).toBe(true)
 
-      // Should match the parent level
+      // Should match the parent level and all descendants
       expect(
         headerRegex.test('/intercepting-routes-dynamic-catchall/photos')
       ).toBe(true)
+      expect(
+        headerRegex.test('/intercepting-routes-dynamic-catchall/photos/foo')
+      ).toBe(true)
+      expect(
+        headerRegex.test('/intercepting-routes-dynamic-catchall/photos/foo/bar')
+      ).toBe(true)
     })
   })
 
@@ -741,7 +952,7 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Note: Router adds ^ and $ anchors automatically via matchHas()
       const { headerRegex } = getRewriteMatchers(rewrites[0])
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/intercepting\\-parallel\\-modal\\/(?<nxtPusername>[^/]+?)$"`
+        `"^\\/intercepting\\-parallel\\-modal\\/(?<nxtPusername>[^/]+?)(?:\\/.*)?$"`
       )
 
       // With (..) marker, should match child routes.
@@ -758,11 +969,12 @@ describe('generateInterceptionRoutesRewrites', () => {
       // So interceptingRoute should be / (root)
       // Note: Router adds ^ and $ anchors automatically via matchHas()
       const { headerRegex } = getRewriteMatchers(rewrites[0])
-      expect(headerRegex.source).toMatchInlineSnapshot(`"^(\\/[^/]+)?\\/?$"`)
+      expect(headerRegex.source).toMatchInlineSnapshot(`"^\\/.*$"`)
 
-      // Should match root-level routes
+      // Should match root-level routes and all descendants
       expect(headerRegex.test('/')).toBe(true)
       expect(headerRegex.test('/nested-link')).toBe(true)
+      expect(headerRegex.test('/nested-link/deep')).toBe(true)
     })
 
     it('should handle parallel routes at nested levels', () => {
@@ -775,11 +987,13 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Note: Router adds ^ and $ anchors automatically via matchHas()
       const { headerRegex } = getRewriteMatchers(rewrites[0])
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/parallel\\-layout(\\/[^/]+)?\\/?$"`
+        `"^\\/parallel\\-layout(?:\\/.*)?$"`
       )
 
-      // Should match routes at /parallel-layout level
+      // Should match routes at /parallel-layout level and all descendants
       expect(headerRegex.test('/parallel-layout')).toBe(true)
+      expect(headerRegex.test('/parallel-layout/nested')).toBe(true)
+      expect(headerRegex.test('/parallel-layout/nested/deep')).toBe(true)
     })
 
     it('should handle optional catchall in route groups with (..) interception', () => {
@@ -798,7 +1012,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       const { headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^(?:\\/(?<nxtPlocale>.+?))?\\/dashboard$"`
+        `"^(?:\\/(?<nxtPlocale>.+?))?\\/dashboard(?:\\/.*)?$"`
       )
 
       // Route group should be normalized, so header should match without it
@@ -821,26 +1035,104 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       const { headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^(?:\\/(?<nxtPlocale>.+?))?(\\/[^/]+)?\\/?$"`
+        `"^(?:\\/(?<nxtPlocale>.+?))?(?:\\/.*)?$"`
       )
 
       // @slot should be normalized away, so interceptingRoute is root
-      // With optional catchall at root level
+      // With optional catchall at root level, should match all descendants
       expect(headerRegex.test('/')).toBe(true) // Zero locale segments (root level)
       expect(headerRegex.test('/en')).toBe(true) // One locale segment
       expect(headerRegex.test('/en/us')).toBe(true) // Multiple locale segments
 
-      // Should match direct children at each level (same-level interception allows one child)
-      expect(headerRegex.test('/other-page')).toBe(true) // Direct child at root
-      expect(headerRegex.test('/en/settings')).toBe(true) // Direct child at /en level
-      expect(headerRegex.test('/en/us/nested')).toBe(true) // Direct child at /en/us level
+      // Should match all descendants at any depth
+      expect(headerRegex.test('/other-page')).toBe(true)
+      expect(headerRegex.test('/en/settings')).toBe(true)
+      expect(headerRegex.test('/en/us/nested')).toBe(true)
+      expect(headerRegex.test('/en/settings/deep')).toBe(true)
+      expect(headerRegex.test('/en/us/nested/deeper')).toBe(true)
+      expect(headerRegex.test('/a/b/c/d/e')).toBe(true)
+    })
 
-      // With optional catchall, any depth of catchall + one child is valid
-      expect(headerRegex.test('/en/settings/deep')).toBe(true) // /en/settings level + child
-      expect(headerRegex.test('/en/us/nested/deeper')).toBe(true) // /en/us/nested level + child
+    it('should handle parallel route with its own dynamic segment', () => {
+      // Pattern: /@modal/[modalId] for different modal types
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/@modal/[modalId]/(.)photos/[id]',
+      ])
 
-      // Should NOT match when there's no valid "catchall + child" or "just catchall" interpretation
-      expect(headerRegex.test('/a/b/c/d/e')).toBe(true) // Actually matches: /a/b/c/d as catchall + /e as child
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      // @modal is normalized away, but [modalId] remains
+      expect(rewrite.source).toBe('/:nxtPmodalId/photos/:nxtPid')
+      expect(rewrite.destination).toBe('/@modal/:nxtPmodalId/(.)photos/:nxtPid')
+
+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+      // Source should match with both parameters
+      expect(sourceRegex.test('/gallery/photos/123')).toBe(true)
+      expect(sourceRegex.test('/lightbox/photos/456')).toBe(true)
+
+      // Header should match the modal type level
+      expect(headerRegex.test('/gallery')).toBe(true)
+      expect(headerRegex.test('/lightbox')).toBe(true)
+      expect(headerRegex.test('/gallery/nested')).toBe(true)
+    })
+
+    it('should handle nested parallel route with dynamic segments in parent', () => {
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/[org]/@sidebar/[section]/(..)profile',
+      ])
+
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      // (..) goes one level up from /[org]/@sidebar/[section], which is /[org]
+      expect(rewrite.source).toBe('/:nxtPorg/profile')
+      expect(rewrite.destination).toBe(
+        '/:nxtPorg/@sidebar/:nxtPsection/(..)profile'
+      )
+
+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+      expect(sourceRegex.test('/vercel/profile')).toBe(true)
+      expect(sourceRegex.test('/acme/profile')).toBe(true)
+
+      // Header should match the sidebar section level
+      expect(headerRegex.test('/vercel/settings')).toBe(true)
+      expect(headerRegex.test('/acme/dashboard')).toBe(true)
+      expect(headerRegex.test('/vercel/settings/nested')).toBe(true)
+    })
+
+    it('should handle multiple parallel routes with their own dynamic segments', () => {
+      const rewrites = generateInterceptionRoutesRewrites([
+        '/[workspace]/@sidebar/[section]/@modal/[modalType]/(.)content/[id]',
+      ])
+
+      expect(rewrites).toHaveLength(1)
+      const rewrite = rewrites[0]
+
+      // Both parallel routes are normalized but their dynamic segments remain
+      expect(rewrite.source).toBe(
+        '/:nxtPworkspace/:nxtPsection/:nxtPmodalType/content/:nxtPid'
+      )
+      expect(rewrite.destination).toBe(
+        '/:nxtPworkspace/@sidebar/:nxtPsection/@modal/:nxtPmodalType/(.)content/:nxtPid'
+      )
+
+      const { sourceRegex } = getRewriteMatchers(rewrite)
+
+      // Should match with all dynamic parameters
+      expect(sourceRegex.test('/acme/settings/gallery/content/photo123')).toBe(
+        true
+      )
+
+      const match = sourceRegex.exec('/acme/settings/gallery/content/photo123')
+      expect(match?.groups).toEqual({
+        nxtPworkspace: 'acme',
+        nxtPsection: 'settings',
+        nxtPmodalType: 'gallery',
+        nxtPid: 'photo123',
+      })
     })
   })
 
@@ -860,7 +1152,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       // Verify source regex includes basePath and matches actual URLs
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
-      expect(headerRegex.source).toMatchInlineSnapshot(`"^(\\/[^/]+)?\\/?$"`)
+      expect(headerRegex.source).toMatchInlineSnapshot(`"^\\/.*$"`)
 
       expect(sourceRegex.test('/base/nested')).toBe(true)
       expect(sourceRegex.test('/nested')).toBe(false) // Should NOT match without basePath
@@ -868,13 +1160,11 @@ describe('generateInterceptionRoutesRewrites', () => {
       // But Next-Url header check should NOT include basePath
       // (comment in code says "The Next-Url header does not contain the base path")
 
-      // Should match root-level routes (without basePath in the check)
+      // Should match root-level routes and all descendants (without basePath in the check)
       expect(headerRegex.test('/')).toBe(true)
       expect(headerRegex.test('/nested-link')).toBe(true)
-      expect(headerRegex.test('/base')).toBe(true) // Matches because it's a root-level route
-
-      // Should NOT match deeply nested routes
-      expect(headerRegex.test('/nested-link/deep')).toBe(false)
+      expect(headerRegex.test('/base')).toBe(true)
+      expect(headerRegex.test('/nested-link/deep')).toBe(true)
     })
 
     it('should handle optional catchall with basePath', () => {
@@ -892,7 +1182,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^(?:\\/(?<nxtPlocale>.+?))?(\\/[^/]+)?\\/?$"`
+        `"^(?:\\/(?<nxtPlocale>.+?))?(?:\\/.*)?$"`
       )
 
       // Source regex should include basePath
@@ -902,10 +1192,11 @@ describe('generateInterceptionRoutesRewrites', () => {
       expect(sourceRegex.test('/settings')).toBe(false) // Without basePath
 
       // Header check should NOT include basePath
-      // The optional catchall allows zero or more segments at root level
+      // The optional catchall allows zero or more segments at root level, matching all descendants
       expect(headerRegex.test('/')).toBe(true) // Zero locale segments
       expect(headerRegex.test('/en')).toBe(true) // One locale segment
       expect(headerRegex.test('/en/us')).toBe(true) // Multiple locale segments
+      expect(headerRegex.test('/en/us/deep')).toBe(true) // Deep nesting
     })
   })
 
@@ -925,11 +1216,13 @@ describe('generateInterceptionRoutesRewrites', () => {
       // Note: Router adds ^ and $ anchors automatically via matchHas()
       const { headerRegex } = getRewriteMatchers(rewrites[0])
       expect(headerRegex.source).toMatchInlineSnapshot(
-        `"^\\/(?<nxtPthisismyroute>[^/]+?)(\\/[^/]+)?\\/?$"`
+        `"^\\/(?<nxtPthisismyroute>[^/]+?)(?:\\/.*)?$"`
       )
 
-      // Should match routes at the parent level
+      // Should match routes at the parent level and all descendants
       expect(headerRegex.test('/foo')).toBe(true)
+      expect(headerRegex.test('/foo/bar')).toBe(true)
+      expect(headerRegex.test('/foo/bar/baz')).toBe(true)
     })
   })
 
@@ -946,19 +1239,19 @@ describe('generateInterceptionRoutesRewrites', () => {
       const sourceParams = rewrite.source
         .match(/:(\w+)/g)
         ?.map((p) => p.slice(1))
-      expect(sourceParams).toEqual(['nxtPauthor', 'nxtPid'])
+      expect(sourceParams).toEqual(['nxtIauthor', 'nxtPid'])
 
       // Extract parameter names from destination
       const destParams = rewrite.destination
         .match(/:(\w+)/g)
         ?.map((p) => p.slice(1))
-      expect(destParams).toEqual(['nxtPauthor', 'nxtPid'])
+      expect(destParams).toEqual(['nxtIauthor', 'nxtPid'])
 
       // Extract capture group names from regex
       const regexParams = Array.from(
         rewrite.regex!.matchAll(/\(\?<(\w+)>/g)
       ).map((m) => m[1])
-      expect(regexParams).toEqual(['nxtPauthor', 'nxtPid'])
+      expect(regexParams).toEqual(['nxtIauthor', 'nxtPid'])
 
       // All three should match exactly
       expect(sourceParams).toEqual(destParams)
@@ -1046,7 +1339,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       expect(match).toBeTruthy()
       expect(match!.groups).toEqual({
-        nxtPcategory: 'electronics',
+        nxtIcategory: 'electronics',
         nxtPproductId: '12345',
       })
 
@@ -1070,9 +1363,9 @@ describe('generateInterceptionRoutesRewrites', () => {
       expect(rewrites).toHaveLength(1)
       const rewrite = rewrites[0]
 
-      // Verify catchall parameters get * suffix in path-to-regexp format
-      expect(rewrite.source).toBe('/docs/:nxtPslug+')
-      expect(rewrite.destination).toBe('/docs/(.):nxtPslug+')
+      // Verify catchall parameters get + suffix in path-to-regexp format
+      expect(rewrite.source).toBe('/docs/:nxtIslug+')
+      expect(rewrite.destination).toBe('/docs/(.):nxtIslug+')
 
       const sourceParams = rewrite.source
         .match(/:(\w+)\*?/g)
@@ -1084,16 +1377,16 @@ describe('generateInterceptionRoutesRewrites', () => {
         rewrite.regex!.matchAll(/\(\?<(\w+)>/g)
       ).map((m) => m[1])
 
-      expect(sourceParams).toEqual(['nxtPslug'])
-      expect(destParams).toEqual(['nxtPslug'])
-      expect(regexParams).toEqual(['nxtPslug'])
+      expect(sourceParams).toEqual(['nxtIslug'])
+      expect(destParams).toEqual(['nxtIslug'])
+      expect(regexParams).toEqual(['nxtIslug'])
 
       // Test actual matching and substitution
       const { sourceRegex } = getRewriteMatchers(rewrite)
       const match = sourceRegex.exec('/docs/getting-started/installation')
 
       expect(match).toBeTruthy()
-      expect(match!.groups!.nxtPslug).toBe('getting-started/installation')
+      expect(match!.groups!.nxtIslug).toBe('getting-started/installation')
     })
 
     it('should handle multiple parameters with mixed types consistently', () => {
@@ -1104,12 +1397,12 @@ describe('generateInterceptionRoutesRewrites', () => {
       expect(rewrites).toHaveLength(1)
       const rewrite = rewrites[0]
 
-      // Verify source and destination have correct format with * suffix for catchall
+      // Verify source and destination have correct format with + suffix for catchall
       expect(rewrite.source).toBe(
-        '/blog/:nxtPyear/:nxtPmonth/:nxtPslug/comments/:nxtPcommentPath+'
+        '/blog/:nxtPyear/:nxtPmonth/:nxtIslug/comments/:nxtPcommentPath+'
       )
       expect(rewrite.destination).toBe(
-        '/blog/:nxtPyear/:nxtPmonth/(.):nxtPslug/comments/:nxtPcommentPath+'
+        '/blog/:nxtPyear/:nxtPmonth/(.):nxtIslug/comments/:nxtPcommentPath+'
       )
 
       // All parameters should use nxtP prefix (no nxtI for intercepted route source)
@@ -1127,19 +1420,19 @@ describe('generateInterceptionRoutesRewrites', () => {
       expect(sourceParams).toEqual([
         'nxtPyear',
         'nxtPmonth',
-        'nxtPslug',
+        'nxtIslug',
         'nxtPcommentPath',
       ])
       expect(destParams).toEqual([
         'nxtPyear',
         'nxtPmonth',
-        'nxtPslug',
+        'nxtIslug',
         'nxtPcommentPath',
       ])
       expect(regexParams).toEqual([
         'nxtPyear',
         'nxtPmonth',
-        'nxtPslug',
+        'nxtIslug',
         'nxtPcommentPath',
       ])
 
@@ -1157,10 +1450,10 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       // This is the exact case that was failing
       expect(rewrite.source).toBe(
-        '/intercepting-routes-dynamic/photos/:nxtPauthor/:nxtPid'
+        '/intercepting-routes-dynamic/photos/:nxtIauthor/:nxtPid'
       )
       expect(rewrite.destination).toBe(
-        '/intercepting-routes-dynamic/photos/(.):nxtPauthor/:nxtPid'
+        '/intercepting-routes-dynamic/photos/(.):nxtIauthor/:nxtPid'
       )
 
       // The bug was: regex had (?<nxtPauthor> but source had :nxtIauthor
@@ -1168,12 +1461,12 @@ describe('generateInterceptionRoutesRewrites', () => {
       const regexParams = Array.from(
         rewrite.regex!.matchAll(/\(\?<(\w+)>/g)
       ).map((m) => m[1])
-      expect(regexParams).toEqual(['nxtPauthor', 'nxtPid'])
+      expect(regexParams).toEqual(['nxtIauthor', 'nxtPid'])
 
       const sourceParams = rewrite.source
         .match(/:(\w+)/g)
         ?.map((p) => p.slice(1))
-      expect(sourceParams).toEqual(['nxtPauthor', 'nxtPid'])
+      expect(sourceParams).toEqual(['nxtIauthor', 'nxtPid'])
 
       // Verify actual URL matching and substitution works
       const { sourceRegex } = getRewriteMatchers(rewrite)
@@ -1183,7 +1476,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
       expect(match).toBeTruthy()
       expect(match!.groups).toEqual({
-        nxtPauthor: 'next',
+        nxtIauthor: 'next',
         nxtPid: '123',
       })
 
@@ -1213,13 +1506,13 @@ describe('generateInterceptionRoutesRewrites', () => {
         expect(rewrite.source).toBe('/photos')
         expect(rewrite.destination).toBe('/@slot1/@slot2/(.)photos')
 
-        // Header should match root-level routes (both slots normalized away)
+        // Header should match root-level routes and all descendants (both slots normalized away)
         const { headerRegex } = getRewriteMatchers(rewrite)
-        expect(headerRegex.source).toMatchInlineSnapshot(`"^(\\/[^/]+)?\\/?$"`)
+        expect(headerRegex.source).toMatchInlineSnapshot(`"^\\/.*$"`)
 
         expect(headerRegex.test('/')).toBe(true)
         expect(headerRegex.test('/home')).toBe(true)
-        expect(headerRegex.test('/home/nested')).toBe(false)
+        expect(headerRegex.test('/home/nested')).toBe(true)
       })
     })
 
@@ -1238,7 +1531,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
         const { headerRegex } = getRewriteMatchers(rewrite)
         expect(headerRegex.source).toMatchInlineSnapshot(
-          `"^\\/templates(\\/.+)?$"`
+          `"^\\/templates(?:\\/.*)?$"`
         )
 
         // With optional catchall sibling, should match exact level AND nested paths
@@ -1261,7 +1554,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
         const { headerRegex } = getRewriteMatchers(rewrite)
         expect(headerRegex.source).toMatchInlineSnapshot(
-          `"^(?:\\/(?<nxtPlocale>.+?))?\\/dashboard(\\/.+)?$"`
+          `"^(?:\\/(?<nxtPlocale>.+?))?\\/dashboard(?:\\/.*)?$"`
         )
 
         // Should match dashboard with and without locale, plus nested paths
@@ -1287,7 +1580,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
         const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
         expect(headerRegex.source).toMatchInlineSnapshot(
-          `"^\\/feed(\\/[^/]+)?\\/?$"`
+          `"^\\/feed(?:\\/.*)?$"`
         )
 
         // Source should match catchall paths
@@ -1295,9 +1588,10 @@ describe('generateInterceptionRoutesRewrites', () => {
         expect(sourceRegex.test('/feed/blog/2024/post-1')).toBe(true)
         expect(sourceRegex.test('/feed/blog/a/b/c')).toBe(true)
 
-        // Header should match /feed level
+        // Header should match /feed level and all descendants
         expect(headerRegex.test('/feed')).toBe(true)
         expect(headerRegex.test('/feed/home')).toBe(true)
+        expect(headerRegex.test('/feed/home/nested')).toBe(true)
       })
 
       it('should intercept an optional catchall route with (..)', () => {
@@ -1316,7 +1610,7 @@ describe('generateInterceptionRoutesRewrites', () => {
 
         const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
         expect(headerRegex.source).toMatchInlineSnapshot(
-          `"^\\/dashboard\\/settings$"`
+          `"^\\/dashboard\\/settings(?:\\/.*)?$"`
         )
 
         // Source should match with 0 or more path segments
@@ -1326,8 +1620,9 @@ describe('generateInterceptionRoutesRewrites', () => {
           true
         )
 
-        // Header should match intercepting route level
+        // Header should match intercepting route level and all descendants
         expect(headerRegex.test('/dashboard/settings')).toBe(true)
+        expect(headerRegex.test('/dashboard/settings/nested')).toBe(true)
       })
 
       it('should handle (...) intercepting a catchall at root', () => {
@@ -1348,15 +1643,17 @@ describe('generateInterceptionRoutesRewrites', () => {
 
         const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
         expect(headerRegex.source).toMatchInlineSnapshot(
-          `"^\\/app\\/dashboard(?:\\/)?$"`
+          `"^\\/app\\/dashboard(?:\\/.*)?$"`
         )
 
         // Source should match catchall paths
         expect(sourceRegex.test('/docs/getting-started')).toBe(true)
         expect(sourceRegex.test('/docs/api/reference')).toBe(true)
 
-        // Header should match intercepting route level
+        // Header should match intercepting route level and all descendants
         expect(headerRegex.test('/app/dashboard')).toBe(true)
+        expect(headerRegex.test('/app/dashboard/nested')).toBe(true)
+        expect(headerRegex.test('/app/dashboard/nested/deep')).toBe(true)
       })
     })
 
@@ -1504,8 +1801,8 @@ describe('generateInterceptionRoutesRewrites', () => {
         const rewrite = rewrites[0]
 
         // Underscores should be preserved in parameter names
-        expect(rewrite.source).toBe('/:nxtPuser_id123/:nxtPpost_id456')
-        expect(rewrite.destination).toBe('/:nxtPuser_id123/(.):nxtPpost_id456')
+        expect(rewrite.source).toBe('/:nxtPuser_id123/:nxtIpost_id456')
+        expect(rewrite.destination).toBe('/:nxtPuser_id123/(.):nxtIpost_id456')
 
         const { sourceRegex } = getRewriteMatchers(rewrite)
         const match = sourceRegex.exec('/user123/post456')
@@ -1513,7 +1810,7 @@ describe('generateInterceptionRoutesRewrites', () => {
         expect(match).toBeTruthy()
         expect(match!.groups).toEqual({
           nxtPuser_id123: 'user123',
-          nxtPpost_id456: 'post456',
+          nxtIpost_id456: 'post456',
         })
       })
 
@@ -1623,5 +1920,368 @@ describe('generateInterceptionRoutesRewrites', () => {
         expect(headerRegex.test('/en/us/dashboard')).toBe(true)
       })
     })
+
+    describe('deep nesting with many dynamic segments', () => {
+      it('should handle GitHub-style deeply nested route with interception', () => {
+        // Pattern: /[org]/[repo]/tree/[branch]/@modal intercepts blob one level up
+        // (..) from /[org]/[repo]/tree/[branch] goes to /[org]/[repo]/tree
+        const rewrites = generateInterceptionRoutesRewrites([
+          '/[org]/[repo]/tree/[branch]/@modal/(..)blob/[...filepath]',
+        ])
+
+        expect(rewrites).toHaveLength(1)
+        const rewrite = rewrites[0]
+
+        // (..) goes one level up from /[org]/[repo]/tree/[branch], which is /[org]/[repo]/tree
+        expect(rewrite.source).toBe(
+          '/:nxtPorg/:nxtPrepo/tree/blob/:nxtPfilepath+'
+        )
+
+        // Destination includes all parameters from the intercepting route
+        expect(rewrite.destination).toBe(
+          '/:nxtPorg/:nxtPrepo/tree/:nxtPbranch/@modal/(..)blob/:nxtPfilepath+'
+        )
+
+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+        // Source should match blob paths under tree
+        expect(sourceRegex.test('/vercel/next.js/tree/blob/README.md')).toBe(
+          true
+        )
+        expect(
+          sourceRegex.test('/vercel/next.js/tree/blob/src/client/app.ts')
+        ).toBe(true)
+
+        // Header should match tree view at specific branch level
+        expect(headerRegex.test('/vercel/next.js/tree/canary')).toBe(true)
+        expect(headerRegex.test('/vercel/next.js/tree/main')).toBe(true)
+        expect(headerRegex.test('/vercel/next.js/tree/canary/nested')).toBe(
+          true
+        )
+
+        // Verify parameter extraction works correctly
+        const match = sourceRegex.exec('/vercel/next.js/tree/blob/src/index.ts')
+        expect(match?.groups).toEqual({
+          nxtPorg: 'vercel',
+          nxtPrepo: 'next.js',
+          nxtPfilepath: 'src/index.ts',
+        })
+      })
+
+      it('should handle multi-tenant SaaS with 5+ segments', () => {
+        // Pattern: /[workspace]/[project]/[env]/[service]/settings intercepts logs
+        const rewrites = generateInterceptionRoutesRewrites([
+          '/[workspace]/[project]/[env]/[service]/settings/@modal/(.)logs/[...path]',
+        ])
+
+        expect(rewrites).toHaveLength(1)
+        const rewrite = rewrites[0]
+
+        expect(rewrite.source).toBe(
+          '/:nxtPworkspace/:nxtPproject/:nxtPenv/:nxtPservice/settings/logs/:nxtPpath+'
+        )
+        expect(rewrite.destination).toBe(
+          '/:nxtPworkspace/:nxtPproject/:nxtPenv/:nxtPservice/settings/@modal/(.)logs/:nxtPpath+'
+        )
+
+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+        // Source should match deeply nested log paths
+        expect(
+          sourceRegex.test('/acme/website/prod/api/settings/logs/errors.log')
+        ).toBe(true)
+        expect(
+          sourceRegex.test(
+            '/acme/website/staging/web/settings/logs/2024/01/app.log'
+          )
+        ).toBe(true)
+
+        // Header should match the settings level
+        expect(headerRegex.test('/acme/website/prod/api/settings')).toBe(true)
+        expect(headerRegex.test('/acme/website/staging/web/settings')).toBe(
+          true
+        )
+
+        // Verify all parameters are extracted
+        const match = sourceRegex.exec(
+          '/acme/website/prod/api/settings/logs/error.log'
+        )
+        expect(match?.groups).toEqual({
+          nxtPworkspace: 'acme',
+          nxtPproject: 'website',
+          nxtPenv: 'prod',
+          nxtPservice: 'api',
+          nxtPpath: 'error.log',
+        })
+      })
+
+      it('should handle 6 consecutive dynamic segments with interception', () => {
+        const rewrites = generateInterceptionRoutesRewrites([
+          '/[a]/[b]/[c]/[d]/[e]/[f]/(.)target',
+        ])
+
+        expect(rewrites).toHaveLength(1)
+        const rewrite = rewrites[0]
+
+        expect(rewrite.source).toBe(
+          '/:nxtPa/:nxtPb/:nxtPc/:nxtPd/:nxtPe/:nxtPf/target'
+        )
+        expect(rewrite.destination).toBe(
+          '/:nxtPa/:nxtPb/:nxtPc/:nxtPd/:nxtPe/:nxtPf/(.)target'
+        )
+
+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+        expect(sourceRegex.test('/1/2/3/4/5/6/target')).toBe(true)
+
+        // Header should match all 6 levels
+        expect(headerRegex.test('/1/2/3/4/5/6')).toBe(true)
+        expect(headerRegex.test('/a/b/c/d/e/f')).toBe(true)
+
+        // Verify all 6 parameters are captured
+        const match = sourceRegex.exec('/1/2/3/4/5/6/target')
+        expect(Object.keys(match?.groups || {}).length).toBe(6)
+        expect(match?.groups).toMatchObject({
+          nxtPa: '1',
+          nxtPb: '2',
+          nxtPc: '3',
+          nxtPd: '4',
+          nxtPe: '5',
+          nxtPf: '6',
+        })
+      })
+    })
+
+    describe('multiple conflicting interception routes', () => {
+      it('should handle multiple routes intercepting the same target from different levels', () => {
+        // Real scenario: multiple modals at different levels trying to intercept the same route
+        const rewrites = generateInterceptionRoutesRewrites([
+          '/dashboard/@modal/(.)settings',
+          '/dashboard/profile/@modal/(..)settings',
+          '/@global-modal/(...)settings',
+        ])
+
+        // Should generate 3 rewrites, one for each interception route
+        expect(rewrites).toHaveLength(3)
+
+        // First rewrite: from /dashboard level
+        const dashboardRewrite = rewrites[0]
+        expect(dashboardRewrite.source).toBe('/dashboard/settings')
+        expect(dashboardRewrite.destination).toBe(
+          '/dashboard/@modal/(.)settings'
+        )
+
+        const { headerRegex: dashboardHeader } =
+          getRewriteMatchers(dashboardRewrite)
+        expect(dashboardHeader.test('/dashboard')).toBe(true)
+        expect(dashboardHeader.test('/dashboard/profile')).toBe(true)
+
+        // Second rewrite: from /dashboard/profile level (one level up)
+        const profileRewrite = rewrites[1]
+        expect(profileRewrite.source).toBe('/dashboard/settings')
+        expect(profileRewrite.destination).toBe(
+          '/dashboard/profile/@modal/(..)settings'
+        )
+
+        const { headerRegex: profileHeader } =
+          getRewriteMatchers(profileRewrite)
+        expect(profileHeader.test('/dashboard/profile')).toBe(true)
+        expect(profileHeader.test('/dashboard/profile/nested')).toBe(true)
+
+        // Third rewrite: from root level (...)
+        const rootRewrite = rewrites[2]
+        expect(rootRewrite.source).toBe('/settings')
+        expect(rootRewrite.destination).toBe('/@global-modal/(...)settings')
+
+        const { headerRegex: rootHeader } = getRewriteMatchers(rootRewrite)
+        expect(rootHeader.test('/')).toBe(true)
+        expect(rootHeader.test('/anything')).toBe(true)
+      })
+
+      it('should handle parallel routes with same target from different positions', () => {
+        const rewrites = generateInterceptionRoutesRewrites([
+          '/dashboard/@sidebar/(.)user/[id]',
+          '/dashboard/@modal/(.)user/[id]',
+        ])
+
+        expect(rewrites).toHaveLength(2)
+
+        // Both should have the same source but different destinations
+        expect(rewrites[0].source).toBe('/dashboard/user/:nxtPid')
+        expect(rewrites[1].source).toBe('/dashboard/user/:nxtPid')
+
+        expect(rewrites[0].destination).toBe(
+          '/dashboard/@sidebar/(.)user/:nxtPid'
+        )
+        expect(rewrites[1].destination).toBe(
+          '/dashboard/@modal/(.)user/:nxtPid'
+        )
+
+        // Both should match the same header pattern
+        const { headerRegex: header1 } = getRewriteMatchers(rewrites[0])
+        const { headerRegex: header2 } = getRewriteMatchers(rewrites[1])
+
+        expect(header1.source).toBe(header2.source)
+        expect(header1.test('/dashboard')).toBe(true)
+      })
+    })
+
+    describe('complex real-world integration patterns', () => {
+      it('should handle enterprise app with all features combined', () => {
+        // i18n + multi-tenant + route groups + parallel routes + interception
+        const rewrites = generateInterceptionRoutesRewrites([
+          '/[[...locale]]/[workspace]/[project]/(dashboard)/[environment]/@modal/(..)settings/[section]/[...path]',
+        ])
+
+        expect(rewrites).toHaveLength(1)
+        const rewrite = rewrites[0]
+
+        // Source: intercepted route one level up from environment
+        expect(rewrite.source).toBe(
+          '/:nxtPlocale*/:nxtPworkspace/:nxtPproject/settings/:nxtPsection/:nxtPpath+'
+        )
+
+        // Destination: full path with all segments
+        expect(rewrite.destination).toBe(
+          '/:nxtPlocale*/:nxtPworkspace/:nxtPproject/(dashboard)/:nxtPenvironment/@modal/(..)settings/:nxtPsection/:nxtPpath+'
+        )
+
+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+        // Test various locale depths with full path
+        expect(sourceRegex.test('/acme/myapp/settings/general/advanced')).toBe(
+          true
+        )
+        expect(
+          sourceRegex.test('/en/acme/myapp/settings/general/advanced')
+        ).toBe(true)
+        expect(
+          sourceRegex.test('/en/US/acme/myapp/settings/general/advanced/nested')
+        ).toBe(true)
+
+        // Header should match the environment level with optional locale
+        expect(headerRegex.test('/acme/myapp/prod')).toBe(true)
+        expect(headerRegex.test('/en/acme/myapp/staging')).toBe(true)
+        expect(headerRegex.test('/en/US/acme/myapp/dev')).toBe(true)
+
+        // Verify all parameters are captured correctly
+        const match = sourceRegex.exec(
+          '/en/acme/myapp/settings/billing/invoices/2024'
+        )
+        expect(match?.groups).toEqual({
+          nxtPlocale: 'en',
+          nxtPworkspace: 'acme',
+          nxtPproject: 'myapp',
+          nxtPsection: 'billing',
+          nxtPpath: 'invoices/2024',
+        })
+      })
+
+      it('should handle e-commerce with product categories and modals', () => {
+        // (..) from /[[...locale]]/shop/[...category] goes to /[[...locale]]/shop
+        const rewrites = generateInterceptionRoutesRewrites([
+          '/[[...locale]]/shop/[...category]/@quickview/(..)product/[slug]',
+        ])
+
+        expect(rewrites).toHaveLength(1)
+        const rewrite = rewrites[0]
+
+        // (..) goes one level up from /[[...locale]]/shop/[...category], which is /[[...locale]]/shop
+        expect(rewrite.source).toBe('/:nxtPlocale*/shop/product/:nxtPslug')
+        expect(rewrite.destination).toBe(
+          '/:nxtPlocale*/shop/:nxtPcategory+/@quickview/(..)product/:nxtPslug'
+        )
+
+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+        // Should work with various locale depths
+        expect(sourceRegex.test('/shop/product/laptop-1')).toBe(true)
+        expect(sourceRegex.test('/en/shop/product/shirt-1')).toBe(true)
+        expect(sourceRegex.test('/en/US/shop/product/blender-1')).toBe(true)
+
+        // Header should match from category pages at any depth
+        expect(headerRegex.test('/shop/electronics')).toBe(true)
+        expect(headerRegex.test('/en/shop/clothing/mens')).toBe(true)
+        expect(headerRegex.test('/en/US/shop/home/kitchen/appliances')).toBe(
+          true
+        )
+      })
+
+      it('should handle documentation site with versioning and modals', () => {
+        // (..) from /[[...locale]]/docs/[version]/[...slug] goes to /[[...locale]]/docs/[version]
+        const rewrites = generateInterceptionRoutesRewrites([
+          '/[[...locale]]/docs/[version]/[...slug]/@modal/(..)api/[endpoint]',
+        ])
+
+        expect(rewrites).toHaveLength(1)
+        const rewrite = rewrites[0]
+
+        // (..) goes one level up from /[[...locale]]/docs/[version]/[...slug], which is /[[...locale]]/docs/[version]
+        expect(rewrite.source).toBe(
+          '/:nxtPlocale*/docs/:nxtPversion/api/:nxtPendpoint'
+        )
+        expect(rewrite.destination).toBe(
+          '/:nxtPlocale*/docs/:nxtPversion/:nxtPslug+/@modal/(..)api/:nxtPendpoint'
+        )
+
+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)
+
+        // Should handle different locales and versions
+        expect(sourceRegex.test('/docs/v14/api/getStaticProps')).toBe(true)
+        expect(sourceRegex.test('/en/docs/v15/api/generateStaticParams')).toBe(
+          true
+        )
+
+        // Header should match the doc page level (with slug catchall)
+        expect(headerRegex.test('/docs/v14/getting-started')).toBe(true)
+        expect(headerRegex.test('/en/docs/v15/guides/routing')).toBe(true)
+
+        const match = sourceRegex.exec('/en/docs/v15/api/generateStaticParams')
+        expect(match?.groups).toEqual({
+          nxtPlocale: 'en',
+          nxtPversion: 'v15',
+          nxtPendpoint: 'generateStaticParams',
+        })
+      })
+
+      it('should handle social media app with multiple modal types', () => {
+        const rewrites = generateInterceptionRoutesRewrites([
+          '/[username]/@post-modal/[postId]/@comments/(..)comment/[commentId]',
+          '/[username]/@photo-modal/(.)photos/[photoId]',
+        ])
+
+        expect(rewrites).toHaveLength(2)
+
+        // First rewrite: comment modal from within post modal
+        // (..) from /[username]/[postId] (after normalizing @post-modal/@comments) goes to /[username]
+        const commentRewrite = rewrites[0]
+        expect(commentRewrite.source).toBe(
+          '/:nxtPusername/comment/:nxtPcommentId'
+        )
+        expect(commentRewrite.destination).toBe(
+          '/:nxtPusername/@post-modal/:nxtPpostId/@comments/(..)comment/:nxtPcommentId'
+        )
+
+        // Second rewrite: photo modal from profile
+        const photoRewrite = rewrites[1]
+        expect(photoRewrite.source).toBe('/:nxtPusername/photos/:nxtPphotoId')
+        expect(photoRewrite.destination).toBe(
+          '/:nxtPusername/@photo-modal/(.)photos/:nxtPphotoId'
+        )
+
+        const { sourceRegex: commentSource, headerRegex: commentHeader } =
+          getRewriteMatchers(commentRewrite)
+        const { sourceRegex: photoSource, headerRegex: photoHeader } =
+          getRewriteMatchers(photoRewrite)
+
+        // Comment interception - goes one level up from postId, so no postId in source
+        expect(commentSource.test('/john/comment/comment456')).toBe(true)
+        expect(commentHeader.test('/john/post123')).toBe(true)
+
+        // Photo interception
+        expect(photoSource.test('/john/photos/photo789')).toBe(true)
+        expect(photoHeader.test('/john')).toBe(true)
+      })
+    })
   })
 })
diff --git a/packages/next/src/lib/generate-interception-routes-rewrites.ts b/packages/next/src/lib/generate-interception-routes-rewrites.ts
index 851c110657..c196b64dbf 100644
--- a/packages/next/src/lib/generate-interception-routes-rewrites.ts
+++ b/packages/next/src/lib/generate-interception-routes-rewrites.ts
@@ -2,233 +2,10 @@ import { NEXT_URL } from '../client/components/app-router-headers'
 import {
   extractInterceptionRouteInformation,
   isInterceptionRouteAppPath,
-  INTERCEPTION_ROUTE_MARKERS,
 } from '../shared/lib/router/utils/interception-routes'
 import type { Rewrite } from './load-custom-routes'
 import type { DeepReadonly } from '../shared/lib/deep-readonly'
 import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'
-import {
-  getSegmentParam,
-  isCatchAll,
-} from '../shared/lib/router/utils/get-segment-param'
-import { InvariantError } from '../shared/lib/invariant-error'
-import { escapeStringRegexp } from '../shared/lib/escape-regexp'
-
-/**
- * Detects which interception marker is used in the app path
- */
-function getInterceptionMarker(
-  appPath: string
-): (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined {
-  for (const segment of appPath.split('/')) {
-    const marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))
-    if (marker) {
-      return marker
-    }
-  }
-  return undefined
-}
-
-/**
- * Generates a regex pattern that matches routes at the same level as the intercepting route.
- * For (.) same-level interception, we need to match:
- * - The intercepting route itself
- * - Any direct child of the intercepting route
- * But NOT deeper nested routes
- */
-function generateSameLevelHeaderRegex(
-  interceptingRoute: string,
-  reference: Record<string, string>
-): string {
-  // Build the pattern for matching the intercepting route and its direct children
-  const segments =
-    interceptingRoute === '/'
-      ? []
-      : interceptingRoute.split('/').filter(Boolean)
-
-  const patterns: string[] = []
-  const optionalIndices: number[] = []
-
-  for (let i = 0; i < segments.length; i++) {
-    const segment = segments[i]
-    const param = getSegmentParam(segment)
-    if (param) {
-      // Dynamic segment - use named capture group
-      // Use the reference mapping which has the correct param -> prefixedKey mapping
-      const prefixedKey = reference[param.param]
-      if (!prefixedKey) {
-        throw new InvariantError(
-          `No reference found for param: ${param.param} in reference: ${JSON.stringify(reference)}`
-        )
-      }
-
-      // Check if this is a catchall (repeat) parameter
-      if (isCatchAll(param.type)) {
-        patterns.push(`(?<${prefixedKey}>.+?)`)
-        // Track optional catchall segments so we can wrap them later
-        if (param.type === 'optional-catchall') {
-          optionalIndices.push(i)
-        }
-      } else {
-        patterns.push(`(?<${prefixedKey}>[^/]+?)`)
-      }
-    } else {
-      // Static segment
-      patterns.push(escapeStringRegexp(segment))
-    }
-  }
-
-  // Build the header regex, wrapping optional catchall segments
-  let pattern = ''
-  for (let i = 0; i < patterns.length; i++) {
-    if (optionalIndices.includes(i)) {
-      // Optional catchall: wrap the segment with its leading / in an optional group
-      pattern += `(?:/${patterns[i]})?`
-    } else {
-      pattern += `/${patterns[i]}`
-    }
-  }
-
-  // Match the pattern, optionally followed by a single segment, with optional trailing slash
-  // Note: Don't add ^ and $ anchors here - matchHas() will add them automatically
-  return `${pattern}(/[^/]+)?/?`
-}
-
-/**
- * Check if there's a catchall route sibling at the intercepting route level.
- * For example, if interceptingRoute is '/templates', this checks for
- * '/templates/[...catchAll]'.
- */
-function hasCatchallSiblingAtLevel(
-  appPaths: string[],
-  interceptingRoute: string
-): boolean {
-  const targetSegments =
-    interceptingRoute === '/'
-      ? []
-      : interceptingRoute.split('/').filter(Boolean)
-  const targetDepth = targetSegments.length
-
-  return appPaths.some((path) => {
-    const segments = path.split('/').filter(Boolean)
-
-    // Check if this path is at the same depth + 1 (parent segments + the catchall segment)
-    if (segments.length !== targetDepth + 1) {
-      return false
-    }
-
-    // Check if the first targetDepth segments match exactly
-    for (let i = 0; i < targetDepth; i++) {
-      // Skip interception routes
-      if (
-        INTERCEPTION_ROUTE_MARKERS.some((marker) =>
-          segments[i].startsWith(marker)
-        )
-      ) {
-        return false
-      }
-
-      if (segments[i] !== targetSegments[i]) {
-        return false
-      }
-    }
-
-    // Check if the last segment is a catchall parameter
-    const lastSegment = segments[segments.length - 1]
-    const param = getSegmentParam(lastSegment)
-    return param !== null && isCatchAll(param.type)
-  })
-}
-
-/**
- * Generates the appropriate header regex based on the interception marker type.
- * @param marker The interception route marker (e.g., '(.)', '(..)'))
- * @param interceptingRoute The route that intercepts (e.g., '/templates')
- * @param headerReference The reference mapping from param names to prefixed keys
- * @param appPaths All app paths (used for catchall sibling detection)
- * @param defaultHeaderRegex The default regex to use if no marker-specific logic applies
- * @returns The header regex pattern to match against the Next-URL header
- */
-function generateInterceptionHeaderRegex(
-  marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,
-  interceptingRoute: string,
-  headerReference: Record<string, string>,
-  appPaths: string[],
-  defaultHeaderRegex: string
-): string {
-  // Generate the appropriate header regex based on the marker type
-  let headerRegex: string
-  if (marker === '(.)') {
-    // For same-level interception, match routes at the same level as the intercepting route
-    // Use header.reference which has the param -> prefixedKey mapping
-    headerRegex = generateSameLevelHeaderRegex(
-      interceptingRoute,
-      headerReference
-    )
-  } else if (marker === '(..)') {
-    // For parent-level interception, match routes at the intercepting route level
-    // Check if there's a catchall sibling at the intercepting route level
-    const hasCatchallSibling = hasCatchallSiblingAtLevel(
-      appPaths,
-      interceptingRoute
-    )
-
-    // Build regex pattern that handles dynamic segments correctly
-    const patterns: string[] = []
-    const optionalIndices: number[] = []
-
-    const segments = interceptingRoute.split('/').filter(Boolean)
-    for (let i = 0; i < segments.length; i++) {
-      const segment = segments[i]
-      const param = getSegmentParam(segment)
-      if (param) {
-        // Dynamic segment - use named capture group from header.reference
-        const key = headerReference[param.param]
-        if (!key) {
-          throw new InvariantError(
-            `No reference found for param: ${param.param} in reference: ${JSON.stringify(headerReference)}`
-          )
-        }
-
-        // Check if this is a catchall (repeat) parameter
-        if (isCatchAll(param.type)) {
-          patterns.push(`(?<${key}>.+?)`)
-          // Track optional catchall segments so we can wrap them later
-          if (param.type === 'optional-catchall') {
-            optionalIndices.push(i)
-          }
-        } else {
-          patterns.push(`(?<${key}>[^/]+?)`)
-        }
-      } else {
-        // Static segment
-        patterns.push(escapeStringRegexp(segment))
-      }
-    }
-
-    // Build the header regex, wrapping optional catchall segments
-    let headerPattern = ''
-    for (let i = 0; i < patterns.length; i++) {
-      if (optionalIndices.includes(i)) {
-        // Optional catchall: wrap the segment with its leading / in an optional group
-        headerPattern += `(?:/${patterns[i]})?`
-      } else {
-        headerPattern += `/${patterns[i]}`
-      }
-    }
-
-    // Note: Don't add ^ and $ anchors - matchHas() will add them automatically
-    // If there's a catchall sibling, match the level and its children (catchall paths)
-    // Otherwise, only match the exact level
-    headerRegex = `${headerPattern}${hasCatchallSibling ? '(/.+)?' : ''}`
-  } else {
-    // For other markers, use the default behavior (match exact intercepting route)
-    // Strip ^ and $ anchors since matchHas() will add them automatically
-    headerRegex = defaultHeaderRegex
-  }
-
-  return headerRegex
-}
 
 export function generateInterceptionRoutesRewrites(
   appPaths: string[],
@@ -241,44 +18,29 @@ export function generateInterceptionRoutesRewrites(
       const { interceptingRoute, interceptedRoute } =
         extractInterceptionRouteInformation(appPath)
 
-      // Detect which marker is being used
-      const marker = getInterceptionMarker(appPath)
-
-      // The Next-Url header does not contain the base path, so just use the
-      // intercepting route. We don't handle duplicate keys here with the
-      // backreferenceDuplicateKeys option because it's not a valid pathname
-      // with them in this case.
-      const header = getNamedRouteRegex(interceptingRoute, {
+      const destination = getNamedRouteRegex(basePath + appPath, {
         prefixRouteKeys: true,
       })
 
-      // The source is the intercepted route with the base path, it's matched by
-      // the router. Generate this first to get the correct parameter prefixes.
-      // We don't handle duplicate keys here with the backreferenceDuplicateKeys
-      // option because it's not a valid pathname with them in this case.
-      const source = getNamedRouteRegex(basePath + interceptedRoute, {
+      const header = getNamedRouteRegex(interceptingRoute, {
         prefixRouteKeys: true,
+        reference: destination.reference,
       })
 
-      // The destination should use the same parameter reference as the source
-      // so that parameter substitution works correctly. This ensures that when
-      // the router extracts params from the source, they can be substituted
-      // into the destination. We don't handle duplicate keys here with the
-      // backreferenceDuplicateKeys option because we don't use the regexp
-      // itself in this case, only the pathToRegexpPattern.
-      const destination = getNamedRouteRegex(basePath + appPath, {
+      const source = getNamedRouteRegex(basePath + interceptedRoute, {
         prefixRouteKeys: true,
-        reference: source.reference,
+        reference: header.reference,
       })
 
-      // Generate the header regex based on the interception marker type
-      const headerRegex = generateInterceptionHeaderRegex(
-        marker,
-        interceptingRoute,
-        header.reference,
-        appPaths,
-        header.namedRegex.replace(/^\^/, '').replace(/\$$/, '')
-      )
+      const headerRegex = header.namedRegex
+        // Strip ^ and $ anchors since matchHas() will add them automatically
+        .replace(/^\^/, '')
+        .replace(/\$$/, '')
+        // Replace matching the `/` with matching any route segment.
+        .replace(/^\/\(\?:\/\)\?$/, '/.*')
+        // Replace the optional trailing with slash capture group with one that
+        // will match any descendants.
+        .replace(/\(\?:\/\)\?$/, '(?:/.*)?')
 
       rewrites.push({
         source: source.pathToRegexpPattern,
diff --git a/packages/next/src/shared/lib/router/utils/interception-routes.ts b/packages/next/src/shared/lib/router/utils/interception-routes.ts
index a899657e0f..7d02174180 100644
--- a/packages/next/src/shared/lib/router/utils/interception-routes.ts
+++ b/packages/next/src/shared/lib/router/utils/interception-routes.ts
@@ -19,10 +19,27 @@ export function isInterceptionRouteAppPath(path: string): boolean {
   )
 }
 
-export function extractInterceptionRouteInformation(path: string) {
-  let interceptingRoute: string | undefined,
-    marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,
-    interceptedRoute: string | undefined
+type InterceptionRouteInformation = {
+  /**
+   * The intercepting route. This is the route that is being intercepted or the
+   * route that the user was coming from. This is matched by the Next-Url
+   * header.
+   */
+  interceptingRoute: string
+
+  /**
+   * The intercepted route. This is the route that is being intercepted or the
+   * route that the user is going to. This is matched by the request pathname.
+   */
+  interceptedRoute: string
+}
+
+export function extractInterceptionRouteInformation(
+  path: string
+): InterceptionRouteInformation {
+  let interceptingRoute: string | undefined
+  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined
+  let interceptedRoute: string | undefined
 
   for (const segment of path.split('/')) {
     marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))
diff --git a/packages/next/src/shared/lib/router/utils/route-regex.test.ts b/packages/next/src/shared/lib/router/utils/route-regex.test.ts
index 045fd9691d..642518bca7 100644
--- a/packages/next/src/shared/lib/router/utils/route-regex.test.ts
+++ b/packages/next/src/shared/lib/router/utils/route-regex.test.ts
@@ -44,8 +44,13 @@ describe('getNamedRouteRegex', () => {
        "pathToRegexpPattern": "/photos/(.):nxtIauthor/:nxtPid",
        "re": /\\^\\\\/photos\\\\/\\\\\\(\\\\\\.\\\\\\)\\(\\[\\^/\\]\\+\\?\\)\\\\/\\(\\[\\^/\\]\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "author": "nxtIauthor",
-         "id": "nxtPid",
+         "intercepted": {
+           "author": "(.)",
+         },
+         "names": {
+           "author": "nxtIauthor",
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtIauthor": "nxtIauthor",
@@ -86,8 +91,13 @@ describe('getNamedRouteRegex', () => {
        "pathToRegexpPattern": "/(.):nxtIauthor/:nxtPid",
        "re": /\\^\\\\/\\\\\\(\\\\\\.\\\\\\)\\(\\[\\^/\\]\\+\\?\\)\\\\/\\(\\[\\^/\\]\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "author": "nxtIauthor",
-         "id": "nxtPid",
+         "intercepted": {
+           "author": "(.)",
+         },
+         "names": {
+           "author": "nxtIauthor",
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtIauthor": "nxtIauthor",
@@ -122,8 +132,13 @@ describe('getNamedRouteRegex', () => {
        "pathToRegexpPattern": "/(..)(..):nxtIauthor/:nxtPid",
        "re": /\\^\\\\/\\\\\\(\\\\\\.\\\\\\.\\\\\\)\\\\\\(\\\\\\.\\\\\\.\\\\\\)\\(\\[\\^/\\]\\+\\?\\)\\\\/\\(\\[\\^/\\]\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "author": "nxtIauthor",
-         "id": "nxtPid",
+         "intercepted": {
+           "author": "(..)(..)",
+         },
+         "names": {
+           "author": "nxtIauthor",
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtIauthor": "nxtIauthor",
@@ -160,8 +175,13 @@ describe('getNamedRouteRegex', () => {
        "pathToRegexpPattern": "/photos/(..)(..):nxtIauthor/:nxtPid",
        "re": /\\^\\\\/photos\\\\/\\\\\\(\\\\\\.\\\\\\.\\\\\\)\\\\\\(\\\\\\.\\\\\\.\\\\\\)\\(\\[\\^/\\]\\+\\?\\)\\\\/\\(\\[\\^/\\]\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "author": "nxtIauthor",
-         "id": "nxtPid",
+         "intercepted": {
+           "author": "(..)(..)",
+         },
+         "names": {
+           "author": "nxtIauthor",
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtIauthor": "nxtIauthor",
@@ -206,8 +226,11 @@ describe('getNamedRouteRegex', () => {
        "pathToRegexpPattern": "/:nxtPlocale/about.segments/:nxtPsegmentPath+.segment.rsc",
        "re": /\\^\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/about\\\\\\.segments\\\\/\\(\\.\\+\\?\\)\\\\\\.segment\\\\\\.rsc\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "locale": "nxtPlocale",
-         "segmentPath": "nxtPsegmentPath",
+         "intercepted": {},
+         "names": {
+           "locale": "nxtPlocale",
+           "segmentPath": "nxtPsegmentPath",
+         },
        },
        "routeKeys": {
          "nxtPlocale": "nxtPlocale",
@@ -245,8 +268,11 @@ describe('getNamedRouteRegex', () => {
        "pathToRegexpPattern": "/:nxtPlocale/about.segments/$dname$d/:nxtPname.segment.rsc",
        "re": /\\^\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/about\\\\\\.segments\\\\/\\\\\\$dname\\\\\\$d\\(\\[\\^/\\]\\+\\?\\)\\\\\\.segment\\\\\\.rsc\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "locale": "nxtPlocale",
-         "name": "nxtPname",
+         "intercepted": {},
+         "names": {
+           "locale": "nxtPlocale",
+           "name": "nxtPname",
+         },
        },
        "routeKeys": {
          "nxtPlocale": "nxtPlocale",
@@ -283,7 +309,10 @@ describe('getNamedRouteRegex', () => {
        "pathToRegexpPattern": "/photos/(.)author/:nxtPid",
        "re": /\\^\\\\/photos\\\\/\\\\\\(\\\\\\.\\\\\\)author\\\\/\\(\\[\\^/\\]\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "id": "nxtPid",
+         "intercepted": {},
+         "names": {
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtPid": "nxtPid",
@@ -317,7 +346,10 @@ describe('getNamedRouteRegex', () => {
        "pathToRegexpPattern": "/photos/:nxtPid",
        "re": /\\^\\\\/photos\\\\/\\(\\[\\^/\\]\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "id": "nxtPid",
+         "intercepted": {},
+         "names": {
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtPid": "nxtPid",
@@ -354,7 +386,10 @@ describe('getNamedRouteRegex', () => {
        "pathToRegexpPattern": "/photos/:nxtPid*",
        "re": /\\^\\\\/photos\\(\\?:\\\\/\\(\\.\\+\\?\\)\\)\\?\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "id": "nxtPid",
+         "intercepted": {},
+         "names": {
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtPid": "nxtPid",
@@ -402,7 +437,10 @@ describe('getNamedRouteRegex - Parameter Sanitization', () => {
        "pathToRegexpPattern": "/:nxtPfoobar/page",
        "re": /\\^\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/page\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "foo-bar": "nxtPfoobar",
+         "intercepted": {},
+         "names": {
+           "foo-bar": "nxtPfoobar",
+         },
        },
        "routeKeys": {
          "nxtPfoobar": "nxtPfoo-bar",
@@ -430,7 +468,10 @@ describe('getNamedRouteRegex - Parameter Sanitization', () => {
        "pathToRegexpPattern": "/:nxtPfoo_id/page",
        "re": /\\^\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/page\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "foo_id": "nxtPfoo_id",
+         "intercepted": {},
+         "names": {
+           "foo_id": "nxtPfoo_id",
+         },
        },
        "routeKeys": {
          "nxtPfoo_id": "nxtPfoo_id",
@@ -458,7 +499,10 @@ describe('getNamedRouteRegex - Parameter Sanitization', () => {
        "pathToRegexpPattern": "/:nxtPthisis_myroute/page",
        "re": /\\^\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/page\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "this-is_my-route": "nxtPthisis_myroute",
+         "intercepted": {},
+         "names": {
+           "this-is_my-route": "nxtPthisis_myroute",
+         },
        },
        "routeKeys": {
          "nxtPthisis_myroute": "nxtPthis-is_my-route",
@@ -508,11 +552,11 @@ describe('getNamedRouteRegex - Reference Mapping', () => {
     })
 
     // Both should use the same prefixed key for 'lang'
-    expect(regex1.reference.lang).toBe(regex2.reference.lang)
-    expect(regex2.reference.lang).toBe('nxtPlang')
+    expect(regex1.reference.names.lang).toBe(regex2.reference.names.lang)
+    expect(regex2.reference.names.lang).toBe('nxtPlang')
 
     // New parameter should be added to the reference
-    expect(regex2.reference.id).toBe('nxtPid')
+    expect(regex2.reference.names.id).toBe('nxtPid')
   })
 
   it('should maintain reference consistency across multiple paths', () => {
@@ -526,8 +570,10 @@ describe('getNamedRouteRegex - Reference Mapping', () => {
     })
 
     // Same parameter name should map to same prefixed key
-    expect(baseRegex.reference.locale).toBe(interceptedRegex.reference.locale)
-    expect(interceptedRegex.reference.locale).toBe('nxtPlocale')
+    expect(baseRegex.reference.names.locale).toBe(
+      interceptedRegex.reference.names.locale
+    )
+    expect(interceptedRegex.reference.names.locale).toBe('nxtPlocale')
   })
 
   it('should generate inverse pattern with correct parameter references', () => {
@@ -566,7 +612,10 @@ describe('getNamedRouteRegex - Duplicate Keys', () => {
        "pathToRegexpPattern": "/:nxtPid/posts/:nxtPid",
        "re": /\\^\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/posts\\\\/\\(\\[\\^/\\]\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "id": "nxtPid",
+         "intercepted": {},
+         "names": {
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtPid": "nxtPid",
@@ -595,7 +644,10 @@ describe('getNamedRouteRegex - Duplicate Keys', () => {
        "pathToRegexpPattern": "/:nxtPid/posts/:nxtPid",
        "re": /\\^\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/posts\\\\/\\(\\[\\^/\\]\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "id": "nxtPid",
+         "intercepted": {},
+         "names": {
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtPid": "nxtPid",
@@ -639,10 +691,13 @@ describe('getNamedRouteRegex - Complex Paths', () => {
        "pathToRegexpPattern": "/:nxtPorg/:nxtPrepo/:nxtPbranch/:nxtPpath+",
        "re": /\\^\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/\\(\\[\\^/\\]\\+\\?\\)\\\\/\\(\\.\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "branch": "nxtPbranch",
-         "org": "nxtPorg",
-         "path": "nxtPpath",
-         "repo": "nxtPrepo",
+         "intercepted": {},
+         "names": {
+           "branch": "nxtPbranch",
+           "org": "nxtPorg",
+           "path": "nxtPpath",
+           "repo": "nxtPrepo",
+         },
        },
        "routeKeys": {
          "nxtPbranch": "nxtPbranch",
@@ -689,7 +744,7 @@ describe('getNamedRouteRegex - Complex Paths', () => {
         prefixRouteKeys: true,
       })
 
-      // Should use interception prefix
+      // Should use consistent parameter prefix (interception marker adjacent to parameter uses nxtI)
       expect(regex.routeKeys).toEqual({
         nxtIid: 'nxtIid',
       })
@@ -721,7 +776,10 @@ describe('getNamedRouteRegex - Trailing Slash Behavior', () => {
        "pathToRegexpPattern": "/posts/:nxtPid",
        "re": /\\^\\\\/posts\\\\/\\(\\[\\^/\\]\\+\\?\\)\\(\\?:\\\\/\\)\\?\\$/,
        "reference": {
-         "id": "nxtPid",
+         "intercepted": {},
+         "names": {
+           "id": "nxtPid",
+         },
        },
        "routeKeys": {
          "nxtPid": "nxtPid",
diff --git a/packages/next/src/shared/lib/router/utils/route-regex.ts b/packages/next/src/shared/lib/router/utils/route-regex.ts
index e4846049ae..602ee38fc4 100644
--- a/packages/next/src/shared/lib/router/utils/route-regex.ts
+++ b/packages/next/src/shared/lib/router/utils/route-regex.ts
@@ -18,6 +18,11 @@ export interface RouteRegex {
   re: RegExp
 }
 
+export type RegexReference = {
+  names: Record<string, string>
+  intercepted: Record<string, string>
+}
+
 type GetNamedRouteRegexOptions = {
   /**
    * Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX
@@ -58,7 +63,7 @@ type GetNamedRouteRegexOptions = {
    * keys instead of generating them in context. This is currently only used for
    * interception routes.
    */
-  reference?: Record<string, string>
+  reference?: RegexReference
 }
 
 type GetRouteRegexOptions = {
@@ -266,7 +271,7 @@ function getNamedParametrizedRoute(
   includeSuffix: boolean,
   includePrefix: boolean,
   backreferenceDuplicateKeys: boolean,
-  reference: Record<string, string> = {}
+  reference: RegexReference = { names: {}, intercepted: {} }
 ) {
   const getSafeRouteKey = buildGetSafeRouteKey()
   const routeKeys: { [named: string]: string } = {}
@@ -284,25 +289,37 @@ function getNamedParametrizedRoute(
 
     const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters
 
-    if (hasInterceptionMarker && paramMatches && paramMatches[2]) {
+    const interceptionMarker = hasInterceptionMarker
+      ? paramMatches?.[1]
+      : undefined
+
+    let keyPrefix: string | undefined
+    if (interceptionMarker && paramMatches?.[2]) {
+      keyPrefix = prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined
+      reference.intercepted[paramMatches[2]] = interceptionMarker
+    } else if (paramMatches?.[2] && reference.intercepted[paramMatches[2]]) {
+      keyPrefix = prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined
+    } else {
+      keyPrefix = prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined
+    }
+
+    if (interceptionMarker && paramMatches && paramMatches[2]) {
       // If there's an interception marker, add it to the segments.
       const { key, pattern, cleanedKey, repeat, optional } =
         getSafeKeyFromSegment({
           getSafeRouteKey,
-          interceptionMarker: paramMatches[1],
+          interceptionMarker,
           segment: paramMatches[2],
           routeKeys,
-          keyPrefix: prefixRouteKeys
-            ? NEXT_INTERCEPTION_MARKER_PREFIX
-            : undefined,
+          keyPrefix,
           backreferenceDuplicateKeys,
         })
 
       segments.push(pattern)
       inverseParts.push(
-        `/${paramMatches[1]}:${reference[key] ?? cleanedKey}${repeat ? (optional ? '*' : '+') : ''}`
+        `/${paramMatches[1]}:${reference.names[key] ?? cleanedKey}${repeat ? (optional ? '*' : '+') : ''}`
       )
-      reference[key] ??= cleanedKey
+      reference.names[key] ??= cleanedKey
     } else if (paramMatches && paramMatches[2]) {
       // If there's a prefix, add it to the segments if it's enabled.
       if (includePrefix && paramMatches[1]) {
@@ -315,7 +332,7 @@ function getNamedParametrizedRoute(
           getSafeRouteKey,
           segment: paramMatches[2],
           routeKeys,
-          keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,
+          keyPrefix,
           backreferenceDuplicateKeys,
         })
 
@@ -327,9 +344,9 @@ function getNamedParametrizedRoute(
 
       segments.push(s)
       inverseParts.push(
-        `/:${reference[key] ?? cleanedKey}${repeat ? (optional ? '*' : '+') : ''}`
+        `/:${reference.names[key] ?? cleanedKey}${repeat ? (optional ? '*' : '+') : ''}`
       )
-      reference[key] ??= cleanedKey
+      reference.names[key] ??= cleanedKey
     } else {
       segments.push(`/${escapeStringRegexp(segment)}`)
       inverseParts.push(`/${segment}`)
diff --git a/test/e2e/app-dir/interception-dynamic-segment-middleware/interception-dynamic-segment-middleware.test.ts b/test/e2e/app-dir/interception-dynamic-segment-middleware/interception-dynamic-segment-middleware.test.ts
index acdfce9549..53e4dbdf4d 100644
--- a/test/e2e/app-dir/interception-dynamic-segment-middleware/interception-dynamic-segment-middleware.test.ts
+++ b/test/e2e/app-dir/interception-dynamic-segment-middleware/interception-dynamic-segment-middleware.test.ts
@@ -1,5 +1,5 @@
 import { nextTestSetup } from 'e2e-utils'
-import { check } from 'next-test-utils'
+import { retry } from 'next-test-utils'
 
 describe('interception-dynamic-segment-middleware', () => {
   const { next } = nextTestSetup({
@@ -10,9 +10,59 @@ describe('interception-dynamic-segment-middleware', () => {
     const browser = await next.browser('/')
 
     await browser.elementByCss('[href="/foo/p/1"]').click()
-    await check(() => browser.elementById('modal').text(), /intercepted/)
+    await retry(async () => {
+      expect(await browser.elementById('modal').text()).toMatch(/intercepted/)
+    })
     await browser.refresh()
-    await check(() => browser.elementById('modal').text(), 'default')
-    await check(() => browser.elementById('children').text(), /not intercepted/)
+    await retry(async () => {
+      expect(await browser.elementById('modal').text()).toBe('default')
+    })
+    await retry(async () => {
+      expect(await browser.elementById('children').text()).toMatch(
+        /not intercepted/
+      )
+    })
+  })
+
+  it('should intercept with back/forward navigation with middleware', async () => {
+    // Test that interception works correctly with middleware and browser navigation
+    const browser = await next.browser('/')
+
+    // Navigate with interception
+    await browser.elementByCss('[href="/foo/p/1"]').click()
+    await retry(async () => {
+      expect(await browser.elementById('modal').text()).toMatch(/intercepted/)
+    })
+
+    // Go back to root
+    await browser.back()
+    await retry(async () => {
+      const url = await browser.url()
+      expect(url).toContain('/')
+    })
+
+    // Go forward - should show intercepted version
+    await browser.forward()
+    await retry(async () => {
+      expect(await browser.elementById('modal').text()).toMatch(/intercepted/)
+    })
+  })
+
+  it('should intercept multiple times with middleware active', async () => {
+    // Test that repeated interception works when middleware is involved
+    const browser = await next.browser('/')
+
+    for (let i = 0; i < 2; i++) {
+      await browser.elementByCss('[href="/foo/p/1"]').click()
+      await retry(async () => {
+        expect(await browser.elementById('modal').text()).toMatch(/intercepted/)
+      })
+
+      await browser.back()
+      await retry(async () => {
+        const url = await browser.url()
+        expect(url).toMatch(/\/$/)
+      })
+    }
   })
 })
diff --git a/test/e2e/app-dir/interception-dynamic-segment/interception-dynamic-segment.test.ts b/test/e2e/app-dir/interception-dynamic-segment/interception-dynamic-segment.test.ts
index 90d9ef22b6..7aa6932f11 100644
--- a/test/e2e/app-dir/interception-dynamic-segment/interception-dynamic-segment.test.ts
+++ b/test/e2e/app-dir/interception-dynamic-segment/interception-dynamic-segment.test.ts
@@ -24,6 +24,48 @@ describe('interception-dynamic-segment', () => {
     })
   })
 
+  it('should intercept consistently with back/forward navigation', async () => {
+    // Test that the fix works with browser back/forward navigation
+    const browser = await next.browser('/')
+
+    // Navigate with interception
+    await browser.elementByCss('[href="/foo/1"]').click()
+    await retry(async () => {
+      expect(await browser.elementById('modal').text()).toEqual('intercepted')
+    })
+
+    // Go back to root
+    await browser.back()
+    await retry(async () => {
+      const url = await browser.url()
+      expect(url).toContain('/')
+    })
+
+    // Go forward - should show intercepted version
+    await browser.forward()
+    await retry(async () => {
+      expect(await browser.elementById('modal').text()).toEqual('intercepted')
+    })
+  })
+
+  it('should intercept multiple times from root', async () => {
+    // Test that repeated interception from root works
+    const browser = await next.browser('/')
+
+    for (let i = 0; i < 2; i++) {
+      await browser.elementByCss('[href="/foo/1"]').click()
+      await retry(async () => {
+        expect(await browser.elementById('modal').text()).toEqual('intercepted')
+      })
+
+      await browser.back()
+      await retry(async () => {
+        const url = await browser.url()
+        expect(url).toMatch(/\/$/)
+      })
+    }
+  })
+
   if (isNextStart) {
     it('should correctly prerender segments with generateStaticParams', async () => {
       expect(next.cliOutput).toContain('/generate-static-params/a')
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)[a]/[b]/[c]/item/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)[a]/[b]/[c]/item/page.tsx
new file mode 100644
index 0000000000..e35a210508
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)[a]/[b]/[c]/item/page.tsx
@@ -0,0 +1,10 @@
+export default async function ItemModal(props: {
+  params: Promise<{ a: string; b: string; c: string }>
+}) {
+  const params = await props.params
+  return (
+    <div id="item-modal">
+      Modal: Item for path {params.a}/{params.b}/{params.c}
+    </div>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)admin/dashboard/users/new/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)admin/dashboard/users/new/page.tsx
new file mode 100644
index 0000000000..6c0e3a0bd0
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)admin/dashboard/users/new/page.tsx
@@ -0,0 +1,3 @@
+export default function NewUserModal() {
+  return <div id="new-user-modal">Modal: New User Form</div>
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)groups/[id]/new/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)groups/[id]/new/page.tsx
new file mode 100644
index 0000000000..87f9da3a4e
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)groups/[id]/new/page.tsx
@@ -0,0 +1,6 @@
+export default async function NewItemModal(props: {
+  params: Promise<{ id: string }>
+}) {
+  const params = await props.params
+  return <div id="new-modal">Modal: New item for group {params.id}</div>
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)org/[orgId]/team/[teamId]/settings/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)org/[orgId]/team/[teamId]/settings/page.tsx
new file mode 100644
index 0000000000..ce99d3eb2e
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)org/[orgId]/team/[teamId]/settings/page.tsx
@@ -0,0 +1,10 @@
+export default async function TeamSettingsModal(props: {
+  params: Promise<{ orgId: string; teamId: string }>
+}) {
+  const params = await props.params
+  return (
+    <div id="settings-modal">
+      Modal: Settings for Team {params.teamId} in Org {params.orgId}
+    </div>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/[a]/[b]/[c]/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/[a]/[b]/[c]/page.tsx
new file mode 100644
index 0000000000..cd6c2f1df2
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/[a]/[b]/[c]/page.tsx
@@ -0,0 +1,3 @@
+export default function ConsecutiveDynamicModalDefault() {
+  return null
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/admin/dashboard/users/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/admin/dashboard/users/page.tsx
new file mode 100644
index 0000000000..6b9b3fb3b7
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/admin/dashboard/users/page.tsx
@@ -0,0 +1,3 @@
+export default function UsersModalDefault() {
+  return null
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/default.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/default.tsx
new file mode 100644
index 0000000000..2c6e067255
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/default.tsx
@@ -0,0 +1 @@
+export default () => 'default'
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/groups/[id]/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/groups/[id]/page.tsx
new file mode 100644
index 0000000000..9475665eeb
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/groups/[id]/page.tsx
@@ -0,0 +1,3 @@
+export default function GroupModalDefault() {
+  return null
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/org/[orgId]/team/[teamId]/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/org/[orgId]/team/[teamId]/page.tsx
new file mode 100644
index 0000000000..dbd550ca15
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/org/[orgId]/team/[teamId]/page.tsx
@@ -0,0 +1,3 @@
+export default function TeamModalDefault() {
+  return null
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/[a]/[b]/[c]/item/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/[a]/[b]/[c]/item/page.tsx
new file mode 100644
index 0000000000..510e869333
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/[a]/[b]/[c]/item/page.tsx
@@ -0,0 +1,10 @@
+export default async function ItemPage(props: {
+  params: Promise<{ a: string; b: string; c: string }>
+}) {
+  const params = await props.params
+  return (
+    <div id="item-page">
+      Item for path: {params.a}/{params.b}/{params.c}
+    </div>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/[a]/[b]/[c]/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/[a]/[b]/[c]/page.tsx
new file mode 100644
index 0000000000..0be8dcd37c
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/[a]/[b]/[c]/page.tsx
@@ -0,0 +1,17 @@
+import Link from 'next/link'
+
+export default async function ConsecutiveDynamicPage(props: {
+  params: Promise<{ a: string; b: string; c: string }>
+}) {
+  const params = await props.params
+  return (
+    <div>
+      <div id="consecutive-page">
+        Path: {params.a}/{params.b}/{params.c}
+      </div>
+      <Link href={`/${params.a}/${params.b}/${params.c}/item`} id="item-link">
+        View Item
+      </Link>
+    </div>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/admin/dashboard/users/new/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/admin/dashboard/users/new/page.tsx
new file mode 100644
index 0000000000..5e7d34ffbf
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/admin/dashboard/users/new/page.tsx
@@ -0,0 +1,3 @@
+export default function NewUserPage() {
+  return <div id="new-user-page">New User Form</div>
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/admin/dashboard/users/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/admin/dashboard/users/page.tsx
new file mode 100644
index 0000000000..459d9c9018
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/admin/dashboard/users/page.tsx
@@ -0,0 +1,12 @@
+import Link from 'next/link'
+
+export default function UsersPage() {
+  return (
+    <div>
+      <div id="users-page">Admin Dashboard - Users</div>
+      <Link href="/admin/dashboard/users/new" id="new-user-link">
+        New User
+      </Link>
+    </div>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/default.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/default.tsx
new file mode 100644
index 0000000000..86b9e9a388
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/default.tsx
@@ -0,0 +1,3 @@
+export default function Default() {
+  return null
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/groups/[id]/new/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/groups/[id]/new/page.tsx
new file mode 100644
index 0000000000..30e3867169
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/groups/[id]/new/page.tsx
@@ -0,0 +1,6 @@
+export default async function NewItemPage(props: {
+  params: Promise<{ id: string }>
+}) {
+  const params = await props.params
+  return <div id="new-page">New item for group {params.id}</div>
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/groups/[id]/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/groups/[id]/page.tsx
new file mode 100644
index 0000000000..a4357329b5
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/groups/[id]/page.tsx
@@ -0,0 +1,15 @@
+import Link from 'next/link'
+
+export default async function GroupPage(props: {
+  params: Promise<{ id: string }>
+}) {
+  const params = await props.params
+  return (
+    <div>
+      <div id="group-page">Group {params.id}</div>
+      <Link href={`/groups/${params.id}/new`} id="new-link">
+        New Item
+      </Link>
+    </div>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/layout.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/layout.tsx
new file mode 100644
index 0000000000..5d9b38f583
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/layout.tsx
@@ -0,0 +1,17 @@
+import { Suspense } from 'react'
+
+export default function Layout(props: {
+  children: React.ReactNode
+  modal: React.ReactNode
+}) {
+  return (
+    <Suspense>
+      <html>
+        <body>
+          <div id="children">{props.children}</div>
+          <div id="modal">{props.modal}</div>
+        </body>
+      </html>
+    </Suspense>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/org/[orgId]/team/[teamId]/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/org/[orgId]/team/[teamId]/page.tsx
new file mode 100644
index 0000000000..e31c5e47f1
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/org/[orgId]/team/[teamId]/page.tsx
@@ -0,0 +1,20 @@
+import Link from 'next/link'
+
+export default async function TeamPage(props: {
+  params: Promise<{ orgId: string; teamId: string }>
+}) {
+  const params = await props.params
+  return (
+    <div>
+      <div id="team-page">
+        Team {params.teamId} in Org {params.orgId}
+      </div>
+      <Link
+        href={`/org/${params.orgId}/team/${params.teamId}/settings`}
+        id="settings-link"
+      >
+        Settings
+      </Link>
+    </div>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/org/[orgId]/team/[teamId]/settings/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/org/[orgId]/team/[teamId]/settings/page.tsx
new file mode 100644
index 0000000000..111866d608
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/org/[orgId]/team/[teamId]/settings/page.tsx
@@ -0,0 +1,10 @@
+export default async function TeamSettingsPage(props: {
+  params: Promise<{ orgId: string; teamId: string }>
+}) {
+  const params = await props.params
+  return (
+    <div id="settings-page">
+      Settings for Team {params.teamId} in Org {params.orgId}
+    </div>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/app/page.tsx b/test/e2e/app-dir/interception-dynamic-single-segment/app/page.tsx
new file mode 100644
index 0000000000..b358f7603e
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/app/page.tsx
@@ -0,0 +1,20 @@
+import Link from 'next/link'
+
+export default function Page() {
+  return (
+    <div>
+      <Link href="/groups/123" id="groups-link">
+        Group 123
+      </Link>{' '}
+      <Link href="/org/acme/team/engineering" id="team-link">
+        Team
+      </Link>{' '}
+      <Link href="/x/y/z" id="consecutive-link">
+        Consecutive
+      </Link>{' '}
+      <Link href="/admin/dashboard/users" id="admin-link">
+        Admin
+      </Link>
+    </div>
+  )
+}
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/interception-dynamic-single-segment.test.ts b/test/e2e/app-dir/interception-dynamic-single-segment/interception-dynamic-single-segment.test.ts
new file mode 100644
index 0000000000..035a2379f1
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/interception-dynamic-single-segment.test.ts
@@ -0,0 +1,302 @@
+import { nextTestSetup } from 'e2e-utils'
+import { retry } from 'next-test-utils'
+
+describe('interception-dynamic-single-segment', () => {
+  const { next } = nextTestSetup({
+    files: __dirname,
+  })
+
+  it('should intercept from nested route to deeper nested route with (.) modifier', async () => {
+    // This test covers the bug fix for same-level (.) interception
+    // where navigation from a nested route (e.g., /groups/123) to a deeper route
+    // (e.g., /groups/123/new) should trigger the modal interception.
+    //
+    // The bug was that the regex pattern used [^/]+ which only matched single segments,
+    // so interception failed when the source route had multiple segments like /groups/123
+    const browser = await next.browser('/groups/123')
+
+    // Verify we're on the group page
+    await retry(async () => {
+      const text = await browser.elementByCss('body').text()
+      expect(text).toContain('Group 123')
+      expect(text).toContain('New Item')
+    })
+
+    // Navigate from /groups/123 to /groups/123/new
+    // This should trigger the modal interception
+    await browser.elementById('new-link').click()
+
+    await retry(async () => {
+      const modalText = await browser.elementById('modal').text()
+      expect(modalText).toContain('Modal: New item for group 123')
+    })
+
+    // The children should still show the group page
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain('Group 123')
+    })
+
+    // Refresh to verify the full page renders (not intercepted)
+    await browser.refresh()
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain('New item for group 123')
+    })
+  })
+
+  it('should intercept from deeply nested route (4 segments) with (.) modifier', async () => {
+    // This test covers deeply nested routes with multiple dynamic segments
+    // Source: /org/acme/team/engineering (4 segments, 2 dynamic)
+    // Target: /org/acme/team/engineering/settings (5 segments)
+    //
+    // This ensures the regex fix (.+) handles very deep nesting correctly
+    const browser = await next.browser('/org/acme/team/engineering')
+
+    // Verify we're on the team page
+    await retry(async () => {
+      const text = await browser.elementByCss('body').text()
+      expect(text).toContain('Team engineering in Org acme')
+      expect(text).toContain('Settings')
+    })
+
+    // Navigate from /org/acme/team/engineering to /org/acme/team/engineering/settings
+    // This should trigger the modal interception
+    await browser.elementById('settings-link').click()
+
+    await retry(async () => {
+      const modalText = await browser.elementById('modal').text()
+      expect(modalText).toContain(
+        'Modal: Settings for Team engineering in Org acme'
+      )
+    })
+
+    // The children should still show the team page
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain('Team engineering in Org acme')
+    })
+
+    // Refresh to verify the full page renders (not intercepted)
+    await browser.refresh()
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain(
+        'Settings for Team engineering in Org acme'
+      )
+    })
+  })
+
+  it('should intercept with programmatic navigation using router.push', async () => {
+    // Test that interception works with programmatic navigation, not just Link clicks
+    // This ensures the NEXT_URL header is set correctly in all navigation scenarios
+    const browser = await next.browser('/groups/123')
+
+    // Verify we're on the group page
+    await retry(async () => {
+      const text = await browser.elementByCss('body').text()
+      expect(text).toContain('Group 123')
+    })
+
+    // Use router.push to navigate programmatically
+    await browser.eval('window.next.router.push("/groups/123/new")')
+
+    // Should trigger the modal interception
+    await retry(async () => {
+      const modalText = await browser.elementById('modal').text()
+      expect(modalText).toContain('Modal: New item for group')
+    })
+
+    // The children should still show the group page
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain('Group 123')
+    })
+  })
+
+  it('should intercept from nested route with query parameters', async () => {
+    // Test that interception works when the source route has query parameters
+    // The query params should not interfere with route matching
+    const browser = await next.browser('/groups/123?tab=settings&view=grid')
+
+    // Verify we're on the group page with query params
+    await retry(async () => {
+      const text = await browser.elementByCss('body').text()
+      expect(text).toContain('Group 123')
+      expect(text).toContain('New Item')
+    })
+
+    // Navigate to /groups/123/new (query params in source shouldn't affect interception)
+    await browser.elementById('new-link').click()
+
+    await retry(async () => {
+      const modalText = await browser.elementById('modal').text()
+      expect(modalText).toContain('Modal: New item for group')
+    })
+
+    // The children should still show the group page
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain('Group 123')
+    })
+  })
+
+  it('should intercept with consecutive dynamic segments', async () => {
+    // Test that interception works with consecutive dynamic segments [a]/[b]/[c]
+    // This is an edge case where there are no static segments between dynamics
+    // Source: /x/y/z (3 consecutive dynamic segments)
+    // Target: /x/y/z/item
+    const browser = await next.browser('/x/y/z')
+
+    // Verify we're on the consecutive dynamic page
+    await retry(async () => {
+      const text = await browser.elementByCss('body').text()
+      expect(text).toContain('Path: x/y/z')
+      expect(text).toContain('View Item')
+    })
+
+    // Navigate to /x/y/z/item
+    await browser.elementById('item-link').click()
+
+    await retry(async () => {
+      const modalText = await browser.elementById('modal').text()
+      expect(modalText).toContain('Modal: Item for path x/y/z')
+    })
+
+    // The children should still show the consecutive page
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain('Path: x/y/z')
+    })
+
+    // Refresh to verify the full page renders (not intercepted)
+    await browser.refresh()
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain('Item for path: x/y/z')
+    })
+  })
+
+  it('should intercept with purely static multi-segment paths', async () => {
+    // Test that interception works with static (non-dynamic) multi-segment paths
+    // This ensures the fix doesn't break static route interception
+    // Source: /admin/dashboard/users (3 static segments)
+    // Target: /admin/dashboard/users/new (4 static segments)
+    const browser = await next.browser('/admin/dashboard/users')
+
+    // Verify we're on the users page
+    await retry(async () => {
+      const text = await browser.elementByCss('body').text()
+      expect(text).toContain('Admin Dashboard - Users')
+      expect(text).toContain('New User')
+    })
+
+    // Navigate to /admin/dashboard/users/new
+    await browser.elementById('new-user-link').click()
+
+    await retry(async () => {
+      const modalText = await browser.elementById('modal').text()
+      expect(modalText).toContain('Modal: New User Form')
+    })
+
+    // The children should still show the users page
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain('Admin Dashboard - Users')
+    })
+
+    // Refresh to verify the full page renders (not intercepted)
+    await browser.refresh()
+    await retry(async () => {
+      const childrenText = await browser.elementById('children').text()
+      expect(childrenText).toContain('New User Form')
+    })
+  })
+
+  describe('nested navigation - descendants of intercepting route', () => {
+    // These tests verify the key bug fix: the regex pattern now matches
+    // all descendants of the intercepting route level, not just the exact level.
+    // Previously, navigation FROM a nested route (e.g., /groups/123/nested) would
+    // fail to trigger interception. Now it should work from any depth.
+    // NOTE: These are conceptual tests - actual nested pages would need to be created
+    // in the app directory structure to fully test this behavior in a real app.
+
+    it('should intercept when navigating from a child route using back navigation', async () => {
+      // Start at /groups/123, navigate to /groups/123/new (intercepted),
+      // then navigate away and back
+      const browser = await next.browser('/groups/123')
+
+      await retry(async () => {
+        const text = await browser.elementByCss('body').text()
+        expect(text).toContain('Group 123')
+      })
+
+      // First navigation - should intercept
+      await browser.elementById('new-link').click()
+      await retry(async () => {
+        const modalText = await browser.elementById('modal').text()
+        expect(modalText).toContain('Modal: New item for group')
+      })
+
+      // Navigate back
+      await browser.back()
+      await retry(async () => {
+        const text = await browser.elementByCss('body').text()
+        expect(text).toContain('Group 123')
+      })
+
+      // Navigate forward again - should still intercept
+      await browser.forward()
+      await retry(async () => {
+        const modalText = await browser.elementById('modal').text()
+        expect(modalText).toContain('Modal: New item for group')
+      })
+    })
+
+    it('should intercept multiple times from the same route', async () => {
+      // Test that interception works consistently on repeated navigation
+      const browser = await next.browser('/groups/456')
+
+      for (let i = 0; i < 3; i++) {
+        await browser.elementById('new-link').click()
+        await retry(async () => {
+          const modalText = await browser.elementById('modal').text()
+          expect(modalText).toContain('Modal: New item for group 456')
+        })
+
+        // Go back to test again
+        await browser.back()
+        await retry(async () => {
+          const text = await browser.elementByCss('body').text()
+          expect(text).toContain('Group 456')
+        })
+      }
+    })
+
+    it('should intercept when navigating between different dynamic segments', async () => {
+      // Test interception works across different dynamic route values
+      // First group
+      const browser1 = await next.browser('/groups/100')
+
+      await browser1.elementById('new-link').click()
+      await retry(async () => {
+        const modalText = await browser1.elementById('modal').text()
+        expect(modalText).toContain('Modal: New item for group 100')
+      })
+
+      // Second group - new browser instance to test fresh navigation
+      const browser2 = await next.browser('/groups/200')
+      await retry(async () => {
+        const text = await browser2.elementByCss('body').text()
+        expect(text).toContain('Group 200')
+      })
+
+      // Intercept from second group - should still work
+      await browser2.elementById('new-link').click()
+      await retry(async () => {
+        const modalText = await browser2.elementById('modal').text()
+        expect(modalText).toContain('Modal: New item for group 200')
+      })
+    })
+  })
+})
diff --git a/test/e2e/app-dir/interception-dynamic-single-segment/next.config.js b/test/e2e/app-dir/interception-dynamic-single-segment/next.config.js
new file mode 100644
index 0000000000..807126e4cf
--- /dev/null
+++ b/test/e2e/app-dir/interception-dynamic-single-segment/next.config.js
@@ -0,0 +1,6 @@
+/**
+ * @type {import('next').NextConfig}
+ */
+const nextConfig = {}
+
+module.exports = nextConfig
diff --git a/test/e2e/app-dir/interception-segments-two-levels-above/interception-segments-two-levels-above.test.ts b/test/e2e/app-dir/interception-segments-two-levels-above/interception-segments-two-levels-above.test.ts
index f1947675f8..d1f9667005 100644
--- a/test/e2e/app-dir/interception-segments-two-levels-above/interception-segments-two-levels-above.test.ts
+++ b/test/e2e/app-dir/interception-segments-two-levels-above/interception-segments-two-levels-above.test.ts
@@ -1,5 +1,5 @@
 import { nextTestSetup } from 'e2e-utils'
-import { check } from 'next-test-utils'
+import { retry } from 'next-test-utils'
 
 describe('interception-segments-two-levels-above', () => {
   const { next } = nextTestSetup({
@@ -10,6 +10,64 @@ describe('interception-segments-two-levels-above', () => {
     const browser = await next.browser('/foo/bar')
 
     await browser.elementByCss('[href="/hoge"]').click()
-    await check(() => browser.elementById('intercepted').text(), /intercepted/)
+    await retry(async () => {
+      expect(await browser.elementById('intercepted').text()).toMatch(
+        /intercepted/
+      )
+    })
+  })
+
+  it('should intercept consistently with back/forward navigation', async () => {
+    // Test that interception works correctly with browser back/forward
+    const browser = await next.browser('/foo/bar')
+
+    // Navigate with interception
+    await browser.elementByCss('[href="/hoge"]').click()
+    await retry(async () => {
+      expect(await browser.elementById('intercepted').text()).toMatch(
+        /intercepted/
+      )
+    })
+
+    // Go back
+    await browser.back()
+    await retry(async () => {
+      const url = await browser.url()
+      expect(url).toContain('/foo/bar')
+    })
+
+    // Go forward - should show the intercepted version again
+    await browser.forward()
+    await retry(async () => {
+      expect(await browser.elementById('intercepted').text()).toMatch(
+        /intercepted/
+      )
+    })
+  })
+
+  it('should intercept multiple times from same route', async () => {
+    // Test that repeated interception works
+    const browser = await next.browser('/foo/bar')
+
+    for (let i = 0; i < 2; i++) {
+      await retry(async () => {
+        await browser.elementByCss('[href="/hoge"]').click()
+      })
+
+      await retry(async () => {
+        expect(await browser.elementById('intercepted').text()).toMatch(
+          /intercepted/
+        )
+      })
+
+      await browser.back()
+
+      await retry(async () => {
+        const url = await browser.url()
+        expect(url).toContain('/foo/bar')
+
+        await browser.elementByCss('[href="/hoge"]')
+      })
+    }
   })
 })
