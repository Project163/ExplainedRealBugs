diff --git a/test/e2e/app-dir/require-context/app/grandparent/parent/file1.js b/test/e2e/app-dir/require-context/app/grandparent/parent/file1.js
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/e2e/app-dir/require-context/app/grandparent/parent/file2.js b/test/e2e/app-dir/require-context/app/grandparent/parent/file2.js
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/e2e/app-dir/require-context/app/grandparent/parent2/file3.js b/test/e2e/app-dir/require-context/app/grandparent/parent2/file3.js
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/e2e/app-dir/require-context/app/layout.tsx b/test/e2e/app-dir/require-context/app/layout.tsx
new file mode 100644
index 0000000000..888614deda
--- /dev/null
+++ b/test/e2e/app-dir/require-context/app/layout.tsx
@@ -0,0 +1,8 @@
+import { ReactNode } from 'react'
+export default function Root({ children }: { children: ReactNode }) {
+  return (
+    <html>
+      <body>{children}</body>
+    </html>
+  )
+}
diff --git a/test/e2e/app-dir/require-context/app/require-context-with-no-regex/page.tsx b/test/e2e/app-dir/require-context/app/require-context-with-no-regex/page.tsx
new file mode 100644
index 0000000000..0e50f897ab
--- /dev/null
+++ b/test/e2e/app-dir/require-context/app/require-context-with-no-regex/page.tsx
@@ -0,0 +1,4 @@
+export default function RequireContextWithNoRegex() {
+  const translationsContext = (require as any).context('../grandparent', true)
+  return <pre>{JSON.stringify(translationsContext.keys())}</pre>
+}
diff --git a/test/e2e/app-dir/require-context/app/require-context-with-regex/page.tsx b/test/e2e/app-dir/require-context/app/require-context-with-regex/page.tsx
new file mode 100644
index 0000000000..d7eb1d47da
--- /dev/null
+++ b/test/e2e/app-dir/require-context/app/require-context-with-regex/page.tsx
@@ -0,0 +1,9 @@
+export default function Home() {
+  const translationsContext = (require as any).context(
+    '../grandparent',
+    true,
+    /\.js/
+  )
+
+  return <pre>{JSON.stringify(translationsContext.keys())}</pre>
+}
diff --git a/test/e2e/app-dir/require-context/next.config.js b/test/e2e/app-dir/require-context/next.config.js
new file mode 100644
index 0000000000..807126e4cf
--- /dev/null
+++ b/test/e2e/app-dir/require-context/next.config.js
@@ -0,0 +1,6 @@
+/**
+ * @type {import('next').NextConfig}
+ */
+const nextConfig = {}
+
+module.exports = nextConfig
diff --git a/test/e2e/app-dir/require-context/require-context.test.ts b/test/e2e/app-dir/require-context/require-context.test.ts
new file mode 100644
index 0000000000..899e7880a1
--- /dev/null
+++ b/test/e2e/app-dir/require-context/require-context.test.ts
@@ -0,0 +1,34 @@
+import { nextTestSetup } from 'e2e-utils'
+
+describe('require-context', () => {
+  const { next } = nextTestSetup({
+    files: __dirname,
+  })
+
+  // Recommended for tests that check HTML. Cheerio is a HTML parser that has a jQuery like API.
+  it('should get correct require context when using regex filtering', async () => {
+    const $ = await next.render$('/require-context-with-regex')
+    expect($('pre').text()).toBe(
+      JSON.stringify([
+        './parent/file1.js',
+        './parent/file2.js',
+        './parent2/file3.js',
+      ])
+    )
+  })
+
+  // TODO: This test is already scaffolded and just needs to be turned on when turbopack supports it.
+  // it('should get correct require context when using no regex', async () => {
+  //   const $ = await next.render$('/require-context-with-no-regex')
+  //   expect($('pre').text()).toBe(
+  //     JSON.stringify([
+  //       './parent/file1',
+  //       './parent/file1.js',
+  //       './parent/file2',
+  //       './parent/file2.js',
+  //       './parent2/file3',
+  //       './parent2/file3.js',
+  //     ])
+  //   )
+  // })
+})
diff --git a/turbopack/crates/turbopack-ecmascript/src/references/require_context.rs b/turbopack/crates/turbopack-ecmascript/src/references/require_context.rs
index 2cc94776c3..653148996f 100644
--- a/turbopack/crates/turbopack-ecmascript/src/references/require_context.rs
+++ b/turbopack/crates/turbopack-ecmascript/src/references/require_context.rs
@@ -74,8 +74,9 @@ impl DirList {
         recursive: bool,
         filter: Vc<Regex>,
     ) -> Result<Vc<Self>> {
-        let root_val = &*dir.await?;
-        let regex = &*filter.await?;
+        let root_val = &root.await?;
+        let dir_val = &dir.await?;
+        let regex = &filter.await?;
 
         let mut list = FxIndexMap::default();
 
@@ -95,7 +96,7 @@ impl DirList {
                     }
                 }
                 DirectoryEntry::Directory(path) if recursive => {
-                    if let Some(relative_path) = root_val.get_relative_path_to(&*path.await?) {
+                    if let Some(relative_path) = dir_val.get_relative_path_to(&*path.await?) {
                         list.insert(
                             relative_path,
                             DirListEntry::Dir(
@@ -182,25 +183,25 @@ impl RequireContextMap {
         let mut map = FxIndexMap::default();
 
         for (context_relative, path) in list {
-            if let Some(origin_relative) = origin_path.get_relative_path_to(&*path.await?) {
-                let request = Request::parse(Value::new(origin_relative.clone().into()))
-                    .to_resolved()
-                    .await?;
-                let result = cjs_resolve(origin, *request, issue_source.clone(), is_optional)
-                    .to_resolved()
-                    .await?;
-
-                map.insert(
-                    context_relative.clone(),
-                    RequireContextMapEntry {
-                        origin_relative,
-                        request,
-                        result,
-                    },
-                );
-            } else {
+            let Some(origin_relative) = origin_path.get_relative_path_to(&*path.await?) else {
                 bail!("invariant error: this was already checked in `list_dir`");
-            }
+            };
+
+            let request = Request::parse(Value::new(origin_relative.clone().into()))
+                .to_resolved()
+                .await?;
+            let result = cjs_resolve(origin, *request, issue_source.clone(), is_optional)
+                .to_resolved()
+                .await?;
+
+            map.insert(
+                context_relative.clone(),
+                RequireContextMapEntry {
+                    origin_relative,
+                    request,
+                    result,
+                },
+            );
         }
 
         Ok(Vc::cell(map))
