diff --git a/crates/next-api/src/project.rs b/crates/next-api/src/project.rs
index 1147b1df2d..463e79210f 100644
--- a/crates/next-api/src/project.rs
+++ b/crates/next-api/src/project.rs
@@ -1082,13 +1082,11 @@ impl Project {
             no_mangling: self.no_mangling(),
             scope_hoisting: self.next_config().turbo_scope_hoisting(self.next_mode()),
             debug_ids: self.next_config().turbopack_debug_ids(),
+            client_root: self.client_relative_path().owned().await?,
+            asset_prefix: self.next_config().computed_asset_prefix().owned().await?,
         };
         Ok(if client_assets {
-            get_server_chunking_context_with_client_assets(
-                options,
-                self.client_relative_path().owned().await?,
-                self.next_config().computed_asset_prefix().owned().await?,
-            )
+            get_server_chunking_context_with_client_assets(options)
         } else {
             get_server_chunking_context(options)
         })
@@ -1111,13 +1109,11 @@ impl Project {
             turbo_source_maps: self.next_config().server_source_maps(),
             no_mangling: self.no_mangling(),
             scope_hoisting: self.next_config().turbo_scope_hoisting(self.next_mode()),
+            client_root: self.client_relative_path().owned().await?,
+            asset_prefix: self.next_config().computed_asset_prefix().owned().await?,
         };
         Ok(if client_assets {
-            get_edge_chunking_context_with_client_assets(
-                options,
-                self.client_relative_path().owned().await?,
-                self.next_config().computed_asset_prefix(),
-            )
+            get_edge_chunking_context_with_client_assets(options)
         } else {
             get_edge_chunking_context(options)
         })
diff --git a/crates/next-core/src/next_client/context.rs b/crates/next-core/src/next_client/context.rs
index 4099a7344c..fa5bbd1f27 100644
--- a/crates/next-core/src/next_client/context.rs
+++ b/crates/next-core/src/next_client/context.rs
@@ -417,7 +417,7 @@ pub struct ClientChunkingContextOptions {
     pub root_path: FileSystemPath,
     pub client_root: FileSystemPath,
     pub client_root_to_root_path: RcStr,
-    pub asset_prefix: Vc<Option<RcStr>>,
+    pub asset_prefix: Vc<RcStr>,
     pub chunk_suffix_path: Vc<Option<RcStr>>,
     pub environment: Vc<Environment>,
     pub module_id_strategy: Vc<Box<dyn ModuleIdStrategy>>,
@@ -463,7 +463,7 @@ pub async fn get_client_chunking_context(
         environment.to_resolved().await?,
         next_mode.runtime_type(),
     )
-    .chunk_base_path(asset_prefix.clone())
+    .chunk_base_path(Some(asset_prefix.clone()))
     .chunk_suffix_path(chunk_suffix_path)
     .minify_type(if *minify.await? {
         MinifyType::Minify {
@@ -477,7 +477,7 @@ pub async fn get_client_chunking_context(
     } else {
         SourceMapsType::None
     })
-    .asset_base_path(asset_prefix)
+    .asset_base_path(Some(asset_prefix))
     .current_chunk_method(CurrentChunkMethod::DocumentCurrentScript)
     .export_usage(*export_usage.await?)
     .module_id_strategy(module_id_strategy.to_resolved().await?)
diff --git a/crates/next-core/src/next_config.rs b/crates/next-core/src/next_config.rs
index 8fe3c4a08e..90e7f277ce 100644
--- a/crates/next-core/src/next_config.rs
+++ b/crates/next-core/src/next_config.rs
@@ -1672,10 +1672,10 @@ impl NextConfig {
     /// Returns the final asset prefix. If an assetPrefix is set, it's used.
     /// Otherwise, the basePath is used.
     #[turbo_tasks::function]
-    pub async fn computed_asset_prefix(self: Vc<Self>) -> Result<Vc<Option<RcStr>>> {
+    pub async fn computed_asset_prefix(self: Vc<Self>) -> Result<Vc<RcStr>> {
         let this = self.await?;
 
-        Ok(Vc::cell(Some(
+        Ok(Vc::cell(
             format!(
                 "{}/_next/",
                 if let Some(asset_prefix) = &this.asset_prefix {
@@ -1686,7 +1686,7 @@ impl NextConfig {
                 .trim_end_matches('/')
             )
             .into(),
-        )))
+        ))
     }
 
     /// Returns the suffix to use for chunk loading.
diff --git a/crates/next-core/src/next_edge/context.rs b/crates/next-core/src/next_edge/context.rs
index 20856b85d8..12342c2630 100644
--- a/crates/next-core/src/next_edge/context.rs
+++ b/crates/next-core/src/next_edge/context.rs
@@ -208,13 +208,14 @@ pub struct EdgeChunkingContextOptions {
     pub turbo_source_maps: Vc<bool>,
     pub no_mangling: Vc<bool>,
     pub scope_hoisting: Vc<bool>,
+    pub client_root: FileSystemPath,
+    pub asset_prefix: RcStr,
 }
 
+/// Like `get_edge_chunking_context` but all assets are emitted as client assets (so `/_next`)
 #[turbo_tasks::function]
 pub async fn get_edge_chunking_context_with_client_assets(
     options: EdgeChunkingContextOptions,
-    client_root: FileSystemPath,
-    asset_prefix: ResolvedVc<Option<RcStr>>,
 ) -> Result<Vc<Box<dyn ChunkingContext>>> {
     let EdgeChunkingContextOptions {
         mode,
@@ -228,6 +229,8 @@ pub async fn get_edge_chunking_context_with_client_assets(
         turbo_source_maps,
         no_mangling,
         scope_hoisting,
+        client_root,
+        asset_prefix,
     } = options;
     let output_root = node_root.join("server/edge")?;
     let next_mode = mode.await?;
@@ -241,7 +244,7 @@ pub async fn get_edge_chunking_context_with_client_assets(
         environment.to_resolved().await?,
         next_mode.runtime_type(),
     )
-    .asset_base_path(asset_prefix.owned().await?)
+    .asset_base_path(Some(asset_prefix))
     .minify_type(if *turbo_minify.await? {
         MinifyType::Minify {
             // React needs deterministic function names to work correctly.
@@ -280,6 +283,7 @@ pub async fn get_edge_chunking_context_with_client_assets(
     Ok(Vc::upcast(builder.build()))
 }
 
+// By default, assets are server assets, but the StructuredImageModuleType ones are on the client
 #[turbo_tasks::function]
 pub async fn get_edge_chunking_context(
     options: EdgeChunkingContextOptions,
@@ -296,6 +300,8 @@ pub async fn get_edge_chunking_context(
         turbo_source_maps,
         no_mangling,
         scope_hoisting,
+        client_root,
+        asset_prefix,
     } = options;
     let output_root = node_root.join("server/edge")?;
     let next_mode = mode.await?;
@@ -309,6 +315,9 @@ pub async fn get_edge_chunking_context(
         environment.to_resolved().await?,
         next_mode.runtime_type(),
     )
+    .client_roots_override(rcstr!("client"), client_root.clone())
+    .asset_root_path_override(rcstr!("client"), client_root.join("static/media")?)
+    .asset_base_path_override(rcstr!("client"), asset_prefix)
     // Since one can't read files in edge directly, any asset need to be fetched
     // instead. This special blob url is handled by the custom fetch
     // implementation in the edge sandbox. It will respond with the
diff --git a/crates/next-core/src/next_image/module.rs b/crates/next-core/src/next_image/module.rs
index 286748d733..81c0ad1f2e 100644
--- a/crates/next-core/src/next_image/module.rs
+++ b/crates/next-core/src/next_image/module.rs
@@ -56,7 +56,9 @@ impl StructuredImageModuleType {
         blur_placeholder_mode: BlurPlaceholderMode,
         module_asset_context: ResolvedVc<ModuleAssetContext>,
     ) -> Result<Vc<Box<dyn Module>>> {
-        let static_asset = StaticUrlJsModule::new(*source).to_resolved().await?;
+        let static_asset = StaticUrlJsModule::new(*source, Some(rcstr!("client")))
+            .to_resolved()
+            .await?;
         Ok(module_asset_context
             .process(
                 Vc::upcast(
diff --git a/crates/next-core/src/next_manifests/client_reference_manifest.rs b/crates/next-core/src/next_manifests/client_reference_manifest.rs
index 960ee9703d..52bb815721 100644
--- a/crates/next-core/src/next_manifests/client_reference_manifest.rs
+++ b/crates/next-core/src/next_manifests/client_reference_manifest.rs
@@ -165,11 +165,7 @@ async fn build_manifest(
         let mut entry_manifest: SerializedClientReferenceManifest = Default::default();
         let mut references = FxIndexSet::default();
         let chunk_suffix_path = next_config.chunk_suffix_path().owned().await?;
-        let prefix_path = next_config
-            .computed_asset_prefix()
-            .owned()
-            .await?
-            .unwrap_or_default();
+        let prefix_path = next_config.computed_asset_prefix().owned().await?;
         let suffix_path = chunk_suffix_path.unwrap_or_default();
 
         // TODO: Add `suffix` to the manifest for React to use.
diff --git a/crates/next-core/src/next_server/context.rs b/crates/next-core/src/next_server/context.rs
index 78234b8f8f..e1aef0c2c0 100644
--- a/crates/next-core/src/next_server/context.rs
+++ b/crates/next-core/src/next_server/context.rs
@@ -998,13 +998,14 @@ pub struct ServerChunkingContextOptions {
     pub no_mangling: Vc<bool>,
     pub scope_hoisting: Vc<bool>,
     pub debug_ids: Vc<bool>,
+    pub client_root: FileSystemPath,
+    pub asset_prefix: RcStr,
 }
 
+/// Like `get_server_chunking_context` but all assets are emitted as client assets (so `/_next`)
 #[turbo_tasks::function]
 pub async fn get_server_chunking_context_with_client_assets(
     options: ServerChunkingContextOptions,
-    client_root: FileSystemPath,
-    asset_prefix: Option<RcStr>,
 ) -> Result<Vc<NodeJsChunkingContext>> {
     let ServerChunkingContextOptions {
         mode,
@@ -1019,6 +1020,8 @@ pub async fn get_server_chunking_context_with_client_assets(
         no_mangling,
         scope_hoisting,
         debug_ids,
+        client_root,
+        asset_prefix,
     } = options;
 
     let next_mode = mode.await?;
@@ -1035,7 +1038,7 @@ pub async fn get_server_chunking_context_with_client_assets(
         environment.to_resolved().await?,
         next_mode.runtime_type(),
     )
-    .asset_prefix(asset_prefix)
+    .asset_prefix(Some(asset_prefix))
     .minify_type(if *turbo_minify.await? {
         MinifyType::Minify {
             // React needs deterministic function names to work correctly.
@@ -1080,6 +1083,7 @@ pub async fn get_server_chunking_context_with_client_assets(
     Ok(builder.build())
 }
 
+// By default, assets are server assets, but the StructuredImageModuleType ones are on the client
 #[turbo_tasks::function]
 pub async fn get_server_chunking_context(
     options: ServerChunkingContextOptions,
@@ -1097,6 +1101,8 @@ pub async fn get_server_chunking_context(
         no_mangling,
         scope_hoisting,
         debug_ids,
+        client_root,
+        asset_prefix,
     } = options;
     let next_mode = mode.await?;
     // TODO(alexkirsz) This should return a trait that can be implemented by the
@@ -1112,6 +1118,9 @@ pub async fn get_server_chunking_context(
         environment.to_resolved().await?,
         next_mode.runtime_type(),
     )
+    .client_roots_override(rcstr!("client"), client_root.clone())
+    .asset_root_path_override(rcstr!("client"), client_root.join("static/media")?)
+    .asset_prefix_override(rcstr!("client"), asset_prefix)
     .minify_type(if *turbo_minify.await? {
         MinifyType::Minify {
             mangle: (!*no_mangling.await?).then_some(MangleType::OptimalSize),
diff --git a/test/integration/url-imports/next.config.js b/test/e2e/url-imports/next.config.js
similarity index 100%
rename from test/integration/url-imports/next.config.js
rename to test/e2e/url-imports/next.config.js
diff --git a/test/integration/url-imports/source/value1.js b/test/e2e/url-imports/next.lock/data/http_localhost_12345/value1_d8c72f577995000e3fad.js
similarity index 100%
rename from test/integration/url-imports/source/value1.js
rename to test/e2e/url-imports/next.lock/data/http_localhost_12345/value1_d8c72f577995000e3fad.js
diff --git a/test/integration/url-imports/source/value2.js b/test/e2e/url-imports/next.lock/data/http_localhost_12345/value2_c78b9332f4998e489c87.js
similarity index 100%
rename from test/integration/url-imports/source/value2.js
rename to test/e2e/url-imports/next.lock/data/http_localhost_12345/value2_c78b9332f4998e489c87.js
diff --git a/test/integration/url-imports/source/value3.js b/test/e2e/url-imports/next.lock/data/http_localhost_12345/value3_206680f033f0d0f3b538.js
similarity index 100%
rename from test/integration/url-imports/source/value3.js
rename to test/e2e/url-imports/next.lock/data/http_localhost_12345/value3_206680f033f0d0f3b538.js
diff --git a/test/integration/url-imports/source/value4.js b/test/e2e/url-imports/next.lock/data/http_localhost_12345/value4_fcfa0c15487b3667cdfd.js
similarity index 100%
rename from test/integration/url-imports/source/value4.js
rename to test/e2e/url-imports/next.lock/data/http_localhost_12345/value4_fcfa0c15487b3667cdfd.js
diff --git a/test/e2e/url-imports/next.lock/lock.json b/test/e2e/url-imports/next.lock/lock.json
new file mode 100644
index 0000000000..0a99ed025e
--- /dev/null
+++ b/test/e2e/url-imports/next.lock/lock.json
@@ -0,0 +1,24 @@
+{
+  "http://localhost:12345/value1.js": {
+    "integrity": "sha512-S1eh3STyIGuRSfoAVU0jhxVY2MoRXSC/JduKMKuATb91ArhG0G2rvRNsGvD2kZo/jENlbrMtWNkzK2dGLgaUfg==",
+    "contentType": "application/javascript; charset=UTF-8"
+  },
+  "http://localhost:12345/value2.js": {
+    "integrity": "sha512-R4XoB/ZTbRL9FGcM5d3hkxtxmMUXaKNKCqRKZPDy1v7Hh61HPLidPQHga1XMurakZPoJnCC5a5jRdOAagn3LRA==",
+    "contentType": "application/javascript; charset=UTF-8"
+  },
+  "http://localhost:12345/value3.js": {
+    "integrity": "sha512-xtYaDPwejlXaMwQOdnYldln3wA5UYqIaJXMuCdBmyjgRX3zSKKd/AbGYobURfITmpzkz7U7E5GEK2Ju17qCZkw==",
+    "contentType": "application/javascript; charset=UTF-8"
+  },
+  "http://localhost:12345/value4.js": {
+    "integrity": "sha512-orh6tVnh1jjxWNNLduiv0pUcW0guzwTmy52JQGdz4D2LL2IgIlJaC0w4+YBtIBXa2kKGho839WgGAK0sC0Folw==",
+    "contentType": "application/javascript; charset=UTF-8"
+  },
+  "https://github.com/vercel/next.js/raw/canary/test/integration/url/public/vercel.png": "no-cache",
+  "https://github.com/vercel/next.js/raw/canary/test/integration/url/public/vercel.png?_=image": "no-cache",
+  "https://github.com/vercel/next.js/raw/canary/test/integration/url/public/vercel.png?_=ssg": "no-cache",
+  "https://github.com/vercel/next.js/raw/canary/test/integration/url/public/vercel.png?_=ssr": "no-cache",
+  "https://github.com/vercel/next.js/raw/canary/test/integration/url/public/vercel.png?_=static": "no-cache",
+  "version": 1
+}
diff --git a/test/integration/url-imports/pages/api/value.js b/test/e2e/url-imports/pages/api/value.js
similarity index 100%
rename from test/integration/url-imports/pages/api/value.js
rename to test/e2e/url-imports/pages/api/value.js
diff --git a/test/integration/url-imports/pages/css.js b/test/e2e/url-imports/pages/css.js
similarity index 100%
rename from test/integration/url-imports/pages/css.js
rename to test/e2e/url-imports/pages/css.js
diff --git a/test/integration/url-imports/pages/css.module.css b/test/e2e/url-imports/pages/css.module.css
similarity index 100%
rename from test/integration/url-imports/pages/css.module.css
rename to test/e2e/url-imports/pages/css.module.css
diff --git a/test/integration/url-imports/pages/image.js b/test/e2e/url-imports/pages/image.js
similarity index 100%
rename from test/integration/url-imports/pages/image.js
rename to test/e2e/url-imports/pages/image.js
diff --git a/test/integration/url-imports/pages/ssg.js b/test/e2e/url-imports/pages/ssg.js
similarity index 100%
rename from test/integration/url-imports/pages/ssg.js
rename to test/e2e/url-imports/pages/ssg.js
diff --git a/test/integration/url-imports/pages/ssr.js b/test/e2e/url-imports/pages/ssr.js
similarity index 100%
rename from test/integration/url-imports/pages/ssr.js
rename to test/e2e/url-imports/pages/ssr.js
diff --git a/test/integration/url-imports/pages/static.js b/test/e2e/url-imports/pages/static.js
similarity index 100%
rename from test/integration/url-imports/pages/static.js
rename to test/e2e/url-imports/pages/static.js
diff --git a/test/integration/url-imports/public/vercel.png b/test/e2e/url-imports/public/vercel.png
similarity index 100%
rename from test/integration/url-imports/public/vercel.png
rename to test/e2e/url-imports/public/vercel.png
diff --git a/test/e2e/url-imports/source/value1.js b/test/e2e/url-imports/source/value1.js
new file mode 100644
index 0000000000..a9334acdeb
--- /dev/null
+++ b/test/e2e/url-imports/source/value1.js
@@ -0,0 +1 @@
+export default 42 // 1
diff --git a/test/e2e/url-imports/source/value2.js b/test/e2e/url-imports/source/value2.js
new file mode 100644
index 0000000000..806efcbdf1
--- /dev/null
+++ b/test/e2e/url-imports/source/value2.js
@@ -0,0 +1 @@
+export default 42 // 2
diff --git a/test/e2e/url-imports/source/value3.js b/test/e2e/url-imports/source/value3.js
new file mode 100644
index 0000000000..6ab694c37a
--- /dev/null
+++ b/test/e2e/url-imports/source/value3.js
@@ -0,0 +1 @@
+export default 42 // 3
diff --git a/test/e2e/url-imports/source/value4.js b/test/e2e/url-imports/source/value4.js
new file mode 100644
index 0000000000..1295372d0b
--- /dev/null
+++ b/test/e2e/url-imports/source/value4.js
@@ -0,0 +1 @@
+export default 42 // 4
diff --git a/test/e2e/url-imports/url-imports.test.ts b/test/e2e/url-imports/url-imports.test.ts
new file mode 100644
index 0000000000..e25079194f
--- /dev/null
+++ b/test/e2e/url-imports/url-imports.test.ts
@@ -0,0 +1,100 @@
+import {
+  getBrowserBodyText,
+  startStaticServer,
+  stopApp,
+  retry,
+} from 'next-test-utils'
+import { FileRef, nextTestSetup, isNextDev } from 'e2e-utils'
+import { join } from 'path'
+
+// experimental.urlImports is not implemented in Turbopack
+;(process.env.IS_TURBOPACK_TEST ? describe.skip : describe)(
+  `Handle url imports`,
+  () => {
+    let staticServer
+    let staticServerPort
+    beforeAll(async () => {
+      staticServerPort = 12345
+      staticServer = await startStaticServer(
+        join(__dirname, 'source'),
+        undefined,
+        staticServerPort
+      )
+    })
+    afterAll(async () => {
+      await stopApp(staticServer)
+    })
+
+    const { next, skipped } = nextTestSetup({
+      files: isNextDev
+        ? {
+            // exclude next.lock here, should be generated automatically in dev
+            'next.config.js': new FileRef(join(__dirname, 'next.config.js')),
+            pages: new FileRef(join(__dirname, 'pages')),
+            public: new FileRef(join(__dirname, 'public')),
+          }
+        : __dirname,
+      // The staticServer above doesn't work when deployed
+      skipDeployment: true,
+    })
+
+    if (skipped) {
+      return
+    }
+
+    const expectedServer =
+      /Hello <!-- -->42<!-- -->\+<!-- -->42<!-- -->\+<!-- -->\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png<!-- -->\+<!-- -->\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png/
+    const expectedClient = new RegExp(
+      expectedServer.source.replace(/<!-- -->/g, '')
+    )
+
+    for (const page of ['/static', '/ssr', '/ssg']) {
+      it(`should render the ${page} page`, async () => {
+        const html = await next.render(page)
+        expect(html).toMatch(expectedServer)
+      })
+
+      it(`should client-render the ${page} page`, async () => {
+        const browser = await next.browser(page)
+        await retry(async () =>
+          expect(await getBrowserBodyText(browser)).toMatch(expectedClient)
+        )
+      })
+    }
+
+    it(`should render a static url image import`, async () => {
+      const browser = await next.browser('/image')
+      await browser.waitForElementByCss('#static-image')
+      await retry(async () =>
+        expect(
+          await browser.elementByCss('#static-image').getAttribute('src')
+        ).toMatch(
+          /^\/_next\/image\?url=%2F_next%2Fstatic%2Fmedia%2Fvercel\.[0-9a-f]{8}\.png&/
+        )
+      )
+    })
+
+    it(`should allow url import in css`, async () => {
+      const browser = await next.browser('/css')
+
+      await browser.waitForElementByCss('#static-css')
+      await retry(async () =>
+        expect(
+          await browser
+            .elementByCss('#static-css')
+            .getComputedCss('background-image')
+        ).toMatch(
+          /^url\("http(s)?:\/\/.+\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png"\)$/
+        )
+      )
+    })
+
+    it('should respond on value api', async () => {
+      const data = await next
+        .fetch('/api/value')
+        .then((res) => res.ok && res.json())
+
+      expect(data).toEqual({ value: 42 })
+    })
+  }
+)
diff --git a/test/e2e/url/app/api/edge/route.js b/test/e2e/url/app/api/edge/route.js
new file mode 100644
index 0000000000..c105ed9d4e
--- /dev/null
+++ b/test/e2e/url/app/api/edge/route.js
@@ -0,0 +1,8 @@
+import imported from '../../../public/vercel.png'
+const url = new URL('../../../public/vercel.png', import.meta.url).toString()
+
+export function GET(req, res) {
+  return Response.json({ imported, url })
+}
+
+export const runtime = 'edge'
diff --git a/test/e2e/url/app/api/route.js b/test/e2e/url/app/api/route.js
new file mode 100644
index 0000000000..8e7a6b6dfd
--- /dev/null
+++ b/test/e2e/url/app/api/route.js
@@ -0,0 +1,6 @@
+import imported from '../../public/vercel.png'
+const url = new URL('../../public/vercel.png', import.meta.url).toString()
+
+export function GET(req, res) {
+  return Response.json({ imported, url })
+}
diff --git a/test/e2e/url/app/client-edge/page.js b/test/e2e/url/app/client-edge/page.js
new file mode 100644
index 0000000000..8b5aea8a1e
--- /dev/null
+++ b/test/e2e/url/app/client-edge/page.js
@@ -0,0 +1,14 @@
+'use client'
+
+import imported from '../../public/vercel.png'
+const url = new URL('../../public/vercel.png', import.meta.url).toString()
+
+export default function Index(props) {
+  return (
+    <main>
+      Hello {imported.src}+{url}
+    </main>
+  )
+}
+
+export const runtime = 'edge'
diff --git a/test/e2e/url/app/client/page.js b/test/e2e/url/app/client/page.js
new file mode 100644
index 0000000000..810acb9585
--- /dev/null
+++ b/test/e2e/url/app/client/page.js
@@ -0,0 +1,12 @@
+'use client'
+
+import imported from '../../public/vercel.png'
+const url = new URL('../../public/vercel.png', import.meta.url).toString()
+
+export default function Index(props) {
+  return (
+    <main>
+      Hello {imported.src}+{url}
+    </main>
+  )
+}
diff --git a/test/e2e/url/app/layout.js b/test/e2e/url/app/layout.js
new file mode 100644
index 0000000000..4ee00a2185
--- /dev/null
+++ b/test/e2e/url/app/layout.js
@@ -0,0 +1,7 @@
+export default function RootLayout({ children }) {
+  return (
+    <html lang="en">
+      <body>{children}</body>
+    </html>
+  )
+}
diff --git a/test/e2e/url/app/manifest.js b/test/e2e/url/app/manifest.js
new file mode 100644
index 0000000000..b19203108f
--- /dev/null
+++ b/test/e2e/url/app/manifest.js
@@ -0,0 +1,17 @@
+import icon from '../public/vercel.png'
+const url = new URL('../public/vercel.png', import.meta.url).toString()
+
+export default function manifest() {
+  return {
+    short_name: 'Next.js',
+    name: 'Next.js',
+    icons: [
+      {
+        src: icon.src,
+        type: 'image/png',
+        sizes: '512x512',
+      },
+    ],
+    description: url,
+  }
+}
diff --git a/test/e2e/url/app/opengraph-image.js b/test/e2e/url/app/opengraph-image.js
new file mode 100644
index 0000000000..07cd809ad1
--- /dev/null
+++ b/test/e2e/url/app/opengraph-image.js
@@ -0,0 +1,9 @@
+import imported from '../public/vercel.png'
+const url = new URL('../public/vercel.png', import.meta.url).toString()
+
+export const contentType = 'text/json'
+
+// Image generation
+export default async function Image() {
+  return Response.json({ imported, url })
+}
diff --git a/test/e2e/url/app/rsc-edge/page.js b/test/e2e/url/app/rsc-edge/page.js
new file mode 100644
index 0000000000..b673e2eb62
--- /dev/null
+++ b/test/e2e/url/app/rsc-edge/page.js
@@ -0,0 +1,12 @@
+import imported from '../../public/vercel.png'
+const url = new URL('../../public/vercel.png', import.meta.url).toString()
+
+export default function Index(props) {
+  return (
+    <main>
+      Hello {imported.src}+{url}
+    </main>
+  )
+}
+
+export const runtime = 'edge'
diff --git a/test/e2e/url/app/rsc/page.js b/test/e2e/url/app/rsc/page.js
new file mode 100644
index 0000000000..ce35c94a1e
--- /dev/null
+++ b/test/e2e/url/app/rsc/page.js
@@ -0,0 +1,10 @@
+import imported from '../../public/vercel.png'
+const url = new URL('../../public/vercel.png', import.meta.url).toString()
+
+export default function Index(props) {
+  return (
+    <main>
+      Hello {imported.src}+{url}
+    </main>
+  )
+}
diff --git a/test/e2e/url/middleware.ts b/test/e2e/url/middleware.ts
new file mode 100644
index 0000000000..1d87d3d5bb
--- /dev/null
+++ b/test/e2e/url/middleware.ts
@@ -0,0 +1,13 @@
+import { NextRequest, NextResponse } from 'next/server'
+
+// @ts-ignore
+import imported from './public/vercel.png'
+const url = new URL('./public/vercel.png', import.meta.url).toString()
+
+export async function middleware(req: NextRequest) {
+  if (req.nextUrl.toString().endsWith('/middleware')) {
+    return Response.json({ imported, url })
+  }
+
+  return NextResponse.next()
+}
diff --git a/test/e2e/url/pages/api/pages-edge/index.js b/test/e2e/url/pages/api/pages-edge/index.js
new file mode 100644
index 0000000000..d124c191ac
--- /dev/null
+++ b/test/e2e/url/pages/api/pages-edge/index.js
@@ -0,0 +1,13 @@
+import imported from '../../../public/vercel.png'
+const url = new URL('../../../public/vercel.png', import.meta.url)
+
+export default (req, res) => {
+  return new Response(
+    JSON.stringify({
+      imported,
+      url: url.toString(),
+    })
+  )
+}
+
+export const runtime = 'experimental-edge'
diff --git a/test/e2e/url/pages/api/pages/index.js b/test/e2e/url/pages/api/pages/index.js
new file mode 100644
index 0000000000..6e1a9c032b
--- /dev/null
+++ b/test/e2e/url/pages/api/pages/index.js
@@ -0,0 +1,19 @@
+import fs from 'fs'
+
+import imported from '../../../public/vercel.png'
+const url = new URL('../../../public/vercel.png', import.meta.url)
+
+export default (req, res) => {
+  let size
+  try {
+    size = fs.readFileSync(url).length
+  } catch (e) {
+    size = e.message
+  }
+
+  res.send({
+    imported,
+    url: url.toString(),
+    size,
+  })
+}
diff --git a/test/e2e/url/pages/pages-edge/ssr.js b/test/e2e/url/pages/pages-edge/ssr.js
new file mode 100644
index 0000000000..de5792607d
--- /dev/null
+++ b/test/e2e/url/pages/pages-edge/ssr.js
@@ -0,0 +1,20 @@
+import imported from '../../public/vercel.png'
+
+export function getServerSideProps() {
+  return {
+    props: {
+      url: new URL('../../public/vercel.png', import.meta.url).toString(),
+    },
+  }
+}
+
+export default function Index({ url }) {
+  return (
+    <main>
+      Hello {imported.src}+
+      {new URL('../../public/vercel.png', import.meta.url).toString()}+{url}
+    </main>
+  )
+}
+
+export const runtime = 'experimental-edge'
diff --git a/test/e2e/url/pages/pages-edge/static.js b/test/e2e/url/pages/pages-edge/static.js
new file mode 100644
index 0000000000..de324501b4
--- /dev/null
+++ b/test/e2e/url/pages/pages-edge/static.js
@@ -0,0 +1,12 @@
+import imported from '../../public/vercel.png'
+const url = new URL('../../public/vercel.png', import.meta.url).toString()
+
+export default function Index(props) {
+  return (
+    <main>
+      Hello {imported.src}+{url}
+    </main>
+  )
+}
+
+export const runtime = 'experimental-edge'
diff --git a/test/e2e/url/pages/pages/ssg.js b/test/e2e/url/pages/pages/ssg.js
new file mode 100644
index 0000000000..fe8d852cca
--- /dev/null
+++ b/test/e2e/url/pages/pages/ssg.js
@@ -0,0 +1,18 @@
+import imported from '../../public/vercel.png'
+
+export async function getStaticProps() {
+  return {
+    props: {
+      url: new URL('../../public/vercel.png', import.meta.url).toString(),
+    },
+  }
+}
+
+export default function Index({ url }) {
+  return (
+    <main>
+      Hello {imported.src}+
+      {new URL('../../public/vercel.png', import.meta.url).toString()}+{url}
+    </main>
+  )
+}
diff --git a/test/e2e/url/pages/pages/ssr.js b/test/e2e/url/pages/pages/ssr.js
new file mode 100644
index 0000000000..ca2572a4b8
--- /dev/null
+++ b/test/e2e/url/pages/pages/ssr.js
@@ -0,0 +1,18 @@
+import imported from '../../public/vercel.png'
+
+export function getServerSideProps() {
+  return {
+    props: {
+      url: new URL('../../public/vercel.png', import.meta.url).toString(),
+    },
+  }
+}
+
+export default function Index({ url }) {
+  return (
+    <main>
+      Hello {imported.src}+
+      {new URL('../../public/vercel.png', import.meta.url).toString()}+{url}
+    </main>
+  )
+}
diff --git a/test/e2e/url/pages/pages/static.js b/test/e2e/url/pages/pages/static.js
new file mode 100644
index 0000000000..ce35c94a1e
--- /dev/null
+++ b/test/e2e/url/pages/pages/static.js
@@ -0,0 +1,10 @@
+import imported from '../../public/vercel.png'
+const url = new URL('../../public/vercel.png', import.meta.url).toString()
+
+export default function Index(props) {
+  return (
+    <main>
+      Hello {imported.src}+{url}
+    </main>
+  )
+}
diff --git a/test/integration/url/public/vercel.png b/test/e2e/url/public/vercel.png
similarity index 100%
rename from test/integration/url/public/vercel.png
rename to test/e2e/url/public/vercel.png
diff --git a/test/e2e/url/url.test.ts b/test/e2e/url/url.test.ts
new file mode 100644
index 0000000000..a89ead35b2
--- /dev/null
+++ b/test/e2e/url/url.test.ts
@@ -0,0 +1,188 @@
+import { retry } from 'next-test-utils'
+import { nextTestSetup } from 'e2e-utils'
+
+// |         | Pages Client            | Pages Server (SSR,RSC)  | API Routes/Middleware/Metadata |
+// |---------|-------------------------|-------------------------|--------------------------------|
+// | new URL | /_next/static/media/... | /_next/static/media/... | /server/assets/...             |
+// | import  | /_next/static/media/... | /_next/static/media/... | /_next/static/media/...        |
+// |---------|-------------------------|-------------------------|--------------------------------|
+//
+// Webpack has
+// - a bug where App Router API routes (and Metadata) return client assets for `new URL`s.
+// - a bug where Edge Page routes return client assets for `new URL`s.
+describe(`Handle new URL asset references`, () => {
+  const { next, skipped } = nextTestSetup({
+    files: __dirname,
+    // Workaround for `Error: invariant: htmlFsRef != null && jsonFsRef != null /ssg` errors
+    skipDeployment: true,
+  })
+
+  if (skipped) {
+    return
+  }
+
+  const serverFilePath = expect.stringMatching(
+    /file:.*\/.next(\/dev)?\/server\/.*\/vercel\.[0-9a-f]{8}\.png$/
+  )
+  const serverEdgeUrl = expect.stringMatching(
+    /^blob:.*vercel\.[0-9a-f]{8,}\.png$/
+  )
+  const clientFilePath = expect.stringMatching(
+    /^\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png$/
+  )
+
+  it('should respond on middleware api', async () => {
+    const data = await next
+      .fetch('/middleware')
+      .then((res) => res.ok && res.json())
+
+    expect(data).toEqual({
+      imported: expect.objectContaining({
+        src: clientFilePath,
+      }),
+      url: serverEdgeUrl,
+    })
+  })
+
+  const expectedPage =
+    /^Hello \/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png(\+\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png(\+\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png)?)?$/
+
+  describe('app router', () => {
+    it('should respond on webmanifest', async () => {
+      const data = await next
+        .fetch('/manifest.webmanifest')
+        .then((res) => res.ok && res.json())
+
+      expect(data).toEqual({
+        short_name: 'Next.js',
+        name: 'Next.js',
+        icons: [
+          {
+            src: clientFilePath,
+            type: 'image/png',
+            sizes: '512x512',
+          },
+        ],
+        // TODO Webpack bug?
+        description: process.env.IS_TURBOPACK_TEST
+          ? serverFilePath
+          : clientFilePath,
+      })
+    })
+
+    it('should respond on opengraph-image', async () => {
+      const data = await next
+        .fetch('/opengraph-image')
+        .then((res) => res.ok && res.json())
+
+      expect(data).toEqual({
+        imported: expect.objectContaining({
+          src: clientFilePath,
+        }),
+        // TODO Webpack bug?
+        url: process.env.IS_TURBOPACK_TEST ? serverFilePath : clientFilePath,
+      })
+    })
+
+    for (const page of ['/rsc', '/rsc-edge', '/client', '/client-edge']) {
+      // TODO Webpack bug?
+      let shouldSkip = process.env.IS_TURBOPACK_TEST
+        ? false
+        : page.includes('edge')
+
+      ;(shouldSkip ? it.skip : it)(
+        `should render the ${page} page`,
+        async () => {
+          const $ = await next.render$(page)
+          // eslint-disable-next-line jest/no-standalone-expect
+          expect($('main').text()).toMatch(expectedPage)
+        }
+      )
+      ;(shouldSkip ? it.skip : it)(
+        `should client-render the ${page} page`,
+        async () => {
+          const browser = await next.browser(page)
+          await retry(async () =>
+            expect(await browser.elementByCss('main').text()).toMatch(
+              expectedPage
+            )
+          )
+        }
+      )
+    }
+
+    it('should respond on API', async () => {
+      const data = await next.fetch('/api').then((res) => res.ok && res.json())
+
+      expect(data).toEqual({
+        imported: expect.objectContaining({
+          src: clientFilePath,
+        }),
+        // TODO Webpack bug?
+        url: process.env.IS_TURBOPACK_TEST ? serverFilePath : clientFilePath,
+      })
+    })
+  })
+
+  describe('pages router', () => {
+    for (const page of [
+      '/pages/static',
+      '/pages/ssr',
+      '/pages/ssg',
+      '/pages-edge/static',
+      '/pages-edge/ssr',
+    ]) {
+      // TODO Webpack bug?
+      let shouldSkip = process.env.IS_TURBOPACK_TEST
+        ? false
+        : page.includes('edge')
+
+      ;(shouldSkip ? it.skip : it)(
+        `should render the ${page} page`,
+        async () => {
+          const $ = await next.render$(page)
+          // eslint-disable-next-line jest/no-standalone-expect
+          expect($('main').text()).toMatch(expectedPage)
+        }
+      )
+      ;(shouldSkip ? it.skip : it)(
+        `should client-render the ${page} page`,
+        async () => {
+          const browser = await next.browser(page)
+          await retry(async () =>
+            expect(await browser.elementByCss('main').text()).toMatch(
+              expectedPage
+            )
+          )
+        }
+      )
+    }
+
+    it('should respond on API', async () => {
+      const data = await next
+        .fetch('/api/pages/')
+        .then((res) => res.ok && res.json())
+
+      expect(data).toEqual({
+        imported: expect.objectContaining({
+          src: clientFilePath,
+        }),
+        url: serverFilePath,
+        size: 30079,
+      })
+    })
+
+    it('should respond on edge API', async () => {
+      const data = await next
+        .fetch('/api/pages-edge/')
+        .then((res) => res.ok && res.json())
+
+      expect(data).toEqual({
+        imported: expect.objectContaining({
+          src: clientFilePath,
+        }),
+        url: serverEdgeUrl,
+      })
+    })
+  })
+})
diff --git a/test/experimental-tests-manifest.json b/test/experimental-tests-manifest.json
index 4d09bbd1c4..217867659c 100644
--- a/test/experimental-tests-manifest.json
+++ b/test/experimental-tests-manifest.json
@@ -332,6 +332,7 @@
       "test/e2e/switchable-runtime/index.test.ts",
       "test/e2e/testmode/testmode.test.ts",
       "test/e2e/use-link-status/index.test.ts",
+      "test/e2e/url/url.test.ts",
       "test/integration/app-dir-export/**/*",
       "test/integration/app-dynamic-error/test/index.test.ts",
       "test/integration/app-types/app-types.test.js",
diff --git a/test/integration/url-imports/.gitignore b/test/integration/url-imports/.gitignore
deleted file mode 100644
index 3d389aacfc..0000000000
--- a/test/integration/url-imports/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-# this is only needed for the test case
-# Do not ignore that in real apps
-next.lock
\ No newline at end of file
diff --git a/test/integration/url-imports/test/index.test.js b/test/integration/url-imports/test/index.test.js
deleted file mode 100644
index c8015dd8a7..0000000000
--- a/test/integration/url-imports/test/index.test.js
+++ /dev/null
@@ -1,125 +0,0 @@
-/* eslint-disable no-loop-func */
-/* eslint-env jest */
-
-import fs from 'fs-extra'
-import { join } from 'path'
-import {
-  nextBuild,
-  findPort,
-  nextStart,
-  killApp,
-  renderViaHTTP,
-  fetchViaHTTP,
-  launchApp,
-  getBrowserBodyText,
-  check,
-  startStaticServer,
-  stopApp,
-} from 'next-test-utils'
-import webdriver from 'next-webdriver'
-
-jest.setTimeout(1000 * 60 * 2)
-const appDir = join(__dirname, '../')
-
-// experimental.urlImports is not implemented in Turbopack
-;(process.env.IS_TURBOPACK_TEST ? describe.skip : describe)(
-  `Handle url imports`,
-  () => {
-    let staticServer
-    let staticServerPort
-    beforeAll(async () => {
-      await fs.remove(join(appDir, 'next.lock'))
-      staticServerPort = 12345
-      staticServer = await startStaticServer(
-        join(appDir, 'source'),
-        undefined,
-        staticServerPort
-      )
-    })
-    afterAll(async () => {
-      await stopApp(staticServer)
-    })
-
-    for (const dev of [true, false]) {
-      describe(dev ? 'with next dev' : 'with next build', () => {
-        let appPort
-        let app
-        beforeAll(async () => {
-          await fs.remove(join(appDir, '.next'))
-          if (dev) {
-            appPort = await findPort()
-            app = await launchApp(appDir, appPort)
-          } else {
-            await nextBuild(appDir)
-            appPort = await findPort()
-            app = await nextStart(appDir, appPort)
-          }
-        })
-        afterAll(async () => {
-          await killApp(app)
-        })
-        const expectedServer =
-          /Hello <!-- -->42<!-- -->\+<!-- -->42<!-- -->\+<!-- -->\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png<!-- -->\+<!-- -->\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png/
-        const expectedClient = new RegExp(
-          expectedServer.source.replace(/<!-- -->/g, '')
-        )
-
-        for (const page of ['/static', '/ssr', '/ssg']) {
-          it(`should render the ${page} page`, async () => {
-            const html = await renderViaHTTP(appPort, page)
-            expect(html).toMatch(expectedServer)
-          })
-
-          it(`should client-render the ${page} page`, async () => {
-            let browser
-            try {
-              browser = await webdriver(appPort, page)
-              await check(() => getBrowserBodyText(browser), expectedClient)
-            } finally {
-              await browser.close()
-            }
-          })
-        }
-
-        it(`should render a static url image import`, async () => {
-          let browser
-          try {
-            browser = await webdriver(appPort, '/image')
-            await browser.waitForElementByCss('#static-image')
-            await check(
-              () => browser.elementByCss('#static-image').getAttribute('src'),
-              /^\/_next\/image\?url=%2F_next%2Fstatic%2Fmedia%2Fvercel\.[0-9a-f]{8}\.png&/
-            )
-          } finally {
-            await browser.close()
-          }
-        })
-
-        it(`should allow url import in css`, async () => {
-          let browser
-          try {
-            browser = await webdriver(appPort, '/css')
-            await browser.waitForElementByCss('#static-css')
-            await check(
-              () =>
-                browser
-                  .elementByCss('#static-css')
-                  .getComputedCss('background-image'),
-              /^url\("http:\/\/localhost:\d+\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png"\)$/
-            )
-          } finally {
-            await browser.close()
-          }
-        })
-
-        it('should respond on value api', async () => {
-          const data = await fetchViaHTTP(appPort, '/api/value').then(
-            (res) => res.ok && res.json()
-          )
-
-          expect(data).toEqual({ value: 42 })
-        })
-      })
-    }
-  }
-)
diff --git a/test/integration/url/pages/api/basename.js b/test/integration/url/pages/api/basename.js
deleted file mode 100644
index 0109c99b7b..0000000000
--- a/test/integration/url/pages/api/basename.js
+++ /dev/null
@@ -1,7 +0,0 @@
-import path from 'path'
-
-const img = new URL('../../public/vercel.png', import.meta.url)
-
-export default (req, res) => {
-  res.json({ basename: path.posix.basename(img.pathname) })
-}
diff --git a/test/integration/url/pages/api/size.js b/test/integration/url/pages/api/size.js
deleted file mode 100644
index 7649a0bcb1..0000000000
--- a/test/integration/url/pages/api/size.js
+++ /dev/null
@@ -1,7 +0,0 @@
-import fs from 'fs'
-
-const img = new URL('../../public/vercel.png', import.meta.url)
-
-export default (req, res) => {
-  res.json({ size: fs.readFileSync(img).length })
-}
diff --git a/test/integration/url/pages/ssg.js b/test/integration/url/pages/ssg.js
deleted file mode 100644
index 113f47c565..0000000000
--- a/test/integration/url/pages/ssg.js
+++ /dev/null
@@ -1,15 +0,0 @@
-export async function getStaticProps() {
-  return {
-    props: {
-      url: new URL('../public/vercel.png', import.meta.url).pathname,
-    },
-  }
-}
-
-export default function Index({ url }) {
-  return (
-    <div>
-      Hello {new URL('../public/vercel.png', import.meta.url).pathname}+{url}
-    </div>
-  )
-}
diff --git a/test/integration/url/pages/ssr.js b/test/integration/url/pages/ssr.js
deleted file mode 100644
index 6aec1e94a0..0000000000
--- a/test/integration/url/pages/ssr.js
+++ /dev/null
@@ -1,15 +0,0 @@
-export function getServerSideProps() {
-  return {
-    props: {
-      url: new URL('../public/vercel.png', import.meta.url).pathname,
-    },
-  }
-}
-
-export default function Index({ url }) {
-  return (
-    <div>
-      Hello {new URL('../public/vercel.png', import.meta.url).pathname}+{url}
-    </div>
-  )
-}
diff --git a/test/integration/url/pages/static.js b/test/integration/url/pages/static.js
deleted file mode 100644
index 03bc185ce9..0000000000
--- a/test/integration/url/pages/static.js
+++ /dev/null
@@ -1,9 +0,0 @@
-const url = new URL('../public/vercel.png', import.meta.url).pathname
-
-export default function Index(props) {
-  return (
-    <div>
-      Hello {new URL('../public/vercel.png', import.meta.url).pathname}+{url}
-    </div>
-  )
-}
diff --git a/test/integration/url/test/index.test.js b/test/integration/url/test/index.test.js
deleted file mode 100644
index ad860c21ae..0000000000
--- a/test/integration/url/test/index.test.js
+++ /dev/null
@@ -1,83 +0,0 @@
-/* eslint-disable no-loop-func */
-/* eslint-env jest */
-
-import fs from 'fs-extra'
-import { join } from 'path'
-import {
-  nextBuild,
-  findPort,
-  nextStart,
-  killApp,
-  renderViaHTTP,
-  fetchViaHTTP,
-  launchApp,
-  getBrowserBodyText,
-  check,
-} from 'next-test-utils'
-import webdriver from 'next-webdriver'
-
-jest.setTimeout(1000 * 60 * 2)
-const appDir = join(__dirname, '../')
-
-for (const dev of [false, true]) {
-  ;(process.env.IS_TURBOPACK_TEST && !dev ? describe.skip : describe)(
-    `Handle new URL asset references in next ${dev ? 'dev' : 'build'}`,
-    () => {
-      let appPort
-      let app
-      beforeAll(async () => {
-        await fs.remove(join(appDir, '.next'))
-        if (dev) {
-          appPort = await findPort()
-          app = await launchApp(appDir, appPort)
-        } else {
-          await nextBuild(appDir)
-          appPort = await findPort()
-          app = await nextStart(appDir, appPort)
-        }
-      })
-      afterAll(() => killApp(app))
-
-      const expectedServer =
-        /Hello <!-- -->\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png<!-- -->\+<!-- -->\/_next\/static\/media\/vercel\.[0-9a-f]{8}\.png/
-      const expectedClient = new RegExp(
-        expectedServer.source.replace(/<!-- -->/g, '')
-      )
-
-      for (const page of ['/static', '/ssr', '/ssg']) {
-        it(`should render the ${page} page`, async () => {
-          const html = await renderViaHTTP(appPort, page)
-          expect(html).toMatch(expectedServer)
-        })
-
-        it(`should client-render the ${page} page`, async () => {
-          let browser
-          try {
-            browser = await webdriver(appPort, page)
-            await check(() => getBrowserBodyText(browser), expectedClient)
-          } finally {
-            await browser.close()
-          }
-        })
-      }
-
-      it('should respond on size api', async () => {
-        const data = await fetchViaHTTP(appPort, '/api/size').then(
-          (res) => res.ok && res.json()
-        )
-
-        expect(data).toEqual({ size: 30079 })
-      })
-
-      it('should respond on basename api', async () => {
-        const data = await fetchViaHTTP(appPort, '/api/basename').then(
-          (res) => res.ok && res.json()
-        )
-
-        expect(data).toEqual({
-          basename: expect.stringMatching(/^vercel\.[0-9a-f]{8}\.png$/),
-        })
-      })
-    }
-  )
-}
diff --git a/turbopack/crates/turbopack-browser/src/chunking_context.rs b/turbopack/crates/turbopack-browser/src/chunking_context.rs
index f8903e0585..dcdf215815 100644
--- a/turbopack/crates/turbopack-browser/src/chunking_context.rs
+++ b/turbopack/crates/turbopack-browser/src/chunking_context.rs
@@ -3,7 +3,7 @@ use serde::{Deserialize, Serialize};
 use tracing::Instrument;
 use turbo_rcstr::{RcStr, rcstr};
 use turbo_tasks::{
-    NonLocalValue, ResolvedVc, TaskInput, TryJoinIterExt, Upcast, ValueToString, Vc,
+    FxIndexMap, NonLocalValue, ResolvedVc, TaskInput, TryJoinIterExt, Upcast, ValueToString, Vc,
     trace::TraceRawVcs,
 };
 use turbo_tasks_fs::FileSystemPath;
@@ -173,6 +173,21 @@ impl BrowserChunkingContextBuilder {
         self
     }
 
+    pub fn asset_root_path_override(mut self, tag: RcStr, path: FileSystemPath) -> Self {
+        self.chunking_context.asset_root_paths.insert(tag, path);
+        self
+    }
+
+    pub fn client_roots_override(mut self, tag: RcStr, path: FileSystemPath) -> Self {
+        self.chunking_context.client_roots.insert(tag, path);
+        self
+    }
+
+    pub fn asset_base_path_override(mut self, tag: RcStr, path: RcStr) -> Self {
+        self.chunking_context.asset_base_paths.insert(tag, path);
+        self
+    }
+
     pub fn chunking_config<T>(mut self, ty: ResolvedVc<T>, chunking_config: ChunkingConfig) -> Self
     where
         T: Upcast<Box<dyn ChunkType>>,
@@ -200,7 +215,7 @@ impl BrowserChunkingContextBuilder {
 /// It splits "node_modules" separately as these are less likely to change
 /// during development
 #[turbo_tasks::value]
-#[derive(Debug, Clone, Hash, TaskInput)]
+#[derive(Debug, Clone)]
 pub struct BrowserChunkingContext {
     name: Option<RcStr>,
     /// The root path of the project
@@ -213,10 +228,14 @@ pub struct BrowserChunkingContext {
     output_root_to_root_path: RcStr,
     /// This path is used to compute the url to request assets from
     client_root: FileSystemPath,
+    /// This path is used to compute the url to request chunks or assets from
+    client_roots: FxIndexMap<RcStr, FileSystemPath>,
     /// Chunks are placed at this path
     chunk_root_path: FileSystemPath,
     /// Static assets are placed at this path
     asset_root_path: FileSystemPath,
+    /// Static assets are placed at this path
+    asset_root_paths: FxIndexMap<RcStr, FileSystemPath>,
     /// Base path that will be prepended to all chunk URLs when loading them.
     /// This path will not appear in chunk paths or chunk data.
     chunk_base_path: Option<RcStr>,
@@ -226,6 +245,9 @@ pub struct BrowserChunkingContext {
     /// URL prefix that will be prepended to all static asset URLs when loading
     /// them.
     asset_base_path: Option<RcStr>,
+    /// URL prefix that will be prepended to all static asset URLs when loading
+    /// them.
+    asset_base_paths: FxIndexMap<RcStr, RcStr>,
     /// Enable HMR for this chunking
     enable_hot_module_replacement: bool,
     /// Enable tracing for this chunking
@@ -276,12 +298,15 @@ impl BrowserChunkingContext {
                 output_root,
                 output_root_to_root_path,
                 client_root,
+                client_roots: Default::default(),
                 chunk_root_path,
                 should_use_file_source_map_uris: false,
                 asset_root_path,
+                asset_root_paths: Default::default(),
                 chunk_base_path: None,
                 chunk_suffix_path: None,
                 asset_base_path: None,
+                asset_base_paths: Default::default(),
                 enable_hot_module_replacement: false,
                 enable_tracing: false,
                 enable_module_merging: false,
@@ -497,19 +522,27 @@ impl ChunkingContext for BrowserChunkingContext {
     }
 
     #[turbo_tasks::function]
-    async fn asset_url(&self, ident: FileSystemPath) -> Result<Vc<RcStr>> {
+    async fn asset_url(&self, ident: FileSystemPath, tag: Option<RcStr>) -> Result<Vc<RcStr>> {
         let asset_path = ident.to_string();
+
+        let client_root = tag
+            .as_ref()
+            .and_then(|tag| self.client_roots.get(tag))
+            .unwrap_or(&self.client_root);
+
+        let asset_base_path = tag
+            .as_ref()
+            .and_then(|tag| self.asset_base_paths.get(tag))
+            .or(self.asset_base_path.as_ref());
+
         let asset_path = asset_path
-            .strip_prefix(&format!("{}/", self.client_root.path))
+            .strip_prefix(&format!("{}/", client_root.path))
             .context("expected asset_path to contain client_root")?;
 
         Ok(Vc::cell(
             format!(
                 "{}{}",
-                self.asset_base_path
-                    .as_ref()
-                    .map(|s| s.as_str())
-                    .unwrap_or("/"),
+                asset_base_path.map(|s| s.as_str()).unwrap_or("/"),
                 asset_path
             )
             .into(),
@@ -537,6 +570,7 @@ impl ChunkingContext for BrowserChunkingContext {
         &self,
         content_hash: RcStr,
         original_asset_ident: Vc<AssetIdent>,
+        tag: Option<RcStr>,
     ) -> Result<Vc<FileSystemPath>> {
         let source_path = original_asset_ident.path().await?;
         let basename = source_path.file_name();
@@ -551,7 +585,13 @@ impl ChunkingContext for BrowserChunkingContext {
                 content_hash = &content_hash[..8]
             ),
         };
-        Ok(self.asset_root_path.join(&asset_path)?.cell())
+
+        let asset_root_path = tag
+            .as_ref()
+            .and_then(|tag| self.asset_root_paths.get(tag))
+            .unwrap_or(&self.asset_root_path);
+
+        Ok(asset_root_path.join(&asset_path)?.cell())
     }
 
     #[turbo_tasks::function]
diff --git a/turbopack/crates/turbopack-core/src/chunk/chunking_context.rs b/turbopack/crates/turbopack-core/src/chunk/chunking_context.rs
index 519b1cb1bb..d7a4434f9c 100644
--- a/turbopack/crates/turbopack-core/src/chunk/chunking_context.rs
+++ b/turbopack/crates/turbopack-core/src/chunk/chunking_context.rs
@@ -184,14 +184,17 @@ pub trait ChunkingContext {
 
     /// Returns a URL (relative or absolute, depending on the asset prefix) to
     /// the static asset based on its `ident`.
+    /// The `tag` is an arbitrary string that can be used to distinguish
+    /// different usages of the same asset (e.g. different base paths).
     #[turbo_tasks::function]
-    fn asset_url(self: Vc<Self>, ident: FileSystemPath) -> Result<Vc<RcStr>>;
+    fn asset_url(self: Vc<Self>, ident: FileSystemPath, tag: Option<RcStr>) -> Result<Vc<RcStr>>;
 
     #[turbo_tasks::function]
     fn asset_path(
         self: Vc<Self>,
         content_hash: RcStr,
         original_asset_ident: Vc<AssetIdent>,
+        tag: Option<RcStr>,
     ) -> Vc<FileSystemPath>;
 
     #[turbo_tasks::function]
diff --git a/turbopack/crates/turbopack-nodejs/src/chunking_context.rs b/turbopack/crates/turbopack-nodejs/src/chunking_context.rs
index e19d1dcb7f..c877f39598 100644
--- a/turbopack/crates/turbopack-nodejs/src/chunking_context.rs
+++ b/turbopack/crates/turbopack-nodejs/src/chunking_context.rs
@@ -1,7 +1,7 @@
 use anyhow::{Context, Result, bail};
 use tracing::Instrument;
 use turbo_rcstr::{RcStr, rcstr};
-use turbo_tasks::{ResolvedVc, TaskInput, TryJoinIterExt, Upcast, ValueToString, Vc};
+use turbo_tasks::{FxIndexMap, ResolvedVc, TryJoinIterExt, Upcast, ValueToString, Vc};
 use turbo_tasks_fs::FileSystemPath;
 use turbopack_core::{
     asset::Asset,
@@ -45,6 +45,21 @@ impl NodeJsChunkingContextBuilder {
         self
     }
 
+    pub fn asset_prefix_override(mut self, tag: RcStr, prefix: RcStr) -> Self {
+        self.chunking_context.asset_prefixes.insert(tag, prefix);
+        self
+    }
+
+    pub fn asset_root_path_override(mut self, tag: RcStr, path: FileSystemPath) -> Self {
+        self.chunking_context.asset_root_paths.insert(tag, path);
+        self
+    }
+
+    pub fn client_roots_override(mut self, tag: RcStr, path: FileSystemPath) -> Self {
+        self.chunking_context.client_roots.insert(tag, path);
+        self
+    }
+
     pub fn minify_type(mut self, minify_type: MinifyType) -> Self {
         self.chunking_context.minify_type = minify_type;
         self
@@ -125,7 +140,7 @@ impl NodeJsChunkingContextBuilder {
 
 /// A chunking context for build mode.
 #[turbo_tasks::value]
-#[derive(Debug, Clone, Hash, TaskInput)]
+#[derive(Debug, Clone)]
 pub struct NodeJsChunkingContext {
     /// The root path of the project
     root_path: FileSystemPath,
@@ -135,12 +150,18 @@ pub struct NodeJsChunkingContext {
     output_root_to_root_path: RcStr,
     /// This path is used to compute the url to request chunks or assets from
     client_root: FileSystemPath,
+    /// This path is used to compute the url to request chunks or assets from
+    client_roots: FxIndexMap<RcStr, FileSystemPath>,
     /// Chunks are placed at this path
     chunk_root_path: FileSystemPath,
     /// Static assets are placed at this path
     asset_root_path: FileSystemPath,
+    /// Static assets are placed at this path
+    asset_root_paths: FxIndexMap<RcStr, FileSystemPath>,
     /// Static assets requested from this url base
     asset_prefix: Option<RcStr>,
+    /// Static assets requested from this url base
+    asset_prefixes: FxIndexMap<RcStr, RcStr>,
     /// The environment chunks will be evaluated in.
     environment: ResolvedVc<Environment>,
     /// The kind of runtime to include in the output.
@@ -187,9 +208,12 @@ impl NodeJsChunkingContext {
                 output_root,
                 output_root_to_root_path,
                 client_root,
+                client_roots: Default::default(),
                 chunk_root_path,
                 asset_root_path,
+                asset_root_paths: Default::default(),
                 asset_prefix: None,
+                asset_prefixes: Default::default(),
                 enable_file_tracing: false,
                 enable_module_merging: false,
                 enable_dynamic_chunk_content_loading: false,
@@ -298,16 +322,27 @@ impl ChunkingContext for NodeJsChunkingContext {
     }
 
     #[turbo_tasks::function]
-    async fn asset_url(&self, ident: FileSystemPath) -> Result<Vc<RcStr>> {
+    async fn asset_url(&self, ident: FileSystemPath, tag: Option<RcStr>) -> Result<Vc<RcStr>> {
         let asset_path = ident.to_string();
+
+        let client_root = tag
+            .as_ref()
+            .and_then(|tag| self.client_roots.get(tag))
+            .unwrap_or(&self.client_root);
+
+        let asset_prefix = tag
+            .as_ref()
+            .and_then(|tag| self.asset_prefixes.get(tag))
+            .or(self.asset_prefix.as_ref());
+
         let asset_path = asset_path
-            .strip_prefix(&format!("{}/", self.client_root.path))
+            .strip_prefix(&format!("{}/", client_root.path))
             .context("expected client root to contain asset path")?;
 
         Ok(Vc::cell(
             format!(
                 "{}{}",
-                self.asset_prefix.clone().unwrap_or(rcstr!("/")),
+                asset_prefix.map(|s| s.as_str()).unwrap_or("/"),
                 asset_path
             )
             .into(),
@@ -366,6 +401,7 @@ impl ChunkingContext for NodeJsChunkingContext {
         &self,
         content_hash: RcStr,
         original_asset_ident: Vc<AssetIdent>,
+        tag: Option<RcStr>,
     ) -> Result<Vc<FileSystemPath>> {
         let source_path = original_asset_ident.path().await?;
         let basename = source_path.file_name();
@@ -380,7 +416,13 @@ impl ChunkingContext for NodeJsChunkingContext {
                 content_hash = &content_hash[..8]
             ),
         };
-        Ok(self.asset_root_path.join(&asset_path)?.cell())
+
+        let asset_root_path = tag
+            .as_ref()
+            .and_then(|tag| self.asset_root_paths.get(tag))
+            .unwrap_or(&self.asset_root_path);
+
+        Ok(asset_root_path.join(&asset_path)?.cell())
     }
 
     #[turbo_tasks::function]
diff --git a/turbopack/crates/turbopack-static/src/css.rs b/turbopack/crates/turbopack-static/src/css.rs
index 04f2724edc..92b9b39351 100644
--- a/turbopack/crates/turbopack-static/src/css.rs
+++ b/turbopack/crates/turbopack-static/src/css.rs
@@ -1,4 +1,4 @@
-use turbo_rcstr::rcstr;
+use turbo_rcstr::{RcStr, rcstr};
 use turbo_tasks::{ResolvedVc, Vc};
 use turbopack_core::{
     asset::{Asset, AssetContent},
@@ -16,13 +16,14 @@ use crate::output_asset::StaticOutputAsset;
 #[derive(Clone)]
 pub struct StaticUrlCssModule {
     pub source: ResolvedVc<Box<dyn Source>>,
+    tag: Option<RcStr>,
 }
 
 #[turbo_tasks::value_impl]
 impl StaticUrlCssModule {
     #[turbo_tasks::function]
-    pub fn new(source: ResolvedVc<Box<dyn Source>>) -> Vc<Self> {
-        Self::cell(StaticUrlCssModule { source })
+    pub fn new(source: ResolvedVc<Box<dyn Source>>, tag: Option<RcStr>) -> Vc<Self> {
+        Self::cell(StaticUrlCssModule { source, tag })
     }
 
     #[turbo_tasks::function]
@@ -30,7 +31,7 @@ impl StaticUrlCssModule {
         &self,
         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,
     ) -> Vc<StaticOutputAsset> {
-        StaticOutputAsset::new(*chunking_context, *self.source)
+        StaticOutputAsset::new(*chunking_context, *self.source, self.tag.clone())
     }
 }
 
@@ -38,7 +39,11 @@ impl StaticUrlCssModule {
 impl Module for StaticUrlCssModule {
     #[turbo_tasks::function]
     fn ident(&self) -> Vc<AssetIdent> {
-        self.source.ident().with_modifier(rcstr!("static in css"))
+        let mut ident = self.source.ident().with_modifier(rcstr!("static in css"));
+        if let Some(tag) = &self.tag {
+            ident = ident.with_modifier(format!("tag {}", tag).into());
+        }
+        ident
     }
 }
 
diff --git a/turbopack/crates/turbopack-static/src/ecma.rs b/turbopack/crates/turbopack-static/src/ecma.rs
index e901981595..cf5530fdfa 100644
--- a/turbopack/crates/turbopack-static/src/ecma.rs
+++ b/turbopack/crates/turbopack-static/src/ecma.rs
@@ -1,5 +1,5 @@
 use anyhow::Result;
-use turbo_rcstr::rcstr;
+use turbo_rcstr::{RcStr, rcstr};
 use turbo_tasks::{ResolvedVc, Vc};
 use turbopack_core::{
     asset::{Asset, AssetContent},
@@ -25,13 +25,14 @@ use crate::output_asset::StaticOutputAsset;
 #[derive(Clone)]
 pub struct StaticUrlJsModule {
     pub source: ResolvedVc<Box<dyn Source>>,
+    pub tag: Option<RcStr>,
 }
 
 #[turbo_tasks::value_impl]
 impl StaticUrlJsModule {
     #[turbo_tasks::function]
-    pub fn new(source: ResolvedVc<Box<dyn Source>>) -> Vc<Self> {
-        Self::cell(StaticUrlJsModule { source })
+    pub fn new(source: ResolvedVc<Box<dyn Source>>, tag: Option<RcStr>) -> Vc<Self> {
+        Self::cell(StaticUrlJsModule { source, tag })
     }
 
     #[turbo_tasks::function]
@@ -39,7 +40,7 @@ impl StaticUrlJsModule {
         &self,
         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,
     ) -> Vc<StaticOutputAsset> {
-        StaticOutputAsset::new(*chunking_context, *self.source)
+        StaticOutputAsset::new(*chunking_context, *self.source, self.tag.clone())
     }
 }
 
@@ -47,9 +48,14 @@ impl StaticUrlJsModule {
 impl Module for StaticUrlJsModule {
     #[turbo_tasks::function]
     fn ident(&self) -> Vc<AssetIdent> {
-        self.source
+        let mut ident = self
+            .source
             .ident()
-            .with_modifier(rcstr!("static in ecmascript"))
+            .with_modifier(rcstr!("static in ecmascript"));
+        if let Some(tag) = &self.tag {
+            ident = ident.with_modifier(format!("tag {}", tag).into());
+        }
+        ident
     }
 }
 
@@ -77,6 +83,7 @@ impl ChunkableModule for StaticUrlJsModule {
                     .static_output_asset(*chunking_context)
                     .to_resolved()
                     .await?,
+                tag: self.await?.tag.clone(),
             },
         )))
     }
@@ -95,6 +102,7 @@ struct StaticUrlJsChunkItem {
     module: ResolvedVc<StaticUrlJsModule>,
     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,
     static_asset: ResolvedVc<StaticOutputAsset>,
+    tag: Option<RcStr>,
 }
 
 #[turbo_tasks::value_impl]
@@ -137,7 +145,7 @@ impl EcmascriptChunkItem for StaticUrlJsChunkItem {
                 path = StringifyJs(
                     &self
                         .chunking_context
-                        .asset_url(self.static_asset.path().owned().await?)
+                        .asset_url(self.static_asset.path().owned().await?, self.tag.clone())
                         .await?
                 )
             )
diff --git a/turbopack/crates/turbopack-static/src/output_asset.rs b/turbopack/crates/turbopack-static/src/output_asset.rs
index c1c4b868c2..3d9600f5e0 100644
--- a/turbopack/crates/turbopack-static/src/output_asset.rs
+++ b/turbopack/crates/turbopack-static/src/output_asset.rs
@@ -1,4 +1,5 @@
 use anyhow::Result;
+use turbo_rcstr::RcStr;
 use turbo_tasks::{ResolvedVc, Vc};
 use turbo_tasks_fs::{FileContent, FileSystemPath};
 use turbopack_core::{
@@ -11,6 +12,7 @@ use turbopack_core::{
 pub struct StaticOutputAsset {
     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,
     source: ResolvedVc<Box<dyn Source>>,
+    tag: Option<RcStr>,
 }
 
 #[turbo_tasks::value_impl]
@@ -19,10 +21,12 @@ impl StaticOutputAsset {
     pub fn new(
         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,
         source: ResolvedVc<Box<dyn Source>>,
+        tag: Option<RcStr>,
     ) -> Vc<Self> {
         Self::cell(StaticOutputAsset {
             chunking_context,
             source,
+            tag,
         })
     }
 }
@@ -42,9 +46,11 @@ impl OutputAsset for StaticOutputAsset {
             anyhow::bail!("StaticAsset::path: unsupported file content")
         };
         let content_hash_b16 = turbo_tasks_hash::encode_hex(content_hash);
-        Ok(self
-            .chunking_context
-            .asset_path(content_hash_b16.into(), self.source.ident()))
+        Ok(self.chunking_context.asset_path(
+            content_hash_b16.into(),
+            self.source.ident(),
+            self.tag.clone(),
+        ))
     }
 }
 
diff --git a/turbopack/crates/turbopack/src/lib.rs b/turbopack/crates/turbopack/src/lib.rs
index 24fc0d504d..565fd0381c 100644
--- a/turbopack/crates/turbopack/src/lib.rs
+++ b/turbopack/crates/turbopack/src/lib.rs
@@ -271,12 +271,16 @@ async fn apply_module_type(
             .to_resolved()
             .await?,
         ),
-        ModuleType::StaticUrlJs => {
-            ResolvedVc::upcast(StaticUrlJsModule::new(*source).to_resolved().await?)
-        }
-        ModuleType::StaticUrlCss => {
-            ResolvedVc::upcast(StaticUrlCssModule::new(*source).to_resolved().await?)
-        }
+        ModuleType::StaticUrlJs { tag } => ResolvedVc::upcast(
+            StaticUrlJsModule::new(*source, tag.clone())
+                .to_resolved()
+                .await?,
+        ),
+        ModuleType::StaticUrlCss { tag } => ResolvedVc::upcast(
+            StaticUrlCssModule::new(*source, tag.clone())
+                .to_resolved()
+                .await?,
+        ),
         ModuleType::InlinedBytesJs => {
             ResolvedVc::upcast(InlinedBytesJsModule::new(*source).to_resolved().await?)
         }
diff --git a/turbopack/crates/turbopack/src/module_options/mod.rs b/turbopack/crates/turbopack/src/module_options/mod.rs
index 2de0143c34..327d87be98 100644
--- a/turbopack/crates/turbopack/src/module_options/mod.rs
+++ b/turbopack/crates/turbopack/src/module_options/mod.rs
@@ -434,15 +434,29 @@ impl ModuleOptions {
                     RuleCondition::ResourcePathEndsWith(".webp".to_string()),
                     RuleCondition::ResourcePathEndsWith(".woff2".to_string()),
                 ]),
-                vec![ModuleRuleEffect::ModuleType(ModuleType::StaticUrlJs)],
+                vec![ModuleRuleEffect::ModuleType(ModuleType::StaticUrlJs {
+                    tag: None,
+                })],
             ),
             ModuleRule::new(
                 RuleCondition::ReferenceType(ReferenceType::Url(UrlReferenceSubType::Undefined)),
-                vec![ModuleRuleEffect::ModuleType(ModuleType::StaticUrlJs)],
+                vec![ModuleRuleEffect::ModuleType(ModuleType::StaticUrlJs {
+                    tag: None,
+                })],
+            ),
+            ModuleRule::new(
+                RuleCondition::ReferenceType(ReferenceType::Url(
+                    UrlReferenceSubType::EcmaScriptNewUrl,
+                )),
+                vec![ModuleRuleEffect::ModuleType(ModuleType::StaticUrlJs {
+                    tag: None,
+                })],
             ),
             ModuleRule::new(
                 RuleCondition::ReferenceType(ReferenceType::Url(UrlReferenceSubType::CssUrl)),
-                vec![ModuleRuleEffect::ModuleType(ModuleType::StaticUrlCss)],
+                vec![ModuleRuleEffect::ModuleType(ModuleType::StaticUrlCss {
+                    tag: None,
+                })],
             ),
         ];
 
diff --git a/turbopack/crates/turbopack/src/module_options/module_rule.rs b/turbopack/crates/turbopack/src/module_options/module_rule.rs
index f1e017c1d3..28ff609703 100644
--- a/turbopack/crates/turbopack/src/module_options/module_rule.rs
+++ b/turbopack/crates/turbopack/src/module_options/module_rule.rs
@@ -1,5 +1,6 @@
 use anyhow::Result;
 use serde::{Deserialize, Serialize};
+use turbo_rcstr::RcStr;
 use turbo_tasks::{NonLocalValue, ResolvedVc, trace::TraceRawVcs};
 use turbo_tasks_fs::FileSystemPath;
 use turbopack_core::{
@@ -138,8 +139,14 @@ pub enum ModuleType {
         ty: CssModuleAssetType,
         environment: Option<ResolvedVc<Environment>>,
     },
-    StaticUrlJs,
-    StaticUrlCss,
+    StaticUrlJs {
+        /// The tag that is passed to ChunkingContext::asset_url
+        tag: Option<RcStr>,
+    },
+    StaticUrlCss {
+        /// The tag that is passed to ChunkingContext::asset_url
+        tag: Option<RcStr>,
+    },
     InlinedBytesJs,
     WebAssembly {
         source_ty: WebAssemblySourceType,
