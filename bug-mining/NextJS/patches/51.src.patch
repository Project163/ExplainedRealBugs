diff --git a/Cargo.lock b/Cargo.lock
index 8c08c8c0df..0bc7003d4d 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -4262,6 +4262,7 @@ dependencies = [
  "indexmap 2.9.0",
  "next-core",
  "regex",
+ "roaring",
  "rustc-hash 2.1.1",
  "serde",
  "serde_json",
diff --git a/Cargo.toml b/Cargo.toml
index 4ecf8109c7..1830ad6c45 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -398,6 +398,7 @@ regex = "1.10.6"
 regress = "0.10.3"
 reqwest = { version = "0.12.20", default-features = false }
 ringmap = "0.1.3"
+roaring = "0.10.10"
 rstest = "0.16.0"
 rustc-hash = "2.1.1"
 semver = "1.0.16"
diff --git a/crates/next-api/Cargo.toml b/crates/next-api/Cargo.toml
index 95eed8fc6c..b4eb3df2a4 100644
--- a/crates/next-api/Cargo.toml
+++ b/crates/next-api/Cargo.toml
@@ -23,6 +23,7 @@ futures = { workspace = true }
 indexmap = { workspace = true }
 next-core = { workspace = true }
 regex = { workspace = true }
+roaring = { workspace = true }
 rustc-hash = { workspace = true }
 serde = { workspace = true }
 serde_json = { workspace = true }
diff --git a/crates/next-api/src/app.rs b/crates/next-api/src/app.rs
index 5570a31ac3..7f021e40be 100644
--- a/crates/next-api/src/app.rs
+++ b/crates/next-api/src/app.rs
@@ -1937,10 +1937,10 @@ impl Endpoint for AppEndpoint {
         };
 
         async move {
-            let output = self.output().await?;
-            let output_assets = self.output().output_assets();
-            let node_root = this.app_project.project().node_root();
-            let node_root_ref = &node_root.await?;
+            let output = self.output();
+            let output_assets = output.output_assets();
+            let output = output.await?;
+            let node_root = &*this.app_project.project().node_root().await?;
 
             let (server_paths, client_paths) = if this
                 .app_project
@@ -1969,7 +1969,7 @@ impl Endpoint for AppEndpoint {
 
             let written_endpoint = match *output {
                 AppEndpointOutput::NodeJs { rsc_chunk, .. } => EndpointOutputPaths::NodeJs {
-                    server_entry_path: node_root_ref
+                    server_entry_path: node_root
                         .get_path_to(&*rsc_chunk.path().await?)
                         .context("Node.js chunk entry path must be inside the node root")?
                         .to_string(),
diff --git a/crates/next-api/src/client_references.rs b/crates/next-api/src/client_references.rs
index fd192d3f79..3d985af34a 100644
--- a/crates/next-api/src/client_references.rs
+++ b/crates/next-api/src/client_references.rs
@@ -1,16 +1,23 @@
 use anyhow::Result;
 use next_core::{
-    self,
     next_client_reference::{CssClientReferenceModule, EcmascriptClientReferenceModule},
     next_server_component::server_component_module::NextServerComponentModule,
 };
+use roaring::RoaringBitmap;
 use rustc_hash::FxHashMap;
 use serde::{Deserialize, Serialize};
 use turbo_tasks::{
-    NonLocalValue, ResolvedVc, TryFlatJoinIterExt, Vc, debug::ValueDebugFormat, trace::TraceRawVcs,
+    FxIndexSet, NonLocalValue, ResolvedVc, TryFlatJoinIterExt, Vc, debug::ValueDebugFormat,
+    trace::TraceRawVcs,
 };
 use turbopack::css::chunk::CssChunkPlaceable;
-use turbopack_core::{module::Module, module_graph::SingleModuleGraph};
+use turbopack_core::{
+    module::Module,
+    module_graph::{
+        GraphTraversalAction, SingleModuleGraph, SingleModuleGraphModuleNode,
+        chunk_group_info::RoaringBitmapWrapper,
+    },
+};
 
 #[derive(
     Copy, Clone, Serialize, Deserialize, Eq, PartialEq, TraceRawVcs, ValueDebugFormat, NonLocalValue,
@@ -24,15 +31,42 @@ pub enum ClientReferenceMapType {
     ServerComponent(ResolvedVc<NextServerComponentModule>),
 }
 
-#[turbo_tasks::value(transparent)]
-pub struct ClientReferencesSet(FxHashMap<ResolvedVc<Box<dyn Module>>, ClientReferenceMapType>);
+#[turbo_tasks::value]
+pub struct ClientReferencesSet {
+    pub client_references: FxHashMap<ResolvedVc<Box<dyn Module>>, ClientReferenceMapType>,
+    // All the server components in the graph.
+    server_components: FxIndexSet<ResolvedVc<NextServerComponentModule>>,
+    // All the server components that depend on each module
+    // This only includes mappings for modules with client references and the bitmaps reference
+    // indices into `[server_components]`
+    server_components_for_client_references:
+        FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper>,
+}
+
+impl ClientReferencesSet {
+    /// Returns all the server components that depend on the given client reference
+    pub fn server_components_for_client_reference(
+        &self,
+        module: ResolvedVc<Box<dyn Module>>,
+    ) -> impl Iterator<Item = ResolvedVc<NextServerComponentModule>> {
+        let bitmap = &self
+            .server_components_for_client_references
+            .get(&module)
+            .expect("Module should be a client reference module")
+            .0;
+
+        bitmap
+            .iter()
+            .map(|index| *self.server_components.get_index(index as usize).unwrap())
+    }
+}
 
 #[turbo_tasks::function]
 pub async fn map_client_references(
     graph: Vc<SingleModuleGraph>,
 ) -> Result<Vc<ClientReferencesSet>> {
+    let graph = graph.await?;
     let client_references = graph
-        .await?
         .iter_nodes()
         .map(|node| async move {
             let module = node.module;
@@ -68,6 +102,99 @@ pub async fn map_client_references(
             }
         })
         .try_flat_join()
-        .await?;
-    Ok(Vc::cell(client_references.into_iter().collect()))
+        .await?
+        .into_iter()
+        .collect::<FxHashMap<_, _>>();
+
+    let mut server_components = FxIndexSet::default();
+    let mut module_to_server_component_bits = FxHashMap::default();
+    if !client_references.is_empty() {
+        graph.traverse_edges_from_entries_fixed_point(
+            graph.entry_modules(),
+            |parent_info, node| {
+                let module = node.module();
+                let module_type = client_references.get(&module);
+                let mut should_visit_children = match module_to_server_component_bits.entry(module)
+                {
+                    std::collections::hash_map::Entry::Occupied(_) => false,
+                    std::collections::hash_map::Entry::Vacant(vacant_entry) => {
+                        // only do this the first time we visit the node.
+                        let bits = vacant_entry.insert(RoaringBitmap::new());
+                        if let Some(ClientReferenceMapType::ServerComponent(
+                            server_component_module,
+                        )) = module_type
+                        {
+                            let index = server_components.insert_full(*server_component_module).0;
+
+                            bits.insert(index.try_into().unwrap());
+                        }
+                        true
+                    }
+                };
+                if let Some((SingleModuleGraphModuleNode{module: parent_module}, _)) = parent_info
+                    // Skip self cycles such as in
+                    // test/e2e/app-dir/dynamic-import/app/page.tsx where a very-dynamic import induces a
+                    // self cycle. They don't introduce new bits anyway.
+                    && module != *parent_module
+                {
+                    // Copy parent bits down.  `traverse_edges_from_entries_fixed_point` always
+                    // visits parents before children so we can simply assert
+                    // that the parent it set.
+                    let [Some(current), Some(parent)] =
+                        module_to_server_component_bits.get_disjoint_mut([&module, parent_module])
+                    else {
+                        unreachable!()
+                    };
+                    // Check if we are adding new bits and thus need to revisit children unless we
+                    // are already planning to because this is a new node.
+                    if !should_visit_children {
+                        let len = current.len();
+                        *current |= &*parent;
+                        // did we find new bits? If so visit the children again
+                        should_visit_children = len != current.len();
+                    } else {
+                        *current |= &*parent;
+                    }
+                }
+
+                Ok(match module_type {
+                    Some(
+                        ClientReferenceMapType::EcmascriptClientReference { .. }
+                        | ClientReferenceMapType::CssClientReference { .. },
+                    ) => {
+                        // No need to explore these subgraphs ever, these are the leaves in the
+                        // server component graph
+                        GraphTraversalAction::Skip
+                    }
+                    // Continue on server components and through graphs of non-ClientReference
+                    // modules, but only if our set of parent components has changed.
+                    _ => {
+                        if should_visit_children {
+                            GraphTraversalAction::Continue
+                        } else {
+                            GraphTraversalAction::Skip
+                        }
+                    }
+                })
+            },
+        )?;
+    }
+
+    // Filter down to just the client reference modules to reduce datastructure size
+    let server_components_for_client_references = module_to_server_component_bits
+        .into_iter()
+        .filter_map(|(k, v)| match client_references.get(&k) {
+            Some(
+                ClientReferenceMapType::CssClientReference(_)
+                | ClientReferenceMapType::EcmascriptClientReference { .. },
+            ) => Some((k, RoaringBitmapWrapper(v))),
+            _ => None,
+        })
+        .collect();
+
+    Ok(ClientReferencesSet::cell(ClientReferencesSet {
+        client_references,
+        server_components,
+        server_components_for_client_references,
+    }))
 }
diff --git a/crates/next-api/src/module_graph.rs b/crates/next-api/src/module_graph.rs
index 8f27dd6630..55fe1eaa01 100644
--- a/crates/next-api/src/module_graph.rs
+++ b/crates/next-api/src/module_graph.rs
@@ -1,6 +1,6 @@
-use std::borrow::Cow;
+use std::{borrow::Cow, collections::hash_map::Entry};
 
-use anyhow::Result;
+use anyhow::{Ok, Result};
 use either::Either;
 use next_core::{
     next_client_reference::{
@@ -10,12 +10,12 @@ use next_core::{
     next_dynamic::NextDynamicEntryModule,
     next_manifests::ActionLayer,
 };
-use rustc_hash::FxHashMap;
+use rustc_hash::{FxHashMap, FxHashSet};
 use tracing::Instrument;
 use turbo_rcstr::RcStr;
 use turbo_tasks::{
-    CollectiblesSource, FxIndexMap, FxIndexSet, ReadRef, ResolvedVc, TryFlatJoinIterExt,
-    TryJoinIterExt, ValueToString, Vc,
+    CollectiblesSource, FxIndexMap, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt,
+    ValueToString, Vc,
 };
 use turbo_tasks_fs::FileSystemPath;
 use turbopack::css::{CssModuleAsset, ModuleCssAsset};
@@ -285,33 +285,65 @@ impl ClientReferencesGraph {
                 Either::Right(graph.entry_modules())
             };
 
-            let mut client_references = FxIndexSet::default();
-            // Make sure None (for the various internal next/dist/esm/client/components/*) is
-            // listed first
-            let mut client_references_by_server_component =
-                FxIndexMap::from_iter([(None, Vec::new())]);
-
+            // Because we care about 'evaluation order' we need to collect client references in the
+            // post_order callbacks which is the same as evaluation order
+            let mut client_references = Vec::new();
+            let mut client_reference_modules = Vec::new();
+            let mut server_components = FxHashSet::default();
+
+            // Track how we reached each client reference.  This way if a client reference is
+            // referenced by the root and by a server component we don't only associate it with the
+            // server component.
+            #[derive(PartialEq, Eq, Copy, Clone)]
+            enum ParentType {
+                ServerComponent,
+                Page,
+                Both,
+            }
+            impl ParentType {
+                fn merge(left: Self, right: Self) -> Self {
+                    if left == right {
+                        left
+                    } else {
+                        // One is Both or one is ServerComponent and the other is Page, which means
+                        // Both
+                        Self::Both
+                    }
+                }
+            }
+            // Perform a DFS traversal to collect all client references and the set of server
+            // components for each module.
             graph.traverse_edges_from_entries_dfs(
                 entries,
-                // state_map is `module -> Option< the current so parent server component >`
+                // state_map is `module -> ParentType` to tracke whether the module is reachable
+                // directly from an entry point.
                 &mut FxHashMap::default(),
                 |parent_info, node, state_map| {
                     let module = node.module();
-                    let module_type = data.get(&module);
-
-                    let current_server_component = if let Some(
-                        ClientReferenceMapType::ServerComponent(module),
-                    ) = module_type
-                    {
-                        Some(*module)
-                    } else if let Some((parent_node, _)) = parent_info {
-                        *state_map.get(&parent_node.module).unwrap()
-                    } else {
-                        // a root node
-                        None
-                    };
-
-                    state_map.insert(module, current_server_component);
+                    let module_type = data.client_references.get(&module);
+
+                    let parent_type =
+                        if let Some(ClientReferenceMapType::ServerComponent(_)) = module_type {
+                            ParentType::ServerComponent
+                        } else if let Some((parent_node, _)) = parent_info {
+                            *state_map.get(&parent_node.module).unwrap()
+                        } else {
+                            // a root node
+                            ParentType::Page
+                        };
+
+                    match state_map.entry(module) {
+                        Entry::Occupied(mut occupied_entry) => {
+                            let current = occupied_entry.get_mut();
+                            let merged = ParentType::merge(*current, parent_type);
+                            if merged != parent_type {
+                                *current = merged;
+                            }
+                        }
+                        Entry::Vacant(vacant_entry) => {
+                            vacant_entry.insert(parent_type);
+                        }
+                    }
 
                     Ok(match module_type {
                         Some(
@@ -321,45 +353,60 @@ impl ClientReferencesGraph {
                         _ => GraphTraversalAction::Continue,
                     })
                 },
-                |parent_info, node, state_map| {
-                    let Some((parent_node, _)) = parent_info else {
+                |_, node, state_map| {
+                    let module = node.module();
+                    let Some(module_type) = data.client_references.get(&module) else {
                         return Ok(());
                     };
-                    let parent_module = parent_node.module;
-
-                    let parent_server_component = *state_map.get(&parent_module).unwrap();
-
-                    match data.get(&node.module()) {
-                        Some(ClientReferenceMapType::EcmascriptClientReference {
-                            module: module_ref,
-                            ssr_module,
-                        }) => {
-                            let client_reference: ClientReference = ClientReference {
-                                server_component: parent_server_component,
-                                ty: ClientReferenceType::EcmascriptClientReference(*module_ref),
-                            };
-                            client_references.insert(client_reference);
-                            client_references_by_server_component
-                                .entry(parent_server_component)
-                                .or_insert_with(Vec::new)
-                                .push(*ssr_module);
+
+                    let ty = match module_type {
+                        ClientReferenceMapType::EcmascriptClientReference {
+                            module,
+                            ssr_module: _,
+                        } => ClientReferenceType::EcmascriptClientReference(*module),
+                        ClientReferenceMapType::CssClientReference(module) => {
+                            ClientReferenceType::CssClientReference(*module)
                         }
-                        Some(ClientReferenceMapType::CssClientReference(module_ref)) => {
-                            let client_reference = ClientReference {
-                                server_component: parent_server_component,
-                                ty: ClientReferenceType::CssClientReference(*module_ref),
-                            };
-                            client_references.insert(client_reference);
+                        ClientReferenceMapType::ServerComponent(sc) => {
+                            server_components.insert(*sc);
+                            return Ok(());
                         }
-                        _ => {}
                     };
+
+                    if *state_map.get(&module).unwrap() == ParentType::ServerComponent {
+                        // This is only reachable through server components, we need to wait to
+                        // compute the client references until we have seen all server components
+                        // reachable by this entrypoint, then we can intersect that with the set of
+                        // server components that depend on this client reference
+                        client_reference_modules.push((module, ty));
+                    } else {
+                        // Otherwise there is some path from the root directly to the reference,
+                        // just associate it with the root.
+                        client_references.push(ClientReference {
+                            server_component: None,
+                            ty,
+                        })
+                    }
+
                     Ok(())
                 },
             )?;
 
+            // Now compute all the parent components for each client reference module reachable from
+            // server components
+            client_references.extend(client_reference_modules.into_iter().flat_map(
+                |(module, ty)| {
+                    data.server_components_for_client_reference(module)
+                        .filter(|sc| server_components.contains(sc))
+                        .map(move |sc| ClientReference {
+                            server_component: Some(sc),
+                            ty,
+                        })
+                },
+            ));
+
             Ok(ClientReferenceGraphResult {
                 client_references: client_references.into_iter().collect(),
-                client_references_by_server_component,
                 server_utils: vec![],
                 server_component_entries: vec![],
             }
@@ -679,11 +726,7 @@ impl GlobalBuildInformation {
                 let results = self
                     .client_references
                     .iter()
-                    .map(|graph| async move {
-                        let get_client_references_for_endpoint =
-                            graph.get_client_references_for_endpoint(entry).await?;
-                        Ok(get_client_references_for_endpoint)
-                    })
+                    .map(|graph| graph.get_client_references_for_endpoint(entry))
                     .try_join()
                     .await?;
 
@@ -695,6 +738,12 @@ impl GlobalBuildInformation {
                 result
             };
 
+            // TODO(luke.sandberg): at least in the whole_app_module_graph case we should be able to
+            // collect server components and server utilities during the above traversals in the
+            // correct order.  `find_server_entries returns them in reverse topological order (root
+            // layout first, page last) but the above traversals find them in DFS post
+            // order which means we would need to reverse it.
+            // For server_utils the order is irrelevant.
             if has_layout_segments {
                 // Do this separately for now, because the graph traversal order messes up the order
                 // of the server_component_entries.
diff --git a/crates/next-core/src/next_client_reference/visit_client_reference.rs b/crates/next-core/src/next_client_reference/visit_client_reference.rs
index c8c251862c..3dda849ca1 100644
--- a/crates/next-core/src/next_client_reference/visit_client_reference.rs
+++ b/crates/next-core/src/next_client_reference/visit_client_reference.rs
@@ -6,7 +6,7 @@ use serde::{Deserialize, Serialize};
 use tracing::Instrument;
 use turbo_rcstr::RcStr;
 use turbo_tasks::{
-    FxIndexMap, FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, TryJoinIterExt, ValueToString, Vc,
+    FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, TryJoinIterExt, ValueToString, Vc,
     debug::ValueDebugFormat,
     graph::{AdjacencyMap, GraphTraversal, Visit, VisitControlFlow},
     trace::TraceRawVcs,
@@ -75,10 +75,6 @@ pub enum ClientReferenceType {
 #[derive(Clone, Debug, Default)]
 pub struct ClientReferenceGraphResult {
     pub client_references: Vec<ClientReference>,
-    /// Only the [`ClientReferenceType::EcmascriptClientReference`]s are listed in this map.
-    #[allow(clippy::type_complexity)]
-    pub client_references_by_server_component:
-        FxIndexMap<Option<ResolvedVc<NextServerComponentModule>>, Vec<ResolvedVc<Box<dyn Module>>>>,
     pub server_component_entries: Vec<ResolvedVc<NextServerComponentModule>>,
     pub server_utils: Vec<ResolvedVc<NextServerUtilityModule>>,
 }
@@ -115,12 +111,6 @@ impl ClientReferenceGraphResult {
     pub fn extend(&mut self, other: &Self) {
         self.client_references
             .extend(other.client_references.iter().copied());
-        for (k, v) in other.client_references_by_server_component.iter() {
-            self.client_references_by_server_component
-                .entry(*k)
-                .or_insert_with(Vec::new)
-                .extend(v);
-        }
         self.server_component_entries
             .extend(other.server_component_entries.iter().copied());
         self.server_utils.extend(other.server_utils.iter().copied());
diff --git a/test/e2e/app-dir/initial-css-not-found/initial-css-not-found.test.ts b/test/e2e/app-dir/initial-css-not-found/initial-css-not-found.test.ts
index 83c2130b2f..1d8e05f4a1 100644
--- a/test/e2e/app-dir/initial-css-not-found/initial-css-not-found.test.ts
+++ b/test/e2e/app-dir/initial-css-not-found/initial-css-not-found.test.ts
@@ -10,15 +10,11 @@ describe('initial-css-not-found', () => {
   it('should serve styles', async () => {
     const browser = await next.browser('/')
 
+    // Simply check that our css was served and applied.
     expect(
       await browser.eval(
         `window.getComputedStyle(document.querySelector('body')).color`
       )
-    ).toBe(
-      // This only fails in production turbopack builds
-      process.env.IS_TURBOPACK_TEST && process.env.NEXT_TEST_MODE !== 'dev'
-        ? 'rgb(0, 0, 0)'
-        : 'rgb(255, 0, 0)'
-    )
+    ).toBe('rgb(255, 0, 0)')
   })
 })
diff --git a/turbopack/crates/turbopack-core/Cargo.toml b/turbopack/crates/turbopack-core/Cargo.toml
index 3bda9c1f02..44f8da8905 100644
--- a/turbopack/crates/turbopack-core/Cargo.toml
+++ b/turbopack/crates/turbopack-core/Cargo.toml
@@ -24,7 +24,7 @@ indexmap = { workspace = true }
 once_cell = { workspace = true }
 patricia_tree = "0.5.5"
 petgraph = { workspace = true, features = ["serde-1"] }
-roaring = { version = "0.10.10", features = ["serde"] }
+roaring = { workspace = true, features = ["serde"] }
 ref-cast = "1.0.20"
 rustc-hash = { workspace = true }
 regex = { workspace = true }
diff --git a/turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs b/turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs
index f2578fc3d8..242fa60ef0 100644
--- a/turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs
+++ b/turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs
@@ -25,6 +25,7 @@ use crate::{
 #[derive(
     Clone, Debug, Default, PartialEq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat,
 )]
+#[repr(transparent)]
 pub struct RoaringBitmapWrapper(#[turbo_tasks(trace_ignore)] pub RoaringBitmap);
 
 impl TaskInput for RoaringBitmapWrapper {
diff --git a/turbopack/crates/turbopack-core/src/module_graph/mod.rs b/turbopack/crates/turbopack-core/src/module_graph/mod.rs
index 3f3676ca90..2d5bcc610a 100644
--- a/turbopack/crates/turbopack-core/src/module_graph/mod.rs
+++ b/turbopack/crates/turbopack-core/src/module_graph/mod.rs
@@ -563,6 +563,70 @@ impl SingleModuleGraph {
         Ok(())
     }
 
+    /// Traverses all reachable nodes and also continue revisiting them as long the visitor returns
+    /// GraphTraversalAction::Continue. The visitor is responsible for the runtime complexity and
+    /// eventual termination of the traversal. This corresponds to computing a fixed point state for
+    /// the graph.
+    ///
+    /// It is guaranteed that the parent node passed to the `visit` function, if any, has
+    /// already been passed to `visit`.
+    ///
+    /// * `entries` - The entry modules to start the traversal from
+    /// * `visit` - Called for a specific edge
+    ///    - Receives: Option(originating &SingleModuleGraphNode, edge &ChunkingType), target
+    ///      &SingleModuleGraphNode
+    ///    - Return [GraphTraversalAction]s to control the traversal
+    ///
+    /// Returns the number of node visits (i.e. higher than the node
+    /// count if there are retraversals).
+    pub fn traverse_edges_from_entries_fixed_point<'a>(
+        &'a self,
+        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,
+        mut visit: impl FnMut(
+            Option<(&'a SingleModuleGraphModuleNode, &'a RefData)>,
+            &'a SingleModuleGraphNode,
+        ) -> Result<GraphTraversalAction>,
+    ) -> Result<usize> {
+        let mut queue = VecDeque::default();
+        let mut queue_set = FxHashSet::default();
+
+        for module in entries {
+            let index = self.get_module(module).unwrap();
+            let action = visit(None, self.graph.node_weight(index).unwrap())?;
+            if action == GraphTraversalAction::Continue && queue_set.insert(index) {
+                queue.push_back(index);
+            }
+        }
+
+        let mut visit_count = 0;
+        while let Some(index) = queue.pop_front() {
+            queue_set.remove(&index);
+            let node = match self.graph.node_weight(index).unwrap() {
+                SingleModuleGraphNode::Module(single_module_graph_module_node) => {
+                    single_module_graph_module_node
+                }
+                _ => {
+                    continue; // we don't traverse into parent graphs
+                }
+            };
+            visit_count += 1;
+            for edge in self
+                .graph
+                .edges_directed(index, petgraph::Direction::Outgoing)
+            {
+                let refdata = edge.weight();
+                let target_index = edge.target();
+                let target = self.graph.node_weight(edge.target()).unwrap();
+                let action = visit(Some((node, refdata)), target)?;
+                if action == GraphTraversalAction::Continue && queue_set.insert(target_index) {
+                    queue.push_back(target_index);
+                }
+            }
+        }
+
+        Ok(visit_count)
+    }
+
     /// Traverses all reachable edges in dfs order. The preorder visitor can be used to
     /// forward state down the graph, and to skip subgraphs.
     ///
@@ -1937,6 +2001,58 @@ pub mod tests {
         .await;
     }
 
+    #[tokio::test]
+    async fn traverse_edges_from_entries_fixed_point_cycle() {
+        run_graph_test(
+            vec![rcstr!("a.js")],
+            {
+                let mut deps = FxHashMap::default();
+                // A cycle of length 3
+                deps.insert(rcstr!("a.js"), vec![rcstr!("b.js")]);
+                deps.insert(rcstr!("b.js"), vec![rcstr!("c.js")]);
+                deps.insert(rcstr!("c.js"), vec![rcstr!("a.js")]);
+                deps
+            },
+            |graph, entry_modules, module_to_name| {
+                let mut visits = Vec::new();
+                let mut count = 0;
+
+                graph.traverse_edges_from_entries_fixed_point(
+                    entry_modules,
+                    |parent, target| {
+                        visits.push((
+                            parent
+                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),
+                            module_to_name.get(&target.module()).unwrap().clone(),
+                        ));
+                        count += 1;
+
+                        // We are a cycle so we need to break the loop eventually
+                        Ok(if count < 6 {
+                            GraphTraversalAction::Continue
+                        } else {
+                            GraphTraversalAction::Skip
+                        })
+                    },
+                )?;
+                assert_eq!(
+                    vec![
+                        (None, rcstr!("a.js")),
+                        (Some(rcstr!("a.js")), rcstr!("b.js")),
+                        (Some(rcstr!("b.js")), rcstr!("c.js")),
+                        (Some(rcstr!("c.js")), rcstr!("a.js")),
+                        // we start following the cycle again
+                        (Some(rcstr!("a.js")), rcstr!("b.js")),
+                        (Some(rcstr!("b.js")), rcstr!("c.js")),
+                    ],
+                    visits
+                );
+
+                Ok(())
+            },
+        )
+        .await;
+    }
     #[turbo_tasks::value(shared)]
     struct TestRepo {
         repo: FxHashMap<FileSystemPath, Vec<FileSystemPath>>,
diff --git a/turbopack/crates/turbopack-trace-server/src/main.rs b/turbopack/crates/turbopack-trace-server/src/main.rs
index 6e49291fca..c3f9ddaa96 100644
--- a/turbopack/crates/turbopack-trace-server/src/main.rs
+++ b/turbopack/crates/turbopack-trace-server/src/main.rs
@@ -30,7 +30,9 @@ fn main() {
     let args: FxIndexSet<String> = std::env::args().skip(1).collect();
 
     let mut iter = args.iter();
-    let arg = iter.next().expect("missing argument: trace file path");
+    let arg = iter
+        .next()
+        .expect("missing positional argument for the trace file path");
     let port = iter.next().map_or(5747, |s| s.parse().unwrap());
 
     let store = Arc::new(StoreContainer::new());
