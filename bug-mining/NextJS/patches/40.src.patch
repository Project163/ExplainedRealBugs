diff --git a/turbopack/crates/turbopack-ecmascript/src/code_gen.rs b/turbopack/crates/turbopack-ecmascript/src/code_gen.rs
index f1fe76ce8f..bd77f1da1c 100644
--- a/turbopack/crates/turbopack-ecmascript/src/code_gen.rs
+++ b/turbopack/crates/turbopack-ecmascript/src/code_gen.rs
@@ -1,11 +1,14 @@
 use anyhow::Result;
 use serde::{Deserialize, Serialize};
-use swc_core::ecma::{
-    ast::{
-        BlockStmt, CallExpr, Expr, Lit, MemberExpr, ModuleDecl, ModuleItem, Pat, Program, Prop,
-        SimpleAssignTarget, Stmt, Str, SwitchCase,
+use swc_core::{
+    base::SwcComments,
+    ecma::{
+        ast::{
+            BlockStmt, CallExpr, Expr, Lit, MemberExpr, ModuleDecl, ModuleItem, Pat, Program, Prop,
+            SimpleAssignTarget, Stmt, Str, SwitchCase,
+        },
+        visit::AstParentKind,
     },
-    visit::AstParentKind,
 };
 use turbo_rcstr::RcStr;
 use turbo_tasks::{NonLocalValue, ResolvedVc, Vc, debug::ValueDebugFormat, trace::TraceRawVcs};
@@ -41,6 +44,7 @@ pub struct CodeGeneration {
     pub visitors: Vec<(Vec<AstParentKind>, Box<dyn AstModifier>)>,
     pub hoisted_stmts: Vec<CodeGenerationHoistedStmt>,
     pub early_hoisted_stmts: Vec<CodeGenerationHoistedStmt>,
+    pub comments: Option<SwcComments>,
 }
 
 impl CodeGeneration {
@@ -59,6 +63,18 @@ impl CodeGeneration {
             visitors,
             hoisted_stmts,
             early_hoisted_stmts,
+            ..Default::default()
+        }
+    }
+
+    pub fn visitors_with_comments(
+        visitors: Vec<(Vec<AstParentKind>, Box<dyn AstModifier>)>,
+        comments: SwcComments,
+    ) -> Self {
+        CodeGeneration {
+            visitors,
+            comments: Some(comments),
+            ..Default::default()
         }
     }
 
diff --git a/turbopack/crates/turbopack-ecmascript/src/lib.rs b/turbopack/crates/turbopack-ecmascript/src/lib.rs
index af2caa9eed..797219c0a0 100644
--- a/turbopack/crates/turbopack-ecmascript/src/lib.rs
+++ b/turbopack/crates/turbopack-ecmascript/src/lib.rs
@@ -50,7 +50,12 @@ pub use references::{AnalyzeEcmascriptModuleResult, TURBOPACK_HELPER};
 use serde::{Deserialize, Serialize};
 pub use static_code::StaticEcmascriptCode;
 use swc_core::{
-    common::{DUMMY_SP, GLOBALS, Globals, Mark, SourceMap, comments::Comments, util::take::Take},
+    base::SwcComments,
+    common::{
+        BytePos, DUMMY_SP, GLOBALS, Globals, Mark, SourceMap,
+        comments::{Comment, Comments},
+        util::take::Take,
+    },
     ecma::{
         ast::{self, Expr, ModuleItem, Program, Script},
         codegen::{Emitter, text_writer::JsWriter},
@@ -956,6 +961,7 @@ struct CodeGenResult {
     program: Program,
     source_map: Arc<SourceMap>,
     comments: Either<ImmutableComments, Arc<ImmutableComments>>,
+    extra_comments: SwcComments,
     is_esm: bool,
     generate_source_map: bool,
     original_source_map: Option<ResolvedVc<Box<dyn GenerateSourceMap>>>,
@@ -965,7 +971,7 @@ async fn process_parse_result(
     parsed: ResolvedVc<ParseResult>,
     ident: Vc<AssetIdent>,
     specified_module_type: SpecifiedModuleType,
-    code_gens: Vec<CodeGeneration>,
+    mut code_gens: Vec<CodeGeneration>,
     generate_source_map: bool,
     original_source_map: Option<ResolvedVc<Box<dyn GenerateSourceMap>>>,
 ) -> Result<CodeGenResult> {
@@ -973,6 +979,11 @@ async fn process_parse_result(
 
     Ok(match &*parsed {
         ParseResult::Ok { .. } => {
+            let extra_comments = SwcComments {
+                leading: Default::default(),
+                trailing: Default::default(),
+            };
+
             // We need a mutable version of the AST. We try to avoid cloning it by unwrapping the
             // ReadRef.
             let mut parsed = ReadRef::try_unwrap(parsed);
@@ -1017,12 +1028,31 @@ async fn process_parse_result(
             let top_level_mark = eval_context.top_level_mark;
             let is_esm = eval_context.is_esm(specified_module_type);
 
-            process_content_with_code_gens(&mut program, globals, Some(top_level_mark), code_gens);
+            process_content_with_code_gens(
+                &mut program,
+                globals,
+                Some(top_level_mark),
+                &mut code_gens,
+            );
+
+            for comments in code_gens.iter_mut().flat_map(|cg| cg.comments.as_mut()) {
+                let leading = Arc::unwrap_or_clone(take(&mut comments.leading));
+                let trailing = Arc::unwrap_or_clone(take(&mut comments.trailing));
+
+                for (pos, v) in leading {
+                    extra_comments.leading.entry(pos).or_default().extend(v);
+                }
+
+                for (pos, v) in trailing {
+                    extra_comments.trailing.entry(pos).or_default().extend(v);
+                }
+            }
 
             CodeGenResult {
                 program,
                 source_map: source_map.clone(),
                 comments,
+                extra_comments,
                 is_esm,
                 generate_source_map,
                 original_source_map,
@@ -1052,6 +1082,7 @@ async fn process_parse_result(
                 }),
                 source_map: Arc::new(SourceMap::default()),
                 comments: Either::Left(Default::default()),
+                extra_comments: Default::default(),
                 is_esm: false,
                 generate_source_map: false,
                 original_source_map: None,
@@ -1076,6 +1107,7 @@ async fn process_parse_result(
                 }),
                 source_map: Arc::new(SourceMap::default()),
                 comments: Either::Left(Default::default()),
+                extra_comments: Default::default(),
                 is_esm: false,
                 generate_source_map: false,
                 original_source_map: None,
@@ -1089,6 +1121,7 @@ async fn emit_content(content: CodeGenResult) -> Result<Vc<EcmascriptModuleConte
         program,
         source_map,
         comments,
+        extra_comments,
         is_esm,
         generate_source_map,
         original_source_map,
@@ -1110,6 +1143,11 @@ async fn emit_content(content: CodeGenResult) -> Result<Vc<EcmascriptModuleConte
             Either::Right(comments) => comments,
         };
 
+        let comments = MergedComments {
+            baseline: comments,
+            mutable: extra_comments,
+        };
+
         let mut wr = JsWriter::new(
             source_map.clone(),
             "\n",
@@ -1121,7 +1159,7 @@ async fn emit_content(content: CodeGenResult) -> Result<Vc<EcmascriptModuleConte
         let mut emitter = Emitter {
             cfg: swc_core::ecma::codegen::Config::default(),
             cm: source_map.clone(),
-            comments: Some(&comments),
+            comments: Some(&comments as &dyn Comments),
             wr,
         };
 
@@ -1162,13 +1200,13 @@ fn process_content_with_code_gens(
     program: &mut Program,
     globals: &Globals,
     top_level_mark: Option<Mark>,
-    mut code_gens: Vec<CodeGeneration>,
+    code_gens: &mut Vec<CodeGeneration>,
 ) {
     let mut visitors = Vec::new();
     let mut root_visitors = Vec::new();
     let mut early_hoisted_stmts = FxIndexMap::default();
     let mut hoisted_stmts = FxIndexMap::default();
-    for code_gen in &mut code_gens {
+    for code_gen in code_gens {
         for CodeGenerationHoistedStmt { key, stmt } in code_gen.hoisted_stmts.drain(..) {
             hoisted_stmts.entry(key).or_insert(stmt);
         }
@@ -1231,6 +1269,104 @@ fn process_content_with_code_gens(
     };
 }
 
+struct MergedComments<A, B>
+where
+    A: Comments,
+    B: Comments,
+{
+    baseline: A,
+    mutable: B,
+}
+
+impl<A, B> Comments for MergedComments<A, B>
+where
+    A: Comments,
+    B: Comments,
+{
+    fn add_leading(&self, pos: BytePos, cmt: Comment) {
+        self.mutable.add_leading(pos, cmt);
+    }
+
+    fn add_leading_comments(&self, pos: BytePos, comments: Vec<Comment>) {
+        self.mutable.add_leading_comments(pos, comments);
+    }
+
+    fn has_leading(&self, pos: BytePos) -> bool {
+        self.baseline.has_leading(pos) || self.mutable.has_leading(pos)
+    }
+
+    fn move_leading(&self, from: BytePos, to: BytePos) {
+        self.baseline.move_leading(from, to);
+        self.mutable.move_leading(from, to);
+    }
+
+    fn take_leading(&self, pos: BytePos) -> Option<Vec<Comment>> {
+        let (v1, v2) = (
+            self.baseline.take_leading(pos),
+            self.mutable.take_leading(pos),
+        );
+
+        merge_option_vec(v1, v2)
+    }
+
+    fn get_leading(&self, pos: BytePos) -> Option<Vec<Comment>> {
+        let (v1, v2) = (
+            self.baseline.get_leading(pos),
+            self.mutable.get_leading(pos),
+        );
+
+        merge_option_vec(v1, v2)
+    }
+
+    fn add_trailing(&self, pos: BytePos, cmt: Comment) {
+        self.mutable.add_trailing(pos, cmt);
+    }
+
+    fn add_trailing_comments(&self, pos: BytePos, comments: Vec<Comment>) {
+        self.mutable.add_trailing_comments(pos, comments);
+    }
+
+    fn has_trailing(&self, pos: BytePos) -> bool {
+        self.baseline.has_trailing(pos) || self.mutable.has_trailing(pos)
+    }
+
+    fn move_trailing(&self, from: BytePos, to: BytePos) {
+        self.baseline.move_trailing(from, to);
+        self.mutable.move_trailing(from, to);
+    }
+
+    fn take_trailing(&self, pos: BytePos) -> Option<Vec<Comment>> {
+        let (v1, v2) = (
+            self.baseline.take_trailing(pos),
+            self.mutable.take_trailing(pos),
+        );
+
+        merge_option_vec(v1, v2)
+    }
+
+    fn get_trailing(&self, pos: BytePos) -> Option<Vec<Comment>> {
+        let (v1, v2) = (
+            self.baseline.get_trailing(pos),
+            self.mutable.get_trailing(pos),
+        );
+
+        merge_option_vec(v1, v2)
+    }
+
+    fn add_pure_comment(&self, pos: BytePos) {
+        self.mutable.add_pure_comment(pos);
+    }
+}
+
+fn merge_option_vec<T>(a: Option<Vec<T>>, b: Option<Vec<T>>) -> Option<Vec<T>> {
+    match (a, b) {
+        (Some(a), Some(b)) => Some(a.into_iter().chain(b).collect()),
+        (Some(a), None) => Some(a),
+        (None, Some(b)) => Some(b),
+        (None, None) => None,
+    }
+}
+
 pub fn register() {
     turbo_tasks::register();
     turbo_tasks_fs::register();
diff --git a/turbopack/crates/turbopack-ecmascript/src/references/unreachable.rs b/turbopack/crates/turbopack-ecmascript/src/references/unreachable.rs
index 30c53dbe5a..081b60f769 100644
--- a/turbopack/crates/turbopack-ecmascript/src/references/unreachable.rs
+++ b/turbopack/crates/turbopack-ecmascript/src/references/unreachable.rs
@@ -1,14 +1,20 @@
-use std::mem::take;
+use std::{mem::take, sync::LazyLock};
 
 use anyhow::Result;
 use serde::{Deserialize, Serialize};
 use swc_core::{
-    common::{Spanned, util::take::Take},
+    atoms::Atom,
+    base::SwcComments,
+    common::{
+        DUMMY_SP, Span, Spanned,
+        comments::{Comment, CommentKind, Comments},
+        util::take::Take,
+    },
     ecma::{
         ast::{
             ArrayPat, ArrowExpr, AssignPat, AssignPatProp, BindingIdent, BlockStmt, ClassDecl,
-            Decl, FnDecl, Ident, KeyValuePatProp, ObjectPat, ObjectPatProp, Pat, RestPat, Stmt,
-            VarDecl, VarDeclKind, VarDeclarator,
+            Decl, EmptyStmt, Expr, FnDecl, Ident, KeyValuePatProp, Lit, ObjectPat, ObjectPatProp,
+            Pat, RestPat, Stmt, Str, SwitchCase, VarDecl, VarDeclKind, VarDeclarator,
         },
         visit::{
             AstParentKind, VisitMut, VisitMutWith,
@@ -21,8 +27,7 @@ use turbo_tasks::{NonLocalValue, Vc, debug::ValueDebugFormat, trace::TraceRawVcs
 use turbopack_core::{chunk::ChunkingContext, module_graph::ModuleGraph};
 
 use crate::{
-    code_gen::{CodeGen, CodeGeneration},
-    create_visitor,
+    code_gen::{AstModifier, CodeGen, CodeGeneration},
     utils::AstPathRange,
 };
 
@@ -32,6 +37,101 @@ pub struct Unreachable {
     range: AstPathRange,
 }
 
+static UNREACHABLE_ATOM: LazyLock<Atom> = LazyLock::new(|| "TURBOPACK unreachable".into());
+
+struct UnreachableModifier {
+    comments: SwcComments,
+}
+
+impl AstModifier for UnreachableModifier {
+    fn visit_mut_expr(&self, node: &mut Expr) {
+        // We use an AST node instead of a comment here because we need to replace it with a valid
+        // JS expression anyway.
+        let span = node.span();
+
+        *node = Expr::Lit(Lit::Str(Str {
+            span,
+            value: UNREACHABLE_ATOM.clone(),
+            raw: None,
+        }));
+    }
+
+    fn visit_mut_stmt(&self, stmt: &mut Stmt) {
+        let mut replacement = Vec::new();
+
+        let span = Span::dummy_with_cmt();
+
+        self.comments.add_leading(
+            span.lo,
+            Comment {
+                kind: CommentKind::Line,
+                span: DUMMY_SP,
+                text: UNREACHABLE_ATOM.clone(),
+            },
+        );
+
+        stmt.visit_mut_with(&mut ExtractDeclarations {
+            stmts: &mut replacement,
+            in_nested_block_scope: false,
+        });
+
+        if replacement.is_empty() {
+            *stmt = Stmt::Empty(EmptyStmt { span });
+            return;
+        }
+
+        *stmt = Stmt::Block(BlockStmt {
+            span,
+            stmts: replacement,
+            ..Default::default()
+        });
+    }
+}
+
+struct UnreachableRangeModifier {
+    comments: SwcComments,
+    start_index: usize,
+}
+
+impl AstModifier for UnreachableRangeModifier {
+    fn visit_mut_block_stmt(&self, block: &mut BlockStmt) {
+        self.replace(&mut block.stmts, self.start_index);
+    }
+
+    fn visit_mut_switch_case(&self, case: &mut SwitchCase) {
+        self.replace(&mut case.cons, self.start_index);
+    }
+}
+
+impl UnreachableRangeModifier {
+    fn replace(&self, stmts: &mut Vec<Stmt>, start_index: usize) {
+        if stmts.len() > start_index + 1 {
+            let span = Span::dummy_with_cmt();
+
+            self.comments.add_leading(
+                span.lo,
+                Comment {
+                    kind: CommentKind::Line,
+                    span: DUMMY_SP,
+                    text: UNREACHABLE_ATOM.clone(),
+                },
+            );
+
+            let unreachable_stmt = Stmt::Empty(EmptyStmt { span });
+
+            let unreachable = stmts
+                .splice(start_index + 1.., [unreachable_stmt])
+                .collect::<Vec<_>>();
+            for mut stmt in unreachable {
+                stmt.visit_mut_with(&mut ExtractDeclarations {
+                    stmts,
+                    in_nested_block_scope: false,
+                });
+            }
+        }
+    }
+}
+
 impl Unreachable {
     pub fn new(range: AstPathRange) -> Self {
         Unreachable { range }
@@ -42,31 +142,15 @@ impl Unreachable {
         _module_graph: Vc<ModuleGraph>,
         _chunking_context: Vc<Box<dyn ChunkingContext>>,
     ) -> Result<CodeGeneration> {
+        let comments = SwcComments::default();
+
         let visitors = match &self.range {
-            AstPathRange::Exact(path) => {
-                [
-                    // Unreachable might be used on Stmt or Expr
-                    create_visitor!(exact path, visit_mut_expr(expr: &mut Expr) {
-                        *expr = quote!("(\"TURBOPACK unreachable\", undefined)" as Expr);
-                    }),
-                    create_visitor!(exact path, visit_mut_stmt(stmt: &mut Stmt) {
-                        // TODO(WEB-553) walk ast to find all `var` declarations and keep them
-                        // since they hoist out of the scope
-                        let mut replacement = Vec::new();
-                        replacement.push(quote!("\"TURBOPACK unreachable\";" as Stmt));
-                        stmt.visit_mut_with(&mut ExtractDeclarations {
-                            stmts: &mut replacement,
-                            in_nested_block_scope: false,
-                        });
-                        *stmt = Stmt::Block(BlockStmt {
-                            span: stmt.span(),
-                            stmts: replacement,
-                            ..Default::default()
-                        });
-                    }),
-                ]
-                .into()
-            }
+            AstPathRange::Exact(path) => vec![(
+                path.clone(),
+                Box::new(UnreachableModifier {
+                    comments: comments.clone(),
+                }) as Box<dyn AstModifier>,
+            )],
             AstPathRange::StartAfter(path) => {
                 let mut parent = &path[..];
                 while !parent.is_empty()
@@ -76,41 +160,28 @@ impl Unreachable {
                 }
                 if !parent.is_empty() {
                     parent = &parent[0..parent.len() - 1];
-                    fn replace(stmts: &mut Vec<Stmt>, start_index: usize) {
-                        if stmts.len() > start_index + 1 {
-                            let unreachable = stmts
-                                .splice(
-                                    start_index + 1..,
-                                    [quote!("\"TURBOPACK unreachable\";" as Stmt)].into_iter(),
-                                )
-                                .collect::<Vec<_>>();
-                            for mut stmt in unreachable {
-                                stmt.visit_mut_with(&mut ExtractDeclarations {
-                                    stmts,
-                                    in_nested_block_scope: false,
-                                });
-                            }
-                        }
-                    }
+
                     let (parent, [last]) = parent.split_at(parent.len() - 1) else {
                         unreachable!();
                     };
                     if let &AstParentKind::BlockStmt(BlockStmtField::Stmts(start_index)) = last {
-                        [
-                            create_visitor!(exact parent, visit_mut_block_stmt(block: &mut BlockStmt) {
-                                replace(&mut block.stmts, start_index);
-                            }),
-                        ]
-                        .into()
+                        vec![(
+                            parent.to_vec(),
+                            Box::new(UnreachableRangeModifier {
+                                comments: comments.clone(),
+                                start_index,
+                            }) as Box<dyn AstModifier>,
+                        )]
                     } else if let &AstParentKind::SwitchCase(SwitchCaseField::Cons(start_index)) =
                         last
                     {
-                        [
-                            create_visitor!(exact parent, visit_mut_switch_case(case: &mut SwitchCase) {
-                                replace(&mut case.cons, start_index);
-                            }),
-                        ]
-                        .into()
+                        vec![(
+                            parent.to_vec(),
+                            Box::new(UnreachableRangeModifier {
+                                comments: comments.clone(),
+                                start_index,
+                            }) as Box<dyn AstModifier>,
+                        )]
                     } else {
                         Vec::new()
                     }
@@ -120,7 +191,7 @@ impl Unreachable {
             }
         };
 
-        Ok(CodeGeneration::visitors(visitors))
+        Ok(CodeGeneration::visitors_with_comments(visitors, comments))
     }
 }
 
diff --git a/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_define_input_index_4d74c0a3.js b/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_define_input_index_4d74c0a3.js
index 35669b6374..1c8fe0bb0c 100644
--- a/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_define_input_index_4d74c0a3.js
+++ b/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_define_input_index_4d74c0a3.js
@@ -16,17 +16,15 @@ console.log('A.VERY.LONG.DEFINED.VALUE');
 if ("TURBOPACK compile-time truthy", 1) {
 console.log('something');
 }
-if ("TURBOPACK compile-time falsy", 0) {
-"TURBOPACK unreachable";
-}
+if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
+;
 var p = process;
 console.log(("TURBOPACK compile-time value", JSON.parse('{"test":true}')));
 console.log(("TURBOPACK compile-time value", "value"));
 console.log(("TURBOPACK compile-time value", "development"));
-if ("TURBOPACK compile-time falsy", 0) {
-"TURBOPACK unreachable";
-}
-("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : console.log('development');
+if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
+;
+("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : console.log('development');
 // TODO short-circuit is not implemented yet
 ("TURBOPACK compile-time value", "development") != 'production' && console.log('development');
 ("TURBOPACK compile-time value", "development") == 'production' && console.log('production');
diff --git a/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_define_input_index_4d74c0a3.js.map b/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_define_input_index_4d74c0a3.js.map
index 248cc66d21..1d18f8bff5 100644
--- a/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_define_input_index_4d74c0a3.js.map
+++ b/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_define_input_index_4d74c0a3.js.map
@@ -2,5 +2,5 @@
   "version": 3,
   "sources": [],
   "sections": [
-    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/input/index.js"],"sourcesContent":["if (DEFINED_VALUE) {\n  console.log('DEFINED_VALUE')\n}\n\nif (DEFINED_TRUE) {\n  console.log('DEFINED_VALUE')\n}\n\nif (A.VERY.LONG.DEFINED.VALUE) {\n  console.log('A.VERY.LONG.DEFINED.VALUE')\n}\n\nif (process.env.NODE_ENV) {\n  console.log('something')\n}\n\nif (process.env.NODE_ENV === 'production') {\n  console.log('production')\n}\n\nvar p = process\n\nconsole.log(A.VERY.LONG.DEFINED.VALUE)\nconsole.log(DEFINED_VALUE)\nconsole.log(p.env.NODE_ENV)\n\nif (p.env.NODE_ENV === 'production') {\n  console.log('production')\n}\n\np.env.NODE_ENV == 'production'\n  ? console.log('production')\n  : console.log('development')\n\n// TODO short-circuit is not implemented yet\np.env.NODE_ENV != 'production' && console.log('development')\np.env.NODE_ENV == 'production' && console.log('production')\n\nconsole.log(__dirname)\n"],"names":[],"mappings":"AAAA,wCAAmB;AACjB,QAAQ,GAAG,CAAC;AACd;AAEA,wCAAkB;AAChB,QAAQ,GAAG,CAAC;AACd;AAEA,iEAA+B;AAC7B,QAAQ,GAAG,CAAC;AACd;AAEA,wCAA0B;AACxB,QAAQ,GAAG,CAAC;AACd;AAEA,uCAA2C;;AAE3C;AAEA,IAAI,IAAI;AAER,QAAQ,GAAG;AACX,QAAQ,GAAG;AACX,QAAQ,GAAG;AAEX,uCAAqC;;AAErC;AAEA,6EAEI,QAAQ,GAAG,CAAC;AAEhB,4CAA4C;AAC5C,mDAAkB,gBAAgB,QAAQ,GAAG,CAAC;AAC9C,mDAAkB,gBAAgB,QAAQ,GAAG,CAAC;AAE9C,QAAQ,GAAG"}}]
+    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/comptime/define/input/index.js"],"sourcesContent":["if (DEFINED_VALUE) {\n  console.log('DEFINED_VALUE')\n}\n\nif (DEFINED_TRUE) {\n  console.log('DEFINED_VALUE')\n}\n\nif (A.VERY.LONG.DEFINED.VALUE) {\n  console.log('A.VERY.LONG.DEFINED.VALUE')\n}\n\nif (process.env.NODE_ENV) {\n  console.log('something')\n}\n\nif (process.env.NODE_ENV === 'production') {\n  console.log('production')\n}\n\nvar p = process\n\nconsole.log(A.VERY.LONG.DEFINED.VALUE)\nconsole.log(DEFINED_VALUE)\nconsole.log(p.env.NODE_ENV)\n\nif (p.env.NODE_ENV === 'production') {\n  console.log('production')\n}\n\np.env.NODE_ENV == 'production'\n  ? console.log('production')\n  : console.log('development')\n\n// TODO short-circuit is not implemented yet\np.env.NODE_ENV != 'production' && console.log('development')\np.env.NODE_ENV == 'production' && console.log('production')\n\nconsole.log(__dirname)\n"],"names":[],"mappings":"AAAA,wCAAmB;AACjB,QAAQ,GAAG,CAAC;AACd;AAEA,wCAAkB;AAChB,QAAQ,GAAG,CAAC;AACd;AAEA,iEAA+B;AAC7B,QAAQ,GAAG,CAAC;AACd;AAEA,wCAA0B;AACxB,QAAQ,GAAG,CAAC;AACd;AAEA;;AAIA,IAAI,IAAI;AAER,QAAQ,GAAG;AACX,QAAQ,GAAG;AACX,QAAQ,GAAG;AAEX;;AAIA,sCACI,0BACA,QAAQ,GAAG,CAAC;AAEhB,4CAA4C;AAC5C,mDAAkB,gBAAgB,QAAQ,GAAG,CAAC;AAC9C,mDAAkB,gBAAgB,QAAQ,GAAG,CAAC;AAE9C,QAAQ,GAAG"}}]
 }
\ No newline at end of file
diff --git a/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_early-return_input_82bbae08._.js b/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_early-return_input_82bbae08._.js
index cee688a786..9277e570f4 100644
--- a/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_early-return_input_82bbae08._.js
+++ b/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_early-return_input_82bbae08._.js
@@ -20,7 +20,8 @@ if ("TURBOPACK compile-time truthy", 1) {
 a1();
 return;
 }
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 var a3;
 function a4() {
 var a5;
@@ -31,7 +32,8 @@ let a11;
 let a12, a15, a17, a18, a19;
 function a20() {
 return;
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 var a28;
 }
@@ -39,54 +41,59 @@ function b() {
 if ("TURBOPACK compile-time truthy", 1) {
 b1();
 return;
-} else {
-"TURBOPACK unreachable";
-}
-"TURBOPACK unreachable";
+} else //TURBOPACK unreachable
+;
+//TURBOPACK unreachable
+;
 }
 function c() {
 if ("TURBOPACK compile-time truthy", 1) {
 return;
 }
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 function d() {
 if ("TURBOPACK compile-time truthy", 1) {
 return;
-} else {
-"TURBOPACK unreachable";
-}
-"TURBOPACK unreachable";
+} else //TURBOPACK unreachable
+;
+//TURBOPACK unreachable
+;
 }
 function e() {
-if ("TURBOPACK compile-time falsy", 0) {
-"TURBOPACK unreachable";
-} else {
+if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
+;
+else {
 return;
 }
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 function f() {
 if ("TURBOPACK compile-time falsy", 0) {} else {
 return;
 }
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 function g() {
-if ("TURBOPACK compile-time falsy", 0) {
-"TURBOPACK unreachable";
-} else {
+if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
+;
+else {
 g2();
 return;
 }
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 function h() {
 if ("TURBOPACK compile-time falsy", 0) {} else {
 h1();
 return;
 }
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 function i(j) {
 if (j < 1) return i1();
@@ -105,7 +112,8 @@ k1();
 } catch (e) {
 k2();
 return;
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 } finally{
 k4();
 }
@@ -119,28 +127,33 @@ l2();
 } finally{
 l3();
 return;
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 get m() {
 if ("TURBOPACK compile-time truthy", 1) {
 m1();
 return;
 }
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 set m(value) {
 m1();
 return m2();
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 n = ()=>{
 switch(42){
 case 1:
 n1();
 return;
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 case 2:
 n3();
 break;
@@ -164,12 +177,14 @@ class C {
 constructor(){
 p1();
 return;
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 }
 p3();
 return;
-"TURBOPACK unreachable";
+//TURBOPACK unreachable
+;
 }
 z1();
 return;
diff --git a/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_early-return_input_82bbae08._.js.map b/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_early-return_input_82bbae08._.js.map
index 2238c9d6e8..4dd7f3dba0 100644
--- a/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_early-return_input_82bbae08._.js.map
+++ b/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_early-return_input_82bbae08._.js.map
@@ -2,6 +2,6 @@
   "version": 3,
   "sources": [],
   "sections": [
-    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/input/module.js"],"sourcesContent":["export function a() {\n  if (true) {\n    a1()\n    return\n  }\n  a2()\n  var a3 = 3\n  function a4() {\n    var a5\n  }\n  ;(function a6() {\n    var a7\n  })\n  const a8 = () => {\n    var a9\n  }\n  class a10 {}\n  let a11 = 11\n  let {\n    a12 = 12,\n    a14: {\n      a15,\n      a16: [a17, ...a18],\n    },\n    ...a19\n  } = {}\n  function a20() {\n    return\n    a21()\n  }\n  ;({\n    get a22() {\n      var a23\n    },\n    set a22(value) {\n      var a24\n    },\n    a25() {\n      var a26\n    },\n  })\n  {\n    let a27\n    var a28\n  }\n}\n\nexport function b() {\n  if (true) {\n    b1()\n    return\n  } else {\n    b2()\n  }\n  b3()\n}\n\nexport function c() {\n  if (true) {\n    return\n  }\n  c1()\n}\n\nexport function d() {\n  if (true) {\n    return\n  } else {\n    d1()\n  }\n  d2()\n}\n\nexport function e() {\n  if (false) {\n    e1()\n  } else {\n    return\n  }\n  e2()\n}\n\nexport function f() {\n  if (false) {\n  } else {\n    return\n  }\n  f1()\n}\n\nexport function g() {\n  if (false) {\n    g1()\n  } else {\n    g2()\n    return\n  }\n  g3()\n}\n\nexport function h() {\n  if (false) {\n  } else {\n    h1()\n    return\n  }\n  h2()\n}\n\nexport function i(j) {\n  if (j < 1) return i1()\n  return i2()\n}\n\nexport function j(j) {\n  if (j < 1) {\n    return i1()\n  }\n  return i2()\n}\n\nclass K {\n  constructor() {\n    try {\n      k1()\n    } catch (e) {\n      k2()\n      return\n      k3()\n    } finally {\n      k4()\n    }\n    k5()\n  }\n\n  l() {\n    try {\n      l1()\n    } catch (e) {\n      l2()\n    } finally {\n      l3()\n      return\n      l4()\n    }\n    l5()\n  }\n\n  get m() {\n    if (true) {\n      m1()\n      return\n    }\n    m2()\n  }\n\n  set m(value) {\n    m1()\n    return m2()\n    m3()\n  }\n\n  n = () => {\n    switch (42) {\n      case 1:\n        n1()\n        return\n        n2()\n      case 2:\n        n3()\n        break\n      default:\n        n4()\n    }\n    n5()\n  }\n\n  o() {\n    if (something) {\n      require('./module')\n      return\n    } else {\n      require('./module')\n      return\n    }\n  }\n}\n\nfunction p() {\n  class C {\n    constructor() {\n      p1()\n      return\n      p2()\n    }\n  }\n\n  p3()\n  return\n  p4()\n}\n\nz1()\n\nreturn\n\nz2()\n"],"names":[],"mappings":";;;;;;;;;;;;AAAO,SAAS;AACd,wCAAU;AACR;AACA;AACF;;AAEA,IAAI;AACJ,SAAS;AACP,IAAI;AACN;AAIA,MAAM;AAGA,IAAA;AACN,IAAI;AACJ,IACE,KAEE,KACM,KAAQ,KAEb;AAEL,SAAS;AACP;;AAEF;AAcE,IAAI;AAER;AAEO,SAAS;AACd,wCAAU;AACR;AACA;AACF,OAAO;;AAEP;;AAEF;AAEO,SAAS;AACd,wCAAU;AACR;AACF;;AAEF;AAEO,SAAS;AACd,wCAAU;AACR;AACF,OAAO;;AAEP;;AAEF;AAEO,SAAS;AACd,uCAAW;;AAEX,OAAO;AACL;AACF;;AAEF;AAEO,SAAS;AACd,uCAAW,CACX,OAAO;AACL;AACF;;AAEF;AAEO,SAAS;AACd,uCAAW;;AAEX,OAAO;AACL;AACA;AACF;;AAEF;AAEO,SAAS;AACd,uCAAW,CACX,OAAO;AACL;AACA;AACF;;AAEF;AAEO,SAAS,EAAE,CAAC;AACjB,IAAI,IAAI,GAAG,OAAO;AAClB,OAAO;AACT;AAEO,SAAS,EAAE,CAAC;AACjB,IAAI,IAAI,GAAG;AACT,OAAO;AACT;AACA,OAAO;AACT;AAEA,MAAM;AACJ,aAAc;AACZ,IAAI;AACF;AACF,EAAE,OAAO,GAAG;AACV;AACA;;AAEF,SAAU;AACR;AACF;AACA;AACF;AAEA,IAAI;AACF,IAAI;AACF;AACF,EAAE,OAAO,GAAG;AACV;AACF,SAAU;AACR;AACA;;AAEF;;AAEF;AAEA,IAAI,IAAI;AACN,wCAAU;AACR;AACA;AACF;;AAEF;AAEA,IAAI,EAAE,KAAK,EAAE;AACX;AACA,OAAO;;AAET;AAEA,IAAI;AACF,OAAQ;AACN,KAAK;AACH;AACA;;AAEF,KAAK;AACH;AACA;AACF;AACE;AACJ;AACA;AACF,EAAC;AAED,IAAI;AACF,IAAI,WAAW;;AAEb;AACF,OAAO;;AAEL;AACF;AACF;AACF;AAEA,SAAS;AACP,MAAM;AACJ,aAAc;AACZ;AACA;;AAEF;AACF;AAEA;AACA;;AAEF;AAEA;AAEA;AAEA"}},
-    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/input/index.js"],"sourcesContent":["import * as module from './module'\nconsole.log(module)\n"],"names":[],"mappings":";AAAA;;AACA,QAAQ,GAAG,CAAC"}}]
+    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/input/module.js"],"sourcesContent":["export function a() {\n  if (true) {\n    a1()\n    return\n  }\n  a2()\n  var a3 = 3\n  function a4() {\n    var a5\n  }\n  ;(function a6() {\n    var a7\n  })\n  const a8 = () => {\n    var a9\n  }\n  class a10 {}\n  let a11 = 11\n  let {\n    a12 = 12,\n    a14: {\n      a15,\n      a16: [a17, ...a18],\n    },\n    ...a19\n  } = {}\n  function a20() {\n    return\n    a21()\n  }\n  ;({\n    get a22() {\n      var a23\n    },\n    set a22(value) {\n      var a24\n    },\n    a25() {\n      var a26\n    },\n  })\n  {\n    let a27\n    var a28\n  }\n}\n\nexport function b() {\n  if (true) {\n    b1()\n    return\n  } else {\n    b2()\n  }\n  b3()\n}\n\nexport function c() {\n  if (true) {\n    return\n  }\n  c1()\n}\n\nexport function d() {\n  if (true) {\n    return\n  } else {\n    d1()\n  }\n  d2()\n}\n\nexport function e() {\n  if (false) {\n    e1()\n  } else {\n    return\n  }\n  e2()\n}\n\nexport function f() {\n  if (false) {\n  } else {\n    return\n  }\n  f1()\n}\n\nexport function g() {\n  if (false) {\n    g1()\n  } else {\n    g2()\n    return\n  }\n  g3()\n}\n\nexport function h() {\n  if (false) {\n  } else {\n    h1()\n    return\n  }\n  h2()\n}\n\nexport function i(j) {\n  if (j < 1) return i1()\n  return i2()\n}\n\nexport function j(j) {\n  if (j < 1) {\n    return i1()\n  }\n  return i2()\n}\n\nclass K {\n  constructor() {\n    try {\n      k1()\n    } catch (e) {\n      k2()\n      return\n      k3()\n    } finally {\n      k4()\n    }\n    k5()\n  }\n\n  l() {\n    try {\n      l1()\n    } catch (e) {\n      l2()\n    } finally {\n      l3()\n      return\n      l4()\n    }\n    l5()\n  }\n\n  get m() {\n    if (true) {\n      m1()\n      return\n    }\n    m2()\n  }\n\n  set m(value) {\n    m1()\n    return m2()\n    m3()\n  }\n\n  n = () => {\n    switch (42) {\n      case 1:\n        n1()\n        return\n        n2()\n      case 2:\n        n3()\n        break\n      default:\n        n4()\n    }\n    n5()\n  }\n\n  o() {\n    if (something) {\n      require('./module')\n      return\n    } else {\n      require('./module')\n      return\n    }\n  }\n}\n\nfunction p() {\n  class C {\n    constructor() {\n      p1()\n      return\n      p2()\n    }\n  }\n\n  p3()\n  return\n  p4()\n}\n\nz1()\n\nreturn\n\nz2()\n"],"names":[],"mappings":";;;;;;;;;;;;AAAO,SAAS;AACd,wCAAU;AACR;AACA;AACF;;;AAEA,IAAI;AACJ,SAAS;AACP,IAAI;AACN;AAIA,MAAM;AAGA,IAAA;AACN,IAAI;AACJ,IACE,KAEE,KACM,KAAQ,KAEb;AAEL,SAAS;AACP;;;AAEF;AAcE,IAAI;AAER;AAEO,SAAS;AACd,wCAAU;AACR;AACA;AACF;;;;AAIF;AAEO,SAAS;AACd,wCAAU;AACR;AACF;;;AAEF;AAEO,SAAS;AACd,wCAAU;AACR;AACF;;;;AAIF;AAEO,SAAS;AACd;;KAEO;AACL;AACF;;;AAEF;AAEO,SAAS;AACd,uCAAW,CACX,OAAO;AACL;AACF;;;AAEF;AAEO,SAAS;AACd;;KAEO;AACL;AACA;AACF;;;AAEF;AAEO,SAAS;AACd,uCAAW,CACX,OAAO;AACL;AACA;AACF;;;AAEF;AAEO,SAAS,EAAE,CAAC;AACjB,IAAI,IAAI,GAAG,OAAO;AAClB,OAAO;AACT;AAEO,SAAS,EAAE,CAAC;AACjB,IAAI,IAAI,GAAG;AACT,OAAO;AACT;AACA,OAAO;AACT;AAEA,MAAM;AACJ,aAAc;AACZ,IAAI;AACF;AACF,EAAE,OAAO,GAAG;AACV;AACA;;;AAEF,SAAU;AACR;AACF;AACA;AACF;AAEA,IAAI;AACF,IAAI;AACF;AACF,EAAE,OAAO,GAAG;AACV;AACF,SAAU;AACR;AACA;;;AAEF;;;AAEF;AAEA,IAAI,IAAI;AACN,wCAAU;AACR;AACA;AACF;;;AAEF;AAEA,IAAI,EAAE,KAAK,EAAE;AACX;AACA,OAAO;;;AAET;AAEA,IAAI;AACF,OAAQ;AACN,KAAK;AACH;AACA;;;AAEF,KAAK;AACH;AACA;AACF;AACE;AACJ;AACA;AACF,EAAC;AAED,IAAI;AACF,IAAI,WAAW;;AAEb;AACF,OAAO;;AAEL;AACF;AACF;AACF;AAEA,SAAS;AACP,MAAM;AACJ,aAAc;AACZ;AACA;;;AAEF;AACF;AAEA;AACA;;;AAEF;AAEA;AAEA;AAEA"}},
+    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/comptime/early-return/input/index.js"],"sourcesContent":["import * as module from './module'\nconsole.log(module)\n"],"names":[],"mappings":";AAAA;;AACA,QAAQ,GAAG,CAAC"}}]
 }
\ No newline at end of file
diff --git a/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/output/turbopack_crates_turbopack-tests_tests_snapshot_tree-shaking_dce_input_d299a335._.js b/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/output/turbopack_crates_turbopack-tests_tests_snapshot_tree-shaking_dce_input_d299a335._.js
index e642ac6bab..7790185531 100644
--- a/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/output/turbopack_crates_turbopack-tests_tests_snapshot_tree-shaking_dce_input_d299a335._.js
+++ b/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/output/turbopack_crates_turbopack-tests_tests_snapshot_tree-shaking_dce_input_d299a335._.js
@@ -12,9 +12,8 @@ __turbopack_context__.s({});
 __turbopack_context__.s({});
 var __TURBOPACK__imported__module__$5b$project$5d2f$turbopack$2f$crates$2f$turbopack$2d$tests$2f$tests$2f$snapshot$2f$tree$2d$shaking$2f$dce$2f$input$2f$module$2e$js__$5b$test$5d$__$28$ecmascript$29$__$3c$internal__part__3$3e$__ = __turbopack_context__.i("[project]/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/input/module.js [test] (ecmascript) <internal part 3>");
 ;
-if ("TURBOPACK compile-time falsy", 0) {
-"TURBOPACK unreachable";
-}
+if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
+;
 }),
 }]);
 
diff --git a/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/output/turbopack_crates_turbopack-tests_tests_snapshot_tree-shaking_dce_input_d299a335._.js.map b/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/output/turbopack_crates_turbopack-tests_tests_snapshot_tree-shaking_dce_input_d299a335._.js.map
index 9a141f145e..68289b49ea 100644
--- a/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/output/turbopack_crates_turbopack-tests_tests_snapshot_tree-shaking_dce_input_d299a335._.js.map
+++ b/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/output/turbopack_crates_turbopack-tests_tests_snapshot_tree-shaking_dce_input_d299a335._.js.map
@@ -3,5 +3,5 @@
   "sources": [],
   "sections": [
     {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
-    {"offset": {"line": 11, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/input/index.js"],"sourcesContent":["import { baz } from './module'\n\nif (1 + 1 == 3) {\n  baz()\n}\n"],"names":[],"mappings":";AAAA;;AAEA,uCAAgB;;AAEhB"}}]
+    {"offset": {"line": 11, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/tree-shaking/dce/input/index.js"],"sourcesContent":["import { baz } from './module'\n\nif (1 + 1 == 3) {\n  baz()\n}\n"],"names":[],"mappings":";AAAA;;AAEA"}}]
 }
\ No newline at end of file
