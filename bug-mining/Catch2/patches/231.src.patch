diff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp
index 79022dd4..8379a7aa 100644
--- a/src/catch2/internal/catch_run_context.cpp
+++ b/src/catch2/internal/catch_run_context.cpp
@@ -60,8 +60,9 @@ namespace Catch {
                     assert( childTracker->isGeneratorTracker() );
                     tracker = static_cast<GeneratorTracker*>( childTracker );
                 } else {
-                    auto newTracker = std::make_shared<GeneratorTracker>(
-                        nameAndLocation, ctx, &currentTracker );
+                    auto newTracker =
+                        Catch::Detail::make_unique<GeneratorTracker>(
+                            nameAndLocation, ctx, &currentTracker );
                     tracker = newTracker.get();
                     currentTracker.addChild( std::move(newTracker) );
                 }
@@ -96,7 +97,7 @@ namespace Catch {
                     if ( std::find_if(
                              m_children.begin(),
                              m_children.end(),
-                             []( TestCaseTracking::ITrackerPtr tracker ) {
+                             []( TestCaseTracking::ITrackerPtr const& tracker ) {
                                  return tracker->hasStarted();
                              } ) != m_children.end() ) {
                         return false;
@@ -105,7 +106,7 @@ namespace Catch {
                     // No children have started. We need to check if they _can_
                     // start, and thus we should wait for them, or they cannot
                     // start (due to filters), and we shouldn't wait for them
-                    auto* parent = m_parent;
+                    ITracker* parent = m_parent;
                     // This is safe: there is always at least one section
                     // tracker in a test case tracking tree
                     while ( !parent->isSectionTracker() ) {
@@ -115,7 +116,7 @@ namespace Catch {
                             "Missing root (test case) level section" );
 
                     auto const& parentSection =
-                        static_cast<SectionTracker&>( *parent );
+                        static_cast<SectionTracker const&>( *parent );
                     auto const& filters = parentSection.getFilters();
                     // No filters -> no restrictions on running sections
                     if ( filters.empty() ) {
@@ -124,11 +125,11 @@ namespace Catch {
 
                     for ( auto const& child : m_children ) {
                         if ( child->isSectionTracker() &&
-                             std::find( filters.begin(),
-                                        filters.end(),
-                                        static_cast<SectionTracker&>( *child )
-                                            .trimmedName() ) !=
-                                 filters.end() ) {
+                             std::find(
+                                 filters.begin(),
+                                 filters.end(),
+                                 static_cast<SectionTracker const&>( *child )
+                                     .trimmedName() ) != filters.end() ) {
                             return true;
                         }
                     }
diff --git a/src/catch2/internal/catch_test_case_tracker.cpp b/src/catch2/internal/catch_test_case_tracker.cpp
index b405ce86..2e8c3169 100644
--- a/src/catch2/internal/catch_test_case_tracker.cpp
+++ b/src/catch2/internal/catch_test_case_tracker.cpp
@@ -12,7 +12,6 @@
 
 #include <algorithm>
 #include <cassert>
-#include <memory>
 
 #if defined(__clang__)
 #    pragma clang diagnostic push
@@ -30,8 +29,8 @@ namespace TestCaseTracking {
 
     ITracker::~ITracker() = default;
 
-    void ITracker::addChild( ITrackerPtr const& child ) {
-        m_children.push_back( child );
+    void ITracker::addChild( ITrackerPtr&& child ) {
+        m_children.push_back( std::move(child) );
     }
 
     ITracker* ITracker::findChild( NameAndLocation const& nameAndLocation ) {
@@ -50,7 +49,10 @@ namespace TestCaseTracking {
 
     ITracker& TrackerContext::startRun() {
         using namespace std::string_literals;
-        m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( "{root}"s, CATCH_INTERNAL_LINEINFO ), *this, nullptr );
+        m_rootTracker = Catch::Detail::make_unique<SectionTracker>(
+            NameAndLocation( "{root}"s, CATCH_INTERNAL_LINEINFO ),
+            *this,
+            nullptr );
         m_currentTracker = nullptr;
         m_runState = Executing;
         return *m_rootTracker;
@@ -204,7 +206,7 @@ namespace TestCaseTracking {
             assert( childTracker->isSectionTracker() );
             section = static_cast<SectionTracker*>( childTracker );
         } else {
-            auto newSection = std::make_shared<SectionTracker>(
+            auto newSection = Catch::Detail::make_unique<SectionTracker>(
                 nameAndLocation, ctx, &currentTracker );
             section = newSection.get();
             currentTracker.addChild( std::move( newSection ) );
diff --git a/src/catch2/internal/catch_test_case_tracker.hpp b/src/catch2/internal/catch_test_case_tracker.hpp
index b1c5a8b4..a8d17ce4 100644
--- a/src/catch2/internal/catch_test_case_tracker.hpp
+++ b/src/catch2/internal/catch_test_case_tracker.hpp
@@ -10,10 +10,10 @@
 
 #include <catch2/internal/catch_compiler_capabilities.hpp>
 #include <catch2/internal/catch_source_line_info.hpp>
+#include <catch2/internal/catch_unique_ptr.hpp>
 
 #include <string>
 #include <vector>
-#include <memory>
 
 namespace Catch {
 namespace TestCaseTracking {
@@ -31,7 +31,7 @@ namespace TestCaseTracking {
 
     class ITracker;
 
-    using ITrackerPtr = std::shared_ptr<ITracker>;
+    using ITrackerPtr = Catch::Detail::unique_ptr<ITracker>;
 
     class  ITracker {
         NameAndLocation m_nameAndLocation;
@@ -69,7 +69,7 @@ namespace TestCaseTracking {
         virtual void markAsNeedingAnotherRun() = 0;
 
         //! Register a nested ITracker
-        void addChild( ITrackerPtr const& child );
+        void addChild( ITrackerPtr&& child );
         /**
          * Returns ptr to specific child if register with this tracker.
          *
