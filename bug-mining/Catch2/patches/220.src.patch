diff --git a/CMake/MiscFunctions.cmake b/CMake/MiscFunctions.cmake
index bca3f0e4..262fc5d4 100644
--- a/CMake/MiscFunctions.cmake
+++ b/CMake/MiscFunctions.cmake
@@ -62,6 +62,7 @@ function(add_warnings_to_targets targets)
           "-Wcall-to-pure-virtual-from-ctor-dtor"
           "-Wdeprecated-register"
           "-Wsuggest-override"
+          "-Wshadow"
         )
         foreach(warning ${CHECKED_WARNING_FLAGS})
             add_cxx_flag_if_supported_to_targets(${warning} "${targets}")
diff --git a/src/catch2/benchmark/catch_benchmark.hpp b/src/catch2/benchmark/catch_benchmark.hpp
index 641a2209..8ff69b4a 100644
--- a/src/catch2/benchmark/catch_benchmark.hpp
+++ b/src/catch2/benchmark/catch_benchmark.hpp
@@ -33,12 +33,12 @@
 namespace Catch {
     namespace Benchmark {
         struct Benchmark {
-            Benchmark(std::string &&name)
-                : name(std::move(name)) {}
+            Benchmark(std::string&& benchmarkName)
+                : name(std::move(benchmarkName)) {}
 
             template <class FUN>
-            Benchmark(std::string &&name, FUN &&func)
-                : fun(std::move(func)), name(std::move(name)) {}
+            Benchmark(std::string&& benchmarkName , FUN &&func)
+                : fun(std::move(func)), name(std::move(benchmarkName)) {}
 
             template <typename Clock>
             ExecutionPlan<FloatDuration<Clock>> prepare(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {
diff --git a/src/catch2/benchmark/catch_chronometer.hpp b/src/catch2/benchmark/catch_chronometer.hpp
index ae172aa6..10fd5a27 100644
--- a/src/catch2/benchmark/catch_chronometer.hpp
+++ b/src/catch2/benchmark/catch_chronometer.hpp
@@ -44,11 +44,11 @@ namespace Catch {
             template <typename Fun>
             void measure(Fun&& fun) { measure(std::forward<Fun>(fun), is_callable<Fun(int)>()); }
 
-            int runs() const { return k; }
+            int runs() const { return repeats; }
 
-            Chronometer(Detail::ChronometerConcept& meter, int k)
+            Chronometer(Detail::ChronometerConcept& meter, int repeats_)
                 : impl(&meter)
-                , k(k) {}
+                , repeats(repeats_) {}
 
         private:
             template <typename Fun>
@@ -60,13 +60,13 @@ namespace Catch {
             void measure(Fun&& fun, std::true_type) {
                 Detail::optimizer_barrier();
                 impl->start();
-                for (int i = 0; i < k; ++i) invoke_deoptimized(fun, i);
+                for (int i = 0; i < repeats; ++i) invoke_deoptimized(fun, i);
                 impl->finish();
                 Detail::optimizer_barrier();
             }
 
             Detail::ChronometerConcept* impl;
-            int k;
+            int repeats;
         };
     } // namespace Benchmark
 } // namespace Catch
diff --git a/src/catch2/benchmark/detail/catch_benchmark_function.hpp b/src/catch2/benchmark/detail/catch_benchmark_function.hpp
index fdac9aff..4e0c55ff 100644
--- a/src/catch2/benchmark/detail/catch_benchmark_function.hpp
+++ b/src/catch2/benchmark/detail/catch_benchmark_function.hpp
@@ -48,8 +48,8 @@ namespace Catch {
                 };
                 template <typename Fun>
                 struct model : public callable {
-                    model(Fun&& fun) : fun(std::move(fun)) {}
-                    model(Fun const& fun) : fun(fun) {}
+                    model(Fun&& fun_) : fun(std::move(fun_)) {}
+                    model(Fun const& fun_) : fun(fun_) {}
 
                     model<Fun>* clone() const override { return new model<Fun>(*this); }
 
diff --git a/src/catch2/internal/catch_clara.cpp b/src/catch2/internal/catch_clara.cpp
index 7c4613ed..eb7dacae 100644
--- a/src/catch2/internal/catch_clara.cpp
+++ b/src/catch2/internal/catch_clara.cpp
@@ -78,8 +78,8 @@ namespace Catch {
             TokenStream::TokenStream( Args const& args ):
                 TokenStream( args.m_args.begin(), args.m_args.end() ) {}
 
-            TokenStream::TokenStream( Iterator it, Iterator itEnd ):
-                it( it ), itEnd( itEnd ) {
+            TokenStream::TokenStream( Iterator it_, Iterator itEnd_ ):
+                it( it_ ), itEnd( itEnd_ ) {
                 loadBuffer();
             }
 
diff --git a/src/catch2/reporters/catch_reporter_helpers.hpp b/src/catch2/reporters/catch_reporter_helpers.hpp
index 0f8dd92b..c86863ba 100644
--- a/src/catch2/reporters/catch_reporter_helpers.hpp
+++ b/src/catch2/reporters/catch_reporter_helpers.hpp
@@ -26,7 +26,7 @@ namespace Catch {
 
     struct lineOfChars {
         char c;
-        constexpr lineOfChars( char c ): c( c ) {}
+        constexpr lineOfChars( char c_ ): c( c_ ) {}
 
         friend std::ostream& operator<<( std::ostream& out, lineOfChars value );
     };
diff --git a/tests/SelfTest/Baselines/compact.sw.approved.txt b/tests/SelfTest/Baselines/compact.sw.approved.txt
index bb73ca18..ab464e66 100644
--- a/tests/SelfTest/Baselines/compact.sw.approved.txt
+++ b/tests/SelfTest/Baselines/compact.sw.approved.txt
@@ -371,7 +371,7 @@ Matchers.tests.cpp:<line number>: passed: with 1 message: 'std::is_same< decltyp
 Matchers.tests.cpp:<line number>: passed: 1, MatcherA() && MatcherB() for: 1 ( equals: (int) 1 or (float) 1.0f and equals: (long long) 1 )
 Matchers.tests.cpp:<line number>: passed: with 1 message: 'std::is_same< decltype(MatcherA() || !MatcherB()), Catch::Matchers::Detail::MatchAnyOfGeneric<MatcherA, Catch::Matchers::Detail::MatchNotOfGeneric<MatcherB>> >::value'
 Matchers.tests.cpp:<line number>: passed: 1, MatcherA() || !MatcherB() for: 1 ( equals: (int) 1 or (float) 1.0f or not equals: (long long) 1 )
-Matchers.tests.cpp:<line number>: passed: vec, Predicate<std::vector<int>>([](auto const& vec) { return std::all_of(vec.begin(), vec.end(), [](int elem) { return elem % 2 == 1; }); }, "All elements are odd") && !EqualsRange(a) for: { 1, 3, 5 } ( matches predicate: "All elements are odd" and not Equals: { 5, 3, 1 } )
+Matchers.tests.cpp:<line number>: passed: vec, Predicate<std::vector<int>>([](auto const& v) { return std::all_of(v.begin(), v.end(), [](int elem) { return elem % 2 == 1; }); }, "All elements are odd") && !EqualsRange(a) for: { 1, 3, 5 } ( matches predicate: "All elements are odd" and not Equals: { 5, 3, 1 } )
 Matchers.tests.cpp:<line number>: passed: str, StartsWith("foo") && EqualsRange(arr) && EndsWith("bar") for: "foobar" ( starts with: "foo" and Equals: { 'f', 'o', 'o', 'b', 'a', 'r' } and ends with: "bar" )
 Matchers.tests.cpp:<line number>: passed: str, StartsWith("foo") && !EqualsRange(bad_arr) && EndsWith("bar") for: "foobar" ( starts with: "foo" and not Equals: { 'o', 'o', 'f', 'b', 'a', 'r' } and ends with: "bar" )
 Matchers.tests.cpp:<line number>: passed: str, EqualsRange(arr) && StartsWith("foo") && EndsWith("bar") for: "foobar" ( Equals: { 'f', 'o', 'o', 'b', 'a', 'r' } and starts with: "foo" and ends with: "bar" )
@@ -1014,7 +1014,7 @@ Message.tests.cpp:<line number>: failed: explicitly with 1 message: 'Message fro
 Message.tests.cpp:<line number>: failed: explicitly with 1 message: 'Message from section two'
 Matchers.tests.cpp:<line number>: passed: (EvilMatcher(), EvilMatcher()), EvilCommaOperatorUsed
 Matchers.tests.cpp:<line number>: passed: &EvilMatcher(), EvilAddressOfOperatorUsed
-Matchers.tests.cpp:<line number>: passed: EvilMatcher() || EvilMatcher() && !EvilMatcher()
+Matchers.tests.cpp:<line number>: passed: EvilMatcher() || (EvilMatcher() && !EvilMatcher())
 Matchers.tests.cpp:<line number>: passed: (EvilMatcher() && EvilMatcher()) || !EvilMatcher()
 CmdLine.tests.cpp:<line number>: passed: spec.hasFilters() == false for: false == false
 CmdLine.tests.cpp:<line number>: passed: spec.matches( *tcA ) == false for: false == false
diff --git a/tests/SelfTest/Baselines/console.sw.approved.txt b/tests/SelfTest/Baselines/console.sw.approved.txt
index e4298d25..7fa50b2f 100644
--- a/tests/SelfTest/Baselines/console.sw.approved.txt
+++ b/tests/SelfTest/Baselines/console.sw.approved.txt
@@ -3037,7 +3037,7 @@ Matchers.tests.cpp:<line number>
 ...............................................................................
 
 Matchers.tests.cpp:<line number>: PASSED:
-  REQUIRE_THAT( vec, Predicate<std::vector<int>>([](auto const& vec) { return std::all_of(vec.begin(), vec.end(), [](int elem) { return elem % 2 == 1; }); }, "All elements are odd") && !EqualsRange(a) )
+  REQUIRE_THAT( vec, Predicate<std::vector<int>>([](auto const& v) { return std::all_of(v.begin(), v.end(), [](int elem) { return elem % 2 == 1; }); }, "All elements are odd") && !EqualsRange(a) )
 with expansion:
   { 1, 3, 5 } ( matches predicate: "All elements are odd" and not Equals: { 5,
   3, 1 } )
@@ -7500,7 +7500,7 @@ Matchers.tests.cpp:<line number>: PASSED:
   REQUIRE_THROWS_AS( &EvilMatcher(), EvilAddressOfOperatorUsed )
 
 Matchers.tests.cpp:<line number>: PASSED:
-  REQUIRE_NOTHROW( EvilMatcher() || EvilMatcher() && !EvilMatcher() )
+  REQUIRE_NOTHROW( EvilMatcher() || (EvilMatcher() && !EvilMatcher()) )
 
 Matchers.tests.cpp:<line number>: PASSED:
   REQUIRE_NOTHROW( (EvilMatcher() && EvilMatcher()) || !EvilMatcher() )
diff --git a/tests/SelfTest/Baselines/tap.sw.approved.txt b/tests/SelfTest/Baselines/tap.sw.approved.txt
index 187c6a42..164ae09f 100644
--- a/tests/SelfTest/Baselines/tap.sw.approved.txt
+++ b/tests/SelfTest/Baselines/tap.sw.approved.txt
@@ -741,7 +741,7 @@ ok {test-number} - with 1 message: 'std::is_same< decltype(MatcherA() || !Matche
 # Combining only templated matchers
 ok {test-number} - 1, MatcherA() || !MatcherB() for: 1 ( equals: (int) 1 or (float) 1.0f or not equals: (long long) 1 )
 # Combining templated and concrete matchers
-ok {test-number} - vec, Predicate<std::vector<int>>([](auto const& vec) { return std::all_of(vec.begin(), vec.end(), [](int elem) { return elem % 2 == 1; }); }, "All elements are odd") && !EqualsRange(a) for: { 1, 3, 5 } ( matches predicate: "All elements are odd" and not Equals: { 5, 3, 1 } )
+ok {test-number} - vec, Predicate<std::vector<int>>([](auto const& v) { return std::all_of(v.begin(), v.end(), [](int elem) { return elem % 2 == 1; }); }, "All elements are odd") && !EqualsRange(a) for: { 1, 3, 5 } ( matches predicate: "All elements are odd" and not Equals: { 5, 3, 1 } )
 # Combining templated and concrete matchers
 ok {test-number} - str, StartsWith("foo") && EqualsRange(arr) && EndsWith("bar") for: "foobar" ( starts with: "foo" and Equals: { 'f', 'o', 'o', 'b', 'a', 'r' } and ends with: "bar" )
 # Combining templated and concrete matchers
@@ -1951,7 +1951,7 @@ ok {test-number} - (EvilMatcher(), EvilMatcher()), EvilCommaOperatorUsed
 # Overloaded comma or address-of operators are not used
 ok {test-number} - &EvilMatcher(), EvilAddressOfOperatorUsed
 # Overloaded comma or address-of operators are not used
-ok {test-number} - EvilMatcher() || EvilMatcher() && !EvilMatcher()
+ok {test-number} - EvilMatcher() || (EvilMatcher() && !EvilMatcher())
 # Overloaded comma or address-of operators are not used
 ok {test-number} - (EvilMatcher() && EvilMatcher()) || !EvilMatcher()
 # Parse test names and tags
diff --git a/tests/SelfTest/Baselines/xml.sw.approved.txt b/tests/SelfTest/Baselines/xml.sw.approved.txt
index 8604c74b..a8c2e3e3 100644
--- a/tests/SelfTest/Baselines/xml.sw.approved.txt
+++ b/tests/SelfTest/Baselines/xml.sw.approved.txt
@@ -3223,7 +3223,7 @@ Nor would this
     <TestCase name="Combining templated and concrete matchers" tags="[matchers][templated]" filename="tests/<exe-name>/UsageTests/Matchers.tests.cpp" >
       <Expression success="true" type="REQUIRE_THAT" filename="tests/<exe-name>/UsageTests/Matchers.tests.cpp" >
         <Original>
-          vec, Predicate&lt;std::vector&lt;int>>([](auto const&amp; vec) { return std::all_of(vec.begin(), vec.end(), [](int elem) { return elem % 2 == 1; }); }, "All elements are odd") &amp;&amp; !EqualsRange(a)
+          vec, Predicate&lt;std::vector&lt;int>>([](auto const&amp; v) { return std::all_of(v.begin(), v.end(), [](int elem) { return elem % 2 == 1; }); }, "All elements are odd") &amp;&amp; !EqualsRange(a)
         </Original>
         <Expanded>
           { 1, 3, 5 } ( matches predicate: "All elements are odd" and not Equals: { 5, 3, 1 } )
@@ -9042,10 +9042,10 @@ Nor would this
       </Expression>
       <Expression success="true" type="REQUIRE_NOTHROW" filename="tests/<exe-name>/UsageTests/Matchers.tests.cpp" >
         <Original>
-          EvilMatcher() || EvilMatcher() &amp;&amp; !EvilMatcher()
+          EvilMatcher() || (EvilMatcher() &amp;&amp; !EvilMatcher())
         </Original>
         <Expanded>
-          EvilMatcher() || EvilMatcher() &amp;&amp; !EvilMatcher()
+          EvilMatcher() || (EvilMatcher() &amp;&amp; !EvilMatcher())
         </Expanded>
       </Expression>
       <Expression success="true" type="REQUIRE_NOTHROW" filename="tests/<exe-name>/UsageTests/Matchers.tests.cpp" >
diff --git a/tests/SelfTest/IntrospectiveTests/UniquePtr.tests.cpp b/tests/SelfTest/IntrospectiveTests/UniquePtr.tests.cpp
index fcdb8a32..d461232d 100644
--- a/tests/SelfTest/IntrospectiveTests/UniquePtr.tests.cpp
+++ b/tests/SelfTest/IntrospectiveTests/UniquePtr.tests.cpp
@@ -68,7 +68,7 @@ TEST_CASE("unique_ptr reimplementation: basic functionality", "[internals][uniqu
 namespace {
     struct base {
         int i;
-        base(int i) :i(i) {}
+        base(int i_) :i(i_) {}
     };
     struct derived : base { using base::base; };
     struct unrelated {};
diff --git a/tests/SelfTest/UsageTests/Matchers.tests.cpp b/tests/SelfTest/UsageTests/Matchers.tests.cpp
index b627d4a9..b4621d86 100644
--- a/tests/SelfTest/UsageTests/Matchers.tests.cpp
+++ b/tests/SelfTest/UsageTests/Matchers.tests.cpp
@@ -711,22 +711,22 @@ namespace { namespace MatchersTests {
     template<typename Range>
     struct EqualsRangeMatcher : Catch::Matchers::MatcherGenericBase {
 
-        EqualsRangeMatcher(Range const& range) : range{ range } {}
+        EqualsRangeMatcher(Range const& range) : m_range{ range } {}
 
         template<typename OtherRange>
         bool match(OtherRange const& other) const {
             using std::begin;
             using std::end;
 
-            return std::equal(begin(range), end(range), begin(other), end(other));
+            return std::equal(begin(m_range), end(m_range), begin(other), end(other));
         }
 
         std::string describe() const override {
-            return "Equals: " + Catch::rangeToString(range);
+            return "Equals: " + Catch::rangeToString(m_range);
         }
 
     private:
-        Range const& range;
+        Range const& m_range;
     };
 
     template<typename Range>
@@ -750,8 +750,8 @@ namespace { namespace MatchersTests {
         std::array<int, 3> a{{ 5, 3, 1 }};
 
         REQUIRE_THAT(vec,
-                    Predicate<std::vector<int>>([](auto const& vec) {
-                        return std::all_of(vec.begin(), vec.end(), [](int elem) {
+                    Predicate<std::vector<int>>([](auto const& v) {
+                        return std::all_of(v.begin(), v.end(), [](int elem) {
                             return elem % 2 == 1;
                         });
                     }, "All elements are odd") &&
@@ -948,7 +948,7 @@ namespace { namespace MatchersTests {
     TEST_CASE("Overloaded comma or address-of operators are not used", "[matchers][templated]") {
         REQUIRE_THROWS_AS((EvilMatcher(), EvilMatcher()), EvilCommaOperatorUsed);
         REQUIRE_THROWS_AS(&EvilMatcher(), EvilAddressOfOperatorUsed);
-        REQUIRE_NOTHROW(EvilMatcher() || EvilMatcher() && !EvilMatcher());
+        REQUIRE_NOTHROW(EvilMatcher() || (EvilMatcher() && !EvilMatcher()));
         REQUIRE_NOTHROW((EvilMatcher() && EvilMatcher()) || !EvilMatcher());
     }
 
