diff --git a/include/catch_runner.hpp b/include/catch_runner.hpp
index 6127c36f..150387b9 100644
--- a/include/catch_runner.hpp
+++ b/include/catch_runner.hpp
@@ -72,7 +72,7 @@ namespace Catch {
             if( testsRunForGroup == 0 && !filterGroup.getName().empty() )
                 m_reporter->noMatchingTestCases( filterGroup.getName() );
             return totals;
-            
+
         }
 
     private:
@@ -100,7 +100,7 @@ namespace Catch {
                 throw std::domain_error( oss.str() );
             }
         }
-        
+
     private:
         Ptr<Config> m_config;
         std::ofstream m_ofs;
@@ -110,9 +110,9 @@ namespace Catch {
 
     class Session {
         static bool alreadyInstantiated;
-        
+
     public:
-    
+
         struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };
 
         Session()
@@ -127,7 +127,7 @@ namespace Catch {
         ~Session() {
             Catch::cleanUp();
         }
-        
+
         void showHelp( std::string const& processName ) {
             std::cout << "\nCatch v"    << libraryVersion.majorVersion << "."
                                         << libraryVersion.minorVersion << " build "
@@ -139,7 +139,7 @@ namespace Catch {
             m_cli.usage( std::cout, processName );
             std::cout << "For more detail usage please see the project docs\n" << std::endl;
         }
-        
+
         int applyCommandLine( int argc, char* const argv[], OnUnusedOptions::DoWhat unusedOptionBehaviour = OnUnusedOptions::Fail ) {
             try {
                 m_unusedTokens = m_cli.parseInto( argc, argv, m_configData );
@@ -177,7 +177,7 @@ namespace Catch {
                 throw std::runtime_error( msg.substr( 0, msg.size()-1 ) );
             }
         }
-        
+
         int run( int argc, char* const argv[] ) {
 
             int returnCode = applyCommandLine( argc, argv );
@@ -206,7 +206,7 @@ namespace Catch {
                 return (std::numeric_limits<int>::max)();
             }
         }
-        
+
         Clara::CommandLine<ConfigData> const& cli() const {
             return m_cli;
         }
@@ -221,8 +221,8 @@ namespace Catch {
                 m_config = new Config( m_configData );
             return *m_config;
         }
-        
-    private:        
+
+    private:
         Clara::CommandLine<ConfigData> m_cli;
         std::vector<Clara::Parser::Token> m_unusedTokens;
         ConfigData m_configData;
@@ -230,7 +230,7 @@ namespace Catch {
     };
 
     bool Session::alreadyInstantiated = false;
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED
diff --git a/include/internal/catch_approx.hpp b/include/internal/catch_approx.hpp
index 2f467a36..b2d7d555 100644
--- a/include/internal/catch_approx.hpp
+++ b/include/internal/catch_approx.hpp
@@ -23,7 +23,7 @@ namespace Detail {
             m_scale( 1.0 ),
             m_value( value )
         {}
-        
+
         Approx( Approx const& other )
         :   m_epsilon( other.m_epsilon ),
             m_scale( other.m_scale ),
@@ -33,23 +33,23 @@ namespace Detail {
         static Approx custom() {
             return Approx( 0 );
         }
-        
+
         Approx operator()( double value ) {
             Approx approx( value );
             approx.epsilon( m_epsilon );
             approx.scale( m_scale );
             return approx;
         }
-        
+
         friend bool operator == ( double lhs, Approx const& rhs ) {
             // Thanks to Richard Harris for his help refining this formula
             return fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( fabs(lhs), fabs(rhs.m_value) ) );
         }
-        
+
         friend bool operator == ( Approx const& lhs, double rhs ) {
             return operator==( rhs, lhs );
         }
-        
+
         friend bool operator != ( double lhs, Approx const& rhs ) {
             return !operator==( lhs, rhs );
         }
@@ -57,23 +57,23 @@ namespace Detail {
         friend bool operator != ( Approx const& lhs, double rhs ) {
             return !operator==( rhs, lhs );
         }
-        
+
         Approx& epsilon( double newEpsilon ) {
             m_epsilon = newEpsilon;
             return *this;
         }
-        
+
         Approx& scale( double newScale ) {
             m_scale = newScale;
             return *this;
         }
-        
+
         std::string toString() const {
             std::ostringstream oss;
             oss << "Approx( " << m_value << " )";
             return oss.str();
         }
-        
+
     private:
         double m_epsilon;
         double m_scale;
@@ -85,7 +85,7 @@ template<>
 inline std::string toString<Detail::Approx>( Detail::Approx const& value ) {
     return value.toString();
 }
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED
diff --git a/include/internal/catch_assertionresult.h b/include/internal/catch_assertionresult.h
index fb230adc..7cfe4d83 100644
--- a/include/internal/catch_assertionresult.h
+++ b/include/internal/catch_assertionresult.h
@@ -41,7 +41,7 @@ namespace Catch {
         AssertionResult();
         AssertionResult( AssertionInfo const& info, AssertionResultData const& data );
         ~AssertionResult();
-        
+
         bool isOk() const;
         bool succeeded() const;
         ResultWas::OfType getResultType() const;
@@ -59,7 +59,7 @@ namespace Catch {
         AssertionInfo m_info;
         AssertionResultData m_resultData;
     };
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED
diff --git a/include/internal/catch_capture.hpp b/include/internal/catch_capture.hpp
index 4aa6bc8c..a934abb1 100644
--- a/include/internal/catch_capture.hpp
+++ b/include/internal/catch_capture.hpp
@@ -25,7 +25,7 @@ namespace Catch {
     inline IResultCapture& getResultCapture() {
         return getCurrentContext().getResultCapture();
     }
-    
+
     template<typename MatcherT>
     ExpressionResultBuilder expressionResultBuilderFromMatcher( MatcherT const& matcher,
                                                                 std::string const& matcherCallAsString ) {
@@ -54,7 +54,7 @@ namespace Catch {
             .setLhs( Catch::toString( arg ) )
             .setResultType( matcher.match( arg ) );
     }
-    
+
 struct TestFailureException{};
 
 } // end namespace Catch
diff --git a/include/internal/catch_commandline.hpp b/include/internal/catch_commandline.hpp
index 871db331..52ba1f69 100644
--- a/include/internal/catch_commandline.hpp
+++ b/include/internal/catch_commandline.hpp
@@ -13,7 +13,7 @@
 #include "clara.h"
 
 namespace Catch {
-    
+
     inline void abortAfterFirst( ConfigData& config ) { config.abortAfter = 1; }
     inline void abortAfterX( ConfigData& config, int x ) {
         if( x < 1 )
@@ -33,7 +33,7 @@ namespace Catch {
         // !TBD: accept strings?
         config.verbosity = (ConfigData::Verbosity::Level)level;
     }
-    
+
     inline Clara::CommandLine<ConfigData> makeCommandLineParser() {
 
         Clara::CommandLine<ConfigData> cli;
@@ -123,7 +123,7 @@ namespace Catch {
 
         return cli;
     }
-        
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED
diff --git a/include/internal/catch_common.h b/include/internal/catch_common.h
index 7e74965a..f1203c5f 100644
--- a/include/internal/catch_common.h
+++ b/include/internal/catch_common.h
@@ -30,7 +30,7 @@ namespace Catch {
         NonCopyable() {}
         virtual ~NonCopyable();
     };
-    
+
     class SafeBool {
     public:
         typedef void (SafeBool::*type)() const;
@@ -41,7 +41,7 @@ namespace Catch {
     private:
         void trueValue() const {}
     };
-  
+
     template<typename ContainerT>
     inline void deleteAll( ContainerT& container ) {
         typename ContainerT::const_iterator it = container.begin();
@@ -56,12 +56,12 @@ namespace Catch {
         for(; it != itEnd; ++it )
             delete it->second;
     }
-    
+
     template<typename ContainerT, typename Function>
     inline void forEach( ContainerT& container, Function function ) {
         std::for_each( container.begin(), container.end(), function );
     }
-    
+
     template<typename ContainerT, typename Function>
     inline void forEach( ContainerT const& container, Function function ) {
         std::for_each( container.begin(), container.end(), function );
@@ -103,7 +103,7 @@ namespace Catch {
     };
 
     struct SourceLineInfo {
-    
+
         SourceLineInfo() : line( 0 ){}
         SourceLineInfo( std::string const& _file, std::size_t _line )
         :   file( _file ),
@@ -116,23 +116,23 @@ namespace Catch {
         bool empty() const {
             return file.empty();
         }
-        
+
         std::string file;
-        std::size_t line;        
+        std::size_t line;
     };
-    
+
     inline std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {
 #ifndef __GNUG__
         os << info.file << "(" << info.line << ")";
-#else                
+#else
         os << info.file << ":" << info.line;
-#endif            
+#endif
         return os;
     }
-    
+
     // This is just here to avoid compiler warnings with macro constants and boolean literals
     inline bool isTrue( bool value ){ return value; }
-    
+
     inline void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo ) {
         std::ostringstream oss;
         oss << locationInfo << ": Internal Catch error: '" << message << "'";
diff --git a/include/internal/catch_config.hpp b/include/internal/catch_config.hpp
index 184649ef..6ed857fc 100644
--- a/include/internal/catch_config.hpp
+++ b/include/internal/catch_config.hpp
@@ -23,7 +23,7 @@
 #endif
 
 namespace Catch {
-    
+
     struct ConfigData {
 
         struct Verbosity { enum Level {
@@ -49,7 +49,7 @@ namespace Catch {
             verbosity( Verbosity::Normal ),
             warnings( WarnAbout::Nothing )
         {}
-        
+
         bool listTests;
         bool listTags;
         bool listReporters;
@@ -71,8 +71,8 @@ namespace Catch {
 
         std::vector<std::string> testsOrTags;
     };
-    
-    
+
+
     class Config : public SharedImpl<IConfig> {
     private:
         Config( Config const& other );
@@ -83,7 +83,7 @@ namespace Catch {
         Config()
         :   m_os( std::cout.rdbuf() )
         {}
-        
+
         Config( ConfigData const& data )
         :   m_data( data ),
             m_os( std::cout.rdbuf() )
@@ -106,24 +106,24 @@ namespace Catch {
                 m_filterSets.push_back( filters );
             }
         }
-        
+
         virtual ~Config() {
             m_os.rdbuf( std::cout.rdbuf() );
             m_stream.release();
         }
-        
+
         void setFilename( std::string const& filename ) {
             m_data.outputFilename = filename;
         }
-        
+
         std::string const& getFilename() const {
             return m_data.outputFilename ;
         }
-        
+
         bool listTests() const { return m_data.listTests; }
         bool listTags() const { return m_data.listTags; }
         bool listReporters() const { return m_data.listReporters; }
-        
+
         std::string getProcessName() const {
             return m_data.processName;
         }
@@ -131,10 +131,10 @@ namespace Catch {
         bool shouldDebugBreak() const {
             return m_data.shouldDebugBreak;
         }
-        
+
         void setStreamBuf( std::streambuf* buf ) {
             m_os.rdbuf( buf ? buf : std::cout.rdbuf() );
-        }        
+        }
 
         void useStream( std::string const& streamName ) {
             Stream stream = createStream( streamName );
@@ -142,7 +142,7 @@ namespace Catch {
             m_stream.release();
             m_stream = stream;
         }
-        
+
         std::string getReporterName() const { return m_data.reporterName; }
 
         void addTestSpec( std::string const& testSpec ) {
@@ -154,11 +154,11 @@ namespace Catch {
         int abortAfter() const {
             return m_data.abortAfter;
         }
-        
+
         std::vector<TestCaseFilters> const& filters() const {
             return m_filterSets;
         }
-        
+
         bool showHelp() const { return m_data.showHelp; }
 
         // IConfig interface
@@ -170,13 +170,13 @@ namespace Catch {
 
     private:
         ConfigData m_data;
-        
+
         Stream m_stream;
         mutable std::ostream m_os;
         std::vector<TestCaseFilters> m_filterSets;
     };
-        
-    
+
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED
diff --git a/include/internal/catch_console_colour.hpp b/include/internal/catch_console_colour.hpp
index 1febc5f7..3fc2e38b 100644
--- a/include/internal/catch_console_colour.hpp
+++ b/include/internal/catch_console_colour.hpp
@@ -19,7 +19,7 @@ namespace Catch {
     struct Colour {
         enum Code {
             None = 0,
-            
+
             White,
             Red,
             Green,
@@ -27,25 +27,25 @@ namespace Catch {
             Cyan,
             Yellow,
             Grey,
-            
+
             Bright = 0x10,
-            
+
             BrightRed = Bright | Red,
             BrightGreen = Bright | Green,
             LightGrey = Bright | Grey,
             BrightWhite = Bright | White,
-            
+
             // By intention
             FileName = LightGrey,
             ResultError = BrightRed,
             ResultSuccess = BrightGreen,
-            
+
             Error = BrightRed,
             Success = Green,
-            
+
             OriginalExpression = Cyan,
             ReconstructedExpression = Yellow,
-            
+
             SecondaryText = LightGrey,
             Headers = White
         };
@@ -53,14 +53,14 @@ namespace Catch {
         // Use constructed object for RAII guard
         Colour( Code _colourCode );
         ~Colour();
-        
+
         // Use static method for one-shot changes
         static void use( Code _colourCode );
-        
+
     private:
         static Detail::IColourImpl* impl;
     };
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED
diff --git a/include/internal/catch_console_colour_impl.hpp b/include/internal/catch_console_colour_impl.hpp
index 92bd1dd9..0183f785 100644
--- a/include/internal/catch_console_colour_impl.hpp
+++ b/include/internal/catch_console_colour_impl.hpp
@@ -31,7 +31,7 @@ namespace Catch { namespace Detail {
 
 namespace Catch {
 namespace {
-    
+
     class Win32ColourImpl : public Detail::IColourImpl {
     public:
         Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
@@ -61,7 +61,7 @@ namespace {
             }
         }
 
-    private:    
+    private:
         void setTextAttribute( WORD _textAttribute ) {
             SetConsoleTextAttribute( stdoutHandle, _textAttribute );
         }
@@ -72,7 +72,7 @@ namespace {
     inline bool shouldUseColourForPlatform() {
         return true;
     }
-    
+
     Win32ColourImpl platformColourImpl;
 
 } // end anon namespace
@@ -106,11 +106,11 @@ namespace {
                 case Colour::BrightRed:     return setColour( "[1;31m" );
                 case Colour::BrightGreen:   return setColour( "[1;32m" );
                 case Colour::BrightWhite:   return setColour( "[1;37m" );
-                
+
                 case Colour::Bright: throw std::logic_error( "not a colour" );
             }
         }
-    private:    
+    private:
         void setColour( const char* _escapeCode ) {
             std::cout << '\033' << _escapeCode;
         }
@@ -119,9 +119,9 @@ namespace {
     inline bool shouldUseColourForPlatform() {
         return isatty( fileno(stdout) );
     }
-    
+
     PosixColourImpl platformColourImpl;
-    
+
 } // end anon namespace
 } // end namespace Catch
 
@@ -133,7 +133,7 @@ namespace Catch {
         struct NoColourImpl : Detail::IColourImpl {
             void use( Colour::Code ) {}
         };
-        NoColourImpl noColourImpl;        
+        NoColourImpl noColourImpl;
         static const bool shouldUseColour = shouldUseColourForPlatform() &&
                                             !isDebuggerActive();
     }
diff --git a/include/internal/catch_context.h b/include/internal/catch_context.h
index a1468dfb..db0704f1 100644
--- a/include/internal/catch_context.h
+++ b/include/internal/catch_context.h
@@ -27,7 +27,7 @@ namespace Catch {
     struct IContext
     {
         virtual ~IContext();
-        
+
         virtual IResultCapture& getResultCapture() = 0;
         virtual IRunner& getRunner() = 0;
         virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;
diff --git a/include/internal/catch_context_impl.hpp b/include/internal/catch_context_impl.hpp
index e870324f..3821fdc3 100644
--- a/include/internal/catch_context_impl.hpp
+++ b/include/internal/catch_context_impl.hpp
@@ -52,7 +52,7 @@ namespace Catch {
         virtual void setConfig( Ptr<IConfig const> const& config ) {
             m_config = config;
         }
-        
+
         friend IMutableContext& getCurrentMutableContext();
 
     private:
@@ -82,7 +82,7 @@ namespace Catch {
         Ptr<IConfig const> m_config;
         std::map<std::string, IGeneratorsForTest*> m_generatorsByTestName;
     };
-    
+
     namespace {
         Context* currentContext = NULL;
     }
diff --git a/include/internal/catch_debugger.hpp b/include/internal/catch_debugger.hpp
index 89e15d69..976d14af 100644
--- a/include/internal/catch_debugger.hpp
+++ b/include/internal/catch_debugger.hpp
@@ -29,42 +29,42 @@
     #include <sys/sysctl.h>
 
     namespace Catch{
-    
+
         // The following function is taken directly from the following technical note:
         // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html
-            
+
         // Returns true if the current process is being debugged (either
         // running under the debugger or has a debugger attached post facto).
         inline bool isDebuggerActive(){
-        
+
             int                 junk;
             int                 mib[4];
             struct kinfo_proc   info;
             size_t              size;
-            
+
             // Initialize the flags so that, if sysctl fails for some bizarre
             // reason, we get a predictable result.
-            
+
             info.kp_proc.p_flag = 0;
-            
+
             // Initialize mib, which tells sysctl the info we want, in this case
             // we're looking for information about a specific process ID.
-            
+
             mib[0] = CTL_KERN;
             mib[1] = KERN_PROC;
             mib[2] = KERN_PROC_PID;
             mib[3] = getpid();
-            
+
             // Call sysctl.
-            
+
             size = sizeof(info);
             junk = sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, NULL, 0);
             assert(junk == 0);
-            
+
             // We're being debugged if the P_TRACED flag is set.
-            
+
             return ( (info.kp_proc.p_flag & P_TRACED) != 0 );
-        }        
+        }
     }
 
     // The following code snippet taken from:
diff --git a/include/internal/catch_default_main.hpp b/include/internal/catch_default_main.hpp
index 5844f350..b7b65a5b 100644
--- a/include/internal/catch_default_main.hpp
+++ b/include/internal/catch_default_main.hpp
@@ -11,7 +11,7 @@
 #ifndef __OBJC__
 
 // Standard C/C++ main entry point
-int main (int argc, char * const argv[]) {    
+int main (int argc, char * const argv[]) {
     return Catch::Session().run( argc, argv );
 }
 
@@ -22,14 +22,14 @@ int main (int argc, char * const argv[]) {
 #if !CATCH_ARC_ENABLED
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
 #endif
-    
-    Catch::registerTestMethods();    
+
+    Catch::registerTestMethods();
     int result = Catch::Session().run( argc, (char* const*)argv );
-    
+
 #if !CATCH_ARC_ENABLED
     [pool drain];
 #endif
-    
+
     return result;
 }
 
diff --git a/include/internal/catch_evaluate.hpp b/include/internal/catch_evaluate.hpp
index 3592e2a7..f345d744 100644
--- a/include/internal/catch_evaluate.hpp
+++ b/include/internal/catch_evaluate.hpp
@@ -24,7 +24,7 @@ namespace Internal {
         IsLessThanOrEqualTo,
         IsGreaterThanOrEqualTo
     };
-    
+
     template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };
     template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };
     template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };
@@ -32,7 +32,7 @@ namespace Internal {
     template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };
     template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };
     template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };
-    
+
     template<typename T>
     inline T& opCast(T const& t) { return const_cast<T&>(t); }
 
@@ -40,13 +40,13 @@ namespace Internal {
 #ifdef CATCH_CONFIG_CPP11_NULLPTR
     inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }
 #endif // CATCH_CONFIG_CPP11_NULLPTR
-    
+
 
     // So the compare overloads can be operator agnostic we convey the operator as a template
     // enum, which is used to specialise an Evaluator for doing the comparison.
     template<typename T1, typename T2, Operator Op>
     class Evaluator{};
-    
+
     template<typename T1, typename T2>
     struct Evaluator<T1, T2, IsEqualTo> {
         static bool evaluate( T1 const& lhs, T2 const& rhs) {
@@ -108,7 +108,7 @@ namespace Internal {
     template<Operator Op> bool compare( unsigned char lhs, int rhs ) {
         return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
     }
-    
+
     // unsigned X to long
     template<Operator Op> bool compare( unsigned int lhs, long rhs ) {
         return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
@@ -119,7 +119,7 @@ namespace Internal {
     template<Operator Op> bool compare( unsigned char lhs, long rhs ) {
         return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
     }
-    
+
     // int to unsigned X
     template<Operator Op> bool compare( int lhs, unsigned int rhs ) {
         return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
@@ -130,7 +130,7 @@ namespace Internal {
     template<Operator Op> bool compare( int lhs, unsigned char rhs ) {
         return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
     }
-    
+
     // long to unsigned X
     template<Operator Op> bool compare( long lhs, unsigned int rhs ) {
         return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
@@ -149,7 +149,7 @@ namespace Internal {
     template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {
         return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
     }
-    
+
     // pointer to int (when comparing against NULL)
     template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {
         return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
@@ -167,7 +167,7 @@ namespace Internal {
         return Evaluator<T*, T*, Op>::evaluate( lhs, NULL );
     }
 #endif // CATCH_CONFIG_CPP11_NULLPTR
- 
+
 } // end of namespace Internal
 } // end of namespace Catch
 
diff --git a/include/internal/catch_exception_translator_registry.hpp b/include/internal/catch_exception_translator_registry.hpp
index c7199b71..d3c11dc8 100644
--- a/include/internal/catch_exception_translator_registry.hpp
+++ b/include/internal/catch_exception_translator_registry.hpp
@@ -25,7 +25,7 @@ namespace Catch {
         virtual void registerTranslator( const IExceptionTranslator* translator ) {
             m_translators.push_back( translator );
         }
-        
+
         virtual std::string translateActiveException() const {
             try {
 #ifdef __OBJC__
@@ -53,11 +53,11 @@ namespace Catch {
                 return tryTranslators( m_translators.begin() );
             }
         }
-        
+
         std::string tryTranslators( std::vector<const IExceptionTranslator*>::const_iterator it ) const {
             if( it == m_translators.end() )
                 return "Unknown exception";
-            
+
             try {
                 return (*it)->translate();
             }
@@ -65,7 +65,7 @@ namespace Catch {
                 return tryTranslators( it+1 );
             }
         }
-        
+
     private:
         std::vector<const IExceptionTranslator*> m_translators;
     };
diff --git a/include/internal/catch_expression_lhs.hpp b/include/internal/catch_expression_lhs.hpp
index f21c4eec..8241ae26 100644
--- a/include/internal/catch_expression_lhs.hpp
+++ b/include/internal/catch_expression_lhs.hpp
@@ -31,22 +31,22 @@ public:
     ExpressionResultBuilder& operator != ( RhsT const& rhs ) {
         return captureExpression<Internal::IsNotEqualTo>( rhs );
     }
-    
+
     template<typename RhsT>
     ExpressionResultBuilder& operator < ( RhsT const& rhs ) {
         return captureExpression<Internal::IsLessThan>( rhs );
     }
-    
+
     template<typename RhsT>
     ExpressionResultBuilder& operator > ( RhsT const& rhs ) {
         return captureExpression<Internal::IsGreaterThan>( rhs );
     }
-    
+
     template<typename RhsT>
     ExpressionResultBuilder& operator <= ( RhsT const& rhs ) {
         return captureExpression<Internal::IsLessThanOrEqualTo>( rhs );
     }
-    
+
     template<typename RhsT>
     ExpressionResultBuilder& operator >= ( RhsT const& rhs ) {
         return captureExpression<Internal::IsGreaterThanOrEqualTo>( rhs );
@@ -55,11 +55,11 @@ public:
     ExpressionResultBuilder& operator == ( bool rhs ) {
         return captureExpression<Internal::IsEqualTo>( rhs );
     }
-    
+
     ExpressionResultBuilder& operator != ( bool rhs ) {
         return captureExpression<Internal::IsNotEqualTo>( rhs );
     }
-    
+
     ExpressionResultBuilder& endExpression( ResultDisposition::Flags resultDisposition ) {
         bool value = m_lhs ? true : false;
         return m_result
diff --git a/include/internal/catch_expressionresult_builder.h b/include/internal/catch_expressionresult_builder.h
index 13855888..96beb4ac 100644
--- a/include/internal/catch_expressionresult_builder.h
+++ b/include/internal/catch_expressionresult_builder.h
@@ -22,7 +22,7 @@ struct STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison;
 // the result of evaluating it. This is used to build an AssertionResult object
 class ExpressionResultBuilder {
 public:
-    
+
     ExpressionResultBuilder( ResultWas::OfType resultType = ResultWas::Unknown );
     ExpressionResultBuilder( ExpressionResultBuilder const& other );
     ExpressionResultBuilder& operator=(ExpressionResultBuilder const& other );
diff --git a/include/internal/catch_expressionresult_builder.hpp b/include/internal/catch_expressionresult_builder.hpp
index ec4774b2..2a451ea6 100644
--- a/include/internal/catch_expressionresult_builder.hpp
+++ b/include/internal/catch_expressionresult_builder.hpp
@@ -59,7 +59,7 @@ namespace Catch {
         assert( m_data.resultType != ResultWas::Unknown );
 
         AssertionResultData data = m_data;
-        
+
         // Flip bool results if shouldNegate is set
         if( m_exprComponents.shouldNegate && data.resultType == ResultWas::Ok )
             data.resultType = ResultWas::ExpressionFailed;
diff --git a/include/internal/catch_generators.hpp b/include/internal/catch_generators.hpp
index 030b1804..84eb22f7 100644
--- a/include/internal/catch_generators.hpp
+++ b/include/internal/catch_generators.hpp
@@ -28,17 +28,17 @@ template<typename T>
 class BetweenGenerator : public IGenerator<T> {
 public:
     BetweenGenerator( T from, T to ) : m_from( from ), m_to( to ){}
-    
+
     virtual T getValue( std::size_t index ) const {
         return m_from+static_cast<int>( index );
     }
-    
+
     virtual std::size_t size() const {
         return static_cast<std::size_t>( 1+m_to-m_from );
     }
-    
+
 private:
-    
+
     T m_from;
     T m_to;
 };
@@ -47,11 +47,11 @@ template<typename T>
 class ValuesGenerator : public IGenerator<T> {
 public:
     ValuesGenerator(){}
-    
+
     void add( T value ) {
         m_values.push_back( value );
     }
-    
+
     virtual T getValue( std::size_t index ) const {
         return m_values[index];
     }
@@ -59,7 +59,7 @@ public:
     virtual std::size_t size() const {
         return m_values.size();
     }
-    
+
 private:
     std::vector<T> m_values;
 };
@@ -68,27 +68,27 @@ template<typename T>
 class CompositeGenerator {
 public:
     CompositeGenerator() : m_totalSize( 0 ) {}
-    
+
     // *** Move semantics, similar to auto_ptr ***
-    CompositeGenerator( CompositeGenerator& other ) 
-    :   m_fileInfo( other.m_fileInfo ), 
-        m_totalSize( 0 ) 
+    CompositeGenerator( CompositeGenerator& other )
+    :   m_fileInfo( other.m_fileInfo ),
+        m_totalSize( 0 )
     {
         move( other );
     }
-    
+
     CompositeGenerator& setFileInfo( const char* fileInfo ) {
         m_fileInfo = fileInfo;
         return *this;
     }
-    
+
     ~CompositeGenerator() {
         deleteAll( m_composed );
     }
-    
+
     operator T () const {
         size_t overallIndex = getCurrentContext().getGeneratorIndex( m_fileInfo, m_totalSize );
-        
+
         typename std::vector<const IGenerator<T>*>::const_iterator it = m_composed.begin();
         typename std::vector<const IGenerator<T>*>::const_iterator itEnd = m_composed.end();
         for( size_t index = 0; it != itEnd; ++it )
@@ -103,32 +103,32 @@ public:
         CATCH_INTERNAL_ERROR( "Indexed past end of generated range" );
         return T(); // Suppress spurious "not all control paths return a value" warning in Visual Studio - if you know how to fix this please do so
     }
-    
+
     void add( const IGenerator<T>* generator ) {
         m_totalSize += generator->size();
         m_composed.push_back( generator );
     }
-    
+
     CompositeGenerator& then( CompositeGenerator& other ) {
         move( other );
         return *this;
     }
-    
+
     CompositeGenerator& then( T value ) {
         ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
         valuesGen->add( value );
         add( valuesGen );
         return *this;
     }
-    
+
 private:
-    
+
     void move( CompositeGenerator& other ) {
         std::copy( other.m_composed.begin(), other.m_composed.end(), std::back_inserter( m_composed ) );
         m_totalSize += other.m_totalSize;
         other.m_composed.clear();
     }
-    
+
     std::vector<const IGenerator<T>*> m_composed;
     std::string m_fileInfo;
     size_t m_totalSize;
@@ -177,9 +177,9 @@ namespace Generators
     }
 
 } // end namespace Generators
-    
+
 using namespace Generators;
-    
+
 } // end namespace Catch
 
 #define INTERNAL_CATCH_LINESTR2( line ) #line
diff --git a/include/internal/catch_generators_impl.hpp b/include/internal/catch_generators_impl.hpp
index 75af7395..fea699ae 100644
--- a/include/internal/catch_generators_impl.hpp
+++ b/include/internal/catch_generators_impl.hpp
@@ -19,37 +19,37 @@
 namespace Catch {
 
     struct GeneratorInfo : IGeneratorInfo {
-    
+
         GeneratorInfo( std::size_t size )
         :   m_size( size ),
             m_currentIndex( 0 )
         {}
-        
-        bool moveNext() {        
+
+        bool moveNext() {
             if( ++m_currentIndex == m_size ) {
                 m_currentIndex = 0;
                 return false;
             }
             return true;
         }
-        
+
         std::size_t getCurrentIndex() const {
             return m_currentIndex;
         }
-        
+
         std::size_t m_size;
         std::size_t m_currentIndex;
     };
-    
+
     ///////////////////////////////////////////////////////////////////////////
-    
+
     class GeneratorsForTest : public IGeneratorsForTest {
-        
+
     public:
         ~GeneratorsForTest() {
             deleteAll( m_generatorsInOrder );
         }
-        
+
         IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) {
             std::map<std::string, IGeneratorInfo*>::const_iterator it = m_generatorsByName.find( fileInfo );
             if( it == m_generatorsByName.end() ) {
@@ -60,7 +60,7 @@ namespace Catch {
             }
             return *it->second;
         }
-        
+
         bool moveNext() {
             std::vector<IGeneratorInfo*>::const_iterator it = m_generatorsInOrder.begin();
             std::vector<IGeneratorInfo*>::const_iterator itEnd = m_generatorsInOrder.end();
@@ -70,7 +70,7 @@ namespace Catch {
             }
             return false;
         }
-        
+
     private:
         std::map<std::string, IGeneratorInfo*> m_generatorsByName;
         std::vector<IGeneratorInfo*> m_generatorsInOrder;
diff --git a/include/internal/catch_interfaces_capture.h b/include/internal/catch_interfaces_capture.h
index 5b1619ae..029a4321 100644
--- a/include/internal/catch_interfaces_capture.h
+++ b/include/internal/catch_interfaces_capture.h
@@ -24,22 +24,22 @@ namespace Catch {
     class ScopedMessageBuilder;
 
     struct IResultCapture {
-    
+
         virtual ~IResultCapture();
-        
+
         virtual void assertionEnded( AssertionResult const& result ) = 0;
         virtual bool sectionStarted(    SectionInfo const& sectionInfo,
                                         Counts& assertions ) = 0;
         virtual void sectionEnded( SectionInfo const& name, Counts const& assertions ) = 0;
         virtual void pushScopedMessage( MessageInfo const& message ) = 0;
         virtual void popScopedMessage( MessageInfo const& message ) = 0;
-        
+
         virtual bool shouldDebugBreak() const = 0;
-        
+
         virtual ResultAction::Value acceptExpression( ExpressionResultBuilder const& assertionResult, AssertionInfo const& assertionInfo ) = 0;
-        
-        virtual std::string getCurrentTestName() const = 0;        
-        virtual const AssertionResult* getLastResult() const = 0;        
+
+        virtual std::string getCurrentTestName() const = 0;
+        virtual const AssertionResult* getLastResult() const = 0;
     };
 }
 
diff --git a/include/internal/catch_interfaces_config.h b/include/internal/catch_interfaces_config.h
index 87ee35b4..06786f81 100644
--- a/include/internal/catch_interfaces_config.h
+++ b/include/internal/catch_interfaces_config.h
@@ -16,9 +16,9 @@
 namespace Catch {
 
     struct IConfig : IShared {
-    
+
         virtual ~IConfig();
-        
+
         virtual bool allowThrows() const = 0;
         virtual std::ostream& stream() const = 0;
         virtual std::string name() const = 0;
diff --git a/include/internal/catch_interfaces_exception.h b/include/internal/catch_interfaces_exception.h
index edfbf87d..c2fc5bf5 100644
--- a/include/internal/catch_interfaces_exception.h
+++ b/include/internal/catch_interfaces_exception.h
@@ -10,19 +10,19 @@
 
 #include <string>
 #include "catch_interfaces_registry_hub.h"
-                                              
+
 namespace Catch {
-    
+
     typedef std::string(*exceptionTranslateFunction)();
 
     struct IExceptionTranslator {
         virtual ~IExceptionTranslator();
         virtual std::string translate() const = 0;
     };
-    
+
     struct IExceptionTranslatorRegistry {
         virtual ~IExceptionTranslatorRegistry();
-        
+
         virtual std::string translateActiveException() const = 0;
     };
 
@@ -30,11 +30,11 @@ namespace Catch {
         template<typename T>
         class ExceptionTranslator : public IExceptionTranslator {
         public:
-            
+
             ExceptionTranslator( std::string(*translateFunction)( T& ) )
             : m_translateFunction( translateFunction )
             {}
-            
+
             virtual std::string translate() const {
                 try {
                     throw;
@@ -43,11 +43,11 @@ namespace Catch {
                     return m_translateFunction( ex );
                 }
             }
-            
+
         protected:
             std::string(*m_translateFunction)( T& );
         };
-        
+
     public:
         template<typename T>
         ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
diff --git a/include/internal/catch_interfaces_generators.h b/include/internal/catch_interfaces_generators.h
index 03b01d9a..d163d5a1 100644
--- a/include/internal/catch_interfaces_generators.h
+++ b/include/internal/catch_interfaces_generators.h
@@ -17,7 +17,7 @@ namespace Catch {
         virtual bool moveNext() = 0;
         virtual std::size_t getCurrentIndex() const = 0;
     };
-    
+
     struct IGeneratorsForTest {
         virtual ~IGeneratorsForTest();
 
diff --git a/include/internal/catch_interfaces_reporter.h b/include/internal/catch_interfaces_reporter.h
index 57db9d7b..bf4d9a88 100644
--- a/include/internal/catch_interfaces_reporter.h
+++ b/include/internal/catch_interfaces_reporter.h
@@ -108,7 +108,7 @@ namespace Catch
             }
         }
         virtual ~AssertionStats();
-        
+
         AssertionResult assertionResult;
         std::vector<MessageInfo> infoMessages;
         Totals totals;
@@ -152,7 +152,7 @@ namespace Catch
         bool missingAssertions;
         bool aborting;
     };
-    
+
     struct TestGroupStats {
         TestGroupStats( GroupInfo const& _groupInfo,
                         Totals const& _totals,
@@ -171,7 +171,7 @@ namespace Catch
         Totals totals;
         bool aborting;
     };
-    
+
     struct TestRunStats {
         TestRunStats(   TestRunInfo const& _runInfo,
                         Totals const& _totals,
@@ -199,7 +199,7 @@ namespace Catch
         // static std::string getDescription();
 
         virtual ReporterPreferences getPreferences() const = 0;
-        
+
         virtual void noMatchingTestCases( std::string const& spec ) = 0;
 
         virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
@@ -225,7 +225,7 @@ namespace Catch
         {}
 
         virtual ~StreamingReporterBase();
-        
+
         virtual void noMatchingTestCases( std::string const& ) {}
 
         virtual void testRunStarting( TestRunInfo const& _testRunInfo ) {
@@ -273,9 +273,9 @@ namespace Catch
         Option<TestCaseInfo> unusedTestCaseInfo;
         Ptr<ThreadedSectionInfo> currentSectionInfo;
         std::ostream& stream;
-        
+
         // !TBD: This should really go in the TestCaseStats class
-        std::vector<Ptr<ThreadedSectionInfo> > m_rootSections;        
+        std::vector<Ptr<ThreadedSectionInfo> > m_rootSections;
     };
 
     struct TestGroupNode : TestGroupStats {
@@ -289,17 +289,17 @@ namespace Catch
 
         TestRunNode( TestRunStats const& _stats ) : TestRunStats( _stats ) {}
         ~TestRunNode();
-        
+
         std::vector<TestGroupNode> groups;
     };
-    
+
     // Deprecated
     struct IReporter : IShared {
         virtual ~IReporter();
 
         virtual bool shouldRedirectStdout() const = 0;
 
-        virtual void StartTesting() = 0;        
+        virtual void StartTesting() = 0;
         virtual void EndTesting( Totals const& totals ) = 0;
         virtual void StartGroup( std::string const& groupName ) = 0;
         virtual void EndGroup( std::string const& groupName, Totals const& totals ) = 0;
@@ -313,7 +313,7 @@ namespace Catch
         virtual void Result( AssertionResult const& result ) = 0;
     };
 
-    
+
     struct IReporterFactory {
         virtual ~IReporterFactory();
         virtual IStreamingReporter* create( ReporterConfig const& config ) const = 0;
@@ -324,14 +324,14 @@ namespace Catch
         typedef std::map<std::string, IReporterFactory*> FactoryMap;
 
         virtual ~IReporterRegistry();
-        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig> const& config ) const = 0;        
+        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig> const& config ) const = 0;
         virtual FactoryMap const& getFactories() const = 0;
     };
-    
+
     inline std::string trim( std::string const& str ) {
         std::string::size_type start = str.find_first_not_of( "\n\r\t " );
         std::string::size_type end = str.find_last_not_of( "\n\r\t " );
-        
+
         return start != std::string::npos ? str.substr( start, 1+end-start ) : "";
     }
 }
diff --git a/include/internal/catch_interfaces_runner.h b/include/internal/catch_interfaces_runner.h
index bb81ffb4..ab127b9f 100644
--- a/include/internal/catch_interfaces_runner.h
+++ b/include/internal/catch_interfaces_runner.h
@@ -14,7 +14,7 @@
 
 namespace Catch {
     class TestCase;
-    
+
     struct IRunner {
         virtual ~IRunner();
     };
diff --git a/include/internal/catch_interfaces_testcase.h b/include/internal/catch_interfaces_testcase.h
index 90d12009..03ef94ec 100644
--- a/include/internal/catch_interfaces_testcase.h
+++ b/include/internal/catch_interfaces_testcase.h
@@ -21,7 +21,7 @@ namespace Catch {
     protected:
         virtual ~ITestCase();
     };
-    
+
     class TestCase;
 
     struct ITestCaseRegistry {
diff --git a/include/internal/catch_legacy_reporter_adapter.hpp b/include/internal/catch_legacy_reporter_adapter.hpp
index 412363d4..d18ee58f 100644
--- a/include/internal/catch_legacy_reporter_adapter.hpp
+++ b/include/internal/catch_legacy_reporter_adapter.hpp
@@ -53,7 +53,7 @@ namespace Catch
                     m_legacyReporter->Result( result );
                 }
             }
-        }    
+        }
         m_legacyReporter->Result( assertionStats.assertionResult );
         return true;
     }
diff --git a/include/internal/catch_list.hpp b/include/internal/catch_list.hpp
index 1abba573..050e1793 100644
--- a/include/internal/catch_list.hpp
+++ b/include/internal/catch_list.hpp
@@ -42,7 +42,7 @@ namespace Catch {
                 maxNameLen = (std::max)( it->getTestCaseInfo().name.size(), maxNameLen );
             }
         }
-        
+
         // Try to fit everything in. If not shrink tag column first, down to 30
         // then shrink name column until it all fits (strings will be wrapped within column)
         while( maxTagLen + maxNameLen > CATCH_CONFIG_CONSOLE_WIDTH-5 ) {
@@ -67,7 +67,7 @@ namespace Catch {
                                         .setWidth( maxTagLen )
                                         .setInitialIndent(0)
                                         .setIndent( 2 ) );
-                
+
                 for( std::size_t i = 0; i < (std::max)( nameWrapper.size(), tagsWrapper.size() ); ++i ) {
                     Colour::Code colour = Colour::None;
                     if( it->getTestCaseInfo().isHidden )
@@ -80,7 +80,7 @@ namespace Catch {
                         nameCol = "    ...";
                         colour = Colour::SecondaryText;
                     }
-                    
+
                     {
                         Colour colourGuard( colour );
                         std::cout << nameCol;
@@ -105,7 +105,7 @@ namespace Catch {
             std::cout << pluralise( matchedTests, "matching test case" ) << "\n" << std::endl;
         return matchedTests;
     }
-    
+
     inline std::size_t listTags( Config const& config ) {
         if( config.filters().empty() )
             std::cout << "All available tags:\n";
@@ -115,7 +115,7 @@ namespace Catch {
         std::vector<TestCase>::const_iterator it = allTests.begin(), itEnd = allTests.end();
 
         std::map<std::string, int> tagCounts;
-        
+
         std::size_t maxTagLen = 0;
 
         for(; it != itEnd; ++it ) {
@@ -137,10 +137,10 @@ namespace Catch {
         maxTagLen +=4;
         if( maxTagLen > CATCH_CONFIG_CONSOLE_WIDTH-10 )
             maxTagLen = CATCH_CONFIG_CONSOLE_WIDTH-10;
-        
+
         for( std::map<std::string, int>::const_iterator countIt = tagCounts.begin(), countItEnd = tagCounts.end();
                 countIt != countItEnd;
-                ++countIt ) {            
+                ++countIt ) {
             Text wrapper( "[" + countIt->first + "]", TextAttributes()
                                                         .setIndent(2)
                                                         .setWidth( maxTagLen ) );
@@ -166,7 +166,7 @@ namespace Catch {
         std::size_t maxNameLen = 0;
         for(it = itBegin; it != itEnd; ++it )
             maxNameLen = (std::max)( maxNameLen, it->first.size() );
-    
+
         for(it = itBegin; it != itEnd; ++it ) {
             Text wrapper( it->second->getDescription(), TextAttributes()
                                                         .setInitialIndent( 0 )
@@ -181,7 +181,7 @@ namespace Catch {
         std::cout << std::endl;
         return factories.size();
     }
-    
+
     inline Option<std::size_t> list( Config const& config ) {
         Option<std::size_t> listedCount;
         if( config.listTests() )
@@ -192,7 +192,7 @@ namespace Catch {
             listedCount = listedCount.valueOr(0) + listReporters( config );
         return listedCount;
     }
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED
diff --git a/include/internal/catch_matchers.hpp b/include/internal/catch_matchers.hpp
index 55d592a3..028ff678 100644
--- a/include/internal/catch_matchers.hpp
+++ b/include/internal/catch_matchers.hpp
@@ -66,7 +66,7 @@ namespace Matchers {
         private:
             std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
         };
-        
+
         template<typename ExpressionT>
         class AnyOf : public MatcherImpl<AnyOf<ExpressionT>, ExpressionT> {
         public:
@@ -100,14 +100,14 @@ namespace Matchers {
         private:
             std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
         };
-        
+
     }
 
     namespace StdString {
 
         inline std::string makeString( std::string const& str ) { return str; }
         inline std::string makeString( const char* str ) { return str ? std::string( str ) : std::string(); }
-        
+
         struct Equals : MatcherImpl<Equals, std::string> {
             Equals( std::string const& str ) : m_str( str ){}
             Equals( Equals const& other ) : m_str( other.m_str ){}
@@ -123,7 +123,7 @@ namespace Matchers {
 
             std::string m_str;
         };
-        
+
         struct Contains : MatcherImpl<Contains, std::string> {
             Contains( std::string const& substr ) : m_substr( substr ){}
             Contains( Contains const& other ) : m_substr( other.m_substr ){}
@@ -139,7 +139,7 @@ namespace Matchers {
 
             std::string m_substr;
         };
-        
+
         struct StartsWith : MatcherImpl<StartsWith, std::string> {
             StartsWith( std::string const& substr ) : m_substr( substr ){}
             StartsWith( StartsWith const& other ) : m_substr( other.m_substr ){}
@@ -155,7 +155,7 @@ namespace Matchers {
 
             std::string m_substr;
         };
-        
+
         struct EndsWith : MatcherImpl<EndsWith, std::string> {
             EndsWith( std::string const& substr ) : m_substr( substr ){}
             EndsWith( EndsWith const& other ) : m_substr( other.m_substr ){}
@@ -223,11 +223,11 @@ namespace Matchers {
     inline Impl::StdString::EndsWith    EndsWith( const char* substr ) {
         return Impl::StdString::EndsWith( Impl::StdString::makeString( substr ) );
     }
-    
+
 } // namespace Matchers
-    
+
 using namespace Matchers;
-    
+
 } // namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED
diff --git a/include/internal/catch_message.h b/include/internal/catch_message.h
index f90d64ce..d0886654 100644
--- a/include/internal/catch_message.h
+++ b/include/internal/catch_message.h
@@ -13,7 +13,7 @@
 #include "catch_common.h"
 
 namespace Catch {
-    
+
     struct MessageInfo {
         MessageInfo(    std::string const& _macroName,
                         SourceLineInfo const& _lineInfo,
@@ -24,7 +24,7 @@ namespace Catch {
         ResultWas::OfType type;
         std::string message;
         unsigned int sequence;
-        
+
         bool operator == ( MessageInfo const& other ) const {
             return sequence == other.sequence;
         }
@@ -34,14 +34,14 @@ namespace Catch {
     private:
         static unsigned int globalCount;
     };
-    
+
     struct MessageBuilder {
         MessageBuilder( std::string const& macroName,
                         SourceLineInfo const& lineInfo,
                         ResultWas::OfType type )
         : m_info( macroName, lineInfo, type )
         {}
-        
+
         template<typename T>
         MessageBuilder& operator << ( T const& value ) {
             m_stream << value;
diff --git a/include/internal/catch_message.hpp b/include/internal/catch_message.hpp
index 949391bf..8f303f7a 100644
--- a/include/internal/catch_message.hpp
+++ b/include/internal/catch_message.hpp
@@ -11,7 +11,7 @@
 #include "catch_message.h"
 
 namespace Catch {
-        
+
     MessageInfo::MessageInfo(   std::string const& _macroName,
                                 SourceLineInfo const& _lineInfo,
                                 ResultWas::OfType _type )
@@ -20,13 +20,13 @@ namespace Catch {
         type( _type ),
         sequence( ++globalCount )
     {}
-    
+
     // This may need protecting if threading support is added
     unsigned int MessageInfo::globalCount = 0;
-    
-    
+
+
     ////////////////////////////////////////////////////////////////////////////
-    
+
     ScopedMessage::ScopedMessage( MessageBuilder const& builder )
     : m_info( builder.m_info )
     {
@@ -36,8 +36,8 @@ namespace Catch {
     ScopedMessage::~ScopedMessage() {
         getResultCapture().popScopedMessage( m_info );
     }
-    
-    
+
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED
diff --git a/include/internal/catch_notimplemented_exception.hpp b/include/internal/catch_notimplemented_exception.hpp
index 7cbe8175..4683dcc1 100644
--- a/include/internal/catch_notimplemented_exception.hpp
+++ b/include/internal/catch_notimplemented_exception.hpp
@@ -24,7 +24,7 @@ namespace Catch {
     const char* NotImplementedException::what() const throw() {
         return m_what.c_str();
     }
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED
diff --git a/include/internal/catch_objc.hpp b/include/internal/catch_objc.hpp
index 640b4cc2..c5e021d3 100644
--- a/include/internal/catch_objc.hpp
+++ b/include/internal/catch_objc.hpp
@@ -34,34 +34,34 @@
 namespace Catch {
 
     class OcMethod : public SharedImpl<ITestCase> {
-    
+
     public:
         OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}
-        
+
         virtual void invoke() const {
             id obj = [[m_cls alloc] init];
-            
+
             performOptionalSelector( obj, @selector(setUp)  );
             performOptionalSelector( obj, m_sel );
             performOptionalSelector( obj, @selector(tearDown)  );
-            
+
             arcSafeRelease( obj );
         }
     private:
         virtual ~OcMethod() {}
-        
+
         Class m_cls;
         SEL m_sel;
     };
-    
+
     namespace Detail{
-    
+
         inline bool startsWith( std::string const& str, std::string const& sub ) {
             return str.length() > sub.length() && str.substr( 0, sub.length() ) == sub;
         }
-        
-        inline std::string getAnnotation(   Class cls, 
-                                            std::string const& annotationName, 
+
+        inline std::string getAnnotation(   Class cls,
+                                            std::string const& annotationName,
                                             std::string const& testCaseName ) {
             NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
             SEL sel = NSSelectorFromString( selStr );
@@ -70,16 +70,16 @@ namespace Catch {
             if( value )
                 return [(NSString*)value UTF8String];
             return "";
-        }        
+        }
     }
 
     inline size_t registerTestMethods() {
         size_t noTestMethods = 0;
         int noClasses = objc_getClassList( NULL, 0 );
-        
+
         Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
         objc_getClassList( classes, noClasses );
-        
+
         for( int c = 0; c < noClasses; c++ ) {
             Class cls = classes[c];
             {
@@ -93,17 +93,17 @@ namespace Catch {
                         std::string name = Detail::getAnnotation( cls, "Name", testCaseName );
                         std::string desc = Detail::getAnnotation( cls, "Description", testCaseName );
                         const char* className = class_getName( cls );
-                        
+
                         getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo() ) );
                         noTestMethods++;
                     }
                 }
-                free(methods);              
+                free(methods);
             }
         }
         return noTestMethods;
     }
-    
+
     namespace Matchers {
         namespace Impl {
         namespace NSStringMatchers {
@@ -115,29 +115,29 @@ namespace Catch {
                 StringHolder() {
                     arcSafeRelease( m_substr );
                 }
-                
+
                 NSString* m_substr;
             };
-            
+
             struct Equals : StringHolder<Equals> {
                 Equals( NSString* substr ) : StringHolder( substr ){}
-                
+
                 virtual bool match( ExpressionType const& str ) const {
                     return [str isEqualToString:m_substr];
                 }
-                
+
                 virtual std::string toString() const {
                     return "equals string: \"" + Catch::toString( m_substr ) + "\"";
                 }
             };
-            
+
             struct Contains : StringHolder<Contains> {
                 Contains( NSString* substr ) : StringHolder( substr ){}
-                
+
                 virtual bool match( ExpressionType const& str ) const {
                     return [str rangeOfString:m_substr].location != NSNotFound;
                 }
-                
+
                 virtual std::string toString() const {
                     return "contains string: \"" + Catch::toString( m_substr ) + "\"";
                 }
@@ -145,46 +145,46 @@ namespace Catch {
 
             struct StartsWith : StringHolder<StartsWith> {
                 StartsWith( NSString* substr ) : StringHolder( substr ){}
-                
+
                 virtual bool match( ExpressionType const& str ) const {
                     return [str rangeOfString:m_substr].location == 0;
                 }
-                
+
                 virtual std::string toString() const {
                     return "starts with: \"" + Catch::toString( m_substr ) + "\"";
                 }
             };
             struct EndsWith : StringHolder<EndsWith> {
                 EndsWith( NSString* substr ) : StringHolder( substr ){}
-                
+
                 virtual bool match( ExpressionType const& str ) const {
                     return [str rangeOfString:m_substr].location == [str length] - [m_substr length];
                 }
-                
+
                 virtual std::string toString() const {
                     return "ends with: \"" + Catch::toString( m_substr ) + "\"";
                 }
             };
-            
+
         } // namespace NSStringMatchers
         } // namespace Impl
-        
+
         inline Impl::NSStringMatchers::Equals
             Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }
-        
+
         inline Impl::NSStringMatchers::Contains
             Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }
-        
+
         inline Impl::NSStringMatchers::StartsWith
             StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }
-        
+
         inline Impl::NSStringMatchers::EndsWith
             EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }
-        
+
     } // namespace Matchers
-    
+
     using namespace Matchers;
-    
+
 } // namespace Catch
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/include/internal/catch_option.hpp b/include/internal/catch_option.hpp
index c56e1582..53abfe60 100644
--- a/include/internal/catch_option.hpp
+++ b/include/internal/catch_option.hpp
@@ -23,7 +23,7 @@ namespace Catch {
         Option( Option const& _other )
         : nullableValue( _other ? new( storage ) T( *_other ) : NULL )
         {}
-        
+
         ~Option() {
             reset();
         }
@@ -51,7 +51,7 @@ namespace Catch {
 
         bool some() const { return nullableValue != NULL; }
         bool none() const { return nullableValue == NULL; }
-        
+
         bool operator !() const { return nullableValue == NULL; }
         operator SafeBool::type() const {
             return SafeBool::makeSafe( some() );
diff --git a/include/internal/catch_ptr.hpp b/include/internal/catch_ptr.hpp
index 0dae6f81..3d76e328 100644
--- a/include/internal/catch_ptr.hpp
+++ b/include/internal/catch_ptr.hpp
@@ -58,20 +58,20 @@ namespace Catch {
         T* operator->() const { return m_p; }
         bool operator !() const { return m_p == NULL; }
         operator SafeBool::type() const { return SafeBool::makeSafe( m_p != NULL ); }
-        
+
     private:
         T* m_p;
     };
-    
+
     struct IShared : NonCopyable {
         virtual ~IShared();
         virtual void addRef() const = 0;
         virtual void release() const = 0;
     };
-    
+
     template<typename T = IShared>
     struct SharedImpl : T {
-        
+
         SharedImpl() : m_rc( 0 ){}
 
         virtual void addRef() const {
@@ -81,10 +81,10 @@ namespace Catch {
             if( --m_rc == 0 )
                 delete this;
         }
-        
+
         mutable unsigned int m_rc;
     };
-    
+
 } // end namespace Catch
 
 #ifdef __clang__
diff --git a/include/internal/catch_registry_hub.hpp b/include/internal/catch_registry_hub.hpp
index 14038aff..303a843a 100644
--- a/include/internal/catch_registry_hub.hpp
+++ b/include/internal/catch_registry_hub.hpp
@@ -17,7 +17,7 @@
 namespace Catch {
 
     namespace {
-        
+
         class RegistryHub : public IRegistryHub, public IMutableRegistryHub {
 
             RegistryHub( RegistryHub const& );
diff --git a/include/internal/catch_reporter_registrars.hpp b/include/internal/catch_reporter_registrars.hpp
index 9e765c21..aa60b49e 100644
--- a/include/internal/catch_reporter_registrars.hpp
+++ b/include/internal/catch_reporter_registrars.hpp
@@ -11,22 +11,22 @@
 #include "catch_interfaces_registry_hub.h"
 #include "catch_legacy_reporter_adapter.h"
 
-namespace Catch {    
+namespace Catch {
 
     template<typename T>
     class LegacyReporterRegistrar {
-    
+
         class ReporterFactory : public IReporterFactory {
 
             virtual IStreamingReporter* create( ReporterConfig const& config ) const {
                 return new LegacyReporterAdapter( new T( config ) );
             }
-            
+
             virtual std::string getDescription() const {
                 return T::getDescription();
             }
         };
-        
+
     public:
 
         LegacyReporterRegistrar( std::string const& name ) {
@@ -64,7 +64,7 @@ namespace Catch {
         ReporterRegistrar( std::string const& name ) {
             getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
         }
-    }; 
+    };
 }
 
 #define INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) \
diff --git a/include/internal/catch_reporter_registry.hpp b/include/internal/catch_reporter_registry.hpp
index ac3ed683..2ce24bef 100644
--- a/include/internal/catch_reporter_registry.hpp
+++ b/include/internal/catch_reporter_registry.hpp
@@ -15,23 +15,23 @@
 namespace Catch {
 
     class ReporterRegistry : public IReporterRegistry {
-    
+
     public:
-        
+
         virtual ~ReporterRegistry() {
             deleteAllValues( m_factories );
         }
-        
+
         virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig> const& config ) const {
             FactoryMap::const_iterator it =  m_factories.find( name );
             if( it == m_factories.end() )
                 return NULL;
             return it->second->create( ReporterConfig( config ) );
         }
-        
+
         void registerReporter( std::string const& name, IReporterFactory* factory ) {
             m_factories.insert( std::make_pair( name, factory ) );
-        }        
+        }
 
         FactoryMap const& getFactories() const {
             return m_factories;
diff --git a/include/internal/catch_result_type.h b/include/internal/catch_result_type.h
index 36aab4c9..9aed2bd3 100644
--- a/include/internal/catch_result_type.h
+++ b/include/internal/catch_result_type.h
@@ -8,7 +8,7 @@
 #ifndef TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED
 #define TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED
 
-namespace Catch {    
+namespace Catch {
 
     // ResultWas::OfType enum
     struct ResultWas { enum OfType {
@@ -16,17 +16,17 @@ namespace Catch {
         Ok = 0,
         Info = 1,
         Warning = 2,
-        
+
         FailureBit = 0x10,
-        
+
         ExpressionFailed = FailureBit | 1,
         ExplicitFailure = FailureBit | 2,
-        
+
         Exception = 0x100 | FailureBit,
-        
+
         ThrewException = Exception | 1,
         DidntThrowException = Exception | 2
-        
+
     }; };
 
     inline bool isOk( ResultWas::OfType resultType ) {
@@ -41,7 +41,7 @@ namespace Catch {
         None,
         Failed = 1, // Failure - but no debug break if Debug bit not set
         Debug = 2,  // If this bit is set, invoke the debugger
-        Abort = 4   // Test run should abort    
+        Abort = 4   // Test run should abort
     }; };
 
     // ResultDisposition::Flags enum
diff --git a/include/internal/catch_runner_impl.hpp b/include/internal/catch_runner_impl.hpp
index b67f2eb0..38315f2f 100644
--- a/include/internal/catch_runner_impl.hpp
+++ b/include/internal/catch_runner_impl.hpp
@@ -25,21 +25,21 @@
 namespace Catch {
 
     class StreamRedirect {
-    
+
     public:
         StreamRedirect( std::ostream& stream, std::string& targetString )
         :   m_stream( stream ),
             m_prevBuf( stream.rdbuf() ),
-            m_targetString( targetString ) 
-        {            
+            m_targetString( targetString )
+        {
             stream.rdbuf( m_oss.rdbuf() );
         }
-        
+
         ~StreamRedirect() {
             m_targetString += m_oss.str();
             m_stream.rdbuf( m_prevBuf );
         }
-        
+
     private:
         std::ostream& m_stream;
         std::streambuf* m_prevBuf;
@@ -50,10 +50,10 @@ namespace Catch {
     ///////////////////////////////////////////////////////////////////////////
 
     class RunContext : public IResultCapture, public IRunner {
-    
+
         RunContext( RunContext const& );
         void operator =( RunContext const& );
-        
+
     public:
 
         explicit RunContext( Ptr<IConfig const> const& config, Ptr<IStreamingReporter> const& reporter )
@@ -71,7 +71,7 @@ namespace Catch {
             m_context.setResultCapture( this );
             m_reporter->testRunStarting( m_runInfo );
         }
-        
+
         virtual ~RunContext() {
             m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, aborting() ) );
             m_context.setRunner( m_prevRunner );
@@ -92,7 +92,7 @@ namespace Catch {
             std::vector<TestCase> matchingTests = getRegistryHub().getTestCaseRegistry().getMatchingTestCases( testSpec );
 
             Totals totals;
-            
+
             testGroupStarting( testSpec, groupIndex, groupsCount );
 
             std::vector<TestCase>::const_iterator it = matchingTests.begin();
@@ -113,7 +113,7 @@ namespace Catch {
             TestCaseInfo testInfo = testCase.getTestCaseInfo();
 
             m_reporter->testCaseStarting( testInfo );
-            
+
             m_runningTest = new RunningTest( testCase );
 
             do {
@@ -151,7 +151,7 @@ namespace Catch {
         Ptr<IConfig const> config() const {
             return m_config;
         }
-        
+
     private: // IResultCapture
 
         virtual ResultAction::Value acceptExpression( ExpressionResultBuilder const& assertionResult, AssertionInfo const& assertionInfo ) {
@@ -166,14 +166,14 @@ namespace Catch {
             else if( !result.isOk() ) {
                 m_totals.assertions.failed++;
             }
-            
+
             if( m_reporter->assertionEnded( AssertionStats( result, m_messages, m_totals ) ) )
                 m_messages.clear();
 
             // Reset working state
             m_lastAssertionInfo = AssertionInfo( "", m_lastAssertionInfo.lineInfo, "{Unknown expression after the reported line}" , m_lastAssertionInfo.resultDisposition );
         }
-        
+
         virtual bool sectionStarted (
             SectionInfo const& sectionInfo,
             Counts& assertions
@@ -191,16 +191,16 @@ namespace Catch {
             m_reporter->sectionStarting( sectionInfo );
 
             assertions = m_totals.assertions;
-            
+
             return true;
         }
-        
+
         virtual void sectionEnded( SectionInfo const& info, Counts const& prevAssertions ) {
             if( std::uncaught_exception() ) {
                 m_unfinishedSections.push_back( UnfinishedSections( info, prevAssertions ) );
                 return;
             }
-            
+
             Counts assertions = m_totals.assertions - prevAssertions;
             bool missingAssertions = false;
             if( assertions.total() == 0 &&
@@ -220,7 +220,7 @@ namespace Catch {
         virtual void pushScopedMessage( MessageInfo const& message ) {
             m_messages.push_back( message );
         }
-        
+
         virtual void popScopedMessage( MessageInfo const& message ) {
             m_messages.erase( std::remove( m_messages.begin(), m_messages.end(), message ), m_messages.end() );
         }
@@ -236,7 +236,7 @@ namespace Catch {
         }
 
         virtual const AssertionResult* getLastResult() const {
-            return &m_lastResult;            
+            return &m_lastResult;
         }
 
     public:
@@ -252,7 +252,7 @@ namespace Catch {
             assertionEnded( m_lastResult );
 
             ResultAction::Value action = ResultAction::None;
-            
+
             if( !m_lastResult.isOk() ) {
                 action = ResultAction::Failed;
                 if( shouldDebugBreak() )
@@ -267,7 +267,7 @@ namespace Catch {
             try {
                 m_lastAssertionInfo = AssertionInfo( "TEST_CASE", m_runningTest->getTestCase().getTestCaseInfo().lineInfo, "", ResultDisposition::Normal );
                 m_runningTest->reset();
-                
+
                 if( m_reporter->getPreferences().shouldRedirectStdOut ) {
                     StreamRedirect coutRedir( std::cout, redirectedCout );
                     StreamRedirect cerrRedir( std::cerr, redirectedCerr );
@@ -320,7 +320,7 @@ namespace Catch {
         AssertionInfo m_lastAssertionInfo;
         std::vector<UnfinishedSections> m_unfinishedSections;
     };
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED
diff --git a/include/internal/catch_running_test.hpp b/include/internal/catch_running_test.hpp
index 7a6fda88..a8af1d9e 100644
--- a/include/internal/catch_running_test.hpp
+++ b/include/internal/catch_running_test.hpp
@@ -1,4 +1,4 @@
-/*  
+/*
  *  Created by Phil Nash on 4/5/2012
  *  Copyright 2012 Two Blue Cubes Ltd. All rights reserved.
  *
@@ -14,7 +14,7 @@
 namespace Catch {
 
     class RunningTest {
-    
+
         enum RunStatus {
             NothingRun,
             EncounteredASection,
@@ -22,7 +22,7 @@ namespace Catch {
             RanToCompletionWithSections,
             RanToCompletionWithNoSections
         };
-        
+
     public:
         explicit RunningTest( TestCase const& info )
         :   m_info( info ),
@@ -31,12 +31,12 @@ namespace Catch {
             m_currentSection( &m_rootSection ),
             m_changed( false )
         {}
-        
+
         bool wasSectionSeen() const {
-            return  m_runStatus == RanAtLeastOneSection || 
+            return  m_runStatus == RanAtLeastOneSection ||
                     m_runStatus == RanToCompletionWithSections;
         }
-        
+
         bool isBranchSection() const {
             return  m_currentSection &&
                     m_currentSection->isBranch();
@@ -53,7 +53,7 @@ namespace Catch {
             m_changed = false;
             m_lastSectionToRun = NULL;
         }
-        
+
         void ranToCompletion() {
             if( m_runStatus != RanAtLeastOneSection && m_runStatus != EncounteredASection )
                 m_runStatus = RanToCompletionWithNoSections;
@@ -63,11 +63,11 @@ namespace Catch {
                 m_changed = true;
             }
         }
-        
+
         bool addSection( std::string const& name ) {
             if( m_runStatus == NothingRun )
                 m_runStatus = EncounteredASection;
-            
+
             RunningSection* thisSection = m_currentSection->findOrAddSubSection( name, m_changed );
 
             if( !wasSectionSeen() && thisSection->shouldRun() ) {
@@ -77,7 +77,7 @@ namespace Catch {
             }
             return false;
         }
-        
+
         void endSection( std::string const&, bool stealth ) {
             if( m_currentSection->ran() ) {
                 if( !stealth )
@@ -91,7 +91,7 @@ namespace Catch {
             }
             m_currentSection = m_currentSection->getParent();
         }
-        
+
         TestCase const& getTestCase() const {
             return m_info;
         }
@@ -100,7 +100,7 @@ namespace Catch {
             return  m_runStatus == RanAtLeastOneSection ||
                     ( m_rootSection.hasUntestedSections() && m_changed );
         }
-        
+
     private:
         RunningTest( RunningTest const& );
         void operator=( RunningTest const& );
diff --git a/include/internal/catch_section.hpp b/include/internal/catch_section.hpp
index fd195364..ddf7a1a2 100644
--- a/include/internal/catch_section.hpp
+++ b/include/internal/catch_section.hpp
@@ -29,7 +29,7 @@ namespace Catch {
             if( m_sectionIncluded )
                 getCurrentContext().getResultCapture().sectionEnded( m_info, m_assertions );
         }
-        
+
         // This indicates whether the section should be executed or not
         operator bool() {
             return m_sectionIncluded;
@@ -37,12 +37,12 @@ namespace Catch {
 
     private:
         SectionInfo m_info;
-        
+
         std::string m_name;
         Counts m_assertions;
         bool m_sectionIncluded;
     };
-    
+
 } // end namespace Catch
 
 #ifdef CATCH_CONFIG_VARIADIC_MACROS
diff --git a/include/internal/catch_section_info.hpp b/include/internal/catch_section_info.hpp
index 1ea24ee2..f60896c4 100644
--- a/include/internal/catch_section_info.hpp
+++ b/include/internal/catch_section_info.hpp
@@ -1,4 +1,4 @@
-/*  
+/*
  *  Created by Phil Nash on 4/5/2012
  *  Copyright 2012 Two Blue Cubes Ltd. All rights reserved.
  *
@@ -19,7 +19,7 @@ namespace Catch {
     public:
 
         typedef std::vector<RunningSection*> SubSections;
-    
+
         enum State {
             Root,
             Unknown,
@@ -27,19 +27,19 @@ namespace Catch {
             TestedBranch,
             TestedLeaf
         };
-        
+
         RunningSection( RunningSection* parent, std::string const& name )
         :   m_state( Unknown ),
             m_parent( parent ),
             m_name( name )
         {}
-        
+
         RunningSection( std::string const& name )
         :   m_state( Root ),
             m_parent( NULL ),
             m_name( name )
         {}
-        
+
         ~RunningSection() {
             deleteAll( m_subSections );
         }
@@ -51,7 +51,7 @@ namespace Catch {
         bool shouldRun() const {
             return m_state < TestedBranch;
         }
-        
+
         bool isBranch() const {
             return m_state == Branch;
         }
diff --git a/include/internal/catch_sfinae.hpp b/include/internal/catch_sfinae.hpp
index bf8749fd..b3bc2278 100644
--- a/include/internal/catch_sfinae.hpp
+++ b/include/internal/catch_sfinae.hpp
@@ -12,7 +12,7 @@
 #include "catch_compiler_capabilities.h"
 
 namespace Catch {
-    
+
     struct TrueType {
         static const bool value = true;
         typedef void Enable;
@@ -37,7 +37,7 @@ namespace Catch {
     template<> struct SizedIf<sizeof(FalseType)> : FalseType {};
 
 #endif // CATCH_CONFIG_SFINAE
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_SFINAE_HPP_INCLUDED
diff --git a/include/internal/catch_stream.hpp b/include/internal/catch_stream.hpp
index 86b11d73..eea576ef 100644
--- a/include/internal/catch_stream.hpp
+++ b/include/internal/catch_stream.hpp
@@ -21,7 +21,7 @@ namespace Catch {
     class StreamBufImpl : public StreamBufBase {
         char data[bufferSize];
         WriterF m_writer;
-        
+
     public:
         StreamBufImpl() {
             setp( data, data + sizeof(data) );
@@ -30,20 +30,20 @@ namespace Catch {
         ~StreamBufImpl() throw() {
             sync();
         }
-        
+
     private:
         int overflow( int c ) {
             sync();
-            
+
             if( c != EOF ) {
                 if( pbase() == epptr() )
                     m_writer( std::string( 1, static_cast<char>( c ) ) );
                 else
                     sputc( static_cast<char>( c ) );
-            }            
+            }
             return 0;
         }
-        
+
         int sync() {
             if( pbase() != pptr() ) {
                 m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );
@@ -52,11 +52,11 @@ namespace Catch {
             return 0;
         }
     };
-    
+
     ///////////////////////////////////////////////////////////////////////////
 
     struct OutputDebugWriter {
-    
+
         void operator()( std::string const&str ) {
             writeToDebugConsole( str );
         }
@@ -67,7 +67,7 @@ namespace Catch {
         Stream()
         : streamBuf( NULL ), isOwned( false )
         {}
-        
+
         Stream( std::streambuf* _streamBuf, bool _isOwned )
         : streamBuf( _streamBuf ), isOwned( _isOwned )
         {}
diff --git a/include/internal/catch_tags.hpp b/include/internal/catch_tags.hpp
index 7b210989..4e7bd5a3 100644
--- a/include/internal/catch_tags.hpp
+++ b/include/internal/catch_tags.hpp
@@ -77,7 +77,7 @@ namespace Catch {
         }
 
         TagExtracter& operator=(TagExtracter const&);
-        
+
         std::set<std::string>& m_tags;
         std::string m_remainder;
     };
@@ -130,7 +130,7 @@ namespace Catch {
             }
             return true;
         }
-        
+
     private:
         TagMap m_tags;
     };
@@ -151,7 +151,7 @@ namespace Catch {
 
         std::vector<TagSet> m_tagSets;
     };
-    
+
     class TagExpressionParser : public TagParser {
     public:
         TagExpressionParser( TagExpression& exp )
@@ -187,7 +187,7 @@ namespace Catch {
         TagSet m_currentTagSet;
         TagExpression& m_exp;
     };
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_TAGS_HPP_INCLUDED
diff --git a/include/internal/catch_test_case_info.h b/include/internal/catch_test_case_info.h
index 72d73f01..2977d945 100644
--- a/include/internal/catch_test_case_info.h
+++ b/include/internal/catch_test_case_info.h
@@ -41,7 +41,7 @@ namespace Catch {
         SourceLineInfo lineInfo;
         bool isHidden;
     };
-    
+
     class TestCase : protected TestCaseInfo {
     public:
 
@@ -58,7 +58,7 @@ namespace Catch {
         bool hasTag( std::string const& tag ) const;
         bool matchesTags( std::string const& tagPattern ) const;
         std::set<std::string> const& getTags() const;
-        
+
         void swap( TestCase& other );
         bool operator == ( TestCase const& other ) const;
         bool operator < ( TestCase const& other ) const;
diff --git a/include/internal/catch_test_case_info.hpp b/include/internal/catch_test_case_info.hpp
index 99f05efe..3a279602 100644
--- a/include/internal/catch_test_case_info.hpp
+++ b/include/internal/catch_test_case_info.hpp
@@ -58,7 +58,7 @@ namespace Catch {
         tags( other.tags ),
         tagsAsString( other.tagsAsString ),
         lineInfo( other.lineInfo ),
-        isHidden( other.isHidden )        
+        isHidden( other.isHidden )
     {}
 
     TestCase::TestCase( ITestCase* testCase, TestCaseInfo const& info ) : TestCaseInfo( info ), test( testCase ) {}
diff --git a/include/internal/catch_test_case_registry_impl.hpp b/include/internal/catch_test_case_registry_impl.hpp
index 0f09369d..eedd0542 100644
--- a/include/internal/catch_test_case_registry_impl.hpp
+++ b/include/internal/catch_test_case_registry_impl.hpp
@@ -24,7 +24,7 @@ namespace Catch {
     public:
         TestRegistry() : m_unnamedCount( 0 ) {}
         virtual ~TestRegistry();
-        
+
         virtual void registerTest( TestCase const& testCase ) {
             std::string name = testCase.getTestCaseInfo().name;
             if( name == "" ) {
@@ -47,7 +47,7 @@ namespace Catch {
                 exit(1);
             }
         }
-        
+
         virtual std::vector<TestCase> const& getAllTests() const {
             return m_functionsInOrder;
         }
@@ -85,15 +85,15 @@ namespace Catch {
         }
 
     private:
-        
+
         std::set<TestCase> m_functions;
         std::vector<TestCase> m_functionsInOrder;
-        std::vector<TestCase> m_nonHiddenFunctions;        
+        std::vector<TestCase> m_nonHiddenFunctions;
         size_t m_unnamedCount;
     };
 
     ///////////////////////////////////////////////////////////////////////////
-        
+
     class FreeFunctionTestCase : public SharedImpl<ITestCase> {
     public:
 
@@ -121,22 +121,22 @@ namespace Catch {
         }
         return className;
     }
-    
+
     ///////////////////////////////////////////////////////////////////////////
-    
+
     AutoReg::AutoReg(   TestFunction function,
                         SourceLineInfo const& lineInfo,
                         NameAndDesc const& nameAndDesc ) {
         registerTestCase( new FreeFunctionTestCase( function ), "global", nameAndDesc, lineInfo );
-    }    
-    
+    }
+
     AutoReg::~AutoReg() {}
-    
+
     void AutoReg::registerTestCase( ITestCase* testCase,
                                     char const* classOrQualifiedMethodName,
                                     NameAndDesc const& nameAndDesc,
                                     SourceLineInfo const& lineInfo ) {
-        
+
         getMutableRegistryHub().registerTest
             ( makeTestCase( testCase,
                             extractClassName( classOrQualifiedMethodName ),
@@ -144,7 +144,7 @@ namespace Catch {
                             nameAndDesc.description,
                             lineInfo ) );
     }
-    
+
 } // end namespace Catch
 
 
diff --git a/include/internal/catch_test_registry.hpp b/include/internal/catch_test_registry.hpp
index 51911a40..73de60b4 100644
--- a/include/internal/catch_test_registry.hpp
+++ b/include/internal/catch_test_registry.hpp
@@ -13,18 +13,18 @@
 #include "internal/catch_compiler_capabilities.h"
 
 namespace Catch {
-    
+
 template<typename C>
 class MethodTestCase : public SharedImpl<ITestCase> {
 
 public:
     MethodTestCase( void (C::*method)() ) : m_method( method ) {}
-    
+
     virtual void invoke() const {
         C obj;
         (obj.*m_method)();
     }
-    
+
 private:
     virtual ~MethodTestCase() {}
 
@@ -47,7 +47,7 @@ struct AutoReg {
     AutoReg(    TestFunction function,
                 SourceLineInfo const& lineInfo,
                 NameAndDesc const& nameAndDesc );
-    
+
     template<typename C>
     AutoReg(    void (C::*method)(),
                 char const* className,
@@ -58,19 +58,19 @@ struct AutoReg {
                             nameAndDesc,
                             lineInfo );
     }
-    
-    void registerTestCase(  ITestCase* testCase, 
+
+    void registerTestCase(  ITestCase* testCase,
                             char const* className,
                             NameAndDesc const& nameAndDesc,
                             SourceLineInfo const& lineInfo );
-    
+
     ~AutoReg();
-    
+
 private:
-    AutoReg( AutoReg const& );    
+    AutoReg( AutoReg const& );
     void operator= ( AutoReg const& );
 };
-    
+
 } // end namespace Catch
 
 #ifdef CATCH_CONFIG_VARIADIC_MACROS
diff --git a/include/internal/catch_test_spec.h b/include/internal/catch_test_spec.h
index 36dc55c4..05f877cf 100644
--- a/include/internal/catch_test_spec.h
+++ b/include/internal/catch_test_spec.h
@@ -16,7 +16,7 @@
 #include <vector>
 
 namespace Catch {
-    
+
     struct IfFilterMatches{ enum DoWhat {
         AutoDetectBehaviour,
         IncludeTests,
@@ -64,7 +64,7 @@ namespace Catch {
         IfFilterMatches::DoWhat getFilterType() const {
             return m_filterType;
         }
-        
+
         bool shouldInclude( TestCase const& testCase ) const {
             return isMatch( testCase ) == (m_filterType == IfFilterMatches::IncludeTests);
         }
@@ -108,7 +108,7 @@ namespace Catch {
         std::string getName() const {
             return m_name;
         }
-        
+
         void addFilter( TestCaseFilter const& filter ) {
             if( filter.getFilterType() == IfFilterMatches::ExcludeTests )
                 m_exclusionFilters.push_back( filter );
@@ -146,7 +146,7 @@ namespace Catch {
             else if( m_exclusionFilters.empty() && m_tagExpressions.empty() ) {
                 return !testCase.isHidden();
             }
-            
+
             std::vector<TestCaseFilter>::const_iterator it = m_exclusionFilters.begin();
             std::vector<TestCaseFilter>::const_iterator itEnd = m_exclusionFilters.end();
             for(; it != itEnd; ++it )
diff --git a/include/internal/catch_text.h b/include/internal/catch_text.h
index 8584da31..e713f7b7 100644
--- a/include/internal/catch_text.h
+++ b/include/internal/catch_text.h
@@ -14,7 +14,7 @@
 #include <vector>
 
 namespace Catch {
-    
+
     struct TextAttributes {
         TextAttributes()
         :   initialIndent( std::string::npos ),
@@ -22,7 +22,7 @@ namespace Catch {
             width( CATCH_CONFIG_CONSOLE_WIDTH-1 ),
             tabChar( '\t' )
         {}
-        
+
         TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return *this; }
         TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this; }
         TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; }
@@ -38,7 +38,7 @@ namespace Catch {
     public:
         Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() );
         void spliceLine( std::size_t _indent, std::string& _remainder, std::size_t _pos );
-        
+
         typedef std::vector<std::string>::const_iterator const_iterator;
 
         const_iterator begin() const { return lines.begin(); }
@@ -49,13 +49,13 @@ namespace Catch {
         std::string toString() const;
 
         friend std::ostream& operator << ( std::ostream& _stream, Text const& _text );
-        
+
     private:
         std::string str;
         TextAttributes attr;
         std::vector<std::string> lines;
     };
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_TEXT_H_INCLUDED
diff --git a/include/internal/catch_text.hpp b/include/internal/catch_text.hpp
index bc502e8d..58eae6fd 100644
--- a/include/internal/catch_text.hpp
+++ b/include/internal/catch_text.hpp
@@ -12,7 +12,7 @@
 #include <vector>
 
 namespace Catch {
-    
+
     Text::Text( std::string const& _str, TextAttributes const& _attr )
     : attr( _attr )
     {
@@ -37,7 +37,7 @@ namespace Catch {
                     width--;
                 remainder = remainder.substr( 0, tabPos ) + remainder.substr( tabPos+1 );
             }
-            
+
             if( width == remainder.size() ) {
                 spliceLine( indent, remainder, width );
             }
@@ -86,7 +86,7 @@ namespace Catch {
         }
         return _stream;
     }
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_TEXT_HPP_INCLUDED
diff --git a/include/internal/catch_tostring.hpp b/include/internal/catch_tostring.hpp
index f9f0f8a4..c952d3ef 100644
--- a/include/internal/catch_tostring.hpp
+++ b/include/internal/catch_tostring.hpp
@@ -38,7 +38,7 @@ namespace Detail {
     public:
         typedef SizedIf<sizeof(dummy((T*)0))> type;
     };
-    
+
     template<typename T>
     struct IsStreamInsertable : IsStreamInsertableHelper<T>::type {};
 
@@ -47,10 +47,10 @@ namespace Detail {
     struct BorgType {
         template<typename T> BorgType( T const& );
     };
-  
+
     TrueType& testStreamable( std::ostream& );
     FalseType testStreamable( FalseType );
-    
+
     FalseType operator<<( std::ostream const&, BorgType const& );
 
     template<typename T>
@@ -59,7 +59,7 @@ namespace Detail {
         static T  const&t;
         enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };
     };
-    
+
 #endif
 
     template<bool C>
@@ -77,7 +77,7 @@ namespace Detail {
             return oss.str();
         }
     };
-    
+
 } // end namespace Detail
 
 template<typename T>
@@ -115,13 +115,13 @@ namespace Detail {
     template<typename T>
     inline std::string makeString( T const& value ) {
         return StringMaker<T>::convert( value );
-    }   
+    }
 } // end namespace Detail
 
 /// \brief converts any type to a string
 ///
-/// The default template forwards on to ostringstream - except when an 
-/// ostringstream overload does not exist - in which case it attempts to detect 
+/// The default template forwards on to ostringstream - except when an
+/// ostringstream overload does not exist - in which case it attempts to detect
 /// that and writes {?}.
 /// Overload (not specialise) this template for custom typs that you don't want
 /// to provide an ostream overload for.
@@ -129,7 +129,7 @@ template<typename T>
 std::string toString( T const& value ) {
     return StringMaker<T>::convert( value );
 }
-    
+
 // Built in overloads
 
 inline std::string toString( std::string const& value ) {
@@ -147,11 +147,11 @@ inline std::string toString( std::wstring const& value ) {
 
 inline std::string toString( const char* const value ) {
     return value ? Catch::toString( std::string( value ) ) : std::string( "{null string}" );
-}   
+}
 
 inline std::string toString( char* const value ) {
     return Catch::toString( static_cast<const char*>( value ) );
-}        
+}
 
 inline std::string toString( int value ) {
     std::ostringstream oss;
@@ -167,17 +167,17 @@ inline std::string toString( unsigned long value ) {
         oss << value;
     return oss.str();
 }
-    
+
 inline std::string toString( unsigned int value ) {
     return toString( static_cast<unsigned long>( value ) );
 }
-    
+
 inline std::string toString( const double value ) {
     std::ostringstream oss;
     oss << std::setprecision (std::numeric_limits<double>::digits10 + 1)
         << value;
     return oss.str();
-}    
+}
 
 inline std::string toString( bool value ) {
     return value ? "true" : "false";
diff --git a/include/internal/catch_totals.hpp b/include/internal/catch_totals.hpp
index 2d10f7f9..5fed14cf 100644
--- a/include/internal/catch_totals.hpp
+++ b/include/internal/catch_totals.hpp
@@ -26,17 +26,17 @@ namespace Catch {
             failed += other.failed;
             return *this;
         }
-        
+
         std::size_t total() const {
             return passed + failed;
         }
-        
+
         std::size_t passed;
         std::size_t failed;
     };
-    
+
     struct Totals {
-    
+
         Totals operator - ( Totals const& other ) const {
             Totals diff;
             diff.assertions = assertions - other.assertions;
diff --git a/include/internal/catch_xmlwriter.hpp b/include/internal/catch_xmlwriter.hpp
index 5e43b88e..5593022c 100644
--- a/include/internal/catch_xmlwriter.hpp
+++ b/include/internal/catch_xmlwriter.hpp
@@ -17,18 +17,18 @@ namespace Catch {
 
     class XmlWriter {
     public:
-        
+
         class ScopedElement {
         public:
             ScopedElement( XmlWriter* writer )
             :   m_writer( writer )
             {}
-            
+
             ScopedElement( ScopedElement const& other )
             :   m_writer( other.m_writer ){
                 other.m_writer = NULL;
             }
-            
+
             ~ScopedElement() {
                 if( m_writer )
                     m_writer->endElement();
@@ -44,11 +44,11 @@ namespace Catch {
                 m_writer->writeAttribute( name, attribute );
                 return *this;
             }
-            
+
         private:
             mutable XmlWriter* m_writer;
         };
-        
+
         XmlWriter()
         :   m_tagIsOpen( false ),
             m_needsNewline( false ),
@@ -60,7 +60,7 @@ namespace Catch {
             m_needsNewline( false ),
             m_os( &os )
         {}
-        
+
         ~XmlWriter() {
             while( !m_tags.empty() )
                 endElement();
@@ -71,7 +71,7 @@ namespace Catch {
             swap( temp );
             return *this;
         }
-        
+
         void swap( XmlWriter& other ) {
             std::swap( m_tagIsOpen, other.m_tagIsOpen );
             std::swap( m_needsNewline, other.m_needsNewline );
@@ -79,7 +79,7 @@ namespace Catch {
             std::swap( m_indent, other.m_indent );
             std::swap( m_os, other.m_os );
         }
-        
+
         XmlWriter& startElement( std::string const& name ) {
             ensureTagClosed();
             newlineIfNecessary();
@@ -105,11 +105,11 @@ namespace Catch {
             }
             else {
                 stream() << m_indent << "</" << m_tags.back() << ">\n";
-            } 
+            }
             m_tags.pop_back();
             return *this;
         }
-        
+
         XmlWriter& writeAttribute( std::string const& name, std::string const& attribute ) {
             if( !name.empty() && !attribute.empty() ) {
                 stream() << " " << name << "=\"";
@@ -123,14 +123,14 @@ namespace Catch {
             stream() << " " << name << "=\"" << ( attribute ? "true" : "false" ) << "\"";
             return *this;
         }
-        
+
         template<typename T>
         XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
             if( !name.empty() )
                 stream() << " " << name << "=\"" << attribute << "\"";
             return *this;
         }
-        
+
         XmlWriter& writeText( std::string const& text, bool indent = true ) {
             if( !text.empty() ){
                 bool tagWasOpen = m_tagIsOpen;
@@ -142,47 +142,47 @@ namespace Catch {
             }
             return *this;
         }
-        
+
         XmlWriter& writeComment( std::string const& text ) {
             ensureTagClosed();
             stream() << m_indent << "<!--" << text << "-->";
             m_needsNewline = true;
             return *this;
         }
-        
+
         XmlWriter& writeBlankLine() {
             ensureTagClosed();
             stream() << "\n";
             return *this;
         }
-        
+
     private:
-        
+
         std::ostream& stream() {
             return *m_os;
         }
-        
+
         void ensureTagClosed() {
             if( m_tagIsOpen ) {
                 stream() << ">\n";
                 m_tagIsOpen = false;
             }
         }
-        
+
         void newlineIfNecessary() {
             if( m_needsNewline ) {
                 stream() << "\n";
                 m_needsNewline = false;
             }
         }
-        
+
         void writeEncodedText( std::string const& text ) {
             static const char* charsToEncode = "<&\"";
             std::string mtext = text;
             std::string::size_type pos = mtext.find_first_of( charsToEncode );
             while( pos != std::string::npos ) {
                 stream() << mtext.substr( 0, pos );
-                
+
                 switch( mtext[pos] ) {
                     case '<':
                         stream() << "&lt;";
@@ -198,14 +198,14 @@ namespace Catch {
                 pos = mtext.find_first_of( charsToEncode );
             }
             stream() << mtext;
-        }        
-        
+        }
+
         bool m_tagIsOpen;
         bool m_needsNewline;
         std::vector<std::string> m_tags;
         std::string m_indent;
         std::ostream* m_os;
     };
-    
+
 }
 #endif // TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED
diff --git a/include/internal/clara.h b/include/internal/clara.h
index 887de868..ed22bc6a 100644
--- a/include/internal/clara.h
+++ b/include/internal/clara.h
@@ -154,7 +154,7 @@ namespace Clara {
             virtual IArgFunction<C>* clone() const { return new BoundUnaryFunction( *this ); }
             void (*function)( C& );
         };
-        
+
         template<typename C, typename T>
         struct BoundBinaryFunction : IArgFunction<C>{
             BoundBinaryFunction( void (*_function)( C&, T ) ) : function( _function ) {}
@@ -172,7 +172,7 @@ namespace Clara {
             virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction( *this ); }
             void (*function)( C&, T );
         };
-        
+
         template<typename C, typename M>
         BoundArgFunction<C> makeBoundField( M C::* _member ) {
             return BoundArgFunction<C>( new BoundDataMember<C,M>( _member ) );
@@ -208,7 +208,7 @@ namespace Clara {
         void parseIntoTokens( int argc, char const * const * argv, std::vector<Parser::Token>& tokens ) const {
             for( int i = 1; i < argc; ++i )
                 parseIntoTokens( argv[i] , tokens);
-        }        
+        }
         void parseIntoTokens( std::string arg, std::vector<Parser::Token>& tokens ) const {
             while( !arg.empty() ) {
                 Parser::Token token( Parser::Token::Positional, arg );
@@ -275,7 +275,7 @@ namespace Clara {
             void validate() const {
                 if( boundField.takesArg() && !takesArg() )
                     throw std::logic_error( dbgName() + " must specify an arg name" );
-            }        
+            }
             std::string commands() const {
                 std::ostringstream oss;
                 bool first = true;
@@ -296,7 +296,7 @@ namespace Clara {
                     oss << " <" << argName << ">";
                 return oss.str();
             }
-        
+
             Detail::BoundArgFunction<ConfigT> boundField;
             std::vector<std::string> shortNames;
             std::string longName;
@@ -361,7 +361,7 @@ namespace Clara {
         };
 
     public:
-    
+
         CommandLine()
         :   m_boundProcessName( new Detail::NullBinder<ConfigT>() ),
             m_highestSpecifiedArgPosition( 0 )
@@ -408,15 +408,15 @@ namespace Clara {
                         os  << std::string( indent + 2 + maxWidth - usageCol.size(), ' ' )
                             << desc[i];
                     os << "\n";
-                }                
-            }            
+                }
+            }
         }
         std::string optUsage() const {
             std::ostringstream oss;
             optUsage( oss );
             return oss.str();
         }
-        
+
         void argSynopsis( std::ostream& os ) const {
             for( int i = 1; i <= m_highestSpecifiedArgPosition; ++i ) {
                 if( i > 1 )
@@ -441,13 +441,13 @@ namespace Clara {
             argSynopsis( oss );
             return oss.str();
         }
-        
+
         void usage( std::ostream& os, std::string const& procName ) const {
             os << "usage:\n  " << procName << " ";
             argSynopsis( os );
             if( !m_options.empty() ) {
                 os << " [options]\n\nwhere options are: \n";
-                optUsage( os, 2 );                
+                optUsage( os, 2 );
             }
             os << "\n";
         }
@@ -455,8 +455,8 @@ namespace Clara {
             std::ostringstream oss;
             usage( oss, procName );
             return oss.str();
-        }        
-        
+        }
+
         std::vector<Parser::Token> parseInto( int argc, char const * const * argv, ConfigT& config ) const {
             std::string processName = argv[0];
             std::size_t lastSlash = processName.find_last_of( "/\\" );
@@ -486,7 +486,7 @@ namespace Clara {
                 typename std::vector<Arg>::const_iterator it = m_options.begin(), itEnd = m_options.end();
                 for(; it != itEnd; ++it ) {
                     Arg const& arg = *it;
-                        
+
                     try {
                         if( ( token.type == Parser::Token::ShortOpt && arg.hasShortName( token.data ) ) ||
                             ( token.type == Parser::Token::LongOpt && arg.hasLongName( token.data ) ) ) {
@@ -521,7 +521,7 @@ namespace Clara {
                 else
                     unusedTokens.push_back( token );
                 if( token.type == Parser::Token::Positional )
-                    position++;                
+                    position++;
             }
             return unusedTokens;
         }
@@ -538,7 +538,7 @@ namespace Clara {
             }
             return unusedTokens;
         }
-        
+
     private:
         Detail::BoundArgFunction<ConfigT> m_boundProcessName;
         std::vector<Arg> m_options;
@@ -546,7 +546,7 @@ namespace Clara {
         std::auto_ptr<Arg> m_arg;
         int m_highestSpecifiedArgPosition;
     };
-    
+
 } // end namespace Clara
 
 
diff --git a/include/reporters/catch_reporter_basic.hpp b/include/reporters/catch_reporter_basic.hpp
index 296d4d89..261092ec 100644
--- a/include/reporters/catch_reporter_basic.hpp
+++ b/include/reporters/catch_reporter_basic.hpp
@@ -16,23 +16,23 @@
 namespace Catch {
 
     class BasicReporter : public SharedImpl<IReporter> {
-    
+
         struct SpanInfo {
 
-            SpanInfo() 
+            SpanInfo()
             :   emitted( false )
             {}
-            
-            SpanInfo( const std::string& spanName ) 
+
+            SpanInfo( const std::string& spanName )
             :   name( spanName ),
                 emitted( false )
             {}
-            
-            SpanInfo( const SpanInfo& other ) 
+
+            SpanInfo( const SpanInfo& other )
             :   name( other.name ),
                 emitted( other.emitted )
             {}
-            
+
             std::string name;
             bool emitted;
         };
@@ -45,7 +45,7 @@ namespace Catch {
         {}
 
         virtual ~BasicReporter();
-        
+
         static std::string getDescription() {
             return "Reports test results as lines of text";
         }
@@ -81,10 +81,10 @@ namespace Catch {
         }
 
     private: // IReporter
-        
+
         virtual bool shouldRedirectStdout() const {
             return false;
-        }        
+        }
 
         virtual void StartTesting() {
             m_testingSpan = SpanInfo();
@@ -119,11 +119,11 @@ namespace Catch {
                 m_groupSpan = SpanInfo();
             }
         }
-        
+
         virtual void StartTestCase( const TestCaseInfo& testInfo ) {
             m_testSpan = testInfo.name;
         }
-        
+
         virtual void StartSection( const std::string& sectionName, const std::string& ) {
             m_sectionSpans.push_back( SpanInfo( sectionName ) );
         }
@@ -144,7 +144,7 @@ namespace Catch {
             SpanInfo& sectionSpan = m_sectionSpans.back();
             if( sectionSpan.emitted && !sectionSpan.name.empty() ) {
                 m_config.stream() << "[End of section: '" << sectionName << "' ";
-                
+
                 if( assertions.failed ) {
                     Colour colour( Colour::ResultError );
                     ReportCounts( "assertion", assertions);
@@ -158,18 +158,18 @@ namespace Catch {
             }
             m_sectionSpans.pop_back();
         }
-        
+
         virtual void Result( const AssertionResult& assertionResult ) {
             if( !m_config.fullConfig()->includeSuccessfulResults() && assertionResult.getResultType() == ResultWas::Ok )
                 return;
-            
+
             startSpansLazily();
-            
+
             if( !assertionResult.getSourceInfo().empty() ) {
                 Colour colour( Colour::FileName );
                 m_config.stream() << assertionResult.getSourceInfo() << ": ";
             }
-            
+
             if( assertionResult.hasExpression() ) {
                 Colour colour( Colour::OriginalExpression );
                 m_config.stream() << assertionResult.getExpression();
@@ -250,7 +250,7 @@ namespace Catch {
                     }
                     break;
             }
-            
+
             if( assertionResult.hasExpandedExpression() ) {
                 m_config.stream() << " for: ";
                 if( assertionResult.getExpandedExpression().size() > 40 ) {
@@ -263,30 +263,30 @@ namespace Catch {
             }
             m_config.stream() << std::endl;
         }
-        
-        virtual void EndTestCase(   const TestCaseInfo& testInfo, 
+
+        virtual void EndTestCase(   const TestCaseInfo& testInfo,
                                     const Totals& totals,
-                                    const std::string& stdOut, 
+                                    const std::string& stdOut,
                                     const std::string& stdErr ) {
             if( !stdOut.empty() ) {
                 startSpansLazily();
                 streamVariableLengthText( "stdout", stdOut );
             }
-            
+
             if( !stdErr.empty() ) {
                 startSpansLazily();
                 streamVariableLengthText( "stderr", stdErr );
             }
-            
+
             if( m_testSpan.emitted ) {
                 m_config.stream() << "[Finished: '" << testInfo.name << "' ";
                 ReportCounts( totals );
                 m_config.stream() << "]" << std::endl;
             }
-        }    
-        
+        }
+
     private: // helpers
-        
+
         void startSpansLazily() {
             if( !m_testingSpan.emitted ) {
                 if( m_config.fullConfig()->name().empty() )
@@ -295,17 +295,17 @@ namespace Catch {
                     m_config.stream() << "[Started testing: " << m_config.fullConfig()->name() << "]" << std::endl;
                 m_testingSpan.emitted = true;
             }
-            
+
             if( !m_groupSpan.emitted && !m_groupSpan.name.empty() ) {
                 m_config.stream() << "[Started group: '" << m_groupSpan.name << "']" << std::endl;
                 m_groupSpan.emitted = true;
             }
-            
+
             if( !m_testSpan.emitted ) {
                 m_config.stream() << std::endl << "[Running: " << m_testSpan.name << "]" << std::endl;
                 m_testSpan.emitted = true;
             }
-            
+
             if( !m_sectionSpans.empty() ) {
                 SpanInfo& sectionSpan = m_sectionSpans.back();
                 if( !sectionSpan.emitted && !sectionSpan.name.empty() ) {
@@ -320,34 +320,34 @@ namespace Catch {
                         if( !prevSpan.emitted && !prevSpan.name.empty() ) {
                             m_config.stream() << "[Started section: '" << prevSpan.name << "']" << std::endl;
                             prevSpan.emitted = true;
-                        }                        
+                        }
                     }
                 }
             }
         }
-        
+
         void streamVariableLengthText( const std::string& prefix, const std::string& text ) {
             std::string trimmed = trim( text );
             if( trimmed.find_first_of( "\r\n" ) == std::string::npos ) {
                 m_config.stream() << "[" << prefix << ": " << trimmed << "]";
             }
             else {
-                m_config.stream() << "\n[" << prefix << "] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n" << trimmed 
+                m_config.stream() << "\n[" << prefix << "] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n" << trimmed
                 << "\n[end of " << prefix << "] <<<<<<<<<<<<<<<<<<<<<<<<\n";
             }
         }
-        
+
     private:
         ReporterConfig m_config;
         bool m_firstSectionInTestCase;
-        
+
         SpanInfo m_testingSpan;
         SpanInfo m_groupSpan;
         SpanInfo m_testSpan;
         std::vector<SpanInfo> m_sectionSpans;
         bool m_aborted;
     };
-        
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_REPORTER_BASIC_HPP_INCLUDED
diff --git a/include/reporters/catch_reporter_console.hpp b/include/reporters/catch_reporter_console.hpp
index f4a69548..7d120780 100644
--- a/include/reporters/catch_reporter_console.hpp
+++ b/include/reporters/catch_reporter_console.hpp
@@ -35,17 +35,17 @@ namespace Catch {
         virtual void noMatchingTestCases( std::string const& spec ) {
             stream << "No test cases matched '" << spec << "'" << std::endl;
         }
-        
+
         virtual void assertionStarting( AssertionInfo const& ) {
         }
 
         virtual bool assertionEnded( AssertionStats const& _assertionStats ) {
             AssertionResult const& result = _assertionStats.assertionResult;
-            
+
             // Drop out if result was successful and we're not printing those
             if( !m_config->includeSuccessfulResults() && result.isOk() )
                 return false;
-            
+
             lazyPrint();
 
             AssertionPrinter printer( stream, _assertionStats );
@@ -96,7 +96,7 @@ namespace Catch {
         }
 
     private:
-        
+
         class AssertionPrinter {
             void operator= ( AssertionPrinter const& );
         public:
@@ -165,7 +165,7 @@ namespace Catch {
                         break;
                 }
             }
-            
+
             void print() const {
                 printSourceInfo();
                 if( stats.totals.assertions.total() > 0 ) {
@@ -180,7 +180,7 @@ namespace Catch {
                 }
                 printMessage();
             }
-            
+
         private:
             void printResultType() const {
                 if( !passOrFail.empty() ) {
@@ -208,7 +208,7 @@ namespace Catch {
                     stream << messageLabel << ":" << "\n";
                 for( std::vector<MessageInfo>::const_iterator it = messages.begin(), itEnd = messages.end();
                         it != itEnd;
-                        ++it ) {                    
+                        ++it ) {
                     stream << Text( it->message, TextAttributes().setIndent(2) ) << "\n";
                 }
             }
@@ -216,7 +216,7 @@ namespace Catch {
                 Colour colourGuard( Colour::FileName );
                 stream << result.getSourceInfo() << ": ";
             }
-            
+
             std::ostream& stream;
             AssertionStats const& stats;
             AssertionResult const& result;
@@ -226,14 +226,14 @@ namespace Catch {
             std::string message;
             std::vector<MessageInfo> messages;
         };
-        
+
         void lazyPrint() {
-            
+
             if( testRunInfo )
                 lazyPrintRunInfo();
             if( unusedGroupInfo )
                 lazyPrintGroupInfo();
-            
+
             if( !m_headerPrinted ) {
                 printTestCaseAndSectionHeader();
                 m_headerPrinted = true;
@@ -251,7 +251,7 @@ namespace Catch {
                 stream << " (" << libraryVersion.branchName << ")";
             stream  << " host application.\n"
                     << "Run with -? for options\n\n";
-            
+
             testRunInfo.reset();
         }
         void lazyPrintGroupInfo() {
@@ -269,9 +269,9 @@ namespace Catch {
                         section;
                         section = section->parent )
                     sections.push_back( section );
-                
+
                 // Sections
-                if( !sections.empty() ) {                    
+                if( !sections.empty() ) {
                     typedef std::vector<ThreadedSectionInfo*>::const_reverse_iterator It;
                     for( It it = sections.rbegin(), itEnd = sections.rend(); it != itEnd; ++it )
                         printHeaderString( (*it)->name, 2 );
@@ -281,7 +281,7 @@ namespace Catch {
             SourceLineInfo lineInfo = currentSectionInfo
                                     ? currentSectionInfo->lineInfo
                                     : unusedTestCaseInfo->lineInfo;
-            
+
             if( !lineInfo.empty() ){
                 stream << getDashes() << "\n";
                 Colour colourGuard( Colour::FileName );
@@ -314,7 +314,7 @@ namespace Catch {
                                         .setIndent( indent+i)
                                         .setInitialIndent( indent ) ) << "\n";
         }
-        
+
         void printTotals( const Totals& totals ) {
             if( totals.assertions.total() == 0 ) {
                 stream << "No tests ran";
@@ -361,7 +361,7 @@ namespace Catch {
                 }
             }
         }
-                
+
         void printTotalsDivider() {
             stream << getDoubleDashes() << "\n";
         }
@@ -384,7 +384,7 @@ namespace Catch {
             static const std::string dots( CATCH_CONFIG_CONSOLE_WIDTH-1, '~' );
             return dots;
         }
-        
+
     private:
         bool m_headerPrinted;
         bool m_atLeastOneTestCasePrinted;
diff --git a/include/reporters/catch_reporter_junit.hpp b/include/reporters/catch_reporter_junit.hpp
index 62b97a42..ecb46c99 100644
--- a/include/reporters/catch_reporter_junit.hpp
+++ b/include/reporters/catch_reporter_junit.hpp
@@ -18,21 +18,21 @@
 namespace Catch {
 
     class JunitReporter : public SharedImpl<IReporter> {
-    
+
         struct TestStats {
             std::string m_element;
             std::string m_resultType;
             std::string m_message;
             std::string m_content;
         };
-        
+
         struct TestCaseStats {
-        
+
             TestCaseStats( const std::string& className, const std::string& name )
             :   m_className( className ),
                 m_name( name )
             {}
-            
+
             double      m_timeInSeconds;
             std::string m_status;
             std::string m_className;
@@ -42,9 +42,9 @@ namespace Catch {
             std::vector<TestStats> m_testStats;
             std::vector<TestCaseStats> m_sections;
         };
-        
+
         struct Stats {
-        
+
             Stats( const std::string& name = std::string() )
             :   m_testsCount( 0 ),
                 m_failuresCount( 0 ),
@@ -53,17 +53,17 @@ namespace Catch {
                 m_timeInSeconds( 0 ),
                 m_name( name )
             {}
-            
+
             std::size_t m_testsCount;
             std::size_t m_failuresCount;
             std::size_t m_disabledCount;
             std::size_t m_errorsCount;
             double      m_timeInSeconds;
             std::string m_name;
-            
+
             std::vector<TestCaseStats> m_testCaseStats;
         };
-        
+
     public:
         JunitReporter( ReporterConfig const& config )
         :   m_config( config ),
@@ -71,19 +71,19 @@ namespace Catch {
             m_currentStats( &m_testSuiteStats )
         {}
         virtual ~JunitReporter();
-        
+
         static std::string getDescription() {
             return "Reports test results in an XML format that looks like Ant's junitreport target";
         }
-        
+
     private: // IReporter
-        
+
         virtual bool shouldRedirectStdout() const {
             return true;
-        }        
+        }
 
         virtual void StartTesting(){}
-        
+
         virtual void StartGroup( const std::string& groupName ) {
             if( groupName.empty() )
                 m_statsForSuites.push_back( Stats( m_config.fullConfig()->name() ) );
@@ -96,19 +96,19 @@ namespace Catch {
             m_currentStats->m_testsCount = totals.assertions.total();
             m_currentStats = &m_testSuiteStats;
         }
-        
+
         virtual void StartSection( const std::string&, const std::string& ){}
 
         virtual void NoAssertionsInSection( const std::string& ) {}
         virtual void NoAssertionsInTestCase( const std::string& ) {}
 
         virtual void EndSection( const std::string&, const Counts& ) {}
-        
+
         virtual void StartTestCase( const Catch::TestCaseInfo& testInfo ) {
             m_currentStats->m_testCaseStats.push_back( TestCaseStats( testInfo.className, testInfo.name ) );
             m_currentTestCaseStats.push_back( &m_currentStats->m_testCaseStats.back() );
         }
-        
+
         virtual void Result( const Catch::AssertionResult& assertionResult ) {
             if( assertionResult.getResultType() != ResultWas::Ok || m_config.fullConfig()->includeSuccessfulResults() ) {
                 TestCaseStats& testCaseStats = m_currentStats->m_testCaseStats.back();
@@ -153,10 +153,10 @@ namespace Catch {
                         stats.m_element = "* internal error *";
                         break;
                 }
-                testCaseStats.m_testStats.push_back( stats );                
+                testCaseStats.m_testStats.push_back( stats );
             }
         }
-        
+
         virtual void EndTestCase( const Catch::TestCaseInfo&, const Totals&, const std::string& stdOut, const std::string& stdErr ) {
             m_currentTestCaseStats.pop_back();
             assert( m_currentTestCaseStats.empty() );
@@ -167,7 +167,7 @@ namespace Catch {
                 m_stdOut << stdOut << "\n";
             if( !stdErr.empty() )
                 m_stdErr << stdErr << "\n";
-        }    
+        }
 
         virtual void Aborted() {
             // !TBD
@@ -175,13 +175,13 @@ namespace Catch {
 
         virtual void EndTesting( const Totals& ) {
             XmlWriter xml( m_config.stream() );
-            
+
             if( m_statsForSuites.size() > 0 )
                 xml.startElement( "testsuites" );
-                        
+
             std::vector<Stats>::const_iterator it = m_statsForSuites.begin();
             std::vector<Stats>::const_iterator itEnd = m_statsForSuites.end();
-            
+
             for(; it != itEnd; ++it ) {
                 XmlWriter::ScopedElement e = xml.scopedElement( "testsuite" );
                 xml.writeAttribute( "name", it->m_name );
@@ -191,19 +191,19 @@ namespace Catch {
                 xml.writeAttribute( "hostname", "tbd" );
                 xml.writeAttribute( "time", "tbd" );
                 xml.writeAttribute( "timestamp", "tbd" );
-                
+
                 OutputTestCases( xml, *it );
             }
-  
+
             xml.scopedElement( "system-out" ).writeText( trim( m_stdOut.str() ), false );
             xml.scopedElement( "system-err" ).writeText( trim( m_stdErr.str() ), false );
         }
-        
+
         void OutputTestCases( XmlWriter& xml, const Stats& stats ) {
             std::vector<TestCaseStats>::const_iterator it = stats.m_testCaseStats.begin();
             std::vector<TestCaseStats>::const_iterator itEnd = stats.m_testCaseStats.end();
             for(; it != itEnd; ++it ) {
-                
+
                 XmlWriter::ScopedElement e = xml.scopedElement( "testcase" );
                 xml.writeAttribute( "classname", it->m_className );
                 xml.writeAttribute( "name", it->m_name );
@@ -220,14 +220,14 @@ namespace Catch {
             }
         }
 
-        
+
         void OutputTestResult( XmlWriter& xml, const TestCaseStats& stats ) {
             std::vector<TestStats>::const_iterator it = stats.m_testStats.begin();
             std::vector<TestStats>::const_iterator itEnd = stats.m_testStats.end();
             for(; it != itEnd; ++it ) {
                 if( it->m_element != "success" ) {
                     XmlWriter::ScopedElement e = xml.scopedElement( it->m_element );
-                    
+
                     xml.writeAttribute( "message", it->m_message );
                     xml.writeAttribute( "type", it->m_resultType );
                     if( !it->m_content.empty() )
@@ -235,10 +235,10 @@ namespace Catch {
                 }
             }
         }
-        
+
     private:
         ReporterConfig m_config;
-        
+
         Stats m_testSuiteStats;
         Stats* m_currentStats;
         std::vector<Stats> m_statsForSuites;
@@ -246,7 +246,7 @@ namespace Catch {
         std::ostringstream m_stdOut;
         std::ostringstream m_stdErr;
     };
-    
+
 } // end namespace Catch
 
 #endif // TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED
diff --git a/include/reporters/catch_reporter_xml.hpp b/include/reporters/catch_reporter_xml.hpp
index da040b46..4c7d2518 100644
--- a/include/reporters/catch_reporter_xml.hpp
+++ b/include/reporters/catch_reporter_xml.hpp
@@ -22,12 +22,12 @@ namespace Catch {
             return "Reports test results as an XML document";
         }
         virtual ~XmlReporter();
-        
+
     private: // IReporter
 
         virtual bool shouldRedirectStdout() const {
             return true;
-        }        
+        }
 
         virtual void StartTesting() {
             m_xml = XmlWriter( m_config.stream() );
@@ -35,14 +35,14 @@ namespace Catch {
             if( !m_config.fullConfig()->name().empty() )
                 m_xml.writeAttribute( "name", m_config.fullConfig()->name() );
         }
-        
+
         virtual void EndTesting( const Totals& totals ) {
             m_xml.scopedElement( "OverallResults" )
                 .writeAttribute( "successes", totals.assertions.passed )
                 .writeAttribute( "failures", totals.assertions.failed );
             m_xml.endElement();
         }
-        
+
         virtual void StartGroup( const std::string& groupName ) {
             m_xml.startElement( "Group" )
                 .writeAttribute( "name", groupName );
@@ -54,7 +54,7 @@ namespace Catch {
                 .writeAttribute( "failures", totals.assertions.failed );
             m_xml.endElement();
         }
-        
+
         virtual void StartSection( const std::string& sectionName, const std::string& description ) {
             m_xml.startElement( "Section" )
                 .writeAttribute( "name", sectionName )
@@ -69,12 +69,12 @@ namespace Catch {
                 .writeAttribute( "failures", assertions.failed );
             m_xml.endElement();
         }
-        
+
         virtual void StartTestCase( const Catch::TestCaseInfo& testInfo ) {
             m_xml.startElement( "TestCase" ).writeAttribute( "name", testInfo.name );
             m_currentTestSuccess = true;
         }
-        
+
         virtual void Result( const Catch::AssertionResult& assertionResult ) {
             if( !m_config.fullConfig()->includeSuccessfulResults() && assertionResult.getResultType() == ResultWas::Ok )
                 return;
@@ -84,14 +84,14 @@ namespace Catch {
                     .writeAttribute( "success", assertionResult.succeeded() )
                     .writeAttribute( "filename", assertionResult.getSourceInfo().file )
                     .writeAttribute( "line", assertionResult.getSourceInfo().line );
-                
+
                 m_xml.scopedElement( "Original" )
                     .writeText( assertionResult.getExpression() );
                 m_xml.scopedElement( "Expanded" )
                     .writeText( assertionResult.getExpandedExpression() );
                 m_currentTestSuccess &= assertionResult.succeeded();
             }
-            
+
             switch( assertionResult.getResultType() ) {
                 case ResultWas::ThrewException:
                     m_xml.scopedElement( "Exception" )
@@ -120,7 +120,7 @@ namespace Catch {
                 case ResultWas::Exception:
                 case ResultWas::DidntThrowException:
                     break;
-            }            
+            }
             if( assertionResult.hasExpression() )
                 m_xml.endElement();
         }
@@ -128,12 +128,12 @@ namespace Catch {
         virtual void Aborted() {
             // !TBD
         }
-        
+
         virtual void EndTestCase( const Catch::TestCaseInfo&, const Totals&, const std::string&, const std::string& ) {
             m_xml.scopedElement( "OverallResult" ).writeAttribute( "success", m_currentTestSuccess );
             m_xml.endElement();
-        }    
-                
+        }
+
     private:
         ReporterConfig m_config;
         bool m_currentTestSuccess;
