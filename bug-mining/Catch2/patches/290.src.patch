diff --git a/src/catch2/matchers/catch_matchers_vector.hpp b/src/catch2/matchers/catch_matchers_vector.hpp
index 9a4b024f..fffbfdf6 100644
--- a/src/catch2/matchers/catch_matchers_vector.hpp
+++ b/src/catch2/matchers/catch_matchers_vector.hpp
@@ -85,11 +85,10 @@ namespace Matchers {
             // - a more general approach would be via a compare template that defaults
             // to using !=. but could be specialised for, e.g. std::vector<T> etc
             // - then just call that directly
-            if (m_comparator.size() != v.size())
-                return false;
-            for (std::size_t i = 0; i < v.size(); ++i)
-                if (m_comparator[i] != v[i])
-                    return false;
+            if ( m_comparator.size() != v.size() ) { return false; }
+            for ( std::size_t i = 0; i < v.size(); ++i ) {
+                if ( !( m_comparator[i] == v[i] ) ) { return false; }
+            }
             return true;
         }
         std::string describe() const override {
diff --git a/tests/SelfTest/UsageTests/Matchers.tests.cpp b/tests/SelfTest/UsageTests/Matchers.tests.cpp
index 49e25232..a40908d7 100644
--- a/tests/SelfTest/UsageTests/Matchers.tests.cpp
+++ b/tests/SelfTest/UsageTests/Matchers.tests.cpp
@@ -406,6 +406,25 @@ TEST_CASE( "Vector matchers that fail", "[matchers][vector][.][failing]" ) {
     }
 }
 
+namespace {
+    struct SomeType {
+        int i;
+        friend bool operator==( SomeType lhs, SomeType rhs ) {
+            return lhs.i == rhs.i;
+        }
+    };
+} // end anonymous namespace
+
+TEST_CASE( "Vector matcher with elements without !=", "[matchers][vector][approvals]" ) {
+    std::vector<SomeType> lhs, rhs;
+    lhs.push_back( { 1 } );
+    lhs.push_back( { 2 } );
+    rhs.push_back( { 1 } );
+    rhs.push_back( { 1 } );
+
+    REQUIRE_THAT( lhs, !Equals(rhs) );
+}
+
 TEST_CASE( "Exception matchers that succeed",
            "[matchers][exceptions][!throws]" ) {
     CHECK_THROWS_MATCHES(
