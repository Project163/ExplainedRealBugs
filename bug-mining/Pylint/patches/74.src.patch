diff --git a/CONTRIBUTORS.txt b/CONTRIBUTORS.txt
index 4e2297f18..01f2fa55e 100644
--- a/CONTRIBUTORS.txt
+++ b/CONTRIBUTORS.txt
@@ -232,4 +232,6 @@ contributors:
 
 * Drew Risinger: committer (docs)
 
-* Tomer Chachamu, Richard Goodman: simplifiable-if-expression
\ No newline at end of file
+* Ben James
+
+* Tomer Chachamu, Richard Goodman: simplifiable-if-expression
diff --git a/ChangeLog b/ChangeLog
index 2562bfc82..1f970989b 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -7,6 +7,10 @@ What's New in Pylint 2.2?
 
 Release date: TBA
 
+   * Remove ``enumerate`` usage suggestion when defining ``__iter__`` (C0200)
+
+     Close #2477
+
    * Add a new check, ``simplifiable-if-expression`` for expressions like ``True if cond else False``.
 
      Close #2487
diff --git a/pylint/checkers/refactoring.py b/pylint/checkers/refactoring.py
index dd19dfbe5..e8f35ca5c 100644
--- a/pylint/checkers/refactoring.py
+++ b/pylint/checkers/refactoring.py
@@ -1112,6 +1112,10 @@ class RecommandationChecker(checkers.BaseChecker):
         iterating_object = len_args[0]
         if not isinstance(iterating_object, astroid.Name):
             return
+        # If we're defining __iter__ on self, enumerate won't work
+        scope = node.scope()
+        if iterating_object.name == "self" and scope.name == "__iter__":
+            return
 
         # Verify that the body of the for loop uses a subscript
         # with the object that was iterated. This uses some heuristics
diff --git a/pylint/test/functional/consider_using_enumerate.py b/pylint/test/functional/consider_using_enumerate.py
index ab4e7b818..758375c37 100644
--- a/pylint/test/functional/consider_using_enumerate.py
+++ b/pylint/test/functional/consider_using_enumerate.py
@@ -1,6 +1,6 @@
 """Emit a message for iteration through range and len is encountered."""
 
-# pylint: disable=missing-docstring, import-error
+# pylint: disable=missing-docstring, import-error, useless-object-inheritance, unsubscriptable-object, too-few-public-methods
 
 def bad():
     iterable = [1, 2, 3]
@@ -10,6 +10,18 @@ def bad():
         yield iterable[obj]
 
 
+class Bad(object):
+
+    def __iter__(self):
+        iterable = [1, 2, 3]
+        for i in range(len(iterable)): # [consider-using-enumerate]
+            yield iterable[i]
+
+    def test(self):
+        for i in range(len(self)): # [consider-using-enumerate]
+            yield self[i]
+
+
 def good():
     iterable = other_obj = [1, 2, 3]
     total = 0
@@ -45,3 +57,11 @@ def good():
         def test(iterable):
             return iterable[index]
         yield test([1, 2, 3])
+
+
+class Good(object):
+
+    def __iter__(self):
+        # Should not suggest enumerate on self
+        for i in range(len(self)):
+            yield self[i]
diff --git a/pylint/test/functional/consider_using_enumerate.txt b/pylint/test/functional/consider_using_enumerate.txt
index d028787e7..9cbf330fb 100644
--- a/pylint/test/functional/consider_using_enumerate.txt
+++ b/pylint/test/functional/consider_using_enumerate.txt
@@ -1,2 +1,4 @@
 consider-using-enumerate:7:bad:Consider using enumerate instead of iterating with range and len
 consider-using-enumerate:9:bad:Consider using enumerate instead of iterating with range and len
+consider-using-enumerate:17:Bad.__iter__:Consider using enumerate instead of iterating with range and len
+consider-using-enumerate:21:Bad.test:Consider using enumerate instead of iterating with range and len
