diff --git a/doc/whatsnew/fragments/7857.false_positive b/doc/whatsnew/fragments/7857.false_positive
new file mode 100644
index 000000000..6dffed9d6
--- /dev/null
+++ b/doc/whatsnew/fragments/7857.false_positive
@@ -0,0 +1,3 @@
+Fixes ``method-cache-max-size-none`` false positive for methods inheriting from ``Enum``.
+
+Closes #7857
diff --git a/pylint/checkers/base/name_checker/checker.py b/pylint/checkers/base/name_checker/checker.py
index 0eded5f9b..616a57638 100644
--- a/pylint/checkers/base/name_checker/checker.py
+++ b/pylint/checkers/base/name_checker/checker.py
@@ -456,10 +456,8 @@ class NameChecker(_BasicChecker):
         elif isinstance(frame, nodes.ClassDef):
             if not list(frame.local_attr_ancestors(node.name)):
                 for ancestor in frame.ancestors():
-                    if (
-                        ancestor.name == "Enum"
-                        and ancestor.root().name == "enum"
-                        or utils.is_assign_name_annotated_with(node, "Final")
+                    if utils.is_enum(ancestor) or utils.is_assign_name_annotated_with(
+                        node, "Final"
                     ):
                         self._check_name("class_const", node.name, node)
                         break
diff --git a/pylint/checkers/design_analysis.py b/pylint/checkers/design_analysis.py
index a8e7fb1da..11ff7a5a1 100644
--- a/pylint/checkers/design_analysis.py
+++ b/pylint/checkers/design_analysis.py
@@ -15,7 +15,7 @@ import astroid
 from astroid import nodes
 
 from pylint.checkers import BaseChecker
-from pylint.checkers.utils import only_required_for_messages
+from pylint.checkers.utils import is_enum, only_required_for_messages
 from pylint.typing import MessageDefinitionTuple
 
 if TYPE_CHECKING:
@@ -175,7 +175,7 @@ def _is_exempt_from_public_methods(node: astroid.ClassDef) -> bool:
 
     # If it's a typing.Namedtuple, typing.TypedDict or an Enum
     for ancestor in node.ancestors():
-        if ancestor.name == "Enum" and ancestor.root().name == "enum":
+        if is_enum(ancestor):
             return True
         if ancestor.qname() in (TYPING_NAMEDTUPLE, TYPING_TYPEDDICT):
             return True
diff --git a/pylint/checkers/stdlib.py b/pylint/checkers/stdlib.py
index 6f40116f7..65e31da79 100644
--- a/pylint/checkers/stdlib.py
+++ b/pylint/checkers/stdlib.py
@@ -592,13 +592,17 @@ class StdlibChecker(DeprecatedMixin, BaseChecker):
     )
     def visit_functiondef(self, node: nodes.FunctionDef) -> None:
         if node.decorators and isinstance(node.parent, nodes.ClassDef):
-            self._check_lru_cache_decorators(node.decorators)
+            self._check_lru_cache_decorators(node)
             self._check_dispatch_decorators(node)
 
-    def _check_lru_cache_decorators(self, decorators: nodes.Decorators) -> None:
+    def _check_lru_cache_decorators(self, node: nodes.FunctionDef) -> None:
         """Check if instance methods are decorated with functools.lru_cache."""
+        if any(utils.is_enum(ancestor) for ancestor in node.parent.ancestors()):
+            # method of class inheriting from Enum is exempt from this check.
+            return
+
         lru_cache_nodes: list[nodes.NodeNG] = []
-        for d_node in decorators.nodes:
+        for d_node in node.decorators.nodes:
             try:
                 for infered_node in d_node.infer():
                     q_name = infered_node.qname()
diff --git a/pylint/checkers/utils.py b/pylint/checkers/utils.py
index 3b94da98e..98e7cbfe3 100644
--- a/pylint/checkers/utils.py
+++ b/pylint/checkers/utils.py
@@ -1724,6 +1724,10 @@ def is_attribute_typed_annotation(
     return False
 
 
+def is_enum(node: nodes.ClassDef) -> bool:
+    return node.name == "Enum" and node.root().name == "enum"  # type: ignore[no-any-return]
+
+
 def is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str) -> bool:
     """Test if AssignName node has `typing_name` annotation.
 
diff --git a/tests/functional/m/method_cache_max_size_none.py b/tests/functional/m/method_cache_max_size_none.py
index a0f5d3ae0..6604a7325 100644
--- a/tests/functional/m/method_cache_max_size_none.py
+++ b/tests/functional/m/method_cache_max_size_none.py
@@ -6,6 +6,7 @@ import functools
 import functools as aliased_functools
 from functools import lru_cache
 from functools import lru_cache as aliased_cache
+from enum import Enum
 
 
 @lru_cache
@@ -78,3 +79,11 @@ class MyClassWithMethodsAndMaxSize:
 @lru_cache(maxsize=None)
 def my_func(param):
     return param + 1
+
+
+class Class(Enum):
+    A = 1
+
+    @lru_cache(maxsize=None)
+    def func(self) -> None:
+        pass
diff --git a/tests/functional/m/method_cache_max_size_none.txt b/tests/functional/m/method_cache_max_size_none.txt
index 6a12d97ce..35512db85 100644
--- a/tests/functional/m/method_cache_max_size_none.txt
+++ b/tests/functional/m/method_cache_max_size_none.txt
@@ -1,7 +1,7 @@
-method-cache-max-size-none:25:5:25:20:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
-method-cache-max-size-none:29:5:29:30:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
-method-cache-max-size-none:33:5:33:38:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
-method-cache-max-size-none:37:5:37:24:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
-method-cache-max-size-none:42:5:42:24:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
+method-cache-max-size-none:26:5:26:20:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
+method-cache-max-size-none:30:5:30:30:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
+method-cache-max-size-none:34:5:34:38:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
+method-cache-max-size-none:38:5:38:24:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
 method-cache-max-size-none:43:5:43:24:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
-method-cache-max-size-none:73:5:73:40:MyClassWithMethodsAndMaxSize.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
+method-cache-max-size-none:44:5:44:24:MyClassWithMethods.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
+method-cache-max-size-none:74:5:74:40:MyClassWithMethodsAndMaxSize.my_func:'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self':INFERENCE
