diff --git a/ChangeLog b/ChangeLog
index e3bdcc079..7a99a734b 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -229,6 +229,10 @@ Release date: tba
 
       Closes #1190
 
+    * Improve handing of Python 3 classes with metaclasses declared in nested scopes.
+
+      Closes #1177
+
 
 What's new in Pylint 1.6.3?
 ===========================
diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py
index f2e8b8083..bfc5f16a2 100644
--- a/pylint/checkers/variables.py
+++ b/pylint/checkers/variables.py
@@ -1225,56 +1225,68 @@ class VariablesChecker3k(VariablesChecker):
         # do not check for not used locals here
         self._to_consume.pop()
 
+    def leave_functiondef(self, node):
+        self._check_metaclasses(node)
+        super(VariablesChecker3k, self).leave_functiondef(node)
+
     def leave_module(self, node):
-        """ Update consumption analysis variable
-        for metaclasses.
-        """
-        module_locals = self._to_consume[0][0]
-        module_imports = self._to_consume[0][1]
-        consumed = {}
-
-        for klass in node.nodes_of_class(astroid.ClassDef):
-            found = metaclass = name = None
-            if not klass._metaclass:
-                # Skip if this class doesn't use
-                # explictly a metaclass, but inherits it from ancestors
-                continue
+        self._check_metaclasses(node)
+        super(VariablesChecker3k, self).leave_module(node)
 
-            metaclass = klass.metaclass()
+    def _check_metaclasses(self, node):
+        """ Update consumption analysis for metaclasses. """
+        consumed = []  # [(scope_locals, consumed_key)]
+
+        for child_node in node.get_children():
+            if isinstance(child_node, astroid.ClassDef):
+                consumed.extend(self._check_classdef_metaclasses(child_node, node))
+
+        # Pop the consumed items, in order to avoid having
+        # unused-import and unused-variable false positives
+        for scope_locals, name in consumed:
+            scope_locals.pop(name, None)
+
+    def _check_classdef_metaclasses(self, klass, parent_node):
+        if not klass._metaclass:
+            # Skip if this class doesn't use explictly a metaclass, but inherits it from ancestors
+            return []
+
+        consumed = []  # [(scope_locals, consumed_key)]
+        metaclass = klass.metaclass()
+
+        name = None
+        if isinstance(klass._metaclass, astroid.Name):
+            name = klass._metaclass.name
+        elif metaclass:
+            name = metaclass.root().name
+
+        found = None
+        if name:
+            # check enclosing scopes starting from most local
+            for scope_locals, _, _ in self._to_consume[::-1]:
+                found = scope_locals.get(name)
+                if found:
+                    consumed.append((scope_locals, name))
+                    break
 
-            # Look the name in the already found locals.
-            # If it's not found there, look in the module locals
-            # and in the imported modules.
+        if found is None and not metaclass:
+            name = None
             if isinstance(klass._metaclass, astroid.Name):
                 name = klass._metaclass.name
-            elif metaclass:
-                # if it uses a `metaclass=module.Class`
-                name = metaclass.root().name
-
-            if name:
-                found = consumed.setdefault(
-                    name, module_locals.get(name, module_imports.get(name)))
-
-            if found is None and not metaclass:
-                name = None
-                if isinstance(klass._metaclass, astroid.Name):
-                    name = klass._metaclass.name
-                elif isinstance(klass._metaclass, astroid.Attribute):
-                    name = klass._metaclass.as_string()
-
-                if name is not None:
-                    if not (name in astroid.Module.scope_attrs or
-                            utils.is_builtin(name) or
-                            name in self.config.additional_builtins or
-                            name in node.locals):
-                        self.add_message('undefined-variable',
-                                         node=klass,
-                                         args=(name, ))
-        # Pop the consumed items, in order to
-        # avoid having unused-import false positives
-        for name in consumed:
-            module_locals.pop(name, None)
-        super(VariablesChecker3k, self).leave_module(node)
+            elif isinstance(klass._metaclass, astroid.Attribute):
+                name = klass._metaclass.as_string()
+
+            if name is not None:
+                if not (name in astroid.Module.scope_attrs or
+                        utils.is_builtin(name) or
+                        name in self.config.additional_builtins or
+                        name in parent_node.locals):
+                    self.add_message('undefined-variable',
+                                     node=klass,
+                                     args=(name,))
+
+        return consumed
+
 
 if sys.version_info >= (3, 0):
     VariablesChecker = VariablesChecker3k
diff --git a/pylint/test/functional/bugfix_local_scope_metaclass_1177.py b/pylint/test/functional/bugfix_local_scope_metaclass_1177.py
new file mode 100644
index 000000000..8904f6fb2
--- /dev/null
+++ b/pylint/test/functional/bugfix_local_scope_metaclass_1177.py
@@ -0,0 +1,56 @@
+# pylint: disable=missing-docstring,too-few-public-methods,import-error
+from UNINFERABLE import ImportedMetaclass
+
+
+class Meta(type):
+    pass
+
+
+class Class(metaclass=Meta):
+    pass
+
+
+def func_scope():
+    class Meta2(type):
+        pass
+
+    class Class2(metaclass=Meta2):
+        pass
+
+    return Class2
+
+
+class ClassScope:
+    class Meta3(type):
+        pass
+
+    class Class3(metaclass=Meta3):
+        pass
+
+    instance = Class3()
+
+
+def mixed_scopes():
+    class ClassM(metaclass=Meta):
+        pass
+
+    return ClassM
+
+
+def imported_and_nested_scope1():
+    class ClassImp1(metaclass=ImportedMetaclass):
+        pass
+
+    class ClassImp2(metaclass=ImportedMetaclass):
+        pass
+
+    return ClassImp1, ClassImp2
+
+
+def imported_and_nested_scope2():
+    from UNINFERABLE import ImportedMetaclass2
+
+    class ClassImp3(metaclass=ImportedMetaclass2):
+        pass
+
+    return ClassImp3
diff --git a/pylint/test/functional/bugfix_local_scope_metaclass_1177.rc b/pylint/test/functional/bugfix_local_scope_metaclass_1177.rc
new file mode 100644
index 000000000..c093be204
--- /dev/null
+++ b/pylint/test/functional/bugfix_local_scope_metaclass_1177.rc
@@ -0,0 +1,2 @@
+[testoptions]
+min_pyver=3.0
