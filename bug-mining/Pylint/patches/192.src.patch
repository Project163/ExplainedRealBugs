diff --git a/ChangeLog b/ChangeLog
index bbc1d7d33..ca0dc8184 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -74,6 +74,11 @@ Release date: TBA
 
   Closes #5569
 
+* Fix false positive for ``undefined-variable`` when ``namedtuple`` class
+  attributes are used as return annotations.
+
+  Closes #5568
+
 * Pyreverse - add output in mermaidjs format
 
 * ``used-before-assignment`` now considers that assignments in a try block
diff --git a/doc/whatsnew/2.13.rst b/doc/whatsnew/2.13.rst
index 5fce171e1..52353a4a0 100644
--- a/doc/whatsnew/2.13.rst
+++ b/doc/whatsnew/2.13.rst
@@ -139,6 +139,11 @@ Other Changes
 
   Closes #5323
 
+* Fix false positive for ``undefined-variable`` when ``namedtuple`` class
+  attributes are used as return annotations.
+
+  Closes #5568
+
 * ``used-before-assignment`` now considers that assignments in a try block
   may not have occurred when the except or finally blocks are executed.
 
diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py
index 1baad8b6f..b540ed615 100644
--- a/pylint/checkers/variables.py
+++ b/pylint/checkers/variables.py
@@ -1781,20 +1781,18 @@ class VariablesChecker(BaseChecker):
             frame, nodes.FunctionDef
         ):
             # Special rule for function return annotations,
-            # which uses the same name as the class where
-            # the function lives.
+            # using a name defined earlier in the class containing the function.
             if node is frame.returns and defframe.parent_of(frame.returns):
-                maybe_before_assign = annotation_return = True
-
-            if (
-                maybe_before_assign
-                and defframe.name in defframe.locals
-                and defframe.locals[node.name][0].lineno < frame.lineno
-            ):
-                # Detect class assignments with the same
-                # name as the class. In this case, no warning
-                # should be raised.
-                maybe_before_assign = False
+                annotation_return = True
+                if (
+                    frame.returns.name in defframe.locals
+                    and defframe.locals[node.name][0].lineno < frame.lineno
+                ):
+                    # Detect class assignments with a name defined earlier in the
+                    # class. In this case, no warning should be raised.
+                    maybe_before_assign = False
+                else:
+                    maybe_before_assign = True
             if isinstance(node.parent, nodes.Arguments):
                 maybe_before_assign = stmt.fromlineno <= defstmt.fromlineno
         elif is_recursive_klass:
diff --git a/tests/functional/u/undefined/undefined_variable.py b/tests/functional/u/undefined/undefined_variable.py
index 6ce9aaa6e..f9961509a 100644
--- a/tests/functional/u/undefined/undefined_variable.py
+++ b/tests/functional/u/undefined/undefined_variable.py
@@ -425,3 +425,18 @@ def typing_and_value_assignment_with_tuple_assignment():
     var_one, var_two = 1, 1
     print(var_one)
     print(var_two)
+
+
+def nested_class_as_return_annotation():
+    """A namedtuple as a class attribute is used as a return annotation
+
+    Taken from https://github.com/PyCQA/pylint/issues/5568"""
+    from collections import namedtuple
+
+    class MyObject:
+        Coords = namedtuple('Point', ['x', 'y'])
+
+        def my_method(self) -> Coords:
+            pass
+
+    print(MyObject)
