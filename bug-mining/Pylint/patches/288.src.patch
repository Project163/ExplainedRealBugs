diff --git a/doc/whatsnew/fragments/8067.bugfix b/doc/whatsnew/fragments/8067.bugfix
new file mode 100644
index 000000000..ea2dc0e47
--- /dev/null
+++ b/doc/whatsnew/fragments/8067.bugfix
@@ -0,0 +1,3 @@
+Fixed a crash when inferring a value and using its qname on a slice that was being incorrectly called.
+
+Closes #8067
diff --git a/pylint/checkers/method_args.py b/pylint/checkers/method_args.py
index e839a4e39..58fcae5c0 100644
--- a/pylint/checkers/method_args.py
+++ b/pylint/checkers/method_args.py
@@ -8,7 +8,7 @@ from __future__ import annotations
 
 from typing import TYPE_CHECKING
 
-from astroid import arguments, nodes
+from astroid import arguments, bases, nodes
 
 from pylint.checkers import BaseChecker, utils
 from pylint.interfaces import INFERENCE
@@ -69,6 +69,9 @@ class MethodArgsChecker(BaseChecker):
         if (
             inferred
             and not call_site.has_invalid_keywords()
+            and isinstance(
+                inferred, (nodes.FunctionDef, nodes.ClassDef, bases.UnboundMethod)
+            )
             and inferred.qname() in self.linter.config.timeout_methods
         ):
             keyword_arguments = [keyword.arg for keyword in node.keywords]
diff --git a/pylint/checkers/refactoring/refactoring_checker.py b/pylint/checkers/refactoring/refactoring_checker.py
index f20795e29..f6db3419f 100644
--- a/pylint/checkers/refactoring/refactoring_checker.py
+++ b/pylint/checkers/refactoring/refactoring_checker.py
@@ -1611,7 +1611,9 @@ class RefactoringChecker(checkers.BaseTokenChecker):
             # the result of this call was already assigned to a variable and will be checked when leaving the scope.
             return
         inferred = utils.safe_infer(node.func)
-        if not inferred:
+        if not inferred or not isinstance(
+            inferred, (nodes.FunctionDef, nodes.ClassDef, bases.UnboundMethod)
+        ):
             return
         could_be_used_in_with = (
             # things like ``lock.acquire()``
@@ -1998,7 +2000,7 @@ class RefactoringChecker(checkers.BaseTokenChecker):
             )
         try:
             return node.qname() in self._never_returning_functions
-        except TypeError:
+        except (TypeError, AttributeError):
             return False
 
     def _check_return_at_the_end(self, node: nodes.FunctionDef) -> None:
diff --git a/tests/functional/r/regression_02/regression_8067.py b/tests/functional/r/regression_02/regression_8067.py
new file mode 100644
index 000000000..f640aed9d
--- /dev/null
+++ b/tests/functional/r/regression_02/regression_8067.py
@@ -0,0 +1,17 @@
+"""Regression tests for inferred.qname missing"""
+
+# pylint: disable=missing-docstring,too-few-public-methods,disallowed-name
+
+x = slice(42)
+x()  # [not-callable]
+
+
+class Foo:
+    def __init__(self, foo=slice(42)):
+        self.foo = foo
+
+
+def bar():
+    i = Foo()
+    i.foo()
+    return 100
diff --git a/tests/functional/r/regression_02/regression_8067.txt b/tests/functional/r/regression_02/regression_8067.txt
new file mode 100644
index 000000000..5dba68c45
--- /dev/null
+++ b/tests/functional/r/regression_02/regression_8067.txt
@@ -0,0 +1 @@
+not-callable:6:0:6:3::x is not callable:UNDEFINED
