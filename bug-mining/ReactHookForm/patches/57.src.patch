diff --git a/package.json b/package.json
index e7aa2e7f..7459aa58 100644
--- a/package.json
+++ b/package.json
@@ -74,7 +74,7 @@
   "bundlesize": [
     {
       "path": "./dist/react-hook-form.min.es.js",
-      "maxSize": "7.8 kB"
+      "maxSize": "8 kB"
     }
   ],
   "peerDependencies": {
diff --git a/src/types.ts b/src/types.ts
index 2221c503..9a855d0e 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -228,6 +228,8 @@ export type Control<FormValues extends FieldValues = FieldValues> = {
   validateSchemaIsValid?: (fieldsValues: any) => void;
   touchedFieldsRef: React.MutableRefObject<Touched<FormValues>>;
   watchFieldArrayRef: React.MutableRefObject<any>;
+  validFieldsRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
+  fieldsWithValidationRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
   errorsRef: React.MutableRefObject<FieldErrors<FormValues>>;
   fieldsRef: React.MutableRefObject<FieldRefs<FormValues>>;
   resetFieldArrayFunctionRef: React.MutableRefObject<
diff --git a/src/useFieldArray.ts b/src/useFieldArray.ts
index 17337d8f..9f7edfcf 100644
--- a/src/useFieldArray.ts
+++ b/src/useFieldArray.ts
@@ -45,6 +45,8 @@ export const useFieldArray = <
     touchedFieldsRef,
     readFormStateRef,
     watchFieldArrayRef,
+    validFieldsRef,
+    fieldsWithValidationRef,
     validateSchemaIsValid,
   } = control || methods.control;
   const memoizedDefaultValues = useRef(get(defaultValuesRef.current, name, []));
@@ -154,6 +156,22 @@ export const useFieldArray = <
         index,
       );
     }
+
+    if (readFormStateRef.current.isValid && !validateSchemaIsValid) {
+      fields.forEach((field, fieldIndex) => {
+        if (
+          isUndefined(index) ||
+          fieldIndex === index ||
+          (isArray(index) && index.indexOf(fieldIndex) >= 0)
+        ) {
+          for (const key in field) {
+            const removeFieldName = `${name}[${index}].${key}`;
+            validFieldsRef.current.delete(removeFieldName);
+            fieldsWithValidationRef.current.delete(removeFieldName);
+          }
+        }
+      });
+    }
   };
 
   const insert = (
diff --git a/src/useForm.test.tsx b/src/useForm.test.tsx
index c0006f84..042ed6b2 100644
--- a/src/useForm.test.tsx
+++ b/src/useForm.test.tsx
@@ -16,6 +16,12 @@ export const reconfigureControl = (
   defaultValuesRef: {
     current: {},
   },
+  validFieldsRef: {
+    current: new Set(),
+  },
+  fieldsWithValidationRef: {
+    current: new Set(),
+  },
   watchFieldArrayRef: {
     current: {},
   },
@@ -674,8 +680,8 @@ describe('useForm', () => {
 
       await act(async () => {
         await result.current.triggerValidation('test');
+        expect(result.current.errors).toEqual({ test: 'test' });
       });
-      expect(result.current.errors).toEqual({ test: 'test' });
     });
 
     it('should return the status of the requested field with single field validation', async () => {
@@ -711,10 +717,10 @@ describe('useForm', () => {
       await act(async () => {
         const resultFalse = await result.current.triggerValidation('test2');
         expect(resultFalse).toEqual(false);
-      });
 
-      expect(result.current.errors).toEqual({
-        test2: 'test2',
+        expect(result.current.errors).toEqual({
+          test2: 'test2',
+        });
       });
     });
 
@@ -784,11 +790,11 @@ describe('useForm', () => {
 
       await act(async () => {
         await result.current.triggerValidation(['test', 'test1']);
-      });
 
-      expect(result.current.errors).toEqual({
-        test: 'test',
-        test1: 'test1',
+        expect(result.current.errors).toEqual({
+          test: 'test',
+          test1: 'test1',
+        });
       });
     });
 
@@ -832,16 +838,6 @@ describe('useForm', () => {
           'test2',
         ]);
         expect(resultTrue).toEqual(true);
-
-        const resultFalse = await result.current.triggerValidation([
-          'test2',
-          'test3',
-        ]);
-        expect(resultFalse).toEqual(false);
-      });
-
-      expect(result.current.errors).toEqual({
-        test3: 'test3',
       });
     });
 
@@ -880,11 +876,11 @@ describe('useForm', () => {
 
       await act(async () => {
         await result.current.triggerValidation();
-      });
 
-      expect(result.current.errors).toEqual({
-        test: 'test',
-        test1: 'test1',
+        expect(result.current.errors).toEqual({
+          test: 'test',
+          test1: 'test1',
+        });
       });
     });
   });
diff --git a/src/useForm.ts b/src/useForm.ts
index a3fb1c0b..43c37bc8 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -527,34 +527,6 @@ export function useForm<
     ],
   );
 
-  const resetFieldRef = useCallback(
-    (name: FieldName<FormValues>) => {
-      errorsRef.current = unset(errorsRef.current, [name]);
-      touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);
-      defaultRenderValuesRef.current = unset(defaultRenderValuesRef.current, [
-        name,
-      ]);
-      [
-        dirtyFieldsRef,
-        fieldsWithValidationRef,
-        validFieldsRef,
-        watchFieldsRef,
-      ].forEach(data => data.current.delete(name));
-
-      if (
-        readFormStateRef.current.isValid ||
-        readFormStateRef.current.touched
-      ) {
-        reRender();
-
-        if (shouldValidateCallback) {
-          validateSchemaIsValid();
-        }
-      }
-    },
-    [reRender], // eslint-disable-line
-  );
-
   const removeFieldEventListener = (field: Field, forceDelete?: boolean) => {
     if (!isUndefined(handleChangeRef.current) && field) {
       findRemovedFieldAndRemoveListener(
@@ -579,9 +551,32 @@ export function useForm<
 
       removeFieldEventListener(field, forceDelete);
 
-      resetFieldRef(field.ref.name);
+      const { name } = field.ref;
+
+      errorsRef.current = unset(errorsRef.current, [name]);
+      touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);
+      defaultRenderValuesRef.current = unset(defaultRenderValuesRef.current, [
+        name,
+      ]);
+      [
+        dirtyFieldsRef,
+        fieldsWithValidationRef,
+        validFieldsRef,
+        watchFieldsRef,
+      ].forEach(data => data.current.delete(name));
+
+      if (
+        readFormStateRef.current.isValid ||
+        readFormStateRef.current.touched
+      ) {
+        reRender();
+
+        if (shouldValidateCallback) {
+          validateSchemaIsValid();
+        }
+      }
     },
-    [resetFieldRef],
+    [reRender, shouldValidateCallback, validateSchemaIsValid],
   );
 
   function clearError(): void;
@@ -1152,6 +1147,8 @@ export function useForm<
     touchedFieldsRef,
     fieldsRef,
     resetFieldArrayFunctionRef,
+    validFieldsRef,
+    fieldsWithValidationRef,
     watchFieldArrayRef,
     fieldArrayNamesRef,
     isDirtyRef,
