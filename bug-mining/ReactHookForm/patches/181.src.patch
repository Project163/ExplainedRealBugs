diff --git a/src/logic/getFieldsValues.ts b/src/logic/getFieldsValues.ts
index e36620d2..0fad9607 100644
--- a/src/logic/getFieldsValues.ts
+++ b/src/logic/getFieldsValues.ts
@@ -35,7 +35,7 @@ export default <TFieldValues extends FieldValues>(
   }
 
   return deepMerge(
-    { ...((shallowFieldsStateRef || {}).current || {}) },
+    transformToNestObject({ ...((shallowFieldsStateRef || {}).current || {}) }),
     transformToNestObject(output),
   );
 };
diff --git a/src/useFieldArray.test.tsx b/src/useFieldArray.test.tsx
index 46f70deb..9639d8e4 100644
--- a/src/useFieldArray.test.tsx
+++ b/src/useFieldArray.test.tsx
@@ -369,6 +369,115 @@ describe('useFieldArray', () => {
         test: [{ id: '0', value: '' }],
       });
     });
+
+    it('should provide correct form data with nested field array', async () => {
+      let formData: any = {};
+      const Nested = ({
+        index,
+        control,
+      }: {
+        control: Control;
+        index: number;
+      }) => {
+        const { fields, append } = useFieldArray({
+          name: `test[${index}].nestedArray`,
+          control,
+        });
+
+        return (
+          <div>
+            {fields.map((item, i) => (
+              <input
+                key={item.id}
+                name={`test[${index}].nestedArray[${i}].value`}
+                ref={control.register()}
+                defaultValue={item.value}
+              />
+            ))}
+
+            <button type={'button'} onClick={() => append({ value: 'test' })}>
+              Append Nest
+            </button>
+          </div>
+        );
+      };
+
+      const Component = () => {
+        const {
+          register,
+          control,
+          formState: { isValid },
+        } = useForm<{
+          test: {
+            value: string;
+            nestedArray: {
+              value: string;
+            }[];
+          }[];
+        }>({
+          resolver: (data) => {
+            formData = data;
+            return {
+              values: data,
+              errors: {},
+            };
+          },
+          mode: 'onChange',
+          shouldUnregister: false,
+          defaultValues: {
+            test: [{ value: '1', nestedArray: [{ value: '2' }] }],
+          },
+        });
+        const { fields, remove } = useFieldArray({
+          name: 'test',
+          control,
+        });
+
+        return (
+          <form>
+            {fields.map((item, i) => (
+              <fieldset key={item.id}>
+                <input
+                  name={`test[${i}].value`}
+                  ref={register()}
+                  defaultValue={item.value}
+                />
+
+                <Nested control={control} index={i} />
+                <button type={'button'} onClick={() => remove(i)}>
+                  delete
+                </button>
+              </fieldset>
+            ))}
+            <span>{isValid && 'valid'}</span>
+          </form>
+        );
+      };
+
+      render(<Component />);
+
+      fireEvent.click(screen.getByRole('button', { name: 'Append Nest' }));
+
+      await waitFor(() => screen.getByText('valid'));
+
+      expect(formData).toEqual({
+        test: [
+          {
+            value: '1',
+            nestedArray: [
+              { id: '1', value: '2' },
+              { id: '2', value: 'test' },
+            ],
+          },
+        ],
+      });
+
+      fireEvent.click(screen.getByRole('button', { name: 'delete' }));
+
+      expect(formData).toEqual({
+        test: [],
+      });
+    });
   });
 
   describe('when component unMount', () => {
@@ -764,6 +873,69 @@ describe('useFieldArray', () => {
   });
 
   describe('append', () => {
+    it('should append dirty fields correctly', async () => {
+      let dirtyInputs = {};
+      const Component = () => {
+        const {
+          register,
+          control,
+          formState: { dirtyFields },
+        } = useForm<{
+          test: { value: string }[];
+        }>({
+          defaultValues: {
+            test: [
+              { value: 'plz change' },
+              { value: 'dont change' },
+              { value: 'dont change' },
+            ],
+          },
+        });
+        const { fields, append } = useFieldArray({
+          control,
+          name: 'test',
+        });
+
+        dirtyInputs = dirtyFields;
+
+        return (
+          <form>
+            {fields.map((field, i) => (
+              <input
+                key={field.id}
+                name={`test[${i}].value`}
+                ref={register()}
+                defaultValue={field.value}
+              />
+            ))}
+            <button type="button" onClick={() => append({ value: '' })}>
+              append
+            </button>
+            {dirtyFields.test?.length && 'dirty'}
+          </form>
+        );
+      };
+
+      render(<Component />);
+
+      fireEvent.input(screen.getAllByRole('textbox')[0], {
+        target: { value: 'test' },
+      });
+      fireEvent.blur(screen.getAllByRole('textbox')[0]);
+
+      await waitFor(() => screen.getByText('dirty'));
+
+      expect(dirtyInputs).toEqual({
+        test: [{ value: true }],
+      });
+
+      fireEvent.click(screen.getByRole('button'));
+
+      expect(dirtyInputs).toEqual({
+        test: [{ value: true }, undefined, undefined, { value: true }],
+      });
+    });
+
     it('should append data into the fields', () => {
       const { result } = renderHook(() => {
         const { register, control } = useForm();
diff --git a/src/useFieldArray.ts b/src/useFieldArray.ts
index 8ce5eea0..967246a8 100644
--- a/src/useFieldArray.ts
+++ b/src/useFieldArray.ts
@@ -262,10 +262,13 @@ export const useFieldArray = <
       readFormStateRef.current.dirtyFields ||
       readFormStateRef.current.isDirty
     ) {
+      const dirtyInputs = get(dirtyFields, name, []);
       set(dirtyFields, name, [
-        ...(isArray(get(dirtyFields, name))
-          ? get(dirtyFields, name)
-          : fillEmptyArray(allFields.current)),
+        ...(allFields.current.length > dirtyInputs.length
+          ? (fillEmptyArray(allFields.current) || []).map(
+              (_, index) => dirtyInputs[index],
+            )
+          : dirtyInputs),
         ...filterBooleanArray(value),
       ]);
       updateFormState({
