diff --git a/src/__snapshots__/useFieldArray.test.tsx.snap b/src/__snapshots__/useFieldArray.test.tsx.snap
index a505b836..c2562710 100644
--- a/src/__snapshots__/useFieldArray.test.tsx.snap
+++ b/src/__snapshots__/useFieldArray.test.tsx.snap
@@ -1,12 +1,37 @@
 // Jest Snapshot v1, https://goo.gl/fbAQLP
 
-exports[`useFieldArray array of array fields should not populate all array fields with setValue by default 1`] = `
+exports[`useFieldArray array of array fields should populate all array fields correctly with setValue 1`] = `
 <DocumentFragment>
-  <div />
+  <div>
+    <div>
+      <input
+        name="nest[0].value"
+        value="1"
+      />
+      <div>
+        <input
+          name="nest[0].nestedArray[0].value"
+          value="1"
+        />
+      </div>
+    </div>
+    <div>
+      <input
+        name="nest[1].value"
+        value="2"
+      />
+      <div>
+        <input
+          name="nest[1].nestedArray[0].value"
+          value="1"
+        />
+      </div>
+    </div>
+  </div>
 </DocumentFragment>
 `;
 
-exports[`useFieldArray array of array fields should populate all array fields correctly with setValue 1`] = `
+exports[`useFieldArray array of array fields should populate all array fields with setValue when name match Field Array 1`] = `
 <DocumentFragment>
   <div>
     <div>
diff --git a/src/types/form.ts b/src/types/form.ts
index f9739b27..de7587c5 100644
--- a/src/types/form.ts
+++ b/src/types/form.ts
@@ -146,8 +146,6 @@ export type Control<TFieldValues extends FieldValues = FieldValues> = Pick<
   formStateRef: React.MutableRefObject<FormState<TFieldValues>>;
   updateFormState: (args?: Partial<FormState<TFieldValues>>) => void;
   validateResolver?: (fieldsValues: FieldValues) => void;
-  watchFieldsRef: React.MutableRefObject<Set<InternalFieldName<TFieldValues>>>;
-  isWatchAllRef: React.MutableRefObject<boolean>;
   validFieldsRef: React.MutableRefObject<FieldNamesMarkedBoolean<TFieldValues>>;
   fieldsWithValidationRef: React.MutableRefObject<
     FieldNamesMarkedBoolean<TFieldValues>
@@ -173,7 +171,7 @@ export type Control<TFieldValues extends FieldValues = FieldValues> = Pick<
     defaultValue?: unknown,
     watchId?: string,
   ) => unknown;
-  renderWatchedInputs: (name: string, found?: boolean) => void;
+  updateWatchedValue: (name: string) => void;
 };
 
 export type UseWatchOptions<TFieldValues extends FieldValues = FieldValues> = {
diff --git a/src/useFieldArray.test.tsx b/src/useFieldArray.test.tsx
index 65e89cda..27076383 100644
--- a/src/useFieldArray.test.tsx
+++ b/src/useFieldArray.test.tsx
@@ -3987,7 +3987,7 @@ describe('useFieldArray', () => {
       expect(screen.getAllByRole('textbox')).toHaveLength(3);
     });
 
-    it('should not populate all array fields with setValue by default', async () => {
+    it('should populate all array fields with setValue when name match Field Array', async () => {
       const ChildComponent = ({
         index,
         control,
diff --git a/src/useFieldArray.ts b/src/useFieldArray.ts
index 2f58346e..414a2000 100644
--- a/src/useFieldArray.ts
+++ b/src/useFieldArray.ts
@@ -63,7 +63,7 @@ export const useFieldArray = <
 
   const focusIndexRef = React.useRef(-1);
   const {
-    isWatchAllRef,
+    updateWatchedValue,
     resetFieldArrayFunctionRef,
     fieldArrayNamesRef,
     fieldsRef,
@@ -73,12 +73,10 @@ export const useFieldArray = <
     shallowFieldsStateRef,
     updateFormState,
     readFormStateRef,
-    watchFieldsRef,
     validFieldsRef,
     fieldsWithValidationRef,
     fieldArrayDefaultValuesRef,
     validateResolver,
-    renderWatchedInputs,
     getValues,
     shouldUnregister,
   } = control || methods.control;
@@ -463,20 +461,7 @@ export const useFieldArray = <
       set(fieldArrayDefaultValuesRef.current, name, defaultValues);
     }
 
-    if (isWatchAllRef.current) {
-      updateFormState();
-    } else if (watchFieldsRef) {
-      let shouldRenderUseWatch = true;
-      for (const watchField of watchFieldsRef.current) {
-        if (watchField.startsWith(name)) {
-          updateFormState();
-          shouldRenderUseWatch = false;
-          break;
-        }
-      }
-
-      shouldRenderUseWatch && renderWatchedInputs(name);
-    }
+    updateWatchedValue(name);
 
     if (focusIndexRef.current > -1) {
       for (const key in fieldsRef.current) {
diff --git a/src/useForm.test.tsx b/src/useForm.test.tsx
index f2dbe3ed..809f185e 100644
--- a/src/useForm.test.tsx
+++ b/src/useForm.test.tsx
@@ -411,6 +411,40 @@ describe('useForm', () => {
   });
 
   describe('watch', () => {
+    it('should return undefined when input gets unmounted', async () => {
+      const Component = () => {
+        const { register, watch } = useForm<{ test: string }>();
+        const [show, setShow] = React.useState(true);
+        const data = watch('test');
+
+        return (
+          <>
+            {show && <input ref={register} name={'test'} />}
+            <span>{data}</span>
+            <button type="button" onClick={() => setShow(false)}>
+              hide
+            </button>
+          </>
+        );
+      };
+
+      render(<Component />);
+
+      fireEvent.input(screen.getByRole('textbox'), {
+        target: {
+          value: 'test',
+        },
+      });
+
+      screen.getByText('test');
+
+      await actComponent(async () => {
+        await fireEvent.click(screen.getByRole('button'));
+      });
+
+      expect(screen.queryByText('test')).toBeNull();
+    });
+
     it('should watch individual input', () => {
       const { result } = renderHook(() => useForm<{ test: string }>());
 
@@ -473,7 +507,6 @@ describe('useForm', () => {
       result.current.register({ type: 'radio', name: 'test1', value: '' });
 
       expect(result.current.watch()).toEqual({ test: '', test1: '' });
-      expect(result.current.control.isWatchAllRef.current).toBeTruthy();
     });
   });
 
@@ -501,6 +534,33 @@ describe('useForm', () => {
       expect(result.current.formState.isSubmitted).toBeFalsy();
     });
 
+    it('should reset shallowStateRef when shouldUnregister set to false', () => {
+      let methods: any;
+      const Component = () => {
+        methods = useForm<{
+          test: string;
+        }>({
+          shouldUnregister: false,
+        });
+        return (
+          <form>
+            <input name="test" ref={methods.register} />
+          </form>
+        );
+      };
+      render(<Component />);
+
+      actComponent(() =>
+        methods.reset({
+          test: 'test',
+        }),
+      );
+
+      expect(methods.control.shallowFieldsStateRef.current).toEqual({
+        test: 'test',
+      });
+    });
+
     it('should reset the form if ref is HTMLElement and parent element is form', async () => {
       const mockReset = jest.spyOn(window.HTMLFormElement.prototype, 'reset');
       let methods: UseFormMethods;
diff --git a/src/useForm.ts b/src/useForm.ts
index 4c38fc84..f38fd01a 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -462,15 +462,16 @@ export function useForm<
       } else if (!isPrimitive(value)) {
         setInternalValues(name, value, config);
 
-        if (fieldArrayNamesRef.current.has(name) && config.shouldDirty) {
+        if (fieldArrayNamesRef.current.has(name)) {
           fieldArrayDefaultValuesRef.current[name] = value;
           resetFieldArrayFunctionRef.current[name]({
             [name]: value,
           } as UnpackNestedValue<DeepPartial<TFieldValues>>);
 
           if (
-            readFormStateRef.current.isDirty ||
-            readFormStateRef.current.dirtyFields
+            (readFormStateRef.current.isDirty ||
+              readFormStateRef.current.dirtyFields) &&
+            config.shouldDirty
           ) {
             set(
               formStateRef.current.dirtyFields,
@@ -691,6 +692,23 @@ export function useForm<
     [shouldUnregister],
   );
 
+  const updateWatchedValue = (name: string) => {
+    if (isWatchAllRef.current) {
+      updateFormState();
+    } else if (watchFieldsRef) {
+      let shouldRenderUseWatch = true;
+      for (const watchField of watchFieldsRef.current) {
+        if (watchField.startsWith(name)) {
+          updateFormState();
+          shouldRenderUseWatch = false;
+          break;
+        }
+      }
+
+      shouldRenderUseWatch && renderWatchedInputs(name);
+    }
+  };
+
   const removeFieldEventListenerAndRef = React.useCallback(
     (field: Field | undefined, forceDelete?: boolean) => {
       if (field) {
@@ -710,6 +728,7 @@ export function useForm<
           });
 
           resolverRef.current && validateResolver();
+          updateWatchedValue(field.ref.name);
         }
       }
     },
@@ -1167,14 +1186,14 @@ export function useForm<
     defaultValuesRef.current = cloneObject(values || defaultValuesRef.current);
     values && renderWatchedInputs('');
 
-    shallowFieldsStateRef.current = shouldUnregister
-      ? {}
-      : cloneObject(values) || {};
-
     Object.values(resetFieldArrayFunctionRef.current).forEach(
       (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),
     );
 
+    shallowFieldsStateRef.current = shouldUnregister
+      ? {}
+      : cloneObject(values) || {};
+
     resetRefs(omitResetState);
   };
 
@@ -1217,7 +1236,7 @@ export function useForm<
   };
 
   const control = {
-    renderWatchedInputs,
+    updateWatchedValue,
     shouldUnregister,
     removeFieldEventListener,
     watchInternal,
@@ -1227,8 +1246,6 @@ export function useForm<
       isReValidateOnChange,
     },
     fieldsRef,
-    isWatchAllRef,
-    watchFieldsRef,
     resetFieldArrayFunctionRef,
     useWatchFieldsRef,
     useWatchRenderFunctionsRef,
diff --git a/src/useWatch.test.tsx b/src/useWatch.test.tsx
index 1f41563f..a647c801 100644
--- a/src/useWatch.test.tsx
+++ b/src/useWatch.test.tsx
@@ -4,6 +4,7 @@ import {
   screen,
   fireEvent,
   act as actComponent,
+  waitFor,
 } from '@testing-library/react';
 import { renderHook } from '@testing-library/react-hooks';
 import { useForm } from './useForm';
@@ -48,7 +49,6 @@ describe('useWatch', () => {
       };
       render(<Component />);
 
-      expect(method.control.isWatchAllRef.current).toBeFalsy();
       expect(watched).toEqual({ test: 'test' });
     });
 
@@ -321,9 +321,75 @@ describe('useWatch', () => {
 
       expect(watchedValue).toEqual({ test: undefined, test1: undefined });
     });
+
+    it('should return undefined when input gets removed', async () => {
+      const Component = () => {
+        const { register, control } = useForm<{ test: string }>();
+        const [show, setShow] = React.useState(true);
+        const data = useWatch<string>({ name: 'test', control });
+
+        return (
+          <>
+            {show && <input ref={register} name={'test'} />}
+            <span>{data}</span>
+            <button type="button" onClick={() => setShow(false)}>
+              hide
+            </button>
+          </>
+        );
+      };
+
+      render(<Component />);
+
+      fireEvent.input(screen.getByRole('textbox'), {
+        target: {
+          value: 'test',
+        },
+      });
+
+      screen.getByText('test');
+
+      await actComponent(async () => {
+        await fireEvent.click(screen.getByRole('button'));
+      });
+
+      expect(screen.queryByText('test')).toBeNull();
+    });
   });
 
   describe('reset', () => {
+    it('should return updated default value with watched field after reset', async () => {
+      function Watcher({ control }: { control: Control }) {
+        const testField = useWatch<string>({
+          name: 'test',
+          control: control,
+        });
+
+        return <div>{testField}</div>;
+      }
+
+      function Component() {
+        const { reset, control } = useForm({
+          defaultValues: {
+            test: '',
+            name: '',
+          },
+        });
+
+        React.useEffect(() => {
+          reset({
+            test: 'test',
+          });
+        }, [reset]);
+
+        return <Watcher control={control} />;
+      }
+
+      render(<Component />);
+
+      await waitFor(() => screen.getByText('test'));
+    });
+
     it('should return default value of reset method', async () => {
       const Component = () => {
         const { register, reset, control } = useForm<{
diff --git a/src/useWatch.ts b/src/useWatch.ts
index 80eefaf9..8d998990 100644
--- a/src/useWatch.ts
+++ b/src/useWatch.ts
@@ -68,7 +68,7 @@ export function useWatch<TWatchFieldValues>({
       : defaultValue,
   );
   const idRef = React.useRef<string>();
-  const defaultValueRef = React.useRef(value);
+  const defaultValueRef = React.useRef(defaultValue);
 
   const updateWatchValue = React.useCallback(() => {
     const value = watchInternal(name, defaultValueRef.current, idRef.current);
