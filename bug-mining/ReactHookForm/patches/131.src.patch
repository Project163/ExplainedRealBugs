diff --git a/src/useForm.test.tsx b/src/useForm.test.tsx
index 11ad1293..e0bb20a8 100644
--- a/src/useForm.test.tsx
+++ b/src/useForm.test.tsx
@@ -492,6 +492,32 @@ describe('useForm', () => {
       });
     });
 
+    it('should reset unmountFieldsState value when shouldUnregister set to false', () => {
+      const { result } = renderHook(() =>
+        useForm({
+          shouldUnregister: false,
+        }),
+      );
+
+      result.current.register('test');
+
+      act(() => result.current.reset({ test: 'test' }));
+
+      expect(result.current.control.unmountFieldsStateRef.current).toEqual({
+        test: 'test',
+      });
+    });
+
+    it('should not reset unmountFieldsState value by default', () => {
+      const { result } = renderHook(() => useForm());
+
+      result.current.register('test');
+
+      act(() => result.current.reset({ test: 'test' }));
+
+      expect(result.current.control.unmountFieldsStateRef.current).toEqual({});
+    });
+
     it('should execute resetFieldArrayFunctionRef if resetFieldArrayFunctionRef is exist', async () => {
       const { result } = renderHook(() => useForm());
       const reset = jest.fn();
@@ -694,6 +720,24 @@ describe('useForm', () => {
       });
     });
 
+    it('should set unmountFieldsState value when shouldUnregister is set to false', async () => {
+      const { result } = renderHook(() =>
+        useForm<{ test: string; checkbox: string[] }>({
+          shouldUnregister: false,
+        }),
+      );
+
+      act(() => {
+        result.current.setValue('test', '1');
+        result.current.setValue('checkbox', ['1', '2']);
+      });
+
+      expect(result.current.control.unmountFieldsStateRef.current).toEqual({
+        checkbox: ['1', '2'],
+        test: '1',
+      });
+    });
+
     it('should set nested value correctly ', () => {
       const { result } = renderHook(() =>
         useForm<{
@@ -813,7 +857,9 @@ describe('useForm', () => {
     it('should not work if field is not registered', () => {
       const { result } = renderHook(() => useForm());
 
-      result.current.setValue('test', '1');
+      act(() => {
+        result.current.setValue('test', '1');
+      });
 
       expect(result.current.control.fieldsRef.current['test']).toBeUndefined();
     });
diff --git a/src/useForm.ts b/src/useForm.ts
index 73d3ba2d..a9320ea0 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -409,10 +409,13 @@ export function useForm<
         return config.shouldDirty && setDirty(name);
       } else if (!isPrimitive(value)) {
         setInternalValues(name, value, config);
-        return true;
       }
 
-      unmountFieldsStateRef.current[name] = value;
+      if (!shouldUnregister) {
+        unmountFieldsStateRef.current[name] = value;
+      }
+
+      return true;
     },
     [setDirty, setFieldValue, setInternalValues],
   );
@@ -924,10 +927,7 @@ export function useForm<
         e.persist();
       }
       let fieldErrors: FieldErrors<TFieldValues> = {};
-      let fieldValues: FieldValues = {
-        ...unmountFieldsStateRef.current,
-        ...getValues(),
-      };
+      let fieldValues: FieldValues = getValues();
 
       if (readFormStateRef.current.isSubmitting) {
         isSubmittingRef.current = true;
@@ -1076,7 +1076,7 @@ export function useForm<
       renderWatchedInputs('');
     }
 
-    unmountFieldsStateRef.current = values || {};
+    unmountFieldsStateRef.current = shouldUnregister ? {} : values || {};
 
     Object.values(resetFieldArrayFunctionRef.current).forEach(
       (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),
