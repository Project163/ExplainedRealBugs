diff --git a/README.md b/README.md
index f5ca3082..b8087657 100644
--- a/README.md
+++ b/README.md
@@ -31,7 +31,7 @@ English | <a href="./docs/README.zh-TW.md">繁中</a> | <a href="./docs/README.z
 
 - Built with performance and DX in mind
 - Embrace native form validation
-- Simple integration with [UI libraries](https://codesandbox.io/s/react-hook-form-v6-controller-24gcl)
+- Simple integration with [UI libraries](https://codesandbox.io/s/react-hook-form-v6-controller-qsd8r)
 - [Tiny size](https://bundlephobia.com/result?p=react-hook-form@latest) without any dependency
 - Follows HTML standard for [validation](https://react-hook-form.com/get-started#Applyvalidation)
 - [Resolvers](https://github.com/react-hook-form/resolvers) support [Yup](https://github.com/jquense/yup), [Zod](https://github.com/vriad/zod), [Superstruct](https://github.com/ianstormtaylor/superstruct), [Joi](https://github.com/hapijs/joi) or custom
diff --git a/src/types/fieldArray.ts b/src/types/fieldArray.ts
index aad8ae2d..6250b59e 100644
--- a/src/types/fieldArray.ts
+++ b/src/types/fieldArray.ts
@@ -1,8 +1,11 @@
-import { Control } from './form';
+import { Control, UnpackNestedValue } from './form';
 import { FieldValues } from './fields';
+import { DeepPartial } from './utils';
 
 export type FieldArrayName = string;
 
+export type FieldArrayDefaultValues = Partial<Record<FieldArrayName, any>>;
+
 export type UseFieldArrayOptions<
   TKeyName extends string = 'id',
   TControl extends Control = Control
@@ -12,6 +15,11 @@ export type UseFieldArrayOptions<
   control?: TControl;
 };
 
+export type ResetFieldArrayFunctionRef<TFieldValues> = Record<
+  FieldArrayName,
+  (data?: UnpackNestedValue<DeepPartial<TFieldValues>>) => void
+>;
+
 export type ArrayField<
   TFieldArrayValues extends FieldValues = FieldValues,
   TKeyName extends string = 'id'
diff --git a/src/types/form.ts b/src/types/form.ts
index 87a1a86a..fd02dd00 100644
--- a/src/types/form.ts
+++ b/src/types/form.ts
@@ -11,10 +11,10 @@ import {
   InternalFieldName,
   Ref,
 } from './fields';
-import { FieldArrayName } from './fieldArray';
 import { ErrorOption, FieldErrors } from './errors';
 import { ValidationRules } from './validator';
 import { ControllerRenderProps } from './props';
+import { FieldArrayDefaultValues } from './fieldArray';
 
 declare const $NestedValue: unique symbol;
 
@@ -36,12 +36,17 @@ export type UnpackNestedValue<T> = T extends NestedValue<infer U>
   ? { [K in keyof T]: UnpackNestedValue<T[K]> }
   : T;
 
-export type DefaultValues<TFieldValues> =
-  | Partial<FieldValue<UnpackNestedValue<TFieldValues>>>
-  | Partial<UnpackNestedValue<DeepPartial<TFieldValues>>>;
+export type DefaultValues<TFieldValues> = UnpackNestedValue<
+  DeepPartial<TFieldValues>
+>;
 
 export type InternalNameSet<FieldValues> = Set<InternalFieldName<FieldValues>>;
 
+export type RecordInternalNameSet<TFieldValues> = Record<
+  string,
+  InternalNameSet<TFieldValues>
+>;
+
 export type ValidationMode = {
   onBlur: 'onBlur';
   onChange: 'onChange';
@@ -75,7 +80,7 @@ export type UseFormOptions<
 > = Partial<{
   mode: Mode;
   reValidateMode: Exclude<Mode, 'onTouched' | 'all'>;
-  defaultValues: UnpackNestedValue<DeepPartial<TFieldValues>>;
+  defaultValues: DefaultValues<TFieldValues>;
   resolver: Resolver<TFieldValues, TContext>;
   context: TContext;
   shouldFocusError: boolean;
@@ -137,12 +142,8 @@ export type Control<TFieldValues extends FieldValues = FieldValues> = Pick<
     isReValidateOnBlur: boolean;
     isReValidateOnChange: boolean;
   }>;
-  fieldArrayDefaultValuesRef: React.MutableRefObject<
-    Record<FieldArrayName, unknown[]>
-  >;
-  fieldArrayValuesRef: React.MutableRefObject<
-    Record<FieldArrayName, unknown[]>
-  >;
+  fieldArrayDefaultValuesRef: FieldArrayDefaultValues;
+  fieldArrayValuesRef: FieldArrayDefaultValues;
   shouldUnregister: boolean;
   formStateRef: React.MutableRefObject<FormState<TFieldValues>>;
   updateFormState: (args?: Partial<FormState<TFieldValues>>) => void;
@@ -162,7 +163,7 @@ export type Control<TFieldValues extends FieldValues = FieldValues> = Pick<
   >;
   defaultValuesRef: React.MutableRefObject<DefaultValues<TFieldValues>>;
   useWatchFieldsRef: React.MutableRefObject<
-    Record<string, InternalNameSet<TFieldValues>>
+    RecordInternalNameSet<TFieldValues>
   >;
   useWatchRenderFunctionsRef: React.MutableRefObject<
     Record<string, React.Dispatch<unknown>>
@@ -175,6 +176,8 @@ export type Control<TFieldValues extends FieldValues = FieldValues> = Pick<
   updateWatchedValue: (name: string) => void;
 };
 
+export type UseWatchRenderFunctions = Record<string, () => void>;
+
 export type UseWatchOptions<TFieldValues extends FieldValues = FieldValues> = {
   defaultValue?: unknown;
   name?: string | string[];
@@ -184,7 +187,7 @@ export type UseWatchOptions<TFieldValues extends FieldValues = FieldValues> = {
 export type SetFieldValue<TFieldValues> =
   | FieldValue<TFieldValues>
   | UnpackNestedValue<DeepPartial<TFieldValues>>
-  | string[]
+  | unknown[]
   | undefined
   | null
   | boolean;
diff --git a/src/useFieldArray.test.tsx b/src/useFieldArray.test.tsx
index 9c59a0ff..8512c45b 100644
--- a/src/useFieldArray.test.tsx
+++ b/src/useFieldArray.test.tsx
@@ -10,6 +10,9 @@ import { act, renderHook } from '@testing-library/react-hooks';
 import { useFieldArray } from './useFieldArray';
 import { useForm } from './useForm';
 import * as generateId from './logic/generateId';
+import { Controller } from './controller';
+import { VALIDATION_MODE } from './constants';
+import { FormProvider } from './useFormContext';
 import {
   Control,
   ValidationRules,
@@ -19,8 +22,6 @@ import {
   UseFormMethods,
   FieldValues,
 } from './types';
-import { VALIDATION_MODE } from './constants';
-import { FormProvider } from './useFormContext';
 
 let nodeEnv: string | undefined;
 
@@ -2509,6 +2510,64 @@ describe('useFieldArray', () => {
       expect(result.current.formState.dirtyFields).toEqual({});
     });
 
+    it("should not reset Controller's value during remove when Field Array name is already registered", () => {
+      function Component() {
+        const { control, handleSubmit } = useForm({
+          defaultValues: {
+            test: [{ firstName: 'Bill', lastName: '' }],
+          },
+        });
+        const { fields, append, remove } = useFieldArray({
+          control,
+          name: 'test',
+        });
+
+        return (
+          <form onSubmit={handleSubmit(() => {})}>
+            <ul>
+              {fields.map((item, index) => {
+                return (
+                  <li key={item.id}>
+                    <Controller
+                      name={`test[${index}].lastName`}
+                      control={control}
+                      defaultValue={item.lastName} // make sure to set up defaultValue
+                      render={(props: any) => <input {...props} />}
+                    />
+                    <button type="button" onClick={() => remove(index)}>
+                      Delete
+                    </button>
+                  </li>
+                );
+              })}
+            </ul>
+            <button
+              type="button"
+              onClick={() => {
+                append({ firstName: 'appendBill', lastName: 'appendLuo' });
+              }}
+            >
+              append
+            </button>
+          </form>
+        );
+      }
+
+      render(<Component />);
+
+      fireEvent.input(screen.getAllByRole('textbox')[0], {
+        target: { name: 'test[0].lastName', value: '111' },
+      });
+
+      fireEvent.click(screen.getByRole('button', { name: 'append' }));
+
+      fireEvent.click(screen.getAllByRole('button', { name: 'Delete' })[1]);
+
+      expect(
+        (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
+      ).toEqual('111');
+    });
+
     describe('with resolver', () => {
       it('should invoke resolver when formState.isValid true', async () => {
         const resolver = jest.fn().mockReturnValue({});
@@ -3719,6 +3778,39 @@ describe('useFieldArray', () => {
       ]);
     });
 
+    it('should populate all fields with default values', () => {
+      let getValues: any;
+      const Component = () => {
+        const { register, control, getValues: tempGetValues } = useForm({
+          defaultValues: {
+            test: [{ value: '1' }, { value: '2' }],
+          },
+        });
+        const { fields } = useFieldArray({
+          control,
+          name: 'test',
+        });
+        getValues = tempGetValues;
+
+        return (
+          <form>
+            {fields.map((field, i) => (
+              <input
+                key={field.id}
+                name={`test[${i}].value`}
+                ref={register()}
+                defaultValue={field.value}
+              />
+            ))}
+          </form>
+        );
+      };
+
+      render(<Component />);
+
+      expect(getValues()).toEqual({ test: [{ value: '1' }, { value: '2' }] });
+    });
+
     it('should return watched value with watch API', async () => {
       const renderedItems: any = [];
       const Component = () => {
diff --git a/src/useFieldArray.ts b/src/useFieldArray.ts
index c0ed3dd2..2f49e9dc 100644
--- a/src/useFieldArray.ts
+++ b/src/useFieldArray.ts
@@ -15,6 +15,7 @@ import insertAt from './utils/insert';
 import fillEmptyArray from './utils/fillEmptyArray';
 import fillBooleanArray from './utils/fillBooleanArray';
 import compact from './utils/compact';
+import cloneObject from './utils/cloneObject';
 import {
   Field,
   FieldValues,
@@ -25,7 +26,6 @@ import {
   DeepPartial,
   UseFieldArrayMethods,
 } from './types';
-import cloneObject from './utils/cloneObject';
 
 const mapIds = <
   TFieldArrayValues extends FieldValues = FieldValues,
@@ -125,6 +125,8 @@ export const useFieldArray = <
     fields: T,
   ) => fields.map(({ [keyName]: omitted, ...rest } = {}) => rest);
 
+  fieldArrayNamesRef.current.add(name);
+
   const getFieldArrayValue = React.useCallback(
     () => get(fieldArrayValuesRef.current, name, []),
     [],
diff --git a/src/useForm.ts b/src/useForm.ts
index 335e5a12..7de01f1a 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -43,7 +43,6 @@ import {
   UnpackNestedValue,
   FieldName,
   InternalFieldName,
-  FieldValue,
   FieldErrors,
   Field,
   FieldRefs,
@@ -68,6 +67,10 @@ import {
   DefaultValues,
   FieldError,
   SetFieldValue,
+  FieldArrayDefaultValues,
+  ResetFieldArrayFunctionRef,
+  UseWatchRenderFunctions,
+  RecordInternalNameSet,
 } from './types';
 
 const isWindowUndefined = typeof window === UNDEFINED;
@@ -85,25 +88,19 @@ export function useForm<
   reValidateMode = VALIDATION_MODE.onChange,
   resolver,
   context,
-  defaultValues = {} as UnpackNestedValue<DeepPartial<TFieldValues>>,
+  defaultValues = {} as DefaultValues<TFieldValues>,
   shouldFocusError = true,
   shouldUnregister = true,
   criteriaMode,
 }: UseFormOptions<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {
   const fieldsRef = React.useRef<FieldRefs<TFieldValues>>({});
-  const fieldArrayDefaultValuesRef = React.useRef<
-    Record<InternalFieldName<FieldValues>, unknown[]>
-  >({});
-  const fieldArrayValuesRef = React.useRef<
-    Record<InternalFieldName<FieldValues>, unknown[]>
-  >({});
+  const fieldArrayDefaultValuesRef = React.useRef<FieldArrayDefaultValues>({});
+  const fieldArrayValuesRef = React.useRef<FieldArrayDefaultValues>({});
   const watchFieldsRef = React.useRef<InternalNameSet<TFieldValues>>(new Set());
-  const useWatchFieldsRef = React.useRef<
-    Record<string, InternalNameSet<TFieldValues>>
-  >({});
-  const useWatchRenderFunctionsRef = React.useRef<Record<string, () => void>>(
+  const useWatchFieldsRef = React.useRef<RecordInternalNameSet<TFieldValues>>(
     {},
   );
+  const useWatchRenderFunctionsRef = React.useRef<UseWatchRenderFunctions>({});
   const fieldsWithValidationRef = React.useRef<
     FieldNamesMarkedBoolean<TFieldValues>
   >({});
@@ -121,10 +118,7 @@ export function useForm<
   const handleChangeRef = React.useRef<HandleChange>();
   const shallowFieldsStateRef = React.useRef({});
   const resetFieldArrayFunctionRef = React.useRef<
-    Record<
-      InternalFieldName<FieldValues>,
-      (data?: UnpackNestedValue<DeepPartial<TFieldValues>>) => void
-    >
+    ResetFieldArrayFunctionRef<TFieldValues>
   >({});
   const contextRef = React.useRef(context);
   const resolverRef = React.useRef(resolver);
@@ -234,16 +228,7 @@ export function useForm<
   );
 
   const setFieldValue = React.useCallback(
-    (
-      name: string,
-      rawValue:
-        | FieldValue<TFieldValues>
-        | UnpackNestedValue<DeepPartial<TFieldValues>>
-        | string[]
-        | undefined
-        | null
-        | boolean,
-    ) => {
+    (name: FieldName<TFieldValues>, rawValue: SetFieldValue<TFieldValues>) => {
       const { ref, options } = fieldsRef.current[name] as Field;
       const value =
         isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)
@@ -306,11 +291,9 @@ export function useForm<
     (
       name: InternalFieldName<TFieldValues>,
       shouldRender = true,
-    ): Partial<{
-      dirtyFields: FieldNamesMarkedBoolean<TFieldValues>;
-      isDirty: boolean;
-      touched: FieldNamesMarkedBoolean<TFieldValues>;
-    }> => {
+    ): Partial<
+      Pick<FormState<TFieldValues>, 'dirtyFields' | 'isDirty' | 'touched'>
+    > => {
       if (
         readFormStateRef.current.isDirty ||
         readFormStateRef.current.dirtyFields
@@ -452,9 +435,9 @@ export function useForm<
   );
 
   const setInternalValues = React.useCallback(
-    <T extends FieldName<TFieldValues>, U extends object | unknown[]>(
-      name: T,
-      value: U,
+    (
+      name: FieldName<TFieldValues>,
+      value: SetFieldValue<TFieldValues>,
       { shouldDirty, shouldValidate }: SetValueConfig,
     ) => {
       const data = {};
@@ -487,9 +470,7 @@ export function useForm<
         setInternalValues(name, value, config);
 
         if (fieldArrayNamesRef.current.has(name)) {
-          fieldArrayDefaultValuesRef.current[
-            name
-          ] = value as TFieldValues[string];
+          fieldArrayDefaultValuesRef.current[name] = value;
           resetFieldArrayFunctionRef.current[name]({
             [name]: value,
           } as UnpackNestedValue<DeepPartial<TFieldValues>>);
@@ -524,7 +505,7 @@ export function useForm<
     [updateAndGetDirtyState, setFieldValue, setInternalValues],
   );
 
-  const isFieldWatched = <T extends FieldName<FieldValues>>(name: T) =>
+  const isFieldWatched = <T extends FieldName<TFieldValues>>(name: T) =>
     isWatchAllRef.current ||
     watchFieldsRef.current.has(name) ||
     watchFieldsRef.current.has((name.match(/\w+/) || [])[0]);
@@ -579,7 +560,9 @@ export function useForm<
             ...modeRef.current,
           });
           let state = updateAndGetDirtyState(name, false);
-          let shouldRender = !isEmptyObject(state) || isFieldWatched(name);
+          let shouldRender =
+            !isEmptyObject(state) ||
+            isFieldWatched(name as FieldName<TFieldValues>);
 
           if (
             isBlurEvent &&
@@ -818,9 +801,6 @@ export function useForm<
       const watchFields = watchId
         ? useWatchFieldsRef.current[watchId]
         : watchFieldsRef.current;
-      const combinedDefaultValues = isUndefined(defaultValue)
-        ? defaultValuesRef.current
-        : defaultValue;
       let fieldValues = getFieldsValues<TFieldValues>(
         fieldsRef,
         cloneObject(shallowFieldsStateRef.current, isWeb),
@@ -848,13 +828,17 @@ export function useForm<
           fieldValues,
           fieldNames,
           watchFields,
-          isUndefined(defaultValue)
-            ? get(combinedDefaultValues, fieldNames)
-            : (defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>),
+          isUndefined(get(defaultValuesRef.current, fieldNames))
+            ? defaultValue
+            : get(defaultValuesRef.current, fieldNames),
           true,
         );
       }
 
+      const combinedDefaultValues = isUndefined(defaultValue)
+        ? defaultValuesRef.current
+        : defaultValue;
+
       if (Array.isArray(fieldNames)) {
         return fieldNames.reduce(
           (previous, name) => ({
@@ -1009,7 +993,7 @@ export function useForm<
       isEmptyDefaultValue = isUndefined(defaultValue);
 
       if (!isEmptyDefaultValue && !isFieldArray) {
-        setFieldValue(name, defaultValue);
+        setFieldValue(name as FieldName<TFieldValues>, defaultValue);
       }
     }
 
@@ -1222,7 +1206,7 @@ export function useForm<
   };
 
   const reset = (
-    values?: UnpackNestedValue<DeepPartial<TFieldValues>>,
+    values?: DefaultValues<TFieldValues>,
     omitResetState: OmitResetState = {},
   ): void => {
     if (isWeb) {
diff --git a/src/utils/get.ts b/src/utils/get.ts
index 5148eef8..9f079edd 100644
--- a/src/utils/get.ts
+++ b/src/utils/get.ts
@@ -2,7 +2,7 @@ import isUndefined from './isUndefined';
 import isNullOrUndefined from './isNullOrUndefined';
 import compact from './compact';
 
-export default (obj: any, path: string, defaultValue?: unknown) => {
+export default (obj: any = {}, path: string, defaultValue?: unknown) => {
   const result = compact(path.split(/[,[\].]+?/)).reduce(
     (result, key) => (isNullOrUndefined(result) ? result : result[key]),
     obj,
diff --git a/src/utils/getPath.test.ts b/src/utils/getPath.test.ts
index f755bf59..2ea59b03 100644
--- a/src/utils/getPath.test.ts
+++ b/src/utils/getPath.test.ts
@@ -3,7 +3,7 @@ import { getPath } from './getPath';
 describe('getPath', () => {
   it('should generate the correct path', () => {
     expect(
-      getPath('test' as any, [
+      getPath<any>('test', [
         1,
         [1, 2],
         {
@@ -33,5 +33,37 @@ describe('getPath', () => {
       'test[2].isAwesome',
       'test[2].answer',
     ]);
+
+    expect(
+      getPath<any>('test', {
+        test: 1,
+        test1: [1, 2],
+        test2: {
+          data: 'test',
+          kidding: { test: 'data' },
+          foo: { bar: {} },
+          what: [{ bill: { haha: 'test' } }, [3, 4]],
+          one: 1,
+          empty: null,
+          absent: undefined,
+          isAwesome: true,
+          answer: Symbol(42),
+        },
+      }),
+    ).toEqual([
+      'test.test',
+      'test.test1[0]',
+      'test.test1[1]',
+      'test.test2.data',
+      'test.test2.kidding.test',
+      'test.test2.what[0].bill.haha',
+      'test.test2.what[1][0]',
+      'test.test2.what[1][1]',
+      'test.test2.one',
+      'test.test2.empty',
+      'test.test2.absent',
+      'test.test2.isAwesome',
+      'test.test2.answer',
+    ]);
   });
 });
diff --git a/src/utils/getPath.ts b/src/utils/getPath.ts
index 087bacfa..a702c902 100644
--- a/src/utils/getPath.ts
+++ b/src/utils/getPath.ts
@@ -1,16 +1,22 @@
 import isPrimitive from './isPrimitive';
 import isObject from './isObject';
+import { FieldName } from '../types';
 
-export const getPath = <T extends string, U extends object | unknown[]>(
-  path: T,
-  values: U,
-): string[] => {
-  const getInnerPath = <K>(key: K, value: U, isObject?: boolean) => {
-    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;
-    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);
-  };
+export const getPath = <TFieldValues>(
+  rootPath: FieldName<TFieldValues>,
+  values: any,
+  paths: FieldName<TFieldValues>[] = [],
+): FieldName<TFieldValues>[] => {
+  for (const property in values) {
+    const rootName = (rootPath +
+      (isObject(values)
+        ? `.${property}`
+        : `[${property}]`)) as FieldName<TFieldValues>;
 
-  return Object.entries(values)
-    .map(([key, value]) => getInnerPath(key, value, isObject(values)))
-    .flat(Infinity) as string[];
+    isPrimitive(values[property])
+      ? paths.push(rootName)
+      : getPath(rootName, values[property], paths);
+  }
+
+  return paths;
 };
