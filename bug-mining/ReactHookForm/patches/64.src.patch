diff --git a/src/utils/unset.test.ts b/src/utils/unset.test.ts
index cb158779..c9506f01 100644
--- a/src/utils/unset.test.ts
+++ b/src/utils/unset.test.ts
@@ -31,6 +31,45 @@ test('should unset the object', () => {
       },
     },
   });
+
+  const test1 = {
+    test: [{ min: 'required' }],
+  };
+
+  expect(unset(test1, ['test[0].min'])).toEqual({});
+
+  const test2 = {
+    test: {
+      min: 'test',
+    },
+  };
+
+  expect(unset(test2, ['test.min'])).toEqual({});
+
+  const test3 = {
+    test: {
+      bill: {
+        min: 'test',
+      },
+    },
+  };
+
+  expect(unset(test3, ['test.bill.min'])).toEqual({});
+
+  const test4 = {
+    test: {
+      bill: {
+        min: [{ test }],
+      },
+      test: 'ha',
+    },
+  };
+
+  expect(unset(test4, ['test.bill.min[0].test'])).toEqual({
+    test: {
+      test: 'ha',
+    },
+  });
 });
 
 test('should unset multiple path', () => {
@@ -66,7 +105,7 @@ test('should return empty object when inner object is empty object', () => {
     },
   };
 
-  expect(unset(test, ['data.firstName'])).toEqual({ data: {} });
+  expect(unset(test, ['data.firstName'])).toEqual({});
 });
 
 test('should clear empty array', () => {
diff --git a/src/utils/unset.ts b/src/utils/unset.ts
index 02f1dd83..f63cd94e 100644
--- a/src/utils/unset.ts
+++ b/src/utils/unset.ts
@@ -2,6 +2,8 @@ import isArray from './isArray';
 import isUndefined from './isUndefined';
 import isKey from './isKey';
 import stringToPath from './stringToPath';
+import isEmptyObject from './isEmptyObject';
+import isObject from './isObject';
 
 function castPath(value: string) {
   return isArray(value) ? value : stringToPath(value);
@@ -45,10 +47,42 @@ function parent(object: any, path: string | string[]) {
 
 function baseUnset(object: any, path: string) {
   const updatePath = isKey(path) ? [path] : castPath(path);
-  object = parent(object, updatePath);
-
+  const childObject = parent(object, updatePath);
   const key = updatePath[updatePath.length - 1];
-  return !(object != null) || delete object[key];
+  const result = !(childObject != null) || delete childObject[key];
+  let previousObjRef = undefined;
+
+  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {
+    let index = -1;
+    let objectRef = undefined;
+    const currentPaths = updatePath.slice(0, -(k + 1));
+    const currentPathsLength = currentPaths.length - 1;
+
+    if (k > 0) {
+      previousObjRef = object;
+    }
+
+    while (++index < currentPaths.length) {
+      const item = currentPaths[index];
+      objectRef = objectRef ? objectRef[item] : object[item];
+
+      if (currentPathsLength === index) {
+        if (isObject(objectRef) && isEmptyObject(objectRef)) {
+          previousObjRef ? delete previousObjRef[item] : delete object[item];
+        } else if (
+          isArray(objectRef) &&
+          !objectRef.filter(data => isObject(data) && !isEmptyObject(data))
+            .length
+        ) {
+          delete previousObjRef[item];
+        }
+      }
+
+      previousObjRef = objectRef;
+    }
+  }
+
+  return result;
 }
 
 export default function unset(object: any, paths: string[]) {
