diff --git a/src/logic/setFieldArrayDirtyFields.test.ts b/src/logic/setFieldArrayDirtyFields.test.ts
new file mode 100644
index 00000000..2b55d87a
--- /dev/null
+++ b/src/logic/setFieldArrayDirtyFields.test.ts
@@ -0,0 +1,117 @@
+import setFieldArrayDirtyFields from './setFieldArrayDirtyFields';
+
+describe('setFieldArrayDirtyFields', () => {
+  it('should set correctly dirtyFields', () => {
+    expect(
+      setFieldArrayDirtyFields(
+        [{ data: 'bill' }, { data: 'luo', data1: 'luo1' }],
+        [{ data: 'bill1' }, { data: 'luo2' }],
+        [],
+      ),
+    ).toEqual([
+      {
+        data: true,
+      },
+      {
+        data: true,
+        data1: true,
+      },
+    ]);
+  });
+
+  it('should unset dirty fields when value matches', () => {
+    expect(
+      setFieldArrayDirtyFields(
+        [{ data: 'bill' }, { data: 'luo2', data1: 'luo1' }],
+        [{ data: 'bill1' }, { data: 'luo2' }],
+        [],
+      ),
+    ).toEqual([
+      {
+        data: true,
+      },
+      {
+        data1: true,
+      },
+    ]);
+  });
+
+  it('should set correctly with nested dirtyFields', () => {
+    expect(
+      setFieldArrayDirtyFields(
+        [
+          { data: 'bill' },
+          {
+            data: 'luo',
+            data1: 'luo1',
+            nested: [{ data: 'luo', data1: 'luo1' }],
+            nested1: [{ data: 'luo', data1: 'luo1' }],
+          },
+        ],
+        [{ data: 'bill1' }, { data: 'luo2' }],
+        [],
+      ),
+    ).toEqual([
+      {
+        data: true,
+      },
+      {
+        data: true,
+        data1: true,
+        nested: [{ data: true, data1: true }],
+        nested1: [{ data: true, data1: true }],
+      },
+    ]);
+  });
+
+  it('should unset nested dirty fields when value matches', () => {
+    expect(
+      setFieldArrayDirtyFields(
+        [
+          { data: 'bill' },
+          {
+            data: 'luo',
+            data1: 'luo1',
+            nested: [{ data: 'luo', data1: 'luo1' }],
+            nested1: [{ data: 'luo', data1: 'luo1' }],
+          },
+        ],
+        [
+          { data: 'bill1' },
+          {
+            data: 'luo2',
+            data1: 'luo1',
+            nested: [{ data: 'luo', data1: 'luo1' }],
+          },
+        ],
+        [],
+      ),
+    ).toEqual([
+      {
+        data: true,
+      },
+      {
+        data: true,
+        nested1: [{ data: true, data1: true }],
+      },
+    ]);
+  });
+
+  it('should reset dirty fields', () => {
+    expect(
+      setFieldArrayDirtyFields(
+        [{ data: 'bill' }],
+        [{ data: 'bill' }],
+        [
+          {
+            data: true,
+          },
+        ],
+      ),
+    ).toEqual([
+      {
+        data: undefined,
+      },
+    ]);
+  });
+});
diff --git a/src/logic/setFieldArrayDirtyFields.ts b/src/logic/setFieldArrayDirtyFields.ts
new file mode 100644
index 00000000..600de6e0
--- /dev/null
+++ b/src/logic/setFieldArrayDirtyFields.ts
@@ -0,0 +1,45 @@
+import { get } from '../utils';
+import isArray from '../utils/isArray';
+import set from '../utils/set';
+
+export default function setFieldArrayDirtyFields<
+  T extends U,
+  U extends Record<string, unknown>[],
+  K extends Record<string, boolean | []>
+>(
+  values: T,
+  defaultValues: U,
+  dirtyFields: Record<string, boolean | []>[],
+  parentNode?: K,
+  parentName?: keyof K,
+) {
+  let index = -1;
+
+  while (++index < values.length) {
+    for (const key in values[index]) {
+      if (isArray(values[index][key])) {
+        !dirtyFields[index] && (dirtyFields[index] = {});
+        dirtyFields[index][key] = [];
+        setFieldArrayDirtyFields(
+          values[index][key],
+          get(defaultValues[index] || {}, key, []),
+          dirtyFields[index][key] as [],
+          dirtyFields[index],
+          key,
+        );
+      } else {
+        get(defaultValues[index] || {}, key) === values[index][key]
+          ? set(dirtyFields[index] || {}, key)
+          : (dirtyFields[index] = {
+              ...dirtyFields[index],
+              [key]: true,
+            });
+      }
+    }
+    !dirtyFields.length &&
+      parentNode &&
+      delete parentNode[parentName as keyof K];
+  }
+
+  return dirtyFields.length ? dirtyFields : undefined;
+}
diff --git a/src/useForm.ts b/src/useForm.ts
index 5f63b619..a832fe28 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -3,6 +3,7 @@ import attachEventListeners from './logic/attachEventListeners';
 import transformToNestObject from './logic/transformToNestObject';
 import focusOnErrorField from './logic/focusOnErrorField';
 import findRemovedFieldAndRemoveListener from './logic/findRemovedFieldAndRemoveListener';
+import setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';
 import getFieldsValues from './logic/getFieldsValues';
 import getFieldValue from './logic/getFieldValue';
 import shouldRenderBasedOnError from './logic/shouldRenderBasedOnError';
@@ -111,9 +112,9 @@ export function useForm<
   const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(
     defaultValues,
   );
-  const defaultValuesAtRenderRef = React.useRef(
-    {} as DefaultValuesAtRender<TFieldValues>,
-  );
+  const defaultValuesAtRenderRef = React.useRef<
+    Partial<DefaultValuesAtRender<TFieldValues>>
+  >({});
   const isUnMount = React.useRef(false);
   const isWatchAllRef = React.useRef(false);
   const handleChangeRef = React.useRef<HandleChange>();
@@ -295,7 +296,6 @@ export function useForm<
         defaultValuesAtRenderRef.current[name] !==
         getFieldValue(fieldsRef, name, shallowFieldsStateRef);
       const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);
-      const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);
       const previousIsDirty = formStateRef.current.isDirty;
 
       isFieldDirty
@@ -304,12 +304,10 @@ export function useForm<
 
       const state = {
         isDirty:
-          (isFieldArray &&
-            !deepEqual(
-              get(getValues(), getFieldArrayParentName(name)),
-              get(defaultValuesRef.current, getFieldArrayParentName(name)),
-            )) ||
-          !isEmptyObject(formStateRef.current.dirtyFields),
+          !deepEqual(
+            get(getValues(), getFieldArrayParentName(name)),
+            get(defaultValuesRef.current, getFieldArrayParentName(name)),
+          ) || !isEmptyObject(formStateRef.current.dirtyFields),
         dirtyFields: formStateRef.current.dirtyFields,
       };
 
@@ -470,15 +468,34 @@ export function useForm<
       } else if (!isPrimitive(value)) {
         setInternalValues(name, value, config);
 
-        if (
-          isNameInFieldArray(fieldArrayNamesRef.current, name) ||
-          fieldArrayNamesRef.current.has(name)
-        ) {
-          const fieldArrayParentName = getFieldArrayParentName(name) || name;
-          fieldArrayDefaultValuesRef.current[fieldArrayParentName] = value;
-          resetFieldArrayFunctionRef.current[fieldArrayParentName]({
+        if (fieldArrayNamesRef.current.has(name)) {
+          fieldArrayDefaultValuesRef.current[name] = value;
+          resetFieldArrayFunctionRef.current[name]({
             [name]: value,
           } as UnpackNestedValue<DeepPartial<TFieldValues>>);
+
+          if (
+            readFormStateRef.current.isDirty ||
+            readFormStateRef.current.dirtyFields
+          ) {
+            set(
+              formStateRef.current.dirtyFields,
+              name,
+              setFieldArrayDirtyFields(
+                value,
+                get(defaultValuesRef.current, name, []),
+                get(formStateRef.current.dirtyFields, name, []),
+              ),
+            );
+
+            updateFormState({
+              isDirty: !deepEqual(
+                { ...getValues(), [name]: value },
+                defaultValuesRef.current,
+              ),
+              dirtyFields: formStateRef.current.dirtyFields,
+            });
+          }
         }
       }
 
@@ -714,10 +731,7 @@ export function useForm<
     });
   }
 
-  function setError(
-    name: FieldName<TFieldValues>,
-    error: ErrorOption = {},
-  ): void {
+  function setError(name: FieldName<TFieldValues>, error: ErrorOption): void {
     const ref = (fieldsRef.current[name] || {})!.ref;
 
     set(formStateRef.current.errors, name, {
@@ -1203,10 +1217,7 @@ export function useForm<
 
     return () => {
       isUnMount.current = true;
-
-      if (observerRef.current) {
-        observerRef.current.disconnect();
-      }
+      observerRef.current && observerRef.current.disconnect();
 
       if (process.env.NODE_ENV !== 'production') {
         return;
diff --git a/src/utils/set.ts b/src/utils/set.ts
index 8d7870ed..e4f08271 100644
--- a/src/utils/set.ts
+++ b/src/utils/set.ts
@@ -4,7 +4,11 @@ import isKey from './isKey';
 import stringToPath from './stringToPath';
 import { FieldValues } from '../types';
 
-export default function set(object: FieldValues, path: string, value: unknown) {
+export default function set(
+  object: FieldValues,
+  path: string,
+  value?: unknown,
+) {
   let index = -1;
   const tempPath = isKey(path) ? [path] : stringToPath(path);
   const length = tempPath.length;
