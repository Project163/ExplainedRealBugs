diff --git a/src/__tests__/useForm/trigger.test.tsx b/src/__tests__/useForm/trigger.test.tsx
index b70bbeb3..c98ddf39 100644
--- a/src/__tests__/useForm/trigger.test.tsx
+++ b/src/__tests__/useForm/trigger.test.tsx
@@ -333,6 +333,89 @@ describe('trigger', () => {
         },
       });
     });
+
+    it('should update isValid with validation result at form level', async () => {
+      const App = () => {
+        const {
+          register,
+          formState: { isValid },
+          trigger,
+        } = useForm<{ test: string; test1: string }>({
+          defaultValues: {
+            test: '',
+          },
+          resolver: async (data) => {
+            if (data.test && data.test1) {
+              return {
+                errors: {},
+                values: {
+                  test: '1',
+                  test1: '2',
+                },
+              };
+            } else {
+              return {
+                errors: {
+                  test: {
+                    message: 'test',
+                    type: 'test',
+                  },
+                },
+                values: {},
+              };
+            }
+          },
+        });
+
+        return (
+          <div>
+            {isValid ? 'yes' : 'no'}
+            <input {...register('test')} />
+            <input {...register('test1')} />
+            <button
+              onClick={() => {
+                trigger('test');
+              }}
+            >
+              trigger1
+            </button>
+            <button
+              onClick={() => {
+                trigger('test1');
+              }}
+            >
+              trigger2
+            </button>
+          </div>
+        );
+      };
+
+      render(<App />);
+
+      fireEvent.change(screen.getAllByRole('textbox')[0], {
+        target: {
+          value: 'test',
+        },
+      });
+
+      fireEvent.click(screen.getByRole('button', { name: 'trigger1' }));
+
+      await waitFor(() => {
+        screen.getByText('no');
+      });
+
+      fireEvent.change(screen.getAllByRole('textbox')[1], {
+        target: {
+          value: 'test',
+        },
+      });
+
+      fireEvent.click(screen.getByRole('button', { name: 'trigger2' }));
+
+      await waitFor(() => {
+        screen.getByText('yes');
+      });
+    });
   });
 
   it('should return the status of the requested fields with array of fields for validation', async () => {
@@ -374,11 +457,38 @@ describe('trigger', () => {
   });
 
   it('should return true when field is found and validation pass', async () => {
-    const { result } = renderHook(() => useForm<{ test: string }>());
+    const App = () => {
+      const {
+        register,
+        trigger,
+        formState: { isValid },
+      } = useForm();
 
-    result.current.register('test');
+      React.useEffect(() => {
+        register('test');
+      }, [register]);
 
-    expect(await result.current.trigger('test')).toBeTruthy();
+      return (
+        <div>
+          <p>{isValid ? 'yes' : 'no'}</p>
+          <button
+            onClick={() => {
+              trigger('test');
+            }}
+          >
+            trigger
+          </button>
+        </div>
+      );
+    };
+
+    render(<App />);
+
+    fireEvent.click(screen.getByRole('button'));
+
+    await waitFor(() => {
+      screen.getByText('yes');
+    });
   });
 
   it('should remove all errors before set new errors when trigger entire form', async () => {
diff --git a/src/logic/createFormControl.ts b/src/logic/createFormControl.ts
index f0342b99..9c4b90f1 100644
--- a/src/logic/createFormControl.ts
+++ b/src/logic/createFormControl.ts
@@ -755,6 +755,7 @@ export function createFormControl<
   const trigger: UseFormTrigger<TFieldValues> = async (name, options = {}) => {
     const fieldNames = convertToArrayPayload(name) as InternalFieldName[];
     let isValid;
+    let validationResult;
 
     _subjects.state.next({
       isValidating: true,
@@ -764,26 +765,25 @@ export function createFormControl<
       const schemaResult = await executeResolverValidation(
         isUndefined(name) ? name : fieldNames,
       );
-      isValid = name
-        ? fieldNames.every((name) => !get(schemaResult, name))
-        : isEmptyObject(schemaResult);
-    } else {
-      if (name) {
-        isValid = (
-          await Promise.all(
-            fieldNames.map(async (fieldName) => {
-              const field = get(_fields, fieldName);
-              return await validateForm(
-                field && field._f ? { [fieldName]: field } : field,
-              );
-            }),
-          )
-        ).every(Boolean);
 
-        _updateValid();
-      } else {
-        isValid = await validateForm(_fields);
-      }
+      isValid = isEmptyObject(schemaResult);
+      validationResult = name
+        ? !fieldNames.some((name) => get(schemaResult, name))
+        : isValid;
+    } else if (name) {
+      validationResult = (
+        await Promise.all(
+          fieldNames.map(async (fieldName) => {
+            const field = get(_fields, fieldName);
+            return await validateForm(
+              field && field._f ? { [fieldName]: field } : field,
+            );
+          }),
+        )
+      ).every(Boolean);
+      _updateValid();
+    } else {
+      validationResult = isValid = await validateForm(_fields);
     }
 
     _subjects.state.next({
@@ -793,7 +793,7 @@ export function createFormControl<
       isValidating: false,
     });
 
-    if (options.shouldFocus && !isValid) {
+    if (options.shouldFocus && !validationResult) {
       focusFieldBy(
         _fields,
         (key) => get(_formState.errors, key),
@@ -801,7 +801,7 @@ export function createFormControl<
       );
     }
 
-    return isValid;
+    return validationResult;
   };
 
   const getValues: UseFormGetValues<TFieldValues> = (
