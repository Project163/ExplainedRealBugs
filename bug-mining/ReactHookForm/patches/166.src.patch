diff --git a/app/src/UseFieldArrayUnregister.tsx b/app/src/UseFieldArrayUnregister.tsx
new file mode 100644
index 00000000..0d0a2660
--- /dev/null
+++ b/app/src/UseFieldArrayUnregister.tsx
@@ -0,0 +1,163 @@
+import React from 'react';
+import {
+  useForm,
+  useWatch,
+  useFieldArray,
+  Controller,
+  Control,
+} from 'react-hook-form';
+
+let renderCount = 0;
+
+const ConditionField = ({
+  control,
+  index,
+}: {
+  control: Control;
+  index: number;
+}) => {
+  const output = useWatch<any>({
+    name: 'data',
+    control,
+    defaultValue: 'yay! I am watching you :)',
+  });
+
+  return output[index]?.name === 'bill' ? (
+    <input ref={control.register()} name={`data[${index}].conditional`} />
+  ) : null;
+};
+
+const UseFieldArrayUnregister: React.FC = () => {
+  const {
+    control,
+    handleSubmit,
+    register,
+    setValue,
+    getValues,
+    formState: { isDirty, touched, dirtyFields },
+    errors,
+  } = useForm<{
+    data: { name: string }[];
+  }>({
+    defaultValues: {
+      data: [{ name: 'test' }, { name: 'test1' }, { name: 'test2' }],
+    },
+    mode: 'onSubmit',
+    shouldUnregister: false,
+  });
+  const {
+    fields,
+    append,
+    prepend,
+    swap,
+    move,
+    insert,
+    remove,
+  } = useFieldArray<{ name: string }>({
+    control,
+    name: 'data',
+  });
+  const [data, setData] = React.useState([]);
+  const onSubmit = (data: any) => {
+    setData(data);
+  };
+  const updateFieldArray = () => {
+    setValue('data', [...getValues().data, { name: 'test' }]);
+  };
+
+  renderCount++;
+
+  return (
+    <form onSubmit={handleSubmit(onSubmit)}>
+      <ul>
+        {fields.map((data, index) => (
+          <li key={data.id}>
+            {index % 2 ? (
+              <input
+                id={`field${index}`}
+                name={`data[${index}].name`}
+                defaultValue={data.name}
+                data-order={index}
+                ref={register({ required: 'This is required' })}
+              />
+            ) : (
+              <Controller
+                render={(props) => <input id={`field${index}`} {...props} />}
+                control={control}
+                rules={{
+                  required: 'This is required',
+                }}
+                name={`data[${index}].name`}
+                defaultValue={data.name}
+                data-order={index}
+              />
+            )}
+            {errors.data?.[index]?.name && (
+              <p id={`error${index}`}>{errors.data[index]!.name!.message}</p>
+            )}
+
+            <ConditionField control={control} index={index} />
+
+            <button id={`delete${index}`} onClick={() => remove(index)}>
+              Delete
+            </button>
+          </li>
+        ))}
+      </ul>
+
+      <button
+        id="append"
+        type="button"
+        onClick={() => append({ name: renderCount.toString() })}
+      >
+        append
+      </button>
+
+      <button
+        id="prepend"
+        type="button"
+        onClick={() => prepend({ name: renderCount.toString() })}
+      >
+        prepend
+      </button>
+
+      <button id="swap" onClick={() => swap(1, 2)} type="button">
+        swap
+      </button>
+
+      <button id="move" onClick={() => move(4, 2)} type="button">
+        move
+      </button>
+
+      <button
+        id="insert"
+        type="button"
+        onClick={() => insert(1, { name: renderCount.toString() })}
+      >
+        insert
+      </button>
+
+      <button id="remove" type="button" onClick={() => remove(1)}>
+        remove
+      </button>
+
+      <button id="removeAll" type="button" onClick={() => remove()}>
+        remove all
+      </button>
+
+      <button id="submit">Submit</button>
+
+      <button type={'button'} onClick={updateFieldArray}>
+        SetValue
+      </button>
+
+      <div id="renderCount">{renderCount}</div>
+      <div id="result">{JSON.stringify(data)}</div>
+      <div id="dirty">{isDirty ? 'yes' : 'no'}</div>
+      <div id="dirtyFields">{JSON.stringify(dirtyFields)}</div>
+      <div id="touched">{JSON.stringify(touched.data)}</div>
+    </form>
+  );
+};
+
+export default UseFieldArrayUnregister;
diff --git a/app/src/app.tsx b/app/src/app.tsx
index 1bbda54f..4d988931 100644
--- a/app/src/app.tsx
+++ b/app/src/app.tsx
@@ -26,6 +26,7 @@ import CustomSchemaValidation from './customSchemaValidation';
 import WatchFieldArray from './watchUseFieldArray';
 import useWatch from './useWatch';
 import FormStateWithNestedFields from './formStateWithNestedFields';
+import UseFieldArrayUnregister from './UseFieldArrayUnregister';
 
 const App: React.FC = () => {
   return (
@@ -61,6 +62,11 @@ const App: React.FC = () => {
       />
       <Route path="/conditionalField" exact component={ConditionalField} />
       <Route path="/UseFieldArray/:mode" exact component={UseFieldArray} />
+      <Route
+        path="/UseFieldArrayUnregister"
+        exact
+        component={UseFieldArrayUnregister}
+      />
       <Route path="/reset" exact component={Reset} />
       <Route path="/setValue" exact component={SetValue} />
       <Route path="/setValueWithSchema" exact component={SetValueWithSchema} />
@@ -70,7 +76,11 @@ const App: React.FC = () => {
         component={SetValueCustomRegister}
       />
       <Route path="/formState/:mode" exact component={FormState} />
-      <Route path="/formStateWithNestedFields/:mode" exact component={FormStateWithNestedFields} />
+      <Route
+        path="/formStateWithNestedFields/:mode"
+        exact
+        component={FormStateWithNestedFields}
+      />
       <Route
         path="/formStateWithSchema/:mode"
         exact
diff --git a/cypress/integration/useFieldArrayUnregister.ts b/cypress/integration/useFieldArrayUnregister.ts
new file mode 100644
index 00000000..d63919f1
--- /dev/null
+++ b/cypress/integration/useFieldArrayUnregister.ts
@@ -0,0 +1,152 @@
+describe('useFieldArrayUnregister', () => {
+  it('should behaviour correctly', () => {
+    cy.visit('http://localhost:3000/UseFieldArrayUnregister');
+
+    cy.get('#field0').clear().type('bill');
+
+    cy.get('input[name="data[0].conditional"]').type('test');
+
+    cy.get('#dirtyFields').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal({
+        data: [{ name: true, conditional: true }],
+      }),
+    );
+
+    cy.get('input[name="data[0].conditional"]').blur();
+
+    cy.get('#touched').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal([
+        { name: true, conditional: true },
+      ]),
+    );
+
+    cy.get('#prepend').click();
+
+    cy.get('input[name="data[0].conditional"]').should('not.exist');
+    cy.get('input[name="data[1].conditional"]').should('has.value', 'test');
+
+    cy.get('#dirtyFields').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal({
+        data: [{ name: true }, { name: true, conditional: true }],
+      }),
+    );
+
+    cy.get('#touched').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal([
+        null,
+        { name: true, conditional: true },
+      ]),
+    );
+
+    cy.get('#swap').click();
+
+    cy.get('input[name="data[1].conditional"]').should('not.exist');
+    cy.get('input[name="data[2].conditional"]').should('has.value', 'test');
+
+    cy.get('#dirtyFields').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal({
+        data: [{ name: true }, null, { name: true, conditional: true }],
+      }),
+    );
+
+    cy.get('#touched').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal([
+        null,
+        null,
+        { name: true, conditional: true },
+      ]),
+    );
+
+    cy.get('#insert').click();
+
+    cy.get('input[name="data[3].conditional"]').should('has.value', 'test');
+
+    cy.get('#dirtyFields').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal({
+        data: [
+          { name: true },
+          { name: true },
+          null,
+          { name: true, conditional: true },
+        ],
+      }),
+    );
+
+    cy.get('#touched').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal([
+        null,
+        null,
+        null,
+        { name: true, conditional: true },
+      ]),
+    );
+
+    cy.get('#move').click();
+
+    cy.get('input[name="data[4].conditional"]').should('has.value', 'test');
+
+    cy.get('#dirtyFields').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal({
+        data: [
+          { name: true },
+          { name: true },
+          null,
+          null,
+          { name: true, conditional: true },
+        ],
+      }),
+    );
+
+    cy.get('#touched').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal([
+        null,
+        { name: true },
+        null,
+        null,
+        { name: true, conditional: true },
+      ]),
+    );
+
+    cy.get('#delete1').click();
+
+    cy.get('input[name="data[3].conditional"]').should('has.value', 'test');
+
+    cy.get('#submit').click();
+
+    cy.get('#result').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal({
+        data: [
+          { name: '5' },
+          { name: 'test2' },
+          { name: 'test1' },
+          { name: 'bill', conditional: 'test' },
+        ],
+      }),
+    );
+
+    cy.get('input[name="data[3].name"]').type('test');
+
+    cy.get('#submit').click();
+
+    cy.get('#result').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal({
+        data: [
+          { name: '5' },
+          { name: 'test2' },
+          { name: 'test1' },
+          { name: 'billtest', conditional: 'test' },
+        ],
+      }),
+    );
+
+    cy.get('#delete3').click();
+
+    cy.get('#submit').click();
+
+    cy.get('#result').should(($state) =>
+      expect(JSON.parse($state.text())).to.be.deep.equal({
+        data: [{ name: '5' }, { name: 'test2' }, { name: 'test1' }],
+      }),
+    );
+  });
+});
diff --git a/src/__snapshots__/useFieldArray.test.tsx.snap b/src/__snapshots__/useFieldArray.test.tsx.snap
new file mode 100644
index 00000000..9839f9df
--- /dev/null
+++ b/src/__snapshots__/useFieldArray.test.tsx.snap
@@ -0,0 +1,32 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`useFieldArray array of array fields should populate all array fields correctly with setValue 1`] = `
+<DocumentFragment>
+  <div>
+    <div>
+      <input
+        name="nest[0].value"
+        value="1"
+      />
+      <div>
+        <input
+          name="nest[0].nestedArray[0].value"
+          value="1"
+        />
+      </div>
+    </div>
+    <div>
+      <input
+        name="nest[1].value"
+        value="2"
+      />
+      <div>
+        <input
+          name="nest[1].nestedArray[0].value"
+          value="1"
+        />
+      </div>
+    </div>
+  </div>
+</DocumentFragment>
+`;
diff --git a/src/controller.test.tsx b/src/controller.test.tsx
index c0cf3342..1f8836d4 100644
--- a/src/controller.test.tsx
+++ b/src/controller.test.tsx
@@ -475,6 +475,7 @@ describe('Controller', () => {
         name: 'test',
         control,
       });
+
       return (
         <form>
           {fields.map((field, i) => (
diff --git a/src/types/form.ts b/src/types/form.ts
index 84fe0187..e7eb4c35 100644
--- a/src/types/form.ts
+++ b/src/types/form.ts
@@ -148,6 +148,7 @@ export type Control<TFieldValues extends FieldValues = FieldValues> = Pick<
   fieldArrayDefaultValuesRef: React.MutableRefObject<
     Record<FieldArrayName, any[]>
   >;
+  shouldUnregister: boolean;
   formStateRef: React.MutableRefObject<FormState<FieldValues>>;
   updateFormState: (args?: Partial<FormState<TFieldValues>>) => void;
   validateResolver: ((fieldsValues: any) => void) | undefined;
@@ -220,10 +221,7 @@ export type UseFormMethods<TFieldValues extends FieldValues = FieldValues> = {
     defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,
   ): UnpackNestedValue<DeepPartial<TFieldValues>>;
   setError(name: FieldName<TFieldValues>, error: ErrorOption): void;
-  clearErrors(
-    name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],
-    config?: ClearErrorsConfig,
-  ): void;
+  clearErrors(name?: FieldName<TFieldValues> | FieldName<TFieldValues>[]): void;
   setValue<
     TFieldName extends string,
     TFieldValue extends TFieldValues[TFieldName]
diff --git a/src/useFieldArray.test.tsx b/src/useFieldArray.test.tsx
index 5b6d6a5c..aec6ef5d 100644
--- a/src/useFieldArray.test.tsx
+++ b/src/useFieldArray.test.tsx
@@ -3695,5 +3695,82 @@ describe('useFieldArray', () => {
 
       expect(screen.getAllByRole('textbox')).toHaveLength(3);
     });
+
+    it('should populate all array fields correctly with setValue', async () => {
+      const ChildComponent = ({
+        index,
+        control,
+      }: {
+        control: Control;
+        index: number;
+      }) => {
+        const { fields } = useFieldArray({
+          name: `nest[${index}].nestedArray`,
+          control,
+        });
+
+        return (
+          <div>
+            {fields.map((item, i) => (
+              <input
+                key={item.id}
+                name={`nest[${index}].nestedArray[${i}].value`}
+                ref={control.register()}
+                defaultValue={item.value}
+              />
+            ))}
+          </div>
+        );
+      };
+
+      const Component = () => {
+        const { register, control, setValue } = useForm();
+        const { fields } = useFieldArray({
+          name: 'nest',
+          control,
+        });
+
+        React.useEffect(() => {
+          setValue('nest', [
+            {
+              value: 1,
+              nestedArray: [
+                {
+                  value: 1,
+                },
+              ],
+            },
+            {
+              value: 2,
+              nestedArray: [
+                {
+                  value: 1,
+                },
+              ],
+            },
+          ]);
+        }, [setValue]);
+
+        return (
+          <div>
+            {fields.map((item, i) => (
+              <div key={item.id}>
+                <input
+                  name={`nest[${i}].value`}
+                  ref={register()}
+                  defaultValue={item.value}
+                />
+
+                <ChildComponent control={control} index={i} />
+              </div>
+            ))}
+          </div>
+        );
+      };
+
+      const { asFragment } = render(<Component />);
+
+      expect(asFragment()).toMatchSnapshot();
+    });
   });
 });
diff --git a/src/useFieldArray.ts b/src/useFieldArray.ts
index 8ee8bb0b..46c92fb1 100644
--- a/src/useFieldArray.ts
+++ b/src/useFieldArray.ts
@@ -23,6 +23,8 @@ import {
   UseFieldArrayOptions,
   Control,
   ArrayField,
+  UnpackNestedValue,
+  DeepPartial,
 } from './types';
 
 const appendId = <TValue extends object, TKeyName extends string>(
@@ -75,6 +77,7 @@ export const useFieldArray = <
     formStateRef: {
       current: { dirtyFields, touched },
     },
+    shallowFieldsStateRef,
     updateFormState,
     readFormStateRef,
     watchFieldsRef,
@@ -86,9 +89,9 @@ export const useFieldArray = <
     getValues,
   } = control || methods.control;
 
-  const rootParentName = getFieldArrayParentName(name);
+  const fieldArrayParentName = getFieldArrayParentName(name);
   const getDefaultValues = () => [
-    ...(get(fieldArrayDefaultValuesRef.current, rootParentName)
+    ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)
       ? get(fieldArrayDefaultValuesRef.current, name, [])
       : get(defaultValuesRef.current, name, [])),
   ];
@@ -113,11 +116,11 @@ export const useFieldArray = <
   allFields.current = fields;
   fieldArrayNamesRef.current.add(name);
 
-  if (!get(fieldArrayDefaultValuesRef.current, rootParentName)) {
+  if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {
     set(
       fieldArrayDefaultValuesRef.current,
-      rootParentName,
-      get(defaultValuesRef.current, rootParentName),
+      fieldArrayParentName,
+      get(defaultValuesRef.current, fieldArrayParentName),
     );
   }
 
@@ -170,6 +173,16 @@ export const useFieldArray = <
     shouldSet = true,
     shouldUpdateValid = false,
   ) => {
+    if (get(shallowFieldsStateRef.current, name)) {
+      const output = method(
+        get(shallowFieldsStateRef.current, name),
+        args.argA,
+        args.argB,
+      );
+      shouldSet && set(shallowFieldsStateRef.current, name, output);
+      cleanup(shallowFieldsStateRef.current);
+    }
+
     if (get(fieldArrayDefaultValuesRef.current, name)) {
       const output = method(
         get(fieldArrayDefaultValuesRef.current, name),
@@ -369,10 +382,13 @@ export const useFieldArray = <
     renderWatchedInputs(name);
   };
 
-  const reset = () => {
+  const reset = <TFieldValues>(
+    data?: UnpackNestedValue<DeepPartial<TFieldValues>>,
+  ) => {
     resetFields();
-    unset(fieldArrayDefaultValuesRef.current, name);
-    memoizedDefaultValues.current = get(defaultValuesRef.current, name);
+    !data && unset(fieldArrayDefaultValuesRef.current, name);
+    unset(shallowFieldsStateRef.current, name);
+    memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);
     setFields(mapIds(memoizedDefaultValues.current, keyName));
   };
 
diff --git a/src/useForm.test.tsx b/src/useForm.test.tsx
index 93bee874..279916ff 100644
--- a/src/useForm.test.tsx
+++ b/src/useForm.test.tsx
@@ -2049,7 +2049,7 @@ describe('useForm', () => {
         }),
       );
       expect(result.current.errors.input?.nested).toBeDefined();
-      act(() => result.current.clearErrors('input.nested', { exact: false }));
+      act(() => result.current.clearErrors('input.nested'));
       expect(result.current.errors.input?.nested).toBeUndefined();
     });
 
@@ -2151,7 +2151,7 @@ describe('useForm', () => {
       expect(submit).not.toBeCalled();
 
       act(() => {
-        result.current.clearErrors('whatever', { exact: false });
+        result.current.clearErrors('whatever');
       });
 
       await act(async () => await result.current.handleSubmit(submit)());
diff --git a/src/useForm.ts b/src/useForm.ts
index e9bf4534..e6b2115c 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -68,7 +68,6 @@ import {
   LiteralToPrimitive,
   DeepPartial,
   NonUndefined,
-  ClearErrorsConfig,
 } from './types';
 
 const isWindowUndefined = typeof window === UNDEFINED;
@@ -116,9 +115,14 @@ export function useForm<
   const isUnMount = React.useRef(false);
   const isWatchAllRef = React.useRef(false);
   const handleChangeRef = React.useRef<HandleChange>();
-  const shallowFieldsStateRef = React.useRef({});
+  const shallowFieldsStateRef = React.useRef(
+    shouldUnregister ? {} : defaultValues,
+  );
   const resetFieldArrayFunctionRef = React.useRef<
-    Record<InternalFieldName<FieldValues>, () => void>
+    Record<
+      InternalFieldName<FieldValues>,
+      (data?: UnpackNestedValue<DeepPartial<TFieldValues>>) => void
+    >
   >({});
   const contextRef = React.useRef(context);
   const resolverRef = React.useRef(resolver);
@@ -461,6 +465,17 @@ export function useForm<
         config.shouldDirty && updateAndGetDirtyState(name);
       } else if (!isPrimitive(value)) {
         setInternalValues(name, value, config);
+
+        if (
+          isNameInFieldArray(fieldArrayNamesRef.current, name) ||
+          fieldArrayNamesRef.current.has(name)
+        ) {
+          const fieldArrayParentName = getFieldArrayParentName(name) || name;
+          fieldArrayDefaultValuesRef.current[fieldArrayParentName] = value;
+          resetFieldArrayFunctionRef.current[fieldArrayParentName]({
+            [name]: value,
+          } as UnpackNestedValue<DeepPartial<TFieldValues>>);
+        }
       }
 
       !shouldUnregister && set(shallowFieldsStateRef.current, name, value);
@@ -679,13 +694,12 @@ export function useForm<
 
   function clearErrors(
     name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],
-    config: ClearErrorsConfig = { exact: true },
   ): void {
     name &&
-      (isArray(name) ? name : [name]).forEach(
-        (inputName) =>
-          (fieldsRef.current[inputName] || !config.exact) &&
-          unset(formStateRef.current.errors, inputName),
+      (isArray(name) ? name : [name]).forEach((inputName) =>
+        fieldsRef.current[inputName]
+          ? delete formStateRef.current.errors[inputName]
+          : unset(formStateRef.current.errors, inputName),
       );
 
     updateFormState({
@@ -1218,6 +1232,7 @@ export function useForm<
     defaultValuesRef,
     shallowFieldsStateRef,
     updateFormState,
+    shouldUnregister,
     validateResolver: resolver ? validateResolver : undefined,
     ...commonProps,
   };
diff --git a/src/utils/deepMerge.test.ts b/src/utils/deepMerge.test.ts
index fe5171ce..5e8c236b 100644
--- a/src/utils/deepMerge.test.ts
+++ b/src/utils/deepMerge.test.ts
@@ -47,6 +47,29 @@ describe('deepMerge', () => {
     });
   });
 
+  it('should deep merge array values  ', () => {
+    expect(deepMerge([{ hey: 'test' }], [{ id: 'id', text: '' }])).toEqual([
+      { hey: 'test', id: 'id', text: '' },
+    ]);
+
+    expect(deepMerge([{ id: 'id', text: '' }], [{ hey: 'test' }])).toEqual([
+      { hey: 'test', id: 'id', text: '' },
+    ]);
+
+    expect(
+      deepMerge(
+        {
+          test: [{ id: 'id', text: '' }],
+        },
+        {
+          test: [{ hey: 'test' }],
+        },
+      ),
+    ).toEqual({
+      test: [{ hey: 'test', id: 'id', text: '' }],
+    });
+  });
+
   it("should never merge non-objects, and always return the 'source' object", () => {
     expect(deepMerge({}, 0)).toEqual(0);
     expect(deepMerge(0, {})).toEqual({});
diff --git a/src/utils/deepMerge.ts b/src/utils/deepMerge.ts
index 9c45027b..7167cfd2 100644
--- a/src/utils/deepMerge.ts
+++ b/src/utils/deepMerge.ts
@@ -1,10 +1,12 @@
 import isObject from './isObject';
+import isArray from './isArray';
+import isPrimitive from './isPrimitive';
 
 export function deepMerge<
   T extends Record<keyof T, any>,
   U extends Record<keyof U, any>
 >(target: T, source: U): T & U {
-  if (!isObject(target) || !isObject(source)) {
+  if (isPrimitive(target) || isPrimitive(source)) {
     return source;
   }
 
@@ -13,7 +15,10 @@ export function deepMerge<
     const sourceValue = source[key];
 
     try {
-      if (isObject(targetValue) && isObject(sourceValue)) {
+      if (
+        (isObject(targetValue) && isObject(sourceValue)) ||
+        (isArray(targetValue) && isArray(sourceValue))
+      ) {
         target[key] = deepMerge(targetValue, sourceValue);
       } else {
         target[key] = sourceValue;
