diff --git a/src/__tests__/useForm/__snapshots__/watch.test.tsx.snap b/src/__tests__/useForm/__snapshots__/watch.test.tsx.snap
index f7ef5283..04e55b0f 100644
--- a/src/__tests__/useForm/__snapshots__/watch.test.tsx.snap
+++ b/src/__tests__/useForm/__snapshots__/watch.test.tsx.snap
@@ -1,5 +1,18 @@
 // Jest Snapshot v1, https://goo.gl/fbAQLP
 
+exports[`watch should remove input value after input is unmounted with shouldUnregister: true 1`] = `
+Array [
+  Object {},
+  Object {
+    "test": "1",
+  },
+  Object {
+    "test": "1",
+  },
+  Object {},
+]
+`;
+
 exports[`watch should watch correctly with useFieldArray with action and then fallback to onChange 1`] = `
 Array [
   Object {
diff --git a/src/__tests__/useForm/watch.test.tsx b/src/__tests__/useForm/watch.test.tsx
index a407c0dc..dffa22b0 100644
--- a/src/__tests__/useForm/watch.test.tsx
+++ b/src/__tests__/useForm/watch.test.tsx
@@ -124,12 +124,39 @@ describe('watch', () => {
     });
   });
 
-  it('should return default value if value is empty', () => {
-    renderHook(() => {
+  it('should return default value for single input', () => {
+    const results: unknown[] = [];
+    const App = () => {
       const { watch } = useForm<{ test: string }>();
 
-      expect(watch('test', 'default')).toBe('default');
-    });
+      results.push(watch('test', 'default'));
+
+      return null;
+    };
+
+    render(<App />);
+
+    expect(results).toEqual(['default']);
+  });
+
+  it('should return array of default value for array of inputs', () => {
+    const results: unknown[] = [];
+    const App = () => {
+      const { watch } = useForm<{ test: string; test1: string }>();
+
+      results.push(
+        watch(['test', 'test1'], {
+          test: 'default',
+          test1: 'test',
+        }),
+      );
+
+      return null;
+    };
+
+    render(<App />);
+
+    expect(results).toEqual([['default', 'test']]);
   });
 
   it('should watch array of inputs', () => {
@@ -391,4 +418,41 @@ describe('watch', () => {
       },
     });
   });
+
+  it('should remove input value after input is unmounted with shouldUnregister: true', () => {
+    const watched: unknown[] = [];
+    const App = () => {
+      const [show, setShow] = React.useState(true);
+      const { watch, register } = useForm({
+        shouldUnregister: true,
+      });
+
+      watched.push(watch());
+
+      return (
+        <div>
+          {show && <input {...register('test')} />}
+          <button
+            onClick={() => {
+              setShow(false);
+            }}
+          >
+            toggle
+          </button>
+        </div>
+      );
+    };
+
+    render(<App />);
+
+    fireEvent.change(screen.getByRole('textbox'), {
+      target: {
+        value: '1',
+      },
+    });
+
+    fireEvent.click(screen.getByRole('button'));
+
+    expect(watched).toMatchSnapshot();
+  });
 });
diff --git a/src/logic/createFormControl.ts b/src/logic/createFormControl.ts
index 7e2bea11..37f58146 100644
--- a/src/logic/createFormControl.ts
+++ b/src/logic/createFormControl.ts
@@ -607,14 +607,11 @@ export function createFormControl<
   ) => {
     const fieldValues = {
       ...(_isMounted
-        ? {
-            ...{
-              ..._defaultValues,
-              ..._formValues,
-            },
-          }
+        ? _formValues
         : isUndefined(defaultValue)
         ? _defaultValues
+        : isString(fieldNames)
+        ? { [fieldNames]: defaultValue }
         : defaultValue),
     };
 
@@ -1086,7 +1083,9 @@ export function createFormControl<
 
   const reset: UseFormReset<TFieldValues> = (values, keepStateOptions = {}) => {
     const updatedValues = values || _defaultValues;
-    const formValues = cloneObject({ ...updatedValues });
+    const formValues = cloneObject(updatedValues);
+
+    _formValues = formValues;
 
     if (isWeb && !keepStateOptions.keepValues) {
       for (const name of _names.mount) {
@@ -1106,12 +1105,10 @@ export function createFormControl<
 
     if (!keepStateOptions.keepDefaultValues) {
       _defaultValues = { ...updatedValues };
-      _formValues = formValues;
     }
 
     if (!keepStateOptions.keepValues) {
       _fields = {};
-      _formValues = {};
 
       _subjects.control.next({
         values: keepStateOptions.keepDefaultValues
diff --git a/src/useFieldArray.ts b/src/useFieldArray.ts
index 3b79735d..93895417 100644
--- a/src/useFieldArray.ts
+++ b/src/useFieldArray.ts
@@ -252,13 +252,6 @@ export const useFieldArray = <
     const fieldArraySubscription = control._subjects.array.subscribe({
       next(payload) {
         if (payload.isReset) {
-          unset(control._fields, payload.name || name);
-          unset(control._formValues, payload.name || name);
-
-          payload.name
-            ? set(control._formValues, payload.name, payload.values)
-            : payload.values && (control._formValues = payload.values);
-
           setFields(mapIds(get(control._formValues, name), keyName));
         }
       },
