diff --git a/CHANGELOG.md b/CHANGELOG.md
index 784a52d3..e0ff95b2 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,9 @@
 # Changelog
 
+## [7.18.1] - 2021-11-02
+
+- revert `FieldPathWithValue`
+
 ## [7.18.0] - 2021-10-28
 
 ## Added
diff --git a/src/__tests__/type.test.tsx b/src/__tests__/type.test.tsx
index 9fb19551..b5494e89 100644
--- a/src/__tests__/type.test.tsx
+++ b/src/__tests__/type.test.tsx
@@ -1,5 +1,6 @@
 import * as React from 'react';
 
+import { Controller } from '../controller';
 import { Path, UseFormReturn } from '../types';
 import { useFieldArray } from '../useFieldArray';
 import { useForm } from '../useForm';
@@ -83,3 +84,37 @@ test('should not throw type error with optional array fields', () => {
 
   App;
 });
+
+test('should work with optional field with Controller', () => {
+  type FormValues = {
+    firstName: string;
+    lastName?: string;
+  };
+
+  function App() {
+    const { control } = useForm<FormValues>();
+
+    return (
+      <div>
+        <Controller
+          name="firstName"
+          defaultValue=""
+          control={control}
+          render={({ field: { value, onChange } }) => {
+            return <input value={value} onChange={onChange} />;
+          }}
+        />
+        <Controller
+          name="lastName"
+          defaultValue=""
+          control={control}
+          render={({ field: { value, onChange } }) => {
+            return <input value={value} onChange={onChange} />;
+          }}
+        />
+      </div>
+    );
+  }
+
+  App;
+});
diff --git a/src/__tests__/useController.test.tsx b/src/__tests__/useController.test.tsx
index 88465a47..e6bdec86 100644
--- a/src/__tests__/useController.test.tsx
+++ b/src/__tests__/useController.test.tsx
@@ -8,12 +8,7 @@ import {
 } from '@testing-library/react';
 
 import { Controller } from '../controller';
-import {
-  Control,
-  FieldPathWithValue,
-  FieldValues,
-  NestedValue,
-} from '../types';
+import { Control } from '../types';
 import { useController } from '../useController';
 import { useForm } from '../useForm';
 import { FormProvider, useFormContext } from '../useFormContext';
@@ -514,12 +509,6 @@ describe('useController', () => {
   });
 
   it('should return defaultValues when component is not yet mounted', async () => {
-    type FormValues = {
-      test: {
-        deep: { test: string; test1: string }[];
-      };
-    };
-
     const defaultValues = {
       test: {
         deep: [
@@ -532,11 +521,15 @@ describe('useController', () => {
     };
 
     const App = () => {
-      const { control, getValues } = useForm<FormValues>({
+      const { control, getValues } = useForm<{
+        test: {
+          deep: { test: string; test1: string }[];
+        };
+      }>({
         defaultValues,
       });
 
-      const { field } = useController<FormValues, string>({
+      const { field } = useController({
         control,
         name: 'test.deep.0.test',
       });
@@ -597,120 +590,4 @@ describe('useController', () => {
       screen.getByText('expected value');
     });
   });
-
-  describe('When expected type is provided', () => {
-    it('should render generic component correctly', () => {
-      type ExpectedType = { test: string };
-
-      const Generic = <FormValues extends FieldValues>({
-        name,
-        control,
-      }: {
-        name: FieldPathWithValue<FormValues, ExpectedType>;
-        control: Control<FormValues>;
-      }) => {
-        const {
-          field: { value, ...fieldProps },
-          fieldState: { error },
-        } = useController<FormValues, ExpectedType>({
-          name,
-          control,
-          defaultValue: { test: 'value' },
-        });
-
-        if (error?.message) {
-          return null;
-        }
-
-        return <input type="text" value={value.test} {...fieldProps} />;
-      };
-
-      const GenericController = <FormValues extends FieldValues>({
-        name,
-        control,
-      }: {
-        name: FieldPathWithValue<FormValues, ExpectedType>;
-        control: Control<FormValues>;
-      }) => {
-        return (
-          <Controller
-            render={({ field }) => <input {...field} />}
-            control={control}
-            name={name}
-          />
-        );
-      };
-
-      const Component = () => {
-        const { control } = useForm<{
-          test: string;
-          key: ExpectedType[];
-          key1: ExpectedType[];
-        }>({
-          defaultValues: {
-            test: 'test',
-            key: [{ test: 'input value' }],
-            key1: [{ test: 'input value' }],
-          },
-        });
-
-        return (
-          <div>
-            <Generic name="key.0" control={control} />
-            <GenericController name="key.1" control={control} />
-          </div>
-        );
-      };
-
-      render(<Component />);
-    });
-
-    it('should be able to access values and error in generic components using NestedValue', () => {
-      type ExpectedType = NestedValue<{ test: string }>;
-
-      const Generic = <FormValues extends FieldValues>({
-        name,
-        control,
-      }: {
-        name: FieldPathWithValue<FormValues, ExpectedType>;
-        control: Control<FormValues>;
-      }) => {
-        const {
-          field: { value, ...fieldProps },
-          fieldState: { error },
-        } = useController<FormValues, ExpectedType>({
-          name,
-          control,
-          defaultValue: { test: 'value' },
-        });
-
-        if (error?.message) {
-          return <>There was an error</>;
-        }
-
-        return <input type="text" value={value.test} {...fieldProps} />;
-      };
-
-      const Component = () => {
-        const { control } = useForm<{
-          test: string;
-          key: ExpectedType[];
-        }>({
-          defaultValues: {
-            test: 'test',
-            key: [{ test: 'input value' }],
-          },
-        });
-
-        return <Generic name="key.0" control={control} />;
-      };
-
-      render(<Component />);
-
-      const input = screen.queryByRole('textbox') as HTMLInputElement | null;
-
-      expect(input).toBeInTheDocument();
-      expect(input?.value).toEqual('input value');
-    });
-  });
 });
diff --git a/src/controller.tsx b/src/controller.tsx
index 0635974d..4074d586 100644
--- a/src/controller.tsx
+++ b/src/controller.tsx
@@ -1,15 +1,11 @@
-import { ControllerProps, FieldPathWithValue, FieldValues } from './types';
+import { ControllerProps, FieldPath, FieldValues } from './types';
 import { useController } from './useController';
 
 const Controller = <
   TFieldValues extends FieldValues = FieldValues,
-  TResult = any,
-  TName extends FieldPathWithValue<TFieldValues, TResult> = FieldPathWithValue<
-    TFieldValues,
-    TResult
-  >,
+  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
 >(
-  props: ControllerProps<TFieldValues, TResult, TName>,
-) => props.render(useController<TFieldValues, TResult, TName>(props));
+  props: ControllerProps<TFieldValues, TName>,
+) => props.render(useController<TFieldValues, TName>(props));
 
 export { Controller };
diff --git a/src/types/controller.ts b/src/types/controller.ts
index a00ed2fc..c4ee5c15 100644
--- a/src/types/controller.ts
+++ b/src/types/controller.ts
@@ -4,10 +4,9 @@ import { RegisterOptions } from './validator';
 import {
   Control,
   FieldError,
+  FieldPath,
   FieldPathValue,
-  FieldPathWithValue,
   FieldValues,
-  IsAny,
   Noop,
   RefCallBack,
   UnpackNestedValue,
@@ -23,28 +22,18 @@ export type ControllerFieldState = {
 
 export type ControllerRenderProps<
   TFieldValues extends FieldValues = FieldValues,
-  TResult = any,
-  TName extends FieldPathWithValue<TFieldValues, TResult> = FieldPathWithValue<
-    TFieldValues,
-    TResult
-  >,
+  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
 > = {
   onChange: (...event: any[]) => void;
   onBlur: Noop;
-  value: IsAny<TResult> extends true
-    ? UnpackNestedValue<FieldPathValue<TFieldValues, TName>>
-    : UnpackNestedValue<TResult>;
+  value: UnpackNestedValue<FieldPathValue<TFieldValues, TName>>;
   name: TName;
   ref: RefCallBack;
 };
 
 export type UseControllerProps<
   TFieldValues extends FieldValues = FieldValues,
-  TResult = any,
-  TName extends FieldPathWithValue<TFieldValues, TResult> = FieldPathWithValue<
-    TFieldValues,
-    TResult
-  >,
+  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
 > = {
   name: TName;
   rules?: Omit<
@@ -52,40 +41,30 @@ export type UseControllerProps<
     'valueAsNumber' | 'valueAsDate' | 'setValueAs' | 'disabled'
   >;
   shouldUnregister?: boolean;
-  defaultValue?: IsAny<TResult> extends true
-    ? UnpackNestedValue<FieldPathValue<TFieldValues, TName>>
-    : UnpackNestedValue<TResult>;
+  defaultValue?: UnpackNestedValue<FieldPathValue<TFieldValues, TName>>;
   control?: Control<TFieldValues>;
 };
 
 export type UseControllerReturn<
   TFieldValues extends FieldValues = FieldValues,
-  TResult = any,
-  TName extends FieldPathWithValue<TFieldValues, TResult> = FieldPathWithValue<
-    TFieldValues,
-    TResult
-  >,
+  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
 > = {
-  field: ControllerRenderProps<TFieldValues, TResult, TName>;
+  field: ControllerRenderProps<TFieldValues, TName>;
   formState: UseFormStateReturn<TFieldValues>;
   fieldState: ControllerFieldState;
 };
 
 export type ControllerProps<
   TFieldValues extends FieldValues = FieldValues,
-  TResult = any,
-  TName extends FieldPathWithValue<TFieldValues, TResult> = FieldPathWithValue<
-    TFieldValues,
-    TResult
-  >,
+  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
 > = {
   render: ({
     field,
     fieldState,
     formState,
   }: {
-    field: ControllerRenderProps<TFieldValues, TResult, TName>;
+    field: ControllerRenderProps<TFieldValues, TName>;
     fieldState: ControllerFieldState;
     formState: UseFormStateReturn<TFieldValues>;
   }) => React.ReactElement;
-} & UseControllerProps<TFieldValues, TResult, TName>;
+} & UseControllerProps<TFieldValues, TName>;
diff --git a/src/types/utils.ts b/src/types/utils.ts
index 17c320e5..b47b1937 100644
--- a/src/types/utils.ts
+++ b/src/types/utils.ts
@@ -182,13 +182,3 @@ export type UnionLike<T> = [T] extends [Date | FileList | File | NestedValue]
       Exclude<UnionKeys<T>, keyof T> | OptionalKeys<T>
     >
   : T;
-
-export type FieldPathWithValue<
-  TFieldValues extends FieldValues,
-  TResult = unknown,
-  FieldPaths extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
-> = {
-  [key in FieldPaths]: FieldPathValue<TFieldValues, key> extends TResult
-    ? key
-    : never;
-}[FieldPaths];
diff --git a/src/useController.ts b/src/useController.ts
index 8d141144..593880a2 100644
--- a/src/useController.ts
+++ b/src/useController.ts
@@ -6,7 +6,7 @@ import get from './utils/get';
 import { EVENTS } from './constants';
 import {
   Field,
-  FieldPathWithValue,
+  FieldPath,
   FieldValues,
   InternalFieldName,
   UseControllerProps,
@@ -18,14 +18,10 @@ import { useSubscribe } from './useSubscribe';
 
 export function useController<
   TFieldValues extends FieldValues = FieldValues,
-  TResult = any,
-  TName extends FieldPathWithValue<TFieldValues, TResult> = FieldPathWithValue<
-    TFieldValues,
-    TResult
-  >,
+  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
 >(
-  props: UseControllerProps<TFieldValues, TResult, TName>,
-): UseControllerReturn<TFieldValues, TResult, TName> {
+  props: UseControllerProps<TFieldValues, TName>,
+): UseControllerReturn<TFieldValues, TName> {
   const methods = useFormContext<TFieldValues>();
   const { name, control = methods.control, shouldUnregister } = props;
   const [value, setInputStateValue] = React.useState(
