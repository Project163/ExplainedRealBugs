diff --git a/src/logic/assignWatchFields.test.ts b/src/logic/assignWatchFields.test.ts
index 234a399f..8499153e 100644
--- a/src/logic/assignWatchFields.test.ts
+++ b/src/logic/assignWatchFields.test.ts
@@ -32,35 +32,9 @@ describe('assignWatchFields', () => {
     ).toEqual(true);
   });
 
-  test('should return watchFieldArray when nothing is defined and watchFieldArray is exist', () => {
-    expect(
-      assignWatchFields<any>({}, 'test', new Set(), {}, [
-        { data: 'test' },
-      ] as any),
-    ).toEqual([{ data: 'test' }]);
-  });
-
-  test('should return watchFieldArray when value length is not matching watchFieldArray length', () => {
-    expect(
-      assignWatchFields<any>(
-        { 'test[0]': '', 'test[1]': '' },
-        'test',
-        new Set(),
-        {},
-        [{ data: 'test' }] as any,
-      ),
-    ).toEqual([{ data: 'test' }]);
-  });
-
   test('should return combinedDefaultValues when there is no value match', () => {
     expect(
-      assignWatchFields<any>(
-        {},
-        'test',
-        new Set(),
-        'test' as any,
-        undefined as any,
-      ),
+      assignWatchFields<any>({}, 'test', new Set(), 'test' as any),
     ).toEqual('test');
   });
 });
diff --git a/src/logic/assignWatchFields.ts b/src/logic/assignWatchFields.ts
index 18908aba..aa3f6de9 100644
--- a/src/logic/assignWatchFields.ts
+++ b/src/logic/assignWatchFields.ts
@@ -5,7 +5,6 @@ import getPath from '../utils/getPath';
 import isEmptyObject from '../utils/isEmptyObject';
 import isUndefined from '../utils/isUndefined';
 import isObject from '../utils/isObject';
-import isArray from '../utils/isArray';
 import { DeepPartial, FieldValue, FieldValues, FieldName } from '../types';
 
 export default <FormValues extends FieldValues>(
@@ -13,28 +12,19 @@ export default <FormValues extends FieldValues>(
   fieldName: FieldName<FormValues>,
   watchFields: Set<FieldName<FormValues>>,
   combinedDefaultValues: DeepPartial<FormValues>,
-  watchFieldArray?: Record<FieldName<FormValues>, Record<string, any>>,
 ): FieldValue<FormValues> | DeepPartial<FormValues> | undefined => {
   let value;
 
   watchFields.add(fieldName);
 
   if (isEmptyObject(fieldValues)) {
-    value = watchFieldArray ? watchFieldArray : undefined;
+    value = undefined;
   } else if (!isUndefined(fieldValues[fieldName])) {
     value = fieldValues[fieldName];
     watchFields.add(fieldName);
   } else {
     value = get(transformToNestObject(fieldValues), fieldName);
 
-    if (
-      isArray(watchFieldArray) &&
-      isArray(value) &&
-      value.length !== watchFieldArray.length
-    ) {
-      value = watchFieldArray;
-    }
-
     if (!isUndefined(value)) {
       getPath<FormValues>(fieldName, value).forEach(name =>
         watchFields.add(name),
diff --git a/src/types.ts b/src/types.ts
index 384f99a4..995d0298 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -282,7 +282,7 @@ export type Control<FormValues extends FieldValues = FieldValues> = {
   dirtyFieldsRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
   validateSchemaIsValid?: (fieldsValues: any) => void;
   touchedFieldsRef: React.MutableRefObject<Touched<FormValues>>;
-  watchFieldArrayRef: React.MutableRefObject<any>;
+  watchFieldsRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
   validFieldsRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
   fieldsWithValidationRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
   errorsRef: React.MutableRefObject<FieldErrors<FormValues>>;
diff --git a/src/useFieldArray.ts b/src/useFieldArray.ts
index 734ad43b..da5c1c75 100644
--- a/src/useFieldArray.ts
+++ b/src/useFieldArray.ts
@@ -46,7 +46,7 @@ export const useFieldArray = <
     isDirtyRef,
     touchedFieldsRef,
     readFormStateRef,
-    watchFieldArrayRef,
+    watchFieldsRef,
     validFieldsRef,
     fieldsWithValidationRef,
     validateSchemaIsValid,
@@ -56,15 +56,13 @@ export const useFieldArray = <
     Partial<ArrayField<FormArrayValues, KeyName>>[]
   >(mapIds(memoizedDefaultValues.current, keyName));
   const allFields = useRef(fields);
+
+  allFields.current = fields;
+
   const appendValueWithKey = (value: Partial<FormArrayValues>[]) =>
     value.map((v: Partial<FormArrayValues>) => appendId(v, keyName));
-  allFields.current = fields;
 
   const commonTasks = (fieldsValues: any) => {
-    watchFieldArrayRef.current = {
-      ...watchFieldArrayRef.current,
-      [name]: fieldsValues,
-    };
     setField(fieldsValues);
 
     if (readFormStateRef.current.isValid && validateSchemaIsValid) {
@@ -297,15 +295,20 @@ export const useFieldArray = <
     setField(mapIds(memoizedDefaultValues.current, keyName));
   };
 
+  useEffect(() => {
+    for (const watchField of watchFieldsRef.current) {
+      if (watchField.startsWith(name)) {
+        reRender();
+        break;
+      }
+    }
+  }, [fields, name, reRender, watchFieldsRef]);
+
   useEffect(() => {
     const resetFunctions = resetFieldArrayFunctionRef.current;
     const fieldArrayNames = fieldArrayNamesRef.current;
     fieldArrayNames.add(name);
     resetFunctions[name] = reset;
-    watchFieldArrayRef.current = {
-      ...watchFieldArrayRef.current,
-      [name]: fields,
-    };
 
     return () => {
       resetFields();
diff --git a/src/useForm.test.tsx b/src/useForm.test.tsx
index 52e1c857..3aad2290 100644
--- a/src/useForm.test.tsx
+++ b/src/useForm.test.tsx
@@ -22,8 +22,8 @@ export const reconfigureControl = (
   fieldsWithValidationRef: {
     current: new Set(),
   },
-  watchFieldArrayRef: {
-    current: {},
+  watchFieldsRef: {
+    current: new Set(),
   },
   dirtyFieldsRef: {
     current: new Set(),
diff --git a/src/useForm.ts b/src/useForm.ts
index 8e796eed..0074f3df 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -84,9 +84,6 @@ export function useForm<
   const validateAllFieldCriteria = validateCriteriaMode === 'all';
   const errorsRef = useRef<FieldErrors<FormValues>>({});
   const touchedFieldsRef = useRef<Touched<FormValues>>({});
-  const watchFieldArrayRef = useRef<
-    Record<FieldName<FormValues>, Record<string, any>>
-  >({} as Record<FieldName<FormValues>, Record<string, any>>);
   const watchFieldsRef = useRef(new Set<FieldName<FormValues>>());
   const dirtyFieldsRef = useRef(new Set<FieldName<FormValues>>());
   const fieldsWithValidationRef = useRef(new Set<FieldName<FormValues>>());
@@ -759,9 +756,6 @@ export function useForm<
         fieldNames,
         watchFields,
         combinedDefaultValues,
-        fieldArrayNamesRef.current.has(fieldNames)
-          ? watchFieldArrayRef.current[fieldNames]
-          : undefined,
       );
     }
 
@@ -1204,7 +1198,7 @@ export function useForm<
     validFieldsRef,
     dirtyFieldsRef,
     fieldsWithValidationRef,
-    watchFieldArrayRef,
+    watchFieldsRef,
     fieldArrayNamesRef,
     isDirtyRef,
     readFormStateRef,
@@ -1226,7 +1220,6 @@ export function useForm<
     register: useCallback(register, [
       defaultValuesRef.current,
       defaultRenderValuesRef.current,
-      watchFieldArrayRef.current,
     ]),
     unregister: useCallback(unregister, []),
     clearError: useCallback(clearError, []),
