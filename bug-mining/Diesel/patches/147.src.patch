diff --git a/CHANGELOG.md b/CHANGELOG.md
index 85fc32c3a..feb20949d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -22,6 +22,13 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 [`PgConnection::build_transaction`]: http://docs.diesel.rs/diesel/pg/struct.PgConnection.html#method.build_transaction
 
+* Added support for `BEGIN IMMEDIATE` and `BEGIN EXCLUSIVE` on SQLite.
+  See [`SqliteConnection::immediate_transaction`] and
+  [`SqliteConnection::exclusive_transaction`] for details
+
+[`SqliteConnection::immediate_transaction`]: http://docs.diesel.rs/diesel/sqlite/struct.SqliteConnection.html#method.immediate_transaction
+[`SqliteConnection::exclusive_transaction`]: http://docs.diesel.rs/diesel/sqlite/struct.SqliteConnection.html#method.exclusive_transaction
+
 ### Changed
 
 * The bounds on `impl ToSql for Cow<'a, T>` have been loosened to no longer
diff --git a/diesel/src/sqlite/connection/mod.rs b/diesel/src/sqlite/connection/mod.rs
index 9e87eb192..a8feded82 100644
--- a/diesel/src/sqlite/connection/mod.rs
+++ b/diesel/src/sqlite/connection/mod.rs
@@ -104,6 +104,86 @@ impl Connection for SqliteConnection {
 }
 
 impl SqliteConnection {
+    /// Run a transaction with `BEGIN IMMEDIATE`
+    ///
+    /// This method will return an error if a transaction is already open.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../../doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     let conn = SqliteConnection::establish(":memory:").unwrap();
+    /// conn.immediate_transaction(|| {
+    ///     // Do stuff in a transaction
+    ///     Ok(())
+    /// })
+    /// # }
+    /// ```
+    pub fn immediate_transaction<T, E, F>(&self, f: F) -> Result<T, E>
+    where
+        F: FnOnce() -> Result<T, E>,
+        E: From<Error>,
+    {
+        self.transaction_sql(f, "BEGIN IMMEDIATE")
+    }
+
+    /// Run a transaction with `BEGIN EXCLUSIVE`
+    ///
+    /// This method will return an error if a transaction is already open.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../../doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     let conn = SqliteConnection::establish(":memory:").unwrap();
+    /// conn.exclusive_transaction(|| {
+    ///     // Do stuff in a transaction
+    ///     Ok(())
+    /// })
+    /// # }
+    /// ```
+    pub fn exclusive_transaction<T, E, F>(&self, f: F) -> Result<T, E>
+    where
+        F: FnOnce() -> Result<T, E>,
+        E: From<Error>,
+    {
+        self.transaction_sql(f, "BEGIN EXCLUSIVE")
+    }
+
+    fn transaction_sql<T, E, F>(&self, f: F, sql: &str) -> Result<T, E>
+    where
+        F: FnOnce() -> Result<T, E>,
+        E: From<Error>,
+    {
+        let transaction_manager = self.transaction_manager();
+
+        transaction_manager.begin_transaction_sql(self, sql)?;
+        match f() {
+            Ok(value) => {
+                transaction_manager.commit_transaction(self)?;
+                Ok(value)
+            }
+            Err(e) => {
+                transaction_manager.rollback_transaction(self)?;
+                Err(e)
+            }
+        }
+    }
+
     fn prepare_query<T: QueryFragment<Sqlite> + QueryId>(
         &self,
         source: &T,
