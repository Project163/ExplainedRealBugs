diff --git a/diesel/src/insertable.rs b/diesel/src/insertable.rs
index f783b1214..df8ee8013 100644
--- a/diesel/src/insertable.rs
+++ b/diesel/src/insertable.rs
@@ -1,5 +1,6 @@
 use backend::{Backend, SupportsDefaultKeyword};
 use expression::{AppearsOnTable, Expression};
+use expression::operators::Eq;
 use result::QueryResult;
 use query_builder::{AstPass, QueryBuilder, QueryFragment};
 use query_source::{Column, Table};
@@ -23,6 +24,10 @@ pub trait Insertable<T: Table, DB: Backend> {
     fn values(self) -> Self::Values;
 }
 
+pub trait CanInsertInSingleQuery<DB: Backend> {
+    fn rows_to_insert(&self) -> usize;
+}
+
 pub trait InsertValues<T: Table, DB: Backend> {
     fn column_names(&self, out: &mut DB::QueryBuilder) -> QueryResult<()>;
     fn walk_ast(&self, out: AstPass<DB>) -> QueryResult<()>;
@@ -112,6 +117,15 @@ where
     }
 }
 
+impl<'a, T, DB> CanInsertInSingleQuery<DB> for &'a [T]
+where
+    DB: Backend + SupportsDefaultKeyword,
+{
+    fn rows_to_insert(&self) -> usize {
+        self.len()
+    }
+}
+
 impl<'a, T, Tab, DB> Insertable<Tab, DB> for &'a Vec<T>
 where
     Tab: Table,
@@ -125,6 +139,25 @@ where
     }
 }
 
+impl<'a, T, DB> CanInsertInSingleQuery<DB> for &'a Vec<T>
+where
+    DB: Backend,
+    &'a [T]: CanInsertInSingleQuery<DB>,
+{
+    fn rows_to_insert(&self) -> usize {
+        self.as_slice().rows_to_insert()
+    }
+}
+
+impl<'a, Lhs, Rhs, DB> CanInsertInSingleQuery<DB> for &'a Eq<Lhs, Rhs>
+where
+    DB: Backend,
+{
+    fn rows_to_insert(&self) -> usize {
+        1
+    }
+}
+
 #[derive(Debug, Clone)]
 pub struct BatchInsertValues<'a, T: 'a> {
     records: &'a [T],
diff --git a/diesel/src/macros/insertable.rs b/diesel/src/macros/insertable.rs
index 30d6769db..379088a33 100644
--- a/diesel/src/macros/insertable.rs
+++ b/diesel/src/macros/insertable.rs
@@ -158,7 +158,7 @@ macro_rules! impl_Insertable {
         lifetimes = ($($lifetime:tt),*),
         self_to_columns = $self_to_columns:pat,
         columns = ($($column_name:ident, $field_ty:ty, $field_kind:ident),+),
-    ) => { __diesel_parse_as_item! {
+    ) => {
         impl<$($lifetime,)* 'insert, DB> $crate::insertable::Insertable<$table_name::table, DB>
             for &'insert $struct_ty where
                 DB: $crate::backend::Backend,
@@ -193,26 +193,21 @@ macro_rules! impl_Insertable {
             }
         }
 
-    } __diesel_parse_as_item! {
-        impl<$($lifetime: 'insert,)* 'insert, Op> $crate::query_builder::insert_statement::IntoInsertStatement<$table_name::table, Op>
+        impl<$($lifetime,)* 'insert, DB> $crate::insertable::CanInsertInSingleQuery<DB>
             for &'insert $struct_ty
+        where
+            DB: $crate::backend::Backend,
         {
-            type InsertStatement = $crate::query_builder::insert_statement::InsertStatement<$table_name::table, Self, Op>;
-
-            fn into_insert_statement(self, target: $table_name::table, operator: Op) -> Self::InsertStatement {
-                $crate::query_builder::insert_statement::InsertStatement::no_returning_clause(
-                    target,
-                    self,
-                    operator,
-                )
+            fn rows_to_insert(&self) -> usize {
+                1
             }
         }
-    } __diesel_parse_as_item! {
+
         impl<$($lifetime: 'insert,)* 'insert> $crate::query_builder::insert_statement::UndecoratedInsertRecord<$table_name::table>
             for &'insert $struct_ty
         {
         }
-    }};
+    };
 }
 
 #[doc(hidden)]
diff --git a/diesel/src/pg/upsert/on_conflict_clause.rs b/diesel/src/pg/upsert/on_conflict_clause.rs
index 7df178faa..aa7b87049 100644
--- a/diesel/src/pg/upsert/on_conflict_clause.rs
+++ b/diesel/src/pg/upsert/on_conflict_clause.rs
@@ -34,23 +34,6 @@ impl<Records, Target, Action> OnConflict<Records, Target, Action> {
     }
 }
 
-impl<'a, T, Tab, Op> IntoInsertStatement<Tab, Op> for &'a OnConflictDoNothing<T> {
-    type InsertStatement = InsertStatement<Tab, Self, Op>;
-
-    fn into_insert_statement(self, target: Tab, operator: Op) -> Self::InsertStatement {
-        InsertStatement::no_returning_clause(target, self, operator)
-    }
-}
-
-impl<'a, Recods, Target, Action, Tab, Op> IntoInsertStatement<Tab, Op>
-    for &'a OnConflict<Recods, Target, Action> {
-    type InsertStatement = InsertStatement<Tab, Self, Op>;
-
-    fn into_insert_statement(self, target: Tab, operator: Op) -> Self::InsertStatement {
-        InsertStatement::no_returning_clause(target, self, operator)
-    }
-}
-
 impl<'a, T, Tab> Insertable<Tab, Pg> for &'a OnConflictDoNothing<T>
 where
     Tab: Table,
@@ -68,6 +51,15 @@ where
     }
 }
 
+impl<'a, T> CanInsertInSingleQuery<Pg> for &'a OnConflictDoNothing<T>
+where
+    T: CanInsertInSingleQuery<Pg>,
+{
+    fn rows_to_insert(&self) -> usize {
+        self.0.rows_to_insert()
+    }
+}
+
 impl<'a, Records, Target, Action, Tab> Insertable<Tab, Pg>
     for &'a OnConflict<Records, Target, Action>
 where
@@ -88,6 +80,16 @@ where
     }
 }
 
+impl<'a, Records, Target, Action> CanInsertInSingleQuery<Pg>
+    for &'a OnConflict<Records, Target, Action>
+where
+    Records: CanInsertInSingleQuery<Pg>,
+{
+    fn rows_to_insert(&self) -> usize {
+        self.records.rows_to_insert()
+    }
+}
+
 #[doc(hidden)]
 #[derive(Debug, Clone, Copy)]
 pub struct OnConflictValues<Values, Target, Action> {
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index ad8a973fe..3cb40ee1b 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -275,8 +275,9 @@ where
 /// query can return the inserted rows if you choose.
 #[cfg(feature = "with-deprecated")]
 #[deprecated(since = "0.99.0", note = "use `insert(&default_values())` instead")]
-pub fn insert_default_values() -> IncompleteInsertStatement<DefaultValues, Insert> {
-    IncompleteInsertStatement::new(DefaultValues, Insert)
+pub fn insert_default_values() -> IncompleteInsertStatement<&'static DefaultValues, Insert> {
+    static STATIC_DEFAULT_VALUES: &'static DefaultValues = &DefaultValues;
+    insert(STATIC_DEFAULT_VALUES)
 }
 
 pub fn default_values() -> DefaultValues {
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index 1ffb5137c..a1a1cb76b 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -1,8 +1,8 @@
-use backend::{Backend, SupportsDefaultKeyword};
+use backend::Backend;
 use connection::Connection;
 use expression::{Expression, NonAggregate, SelectableExpression};
 use expression::operators::Eq;
-use insertable::{InsertValues, Insertable};
+use insertable::{CanInsertInSingleQuery, InsertValues, Insertable};
 use query_builder::*;
 use query_dsl::{ExecuteDsl, LoadDsl, LoadQuery};
 use query_source::{Column, Table};
@@ -27,47 +27,16 @@ impl<T, Op> IncompleteInsertStatement<T, Op> {
     }
 
     /// Specify which table the data passed to `insert` should be added to.
-    pub fn into<S>(self, target: S) -> T::InsertStatement
-    where
-        T: IntoInsertStatement<S, Op>,
-    {
-        self.records.into_insert_statement(target, self.operator)
-    }
-}
-
-pub trait IntoInsertStatement<Tab, Op> {
-    type InsertStatement;
-
-    fn into_insert_statement(self, target: Tab, operator: Op) -> Self::InsertStatement;
-}
-
-impl<'a, T, Tab, Op> IntoInsertStatement<Tab, Op> for &'a [T]
-where
-    &'a T: UndecoratedInsertRecord<Tab>,
-{
-    type InsertStatement = BatchInsertStatement<Tab, Self, Op, NoReturningClause>;
-
-    fn into_insert_statement(self, target: Tab, operator: Op) -> Self::InsertStatement {
+    pub fn into<S>(self, target: S) -> BatchInsertStatement<S, T, Op> {
         BatchInsertStatement {
-            operator: operator,
+            operator: self.operator,
             target: target,
-            records: self,
+            records: self.records,
             returning: NoReturningClause,
         }
     }
 }
 
-impl<'a, T, Tab, Op> IntoInsertStatement<Tab, Op> for &'a Vec<T>
-where
-    &'a [T]: IntoInsertStatement<Tab, Op>,
-{
-    type InsertStatement = <&'a [T] as IntoInsertStatement<Tab, Op>>::InsertStatement;
-
-    fn into_insert_statement(self, target: Tab, operator: Op) -> Self::InsertStatement {
-        (&**self).into_insert_statement(target, operator)
-    }
-}
-
 #[derive(Debug, Copy, Clone)]
 pub struct InsertStatement<T, U, Op = Insert, Ret = NoReturningClause> {
     operator: Op,
@@ -76,12 +45,6 @@ pub struct InsertStatement<T, U, Op = Insert, Ret = NoReturningClause> {
     returning: Ret,
 }
 
-impl<T, U, Op> InsertStatement<T, U, Op> {
-    pub fn no_returning_clause(target: T, records: U, operator: Op) -> Self {
-        InsertStatement::new(target, records, operator, NoReturningClause)
-    }
-}
-
 impl<T, U, Op, Ret> InsertStatement<T, U, Op, Ret> {
     pub fn new(target: T, records: U, operator: Op, returning: Ret) -> Self {
         InsertStatement {
@@ -125,19 +88,6 @@ where
 
 impl_query_id!(noop: InsertStatement<T, U, Op, Ret>);
 
-impl<T, U, Op> AsQuery for InsertStatement<T, U, Op, NoReturningClause>
-where
-    T: Table,
-    InsertStatement<T, U, Op, ReturningClause<T::AllColumns>>: Query,
-{
-    type SqlType = <Self::Query as Query>::SqlType;
-    type Query = InsertStatement<T, U, Op, ReturningClause<T::AllColumns>>;
-
-    fn as_query(self) -> Self::Query {
-        self.returning(T::all_columns())
-    }
-}
-
 impl<T, U, Op, Ret> Query for InsertStatement<T, U, Op, ReturningClause<Ret>>
 where
     Ret: Expression + SelectableExpression<T> + NonAggregate,
@@ -145,55 +95,6 @@ where
     type SqlType = Ret::SqlType;
 }
 
-impl<T, U, Op> InsertStatement<T, U, Op, NoReturningClause> {
-    /// Specify what expression is returned after execution of the `insert`.
-    /// This method can only be called once.
-    ///
-    /// # Examples
-    ///
-    /// ### Inserting a record:
-    ///
-    /// ```rust
-    /// # #[macro_use] extern crate diesel;
-    /// # include!("../doctest_setup.rs");
-    /// #
-    /// # table! {
-    /// #     users {
-    /// #         id -> Integer,
-    /// #         name -> VarChar,
-    /// #     }
-    /// # }
-    /// #
-    /// # #[cfg(feature = "postgres")]
-    /// # fn main() {
-    /// #     use self::users::dsl::*;
-    /// #     let connection = establish_connection();
-    /// let new_user = NewUser {
-    ///     name: "Timmy".to_string(),
-    /// };
-    ///
-    /// let inserted_name = diesel::insert(&new_user)
-    ///     .into(users)
-    ///     .returning(name)
-    ///     .get_result(&connection);
-    /// assert_eq!(Ok("Timmy".to_string()), inserted_name);
-    /// # }
-    /// # #[cfg(not(feature = "postgres"))]
-    /// # fn main() {}
-    /// ```
-    pub fn returning<E>(self, returns: E) -> InsertStatement<T, U, Op, ReturningClause<E>>
-    where
-        InsertStatement<T, U, Op, ReturningClause<E>>: Query,
-    {
-        InsertStatement {
-            operator: self.operator,
-            target: self.target,
-            records: self.records,
-            returning: ReturningClause(returns),
-        }
-    }
-}
-
 #[derive(Debug, Clone, Copy)]
 /// The result of calling `insert(records).into(some_table)` when `records` is
 /// a slice or a `Vec`. When calling methods from `ExecuteDsl` or `LoadDsl`.
@@ -259,14 +160,15 @@ impl<T, U, Op> BatchInsertStatement<T, U, Op> {
     }
 }
 
-impl<'a, T, U, Op, Ret, Conn, DB> ExecuteDsl<Conn, DB> for BatchInsertStatement<T, &'a [U], Op, Ret>
+impl<T, U, Op, Ret, Conn, DB> ExecuteDsl<Conn, DB> for BatchInsertStatement<T, U, Op, Ret>
 where
     Conn: Connection<Backend = DB>,
-    DB: Backend + SupportsDefaultKeyword,
-    InsertStatement<T, &'a [U], Op, Ret>: ExecuteDsl<Conn>,
+    DB: Backend,
+    U: CanInsertInSingleQuery<DB>,
+    InsertStatement<T, U, Op, Ret>: ExecuteDsl<Conn>,
 {
     fn execute(self, conn: &Conn) -> QueryResult<usize> {
-        if self.records.is_empty() {
+        if self.records.rows_to_insert() == 0 {
             Ok(0)
         } else {
             self.into_insert_statement().execute(conn)
@@ -293,12 +195,31 @@ where
     }
 }
 
-impl<'a, T, U, V, Op, Ret, Conn> LoadQuery<Conn, V> for BatchInsertStatement<T, &'a [U], Op, Ret>
+#[cfg(feature = "sqlite")]
+impl<'a, T, U, Op, Ret> ExecuteDsl<::sqlite::SqliteConnection>
+    for BatchInsertStatement<T, &'a Vec<U>, Op, Ret>
+where
+    BatchInsertStatement<T, &'a [U], Op, Ret>: ExecuteDsl<::sqlite::SqliteConnection>,
+{
+    fn execute(self, conn: &::sqlite::SqliteConnection) -> QueryResult<usize> {
+        BatchInsertStatement {
+            records: &**self.records,
+            target: self.target,
+            operator: self.operator,
+            returning: self.returning,
+        }.execute(conn)
+    }
+}
+
+impl<T, U, V, Op, Ret, Conn> LoadQuery<Conn, V>
+    for BatchInsertStatement<T, U, Op, ReturningClause<Ret>>
 where
-    InsertStatement<T, &'a [U], Op, Ret>: LoadQuery<Conn, V>,
+    Conn: Connection,
+    U: CanInsertInSingleQuery<Conn::Backend>,
+    InsertStatement<T, U, Op, ReturningClause<Ret>>: LoadQuery<Conn, V>,
 {
     fn internal_load(self, conn: &Conn) -> QueryResult<Vec<V>> {
-        if self.records.is_empty() {
+        if self.records.rows_to_insert() == 0 {
             Ok(Vec::new())
         } else {
             self.into_insert_statement().internal_load(conn)
@@ -306,7 +227,18 @@ where
     }
 }
 
-impl<'a, T, U, Op, Ret, Conn> LoadDsl<Conn> for BatchInsertStatement<T, &'a [U], Op, Ret> {}
+impl<T, U, V, Op, Conn> LoadQuery<Conn, V> for BatchInsertStatement<T, U, Op>
+where
+    T: Table,
+    BatchInsertStatement<T, U, Op, ReturningClause<T::AllColumns>>: LoadQuery<Conn, V>,
+{
+    fn internal_load(self, conn: &Conn) -> QueryResult<Vec<V>> {
+        self.returning(T::all_columns()).internal_load(conn)
+    }
+}
+
+
+impl<T, U, Op, Ret, Conn> LoadDsl<Conn> for BatchInsertStatement<T, U, Op, Ret> {}
 
 #[derive(Debug, Copy, Clone)]
 pub struct Insert;
@@ -348,42 +280,21 @@ where
 #[doc(hidden)]
 pub struct DefaultValues;
 
-impl<Tab> IntoInsertStatement<Tab, Insert> for DefaultValues {
-    type InsertStatement = InsertStatement<Tab, Self, Insert>;
-
-    fn into_insert_statement(self, target: Tab, operator: Insert) -> Self::InsertStatement {
-        InsertStatement::no_returning_clause(target, self, operator)
-    }
-}
-
-impl<'a, Tab> IntoInsertStatement<Tab, Insert> for &'a DefaultValues {
-    type InsertStatement = <DefaultValues as IntoInsertStatement<Tab, Insert>>::InsertStatement;
-
-    fn into_insert_statement(self, target: Tab, operator: Insert) -> Self::InsertStatement {
-        (*self).into_insert_statement(target, operator)
-    }
-}
-
-impl<'a, Lhs, Rhs, Op> IntoInsertStatement<Lhs::Table, Op> for &'a Eq<Lhs, Rhs>
-where
-    Lhs: Column,
-{
-    type InsertStatement = InsertStatement<Lhs::Table, Self, Op>;
-
-    fn into_insert_statement(self, target: Lhs::Table, operator: Op) -> Self::InsertStatement {
-        InsertStatement::no_returning_clause(target, self, operator)
+impl<'a, DB: Backend> CanInsertInSingleQuery<DB> for &'a DefaultValues {
+    fn rows_to_insert(&self) -> usize {
+        1
     }
 }
 
-impl<Tab, DB> Insertable<Tab, DB> for DefaultValues
+impl<'a, Tab, DB> Insertable<Tab, DB> for &'a DefaultValues
 where
     Tab: Table,
     DB: Backend,
 {
-    type Values = Self;
+    type Values = DefaultValues;
 
     fn values(self) -> Self::Values {
-        self
+        *self
     }
 }
 
diff --git a/diesel_tests/tests/insert.rs b/diesel_tests/tests/insert.rs
index b775d70d5..665bd6512 100644
--- a/diesel_tests/tests/insert.rs
+++ b/diesel_tests/tests/insert.rs
@@ -266,6 +266,19 @@ fn insert_empty_slice_with_returning() {
     assert_eq!(Ok(vec![]), insert_all);
 }
 
+#[test]
+#[cfg(feature = "postgres")]
+fn upsert_empty_slice() {
+    use diesel::pg::upsert::*;
+    let connection = connection();
+
+    let inserted_records = insert(&Vec::<NewUser>::new().on_conflict_do_nothing())
+        .into(users::table)
+        .execute(&connection);
+
+    assert_eq!(Ok(0), inserted_records);
+}
+
 #[test]
 #[cfg(not(feature = "mysql"))]
 fn insert_only_default_values_deprecated() {
