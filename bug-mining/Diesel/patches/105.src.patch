diff --git a/diesel/src/lib.rs b/diesel/src/lib.rs
index e6ca6b28a..0e5417852 100644
--- a/diesel/src/lib.rs
+++ b/diesel/src/lib.rs
@@ -127,7 +127,7 @@ pub mod prelude {
 
 pub use prelude::*;
 #[doc(inline)]
-pub use query_builder::functions::{insert, update, delete, select};
+pub use query_builder::functions::{insert, update, delete, select, insert_default_values};
 #[cfg(feature = "sqlite")]
 pub use sqlite::query_builder::functions::*;
 pub use result::Error::NotFound;
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index 8b4a87339..54a284d84 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -3,7 +3,7 @@ use helper_types::Select;
 use query_dsl::SelectDsl;
 use super::delete_statement::DeleteStatement;
 use super::insert_statement::Insert;
-use super::{IntoUpdateTarget, IncompleteUpdateStatement, IncompleteInsertStatement, SelectStatement};
+use super::{IntoUpdateTarget, IncompleteUpdateStatement, IncompleteInsertStatement, SelectStatement, IncompleteDefaultInsertStatement};
 
 /// Creates an update statement. Helpers for updating a single row can be
 /// generated by deriving [`AsChangeset`](query_builder/trait.AsChangeset.html)
@@ -157,3 +157,11 @@ pub fn select<T>(expression: T) -> Select<SelectStatement<()>, T> where
 {
     SelectStatement::simple(()).select(expression)
 }
+
+/// Creates an insert statement with default values.
+///
+/// This function is not exported by default. As with other commands, the resulting
+/// query can return the inserted rows if you choose.
+pub fn insert_default_values() -> IncompleteDefaultInsertStatement {
+    IncompleteDefaultInsertStatement::new()
+}
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index 0b09b5cc4..bb95804e0 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -351,3 +351,66 @@ impl<'a, T, Table> UndecoratedInsertRecord<Table> for &'a Vec<T> where
     &'a [T]: UndecoratedInsertRecord<Table>,
 {
 }
+
+/// The structure returned by [`insert_default_values`](/diesel/fn.insert_default_values.html). The
+/// only thing that can be done with it is call `into`.
+#[derive(Debug, Copy, Clone, Default)]
+pub struct IncompleteDefaultInsertStatement {}
+
+#[derive(Debug, Copy, Clone)]
+pub struct DefaultInsertStatement<T, Ret=NoReturningClause> {
+    target: T,
+    returning: Ret,
+}
+
+impl IncompleteDefaultInsertStatement {
+    #[doc(hidden)]
+    pub fn new() -> Self {
+        IncompleteDefaultInsertStatement {}
+    }
+
+    /// Specify which table the data passed to `insert` should be added to.
+    pub fn into<S>(self, target: S) -> DefaultInsertStatement<S>
+    {
+        DefaultInsertStatement { target: target, returning: NoReturningClause }
+    }
+}
+
+impl<T> DefaultInsertStatement<T, NoReturningClause> {
+    /// Specify what expression is returned after execution of the `insert_default_values`.
+    /// This method can only be called once.
+    pub fn returning<E>(self, returns: E)
+        -> DefaultInsertStatement<T, ReturningClause<E>> where
+            DefaultInsertStatement<T, ReturningClause<E>>: Query,
+    {
+        DefaultInsertStatement {
+            target: self.target,
+            returning: ReturningClause(returns),
+        }
+    }
+}
+
+impl<T, Ret> Query for DefaultInsertStatement<T, ReturningClause<Ret>> where
+    Ret: Expression + SelectableExpression<T> + NonAggregate,
+{
+    type SqlType = Ret::SqlType;
+}
+
+impl<T, Ret, DB> QueryFragment<DB> for DefaultInsertStatement<T, Ret> where
+    DB: Backend,
+    T: Table,
+    T::FromClause: QueryFragment<DB>,
+    Ret: QueryFragment<DB>,
+{
+    fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
+        out.unsafe_to_cache_prepared();
+
+        out.push_sql("INSERT INTO ");
+        self.target.from_clause().walk_ast(out.reborrow())?;
+        out.push_sql("DEFAULT VALUES ");
+        self.returning.walk_ast(out.reborrow())?;
+        Ok(())
+    }
+}
+
+impl_query_id!(noop: DefaultInsertStatement<T, Ret>);
diff --git a/diesel/src/query_builder/mod.rs b/diesel/src/query_builder/mod.rs
index 84d3e1964..96cdac6d5 100644
--- a/diesel/src/query_builder/mod.rs
+++ b/diesel/src/query_builder/mod.rs
@@ -40,7 +40,7 @@ pub use self::update_statement::{
     UpdateTarget,
 };
 #[doc(inline)]
-pub use self::insert_statement::IncompleteInsertStatement;
+pub use self::insert_statement::{IncompleteInsertStatement, IncompleteDefaultInsertStatement};
 
 use std::error::Error;
 
diff --git a/diesel_compile_tests/tests/compile-fail/insert_default_values_statement_does_not_support_returning_methods_on_sqlite.rs b/diesel_compile_tests/tests/compile-fail/insert_default_values_statement_does_not_support_returning_methods_on_sqlite.rs
new file mode 100644
index 000000000..5f1c39899
--- /dev/null
+++ b/diesel_compile_tests/tests/compile-fail/insert_default_values_statement_does_not_support_returning_methods_on_sqlite.rs
@@ -0,0 +1,51 @@
+#[macro_use]
+extern crate diesel;
+
+use diesel::*;
+use diesel::sqlite::{Sqlite, SqliteQueryBuilder, SqliteConnection};
+use diesel::backend::Backend;
+use diesel::types::{Integer, VarChar};
+
+table! {
+    users {
+        id -> Integer,
+        name -> VarChar,
+    }
+}
+
+pub struct User {
+    id: i32,
+    name: String,
+}
+
+use diesel::types::FromSqlRow;
+
+impl<DB: Backend> Queryable<(Integer, VarChar), DB> for User where
+    (i32, String): FromSqlRow<(Integer, VarChar), DB>,
+{
+    type Row = (i32, String);
+
+    fn build(row: Self::Row) -> Self {
+        User {
+            id: row.0,
+            name: row.1,
+        }
+    }
+}
+
+pub struct NewUser(String);
+
+fn main() {
+    let connection = SqliteConnection::establish(":memory:").unwrap();
+
+    insert_default_values()
+        .into(users::table)
+        .get_result::<User>(&connection);
+    //~^ ERROR: no method named `get_result`
+
+    insert_default_values()
+        .into(users::table)
+        .returning(users::name)
+        .get_result::<String>(&connection);
+    //~^ ERROR: SupportsReturningClause
+}
diff --git a/diesel_tests/tests/insert.rs b/diesel_tests/tests/insert.rs
index c511c848d..aa1771087 100644
--- a/diesel_tests/tests/insert.rs
+++ b/diesel_tests/tests/insert.rs
@@ -214,3 +214,41 @@ fn insert_empty_slice_with_returning() {
     assert_eq!(Ok(None), insert_one.optional());
     assert_eq!(Ok(vec![]), insert_all);
 }
+
+#[test]
+#[cfg(not(feature = "mysql"))]
+fn insert_only_default_values() {
+    use schema::users::table as users;
+    use schema_dsl::*;
+    let connection = connection();
+
+    connection.execute("DROP TABLE users").unwrap();
+    create_table("users", (
+        integer("id").primary_key().auto_increment(),
+        string("name").not_null().default("'Sean'"),
+        string("hair_color").not_null().default("'Green'"),
+    )).execute(&connection).unwrap();
+
+    insert_default_values().into(users).execute(&connection);
+    assert_eq!(users.load::<User>(&connection), Ok(vec![User { id: 1, name: "Sean".into(), hair_color: Some("Green".into()) }]));
+}
+
+#[test]
+#[cfg(feature = "postgres")]
+fn insert_only_default_values_with_returning() {
+    use schema::users::table as users;
+    use schema::users::id;
+    use schema_dsl::*;
+    let connection = connection();
+
+    connection.execute("DROP TABLE users").unwrap();
+    create_table("users", (
+        integer("id").primary_key().auto_increment(),
+        string("name").not_null().default("'Sean'"),
+        string("hair_color").not_null().default("'Green'"),
+    )).execute(&connection).unwrap();
+    let result = LoadDsl::get_result::<i32>(insert_default_values().into(users).returning(id), &connection).unwrap();
+
+    assert_eq!(result, 1);
+    assert_eq!(users.load::<User>(&connection), Ok(vec![User { id: 1, name: "Sean".into(), hair_color: Some("Green".into()) }]));
+}
