diff --git a/diesel_cli/Cargo.toml b/diesel_cli/Cargo.toml
index 5f8555d1d..ed7e2cede 100644
--- a/diesel_cli/Cargo.toml
+++ b/diesel_cli/Cargo.toml
@@ -26,7 +26,7 @@ dotenvy = "0.15"
 heck = "0.4.0"
 serde = { version = "1.0.0", features = ["derive"] }
 toml = "0.5"
-url = { version = "2.2.2", optional = true }
+url = { version = "2.2.2" }
 libsqlite3-sys = { version = ">=0.17.2, <0.26.0", optional = true }
 diffy = "0.2.0"
 regex = "1.0.6"
@@ -49,9 +49,9 @@ url = { version = "2.2.2" }
 
 [features]
 default = ["postgres", "sqlite", "mysql"]
-postgres = ["diesel/postgres", "url", "uses_information_schema"]
+postgres = ["diesel/postgres", "uses_information_schema"]
 sqlite = ["diesel/sqlite"]
-mysql = ["diesel/mysql", "url", "uses_information_schema"]
+mysql = ["diesel/mysql", "uses_information_schema"]
 sqlite-bundled = ["sqlite", "libsqlite3-sys/bundled"]
 uses_information_schema = []
 
diff --git a/diesel_cli/src/database.rs b/diesel_cli/src/database.rs
index c8f646328..572449b6d 100644
--- a/diesel_cli/src/database.rs
+++ b/diesel_cli/src/database.rs
@@ -172,7 +172,8 @@ fn create_database_if_needed(database_url: &str) -> DatabaseResult<()> {
         }
         #[cfg(feature = "sqlite")]
         Backend::Sqlite => {
-            if !::std::path::Path::new(database_url).exists() {
+            let path = path_from_sqlite_url(database_url)?;
+            if !path.exists() {
                 println!("Creating database: {}", database_url);
                 SqliteConnection::establish(database_url)?;
             }
@@ -361,6 +362,23 @@ fn change_database_of_url(database_url: &str, default_database: &str) -> (String
     (database, new_url.into())
 }
 
+#[cfg(feature = "sqlite")]
+fn path_from_sqlite_url(database_url: &str) -> DatabaseResult<::std::path::PathBuf> {
+    match ::url::Url::parse(database_url) {
+        Ok(url) if url.scheme() == "file" => Ok(url.to_file_path().map_err(|_err| {
+            result::ConnectionError::InvalidConnectionUrl(String::from(database_url))
+        })?),
+        Err(::url::ParseError::RelativeUrlWithoutBase) => {
+            // assume a bare path
+            Ok(::std::path::PathBuf::from(database_url))
+        }
+        _ => {
+            // invalid URL or scheme
+            Err(result::ConnectionError::InvalidConnectionUrl(String::from(database_url)).into())
+        }
+    }
+}
+
 fn handle_error<E: Error, T>(error: E) -> T {
     println!("{}", error);
     ::std::process::exit(1);
