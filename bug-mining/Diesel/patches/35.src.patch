diff --git a/diesel/src/backend.rs b/diesel/src/backend.rs
index a65b4e246..122ea6a95 100644
--- a/diesel/src/backend.rs
+++ b/diesel/src/backend.rs
@@ -26,6 +26,7 @@ pub trait TypeMetadata {
 
 pub trait SupportsReturningClause {}
 pub trait SupportsDefaultKeyword {}
+pub trait SupportsNowFunction {}
 
 pub struct Debug;
 
@@ -40,3 +41,4 @@ impl TypeMetadata for Debug {
 
 impl SupportsReturningClause for Debug {}
 impl SupportsDefaultKeyword for Debug {}
+impl SupportsNowFunction for Debug {}
diff --git a/diesel/src/expression/expression_methods/global_expression_methods.rs b/diesel/src/expression/expression_methods/global_expression_methods.rs
index f71f22023..77b01f545 100644
--- a/diesel/src/expression/expression_methods/global_expression_methods.rs
+++ b/diesel/src/expression/expression_methods/global_expression_methods.rs
@@ -49,14 +49,6 @@ pub trait ExpressionMethods: Expression + Sized {
         Eq::new(self, other.as_expression())
     }
 
-    #[doc(hidden)]
-    fn is_not_distinct_from<T>(self, other: T)
-        -> IsNotDistinctFrom<Self, T::Expression> where
-            T: AsExpression<Self::SqlType>,
-    {
-        IsNotDistinctFrom::new(self, other.as_expression())
-    }
-
     /// Creates a SQL `!=` expression.
     ///
     /// # Example
diff --git a/diesel/src/expression/expression_methods/mod.rs b/diesel/src/expression/expression_methods/mod.rs
index 22f493a49..477032040 100644
--- a/diesel/src/expression/expression_methods/mod.rs
+++ b/diesel/src/expression/expression_methods/mod.rs
@@ -7,11 +7,10 @@
 pub mod global_expression_methods;
 pub mod bool_expression_methods;
 pub mod text_expression_methods;
-#[doc(hidden)]
-pub mod timestamp_expression_methods;
 
 pub use self::global_expression_methods::ExpressionMethods;
 pub use self::bool_expression_methods::BoolExpressionMethods;
 pub use self::text_expression_methods::{TextExpressionMethods, VarCharExpressionMethods};
-#[doc(hidden)]
-pub use self::timestamp_expression_methods::TimestampExpressionMethods;
+
+#[cfg(feature = "postgres")]
+pub use pg::expression::expression_methods::*;
diff --git a/diesel/src/expression/expression_methods/timestamp_expression_methods.rs b/diesel/src/expression/expression_methods/timestamp_expression_methods.rs
deleted file mode 100644
index 23e394a74..000000000
--- a/diesel/src/expression/expression_methods/timestamp_expression_methods.rs
+++ /dev/null
@@ -1,14 +0,0 @@
-use expression::{AsExpression, Expression};
-use expression::date_and_time::AtTimeZone;
-use types::{VarChar, Timestamp};
-
-pub trait TimestampExpressionMethods: Expression<SqlType=Timestamp> + Sized {
-    /// Returns a PostgreSQL "AT TIME ZONE" expression
-    fn at_time_zone<T>(self, timezone: T) -> AtTimeZone<Self, T::Expression> where
-        T: AsExpression<VarChar>,
-    {
-        AtTimeZone::new(self, timezone.as_expression())
-    }
-}
-
-impl<T: Expression<SqlType=Timestamp>> TimestampExpressionMethods for T {}
diff --git a/diesel/src/expression/functions/date_and_time.rs b/diesel/src/expression/functions/date_and_time.rs
index 88ae08b60..bf1607c28 100644
--- a/diesel/src/expression/functions/date_and_time.rs
+++ b/diesel/src/expression/functions/date_and_time.rs
@@ -1,6 +1,7 @@
+use backend;
 use types::*;
 
-no_arg_sql_function!(now, Timestamp, "Represents the SQL NOW() function");
+no_arg_sql_function!(now, Timestamp, "Represents the SQL NOW() function", backend::SupportsNowFunction);
 operator_allowed!(now, Add, add);
 operator_allowed!(now, Sub, sub);
 sql_function!(date, date_t, (x: Timestamp) -> Date,
diff --git a/diesel/src/expression/functions/mod.rs b/diesel/src/expression/functions/mod.rs
index 48d3e972f..8e2919c6f 100644
--- a/diesel/src/expression/functions/mod.rs
+++ b/diesel/src/expression/functions/mod.rs
@@ -106,7 +106,7 @@ macro_rules! sql_function {
 
 #[macro_export]
 #[doc(hidden)]
-macro_rules! no_arg_sql_function_body {
+macro_rules! no_arg_sql_function_body_except_to_sql {
     ($type_name:ident, $return_type:ty, $docs:expr) => {
         #[allow(non_camel_case_types)]
         #[doc=$docs]
@@ -116,23 +116,48 @@ macro_rules! no_arg_sql_function_body {
             type SqlType = $return_type;
         }
 
+        impl<QS> $crate::expression::SelectableExpression<QS> for $type_name {
+        }
+
+        impl $crate::expression::NonAggregate for $type_name {
+        }
+    }
+}
+
+#[macro_export]
+#[doc(hidden)]
+macro_rules! no_arg_sql_function_body {
+    ($type_name:ident, $return_type:ty, $docs:expr, $($constraint:ident)::+) => {
+        no_arg_sql_function_body_except_to_sql!($type_name, $return_type, $docs);
+
         impl<DB> $crate::query_builder::QueryFragment<DB> for $type_name where
-            DB: $crate::backend::Backend,
+            DB: $crate::backend::Backend + $($constraint)::+,
         {
             fn to_sql(&self, out: &mut DB::QueryBuilder)
-                -> $crate::query_builder::BuildQueryResult {
-                    use $crate::query_builder::QueryBuilder;
-                    out.push_sql(concat!(stringify!($type_name), "()"));
-                    Ok(())
-                }
+                -> $crate::query_builder::BuildQueryResult
+            {
+                use $crate::query_builder::QueryBuilder;
+                out.push_sql(concat!(stringify!($type_name), "()"));
+                Ok(())
+            }
         }
+    };
 
-        impl<QS> $crate::expression::SelectableExpression<QS> for $type_name {
-        }
+    ($type_name:ident, $return_type:ty, $docs:expr) => {
+        no_arg_sql_function_body_except_to_sql!($type_name, $return_type, $docs);
 
-        impl $crate::expression::NonAggregate for $type_name {
+        impl<DB> $crate::query_builder::QueryFragment<DB> for $type_name where
+            DB: $crate::backend::Backend,
+        {
+            fn to_sql(&self, out: &mut DB::QueryBuilder)
+                -> $crate::query_builder::BuildQueryResult
+            {
+                use $crate::query_builder::QueryBuilder;
+                out.push_sql(concat!(stringify!($type_name), "()"));
+                Ok(())
+            }
         }
-    }
+    };
 }
 
 #[macro_export]
@@ -147,6 +172,9 @@ macro_rules! no_arg_sql_function_body {
 /// no_arg_sql_function!(now, types::Timestamp, "Represents the SQL NOW() function");
 /// # fn main() {}
 /// ```
+///
+/// You can optionally pass the name of a trait, as a constraint for backends which support the
+/// function.
 macro_rules! no_arg_sql_function {
     ($type_name:ident, $return_type:ty) => {
         no_arg_sql_function!($type_name, $return_type, "");
@@ -154,7 +182,11 @@ macro_rules! no_arg_sql_function {
 
     ($type_name:ident, $return_type:ty, $docs:expr) => {
         no_arg_sql_function_body!($type_name, $return_type, $docs);
-    }
+    };
+
+    ($type_name:ident, $return_type:ty, $docs:expr, $($constraint:ident)::+) => {
+        no_arg_sql_function_body!($type_name, $return_type, $docs, $($constraint)::+);
+    };
 }
 
 pub mod aggregate_ordering;
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index 278f4b4c0..41f490951 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -23,8 +23,6 @@ pub mod aliased;
 pub mod bound;
 #[doc(hidden)]
 pub mod count;
-#[doc(hidden)]
-pub mod date_and_time;
 pub mod expression_methods;
 #[doc(hidden)]
 pub mod functions;
@@ -34,6 +32,7 @@ pub mod helper_types;
 #[doc(hidden)]
 pub mod nullable;
 #[doc(hidden)]
+#[macro_use]
 pub mod predicates;
 pub mod sql_literal;
 
diff --git a/diesel/src/expression/predicates.rs b/diesel/src/expression/predicates.rs
index 21b655ecb..1443d54d7 100644
--- a/diesel/src/expression/predicates.rs
+++ b/diesel/src/expression/predicates.rs
@@ -24,6 +24,24 @@ macro_rules! infix_predicate_body {
             type SqlType = $return_type;
         }
 
+        impl<T, U, QS> $crate::expression::SelectableExpression<QS> for $name<T, U> where
+            T: $crate::expression::SelectableExpression<QS>,
+            U: $crate::expression::SelectableExpression<QS>,
+        {
+        }
+
+        impl<T, U> $crate::expression::NonAggregate for $name<T, U> where
+            T: $crate::expression::NonAggregate,
+            U: $crate::expression::NonAggregate,
+        {
+        }
+    }
+}
+
+#[macro_export]
+#[doc(hidden)]
+macro_rules! global_infix_predicate_to_sql {
+    ($name:ident, $operator:expr) => {
         impl<T, U, DB> $crate::query_builder::QueryFragment<DB> for $name<T, U> where
             DB: $crate::backend::Backend,
             T: $crate::query_builder::QueryFragment<DB>,
@@ -35,17 +53,41 @@ macro_rules! infix_predicate_body {
                 self.right.to_sql(out)
             }
         }
+    }
+}
 
-        impl<T, U, QS> $crate::expression::SelectableExpression<QS> for $name<T, U> where
-            T: $crate::expression::SelectableExpression<QS>,
-            U: $crate::expression::SelectableExpression<QS>,
+#[macro_export]
+#[doc(hidden)]
+macro_rules! backend_specific_infix_predicate_to_sql {
+    ($name:ident, $operator:expr, $backend:ty) => {
+        impl<T, U> $crate::query_builder::QueryFragment<$backend> for $name<T, U> where
+            T: $crate::query_builder::QueryFragment<$backend>,
+            U: $crate::query_builder::QueryFragment<$backend>,
         {
+            fn to_sql(&self, out: &mut <$backend as $crate::backend::Backend>::QueryBuilder)
+                -> $crate::query_builder::BuildQueryResult
+            {
+                use $crate::query_builder::QueryBuilder;
+                try!(self.left.to_sql(out));
+                out.push_sql($operator);
+                self.right.to_sql(out)
+            }
         }
 
-        impl<T, U> $crate::expression::NonAggregate for $name<T, U> where
-            T: $crate::expression::NonAggregate,
-            U: $crate::expression::NonAggregate,
+        impl<T, U> $crate::query_builder::QueryFragment<$crate::backend::Debug>
+            for $name<T, U> where
+                T: $crate::query_builder::QueryFragment<$crate::backend::Debug>,
+                U: $crate::query_builder::QueryFragment<$crate::backend::Debug>,
         {
+            fn to_sql(
+                &self,
+                out: &mut <$crate::backend::Debug as $crate::backend::Backend>::QueryBuilder,
+            ) -> $crate::query_builder::BuildQueryResult {
+                use $crate::query_builder::QueryBuilder;
+                try!(self.left.to_sql(out));
+                out.push_sql($operator);
+                self.right.to_sql(out)
+            }
         }
     }
 }
@@ -70,6 +112,16 @@ macro_rules! infix_predicate {
     };
 
     ($name:ident, $operator:expr, $return_type:ty) => {
+        global_infix_predicate_to_sql!($name, $operator);
+        infix_predicate_body!($name, $operator, $return_type);
+    };
+
+    ($name:ident, $operator:expr, backend: $backend:ty) => {
+        infix_predicate!($name, $operator, $backend, $crate::types::Bool);
+    };
+
+    ($name:ident, $operator:expr, $backend:ty, $return_type:ty) => {
+        backend_specific_infix_predicate_to_sql!($name, $operator, $backend);
         infix_predicate_body!($name, $operator, $return_type);
     };
 }
@@ -139,7 +191,6 @@ macro_rules! postfix_expression {
 infix_predicate!(And, " AND ");
 infix_predicate!(Between, " BETWEEN ");
 infix_predicate!(Eq, " = ");
-infix_predicate!(IsNotDistinctFrom, " IS NOT DISTINCT FROM ");
 infix_predicate!(Gt, " > ");
 infix_predicate!(GtEq, " >= ");
 infix_predicate!(Like, " LIKE ");
diff --git a/diesel/src/lib.rs b/diesel/src/lib.rs
index d3e606358..cd71e3e38 100644
--- a/diesel/src/lib.rs
+++ b/diesel/src/lib.rs
@@ -5,6 +5,7 @@
 #![cfg_attr(all(feature = "unstable", feature = "postgres"), feature(time2))]
 pub mod backend;
 pub mod connection;
+#[macro_use]
 pub mod expression;
 #[doc(hidden)]
 pub mod persistable;
diff --git a/diesel/src/pg/backend.rs b/diesel/src/pg/backend.rs
index 1147dd550..a792494ff 100644
--- a/diesel/src/pg/backend.rs
+++ b/diesel/src/pg/backend.rs
@@ -20,3 +20,4 @@ impl TypeMetadata for Pg {
 
 impl SupportsReturningClause for Pg {}
 impl SupportsDefaultKeyword for Pg {}
+impl SupportsNowFunction for Pg {}
diff --git a/diesel/src/expression/date_and_time.rs b/diesel/src/pg/expression/date_and_time.rs
similarity index 54%
rename from diesel/src/expression/date_and_time.rs
rename to diesel/src/pg/expression/date_and_time.rs
index 029778afe..64df92553 100644
--- a/diesel/src/expression/date_and_time.rs
+++ b/diesel/src/pg/expression/date_and_time.rs
@@ -1,5 +1,6 @@
-use backend::Backend;
-use expression::{Expression, SelectableExpression};
+use backend::*;
+use expression::{Expression, SelectableExpression, NonAggregate};
+use pg::{Pg, PgQueryBuilder};
 use query_builder::*;
 use types::{Timestamp, VarChar};
 
@@ -25,12 +26,27 @@ impl<Ts, Tz> Expression for AtTimeZone<Ts, Tz> where
     type SqlType = Timestamp;
 }
 
-impl<Ts, Tz, DB> QueryFragment<DB> for AtTimeZone<Ts, Tz> where
-    DB: Backend,
-    Ts: QueryFragment<DB>,
-    Tz: QueryFragment<DB>,
+impl<Ts, Tz> NonAggregate for AtTimeZone<Ts, Tz> where
+    AtTimeZone<Ts, Tz>: Expression,
+{
+}
+
+impl<Ts, Tz> QueryFragment<Pg> for AtTimeZone<Ts, Tz> where
+    Ts: QueryFragment<Pg>,
+    Tz: QueryFragment<Pg>,
+{
+    fn to_sql(&self, out: &mut PgQueryBuilder) -> BuildQueryResult {
+        try!(self.timestamp.to_sql(out));
+        out.push_sql(" AT TIME ZONE ");
+        self.timezone.to_sql(out)
+    }
+}
+
+impl<Ts, Tz> QueryFragment<Debug> for AtTimeZone<Ts, Tz> where
+    Ts: QueryFragment<Debug>,
+    Tz: QueryFragment<Debug>,
 {
-    fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
+    fn to_sql(&self, out: &mut <Debug as Backend>::QueryBuilder) -> BuildQueryResult {
         try!(self.timestamp.to_sql(out));
         out.push_sql(" AT TIME ZONE ");
         self.timezone.to_sql(out)
diff --git a/diesel/src/pg/expression/expression_methods.rs b/diesel/src/pg/expression/expression_methods.rs
new file mode 100644
index 000000000..9e677d608
--- /dev/null
+++ b/diesel/src/pg/expression/expression_methods.rs
@@ -0,0 +1,51 @@
+use expression::{Expression, AsExpression};
+use super::predicates::*;
+
+pub trait PgExpressionMethods: Expression + Sized {
+    /// Creates a PostgreSQL `IS NOT DISTINCT FROM` expression. This behaves
+    /// identically to the `=` operator, except that `NULL` is treated as a
+    /// normal value.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("src/doctest_setup.rs");
+    /// #
+    /// # table! {
+    /// #     users {
+    /// #         id -> Integer,
+    /// #         name -> VarChar,
+    /// #     }
+    /// # }
+    /// #
+    /// # fn main() {
+    /// #     use self::users::dsl::*;
+    /// #     let connection = establish_connection();
+    /// let data = users.select(id).filter(name.is_not_distinct_from("Sean"));
+    /// assert_eq!(Ok(1), data.first(&connection));
+    /// # }
+    fn is_not_distinct_from<T>(self, other: T)
+        -> IsNotDistinctFrom<Self, T::Expression> where
+            T: AsExpression<Self::SqlType>,
+    {
+        IsNotDistinctFrom::new(self, other.as_expression())
+    }
+}
+
+impl<T: Expression> PgExpressionMethods for T {}
+
+use super::date_and_time::AtTimeZone;
+use types::{VarChar, Timestamp};
+
+#[doc(hidden)]
+pub trait PgTimestampExpressionMethods: Expression<SqlType=Timestamp> + Sized {
+    /// Returns a PostgreSQL "AT TIME ZONE" expression
+    fn at_time_zone<T>(self, timezone: T) -> AtTimeZone<Self, T::Expression> where
+        T: AsExpression<VarChar>,
+    {
+        AtTimeZone::new(self, timezone.as_expression())
+    }
+}
+
+impl<T: Expression<SqlType=Timestamp>> PgTimestampExpressionMethods for T {}
diff --git a/diesel/src/pg/expression/mod.rs b/diesel/src/pg/expression/mod.rs
index 1e9a40c5c..315b55779 100644
--- a/diesel/src/pg/expression/mod.rs
+++ b/diesel/src/pg/expression/mod.rs
@@ -1,6 +1,11 @@
 #[doc(hidden)]
 pub mod array_comparison;
+pub mod expression_methods;
 pub mod extensions;
+#[doc(hidden)]
+pub mod predicates;
+
+mod date_and_time;
 
 /// PostgreSQL specific expression DSL methods. This module will be glob
 /// imported by [`expression::dsl`](../../expression/dsl/index.html) when
diff --git a/diesel/src/pg/expression/predicates.rs b/diesel/src/pg/expression/predicates.rs
new file mode 100644
index 000000000..8d5aca141
--- /dev/null
+++ b/diesel/src/pg/expression/predicates.rs
@@ -0,0 +1,3 @@
+use pg::Pg;
+
+infix_predicate!(IsNotDistinctFrom, " IS NOT DISTINCT FROM ", backend: Pg);
diff --git a/diesel/src/query_dsl/with_dsl.rs b/diesel/src/query_dsl/with_dsl.rs
index fe40fb388..aba12291d 100644
--- a/diesel/src/query_dsl/with_dsl.rs
+++ b/diesel/src/query_dsl/with_dsl.rs
@@ -45,9 +45,30 @@ impl<'a, Left, Right> QuerySource for WithQuerySource<'a, Left, Right> where
     Left: QuerySource,
     Aliased<'a, Right>: QuerySource + Expression,
 {
-    type FromClause = (Left::FromClause, <Aliased<'a, Right> as QuerySource>::FromClause);
+    type FromClause = PgOnly<(Left::FromClause, <Aliased<'a, Right> as QuerySource>::FromClause)>;
 
     fn from_clause(&self) -> Self::FromClause {
-        (self.left.from_clause(), self.right.from_clause())
+        PgOnly((self.left.from_clause(), self.right.from_clause()))
+    }
+}
+
+#[doc(hidden)]
+pub struct PgOnly<T>(T);
+
+#[cfg(feature = "postgres")]
+use pg::{Pg, PgQueryBuilder};
+
+#[cfg(feature = "postgres")]
+impl<T: QueryFragment<Pg>> QueryFragment<Pg> for PgOnly<T> {
+    fn to_sql(&self, out: &mut PgQueryBuilder) -> BuildQueryResult {
+        self.0.to_sql(out)
+    }
+}
+
+use backend::*;
+
+impl<T: QueryFragment<Debug>> QueryFragment<Debug> for PgOnly<T> {
+    fn to_sql(&self, out: &mut <Debug as Backend>::QueryBuilder) -> BuildQueryResult {
+        self.0.to_sql(out)
     }
 }
diff --git a/diesel/src/sqlite/mod.rs b/diesel/src/sqlite/mod.rs
index ccc195892..567449e23 100644
--- a/diesel/src/sqlite/mod.rs
+++ b/diesel/src/sqlite/mod.rs
@@ -6,3 +6,13 @@ mod types;
 pub use self::backend::{Sqlite, SqliteType};
 pub use self::connection::SqliteConnection;
 pub use self::query_builder::SqliteQueryBuilder;
+
+use ::expression::dsl::now;
+
+impl ::query_builder::QueryFragment<Sqlite> for now {
+    fn to_sql(&self, out: &mut SqliteQueryBuilder) -> ::query_builder::BuildQueryResult {
+        use ::query_builder::QueryBuilder;
+        out.push_sql("'now'");
+        Ok(())
+    }
+}
diff --git a/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs b/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs
new file mode 100644
index 000000000..24d40f057
--- /dev/null
+++ b/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs
@@ -0,0 +1,36 @@
+#[macro_use]
+extern crate diesel;
+
+use diesel::*;
+use diesel::sqlite::SqliteConnection;
+use diesel::types::*;
+use diesel::expression::dsl::*;
+
+table! {
+    users {
+        id -> Integer,
+        name -> VarChar,
+    }
+}
+
+sql_function!(lower, lower_t, (x: VarChar) -> VarChar);
+
+// NOTE: This test is meant to be comprehensive, but not exhaustive.
+fn main() {
+    use self::users::dsl::*;
+    let connection = SqliteConnection::establish(":memory:").unwrap();
+
+    users.select(id).filter(name.eq(any(Vec::<String>::new())))
+        .load::<i32>(&connection);
+    //~^ ERROR type mismatch resolving `<diesel::sqlite::connection::SqliteConnection as diesel::connection::Connection>::Backend == diesel::pg::backend::Pg
+    users.select(id).filter(name.is_not_distinct_from("Sean"))
+        .load::<i32>(&connection);
+    //~^ ERROR E0277
+    let n = lower("sean").aliased("n");
+    users.with(n).select(id)
+        .load::<i32>(&connection);
+    //~^ ERROR E0277
+    users.select(id).filter(now.eq(now.at_time_zone("UTC")))
+        .load::<i32>(&connection);
+    //~^ ERROR E0277
+}
diff --git a/diesel_tests/tests/expressions/mod.rs b/diesel_tests/tests/expressions/mod.rs
index 4ba7bfd28..6576f9da0 100644
--- a/diesel_tests/tests/expressions/mod.rs
+++ b/diesel_tests/tests/expressions/mod.rs
@@ -2,7 +2,7 @@
 mod date_and_time;
 mod ops;
 
-use schema::{connection, NewUser, batch_insert};
+use schema::{connection, NewUser, batch_insert, connection_with_sean_and_tess_in_users_table};
 use schema::users::dsl::*;
 use diesel::*;
 use diesel::backend::Backend;
@@ -36,12 +36,17 @@ use diesel::types::VarChar;
 sql_function!(lower, lower_t, (x: VarChar) -> VarChar);
 
 #[test]
+#[cfg(feature = "postgres")]
 fn test_with_expression_aliased() {
     let n = lower("sean").aliased("n");
     assert_eq!(
         "SELECT `users`.`id` FROM `users`, lower(?) `n` WHERE `n` = ?",
-        debug_sql!(users.with(n).filter(n.eq("Jim")).select(id))
+        debug_sql!(users.with(n).filter(n.eq("Sean")).select(id))
     );
+    let connection = connection_with_sean_and_tess_in_users_table();
+    let result = users.with(n).filter(n.eq("sean")).select(name)
+        .first::<String>(&connection);
+    assert_eq!(Ok("Sean".into()), result);
 }
 
 table! {
