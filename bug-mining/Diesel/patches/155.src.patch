diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3769d3341..ea0440c7c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -46,6 +46,12 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 [`DeleteStatement::into_boxed`]: http://docs.diesel.rs/diesel/query_builder/struct.DeleteStatement.html#method.into_boxed
 
+* Update statements can now be boxed. This is useful for conditionally modifying
+  the where clause of a update statement. See [`UpdateStatement::into_boxed`]
+  for details.
+
+[`UpdateStatement::into_boxed`]: http://docs.diesel.rs/diesel/query_builder/struct.UpdateStatement.html#method.into_boxed
+
 * Added `order_by` as an alias for `order`.
 
 * Added `then_order_by`, which appends to an `ORDER BY` clause rather than
diff --git a/diesel/src/query_builder/delete_statement/boxed.rs b/diesel/src/query_builder/delete_statement/boxed.rs
deleted file mode 100644
index c272e1d71..000000000
--- a/diesel/src/query_builder/delete_statement/boxed.rs
+++ /dev/null
@@ -1,139 +0,0 @@
-use backend::Backend;
-use expression::{AppearsOnTable, SelectableExpression};
-use query_builder::returning_clause::*;
-use query_builder::*;
-use query_dsl::RunQueryDsl;
-use query_dsl::methods::FilterDsl;
-use query_source::Table;
-use result::QueryResult;
-
-#[allow(missing_debug_implementations)] // We can't...
-/// Represents a boxed SQL `DELETE` statement.
-///
-/// The where clause of this delete statement has been boxed,
-/// allowing `.filter` to be called conditionally without changing
-/// the return type.
-///
-/// The parameters on this struct represent:
-///
-/// - `'a`: The lifetime of the where clause.
-/// - `DB`: The backend this query will be run against.
-/// - `T`: The table we are deleting from.
-/// - `Ret`: The `RETURNING` clause of this query. The exact types used to
-///   represent this are private. You can safely rely on the default type
-///   representing the lack of a `RETURNING` clause.
-pub struct BoxedDeleteStatement<'a, DB, T, Ret = NoReturningClause> {
-    table: T,
-    where_clause: Option<Box<QueryFragment<DB> + 'a>>,
-    returning: Ret,
-}
-
-impl<'a, DB, T, Ret> BoxedDeleteStatement<'a, DB, T, Ret> {
-    pub(crate) fn new(
-        table: T,
-        where_clause: Option<Box<QueryFragment<DB> + 'a>>,
-        returning: Ret,
-    ) -> Self {
-        BoxedDeleteStatement {
-            table,
-            where_clause,
-            returning,
-        }
-    }
-
-    /// Adds the given predicate to the `WHERE` clause of the statement being
-    /// constructed.
-    ///
-    /// If there is already a `WHERE` clause, the predicate will be appended
-    /// with `AND`.
-    ///
-    /// See [`DeleteStatement::filter`] for examples.
-    ///
-    /// [`DeleteStatement::filter`]: struct.DeleteStatement.html#method.filter
-    pub fn filter<Predicate>(self, predicate: Predicate) -> Self
-    where
-        Self: FilterDsl<Predicate, Output = Self>,
-    {
-        FilterDsl::filter(self, predicate)
-    }
-}
-
-impl<'a, DB, T, Ret, Predicate> FilterDsl<Predicate> for BoxedDeleteStatement<'a, DB, T, Ret>
-where
-    DB: Backend + 'a,
-    Predicate: AppearsOnTable<T> + QueryFragment<DB> + 'a,
-{
-    type Output = Self;
-
-    fn filter(mut self, predicate: Predicate) -> Self::Output {
-        use expression::operators::And;
-        self.where_clause = match self.where_clause {
-            Some(where_clause) => Some(Box::new(And::new(where_clause, predicate))),
-            None => Some(Box::new(predicate)),
-        };
-        self
-    }
-}
-
-impl<'a, DB, T, Ret> QueryFragment<DB> for BoxedDeleteStatement<'a, DB, T, Ret>
-where
-    DB: Backend,
-    T: Table,
-    T::FromClause: QueryFragment<DB>,
-    Ret: QueryFragment<DB>,
-{
-    fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
-        out.push_sql("DELETE FROM ");
-        self.table.from_clause().walk_ast(out.reborrow())?;
-        if let Some(ref where_clause) = self.where_clause {
-            out.push_sql(" WHERE ");
-            where_clause.walk_ast(out.reborrow())?;
-        }
-        self.returning.walk_ast(out.reborrow())?;
-        Ok(())
-    }
-}
-
-impl<'a, DB, T, Ret> QueryId for BoxedDeleteStatement<'a, DB, T, Ret> {
-    type QueryId = ();
-    const HAS_STATIC_QUERY_ID: bool = false;
-}
-
-impl<'a, T, DB> AsQuery for BoxedDeleteStatement<'a, DB, T>
-where
-    T: Table,
-    T::AllColumns: SelectableExpression<T>,
-    BoxedDeleteStatement<'a, DB, T, ReturningClause<T::AllColumns>>: Query,
-{
-    type SqlType = <Self::Query as Query>::SqlType;
-    type Query = BoxedDeleteStatement<'a, DB, T, ReturningClause<T::AllColumns>>;
-
-    fn as_query(self) -> Self::Query {
-        self.returning(T::all_columns())
-    }
-}
-
-impl<'a, DB, T, Ret> Query for BoxedDeleteStatement<'a, DB, T, ReturningClause<Ret>>
-where
-    T: Table,
-    Ret: SelectableExpression<T>,
-{
-    type SqlType = Ret::SqlType;
-}
-
-impl<'a, T, DB, Ret, Conn> RunQueryDsl<Conn> for BoxedDeleteStatement<'a, DB, T, Ret> {}
-
-impl<'a, DB, T> BoxedDeleteStatement<'a, DB, T> {
-    /// Specify what expression is returned after execution of the `delete`.
-    ///
-    /// See [`DeleteStatement::returning`] for examples.
-    ///
-    /// [`DeleteStatement::returning`]: struct.DeleteStatement.html#method.returning
-    pub fn returning<E>(self, returns: E) -> BoxedDeleteStatement<'a, DB, T, ReturningClause<E>>
-    where
-        E: SelectableExpression<T>,
-        BoxedDeleteStatement<'a, DB, T, ReturningClause<E>>: Query,
-    {
-        BoxedDeleteStatement::new(self.table, self.where_clause, ReturningClause(returns))
-    }
-}
diff --git a/diesel/src/query_builder/delete_statement/mod.rs b/diesel/src/query_builder/delete_statement/mod.rs
index 2acf20bb7..c7292973c 100644
--- a/diesel/src/query_builder/delete_statement/mod.rs
+++ b/diesel/src/query_builder/delete_statement/mod.rs
@@ -1,5 +1,3 @@
-mod boxed;
-
 use backend::Backend;
 use dsl::{Filter, IntoBoxed};
 use expression::{AppearsOnTable, SelectableExpression};
@@ -11,8 +9,6 @@ use query_dsl::methods::{BoxedDsl, FilterDsl};
 use query_source::Table;
 use result::QueryResult;
 
-pub use self::boxed::BoxedDeleteStatement;
-
 #[derive(Debug, Clone, Copy, QueryId)]
 /// Represents a SQL `DELETE` statement.
 ///
@@ -30,6 +26,10 @@ pub struct DeleteStatement<T, U, Ret = NoReturningClause> {
     returning: Ret,
 }
 
+/// A `DELETE` statement with a boxed `WHERE` clause
+pub type BoxedDeleteStatement<'a, DB, T, Ret = NoReturningClause> =
+    DeleteStatement<T, BoxedWhereClause<'a, DB>, Ret>;
+
 impl<T, U> DeleteStatement<T, U, NoReturningClause> {
     pub(crate) fn new(table: T, where_clause: U) -> Self {
         DeleteStatement {
@@ -144,12 +144,16 @@ where
 
 impl<'a, T, U, Ret, DB> BoxedDsl<'a, DB> for DeleteStatement<T, U, Ret>
 where
-    U: Into<Option<Box<QueryFragment<DB> + 'a>>>,
+    U: Into<BoxedWhereClause<'a, DB>>,
 {
     type Output = BoxedDeleteStatement<'a, DB, T, Ret>;
 
     fn internal_into_boxed(self) -> Self::Output {
-        BoxedDeleteStatement::new(self.table, self.where_clause.into(), self.returning)
+        DeleteStatement {
+            table: self.table,
+            where_clause: self.where_clause.into(),
+            returning: self.returning,
+        }
     }
 }
 
diff --git a/diesel/src/query_builder/mod.rs b/diesel/src/query_builder/mod.rs
index e15c7e517..cc74aadfc 100644
--- a/diesel/src/query_builder/mod.rs
+++ b/diesel/src/query_builder/mod.rs
@@ -43,7 +43,8 @@ pub use self::query_id::QueryId;
 pub use self::select_statement::{BoxedSelectStatement, SelectStatement};
 pub use self::sql_query::SqlQuery;
 #[doc(inline)]
-pub use self::update_statement::{AsChangeset, IntoUpdateTarget, UpdateStatement, UpdateTarget};
+pub use self::update_statement::{AsChangeset, BoxedUpdateStatement, IntoUpdateTarget,
+                                 UpdateStatement, UpdateTarget};
 #[cfg(feature = "with-deprecated")]
 #[allow(deprecated)]
 pub use self::update_statement::IncompleteUpdateStatement;
diff --git a/diesel/src/query_builder/select_statement/boxed.rs b/diesel/src/query_builder/select_statement/boxed.rs
index 9777a4c24..a0cb8e27d 100644
--- a/diesel/src/query_builder/select_statement/boxed.rs
+++ b/diesel/src/query_builder/select_statement/boxed.rs
@@ -12,6 +12,7 @@ use query_builder::insert_statement::InsertFromSelect;
 use query_builder::limit_clause::LimitClause;
 use query_builder::offset_clause::OffsetClause;
 use query_builder::order_clause::OrderClause;
+use query_builder::where_clause::*;
 use query_dsl::*;
 use query_dsl::methods::*;
 use query_source::joins::*;
@@ -24,7 +25,7 @@ pub struct BoxedSelectStatement<'a, ST, QS, DB> {
     select: Box<QueryFragment<DB> + 'a>,
     from: QS,
     distinct: Box<QueryFragment<DB> + 'a>,
-    where_clause: Option<Box<QueryFragment<DB> + 'a>>,
+    where_clause: BoxedWhereClause<'a, DB>,
     order: Option<Box<QueryFragment<DB> + 'a>>,
     limit: Box<QueryFragment<DB> + 'a>,
     offset: Box<QueryFragment<DB> + 'a>,
@@ -38,7 +39,7 @@ impl<'a, ST, QS, DB> BoxedSelectStatement<'a, ST, QS, DB> {
         select: Box<QueryFragment<DB> + 'a>,
         from: QS,
         distinct: Box<QueryFragment<DB> + 'a>,
-        where_clause: Option<Box<QueryFragment<DB> + 'a>>,
+        where_clause: BoxedWhereClause<'a, DB>,
         order: Option<Box<QueryFragment<DB> + 'a>>,
         limit: Box<QueryFragment<DB> + 'a>,
         offset: Box<QueryFragment<DB> + 'a>,
@@ -90,12 +91,7 @@ where
         self.select.walk_ast(out.reborrow())?;
         out.push_sql(" FROM ");
         self.from.from_clause().walk_ast(out.reborrow())?;
-
-        if let Some(ref where_clause) = self.where_clause {
-            out.push_sql(" WHERE ");
-            where_clause.walk_ast(out.reborrow())?;
-        }
-
+        self.where_clause.walk_ast(out.reborrow())?;
         self.group_by.walk_ast(out.reborrow())?;
 
         if let Some(ref order) = self.order {
@@ -117,12 +113,7 @@ where
         out.push_sql("SELECT ");
         self.distinct.walk_ast(out.reborrow())?;
         self.select.walk_ast(out.reborrow())?;
-
-        if let Some(ref where_clause) = self.where_clause {
-            out.push_sql(" WHERE ");
-            where_clause.walk_ast(out.reborrow())?;
-        }
-
+        self.where_clause.walk_ast(out.reborrow())?;
         self.group_by.walk_ast(out.reborrow())?;
         self.order.walk_ast(out.reborrow())?;
         self.limit.walk_ast(out.reborrow())?;
@@ -194,37 +185,26 @@ where
 
 impl<'a, ST, QS, DB, Predicate> FilterDsl<Predicate> for BoxedSelectStatement<'a, ST, QS, DB>
 where
-    DB: Backend + 'a,
+    BoxedWhereClause<'a, DB>: WhereAnd<Predicate, Output = BoxedWhereClause<'a, DB>>,
     Predicate: AppearsOnTable<QS, SqlType = Bool> + NonAggregate,
-    Predicate: QueryFragment<DB> + 'a,
 {
     type Output = Self;
 
     fn filter(mut self, predicate: Predicate) -> Self::Output {
-        use expression::operators::And;
-        self.where_clause = Some(match self.where_clause {
-            Some(where_clause) => Box::new(And::new(where_clause, predicate)),
-            None => Box::new(predicate),
-        });
+        self.where_clause = self.where_clause.and(predicate);
         self
     }
 }
 
 impl<'a, ST, QS, DB, Predicate> OrFilterDsl<Predicate> for BoxedSelectStatement<'a, ST, QS, DB>
 where
-    DB: Backend + 'a,
+    BoxedWhereClause<'a, DB>: WhereOr<Predicate, Output = BoxedWhereClause<'a, DB>>,
     Predicate: AppearsOnTable<QS, SqlType = Bool> + NonAggregate,
-    Predicate: QueryFragment<DB> + 'a,
 {
     type Output = Self;
 
     fn or_filter(mut self, predicate: Predicate) -> Self::Output {
-        use expression::operators::Or;
-        use expression::grouped::Grouped;
-        self.where_clause = Some(match self.where_clause {
-            Some(where_clause) => Box::new(Grouped(Or::new(where_clause, predicate))),
-            None => Box::new(predicate),
-        });
+        self.where_clause = self.where_clause.or(predicate);
         self
     }
 }
diff --git a/diesel/src/query_builder/select_statement/dsl_impls.rs b/diesel/src/query_builder/select_statement/dsl_impls.rs
index a5c8cc6c1..477d78563 100644
--- a/diesel/src/query_builder/select_statement/dsl_impls.rs
+++ b/diesel/src/query_builder/select_statement/dsl_impls.rs
@@ -314,7 +314,7 @@ where
     DB: Backend,
     S: QueryFragment<DB> + SelectableExpression<F> + 'a,
     D: QueryFragment<DB> + 'a,
-    W: Into<Option<Box<QueryFragment<DB> + 'a>>>,
+    W: Into<BoxedWhereClause<'a, DB>>,
     O: Into<Option<Box<QueryFragment<DB> + 'a>>>,
     L: QueryFragment<DB> + 'a,
     Of: QueryFragment<DB> + 'a,
@@ -344,7 +344,7 @@ where
     F: QuerySource,
     F::DefaultSelection: QueryFragment<DB> + 'a,
     D: QueryFragment<DB> + 'a,
-    W: Into<Option<Box<QueryFragment<DB> + 'a>>>,
+    W: Into<BoxedWhereClause<'a, DB>>,
     O: Into<Option<Box<QueryFragment<DB> + 'a>>>,
     L: QueryFragment<DB> + 'a,
     Of: QueryFragment<DB> + 'a,
diff --git a/diesel/src/query_builder/update_statement/mod.rs b/diesel/src/query_builder/update_statement/mod.rs
index 54437bdfd..878413232 100644
--- a/diesel/src/query_builder/update_statement/mod.rs
+++ b/diesel/src/query_builder/update_statement/mod.rs
@@ -5,13 +5,13 @@ pub use self::changeset::AsChangeset;
 pub use self::target::{IntoUpdateTarget, UpdateTarget};
 
 use backend::Backend;
-use dsl::Filter;
+use dsl::{Filter, IntoBoxed};
 use expression::{AppearsOnTable, Expression, NonAggregate, SelectableExpression};
 use query_builder::*;
 use query_builder::returning_clause::*;
 use query_builder::where_clause::*;
 use query_dsl::RunQueryDsl;
-use query_dsl::methods::FilterDsl;
+use query_dsl::methods::{BoxedDsl, FilterDsl};
 use query_source::Table;
 use result::Error::QueryBuilderError;
 use result::QueryResult;
@@ -65,6 +65,10 @@ pub struct UpdateStatement<T, U, V = SetNotCalled, Ret = NoReturningClause> {
     returning: Ret,
 }
 
+/// An `UPDATE` statement with a boxed `WHERE` clause.
+pub type BoxedUpdateStatement<'a, DB, T, V = SetNotCalled, Ret = NoReturningClause> =
+    UpdateStatement<T, BoxedWhereClause<'a, DB>, V, Ret>;
+
 impl<T, U, V, Ret> UpdateStatement<T, U, V, Ret> {
     /// Adds the given predicate to the `WHERE` clause of the statement being
     /// constructed.
@@ -100,6 +104,59 @@ impl<T, U, V, Ret> UpdateStatement<T, U, V, Ret> {
     {
         FilterDsl::filter(self, predicate)
     }
+
+    /// Boxes the `WHERE` clause of this update statement.
+    ///
+    /// This is useful for cases where you want to conditionally modify a query,
+    /// but need the type to remain the same. The backend must be specified as
+    /// part of this. It is not possible to box a query and have it be useable
+    /// on multiple backends.
+    ///
+    /// A boxed query will incur a minor performance penalty, as the query builder
+    /// can no longer be inlined by the compiler. For most applications this cost
+    /// will be minimal.
+    ///
+    /// ### Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../../doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use std::collections::HashMap;
+    /// #     use schema::users::dsl::*;
+    /// #     let connection = establish_connection();
+    /// #     let mut params = HashMap::new();
+    /// #     params.insert("tess_has_been_a_jerk", false);
+    /// let mut query = diesel::update(users)
+    ///     .set(name.eq("Jerk"))
+    ///     .into_boxed();
+    ///
+    /// if !params["tess_has_been_a_jerk"] {
+    ///     query = query.filter(name.ne("Tess"));
+    /// }
+    ///
+    /// let updated_rows = query.execute(&connection)?;
+    /// assert_eq!(1, updated_rows);
+    ///
+    /// let expected_names = vec!["Jerk", "Tess"];
+    /// let names = users.select(name).order(id).load::<String>(&connection)?;
+    ///
+    /// assert_eq!(expected_names, names);
+    /// #     Ok(())
+    /// # }
+    /// ```
+    pub fn into_boxed<'a, DB>(self) -> IntoBoxed<'a, Self, DB>
+    where
+        DB: Backend,
+        Self: BoxedDsl<'a, DB>,
+    {
+        BoxedDsl::internal_into_boxed(self)
+    }
 }
 
 impl<T, U, V, Ret, Predicate> FilterDsl<Predicate> for UpdateStatement<T, U, V, Ret>
@@ -119,6 +176,22 @@ where
     }
 }
 
+impl<'a, T, U, V, Ret, DB> BoxedDsl<'a, DB> for UpdateStatement<T, U, V, Ret>
+where
+    U: Into<BoxedWhereClause<'a, DB>>,
+{
+    type Output = BoxedUpdateStatement<'a, DB, T, V, Ret>;
+
+    fn internal_into_boxed(self) -> Self::Output {
+        UpdateStatement {
+            table: self.table,
+            where_clause: self.where_clause.into(),
+            values: self.values,
+            returning: self.returning,
+        }
+    }
+}
+
 impl<T, U, V, Ret, DB> QueryFragment<DB> for UpdateStatement<T, U, V, Ret>
 where
     DB: Backend,
diff --git a/diesel/src/query_builder/where_clause.rs b/diesel/src/query_builder/where_clause.rs
index ee1d88980..cc270aafb 100644
--- a/diesel/src/query_builder/where_clause.rs
+++ b/diesel/src/query_builder/where_clause.rs
@@ -59,9 +59,9 @@ where
     }
 }
 
-impl<DB: Backend> Into<Option<Box<QueryFragment<DB>>>> for NoWhereClause {
-    fn into(self) -> Option<Box<QueryFragment<DB>>> {
-        None
+impl<DB> Into<BoxedWhereClause<'static, DB>> for NoWhereClause {
+    fn into(self) -> BoxedWhereClause<'static, DB> {
+        BoxedWhereClause::None
     }
 }
 
@@ -105,13 +105,13 @@ where
     }
 }
 
-impl<'a, DB, Predicate> Into<Option<Box<QueryFragment<DB> + 'a>>> for WhereClause<Predicate>
+impl<'a, DB, Predicate> Into<BoxedWhereClause<'a, DB>> for WhereClause<Predicate>
 where
     DB: Backend,
     Predicate: QueryFragment<DB> + 'a,
 {
-    fn into(self) -> Option<Box<QueryFragment<DB> + 'a>> {
-        Some(Box::new(self.0))
+    fn into(self) -> BoxedWhereClause<'a, DB> {
+        BoxedWhereClause::Where(Box::new(self.0))
     }
 }
 
@@ -126,3 +126,67 @@ where
     Expr: AppearsOnTable<QS>,
 {
 }
+
+#[allow(missing_debug_implementations)] // We can't...
+pub enum BoxedWhereClause<'a, DB> {
+    Where(Box<QueryFragment<DB> + 'a>),
+    None,
+}
+
+impl<'a, DB> QueryFragment<DB> for BoxedWhereClause<'a, DB>
+where
+    DB: Backend,
+{
+    fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
+        match *self {
+            BoxedWhereClause::Where(ref where_clause) => {
+                out.push_sql(" WHERE ");
+                where_clause.walk_ast(out)
+            }
+            BoxedWhereClause::None => Ok(()),
+        }
+    }
+}
+
+impl<'a, DB> QueryId for BoxedWhereClause<'a, DB> {
+    type QueryId = ();
+
+    const HAS_STATIC_QUERY_ID: bool = false;
+}
+
+impl<'a, DB, Predicate> WhereAnd<Predicate> for BoxedWhereClause<'a, DB>
+where
+    DB: Backend + 'a,
+    Predicate: QueryFragment<DB> + 'a,
+{
+    type Output = Self;
+
+    fn and(self, predicate: Predicate) -> Self::Output {
+        use expression::operators::And;
+        use self::BoxedWhereClause::Where;
+
+        match self {
+            Where(where_clause) => Where(Box::new(And::new(where_clause, predicate))),
+            BoxedWhereClause::None => Where(Box::new(predicate)),
+        }
+    }
+}
+
+impl<'a, DB, Predicate> WhereOr<Predicate> for BoxedWhereClause<'a, DB>
+where
+    DB: Backend + 'a,
+    Predicate: QueryFragment<DB> + 'a,
+{
+    type Output = Self;
+
+    fn or(self, predicate: Predicate) -> Self::Output {
+        use expression::operators::Or;
+        use expression::grouped::Grouped;
+        use self::BoxedWhereClause::Where;
+
+        match self {
+            Where(where_clause) => Where(Box::new(Grouped(Or::new(where_clause, predicate)))),
+            BoxedWhereClause::None => Where(Box::new(predicate)),
+        }
+    }
+}
