diff --git a/CHANGELOG.md b/CHANGELOG.md
index 31a7b00b7..474e5103f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -11,6 +11,10 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
   Previously a field with `None` for the value would insert `NULL` into the
   database field. It now does not update the field if the value is `None`.
 
+* `.save_changes` (generated by `#[changeset_for]`) now returns a new struct,
+  rather than mutating `self`. The returned struct can be any type that
+  implements `Queriable` for the right SQL type
+
 ### Fixed
 
 * `#[derive(Queriable)]` now allows generic parameters on the struct.
diff --git a/diesel_codegen/src/update.rs b/diesel_codegen/src/update.rs
index 3b676d715..262040fe5 100644
--- a/diesel_codegen/src/update.rs
+++ b/diesel_codegen/src/update.rs
@@ -88,6 +88,10 @@ fn save_changes_impl(
 ) -> Option<P<ast::Item>> {
     let ref struct_name = model.ty;
     let pk = model.primary_key_name();
+    let sql_type = builder.path()
+        .segment(table).build()
+        .segment("SqlType").build()
+        .build();
     let table = builder.path()
         .segment(table).build()
         .segment("table").build()
@@ -96,14 +100,14 @@ fn save_changes_impl(
         let pk_field = pk.field_name.unwrap();
         quote_item!(cx,
             impl<'a> $struct_name {
-                pub fn save_changes(&mut self, connection: &::diesel::Connection) -> ::diesel::QueryResult<()> {
+                pub fn save_changes<T>(&self, connection: &::diesel::Connection)
+                    -> ::diesel::QueryResult<T> where
+                    T: Queriable<$sql_type>,
+                {
                     use ::diesel::query_builder::update;
-                    *self = {
-                        try!(update($table.filter($table.primary_key().eq(&self.$pk_field)))
-                            .set(&*self)
-                            .get_result(&connection))
-                    };
-                    Ok(())
+                    update($table.filter($table.primary_key().eq(&self.$pk_field)))
+                        .set(self)
+                        .get_result(&connection)
                 }
             }
         )
diff --git a/diesel_tests/tests/update.rs b/diesel_tests/tests/update.rs
index a5ac68c66..f22827c93 100644
--- a/diesel_tests/tests/update.rs
+++ b/diesel_tests/tests/update.rs
@@ -118,10 +118,9 @@ fn save_on_struct_with_primary_key_changes_that_struct() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
-    let mut user = User::with_hair_color(1, "Jim", "blue");
-    user.save_changes(&connection).unwrap();
+    let user = User::with_hair_color(1, "Jim", "blue").save_changes::<User>(&connection);
 
-    let user_in_db = connection.find(users, 1).unwrap();
+    let user_in_db = connection.find(users, 1);
 
     assert_eq!(user, user_in_db);
 }
@@ -134,11 +133,10 @@ fn option_fields_on_structs_are_not_assigned() {
     update(users.filter(id.eq(1)))
         .set(hair_color.eq("black"))
         .execute(&connection).unwrap();
-    let mut user = User::new(1, "Jim");
-    user.save_changes(&connection).unwrap();
+    let user = User::new(1, "Jim").save_changes(&connection);
 
     let expected_user = User::with_hair_color(1, "Jim", "black");
-    assert_eq!(expected_user, user);
+    assert_eq!(Ok(expected_user), user);
 }
 
 #[test]
