diff --git a/CHANGELOG.md b/CHANGELOG.md
index 6771a5691..bbc8d4489 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -42,6 +42,11 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * `allow_tables_to_appear_in_same_query!` can now take more than 2 tables, and is the same
   as invoking it separately for every combination of those tables.
 
+* Added `sql_query`, a new API for dropping to raw SQL that is more pleasant to
+  use than `sql` for complete queries. The main difference from `sql` is that
+  you do not need to state the return type, and data is loaded from the query by
+  name rather than by index.
+
 ### Changed
 
 * The signatures of `QueryId`, `Column`, and `FromSqlRow` have all changed to
@@ -74,6 +79,11 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * Deprecated `enable_multi_table_joins` in favor of
   `allow_tables_to_appear_in_same_query!`
 
+* Deprecated `SqlLiteral#bind`. `sql` is intended for use with small fragments
+  of SQL, not complete queries. Writing bind parameters in raw SQL when you are
+  not writing the whole query is error-prone. Use `sql_query` if you need raw
+  SQL with bind parameters.
+
 ### Removed
 
 * `IntoInsertStatement` and `BatchInsertStatement` have been removed. It's
diff --git a/diesel/Cargo.toml b/diesel/Cargo.toml
index 6ae782e63..20b884593 100644
--- a/diesel/Cargo.toml
+++ b/diesel/Cargo.toml
@@ -33,7 +33,7 @@ bitflags = { version = "0.9", optional = true }
 
 [dev-dependencies]
 cfg-if = "0.1.0"
-diesel_codegen = "0.13.0"
+diesel_codegen = "0.16.0"
 dotenv = ">=0.8, <0.11"
 quickcheck = "0.3.1"
 tempdir = "^0.3.4"
diff --git a/diesel/src/connection/mod.rs b/diesel/src/connection/mod.rs
index a5730557c..a7b1d9c08 100644
--- a/diesel/src/connection/mod.rs
+++ b/diesel/src/connection/mod.rs
@@ -3,7 +3,7 @@ mod transaction_manager;
 
 use backend::Backend;
 use query_builder::{AsQuery, QueryFragment, QueryId};
-use query_source::Queryable;
+use query_source::{Queryable, QueryableByName};
 use result::*;
 use types::HasSqlType;
 
@@ -145,6 +145,12 @@ pub trait Connection: SimpleConnection + Sized + Send {
         Self::Backend: HasSqlType<T::SqlType>,
         U: Queryable<T::SqlType, Self::Backend>;
 
+    #[doc(hidden)]
+    fn query_by_name<T, U>(&self, source: &T) -> QueryResult<Vec<U>>
+    where
+        T: QueryFragment<Self::Backend> + QueryId,
+        U: QueryableByName<Self::Backend>;
+
     #[doc(hidden)]
     fn execute_returning_count<T>(&self, source: &T) -> QueryResult<usize>
     where
diff --git a/diesel/src/expression/sql_literal.rs b/diesel/src/expression/sql_literal.rs
index 1c9af96b4..eb4e493da 100644
--- a/diesel/src/expression/sql_literal.rs
+++ b/diesel/src/expression/sql_literal.rs
@@ -4,6 +4,7 @@ use backend::Backend;
 use expression::*;
 use query_builder::*;
 use result::QueryResult;
+#[cfg(feature = "with-deprecated")]
 use super::unchecked_bind::UncheckedBind;
 use types::HasSqlType;
 
@@ -99,6 +100,8 @@ impl<ST> SqlLiteral<ST> {
     /// assert_eq!(Ok(expected), query.load(&connection));
     /// # }
     /// ```
+    #[deprecated(since = "0.99.0", note = "use `sql_query` if you need bind parameters")]
+    #[cfg(feature = "with-deprecated")]
     pub fn bind<BindST, T>(self, bind_value: T) -> UncheckedBind<Self, T, BindST> {
         UncheckedBind::new(self, bind_value)
     }
@@ -137,11 +140,9 @@ impl<ST> NonAggregate for SqlLiteral<ST> {}
 /// DSL. You will need to provide the SQL type of the expression, in addition to
 /// the SQL.
 ///
-/// # Bound parameters
-///
-/// If you need to pass arguments to your query, you should use [`.bind()`].
-///
-/// [`.bind()`]: ../sql_literal/struct.SqlLiteral.html#method.bind
+/// This function is intended for use when you need a small bit of raw SQL in
+/// your query. If you want to write the entire query using raw SQL, use
+/// [`sql_query`](../fn.sql_query.html) instead.
 ///
 /// # Safety
 ///
diff --git a/diesel/src/expression/unchecked_bind.rs b/diesel/src/expression/unchecked_bind.rs
index a3070a718..2cbbb31f4 100644
--- a/diesel/src/expression/unchecked_bind.rs
+++ b/diesel/src/expression/unchecked_bind.rs
@@ -1,3 +1,5 @@
+#![cfg(feature = "with-deprecated")]
+
 use std::marker::PhantomData;
 
 use backend::Backend;
diff --git a/diesel/src/lib.rs b/diesel/src/lib.rs
index cc6440ae7..4a2e8013f 100644
--- a/diesel/src/lib.rs
+++ b/diesel/src/lib.rs
@@ -173,7 +173,7 @@ pub use prelude::*;
 #[doc(inline)]
 pub use query_builder::debug_query;
 #[doc(inline)]
-pub use query_builder::functions::{delete, insert_into, replace_into, select, update};
+pub use query_builder::functions::{delete, insert_into, replace_into, select, sql_query, update};
 #[cfg(feature = "with-deprecated")]
 #[doc(inline)]
 #[allow(deprecated)]
diff --git a/diesel/src/mysql/connection/bind.rs b/diesel/src/mysql/connection/bind.rs
index d0fd13558..663eb1384 100644
--- a/diesel/src/mysql/connection/bind.rs
+++ b/diesel/src/mysql/connection/bind.rs
@@ -34,6 +34,16 @@ impl Binds {
         Binds { data: data }
     }
 
+    pub fn from_result_metadata(fields: &[ffi::MYSQL_FIELD]) -> Self {
+        let data = fields
+            .iter()
+            .map(|field| field.type_)
+            .map(BindData::for_output)
+            .collect();
+
+        Binds { data }
+    }
+
     pub fn with_mysql_binds<F, T>(&mut self, f: F) -> T
     where
         F: FnOnce(*mut ffi::MYSQL_BIND) -> T,
diff --git a/diesel/src/mysql/connection/mod.rs b/diesel/src/mysql/connection/mod.rs
index 678e70f35..5faaccbaa 100644
--- a/diesel/src/mysql/connection/mod.rs
+++ b/diesel/src/mysql/connection/mod.rs
@@ -6,7 +6,7 @@ mod url;
 use connection::*;
 use query_builder::*;
 use query_builder::bind_collector::RawBytesBindCollector;
-use query_source::Queryable;
+use query_source::{Queryable, QueryableByName};
 use result::*;
 use self::raw::RawConnection;
 use self::stmt::Statement;
@@ -80,6 +80,19 @@ impl Connection for MysqlConnection {
         })
     }
 
+    #[doc(hidden)]
+    fn query_by_name<T, U>(&self, source: &T) -> QueryResult<Vec<U>>
+    where
+        T: QueryFragment<Self::Backend> + QueryId,
+        U: QueryableByName<Self::Backend>,
+    {
+        use result::Error::DeserializationError;
+
+        let mut stmt = try!(self.prepare_query(source));
+        let results = unsafe { stmt.named_results()? };
+        results.map(|row| U::build(&row).map_err(DeserializationError))
+    }
+
     #[doc(hidden)]
     fn execute_returning_count<T>(&self, source: &T) -> QueryResult<usize>
     where
diff --git a/diesel/src/mysql/connection/stmt/iterator.rs b/diesel/src/mysql/connection/stmt/iterator.rs
index 3718adbb5..bf4883f9d 100644
--- a/diesel/src/mysql/connection/stmt/iterator.rs
+++ b/diesel/src/mysql/connection/stmt/iterator.rs
@@ -1,6 +1,8 @@
-use super::{ffi, libc, Binds, Statement};
+use std::collections::HashMap;
+
+use super::{ffi, libc, Binds, Statement, StatementMetadata};
 use result::QueryResult;
-use row::Row;
+use row::*;
 use mysql::{Mysql, MysqlType};
 
 pub struct StatementIterator<'a> {
@@ -13,10 +15,7 @@ impl<'a> StatementIterator<'a> {
     pub fn new(stmt: &'a mut Statement, types: Vec<MysqlType>) -> QueryResult<Self> {
         let mut output_binds = Binds::from_output_types(types);
 
-        unsafe {
-            output_binds.with_mysql_binds(|bind_ptr| stmt.bind_result(bind_ptr))?;
-            stmt.execute()?;
-        }
+        execute_statement(stmt, &mut output_binds)?;
 
         Ok(StatementIterator {
             stmt: stmt,
@@ -36,25 +35,14 @@ impl<'a> StatementIterator<'a> {
     }
 
     fn next(&mut self) -> Option<QueryResult<MysqlRow>> {
-        let next_row_result = unsafe { ffi::mysql_stmt_fetch(self.stmt.stmt) };
-        match next_row_result as libc::c_uint {
-            ffi::MYSQL_NO_DATA => return None,
-            ffi::MYSQL_DATA_TRUNCATED => {
-                let res = self.output_binds.populate_dynamic_buffers(self.stmt);
-                if let Err(e) = res {
-                    return Some(Err(e));
-                }
-            }
-            0 => self.output_binds.update_buffer_lengths(),
-            _error => if let Err(e) = self.stmt.did_an_error_occur() {
-                return Some(Err(e));
-            },
+        match populate_row_buffers(self.stmt, &mut self.output_binds) {
+            Ok(Some(())) => Some(Ok(MysqlRow {
+                col_idx: 0,
+                binds: &mut self.output_binds,
+            })),
+            Ok(None) => None,
+            Err(e) => Some(Err(e)),
         }
-
-        Some(Ok(MysqlRow {
-            col_idx: 0,
-            binds: &mut self.output_binds,
-        }))
     }
 }
 
@@ -74,3 +62,83 @@ impl<'a> Row<Mysql> for MysqlRow<'a> {
         (0..count).all(|i| self.binds.field_data(self.col_idx + i).is_none())
     }
 }
+
+pub struct NamedStatementIterator<'a> {
+    stmt: &'a mut Statement,
+    output_binds: Binds,
+    metadata: StatementMetadata,
+}
+
+#[cfg_attr(feature = "clippy", allow(should_implement_trait))] // don't need `Iterator` here
+impl<'a> NamedStatementIterator<'a> {
+    pub fn new(stmt: &'a mut Statement) -> QueryResult<Self> {
+        let metadata = stmt.metadata()?;
+        let mut output_binds = Binds::from_result_metadata(metadata.fields());
+
+        execute_statement(stmt, &mut output_binds)?;
+
+        Ok(NamedStatementIterator {
+            stmt,
+            output_binds,
+            metadata,
+        })
+    }
+
+    pub fn map<F, T>(mut self, mut f: F) -> QueryResult<Vec<T>>
+    where
+        F: FnMut(NamedMysqlRow) -> QueryResult<T>,
+    {
+        let mut results = Vec::new();
+        while let Some(row) = self.next() {
+            results.push(f(row?)?);
+        }
+        Ok(results)
+    }
+
+    fn next(&mut self) -> Option<QueryResult<NamedMysqlRow>> {
+        match populate_row_buffers(self.stmt, &mut self.output_binds) {
+            Ok(Some(())) => Some(Ok(NamedMysqlRow {
+                binds: &self.output_binds,
+                column_indices: self.metadata.column_indices(),
+            })),
+            Ok(None) => None,
+            Err(e) => Some(Err(e)),
+        }
+    }
+}
+
+pub struct NamedMysqlRow<'a> {
+    binds: &'a Binds,
+    column_indices: &'a HashMap<&'a str, usize>,
+}
+
+impl<'a> NamedRow<Mysql> for NamedMysqlRow<'a> {
+    fn index_of(&self, column_name: &str) -> Option<usize> {
+        self.column_indices.get(column_name).cloned()
+    }
+
+    fn get_raw_value(&self, idx: usize) -> Option<&[u8]> {
+        self.binds.field_data(idx)
+    }
+}
+
+fn execute_statement(stmt: &mut Statement, binds: &mut Binds) -> QueryResult<()> {
+    unsafe {
+        binds.with_mysql_binds(|bind_ptr| stmt.bind_result(bind_ptr))?;
+        stmt.execute()?;
+    }
+    Ok(())
+}
+
+fn populate_row_buffers(stmt: &Statement, binds: &mut Binds) -> QueryResult<Option<()>> {
+    let next_row_result = unsafe { ffi::mysql_stmt_fetch(stmt.stmt) };
+    match next_row_result as libc::c_uint {
+        ffi::MYSQL_NO_DATA => Ok(None),
+        ffi::MYSQL_DATA_TRUNCATED => binds.populate_dynamic_buffers(stmt).map(Some),
+        0 => {
+            binds.update_buffer_lengths();
+            Ok(Some(()))
+        }
+        _error => stmt.did_an_error_occur().map(Some),
+    }
+}
diff --git a/diesel/src/mysql/connection/stmt/metadata.rs b/diesel/src/mysql/connection/stmt/metadata.rs
new file mode 100644
index 000000000..b707d471b
--- /dev/null
+++ b/diesel/src/mysql/connection/stmt/metadata.rs
@@ -0,0 +1,51 @@
+use std::collections::HashMap;
+use std::ffi::CStr;
+use std::slice;
+
+use super::ffi;
+
+pub struct StatementMetadata {
+    result: &'static mut ffi::MYSQL_RES,
+    column_indices: HashMap<&'static str, usize>,
+}
+
+impl StatementMetadata {
+    pub fn new(result: &'static mut ffi::MYSQL_RES) -> Self {
+        let mut res = StatementMetadata {
+            column_indices: HashMap::new(),
+            result,
+        };
+        res.populate_column_indices();
+        res
+    }
+
+    pub fn fields(&self) -> &[ffi::MYSQL_FIELD] {
+        unsafe {
+            let ptr = self.result as *const _ as *mut _;
+            let num_fields = ffi::mysql_num_fields(ptr);
+            let field_ptr = ffi::mysql_fetch_fields(ptr);
+            slice::from_raw_parts(field_ptr, num_fields as usize)
+        }
+    }
+
+    pub fn column_indices(&self) -> &HashMap<&str, usize> {
+        &self.column_indices
+    }
+
+    fn populate_column_indices(&mut self) {
+        self.column_indices = self.fields()
+            .iter()
+            .enumerate()
+            .map(|(i, field)| {
+                let c_name = unsafe { CStr::from_ptr(field.name) };
+                (c_name.to_str().unwrap_or_default(), i)
+            })
+            .collect()
+    }
+}
+
+impl Drop for StatementMetadata {
+    fn drop(&mut self) {
+        unsafe { ffi::mysql_free_result(self.result) };
+    }
+}
diff --git a/diesel/src/mysql/connection/stmt/mod.rs b/diesel/src/mysql/connection/stmt/mod.rs
index 973d41d36..b35b0d674 100644
--- a/diesel/src/mysql/connection/stmt/mod.rs
+++ b/diesel/src/mysql/connection/stmt/mod.rs
@@ -1,13 +1,15 @@
 extern crate mysqlclient_sys as ffi;
 
 mod iterator;
+mod metadata;
 
 use std::os::raw as libc;
 use std::ffi::CStr;
 
 use mysql::MysqlType;
 use result::{DatabaseErrorKind, QueryResult};
-use self::iterator::StatementIterator;
+use self::iterator::*;
+use self::metadata::*;
 use super::bind::Binds;
 
 pub struct Statement {
@@ -73,6 +75,14 @@ impl Statement {
         StatementIterator::new(self, types)
     }
 
+    /// This function should be called instead of `execute` for queries which
+    /// have a return value. After calling this function, `execute` can never
+    /// be called on this statement.
+    pub unsafe fn named_results(&mut self) -> QueryResult<NamedStatementIterator> {
+        NamedStatementIterator::new(self)
+    }
+
+
     fn last_error_message(&self) -> String {
         unsafe { CStr::from_ptr(ffi::mysql_stmt_error(self.stmt)) }
             .to_string_lossy()
@@ -101,6 +111,16 @@ impl Statement {
         self.did_an_error_occur()
     }
 
+    fn metadata(&self) -> QueryResult<StatementMetadata> {
+        use result::Error::DeserializationError;
+
+        let result_ptr = unsafe { ffi::mysql_stmt_result_metadata(self.stmt).as_mut() };
+        self.did_an_error_occur()?;
+        result_ptr
+            .map(StatementMetadata::new)
+            .ok_or_else(|| DeserializationError("No metadata exists".into()))
+    }
+
     fn did_an_error_occur(&self) -> QueryResult<()> {
         use result::Error::DatabaseError;
 
diff --git a/diesel/src/pg/connection/cursor.rs b/diesel/src/pg/connection/cursor.rs
index de4902db9..06008be45 100644
--- a/diesel/src/pg/connection/cursor.rs
+++ b/diesel/src/pg/connection/cursor.rs
@@ -1,8 +1,9 @@
 use pg::Pg;
-use query_source::Queryable;
-use result::QueryResult;
+use query_source::{Queryable, QueryableByName};
 use result::Error::DeserializationError;
+use result::QueryResult;
 use super::result::PgResult;
+use super::row::PgNamedRow;
 use types::{FromSqlRow, HasSqlType};
 
 use std::marker::PhantomData;
@@ -46,3 +47,35 @@ where
         }
     }
 }
+
+pub struct NamedCursor {
+    db_result: PgResult,
+}
+
+impl NamedCursor {
+    pub fn new(db_result: PgResult) -> Self {
+        NamedCursor { db_result }
+    }
+
+    pub fn collect<T>(self) -> QueryResult<Vec<T>>
+    where
+        T: QueryableByName<Pg>,
+    {
+        use result::Error::DeserializationError;
+
+        (0..self.db_result.num_rows())
+            .map(|i| {
+                let row = PgNamedRow::new(&self, i);
+                T::build(&row).map_err(DeserializationError)
+            })
+            .collect()
+    }
+
+    pub fn index_of_column(&self, column_name: &str) -> Option<usize> {
+        self.db_result.field_number(column_name)
+    }
+
+    pub fn get_value(&self, row: usize, column: usize) -> Option<&[u8]> {
+        self.db_result.get(row, column)
+    }
+}
diff --git a/diesel/src/pg/connection/mod.rs b/diesel/src/pg/connection/mod.rs
index 2963ab1bd..55e9d6453 100644
--- a/diesel/src/pg/connection/mod.rs
+++ b/diesel/src/pg/connection/mod.rs
@@ -12,10 +12,10 @@ use connection::*;
 use pg::{Pg, PgMetadataLookup};
 use query_builder::*;
 use query_builder::bind_collector::RawBytesBindCollector;
-use query_source::Queryable;
+use query_source::{Queryable, QueryableByName};
 use result::*;
 use result::ConnectionError::CouldntSetupConfiguration;
-use self::cursor::Cursor;
+use self::cursor::*;
 use self::raw::RawConnection;
 use self::result::PgResult;
 use self::stmt::Statement;
@@ -77,6 +77,19 @@ impl Connection for PgConnection {
             .and_then(|r| Cursor::new(r).collect())
     }
 
+    #[doc(hidden)]
+    #[doc(hidden)]
+    fn query_by_name<T, U>(&self, source: &T) -> QueryResult<Vec<U>>
+    where
+        T: QueryFragment<Pg> + QueryId,
+        U: QueryableByName<Pg>,
+    {
+        let (query, params) = try!(self.prepare_query(source));
+        query
+            .execute(&self.raw_connection, &params)
+            .and_then(|r| NamedCursor::new(r).collect())
+    }
+
     #[doc(hidden)]
     fn execute_returning_count<T>(&self, source: &T) -> QueryResult<usize>
     where
diff --git a/diesel/src/pg/connection/result.rs b/diesel/src/pg/connection/result.rs
index c1d360bfd..785a80caa 100644
--- a/diesel/src/pg/connection/result.rs
+++ b/diesel/src/pg/connection/result.rs
@@ -1,7 +1,7 @@
 extern crate pq_sys;
 
 use self::pq_sys::*;
-use std::ffi::CStr;
+use std::ffi::{CStr, CString};
 use std::os::raw as libc;
 use std::{slice, str};
 
@@ -91,6 +91,15 @@ impl PgResult {
                 )
         }
     }
+
+    pub fn field_number(&self, column_name: &str) -> Option<usize> {
+        let cstr = CString::new(column_name).unwrap_or_default();
+        let fnum = unsafe { PQfnumber(self.internal_result.as_ptr(), cstr.as_ptr()) };
+        match fnum {
+            -1 => None,
+            x => Some(x as usize),
+        }
+    }
 }
 
 struct PgErrorInformation(RawResult);
diff --git a/diesel/src/pg/connection/row.rs b/diesel/src/pg/connection/row.rs
index fafb2c8d4..627214472 100644
--- a/diesel/src/pg/connection/row.rs
+++ b/diesel/src/pg/connection/row.rs
@@ -1,6 +1,7 @@
 use pg::Pg;
-use row::Row;
+use row::*;
 use super::result::PgResult;
+use super::cursor::NamedCursor;
 
 pub struct PgRow<'a> {
     db_result: &'a PgResult,
@@ -29,3 +30,24 @@ impl<'a> Row<Pg> for PgRow<'a> {
         (0..count).all(|i| self.db_result.is_null(self.row_idx, self.col_idx + i))
     }
 }
+
+pub struct PgNamedRow<'a> {
+    cursor: &'a NamedCursor,
+    idx: usize,
+}
+
+impl<'a> PgNamedRow<'a> {
+    pub fn new(cursor: &'a NamedCursor, idx: usize) -> Self {
+        PgNamedRow { cursor, idx }
+    }
+}
+
+impl<'a> NamedRow<Pg> for PgNamedRow<'a> {
+    fn get_raw_value(&self, index: usize) -> Option<&[u8]> {
+        self.cursor.get_value(self.idx, index)
+    }
+
+    fn index_of(&self, column_name: &str) -> Option<usize> {
+        self.cursor.index_of_column(column_name)
+    }
+}
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index bd2058e06..06724eb5b 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -6,7 +6,7 @@ use super::delete_statement::DeleteStatement;
 use super::insert_statement::{DefaultValues, DeprecatedIncompleteInsertStatement};
 use super::insert_statement::{Insert, Replace};
 use super::{IncompleteInsertStatement, IncompleteUpdateStatement, IntoUpdateTarget,
-            SelectStatement};
+            SelectStatement, SqlQuery};
 
 /// Creates an update statement. Helpers for updating a single row can be
 /// generated by deriving [`AsChangeset`](query_builder/trait.AsChangeset.html)
@@ -534,3 +534,51 @@ pub fn insert_default_values() -> DeprecatedIncompleteInsertStatement<&'static D
 pub fn replace_into<T>(target: T) -> IncompleteInsertStatement<T, Replace> {
     IncompleteInsertStatement::new(target, Replace)
 }
+
+/// Construct a full SQL query using raw SQL.
+///
+/// This function exists for cases where a query needs to be written that is not
+/// supported by the query builder. Unlike most queries in Diesel, `sql_query`
+/// will deserialize its data by name, not by index. That means that you cannot
+/// deserialize into a tuple, and structs which you deserialize from this
+/// function will need to have `#[derive(QueryableByName)]`
+///
+/// # Safety
+///
+/// The implementation of `QueryableByName` will assume that columns with a
+/// given name will have a certain type. The compiler will be unable to verify
+/// that the given type is correct. If your query returns a column of an
+/// unexpected type, the result may have the wrong value, or return an error.
+///
+/// # Example
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # #[macro_use] extern crate diesel_codegen;
+/// # include!("../doctest_setup.rs");
+/// #
+/// # use schema::users;
+/// #
+/// # #[derive(QueryableByName, Debug, PartialEq)]
+/// # #[table_name="users"]
+/// # struct User {
+/// #     id: i32,
+/// #     name: String,
+/// # }
+/// #
+/// # fn main() {
+/// #     use diesel::sql_query;
+/// #
+/// #     let connection = establish_connection();
+/// let users = sql_query("SELECT * FROM users ORDER BY id")
+///     .load(&connection);
+/// let expected_users = vec![
+///     User { id: 1, name: "Sean".into() },
+///     User { id: 2, name: "Tess".into() },
+/// ];
+/// assert_eq!(Ok(expected_users), users);
+/// # }
+/// ```
+pub fn sql_query<T: Into<String>>(query: T) -> SqlQuery {
+    SqlQuery::new(query.into())
+}
diff --git a/diesel/src/query_builder/mod.rs b/diesel/src/query_builder/mod.rs
index 3706ff478..289b2832b 100644
--- a/diesel/src/query_builder/mod.rs
+++ b/diesel/src/query_builder/mod.rs
@@ -26,6 +26,7 @@ mod order_clause;
 mod returning_clause;
 mod select_clause;
 mod select_statement;
+mod sql_query;
 pub mod where_clause;
 pub mod insert_statement;
 mod update_statement;
@@ -39,6 +40,7 @@ pub use self::insert_statement::IncompleteInsertStatement;
 pub use self::query_id::QueryId;
 #[doc(hidden)]
 pub use self::select_statement::{BoxedSelectStatement, SelectStatement};
+pub use self::sql_query::SqlQuery;
 #[doc(inline)]
 pub use self::update_statement::{AsChangeset, Changeset, IncompleteUpdateStatement,
                                  IntoUpdateTarget, UpdateStatement, UpdateTarget};
diff --git a/diesel/src/query_builder/sql_query.rs b/diesel/src/query_builder/sql_query.rs
new file mode 100644
index 000000000..4e664976e
--- /dev/null
+++ b/diesel/src/query_builder/sql_query.rs
@@ -0,0 +1,162 @@
+use std::marker::PhantomData;
+
+use backend::Backend;
+use connection::Connection;
+use load_dsl::*;
+use query_builder::{AstPass, QueryFragment, QueryId};
+use query_source::QueryableByName;
+use result::QueryResult;
+use types::{HasSqlType, ToSql};
+
+#[derive(Debug, Clone)]
+#[must_use = "Queries are only executed when calling `load`, `get_result` or similar."]
+/// The return value of `sql_query`.
+///
+/// Unlike most queries in Diesel, `SqlQuery` loads its data by column name,
+/// rather than by index. This means that you cannot deserialize this query into
+/// a tuple, and any structs used must implement `QueryableByName`.
+///
+/// See [`sql_query`](../fn.sql_query.html) for examples.
+pub struct SqlQuery {
+    query: String,
+}
+
+impl SqlQuery {
+    pub(crate) fn new(query: String) -> Self {
+        SqlQuery { query }
+    }
+
+    /// Bind a value for use with this SQL query.
+    ///
+    /// # Safety
+    ///
+    /// This function should be used with care, as Diesel cannot validate that
+    /// the value is of the right type nor can it validate that you have passed
+    /// the correct number of parameters.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # #[macro_use] extern crate diesel;
+    /// # #[macro_use] extern crate diesel_codegen;
+    /// # include!("../doctest_setup.rs");
+    /// #
+    /// # use schema::users;
+    /// #
+    /// # #[derive(QueryableByName, Debug, PartialEq)]
+    /// # #[table_name="users"]
+    /// # struct User {
+    /// #     id: i32,
+    /// #     name: String,
+    /// # }
+    /// #
+    /// # fn main() {
+    /// #     use diesel::sql_query;
+    /// #     use diesel::types::{Integer, Text};
+    /// #
+    /// #     let connection = establish_connection();
+    /// #     diesel::insert_into(users::table)
+    /// #         .values(&NewUser::new("Jim"))
+    /// #         .execute(&connection).unwrap();
+    /// # #[cfg(feature = "postgres")]
+    /// # let users = sql_query("SELECT * FROM users WHERE id > $1 AND name != $2");
+    /// # #[cfg(not(feature = "postgres"))]
+    /// let users = sql_query("SELECT * FROM users WHERE id > ? AND name <> ?")
+    /// # ;
+    /// # let users = users
+    ///     .bind::<Integer, _>(1)
+    ///     .bind::<Text, _>("Tess")
+    ///     .get_results(&connection);
+    /// let expected_users = vec![
+    ///     User { id: 3, name: "Jim".into() },
+    /// ];
+    /// assert_eq!(Ok(expected_users), users);
+    /// # }
+    /// ```
+    pub fn bind<ST, Value>(self, value: Value) -> UncheckedBind<Self, Value, ST> {
+        UncheckedBind::new(self, value)
+    }
+}
+
+impl_query_id!(noop: SqlQuery);
+
+impl<DB> QueryFragment<DB> for SqlQuery
+where
+    DB: Backend,
+{
+    fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
+        out.unsafe_to_cache_prepared();
+        out.push_sql(&self.query);
+        Ok(())
+    }
+}
+
+impl<Conn, T> LoadQuery<Conn, T> for SqlQuery
+where
+    Conn: Connection,
+    T: QueryableByName<Conn::Backend>,
+{
+    fn internal_load(self, conn: &Conn) -> QueryResult<Vec<T>> {
+        conn.query_by_name(&self)
+    }
+}
+
+impl<Conn> LoadDsl<Conn> for SqlQuery {}
+
+#[derive(Debug, Clone, Copy)]
+#[must_use = "Queries are only executed when calling `load`, `get_result` or similar."]
+pub struct UncheckedBind<Query, Value, ST> {
+    query: Query,
+    value: Value,
+    _marker: PhantomData<ST>,
+}
+
+impl<Query, Value, ST> UncheckedBind<Query, Value, ST> {
+    pub fn new(query: Query, value: Value) -> Self {
+        UncheckedBind {
+            query,
+            value,
+            _marker: PhantomData,
+        }
+    }
+
+    pub fn bind<ST2, Value2>(self, value: Value2) -> UncheckedBind<Self, Value2, ST2> {
+        UncheckedBind::new(self, value)
+    }
+}
+
+impl<Query, Value, ST> QueryId for UncheckedBind<Query, Value, ST>
+where
+    Query: QueryId,
+    ST: QueryId,
+{
+    type QueryId = UncheckedBind<Query::QueryId, (), ST::QueryId>;
+
+    const HAS_STATIC_QUERY_ID: bool = Query::HAS_STATIC_QUERY_ID && ST::HAS_STATIC_QUERY_ID;
+}
+
+impl<Query, Value, ST, DB> QueryFragment<DB> for UncheckedBind<Query, Value, ST>
+where
+    DB: Backend + HasSqlType<ST>,
+    Query: QueryFragment<DB>,
+    Value: ToSql<ST, DB>,
+{
+    fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
+        self.query.walk_ast(out.reborrow())?;
+        out.push_bind_param_value_only(&self.value)?;
+        Ok(())
+    }
+}
+
+impl<Conn, Query, Value, ST, T> LoadQuery<Conn, T> for UncheckedBind<Query, Value, ST>
+where
+    Conn: Connection,
+    T: QueryableByName<Conn::Backend>,
+    Self: QueryFragment<Conn::Backend> + QueryId,
+{
+    fn internal_load(self, conn: &Conn) -> QueryResult<Vec<T>> {
+        conn.query_by_name(&self)
+    }
+}
+
+impl<Conn, Query, Value, ST> LoadDsl<Conn> for UncheckedBind<Query, Value, ST> {}
diff --git a/diesel/src/query_source/mod.rs b/diesel/src/query_source/mod.rs
index 577e4f591..864e2d928 100644
--- a/diesel/src/query_source/mod.rs
+++ b/diesel/src/query_source/mod.rs
@@ -5,9 +5,12 @@
 pub mod joins;
 mod peano_numbers;
 
+use std::error::Error;
+
 use backend::Backend;
 use expression::{Expression, NonAggregate, SelectableExpression};
 use query_builder::*;
+use row::NamedRow;
 use types::{FromSqlRow, HasSqlType};
 
 pub use self::joins::JoinTo;
@@ -25,6 +28,33 @@ where
     fn build(row: Self::Row) -> Self;
 }
 
+/// Deserializes the result of a query constructed with [`sql_query`].
+///
+/// # Deriving
+///
+/// This trait can be automatically derived by `diesel_codegen`. To derive this
+/// trait, the struct must be associated with a single table. If the table name
+/// is different than `"struct_name" + "s"`, you can annotate your struct with
+/// `#[table_name = "some_table"]`.
+///
+/// The module for that table must be in scope. For example, to derive this for
+/// a struct called `User`, you will likely need a line such as `use
+/// schema::users;`
+///
+/// If the name of a field on your struct is different than the column in your
+/// `table!` declaration, or if you are deriving this trait on a tuple struct,
+/// you can annotate the field with `#[column_name = "some_column"]`. For tuple
+/// structs, all fields must have this annotation.
+///
+/// [`sql_query`]: ../fn.sql_query.html
+pub trait QueryableByName<DB>
+where
+    Self: Sized,
+    DB: Backend,
+{
+    fn build<R: NamedRow<DB>>(row: &R) -> Result<Self, Box<Error + Send + Sync>>;
+}
+
 #[doc(hidden)]
 pub trait QuerySource {
     type FromClause;
diff --git a/diesel/src/row.rs b/diesel/src/row.rs
index 3a56eb044..327b00e88 100644
--- a/diesel/src/row.rs
+++ b/diesel/src/row.rs
@@ -1,6 +1,9 @@
 //! Contains the `Row` trait
 
+use std::error::Error;
+
 use backend::Backend;
+use types::{FromSql, HasSqlType};
 
 /// The row trait which is used for [`FromSqlRow`][]. Apps should not need to
 /// concern themselves with this trait.
@@ -25,3 +28,40 @@ pub trait Row<DB: Backend> {
         }
     }
 }
+
+/// Represents a row of a SQL query, where the values are accessed by name
+/// rather than by index.
+///
+/// This trait is used by implementations of
+/// [`QueryableByName`](../query_source/trait.QueryableByName.html)
+pub trait NamedRow<DB: Backend> {
+    /// Retreive and deserialize a single value from the query
+    ///
+    /// Note that `ST` *must* be the exact type of the value with that name in
+    /// the query. The compiler will not be able to verify that you have
+    /// provided the correct type. If there is a mismatch, you may receive an
+    /// incorrect value, or a runtime error.
+    ///
+    /// If two or more fields in the query have the given name, the result of
+    /// this function is undefined.
+    fn get<ST, T>(&self, column_name: &str) -> Result<T, Box<Error + Send + Sync>>
+    where
+        DB: HasSqlType<ST>,
+        T: FromSql<ST, DB>,
+    {
+        let idx = self.index_of(column_name).ok_or_else(|| {
+            format!("Column `{}` was not present in query", column_name).into()
+        });
+        let idx = match idx {
+            Ok(x) => x,
+            Err(e) => return Err(e),
+        };
+        let raw_value = self.get_raw_value(idx);
+        T::from_sql(raw_value)
+    }
+
+    #[doc(hidden)]
+    fn index_of(&self, column_name: &str) -> Option<usize>;
+    #[doc(hidden)]
+    fn get_raw_value(&self, index: usize) -> Option<&DB::RawValue>;
+}
diff --git a/diesel/src/sqlite/connection/mod.rs b/diesel/src/sqlite/connection/mod.rs
index 7fafe287f..b4561a147 100644
--- a/diesel/src/sqlite/connection/mod.rs
+++ b/diesel/src/sqlite/connection/mod.rs
@@ -17,7 +17,7 @@ use query_builder::bind_collector::RawBytesBindCollector;
 use query_source::*;
 use result::*;
 use self::raw::RawConnection;
-use self::statement_iterator::StatementIterator;
+use self::statement_iterator::*;
 use self::stmt::{Statement, StatementUse};
 use sqlite::Sqlite;
 use types::HasSqlType;
@@ -74,6 +74,18 @@ impl Connection for SqliteConnection {
         iter.collect()
     }
 
+    #[doc(hidden)]
+    fn query_by_name<T, U>(&self, source: &T) -> QueryResult<Vec<U>>
+    where
+        T: QueryFragment<Self::Backend> + QueryId,
+        U: QueryableByName<Self::Backend>,
+    {
+        let mut statement = try!(self.prepare_query(source));
+        let statement_use = StatementUse::new(&mut statement);
+        let iter = NamedStatementIterator::new(statement_use)?;
+        iter.collect()
+    }
+
     #[doc(hidden)]
     fn execute_returning_count<T>(&self, source: &T) -> QueryResult<usize>
     where
diff --git a/diesel/src/sqlite/connection/sqlite_value.rs b/diesel/src/sqlite/connection/sqlite_value.rs
index 631d67f52..8e2caa6f1 100644
--- a/diesel/src/sqlite/connection/sqlite_value.rs
+++ b/diesel/src/sqlite/connection/sqlite_value.rs
@@ -1,15 +1,17 @@
 extern crate libsqlite3_sys as ffi;
 
+use std::cell::Cell;
+use std::collections::HashMap;
 use std::os::raw as libc;
 use std::{slice, str};
 
 use sqlite::Sqlite;
-use row::Row;
+use row::*;
 
 #[allow(missing_debug_implementations, missing_copy_implementations)]
 pub struct SqliteValue {
     inner_statement: *mut ffi::sqlite3_stmt,
-    col_index: libc::c_int,
+    col_index: Cell<libc::c_int>,
 }
 
 pub struct SqliteRow {
@@ -21,14 +23,14 @@ impl SqliteValue {
     pub fn new(inner_statement: *mut ffi::sqlite3_stmt) -> Self {
         SqliteValue {
             inner_statement: inner_statement,
-            col_index: 0,
+            col_index: Cell::new(0),
         }
     }
 
     pub fn read_text(&self) -> &str {
         unsafe {
-            let ptr = ffi::sqlite3_column_text(self.inner_statement, self.col_index);
-            let len = ffi::sqlite3_column_bytes(self.inner_statement, self.col_index);
+            let ptr = ffi::sqlite3_column_text(self.inner_statement, self.col_index.get());
+            let len = ffi::sqlite3_column_bytes(self.inner_statement, self.col_index.get());
             let bytes = slice::from_raw_parts(ptr as *const u8, len as usize);
             str::from_utf8_unchecked(bytes)
         }
@@ -36,22 +38,27 @@ impl SqliteValue {
 
     pub fn read_blob(&self) -> &[u8] {
         unsafe {
-            let ptr = ffi::sqlite3_column_blob(self.inner_statement, self.col_index);
-            let len = ffi::sqlite3_column_bytes(self.inner_statement, self.col_index);
+            let ptr = ffi::sqlite3_column_blob(self.inner_statement, self.col_index.get());
+            let len = ffi::sqlite3_column_bytes(self.inner_statement, self.col_index.get());
             slice::from_raw_parts(ptr as *const u8, len as usize)
         }
     }
 
     pub fn read_integer(&self) -> i32 {
-        unsafe { ffi::sqlite3_column_int(self.inner_statement, self.col_index) as i32 }
+        unsafe { ffi::sqlite3_column_int(self.inner_statement, self.col_index.get()) as i32 }
     }
 
     pub fn read_long(&self) -> i64 {
-        unsafe { ffi::sqlite3_column_int64(self.inner_statement, self.col_index) as i64 }
+        unsafe { ffi::sqlite3_column_int64(self.inner_statement, self.col_index.get()) as i64 }
     }
 
     pub fn read_double(&self) -> f64 {
-        unsafe { ffi::sqlite3_column_double(self.inner_statement, self.col_index) as f64 }
+        unsafe { ffi::sqlite3_column_double(self.inner_statement, self.col_index.get()) as f64 }
+    }
+
+    pub fn is_null(&self) -> bool {
+        let tpe = unsafe { ffi::sqlite3_column_type(self.inner_statement, self.col_index.get()) };
+        tpe == ffi::SQLITE_NULL
     }
 }
 
@@ -62,12 +69,19 @@ impl SqliteRow {
             next_col_index: 0,
         }
     }
+
+    pub fn into_named<'a>(self, indices: &'a HashMap<&'a str, usize>) -> SqliteNamedRow<'a> {
+        SqliteNamedRow {
+            value: self.value,
+            column_indices: indices,
+        }
+    }
 }
 
 impl Row<Sqlite> for SqliteRow {
     fn take(&mut self) -> Option<&SqliteValue> {
         let is_null = self.next_is_null(1);
-        self.value.col_index = self.next_col_index;
+        self.value.col_index.set(self.next_col_index);
         self.next_col_index += 1;
         if is_null {
             None
@@ -84,3 +98,23 @@ impl Row<Sqlite> for SqliteRow {
         })
     }
 }
+
+pub struct SqliteNamedRow<'a> {
+    value: SqliteValue,
+    column_indices: &'a HashMap<&'a str, usize>,
+}
+
+impl<'a> NamedRow<Sqlite> for SqliteNamedRow<'a> {
+    fn index_of(&self, column_name: &str) -> Option<usize> {
+        self.column_indices.get(column_name).cloned()
+    }
+
+    fn get_raw_value(&self, idx: usize) -> Option<&SqliteValue> {
+        self.value.col_index.set(idx as libc::c_int);
+        if self.value.is_null() {
+            None
+        } else {
+            Some(&self.value)
+        }
+    }
+}
diff --git a/diesel/src/sqlite/connection/statement_iterator.rs b/diesel/src/sqlite/connection/statement_iterator.rs
index 507e2f321..a8ec6b92f 100644
--- a/diesel/src/sqlite/connection/statement_iterator.rs
+++ b/diesel/src/sqlite/connection/statement_iterator.rs
@@ -1,6 +1,7 @@
+use std::collections::HashMap;
 use std::marker::PhantomData;
 
-use query_source::Queryable;
+use query_source::{Queryable, QueryableByName};
 use result::Error::DeserializationError;
 use result::QueryResult;
 use sqlite::Sqlite;
@@ -36,3 +37,41 @@ where
         })
     }
 }
+
+pub struct NamedStatementIterator<'a, T> {
+    stmt: StatementUse<'a>,
+    column_indices: HashMap<&'a str, usize>,
+    _marker: PhantomData<T>,
+}
+
+impl<'a, T> NamedStatementIterator<'a, T> {
+    pub fn new(stmt: StatementUse<'a>) -> QueryResult<Self> {
+        let column_indices = (0..stmt.num_fields())
+            .filter_map(|i| {
+                stmt.field_name(i).map(|column| {
+                    let column = column.to_str().map_err(|e| DeserializationError(e.into()))?;
+                    Ok((column, i))
+                })
+            })
+            .collect::<QueryResult<_>>()?;
+        Ok(NamedStatementIterator {
+            stmt,
+            column_indices,
+            _marker: PhantomData,
+        })
+    }
+}
+
+impl<'a, T> Iterator for NamedStatementIterator<'a, T>
+where
+    T: QueryableByName<Sqlite>,
+{
+    type Item = QueryResult<T>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        self.stmt.step().map(|row| {
+            let row = row.into_named(&self.column_indices);
+            T::build(&row).map_err(DeserializationError)
+        })
+    }
+}
diff --git a/diesel/src/sqlite/connection/stmt.rs b/diesel/src/sqlite/connection/stmt.rs
index 8cec8ef8e..3948be815 100644
--- a/diesel/src/sqlite/connection/stmt.rs
+++ b/diesel/src/sqlite/connection/stmt.rs
@@ -1,6 +1,6 @@
 extern crate libsqlite3_sys as ffi;
 
-use std::ffi::CString;
+use std::ffi::{CStr, CString};
 use std::io::{stderr, Write};
 use std::os::raw as libc;
 use std::ptr;
@@ -115,6 +115,21 @@ impl Statement {
         ensure_sqlite_ok(result, &self.raw_connection)
     }
 
+    fn num_fields(&self) -> usize {
+        unsafe { ffi::sqlite3_column_count(self.inner_statement) as usize }
+    }
+
+    /// The lifetime of the returned CStr is shorter than self. This function
+    /// should be tied to a lifetime that ends before the next call to `reset`
+    unsafe fn field_name<'a>(&self, idx: usize) -> Option<&'a CStr> {
+        let ptr = ffi::sqlite3_column_name(self.inner_statement, idx as libc::c_int);
+        if ptr.is_null() {
+            None
+        } else {
+            Some(CStr::from_ptr(ptr))
+        }
+    }
+
     fn step(&mut self) -> Option<SqliteRow> {
         match unsafe { ffi::sqlite3_step(self.inner_statement) } {
             ffi::SQLITE_DONE => None,
@@ -187,6 +202,14 @@ impl<'a> StatementUse<'a> {
     pub fn step(&mut self) -> Option<SqliteRow> {
         self.statement.step()
     }
+
+    pub fn num_fields(&self) -> usize {
+        self.statement.num_fields()
+    }
+
+    pub fn field_name(&self, idx: usize) -> Option<&'a CStr> {
+        unsafe { self.statement.field_name(idx) }
+    }
 }
 
 impl<'a> Drop for StatementUse<'a> {
diff --git a/diesel/src/types/impls/tuples.rs b/diesel/src/types/impls/tuples.rs
index 71ee29b84..a681e3a75 100644
--- a/diesel/src/types/impls/tuples.rs
+++ b/diesel/src/types/impls/tuples.rs
@@ -6,9 +6,9 @@ use expression::{AppearsOnTable, Expression, NonAggregate, SelectableExpression}
 use insertable::{CanInsertInSingleQuery, InsertValues, Insertable};
 use query_builder::*;
 use query_builder::insert_statement::UndecoratedInsertRecord;
-use query_source::{QuerySource, Queryable, Table};
+use query_source::*;
 use result::QueryResult;
-use row::Row;
+use row::*;
 use types::{FromSqlRow, HasSqlType, NotNull};
 use util::TupleAppend;
 
@@ -61,6 +61,16 @@ macro_rules! tuple_impls {
                 }
             }
 
+            impl<$($T,)+ DB> QueryableByName<DB> for ($($T,)+)
+            where
+                DB: Backend,
+                $($T: QueryableByName<DB>,)+
+            {
+                fn build<R: NamedRow<DB>>(row: &R) -> Result<Self, Box<Error + Send + Sync>> {
+                    Ok(($($T::build(row)?,)+))
+                }
+            }
+
             impl<$($T: Expression + NonAggregate),+> Expression for ($($T,)+) {
                 type SqlType = ($(<$T as Expression>::SqlType,)+);
             }
diff --git a/diesel_codegen/src/as_changeset.rs b/diesel_codegen/src/as_changeset.rs
index 5b40a4ef6..8035a8e73 100644
--- a/diesel_codegen/src/as_changeset.rs
+++ b/diesel_codegen/src/as_changeset.rs
@@ -16,10 +16,7 @@ pub fn derive_as_changeset(item: syn::DeriveInput) -> quote::Tokens {
         .attrs
         .as_slice()
         .iter()
-        .filter(|a| match a.column_name() {
-            Some(name) => !model.primary_key_names.contains(name),
-            None => true,
-        })
+        .filter(|a| !model.primary_key_names.contains(a.column_name()))
         .collect::<Vec<_>>();
 
     if attrs.is_empty() {
diff --git a/diesel_codegen/src/attr.rs b/diesel_codegen/src/attr.rs
index c7b80b102..fd29e2557 100644
--- a/diesel_codegen/src/attr.rs
+++ b/diesel_codegen/src/attr.rs
@@ -31,10 +31,13 @@ impl Attr {
         self.field_name.as_ref().unwrap_or(&self.field_position)
     }
 
-    pub fn column_name(&self) -> Option<&syn::Ident> {
+    pub fn column_name(&self) -> &syn::Ident {
         self.column_name
             .as_ref()
             .or_else(|| self.field_name.as_ref())
+            .expect(
+                "All fields of tuple structs must be annotated with `#[column_name=\"something\"]`",
+            )
     }
 
     fn field_kind(&self) -> &str {
diff --git a/diesel_codegen/src/lib.rs b/diesel_codegen/src/lib.rs
index 145998659..beab65306 100644
--- a/diesel_codegen/src/lib.rs
+++ b/diesel_codegen/src/lib.rs
@@ -38,6 +38,7 @@ mod identifiable;
 mod insertable;
 mod model;
 mod queryable;
+mod queryable_by_name;
 #[cfg(feature = "diesel_infer_schema")]
 mod schema_inference;
 #[cfg(feature = "diesel_infer_schema")]
@@ -53,6 +54,11 @@ pub fn derive_queryable(input: TokenStream) -> TokenStream {
     expand_derive(input, queryable::derive_queryable)
 }
 
+#[proc_macro_derive(QueryableByName, attributes(table_name, column_name))]
+pub fn derive_queryable_by_name(input: TokenStream) -> TokenStream {
+    expand_derive(input, queryable_by_name::derive)
+}
+
 #[proc_macro_derive(Identifiable, attributes(table_name, primary_key))]
 pub fn derive_identifiable(input: TokenStream) -> TokenStream {
     expand_derive(input, identifiable::derive_identifiable)
diff --git a/diesel_codegen/src/queryable_by_name.rs b/diesel_codegen/src/queryable_by_name.rs
new file mode 100644
index 000000000..63eb9ba5e
--- /dev/null
+++ b/diesel_codegen/src/queryable_by_name.rs
@@ -0,0 +1,57 @@
+use quote::Tokens;
+use syn;
+
+use model::Model;
+use util::wrap_item_in_const;
+
+pub fn derive(item: syn::DeriveInput) -> Tokens {
+    let model = t!(Model::from_item(&item, "QueryableByName"));
+
+    let generics = syn::aster::from_generics(model.generics.clone())
+        .ty_param_id("__DB")
+        .build();
+    let struct_ty = &model.ty;
+    let table_name = model.table_name();
+
+    let attr_where_clause = model.attrs.iter().map(|attr| {
+        let attr_ty = &attr.ty;
+        let column_name = attr.column_name();
+        quote! {
+            __DB: diesel::types::HasSqlType<diesel::dsl::SqlTypeOf<#table_name::#column_name>>,
+            #attr_ty: diesel::types::FromSql<diesel::dsl::SqlTypeOf<#table_name::#column_name>, __DB>,
+        }
+    });
+
+    let build_expr = build_expr_for_model(&model);
+
+    let model_name_uppercase = model.name.as_ref().to_uppercase();
+    let dummy_const = format!("_IMPL_QUERYABLE_BY_NAME_FOR_{}", model_name_uppercase).into();
+
+    wrap_item_in_const(
+        dummy_const,
+        quote!(
+            impl#generics diesel::query_source::QueryableByName<__DB> for #struct_ty where
+                __DB: diesel::backend::Backend,
+                #(#attr_where_clause)*
+            {
+               fn build<__R: diesel::row::NamedRow<__DB>>(row: &__R) -> Result<Self, Box<::std::error::Error + Send + Sync>> {
+                   Ok(#build_expr)
+               }
+            }
+        ),
+    )
+}
+
+fn build_expr_for_model(model: &Model) -> Tokens {
+    let table_name = model.table_name();
+    let attr_exprs = model.attrs.iter().map(|attr| {
+        let name = attr.field_name();
+        let column_name = attr.column_name();
+        let st = quote!(diesel::dsl::SqlTypeOf<#table_name::#column_name>);
+        quote!(#name: diesel::row::NamedRow::get::<#st, _>(row, stringify!(#column_name))?)
+    });
+
+    quote!(Self {
+        #(#attr_exprs,)*
+    })
+}
diff --git a/diesel_codegen/tests/queryable_by_name.rs b/diesel_codegen/tests/queryable_by_name.rs
new file mode 100644
index 000000000..0f17d1047
--- /dev/null
+++ b/diesel_codegen/tests/queryable_by_name.rs
@@ -0,0 +1,46 @@
+use diesel::*;
+
+use test_helpers::connection;
+
+#[cfg(feature = "mysql")]
+type IntSql = ::diesel::types::BigInt;
+#[cfg(feature = "mysql")]
+type IntRust = i64;
+
+#[cfg(not(feature = "mysql"))]
+type IntSql = ::diesel::types::Integer;
+#[cfg(not(feature = "mysql"))]
+type IntRust = i32;
+
+table! {
+    use super::IntSql;
+    my_structs (foo) {
+        foo -> IntSql,
+        bar -> IntSql,
+    }
+}
+
+#[test]
+fn named_struct_definition() {
+    #[derive(Debug, Clone, Copy, PartialEq, Eq, QueryableByName)]
+    struct MyStruct {
+        foo: IntRust,
+        bar: IntRust,
+    }
+
+    let conn = connection();
+    let data = sql_query("SELECT 1 AS foo, 2 AS bar").get_result(&conn);
+    assert_eq!(Ok(MyStruct { foo: 1, bar: 2 }), data);
+}
+
+#[test]
+fn tuple_struct() {
+    #[derive(Debug, Clone, Copy, PartialEq, Eq, QueryableByName)]
+    struct MyStruct(#[column_name(foo)] IntRust, #[column_name(bar)] IntRust);
+
+    let conn = connection();
+    let data = sql_query("SELECT 1 AS foo, 2 AS bar").get_result(&conn);
+    assert_eq!(Ok(MyStruct(1, 2)), data);
+}
+
+// FIXME: Test usage with renamed columns
diff --git a/diesel_codegen/tests/tests.rs b/diesel_codegen/tests/tests.rs
index 3d1e1f433..179888a4a 100644
--- a/diesel_codegen/tests/tests.rs
+++ b/diesel_codegen/tests/tests.rs
@@ -6,5 +6,6 @@ extern crate diesel;
 extern crate diesel_codegen;
 
 mod queryable;
+mod queryable_by_name;
 mod associations;
 mod test_helpers;
diff --git a/diesel_tests/tests/backend_specifics.rs b/diesel_tests/tests/backend_specifics.rs
index bcaa4faba..6a8c95ae6 100644
--- a/diesel_tests/tests/backend_specifics.rs
+++ b/diesel_tests/tests/backend_specifics.rs
@@ -1,4 +1,4 @@
-use super::{posts, User};
+use super::*;
 
 #[derive(PartialEq, Eq, Debug, Clone, Queryable, Identifiable, Associations)]
 #[belongs_to(User)]
diff --git a/diesel_tests/tests/lib.rs b/diesel_tests/tests/lib.rs
index 6281f115b..9276ad8d3 100644
--- a/diesel_tests/tests/lib.rs
+++ b/diesel_tests/tests/lib.rs
@@ -34,6 +34,7 @@ mod joins;
 mod macros;
 mod order;
 mod perf_details;
+mod raw_sql;
 mod schema;
 mod schema_dsl;
 mod schema_inference;
diff --git a/diesel_tests/tests/raw_sql.rs b/diesel_tests/tests/raw_sql.rs
new file mode 100644
index 000000000..7adc8bc4f
--- /dev/null
+++ b/diesel_tests/tests/raw_sql.rs
@@ -0,0 +1,54 @@
+use diesel::*;
+use schema::*;
+
+#[test]
+fn execute_query_by_raw_sql() {
+    let conn = connection();
+
+    let inserted_rows = sql_query("INSERT INTO users (id, name) VALUES (1, 'Sean')").execute(&conn);
+    let users = users::table.load(&conn);
+    let expected_users = vec![User::new(1, "Sean")];
+
+    assert_eq!(Ok(1), inserted_rows);
+    assert_eq!(Ok(expected_users), users);
+}
+
+#[test]
+fn query_by_raw_sql() {
+    let conn = connection_with_sean_and_tess_in_users_table();
+    let sean = find_user_by_name("Sean", &conn);
+    let tess = find_user_by_name("Tess", &conn);
+
+    let users = sql_query("SELECT * FROM users ORDER BY id").load(&conn);
+    let expected = vec![sean, tess];
+    assert_eq!(Ok(expected), users);
+}
+
+#[test]
+fn sql_query_deserializes_by_name_not_index() {
+    let conn = connection_with_sean_and_tess_in_users_table();
+    let sean = find_user_by_name("Sean", &conn);
+    let tess = find_user_by_name("Tess", &conn);
+
+    let users = sql_query("SELECT name, hair_color, id FROM users ORDER BY id").load(&conn);
+    let expected = vec![sean, tess];
+    assert_eq!(Ok(expected), users);
+}
+
+#[test]
+fn sql_query_can_take_bind_params() {
+    use diesel::types::Text;
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+    let tess = find_user_by_name("Tess", &conn);
+
+    let query = if cfg!(feature = "postgres") {
+        sql_query("SELECT * FROM users WHERE name = $1")
+    } else {
+        sql_query("SELECT * FROM users WHERE name = ?")
+    };
+    let users = query.bind::<Text, _>("Tess").load(&conn);
+    let expected = vec![tess];
+
+    assert_eq!(Ok(expected), users);
+}
diff --git a/diesel_tests/tests/schema.rs b/diesel_tests/tests/schema.rs
index 5b8ccbeec..81f94b243 100644
--- a/diesel_tests/tests/schema.rs
+++ b/diesel_tests/tests/schema.rs
@@ -12,7 +12,7 @@ infer_schema!("dotenv:MYSQL_DATABASE_URL");
 infer_schema!("dotenv:DATABASE_URL");
 
 #[derive(PartialEq, Eq, Debug, Clone, Queryable, Identifiable, Insertable, AsChangeset,
-         Associations)]
+         Associations, QueryableByName)]
 #[table_name = "users"]
 pub struct User {
     pub id: i32,
