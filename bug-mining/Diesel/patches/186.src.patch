diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4bf063bbc..f4e6f85c1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -72,6 +72,14 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
   any columns from `posts`. That will now fail to compile, and any selections
   from `posts` will need to be made explicitly nullable.
 
+* Diesel CLI will now look for `diesel.toml` to determine the project root
+  before looking for `Cargo.toml`.
+
+* Any relative paths in `diesel.toml` will now be treated as relative to the
+  project root (the directory containing either `diesel.toml` or `Cargo.toml`).
+  They are no longer dependent on the current working directory (for all
+  directories in the same project)
+
 ### Deprecated
 
 * `diesel_(prefix|postfix|infix)_operator!` have been deprecated. These macros
diff --git a/diesel_cli/src/config.rs b/diesel_cli/src/config.rs
index 5e7a7483c..0c6bea99c 100644
--- a/diesel_cli/src/config.rs
+++ b/diesel_cli/src/config.rs
@@ -3,7 +3,7 @@ use std::env;
 use std::error::Error;
 use std::fs;
 use std::io::Read;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use super::find_project_root;
 use crate::print_schema;
@@ -31,12 +31,18 @@ impl Config {
 
         if path.exists() {
             let mut bytes = Vec::new();
-            fs::File::open(path)?.read_to_end(&mut bytes)?;
-            toml::from_slice(&bytes).map_err(Into::into)
+            fs::File::open(&path)?.read_to_end(&mut bytes)?;
+            let mut result = toml::from_slice::<Self>(&bytes)?;
+            result.set_relative_path_base(path.parent().unwrap());
+            Ok(result)
         } else {
             Ok(Self::default())
         }
     }
+
+    fn set_relative_path_base(&mut self, base: &Path) {
+        self.print_schema.set_relative_path_base(base)
+    }
 }
 
 #[derive(Default, Deserialize)]
@@ -64,6 +70,20 @@ impl PrintSchema {
     pub fn import_types(&self) -> Option<&[String]> {
         self.import_types.as_ref().map(|v| &**v)
     }
+
+    fn set_relative_path_base(&mut self, base: &Path) {
+        if let Some(ref mut file) = self.file {
+            if file.is_relative() {
+                *file = base.join(&file);
+            }
+        }
+
+        if let Some(ref mut patch_file) = self.patch_file {
+            if patch_file.is_relative() {
+                *patch_file = base.join(&patch_file);
+            }
+        }
+    }
 }
 
 #[derive(Default, Deserialize)]
diff --git a/diesel_cli/src/database_error.rs b/diesel_cli/src/database_error.rs
index 6cd693705..c323d3e6d 100644
--- a/diesel_cli/src/database_error.rs
+++ b/diesel_cli/src/database_error.rs
@@ -10,7 +10,7 @@ pub type DatabaseResult<T> = Result<T, DatabaseError>;
 
 #[derive(Debug)]
 pub enum DatabaseError {
-    CargoTomlNotFound,
+    ProjectRootNotFound,
     DatabaseUrlMissing,
     IoError(io::Error),
     QueryError(result::Error),
@@ -40,8 +40,8 @@ impl Error for DatabaseError {}
 impl fmt::Display for DatabaseError {
     fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
         match *self {
-            CargoTomlNotFound => {
-                f.write_str("Unable to find Cargo.toml in this directory or any parent directories.")
+            ProjectRootNotFound => {
+                f.write_str("Unable to find diesel.toml or Cargo.toml in this directory or any parent directories.")
             }
             DatabaseUrlMissing => {
                 f.write_str("The --database-url argument must be passed, or the DATABASE_URL environment variable must be set.")
@@ -65,7 +65,7 @@ impl fmt::Display for DatabaseError {
 impl PartialEq for DatabaseError {
     fn eq(&self, other: &Self) -> bool {
         match (self, other) {
-            (&CargoTomlNotFound, &CargoTomlNotFound) => true,
+            (&ProjectRootNotFound, &ProjectRootNotFound) => true,
             _ => false,
         }
     }
diff --git a/diesel_cli/src/main.rs b/diesel_cli/src/main.rs
index f4a5cde84..841e3b5c8 100644
--- a/diesel_cli/src/main.rs
+++ b/diesel_cli/src/main.rs
@@ -293,7 +293,7 @@ fn generate_completions_command(matches: &ArgMatches) {
 /// Looks for a migrations directory in the current path and all parent paths,
 /// and creates one in the same directory as the Cargo.toml if it can't find
 /// one. It also sticks a .gitkeep in the directory so git will pick it up.
-/// Returns a `DatabaseError::CargoTomlNotFound` if no Cargo.toml is found.
+/// Returns a `DatabaseError::ProjectRootNotFound` if no Cargo.toml is found.
 fn create_migrations_directory(path: &Path) -> DatabaseResult<PathBuf> {
     println!("Creating migrations directory at: {}", path.display());
     fs::create_dir(path)?;
@@ -302,19 +302,21 @@ fn create_migrations_directory(path: &Path) -> DatabaseResult<PathBuf> {
 }
 
 fn find_project_root() -> DatabaseResult<PathBuf> {
-    search_for_cargo_toml_directory(&env::current_dir()?)
+    let current_dir = env::current_dir()?;
+    search_for_directory_containing_file(&current_dir, "diesel.toml")
+        .or_else(|_| search_for_directory_containing_file(&current_dir, "Cargo.toml"))
 }
 
 /// Searches for the directory that holds the project's Cargo.toml, and returns
-/// the path if it found it, or returns a `DatabaseError::CargoTomlNotFound`.
-fn search_for_cargo_toml_directory(path: &Path) -> DatabaseResult<PathBuf> {
-    let toml_path = path.join("Cargo.toml");
+/// the path if it found it, or returns a `DatabaseError::ProjectRootNotFound`.
+fn search_for_directory_containing_file(path: &Path, file: &str) -> DatabaseResult<PathBuf> {
+    let toml_path = path.join(file);
     if toml_path.is_file() {
         Ok(path.to_owned())
     } else {
         path.parent()
-            .map(search_for_cargo_toml_directory)
-            .unwrap_or(Err(DatabaseError::CargoTomlNotFound))
+            .map(|p| search_for_directory_containing_file(p, file))
+            .unwrap_or(Err(DatabaseError::ProjectRootNotFound))
     }
 }
 
@@ -475,7 +477,7 @@ mod tests {
     use std::path::PathBuf;
 
     use super::convert_absolute_path_to_relative;
-    use super::search_for_cargo_toml_directory;
+    use super::search_for_directory_containing_file;
 
     #[test]
     fn toml_directory_find_cargo_toml() {
@@ -487,7 +489,7 @@ mod tests {
 
         assert_eq!(
             Ok(temp_path.clone()),
-            search_for_cargo_toml_directory(&temp_path)
+            search_for_directory_containing_file(&temp_path, "Cargo.toml")
         );
     }
 
@@ -497,8 +499,8 @@ mod tests {
         let temp_path = dir.path().canonicalize().unwrap();
 
         assert_eq!(
-            Err(DatabaseError::CargoTomlNotFound),
-            search_for_cargo_toml_directory(&temp_path)
+            Err(DatabaseError::ProjectRootNotFound),
+            search_for_directory_containing_file(&temp_path, "Cargo.toml")
         );
     }
 
diff --git a/diesel_cli/tests/print_schema.rs b/diesel_cli/tests/print_schema.rs
index e129237f0..ccffa649c 100644
--- a/diesel_cli/tests/print_schema.rs
+++ b/diesel_cli/tests/print_schema.rs
@@ -115,6 +115,19 @@ fn print_schema_custom_types() {
     );
 }
 
+#[test]
+fn schema_file_is_relative_to_project_root() {
+    let p = project("schema_file_is_relative_to_project_root")
+        .folder("foo")
+        .build();
+    let _db = database(&p.database_url());
+
+    p.command("setup").run();
+    p.command("migration").arg("run").cd("foo").run();
+
+    assert!(p.has_file("src/schema.rs"));
+}
+
 #[cfg(feature = "sqlite")]
 const BACKEND: &str = "sqlite";
 #[cfg(feature = "postgres")]
diff --git a/diesel_cli/tests/support/command.rs b/diesel_cli/tests/support/command.rs
index 08c2a551b..a9cb7d9eb 100644
--- a/diesel_cli/tests/support/command.rs
+++ b/diesel_cli/tests/support/command.rs
@@ -36,6 +36,11 @@ impl TestCommand {
         self
     }
 
+    pub fn cd<P: AsRef<Path>>(mut self, path: P) -> Self {
+        self.cwd.push(path);
+        self
+    }
+
     pub fn run(self) -> CommandResult {
         let output = self.build_command().output().unwrap();
         CommandResult { output: output }
