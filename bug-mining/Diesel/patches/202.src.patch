diff --git a/diesel/src/connection/mod.rs b/diesel/src/connection/mod.rs
index de1cbff09..c26e934d7 100644
--- a/diesel/src/connection/mod.rs
+++ b/diesel/src/connection/mod.rs
@@ -50,6 +50,12 @@ pub trait Connection: SimpleConnection + Sized + Send {
     /// the original error will be returned, otherwise the error generated by the rollback
     /// will be returned. In the second case the connection should be considered broken
     /// as it contains a uncommitted unabortable open transaction.
+    ///
+    /// If a nested transaction fails to release the corresponding savepoint
+    /// a rollback will be attempted. If the rollback succeeds,
+    /// the original error will be returned, otherwise the error generated by the rollback
+    /// will be returned.
+    ///
     /// # Example
     ///
     /// ```rust
diff --git a/diesel/src/connection/transaction_manager.rs b/diesel/src/connection/transaction_manager.rs
index 746afb19b..ccdbf52aa 100644
--- a/diesel/src/connection/transaction_manager.rs
+++ b/diesel/src/connection/transaction_manager.rs
@@ -130,13 +130,30 @@ where
                 result => self.change_transaction_depth(-1, result),
             }
         } else {
-            self.change_transaction_depth(
-                -1,
-                conn.batch_execute(&format!(
-                    "RELEASE SAVEPOINT diesel_savepoint_{}",
-                    transaction_depth - 1
-                )),
-            )
+            match conn.batch_execute(&format!(
+                "RELEASE SAVEPOINT diesel_savepoint_{}",
+                transaction_depth - 1,
+            )) {
+                Ok(_) => self.change_transaction_depth(-1, Ok(())),
+                // Postgres treats error (like syntax errors, missing tables, â€¦)
+                // as fatal errors and does not accept any new commands till the
+                // transaction is aborted or we've done a rollback
+                // To mirror the behaviour above we attempt to rollback
+                // to the last savepoint if we hit such a case
+                Err(Error::DatabaseError(DatabaseErrorKind::__Unknown, msg))
+                    if msg.message().starts_with("current transaction is aborted") =>
+                {
+                    self.change_transaction_depth(
+                        -1,
+                        conn.batch_execute(&format!(
+                            "ROLLBACK TO SAVEPOINT diesel_savepoint_{}",
+                            transaction_depth - 1
+                        )),
+                    )?;
+                    Err(Error::DatabaseError(DatabaseErrorKind::__Unknown, msg))
+                }
+                Err(e) => panic!("{}", e),
+            }
         }
     }
 
diff --git a/diesel_tests/tests/transactions.rs b/diesel_tests/tests/transactions.rs
index c32cd4e25..61e3568ac 100644
--- a/diesel_tests/tests/transactions.rs
+++ b/diesel_tests/tests/transactions.rs
@@ -134,3 +134,37 @@ fn count_test_table(connection: &TestConnection, table_name: &str) -> i64 {
     .first(connection)
     .unwrap()
 }
+
+#[test]
+#[cfg(feature = "postgres")]
+fn regression_test_for_2123() {
+    let conn = connection_without_transaction();
+    // fail once
+    let ret = conn.transaction(|| {
+        let _ = conn.transaction(|| {
+            // handling error
+            match conn.execute("SELECT foo") {
+                // do nothing
+                Ok(_) => unreachable!("This query should fail"),
+                // ignore the error
+                Err(e) => eprintln!("error occurred: {}", e),
+            };
+            Ok::<_, Error>(())
+        });
+
+        conn.transaction(|| {
+            let ret = conn.execute("SELECT 1");
+            assert_eq!(Ok(1), ret);
+            Ok::<_, Error>(())
+        })
+    });
+    println!("{:?}", ret);
+    // other transaction
+    let ret = conn
+        .build_transaction()
+        .serializable()
+        .run(|| conn.execute("SELECT 1"));
+    // must be Ok(1), but get Err(AlreadyInTransaction)
+    println!("{:?}", ret);
+    assert_eq!(Ok(1), ret);
+}
