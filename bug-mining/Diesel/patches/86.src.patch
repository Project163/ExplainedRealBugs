diff --git a/diesel/src/macros/insertable.rs b/diesel/src/macros/insertable.rs
index beb2c114b..ca2d761d0 100644
--- a/diesel/src/macros/insertable.rs
+++ b/diesel/src/macros/insertable.rs
@@ -193,17 +193,16 @@ macro_rules! impl_Insertable {
         }
 
     } __diesel_parse_as_item! {
-        impl<$($lifetime: 'insert,)* 'insert, Op, Ret> $crate::query_builder::insert_statement::IntoInsertStatement<$table_name::table, Op, Ret>
+        impl<$($lifetime: 'insert,)* 'insert, Op> $crate::query_builder::insert_statement::IntoInsertStatement<$table_name::table, Op>
             for &'insert $struct_ty
         {
-            type InsertStatement = $crate::query_builder::insert_statement::InsertStatement<$table_name::table, Self, Op, Ret>;
+            type InsertStatement = $crate::query_builder::insert_statement::InsertStatement<$table_name::table, Self, Op>;
 
-            fn into_insert_statement(self, target: $table_name::table, operator: Op, returning: Ret) -> Self::InsertStatement {
-                $crate::query_builder::insert_statement::InsertStatement::new(
+            fn into_insert_statement(self, target: $table_name::table, operator: Op) -> Self::InsertStatement {
+                $crate::query_builder::insert_statement::InsertStatement::no_returning_clause(
                     target,
                     self,
                     operator,
-                    returning,
                 )
             }
         }
diff --git a/diesel/src/pg/upsert/on_conflict_clause.rs b/diesel/src/pg/upsert/on_conflict_clause.rs
index 81146325d..3e5e187de 100644
--- a/diesel/src/pg/upsert/on_conflict_clause.rs
+++ b/diesel/src/pg/upsert/on_conflict_clause.rs
@@ -15,13 +15,13 @@ impl<T> OnConflictDoNothing<T> {
     }
 }
 
-impl<'a, T, Tab, Op, Ret> IntoInsertStatement<Tab, Op, Ret> for &'a OnConflictDoNothing<T> {
-    type InsertStatement = InsertStatement<Tab, Self, Op, Ret>;
+impl<'a, T, Tab, Op> IntoInsertStatement<Tab, Op> for &'a OnConflictDoNothing<T> {
+    type InsertStatement = InsertStatement<Tab, Self, Op>;
 
-    fn into_insert_statement(self, target: Tab, operator: Op, returning: Ret)
+    fn into_insert_statement(self, target: Tab, operator: Op)
         -> Self::InsertStatement
     {
-        InsertStatement::new(target, self, operator, returning)
+        InsertStatement::no_returning_clause(target, self, operator)
     }
 }
 
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index 7ea7eab34..9f0bc4b3a 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -28,45 +28,45 @@ impl<T, Op> IncompleteInsertStatement<T, Op> {
 
     /// Specify which table the data passed to `insert` should be added to.
     pub fn into<S>(self, target: S) -> T::InsertStatement where
-        T: IntoInsertStatement<S, Op, NoReturningClause>,
+        T: IntoInsertStatement<S, Op>,
     {
-        self.records.into_insert_statement(target, self.operator, NoReturningClause)
+        self.records.into_insert_statement(target, self.operator)
     }
 }
 
-pub trait IntoInsertStatement<Tab, Op, Ret> {
+pub trait IntoInsertStatement<Tab, Op> {
     type InsertStatement;
 
-    fn into_insert_statement(self, target: Tab, operator: Op, returning: Ret)
+    fn into_insert_statement(self, target: Tab, operator: Op)
         -> Self::InsertStatement;
 }
 
-impl<'a, T, Tab, Op, Ret> IntoInsertStatement<Tab, Op, Ret> for &'a [T] where
+impl<'a, T, Tab, Op> IntoInsertStatement<Tab, Op> for &'a [T] where
     &'a T: UndecoratedInsertRecord<Tab>,
 {
-    type InsertStatement = BatchInsertStatement<Tab, Self, Op, Ret>;
+    type InsertStatement = BatchInsertStatement<Tab, Self, Op, NoReturningClause>;
 
-    fn into_insert_statement(self, target: Tab, operator: Op, returning: Ret)
+    fn into_insert_statement(self, target: Tab, operator: Op)
         -> Self::InsertStatement
     {
         BatchInsertStatement {
             operator: operator,
             target: target,
             records: self,
-            returning: returning,
+            returning: NoReturningClause,
         }
     }
 }
 
-impl<'a, T, Tab, Op, Ret> IntoInsertStatement<Tab, Op, Ret> for &'a Vec<T> where
-    &'a [T]: IntoInsertStatement<Tab, Op, Ret>,
+impl<'a, T, Tab, Op> IntoInsertStatement<Tab, Op> for &'a Vec<T> where
+    &'a [T]: IntoInsertStatement<Tab, Op>,
 {
-    type InsertStatement = <&'a [T] as IntoInsertStatement<Tab, Op, Ret>>::InsertStatement;
+    type InsertStatement = <&'a [T] as IntoInsertStatement<Tab, Op>>::InsertStatement;
 
-    fn into_insert_statement(self, target: Tab, operator: Op, returning: Ret)
+    fn into_insert_statement(self, target: Tab, operator: Op)
         -> Self::InsertStatement
     {
-        (&**self).into_insert_statement(target, operator, returning)
+        (&**self).into_insert_statement(target, operator)
     }
 }
 
@@ -78,6 +78,12 @@ pub struct InsertStatement<T, U, Op=Insert, Ret=NoReturningClause> {
     returning: Ret,
 }
 
+impl<T, U, Op> InsertStatement<T, U, Op> {
+    pub fn no_returning_clause(target: T, records: U, operator: Op) -> Self {
+        InsertStatement::new(target, records, operator, NoReturningClause)
+    }
+}
+
 impl<T, U, Op, Ret> InsertStatement<T, U, Op, Ret> {
     pub fn new(target: T, records: U, operator: Op, returning: Ret) -> Self {
         InsertStatement {
