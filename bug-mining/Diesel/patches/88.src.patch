diff --git a/CHANGELOG.md b/CHANGELOG.md
index 80eef009f..1439bb3e2 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,6 +4,13 @@ All user visible changes to this project will be documented in this file.
 This project adheres to [Semantic Versioning](http://semver.org/), as described
 for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md)
 
+## Unreleased
+
+### Fixed
+
+* `diesel_codegen` will provide a more useful error message when it encounters
+  an unsupported type that contains a space in MySQL.
+
 ## [0.11.4] - 2017-02-21
 
 ### Fixed
diff --git a/diesel_infer_schema/src/codegen.rs b/diesel_infer_schema/src/codegen.rs
index 260f2e3da..6be126088 100644
--- a/diesel_infer_schema/src/codegen.rs
+++ b/diesel_infer_schema/src/codegen.rs
@@ -21,7 +21,7 @@ pub fn expand_infer_table_from_schema(database_url: &str, table: &TableData)
     let mut tokens = Vec::with_capacity(data.len());
 
     for a in data {
-        tokens.push(column_def_tokens(&a, &connection)?);
+        tokens.push(column_def_tokens(table, &a, &connection)?);
     }
     let default_schema = default_schema(&connection);
     if table.schema != default_schema {
@@ -54,11 +54,20 @@ pub fn handle_schema<I>(tables: I, schema_name: Option<&str>) -> quote::Tokens
 }
 
 fn column_def_tokens(
+    table: &TableData,
     column: &ColumnInformation,
     connection: &InferConnection,
 ) -> Result<quote::Tokens, Box<Error>> {
     let column_name = syn::Ident::new(&*column.column_name);
-    let column_type = try!(determine_column_type(column, connection));
+    let column_type = match determine_column_type(column, connection) {
+        Ok(t) => t,
+        Err(e) => return Err(format!(
+            "Error determining type of {}.{}: {}",
+            table,
+            column.column_name,
+            e,
+        ).into()),
+    };
     let tpe = if column_type.path[0] == "diesel" && column_type.path[1] == "types" {
         let path_segments = column_type.path
             .into_iter()
diff --git a/diesel_infer_schema/src/mysql.rs b/diesel_infer_schema/src/mysql.rs
index 43a381209..7c89b05f5 100644
--- a/diesel_infer_schema/src/mysql.rs
+++ b/diesel_infer_schema/src/mysql.rs
@@ -3,7 +3,7 @@ use std::error::Error;
 use data_structures::*;
 
 pub fn determine_column_type(attr: &ColumnInformation) -> Result<ColumnType, Box<Error>> {
-    let tpe = determine_type_name(&attr.type_name);
+    let tpe = determine_type_name(&attr.type_name)?;
 
     Ok(ColumnType {
         path: vec!["diesel".into(), "types".into(), capitalize(tpe)],
@@ -12,8 +12,8 @@ pub fn determine_column_type(attr: &ColumnInformation) -> Result<ColumnType, Box
     })
 }
 
-fn determine_type_name(sql_type_name: &str) -> &str {
-    if sql_type_name == "tinyint(1)" {
+fn determine_type_name(sql_type_name: &str) -> Result<&str, Box<Error>> {
+    let result = if sql_type_name == "tinyint(1)" {
         "bool"
     } else if sql_type_name.starts_with("int") {
         "integer"
@@ -21,6 +21,14 @@ fn determine_type_name(sql_type_name: &str) -> &str {
         &sql_type_name[..idx]
     } else {
         sql_type_name
+    };
+
+    if result.to_lowercase().contains("unsigned") {
+        Err("unsigned types are not yet supported".into())
+    } else if result.contains(' ') {
+        Err(format!("unrecognized type {:?}", result).into())
+    } else {
+        Ok(result)
     }
 }
 
@@ -30,26 +38,38 @@ fn capitalize(name: &str) -> String {
 
 #[test]
 fn values_which_already_map_to_type_are_returned_unchanged() {
-    assert_eq!("text", determine_type_name("text"));
-    assert_eq!("integer", determine_type_name("integer"));
-    assert_eq!("biginteger", determine_type_name("biginteger"));
+    assert_eq!("text", determine_type_name("text").unwrap());
+    assert_eq!("integer", determine_type_name("integer").unwrap());
+    assert_eq!("biginteger", determine_type_name("biginteger").unwrap());
 }
 
 #[test]
 fn trailing_parenthesis_are_stripped() {
-    assert_eq!("varchar", determine_type_name("varchar(255)"));
-    assert_eq!("decimal", determine_type_name("decimal(10, 2)"));
-    assert_eq!("float", determine_type_name("float(1)"));
+    assert_eq!("varchar", determine_type_name("varchar(255)").unwrap());
+    assert_eq!("decimal", determine_type_name("decimal(10, 2)").unwrap());
+    assert_eq!("float", determine_type_name("float(1)").unwrap());
 }
 
 #[test]
 fn tinyint_is_bool_if_limit_1() {
-    assert_eq!("bool", determine_type_name("tinyint(1)"));
-    assert_eq!("tinyint", determine_type_name("tinyint(2)"));
+    assert_eq!("bool", determine_type_name("tinyint(1)").unwrap());
+    assert_eq!("tinyint", determine_type_name("tinyint(2)").unwrap());
 }
 
 #[test]
 fn int_is_treated_as_integer() {
-    assert_eq!("integer", determine_type_name("int"));
-    assert_eq!("integer", determine_type_name("int(11)"));
+    assert_eq!("integer", determine_type_name("int").unwrap());
+    assert_eq!("integer", determine_type_name("int(11)").unwrap());
+}
+
+#[test]
+fn unsigned_types_are_not_supported() {
+    assert!(determine_type_name("float unsigned").is_err());
+    assert!(determine_type_name("UNSIGNED INT").is_err());
+    assert!(determine_type_name("unsigned bigint").is_err())
+}
+
+#[test]
+fn types_with_space_are_not_supported() {
+    assert!(determine_type_name("lol wat").is_err());
 }
