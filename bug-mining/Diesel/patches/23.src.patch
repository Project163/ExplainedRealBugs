diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1074ab8ed..0192082d7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -10,6 +10,19 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * Added support for mapping `types::Timestamp` to/from `chrono::NaiveDateTime`.
   Add `features = ["chrono"]` to enable.
 
+* Added a top level `select` function for select statements with no from clause.
+  This is primarily intended to be used for testing Diesel itself, but it has
+  been added to the public API as it will likely be useful for third party
+  crates in the future. `select(foo).from(bar)` might be a supported API in the
+  future as an alternative to `bar.select(foo)`.
+
+* Added `expression::dsl::sql` as a helper function for constructing
+  `SqlLiteral` nodes. This is primarily intended to be used for testing Diesel
+  itself, but is part of the public API as an escape hatch if our query builder
+  DSL proves inadequate for a specific case. Use of this function in any
+  production code is discouraged as it is inherently unsafe and avoids real type
+  checking.
+
 ### Changed
 
 * Rename both the `#[derive(Queriable)]` attribute and the `Queriable` trait to
diff --git a/diesel/src/expression/date_and_time.rs b/diesel/src/expression/date_and_time.rs
new file mode 100644
index 000000000..80d1c6065
--- /dev/null
+++ b/diesel/src/expression/date_and_time.rs
@@ -0,0 +1,35 @@
+use expression::{Expression, SelectableExpression};
+use query_builder::{QueryBuilder, BuildQueryResult};
+use types::{Timestamp, VarChar};
+
+pub struct AtTimeZone<Ts, Tz> {
+    timestamp: Ts,
+    timezone: Tz,
+}
+
+impl<Ts, Tz> AtTimeZone<Ts, Tz> {
+    pub fn new(timestamp: Ts, timezone: Tz) -> Self {
+        AtTimeZone {
+            timestamp: timestamp,
+            timezone: timezone,
+        }
+    }
+}
+
+impl<Ts, Tz> Expression for AtTimeZone<Ts, Tz> where
+    Ts: Expression<SqlType=Timestamp>,
+    Tz: Expression<SqlType=VarChar>,
+{
+    // FIXME: This should be Timestamptz when we support that type
+    type SqlType = Timestamp;
+
+    fn to_sql(&self, out: &mut QueryBuilder) -> BuildQueryResult {
+        try!(self.timestamp.to_sql(out));
+        out.push_sql(" AT TIME ZONE ");
+        self.timezone.to_sql(out)
+    }
+}
+
+impl<Ts, Tz, Qs> SelectableExpression<Qs> for AtTimeZone<Ts, Tz> where
+    AtTimeZone<Ts, Tz>: Expression,
+{}
diff --git a/diesel/src/expression/expression_methods/mod.rs b/diesel/src/expression/expression_methods/mod.rs
index 0e655a8fb..22f493a49 100644
--- a/diesel/src/expression/expression_methods/mod.rs
+++ b/diesel/src/expression/expression_methods/mod.rs
@@ -7,7 +7,11 @@
 pub mod global_expression_methods;
 pub mod bool_expression_methods;
 pub mod text_expression_methods;
+#[doc(hidden)]
+pub mod timestamp_expression_methods;
 
 pub use self::global_expression_methods::ExpressionMethods;
 pub use self::bool_expression_methods::BoolExpressionMethods;
 pub use self::text_expression_methods::{TextExpressionMethods, VarCharExpressionMethods};
+#[doc(hidden)]
+pub use self::timestamp_expression_methods::TimestampExpressionMethods;
diff --git a/diesel/src/expression/expression_methods/timestamp_expression_methods.rs b/diesel/src/expression/expression_methods/timestamp_expression_methods.rs
new file mode 100644
index 000000000..23e394a74
--- /dev/null
+++ b/diesel/src/expression/expression_methods/timestamp_expression_methods.rs
@@ -0,0 +1,14 @@
+use expression::{AsExpression, Expression};
+use expression::date_and_time::AtTimeZone;
+use types::{VarChar, Timestamp};
+
+pub trait TimestampExpressionMethods: Expression<SqlType=Timestamp> + Sized {
+    /// Returns a PostgreSQL "AT TIME ZONE" expression
+    fn at_time_zone<T>(self, timezone: T) -> AtTimeZone<Self, T::Expression> where
+        T: AsExpression<VarChar>,
+    {
+        AtTimeZone::new(self, timezone.as_expression())
+    }
+}
+
+impl<T: Expression<SqlType=Timestamp>> TimestampExpressionMethods for T {}
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index bf70aa1b2..f80d75daf 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -25,6 +25,8 @@ pub mod array_comparison;
 pub mod bound;
 #[doc(hidden)]
 pub mod count;
+#[doc(hidden)]
+pub mod date_and_time;
 pub mod expression_methods;
 pub mod extensions;
 #[doc(hidden)]
@@ -42,14 +44,11 @@ pub mod sql_literal;
 /// generic to export by default. This module exists to conveniently glob import
 /// in functions where you need them.
 pub mod dsl {
-    #[doc(inline)]
-    pub use super::array_comparison::any;
-    #[doc(inline)]
-    pub use super::count::{count, count_star};
-    #[doc(inline)]
-    pub use super::functions::date_and_time::*;
-    #[doc(inline)]
-    pub use super::functions::aggregate_ordering::*;
+    #[doc(inline)] pub use super::array_comparison::any;
+    #[doc(inline)] pub use super::count::{count, count_star};
+    #[doc(inline)] pub use super::functions::date_and_time::*;
+    #[doc(inline)] pub use super::functions::aggregate_ordering::*;
+    #[doc(inline)] pub use super::sql_literal::sql;
 
     pub use super::extensions::*;
 }
diff --git a/diesel/src/expression/sql_literal.rs b/diesel/src/expression/sql_literal.rs
index e9bffa7d2..2fb1c5467 100644
--- a/diesel/src/expression/sql_literal.rs
+++ b/diesel/src/expression/sql_literal.rs
@@ -32,3 +32,7 @@ impl<ST: NativeSqlType> Expression for SqlLiteral<ST> {
 
 impl<QS, ST: NativeSqlType> SelectableExpression<QS> for SqlLiteral<ST> {
 }
+
+pub fn sql<ST: NativeSqlType>(sql: &str) -> SqlLiteral<ST> {
+    SqlLiteral::new(sql.into())
+}
diff --git a/diesel/src/lib.rs b/diesel/src/lib.rs
index 4a5ca5cd3..9cc83e532 100644
--- a/diesel/src/lib.rs
+++ b/diesel/src/lib.rs
@@ -74,7 +74,7 @@ pub mod prelude {
 pub use connection::{Connection, Cursor};
 pub use prelude::*;
 #[doc(inline)]
-pub use query_builder::functions::{insert, update, delete};
+pub use query_builder::functions::{insert, update, delete, select};
 pub use result::Error::NotFound;
 #[doc(inline)]
 pub use types::structs::data_types;
diff --git a/diesel/src/query_builder/bare_select_statement.rs b/diesel/src/query_builder/bare_select_statement.rs
new file mode 100644
index 000000000..eb7d91e24
--- /dev/null
+++ b/diesel/src/query_builder/bare_select_statement.rs
@@ -0,0 +1,29 @@
+use expression::SelectableExpression;
+use super::{Query, QueryFragment, QueryBuilder, BuildQueryResult};
+
+pub struct BareSelectStatement<T> {
+    expression: T,
+}
+
+impl<T> BareSelectStatement<T> {
+    pub fn new(expression: T) -> Self {
+        BareSelectStatement {
+            expression: expression,
+        }
+    }
+}
+
+impl<T> QueryFragment for BareSelectStatement<T> where
+    T: SelectableExpression<()>,
+{
+    fn to_sql(&self, out: &mut QueryBuilder) -> BuildQueryResult {
+        out.push_sql("SELECT ");
+        self.expression.to_sql(out)
+    }
+}
+
+impl<T> Query for BareSelectStatement<T> where
+    T: SelectableExpression<()>,
+{
+    type SqlType = T::SqlType;
+}
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index 02abebc56..6651d2817 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -1,5 +1,6 @@
 use super::{UpdateTarget, IncompleteUpdateStatement};
 use super::delete_statement::DeleteStatement;
+use super::BareSelectStatement;
 use super::IncompleteInsertStatement;
 
 /// Creates an update statement. Helpers for updating a single row can be
@@ -107,3 +108,14 @@ pub fn delete<T: UpdateTarget>(source: T) -> DeleteStatement<T> {
 pub fn insert<T>(records: T) -> IncompleteInsertStatement<T> {
     IncompleteInsertStatement::new(records)
 }
+
+/// Creates a bare select statement, with no from clause. Primarily used for
+/// testing diesel itself, but likely useful for third party crates as well. The
+/// given expressions must be selectable from anywhere.
+///
+/// Note: You must use `get_result` and not `first` to get a single value out of
+/// this, or you will get a vague compiler error (the reason being you cannot
+/// call `limit` on the type returned by this function).
+pub fn select<T>(expression: T) -> BareSelectStatement<T> {
+    BareSelectStatement::new(expression)
+}
diff --git a/diesel/src/query_builder/mod.rs b/diesel/src/query_builder/mod.rs
index 65f42de17..2e9310a3b 100644
--- a/diesel/src/query_builder/mod.rs
+++ b/diesel/src/query_builder/mod.rs
@@ -3,6 +3,7 @@
 pub mod pg;
 pub mod debug;
 
+mod bare_select_statement;
 mod delete_statement;
 #[doc(hidden)]
 pub mod functions;
@@ -14,6 +15,8 @@ mod where_clause;
 pub mod insert_statement;
 pub mod update_statement;
 
+#[doc(hidden)]
+pub use self::bare_select_statement::BareSelectStatement;
 #[doc(hidden)]
 pub use self::select_statement::SelectStatement;
 #[doc(inline)]
diff --git a/diesel/src/types/impls/date_and_time/chrono.rs b/diesel/src/types/impls/date_and_time/chrono.rs
index 6b1882c6b..1c66aaf42 100644
--- a/diesel/src/types/impls/date_and_time/chrono.rs
+++ b/diesel/src/types/impls/date_and_time/chrono.rs
@@ -50,10 +50,14 @@ mod tests {
     extern crate dotenv;
     extern crate chrono;
 
-    use connection::Connection;
-    use self::dotenv::dotenv;
     use self::chrono::*;
-    use types::{Bool, Timestamp};
+    use self::dotenv::dotenv;
+
+    use ::select;
+    use connection::Connection;
+    use expression::dsl::{sql, now};
+    use prelude::*;
+    use types::Timestamp;
 
     fn connection() -> Connection {
         dotenv().ok();
@@ -67,37 +71,28 @@ mod tests {
     fn unix_epoch_encodes_correctly() {
         let connection = connection();
         let time = NaiveDate::from_ymd(1970, 1, 1).and_hms(0, 0, 0);
-        assert!(
-            connection.query_sql_params::<Bool, bool, Timestamp, NaiveDateTime>(
-                "SELECT $1::timestamp = '1970-01-01'", &time)
-            .unwrap().nth(0).unwrap()
-        );
+        let query = select(sql::<Timestamp>("'1970-01-01'").eq(time));
+        assert!(query.get_result::<bool>(&connection).unwrap());
     }
 
     #[test]
     fn unix_epoch_decodes_correctly() {
         let connection = connection();
         let time = NaiveDate::from_ymd(1970, 1, 1).and_hms(0, 0, 0);
-        let epoch_from_sql = connection.query_sql::<Timestamp, NaiveDateTime>("SELECT '1970-01-01'::timestamp")
-            .unwrap().nth(0).unwrap();
-        assert_eq!(time, epoch_from_sql);
+        let epoch_from_sql = select(sql::<Timestamp>("'1970-01-01'::timestamp"))
+            .get_result(&connection);
+        assert_eq!(Ok(time), epoch_from_sql);
     }
 
     #[test]
     fn times_relative_to_now_encode_correctly() {
         let connection = connection();
         let time = UTC::now().naive_utc() + Duration::seconds(60);
-        assert!(
-            connection.query_sql_params::<Bool, bool, Timestamp, NaiveDateTime>(
-                "SELECT $1::timestamp > current_timestamp at time zone 'utc'", &time)
-            .unwrap().nth(0).unwrap()
-        );
+        let query = select(now.at_time_zone("utc").lt(time));
+        assert!(query.get_result::<bool>(&connection).unwrap());
 
         let time = UTC::now().naive_utc() - Duration::seconds(60);
-        assert!(
-            connection.query_sql_params::<Bool, bool, Timestamp, NaiveDateTime>(
-                "SELECT $1::timestamp < current_timestamp at time zone 'utc'", &time)
-            .unwrap().nth(0).unwrap()
-        );
+        let query = select(now.at_time_zone("utc").gt(time));
+        assert!(query.get_result::<bool>(&connection).unwrap());
     }
 }
diff --git a/diesel/src/types/impls/date_and_time/std_time.rs b/diesel/src/types/impls/date_and_time/std_time.rs
index c07acfdc4..7e70e77a4 100644
--- a/diesel/src/types/impls/date_and_time/std_time.rs
+++ b/diesel/src/types/impls/date_and_time/std_time.rs
@@ -70,10 +70,14 @@ fn duration_to_usecs(duration: Duration) -> u64 {
 mod tests {
     extern crate dotenv;
 
-    use connection::Connection;
     use self::dotenv::dotenv;
     use std::time::{SystemTime, Duration, UNIX_EPOCH};
-    use types::{Bool, Timestamp};
+
+    use ::select;
+    use connection::Connection;
+    use expression::dsl::{sql, now};
+    use prelude::*;
+    use types::Timestamp;
 
     fn connection() -> Connection {
         dotenv().ok();
@@ -86,36 +90,27 @@ mod tests {
     #[test]
     fn unix_epoch_encodes_correctly() {
         let connection = connection();
-        assert!(
-            connection.query_sql_params::<Bool, bool, Timestamp, SystemTime>(
-                "SELECT $1::timestamp = '1970-01-01'", &UNIX_EPOCH)
-            .unwrap().nth(0).unwrap()
-        );
+        let query = select(sql::<Timestamp>("'1970-01-01'").eq(UNIX_EPOCH));
+        assert!(query.get_result::<bool>(&connection).unwrap());
     }
 
     #[test]
     fn unix_epoch_decodes_correctly() {
         let connection = connection();
-        let epoch_from_sql = connection.query_sql::<Timestamp, SystemTime>("SELECT '1970-01-01'::timestamp")
-            .unwrap().nth(0).unwrap();
-        assert_eq!(UNIX_EPOCH, epoch_from_sql);
+        let epoch_from_sql = select(sql::<Timestamp>("'1970-01-01'::timestamp"))
+            .get_result::<SystemTime>(&connection);
+        assert_eq!(Ok(UNIX_EPOCH), epoch_from_sql);
     }
 
     #[test]
     fn times_relative_to_now_encode_correctly() {
         let connection = connection();
         let time = SystemTime::now() + Duration::from_secs(60);
-        assert!(
-            connection.query_sql_params::<Bool, bool, Timestamp, SystemTime>(
-                "SELECT $1::timestamp > current_timestamp at time zone 'utc'", &time)
-            .unwrap().nth(0).unwrap()
-        );
+        let query = select(now.at_time_zone("utc").lt(time));
+        assert!(query.get_result::<bool>(&connection).unwrap());
 
         let time = SystemTime::now() - Duration::from_secs(60);
-        assert!(
-            connection.query_sql_params::<Bool, bool, Timestamp, SystemTime>(
-                "SELECT $1::timestamp < current_timestamp at time zone 'utc'", &time)
-            .unwrap().nth(0).unwrap()
-        );
+        let query = select(now.at_time_zone("utc").gt(time));
+        assert!(query.get_result::<bool>(&connection).unwrap());
     }
 }
diff --git a/diesel_tests/tests/types_roundtrip.rs b/diesel_tests/tests/types_roundtrip.rs
index 05faeeeeb..c44b5eec3 100644
--- a/diesel_tests/tests/types_roundtrip.rs
+++ b/diesel_tests/tests/types_roundtrip.rs
@@ -9,16 +9,18 @@ pub use diesel::result::Error;
 pub use diesel::data_types::*;
 pub use diesel::types::{NativeSqlType, ToSql, Nullable, Array};
 
-pub fn test_type_round_trips<ST, T>(value: T, type_name: &str) -> bool where
+use diesel::expression::AsExpression;
+
+pub fn test_type_round_trips<ST, T>(value: T) -> bool where
     ST: NativeSqlType,
-    T: ToSql<ST> + Queryable<ST> + PartialEq + ::std::fmt::Debug,
+    T: AsExpression<ST> + Queryable<ST> + PartialEq + Clone + ::std::fmt::Debug,
+    <T as AsExpression<ST>>::Expression: SelectableExpression<()>,
 {
     let connection = connection();
-    let query = format!("SELECT $1::{}", type_name);
-    let result = connection.query_sql_params::<ST, T, ST, T>(&query, &value);
+    let query = select(AsExpression::<ST>::as_expression(value.clone()));
+    let result = query.get_result::<T>(&connection);
     match result {
-        Ok(mut val) => {
-            let res = val.nth(0).unwrap();
+        Ok(res) => {
             if value != res {
                 println!("{:?}, {:?}", value, res);
                 false
@@ -35,25 +37,25 @@ pub fn test_type_round_trips<ST, T>(value: T, type_name: &str) -> bool where
 pub fn id<A>(a: A) -> A { a }
 
 macro_rules! test_round_trip {
-    ($test_name:ident, $sql_type:ident, $tpe:ty, $sql_type_name:expr) => {
-        test_round_trip!($test_name, $sql_type, $tpe, id, $sql_type_name);
+    ($test_name:ident, $sql_type:ident, $tpe:ty) => {
+        test_round_trip!($test_name, $sql_type, $tpe, id);
     };
 
-    ($test_name:ident, $sql_type:ident, $tpe:ty, $map_fn:ident, $sql_type_name:expr) => {
+    ($test_name:ident, $sql_type:ident, $tpe:ty, $map_fn:ident) => {
         #[test]
         fn $test_name() {
             fn round_trip(val: $tpe) -> bool {
-                test_type_round_trips::<types::$sql_type, _>($map_fn(val), $sql_type_name)
+                test_type_round_trips::<types::$sql_type, _>($map_fn(val))
             }
 
             fn option_round_trip(val: Option<$tpe>) -> bool {
                 let val = val.map($map_fn);
-                test_type_round_trips::<Nullable<types::$sql_type>, _>(val, $sql_type_name)
+                test_type_round_trips::<Nullable<types::$sql_type>, _>(val)
             }
 
             fn vec_round_trip(val: Vec<$tpe>) -> bool {
                 let val: Vec<_> = val.into_iter().map($map_fn).collect();
-                test_type_round_trips::<Array<types::$sql_type>, _>(val, concat!($sql_type_name, "[]"))
+                test_type_round_trips::<Array<types::$sql_type>, _>(val)
             }
 
             quickcheck(round_trip as fn($tpe) -> bool);
@@ -63,21 +65,21 @@ macro_rules! test_round_trip {
     }
 }
 
-test_round_trip!(bool_roundtrips, Bool, bool, "boolean");
-test_round_trip!(i16_roundtrips, SmallInt, i16, "int2");
-test_round_trip!(i32_roundtrips, Integer, i32, "int4");
-test_round_trip!(i64_roundtrips, BigInt, i64, "int8");
-test_round_trip!(f32_roundtrips, Float, f32, "real");
-test_round_trip!(f64_roundtrips, Double, f64, "double precision");
-test_round_trip!(string_roundtrips, VarChar, String, "varchar");
-test_round_trip!(text_roundtrips, Text, String, "text");
-test_round_trip!(binary_roundtrips, Binary, Vec<u8>, "bytea");
-test_round_trip!(date_roundtrips, Date, PgDate, "date");
-test_round_trip!(time_roundtrips, Time, PgTime, "time");
-test_round_trip!(timestamp_roundtrips, Timestamp, PgTimestamp, "timestamp");
-test_round_trip!(interval_roundtrips, Interval, PgInterval, "interval");
-test_round_trip!(numeric_roundtrips, Numeric, PgNumeric, "numeric");
-test_round_trip!(naive_datetime_roundtrips, Timestamp, (i64, u32), mk_naive_datetime, "timestamp");
+test_round_trip!(bool_roundtrips, Bool, bool);
+test_round_trip!(i16_roundtrips, SmallInt, i16);
+test_round_trip!(i32_roundtrips, Integer, i32);
+test_round_trip!(i64_roundtrips, BigInt, i64);
+test_round_trip!(f32_roundtrips, Float, f32);
+test_round_trip!(f64_roundtrips, Double, f64);
+test_round_trip!(string_roundtrips, VarChar, String);
+test_round_trip!(text_roundtrips, Text, String);
+test_round_trip!(binary_roundtrips, Binary, Vec<u8>);
+test_round_trip!(date_roundtrips, Date, PgDate);
+test_round_trip!(time_roundtrips, Time, PgTime);
+test_round_trip!(timestamp_roundtrips, Timestamp, PgTimestamp);
+test_round_trip!(interval_roundtrips, Interval, PgInterval);
+test_round_trip!(numeric_roundtrips, Numeric, PgNumeric);
+test_round_trip!(naive_datetime_roundtrips, Timestamp, (i64, u32), mk_naive_datetime);
 
 fn mk_naive_datetime(data: (i64, u32)) -> NaiveDateTime {
     NaiveDateTime::from_timestamp(data.0, data.1 / 1000)
@@ -100,5 +102,5 @@ mod unstable_types {
         time + Duration::new(0, 1) - Duration::new(0, 1)
     }
 
-    test_round_trip!(systemtime_roundtrips, Timestamp, SystemTime, strip_nanosecond_precision, "timestamp");
+    test_round_trip!(systemtime_roundtrips, Timestamp, SystemTime, strip_nanosecond_precision);
 }
