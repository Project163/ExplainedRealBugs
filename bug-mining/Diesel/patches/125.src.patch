diff --git a/.travis.yml b/.travis.yml
index 56793a52c..512a3fb7d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -15,10 +15,11 @@ before_script:
 script:
 - |
   if [[ "$TRAVIS_RUST_VERSION" == nightly* ]]; then
-    (cd diesel && travis-cargo test -- --no-default-features --features "unstable chrono $BACKEND")
+    (cd diesel && travis-cargo test -- --no-default-features --features "unstable extras $BACKEND")
   else
-    (cd diesel && travis-cargo test -- --no-default-features --features "chrono $BACKEND")
+    (cd diesel && travis-cargo test -- --no-default-features --features "extras $BACKEND")
   fi &&
+  (cd diesel && travis-cargo test -- --no-default-features --features "extras with-deprecated $BACKEND") &&
   if [[ "$BACKEND" == postgres ]]; then
     (cd examples/postgres && ./test_all)
   fi &&
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 559eae048..9603ea35d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -11,9 +11,17 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * The `.for_update()` method has been added to select statements, allowing
   construction of `SELECT ... FOR UPDATE`.
 
-* Added `insert(&default_values())` as a replacement for
+* Added `insert_into(table).default_values()` as a replacement for
   `insert_default_values()`
 
+* Added `insert_into(table).values(values)` as a replacement for
+  `insert(values).into(table)`.
+
+* Added support for MySQL's `REPLACE INTO` as `replace_into(table)`.
+
+* Added `replace_into(table).values(values)` as a replacement for
+  `insert_or_replace(values).into(table)`.
+
 ### Changed
 
 * The signatures of `QueryId`, `Column`, and `FromSqlRow` have all changed to
@@ -21,7 +29,14 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 ### Deprecated
 
-* Deprecated `insert_default_values()` in favor of `insert(&default_values())`
+* Deprecated `insert_default_values()` in favor of
+  `insert_into(table).default_values()`
+
+* Deprecated `insert(values).into(table)` in favor of
+  `insert_into(table).values(values)`.
+
+* Deprecated `insert_or_replace(values).into(table)` in favor of
+  `replace_into(table).values(values)`.
 
 ### Removed
 
diff --git a/diesel/src/connection/mod.rs b/diesel/src/connection/mod.rs
index 9c59f5f39..c32725244 100644
--- a/diesel/src/connection/mod.rs
+++ b/diesel/src/connection/mod.rs
@@ -62,7 +62,7 @@ pub trait Connection: SimpleConnection + Sized + Send {
     ///     let conn = establish_connection();
     ///     let _ = conn.transaction::<_, Error, _>(|| {
     ///         let new_user = NewUser { name: "Ruby".into() };
-    ///         diesel::insert(&new_user).into(users::table).execute(&conn)?;
+    ///         diesel::insert_into(users::table).values(&new_user).execute(&conn)?;
     ///         assert_eq!(users::table.load::<User>(&conn), Ok(vec![
     ///             User { id: 1, name: "Sean".into() },
     ///             User { id: 2, name: "Tess".into() },
@@ -74,7 +74,7 @@ pub trait Connection: SimpleConnection + Sized + Send {
     ///
     ///     let _ = conn.transaction::<(), Error, _>(|| {
     ///         let new_user = NewUser { name: "Pascal".into() };
-    ///         diesel::insert(&new_user).into(users::table).execute(&conn)?;
+    ///         diesel::insert_into(users::table).values(&new_user).execute(&conn)?;
     ///
     ///         assert_eq!(users::table.load::<User>(&conn), Ok(vec![
     ///             User { id: 1, name: "Sean".into() },
diff --git a/diesel/src/expression/sql_literal.rs b/diesel/src/expression/sql_literal.rs
index c6ff46a87..1c9af96b4 100644
--- a/diesel/src/expression/sql_literal.rs
+++ b/diesel/src/expression/sql_literal.rs
@@ -86,7 +86,7 @@ impl<ST> SqlLiteral<ST> {
     /// #     use diesel::dsl::sql;
     /// #     use diesel::types::{Integer, Text};
     /// #     let connection = establish_connection();
-    /// #     diesel::insert(&NewUser::new("Jim")).into(users)
+    /// #     diesel::insert_into(users).values(&NewUser::new("Jim"))
     /// #         .execute(&connection).unwrap();
     /// #[cfg(not(feature="postgres"))]
     /// let query = sql::<Text>("SELECT name FROM users WHERE id > ? AND name <> ?");
diff --git a/diesel/src/expression_methods/escape_expression_methods.rs b/diesel/src/expression_methods/escape_expression_methods.rs
index 0c193ce5f..e619da169 100644
--- a/diesel/src/expression_methods/escape_expression_methods.rs
+++ b/diesel/src/expression_methods/escape_expression_methods.rs
@@ -20,9 +20,9 @@ use types::VarChar;
 /// #
 /// # fn main() {
 /// #     use self::users::dsl::*;
-/// #     use diesel::insert;
+/// #     use diesel::insert_into;
 /// #     let connection = establish_connection();
-/// #     insert(&NewUser { name: "Ha%%0r".into() }).into(users)
+/// #     insert_into(users).values(&NewUser { name: "Ha%%0r".into() })
 /// #         .execute(&connection).unwrap();
 /// let users_with_percent = users.select(name)
 ///     .filter(name.like("%ðŸ˜€%%").escape('ðŸ˜€'))
diff --git a/diesel/src/expression_methods/global_expression_methods.rs b/diesel/src/expression_methods/global_expression_methods.rs
index baa087067..da2d13504 100644
--- a/diesel/src/expression_methods/global_expression_methods.rs
+++ b/diesel/src/expression_methods/global_expression_methods.rs
@@ -20,7 +20,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
+    /// #     use users::dsl::*;
     /// #     let connection = establish_connection();
     /// let data = users.select(id).filter(name.eq("Sean"));
     /// assert_eq!(Ok(1), data.first(&connection));
@@ -46,7 +46,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
+    /// #     use users::dsl::*;
     /// #     let connection = establish_connection();
     /// let data = users.select(id).filter(name.ne("Sean"));
     /// assert_eq!(Ok(2), data.first(&connection));
@@ -75,7 +75,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
+    /// #     use users::dsl::*;
     /// #     let connection = establish_connection();
     /// #     connection.execute("INSERT INTO users (name) VALUES
     /// #         ('Jim')").unwrap();
@@ -113,7 +113,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
+    /// #     use users::dsl::*;
     /// #     let connection = establish_connection();
     /// #     connection.execute("INSERT INTO users (name) VALUES
     /// #         ('Jim')").unwrap();
@@ -161,7 +161,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
+    /// #     use users::dsl::*;
     /// #     let connection = establish_connection();
     /// let data = users.select(name).filter(id.gt(1));
     /// assert_eq!(Ok("Tess".to_string()), data.first(&connection));
@@ -187,7 +187,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
+    /// #     use users::dsl::*;
     /// #     let connection = establish_connection();
     /// let data = users.select(name).filter(id.ge(2));
     /// assert_eq!(Ok("Tess".to_string()), data.first(&connection));
@@ -213,7 +213,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
+    /// #     use users::dsl::*;
     /// #     let connection = establish_connection();
     /// let data = users.select(name).filter(id.lt(2));
     /// assert_eq!(Ok("Sean".to_string()), data.first(&connection));
@@ -239,7 +239,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
+    /// #     use users::dsl::*;
     /// #     let connection = establish_connection();
     /// let data = users.select(name).filter(id.le(2));
     /// assert_eq!(Ok("Sean".to_string()), data.first(&connection));
@@ -297,7 +297,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
+    /// #     use users::dsl::*;
     /// #     let order = "name";
     /// let ordering: Box<BoxableExpression<users, DB, SqlType=()>> =
     ///     if order == "name" {
@@ -329,7 +329,7 @@ pub trait NullableExpressionMethods: Expression + Sized {
     /// # #![allow(dead_code)]
     /// # #[macro_use] extern crate diesel;
     /// # include!("../doctest_setup.rs");
-    /// # use self::diesel::types::*;
+    /// # use diesel::types::*;
     /// #
     /// table! {
     ///     users {
@@ -360,8 +360,8 @@ pub trait NullableExpressionMethods: Expression + Sized {
     /// #  joinable!(posts -> users (user_id));
     ///
     /// fn main() {
-    ///     use self::users::dsl::*;
-    ///     use self::posts::dsl::{posts, author_name};
+    ///     use users::dsl::*;
+    ///     use posts::dsl::{posts, author_name};
     ///     let connection = establish_connection();
     ///
     ///     let data = users.inner_join(posts)
diff --git a/diesel/src/lib.rs b/diesel/src/lib.rs
index 43803919f..4aaf50ddb 100644
--- a/diesel/src/lib.rs
+++ b/diesel/src/lib.rs
@@ -161,12 +161,13 @@ pub use prelude::*;
 #[doc(inline)]
 pub use query_builder::debug_query;
 #[doc(inline)]
-pub use query_builder::functions::{default_values, delete, insert, select, update};
+pub use query_builder::functions::{delete, insert_into, replace_into, select, update};
 #[cfg(feature = "with-deprecated")]
 #[doc(inline)]
 #[allow(deprecated)]
-pub use query_builder::functions::insert_default_values;
-#[cfg(feature = "sqlite")]
+pub use query_builder::functions::{insert, insert_default_values};
+#[cfg(all(feature = "sqlite", feature = "with-deprecated"))]
+#[allow(deprecated)]
 pub use sqlite::query_builder::functions::*;
 pub use result::Error::NotFound;
 #[doc(inline)]
diff --git a/diesel/src/macros/as_changeset.rs b/diesel/src/macros/as_changeset.rs
index 8154b56d8..c870ed6bc 100644
--- a/diesel/src/macros/as_changeset.rs
+++ b/diesel/src/macros/as_changeset.rs
@@ -49,8 +49,8 @@
 /// # fn main() {
 /// #     use users::dsl::*;
 /// #     let connection = establish_connection();
-/// diesel::insert(&NewUser::new("Sean"))
-///     .into(users)
+/// diesel::insert_into(users)
+///     .values(&NewUser::new("Sean"))
 ///     .execute(&connection)
 ///     .unwrap();
 /// let user_id = users.select(id).order(id.desc()).first(&connection).unwrap();
diff --git a/diesel/src/macros/insertable.rs b/diesel/src/macros/insertable.rs
index f0d90a458..fb836c26a 100644
--- a/diesel/src/macros/insertable.rs
+++ b/diesel/src/macros/insertable.rs
@@ -262,8 +262,8 @@ mod tests {
             name: "Sean".into(),
             hair_color: "Black".into(),
         };
-        ::insert(&new_user)
-            .into(users::table)
+        ::insert_into(users::table)
+            .values(&new_user)
             .execute(&conn)
             .unwrap();
 
@@ -288,7 +288,7 @@ mod tests {
 
                 let conn = connection();
                 let new_user = NewUser { name: "Sean".into(), hair_color: None };
-                ::insert(&new_user).into(users::table).execute(&conn).unwrap();
+                ::insert_into(users::table).values(&new_user).execute(&conn).unwrap();
 
                 let saved = users::table.select((users::name, users::hair_color))
                     .load::<(String, Option<String>)>(&conn);
@@ -367,8 +367,8 @@ mod tests {
             my_name: "Sean".into(),
             hair_color: "Black".into(),
         };
-        ::insert(&new_user)
-            .into(users::table)
+        ::insert_into(users::table)
+            .values(&new_user)
             .execute(&conn)
             .unwrap();
 
@@ -401,8 +401,8 @@ mod tests {
             my_name: "Sean".into(),
             my_hair_color: None,
         };
-        ::insert(&new_user)
-            .into(users::table)
+        ::insert_into(users::table)
+            .values(&new_user)
             .execute(&conn)
             .unwrap();
 
@@ -429,8 +429,8 @@ mod tests {
 
         let conn = connection();
         let new_user = NewUser("Sean", None);
-        ::insert(&new_user)
-            .into(users::table)
+        ::insert_into(users::table)
+            .values(&new_user)
             .execute(&conn)
             .unwrap();
 
@@ -457,8 +457,8 @@ mod tests {
 
         let conn = connection();
         let new_user = NewUser("Sean", None);
-        ::insert(&new_user)
-            .into(users::table)
+        ::insert_into(users::table)
+            .values(&new_user)
             .execute(&conn)
             .unwrap();
 
@@ -500,7 +500,7 @@ mod tests {
                 conn.execute("DROP TABLE IF EXISTS posts").unwrap();
                 conn.execute("CREATE TABLE posts (id SERIAL PRIMARY KEY, tags TEXT[] NOT NULL)").unwrap();
                 let new_post = NewPost { tags: &["hi", "there"] };
-                ::insert(&new_post).into(posts::table).execute(&conn).unwrap();
+                ::insert_into(posts::table).values(&new_post).execute(&conn).unwrap();
 
                 let saved = posts::table.select(posts::tags).load::<Vec<String>>(&conn);
                 let expected = vec![vec![String::from("hi"), String::from("there")]];
diff --git a/diesel/src/migrations/connection.rs b/diesel/src/migrations/connection.rs
index 6a7073e7b..8800b28ba 100644
--- a/diesel/src/migrations/connection.rs
+++ b/diesel/src/migrations/connection.rs
@@ -36,8 +36,8 @@ where
 
     fn insert_new_migration(&self, ver: &str) -> QueryResult<()> {
         try!(
-            ::insert(&NewMigration(ver))
-                .into(__diesel_schema_migrations)
+            ::insert_into(__diesel_schema_migrations)
+                .values(&NewMigration(ver))
                 .execute(self)
         );
         Ok(())
diff --git a/diesel/src/pg/expression/expression_methods.rs b/diesel/src/pg/expression/expression_methods.rs
index 4da6d6cb3..586494719 100644
--- a/diesel/src/pg/expression/expression_methods.rs
+++ b/diesel/src/pg/expression/expression_methods.rs
@@ -128,11 +128,14 @@ pub trait ArrayExpressionMethods<ST>: Expression<SqlType = Array<ST>> + Sized {
     /// #     conn.execute("DROP TABLE IF EXISTS posts").unwrap();
     /// #     conn.execute("CREATE TABLE posts (id SERIAL PRIMARY KEY, tags TEXT[] NOT NULL)").unwrap();
     /// #
-    /// diesel::insert(&vec![
-    ///     NewPost { tags: vec!["cool", "awesome"] },
-    ///     NewPost { tags: vec!["awesome", "great"] },
-    ///     NewPost { tags: vec!["cool", "great"] },
-    /// ]).into(posts).execute(&conn).unwrap();
+    /// diesel::insert_into(posts)
+    ///     .values(&vec![
+    ///         NewPost { tags: vec!["cool", "awesome"] },
+    ///         NewPost { tags: vec!["awesome", "great"] },
+    ///         NewPost { tags: vec!["cool", "great"] },
+    ///     ])
+    ///     .execute(&conn)
+    ///     .unwrap();
     ///
     /// let query = posts.select(id).filter(tags.overlaps_with(vec!["horrid", "cool"]));
     /// assert_eq!(Ok(vec![1, 3]), query.load(&conn));
@@ -185,9 +188,12 @@ pub trait ArrayExpressionMethods<ST>: Expression<SqlType = Array<ST>> + Sized {
     /// #     conn.execute("DROP TABLE IF EXISTS posts").unwrap();
     /// #     conn.execute("CREATE TABLE posts (id SERIAL PRIMARY KEY, tags TEXT[] NOT NULL)").unwrap();
     /// #
-    /// diesel::insert(&vec![
-    ///     NewPost { tags: vec!["cool", "awesome"] },
-    /// ]).into(posts).execute(&conn).unwrap();
+    /// diesel::insert_into(posts)
+    ///     .values(&vec![
+    ///         NewPost { tags: vec!["cool", "awesome"] },
+    ///     ])
+    ///     .execute(&conn)
+    ///     .unwrap();
     ///
     /// let query = posts.select(id).filter(tags.contains(vec!["cool"]));
     /// assert_eq!(Ok(vec![1]), query.load(&conn));
@@ -238,9 +244,12 @@ pub trait ArrayExpressionMethods<ST>: Expression<SqlType = Array<ST>> + Sized {
     /// #     conn.execute("DROP TABLE IF EXISTS posts").unwrap();
     /// #     conn.execute("CREATE TABLE posts (id SERIAL PRIMARY KEY, tags TEXT[] NOT NULL)").unwrap();
     /// #
-    /// diesel::insert(&vec![
-    ///     NewPost { tags: vec!["cool", "awesome"] },
-    /// ]).into(posts).execute(&conn).unwrap();
+    /// diesel::insert_into(posts)
+    ///     .values(&vec![
+    ///         NewPost { tags: vec!["cool", "awesome"] },
+    ///     ])
+    ///     .execute(&conn)
+    ///     .unwrap();
     ///
     /// let query = posts.select(id).filter(tags.is_contained_by(vec!["cool", "awesome", "amazing"]));
     /// assert_eq!(Ok(vec![1]), query.load(&conn));
diff --git a/diesel/src/pg/types/mod.rs b/diesel/src/pg/types/mod.rs
index 72bb86587..d89a97081 100644
--- a/diesel/src/pg/types/mod.rs
+++ b/diesel/src/pg/types/mod.rs
@@ -221,8 +221,8 @@ pub mod sql_types {
     /// }
     ///
     /// # fn main() {
-    /// #     use self::diesel::insert;
-    /// #     use self::contacts::dsl::*;
+    /// #     use diesel::insert_into;
+    /// #     use contacts::dsl::*;
     /// #     let connection = connection_no_data();
     /// #     connection.execute("CREATE TABLE contacts (
     /// #         id SERIAL PRIMARY KEY,
@@ -239,7 +239,7 @@ pub mod sql_types {
     ///     name: "Claus".into(),
     ///     address: santas_address.clone()
     /// };
-    /// let inserted_contact = insert(&new_contact).into(contacts)
+    /// let inserted_contact = insert_into(contacts).values(&new_contact)
     ///     .get_result::<Contact>(&connection).unwrap();
     /// assert_eq!(santas_address, inserted_contact.address);
     /// # }
@@ -300,8 +300,8 @@ pub mod sql_types {
     /// }
     ///
     /// # fn main() {
-    /// #     use self::diesel::insert;
-    /// #     use self::items::dsl::*;
+    /// #     use diesel::insert_into;
+    /// #     use items::dsl::*;
     /// #     let connection = connection_no_data();
     /// #     connection.execute("CREATE TABLE items (
     /// #         id SERIAL PRIMARY KEY,
@@ -312,7 +312,7 @@ pub mod sql_types {
     ///     name: "Shiny Thing".into(),
     ///     price: Cents(123_456),
     /// };
-    /// let inserted_item = insert(&new_item).into(items)
+    /// let inserted_item = insert_into(items).values(&new_item)
     ///     .get_result::<Item>(&connection).unwrap();
     /// assert_eq!(Cents(123_456), inserted_item.price);
     /// # }
@@ -368,8 +368,8 @@ pub mod sql_types {
     /// }
     ///
     /// # fn main() {
-    /// #     use self::diesel::insert;
-    /// #     use self::devices::dsl::*;
+    /// #     use diesel::insert_into;
+    /// #     use devices::dsl::*;
     /// #     let connection = connection_no_data();
     /// #     connection.execute("CREATE TABLE devices (
     /// #         id SERIAL PRIMARY KEY,
@@ -378,7 +378,7 @@ pub mod sql_types {
     /// let new_device = NewDevice {
     ///     macaddr: [0x08, 0x00, 0x2b, 0x01, 0x02, 0x03],
     /// };
-    /// let inserted_device = insert(&new_device).into(devices)
+    /// let inserted_device = insert_into(devices).values(&new_device)
     ///     .get_result::<Device>(&connection).unwrap();
     /// assert_eq!([0x08, 0x00, 0x2b, 0x01, 0x02, 0x03], inserted_device.macaddr);
     /// # }
@@ -443,8 +443,8 @@ pub mod sql_types {
     /// }
     ///
     /// # fn main() {
-    /// #     use self::diesel::insert;
-    /// #     use self::clients::dsl::*;
+    /// #     use diesel::insert_into;
+    /// #     use clients::dsl::*;
     /// #     use std::str::FromStr;
     /// #     let connection = connection_no_data();
     /// #     connection.execute("CREATE TABLE clients (
@@ -454,7 +454,7 @@ pub mod sql_types {
     /// let new_client = NewClient {
     ///     ip_address: "10.1.9.32/32".parse().unwrap(),
     /// };
-    /// let inserted_client = insert(&new_client).into(clients)
+    /// let inserted_client = insert_into(clients).values(&new_client)
     ///     .get_result::<Client>(&connection).unwrap();
     /// assert_eq!(IpNetwork::from_str("10.1.9.32/32").unwrap(), inserted_client.ip_address);
     /// # }
@@ -514,8 +514,8 @@ pub mod sql_types {
     /// }
     ///
     /// # fn main() {
-    /// #     use self::diesel::insert;
-    /// #     use self::clients::dsl::*;
+    /// #     use diesel::insert_into;
+    /// #     use clients::dsl::*;
     /// #     use std::str::FromStr;
     /// #     let connection = connection_no_data();
     /// #     connection.execute("CREATE TABLE clients (
@@ -525,7 +525,7 @@ pub mod sql_types {
     /// let new_client = NewClient {
     ///     ip_address: "10.1.9.32/32".parse().unwrap(),
     /// };
-    /// let inserted_client = insert(&new_client).into(clients)
+    /// let inserted_client = insert_into(clients).values(&new_client)
     ///     .get_result::<Client>(&connection).unwrap();
     /// assert_eq!(IpNetwork::from_str("10.1.9.32/32").unwrap(), inserted_client.ip_address);
     /// # }
diff --git a/diesel/src/pg/upsert/on_conflict_actions.rs b/diesel/src/pg/upsert/on_conflict_actions.rs
index a8ff65dbe..90fc236ab 100644
--- a/diesel/src/pg/upsert/on_conflict_actions.rs
+++ b/diesel/src/pg/upsert/on_conflict_actions.rs
@@ -33,19 +33,21 @@ pub fn do_nothing() -> DoNothing {
 /// # include!("on_conflict_docs_setup.rs");
 /// #
 /// # fn main() {
-/// #     use self::users::dsl::*;
-/// use self::diesel::pg::upsert::*;
+/// #     use users::dsl::*;
+/// use diesel::pg::upsert::*;
 ///
 /// #     let conn = establish_connection();
 /// #     conn.execute("TRUNCATE TABLE users").unwrap();
 /// let user = User { id: 1, name: "Pascal" };
 /// let user2 = User { id: 1, name: "Sean" };
 ///
-/// assert_eq!(Ok(1), diesel::insert(&user).into(users).execute(&conn));
+/// assert_eq!(Ok(1), diesel::insert_into(users).values(&user).execute(&conn));
 ///
-/// let insert_count = diesel::insert(
-///     &user2.on_conflict(id, do_update().set(name.eq("I DONT KNOW ANYMORE")))
-/// ).into(users).execute(&conn);
+/// let insert_count = diesel::insert_into(users)
+///     .values(
+///         &user2.on_conflict(id, do_update().set(name.eq("I DONT KNOW ANYMORE")))
+///     )
+///     .execute(&conn);
 /// assert_eq!(Ok(1), insert_count);
 ///
 /// let users_in_db = users.load(&conn);
@@ -61,19 +63,21 @@ pub fn do_nothing() -> DoNothing {
 /// # include!("on_conflict_docs_setup.rs");
 /// #
 /// # fn main() {
-/// #     use self::users::dsl::*;
-/// use self::diesel::pg::upsert::*;
+/// #     use users::dsl::*;
+/// use diesel::pg::upsert::*;
 ///
 /// #     let conn = establish_connection();
 /// #     conn.execute("TRUNCATE TABLE users").unwrap();
 /// let user = User { id: 1, name: "Pascal" };
 /// let user2 = User { id: 1, name: "Sean" };
 ///
-/// assert_eq!(Ok(1), diesel::insert(&user).into(users).execute(&conn));
+/// assert_eq!(Ok(1), diesel::insert_into(users).values(&user).execute(&conn));
 ///
-/// let insert_count = diesel::insert(
-///     &user2.on_conflict(id, do_update().set(&user2))
-/// ).into(users).execute(&conn);
+/// let insert_count = diesel::insert_into(users)
+///     .values(
+///         &user2.on_conflict(id, do_update().set(&user2))
+///     )
+///     .execute(&conn);
 /// assert_eq!(Ok(1), insert_count);
 ///
 /// let users_in_db = users.load(&conn);
@@ -89,8 +93,8 @@ pub fn do_nothing() -> DoNothing {
 /// # include!("on_conflict_docs_setup.rs");
 /// #
 /// # fn main() {
-/// #     use self::users::dsl::*;
-/// use self::diesel::pg::upsert::*;
+/// #     use users::dsl::*;
+/// use diesel::pg::upsert::*;
 ///
 /// #     let conn = establish_connection();
 /// #     conn.execute("TRUNCATE TABLE users").unwrap();
@@ -98,11 +102,14 @@ pub fn do_nothing() -> DoNothing {
 /// let user2 = User { id: 1, name: "Sean" };
 /// let user3 = User { id: 2, name: "Tess" };
 ///
-/// assert_eq!(Ok(1), diesel::insert(&user).into(users).execute(&conn));
+/// assert_eq!(Ok(1), diesel::insert_into(users).values(&user).execute(&conn));
 ///
-/// let insert_count = diesel::insert(&vec![user2, user3]
-///     .on_conflict(id, do_update().set(name.eq(excluded(name))))
-/// ).into(users).execute(&conn);
+/// let insert_count = diesel::insert_into(users)
+///     .values(
+///         &vec![user2, user3]
+///             .on_conflict(id, do_update().set(name.eq(excluded(name))))
+///     )
+///     .execute(&conn);
 /// assert_eq!(Ok(2), insert_count);
 ///
 /// let users_in_db = users.load(&conn);
diff --git a/diesel/src/pg/upsert/on_conflict_extension.rs b/diesel/src/pg/upsert/on_conflict_extension.rs
index 216e1eaaf..ff2001816 100644
--- a/diesel/src/pg/upsert/on_conflict_extension.rs
+++ b/diesel/src/pg/upsert/on_conflict_extension.rs
@@ -16,19 +16,21 @@ pub trait OnConflictExtension {
     /// # include!("on_conflict_docs_setup.rs");
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
-    /// use self::diesel::pg::upsert::*;
+    /// #     use users::dsl::*;
+    /// use diesel::pg::upsert::*;
     ///
     /// #     let conn = establish_connection();
     /// #     conn.execute("TRUNCATE TABLE users").unwrap();
     /// let user = User { id: 1, name: "Sean", };
     ///
-    /// let inserted_row_count = diesel::insert(&user.on_conflict_do_nothing())
-    ///     .into(users).execute(&conn);
+    /// let inserted_row_count = diesel::insert_into(users)
+    ///     .values(&user.on_conflict_do_nothing())
+    ///     .execute(&conn);
     /// assert_eq!(Ok(1), inserted_row_count);
     ///
-    /// let inserted_row_count = diesel::insert(&user.on_conflict_do_nothing())
-    ///     .into(users).execute(&conn);
+    /// let inserted_row_count = diesel::insert_into(users)
+    ///     .values(&user.on_conflict_do_nothing())
+    ///     .execute(&conn);
     /// assert_eq!(Ok(0), inserted_row_count);
     /// # }
     /// ```
@@ -41,15 +43,16 @@ pub trait OnConflictExtension {
     /// # include!("on_conflict_docs_setup.rs");
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
-    /// use self::diesel::pg::upsert::*;
+    /// #     use users::dsl::*;
+    /// use diesel::pg::upsert::*;
     ///
     /// #     let conn = establish_connection();
     /// #     conn.execute("TRUNCATE TABLE users").unwrap();
     /// let user = User { id: 1, name: "Sean", };
     ///
-    /// let inserted_row_count = diesel::insert(&vec![user, user].on_conflict_do_nothing())
-    ///     .into(users).execute(&conn);
+    /// let inserted_row_count = diesel::insert_into(users)
+    ///     .values(&vec![user, user].on_conflict_do_nothing())
+    ///     .execute(&conn);
     /// assert_eq!(Ok(1), inserted_row_count);
     /// # }
     /// ```
@@ -62,16 +65,17 @@ pub trait OnConflictExtension {
     /// # include!("on_conflict_docs_setup.rs");
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
-    /// use self::diesel::pg::upsert::*;
+    /// #     use users::dsl::*;
+    /// use diesel::pg::upsert::*;
     ///
     /// #     let conn = establish_connection();
     /// #     conn.execute("TRUNCATE TABLE users").unwrap();
     /// let user = User { id: 1, name: "Sean", };
     ///
     /// let new_users: &[User] = &[user, user];
-    /// let inserted_row_count = diesel::insert(&new_users.on_conflict_do_nothing())
-    ///     .into(users).execute(&conn);
+    /// let inserted_row_count = diesel::insert_into(users)
+    ///     .values(&new_users.on_conflict_do_nothing())
+    ///     .execute(&conn);
     /// assert_eq!(Ok(1), inserted_row_count);
     /// # }
     /// ```
@@ -103,8 +107,8 @@ pub trait OnConflictExtension {
     /// # include!("on_conflict_docs_setup.rs");
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
-    /// use self::diesel::pg::upsert::*;
+    /// #     use users::dsl::*;
+    /// use diesel::pg::upsert::*;
     ///
     /// #     let conn = establish_connection();
     /// #     conn.execute("TRUNCATE TABLE users").unwrap();
@@ -113,16 +117,20 @@ pub trait OnConflictExtension {
     /// let same_name_different_id = User { id: 2, name: "Sean" };
     /// let same_id_different_name = User { id: 1, name: "Pascal" };
     ///
-    /// assert_eq!(Ok(1), diesel::insert(&user).into(users).execute(&conn));
+    /// assert_eq!(Ok(1), diesel::insert_into(users).values(&user).execute(&conn));
     ///
-    /// let inserted_row_count = diesel::insert(
-    ///     &same_name_different_id.on_conflict(name, do_nothing())
-    /// ).into(users).execute(&conn);
+    /// let inserted_row_count = diesel::insert_into(users)
+    ///     .values(
+    ///         &same_name_different_id.on_conflict(name, do_nothing())
+    ///     )
+    ///     .execute(&conn);
     /// assert_eq!(Ok(0), inserted_row_count);
     ///
-    /// let pk_conflict_result = diesel::insert(
-    ///     &same_id_different_name.on_conflict(name, do_nothing())
-    /// ).into(users).execute(&conn);
+    /// let pk_conflict_result = diesel::insert_into(users)
+    ///     .values(
+    ///         &same_id_different_name.on_conflict(name, do_nothing())
+    ///     )
+    ///     .execute(&conn);
     /// assert!(pk_conflict_result.is_err());
     /// # }
     /// ```
@@ -151,8 +159,8 @@ pub trait OnConflictExtension {
     /// # }
     /// #
     /// # fn main() {
-    /// #     use self::users::dsl::*;
-    /// use self::diesel::pg::upsert::*;
+    /// #     use users::dsl::*;
+    /// use diesel::pg::upsert::*;
     ///
     /// #     let conn = establish_connection();
     /// #     conn.execute("DROP TABLE users").unwrap();
@@ -162,16 +170,20 @@ pub trait OnConflictExtension {
     /// let same_name_different_hair_color = User { id: 2, name: "Sean", hair_color: "brown" };
     /// let same_same_name_same_hair_color = User { id: 3, name: "Sean", hair_color: "black" };
     ///
-    /// assert_eq!(Ok(1), diesel::insert(&user).into(users).execute(&conn));
+    /// assert_eq!(Ok(1), diesel::insert_into(users).values(&user).execute(&conn));
     ///
-    /// let inserted_row_count = diesel::insert(
-    ///     &same_name_different_hair_color.on_conflict((name, hair_color), do_nothing())
-    /// ).into(users).execute(&conn);
+    /// let inserted_row_count = diesel::insert_into(users)
+    ///     .values(
+    ///         &same_name_different_hair_color.on_conflict((name, hair_color), do_nothing())
+    ///     )
+    ///     .execute(&conn);
     /// assert_eq!(Ok(1), inserted_row_count);
     ///
-    /// let inserted_row_count = diesel::insert(
-    ///     &same_same_name_same_hair_color.on_conflict((name, hair_color), do_nothing())
-    /// ).into(users).execute(&conn);
+    /// let inserted_row_count = diesel::insert_into(users)
+    ///     .values(
+    ///         &same_same_name_same_hair_color.on_conflict((name, hair_color), do_nothing())
+    ///     )
+    ///     .execute(&conn);
     /// assert_eq!(Ok(0), inserted_row_count);
     /// # }
     /// ```
diff --git a/diesel/src/pg/upsert/on_conflict_target.rs b/diesel/src/pg/upsert/on_conflict_target.rs
index c80cda831..3f6ca8b58 100644
--- a/diesel/src/pg/upsert/on_conflict_target.rs
+++ b/diesel/src/pg/upsert/on_conflict_target.rs
@@ -16,8 +16,8 @@ use result::QueryResult;
 /// # include!("on_conflict_docs_setup.rs");
 /// #
 /// # fn main() {
-/// #     use self::users::dsl::*;
-/// use self::diesel::pg::upsert::*;
+/// #     use users::dsl::*;
+/// use diesel::pg::upsert::*;
 ///
 /// #     let conn = establish_connection();
 /// #     conn.execute("TRUNCATE TABLE users").unwrap();
@@ -26,16 +26,20 @@ use result::QueryResult;
 /// let same_name_different_id = User { id: 2, name: "Sean" };
 /// let same_id_different_name = User { id: 1, name: "Pascal" };
 ///
-/// assert_eq!(Ok(1), diesel::insert(&user).into(users).execute(&conn));
+/// assert_eq!(Ok(1), diesel::insert_into(users).values(&user).execute(&conn));
 ///
-/// let inserted_row_count = diesel::insert(
-///     &same_name_different_id.on_conflict(on_constraint("users_name"), do_nothing())
-/// ).into(users).execute(&conn);
+/// let inserted_row_count = diesel::insert_into(users)
+///     .values(
+///         &same_name_different_id.on_conflict(on_constraint("users_name"), do_nothing())
+///     )
+///     .execute(&conn);
 /// assert_eq!(Ok(0), inserted_row_count);
 ///
-/// let pk_conflict_result = diesel::insert(
-///     &same_id_different_name.on_conflict(on_constraint("users_name"), do_nothing())
-/// ).into(users).execute(&conn);
+/// let pk_conflict_result = diesel::insert_into(users)
+///     .values(
+///         &same_id_different_name.on_conflict(on_constraint("users_name"), do_nothing())
+///     )
+///     .execute(&conn);
 /// assert!(pk_conflict_result.is_err());
 /// # }
 /// ```
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index d19e4f5a9..9978c6da4 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -2,7 +2,9 @@ use dsl::Select;
 use expression::Expression;
 use query_dsl::SelectDsl;
 use super::delete_statement::DeleteStatement;
-use super::insert_statement::{DefaultValues, Insert};
+#[cfg(feature = "with-deprecated")]
+use super::insert_statement::{DefaultValues, DeprecatedIncompleteInsertStatement};
+use super::insert_statement::{Insert, Replace};
 use super::{IncompleteInsertStatement, IncompleteUpdateStatement, IntoUpdateTarget,
             SelectStatement};
 
@@ -24,7 +26,7 @@ use super::{IncompleteInsertStatement, IncompleteUpdateStatement, IntoUpdateTarg
 /// #
 /// # #[cfg(feature = "postgres")]
 /// # fn main() {
-/// #     use self::users::dsl::*;
+/// #     use users::dsl::*;
 /// #     let connection = establish_connection();
 /// let updated_row = diesel::update(users.filter(id.eq(1)))
 ///     .set(name.eq("James"))
@@ -103,7 +105,7 @@ pub fn update<T: IntoUpdateTarget>(
 /// # }
 /// #
 /// # fn delete() -> QueryResult<()> {
-/// #     use self::users::dsl::*;
+/// #     use users::dsl::*;
 /// #     let connection = establish_connection();
 /// #     let get_count = || users.count().first::<i64>(&connection);
 /// let old_count = get_count();
@@ -131,7 +133,7 @@ pub fn update<T: IntoUpdateTarget>(
 /// # }
 /// #
 /// # fn delete() -> QueryResult<()> {
-/// #     use self::users::dsl::*;
+/// #     use users::dsl::*;
 /// #     let connection = establish_connection();
 /// #     let get_count = || users.count().first::<i64>(&connection);
 /// try!(diesel::delete(users).execute(&connection));
@@ -291,8 +293,161 @@ pub fn delete<T: IntoUpdateTarget>(source: T) -> DeleteStatement<T::Table, T::Wh
 /// # #[cfg(not(feature = "postgres"))]
 /// # fn main() {}
 /// ```
-pub fn insert<T: ?Sized>(records: &T) -> IncompleteInsertStatement<&T, Insert> {
-    IncompleteInsertStatement::new(records, Insert)
+#[cfg(feature = "with-deprecated")]
+#[deprecated(since = "0.99.0", note = "use `insert_into` instead")]
+pub fn insert<T: ?Sized>(records: &T) -> DeprecatedIncompleteInsertStatement<&T, Insert> {
+    DeprecatedIncompleteInsertStatement::new(records, Insert)
+}
+
+/// Creates an `INSERT` statement. Will add the given data to a table. As with
+/// other commands, the resulting query can return the inserted rows if you
+/// choose if you are using PostgreSQL.
+///
+/// # Examples
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # include!("../doctest_setup.rs");
+/// #
+/// # table! {
+/// #     users {
+/// #         id -> Integer,
+/// #         name -> Text,
+/// #     }
+/// # }
+/// #
+/// # fn main() {
+/// #     use users::dsl::*;
+/// #     let connection = establish_connection();
+/// let rows_inserted = diesel::insert_into(users)
+///     .values(&name.eq("Sean"))
+///     .execute(&connection);
+///
+/// assert_eq!(Ok(1), rows_inserted);
+///
+/// let new_users = vec![
+///     name.eq("Tess"),
+///     name.eq("Jim"),
+/// ];
+///
+/// let rows_inserted = diesel::insert_into(users)
+///     .values(&new_users)
+///     .execute(&connection);
+///
+/// assert_eq!(Ok(2), rows_inserted);
+/// # }
+/// ```
+///
+/// ### Using a tuple for values
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # include!("../doctest_setup.rs");
+/// #
+/// # table! {
+/// #     users {
+/// #         id -> Integer,
+/// #         name -> Text,
+/// #     }
+/// # }
+/// #
+/// # fn main() {
+/// #     use users::dsl::*;
+/// #     let connection = establish_connection();
+/// #     diesel::delete(users).execute(&connection).unwrap();
+/// let new_user = (id.eq(1), name.eq("Sean"));
+/// let rows_inserted = diesel::insert_into(users)
+///     .values(&new_user)
+///     .execute(&connection);
+///
+/// assert_eq!(Ok(1), rows_inserted);
+///
+/// let new_users = vec![
+///     (id.eq(2), name.eq("Tess")),
+///     (id.eq(2), name.eq("Jim")),
+/// ];
+///
+/// let rows_inserted = diesel::insert_into(users)
+///     .values(&new_users)
+///     .execute(&connection);
+///
+/// // assert_eq!(Ok(2), rows_inserted);
+/// # }
+/// ```
+///
+/// ### Using struct for values
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # include!("../doctest_setup.rs");
+/// #
+/// # table! {
+/// #     users {
+/// #         id -> Integer,
+/// #         name -> Text,
+/// #     }
+/// # }
+/// #
+/// # fn main() {
+/// #     use users::dsl::*;
+/// #     let connection = establish_connection();
+/// // Insert one record at a time
+///
+/// let new_user = NewUser { name: "Ruby Rhod".to_string() };
+///
+/// diesel::insert_into(users)
+///     .values(&new_user)
+///     .execute(&connection)
+///     .unwrap();
+///
+/// // Insert many records
+///
+/// let new_users = vec![
+///     NewUser { name: "Leeloo Multipass".to_string(), },
+///     NewUser { name: "Korben Dallas".to_string(), },
+/// ];
+///
+/// let inserted_names = diesel::insert_into(users)
+///     .values(&new_users)
+///     .execute(&connection)
+///     .unwrap();
+/// # }
+/// ```
+///
+/// ### With return value
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # include!("../doctest_setup.rs");
+/// #
+/// # table! {
+/// #     users {
+/// #         id -> Integer,
+/// #         name -> Text,
+/// #     }
+/// # }
+/// #
+/// # #[cfg(feature = "postgres")]
+/// # fn main() {
+/// #     use users::dsl::*;
+/// #     let connection = establish_connection();
+/// // postgres only
+/// let new_users = vec![
+///     NewUser { name: "Diva Plavalaguna".to_string(), },
+///     NewUser { name: "Father Vito Cornelius".to_string(), },
+/// ];
+///
+/// let inserted_names = diesel::insert_into(users)
+///     .values(&new_users)
+///     .returning(name)
+///     .get_results(&connection);
+/// assert_eq!(Ok(vec!["Diva Plavalaguna".to_string(), "Father Vito Cornelius".to_string()]), inserted_names);
+/// # }
+/// # #[cfg(not(feature = "postgres"))]
+/// # fn main() {}
+/// ```
+pub fn insert_into<T>(target: T) -> IncompleteInsertStatement<T, Insert> {
+    IncompleteInsertStatement::new(target, Insert)
 }
 
 /// Creates a bare select statement, with no from clause. Primarily used for
@@ -311,12 +466,71 @@ where
 /// This function is not exported by default. As with other commands, the resulting
 /// query can return the inserted rows if you choose.
 #[cfg(feature = "with-deprecated")]
-#[deprecated(since = "0.99.0", note = "use `insert(&default_values())` instead")]
-pub fn insert_default_values() -> IncompleteInsertStatement<&'static DefaultValues, Insert> {
+#[deprecated(since = "0.99.0", note = "use `insert_into(table).default_values()` instead")]
+#[allow(deprecated)]
+pub fn insert_default_values() -> DeprecatedIncompleteInsertStatement<&'static DefaultValues, Insert> {
     static STATIC_DEFAULT_VALUES: &'static DefaultValues = &DefaultValues;
     insert(STATIC_DEFAULT_VALUES)
 }
 
-pub fn default_values() -> DefaultValues {
-    DefaultValues
+/// Creates a `REPLACE` statement.
+///
+/// If a constraint violation fails, the database will attempt to replace the
+/// offending row instead. This function is only available with MySQL and
+/// SQLite.
+///
+/// # Example
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # #[macro_use] extern crate diesel_codegen;
+/// # include!("../doctest_setup.rs");
+/// #
+/// # table! {
+/// #     users {
+/// #         id -> Integer,
+/// #         name -> VarChar,
+/// #     }
+/// # }
+/// #
+/// # #[derive(Insertable)]
+/// # #[table_name="users"]
+/// # struct User<'a> {
+/// #     id: i32,
+/// #     name: &'a str,
+/// # }
+/// #
+/// # #[cfg(not(feature = "postgres"))]
+/// # fn main() {
+/// #     use users::dsl::*;
+/// #     use diesel::{insert_into, replace_into};
+/// #
+/// #     let conn = establish_connection();
+/// #     conn.execute("DELETE FROM users").unwrap();
+/// replace_into(users)
+///     .values(&vec![
+///         User {
+///             id: 1,
+///             name: "Sean",
+///         },
+///         User {
+///             id: 2,
+///             name: "Tess",
+///         },
+///     ])
+///     .execute(&conn)
+///     .unwrap();
+///
+/// let new_user = User { id: 1, name: "Jim" };
+/// replace_into(users)
+///     .values(&new_user)
+///     .execute(&conn)
+///     .unwrap();
+///
+/// let names = users.select(name).order(id).load::<String>(&conn);
+/// assert_eq!(Ok(vec!["Jim".into(), "Tess".into()]), names);
+/// # }
+/// # #[cfg(feature = "postgres")] fn main() {}
+pub fn replace_into<T>(target: T) -> IncompleteInsertStatement<T, Replace> {
+    IncompleteInsertStatement::new(target, Replace)
 }
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index a22bfe6db..462820c38 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -1,7 +1,11 @@
+use std::any::*;
+
 use backend::Backend;
 use expression::{Expression, NonAggregate, SelectableExpression};
 use expression::operators::Eq;
 use insertable::{CanInsertInSingleQuery, InsertValues, Insertable};
+#[cfg(feature = "mysql")]
+use mysql::Mysql;
 use query_builder::*;
 #[cfg(feature = "sqlite")]
 use query_dsl::ExecuteDsl;
@@ -11,18 +15,79 @@ use result::QueryResult;
 use sqlite::{Sqlite, SqliteConnection};
 use super::returning_clause::*;
 
+/// The structure returned by [`insert_into`](../../fn.insert_into.html).
+#[derive(Debug, Clone, Copy)]
+pub struct IncompleteInsertStatement<T, Op> {
+    target: T,
+    operator: Op,
+}
+
+impl<T, Op> IncompleteInsertStatement<T, Op> {
+    pub(crate) fn new(target: T, operator: Op) -> Self {
+        IncompleteInsertStatement { target, operator }
+    }
+
+    /// Inserts `DEFAULT VALUES` into the targeted table.
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// #
+    /// # table! {
+    /// #     users (name) {
+    /// #         name -> Text,
+    /// #         hair_color -> Text,
+    /// #     }
+    /// # }
+    /// #
+    /// # fn main() {
+    /// #     use diesel::insert_into;
+    /// #     use users::dsl::*;
+    /// #     let connection = connection_no_data();
+    /// connection.execute("CREATE TABLE users (
+    ///     name VARCHAR(255) NOT NULL DEFAULT 'Sean',
+    ///     hair_color VARCHAR(255) NOT NULL DEFAULT 'Green'
+    /// )").unwrap();
+    ///
+    /// insert_into(users)
+    ///     .default_values()
+    ///     .execute(&connection)
+    ///     .unwrap();
+    ///
+    /// let expected_data = vec![
+    ///     ("Sean".to_string(), "Green".to_string()),
+    /// ];
+    /// assert_eq!(Ok(expected_data), users.load(&connection));
+    /// # }
+    /// ```
+    pub fn default_values(self) -> InsertStatement<T, &'static DefaultValues, Op> {
+        static STATIC_DEFAULT_VALUES: &'static DefaultValues = &DefaultValues;
+        self.values(STATIC_DEFAULT_VALUES)
+    }
+
+    /// Inserts the given values into the table passed to `insert_into`.
+    ///
+    /// See the documentation of [`insert_into`](../fn.insert_into.html) for
+    /// usage examples.
+    pub fn values<U: ?Sized>(self, records: &U) -> InsertStatement<T, &U, Op> {
+        InsertStatement::new(self.target, records, self.operator, NoReturningClause)
+    }
+}
+
 /// The structure returned by [`insert`](/diesel/fn.insert.html). The only thing that can be done with it
 /// is call `into`.
 #[derive(Debug, Copy, Clone)]
-pub struct IncompleteInsertStatement<T, Op> {
+#[cfg(feature = "with-deprecated")]
+pub struct DeprecatedIncompleteInsertStatement<T, Op> {
     records: T,
     operator: Op,
 }
 
-impl<T, Op> IncompleteInsertStatement<T, Op> {
+#[cfg(feature = "with-deprecated")]
+impl<T, Op> DeprecatedIncompleteInsertStatement<T, Op> {
     #[doc(hidden)]
     pub fn new(records: T, operator: Op) -> Self {
-        IncompleteInsertStatement {
+        DeprecatedIncompleteInsertStatement {
             records: records,
             operator: operator,
         }
@@ -177,8 +242,8 @@ impl<T, U, Op> InsertStatement<T, U, Op> {
     ///     NewUser { name: "Jimmy".to_string(), },
     /// ];
     ///
-    /// let inserted_names = diesel::insert(&new_users)
-    ///     .into(users)
+    /// let inserted_names = diesel::insert_into(users)
+    ///     .values(&new_users)
     ///     .returning(name)
     ///     .get_results(&connection);
     /// assert_eq!(Ok(vec!["Timmy".to_string(), "Jimmy".to_string()]), inserted_names);
@@ -200,6 +265,7 @@ impl<T, U, Op> InsertStatement<T, U, Op> {
 }
 
 #[derive(Debug, Copy, Clone)]
+#[doc(hidden)]
 pub struct Insert;
 
 impl<DB: Backend> QueryFragment<DB> for Insert {
@@ -211,6 +277,28 @@ impl<DB: Backend> QueryFragment<DB> for Insert {
 
 impl_query_id!(Insert);
 
+#[derive(Debug, Copy, Clone)]
+#[doc(hidden)]
+pub struct Replace;
+
+#[cfg(feature = "sqlite")]
+impl QueryFragment<Sqlite> for Replace {
+    fn walk_ast(&self, mut out: AstPass<Sqlite>) -> QueryResult<()> {
+        out.push_sql("REPLACE");
+        Ok(())
+    }
+}
+
+#[cfg(feature = "mysql")]
+impl QueryFragment<Mysql> for Replace {
+    fn walk_ast(&self, mut out: AstPass<Mysql>) -> QueryResult<()> {
+        out.push_sql("REPLACE");
+        Ok(())
+    }
+}
+
+impl_query_id!(Replace);
+
 /// Marker trait to indicate that no additional operations have been added
 /// to a record for insert. Used to prevent things like
 /// `insert(&vec![user.on_conflict_do_nothing(), user2.on_conflict_do_nothing()])`
@@ -255,6 +343,7 @@ impl<'a, Tab, DB> Insertable<Tab, DB> for &'a DefaultValues
 where
     Tab: Table,
     DB: Backend,
+    DefaultValues: InsertValues<Tab, DB>,
 {
     type Values = DefaultValues;
 
@@ -266,7 +355,7 @@ where
 impl<Tab, DB> InsertValues<Tab, DB> for DefaultValues
 where
     Tab: Table,
-    DB: Backend,
+    DB: Backend + Any,
 {
     fn column_names(&self, _: &mut DB::QueryBuilder) -> QueryResult<()> {
         Ok(())
@@ -276,7 +365,18 @@ where
         Ok(())
     }
 
+    #[cfg(not(feature = "mysql"))]
     fn is_noop(&self) -> bool {
         true
     }
+
+    #[cfg(feature = "mysql")]
+    fn is_noop(&self) -> bool {
+        // The syntax for this on MySQL is
+        // INSERT INTO table () VALUES ()
+        //
+        // This is hacky, but it's the easiest way to get this done without a
+        // deeper restructuring of this code.
+        TypeId::of::<DB>() != TypeId::of::<::mysql::Mysql>()
+    }
 }
diff --git a/diesel/src/query_dsl/load_dsl.rs b/diesel/src/query_dsl/load_dsl.rs
index 058dd1abc..647b42fb8 100644
--- a/diesel/src/query_dsl/load_dsl.rs
+++ b/diesel/src/query_dsl/load_dsl.rs
@@ -99,7 +99,7 @@ pub trait FirstDsl<Conn>: LimitDsl + LoadDsl<Conn> {
     /// #   let connection = establish_connection();
     /// let user1 = NewUser { name: "Sean".into() };
     /// let user2 = NewUser { name: "Pascal".into() };
-    /// diesel::insert(&vec![user1, user2]).into(users::table).execute(&connection).unwrap();
+    /// diesel::insert_into(users::table).values(&vec![user1, user2]).execute(&connection).unwrap();
     ///
     /// let user = users::table.order(users::id.asc()).first(&connection);
     /// assert_eq!(Ok(User { id: 1, name: "Sean".into() }), user);
diff --git a/diesel/src/sqlite/query_builder/functions.rs b/diesel/src/sqlite/query_builder/functions.rs
index ec3f34ec5..230070f4d 100644
--- a/diesel/src/sqlite/query_builder/functions.rs
+++ b/diesel/src/sqlite/query_builder/functions.rs
@@ -1,6 +1,6 @@
-use expression::operators::Or;
-use query_builder::insert_statement::{IncompleteInsertStatement, Insert};
-use super::nodes::Replace;
+#![cfg(feature = "with-deprecated")]
+use query_builder::insert_statement::{DeprecatedIncompleteInsertStatement, Replace};
+
 /// Creates a SQLite `INSERT OR REPLACE` statement. If a constraint violation
 /// fails, SQLite will attempt to replace the offending row instead.
 ///
@@ -27,14 +27,14 @@ use super::nodes::Replace;
 /// #
 /// #
 /// # fn main() {
-/// #     use self::users::dsl::*;
-/// #     use self::diesel::{insert, insert_or_replace};
-/// #     use self::diesel::sqlite::SqliteConnection;
+/// #     use users::dsl::*;
+/// #     use diesel::{insert_into, insert_or_replace};
+/// #     use diesel::sqlite::SqliteConnection;
 /// #
 /// #     let conn = SqliteConnection::establish(":memory:").unwrap();
 /// #     conn.execute("CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR)").unwrap();
-/// insert(&NewUser::new("Sean")).into(users).execute(&conn).unwrap();
-/// insert(&NewUser::new("Tess")).into(users).execute(&conn).unwrap();
+/// insert_into(users).values(&NewUser::new("Sean")).execute(&conn).unwrap();
+/// insert_into(users).values(&NewUser::new("Tess")).execute(&conn).unwrap();
 ///
 /// let new_user = User { id: 1, name: "Jim" };
 /// insert_or_replace(&new_user).into(users).execute(&conn).unwrap();
@@ -43,8 +43,9 @@ use super::nodes::Replace;
 /// assert_eq!(Ok(vec!["Jim".into(), "Tess".into()]), names);
 /// # }
 /// ```
+#[deprecated(since = "0.99.0", note = "use `replace_into` instead")]
 pub fn insert_or_replace<T: ?Sized>(
     records: &T,
-) -> IncompleteInsertStatement<&T, Or<Insert, Replace>> {
-    IncompleteInsertStatement::new(records, Or::new(Insert, Replace))
+) -> DeprecatedIncompleteInsertStatement<&T, Replace> {
+    DeprecatedIncompleteInsertStatement::new(records, Replace)
 }
diff --git a/diesel/src/sqlite/query_builder/mod.rs b/diesel/src/sqlite/query_builder/mod.rs
index b51dead2e..83607a58d 100644
--- a/diesel/src/sqlite/query_builder/mod.rs
+++ b/diesel/src/sqlite/query_builder/mod.rs
@@ -3,8 +3,6 @@ use query_builder::QueryBuilder;
 use result::QueryResult;
 
 pub mod functions;
-#[doc(hidden)]
-pub mod nodes;
 
 #[allow(missing_debug_implementations)]
 #[derive(Default)]
diff --git a/diesel/src/sqlite/query_builder/nodes.rs b/diesel/src/sqlite/query_builder/nodes.rs
deleted file mode 100644
index ba54eca53..000000000
--- a/diesel/src/sqlite/query_builder/nodes.rs
+++ /dev/null
@@ -1,15 +0,0 @@
-use query_builder::*;
-use result::QueryResult;
-use sqlite::Sqlite;
-
-#[derive(Debug, Copy, Clone)]
-pub struct Replace;
-
-impl QueryFragment<Sqlite> for Replace {
-    fn walk_ast(&self, mut out: AstPass<Sqlite>) -> QueryResult<()> {
-        out.push_sql("REPLACE");
-        Ok(())
-    }
-}
-
-impl_query_id!(Replace);
diff --git a/diesel_compile_tests/tests/compile-fail/columns_cannot_be_rhs_of_insert.rs b/diesel_compile_tests/tests/compile-fail/columns_cannot_be_rhs_of_insert.rs
index 291e107f6..b1492e82d 100644
--- a/diesel_compile_tests/tests/compile-fail/columns_cannot_be_rhs_of_insert.rs
+++ b/diesel_compile_tests/tests/compile-fail/columns_cannot_be_rhs_of_insert.rs
@@ -16,8 +16,8 @@ fn main() {
     use users::dsl::*;
     let conn = PgConnection::establish("").unwrap();
 
-    insert(&name.eq(hair_color))
-        .into(users)
+    insert_into(users)
+        .values(&name.eq(hair_color))
         .execute(&conn)
         //~^ ERROR E0599
         .unwrap();
diff --git a/diesel_compile_tests/tests/compile-fail/custom_returning_requires_nonaggregate.rs b/diesel_compile_tests/tests/compile-fail/custom_returning_requires_nonaggregate.rs
index ece620f5d..dd8f59aa8 100644
--- a/diesel_compile_tests/tests/compile-fail/custom_returning_requires_nonaggregate.rs
+++ b/diesel_compile_tests/tests/compile-fail/custom_returning_requires_nonaggregate.rs
@@ -28,6 +28,6 @@ fn main() {
     let new_user = NewUser {
         name: "Foobar".to_string(),
     };
-    let stmt = insert(&new_user).into(users).returning((name, count(name)));
+    let stmt = insert_into(users).values(&new_user).returning((name, count(name)));
     //~^ ERROR NonAggregate
 }
diff --git a/diesel_compile_tests/tests/compile-fail/custom_returning_requires_selectable_expression.rs b/diesel_compile_tests/tests/compile-fail/custom_returning_requires_selectable_expression.rs
index 7b20cd40b..b569bb9da 100644
--- a/diesel_compile_tests/tests/compile-fail/custom_returning_requires_selectable_expression.rs
+++ b/diesel_compile_tests/tests/compile-fail/custom_returning_requires_selectable_expression.rs
@@ -34,7 +34,7 @@ fn main() {
     let new_user = NewUser {
         name: "Foobar".to_string(),
     };
-    let stmt = insert(&new_user).into(users).returning((name, bad::age));
+    let stmt = insert_into(users).values(&new_user).returning((name, bad::age));
     //~^ ERROR SelectableExpression
     //~| ERROR AppearsInFromClause
     //~| ERROR E0277
diff --git a/diesel_compile_tests/tests/compile-fail/default_values_cannot_be_used_in_tuple_insert.rs b/diesel_compile_tests/tests/compile-fail/default_values_cannot_be_used_in_tuple_insert.rs
deleted file mode 100644
index 4f0c91aca..000000000
--- a/diesel_compile_tests/tests/compile-fail/default_values_cannot_be_used_in_tuple_insert.rs
+++ /dev/null
@@ -1,24 +0,0 @@
-#[macro_use]
-extern crate diesel;
-
-use diesel::*;
-use diesel::pg::PgConnection;
-
-table! {
-    users {
-        id -> Integer,
-        name -> Text,
-        hair_color -> Text,
-    }
-}
-
-fn main() {
-    use users::dsl::*;
-    let conn = PgConnection::establish("").unwrap();
-
-    ExecuteDsl::execute(
-    //~^ ERROR ExecuteDsl
-        insert(&(default_values(), name.eq("Sean"))).into(users),
-        &conn,
-    );
-}
diff --git a/diesel_compile_tests/tests/compile-fail/insert_cannot_reference_columns_from_other_table.rs b/diesel_compile_tests/tests/compile-fail/insert_cannot_reference_columns_from_other_table.rs
index 735e97b8e..833591cab 100644
--- a/diesel_compile_tests/tests/compile-fail/insert_cannot_reference_columns_from_other_table.rs
+++ b/diesel_compile_tests/tests/compile-fail/insert_cannot_reference_columns_from_other_table.rs
@@ -19,14 +19,14 @@ table! {
 fn main() {
     let conn = PgConnection::establish("").unwrap();
 
-    insert(&posts::id.eq(1))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&posts::id.eq(1))
         .execute(&conn)
         //~^ ERROR E0599
         .unwrap();
 
-    insert(&(posts::id.eq(1), users::id.eq(2)))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&(posts::id.eq(1), users::id.eq(2)))
         .execute(&conn)
         //~^ ERROR E0599
         .unwrap();
diff --git a/diesel_compile_tests/tests/compile-fail/insert_requires_value_of_same_type_as_column.rs b/diesel_compile_tests/tests/compile-fail/insert_requires_value_of_same_type_as_column.rs
index 70554bd03..f536779b5 100644
--- a/diesel_compile_tests/tests/compile-fail/insert_requires_value_of_same_type_as_column.rs
+++ b/diesel_compile_tests/tests/compile-fail/insert_requires_value_of_same_type_as_column.rs
@@ -16,6 +16,7 @@ fn main() {
     use users::dsl::*;
     let conn = PgConnection::establish("").unwrap();
 
-    insert(&name.eq(1));
-    //~^ ERROR E0277
+    insert_into(users)
+        .values(&name.eq(1));
+        //~^ ERROR E0277
 }
diff --git a/diesel_compile_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs b/diesel_compile_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs
index 9983cbc20..19f153fc5 100644
--- a/diesel_compile_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs
+++ b/diesel_compile_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs
@@ -43,13 +43,13 @@ impl_Insertable! {
 fn main() {
     let connection = SqliteConnection::establish(":memory:").unwrap();
 
-    insert(&NewUser("Hello".into()))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&NewUser("Hello".into()))
         .get_result::<User>(&connection);
     //~^ ERROR: SupportsReturningClause
 
-    insert(&NewUser("Hello".into()))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&NewUser("Hello".into()))
         .returning(users::name)
         .get_result::<String>(&connection);
     //~^ ERROR: SupportsReturningClause
diff --git a/diesel_compile_tests/tests/compile-fail/pg_on_conflict_requires_valid_conflict_target.rs b/diesel_compile_tests/tests/compile-fail/pg_on_conflict_requires_valid_conflict_target.rs
index 733f03b2d..043d6b46c 100644
--- a/diesel_compile_tests/tests/compile-fail/pg_on_conflict_requires_valid_conflict_target.rs
+++ b/diesel_compile_tests/tests/compile-fail/pg_on_conflict_requires_valid_conflict_target.rs
@@ -28,25 +28,25 @@ fn main() {
     use self::users::dsl::*;
     let connection = PgConnection::establish("postgres://localhost").unwrap();
 
-    let valid_insert = insert(&NewUser("Sean").on_conflict(id, do_nothing())).into(users).execute(&connection);
+    let valid_insert = insert_into(users).values(&NewUser("Sean").on_conflict(id, do_nothing())).execute(&connection);
     // Sanity check, no error
 
     // Using UFCS to get a more specific error message
     let column_from_other_table = <_ as ExecuteDsl<_>>::execute(
-        //~^ ERROR E0277
-        insert(&NewUser("Sean").on_conflict(posts::id, do_nothing())).into(users),
+        //~^ ERROR type mismatch resolving `<posts::columns::id as diesel::Column>::Table == users::table`
+        insert_into(users).values(&NewUser("Sean").on_conflict(posts::id, do_nothing())),
         &connection,
     );
 
     let expression_using_column_from_other_table = <_ as ExecuteDsl<_>>::execute(
         //~^ ERROR E0277
-        insert(&NewUser("Sean").on_conflict(lower(posts::title), do_nothing())).into(users),
+        insert_into(users).values(&NewUser("Sean").on_conflict(lower(posts::title), do_nothing())),
         &connection,
     );
 
     let random_non_expression = <_ as ExecuteDsl<_>>::execute(
         //~^ ERROR E0277
-        insert(&NewUser("Sean").on_conflict("id", do_nothing())).into(users),
+        insert_into(users).values(&NewUser("Sean").on_conflict("id", do_nothing())),
         &connection,
     );
 }
diff --git a/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs b/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs
index 4f8cfb6f0..a6cb4d3a5 100644
--- a/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs
+++ b/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs
@@ -33,7 +33,7 @@ fn main() {
     users.select(id).filter(now.eq(now.at_time_zone("UTC")))
         .load::<i32>(&connection);
     //~^ ERROR type mismatch resolving `<diesel::SqliteConnection as diesel::Connection>::Backend == diesel::pg::Pg`
-    insert(&NewUser("Sean").on_conflict_do_nothing()).into(users)
+    insert_into(users).values(&NewUser("Sean").on_conflict_do_nothing())
         .execute(&connection);
     //~^ ERROR type mismatch resolving `<diesel::SqliteConnection as diesel::Connection>::Backend == diesel::pg::Pg`
 }
diff --git a/diesel_compile_tests/tests/compile-fail/pg_upsert_do_update_requires_valid_update.rs b/diesel_compile_tests/tests/compile-fail/pg_upsert_do_update_requires_valid_update.rs
index f32f40fef..a9bcc7732 100644
--- a/diesel_compile_tests/tests/compile-fail/pg_upsert_do_update_requires_valid_update.rs
+++ b/diesel_compile_tests/tests/compile-fail/pg_upsert_do_update_requires_valid_update.rs
@@ -27,29 +27,29 @@ fn main() {
     let connection = PgConnection::establish("postgres://localhost").unwrap();
 
     // Valid update as sanity check
-    insert(&NewUser("Sean").on_conflict(id, do_update().set(name.eq("Sean")))).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict(id, do_update().set(name.eq("Sean")))).execute(&connection);
 
     // No set clause
-    insert(&NewUser("Sean").on_conflict(id, do_update())).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict(id, do_update())).execute(&connection);
     //~^ ERROR no method named `execute`
 
     // Update column from other table
-    insert(&NewUser("Sean").on_conflict(id, do_update().set(posts::title.eq("Sean")))).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict(id, do_update().set(posts::title.eq("Sean")))).execute(&connection);
     //~^ ERROR no method named `execute`
 
     // Update column with value that is not selectable
-    insert(&NewUser("Sean").on_conflict(id, do_update().set(name.eq(posts::title)))).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict(id, do_update().set(name.eq(posts::title)))).execute(&connection);
     //~^ ERROR E0277
     //~| ERROR no method named `execute`
     //~| ERROR E0271
 
     // Update column with excluded value that is not selectable
-    insert(&NewUser("Sean").on_conflict(id, do_update().set(name.eq(excluded(posts::title))))).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict(id, do_update().set(name.eq(excluded(posts::title))))).execute(&connection);
     //~^ ERROR E0271
     //~| ERROR no method named `execute`
 
     // Update column with excluded value of wrong type
-    insert(&NewUser("Sean").on_conflict(id, do_update().set(name.eq(excluded(id))))).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict(id, do_update().set(name.eq(excluded(id))))).execute(&connection);
     //~^ ERROR E0271
 
     // Excluded is only valid in upsert
diff --git a/diesel_compile_tests/tests/compile-fail/returning_cannot_be_called_twice.rs b/diesel_compile_tests/tests/compile-fail/returning_cannot_be_called_twice.rs
index 221adab01..55f1326f8 100644
--- a/diesel_compile_tests/tests/compile-fail/returning_cannot_be_called_twice.rs
+++ b/diesel_compile_tests/tests/compile-fail/returning_cannot_be_called_twice.rs
@@ -26,8 +26,8 @@ fn main() {
     query.returning(name);
     //~^ ERROR: no method named `returning`
 
-    let query = insert(&NewUser("Hello".into()))
-        .into(users)
+    let query = insert_into(users)
+        .values(&NewUser("Hello".into()))
         .returning(id);
     query.returning(name);
     //~^ ERROR: no method named `returning`
diff --git a/diesel_compile_tests/tests/compile-fail/returning_clause_requires_selectable_expression.rs b/diesel_compile_tests/tests/compile-fail/returning_clause_requires_selectable_expression.rs
index 36779cf0f..b2b5c8e97 100644
--- a/diesel_compile_tests/tests/compile-fail/returning_clause_requires_selectable_expression.rs
+++ b/diesel_compile_tests/tests/compile-fail/returning_clause_requires_selectable_expression.rs
@@ -31,8 +31,8 @@ fn main() {
         .returning(non_users::columns::noname);
     //~^ ERROR SelectableExpression
 
-    insert(&NewUser("Hello".into()))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&NewUser("Hello".into()))
         .returning(non_users::columns::noname);
     //~^ ERROR SelectableExpression
 
diff --git a/diesel_compile_tests/tests/compile-fail/sqlite_upsert_cannot_be_used_on_pg.rs b/diesel_compile_tests/tests/compile-fail/sqlite_upsert_cannot_be_used_on_pg.rs
index 858b31856..58520e235 100644
--- a/diesel_compile_tests/tests/compile-fail/sqlite_upsert_cannot_be_used_on_pg.rs
+++ b/diesel_compile_tests/tests/compile-fail/sqlite_upsert_cannot_be_used_on_pg.rs
@@ -19,6 +19,8 @@ struct User {
 
 fn main() {
     let connection = PgConnection::establish("").unwrap();
-    insert_or_replace(&User { id: 1 }).into(users::table).execute(&connection).unwrap();
-    //~^ ERROR type mismatch resolving `<diesel::PgConnection as diesel::Connection>::Backend == diesel::sqlite::Sqlite`
+    replace_into(users::table)
+        .values(&User { id: 1 })
+        .execute(&connection);
+        //~^ ERROR E0277
 }
diff --git a/diesel_compile_tests/tests/compile-fail/upsert_cannot_be_nested.rs b/diesel_compile_tests/tests/compile-fail/upsert_cannot_be_nested.rs
index 7d2b88ad8..1284342c6 100644
--- a/diesel_compile_tests/tests/compile-fail/upsert_cannot_be_nested.rs
+++ b/diesel_compile_tests/tests/compile-fail/upsert_cannot_be_nested.rs
@@ -19,20 +19,20 @@ fn main() {
     use self::users::dsl::*;
     let connection = PgConnection::establish("postgres://localhost").unwrap();
 
-    insert(&NewUser("Sean").on_conflict_do_nothing().on_conflict_do_nothing()).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict_do_nothing().on_conflict_do_nothing()).execute(&connection);
     //~^ ERROR no method named `execute`
-    insert(&NewUser("Sean").on_conflict(id, do_nothing()).on_conflict_do_nothing()).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict(id, do_nothing()).on_conflict_do_nothing()).execute(&connection);
     //~^ ERROR no method named `execute`
-    insert(&NewUser("Sean").on_conflict_do_nothing().on_conflict(id, do_nothing())).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict_do_nothing().on_conflict(id, do_nothing())).execute(&connection);
     //~^ ERROR no method named `execute`
-    insert(&NewUser("Sean").on_conflict(id, do_nothing()).on_conflict(id, do_nothing())).into(users).execute(&connection);
+    insert_into(users).values(&NewUser("Sean").on_conflict(id, do_nothing()).on_conflict(id, do_nothing())).execute(&connection);
     //~^ ERROR no method named `execute`
-    insert(&vec![NewUser("Sean").on_conflict_do_nothing()]).into(users).execute(&connection);
+    insert_into(users).values(&vec![NewUser("Sean").on_conflict_do_nothing()]).execute(&connection);
     //~^ ERROR E0599
-    insert(&vec![&NewUser("Sean").on_conflict_do_nothing()]).into(users).execute(&connection);
+    insert_into(users).values(&vec![&NewUser("Sean").on_conflict_do_nothing()]).execute(&connection);
     //~^ ERROR E0599
-    insert(&vec![&NewUser("Sean").on_conflict(id, do_nothing())]).into(users).execute(&connection);
+    insert_into(users).values(&vec![&NewUser("Sean").on_conflict(id, do_nothing())]).execute(&connection);
     //~^ ERROR E0599
-    insert(&(name.eq("Sean").on_conflict_do_nothing(),)).into(users).execute(&connection);
+    insert_into(users).values(&(name.eq("Sean").on_conflict_do_nothing(),)).execute(&connection);
     //~^ ERROR E0599
 }
diff --git a/diesel_tests/tests/annotations.rs b/diesel_tests/tests/annotations.rs
index ab0516372..38d593e8d 100644
--- a/diesel_tests/tests/annotations.rs
+++ b/diesel_tests/tests/annotations.rs
@@ -14,13 +14,13 @@ fn association_where_struct_name_doesnt_match_table_name() {
     let connection = connection_with_sean_and_tess_in_users_table();
 
     let sean = find_user_by_name("Sean", &connection);
-    insert(&sean.new_post("Hello", None))
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&sean.new_post("Hello", None))
         .execute(&connection)
         .unwrap();
     let post = posts::table.first::<Post>(&connection).unwrap();
-    insert(&NewComment(post.id, "comment"))
-        .into(comments::table)
+    insert_into(comments::table)
+        .values(&NewComment(post.id, "comment"))
         .execute(&connection)
         .unwrap();
 
@@ -82,13 +82,13 @@ fn association_where_parent_and_child_have_underscores() {
 
     let sean = find_user_by_name("Sean", &connection);
     let new_post = SpecialPost::new(sean.id, "title");
-    let special_post: SpecialPost = insert(&new_post)
-        .into(special_posts::table)
+    let special_post: SpecialPost = insert_into(special_posts::table)
+        .values(&new_post)
         .get_result(&connection)
         .unwrap();
     let new_comment = SpecialComment::new(special_post.id);
-    insert(&new_comment)
-        .into(special_comments::table)
+    insert_into(special_comments::table)
+        .values(&new_comment)
         .execute(&connection)
         .unwrap();
 
@@ -275,7 +275,10 @@ fn derive_insertable_with_option_for_not_null_field_with_default() {
             name: "Bob",
         },
     ];
-    assert_eq!(Ok(2), insert(&data).into(users::table).execute(&conn));
+    assert_eq!(
+        Ok(2),
+        insert_into(users::table).values(&data).execute(&conn)
+    );
 
     let users = users::table.load::<User>(&conn).unwrap();
     let jim = users.iter().find(|u| u.name == "Jim");
@@ -302,7 +305,10 @@ fn derive_insertable_with_field_that_cannot_convert_expression_to_nullable() {
         id: nextval("users_id_seq"),
         name: "Jim",
     };
-    assert_eq!(Ok(1), insert(&data).into(users::table).execute(&conn));
+    assert_eq!(
+        Ok(1),
+        insert_into(users::table).values(&data).execute(&conn)
+    );
 
     let users = users::table.load::<User>(&conn).unwrap();
     let jim = users.iter().find(|u| u.name == "Jim");
diff --git a/diesel_tests/tests/associations.rs b/diesel_tests/tests/associations.rs
index ca9b9994c..9e5d8c85c 100644
--- a/diesel_tests/tests/associations.rs
+++ b/diesel_tests/tests/associations.rs
@@ -203,8 +203,8 @@ fn self_referencing_associations() {
             parent_id: Some(1),
         },
     ];
-    insert(&test_data)
-        .into(trees::table)
+    insert_into(trees::table)
+        .values(&test_data)
         .execute(&conn)
         .unwrap();
 
@@ -225,8 +225,8 @@ fn self_referencing_associations() {
 
 fn conn_with_test_data() -> (TestConnection, User, User, User) {
     let connection = connection_with_sean_and_tess_in_users_table();
-    insert(&NewUser::new("Jim", None))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&NewUser::new("Jim", None))
         .execute(&connection)
         .unwrap();
 
@@ -234,21 +234,21 @@ fn conn_with_test_data() -> (TestConnection, User, User, User) {
     let tess = find_user_by_name("Tess", &connection);
     let jim = find_user_by_name("Jim", &connection);
     let new_posts = vec![sean.new_post("Hello", None), sean.new_post("World", None)];
-    insert(&new_posts)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_posts)
         .execute(&connection)
         .unwrap();
     let new_posts = vec![
         tess.new_post("Hello 2", None),
         tess.new_post("World 2", None),
     ];
-    insert(&new_posts)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_posts)
         .execute(&connection)
         .unwrap();
     let new_posts = vec![jim.new_post("Hello 3", None), jim.new_post("World 3", None)];
-    insert(&new_posts)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_posts)
         .execute(&connection)
         .unwrap();
 
diff --git a/diesel_tests/tests/backend_specifics.rs b/diesel_tests/tests/backend_specifics.rs
index aaef23a3d..bcaa4faba 100644
--- a/diesel_tests/tests/backend_specifics.rs
+++ b/diesel_tests/tests/backend_specifics.rs
@@ -1,4 +1,3 @@
-use diesel::*;
 use super::{posts, User};
 
 #[derive(PartialEq, Eq, Debug, Clone, Queryable, Identifiable, Associations)]
diff --git a/diesel_tests/tests/bench.rs b/diesel_tests/tests/bench.rs
index 187fd5816..d64456ffe 100644
--- a/diesel_tests/tests/bench.rs
+++ b/diesel_tests/tests/bench.rs
@@ -1,5 +1,6 @@
 #![feature(test)]
 #![allow(non_snake_case)]
+#![recursion_limit = "128"]
 
 #[macro_use]
 extern crate diesel;
@@ -38,7 +39,7 @@ macro_rules! bench_trivial_query {
             let data: Vec<_> = (0..$n).map(|i| {
                 NewUser::new(&format!("User {}", i), None)
             }).collect();
-            insert(&data).into(users::table).execute(&conn).unwrap();
+            insert_into(users::table).values(&data).execute(&conn).unwrap();
 
             b.iter(|| {
                 users::table.load::<User>(&conn).unwrap()
@@ -52,7 +53,7 @@ macro_rules! bench_trivial_query {
             let data: Vec<_> = (0..$n).map(|i| {
                 NewUser::new(&format!("User {}", i), None)
             }).collect();
-            insert(&data).into(users::table).execute(&conn).unwrap();
+            insert_into(users::table).values(&data).execute(&conn).unwrap();
 
             b.iter(|| {
                 users::table.into_boxed().load::<User>(&conn).unwrap()
@@ -99,7 +100,7 @@ macro_rules! bench_medium_complex_query {
                 let hair_color = if i % 2 == 0 { "black" } else { "brown" };
                 NewUser::new(&format!("User {}", i), Some(hair_color))
             }).collect();
-            insert(&data).into(users::table).execute(&conn).unwrap();
+            insert_into(users::table).values(&data).execute(&conn).unwrap();
 
             b.iter(|| {
                 use schema::users::dsl::*;
@@ -118,7 +119,7 @@ macro_rules! bench_medium_complex_query {
                 let hair_color = if i % 2 == 0 { "black" } else { "brown" };
                 NewUser::new(&format!("User {}", i), Some(hair_color))
             }).collect();
-            insert(&data).into(users::table).execute(&conn).unwrap();
+            insert_into(users::table).values(&data).execute(&conn).unwrap();
 
             b.iter(|| {
                 use schema::users::dsl::*;
@@ -170,7 +171,10 @@ fn loading_associations_sequentially(b: &mut Bencher) {
             NewUser::new(&format!("User {}", i), Some(hair_color))
         })
         .collect();
-    insert(&data).into(users::table).execute(&conn).unwrap();
+    insert_into(users::table)
+        .values(&data)
+        .execute(&conn)
+        .unwrap();
     let all_users = users::table.load::<User>(&conn).unwrap();
     let data: Vec<_> = all_users
         .iter()
@@ -182,7 +186,10 @@ fn loading_associations_sequentially(b: &mut Bencher) {
             })
         })
         .collect();
-    insert(&data).into(posts::table).execute(&conn).unwrap();
+    insert_into(posts::table)
+        .values(&data)
+        .execute(&conn)
+        .unwrap();
     let all_posts = posts::table.load::<Post>(&conn).unwrap();
     let data: Vec<_> = all_posts
         .iter()
@@ -197,8 +204,8 @@ fn loading_associations_sequentially(b: &mut Bencher) {
     let comment_data: Vec<_> = data.iter()
         .map(|&(ref title, post_id)| NewComment(post_id, &title))
         .collect();
-    insert(&comment_data)
-        .into(comments::table)
+    insert_into(comments::table)
+        .values(&comment_data)
         .execute(&conn)
         .unwrap();
 
diff --git a/diesel_tests/tests/boxed_queries.rs b/diesel_tests/tests/boxed_queries.rs
index 4a3b8bed0..ff8f572e0 100644
--- a/diesel_tests/tests/boxed_queries.rs
+++ b/diesel_tests/tests/boxed_queries.rs
@@ -4,8 +4,8 @@ use diesel::*;
 #[test]
 fn boxed_queries_can_be_executed() {
     let connection = connection_with_sean_and_tess_in_users_table();
-    insert(&NewUser::new("Jim", None))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&NewUser::new("Jim", None))
         .execute(&connection)
         .unwrap();
     let query_which_fails_unless_all_segments_are_applied = users::table
@@ -24,8 +24,8 @@ fn boxed_queries_can_be_executed() {
 #[test]
 fn boxed_queries_can_differ_conditionally() {
     let connection = connection_with_sean_and_tess_in_users_table();
-    insert(&NewUser::new("Jim", None))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&NewUser::new("Jim", None))
         .execute(&connection)
         .unwrap();
 
@@ -74,8 +74,8 @@ fn boxed_queries_implement_select_dsl() {
 #[test]
 fn boxed_queries_implement_filter_dsl() {
     let connection = connection_with_sean_and_tess_in_users_table();
-    insert(&NewUser::new("Shane", None))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&NewUser::new("Shane", None))
         .execute(&connection)
         .unwrap();
     let data = users::table
diff --git a/diesel_tests/tests/custom_schemas.rs b/diesel_tests/tests/custom_schemas.rs
index 1d508f335..10a130a28 100644
--- a/diesel_tests/tests/custom_schemas.rs
+++ b/diesel_tests/tests/custom_schemas.rs
@@ -18,8 +18,8 @@ mod using_infer_schema {
     #[test]
     fn custom_schemas_are_loaded_by_infer_schema() {
         let conn = connection();
-        insert(&NewUser { id: 1 })
-            .into(users::table)
+        insert_into(users::table)
+            .values(&NewUser { id: 1 })
             .execute(&conn)
             .unwrap();
         let users = users::table.select(users::id).load(&conn);
@@ -47,8 +47,8 @@ mod using_infer_table_from_schema {
     #[test]
     fn custom_schemas_are_loaded_by_infer_table_from_schema() {
         let conn = connection();
-        insert(&NewUser { id: 1 })
-            .into(users::table)
+        insert_into(users::table)
+            .values(&NewUser { id: 1 })
             .execute(&conn)
             .unwrap();
         let users = users::table.select(users::id).load(&conn);
@@ -77,10 +77,11 @@ mod using_infer_table_from_schema_with_default_schema {
     #[test]
     fn custom_schemas_are_loaded_by_infer_table_from_schema() {
         let conn = connection();
-        insert(&NewUser {
-            id: 1,
-            name: "Sean",
-        }).into(users::table)
+        insert_into(users::table)
+            .values(&NewUser {
+                id: 1,
+                name: "Sean",
+            })
             .execute(&conn)
             .unwrap();
         let users = users::table.select(users::id).load(&conn);
diff --git a/diesel_tests/tests/custom_types.rs b/diesel_tests/tests/custom_types.rs
index 68289b81d..e9e3db9f3 100644
--- a/diesel_tests/tests/custom_types.rs
+++ b/diesel_tests/tests/custom_types.rs
@@ -103,8 +103,8 @@ fn custom_types_round_trip() {
         )
         .unwrap();
 
-    let inserted = insert(&data)
-        .into(custom_types::table)
+    let inserted = insert_into(custom_types::table)
+        .values(&data)
         .get_results(&connection)
         .unwrap();
     assert_eq!(data, inserted);
diff --git a/diesel_tests/tests/errors.rs b/diesel_tests/tests/errors.rs
index b68f02372..12b70ac31 100644
--- a/diesel_tests/tests/errors.rs
+++ b/diesel_tests/tests/errors.rs
@@ -1,5 +1,4 @@
-use diesel;
-use diesel::prelude::*;
+use diesel::*;
 use diesel::result::Error::DatabaseError;
 use diesel::result::DatabaseErrorKind::{ForeignKeyViolation, UniqueViolation};
 use schema::*;
@@ -7,13 +6,13 @@ use schema::*;
 #[test]
 fn unique_constraints_are_detected() {
     let connection = connection();
-    diesel::insert(&User::new(1, "Sean"))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&User::new(1, "Sean"))
         .execute(&connection)
         .unwrap();
 
-    let failure = diesel::insert(&User::new(1, "Jim"))
-        .into(users::table)
+    let failure = insert_into(users::table)
+        .values(&User::new(1, "Jim"))
         .execute(&connection);
     assert_matches!(failure, Err(DatabaseError(UniqueViolation, _)));
 }
@@ -25,13 +24,13 @@ fn unique_constraints_report_correct_constraint_name() {
     connection
         .execute("CREATE UNIQUE INDEX users_name ON users (name)")
         .unwrap();
-    diesel::insert(&User::new(1, "Sean"))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&User::new(1, "Sean"))
         .execute(&connection)
         .unwrap();
 
-    let failure = diesel::insert(&User::new(2, "Sean"))
-        .into(users::table)
+    let failure = insert_into(users::table)
+        .values(&User::new(2, "Sean"))
         .execute(&connection);
     match failure {
         Err(DatabaseError(UniqueViolation, e)) => {
@@ -59,7 +58,7 @@ macro_rules! try_no_coerce {
 fn cached_prepared_statements_can_be_reused_after_error() {
     let connection = connection_without_transaction();
     let user = User::new(1, "Sean");
-    let query = diesel::insert(&user).into(users::table);
+    let query = insert_into(users::table).values(&user);
 
     connection.test_transaction(|| {
         try_no_coerce!(query.execute(&connection));
@@ -76,8 +75,8 @@ fn cached_prepared_statements_can_be_reused_after_error() {
 fn foreign_key_violation_detected() {
     let connection = connection();
 
-    let failure = diesel::insert(&FkTest::new(1, 100))
-        .into(fk_tests::table)
+    let failure = insert_into(fk_tests::table)
+        .values(&FkTest::new(1, 100))
         .execute(&connection);
     assert_matches!(failure, Err(DatabaseError(ForeignKeyViolation, _)));
 }
@@ -87,8 +86,8 @@ fn foreign_key_violation_detected() {
 fn foreign_key_violation_correct_constraint_name() {
     let connection = connection();
 
-    let failure = diesel::insert(&FkTest::new(1, 100))
-        .into(fk_tests::table)
+    let failure = insert_into(fk_tests::table)
+        .values(&FkTest::new(1, 100))
         .execute(&connection);
     match failure {
         Err(DatabaseError(ForeignKeyViolation, e)) => {
diff --git a/diesel_tests/tests/expressions/mod.rs b/diesel_tests/tests/expressions/mod.rs
index f941b466a..6ecf0d8af 100644
--- a/diesel_tests/tests/expressions/mod.rs
+++ b/diesel_tests/tests/expressions/mod.rs
@@ -14,8 +14,8 @@ fn test_count_counts_the_rows() {
     let source = users.select(count(id));
 
     assert_eq!(Ok(0), source.first(&connection));
-    insert(&NewUser::new("Sean", None))
-        .into(users)
+    insert_into(users)
+        .values(&NewUser::new("Sean", None))
         .execute(&connection)
         .unwrap();
     assert_eq!(Ok(1), source.first(&connection));
@@ -27,8 +27,8 @@ fn test_count_star() {
     let source = users.count();
 
     assert_eq!(Ok(0), source.first(&connection));
-    insert(&NewUser::new("Sean", None))
-        .into(users)
+    insert_into(users)
+        .values(&NewUser::new("Sean", None))
         .execute(&connection)
         .unwrap();
     assert_eq!(Ok(1), source.first(&connection));
@@ -77,7 +77,10 @@ fn max_returns_same_type_as_expression_being_maximized() {
         NewUser::new("C", None),
         NewUser::new("A", None),
     ];
-    insert(data).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(data)
+        .execute(&connection)
+        .unwrap();
     assert_eq!(Ok(Some("C".to_string())), source.first(&connection));
     connection
         .execute("DELETE FROM users WHERE name = 'C'")
@@ -168,7 +171,10 @@ fn function_with_multiple_arguments() {
         NewUser::new("Sean", Some("black")),
         NewUser::new("Tess", None),
     ];
-    insert(&new_users).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&new_users)
+        .execute(&connection)
+        .unwrap();
 
     let expected_data = vec!["black".to_string(), "Tess".to_string()];
     let data = users
diff --git a/diesel_tests/tests/filter.rs b/diesel_tests/tests/filter.rs
index 168e5b193..331d7b72f 100644
--- a/diesel_tests/tests/filter.rs
+++ b/diesel_tests/tests/filter.rs
@@ -57,7 +57,10 @@ fn filter_by_equality_on_nullable_columns() {
         NewUser::new("Tess", Some("brown")),
         NewUser::new("Jim", Some("black")),
     ];
-    insert(&data).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&data)
+        .execute(&connection)
+        .unwrap();
 
     let data = users.order(id).load::<User>(&connection).unwrap();
     let sean = data[0].clone();
@@ -80,7 +83,10 @@ fn filter_by_is_not_null_on_nullable_columns() {
         NewUser::new("Derek", Some("red")),
         NewUser::new("Gordon", None),
     ];
-    insert(&data).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&data)
+        .execute(&connection)
+        .unwrap();
     let data = users.order(id).load::<User>(&connection).unwrap();
     let derek = data[0].clone();
 
@@ -97,7 +103,10 @@ fn filter_by_is_null_on_nullable_columns() {
         NewUser::new("Derek", Some("red")),
         NewUser::new("Gordon", None),
     ];
-    insert(&data).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&data)
+        .execute(&connection)
+        .unwrap();
     let data = users.order(id).load::<User>(&connection).unwrap();
     let gordon = data[1].clone();
 
@@ -165,7 +174,10 @@ fn filter_then_select() {
 
     let connection = connection();
     let data = vec![NewUser::new("Sean", None), NewUser::new("Tess", None)];
-    insert(&data).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&data)
+        .execute(&connection)
+        .unwrap();
 
     assert_eq!(
         Ok("Sean".to_string()),
@@ -202,7 +214,10 @@ fn filter_on_multiple_columns() {
         NewUser::new("Tess", Some("black")),
         NewUser::new("Tess", Some("brown")),
     ];
-    insert(data).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(data)
+        .execute(&connection)
+        .unwrap();
     let data = users.order(id).load::<User>(&connection).unwrap();
     let black_haired_sean = data[0].clone();
     let brown_haired_sean = data[1].clone();
@@ -234,7 +249,10 @@ fn filter_called_twice_means_same_thing_as_and() {
         NewUser::new("Tess", Some("black")),
         NewUser::new("Tess", Some("brown")),
     ];
-    insert(data).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(data)
+        .execute(&connection)
+        .unwrap();
     let data = users.order(id).load::<User>(&connection).unwrap();
     let black_haired_sean = data[0].clone();
     let brown_haired_sean = data[1].clone();
@@ -281,8 +299,8 @@ fn filter_with_or() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
-    insert(&NewUser::new("Jim", None))
-        .into(users)
+    insert_into(users)
+        .values(&NewUser::new("Jim", None))
         .execute(&connection)
         .unwrap();
 
diff --git a/diesel_tests/tests/filter_operators.rs b/diesel_tests/tests/filter_operators.rs
index 718823bed..346b6466e 100644
--- a/diesel_tests/tests/filter_operators.rs
+++ b/diesel_tests/tests/filter_operators.rs
@@ -146,7 +146,10 @@ fn filter_by_like() {
         NewUser::new("Tess Griffin", None),
         NewUser::new("Jim", None),
     ];
-    insert(&data).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&data)
+        .execute(&connection)
+        .unwrap();
     let data = users.load::<User>(&connection).unwrap();
     let sean = data[0].clone();
     let tess = data[1].clone();
@@ -181,7 +184,10 @@ fn filter_by_ilike() {
         NewUser::new("Tess Griffin", None),
         NewUser::new("Jim", None),
     ];
-    insert(&data).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&data)
+        .execute(&connection)
+        .unwrap();
     let data = users.load::<User>(&connection).unwrap();
     let sean = data[0].clone();
     let tess = data[1].clone();
diff --git a/diesel_tests/tests/find.rs b/diesel_tests/tests/find.rs
index 82996775a..e43f8aaa1 100644
--- a/diesel_tests/tests/find.rs
+++ b/diesel_tests/tests/find.rs
@@ -70,8 +70,8 @@ fn find_with_composite_pk() {
 
     let connection = connection();
     disable_foreign_keys(&connection);
-    insert(&vec![first_following, second_following, third_following])
-        .into(followings)
+    insert_into(followings)
+        .values(&vec![first_following, second_following, third_following])
         .execute(&connection)
         .unwrap();
 
diff --git a/diesel_tests/tests/insert.rs b/diesel_tests/tests/insert.rs
index a6a639ac2..bbdb74270 100644
--- a/diesel_tests/tests/insert.rs
+++ b/diesel_tests/tests/insert.rs
@@ -10,7 +10,10 @@ fn insert_records() {
         NewUser::new("Tess", None),
     ];
 
-    insert(new_users).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(new_users)
+        .execute(&connection)
+        .unwrap();
     let actual_users = users.load::<User>(&connection).unwrap();
 
     let expected_users = vec![
@@ -38,8 +41,8 @@ fn insert_records_using_returning_clause() {
         NewUser::new("Tess", None),
     ];
 
-    let inserted_users = insert(new_users)
-        .into(users)
+    let inserted_users = insert_into(users)
+        .values(new_users)
         .get_results::<User>(&connection)
         .unwrap();
     let expected_users = vec![
@@ -69,8 +72,8 @@ fn insert_records_with_custom_returning_clause() {
         NewUser::new("Tess", None),
     ];
 
-    let inserted_users = insert(new_users)
-        .into(users)
+    let inserted_users = insert_into(users)
+        .values(new_users)
         .returning((name, hair_color))
         .get_results::<(String, Option<String>)>(&connection)
         .unwrap();
@@ -104,7 +107,10 @@ fn batch_insert_with_defaults() {
         NewUser::new("Sean", Some("Black")),
         NewUser::new("Tess", None),
     ];
-    insert(new_users).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(new_users)
+        .execute(&connection)
+        .unwrap();
 
     let expected_users = vec![
         User {
@@ -140,8 +146,8 @@ fn insert_with_defaults() {
         ),
     ).execute(&connection)
         .unwrap();
-    insert(&NewUser::new("Tess", None))
-        .into(users)
+    insert_into(users)
+        .values(&NewUser::new("Tess", None))
         .execute(&connection)
         .unwrap();
 
@@ -180,10 +186,14 @@ fn insert_returning_count_returns_number_of_rows_inserted() {
             name: "Tess".to_string(),
         },
     ];
-    let count = insert(new_users).into(users).execute(&connection).unwrap();
-    let second_count = insert(&BaldUser {
-        name: "Guy".to_string(),
-    }).into(users)
+    let count = insert_into(users)
+        .values(new_users)
+        .execute(&connection)
+        .unwrap();
+    let second_count = insert_into(users)
+        .values(&BaldUser {
+            name: "Guy".to_string(),
+        })
         .execute(&connection)
         .unwrap();
 
@@ -208,7 +218,10 @@ fn insert_borrowed_content() {
     use schema::users::table as users;
     let connection = connection();
     let new_users: &[_] = &[BorrowedUser { name: "Sean" }, BorrowedUser { name: "Tess" }];
-    insert(new_users).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(new_users)
+        .execute(&connection)
+        .unwrap();
 
     let actual_users = users.load::<User>(&connection).unwrap();
     let expected_users = vec![
@@ -219,32 +232,12 @@ fn insert_borrowed_content() {
     assert_eq!(expected_users, actual_users);
 }
 
-#[test]
-#[cfg(feature = "sqlite")]
-fn insert_on_conflict_replace() {
-    use schema::users::dsl::*;
-    use diesel::insert_or_replace;
-
-    let connection = connection_with_sean_and_tess_in_users_table();
-
-    let mut sean = find_user_by_name("Sean", &connection);
-    sean.name = "Jim".into();
-    insert_or_replace(&sean)
-        .into(users)
-        .execute(&connection)
-        .unwrap();
-
-    let expected_names = vec!["Jim".into(), "Tess".into()];
-    let names = users.select(name).order(id).load::<String>(&connection);
-    assert_eq!(Ok(expected_names), names);
-}
-
 #[test]
 fn insert_empty_slice() {
     let connection = connection();
 
-    let inserted_records = insert(&Vec::<NewUser>::new())
-        .into(users::table)
+    let inserted_records = insert_into(users::table)
+        .values(&Vec::<NewUser>::new())
         .execute(&connection);
 
     assert_eq!(Ok(0), inserted_records);
@@ -255,11 +248,11 @@ fn insert_empty_slice() {
 fn insert_empty_slice_with_returning() {
     let connection = connection();
 
-    let insert_one = insert(&Vec::<NewUser>::new())
-        .into(users::table)
+    let insert_one = insert_into(users::table)
+        .values(&Vec::<NewUser>::new())
         .get_result::<User>(&connection);
-    let insert_all = insert(&Vec::<NewUser>::new())
-        .into(users::table)
+    let insert_all = insert_into(users::table)
+        .values(&Vec::<NewUser>::new())
         .get_results::<User>(&connection);
 
     assert_eq!(Ok(None), insert_one.optional());
@@ -272,8 +265,8 @@ fn upsert_empty_slice() {
     use diesel::pg::upsert::*;
     let connection = connection();
 
-    let inserted_records = insert(&Vec::<NewUser>::new().on_conflict_do_nothing())
-        .into(users::table)
+    let inserted_records = insert_into(users::table)
+        .values(&Vec::<NewUser>::new().on_conflict_do_nothing())
         .execute(&connection);
 
     assert_eq!(Ok(0), inserted_records);
@@ -313,40 +306,6 @@ fn insert_only_default_values_deprecated() {
     );
 }
 
-#[test]
-#[cfg(not(feature = "mysql"))]
-fn insert_only_default_values() {
-    use schema::users::table as users;
-    use schema_dsl::*;
-    let connection = connection();
-
-    drop_table_cascade(&connection, "users");
-    create_table(
-        "users",
-        (
-            integer("id").primary_key().auto_increment(),
-            string("name").not_null().default("'Sean'"),
-            string("hair_color").not_null().default("'Green'"),
-        ),
-    ).execute(&connection)
-        .unwrap();
-
-    insert(&default_values())
-        .into(users)
-        .execute(&connection)
-        .unwrap();
-    assert_eq!(
-        users.load::<User>(&connection),
-        Ok(vec![
-            User {
-                id: 1,
-                name: "Sean".into(),
-                hair_color: Some("Green".into()),
-            },
-        ])
-    );
-}
-
 #[test]
 #[cfg(feature = "postgres")]
 fn insert_only_default_values_with_returning() {
@@ -365,22 +324,14 @@ fn insert_only_default_values_with_returning() {
         ),
     ).execute(&connection)
         .unwrap();
-    let result = LoadDsl::get_result::<i32>(
-        insert_default_values().into(users).returning(id),
-        &connection,
-    ).unwrap();
+    let inserted_rows = insert_into(users)
+        .default_values()
+        .returning(id)
+        .execute(&connection);
+    let expected_users = vec![User::with_hair_color(1, "Sean", "Green")];
 
-    assert_eq!(result, 1);
-    assert_eq!(
-        users.load::<User>(&connection),
-        Ok(vec![
-            User {
-                id: 1,
-                name: "Sean".into(),
-                hair_color: Some("Green".into()),
-            },
-        ])
-    );
+    assert_eq!(Ok(1), inserted_rows);
+    assert_eq!(Ok(expected_users), users.load(&connection));
 }
 
 #[test]
@@ -388,8 +339,8 @@ fn insert_single_bare_value() {
     use schema::users::dsl::*;
     let connection = connection();
 
-    insert(&name.eq("Sean"))
-        .into(users)
+    insert_into(users)
+        .values(&name.eq("Sean"))
         .execute(&connection)
         .unwrap();
 
@@ -405,7 +356,10 @@ fn insert_multiple_bare_values() {
 
     let new_users = vec![name.eq("Sean"), name.eq("Tess")];
 
-    insert(&new_users).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&new_users)
+        .execute(&connection)
+        .unwrap();
 
     let expected_names = vec!["Sean".to_string(), "Tess".to_string()];
     let actual_names = users.select(name).load(&connection);
@@ -417,8 +371,8 @@ fn insert_single_tuple() {
     use schema::users::dsl::*;
     let connection = connection();
 
-    insert(&(name.eq("Sean"), hair_color.eq("Brown")))
-        .into(users)
+    insert_into(users)
+        .values(&(name.eq("Sean"), hair_color.eq("Brown")))
         .execute(&connection)
         .unwrap();
 
@@ -432,8 +386,8 @@ fn insert_nested_tuples() {
     use schema::users::dsl::*;
     let connection = connection();
 
-    insert(&(id.eq(1), (name.eq("Sean"), hair_color.eq("Brown"))))
-        .into(users)
+    insert_into(users)
+        .values(&(id.eq(1), (name.eq("Sean"), hair_color.eq("Brown"))))
         .execute(&connection)
         .unwrap();
 
@@ -448,8 +402,8 @@ fn insert_mixed_tuple_and_insertable_struct() {
     let connection = connection();
 
     let new_user = NewUser::new("Sean", Some("Brown"));
-    insert(&(id.eq(3), new_user))
-        .into(users)
+    insert_into(users)
+        .values(&(id.eq(3), new_user))
         .execute(&connection)
         .unwrap();
 
@@ -467,7 +421,10 @@ fn insert_multiple_tuples() {
         (name.eq("Sean"), hair_color.eq("Brown")),
         (name.eq("Tess"), hair_color.eq("Green")),
     ];
-    insert(&new_users).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&new_users)
+        .execute(&connection)
+        .unwrap();
 
     let expected_data = vec![
         ("Sean".to_string(), Some("Brown".to_string())),
@@ -486,7 +443,10 @@ fn insert_optional_field_with_null() {
         (name.eq("Sean"), hair_color.eq(Some("Brown"))),
         (name.eq("Tess"), hair_color.eq(None)),
     ];
-    insert(&new_users).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&new_users)
+        .execute(&connection)
+        .unwrap();
 
     let expected_data = vec![
         ("Sean".to_string(), Some("Brown".to_string())),
@@ -517,7 +477,10 @@ fn insert_optional_field_with_default() {
         (name.eq("Sean"), Some(hair_color.eq("Brown"))),
         (name.eq("Tess"), None),
     ];
-    insert(&new_users).into(users).execute(&connection).unwrap();
+    insert_into(users)
+        .values(&new_users)
+        .execute(&connection)
+        .unwrap();
 
     let expected_data = vec![
         ("Sean".to_string(), Some("Brown".to_string())),
diff --git a/diesel_tests/tests/internal_details.rs b/diesel_tests/tests/internal_details.rs
index 08b92587a..eb73536c6 100644
--- a/diesel_tests/tests/internal_details.rs
+++ b/diesel_tests/tests/internal_details.rs
@@ -22,7 +22,7 @@ fn query_which_cannot_be_transmitted_gives_proper_error_message() {
 
     // Create a query with 90000 binds, 2 binds per row
     let data: &[NewComment<'static>] = &[NewComment(1, "hi"); 45_000];
-    let query_with_to_many_binds = insert(data).into(comments);
+    let query_with_to_many_binds = insert_into(comments).values(data);
 
     match query_with_to_many_binds.execute(&connection()) {
         Ok(_) => panic!(
diff --git a/diesel_tests/tests/joins.rs b/diesel_tests/tests/joins.rs
index 9395308b4..129a64f9e 100644
--- a/diesel_tests/tests/joins.rs
+++ b/diesel_tests/tests/joins.rs
@@ -330,8 +330,8 @@ fn selecting_complex_expression_from_right_side_of_left_join() {
         NewPost::new(1, "Post One", None),
         NewPost::new(1, "Post Two", None),
     ];
-    insert(&new_posts)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_posts)
         .execute(&connection)
         .unwrap();
     sql_function!(lower, lower_t, (x: Text) -> Text);
@@ -356,8 +356,8 @@ fn selecting_complex_expression_from_both_sides_of_outer_join() {
         NewPost::new(1, "Post One", None),
         NewPost::new(1, "Post Two", None),
     ];
-    insert(&new_posts)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_posts)
         .execute(&connection)
         .unwrap();
 
@@ -386,8 +386,8 @@ fn join_with_explicit_on_clause() {
         NewPost::new(1, "Post One", None),
         NewPost::new(1, "Post Two", None),
     ];
-    insert(&new_posts)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_posts)
         .execute(&connection)
         .unwrap();
 
@@ -665,8 +665,8 @@ fn connection_with_fixture_data_for_multitable_joins() -> (TestConnection, TestD
         NewPost::new(tess.id, "Second Post", None),
         NewPost::new(sean.id, "Third Post", None),
     ];
-    insert(&new_posts)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_posts)
         .execute(&connection)
         .unwrap();
 
@@ -679,8 +679,8 @@ fn connection_with_fixture_data_for_multitable_joins() -> (TestConnection, TestD
         NewComment(posts[2].id, "Second Comment"),
         NewComment(posts[0].id, "Third Comment"),
     ];
-    insert(&new_comments)
-        .into(comments::table)
+    insert_into(comments::table)
+        .values(&new_comments)
         .execute(&connection)
         .unwrap();
 
@@ -692,8 +692,8 @@ fn connection_with_fixture_data_for_multitable_joins() -> (TestConnection, TestD
         user_id: tess.id,
         comment_id: *comments[0].id(),
     };
-    insert(&like)
-        .into(likes::table)
+    insert_into(likes::table)
+        .values(&like)
         .execute(&connection)
         .unwrap();
 
@@ -707,8 +707,8 @@ fn connection_with_fixture_data_for_multitable_joins() -> (TestConnection, TestD
         post_id: posts[1].id,
         email_notifications: false,
     };
-    insert(&new_following)
-        .into(followings::table)
+    insert_into(followings::table)
+        .values(&new_following)
         .execute(&connection)
         .unwrap();
     let followings = followings::table
diff --git a/diesel_tests/tests/order.rs b/diesel_tests/tests/order.rs
index 0f58a0c99..f7336a282 100644
--- a/diesel_tests/tests/order.rs
+++ b/diesel_tests/tests/order.rs
@@ -11,7 +11,7 @@ fn order_by_column() {
         NewUser::new("Tess", None),
         NewUser::new("Jim", None),
     ];
-    insert(&data).into(users).execute(&conn).unwrap();
+    insert_into(users).values(&data).execute(&conn).unwrap();
     let data = users.load::<User>(&conn).unwrap();
     let sean = &data[0];
     let tess = &data[1];
@@ -25,8 +25,8 @@ fn order_by_column() {
     let data: Vec<_> = users.order(name).load(&conn).unwrap();
     assert_eq!(expected_data, data);
 
-    insert(&NewUser::new("Aaron", None))
-        .into(users)
+    insert_into(users)
+        .values(&NewUser::new("Aaron", None))
         .execute(&conn)
         .unwrap();
     let aaron = users.order(id.desc()).first::<User>(&conn).unwrap();
@@ -50,7 +50,7 @@ fn order_by_descending_column() {
         NewUser::new("Tess", None),
         NewUser::new("Jim", None),
     ];
-    insert(&data).into(users).execute(&conn).unwrap();
+    insert_into(users).values(&data).execute(&conn).unwrap();
     let data = users.load::<User>(&conn).unwrap();
     let sean = &data[0];
     let tess = &data[1];
@@ -64,8 +64,8 @@ fn order_by_descending_column() {
     let data: Vec<_> = users.order(name.desc()).load(&conn).unwrap();
     assert_eq!(expected_data, data);
 
-    insert(&NewUser::new("Aaron", None))
-        .into(users)
+    insert_into(users)
+        .values(&NewUser::new("Aaron", None))
         .execute(&conn)
         .unwrap();
     let aaron = users.order(id.desc()).first::<User>(&conn).unwrap();
diff --git a/diesel_tests/tests/schema.rs b/diesel_tests/tests/schema.rs
index 242dd87c2..7b220802c 100644
--- a/diesel_tests/tests/schema.rs
+++ b/diesel_tests/tests/schema.rs
@@ -278,8 +278,8 @@ pub fn connection_with_nullable_table_data() -> TestConnection {
             value: Some(1),
         },
     ];
-    insert(&test_data)
-        .into(nullable_table::table)
+    insert_into(nullable_table::table)
+        .values(&test_data)
         .execute(&connection)
         .unwrap();
 
diff --git a/diesel_tests/tests/schema_inference.rs b/diesel_tests/tests/schema_inference.rs
index 170de49d8..2caffe64f 100644
--- a/diesel_tests/tests/schema_inference.rs
+++ b/diesel_tests/tests/schema_inference.rs
@@ -42,8 +42,8 @@ mod sqlite {
             col12: 12,
             col13: 13,
         };
-        insert(&inferred_ints)
-            .into(infer_all_the_ints::table)
+        insert_into(infer_all_the_ints::table)
+            .values(&inferred_ints)
             .execute(&conn)
             .unwrap();
 
@@ -71,8 +71,8 @@ mod sqlite {
             col3: false,
             col4: false,
         };
-        insert(&inferred_bools)
-            .into(infer_all_the_bools::table)
+        insert_into(infer_all_the_bools::table)
+            .values(&inferred_bools)
             .execute(&conn)
             .unwrap();
 
@@ -112,8 +112,8 @@ mod sqlite {
             col9: vec![1, 2, 3],
             col10: vec![1, 2, 3],
         };
-        insert(&inferred_strings)
-            .into(infer_all_the_strings::table)
+        insert_into(infer_all_the_strings::table)
+            .values(&inferred_strings)
             .execute(&conn)
             .unwrap();
 
@@ -145,8 +145,8 @@ mod sqlite {
             col5: 5.0,
             col6: 6.0,
         };
-        insert(&inferred_floats)
-            .into(infer_all_the_floats::table)
+        insert_into(infer_all_the_floats::table)
+            .values(&inferred_floats)
             .execute(&conn)
             .unwrap();
 
@@ -177,8 +177,8 @@ mod sqlite {
             timestamp: dt,
         };
 
-        insert(&inferred_datetime_types)
-            .into(infer_all_the_datetime_types::table)
+        insert_into(infer_all_the_datetime_types::table)
+            .values(&inferred_datetime_types)
             .execute(&conn)
             .unwrap();
 
@@ -230,8 +230,8 @@ mod postgres {
             date: (Bound::Included(dt.date()), Bound::Unbounded),
         };
 
-        insert(&inferred_ranges)
-            .into(all_the_ranges::table)
+        insert_into(all_the_ranges::table)
+            .values(&inferred_ranges)
             .execute(&conn)
             .unwrap();
 
@@ -282,8 +282,8 @@ mod mysql {
             big: vec![0x04],
         };
 
-        insert(&inferred_blobs)
-            .into(all_the_blobs::table)
+        insert_into(all_the_blobs::table)
+            .values(&inferred_blobs)
             .execute(&conn)
             .unwrap();
         assert_eq!(Ok(vec![blobs]), all_the_blobs::table.load(&conn));
@@ -310,8 +310,8 @@ fn columns_named_as_reserved_keywords_are_renamed() {
     };
 
     let conn = connection();
-    insert(&value)
-        .into(with_keywords::table)
+    insert_into(with_keywords::table)
+        .values(&value)
         .execute(&conn)
         .unwrap();
     assert_eq!(Ok(vec![value]), with_keywords::table.load(&conn));
diff --git a/diesel_tests/tests/select.rs b/diesel_tests/tests/select.rs
index da3a2e585..25e38f003 100644
--- a/diesel_tests/tests/select.rs
+++ b/diesel_tests/tests/select.rs
@@ -150,8 +150,8 @@ fn selecting_columns_with_different_definition_order() {
     ).execute(&connection)
         .unwrap();
     let expected_user = User::with_hair_color(1, "Sean", "black");
-    insert(&NewUser::new("Sean", Some("black")))
-        .into(users::table)
+    insert_into(users::table)
+        .values(&NewUser::new("Sean", Some("black")))
         .execute(&connection)
         .unwrap();
     let user_from_select = users::table.first(&connection);
diff --git a/diesel_tests/tests/types.rs b/diesel_tests/tests/types.rs
index 8da2a10cd..127ee1a8e 100644
--- a/diesel_tests/tests/types.rs
+++ b/diesel_tests/tests/types.rs
@@ -122,9 +122,10 @@ fn test_chrono_types_sqlite() {
         time: dt.time(),
     };
 
-    insert(&new_time_types)
-        .into(has_time_types::table)
-        .execute(&connection);
+    insert_into(has_time_types::table)
+        .values(&new_time_types)
+        .execute(&connection)
+        .unwrap();
 
     let result = has_time_types::table
         .first::<NewTimeTypes>(&connection)
@@ -959,8 +960,8 @@ fn pg_jsonb_to_sql_jsonb() {
 fn text_array_can_be_assigned_to_varchar_array_column() {
     let conn = connection_with_sean_and_tess_in_users_table();
     let sean = find_user_by_name("Sean", &conn);
-    let post = insert(&sean.new_post("Hello", None))
-        .into(posts::table)
+    let post = insert_into(posts::table)
+        .values(&sean.new_post("Hello", None))
         .get_result::<Post>(&conn)
         .unwrap();
 
diff --git a/diesel_tests/tests/update.rs b/diesel_tests/tests/update.rs
index 149a6e1f1..9422f3287 100644
--- a/diesel_tests/tests/update.rs
+++ b/diesel_tests/tests/update.rs
@@ -216,8 +216,8 @@ fn sql_syntax_is_correct_when_option_field_comes_mixed_with_non_option() {
     let connection = connection_with_sean_and_tess_in_users_table();
     let sean = find_user_by_name("Sean", &connection);
     let new_post = sean.new_post("Hello", Some("world"));
-    insert(&new_post)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_post)
         .execute(&connection)
         .unwrap();
 
@@ -250,8 +250,8 @@ fn can_update_with_struct_containing_single_field() {
     let connection = connection_with_sean_and_tess_in_users_table();
     let sean = find_user_by_name("Sean", &connection);
     let new_post = sean.new_post("Hello", Some("world"));
-    insert(&new_post)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_post)
         .execute(&connection)
         .unwrap();
 
@@ -285,8 +285,8 @@ fn struct_with_option_fields_treated_as_null() {
     let connection = connection_with_sean_and_tess_in_users_table();
     let sean = find_user_by_name("Sean", &connection);
     let new_post = sean.new_post("Hello", Some("world"));
-    insert(&new_post)
-        .into(posts::table)
+    insert_into(posts::table)
+        .values(&new_post)
         .execute(&connection)
         .unwrap();
     let post = posts::table
@@ -340,10 +340,11 @@ fn upsert_with_no_changes_executes_do_nothing() {
     }
 
     let connection = connection_with_sean_and_tess_in_users_table();
-    let result = insert(
-        &User::new(1, "Sean")
-            .on_conflict(users::id, do_update().set(&Changes { hair_color: None })),
-    ).into(users::table)
+    let result = insert_into(users::table)
+        .values(
+            &User::new(1, "Sean")
+                .on_conflict(users::id, do_update().set(&Changes { hair_color: None })),
+        )
         .execute(&connection);
 
     assert_eq!(Ok(0), result);
@@ -371,8 +372,8 @@ fn upsert_with_sql_literal_for_target() {
     ];
     let conflict_target = sql::<Text>("(name) WHERE name != 'Tess'");
     let conflict_action = do_update().set(hair_color.eq(excluded(hair_color)));
-    insert(&new_users.on_conflict(conflict_target, conflict_action))
-        .into(users)
+    insert_into(users)
+        .values(&new_users.on_conflict(conflict_target, conflict_action))
         .execute(&connection)
         .unwrap();
 
diff --git a/examples/mysql/getting_started_step_2/src/lib.rs b/examples/mysql/getting_started_step_2/src/lib.rs
index b865eb322..10a5c0fd8 100644
--- a/examples/mysql/getting_started_step_2/src/lib.rs
+++ b/examples/mysql/getting_started_step_2/src/lib.rs
@@ -29,8 +29,8 @@ pub fn create_post(conn: &MysqlConnection, title: &str, body: &str) -> Post {
         body: body,
     };
 
-    diesel::insert(&new_post)
-        .into(posts::table)
+    diesel::insert_into(posts::table)
+        .values(&new_post)
         .execute(conn)
         .expect("Error saving new post");
 
diff --git a/examples/mysql/getting_started_step_3/src/lib.rs b/examples/mysql/getting_started_step_3/src/lib.rs
index bae0513b1..703010051 100644
--- a/examples/mysql/getting_started_step_3/src/lib.rs
+++ b/examples/mysql/getting_started_step_3/src/lib.rs
@@ -29,8 +29,8 @@ pub fn create_post(conn: &MysqlConnection, title: &str, body: &str) -> Post {
         body: body,
     };
 
-    diesel::insert(&new_post)
-        .into(posts)
+    diesel::insert_into(posts)
+        .values(&new_post)
         .execute(conn)
         .expect("Error saving new post");
 
diff --git a/examples/postgres/getting_started_step_2/src/lib.rs b/examples/postgres/getting_started_step_2/src/lib.rs
index 34901814f..c5e4447cf 100644
--- a/examples/postgres/getting_started_step_2/src/lib.rs
+++ b/examples/postgres/getting_started_step_2/src/lib.rs
@@ -28,8 +28,8 @@ pub fn create_post(conn: &PgConnection, title: &str, body: &str) -> Post {
         body: body,
     };
 
-    diesel::insert(&new_post)
-        .into(posts::table)
+    diesel::insert_into(posts::table)
+        .values(&new_post)
         .get_result(conn)
         .expect("Error saving new post")
 }
diff --git a/examples/postgres/getting_started_step_3/src/lib.rs b/examples/postgres/getting_started_step_3/src/lib.rs
index 34901814f..c5e4447cf 100644
--- a/examples/postgres/getting_started_step_3/src/lib.rs
+++ b/examples/postgres/getting_started_step_3/src/lib.rs
@@ -28,8 +28,8 @@ pub fn create_post(conn: &PgConnection, title: &str, body: &str) -> Post {
         body: body,
     };
 
-    diesel::insert(&new_post)
-        .into(posts::table)
+    diesel::insert_into(posts::table)
+        .values(&new_post)
         .get_result(conn)
         .expect("Error saving new post")
 }
diff --git a/examples/sqlite/getting_started_step_2/src/lib.rs b/examples/sqlite/getting_started_step_2/src/lib.rs
index 400a0670c..7068ef212 100644
--- a/examples/sqlite/getting_started_step_2/src/lib.rs
+++ b/examples/sqlite/getting_started_step_2/src/lib.rs
@@ -29,8 +29,8 @@ pub fn create_post(conn: &SqliteConnection, title: &str, body: &str) -> usize {
         body: body,
     };
 
-    diesel::insert(&new_post)
-        .into(posts::table)
+    diesel::insert_into(posts::table)
+        .values(&new_post)
         .execute(conn)
         .expect("Error saving new post")
 }
diff --git a/examples/sqlite/getting_started_step_3/src/lib.rs b/examples/sqlite/getting_started_step_3/src/lib.rs
index 785aa35c8..649b0dd86 100644
--- a/examples/sqlite/getting_started_step_3/src/lib.rs
+++ b/examples/sqlite/getting_started_step_3/src/lib.rs
@@ -30,8 +30,8 @@ pub fn create_post(conn: &SqliteConnection, title: &str, body: &str) -> usize {
         body: body,
     };
 
-    diesel::insert(&new_post)
-        .into(posts::table)
+    diesel::insert_into(posts::table)
+        .values(&new_post)
         .execute(conn)
         .expect("Error saving new post")
 }
diff --git a/guide_drafts/model-derives.md b/guide_drafts/model-derives.md
index 235671f32..dd7dc0500 100644
--- a/guide_drafts/model-derives.md
+++ b/guide_drafts/model-derives.md
@@ -220,7 +220,7 @@ error[E0277]: the trait bound `&diesel_demo::models::NewUser<'_>: diesel::query_
 ```
 
 In the above error, the compiler is telling us there is an unsatisfied trait bound from `IntoInsertStatement`.
-`diesel::insert()` returns an `IncompleteInsertStatement`,
+`diesel::insert()` returns an `DeprecatedIncompleteInsertStatement`,
 which implements `into()`.
 `into()` specifies the table the `Insertable` data should be passed to.
 If your struct isn't `Insertable`, Rust will get confused and ask you implement this trait.
