diff --git a/CHANGELOG.md b/CHANGELOG.md
index c2a00b48a..3646f0d34 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -27,6 +27,10 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * Diesel CLI can now generate completions for zsh and fish. See `diesel
   completions --help` for details.
 
+* `#[belongs_to]` can now accept types that are generic over lifetimes (for
+  example, if one of the fields has the type `Cow<'a, str>`). To define an
+  association to such a type, write `#[belongs_to(parent = "User<'_>")]`
+
 ### Changed
 
 * Diesel's derives now require that `extern crate diesel;` be at your crate root
diff --git a/diesel/src/associations/mod.rs b/diesel/src/associations/mod.rs
index 1f9ad16f3..33ebbe49b 100644
--- a/diesel/src/associations/mod.rs
+++ b/diesel/src/associations/mod.rs
@@ -49,6 +49,35 @@
 //! The struct given to `#[belongs_to]` must be in scope,
 //! so you will need `use some_module::User` if `User` is defined in another module.
 //!
+//! If the parent record is generic over lifetimes, they can be written as `'_`.
+//! You will also need to wrap the type in quotes until
+//! `unrestricted_attribute_tokens` is stable.
+//!
+//! ```rust
+//! # #[macro_use] extern crate diesel;
+//! # include!("../doctest_setup.rs");
+//! # use schema::{posts, users};
+//! # use std::borrow::Cow;
+//! #
+//! #[derive(Identifiable)]
+//! #[table_name = "users"]
+//! pub struct User<'a> {
+//!     id: i32,
+//!     name: Cow<'a, str>,
+//! }
+//!
+//! #[derive(Associations)]
+//! #[belongs_to(parent = "User<'_>")]
+//! #[table_name = "posts"]
+//! pub struct Post {
+//!     id: i32,
+//!     user_id: i32,
+//!     title: String,
+//! }
+//! #
+//! # fn main() {}
+//! ```
+//!
 //! [`Identifiable`]: trait.Identifiable.html
 //!
 //! By default, Diesel assumes that your foreign keys will follow the convention `table_name_id`.
diff --git a/diesel_compile_tests/tests/ui/belongs_to_incorrect_lifetime_syntax.rs b/diesel_compile_tests/tests/ui/belongs_to_incorrect_lifetime_syntax.rs
new file mode 100644
index 000000000..2e7adc3cd
--- /dev/null
+++ b/diesel_compile_tests/tests/ui/belongs_to_incorrect_lifetime_syntax.rs
@@ -0,0 +1,30 @@
+#[macro_use] extern crate diesel;
+
+table! {
+    foo {
+        id -> Integer,
+    }
+}
+
+table! {
+    bars {
+        id -> Integer,
+        foo_id -> Integer,
+    }
+}
+
+#[derive(Identifiable)]
+#[table_name = "foo"]
+struct Foo<'a> {
+    id: i32,
+    _marker: ::std::marker::PhantomData<&'a ()>,
+}
+
+
+#[derive(Associations)]
+#[belongs_to(parent = "Foo<'a>")]
+struct Bar {
+    foo_id: i32,
+}
+
+fn main() {}
diff --git a/diesel_compile_tests/tests/ui/belongs_to_incorrect_lifetime_syntax.stderr b/diesel_compile_tests/tests/ui/belongs_to_incorrect_lifetime_syntax.stderr
new file mode 100644
index 000000000..8a53c9764
--- /dev/null
+++ b/diesel_compile_tests/tests/ui/belongs_to_incorrect_lifetime_syntax.stderr
@@ -0,0 +1,9 @@
+error[E0261]: use of undeclared lifetime name `'a`
+  --> $DIR/belongs_to_incorrect_lifetime_syntax.rs:25:23
+   |
+25 | #[belongs_to(parent = "Foo<'a>")]
+   |                       ^^^^^^^^^ undeclared lifetime
+
+error: aborting due to previous error
+
+For more information about this error, try `rustc --explain E0261`.
diff --git a/diesel_compile_tests/tests/ui/belongs_to_invalid_option_syntax.stderr b/diesel_compile_tests/tests/ui/belongs_to_invalid_option_syntax.stderr
index 782ae673f..4de256291 100644
--- a/diesel_compile_tests/tests/ui/belongs_to_invalid_option_syntax.stderr
+++ b/diesel_compile_tests/tests/ui/belongs_to_invalid_option_syntax.stderr
@@ -16,15 +16,15 @@ error: Expected a struct name
 25 | #[belongs_to()]
    |   ^^^^^^^^^^
    |
-   = help: e.g. `#[belongs_to(User)]`
+   = help: e.g. `#[belongs_to(User)]` or `#[belongs_to(parent = "User<'_>")]
 
 error: Expected a struct name
-  --> $DIR/belongs_to_invalid_option_syntax.rs:26:14
+  --> $DIR/belongs_to_invalid_option_syntax.rs:26:3
    |
 26 | #[belongs_to(foreign_key = "bar_id")]
-   |              ^^^^^^^^^^^
+   |   ^^^^^^^^^^
    |
-   = help: e.g. `#[belongs_to(User)]`
+   = help: e.g. `#[belongs_to(User)]` or `#[belongs_to(parent = "User<'_>")]
 
 error: `foreign_key` must be in the form `foreign_key = "value"`
   --> $DIR/belongs_to_invalid_option_syntax.rs:27:19
diff --git a/diesel_derives/src/associations.rs b/diesel_derives/src/associations.rs
index 2b3cf28d7..064046c98 100644
--- a/diesel_derives/src/associations.rs
+++ b/diesel_derives/src/associations.rs
@@ -1,5 +1,8 @@
 use proc_macro2;
+use proc_macro2::Span;
 use syn;
+use syn::fold::Fold;
+use syn::spanned::Spanned;
 
 use diagnostic_shim::*;
 use meta::*;
@@ -45,6 +48,13 @@ fn derive_belongs_to(
 
     let mut generics = generics.clone();
 
+    let parent_struct = ReplacePathLifetimes::new(|i, span| {
+        let letter = char::from(b'b' + i as u8);
+        let lifetime = syn::Lifetime::new(&format!("'__{}", letter), span);
+        generics.params.push(parse_quote!(#lifetime));
+        lifetime
+    }).fold_type_path(parent_struct);
+
     // TODO: Remove this special casing as soon as we bump our minimal supported
     // rust version to >= 1.30.0 because this version will add
     // `impl<'a, T> From<&'a Option<T>> for Option<&'a T>` to the std-lib
@@ -96,24 +106,41 @@ fn derive_belongs_to(
 }
 
 struct AssociationOptions {
-    parent_struct: syn::Ident,
+    parent_struct: syn::TypePath,
     foreign_key: syn::Ident,
 }
 
 impl AssociationOptions {
     fn from_meta(meta: MetaItem) -> Result<Self, Diagnostic> {
         let parent_struct = meta.nested()?
-            .nth(0)
+            .find(|m| m.word().is_ok() || m.name() == "parent")
             .ok_or_else(|| meta.span())
-            .and_then(|m| m.word().map_err(|_| m.span()))
+            .and_then(|m| {
+                m.word()
+                    .map(|i| parse_quote!(#i))
+                    .or_else(|_| m.ty_value())
+                    .map_err(|_| m.span())
+            })
+            .and_then(|ty| match ty {
+                syn::Type::Path(ty_path) => Ok(ty_path),
+                _ => Err(ty.span()),
+            })
             .map_err(|span| {
                 span.error("Expected a struct name")
-                    .help("e.g. `#[belongs_to(User)]`")
+                    .help("e.g. `#[belongs_to(User)]` or `#[belongs_to(parent = \"User<'_>\")]")
             })?;
-        let foreign_key = meta.nested_item("foreign_key")
-            .ok()
-            .map(|i| i.ident_value())
-            .unwrap_or_else(|| Ok(infer_foreign_key(&parent_struct)))?;
+        let foreign_key = {
+            let parent_struct_name = parent_struct
+                .path
+                .segments
+                .last()
+                .expect("paths always have at least one segment")
+                .into_value();
+            meta.nested_item("foreign_key")
+                .ok()
+                .map(|i| i.ident_value())
+                .unwrap_or_else(|| Ok(infer_foreign_key(&parent_struct_name.ident)))?
+        };
 
         let unrecognized_options = meta.nested()?.skip(1).filter(|n| n.name() != "foreign_key");
         for ignored in unrecognized_options {
@@ -134,3 +161,27 @@ fn infer_foreign_key(name: &syn::Ident) -> syn::Ident {
     let snake_case = camel_to_snake(&name.to_string());
     syn::Ident::new(&format!("{}_id", snake_case), name.span())
 }
+
+struct ReplacePathLifetimes<F> {
+    count: usize,
+    f: F,
+}
+
+impl<F> ReplacePathLifetimes<F> {
+    fn new(f: F) -> Self {
+        Self { count: 0, f }
+    }
+}
+
+impl<F> Fold for ReplacePathLifetimes<F>
+where
+    F: FnMut(usize, Span) -> syn::Lifetime,
+{
+    fn fold_lifetime(&mut self, mut lt: syn::Lifetime) -> syn::Lifetime {
+        if lt.ident == "_" {
+            lt = (self.f)(self.count, lt.span());
+            self.count += 1;
+        }
+        lt
+    }
+}
