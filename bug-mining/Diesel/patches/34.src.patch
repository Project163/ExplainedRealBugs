diff --git a/.travis.yml b/.travis.yml
index d23d6810b..16dedd5fb 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -14,12 +14,11 @@ before_script:
   - psql -c 'create database diesel_schema;' -U postgres
 script:
 - |
-  (cd diesel && travis-cargo build) &&
-  (cd diesel && travis-cargo doc) &&
+  (cd diesel && travis-cargo doc -- --features "postgres sqlite") &&
   if [[ "$TRAVIS_RUST_VERSION" == nightly* ]]; then
-    (cd diesel && travis-cargo test -- --features "unstable chrono")
+    (cd diesel && travis-cargo test -- --no-default-features --features "unstable chrono $BACKEND")
   else
-    (cd diesel && travis-cargo test -- --features chrono)
+    (cd diesel && travis-cargo test -- --no-default-features --features "chrono $BACKEND")
   fi &&
   (cd diesel_cli && travis-cargo test) &&
   if [[ "$TRAVIS_RUST_VERSION" == nightly* ]]; then
@@ -44,7 +43,7 @@ matrix:
   allow_failures:
     - rust: nightly
 after_success:
-- "(cd diesel && travis-cargo --only stable doc-upload)"
+  - "(cd diesel && travis-cargo --only stable doc-upload -- --features \"postgres sqlite\")"
 branches:
   only:
     - master
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 98eb645fe..ec6859ba6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -39,6 +39,9 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 ### Changed
 
+* `Connection` is now a trait instead of a struct. The struct that was
+  previously known as `Connection` can be found at `diesel::pg::PgConnection`.
+
 * Rename both the `#[derive(Queriable)]` attribute and the `Queriable` trait to
   use the correct spelling `Queryable`.
 
diff --git a/bin/test b/bin/test
index 9c4e517ab..b2233707c 100755
--- a/bin/test
+++ b/bin/test
@@ -1,7 +1,7 @@
 #!/bin/sh
 set -e
 
-(cd diesel && cargo test --features "unstable chrono")
+(cd diesel && cargo test --features "unstable chrono sqlite")
 (cd diesel_cli && cargo test)
 (cd diesel_codegen && cargo test --no-default-features --features nightly)
 (cd diesel_tests && cargo test --features "unstable postgres" --no-default-features)
diff --git a/diesel/Cargo.toml b/diesel/Cargo.toml
index 123465eb8..3bb83ed49 100644
--- a/diesel/Cargo.toml
+++ b/diesel/Cargo.toml
@@ -11,8 +11,8 @@ keywords = ["orm", "database", "postgres", "postgresql", "sql"]
 
 [dependencies]
 libc = "0.2.*"
-pq-sys = "0.2.*"
-libsqlite3-sys = "^0.4.0"
+pq-sys = { version = "^0.2.0", optional = true }
+libsqlite3-sys = { version = "^0.4.0", optional = true }
 byteorder = "0.3.*"
 quickcheck = { git = "https://github.com/BurntSushi/quickcheck.git", optional = true }
 chrono = { version = "^0.2.17", optional = true }
@@ -23,5 +23,8 @@ dotenv = "^0.6.0"
 tempdir = "^0.3.4"
 
 [features]
+default = ["postgres"]
 unstable = []
 large-tables = []
+postgres = ["pq-sys"]
+sqlite = ["libsqlite3-sys"]
diff --git a/diesel/src/backend.rs b/diesel/src/backend.rs
index 1d1a8cc2c..a65b4e246 100644
--- a/diesel/src/backend.rs
+++ b/diesel/src/backend.rs
@@ -1,8 +1,5 @@
-use connection::sqlite::SqliteValue;
 use query_builder::QueryBuilder;
 use query_builder::debug::DebugQueryBuilder;
-use query_builder::pg::PgQueryBuilder;
-use query_builder::sqlite::SqliteQueryBuilder;
 use types::{self, HasSqlType};
 
 pub trait Backend where
@@ -12,7 +9,6 @@ pub trait Backend where
     Self: HasSqlType<types::BigInt>,
     Self: HasSqlType<types::Float>,
     Self: HasSqlType<types::Double>,
-    Self: HasSqlType<types::Numeric>,
     Self: HasSqlType<types::VarChar>,
     Self: HasSqlType<types::Text>,
     Self: HasSqlType<types::Binary>,
@@ -44,44 +40,3 @@ impl TypeMetadata for Debug {
 
 impl SupportsReturningClause for Debug {}
 impl SupportsDefaultKeyword for Debug {}
-
-pub struct Pg;
-
-#[derive(Debug, Clone, Copy)]
-pub struct PgTypeMetadata {
-    pub oid: u32,
-    pub array_oid: u32,
-}
-
-impl Backend for Pg {
-    type QueryBuilder = PgQueryBuilder;
-    type RawValue = [u8];
-}
-
-impl TypeMetadata for Pg {
-    type TypeMetadata = PgTypeMetadata;
-}
-
-impl SupportsReturningClause for Pg {}
-impl SupportsDefaultKeyword for Pg {}
-
-pub struct Sqlite;
-
-pub enum SqliteType {
-    Binary,
-    Text,
-    Float,
-    Double,
-    SmallInt,
-    Integer,
-    Long,
-}
-
-impl Backend for Sqlite {
-    type QueryBuilder = SqliteQueryBuilder;
-    type RawValue = SqliteValue;
-}
-
-impl TypeMetadata for Sqlite {
-    type TypeMetadata = SqliteType;
-}
diff --git a/diesel/src/connection/mod.rs b/diesel/src/connection/mod.rs
index eddd7715d..16bec9545 100644
--- a/diesel/src/connection/mod.rs
+++ b/diesel/src/connection/mod.rs
@@ -1,11 +1,5 @@
 extern crate libc;
 
-pub mod pg;
-pub mod sqlite;
-
-pub use self::pg::PgConnection;
-pub use self::sqlite::SqliteConnection;
-
 use backend::Backend;
 use query_builder::{AsQuery, QueryFragment};
 use query_source::Queryable;
diff --git a/diesel/src/doctest_setup.rs b/diesel/src/doctest_setup.rs
index 3a0d9e99f..a70238017 100644
--- a/diesel/src/doctest_setup.rs
+++ b/diesel/src/doctest_setup.rs
@@ -4,19 +4,24 @@ use diesel::prelude::*;
 use diesel::backend;
 use self::dotenv::dotenv;
 
-fn connection_no_data() -> diesel::connection::PgConnection {
+#[cfg(feature = "postgres")]
+type DB = diesel::pg::Pg;
+
+#[cfg(feature = "postgres")]
+fn connection_no_data() -> diesel::pg::PgConnection {
     dotenv().ok();
 
     let connection_url = ::std::env::var("DATABASE_URL")
         .expect("DATABASE_URL must be set in order to run tests");
-    let connection = diesel::connection::PgConnection::establish(&connection_url).unwrap();
+    let connection = diesel::pg::PgConnection::establish(&connection_url).unwrap();
     connection.begin_test_transaction().unwrap();
     connection.execute("DROP TABLE IF EXISTS users").unwrap();
 
     connection
 }
 
-fn establish_connection() -> diesel::connection::PgConnection {
+#[cfg(feature = "postgres")]
+fn establish_connection() -> diesel::pg::PgConnection {
     let connection = connection_no_data();
 
     connection.execute("CREATE TABLE users (
@@ -27,3 +32,24 @@ fn establish_connection() -> diesel::connection::PgConnection {
 
     connection
 }
+
+#[cfg(all(not(feature = "postgres"), feature = "sqlite"))]
+type DB = diesel::sqlite::Sqlite;
+
+#[cfg(all(not(feature = "postgres"), feature = "sqlite"))]
+fn connection_no_data() -> diesel::sqlite::SqliteConnection {
+    diesel::sqlite::SqliteConnection::establish(":memory:").unwrap()
+}
+
+#[cfg(all(not(feature = "postgres"), feature = "sqlite"))]
+fn establish_connection() -> diesel::sqlite::SqliteConnection {
+    let connection = connection_no_data();
+
+    connection.execute("CREATE TABLE users (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        name VARCHAR NOT NULL
+    )").unwrap();
+    connection.execute("INSERT INTO users (name) VALUES ('Sean'), ('Tess')").unwrap();
+
+    connection
+}
diff --git a/diesel/src/expression/expression_methods/global_expression_methods.rs b/diesel/src/expression/expression_methods/global_expression_methods.rs
index 43054a04b..f71f22023 100644
--- a/diesel/src/expression/expression_methods/global_expression_methods.rs
+++ b/diesel/src/expression/expression_methods/global_expression_methods.rs
@@ -33,7 +33,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #
     /// # table! {
     /// #     users {
-    /// #         id -> Serial,
+    /// #         id -> Integer,
     /// #         name -> VarChar,
     /// #     }
     /// # }
@@ -67,7 +67,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #
     /// # table! {
     /// #     users {
-    /// #         id -> Serial,
+    /// #         id -> Integer,
     /// #         name -> VarChar,
     /// #     }
     /// # }
@@ -103,7 +103,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #
     /// # table! {
     /// #     users {
-    /// #         id -> Serial,
+    /// #         id -> Integer,
     /// #         name -> VarChar,
     /// #     }
     /// # }
@@ -129,7 +129,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #
     /// # table! {
     /// #     users {
-    /// #         id -> Serial,
+    /// #         id -> Integer,
     /// #         name -> VarChar,
     /// #     }
     /// # }
@@ -155,7 +155,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #
     /// # table! {
     /// #     users {
-    /// #         id -> Serial,
+    /// #         id -> Integer,
     /// #         name -> VarChar,
     /// #     }
     /// # }
@@ -181,7 +181,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #
     /// # table! {
     /// #     users {
-    /// #         id -> Serial,
+    /// #         id -> Integer,
     /// #         name -> VarChar,
     /// #     }
     /// # }
@@ -229,7 +229,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #
     /// # table! {
     /// #     users {
-    /// #         id -> Serial,
+    /// #         id -> Integer,
     /// #         name -> VarChar,
     /// #     }
     /// # }
@@ -237,7 +237,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # fn main() {
     /// #     use self::users::dsl::*;
     /// #     let order = "name";
-    /// let ordering: Box<BoxableExpression<users, (), backend::Pg, SqlType=()>> =
+    /// let ordering: Box<BoxableExpression<users, (), DB, SqlType=()>> =
     ///     if order == "name" {
     ///         Box::new(name.desc())
     ///     } else {
@@ -262,14 +262,14 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #
     /// table! {
     ///     users {
-    ///         id -> Serial,
+    ///         id -> Integer,
     ///         name -> VarChar,
     ///     }
     /// }
     ///
     /// table! {
     ///     posts {
-    ///         id -> Serial,
+    ///         id -> Integer,
     ///         user_id -> Integer,
     ///         author_name -> Nullable<VarChar>,
     ///     }
diff --git a/diesel/src/expression/functions/mod.rs b/diesel/src/expression/functions/mod.rs
index 769561229..48d3e972f 100644
--- a/diesel/src/expression/functions/mod.rs
+++ b/diesel/src/expression/functions/mod.rs
@@ -82,7 +82,7 @@ macro_rules! sql_function_body {
 /// # #[macro_use] extern crate diesel;
 /// # use diesel::*;
 /// #
-/// # table! { crates { id -> Serial, name -> VarChar, } }
+/// # table! { crates { id -> Integer, name -> VarChar, } }
 /// #
 /// sql_function!(canon_crate_name, canon_crate_name_t, (a: types::VarChar) -> types::VarChar);
 ///
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index f059791c6..278f4b4c0 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -20,15 +20,12 @@ pub mod ops;
 #[doc(hidden)]
 pub mod aliased;
 #[doc(hidden)]
-pub mod array_comparison;
-#[doc(hidden)]
 pub mod bound;
 #[doc(hidden)]
 pub mod count;
 #[doc(hidden)]
 pub mod date_and_time;
 pub mod expression_methods;
-pub mod extensions;
 #[doc(hidden)]
 pub mod functions;
 #[doc(hidden)]
@@ -44,14 +41,14 @@ pub mod sql_literal;
 /// generic to export by default. This module exists to conveniently glob import
 /// in functions where you need them.
 pub mod dsl {
-    #[doc(inline)] pub use super::array_comparison::any;
     #[doc(inline)] pub use super::count::{count, count_star};
     #[doc(inline)] pub use super::functions::date_and_time::*;
     #[doc(inline)] pub use super::functions::aggregate_ordering::*;
     #[doc(inline)] pub use super::functions::aggregate_folding::*;
     #[doc(inline)] pub use super::sql_literal::sql;
 
-    pub use super::extensions::*;
+    #[cfg(feature = "postgres")]
+    pub use pg::expression::dsl::*;
 }
 
 pub use self::dsl::*;
diff --git a/diesel/src/lib.rs b/diesel/src/lib.rs
index 33c6aeb2b..d3e606358 100644
--- a/diesel/src/lib.rs
+++ b/diesel/src/lib.rs
@@ -2,18 +2,23 @@
 //! interactions. [A getting started guide](https://github.com/sgrif/diesel#getting-started) can be
 //! found in the README.
 #![deny(warnings)]
-#![cfg_attr(feature = "unstable", feature(time2))]
+#![cfg_attr(all(feature = "unstable", feature = "postgres"), feature(time2))]
 pub mod backend;
 pub mod connection;
 pub mod expression;
 #[doc(hidden)]
 pub mod persistable;
+#[macro_use]
 pub mod types;
 
+#[cfg(feature = "postgres")]
+pub mod pg;
+#[cfg(feature = "sqlite")]
+pub mod sqlite;
+
 #[macro_use]
 mod macros;
 
-mod db_result;
 pub mod migrations;
 pub mod query_builder;
 mod query_dsl;
diff --git a/diesel/src/macros.rs b/diesel/src/macros.rs
index 666bd029a..5c8ee962a 100644
--- a/diesel/src/macros.rs
+++ b/diesel/src/macros.rs
@@ -61,7 +61,7 @@ macro_rules! column {
 /// # #[macro_use] extern crate diesel;
 /// table! {
 ///     users {
-///         id -> Serial,
+///         id -> Integer,
 ///         name -> VarChar,
 ///         favorite_color -> Nullable<VarChar>,
 ///     }
@@ -75,7 +75,7 @@ macro_rules! column {
 /// # #[macro_use] extern crate diesel;
 /// table! {
 ///     users (non_standard_primary_key) {
-///         non_standard_primary_key -> Serial,
+///         non_standard_primary_key -> Integer,
 ///         name -> VarChar,
 ///         favorite_color -> Nullable<VarChar>,
 ///     } no select {
diff --git a/diesel/src/pg/backend.rs b/diesel/src/pg/backend.rs
new file mode 100644
index 000000000..1147dd550
--- /dev/null
+++ b/diesel/src/pg/backend.rs
@@ -0,0 +1,22 @@
+use backend::*;
+use super::query_builder::PgQueryBuilder;
+
+pub struct Pg;
+
+#[derive(Debug, Clone, Copy)]
+pub struct PgTypeMetadata {
+    pub oid: u32,
+    pub array_oid: u32,
+}
+
+impl Backend for Pg {
+    type QueryBuilder = PgQueryBuilder;
+    type RawValue = [u8];
+}
+
+impl TypeMetadata for Pg {
+    type TypeMetadata = PgTypeMetadata;
+}
+
+impl SupportsReturningClause for Pg {}
+impl SupportsDefaultKeyword for Pg {}
diff --git a/diesel/src/connection/pg/cursor.rs b/diesel/src/pg/connection/cursor.rs
similarity index 96%
rename from diesel/src/connection/pg/cursor.rs
rename to diesel/src/pg/connection/cursor.rs
index 07d7e42fa..bb92d2898 100644
--- a/diesel/src/connection/pg/cursor.rs
+++ b/diesel/src/pg/connection/cursor.rs
@@ -1,6 +1,6 @@
-use backend::Pg;
+use pg::Pg;
 use query_source::Queryable;
-use db_result::PgResult;
+use super::result::PgResult;
 use types::{HasSqlType, FromSqlRow};
 
 use std::marker::PhantomData;
diff --git a/diesel/src/connection/pg/mod.rs b/diesel/src/pg/connection/mod.rs
similarity index 97%
rename from diesel/src/connection/pg/mod.rs
rename to diesel/src/pg/connection/mod.rs
index 924d664af..f9ed814b3 100644
--- a/diesel/src/connection/pg/mod.rs
+++ b/diesel/src/pg/connection/mod.rs
@@ -1,23 +1,22 @@
 extern crate libc;
 
 mod cursor;
-#[doc(hidden)]
 pub mod raw;
+mod row;
+mod result;
 
-use std::cell::Cell;
-use std::ffi::{CString, CStr};
-use std::rc::Rc;
-use std::ptr;
-
-use backend::Pg;
-use db_result::PgResult;
+use connection::{SimpleConnection, Connection};
+use pg::{Pg, PgQueryBuilder};
 use query_builder::{AsQuery, QueryFragment};
-use query_builder::pg::PgQueryBuilder;
 use query_source::Queryable;
 use result::*;
 use self::cursor::Cursor;
 use self::raw::RawConnection;
-use super::{SimpleConnection, Connection};
+use self::result::PgResult;
+use std::cell::Cell;
+use std::ffi::{CString, CStr};
+use std::ptr;
+use std::rc::Rc;
 use types::{ToSql, HasSqlType};
 
 /// The connection string expected by `PgConnection::establish`
diff --git a/diesel/src/connection/pg/raw.rs b/diesel/src/pg/connection/raw.rs
similarity index 100%
rename from diesel/src/connection/pg/raw.rs
rename to diesel/src/pg/connection/raw.rs
diff --git a/diesel/src/db_result.rs b/diesel/src/pg/connection/result.rs
similarity index 97%
rename from diesel/src/db_result.rs
rename to diesel/src/pg/connection/result.rs
index e8d1130c7..953dfc809 100644
--- a/diesel/src/db_result.rs
+++ b/diesel/src/pg/connection/result.rs
@@ -1,9 +1,9 @@
 extern crate pq_sys;
 extern crate libc;
 
-use connection::pg::PgConnection;
 use result::{Error, QueryResult};
-use row::PgRow;
+use super::PgConnection;
+use super::row::PgRow;
 
 use self::pq_sys::*;
 use std::ffi::CStr;
diff --git a/diesel/src/pg/connection/row.rs b/diesel/src/pg/connection/row.rs
new file mode 100644
index 000000000..ed112998d
--- /dev/null
+++ b/diesel/src/pg/connection/row.rs
@@ -0,0 +1,33 @@
+use pg::Pg;
+use row::Row;
+use super::result::PgResult;
+
+pub struct PgRow<'a> {
+    db_result: &'a PgResult,
+    row_idx: usize,
+    col_idx: usize,
+}
+
+impl<'a> PgRow<'a> {
+    pub fn new(db_result: &'a PgResult, row_idx: usize) -> Self {
+        PgRow {
+            db_result: db_result,
+            row_idx: row_idx,
+            col_idx: 0,
+        }
+    }
+}
+
+impl<'a> Row<Pg> for PgRow<'a> {
+    fn take(&mut self) -> Option<&[u8]> {
+        let current_idx = self.col_idx;
+        self.col_idx += 1;
+        self.db_result.get(self.row_idx, current_idx)
+    }
+
+    fn next_is_null(&self, count: usize) -> bool {
+        (0..count).all(|i| {
+            self.db_result.is_null(self.row_idx, self.col_idx + i)
+        })
+    }
+}
diff --git a/diesel/src/expression/array_comparison.rs b/diesel/src/pg/expression/array_comparison.rs
similarity index 76%
rename from diesel/src/expression/array_comparison.rs
rename to diesel/src/pg/expression/array_comparison.rs
index c16943d41..a7c49bda8 100644
--- a/diesel/src/expression/array_comparison.rs
+++ b/diesel/src/pg/expression/array_comparison.rs
@@ -1,8 +1,10 @@
 use std::marker::PhantomData;
 
-use backend::{Backend, Pg};
+use backend::*;
+use expression::{AsExpression, Expression, SelectableExpression, NonAggregate};
+use pg::{Pg, PgQueryBuilder};
 use query_builder::*;
-use super::{AsExpression, Expression, SelectableExpression, NonAggregate};
+use query_builder::debug::DebugQueryBuilder;
 use types::{Array, HasSqlType};
 
 /// Creates a PostgreSQL `ANY` expression.
@@ -64,11 +66,21 @@ impl<Expr, ST> Expression for Any<Expr, ST> where
     type SqlType = ST;
 }
 
-impl<Expr, ST, DB> QueryFragment<DB> for Any<Expr, ST> where
-    DB: Backend,
-    Expr: QueryFragment<DB>,
+impl<Expr, ST> QueryFragment<Pg> for Any<Expr, ST> where
+    Expr: QueryFragment<Pg>,
 {
-    fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
+    fn to_sql(&self, out: &mut PgQueryBuilder) -> BuildQueryResult {
+        out.push_sql("ANY(");
+        try!(self.expr.to_sql(out));
+        out.push_sql(")");
+        Ok(())
+    }
+}
+
+impl<Expr, ST> QueryFragment<Debug> for Any<Expr, ST> where
+    Expr: QueryFragment<Debug>,
+{
+    fn to_sql(&self, out: &mut DebugQueryBuilder) -> BuildQueryResult {
         out.push_sql("ANY(");
         try!(self.expr.to_sql(out));
         out.push_sql(")");
diff --git a/diesel/src/expression/extensions/interval_dsl.rs b/diesel/src/pg/expression/extensions/interval_dsl.rs
similarity index 99%
rename from diesel/src/expression/extensions/interval_dsl.rs
rename to diesel/src/pg/expression/extensions/interval_dsl.rs
index 4595fbd3c..67418cb33 100644
--- a/diesel/src/expression/extensions/interval_dsl.rs
+++ b/diesel/src/pg/expression/extensions/interval_dsl.rs
@@ -248,9 +248,9 @@ mod tests {
     use self::dotenv::dotenv;
 
     use ::{types, select};
-    use connection::PgConnection;
     use data_types::PgInterval;
     use expression::dsl::sql;
+    use pg::PgConnection;
     use prelude::*;
     use super::*;
 
diff --git a/diesel/src/expression/extensions/mod.rs b/diesel/src/pg/expression/extensions/mod.rs
similarity index 100%
rename from diesel/src/expression/extensions/mod.rs
rename to diesel/src/pg/expression/extensions/mod.rs
diff --git a/diesel/src/pg/expression/mod.rs b/diesel/src/pg/expression/mod.rs
new file mode 100644
index 000000000..1e9a40c5c
--- /dev/null
+++ b/diesel/src/pg/expression/mod.rs
@@ -0,0 +1,12 @@
+#[doc(hidden)]
+pub mod array_comparison;
+pub mod extensions;
+
+/// PostgreSQL specific expression DSL methods. This module will be glob
+/// imported by [`expression::dsl`](../../expression/dsl/index.html) when
+/// compiled with the `feature = "postgres"` flag.
+pub mod dsl {
+    #[doc(inline)] pub use super::array_comparison::any;
+
+    pub use super::extensions::*;
+}
diff --git a/diesel/src/pg/mod.rs b/diesel/src/pg/mod.rs
new file mode 100644
index 000000000..4a9b1c333
--- /dev/null
+++ b/diesel/src/pg/mod.rs
@@ -0,0 +1,18 @@
+pub mod expression;
+
+mod backend;
+mod query_builder;
+mod connection;
+#[doc(hidden)]
+pub mod types;
+
+pub use self::backend::{Pg, PgTypeMetadata};
+pub use self::connection::PgConnection;
+pub use self::query_builder::PgQueryBuilder;
+
+pub mod data_types {
+    #[doc(inline)]
+    pub use super::types::date_and_time::{PgTimestamp, PgDate, PgTime, PgInterval};
+    #[doc(inline)]
+    pub use super::types::floats::PgNumeric;
+}
diff --git a/diesel/src/query_builder/pg.rs b/diesel/src/pg/query_builder.rs
similarity index 89%
rename from diesel/src/query_builder/pg.rs
rename to diesel/src/pg/query_builder.rs
index 4852d8515..de83a4e73 100644
--- a/diesel/src/query_builder/pg.rs
+++ b/diesel/src/pg/query_builder.rs
@@ -1,8 +1,8 @@
 use std::rc::Rc;
 
-use backend::Pg;
-use connection::pg::raw::RawConnection;
-use super::{QueryBuilder, Binds, BuildQueryResult};
+use super::backend::Pg;
+use super::connection::raw::RawConnection;
+use query_builder::{QueryBuilder, Binds, BuildQueryResult};
 use types::HasSqlType;
 
 pub struct PgQueryBuilder {
diff --git a/diesel/src/types/impls/array.rs b/diesel/src/pg/types/array.rs
similarity index 98%
rename from diesel/src/types/impls/array.rs
rename to diesel/src/pg/types/array.rs
index 8cd8b9365..fd14b2be5 100644
--- a/diesel/src/types/impls/array.rs
+++ b/diesel/src/pg/types/array.rs
@@ -4,10 +4,10 @@ use self::byteorder::{ReadBytesExt, WriteBytesExt, BigEndian};
 use std::error::Error;
 use std::io::Write;
 
-use backend::{Pg, Debug, PgTypeMetadata};
+use backend::Debug;
+use pg::{Pg, PgTypeMetadata};
 use query_source::Queryable;
 use row::Row;
-use super::option::UnexpectedNullError;
 use types::{HasSqlType, FromSql, FromSqlRow, ToSql, Array, IsNull, NotNull};
 
 impl<T> HasSqlType<Array<T>> for Pg where
diff --git a/diesel/src/types/impls/date_and_time/chrono.rs b/diesel/src/pg/types/date_and_time/chrono.rs
similarity index 99%
rename from diesel/src/types/impls/date_and_time/chrono.rs
rename to diesel/src/pg/types/date_and_time/chrono.rs
index a9b2d6e63..eb3abd0f4 100644
--- a/diesel/src/types/impls/date_and_time/chrono.rs
+++ b/diesel/src/pg/types/date_and_time/chrono.rs
@@ -7,9 +7,9 @@ use std::io::Write;
 use self::chrono::{Duration, NaiveDateTime, NaiveDate, NaiveTime};
 use self::chrono::naive::date;
 
-use backend::Pg;
 use expression::AsExpression;
 use expression::bound::Bound;
+use pg::Pg;
 use query_source::Queryable;
 use super::{PgDate, PgTime, PgTimestamp};
 use types::{self, Date, FromSql, IsNull, Time, Timestamp, ToSql};
@@ -108,8 +108,8 @@ mod tests {
     use self::dotenv::dotenv;
 
     use ::select;
-    use connection::PgConnection;
     use expression::dsl::{sql, now};
+    use pg::PgConnection;
     use prelude::*;
     use types::{Date, Time, Timestamp};
 
diff --git a/diesel/src/types/impls/date_and_time/mod.rs b/diesel/src/pg/types/date_and_time/mod.rs
similarity index 84%
rename from diesel/src/types/impls/date_and_time/mod.rs
rename to diesel/src/pg/types/date_and_time/mod.rs
index dd7c9089d..a14dcb834 100644
--- a/diesel/src/types/impls/date_and_time/mod.rs
+++ b/diesel/src/pg/types/date_and_time/mod.rs
@@ -2,11 +2,10 @@ use std::error::Error;
 use std::io::Write;
 use std::ops::Add;
 
-use backend::Pg;
 use expression::*;
 use expression::bound::Bound;
+use pg::{Pg, PgTypeMetadata};
 use query_source::Queryable;
-use super::option::UnexpectedNullError;
 use types::{self, FromSql, ToSql, IsNull};
 
 #[cfg(feature = "quickcheck")]
@@ -67,10 +66,43 @@ impl PgInterval {
     }
 }
 
-primitive_impls!(Date -> (PgDate, pg: (1082, 1182), sqlite: (Text)));
+queryable_impls!(Date -> PgDate,);
+queryable_impls!(Time -> PgTime,);
+queryable_impls!(Timestamp -> PgTimestamp,);
+expression_impls!(Date -> PgDate,);
+expression_impls!(Time -> PgTime,);
+expression_impls!(Timestamp -> PgTimestamp,);
+
 primitive_impls!(Interval -> (PgInterval, pg: (1186, 1187)));
-primitive_impls!(Time -> (PgTime, pg: (1083, 1183), sqlite: (Text)));
-primitive_impls!(Timestamp -> (PgTimestamp, pg: (1114, 1115), sqlite: (Text)));
+
+use types::HasSqlType;
+
+impl HasSqlType<types::Date> for Pg {
+    fn metadata() -> PgTypeMetadata {
+        PgTypeMetadata {
+            oid: 1082,
+            array_oid: 1182,
+        }
+    }
+}
+
+impl HasSqlType<types::Time> for Pg {
+    fn metadata() -> PgTypeMetadata {
+        PgTypeMetadata {
+            oid: 1083,
+            array_oid: 1183,
+        }
+    }
+}
+
+impl HasSqlType<types::Timestamp> for Pg {
+    fn metadata() -> PgTypeMetadata {
+        PgTypeMetadata {
+            oid: 1114,
+            array_oid: 1115,
+        }
+    }
+}
 
 impl ToSql<types::Timestamp, Pg> for PgTimestamp {
     fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
diff --git a/diesel/src/types/impls/date_and_time/quickcheck_impls.rs b/diesel/src/pg/types/date_and_time/quickcheck_impls.rs
similarity index 100%
rename from diesel/src/types/impls/date_and_time/quickcheck_impls.rs
rename to diesel/src/pg/types/date_and_time/quickcheck_impls.rs
diff --git a/diesel/src/types/impls/date_and_time/std_time.rs b/diesel/src/pg/types/date_and_time/std_time.rs
similarity index 98%
rename from diesel/src/types/impls/date_and_time/std_time.rs
rename to diesel/src/pg/types/date_and_time/std_time.rs
index a7841f773..c6357d312 100644
--- a/diesel/src/types/impls/date_and_time/std_time.rs
+++ b/diesel/src/pg/types/date_and_time/std_time.rs
@@ -2,11 +2,11 @@ use std::error::Error;
 use std::io::Write;
 use std::time::{Duration, SystemTime, UNIX_EPOCH};
 
-use backend::Pg;
-use expression::bound::Bound;
 use expression::AsExpression;
-use types::{self, ToSql, FromSql, IsNull};
+use expression::bound::Bound;
+use pg::Pg;
 use query_source::Queryable;
+use types::{self, ToSql, FromSql, IsNull};
 
 expression_impls! {
     Timestamp -> SystemTime,
@@ -75,8 +75,8 @@ mod tests {
     use std::time::{SystemTime, Duration, UNIX_EPOCH};
 
     use ::select;
-    use connection::PgConnection;
     use expression::dsl::{sql, now};
+    use pg::PgConnection;
     use prelude::*;
     use types::Timestamp;
 
diff --git a/diesel/src/types/impls/floats/mod.rs b/diesel/src/pg/types/floats/mod.rs
similarity index 72%
rename from diesel/src/types/impls/floats/mod.rs
rename to diesel/src/pg/types/floats/mod.rs
index 2831c0c64..f58dc3774 100644
--- a/diesel/src/types/impls/floats/mod.rs
+++ b/diesel/src/pg/types/floats/mod.rs
@@ -1,46 +1,15 @@
 extern crate byteorder;
 
+use self::byteorder::{ReadBytesExt, WriteBytesExt, BigEndian};
 use std::error::Error;
 use std::io::prelude::*;
 
-use backend::Backend;
-use self::byteorder::{ReadBytesExt, WriteBytesExt, BigEndian};
-use super::option::UnexpectedNullError;
-use types::{self, FromSql, ToSql, IsNull};
+use pg::Pg;
+use types::{self, IsNull, FromSql, ToSql};
 
 #[cfg(feature = "quickcheck")]
 mod quickcheck_impls;
 
-impl<DB: Backend<RawValue=[u8]>> FromSql<types::Float, DB> for f32 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
-        let mut bytes = not_none!(bytes);
-        bytes.read_f32::<BigEndian>().map_err(|e| Box::new(e) as Box<Error>)
-    }
-}
-
-impl<DB: Backend> ToSql<types::Float, DB> for f32 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
-        out.write_f32::<BigEndian>(*self)
-            .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
-    }
-}
-
-impl<DB: Backend<RawValue=[u8]>> FromSql<types::Double, DB> for f64 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
-        let mut bytes = not_none!(bytes);
-        bytes.read_f64::<BigEndian>().map_err(|e| Box::new(e) as Box<Error>)
-    }
-}
-
-impl<DB: Backend> ToSql<types::Double, DB> for f64 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
-        out.write_f64::<BigEndian>(*self)
-            .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
-    }
-}
-
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum PgNumeric {
     Positive {
@@ -71,8 +40,6 @@ impl Error for InvalidNumericSign {
     }
 }
 
-use backend::Pg;
-
 impl FromSql<types::Numeric, Pg> for PgNumeric {
     fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
         let mut bytes = not_none!(bytes);
diff --git a/diesel/src/types/impls/floats/quickcheck_impls.rs b/diesel/src/pg/types/floats/quickcheck_impls.rs
similarity index 100%
rename from diesel/src/types/impls/floats/quickcheck_impls.rs
rename to diesel/src/pg/types/floats/quickcheck_impls.rs
diff --git a/diesel/src/pg/types/integers.rs b/diesel/src/pg/types/integers.rs
new file mode 100644
index 000000000..703ecd019
--- /dev/null
+++ b/diesel/src/pg/types/integers.rs
@@ -0,0 +1,58 @@
+extern crate byteorder;
+
+use self::byteorder::{ReadBytesExt, WriteBytesExt, BigEndian};
+use std::error::Error;
+use std::io::prelude::*;
+
+use expression::AsExpression;
+use expression::bound::Bound;
+use pg::Pg;
+use query_source::Queryable;
+use types::{self, ToSql, IsNull, FromSql};
+
+primitive_impls!(Oid -> (u32, pg: (26, 1018)));
+
+impl FromSql<types::Oid, Pg> for u32 {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+        let mut bytes = not_none!(bytes);
+        bytes.read_u32::<BigEndian>().map_err(|e| e.into())
+    }
+}
+
+impl ToSql<types::Oid, Pg> for u32 {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+        out.write_u32::<BigEndian>(*self)
+            .map(|_| IsNull::No)
+            .map_err(|e| e.into())
+    }
+}
+
+#[test]
+fn i16_to_sql() {
+    let mut bytes = vec![];
+    ToSql::<types::SmallInt, Pg>::to_sql(&1i16, &mut bytes).unwrap();
+    ToSql::<types::SmallInt, Pg>::to_sql(&0i16, &mut bytes).unwrap();
+    ToSql::<types::SmallInt, Pg>::to_sql(&-1i16, &mut bytes).unwrap();
+    assert_eq!(bytes, vec![0, 1, 0, 0, 255, 255]);
+}
+
+#[test]
+fn i32_to_sql() {
+    let mut bytes = vec![];
+    ToSql::<types::Integer, Pg>::to_sql(&1i32, &mut bytes).unwrap();
+    ToSql::<types::Integer, Pg>::to_sql(&0i32, &mut bytes).unwrap();
+    ToSql::<types::Integer, Pg>::to_sql(&-1i32, &mut bytes).unwrap();
+    assert_eq!(bytes, vec![0, 0, 0, 1, 0, 0, 0, 0, 255, 255, 255, 255]);
+}
+
+#[test]
+fn i64_to_sql() {
+    let mut bytes = vec![];
+    ToSql::<types::BigInt, Pg>::to_sql(&1i64, &mut bytes).unwrap();
+    ToSql::<types::BigInt, Pg>::to_sql(&0i64, &mut bytes).unwrap();
+    ToSql::<types::BigInt, Pg>::to_sql(&-1i64, &mut bytes).unwrap();
+    assert_eq!(bytes, vec![
+               0, 0, 0, 0, 0, 0, 0, 1,
+               0, 0, 0, 0, 0, 0, 0, 0,
+               255, 255, 255, 255, 255, 255, 255, 255]);
+}
diff --git a/diesel/src/pg/types/mod.rs b/diesel/src/pg/types/mod.rs
new file mode 100644
index 000000000..83bef9610
--- /dev/null
+++ b/diesel/src/pg/types/mod.rs
@@ -0,0 +1,14 @@
+mod array;
+pub mod date_and_time;
+pub mod floats;
+mod integers;
+mod primitives;
+
+#[doc(hidden)]
+pub mod sql_types {
+    #[derive(Clone, Copy, Default)] pub struct Oid;
+    #[derive(Clone, Copy, Default)] pub struct Array<T>(T);
+    pub type SmallSerial = ::types::SmallInt;
+    pub type Serial = ::types::Integer;
+    pub type BigSerial = ::types::BigInt;
+}
diff --git a/diesel/src/pg/types/primitives.rs b/diesel/src/pg/types/primitives.rs
new file mode 100644
index 000000000..44f3dae98
--- /dev/null
+++ b/diesel/src/pg/types/primitives.rs
@@ -0,0 +1,47 @@
+use std::io::prelude::*;
+use std::error::Error;
+
+use expression::AsExpression;
+use expression::bound::Bound;
+use pg::Pg;
+use pg::data_types::PgNumeric;
+use query_source::Queryable;
+use types::{self, ToSql, IsNull, FromSql};
+
+primitive_impls!(Numeric -> (PgNumeric, pg: (1700, 1231)));
+
+impl FromSql<types::Bool, Pg> for bool {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+        match bytes {
+            Some(bytes) => Ok(bytes[0] != 0),
+            None => Ok(false),
+        }
+    }
+}
+
+impl ToSql<types::Bool, Pg> for bool {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+        let write_result = if *self {
+            out.write_all(&[1])
+        } else {
+            out.write_all(&[0])
+        };
+        write_result
+            .map(|_| IsNull::No)
+            .map_err(|e| Box::new(e) as Box<Error>)
+    }
+}
+
+#[test]
+fn bool_to_sql() {
+    let mut bytes = vec![];
+    ToSql::<types::Bool, Pg>::to_sql(&true, &mut bytes).unwrap();
+    ToSql::<types::Bool, Pg>::to_sql(&false, &mut bytes).unwrap();
+    assert_eq!(bytes, vec![1u8, 0u8]);
+}
+
+#[test]
+fn bool_from_sql_treats_null_as_false() {
+    let result = <bool as FromSql<types::Bool, Pg>>::from_sql(None).unwrap();
+    assert!(!result);
+}
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index 6f1d2f9b7..d1059e1dc 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -18,20 +18,24 @@ use super::delete_statement::DeleteStatement;
 /// #
 /// # table! {
 /// #     users {
-/// #         id -> Serial,
+/// #         id -> Integer,
 /// #         name -> VarChar,
 /// #     }
 /// # }
 /// #
+/// # #[cfg(feature = "postgres")]
 /// # fn main() {
 /// #     use self::users::dsl::*;
 /// #     let connection = establish_connection();
 /// let updated_row = diesel::update(users.filter(id.eq(1)))
 ///     .set(name.eq("James"))
 ///     .get_result(&connection);
-/// // When passed to `query_one`, the update statement will gain `RETURNING *`
+/// // On backends that support it, you can call `get_result` instead of `execute`
+/// // to have `RETURNING *` automatically appended to the query.
 /// assert_eq!(Ok((1, "James".to_string())), updated_row);
 /// # }
+/// # #[cfg(not(feature = "postgres"))]
+/// # fn main() {}
 /// ```
 pub fn update<T: UpdateTarget>(source: T) -> IncompleteUpdateStatement<T> {
     IncompleteUpdateStatement::new(source)
@@ -51,7 +55,7 @@ pub fn update<T: UpdateTarget>(source: T) -> IncompleteUpdateStatement<T> {
 /// #
 /// # table! {
 /// #     users {
-/// #         id -> Serial,
+/// #         id -> Integer,
 /// #         name -> VarChar,
 /// #     }
 /// # }
@@ -79,7 +83,7 @@ pub fn update<T: UpdateTarget>(source: T) -> IncompleteUpdateStatement<T> {
 /// #
 /// # table! {
 /// #     users {
-/// #         id -> Serial,
+/// #         id -> Integer,
 /// #         name -> VarChar,
 /// #     }
 /// # }
diff --git a/diesel/src/query_builder/mod.rs b/diesel/src/query_builder/mod.rs
index bcc0a886e..4c4efc121 100644
--- a/diesel/src/query_builder/mod.rs
+++ b/diesel/src/query_builder/mod.rs
@@ -1,9 +1,6 @@
 //! Contains traits responsible for the actual construction of SQL statements
 pub mod debug;
 
-#[doc(hidden)] pub mod pg;
-#[doc(hidden)] pub mod sqlite;
-
 mod delete_statement;
 #[doc(hidden)]
 pub mod functions;
diff --git a/diesel/src/query_builder/select_statement/mod.rs b/diesel/src/query_builder/select_statement/mod.rs
index 0cf8ea869..ff766b6be 100644
--- a/diesel/src/query_builder/select_statement/mod.rs
+++ b/diesel/src/query_builder/select_statement/mod.rs
@@ -9,7 +9,6 @@ use super::limit_clause::NoLimitClause;
 use super::offset_clause::NoOffsetClause;
 use super::order_clause::NoOrderClause;
 use super::where_clause::NoWhereClause;
-use types;
 
 #[derive(Debug, Clone, Copy)]
 #[doc(hidden)]
@@ -75,10 +74,18 @@ impl<ST, S, F, W, O, L, Of> Query for SelectStatement<ST, S, F, W, O, L, Of> whe
     type SqlType = ST;
 }
 
+#[cfg(feature = "postgres")]
 impl<ST, S, F, W, O, L, Of> Expression for SelectStatement<ST, S, F, W, O, L, Of> where
     S: SelectableExpression<F, ST>,
 {
-    type SqlType = types::Array<ST>;
+    type SqlType = ::types::Array<ST>;
+}
+
+#[cfg(not(feature = "postgres"))]
+impl<ST, S, F, W, O, L, Of> Expression for SelectStatement<ST, S, F, W, O, L, Of> where
+    S: SelectableExpression<F, ST>,
+{
+    type SqlType = ST;
 }
 
 impl<ST, S, F, W, O, L, Of, DB> QueryFragment<DB> for SelectStatement<ST, S, F, W, O, L, Of> where
diff --git a/diesel/src/query_dsl/count_dsl.rs b/diesel/src/query_dsl/count_dsl.rs
index 299adee88..3476668b9 100644
--- a/diesel/src/query_dsl/count_dsl.rs
+++ b/diesel/src/query_dsl/count_dsl.rs
@@ -12,7 +12,7 @@ use super::SelectDsl;
 /// #
 /// # table! {
 /// #     users {
-/// #         id -> Serial,
+/// #         id -> Integer,
 /// #         name -> VarChar,
 /// #     }
 /// # }
diff --git a/diesel/src/query_dsl/filter_dsl.rs b/diesel/src/query_dsl/filter_dsl.rs
index 32b825484..5625da932 100644
--- a/diesel/src/query_dsl/filter_dsl.rs
+++ b/diesel/src/query_dsl/filter_dsl.rs
@@ -16,7 +16,7 @@ use types::Bool;
 /// #
 /// # table! {
 /// #     users {
-/// #         id -> Serial,
+/// #         id -> Integer,
 /// #         name -> VarChar,
 /// #     }
 /// # }
@@ -72,7 +72,7 @@ use helper_types::FindBy;
 /// #
 /// # table! {
 /// #     users {
-/// #         id -> Serial,
+/// #         id -> Integer,
 /// #         name -> VarChar,
 /// #     }
 /// # }
diff --git a/diesel/src/row.rs b/diesel/src/row.rs
index 3b7910406..70e24d1c0 100644
--- a/diesel/src/row.rs
+++ b/diesel/src/row.rs
@@ -1,37 +1,6 @@
-use backend::{Backend, Pg};
-use db_result::PgResult;
+use backend::Backend;
 
 pub trait Row<DB: Backend> {
     fn take(&mut self) -> Option<&DB::RawValue>;
     fn next_is_null(&self, count: usize) -> bool;
 }
-
-pub struct PgRow<'a> {
-    db_result: &'a PgResult,
-    row_idx: usize,
-    col_idx: usize,
-}
-
-impl<'a> PgRow<'a> {
-    pub fn new(db_result: &'a PgResult, row_idx: usize) -> Self {
-        PgRow {
-            db_result: db_result,
-            row_idx: row_idx,
-            col_idx: 0,
-        }
-    }
-}
-
-impl<'a> Row<Pg> for PgRow<'a> {
-    fn take(&mut self) -> Option<&[u8]> {
-        let current_idx = self.col_idx;
-        self.col_idx += 1;
-        self.db_result.get(self.row_idx, current_idx)
-    }
-
-    fn next_is_null(&self, count: usize) -> bool {
-        (0..count).all(|i| {
-            self.db_result.is_null(self.row_idx, self.col_idx + i)
-        })
-    }
-}
diff --git a/diesel/src/sqlite/backend.rs b/diesel/src/sqlite/backend.rs
new file mode 100644
index 000000000..7dc3303c7
--- /dev/null
+++ b/diesel/src/sqlite/backend.rs
@@ -0,0 +1,24 @@
+use backend::*;
+use super::connection::SqliteValue;
+use super::query_builder::SqliteQueryBuilder;
+
+pub struct Sqlite;
+
+pub enum SqliteType {
+    Binary,
+    Text,
+    Float,
+    Double,
+    SmallInt,
+    Integer,
+    Long,
+}
+
+impl Backend for Sqlite {
+    type QueryBuilder = SqliteQueryBuilder;
+    type RawValue = SqliteValue;
+}
+
+impl TypeMetadata for Sqlite {
+    type TypeMetadata = SqliteType;
+}
diff --git a/diesel/src/connection/sqlite/mod.rs b/diesel/src/sqlite/connection/mod.rs
similarity index 97%
rename from diesel/src/connection/sqlite/mod.rs
rename to diesel/src/sqlite/connection/mod.rs
index 6247cb121..68553a2f2 100644
--- a/diesel/src/connection/sqlite/mod.rs
+++ b/diesel/src/sqlite/connection/mod.rs
@@ -12,16 +12,16 @@ pub use self::sqlite_value::SqliteValue;
 use std::cell::Cell;
 use std::ffi::CStr;
 
-use backend::Sqlite;
+use connection::{SimpleConnection, Connection};
 use query_builder::*;
-use query_builder::sqlite::SqliteQueryBuilder;
 use query_source::*;
 use result::*;
 use result::Error::QueryBuilderError;
 use self::raw::*;
-use self::stmt::*;
 use self::statement_iterator::StatementIterator;
-use super::{SimpleConnection, Connection};
+use self::stmt::*;
+use sqlite::Sqlite;
+use super::query_builder::SqliteQueryBuilder;
 use types::HasSqlType;
 
 pub struct SqliteConnection {
diff --git a/diesel/src/connection/sqlite/raw.rs b/diesel/src/sqlite/connection/raw.rs
similarity index 100%
rename from diesel/src/connection/sqlite/raw.rs
rename to diesel/src/sqlite/connection/raw.rs
diff --git a/diesel/src/connection/sqlite/sqlite_value.rs b/diesel/src/sqlite/connection/sqlite_value.rs
similarity index 99%
rename from diesel/src/connection/sqlite/sqlite_value.rs
rename to diesel/src/sqlite/connection/sqlite_value.rs
index 267e4cb43..5c915bdf3 100644
--- a/diesel/src/connection/sqlite/sqlite_value.rs
+++ b/diesel/src/sqlite/connection/sqlite_value.rs
@@ -3,7 +3,7 @@ extern crate libc;
 
 use std::{slice, str};
 
-use backend::Sqlite;
+use sqlite::Sqlite;
 use row::Row;
 
 pub struct SqliteValue {
diff --git a/diesel/src/connection/sqlite/statement_iterator.rs b/diesel/src/sqlite/connection/statement_iterator.rs
similarity index 97%
rename from diesel/src/connection/sqlite/statement_iterator.rs
rename to diesel/src/sqlite/connection/statement_iterator.rs
index 2bf108b1d..94469d3c5 100644
--- a/diesel/src/connection/sqlite/statement_iterator.rs
+++ b/diesel/src/sqlite/connection/statement_iterator.rs
@@ -1,6 +1,6 @@
 use std::marker::PhantomData;
 
-use backend::Sqlite;
+use sqlite::Sqlite;
 use super::stmt::Statement;
 use query_source::Queryable;
 use types::{HasSqlType, FromSqlRow};
diff --git a/diesel/src/connection/sqlite/stmt.rs b/diesel/src/sqlite/connection/stmt.rs
similarity index 99%
rename from diesel/src/connection/sqlite/stmt.rs
rename to diesel/src/sqlite/connection/stmt.rs
index 6e536520a..8d13e262c 100644
--- a/diesel/src/connection/sqlite/stmt.rs
+++ b/diesel/src/sqlite/connection/stmt.rs
@@ -7,7 +7,7 @@ use std::ffi::CString;
 use std::io::{stderr, Write};
 use std::ptr;
 
-use backend::SqliteType;
+use sqlite::SqliteType;
 use result::*;
 use result::Error::{DatabaseError, QueryBuilderError};
 use super::raw::RawConnection;
diff --git a/diesel/src/sqlite/mod.rs b/diesel/src/sqlite/mod.rs
new file mode 100644
index 000000000..ccc195892
--- /dev/null
+++ b/diesel/src/sqlite/mod.rs
@@ -0,0 +1,8 @@
+mod backend;
+mod connection;
+mod query_builder;
+mod types;
+
+pub use self::backend::{Sqlite, SqliteType};
+pub use self::connection::SqliteConnection;
+pub use self::query_builder::SqliteQueryBuilder;
diff --git a/diesel/src/query_builder/sqlite.rs b/diesel/src/sqlite/query_builder.rs
similarity index 89%
rename from diesel/src/query_builder/sqlite.rs
rename to diesel/src/sqlite/query_builder.rs
index ee6530ff6..148380ec9 100644
--- a/diesel/src/query_builder/sqlite.rs
+++ b/diesel/src/sqlite/query_builder.rs
@@ -1,8 +1,7 @@
-use backend::{Sqlite, SqliteType};
-use super::{QueryBuilder, BuildQueryResult};
+use super::backend::{Sqlite, SqliteType};
+use query_builder::{QueryBuilder, BuildQueryResult};
 use types::HasSqlType;
 
-#[doc(hidden)]
 pub struct SqliteQueryBuilder {
     pub sql: String,
     pub bind_params: Vec<(SqliteType, Option<Vec<u8>>)>,
diff --git a/diesel/src/sqlite/types/date_and_time.rs b/diesel/src/sqlite/types/date_and_time.rs
new file mode 100644
index 000000000..72dc64b5f
--- /dev/null
+++ b/diesel/src/sqlite/types/date_and_time.rs
@@ -0,0 +1,20 @@
+use sqlite::{Sqlite, SqliteType};
+use types;
+
+impl types::HasSqlType<types::Date> for Sqlite {
+    fn metadata() -> SqliteType {
+        SqliteType::Text
+    }
+}
+
+impl types::HasSqlType<types::Time> for Sqlite {
+    fn metadata() -> SqliteType {
+        SqliteType::Text
+    }
+}
+
+impl types::HasSqlType<types::Timestamp> for Sqlite {
+    fn metadata() -> SqliteType {
+        SqliteType::Text
+    }
+}
diff --git a/diesel/src/types/impls/sqlite.rs b/diesel/src/sqlite/types/mod.rs
similarity index 93%
rename from diesel/src/types/impls/sqlite.rs
rename to diesel/src/sqlite/types/mod.rs
index e06321735..67297032f 100644
--- a/diesel/src/types/impls/sqlite.rs
+++ b/diesel/src/sqlite/types/mod.rs
@@ -1,8 +1,9 @@
+mod date_and_time;
+
 use std::error::Error;
 
-use backend::Sqlite;
-use connection::sqlite::SqliteValue;
-use super::option::UnexpectedNullError;
+use super::Sqlite;
+use super::connection::SqliteValue;
 use types::{self, FromSql};
 
 impl FromSql<types::VarChar, Sqlite> for String {
diff --git a/diesel/src/types/impls/floats.rs b/diesel/src/types/impls/floats.rs
new file mode 100644
index 000000000..e22d4c580
--- /dev/null
+++ b/diesel/src/types/impls/floats.rs
@@ -0,0 +1,38 @@
+extern crate byteorder;
+
+use std::error::Error;
+use std::io::prelude::*;
+
+use backend::Backend;
+use self::byteorder::{ReadBytesExt, WriteBytesExt, BigEndian};
+use types::{self, FromSql, ToSql, IsNull};
+
+impl<DB: Backend<RawValue=[u8]>> FromSql<types::Float, DB> for f32 {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+        let mut bytes = not_none!(bytes);
+        bytes.read_f32::<BigEndian>().map_err(|e| Box::new(e) as Box<Error>)
+    }
+}
+
+impl<DB: Backend> ToSql<types::Float, DB> for f32 {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+        out.write_f32::<BigEndian>(*self)
+            .map(|_| IsNull::No)
+            .map_err(|e| Box::new(e) as Box<Error>)
+    }
+}
+
+impl<DB: Backend<RawValue=[u8]>> FromSql<types::Double, DB> for f64 {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+        let mut bytes = not_none!(bytes);
+        bytes.read_f64::<BigEndian>().map_err(|e| Box::new(e) as Box<Error>)
+    }
+}
+
+impl<DB: Backend> ToSql<types::Double, DB> for f64 {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+        out.write_f64::<BigEndian>(*self)
+            .map(|_| IsNull::No)
+            .map_err(|e| Box::new(e) as Box<Error>)
+    }
+}
diff --git a/diesel/src/types/impls/integers.rs b/diesel/src/types/impls/integers.rs
index 96c4f21c9..6ada12ede 100644
--- a/diesel/src/types/impls/integers.rs
+++ b/diesel/src/types/impls/integers.rs
@@ -2,10 +2,9 @@ extern crate byteorder;
 
 use std::error::Error;
 use std::io::prelude::*;
-
-use backend::{Backend, Pg};
 use self::byteorder::{ReadBytesExt, WriteBytesExt, BigEndian};
-use super::option::UnexpectedNullError;
+
+use backend::Backend;
 use types::{self, FromSql, ToSql, IsNull};
 
 impl<DB: Backend<RawValue=[u8]>> FromSql<types::SmallInt, DB> for i16 {
@@ -52,48 +51,3 @@ impl<DB: Backend> ToSql<types::BigInt, DB> for i64 {
             .map_err(|e| Box::new(e) as Box<Error>)
     }
 }
-
-impl FromSql<types::Oid, Pg> for u32 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
-        let mut bytes = not_none!(bytes);
-        bytes.read_u32::<BigEndian>().map_err(|e| e.into())
-    }
-}
-
-impl ToSql<types::Oid, Pg> for u32 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
-        out.write_u32::<BigEndian>(*self)
-            .map(|_| IsNull::No)
-            .map_err(|e| e.into())
-    }
-}
-
-#[test]
-fn i16_to_sql() {
-    let mut bytes = vec![];
-    ToSql::<types::SmallInt, Pg>::to_sql(&1i16, &mut bytes).unwrap();
-    ToSql::<types::SmallInt, Pg>::to_sql(&0i16, &mut bytes).unwrap();
-    ToSql::<types::SmallInt, Pg>::to_sql(&-1i16, &mut bytes).unwrap();
-    assert_eq!(bytes, vec![0, 1, 0, 0, 255, 255]);
-}
-
-#[test]
-fn i32_to_sql() {
-    let mut bytes = vec![];
-    ToSql::<types::Integer, Pg>::to_sql(&1i32, &mut bytes).unwrap();
-    ToSql::<types::Integer, Pg>::to_sql(&0i32, &mut bytes).unwrap();
-    ToSql::<types::Integer, Pg>::to_sql(&-1i32, &mut bytes).unwrap();
-    assert_eq!(bytes, vec![0, 0, 0, 1, 0, 0, 0, 0, 255, 255, 255, 255]);
-}
-
-#[test]
-fn i64_to_sql() {
-    let mut bytes = vec![];
-    ToSql::<types::BigInt, Pg>::to_sql(&1i64, &mut bytes).unwrap();
-    ToSql::<types::BigInt, Pg>::to_sql(&0i64, &mut bytes).unwrap();
-    ToSql::<types::BigInt, Pg>::to_sql(&-1i64, &mut bytes).unwrap();
-    assert_eq!(bytes, vec![
-               0, 0, 0, 0, 0, 0, 0, 1,
-               0, 0, 0, 0, 0, 0, 0, 0,
-               255, 255, 255, 255, 255, 255, 255, 255]);
-}
diff --git a/diesel/src/types/impls/mod.rs b/diesel/src/types/impls/mod.rs
index 7a20a3efd..ea438d079 100644
--- a/diesel/src/types/impls/mod.rs
+++ b/diesel/src/types/impls/mod.rs
@@ -2,7 +2,7 @@ macro_rules! not_none {
     ($bytes:expr) => {
         match $bytes {
             Some(bytes) => bytes,
-            None => return Err(Box::new(UnexpectedNullError {
+            None => return Err(Box::new($crate::types::impls::option::UnexpectedNullError {
                 msg: "Unexpected null for non-null column".to_string(),
             })),
         }
@@ -48,7 +48,7 @@ macro_rules! expression_impls {
                 DB: $crate::backend::Backend + types::HasSqlType<types::$Source>,
                 $Target: ToSql<types::$Source, DB>,
             {
-                fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+                fn to_sql<W: ::std::io::Write>(&self, out: &mut W) -> Result<IsNull, Box<::std::error::Error>> {
                     ToSql::<types::$Source, DB>::to_sql(self, out)
                 }
             }
@@ -63,7 +63,7 @@ macro_rules! queryable_impls {
             DB: $crate::backend::Backend + $crate::types::HasSqlType<types::$Source>,
             $Target: $crate::types::FromSql<types::$Source, DB>,
         {
-            fn build_from_row<R: $crate::row::Row<DB>>(row: &mut R) -> Result<Self, Box<Error>> {
+            fn build_from_row<R: $crate::row::Row<DB>>(row: &mut R) -> Result<Self, Box<::std::error::Error>> {
                 $crate::types::FromSql::<types::$Source, DB>::from_sql(row.take())
             }
         }
@@ -73,7 +73,7 @@ macro_rules! queryable_impls {
             DB: $crate::backend::Backend + $crate::types::HasSqlType<types::$Source>,
             Option<$Target>: $crate::types::FromSql<types::Nullable<types::$Source>, DB>,
         {
-            fn build_from_row<R: $crate::row::Row<DB>>(row: &mut R) -> Result<Self, Box<Error>> {
+            fn build_from_row<R: $crate::row::Row<DB>>(row: &mut R) -> Result<Self, Box<::std::error::Error>> {
                 $crate::types::FromSql::<types::Nullable<types::$Source>, DB>::from_sql(row.take())
             }
         }
@@ -93,9 +93,10 @@ macro_rules! queryable_impls {
 
 macro_rules! primitive_impls {
     ($Source:ident -> ($Target:ty, pg: ($oid:expr, $array_oid:expr), sqlite: ($tpe:ident))) => {
-        impl types::HasSqlType<types::$Source> for $crate::backend::Sqlite {
-            fn metadata() -> $crate::backend::SqliteType {
-                $crate::backend::SqliteType::$tpe
+        #[cfg(feature = "sqlite")]
+        impl types::HasSqlType<types::$Source> for $crate::sqlite::Sqlite {
+            fn metadata() -> $crate::sqlite::SqliteType {
+                $crate::sqlite::SqliteType::$tpe
             }
         }
 
@@ -103,32 +104,37 @@ macro_rules! primitive_impls {
     };
 
     ($Source:ident -> ($Target:ty, pg: ($oid:expr, $array_oid:expr))) => {
-        impl types::HasSqlType<types::$Source> for $crate::backend::Pg {
-            fn metadata() -> $crate::backend::PgTypeMetadata {
-                $crate::backend::PgTypeMetadata {
+        #[cfg(feature = "postgres")]
+        impl types::HasSqlType<types::$Source> for $crate::pg::Pg {
+            fn metadata() -> $crate::pg::PgTypeMetadata {
+                $crate::pg::PgTypeMetadata {
                     oid: $oid,
                     array_oid: $array_oid,
                 }
             }
         }
 
+        primitive_impls!($Source -> $Target);
+    };
+
+    ($Source:ident -> $Target:ty) => {
+        primitive_impls!($Source);
+        queryable_impls!($Source -> $Target,);
+        expression_impls!($Source -> $Target,);
+    };
+
+    ($Source:ident) => {
         impl types::HasSqlType<types::$Source> for $crate::backend::Debug {
             fn metadata() {}
         }
 
         impl types::NotNull for types::$Source {
         }
-
-        queryable_impls!($Source -> $Target,);
-        expression_impls!($Source -> $Target,);
     }
 }
 
-mod array;
-pub mod date_and_time;
 pub mod floats;
 mod integers;
-mod option;
+pub mod option;
 mod primitives;
-mod sqlite;
 mod tuples;
diff --git a/diesel/src/types/impls/option.rs b/diesel/src/types/impls/option.rs
index e4dccbb50..7bfedf035 100644
--- a/diesel/src/types/impls/option.rs
+++ b/diesel/src/types/impls/option.rs
@@ -92,12 +92,13 @@ impl Error for UnexpectedNullError {
     }
 }
 
-#[cfg(test)]
+#[cfg(all(test, feature = "postgres"))]
 use types;
-#[cfg(test)]
-use backend::Pg;
+#[cfg(all(test, feature = "postgres"))]
+use pg::Pg;
 
 #[test]
+#[cfg(feature = "postgres")]
 fn option_to_sql() {
     type Type = types::Nullable<types::VarChar>;
     let mut bytes = Vec::<u8>::new();
diff --git a/diesel/src/types/impls/primitives.rs b/diesel/src/types/impls/primitives.rs
index ccec98de2..b8a703669 100644
--- a/diesel/src/types/impls/primitives.rs
+++ b/diesel/src/types/impls/primitives.rs
@@ -1,11 +1,9 @@
 use std::error::Error;
 use std::io::Write;
 
-use backend::{Backend, Pg};
-use data_types::PgNumeric;
+use backend::Backend;
 use expression::bound::Bound;
 use expression::AsExpression;
-use super::option::UnexpectedNullError;
 use types::{HasSqlType, FromSql, ToSql, IsNull, NotNull};
 use {Queryable, types};
 
@@ -15,17 +13,18 @@ primitive_impls!(SmallInt -> (i16, pg: (21, 1005), sqlite: (SmallInt)));
 primitive_impls!(Integer -> (i32, pg: (23, 1007), sqlite: (Integer)));
 primitive_impls!(BigInt -> (i64, pg: (20, 1016), sqlite: (Long)));
 
-primitive_impls!(Oid -> (u32, pg: (26, 1018)));
-
 primitive_impls!(Float -> (f32, pg: (700, 1021), sqlite: (Float)));
 primitive_impls!(Double -> (f64, pg: (701, 1022), sqlite: (Double)));
-primitive_impls!(Numeric -> (PgNumeric, pg: (1700, 1231), sqlite: (Text)));
 
 primitive_impls!(VarChar -> (String, pg: (1043, 1015), sqlite: (Text)));
 primitive_impls!(Text -> (String, pg: (25, 1009), sqlite: (Text)));
 
 primitive_impls!(Binary -> (Vec<u8>, pg: (17, 1001), sqlite: (Binary)));
 
+primitive_impls!(Date);
+primitive_impls!(Time);
+primitive_impls!(Timestamp);
+
 expression_impls! {
     VarChar -> &'a str,
     Text -> &'a str,
@@ -35,28 +34,6 @@ expression_impls! {
 
 impl NotNull for () {}
 
-impl FromSql<types::Bool, Pg> for bool {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
-        match bytes {
-            Some(bytes) => Ok(bytes[0] != 0),
-            None => Ok(false),
-        }
-    }
-}
-
-impl ToSql<types::Bool, Pg> for bool {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
-        let write_result = if *self {
-            out.write_all(&[1])
-        } else {
-            out.write_all(&[0])
-        };
-        write_result
-            .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
-    }
-}
-
 impl<DB: Backend<RawValue=[u8]>> FromSql<types::VarChar, DB> for String {
     fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
         let bytes = not_none!(bytes);
@@ -164,17 +141,3 @@ impl <'a, T: ?Sized, ST, DB> ::types::FromSqlRow<ST, DB> for Cow<'a, T> where
         FromSql::<ST, DB>::from_sql(row.take())
     }
 }
-
-#[test]
-fn bool_to_sql() {
-    let mut bytes = vec![];
-    ToSql::<types::Bool, Pg>::to_sql(&true, &mut bytes).unwrap();
-    ToSql::<types::Bool, Pg>::to_sql(&false, &mut bytes).unwrap();
-    assert_eq!(bytes, vec![1u8, 0u8]);
-}
-
-#[test]
-fn bool_from_sql_treats_null_as_false() {
-    let result = <bool as FromSql<types::Bool, Pg>>::from_sql(None).unwrap();
-    assert!(!result);
-}
diff --git a/diesel/src/types/impls/tuples.rs b/diesel/src/types/impls/tuples.rs
index f4b9131d7..869409ec1 100644
--- a/diesel/src/types/impls/tuples.rs
+++ b/diesel/src/types/impls/tuples.rs
@@ -1,8 +1,7 @@
-use backend::{Backend, Sqlite, SupportsDefaultKeyword};
+use backend::{Backend, SupportsDefaultKeyword};
 use expression::{Expression, SelectableExpression, NonAggregate};
 use persistable::{ColumnInsertValue, InsertValues};
 use query_builder::{Changeset, AsChangeset, QueryBuilder, BuildQueryResult, QueryFragment};
-use query_builder::sqlite::SqliteQueryBuilder;
 use query_source::{QuerySource, Queryable, Table, Column};
 use row::Row;
 use std::error::Error;
@@ -126,14 +125,15 @@ macro_rules! tuple_impls {
                 }
             }
 
-            impl<$($T,)+ $($ST,)+ Tab> InsertValues<Sqlite>
+            #[cfg(feature = "sqlite")]
+            impl<$($T,)+ $($ST,)+ Tab> InsertValues<::sqlite::Sqlite>
                 for ($(ColumnInsertValue<$T, $ST>,)+) where
                     Tab: Table,
                     $($T: Column<Table=Tab>,)+
-                    $($ST: Expression<SqlType=$T::SqlType> + QueryFragment<Sqlite>,)+
+                    $($ST: Expression<SqlType=$T::SqlType> + QueryFragment<::sqlite::Sqlite>,)+
             {
                 #[allow(unused_assignments)]
-                fn column_names(&self, out: &mut SqliteQueryBuilder) -> BuildQueryResult {
+                fn column_names(&self, out: &mut ::sqlite::SqliteQueryBuilder) -> BuildQueryResult {
                     let mut columns_present = false;
                     $(
                         match e!(&self.$idx) {
@@ -151,7 +151,7 @@ macro_rules! tuple_impls {
                 }
 
                 #[allow(unused_assignments)]
-                fn values_clause(&self, out: &mut SqliteQueryBuilder) -> BuildQueryResult {
+                fn values_clause(&self, out: &mut ::sqlite::SqliteQueryBuilder) -> BuildQueryResult {
                     out.push_sql("(");
                     let mut columns_present = false;
                     $(
diff --git a/diesel/src/types/mod.rs b/diesel/src/types/mod.rs
index e965d2435..60d7d8386 100644
--- a/diesel/src/types/mod.rs
+++ b/diesel/src/types/mod.rs
@@ -2,7 +2,9 @@
 //! them and Rust primitives. Additional types can be added by other crates.
 pub mod ops;
 mod ord;
-mod impls;
+#[macro_use]
+#[doc(hidden)]
+pub mod impls;
 mod fold;
 
 #[doc(hidden)]
@@ -10,9 +12,11 @@ pub mod structs {
     pub mod data_types {
         //! Structs to represent the primitive equivalent of SQL types where
         //! there is no existing Rust primitive, or where using it would be
-        //! confusing (such as date and time types)
-        pub use super::super::impls::date_and_time::{PgTimestamp, PgDate, PgTime, PgInterval};
-        pub use super::super::impls::floats::PgNumeric;
+        //! confusing (such as date and time types). This module will re-export
+        //! all backend specific data structures when compiled against that
+        //! backend.
+        #[cfg(feature = "postgres")]
+        pub use pg::data_types::*;
     }
 }
 
@@ -29,10 +33,6 @@ use std::io::Write;
 
 #[derive(Clone, Copy, Default)] pub struct Bool;
 
-pub type SmallSerial = SmallInt;
-pub type Serial = Integer;
-pub type BigSerial = BigInt;
-
 #[derive(Clone, Copy, Default)] pub struct SmallInt;
 #[doc(hidden)] pub type Int2 = SmallInt;
 #[derive(Clone, Copy, Default)] pub struct Integer;
@@ -46,8 +46,6 @@ pub type BigSerial = BigInt;
 #[doc(hidden)] pub type Float8 = Double;
 #[derive(Clone, Copy, Default)] pub struct Numeric;
 
-#[derive(Clone, Copy, Default)] pub struct Oid;
-
 #[derive(Clone, Copy, Default)] pub struct VarChar;
 #[doc(hidden)] pub type Varchar = VarChar;
 #[derive(Clone, Copy, Default)] pub struct Text;
@@ -60,7 +58,10 @@ pub type BigSerial = BigInt;
 #[derive(Clone, Copy, Default)] pub struct Timestamp;
 
 #[derive(Clone, Copy, Default)] pub struct Nullable<T: NotNull>(T);
-#[derive(Clone, Copy, Default)] pub struct Array<T>(T);
+
+#[cfg(feature = "postgres")]
+#[doc(inline)]
+pub use pg::types::sql_types::*;
 
 pub trait HasSqlType<ST>: TypeMetadata {
     fn metadata() -> Self::TypeMetadata;
diff --git a/diesel_cli/src/main.rs b/diesel_cli/src/main.rs
index eda5d60c0..0283b35d1 100644
--- a/diesel_cli/src/main.rs
+++ b/diesel_cli/src/main.rs
@@ -9,8 +9,7 @@ mod database_error;
 use chrono::*;
 use clap::{App, AppSettings, Arg, ArgMatches, SubCommand};
 use diesel::{migrations, Connection};
-use diesel::connection::PgConnection;
-use diesel::types::{FromSql, VarChar};
+use diesel::pg::PgConnection;
 use std::{env, fs};
 use std::io::stdout;
 use std::error::Error;
@@ -318,14 +317,20 @@ where I: Iterator<Item = A> + Clone,
 
 #[cfg(test)]
 mod tests {
+<<<<<<< baf952efb64a879e3388a1ae0cb4e76ea534dc80
     extern crate diesel;
     extern crate tempdir;
 
     use dotenv::dotenv;
 
+=======
+    extern crate dotenv;
+    extern crate tempdir;
+
+    use diesel::Connection;
+    use diesel::pg::PgConnection;
+>>>>>>> Remove hard dependencies on `libpq` and `libsqlite3`
     use self::tempdir::TempDir;
-    use self::diesel::Connection;
-    use self::diesel::connection::PgConnection;
 
     use database_error::DatabaseError;
 
diff --git a/diesel_codegen/src/schema_inference/data_structures.rs b/diesel_codegen/src/schema_inference/data_structures.rs
index 944f9765f..f7b036943 100644
--- a/diesel_codegen/src/schema_inference/data_structures.rs
+++ b/diesel_codegen/src/schema_inference/data_structures.rs
@@ -1,5 +1,5 @@
 use diesel::*;
-use diesel::backend::Pg;
+use diesel::pg::Pg;
 use diesel::types::{HasSqlType, FromSqlRow};
 
 table! {
diff --git a/diesel_codegen/src/schema_inference/mod.rs b/diesel_codegen/src/schema_inference/mod.rs
index d79884d6d..9a9f524c0 100644
--- a/diesel_codegen/src/schema_inference/mod.rs
+++ b/diesel_codegen/src/schema_inference/mod.rs
@@ -1,7 +1,7 @@
 mod data_structures;
 
 use diesel::*;
-use diesel::connection::PgConnection;
+use diesel::pg::PgConnection;
 use syntax::ast;
 use syntax::codemap::Span;
 use syntax::ext::base::*;
diff --git a/diesel_tests/Cargo.toml b/diesel_tests/Cargo.toml
index 0ad1b7f15..58e622906 100644
--- a/diesel_tests/Cargo.toml
+++ b/diesel_tests/Cargo.toml
@@ -13,7 +13,7 @@ diesel = { path = "../diesel" }
 dotenv = { git = "https://github.com/slapresta/rust-dotenv.git" }
 
 [dependencies]
-diesel = { path = "../diesel", features = ["quickcheck", "chrono"] }
+diesel = { path = "../diesel", default-features = false, features = ["quickcheck", "chrono"] }
 diesel_codegen = { path = "../diesel_codegen", default-features = false }
 compiletest_rs = { version = "^0.0.11", optional = true }
 dotenv_macros = { git = "https://github.com/slapresta/rust-dotenv.git", optional = true }
@@ -26,8 +26,8 @@ quickcheck = { git = "https://github.com/BurntSushi/quickcheck.git" }
 default = ["syntex", "diesel_codegen/with-syntex", "dotenv_codegen"]
 unstable = ["compiletest_rs", "diesel_codegen/nightly", "diesel/unstable",
   "quickcheck/unstable", "dotenv_macros"]
-postgres = []
-sqlite = []
+postgres = ["diesel/postgres"]
+sqlite = ["diesel/sqlite"]
 
 [[test]]
 name = "compile_tests"
diff --git a/diesel_tests/build.rs b/diesel_tests/build.rs
index 85d1f5642..62066c54f 100644
--- a/diesel_tests/build.rs
+++ b/diesel_tests/build.rs
@@ -28,7 +28,7 @@ mod inner {
 extern crate diesel;
 extern crate dotenv;
 use diesel::*;
-use diesel::connection::PgConnection;
+use diesel::pg::PgConnection;
 use dotenv::dotenv;
 use std::io;
 
diff --git a/diesel_tests/tests/compile-fail/folding_functions_require_fold.rs b/diesel_tests/tests/compile-fail/folding_functions_require_fold.rs
deleted file mode 100644
index d2ec103ef..000000000
--- a/diesel_tests/tests/compile-fail/folding_functions_require_fold.rs
+++ /dev/null
@@ -1,26 +0,0 @@
-#[macro_use]
-extern crate diesel;
-
-use diesel::*;
-use diesel::expression::{sum, avg};
-
-table! {
-    time_key {
-        id -> Time,
-    }
-}
-
-table! {
-    string_primary_key {
-        id -> VarChar,
-    }
-}
-
-fn main() {
-    time_key::table.select(sum(time_key::id));
-    //~^ ERROR E0277
-    //~| ERROR E0277
-    string_primary_key::table.select(avg(string_primary_key::id));
-    //~^ ERROR E0277
-    //~| ERROR E0277
-}
diff --git a/diesel_tests/tests/compile-fail/any_is_only_selectable_if_inner_expr_is_selectable.rs b/diesel_tests/tests/compile-fail/global/any_is_only_selectable_if_inner_expr_is_selectable.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/any_is_only_selectable_if_inner_expr_is_selectable.rs
rename to diesel_tests/tests/compile-fail/global/any_is_only_selectable_if_inner_expr_is_selectable.rs
diff --git a/diesel_tests/tests/compile-fail/cannot_mix_aggregate_and_non_aggregate_selects.rs b/diesel_tests/tests/compile-fail/global/cannot_mix_aggregate_and_non_aggregate_selects.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/cannot_mix_aggregate_and_non_aggregate_selects.rs
rename to diesel_tests/tests/compile-fail/global/cannot_mix_aggregate_and_non_aggregate_selects.rs
diff --git a/diesel_tests/tests/compile-fail/cannot_pass_aggregate_to_where.rs b/diesel_tests/tests/compile-fail/global/cannot_pass_aggregate_to_where.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/cannot_pass_aggregate_to_where.rs
rename to diesel_tests/tests/compile-fail/global/cannot_pass_aggregate_to_where.rs
diff --git a/diesel_tests/tests/compile-fail/codegen_does_not_add_save_changes_method_on_structs_without_primary_key.rs b/diesel_tests/tests/compile-fail/global/codegen_does_not_add_save_changes_method_on_structs_without_primary_key.rs
similarity index 94%
rename from diesel_tests/tests/compile-fail/codegen_does_not_add_save_changes_method_on_structs_without_primary_key.rs
rename to diesel_tests/tests/compile-fail/global/codegen_does_not_add_save_changes_method_on_structs_without_primary_key.rs
index 19813b025..d0178d30c 100644
--- a/diesel_tests/tests/compile-fail/codegen_does_not_add_save_changes_method_on_structs_without_primary_key.rs
+++ b/diesel_tests/tests/compile-fail/global/codegen_does_not_add_save_changes_method_on_structs_without_primary_key.rs
@@ -4,7 +4,7 @@
 extern crate diesel;
 
 use diesel::*;
-use diesel::connection::PgConnection;
+use diesel::pg::PgConnection;
 
 table! {
     users {
diff --git a/diesel_tests/tests/compile-fail/expressions_can_only_be_compared_for_equality_to_expressions_of_same_type.rs b/diesel_tests/tests/compile-fail/global/expressions_can_only_be_compared_for_equality_to_expressions_of_same_type.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/expressions_can_only_be_compared_for_equality_to_expressions_of_same_type.rs
rename to diesel_tests/tests/compile-fail/global/expressions_can_only_be_compared_for_equality_to_expressions_of_same_type.rs
diff --git a/diesel_tests/tests/compile-fail/filter_cannot_take_comparison_for_columns_from_another_table.rs b/diesel_tests/tests/compile-fail/global/filter_cannot_take_comparison_for_columns_from_another_table.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/filter_cannot_take_comparison_for_columns_from_another_table.rs
rename to diesel_tests/tests/compile-fail/global/filter_cannot_take_comparison_for_columns_from_another_table.rs
diff --git a/diesel_tests/tests/compile-fail/find_requires_correct_type.rs b/diesel_tests/tests/compile-fail/global/find_requires_correct_type.rs
similarity index 96%
rename from diesel_tests/tests/compile-fail/find_requires_correct_type.rs
rename to diesel_tests/tests/compile-fail/global/find_requires_correct_type.rs
index 041ddf7a1..8f17f7af1 100644
--- a/diesel_tests/tests/compile-fail/find_requires_correct_type.rs
+++ b/diesel_tests/tests/compile-fail/global/find_requires_correct_type.rs
@@ -2,7 +2,7 @@
 extern crate diesel;
 
 use diesel::*;
-use diesel::connection::PgConnection;
+use diesel::pg::PgConnection;
 
 table! {
     int_primary_key {
diff --git a/diesel_tests/tests/compile-fail/numeric_ops_require_numeric_column.rs b/diesel_tests/tests/compile-fail/global/numeric_ops_require_numeric_column.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/numeric_ops_require_numeric_column.rs
rename to diesel_tests/tests/compile-fail/global/numeric_ops_require_numeric_column.rs
diff --git a/diesel_tests/tests/compile-fail/order_requires_column_from_same_table.rs b/diesel_tests/tests/compile-fail/global/order_requires_column_from_same_table.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/order_requires_column_from_same_table.rs
rename to diesel_tests/tests/compile-fail/global/order_requires_column_from_same_table.rs
diff --git a/diesel_tests/tests/compile-fail/ordering_functions_require_ord.rs b/diesel_tests/tests/compile-fail/global/ordering_functions_require_ord.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/ordering_functions_require_ord.rs
rename to diesel_tests/tests/compile-fail/global/ordering_functions_require_ord.rs
diff --git a/diesel_tests/tests/compile-fail/select_requires_column_from_same_table.rs b/diesel_tests/tests/compile-fail/global/select_requires_column_from_same_table.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/select_requires_column_from_same_table.rs
rename to diesel_tests/tests/compile-fail/global/select_requires_column_from_same_table.rs
diff --git a/diesel_tests/tests/compile-fail/select_sql_still_ensures_result_type.rs b/diesel_tests/tests/compile-fail/global/select_sql_still_ensures_result_type.rs
similarity index 90%
rename from diesel_tests/tests/compile-fail/select_sql_still_ensures_result_type.rs
rename to diesel_tests/tests/compile-fail/global/select_sql_still_ensures_result_type.rs
index ec3ba95b1..6b76933c3 100644
--- a/diesel_tests/tests/compile-fail/select_sql_still_ensures_result_type.rs
+++ b/diesel_tests/tests/compile-fail/global/select_sql_still_ensures_result_type.rs
@@ -2,7 +2,7 @@
 extern crate diesel;
 
 use diesel::*;
-use diesel::connection::PgConnection;
+use diesel::pg::PgConnection;
 
 table! {
     users {
diff --git a/diesel_tests/tests/compile-fail/selecting_multiple_columns_requires_all_must_be_from_selectable_table.rs b/diesel_tests/tests/compile-fail/global/selecting_multiple_columns_requires_all_must_be_from_selectable_table.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/selecting_multiple_columns_requires_all_must_be_from_selectable_table.rs
rename to diesel_tests/tests/compile-fail/global/selecting_multiple_columns_requires_all_must_be_from_selectable_table.rs
diff --git a/diesel_tests/tests/compile-fail/update_requires_column_be_from_same_table.rs b/diesel_tests/tests/compile-fail/global/update_requires_column_be_from_same_table.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/update_requires_column_be_from_same_table.rs
rename to diesel_tests/tests/compile-fail/global/update_requires_column_be_from_same_table.rs
diff --git a/diesel_tests/tests/compile-fail/update_requires_left_side_of_eq_to_be_a_column.rs b/diesel_tests/tests/compile-fail/global/update_requires_left_side_of_eq_to_be_a_column.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/update_requires_left_side_of_eq_to_be_a_column.rs
rename to diesel_tests/tests/compile-fail/global/update_requires_left_side_of_eq_to_be_a_column.rs
diff --git a/diesel_tests/tests/compile-fail/user_defined_functions_follow_same_selection_rules.rs b/diesel_tests/tests/compile-fail/global/user_defined_functions_follow_same_selection_rules.rs
similarity index 100%
rename from diesel_tests/tests/compile-fail/user_defined_functions_follow_same_selection_rules.rs
rename to diesel_tests/tests/compile-fail/global/user_defined_functions_follow_same_selection_rules.rs
diff --git a/diesel_tests/tests/compile-fail/select_carries_correct_result_type_info.rs b/diesel_tests/tests/compile-fail/postgres/select_carries_correct_result_type_info.rs
similarity index 78%
rename from diesel_tests/tests/compile-fail/select_carries_correct_result_type_info.rs
rename to diesel_tests/tests/compile-fail/postgres/select_carries_correct_result_type_info.rs
index 0da2e14e9..7babd72ea 100644
--- a/diesel_tests/tests/compile-fail/select_carries_correct_result_type_info.rs
+++ b/diesel_tests/tests/compile-fail/postgres/select_carries_correct_result_type_info.rs
@@ -2,7 +2,7 @@
 extern crate diesel;
 
 use diesel::*;
-use diesel::connection::PgConnection;
+use diesel::pg::PgConnection;
 
 table! {
     users {
@@ -19,7 +19,7 @@ fn main() {
     let select_name = users.select(name);
 
     let ids: QueryResult<Vec<i32>> = select_name.load(&connection).map(Iterator::collect);
-    //~^ ERROR the trait `diesel::query_source::Queryable<diesel::types::VarChar, diesel::backend::Pg>` is not implemented for the type `i32`
+    //~^ ERROR the trait `diesel::query_source::Queryable<diesel::types::VarChar, diesel::pg::backend::Pg>` is not implemented for the type `i32`
     let names: QueryResult<Vec<String>> = select_id.load(&connection).map(Iterator::collect);
-    //~^ ERROR the trait `diesel::query_source::Queryable<diesel::types::Integer, diesel::backend::Pg>` is not implemented
+    //~^ ERROR the trait `diesel::query_source::Queryable<diesel::types::Integer, diesel::pg::backend::Pg>` is not implemented
 }
diff --git a/diesel_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs b/diesel_tests/tests/compile-fail/sqlite/batch_insert_is_not_supported_on_sqlite.rs
similarity index 89%
rename from diesel_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs
rename to diesel_tests/tests/compile-fail/sqlite/batch_insert_is_not_supported_on_sqlite.rs
index 2976ff07e..7462fd689 100644
--- a/diesel_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs
+++ b/diesel_tests/tests/compile-fail/sqlite/batch_insert_is_not_supported_on_sqlite.rs
@@ -2,7 +2,7 @@
 extern crate diesel;
 
 use diesel::*;
-use diesel::connection::SqliteConnection;
+use diesel::sqlite::*;
 use diesel::types::{Integer, VarChar};
 
 table! {
@@ -14,10 +14,8 @@ table! {
 
 pub struct NewUser(String);
 
-use diesel::backend::Sqlite;
 use diesel::persistable::InsertValues;
 use diesel::query_builder::BuildQueryResult;
-use diesel::query_builder::sqlite::SqliteQueryBuilder;
 
 // It doesn't actually matter if this would work. We're testing that insert fails
 // to compile here.
diff --git a/diesel_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs b/diesel_tests/tests/compile-fail/sqlite/insert_statement_does_not_support_returning_methods_on_sqlite.rs
similarity index 91%
rename from diesel_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs
rename to diesel_tests/tests/compile-fail/sqlite/insert_statement_does_not_support_returning_methods_on_sqlite.rs
index 2bc6ff938..f24f9a796 100644
--- a/diesel_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs
+++ b/diesel_tests/tests/compile-fail/sqlite/insert_statement_does_not_support_returning_methods_on_sqlite.rs
@@ -2,8 +2,8 @@
 extern crate diesel;
 
 use diesel::*;
+use diesel::sqlite::*;
 use diesel::backend::Backend;
-use diesel::connection::SqliteConnection;
 use diesel::types::{Integer, VarChar};
 
 table! {
@@ -35,10 +35,8 @@ impl<DB: Backend> Queryable<(Integer, VarChar), DB> for User where
 
 pub struct NewUser(String);
 
-use diesel::backend::Sqlite;
 use diesel::persistable::InsertValues;
 use diesel::query_builder::BuildQueryResult;
-use diesel::query_builder::sqlite::SqliteQueryBuilder;
 
 // It doesn't actually matter if this would work. We're testing that insert fails
 // to compile here.
diff --git a/diesel_tests/tests/compile_tests.rs b/diesel_tests/tests/compile_tests.rs
index d9a550781..2f36f5125 100644
--- a/diesel_tests/tests/compile_tests.rs
+++ b/diesel_tests/tests/compile_tests.rs
@@ -7,7 +7,7 @@ use std::env::var;
 fn run_mode(mode: &'static str) {
     let mut config = compiletest::default_config();
 
-    let cfg_mode = mode.parse().expect("Invalid mode");
+    let cfg_mode = "compile-fail".parse().expect("Invalid mode");
 
     config.target_rustcflags = Some("-L target/debug/ -L target/debug/deps/".to_owned());
     if let Ok(name) = var::<&str>("TESTNAME") {
@@ -15,12 +15,18 @@ fn run_mode(mode: &'static str) {
         config.filter = Some(s)
     }
     config.mode = cfg_mode;
-    config.src_base = PathBuf::from(format!("tests/{}", mode));
+    config.src_base = PathBuf::from(format!("tests/compile-fail/{}", mode));
 
     compiletest::run_tests(&config);
 }
 
 #[test]
 fn compile_test() {
-    run_mode("compile-fail");
+    run_mode("global");
+    if cfg!(feature = "postgres") {
+        run_mode("postgres")
+    }
+    if cfg!(feature = "sqlite") {
+        run_mode("sqlite")
+    }
 }
diff --git a/diesel_tests/tests/expressions/date_and_time.rs b/diesel_tests/tests/expressions/date_and_time.rs
index 3ada7325e..35491bfea 100644
--- a/diesel_tests/tests/expressions/date_and_time.rs
+++ b/diesel_tests/tests/expressions/date_and_time.rs
@@ -1,6 +1,6 @@
 use schema::connection;
 use diesel::*;
-use diesel::connection::PgConnection;
+use diesel::pg::PgConnection;
 use diesel::data_types::*;
 use diesel::expression::dsl::*;
 
diff --git a/diesel_tests/tests/filter.rs b/diesel_tests/tests/filter.rs
index e75fabc51..01abb5d18 100644
--- a/diesel_tests/tests/filter.rs
+++ b/diesel_tests/tests/filter.rs
@@ -1,6 +1,5 @@
 use schema::*;
 use diesel::*;
-use diesel::backend::Pg;
 
 #[test]
 fn filter_by_int_equality() {
@@ -272,7 +271,7 @@ sql_function!(lower, lower_t, (x: VarChar) -> VarChar);
 #[test]
 #[cfg(feature = "postgres")] // FIXME: There are valuable tests for SQLite here
 fn filter_by_boxed_predicate() {
-    fn by_name(name: &str) -> Box<BoxableExpression<users::table, types::Bool, Pg, SqlType=types::Bool>> {
+    fn by_name(name: &str) -> Box<BoxableExpression<users::table, types::Bool, pg::Pg, SqlType=types::Bool>> {
         Box::new(lower(users::name).eq(name.to_string()))
     }
 
diff --git a/diesel_tests/tests/schema.rs b/diesel_tests/tests/schema.rs
index 2d26e470f..89b455fbe 100644
--- a/diesel_tests/tests/schema.rs
+++ b/diesel_tests/tests/schema.rs
@@ -96,9 +96,9 @@ pub struct NewComment<'a>(
 );
 
 #[cfg(feature = "postgres")]
-pub type TestConnection = ::diesel::connection::PgConnection;
+pub type TestConnection = ::diesel::pg::PgConnection;
 #[cfg(feature = "sqlite")]
-pub type TestConnection = ::diesel::connection::SqliteConnection;
+pub type TestConnection = ::diesel::sqlite::SqliteConnection;
 
 pub type TestBackend = <TestConnection as Connection>::Backend;
 
@@ -112,14 +112,14 @@ pub fn connection() -> TestConnection {
 pub fn connection_without_transaction() -> TestConnection {
     let connection_url = dotenv!("DATABASE_URL",
         "DATABASE_URL must be set in order to run tests");
-    ::diesel::connection::PgConnection::establish(&connection_url).unwrap()
+    ::diesel::pg::PgConnection::establish(&connection_url).unwrap()
 }
 
 #[cfg(feature = "sqlite")]
 pub fn connection_without_transaction() -> TestConnection {
     use std::io;
 
-    let connection = ::diesel::connection::SqliteConnection::establish(":memory:").unwrap();
+    let connection = ::diesel::sqlite::SqliteConnection::establish(":memory:").unwrap();
     let migrations_dir = migrations::find_migrations_directory().unwrap().join("sqlite");
     migrations::run_pending_migrations_in_directory(&connection, &migrations_dir, &mut io::sink()).unwrap();
     connection
diff --git a/diesel_tests/tests/schema_dsl/structures.rs b/diesel_tests/tests/schema_dsl/structures.rs
index 7f9d36724..9a70d3576 100644
--- a/diesel_tests/tests/schema_dsl/structures.rs
+++ b/diesel_tests/tests/schema_dsl/structures.rs
@@ -65,6 +65,10 @@ pub struct Default<'a, Col> {
 use diesel::backend::*;
 use diesel::query_builder::*;
 use diesel::types::Integer;
+#[cfg(feature = "postgres")]
+use diesel::pg::Pg;
+#[cfg(feature = "sqlite")]
+use diesel::sqlite::Sqlite;
 
 impl<'a, DB, Cols> QueryFragment<DB> for CreateTable<'a, Cols> where
     DB: Backend,
@@ -102,6 +106,7 @@ impl<DB, Col> QueryFragment<DB> for PrimaryKey<Col> where
     }
 }
 
+#[cfg(feature = "sqlite")]
 impl<Col> QueryFragment<Sqlite> for AutoIncrement<Col> where
     Col: QueryFragment<Sqlite>,
 {
@@ -112,6 +117,7 @@ impl<Col> QueryFragment<Sqlite> for AutoIncrement<Col> where
     }
 }
 
+#[cfg(feature = "postgres")]
 impl<'a> QueryFragment<Pg> for AutoIncrement<PrimaryKey<Column<'a, Integer>>> {
     fn to_sql(&self, out: &mut <Pg as Backend>::QueryBuilder) -> BuildQueryResult {
         try!(out.push_identifier((self.0).0.name));
diff --git a/diesel_tests/tests/types.rs b/diesel_tests/tests/types.rs
index 3542178e9..538acc18d 100644
--- a/diesel_tests/tests/types.rs
+++ b/diesel_tests/tests/types.rs
@@ -2,7 +2,8 @@
 
 use schema::{connection, TestBackend};
 use diesel::*;
-use diesel::backend::Pg;
+#[cfg(feature="postgres")]
+use diesel::pg::Pg;
 use diesel::types::*;
 
 #[test]
