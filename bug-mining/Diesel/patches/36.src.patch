diff --git a/diesel/src/expression/array_comparison.rs b/diesel/src/expression/array_comparison.rs
new file mode 100644
index 000000000..b148fa3e3
--- /dev/null
+++ b/diesel/src/expression/array_comparison.rs
@@ -0,0 +1,57 @@
+use backend::Backend;
+use expression::*;
+use query_builder::{QueryBuilder, QueryFragment, BuildQueryResult};
+use types::Bool;
+
+pub struct In<T, U> {
+    left: T,
+    values: Vec<U>,
+}
+
+impl<T, U> In<T, U> {
+    pub fn new(left: T, values: Vec<U>) -> Self {
+        In {
+            left: left,
+            values: values,
+        }
+    }
+}
+
+impl<T, U> Expression for In<T, U> where
+    T: Expression,
+    U: Expression<SqlType=T::SqlType>,
+{
+    type SqlType = Bool;
+}
+
+impl<T, U, QS> SelectableExpression<QS> for In<T, U> where
+    In<T, U>: Expression,
+    T: SelectableExpression<QS>,
+    U: SelectableExpression<QS>,
+{
+}
+
+impl<T, U> NonAggregate for In<T, U> where
+    In<T, U>: Expression,
+    T: NonAggregate,
+    U: NonAggregate,
+{
+}
+
+impl<T, U, DB> QueryFragment<DB> for In<T, U> where
+    DB: Backend,
+    T: QueryFragment<DB>,
+    U: QueryFragment<DB>,
+{
+    fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
+        try!(self.left.to_sql(out));
+        out.push_sql(" IN (");
+        try!(self.values[0].to_sql(out));
+        for value in self.values[1..].iter() {
+            out.push_sql(", ");
+            try!(value.to_sql(out));
+        }
+        out.push_sql(")");
+        Ok(())
+    }
+}
diff --git a/diesel/src/expression/expression_methods/global_expression_methods.rs b/diesel/src/expression/expression_methods/global_expression_methods.rs
index 41cb1cb14..8923d26af 100644
--- a/diesel/src/expression/expression_methods/global_expression_methods.rs
+++ b/diesel/src/expression/expression_methods/global_expression_methods.rs
@@ -1,5 +1,6 @@
 use expression::{Expression, AsExpression, nullable};
 use expression::aliased::Aliased;
+use expression::array_comparison::In;
 use expression::predicates::*;
 
 pub trait ExpressionMethods: Expression + Sized {
@@ -75,6 +76,42 @@ pub trait ExpressionMethods: Expression + Sized {
         NotEq::new(self, other.as_expression())
     }
 
+    /// Creates a SQL `IN` statement. Queries using this method will not be
+    /// placed in the prepared statement cache. On PostgreSQL, you should use
+    /// `eq(any())` instead. This method may change in the future to
+    /// automatically perform `= ANY` on PostgreSQL.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("src/doctest_setup.rs");
+    /// #
+    /// # table! {
+    /// #     users {
+    /// #         id -> Integer,
+    /// #         name -> VarChar,
+    /// #     }
+    /// # }
+    /// #
+    /// # fn main() {
+    /// #     use self::users::dsl::*;
+    /// #     let connection = establish_connection();
+    /// #     connection.execute("INSERT INTO users (name) VALUES
+    /// #         ('Jim')").unwrap();
+    /// let data = users.select(id).filter(name.eq_any(vec!["Sean", "Jim"]));
+    /// assert_eq!(Ok(vec![1, 3]), data.load(&connection));
+    /// # }
+    /// ```
+    fn eq_any<I, T>(self, values: I) -> In<Self, T::Expression> where
+        I: IntoIterator<Item=T>,
+        T: AsExpression<Self::SqlType>,
+    {
+        let expressions = values.into_iter()
+            .map(AsExpression::as_expression).collect();
+        In::new(self, expressions)
+    }
+
     /// Creates a SQL `IS NULL` expression.
     fn is_null(self) -> IsNull<Self> {
        IsNull::new(self)
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index 41f490951..602a04b43 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -20,6 +20,8 @@ pub mod ops;
 #[doc(hidden)]
 pub mod aliased;
 #[doc(hidden)]
+pub mod array_comparison;
+#[doc(hidden)]
 pub mod bound;
 #[doc(hidden)]
 pub mod count;
diff --git a/diesel_tests/tests/filter_operators.rs b/diesel_tests/tests/filter_operators.rs
index a4bf001a3..598af262e 100644
--- a/diesel_tests/tests/filter_operators.rs
+++ b/diesel_tests/tests/filter_operators.rs
@@ -122,6 +122,23 @@ fn filter_by_any() {
         users.filter(name.eq(any(borrowed_names))).load(&connection).unwrap());
 }
 
+#[test]
+fn filter_by_in() {
+    use schema::users::dsl::*;
+
+    let connection = connection_with_3_users();
+    let sean = User::new(1, "Sean");
+    let tess = User::new(2, "Tess");
+    let jim = User::new(3, "Jim");
+
+    let owned_names = vec!["Sean", "Tess"];
+    let borrowed_names: &[_] = &["Sean", "Jim"];
+    assert_eq!(vec![sean.clone(), tess],
+        users.filter(name.eq_any(owned_names)).load(&connection).unwrap());
+    assert_eq!(vec![sean, jim],
+        users.filter(name.eq_any(borrowed_names)).load(&connection).unwrap());
+}
+
 fn connection_with_3_users() -> TestConnection {
     let connection = connection_with_sean_and_tess_in_users_table();
     connection.execute("INSERT INTO users (id, name) VALUES (3, 'Jim')").unwrap();
