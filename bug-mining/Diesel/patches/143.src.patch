diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3ab3198f7..5530f50e0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -50,6 +50,12 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * `helper_types` now contains a type for every method defined in
   `expression_methods`, and every function in `dsl`.
 
+* Added `FromSql` impls for `*const str` and `*const [u8]` everywhere that
+  `String` and `Vec` are supported. These impls do not allocate, and are
+  intended for use by other impls which need to parse a string or bytes, and
+  don't want to allocate. These impls should never be used outside of another
+  `FromSql` impl.
+
 ### Deprecated
 
 * *IMPORTANT NOTE* Do to [several][rust-deprecation-bug-1]
diff --git a/diesel/src/mysql/types/numeric.rs b/diesel/src/mysql/types/numeric.rs
index 4dd519f36..672bcb6ad 100644
--- a/diesel/src/mysql/types/numeric.rs
+++ b/diesel/src/mysql/types/numeric.rs
@@ -5,10 +5,11 @@ pub mod bigdecimal {
     use self::bigdecimal::BigDecimal;
     use std::io::prelude::*;
 
+    use backend::Backend;
     use deserialize::{self, FromSql};
     use mysql::Mysql;
     use serialize::{self, IsNull, Output, ToSql};
-    use sql_types::Numeric;
+    use sql_types::{Binary, Numeric};
 
     impl ToSql<Numeric, Mysql> for BigDecimal {
         fn to_sql<W: Write>(&self, out: &mut Output<W, Mysql>) -> serialize::Result {
@@ -19,8 +20,9 @@ pub mod bigdecimal {
     }
 
     impl FromSql<Numeric, Mysql> for BigDecimal {
-        fn from_sql(bytes: Option<&[u8]>) -> deserialize::Result<Self> {
-            let bytes = not_none!(bytes);
+        fn from_sql(bytes: Option<&<Mysql as Backend>::RawValue>) -> deserialize::Result<Self> {
+            let bytes_ptr = <*const [u8] as FromSql<Binary, Mysql>>::from_sql(bytes)?;
+            let bytes = unsafe { &*bytes_ptr };
             BigDecimal::parse_bytes(bytes, 10)
                 .ok_or_else(|| Box::from(format!("{:?} is not valid decimal number ", bytes)))
         }
diff --git a/diesel/src/sqlite/types/date_and_time/chrono.rs b/diesel/src/sqlite/types/date_and_time/chrono.rs
index 8ad2d557d..82a14b3a3 100644
--- a/diesel/src/sqlite/types/date_and_time/chrono.rs
+++ b/diesel/src/sqlite/types/date_and_time/chrono.rs
@@ -3,17 +3,18 @@ extern crate chrono;
 use std::io::Write;
 use self::chrono::{NaiveDate, NaiveDateTime, NaiveTime};
 
+use backend::Backend;
 use deserialize::{self, FromSql};
 use serialize::{self, Output, ToSql};
 use sqlite::Sqlite;
-use sqlite::connection::SqliteValue;
 use sql_types::{Date, Text, Time, Timestamp};
 
 const SQLITE_DATE_FORMAT: &str = "%F";
 
 impl FromSql<Date, Sqlite> for NaiveDate {
-    fn from_sql(value: Option<&SqliteValue>) -> deserialize::Result<Self> {
-        let text = not_none!(value).read_text();
+    fn from_sql(value: Option<&<Sqlite as Backend>::RawValue>) -> deserialize::Result<Self> {
+        let text_ptr = <*const str as FromSql<Date, Sqlite>>::from_sql(value)?;
+        let text = unsafe { &*text_ptr };
         Self::parse_from_str(text, SQLITE_DATE_FORMAT).map_err(Into::into)
     }
 }
@@ -26,8 +27,9 @@ impl ToSql<Date, Sqlite> for NaiveDate {
 }
 
 impl FromSql<Time, Sqlite> for NaiveTime {
-    fn from_sql(value: Option<&SqliteValue>) -> deserialize::Result<Self> {
-        let text = not_none!(value).read_text();
+    fn from_sql(value: Option<&<Sqlite as Backend>::RawValue>) -> deserialize::Result<Self> {
+        let text_ptr = <*const str as FromSql<Date, Sqlite>>::from_sql(value)?;
+        let text = unsafe { &*text_ptr };
         let valid_time_formats = &[
             // Most likely
             "%T%.f",
@@ -57,8 +59,9 @@ impl ToSql<Time, Sqlite> for NaiveTime {
 }
 
 impl FromSql<Timestamp, Sqlite> for NaiveDateTime {
-    fn from_sql(value: Option<&SqliteValue>) -> deserialize::Result<Self> {
-        let text = not_none!(value).read_text();
+    fn from_sql(value: Option<&<Sqlite as Backend>::RawValue>) -> deserialize::Result<Self> {
+        let text_ptr = <*const str as FromSql<Date, Sqlite>>::from_sql(value)?;
+        let text = unsafe { &*text_ptr };
 
         let sqlite_datetime_formats = &[
             // Most likely format
diff --git a/diesel/src/sqlite/types/date_and_time/mod.rs b/diesel/src/sqlite/types/date_and_time/mod.rs
index b2d964d36..2907f82cf 100644
--- a/diesel/src/sqlite/types/date_and_time/mod.rs
+++ b/diesel/src/sqlite/types/date_and_time/mod.rs
@@ -9,7 +9,12 @@ use sql_types;
 #[cfg(feature = "chrono")]
 mod chrono;
 
-impl FromSql<sql_types::Date, Sqlite> for String {
+/// The returned pointer is *only* valid for the lifetime to the argument of
+/// `from_sql`. This impl is intended for uses where you want to write a new
+/// impl in terms of `String`, but don't want to allocate. We have to return a
+/// raw pointer instead of a reference with a lifetime due to the structure of
+/// `FromSql`
+impl FromSql<sql_types::Date, Sqlite> for *const str {
     fn from_sql(value: Option<&SqliteValue>) -> deserialize::Result<Self> {
         FromSql::<sql_types::Text, Sqlite>::from_sql(value)
     }
@@ -27,7 +32,12 @@ impl ToSql<sql_types::Date, Sqlite> for String {
     }
 }
 
-impl FromSql<sql_types::Time, Sqlite> for String {
+/// The returned pointer is *only* valid for the lifetime to the argument of
+/// `from_sql`. This impl is intended for uses where you want to write a new
+/// impl in terms of `String`, but don't want to allocate. We have to return a
+/// raw pointer instead of a reference with a lifetime due to the structure of
+/// `FromSql`
+impl FromSql<sql_types::Time, Sqlite> for *const str {
     fn from_sql(value: Option<&SqliteValue>) -> deserialize::Result<Self> {
         FromSql::<sql_types::Text, Sqlite>::from_sql(value)
     }
@@ -45,7 +55,12 @@ impl ToSql<sql_types::Time, Sqlite> for String {
     }
 }
 
-impl FromSql<sql_types::Timestamp, Sqlite> for String {
+/// The returned pointer is *only* valid for the lifetime to the argument of
+/// `from_sql`. This impl is intended for uses where you want to write a new
+/// impl in terms of `String`, but don't want to allocate. We have to return a
+/// raw pointer instead of a reference with a lifetime due to the structure of
+/// `FromSql`
+impl FromSql<sql_types::Timestamp, Sqlite> for *const str {
     fn from_sql(value: Option<&SqliteValue>) -> deserialize::Result<Self> {
         FromSql::<sql_types::Text, Sqlite>::from_sql(value)
     }
diff --git a/diesel/src/sqlite/types/mod.rs b/diesel/src/sqlite/types/mod.rs
index 9287accba..86d7191d9 100644
--- a/diesel/src/sqlite/types/mod.rs
+++ b/diesel/src/sqlite/types/mod.rs
@@ -8,17 +8,27 @@ use super::Sqlite;
 use super::connection::SqliteValue;
 use sql_types;
 
-impl FromSql<sql_types::VarChar, Sqlite> for String {
+/// The returned pointer is *only* valid for the lifetime to the argument of
+/// `from_sql`. This impl is intended for uses where you want to write a new
+/// impl in terms of `String`, but don't want to allocate. We have to return a
+/// raw pointer instead of a reference with a lifetime due to the structure of
+/// `FromSql`
+impl FromSql<sql_types::VarChar, Sqlite> for *const str {
     fn from_sql(value: Option<&SqliteValue>) -> deserialize::Result<Self> {
         let text = not_none!(value).read_text();
-        Ok(text.into())
+        Ok(text as *const _)
     }
 }
 
-impl FromSql<sql_types::Binary, Sqlite> for Vec<u8> {
+/// The returned pointer is *only* valid for the lifetime to the argument of
+/// `from_sql`. This impl is intended for uses where you want to write a new
+/// impl in terms of `Vec<u8>`, but don't want to allocate. We have to return a
+/// raw pointer instead of a reference with a lifetime due to the structure of
+/// `FromSql`
+impl FromSql<sql_types::Binary, Sqlite> for *const [u8] {
     fn from_sql(bytes: Option<&SqliteValue>) -> deserialize::Result<Self> {
         let bytes = not_none!(bytes).read_blob();
-        Ok(bytes.into())
+        Ok(bytes as *const _)
     }
 }
 
diff --git a/diesel/src/type_impls/primitives.rs b/diesel/src/type_impls/primitives.rs
index 93307f141..bd5573d64 100644
--- a/diesel/src/type_impls/primitives.rs
+++ b/diesel/src/type_impls/primitives.rs
@@ -83,10 +83,29 @@ mod foreign_impls {
 
 impl NotNull for () {}
 
-impl<DB: Backend<RawValue = [u8]>> FromSql<sql_types::Text, DB> for String {
-    fn from_sql(bytes: Option<&[u8]>) -> deserialize::Result<Self> {
-        let bytes = not_none!(bytes);
-        String::from_utf8(bytes.into()).map_err(|e| Box::new(e) as Box<Error + Send + Sync>)
+impl<ST, DB> FromSql<ST, DB> for String
+where
+    DB: Backend,
+    *const str: FromSql<ST, DB>,
+{
+    fn from_sql(bytes: Option<&DB::RawValue>) -> deserialize::Result<Self> {
+        let str_ptr = <*const str as FromSql<ST, DB>>::from_sql(bytes)?;
+        // We know that the pointer impl will never return null
+        let string = unsafe { &*str_ptr };
+        Ok(string.to_owned())
+    }
+}
+
+/// The returned pointer is *only* valid for the lifetime to the argument of
+/// `from_sql`. This impl is intended for uses where you want to write a new
+/// impl in terms of `String`, but don't want to allocate. We have to return a
+/// raw pointer instead of a reference with a lifetime due to the structure of
+/// `FromSql`
+impl<DB: Backend<RawValue = [u8]>> FromSql<sql_types::Text, DB> for *const str {
+    fn from_sql(bytes: Option<&DB::RawValue>) -> deserialize::Result<Self> {
+        use std::str;
+        let string = str::from_utf8(not_none!(bytes))?;
+        Ok(string as *const _)
     }
 }
 
@@ -108,9 +127,27 @@ where
     }
 }
 
-impl<DB: Backend<RawValue = [u8]>> FromSql<sql_types::Binary, DB> for Vec<u8> {
+impl<ST, DB> FromSql<ST, DB> for Vec<u8>
+where
+    DB: Backend,
+    *const [u8]: FromSql<ST, DB>,
+{
+    fn from_sql(bytes: Option<&DB::RawValue>) -> deserialize::Result<Self> {
+        let slice_ptr = <*const [u8] as FromSql<ST, DB>>::from_sql(bytes)?;
+        // We know that the pointer impl will never return null
+        let bytes = unsafe { &*slice_ptr };
+        Ok(bytes.to_owned())
+    }
+}
+
+/// The returned pointer is *only* valid for the lifetime to the argument of
+/// `from_sql`. This impl is intended for uses where you want to write a new
+/// impl in terms of `Vec<u8>`, but don't want to allocate. We have to return a
+/// raw pointer instead of a reference with a lifetime due to the structure of
+/// `FromSql`
+impl<DB: Backend<RawValue = [u8]>> FromSql<sql_types::Binary, DB> for *const [u8] {
     fn from_sql(bytes: Option<&DB::RawValue>) -> deserialize::Result<Self> {
-        Ok(not_none!(bytes).into())
+        Ok(not_none!(bytes) as *const _)
     }
 }
 
diff --git a/diesel_compile_tests/tests/compile-fail/select_carries_correct_result_type_info.rs b/diesel_compile_tests/tests/compile-fail/select_carries_correct_result_type_info.rs
index d0328f30e..f01f5be9c 100644
--- a/diesel_compile_tests/tests/compile-fail/select_carries_correct_result_type_info.rs
+++ b/diesel_compile_tests/tests/compile-fail/select_carries_correct_result_type_info.rs
@@ -20,5 +20,5 @@ fn main() {
     let ids = select_name.load::<i32>(&connection);
     //~^ ERROR the trait bound `i32: diesel::deserialize::FromSql<diesel::sql_types::Text, _>` is not satisfied
     let names = select_id.load::<String>(&connection);
-    //~^ ERROR the trait bound `std::string::String: diesel::deserialize::FromSql<diesel::sql_types::Integer, _>` is not satisfied
+    //~^ ERROR the trait bound `*const str: diesel::deserialize::FromSql<diesel::sql_types::Integer, _>` is not satisfied
 }
