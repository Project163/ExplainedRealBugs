diff --git a/diesel_compile_tests/tests/fail/derive/selectable.rs b/diesel_compile_tests/tests/fail/derive/selectable.rs
index 5edee02f5..79c913e9e 100644
--- a/diesel_compile_tests/tests/fail/derive/selectable.rs
+++ b/diesel_compile_tests/tests/fail/derive/selectable.rs
@@ -41,4 +41,11 @@ struct User {
     no_tuple: i32,
 }
 
+#[derive(Selectable)]
+#[diesel(table_name = users)]
+#[diesel(check_for_backend(diesel::pg::Pg))]
+struct User1<'a> {
+    name: &'a str,
+}
+
 fn main() {}
diff --git a/diesel_compile_tests/tests/fail/derive/selectable.stderr b/diesel_compile_tests/tests/fail/derive/selectable.stderr
index 37dd257c4..bfd06d17b 100644
--- a/diesel_compile_tests/tests/fail/derive/selectable.stderr
+++ b/diesel_compile_tests/tests/fail/derive/selectable.stderr
@@ -1,3 +1,10 @@
+error: References are not supported in `Queryable` types
+       Consider using `std::borrow::Cow<'a, str>` instead
+  --> tests/fail/derive/selectable.rs:48:11
+   |
+48 |     name: &'a str,
+   |           ^^^^^^^
+
 error[E0412]: cannot find type `non_existing` in module `users`
   --> tests/fail/derive/selectable.rs:26:5
    |
diff --git a/diesel_derives/src/selectable.rs b/diesel_derives/src/selectable.rs
index 352a86d65..5d2684bd8 100644
--- a/diesel_derives/src/selectable.rs
+++ b/diesel_derives/src/selectable.rs
@@ -11,7 +11,7 @@ use crate::util::wrap_in_dummy_mod;
 pub fn derive(item: DeriveInput) -> Result<TokenStream> {
     let model = Model::from_item(&item, false, false)?;
 
-    let (_, ty_generics, _) = item.generics.split_for_impl();
+    let (_, ty_generics, original_where_clause) = item.generics.split_for_impl();
 
     let mut generics = item.generics.clone();
     generics
@@ -51,20 +51,23 @@ pub fn derive(item: DeriveInput) -> Result<TokenStream> {
             .filter(|(f, _)| !f.embed())
             .flat_map(|(f, ty)| {
                 backends.iter().map(move |b| {
-                    let field_ty = to_field_ty_bound(f.ty_for_deserialize());
-                    let span = field_ty.span();
-                    quote::quote_spanned! {span =>
+                    let span = f.ty.span();
+                    let field_ty = to_field_ty_bound(f.ty_for_deserialize())?;
+                    Ok(syn::parse_quote_spanned! {span =>
                         #field_ty: diesel::deserialize::FromSqlRow<diesel::dsl::SqlTypeOf<#ty>, #b>
-                    }
+                    })
                 })
-            });
+            })
+            .collect::<Result<Vec<_>>>()?;
+        let where_clause = &mut original_where_clause.cloned();
+        let where_clause = where_clause.get_or_insert_with(|| parse_quote!(where));
+        for field_check in field_check_bound {
+            where_clause.predicates.push(field_check);
+        }
         Some(quote::quote! {
-            fn _check_field_compatibility()
-            where
-                #(#field_check_bound,)*
-            {
-
-            }
+            fn _check_field_compatibility #impl_generics()
+                #where_clause
+            {}
         })
     } else {
         None
@@ -95,49 +98,27 @@ pub fn derive(item: DeriveInput) -> Result<TokenStream> {
     }))
 }
 
-fn to_field_ty_bound(field_ty: &syn::Type) -> Option<TokenStream> {
+fn to_field_ty_bound(field_ty: &syn::Type) -> Result<TokenStream> {
     match field_ty {
-        syn::Type::Path(p) => {
-            if let syn::PathArguments::AngleBracketed(ref args) =
-                p.path.segments.last().unwrap().arguments
-            {
-                let lt = args
-                    .args
-                    .iter()
-                    .filter_map(|f| {
-                        if let syn::GenericArgument::Lifetime(lt) = f {
-                            Some(lt)
-                        } else {
-                            None
-                        }
-                    })
-                    .collect::<Vec<_>>();
-                if lt.is_empty() {
-                    Some(quote::quote! {
-                        #field_ty
-                    })
-                } else if lt.len() == args.args.len() {
-                    Some(quote::quote! {
-                        for<#(#lt,)*> #field_ty
-                    })
-                } else {
-                    // type parameters are not supported for checking
-                    // for now
-                    None
-                }
-            } else {
-                Some(quote::quote! {
-                    #field_ty
-                })
-            }
-        }
-        syn::Type::Reference(_r) => {
+        syn::Type::Reference(r) => {
+            use crate::quote::ToTokens;
             // references are not supported for checking for now
             //
             // (How ever you can even have references in a `Queryable` struct anyway)
-            None
+            Err(syn::Error::new(
+                field_ty.span(),
+                format!(
+                    "References are not supported in `Queryable` types\n\
+                         Consider using `std::borrow::Cow<'{}, {}>` instead",
+                    r.lifetime
+                        .as_ref()
+                        .expect("It's a struct field so it must have a named lifetime")
+                        .ident,
+                    r.elem.to_token_stream()
+                ),
+            ))
         }
-        field_ty => Some(quote::quote! {
+        field_ty => Ok(quote::quote! {
             #field_ty
         }),
     }
diff --git a/diesel_derives/tests/selectable.rs b/diesel_derives/tests/selectable.rs
index af1c73e45..4b151f7fc 100644
--- a/diesel_derives/tests/selectable.rs
+++ b/diesel_derives/tests/selectable.rs
@@ -1,3 +1,7 @@
+use std::marker::PhantomData;
+
+use diesel::deserialize::FromSql;
+use diesel::sql_types::Text;
 use diesel::*;
 
 use crate::helpers::connection;
@@ -172,3 +176,50 @@ fn check_for_backend_with_deserialize_as() {
         name: MyString,
     }
 }
+
+#[allow(dead_code)] // that's essentially a compile test
+#[test]
+fn check_with_lifetime_and_type_param() {
+    use std::borrow::Cow;
+    table! {
+        test {
+            id -> Integer,
+            name -> Text,
+        }
+    }
+
+    #[derive(Queryable, Selectable)]
+    #[diesel(table_name = test)]
+    #[diesel(check_for_backend(crate::helpers::TestBackend))]
+    pub struct Account<'n0> {
+        id: i32,
+        name: Cow<'n0, str>,
+    }
+
+    #[derive(Queryable, Selectable)]
+    #[diesel(table_name = test)]
+    #[diesel(check_for_backend(crate::helpers::TestBackend))]
+    pub struct Foo<T>
+    where
+        T: Copy,
+    {
+        name: FooInner<T>,
+    }
+
+    #[derive(FromSqlRow)]
+    pub struct FooInner<T>(String, PhantomData<T>);
+
+    impl<T> FromSql<Text, crate::helpers::TestBackend> for FooInner<T>
+    where
+        T: Copy,
+    {
+        fn from_sql(
+            bytes: <crate::helpers::TestBackend as backend::Backend>::RawValue<'_>,
+        ) -> deserialize::Result<Self> {
+            Ok(Self(
+                <String as FromSql<Text, crate::helpers::TestBackend>>::from_sql(bytes)?,
+                PhantomData,
+            ))
+        }
+    }
+}
