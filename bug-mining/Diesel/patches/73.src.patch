diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9eab776f3..5d6414d26 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -17,6 +17,10 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * `debug_sql!` can now properly be used with types from `chrono` or
   `std::time`.
 
+* When using PostgreSQL, attempting to get the error message of a query which
+  could not be transmitted to the server (such as a query with greater than
+  65535 bind parameters) will no longer panic.
+
 ## [0.9.0] - 2016-12-08
 
 ### Added
diff --git a/diesel/src/pg/connection/mod.rs b/diesel/src/pg/connection/mod.rs
index 36b7a6d08..4025e0de5 100644
--- a/diesel/src/pg/connection/mod.rs
+++ b/diesel/src/pg/connection/mod.rs
@@ -41,7 +41,7 @@ impl SimpleConnection for PgConnection {
         let inner_result = unsafe {
             self.raw_connection.exec(query.as_ptr())
         };
-        try!(PgResult::new(inner_result));
+        try!(PgResult::new(inner_result?));
         Ok(())
     }
 }
diff --git a/diesel/src/pg/connection/raw.rs b/diesel/src/pg/connection/raw.rs
index df4b4dd67..1c9f47540 100644
--- a/diesel/src/pg/connection/raw.rs
+++ b/diesel/src/pg/connection/raw.rs
@@ -57,8 +57,8 @@ impl RawConnection {
         }
     }
 
-    pub unsafe fn exec(&self, query: *const libc::c_char) -> *mut PGresult {
-        PQexec(self.internal_connection, query)
+    pub unsafe fn exec(&self, query: *const libc::c_char) -> QueryResult<RawResult> {
+        RawResult::new(PQexec(self.internal_connection, query), self)
     }
 
     pub unsafe fn exec_params(
@@ -70,8 +70,8 @@ impl RawConnection {
         param_lengths: *const libc::c_int,
         param_formats: *const libc::c_int,
         result_format: libc::c_int,
-    ) -> *mut PGresult {
-        PQexecParams(
+    ) -> QueryResult<RawResult> {
+        let ptr = PQexecParams(
             self.internal_connection,
             query,
             param_count,
@@ -80,7 +80,8 @@ impl RawConnection {
             param_lengths,
             param_formats,
             result_format,
-        )
+        );
+        RawResult::new(ptr, self)
     }
 
     pub unsafe fn exec_prepared(
@@ -91,8 +92,8 @@ impl RawConnection {
         param_lengths: *const libc::c_int,
         param_formats: *const libc::c_int,
         result_format: libc::c_int,
-    ) -> *mut PGresult {
-        PQexecPrepared(
+    ) -> QueryResult<RawResult> {
+        let ptr = PQexecPrepared(
             self.internal_connection,
             stmt_name,
             param_count,
@@ -100,7 +101,8 @@ impl RawConnection {
             param_lengths,
             param_formats,
             result_format,
-        )
+        );
+        RawResult::new(ptr, self)
     }
 
     pub unsafe fn prepare(
@@ -109,14 +111,15 @@ impl RawConnection {
         query: *const libc::c_char,
         param_count: libc::c_int,
         param_types: *const Oid,
-    ) -> *mut PGresult {
-        PQprepare(
+    ) -> QueryResult<RawResult> {
+        let ptr = PQprepare(
             self.internal_connection,
             stmt_name,
             query,
             param_count,
             param_types,
-        )
+        );
+        RawResult::new(ptr, self)
     }
 }
 
@@ -167,3 +170,37 @@ impl Drop for PgString {
         }
     }
 }
+
+/// Internal wrapper around a `*mut PGresult` which is known to be not-null, and
+/// have no aliases.  This wrapper is to ensure that it's always properly
+/// dropped.
+///
+/// If `Unique` is ever stabilized, we should use it here.
+#[allow(missing_debug_implementations)]
+pub struct RawResult(*mut PGresult);
+
+unsafe impl Send for RawResult {}
+unsafe impl Sync for RawResult {}
+
+impl RawResult {
+    fn new(ptr: *mut PGresult, conn: &RawConnection) -> QueryResult<Self> {
+        if ptr.is_null() {
+            Err(Error::DatabaseError(
+                DatabaseErrorKind::UnableToSendCommand,
+                Box::new(conn.last_error_message()),
+            ))
+        } else {
+            Ok(RawResult(ptr))
+        }
+    }
+
+    pub fn as_ptr(&self) -> *mut PGresult {
+        self.0
+    }
+}
+
+impl Drop for RawResult {
+    fn drop(&mut self) {
+        unsafe { PQclear(self.0) }
+    }
+}
diff --git a/diesel/src/pg/connection/result.rs b/diesel/src/pg/connection/result.rs
index 5684ff328..51f3ca9ea 100644
--- a/diesel/src/pg/connection/result.rs
+++ b/diesel/src/pg/connection/result.rs
@@ -3,18 +3,19 @@ extern crate libc;
 
 use result::{Error, QueryResult, DatabaseErrorInformation, DatabaseErrorKind};
 use super::row::PgRow;
+use super::raw::RawResult;
 
 use self::pq_sys::*;
 use std::ffi::CStr;
 use std::{str, slice};
 
 pub struct PgResult {
-    internal_result: *mut PGresult,
+    internal_result: RawResult,
 }
 
 impl PgResult {
-    pub fn new(internal_result: *mut PGresult) -> QueryResult<Self> {
-        let result_status = unsafe { PQresultStatus(internal_result) };
+    pub fn new(internal_result: RawResult) -> QueryResult<Self> {
+        let result_status = unsafe { PQresultStatus(internal_result.as_ptr()) };
         match result_status {
             PGRES_COMMAND_OK | PGRES_TUPLES_OK => {
                 Ok(PgResult {
@@ -22,11 +23,11 @@ impl PgResult {
                 })
             },
             _ => {
-                let error_information = Box::new(PgErrorInformation(internal_result));
-                let error_kind = match get_result_field(internal_result, ResultField::SqlState) {
+                let error_kind = match get_result_field(internal_result.as_ptr(), ResultField::SqlState) {
                     Some(error_codes::UNIQUE_VIOLATION) => DatabaseErrorKind::UniqueViolation,
                     _ => DatabaseErrorKind::__Unknown,
                 };
+                let error_information = Box::new(PgErrorInformation(internal_result));
                 Err(Error::DatabaseError(error_kind, error_information))
             }
         }
@@ -34,7 +35,7 @@ impl PgResult {
 
     pub fn rows_affected(&self) -> usize {
         unsafe {
-            let count_char_ptr = PQcmdTuples(self.internal_result);
+            let count_char_ptr = PQcmdTuples(self.internal_result.as_ptr());
             let count_bytes = CStr::from_ptr(count_char_ptr).to_bytes();
             let count_str = str::from_utf8_unchecked(count_bytes);
             match count_str {
@@ -45,7 +46,7 @@ impl PgResult {
     }
 
     pub fn num_rows(&self) -> usize {
-        unsafe { PQntuples(self.internal_result) as usize }
+        unsafe { PQntuples(self.internal_result.as_ptr()) as usize }
     }
 
     pub fn get_row(&self, idx: usize) -> PgRow {
@@ -59,8 +60,9 @@ impl PgResult {
             let row_idx = row_idx as libc::c_int;
             let col_idx = col_idx as libc::c_int;
             unsafe {
-                let value_ptr = PQgetvalue(self.internal_result, row_idx, col_idx) as *const u8;
-                let num_bytes = PQgetlength(self.internal_result, row_idx, col_idx);
+                let value_ptr = PQgetvalue(self.internal_result.as_ptr(), row_idx, col_idx)
+                    as *const u8;
+                let num_bytes = PQgetlength(self.internal_result.as_ptr(), row_idx, col_idx);
                 Some(slice::from_raw_parts(value_ptr, num_bytes as usize))
             }
         }
@@ -69,7 +71,7 @@ impl PgResult {
     pub fn is_null(&self, row_idx: usize, col_idx: usize) -> bool {
         unsafe {
             0 != PQgetisnull(
-                self.internal_result,
+                self.internal_result.as_ptr(),
                 row_idx as libc::c_int,
                 col_idx as libc::c_int,
             )
@@ -77,48 +79,34 @@ impl PgResult {
     }
 }
 
-impl Drop for PgResult {
-    fn drop(&mut self) {
-        unsafe { PQclear(self.internal_result) };
-    }
-}
-
-struct PgErrorInformation(*mut PGresult);
-
-unsafe impl Send for PgErrorInformation {}
-
-impl Drop for PgErrorInformation {
-    fn drop(&mut self) {
-        unsafe { PQclear(self.0) };
-    }
-}
+struct PgErrorInformation(RawResult);
 
 impl DatabaseErrorInformation for PgErrorInformation {
     fn message(&self) -> &str {
-        match get_result_field(self.0, ResultField::MessagePrimary) {
+        match get_result_field(self.0.as_ptr(), ResultField::MessagePrimary) {
             Some(e) => e,
             None => unreachable!("Per PGs documentation, all errors should have a message"),
         }
     }
 
     fn details(&self) -> Option<&str> {
-        get_result_field(self.0, ResultField::MessageDetail)
+        get_result_field(self.0.as_ptr(), ResultField::MessageDetail)
     }
 
     fn hint(&self) -> Option<&str> {
-        get_result_field(self.0, ResultField::MessageHint)
+        get_result_field(self.0.as_ptr(), ResultField::MessageHint)
     }
 
     fn table_name(&self) -> Option<&str> {
-        get_result_field(self.0, ResultField::TableName)
+        get_result_field(self.0.as_ptr(), ResultField::TableName)
     }
 
     fn column_name(&self) -> Option<&str> {
-        get_result_field(self.0, ResultField::ColumnName)
+        get_result_field(self.0.as_ptr(), ResultField::ColumnName)
     }
 
     fn constraint_name(&self) -> Option<&str> {
-        get_result_field(self.0, ResultField::ConstraintName)
+        get_result_field(self.0.as_ptr(), ResultField::ConstraintName)
     }
 }
 
diff --git a/diesel/src/pg/connection/stmt/mod.rs b/diesel/src/pg/connection/stmt/mod.rs
index 4d8e7dd46..49613a1ee 100644
--- a/diesel/src/pg/connection/stmt/mod.rs
+++ b/diesel/src/pg/connection/stmt/mod.rs
@@ -63,7 +63,7 @@ impl Query {
             }
         };
 
-        PgResult::new(internal_res)
+        PgResult::new(internal_res?)
     }
 
     pub fn sql(sql: &str, param_types: Option<Vec<u32>>) -> QueryResult<Self> {
@@ -90,7 +90,7 @@ impl Query {
                 param_types_to_ptr(Some(&param_types)),
             )
         };
-        try!(PgResult::new(internal_result));
+        try!(PgResult::new(internal_result?));
 
         Ok(Query::Prepared {
             name: name,
diff --git a/diesel/src/result.rs b/diesel/src/result.rs
index 327f5dff1..f3f76367f 100644
--- a/diesel/src/result.rs
+++ b/diesel/src/result.rs
@@ -26,6 +26,7 @@ pub enum Error {
 /// bump.
 pub enum DatabaseErrorKind {
     UniqueViolation,
+    UnableToSendCommand,
     #[doc(hidden)]
     __Unknown, // Match against _ instead, more variants may be added in the future
 }
diff --git a/diesel_tests/tests/internal_details.rs b/diesel_tests/tests/internal_details.rs
index b1eeb7a75..1d2d92f8c 100644
--- a/diesel_tests/tests/internal_details.rs
+++ b/diesel_tests/tests/internal_details.rs
@@ -11,3 +11,23 @@ fn bind_params_are_passed_for_null_when_not_inserting() {
         .filter(AsExpression::<Nullable<Integer>>::as_expression(None::<i32>).is_null());
     assert_eq!(Ok(1), query.first(&connection));
 }
+
+#[test]
+#[cfg(feature = "postgres")]
+fn query_which_cannot_be_transmitted_gives_proper_error_message() {
+    use schema::comments::dsl::*;
+    use diesel::result::Error::DatabaseError;
+    use diesel::result::DatabaseErrorKind::UnableToSendCommand;
+
+    // Create a query with 90000 binds, 2 binds per row
+    let data: &[NewComment<'static>] = &[NewComment(1, "hi"); 45_000];
+    let query_with_to_many_binds = insert(data).into(comments);
+
+    match query_with_to_many_binds.execute(&connection()) {
+        Ok(_) => panic!("We successfully executed a query with 90k binds. \
+            We need to find a new query to test which can't be represented by \
+            the wire protocol."),
+        Err(DatabaseError(UnableToSendCommand, info)) => assert_ne!("", info.message()),
+        Err(_) => panic!("We got back the wrong kind of error. This test is invalid."),
+    }
+}
diff --git a/diesel_tests/tests/schema.rs b/diesel_tests/tests/schema.rs
index dddca8022..16b535e55 100644
--- a/diesel_tests/tests/schema.rs
+++ b/diesel_tests/tests/schema.rs
@@ -126,7 +126,7 @@ impl NewPost {
     }
 }
 
-#[derive(Insertable)]
+#[derive(Debug, Clone, Copy, Insertable)]
 #[table_name="comments"]
 pub struct NewComment<'a>(
     #[column_name(post_id)]
