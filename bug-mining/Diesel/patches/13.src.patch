diff --git a/diesel_tests/tests/associations.rs b/diesel_tests/tests/associations.rs
index a6daa16d0..d7e236304 100644
--- a/diesel_tests/tests/associations.rs
+++ b/diesel_tests/tests/associations.rs
@@ -6,8 +6,8 @@ fn one_to_many_returns_query_source_for_association() {
     let connection = connection_with_sean_and_tess_in_users_table();
     setup_posts_table(&connection);
 
-    let sean: User = connection.find(users::table, 1).unwrap();
-    let tess: User = connection.find(users::table, 2).unwrap();
+    let sean = find_user_by_name("Sean", &connection);
+    let tess = find_user_by_name("Tess", &connection);
     let seans_posts: Vec<Post> =  insert(&vec![
         sean.new_post("Hello", None), sean.new_post("World", None)
         ]).into(posts::table)
diff --git a/diesel_tests/tests/filter.rs b/diesel_tests/tests/filter.rs
index d4b48671d..536e6c37c 100644
--- a/diesel_tests/tests/filter.rs
+++ b/diesel_tests/tests/filter.rs
@@ -6,12 +6,15 @@ fn filter_by_int_equality() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
-
-    let sean = User::new(1, "Sean");
-    let tess = User::new(2, "Tess");
-    assert_eq!(Ok(sean), users.filter(id.eq(1)).first(&connection));
-    assert_eq!(Ok(tess), users.filter(id.eq(2)).first(&connection));
-    assert_eq!(Err(NotFound), users.filter(id.eq(3)).first::<User>(&connection));
+    let sean_id = find_user_by_name("Sean", &connection).id;
+    let tess_id = find_user_by_name("Tess", &connection).id;
+    let unused_id = sean_id + tess_id;
+
+    let sean = User::new(sean_id, "Sean");
+    let tess = User::new(tess_id, "Tess");
+    assert_eq!(Ok(sean), users.filter(id.eq(sean_id)).first(&connection));
+    assert_eq!(Ok(tess), users.filter(id.eq(tess_id)).first(&connection));
+    assert_eq!(Err(NotFound), users.filter(id.eq(unused_id)).first::<User>(&connection));
 }
 
 #[test]
diff --git a/diesel_tests/tests/schema.rs b/diesel_tests/tests/schema.rs
index 2cb9d3aa3..ffdf9bd8f 100644
--- a/diesel_tests/tests/schema.rs
+++ b/diesel_tests/tests/schema.rs
@@ -151,3 +151,10 @@ pub fn connection_with_sean_and_tess_in_users_table() -> Connection {
     insert(data).into(users::table).execute(&connection).unwrap();
     connection
 }
+
+pub fn find_user_by_name(name: &str, connection: &Connection) -> User {
+    let result: QueryResult<Vec<User>> = users::table.filter(users::name.eq(name))
+        .load(connection)
+        .map(|x| x.collect());
+    result.unwrap()[0].to_owned()
+}
diff --git a/diesel_tests/tests/update.rs b/diesel_tests/tests/update.rs
index f22827c93..6428093aa 100644
--- a/diesel_tests/tests/update.rs
+++ b/diesel_tests/tests/update.rs
@@ -24,8 +24,9 @@ fn test_updating_single_column_of_single_row() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
+    let sean = find_user_by_name("Sean", &connection);
 
-    update(users.filter(id.eq(1))).set(name.eq("Jim"))
+    update(users.filter(id.eq(sean.id))).set(name.eq("Jim"))
         .execute(&connection).unwrap();
 
     let expected_data = vec!["Tess".to_string(), "Jim".to_string()];
@@ -38,21 +39,22 @@ fn test_updating_nullable_column() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
+    let sean = find_user_by_name("Sean", &connection);
 
-    update(users.filter(id.eq(1))).set(hair_color.eq(Some("black")))
+    update(users.filter(id.eq(sean.id))).set(hair_color.eq(Some("black")))
         .execute(&connection).unwrap();
 
     let data: Option<String> = users.select(hair_color)
-        .filter(id.eq(1))
+        .filter(id.eq(sean.id))
         .first(&connection)
         .unwrap();
     assert_eq!(Some("black".to_string()), data);
 
-    update(users.filter(id.eq(1))).set(hair_color.eq(None::<String>))
+    update(users.filter(id.eq(sean.id))).set(hair_color.eq(None::<String>))
         .execute(&connection).unwrap();
 
     let data: QueryResult<Option<String>> = users.select(hair_color)
-        .filter(id.eq(1))
+        .filter(id.eq(sean.id))
         .first(&connection);
     assert_eq!(Ok(None::<String>), data);
 }
@@ -62,14 +64,15 @@ fn test_updating_multiple_columns() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
+    let sean = find_user_by_name("Sean", &connection);
 
-    update(users.filter(id.eq(1))).set((
+    update(users.filter(id.eq(sean.id))).set((
         name.eq("Jim"),
         hair_color.eq(Some("black")),
     )).execute(&connection).unwrap();
 
-    let expected_user = User::with_hair_color(1, "Jim", "black");
-    let user = connection.find(users, 1);
+    let expected_user = User::with_hair_color(sean.id, "Jim", "black");
+    let user = connection.find(users, sean.id);
     assert_eq!(Ok(expected_user), user);
 }
 
@@ -78,9 +81,10 @@ fn update_returning_struct() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
-    let user = update(users.filter(id.eq(1))).set(hair_color.eq("black"))
+    let sean = find_user_by_name("Sean", &connection);
+    let user = update(users.filter(id.eq(sean.id))).set(hair_color.eq("black"))
         .get_result(&connection);
-    let expected_user = User::with_hair_color(1, "Sean", "black");
+    let expected_user = User::with_hair_color(sean.id, "Sean", "black");
 
     assert_eq!(Ok(expected_user), user);
 }
@@ -90,11 +94,12 @@ fn update_with_struct_as_changes() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
+    let sean = find_user_by_name("Sean", &connection);
     let changes = NewUser::new("Jim", Some("blue"));
 
-    let user = update(users.filter(id.eq(1))).set(&changes)
+    let user = update(users.filter(id.eq(sean.id))).set(&changes)
         .get_result(&connection);
-    let expected_user = User::with_hair_color(1, "Jim", "blue");
+    let expected_user = User::with_hair_color(sean.id, "Jim", "blue");
 
     assert_eq!(Ok(expected_user), user);
 }
@@ -104,11 +109,13 @@ fn update_with_struct_does_not_set_primary_key() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
-    let changes = User::with_hair_color(2, "Jim", "blue");
+    let sean = find_user_by_name("Sean", &connection);
+    let other_id = sean.id + 1;
+    let changes = User::with_hair_color(other_id, "Jim", "blue");
 
-    let user = update(users.filter(id.eq(1))).set(&changes)
+    let user = update(users.filter(id.eq(sean.id))).set(&changes)
         .get_result(&connection);
-    let expected_user = User::with_hair_color(1, "Jim", "blue");
+    let expected_user = User::with_hair_color(sean.id, "Jim", "blue");
 
     assert_eq!(Ok(expected_user), user);
 }
@@ -118,9 +125,10 @@ fn save_on_struct_with_primary_key_changes_that_struct() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
-    let user = User::with_hair_color(1, "Jim", "blue").save_changes::<User>(&connection);
+    let sean = find_user_by_name("Sean", &connection);
+    let user = User::with_hair_color(sean.id, "Jim", "blue").save_changes::<User>(&connection);
 
-    let user_in_db = connection.find(users, 1);
+    let user_in_db = connection.find(users, sean.id);
 
     assert_eq!(user, user_in_db);
 }
@@ -130,12 +138,13 @@ fn option_fields_on_structs_are_not_assigned() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
-    update(users.filter(id.eq(1)))
+    let sean = find_user_by_name("Sean", &connection);
+    update(users.filter(id.eq(sean.id)))
         .set(hair_color.eq("black"))
         .execute(&connection).unwrap();
-    let user = User::new(1, "Jim").save_changes(&connection);
+    let user = User::new(sean.id, "Jim").save_changes(&connection);
 
-    let expected_user = User::with_hair_color(1, "Jim", "black");
+    let expected_user = User::with_hair_color(sean.id, "Jim", "black");
     assert_eq!(Ok(expected_user), user);
 }
 
@@ -149,9 +158,10 @@ fn sql_syntax_is_correct_when_option_field_comes_before_non_option() {
 
     let changes = Changes { hair_color: None, name: "Jim".into() };
     let connection = connection_with_sean_and_tess_in_users_table();
-    let user = update(users::table.filter(users::id.eq(1))).set(&changes)
+    let sean = find_user_by_name("Sean", &connection);
+    let user = update(users::table.filter(users::id.eq(sean.id))).set(&changes)
         .get_result(&connection);
 
-    let expected_user = User::new(1, "Jim");
+    let expected_user = User::new(sean.id, "Jim");
     assert_eq!(Ok(expected_user), user);
 }
