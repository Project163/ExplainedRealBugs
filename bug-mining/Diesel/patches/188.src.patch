diff --git a/diesel/src/deserialize.rs b/diesel/src/deserialize.rs
index 27bbf21a7..b2b07063a 100644
--- a/diesel/src/deserialize.rs
+++ b/diesel/src/deserialize.rs
@@ -325,10 +325,6 @@ pub trait FromSql<A, DB: Backend>: Sized {
 ///
 /// This trait can be [derived](derive.FromSqlRow.html)
 pub trait FromSqlRow<A, DB: Backend>: Sized {
-    /// The number of fields that this type will consume. Must be equal to
-    /// the number of times you would call `row.take()` in `build_from_row`
-    const FIELDS_NEEDED: usize = 1;
-
     /// See the trait documentation.
     fn build_from_row<T: Row<DB>>(row: &mut T) -> Result<Self>;
 }
@@ -336,6 +332,21 @@ pub trait FromSqlRow<A, DB: Backend>: Sized {
 #[doc(inline)]
 pub use diesel_derives::FromSqlRow;
 
+/// A marker trait indicating that the corresponding type is a statically sized row
+///
+/// This trait is implemented for all types provided by diesel, that
+/// implement `FromSqlRow`.
+///
+/// For dynamically sized types, like `diesel_dynamic_schema::DynamicRow`
+/// this traits should not be implemented.
+///
+/// This trait can be [derived](derive.FromSqlRow.html)
+pub trait StaticallySizedRow<A, DB: Backend>: FromSqlRow<A, DB> {
+    /// The number of fields that this type will consume. Must be equal to
+    /// the number of times you would call `row.take()` in `build_from_row`
+    const FIELD_COUNT: usize = 1;
+}
+
 // Reasons we can't write this:
 //
 // impl<T, ST, DB> FromSqlRow<ST, DB> for T
diff --git a/diesel/src/pg/types/primitives.rs b/diesel/src/pg/types/primitives.rs
index 79e147988..284ef0c24 100644
--- a/diesel/src/pg/types/primitives.rs
+++ b/diesel/src/pg/types/primitives.rs
@@ -7,10 +7,8 @@ use crate::sql_types;
 
 impl FromSql<sql_types::Bool, Pg> for bool {
     fn from_sql(bytes: Option<PgValue<'_>>) -> deserialize::Result<Self> {
-        match bytes {
-            Some(bytes) => Ok(bytes.as_bytes()[0] != 0),
-            None => Ok(false),
-        }
+        let bytes = not_none!(bytes);
+        Ok(bytes.as_bytes()[0] != 0)
     }
 }
 
diff --git a/diesel/src/pg/types/record.rs b/diesel/src/pg/types/record.rs
index 05fd2faab..5f0624a9e 100644
--- a/diesel/src/pg/types/record.rs
+++ b/diesel/src/pg/types/record.rs
@@ -73,8 +73,6 @@ macro_rules! tuple_impls {
         where
             Self: FromSql<Record<($($ST,)+)>, Pg>,
         {
-            const FIELDS_NEEDED: usize = 1;
-
             fn build_from_row<RowT: Row<Pg>>(row: &mut RowT) -> deserialize::Result<Self> {
                 Self::from_sql(row.take())
             }
diff --git a/diesel/src/row.rs b/diesel/src/row.rs
index e9231ab0f..4ad69eb52 100644
--- a/diesel/src/row.rs
+++ b/diesel/src/row.rs
@@ -19,15 +19,6 @@ pub trait Row<DB: Backend> {
     /// would all return `None`.
     fn next_is_null(&self, count: usize) -> bool;
 
-    /// Skips the next `count` columns. This method must be called if you are
-    /// choosing not to call `take` as a result of `next_is_null` returning
-    /// `true`.
-    fn advance(&mut self, count: usize) {
-        for _ in 0..count {
-            self.take();
-        }
-    }
-
     /// Number of columns in the current result set
     fn column_count(&self) -> usize;
 
diff --git a/diesel/src/sqlite/backend.rs b/diesel/src/sqlite/backend.rs
index 4e32334ad..1c6af1637 100644
--- a/diesel/src/sqlite/backend.rs
+++ b/diesel/src/sqlite/backend.rs
@@ -20,7 +20,7 @@ pub struct Sqlite;
 /// The variants of this struct determine what bytes are expected from
 /// `ToSql` impls.
 #[allow(missing_debug_implementations)]
-#[derive(Hash, PartialEq, Eq, Clone, Copy)]
+#[derive(Debug, Hash, PartialEq, Eq, Clone, Copy)]
 pub enum SqliteType {
     /// Bind using `sqlite3_bind_blob`
     Binary,
diff --git a/diesel/src/sqlite/connection/functions.rs b/diesel/src/sqlite/connection/functions.rs
index 551f1cfe1..8c7e5814d 100644
--- a/diesel/src/sqlite/connection/functions.rs
+++ b/diesel/src/sqlite/connection/functions.rs
@@ -3,7 +3,7 @@ extern crate libsqlite3_sys as ffi;
 use super::raw::RawConnection;
 use super::serialized_value::SerializedValue;
 use super::{Sqlite, SqliteAggregateFunction, SqliteValue};
-use crate::deserialize::{FromSqlRow, Queryable};
+use crate::deserialize::{FromSqlRow, Queryable, StaticallySizedRow};
 use crate::result::{DatabaseErrorKind, Error, QueryResult};
 use crate::row::Row;
 use crate::serialize::{IsNull, Output, ToSql};
@@ -18,10 +18,11 @@ pub fn register<ArgsSqlType, RetSqlType, Args, Ret, F>(
 where
     F: FnMut(&RawConnection, Args) -> Ret + Send + 'static,
     Args: Queryable<ArgsSqlType, Sqlite>,
+    Args::Row: StaticallySizedRow<ArgsSqlType, Sqlite>,
     Ret: ToSql<RetSqlType, Sqlite>,
     Sqlite: HasSqlType<RetSqlType>,
 {
-    let fields_needed = Args::Row::FIELDS_NEEDED;
+    let fields_needed = Args::Row::FIELD_COUNT;
     if fields_needed > 127 {
         return Err(Error::DatabaseError(
             DatabaseErrorKind::UnableToSendCommand,
@@ -46,10 +47,11 @@ pub fn register_aggregate<ArgsSqlType, RetSqlType, Args, Ret, A>(
 where
     A: SqliteAggregateFunction<Args, Output = Ret> + 'static + Send,
     Args: Queryable<ArgsSqlType, Sqlite>,
+    Args::Row: StaticallySizedRow<ArgsSqlType, Sqlite>,
     Ret: ToSql<RetSqlType, Sqlite>,
     Sqlite: HasSqlType<RetSqlType>,
 {
-    let fields_needed = Args::Row::FIELDS_NEEDED;
+    let fields_needed = Args::Row::FIELD_COUNT;
     if fields_needed > 127 {
         return Err(Error::DatabaseError(
             DatabaseErrorKind::UnableToSendCommand,
diff --git a/diesel/src/sqlite/connection/mod.rs b/diesel/src/sqlite/connection/mod.rs
index b200d15e5..5392bde45 100644
--- a/diesel/src/sqlite/connection/mod.rs
+++ b/diesel/src/sqlite/connection/mod.rs
@@ -17,7 +17,7 @@ use self::statement_iterator::*;
 use self::stmt::{Statement, StatementUse};
 use super::SqliteAggregateFunction;
 use crate::connection::*;
-use crate::deserialize::{Queryable, QueryableByName};
+use crate::deserialize::{Queryable, QueryableByName, StaticallySizedRow};
 use crate::query_builder::bind_collector::RawBytesBindCollector;
 use crate::query_builder::*;
 use crate::result::*;
@@ -228,6 +228,7 @@ impl SqliteConnection {
     where
         F: FnMut(Args) -> Ret + Send + 'static,
         Args: Queryable<ArgsSqlType, Sqlite>,
+        Args::Row: StaticallySizedRow<ArgsSqlType, Sqlite>,
         Ret: ToSql<RetSqlType, Sqlite>,
         Sqlite: HasSqlType<RetSqlType>,
     {
@@ -247,6 +248,7 @@ impl SqliteConnection {
     where
         A: SqliteAggregateFunction<Args, Output = Ret> + 'static + Send,
         Args: Queryable<ArgsSqlType, Sqlite>,
+        Args::Row: StaticallySizedRow<ArgsSqlType, Sqlite>,
         Ret: ToSql<RetSqlType, Sqlite>,
         Sqlite: HasSqlType<RetSqlType>,
     {
diff --git a/diesel/src/type_impls/option.rs b/diesel/src/type_impls/option.rs
index 10414eefe..5d11c6038 100644
--- a/diesel/src/type_impls/option.rs
+++ b/diesel/src/type_impls/option.rs
@@ -87,15 +87,11 @@ where
     DB: Backend,
     ST: NotNull,
 {
-    const FIELDS_NEEDED: usize = T::FIELDS_NEEDED;
-
     fn build_from_row<R: crate::row::Row<DB>>(row: &mut R) -> deserialize::Result<Self> {
-        let fields_needed = Self::FIELDS_NEEDED;
-        if row.next_is_null(fields_needed) {
-            row.advance(fields_needed);
-            Ok(None)
-        } else {
-            T::build_from_row(row).map(Some)
+        match T::build_from_row(row) {
+            Ok(v) => Ok(Some(v)),
+            Err(e) if e.is::<UnexpectedNullError>() => Ok(None),
+            Err(e) => Err(e),
         }
     }
 }
diff --git a/diesel/src/type_impls/tuples.rs b/diesel/src/type_impls/tuples.rs
index a544c10dc..e0fb8464c 100644
--- a/diesel/src/type_impls/tuples.rs
+++ b/diesel/src/type_impls/tuples.rs
@@ -2,7 +2,7 @@ use std::error::Error;
 
 use crate::associations::BelongsTo;
 use crate::backend::Backend;
-use crate::deserialize::{self, FromSqlRow, Queryable, QueryableByName};
+use crate::deserialize::{self, FromSqlRow, Queryable, QueryableByName, StaticallySizedRow};
 use crate::expression::{
     AppearsOnTable, AsExpression, AsExpressionList, Expression, SelectableExpression, ValidGrouping,
 };
@@ -42,13 +42,36 @@ macro_rules! tuple_impls {
                 __DB: Backend,
                 $($T: FromSqlRow<$ST, __DB>),+,
             {
-                const FIELDS_NEEDED: usize = $($T::FIELDS_NEEDED +)+ 0;
 
+                #[allow(non_snake_case)]
                 fn build_from_row<RowT: Row<__DB>>(row: &mut RowT) -> Result<Self, Box<dyn Error + Send + Sync>> {
-                    Ok(($($T::build_from_row(row)?,)+))
+                    // First call `build_from_row` for all tuple elements
+                    // to advance the row iterator correctly
+                    $(
+                        let $ST = $T::build_from_row(row);
+                    )+
+
+                    // Afterwards bubble up any possible errors
+                    Ok(($($ST?,)+))
+
+                    // As a note for anyone trying to optimize this:
+                    // We cannot just call something like `row.take()` for the
+                    // remaining tuple elements as we cannot know how much childs
+                    // they have on their own. For example one of them could be
+                    // `Option<(A, B)>`. Just calling `row.take()` as many times
+                    // as tuple elements are left would cause calling `row.take()`
+                    // at least one time less then required (as the child has two)
+                    // elements, not one.
                 }
             }
 
+            impl<$($T),+, $($ST),+, __DB > StaticallySizedRow<($($ST,)+), __DB> for ($($T,)+) where
+                __DB: Backend,
+                $($T: StaticallySizedRow<$ST, __DB>,)+
+            {
+                const FIELD_COUNT: usize = $($T::FIELD_COUNT +)+ 0;
+            }
+
             impl<$($T),+, $($ST),+, __DB> Queryable<($($ST,)+), __DB> for ($($T,)+) where
                 __DB: Backend,
                 $($T: Queryable<$ST, __DB>),+,
diff --git a/diesel_derives/src/from_sql_row.rs b/diesel_derives/src/from_sql_row.rs
index 823708cee..73fa7aabd 100644
--- a/diesel_derives/src/from_sql_row.rs
+++ b/diesel_derives/src/from_sql_row.rs
@@ -26,7 +26,7 @@ pub fn derive(mut item: syn::DeriveInput) -> Result<TokenStream, Diagnostic> {
     let (impl_generics, _, where_clause) = item.generics.split_for_impl();
 
     Ok(wrap_in_dummy_mod(quote! {
-        use diesel::deserialize::{self, FromSql, FromSqlRow, Queryable};
+        use diesel::deserialize::{self, FromSql, FromSqlRow, Queryable, StaticallySizedRow};
 
         impl #impl_generics FromSqlRow<__ST, __DB> for #struct_ty
         #where_clause
@@ -47,5 +47,9 @@ pub fn derive(mut item: syn::DeriveInput) -> Result<TokenStream, Diagnostic> {
                 row
             }
         }
+
+        impl #impl_generics StaticallySizedRow<__ST, __DB> for #struct_ty
+        #where_clause
+        {}
     }))
 }
diff --git a/diesel_derives/src/sql_function.rs b/diesel_derives/src/sql_function.rs
index a41af4f9f..7ffd525e1 100644
--- a/diesel_derives/src/sql_function.rs
+++ b/diesel_derives/src/sql_function.rs
@@ -141,7 +141,7 @@ pub(crate) fn expand(input: SqlFunctionDecl) -> Result<TokenStream, Diagnostic>
 
                 use diesel::sqlite::{Sqlite, SqliteConnection};
                 use diesel::serialize::ToSql;
-                use diesel::deserialize::Queryable;
+                use diesel::deserialize::{Queryable, StaticallySizedRow};
                 use diesel::sqlite::SqliteAggregateFunction;
                 use diesel::sql_types::IntoNullable;
             };
@@ -164,6 +164,7 @@ pub(crate) fn expand(input: SqlFunctionDecl) -> Result<TokenStream, Diagnostic>
                             A: SqliteAggregateFunction<(#(#arg_name,)*)> + Send + 'static,
                             A::Output: ToSql<#return_type, Sqlite>,
                             (#(#arg_name,)*): Queryable<(#(#arg_type,)*), Sqlite>,
+                            <(#(#arg_name,)*) as Queryable<(#(#arg_type,)*), Sqlite>>::Row: StaticallySizedRow<(#(#arg_type,)*), Sqlite>,
                         {
                             conn.register_aggregate_function::<(#(#arg_type,)*), #return_type, _, _, A>(#sql_name)
                         }
@@ -189,6 +190,7 @@ pub(crate) fn expand(input: SqlFunctionDecl) -> Result<TokenStream, Diagnostic>
                             A: SqliteAggregateFunction<#arg_name> + Send + 'static,
                             A::Output: ToSql<#return_type, Sqlite>,
                             #arg_name: Queryable<#arg_type, Sqlite>,
+                            <#arg_name as Queryable<#arg_type, Sqlite>>::Row: StaticallySizedRow<#arg_type, Sqlite>,
                             {
                                 conn.register_aggregate_function::<#arg_type, #return_type, _, _, A>(#sql_name)
                             }
@@ -219,7 +221,7 @@ pub(crate) fn expand(input: SqlFunctionDecl) -> Result<TokenStream, Diagnostic>
 
                 use diesel::sqlite::{Sqlite, SqliteConnection};
                 use diesel::serialize::ToSql;
-                use diesel::deserialize::Queryable;
+                use diesel::deserialize::{Queryable, StaticallySizedRow};
 
                 #[allow(dead_code)]
                 /// Registers an implementation for this function on the given connection
@@ -236,6 +238,7 @@ pub(crate) fn expand(input: SqlFunctionDecl) -> Result<TokenStream, Diagnostic>
                 where
                     F: Fn(#(#arg_name,)*) -> Ret + Send + 'static,
                     (#(#arg_name,)*): Queryable<(#(#arg_type,)*), Sqlite>,
+                    <(#(#arg_name,)*) as Queryable<(#(#arg_type,)*), Sqlite>>::Row: StaticallySizedRow<(#(#arg_type,)*), Sqlite>,
                     Ret: ToSql<#return_type, Sqlite>,
                 {
                     conn.register_sql_function::<(#(#arg_type,)*), #return_type, _, _, _>(
@@ -261,6 +264,7 @@ pub(crate) fn expand(input: SqlFunctionDecl) -> Result<TokenStream, Diagnostic>
                 where
                     F: FnMut(#(#arg_name,)*) -> Ret + Send + 'static,
                     (#(#arg_name,)*): Queryable<(#(#arg_type,)*), Sqlite>,
+                    <(#(#arg_name,)*) as Queryable<(#(#arg_type,)*), Sqlite>>::Row: StaticallySizedRow<(#(#arg_type,)*), Sqlite>,
                     Ret: ToSql<#return_type, Sqlite>,
                 {
                     conn.register_sql_function::<(#(#arg_type,)*), #return_type, _, _, _>(
diff --git a/diesel_tests/tests/joins.rs b/diesel_tests/tests/joins.rs
index c7d4d5a02..74e2810e2 100644
--- a/diesel_tests/tests/joins.rs
+++ b/diesel_tests/tests/joins.rs
@@ -300,6 +300,35 @@ fn select_right_side_with_nullable_column_first() {
     assert_eq!(expected_data, actual_data);
 }
 
+#[test]
+fn select_left_join_right_side_with_non_null_inside() {
+    let connection = connection_with_sean_and_tess_in_users_table();
+
+    connection
+        .execute(
+            "INSERT INTO posts (user_id, title, body) VALUES
+        (1, 'Hello', 'Content')
+    ",
+        )
+        .unwrap();
+
+    let expected_data = vec![
+        (None, 2),
+        (Some((1, "Hello".to_string(), "Hello".to_string())), 1),
+    ];
+
+    let source = users::table
+        .left_outer_join(posts::table)
+        .select((
+            (users::id, posts::title, posts::title).nullable(),
+            users::id,
+        ))
+        .order_by((users::id.desc(), posts::id.asc()));
+    let actual_data: Vec<_> = source.load(&connection).unwrap();
+
+    assert_eq!(expected_data, actual_data);
+}
+
 #[test]
 fn select_then_join() {
     use crate::schema::users::dsl::*;
