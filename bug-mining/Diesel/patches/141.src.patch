diff --git a/diesel/src/lib.rs b/diesel/src/lib.rs
index d8b7e3109..5ebd52509 100644
--- a/diesel/src/lib.rs
+++ b/diesel/src/lib.rs
@@ -267,7 +267,8 @@ pub use prelude::*;
 #[doc(inline)]
 pub use query_builder::debug_query;
 #[doc(inline)]
-pub use query_builder::functions::{delete, insert_into, replace_into, select, sql_query, update};
+pub use query_builder::functions::{delete, insert_into, insert_or_ignore_into, replace_into,
+                                   select, sql_query, update};
 pub use result::Error::NotFound;
 #[doc(inline)]
 pub use types::structs::data_types;
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index 4b11b374c..8eec359a3 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -2,7 +2,7 @@ use dsl::Select;
 use expression::Expression;
 use query_dsl::methods::SelectDsl;
 use super::delete_statement::DeleteStatement;
-use super::insert_statement::{Insert, Replace};
+use super::insert_statement::{Insert, InsertOrIgnore, Replace};
 use super::{IncompleteInsertStatement, IncompleteUpdateStatement, IntoUpdateTarget,
             SelectStatement, SqlQuery};
 
@@ -275,6 +275,58 @@ pub fn insert_into<T>(target: T) -> IncompleteInsertStatement<T, Insert> {
     IncompleteInsertStatement::new(target, Insert)
 }
 
+/// Creates an `INSERT [OR] IGNORE` statement.
+///
+/// If a constraint violation fails, the database will ignore the offending
+/// row and continue processing any subsequent rows. This function is only
+/// available with MySQL and SQLite.
+///
+/// With PostgreSQL, similar functionality is provided by [`on_conflict_do_nothing`].
+///
+/// [`on_conflict_do_nothing`]: query_builder/insert_statement/struct.InsertStatement.html#method.on_conflict_do_nothing
+///
+/// # Example
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # include!("../doctest_setup.rs");
+/// #
+/// # fn main() {
+/// #     run_test().unwrap();
+/// # }
+/// #
+/// # #[cfg(not(feature = "postgres"))]
+/// # fn run_test() -> QueryResult<()> {
+/// #     use schema::users::dsl::*;
+/// #     use diesel::{delete, insert_or_ignore_into};
+/// #
+/// #     let connection = establish_connection();
+/// #     diesel::delete(users).execute(&connection)?;
+/// insert_or_ignore_into(users)
+///     .values((id.eq(1), name.eq("Jim")))
+///     .execute(&connection)?;
+///
+/// insert_or_ignore_into(users)
+///     .values(&vec![
+///         (id.eq(1), name.eq("Sean")),
+///         (id.eq(2), name.eq("Tess")),
+///     ])
+///     .execute(&connection)?;
+///
+/// let names = users.select(name).order(id).load::<String>(&connection)?;
+/// assert_eq!(vec![String::from("Jim"), String::from("Tess")], names);
+/// #     Ok(())
+/// # }
+/// #
+/// # #[cfg(feature = "postgres")]
+/// # fn run_test() -> QueryResult<()> {
+/// #     Ok(())
+/// # }
+/// ```
+pub fn insert_or_ignore_into<T>(target: T) -> IncompleteInsertStatement<T, InsertOrIgnore> {
+    IncompleteInsertStatement::new(target, InsertOrIgnore)
+}
+
 /// Creates a bare select statement, with no from clause. Primarily used for
 /// testing diesel itself, but likely useful for third party crates as well. The
 /// given expressions must be selectable from anywhere.
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index 3ea14a511..7e1003424 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -281,6 +281,28 @@ impl<DB: Backend> QueryFragment<DB> for Insert {
 
 impl_query_id!(Insert);
 
+#[derive(Debug, Copy, Clone)]
+#[doc(hidden)]
+pub struct InsertOrIgnore;
+
+#[cfg(feature = "sqlite")]
+impl QueryFragment<Sqlite> for InsertOrIgnore {
+    fn walk_ast(&self, mut out: AstPass<Sqlite>) -> QueryResult<()> {
+        out.push_sql("INSERT OR IGNORE");
+        Ok(())
+    }
+}
+
+#[cfg(feature = "mysql")]
+impl QueryFragment<Mysql> for InsertOrIgnore {
+    fn walk_ast(&self, mut out: AstPass<Mysql>) -> QueryResult<()> {
+        out.push_sql("INSERT IGNORE");
+        Ok(())
+    }
+}
+
+impl_query_id!(InsertOrIgnore);
+
 #[derive(Debug, Copy, Clone)]
 #[doc(hidden)]
 pub struct Replace;
diff --git a/diesel_compile_tests/tests/compile-fail/sqlite_insert_or_ignore_cannot_be_used_on_pg.rs b/diesel_compile_tests/tests/compile-fail/sqlite_insert_or_ignore_cannot_be_used_on_pg.rs
new file mode 100644
index 000000000..9751707f7
--- /dev/null
+++ b/diesel_compile_tests/tests/compile-fail/sqlite_insert_or_ignore_cannot_be_used_on_pg.rs
@@ -0,0 +1,24 @@
+#[macro_use] extern crate diesel;
+
+use diesel::*;
+
+table! {
+    users {
+        id -> Integer,
+    }
+}
+
+#[derive(Insertable)]
+#[table_name="users"]
+struct User {
+    id: i32,
+}
+
+fn main() {
+    let connection = PgConnection::establish("").unwrap();
+    insert_or_ignore_into(users::table)
+        .values(users::id.eq(1))
+        .execute(&connection)
+        //~^ ERROR E0277
+        .unwrap();
+}
