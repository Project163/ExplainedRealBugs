diff --git a/CHANGELOG.md b/CHANGELOG.md
index ca6b02387..b5bf488e9 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -41,6 +41,12 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 [transaction-0.11.0]: http://docs.diesel.rs/diesel/connection/trait.Connection.html#method.transaction
 
+* The way tuples of columns from the right side of left outer joins interact
+  with `.select` has changed. If you are deserializing into an option of a tuple
+  (instead of a tuple of options), you will need to explicitly call
+  `.nullable()`. (e.g. `.select(users::name, (posts::title,
+  posts::body).nullable())`)
+
 ### Removed
 
 * `result::TransactionError`
diff --git a/diesel/src/expression/aliased.rs b/diesel/src/expression/aliased.rs
index d6eace25d..20f3f3159 100644
--- a/diesel/src/expression/aliased.rs
+++ b/diesel/src/expression/aliased.rs
@@ -20,9 +20,6 @@ impl<'a, Expr> Aliased<'a, Expr> {
     }
 }
 
-#[derive(Debug, Copy, Clone)]
-pub struct FromEverywhere;
-
 impl<'a, T> Expression for Aliased<'a, T> where
     T: Expression,
 {
@@ -57,7 +54,9 @@ impl<'a, T> QueryId for Aliased<'a, T> {
 // FIXME This is incorrect, should only be selectable from WithQuerySource
 impl<'a, T, QS> SelectableExpression<QS> for Aliased<'a, T> where
     Aliased<'a, T>: Expression,
+    T: SelectableExpression<QS>,
 {
+    type SqlTypeForSelect = T::SqlTypeForSelect;
 }
 
 impl<'a, T: Expression + Copy> QuerySource for Aliased<'a, T> {
diff --git a/diesel/src/expression/array_comparison.rs b/diesel/src/expression/array_comparison.rs
index 15e33601e..5a06df87d 100644
--- a/diesel/src/expression/array_comparison.rs
+++ b/diesel/src/expression/array_comparison.rs
@@ -57,6 +57,7 @@ impl<T, U, QS> SelectableExpression<QS> for In<T, U> where
     T: SelectableExpression<QS>,
     U: SelectableExpression<QS>,
 {
+    type SqlTypeForSelect = Self::SqlType;
 }
 
 impl<T, U, QS> SelectableExpression<QS> for NotIn<T, U> where
@@ -64,6 +65,7 @@ impl<T, U, QS> SelectableExpression<QS> for NotIn<T, U> where
     T: SelectableExpression<QS>,
     U: SelectableExpression<QS>,
 {
+    type SqlTypeForSelect = Self::SqlType;
 }
 
 impl<T, U> NonAggregate for In<T, U> where
@@ -163,9 +165,10 @@ pub trait MaybeEmpty {
     fn is_empty(&self) -> bool;
 }
 
-impl<ST, S, F, W, O, L, Of> AsInExpression<ST>
-    for SelectStatement<ST, S, F, W, O, L, Of> where
-        Subselect<SelectStatement<ST, S, F, W, O, L, Of>, ST>: Expression<SqlType=ST>,
+impl<ST, S, F, W, O, L, Of, G> AsInExpression<ST>
+    for SelectStatement<S, F, W, O, L, Of, G> where
+        SelectStatement<S, F, W, O, L, Of, G>: Query<SqlType=ST>,
+        Subselect<SelectStatement<S, F, W, O, L, Of>, ST>: Expression,
 {
     type InExpression = Subselect<Self, ST>;
 
@@ -202,6 +205,7 @@ impl<T, QS> SelectableExpression<QS> for Many<T> where
     Many<T>: Expression,
     T: SelectableExpression<QS>,
 {
+    type SqlTypeForSelect = T::SqlTypeForSelect;
 }
 
 impl<T, DB> QueryFragment<DB> for Many<T> where
@@ -251,6 +255,7 @@ impl<T, ST, QS> SelectableExpression<QS> for Subselect<T, ST> where
     Subselect<T, ST>: Expression,
     T: Query,
 {
+    type SqlTypeForSelect = ST;
 }
 
 impl<T, ST, DB> QueryFragment<DB> for Subselect<T, ST> where
diff --git a/diesel/src/expression/bound.rs b/diesel/src/expression/bound.rs
index d4e3587fa..5ff48d4e7 100644
--- a/diesel/src/expression/bound.rs
+++ b/diesel/src/expression/bound.rs
@@ -66,6 +66,7 @@ impl<T: QueryId, U> QueryId for Bound<T, U> {
 impl<T, U, QS> SelectableExpression<QS> for Bound<T, U> where
     Bound<T, U>: Expression,
 {
+    type SqlTypeForSelect = T;
 }
 
 impl<T, U> NonAggregate for Bound<T, U> where
diff --git a/diesel/src/expression/coerce.rs b/diesel/src/expression/coerce.rs
index 665367a04..a6735bc94 100644
--- a/diesel/src/expression/coerce.rs
+++ b/diesel/src/expression/coerce.rs
@@ -41,6 +41,7 @@ impl<T, ST> Expression for Coerce<T, ST> where
 impl<T, ST, QS> SelectableExpression<QS> for Coerce<T, ST> where
     T: SelectableExpression<QS>,
 {
+    type SqlTypeForSelect = Self::SqlType;
 }
 
 impl<T, ST, DB> QueryFragment<DB> for Coerce<T, ST> where
diff --git a/diesel/src/expression/count.rs b/diesel/src/expression/count.rs
index 80d48a5c2..691d02d33 100644
--- a/diesel/src/expression/count.rs
+++ b/diesel/src/expression/count.rs
@@ -80,6 +80,7 @@ impl<T: QueryFragment<DB>, DB: Backend> QueryFragment<DB> for Count<T> {
 impl_query_id!(Count<T>);
 
 impl<T: Expression, QS> SelectableExpression<QS> for Count<T> {
+    type SqlTypeForSelect = BigInt;
 }
 
 #[derive(Debug, Clone, Copy)]
@@ -106,6 +107,7 @@ impl<DB: Backend> QueryFragment<DB> for CountStar {
 }
 
 impl<QS> SelectableExpression<QS> for CountStar {
+    type SqlTypeForSelect = BigInt;
 }
 
 impl_query_id!(CountStar);
diff --git a/diesel/src/expression/exists.rs b/diesel/src/expression/exists.rs
index f0047369f..79d569816 100644
--- a/diesel/src/expression/exists.rs
+++ b/diesel/src/expression/exists.rs
@@ -52,6 +52,7 @@ impl<T> Expression for Exists<T> where
 impl<T, QS> SelectableExpression<QS> for Exists<T> where
     Exists<T>: Expression,
 {
+    type SqlTypeForSelect = Bool;
 }
 
 impl<T> NonAggregate for Exists<T> {
diff --git a/diesel/src/expression/expression_methods/global_expression_methods.rs b/diesel/src/expression/expression_methods/global_expression_methods.rs
index 95f7e6ac5..a462a3541 100644
--- a/diesel/src/expression/expression_methods/global_expression_methods.rs
+++ b/diesel/src/expression/expression_methods/global_expression_methods.rs
@@ -307,7 +307,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// # fn main() {
     /// #     use self::users::dsl::*;
     /// #     let order = "name";
-    /// let ordering: Box<BoxableExpression<users, (), DB, SqlType=()>> =
+    /// let ordering: Box<BoxableExpression<users, DB, SqlType=(), SqlTypeForSelect=()>> =
     ///     if order == "name" {
     ///         Box::new(name.desc())
     ///     } else {
diff --git a/diesel/src/expression/functions/aggregate_folding.rs b/diesel/src/expression/functions/aggregate_folding.rs
index 7cf24130b..bd5a825cb 100644
--- a/diesel/src/expression/functions/aggregate_folding.rs
+++ b/diesel/src/expression/functions/aggregate_folding.rs
@@ -55,6 +55,7 @@ macro_rules! fold_function {
             $type_name<T>: Expression,
             T: SelectableExpression<QS>,
         {
+            type SqlTypeForSelect = Self::SqlType;
         }
     }
 }
diff --git a/diesel/src/expression/functions/aggregate_ordering.rs b/diesel/src/expression/functions/aggregate_ordering.rs
index c2f950700..19d05466d 100644
--- a/diesel/src/expression/functions/aggregate_ordering.rs
+++ b/diesel/src/expression/functions/aggregate_ordering.rs
@@ -54,6 +54,7 @@ macro_rules! ord_function {
             $type_name<T>: Expression,
             T: SelectableExpression<QS>,
         {
+            type SqlTypeForSelect = Self::SqlType;
         }
     }
 }
diff --git a/diesel/src/expression/functions/date_and_time.rs b/diesel/src/expression/functions/date_and_time.rs
index 01dd04964..e1c091476 100644
--- a/diesel/src/expression/functions/date_and_time.rs
+++ b/diesel/src/expression/functions/date_and_time.rs
@@ -15,6 +15,7 @@ impl Expression for now {
 }
 
 impl<QS> SelectableExpression<QS> for now {
+    type SqlTypeForSelect = Timestamp;
 }
 
 impl NonAggregate for now {
diff --git a/diesel/src/expression/functions/mod.rs b/diesel/src/expression/functions/mod.rs
index b80839cb6..0d49dbf6f 100644
--- a/diesel/src/expression/functions/mod.rs
+++ b/diesel/src/expression/functions/mod.rs
@@ -65,6 +65,7 @@ macro_rules! sql_function_body {
             $($arg_name: $crate::expression::SelectableExpression<QS>,)*
             $struct_name<$($arg_name),*>: $crate::expression::Expression,
         {
+            type SqlTypeForSelect = Self::SqlType;
         }
 
         #[allow(non_camel_case_types)]
@@ -132,6 +133,7 @@ macro_rules! no_arg_sql_function_body_except_to_sql {
         }
 
         impl<QS> $crate::expression::SelectableExpression<QS> for $type_name {
+            type SqlTypeForSelect = $return_type;
         }
 
         impl $crate::expression::NonAggregate for $type_name {
diff --git a/diesel/src/expression/grouped.rs b/diesel/src/expression/grouped.rs
index 30f8bcd45..9ef0688d3 100644
--- a/diesel/src/expression/grouped.rs
+++ b/diesel/src/expression/grouped.rs
@@ -34,6 +34,7 @@ impl<T, QS> SelectableExpression<QS> for Grouped<T> where
     T: SelectableExpression<QS>,
     Grouped<T>: Expression,
 {
+    type SqlTypeForSelect = T::SqlTypeForSelect;
 }
 
 impl<T: NonAggregate> NonAggregate for Grouped<T> where
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index b7d97661b..7b6857d75 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -104,29 +104,30 @@ impl<T: Expression> AsExpression<T::SqlType> for T {
     }
 }
 
-/// Indicates that an expression can be selected from a source. The second type
-/// argument is optional, but is used to indicate that the right side of a left
-/// outer join is nullable, even if it wasn't before.
+/// Indicates that an expression can be selected from a source. The associated
+/// type is usually the same as `Expression::SqlType`, but is used to indicate
+/// that a column is always nullable when it appears on the right side of a left
+/// outer join, even if it wasn't nullable to begin with.
 ///
 /// Columns will implement this for their table. Certain special types, like
 /// `CountStar` and `Bound` will implement this for all sources. All other
 /// expressions will inherit this from their children.
-pub trait SelectableExpression<
-    QS,
-    Type = <Self as Expression>::SqlType,
->: Expression {
+pub trait SelectableExpression<QS>: Expression {
+    type SqlTypeForSelect;
 }
 
-impl<T: ?Sized, ST, QS> SelectableExpression<QS, ST> for Box<T> where
-    T: SelectableExpression<QS, ST>,
+impl<T: ?Sized, QS> SelectableExpression<QS> for Box<T> where
+    T: SelectableExpression<QS>,
     Box<T>: Expression,
 {
+    type SqlTypeForSelect = T::SqlTypeForSelect;
 }
 
-impl<'a, T: ?Sized, ST, QS> SelectableExpression<QS, ST> for &'a T where
-    T: SelectableExpression<QS, ST>,
+impl<'a, T: ?Sized, QS> SelectableExpression<QS> for &'a T where
+    T: SelectableExpression<QS>,
     &'a T: Expression,
 {
+    type SqlTypeForSelect = T::SqlTypeForSelect;
 }
 
 /// Marker trait to indicate that an expression does not include any aggregate
@@ -147,24 +148,24 @@ use query_builder::{QueryFragment, QueryId};
 /// Helper trait used when boxing expressions. This exists to work around the
 /// fact that Rust will not let us use non-core types as bounds on a trait
 /// object (you could not return `Box<Expression+NonAggregate>`)
-pub trait BoxableExpression<QS, ST, DB> where
+pub trait BoxableExpression<QS, DB> where
     DB: Backend,
     Self: Expression,
-    Self: SelectableExpression<QS, ST>,
+    Self: SelectableExpression<QS>,
     Self: NonAggregate,
     Self: QueryFragment<DB>,
 {}
 
-impl<QS, T, ST, DB> BoxableExpression<QS, ST, DB> for T where
+impl<QS, T, DB> BoxableExpression<QS, DB> for T where
     DB: Backend,
     T: Expression,
-    T: SelectableExpression<QS, ST>,
+    T: SelectableExpression<QS>,
     T: NonAggregate,
     T: QueryFragment<DB>,
 {
 }
 
-impl<QS, ST, DB> QueryId for BoxableExpression<QS, ST, DB, SqlType=ST> {
+impl<QS, ST, STS, DB> QueryId for BoxableExpression<QS, DB, SqlType=ST, SqlTypeForSelect=STS> {
     type QueryId = ();
 
     fn has_static_query_id() -> bool {
diff --git a/diesel/src/expression/nullable.rs b/diesel/src/expression/nullable.rs
index 0ebea3f11..7095eeea1 100644
--- a/diesel/src/expression/nullable.rs
+++ b/diesel/src/expression/nullable.rs
@@ -37,10 +37,14 @@ impl<T, DB> QueryFragment<DB> for Nullable<T> where
     }
 }
 
+/// This impl relies on the fact that the only time `T::SqlType` will differ
+/// from `T::SqlTypeForSelect` is to make the right side of a left join become
+/// nullable.
 impl<T, QS> SelectableExpression<QS> for Nullable<T> where
     T: SelectableExpression<QS>,
     Nullable<T>: Expression,
 {
+    type SqlTypeForSelect = Self::SqlType;
 }
 
 impl<T: QueryId> QueryId for Nullable<T> {
diff --git a/diesel/src/expression/ops/numeric.rs b/diesel/src/expression/ops/numeric.rs
index 1f6522fa1..ed86bc104 100644
--- a/diesel/src/expression/ops/numeric.rs
+++ b/diesel/src/expression/ops/numeric.rs
@@ -59,6 +59,7 @@ macro_rules! numeric_operation {
             Rhs: SelectableExpression<QS>,
             $name<Lhs, Rhs>: Expression,
         {
+            type SqlTypeForSelect = Self::SqlType;
         }
 
         impl<Lhs, Rhs> NonAggregate for $name<Lhs, Rhs> where
diff --git a/diesel/src/expression/predicates.rs b/diesel/src/expression/predicates.rs
index c1fb0ab2a..1cfd96c59 100644
--- a/diesel/src/expression/predicates.rs
+++ b/diesel/src/expression/predicates.rs
@@ -30,6 +30,7 @@ macro_rules! infix_predicate_body {
             T: $crate::expression::SelectableExpression<QS>,
             U: $crate::expression::SelectableExpression<QS>,
         {
+            type SqlTypeForSelect = Self::SqlType;
         }
 
         impl<T, U> $crate::expression::NonAggregate for $name<T, U> where
@@ -219,6 +220,7 @@ macro_rules! postfix_predicate_body {
         impl<T, QS> $crate::expression::SelectableExpression<QS> for $name<T> where
             T: $crate::expression::SelectableExpression<QS>,
         {
+            type SqlTypeForSelect = Self::SqlType;
         }
 
         impl<T> $crate::expression::NonAggregate for $name<T> where
diff --git a/diesel/src/expression/sql_literal.rs b/diesel/src/expression/sql_literal.rs
index 7889786f2..1e98109c8 100644
--- a/diesel/src/expression/sql_literal.rs
+++ b/diesel/src/expression/sql_literal.rs
@@ -51,6 +51,7 @@ impl<ST> Query for SqlLiteral<ST> {
 }
 
 impl<QS, ST> SelectableExpression<QS> for SqlLiteral<ST> {
+    type SqlTypeForSelect = ST;
 }
 
 impl<ST> NonAggregate for SqlLiteral<ST> {
diff --git a/diesel/src/macros/mod.rs b/diesel/src/macros/mod.rs
index 243c7e178..4dbb0d991 100644
--- a/diesel/src/macros/mod.rs
+++ b/diesel/src/macros/mod.rs
@@ -31,19 +31,24 @@ macro_rules! __diesel_column {
 
         impl_query_id!($column_name);
 
-        impl $crate::expression::SelectableExpression<$($table)::*> for $column_name {}
+        impl $crate::expression::SelectableExpression<$($table)::*> for $column_name {
+            type SqlTypeForSelect = $Type;
+        }
 
-        impl<'a, ST, Left, Right> SelectableExpression<
-            $crate::WithQuerySource<'a, Left, Right>, ST> for $column_name where
-            $column_name: SelectableExpression<Left, ST>
+        impl<'a, Left, Right> SelectableExpression<
+            $crate::WithQuerySource<'a, Left, Right>,
+        > for $column_name where
+            $column_name: SelectableExpression<Left>,
         {
+            type SqlTypeForSelect = $Type;
         }
 
-        impl<ST, Source, Predicate> SelectableExpression<
-            $crate::query_source::filter::FilteredQuerySource<Source, Predicate>, ST>
-            for $column_name where
-                $column_name: SelectableExpression<Source, ST>
+        impl<Source, Predicate> SelectableExpression<
+            $crate::query_source::filter::FilteredQuerySource<Source, Predicate>,
+        > for $column_name where
+            $column_name: SelectableExpression<Source>,
         {
+            type SqlTypeForSelect = $Type;
         }
 
         impl $crate::expression::NonAggregate for $column_name {}
@@ -301,7 +306,7 @@ macro_rules! table_body {
 
             impl AsQuery for table {
                 type SqlType = SqlType;
-                type Query = SelectStatement<SqlType, ($($column_name,)+), Self>;
+                type Query = SelectStatement<($($column_name,)+), Self>;
 
                 fn as_query(self) -> Self::Query {
                     SelectStatement::simple(all_columns, self)
@@ -376,7 +381,9 @@ macro_rules! table_body {
                     }
                 }
 
-                impl SelectableExpression<table> for star {}
+                impl SelectableExpression<table> for star {
+                    type SqlTypeForSelect = Self::SqlType;
+                }
 
                 $(__diesel_column!(table, $column_name -> $column_ty);)+
             }
@@ -485,26 +492,29 @@ macro_rules! select_column_inner {
             $crate::query_source::InnerJoinSource<$child, $parent>,
         > for $column
         {
+            type SqlTypeForSelect = <Self as $crate::Expression>::SqlType;
         }
 
         impl $crate::expression::SelectableExpression<
             $crate::query_source::InnerJoinSource<$parent, $child>,
         > for $column
         {
+            type SqlTypeForSelect = <Self as $crate::Expression>::SqlType;
         }
 
         impl $crate::expression::SelectableExpression<
             $crate::query_source::LeftOuterJoinSource<$child, $parent>,
-            <<$column as $crate::Expression>::SqlType
-                as $crate::types::IntoNullable>::Nullable,
         > for $column
         {
+            type SqlTypeForSelect = <<Self as $crate::Expression>::SqlType
+                as $crate::types::IntoNullable>::Nullable;
         }
 
         impl $crate::expression::SelectableExpression<
             $crate::query_source::LeftOuterJoinSource<$parent, $child>,
         > for $column
         {
+            type SqlTypeForSelect = <Self as $crate::Expression>::SqlType;
         }
     }
 }
diff --git a/diesel/src/pg/expression/array_comparison.rs b/diesel/src/pg/expression/array_comparison.rs
index 7bd541a1e..728824e4c 100644
--- a/diesel/src/pg/expression/array_comparison.rs
+++ b/diesel/src/pg/expression/array_comparison.rs
@@ -143,6 +143,7 @@ impl<Expr, QS> SelectableExpression<QS> for Any<Expr> where
     Any<Expr>: Expression,
     Expr: SelectableExpression<QS>,
 {
+    type SqlTypeForSelect = Self::SqlType;
 }
 
 impl<Expr> NonAggregate for Any<Expr> where
@@ -216,6 +217,7 @@ impl<Expr, QS> SelectableExpression<QS> for All<Expr> where
     All<Expr>: Expression,
     Expr: SelectableExpression<QS>,
 {
+    type SqlTypeForSelect = Self::SqlType;
 }
 
 impl<Expr> NonAggregate for All<Expr> where
diff --git a/diesel/src/pg/expression/date_and_time.rs b/diesel/src/pg/expression/date_and_time.rs
index 1bb5e4cd6..bff5287b2 100644
--- a/diesel/src/pg/expression/date_and_time.rs
+++ b/diesel/src/pg/expression/date_and_time.rs
@@ -88,5 +88,7 @@ impl<Ts, Tz> QueryFragment<Debug> for AtTimeZone<Ts, Tz> where
 impl<Ts, Tz, Qs> SelectableExpression<Qs> for AtTimeZone<Ts, Tz> where
     AtTimeZone<Ts, Tz>: Expression,
     Ts: SelectableExpression<Qs>,
-    Tz: SelectableExpression<Tz>,
-{}
+    Tz: SelectableExpression<Qs>,
+{
+    type SqlTypeForSelect = Self::SqlType;
+}
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index ba605e852..e24592b5f 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -115,7 +115,7 @@ pub fn insert<T: ?Sized>(records: &T) -> IncompleteInsertStatement<&T, Insert> {
 /// Creates a bare select statement, with no from clause. Primarily used for
 /// testing diesel itself, but likely useful for third party crates as well. The
 /// given expressions must be selectable from anywhere.
-pub fn select<T>(expression: T) -> SelectStatement<T::SqlType, T, ()> where
+pub fn select<T>(expression: T) -> SelectStatement<T, ()> where
     T: Expression,
 {
     SelectStatement::simple(expression, ())
diff --git a/diesel/src/query_builder/select_statement/boxed.rs b/diesel/src/query_builder/select_statement/boxed.rs
index d7aed6c69..04727588e 100644
--- a/diesel/src/query_builder/select_statement/boxed.rs
+++ b/diesel/src/query_builder/select_statement/boxed.rs
@@ -20,7 +20,7 @@ pub struct BoxedSelectStatement<'a, ST, QS, DB> {
     order: Box<QueryFragment<DB> + 'a>,
     limit: Box<QueryFragment<DB> + 'a>,
     offset: Box<QueryFragment<DB> + 'a>,
-    _marker: PhantomData<(ST, DB)>,
+    _marker: PhantomData<ST>,
 }
 
 impl<'a, ST, QS, DB> BoxedSelectStatement<'a, ST, QS, DB> {
@@ -153,12 +153,12 @@ impl<'a, ST, QS, DB> QueryId for BoxedSelectStatement<'a, ST, QS, DB> {
     }
 }
 
-impl<'a, ST, QS, DB, Type, Selection> SelectDsl<Selection, Type>
+impl<'a, ST, QS, DB, Selection> SelectDsl<Selection, Selection::SqlTypeForSelect>
     for BoxedSelectStatement<'a, ST, QS, DB> where
-        DB: Backend + HasSqlType<Type>,
-        Selection: SelectableExpression<QS, Type> + QueryFragment<DB> + 'a,
+        DB: Backend + HasSqlType<Selection::SqlTypeForSelect>,
+        Selection: SelectableExpression<QS> + QueryFragment<DB> + 'a,
 {
-    type Output = BoxedSelectStatement<'a, Type, QS, DB>;
+    type Output = BoxedSelectStatement<'a, Selection::SqlTypeForSelect, QS, DB>;
 
     fn select(self, selection: Selection) -> Self::Output {
         BoxedSelectStatement::new(
diff --git a/diesel/src/query_builder/select_statement/dsl_impls.rs b/diesel/src/query_builder/select_statement/dsl_impls.rs
index 2d26b740b..737f0372c 100644
--- a/diesel/src/query_builder/select_statement/dsl_impls.rs
+++ b/diesel/src/query_builder/select_statement/dsl_impls.rs
@@ -13,12 +13,12 @@ use query_dsl::boxed_dsl::InternalBoxedDsl;
 use super::BoxedSelectStatement;
 use types::{self, Bool};
 
-impl<ST, S, F, D, W, O, L, Of, G, Selection, Type> SelectDsl<Selection, Type>
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
+impl<S, F, D, W, O, L, Of, G, Selection, Type> SelectDsl<Selection, Type>
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
         Selection: Expression,
-        SelectStatement<Type, Selection, F, D, W, O, L, Of, G>: Query<SqlType=Type>,
+        SelectStatement<Selection, F, D, W, O, L, Of, G>: Query<SqlType=Type>,
 {
-    type Output = SelectStatement<Type, Selection, F, D, W, O, L, Of, G>;
+    type Output = SelectStatement<Selection, F, D, W, O, L, Of, G>;
 
     fn select(self, selection: Selection) -> Self::Output {
         SelectStatement::new(
@@ -35,11 +35,11 @@ impl<ST, S, F, D, W, O, L, Of, G, Selection, Type> SelectDsl<Selection, Type>
 }
 
 impl<ST, S, F, D, W, O, L, Of, G> DistinctDsl
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        SelectStatement<ST, S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
-        SelectStatement<ST, S, F, DistinctClause, W, O, L, Of, G>: AsQuery<SqlType=ST>,
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        SelectStatement<S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
+        SelectStatement<S, F, DistinctClause, W, O, L, Of, G>: AsQuery<SqlType=ST>,
 {
-    type Output = SelectStatement<ST, S, F, DistinctClause, W, O, L, Of, G>;
+    type Output = SelectStatement<S, F, DistinctClause, W, O, L, Of, G>;
 
     fn distinct(self) -> Self::Output {
         SelectStatement::new(
@@ -56,13 +56,13 @@ impl<ST, S, F, D, W, O, L, Of, G> DistinctDsl
 }
 
 impl<ST, S, F, D, W, O, L, Of, G, Predicate> FilterDsl<Predicate>
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        SelectStatement<ST, S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
-        SelectStatement<ST, S, F, D, W::Output, O, L, Of, G>: Query<SqlType=ST>,
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        SelectStatement<S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
+        SelectStatement<S, F, D, W::Output, O, L, Of, G>: Query<SqlType=ST>,
         Predicate: SelectableExpression<F, SqlType=Bool> + NonAggregate,
         W: WhereAnd<Predicate>,
 {
-    type Output = SelectStatement<ST, S, F, D, W::Output, O, L, Of, G>;
+    type Output = SelectStatement<S, F, D, W::Output, O, L, Of, G>;
 
     fn filter(self, predicate: Predicate) -> Self::Output {
         SelectStatement::new(
@@ -79,12 +79,12 @@ impl<ST, S, F, D, W, O, L, Of, G, Predicate> FilterDsl<Predicate>
 }
 
 impl<ST, S, F, D, W, O, L, Of, G, Expr> OrderDsl<Expr>
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
         Expr: SelectableExpression<F>,
-        SelectStatement<ST, S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
-        SelectStatement<ST, S, F, D, W, OrderClause<Expr>, L, Of, G>: AsQuery<SqlType=ST>,
+        SelectStatement<S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
+        SelectStatement<S, F, D, W, OrderClause<Expr>, L, Of, G>: AsQuery<SqlType=ST>,
 {
-    type Output = SelectStatement<ST, S, F, D, W, OrderClause<Expr>, L, Of, G>;
+    type Output = SelectStatement<S, F, D, W, OrderClause<Expr>, L, Of, G>;
 
     fn order(self, expr: Expr) -> Self::Output {
         let order = OrderClause(expr);
@@ -105,11 +105,11 @@ impl<ST, S, F, D, W, O, L, Of, G, Expr> OrderDsl<Expr>
 pub type Limit = <i64 as AsExpression<types::BigInt>>::Expression;
 
 impl<ST, S, F, D, W, O, L, Of, G> LimitDsl
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        SelectStatement<ST, S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
-        SelectStatement<ST, S, F, D, W, O, LimitClause<Limit>, Of, G>: Query<SqlType=ST>,
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        SelectStatement<S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
+        SelectStatement<S, F, D, W, O, LimitClause<Limit>, Of, G>: Query<SqlType=ST>,
 {
-    type Output = SelectStatement<ST, S, F, D, W, O, LimitClause<Limit>, Of, G>;
+    type Output = SelectStatement<S, F, D, W, O, LimitClause<Limit>, Of, G>;
 
     fn limit(self, limit: i64) -> Self::Output {
         let limit_clause = LimitClause(AsExpression::<types::BigInt>::as_expression(limit));
@@ -130,11 +130,11 @@ impl<ST, S, F, D, W, O, L, Of, G> LimitDsl
 pub type Offset = Limit;
 
 impl<ST, S, F, D, W, O, L, Of, G> OffsetDsl
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        SelectStatement<ST, S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
-        SelectStatement<ST, S, F, D, W, O, L, OffsetClause<Offset>, G>: AsQuery<SqlType=ST>,
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        SelectStatement<S, F, D, W, O, L, Of, G>: AsQuery<SqlType=ST>,
+        SelectStatement<S, F, D, W, O, L, OffsetClause<Offset>, G>: AsQuery<SqlType=ST>,
 {
-    type Output = SelectStatement<ST, S, F, D, W, O, L, OffsetClause<Offset>, G>;
+    type Output = SelectStatement<S, F, D, W, O, L, OffsetClause<Offset>, G>;
 
     fn offset(self, offset: i64) -> Self::Output {
         let offset_clause = OffsetClause(AsExpression::<types::BigInt>::as_expression(offset));
@@ -151,11 +151,11 @@ impl<ST, S, F, D, W, O, L, Of, G> OffsetDsl
     }
 }
 
-impl<'a, ST, S, F, D, W, O, L, Of, G, Expr> WithDsl<'a, Expr>
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        SelectStatement<ST, S, WithQuerySource<'a, F, Expr>, D, W, O, L, Of, G>: Query,
+impl<'a, S, F, D, W, O, L, Of, G, Expr> WithDsl<'a, Expr>
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        SelectStatement<S, WithQuerySource<'a, F, Expr>, D, W, O, L, Of, G>: Query,
 {
-    type Output = SelectStatement<ST, S, WithQuerySource<'a, F, Expr>, D, W, O, L, Of, G>;
+    type Output = SelectStatement<S, WithQuerySource<'a, F, Expr>, D, W, O, L, Of, G>;
 
     fn with(self, expr: Aliased<'a, Expr>) -> Self::Output {
         let source = WithQuerySource::new(self.from, expr);
@@ -172,12 +172,12 @@ impl<'a, ST, S, F, D, W, O, L, Of, G, Expr> WithDsl<'a, Expr>
     }
 }
 
-impl<ST, S, F, D, W, O, L, Of, G, Expr> GroupByDsl<Expr>
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        SelectStatement<ST, S, F, D, W, O, L, Of, GroupByClause<Expr>>: Query,
+impl<S, F, D, W, O, L, Of, G, Expr> GroupByDsl<Expr>
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        SelectStatement<S, F, D, W, O, L, Of, GroupByClause<Expr>>: Query,
         Expr: Expression,
 {
-    type Output = SelectStatement<ST, S, F, D, W, O, L, Of, GroupByClause<Expr>>;
+    type Output = SelectStatement<S, F, D, W, O, L, Of, GroupByClause<Expr>>;
 
     fn group_by(self, expr: Expr) -> Self::Output {
         let group_by = GroupByClause(expr);
@@ -194,17 +194,17 @@ impl<ST, S, F, D, W, O, L, Of, G, Expr> GroupByDsl<Expr>
     }
 }
 
-impl<'a, ST, S, F, D, W, O, L, Of, G, DB> InternalBoxedDsl<'a, DB>
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
+impl<'a, S, F, D, W, O, L, Of, G, DB> InternalBoxedDsl<'a, DB>
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
         DB: Backend,
-        S: QueryFragment<DB> + 'a,
+        S: QueryFragment<DB> + SelectableExpression<F> + 'a,
         D: QueryFragment<DB> + 'a,
         W: Into<Option<Box<QueryFragment<DB> + 'a>>>,
         O: QueryFragment<DB> + 'a,
         L: QueryFragment<DB> + 'a,
         Of: QueryFragment<DB> + 'a,
 {
-    type Output = BoxedSelectStatement<'a, ST, F, DB>;
+    type Output = BoxedSelectStatement<'a, S::SqlTypeForSelect, F, DB>;
 
     fn internal_into_boxed(self) -> Self::Output {
         BoxedSelectStatement::new(
diff --git a/diesel/src/query_builder/select_statement/mod.rs b/diesel/src/query_builder/select_statement/mod.rs
index b3e38477d..7a25bbddf 100644
--- a/diesel/src/query_builder/select_statement/mod.rs
+++ b/diesel/src/query_builder/select_statement/mod.rs
@@ -3,8 +3,6 @@ mod boxed;
 
 pub use self::boxed::BoxedSelectStatement;
 
-use std::marker::PhantomData;
-
 use backend::Backend;
 use expression::*;
 use query_source::*;
@@ -20,7 +18,6 @@ use super::{Query, QueryBuilder, QueryFragment, BuildQueryResult};
 #[derive(Debug, Clone, Copy)]
 #[doc(hidden)]
 pub struct SelectStatement<
-    SqlType,
     Select,
     From,
     Distinct = NoDistinctClause,
@@ -38,10 +35,9 @@ pub struct SelectStatement<
     limit: Limit,
     offset: Offset,
     group_by: GroupBy,
-    _marker: PhantomData<SqlType>,
 }
 
-impl<ST, S, F, D, W, O, L, Of, G> SelectStatement<ST, S, F, D, W, O, L, Of, G> {
+impl<S, F, D, W, O, L, Of, G> SelectStatement<S, F, D, W, O, L, Of, G> {
     #[cfg_attr(feature = "clippy", allow(too_many_arguments))]
     pub fn new(
         select: S,
@@ -62,12 +58,11 @@ impl<ST, S, F, D, W, O, L, Of, G> SelectStatement<ST, S, F, D, W, O, L, Of, G> {
             limit: limit,
             offset: offset,
             group_by: group_by,
-            _marker: PhantomData,
         }
     }
 
     pub fn inner_join<T>(self, other: T)
-        -> SelectStatement<ST, S, InnerJoinSource<F, T>, D, W, O, L, Of, G> where
+        -> SelectStatement<S, InnerJoinSource<F, T>, D, W, O, L, Of, G> where
             T: Table,
             F: Table + JoinTo<T, joins::Inner>,
     {
@@ -84,7 +79,7 @@ impl<ST, S, F, D, W, O, L, Of, G> SelectStatement<ST, S, F, D, W, O, L, Of, G> {
     }
 
     pub fn left_outer_join<T>(self, other: T)
-        -> SelectStatement<ST, S, LeftOuterJoinSource<F, T>, D, W, O, L, Of, G> where
+        -> SelectStatement<S, LeftOuterJoinSource<F, T>, D, W, O, L, Of, G> where
             T: Table,
             F: Table + JoinTo<T, joins::LeftOuter>,
     {
@@ -101,7 +96,7 @@ impl<ST, S, F, D, W, O, L, Of, G> SelectStatement<ST, S, F, D, W, O, L, Of, G> {
     }
 }
 
-impl<ST, S, F> SelectStatement<ST, S, F> {
+impl<S, F> SelectStatement<S, F> {
     pub fn simple(select: S, from: F) -> Self {
         SelectStatement::new(
             select,
@@ -116,31 +111,31 @@ impl<ST, S, F> SelectStatement<ST, S, F> {
     }
 }
 
-impl<ST, S, F, D, W, O, L, Of, G> Query
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        S: SelectableExpression<F, ST>,
+impl<S, F, D, W, O, L, Of, G> Query
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        S: SelectableExpression<F>,
 {
-    type SqlType = ST;
+    type SqlType = S::SqlTypeForSelect;
 }
 
 #[cfg(feature = "postgres")]
-impl<ST, S, F, D, W, O, L, Of, G> Expression
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        S: SelectableExpression<F, ST>,
+impl<S, F, D, W, O, L, Of, G> Expression
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        S: SelectableExpression<F>,
 {
-    type SqlType = ::types::Array<ST>;
+    type SqlType = ::types::Array<S::SqlTypeForSelect>;
 }
 
 #[cfg(not(feature = "postgres"))]
-impl<ST, S, F, D, W, O, L, Of, G> Expression
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        S: SelectableExpression<F, ST>,
+impl<S, F, D, W, O, L, Of, G> Expression
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        S: SelectableExpression<F>,
 {
-    type SqlType = ST;
+    type SqlType = S::SqlTypeForSelect;
 }
 
-impl<ST, S, F, D, W, O, L, Of, G, DB> QueryFragment<DB>
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
+impl<S, F, D, W, O, L, Of, G, DB> QueryFragment<DB>
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
         DB: Backend,
         S: QueryFragment<DB>,
         F: QuerySource,
@@ -190,8 +185,8 @@ impl<ST, S, F, D, W, O, L, Of, G, DB> QueryFragment<DB>
     }
 }
 
-impl<ST, S, D, W, O, L, Of, G, DB> QueryFragment<DB>
-    for SelectStatement<ST, S, (), D, W, O, L, Of, G> where
+impl<S, D, W, O, L, Of, G, DB> QueryFragment<DB>
+    for SelectStatement<S, (), D, W, O, L, Of, G> where
         DB: Backend,
         S: QueryFragment<DB>,
         D: QueryFragment<DB>,
@@ -235,16 +230,17 @@ impl<ST, S, D, W, O, L, Of, G, DB> QueryFragment<DB>
     }
 }
 
-impl_query_id!(SelectStatement<ST, S, F, D, W, O, L, Of, G>);
+impl_query_id!(SelectStatement<S, F, D, W, O, L, Of, G>);
 
-impl<ST, S, F, D, W, O, L, Of, G, QS> SelectableExpression<QS>
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        SelectStatement<ST, S, F, D, W, O, L, Of, G>: Expression,
+impl<S, F, D, W, O, L, Of, G, QS> SelectableExpression<QS>
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        SelectStatement<S, F, D, W, O, L, Of, G>: Expression,
 {
+    type SqlTypeForSelect = Self::SqlType;
 }
 
-impl<ST, S, F, D, W, O, L, Of, G> NonAggregate
-    for SelectStatement<ST, S, F, D, W, O, L, Of, G> where
-        SelectStatement<ST, S, F, D, W, O, L, Of, G>: Expression,
+impl<S, F, D, W, O, L, Of, G> NonAggregate
+    for SelectStatement<S, F, D, W, O, L, Of, G> where
+        SelectStatement<S, F, D, W, O, L, Of, G>: Expression,
 {
 }
diff --git a/diesel/src/query_source/joins.rs b/diesel/src/query_source/joins.rs
index 86f6b89fe..fccf96af7 100644
--- a/diesel/src/query_source/joins.rs
+++ b/diesel/src/query_source/joins.rs
@@ -1,4 +1,6 @@
+use prelude::*;
 use expression::SelectableExpression;
+use expression::nullable::Nullable;
 use query_builder::*;
 use result::QueryResult;
 use super::{QuerySource, Table};
@@ -35,13 +37,12 @@ impl<Left, Right> AsQuery for InnerJoinSource<Left, Right> where
     Left: Table + JoinTo<Right, Inner>,
     Right: Table,
     (Left::AllColumns, Right::AllColumns): SelectableExpression<
-                                   InnerJoinSource<Left, Right>,
-                                   (Left::SqlType, Right::SqlType),
-                               >,
+        InnerJoinSource<Left, Right>,
+        SqlTypeForSelect=(Left::SqlType, Right::SqlType),
+    >,
 {
     type SqlType = (Left::SqlType, Right::SqlType);
     type Query = SelectStatement<
-        (Left::SqlType, Right::SqlType),
         (Left::AllColumns, Right::AllColumns),
         Self,
     >;
@@ -84,20 +85,22 @@ impl<Left, Right> AsQuery for LeftOuterJoinSource<Left, Right> where
     Left: Table + JoinTo<Right, LeftOuter>,
     Right: Table,
     Right::SqlType: IntoNullable,
-    (Left::AllColumns, Right::AllColumns): SelectableExpression<
-                                   LeftOuterJoinSource<Left, Right>,
-                                   (Left::SqlType, <Right::SqlType as IntoNullable>::Nullable),
-                               >,
+    (Left::AllColumns, Nullable<Right::AllColumns>): SelectableExpression<
+        LeftOuterJoinSource<Left, Right>,
+        SqlTypeForSelect=(Left::SqlType, <Right::SqlType as IntoNullable>::Nullable)
+    >,
 {
     type SqlType = (Left::SqlType, <Right::SqlType as IntoNullable>::Nullable);
     type Query = SelectStatement<
-        Self::SqlType,
-        (Left::AllColumns, Right::AllColumns),
+        (Left::AllColumns, Nullable<Right::AllColumns>),
         Self,
     >;
 
     fn as_query(self) -> Self::Query {
-        SelectStatement::simple((Left::all_columns(), Right::all_columns()), self)
+        SelectStatement::simple(
+            (Left::all_columns(), Right::all_columns().nullable()),
+            self,
+        )
     }
 }
 
diff --git a/diesel/src/types/impls/tuples.rs b/diesel/src/types/impls/tuples.rs
index ff4eaf438..c40b73276 100644
--- a/diesel/src/types/impls/tuples.rs
+++ b/diesel/src/types/impls/tuples.rs
@@ -210,21 +210,11 @@ macro_rules! tuple_impls {
                 }
             }
 
-            impl<$($T),+, $($ST),+, QS>
-                SelectableExpression<QS, ($($ST,)+)>
-                for ($($T,)+) where
-                $($T: SelectableExpression<QS, $ST>),+,
-                ($($T,)+): Expression,
-            {
-            }
-
-            impl<$($T),+, $($ST),+, QS>
-                SelectableExpression<QS, Nullable<($($ST,)+)>>
-                for ($($T,)+) where
-                $($ST: IntoNullable,)+
-                $($T: SelectableExpression<QS, $ST::Nullable, SqlType=$ST>),+,
+            impl<$($T,)+ QS> SelectableExpression<QS> for ($($T,)+) where
+                $($T: SelectableExpression<QS>,)+
                 ($($T,)+): Expression,
             {
+                type SqlTypeForSelect = ($($T::SqlTypeForSelect,)+);
             }
 
             impl<Target, $($T,)+> AsChangeset for ($($T,)+) where
diff --git a/diesel_compile_tests/tests/compile-fail/cannot_mix_aggregate_and_non_aggregate_selects.rs b/diesel_compile_tests/tests/compile-fail/cannot_mix_aggregate_and_non_aggregate_selects.rs
index beec1e831..6db1281cc 100644
--- a/diesel_compile_tests/tests/compile-fail/cannot_mix_aggregate_and_non_aggregate_selects.rs
+++ b/diesel_compile_tests/tests/compile-fail/cannot_mix_aggregate_and_non_aggregate_selects.rs
@@ -15,11 +15,4 @@ fn main() {
 
     let source = users.select((id, count(users.star())));
     //~^ ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
 }
diff --git a/diesel_compile_tests/tests/compile-fail/find_requires_correct_type.rs b/diesel_compile_tests/tests/compile-fail/find_requires_correct_type.rs
index 6ad648d57..e14d8efbd 100644
--- a/diesel_compile_tests/tests/compile-fail/find_requires_correct_type.rs
+++ b/diesel_compile_tests/tests/compile-fail/find_requires_correct_type.rs
@@ -28,5 +28,4 @@ fn main() {
     //~| ERROR E0277
     //~| ERROR E0277
     //~| ERROR E0277
-    //~| ERROR E0277
 }
diff --git a/diesel_compile_tests/tests/compile-fail/select_requires_column_from_same_table.rs b/diesel_compile_tests/tests/compile-fail/select_requires_column_from_same_table.rs
index a16275a4c..67c258de5 100644
--- a/diesel_compile_tests/tests/compile-fail/select_requires_column_from_same_table.rs
+++ b/diesel_compile_tests/tests/compile-fail/select_requires_column_from_same_table.rs
@@ -20,10 +20,4 @@ table! {
 fn main() {
     let select_id = users::table.select(posts::id);
     //~^ ERROR SelectableExpression
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
 }
diff --git a/diesel_compile_tests/tests/compile-fail/selecting_multiple_columns_requires_all_must_be_from_selectable_table.rs b/diesel_compile_tests/tests/compile-fail/selecting_multiple_columns_requires_all_must_be_from_selectable_table.rs
index 1ae8e067c..faa919cf3 100644
--- a/diesel_compile_tests/tests/compile-fail/selecting_multiple_columns_requires_all_must_be_from_selectable_table.rs
+++ b/diesel_compile_tests/tests/compile-fail/selecting_multiple_columns_requires_all_must_be_from_selectable_table.rs
@@ -22,17 +22,6 @@ fn main() {
     let stuff = users::table.select((posts::id, posts::user_id));
     //~^ ERROR Selectable
     //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
     let stuff = users::table.select((posts::id, users::name));
     //~^ ERROR Selectable
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
-    //~| ERROR E0277
 }
diff --git a/diesel_infer_schema/src/information_schema.rs b/diesel_infer_schema/src/information_schema.rs
index 1dead5ded..5b7301268 100644
--- a/diesel_infer_schema/src/information_schema.rs
+++ b/diesel_infer_schema/src/information_schema.rs
@@ -16,7 +16,7 @@ use super::data_structures::*;
 pub trait UsesInformationSchema: Backend {
     type TypeColumn: SelectableExpression<
         self::information_schema::columns::table,
-        types::Text,
+        SqlTypeForSelect=types::Text,
     > + NonAggregate + QueryId + QueryFragment<Self>;
 
     fn type_column() -> Self::TypeColumn;
diff --git a/diesel_tests/tests/expressions/mod.rs b/diesel_tests/tests/expressions/mod.rs
index c8626d53e..096d8ce08 100644
--- a/diesel_tests/tests/expressions/mod.rs
+++ b/diesel_tests/tests/expressions/mod.rs
@@ -114,7 +114,9 @@ impl<T, DB> QueryFragment<DB> for Arbitrary<T> where
     }
 }
 
-impl<T, QS> SelectableExpression<QS> for Arbitrary<T> {}
+impl<T, QS> SelectableExpression<QS> for Arbitrary<T> {
+    type SqlTypeForSelect = T;
+}
 
 fn arbitrary<T>() -> Arbitrary<T> {
     Arbitrary { _marker: PhantomData }
diff --git a/diesel_tests/tests/filter.rs b/diesel_tests/tests/filter.rs
index 61d66ab26..98bbc45cb 100644
--- a/diesel_tests/tests/filter.rs
+++ b/diesel_tests/tests/filter.rs
@@ -260,7 +260,7 @@ sql_function!(lower, lower_t, (x: VarChar) -> VarChar);
 
 #[test]
 fn filter_by_boxed_predicate() {
-    fn by_name(name: &str) -> Box<BoxableExpression<users::table, types::Bool, TestBackend, SqlType=types::Bool>> {
+    fn by_name(name: &str) -> Box<BoxableExpression<users::table, TestBackend, SqlType=types::Bool, SqlTypeForSelect=types::Bool>> {
         Box::new(lower(users::name).eq(name.to_string()))
     }
 
diff --git a/diesel_tests/tests/joins.rs b/diesel_tests/tests/joins.rs
index 64a3502f8..308c91636 100644
--- a/diesel_tests/tests/joins.rs
+++ b/diesel_tests/tests/joins.rs
@@ -128,7 +128,27 @@ fn columns_on_right_side_of_left_outer_joins_are_nullable() {
 }
 
 #[test]
-fn select_multiple_from_right_side_returns_optional_tuple() {
+fn columns_on_right_side_of_left_outer_joins_can_be_used_in_filter() {
+    let connection = connection_with_sean_and_tess_in_users_table();
+
+    connection.execute("INSERT INTO posts (user_id, title) VALUES
+        (1, 'Hello'),
+        (1, 'World')
+    ").unwrap();
+
+    let expected_data = vec![
+        ("Sean".to_string(), Some("Hello".to_string())),
+    ];
+    let source = users::table.left_outer_join(posts::table)
+        .select((users::name, posts::title))
+        .filter(posts::title.eq("Hello"));
+    let actual_data: Vec<_> = source.load(&connection).unwrap();
+
+    assert_eq!(expected_data, actual_data);
+}
+
+#[test]
+fn select_multiple_from_right_side_returns_optional_tuple_when_nullable_is_called() {
     let connection = connection_with_sean_and_tess_in_users_table();
 
     connection.execute("INSERT INTO posts (user_id, title, body) VALUES
@@ -142,7 +162,7 @@ fn select_multiple_from_right_side_returns_optional_tuple() {
         None,
     ];
 
-    let source = users::table.left_outer_join(posts::table).select((posts::title, posts::body));
+    let source = users::table.left_outer_join(posts::table).select((posts::title, posts::body).nullable());
     let actual_data: Vec<_> = source.load(&connection).unwrap();
 
     assert_eq!(expected_data, actual_data);
@@ -165,7 +185,7 @@ fn select_complex_from_left_join() {
         (tess, None),
     ];
 
-    let source = users::table.left_outer_join(posts::table).select((users::all_columns, (posts::title, posts::body)));
+    let source = users::table.left_outer_join(posts::table).select((users::all_columns, (posts::title, posts::body).nullable()));
     let actual_data: Vec<_> = source.load(&connection).unwrap();
 
     assert_eq!(expected_data, actual_data);
@@ -188,7 +208,7 @@ fn select_right_side_with_nullable_column_first() {
         (tess, None),
     ];
 
-    let source = users::table.left_outer_join(posts::table).select((users::all_columns, (posts::body, posts::title)));
+    let source = users::table.left_outer_join(posts::table).select((users::all_columns, (posts::body, posts::title).nullable()));
     let actual_data: Vec<_> = source.load(&connection).unwrap();
 
     assert_eq!(expected_data, actual_data);
diff --git a/diesel_tests/tests/types.rs b/diesel_tests/tests/types.rs
index 5d8c299d9..52b8b5296 100644
--- a/diesel_tests/tests/types.rs
+++ b/diesel_tests/tests/types.rs
@@ -491,7 +491,7 @@ use diesel::query_builder::{QueryFragment, QueryId};
 fn query_to_sql_equality<T, U>(sql_str: &str, value: U) -> bool where
     TestBackend: HasSqlType<T>,
     U: AsExpression<T> + Debug + Clone,
-    U::Expression: SelectableExpression<(), T> + QueryFragment<TestBackend> + QueryId,
+    U::Expression: SelectableExpression<()> + QueryFragment<TestBackend> + QueryId,
     T: QueryId,
 {
     use diesel::expression::dsl::sql;
diff --git a/diesel_tests/tests/types_roundtrip.rs b/diesel_tests/tests/types_roundtrip.rs
index 63605397c..e467f55e1 100644
--- a/diesel_tests/tests/types_roundtrip.rs
+++ b/diesel_tests/tests/types_roundtrip.rs
@@ -17,7 +17,7 @@ pub fn test_type_round_trips<ST, T>(value: T) -> bool where
     ST: QueryId,
     <TestConnection as Connection>::Backend: HasSqlType<ST>,
     T: AsExpression<ST> + Queryable<ST, <TestConnection as Connection>::Backend> + PartialEq + Clone + ::std::fmt::Debug,
-    <T as AsExpression<ST>>::Expression: SelectableExpression<()> + QueryFragment<<TestConnection as Connection>::Backend> + QueryId,
+    <T as AsExpression<ST>>::Expression: SelectableExpression<(), SqlTypeForSelect=ST> + QueryFragment<<TestConnection as Connection>::Backend> + QueryId,
 {
     let connection = connection();
     let query = select(AsExpression::<ST>::as_expression(value.clone()));
