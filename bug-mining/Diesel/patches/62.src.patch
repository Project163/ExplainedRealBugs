diff --git a/diesel/src/macros/insertable.rs b/diesel/src/macros/insertable.rs
index 111893ad0..f2795d370 100644
--- a/diesel/src/macros/insertable.rs
+++ b/diesel/src/macros/insertable.rs
@@ -199,6 +199,24 @@ macro_rules! _Insertable {
                 ,)+)
             }
         }
+
+    } __diesel_parse_as_item! {
+        impl<$($lifetime,)* 'insert, Op, Ret> $crate::query_builder::insert_statement::IntoInsertStatement<$table_name::table, Op, Ret>
+            for &'insert $struct_ty where
+                $('insert: $lifetime,)*
+                $crate::query_builder::insert_statement::InsertStatement<$table_name::table, &'insert $struct_ty, Op, Ret>: $crate::query_builder::AsQuery,
+        {
+            type InsertStatement = $crate::query_builder::insert_statement::InsertStatement<$table_name::table, Self, Op, Ret>;
+
+            fn into_insert_statement(self, target: $table_name::table, operator: Op, returning: Ret) -> Self::InsertStatement {
+                $crate::query_builder::insert_statement::InsertStatement::new(
+                    target,
+                    self,
+                    operator,
+                    returning,
+                )
+            }
+        }
     }};
 }
 
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index 31bea45fb..9cf8cb0bf 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -1,10 +1,13 @@
-use backend::Backend;
+use backend::{Backend, SupportsDefaultKeyword};
+use connection::Connection;
 use expression::{Expression, SelectableExpression, NonAggregate};
 use persistable::{Insertable, InsertValues};
 use query_builder::*;
-use query_source::Table;
+use query_dsl::{ExecuteDsl, LoadDsl};
+use query_source::{Queryable, Table};
 use result::QueryResult;
 use super::returning_clause::*;
+use types::HasSqlType;
 
 /// The structure returned by [`insert`](fn.insert.html). The only thing that can be done with it
 /// is call `into`.
@@ -24,26 +27,64 @@ impl<T, Op> IncompleteInsertStatement<T, Op> {
     }
 
     /// Specify which table the data passed to `insert` should be added to.
-    pub fn into<S>(self, target: S) -> InsertStatement<S, T, Op> where
-        InsertStatement<S, T, Op>: AsQuery,
+    pub fn into<S>(self, target: S) -> T::InsertStatement where
+        T: IntoInsertStatement<S, Op, NoReturningClause>,
     {
-        InsertStatement {
-            operator: self.operator,
+        self.records.into_insert_statement(target, self.operator, NoReturningClause)
+    }
+}
+
+pub trait IntoInsertStatement<Tab, Op=Insert, Ret=NoReturningClause> {
+    type InsertStatement;
+
+    fn into_insert_statement(self, target: Tab, operator: Op, returning: Ret)
+        -> Self::InsertStatement;
+}
+
+impl<'a, T, Tab, Op, Ret> IntoInsertStatement<Tab, Op, Ret> for &'a [T] {
+    type InsertStatement = BatchInsertStatement<Tab, Self, Op, Ret>;
+
+    fn into_insert_statement(self, target: Tab, operator: Op, returning: Ret)
+        -> Self::InsertStatement
+    {
+        BatchInsertStatement {
+            operator: operator,
             target: target,
-            records: self.records,
-            returning: NoReturningClause,
+            records: self,
+            returning: returning,
         }
     }
 }
 
+impl<'a, T, Tab, Op, Ret> IntoInsertStatement<Tab, Op, Ret> for &'a Vec<T> {
+    type InsertStatement = <&'a [T] as IntoInsertStatement<Tab, Op, Ret>>::InsertStatement;
+
+    fn into_insert_statement(self, target: Tab, operator: Op, returning: Ret)
+        -> Self::InsertStatement
+    {
+        (&**self).into_insert_statement(target, operator, returning)
+    }
+}
+
 #[derive(Debug, Copy, Clone)]
-pub struct InsertStatement<T, U, Op, Ret=NoReturningClause> {
+pub struct InsertStatement<T, U, Op=Insert, Ret=NoReturningClause> {
     operator: Op,
     target: T,
     records: U,
     returning: Ret,
 }
 
+impl<T, U, Op, Ret> InsertStatement<T, U, Op, Ret> {
+    pub fn new(target: T, records: U, operator: Op, returning: Ret) -> Self {
+        InsertStatement {
+            operator: operator,
+            target: target,
+            records: records,
+            returning: returning,
+        }
+    }
+}
+
 impl<T, U, Op, Ret, DB> QueryFragment<DB> for InsertStatement<T, U, Op, Ret> where
     DB: Backend,
     T: Table,
@@ -148,6 +189,140 @@ impl<T, U, Op> InsertStatement<T, U, Op, NoReturningClause> {
     }
 }
 
+#[derive(Debug, Clone, Copy)]
+/// The result of calling `insert(records).into(some_table)` when `records` is
+/// a slice or a `Vec`. When calling methods from `ExecuteDsl` or `LoadDsl`.
+/// When the given slice is empty, this struct will not execute any queries.
+/// When the given slice is not empty, this will execute a single bulk insert
+/// on backends which support the `DEFAULT` keyword, and one query per record
+/// on backends which do not (SQLite).
+pub struct BatchInsertStatement<T, U, Op=Insert, Ret=NoReturningClause> {
+    operator: Op,
+    target: T,
+    records: U,
+    returning: Ret,
+}
+
+impl<T, U, Op, Ret> BatchInsertStatement<T, U, Op, Ret> {
+    fn into_insert_statement(self) -> InsertStatement<T, U, Op, Ret> {
+        InsertStatement::new(
+            self.target,
+            self.records,
+            self.operator,
+            self.returning,
+        )
+    }
+}
+
+impl<T, U, Op> BatchInsertStatement<T, U, Op> {
+    /// Specify what expression is returned after execution of the `insert`.
+    /// # Examples
+    ///
+    /// ### Inserting records:
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("src/doctest_setup.rs");
+    /// #
+    /// # table! {
+    /// #     users {
+    /// #         id -> Integer,
+    /// #         name -> VarChar,
+    /// #     }
+    /// # }
+    /// #
+    /// # #[cfg(feature = "postgres")]
+    /// # fn main() {
+    /// #     use self::users::dsl::*;
+    /// #     let connection = establish_connection();
+    /// let new_users = vec![
+    ///     NewUser { name: "Timmy".to_string(), },
+    ///     NewUser { name: "Jimmy".to_string(), },
+    /// ];
+    ///
+    /// let inserted_names = diesel::insert(&new_users)
+    ///     .into(users)
+    ///     .returning(name)
+    ///     .get_results(&connection);
+    /// assert_eq!(Ok(vec!["Timmy".to_string(), "Jimmy".to_string()]), inserted_names);
+    /// # }
+    /// # #[cfg(not(feature = "postgres"))]
+    /// # fn main() {}
+    /// ```
+    pub fn returning<E>(self, returns: E)
+        -> BatchInsertStatement<T, U, Op, ReturningClause<E>>
+    {
+        BatchInsertStatement {
+            operator: self.operator,
+            target: self.target,
+            records: self.records,
+            returning: ReturningClause(returns),
+        }
+    }
+}
+
+impl<'a, T, U, Op, Ret, Conn, DB> ExecuteDsl<Conn, DB>
+    for BatchInsertStatement<T, &'a [U], Op, Ret> where
+        Conn: Connection<Backend=DB>,
+        DB: Backend + SupportsDefaultKeyword,
+        InsertStatement<T, &'a [U], Op, Ret>: ExecuteDsl<Conn>,
+{
+    fn execute(self, conn: &Conn) -> QueryResult<usize> {
+        if self.records.is_empty() {
+            Ok(0)
+        } else {
+            self.into_insert_statement().execute(conn)
+        }
+    }
+}
+
+#[cfg(feature="sqlite")]
+impl<'a, T, U, Op, Ret> ExecuteDsl<::sqlite::SqliteConnection>
+    for BatchInsertStatement<T, &'a [U], Op, Ret> where
+        InsertStatement<T, &'a U, Op, Ret>: ExecuteDsl<::sqlite::SqliteConnection>,
+        T: Copy,
+        Op: Copy,
+        Ret: Copy,
+{
+    fn execute(self, conn: &::sqlite::SqliteConnection) -> QueryResult<usize> {
+        let mut result = 0;
+        for record in self.records {
+            result += InsertStatement::new(self.target, record, self.operator, self.returning)
+                .execute(conn)?;
+        }
+        Ok(result)
+    }
+}
+
+impl<'a, T, U, Op, Ret, Conn, ST> LoadDsl<Conn>
+    for BatchInsertStatement<T, &'a [U], Op, Ret> where
+        Conn: Connection,
+        Conn::Backend: HasSqlType<ST>,
+        InsertStatement<T, &'a [U], Op, Ret>: LoadDsl<Conn, SqlType=ST>,
+{
+    type SqlType = ST;
+
+    fn load<'b, V>(self, conn: &Conn) -> QueryResult<Vec<V>> where
+        V: Queryable<Self::SqlType, Conn::Backend> + 'b,
+    {
+        if self.records.is_empty() {
+            Ok(Vec::new())
+        } else {
+            self.into_insert_statement().load(conn)
+        }
+    }
+
+    fn get_result<V>(self, conn: &Conn) -> QueryResult<V> where
+        V: Queryable<Self::SqlType, Conn::Backend>,
+    {
+        if self.records.is_empty() {
+            Err(::result::Error::NotFound)
+        } else {
+            self.into_insert_statement().get_result(conn)
+        }
+    }
+}
+
 #[derive(Debug, Copy, Clone)]
 pub struct Insert;
 
diff --git a/diesel/src/query_dsl/load_dsl.rs b/diesel/src/query_dsl/load_dsl.rs
index 66350edfb..e06aa1c13 100644
--- a/diesel/src/query_dsl/load_dsl.rs
+++ b/diesel/src/query_dsl/load_dsl.rs
@@ -1,3 +1,4 @@
+use backend::Backend;
 use connection::Connection;
 use helper_types::Limit;
 use query_builder::{QueryFragment, AsQuery, QueryId};
@@ -8,9 +9,11 @@ use types::HasSqlType;
 
 /// Methods to execute a query given a connection. These are automatically implemented for the
 /// various query types.
-pub trait LoadDsl<Conn: Connection>: AsQuery + Sized where
+pub trait LoadDsl<Conn: Connection>: Sized where
     Conn::Backend: HasSqlType<Self::SqlType>,
 {
+    type SqlType;
+
     /// Executes the given query, returning an `Iterator` over the returned
     /// rows.
     fn load<'a, U>(self, conn: &Conn) -> QueryResult<Vec<U>> where
@@ -22,8 +25,8 @@ pub trait LoadDsl<Conn: Connection>: AsQuery + Sized where
     /// `Result<Option<U>>`.
     fn first<U>(self, conn: &Conn) -> QueryResult<U> where
         Self: LimitDsl,
-        Limit<Self>: LoadDsl<Conn, SqlType=Self::SqlType>,
-        U: Queryable<Self::SqlType, Conn::Backend>,
+        Limit<Self>: LoadDsl<Conn, SqlType=<Self as LoadDsl<Conn>>::SqlType>,
+        U: Queryable<<Self as LoadDsl<Conn>>::SqlType, Conn::Backend>,
     {
         self.limit(1).get_result(conn)
     }
@@ -47,6 +50,8 @@ impl<Conn: Connection, T: AsQuery> LoadDsl<Conn> for T where
     T::Query: QueryFragment<Conn::Backend> + QueryId,
     Conn::Backend: HasSqlType<T::SqlType>,
 {
+    type SqlType = <Self as AsQuery>::SqlType;
+
     fn load<'a, U>(self, conn: &Conn) -> QueryResult<Vec<U>> where
         U: Queryable<Self::SqlType, Conn::Backend> + 'a,
     {
@@ -60,18 +65,19 @@ impl<Conn: Connection, T: AsQuery> LoadDsl<Conn> for T where
     }
 }
 
-pub trait ExecuteDsl<Conn: Connection>: Sized + QueryFragment<Conn::Backend> + QueryId {
+pub trait ExecuteDsl<Conn: Connection<Backend=DB>, DB: Backend = <Conn as Connection>::Backend>: Sized {
     /// Executes the given command, returning the number of rows affected. Used
     /// in conjunction with
     /// [`update`](../query_builder/fn.update.html) and
     /// [`delete`](../query_builder/fn.delete.html)
-    fn execute(&self, conn: &Conn) -> QueryResult<usize> {
-        conn.execute_returning_count(self)
-    }
+    fn execute(self, conn: &Conn) -> QueryResult<usize>;
 }
 
 impl<Conn, T> ExecuteDsl<Conn> for T where
     Conn: Connection,
     T: QueryFragment<Conn::Backend> + QueryId,
 {
+    fn execute(self, conn: &Conn) -> QueryResult<usize> {
+        conn.execute_returning_count(&self)
+    }
 }
diff --git a/diesel_compile_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs b/diesel_compile_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs
deleted file mode 100644
index c50131036..000000000
--- a/diesel_compile_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs
+++ /dev/null
@@ -1,34 +0,0 @@
-#[macro_use]
-extern crate diesel;
-
-use diesel::*;
-use diesel::backend::Backend;
-use diesel::sqlite::{Sqlite, SqliteQueryBuilder, SqliteConnection};
-use diesel::types::{Integer, VarChar};
-
-table! {
-    users {
-        id -> Integer,
-        name -> VarChar,
-    }
-}
-
-pub struct NewUser(String);
-
-Insertable! {
-    (users)
-    pub struct NewUser(#[column_name(name)] String,);
-}
-
-fn main() {
-    let connection = SqliteConnection::establish(":memory:").unwrap();
-
-    let new_users = vec![
-        NewUser("Hello".into()),
-        NewUser("World".into()),
-    ];
-    insert(&new_users)
-        .into(users::table)
-        .execute(&connection);
-    //~^ ERROR: SupportsDefaultKeyword
-}
diff --git a/diesel_tests/tests/insert.rs b/diesel_tests/tests/insert.rs
index f767147c4..d2847bc01 100644
--- a/diesel_tests/tests/insert.rs
+++ b/diesel_tests/tests/insert.rs
@@ -64,16 +64,18 @@ fn insert_records_with_custom_returning_clause() {
 }
 
 #[test]
-#[cfg(not(feature = "sqlite"))]
 fn batch_insert_with_defaults() {
     use schema::users::table as users;
+    use schema_dsl::*;
+
     let connection = connection();
     connection.execute("DROP TABLE users").unwrap();
-    connection.execute("CREATE TABLE users (
-        id SERIAL PRIMARY KEY,
-        name VARCHAR NOT NULL,
-        hair_color VARCHAR NOT NULL DEFAULT 'Green'
-    )").unwrap();
+    create_table("users", (
+        integer("id").primary_key().auto_increment(),
+        string("name").not_null(),
+        string("hair_color").not_null().default("'Green'"),
+    )).execute(&connection).unwrap();
+
     let new_users: &[_] = &[
         NewUser::new("Sean", Some("Black")),
         NewUser::new("Tess", None),
@@ -182,3 +184,30 @@ fn insert_on_conflict_replace() {
     let names = users.select(name).order(id).load::<String>(&connection);
     assert_eq!(Ok(expected_names), names);
 }
+
+#[test]
+fn insert_empty_slice() {
+    let connection = connection();
+
+    let inserted_records = insert(&Vec::<NewUser>::new())
+        .into(users::table)
+        .execute(&connection);
+
+    assert_eq!(Ok(0), inserted_records);
+}
+
+#[test]
+#[cfg(feature = "postgres")]
+fn insert_empty_slice_with_returning() {
+    let connection = connection();
+
+    let insert_one = insert(&Vec::<NewUser>::new())
+        .into(users::table)
+        .get_result::<User>(&connection);
+    let insert_all = insert(&Vec::<NewUser>::new())
+        .into(users::table)
+        .get_results::<User>(&connection);
+
+    assert_eq!(Ok(None), insert_one.optional());
+    assert_eq!(Ok(vec![]), insert_all);
+}
diff --git a/diesel_tests/tests/schema.rs b/diesel_tests/tests/schema.rs
index 3b1cdab58..010c94591 100644
--- a/diesel_tests/tests/schema.rs
+++ b/diesel_tests/tests/schema.rs
@@ -166,34 +166,18 @@ pub fn connection_without_transaction() -> TestConnection {
     connection
 }
 
-use diesel::query_builder::insert_statement::{InsertStatement, Insert};
-use diesel::query_builder::QueryFragment;
+use diesel::query_builder::insert_statement::IntoInsertStatement;
 
-#[cfg(not(feature = "sqlite"))]
 pub fn batch_insert<'a, T, U: 'a, Conn>(records: &'a [U], table: T, connection: &Conn)
     -> usize where
         T: Table,
         Conn: Connection,
-        &'a [U]: Insertable<T, Conn::Backend>,
-        InsertStatement<T, &'a [U], Insert>: QueryFragment<Conn::Backend>,
+        &'a [U]: IntoInsertStatement<T>,
+        <&'a [U] as IntoInsertStatement<T>>::InsertStatement: ExecuteDsl<Conn>,
 {
     insert(records).into(table).execute(connection).unwrap()
 }
 
-#[cfg(feature = "sqlite")]
-pub fn batch_insert<'a, T, U: 'a, Conn>(records: &'a [U], table: T, connection: &Conn)
-    -> usize where
-        T: Table + Copy,
-        Conn: Connection,
-        &'a U: Insertable<T, Conn::Backend>,
-        InsertStatement<T, &'a U, Insert>: QueryFragment<Conn::Backend>,
-{
-    for record in records {
-        insert(record).into(table).execute(connection).unwrap();
-    }
-    records.len()
-}
-
 sql_function!(nextval, nextval_t, (a: types::VarChar) -> types::BigInt);
 
 pub fn connection_with_sean_and_tess_in_users_table() -> TestConnection {
