diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1af9981b3..03e68c1a0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -17,6 +17,9 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * `#[changeset_for]` can now be used with structs containing a `Vec`. Fixes
   [#63](https://github.com/sgrif/diesel/issues/63).
 
+* No longer generate invalid SQL when an optional update field is not the first
+  field on a changeset. Fixes [#68](https://github.com/sgrif/diesel/issues/68).
+
 ## [0.3.0] 2015-12-04
 
 ### Changed
diff --git a/diesel/src/types/impls/tuples.rs b/diesel/src/types/impls/tuples.rs
index e93792b3e..6ecca8203 100644
--- a/diesel/src/types/impls/tuples.rs
+++ b/diesel/src/types/impls/tuples.rs
@@ -131,16 +131,17 @@ macro_rules! tuple_impls {
                     $(e!(self.$idx.is_noop()) &&)+ true
                 }
 
+                #[allow(unused_assignments)]
                 fn to_sql(&self, out: &mut QueryBuilder) -> BuildQueryResult {
-                    let noop_element = true;
+                    let mut needs_comma = false;
                     $(
-                        let needs_comma = !noop_element;
                         let noop_element = e!(self.$idx.is_noop());
                         if !noop_element {
                             if needs_comma {
                                 out.push_sql(", ");
                             }
                             try!(e!(self.$idx.to_sql(out)));
+                            needs_comma = true;
                         }
                     )+
                     Ok(())
diff --git a/diesel_tests/tests/update.rs b/diesel_tests/tests/update.rs
index 6428093aa..5596c2ab8 100644
--- a/diesel_tests/tests/update.rs
+++ b/diesel_tests/tests/update.rs
@@ -165,3 +165,27 @@ fn sql_syntax_is_correct_when_option_field_comes_before_non_option() {
     let expected_user = User::new(sean.id, "Jim");
     assert_eq!(Ok(expected_user), user);
 }
+
+#[test]
+fn sql_syntax_is_correct_when_option_field_comes_mixed_with_non_option() {
+    #[changeset_for(posts)]
+    struct Changes {
+        user_id: i32,
+        title: Option<String>,
+        body: String,
+    }
+
+    let connection = connection_with_sean_and_tess_in_users_table();
+    let sean = find_user_by_name("Sean", &connection);
+    let new_post = sean.new_post("Hello", Some("world"));
+    insert(&new_post).into(posts::table).execute(&connection).unwrap();
+
+    let changes = Changes { user_id: 1, title: None, body: "earth".into() };
+    let post = update(posts::table)
+        .set(&changes)
+        .get_result::<Post>(&connection)
+        .unwrap();
+
+    let expected_post = Post::new(post.id, sean.id, "Hello".into(), Some("earth".into()));
+    assert_eq!(expected_post, post);
+}
