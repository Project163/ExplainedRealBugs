diff --git a/diesel/src/expression/array_comparison.rs b/diesel/src/expression/array_comparison.rs
index 9b914d96c..19a40bacf 100644
--- a/diesel/src/expression/array_comparison.rs
+++ b/diesel/src/expression/array_comparison.rs
@@ -9,6 +9,7 @@ use crate::expression::{
     AppearsOnTable, AsExpression, Expression, SelectableExpression, TypedExpressionType,
     ValidGrouping,
 };
+use crate::query_builder::combination_clause::CombinationClause;
 use crate::query_builder::{
     AstPass, BoxedSelectStatement, QueryFragment, QueryId, SelectQuery, SelectStatement,
 };
@@ -228,6 +229,20 @@ where
     }
 }
 
+impl<ST, Combinator, Rule, Source, Rhs> AsInExpression<ST>
+    for CombinationClause<Combinator, Rule, Source, Rhs>
+where
+    ST: SqlType + TypedExpressionType,
+    Self: SelectQuery<SqlType = ST>,
+    Subselect<Self, ST>: Expression<SqlType = ST>,
+{
+    type InExpression = Subselect<Self, ST>;
+
+    fn as_in_expression(self) -> Self::InExpression {
+        Subselect::new(self)
+    }
+}
+
 /// Query dsl node for a `IN (values)` clause containing
 /// a variable number of bind values.
 ///
diff --git a/diesel/src/query_builder/combination_clause.rs b/diesel/src/query_builder/combination_clause.rs
index 23a7002e0..39e681282 100644
--- a/diesel/src/query_builder/combination_clause.rs
+++ b/diesel/src/query_builder/combination_clause.rs
@@ -2,9 +2,10 @@
 //! with or without `ALL` rule for duplicates
 
 use crate::backend::{Backend, DieselReserveSpecialization};
+use crate::expression::subselect::ValidSubselect;
 use crate::expression::NonAggregate;
 use crate::query_builder::insert_statement::InsertFromSelect;
-use crate::query_builder::{AsQuery, AstPass, Query, QueryFragment, QueryId};
+use crate::query_builder::{AsQuery, AstPass, Query, QueryFragment, QueryId, SelectQuery};
 use crate::{CombineDsl, Insertable, QueryResult, RunQueryDsl, Table};
 
 #[derive(Debug, Clone, Copy, QueryId)]
@@ -55,6 +56,22 @@ where
     type SqlType = Source::SqlType;
 }
 
+impl<Combinator, Rule, Source, Rhs> SelectQuery for CombinationClause<Combinator, Rule, Source, Rhs>
+where
+    Source: SelectQuery,
+    Rhs: SelectQuery<SqlType = Source::SqlType>,
+{
+    type SqlType = Source::SqlType;
+}
+
+impl<Combinator, Rule, Source, Rhs, QS> ValidSubselect<QS>
+    for CombinationClause<Combinator, Rule, Source, Rhs>
+where
+    Source: ValidSubselect<QS>,
+    Rhs: ValidSubselect<QS>,
+{
+}
+
 impl<Combinator, Rule, Source, Rhs, Conn> RunQueryDsl<Conn>
     for CombinationClause<Combinator, Rule, Source, Rhs>
 {
diff --git a/diesel_compile_tests/Cargo.lock b/diesel_compile_tests/Cargo.lock
index 0da3f61c9..ee009f56d 100644
--- a/diesel_compile_tests/Cargo.lock
+++ b/diesel_compile_tests/Cargo.lock
@@ -58,7 +58,7 @@ dependencies = [
 
 [[package]]
 name = "diesel"
-version = "2.0.0"
+version = "2.0.2"
 dependencies = [
  "bigdecimal",
  "bitflags",
@@ -92,7 +92,7 @@ dependencies = [
 
 [[package]]
 name = "diesel_derives"
-version = "2.0.0"
+version = "2.0.1"
 dependencies = [
  "proc-macro-error",
  "proc-macro2",
diff --git a/diesel_compile_tests/tests/fail/exists_can_only_take_subselects.stderr b/diesel_compile_tests/tests/fail/exists_can_only_take_subselects.stderr
index 0f6c80255..60fac020c 100644
--- a/diesel_compile_tests/tests/fail/exists_can_only_take_subselects.stderr
+++ b/diesel_compile_tests/tests/fail/exists_can_only_take_subselects.stderr
@@ -7,6 +7,7 @@ error[E0277]: the trait bound `bool: SelectQuery` is not satisfied
    = help: the following other types implement trait `SelectQuery`:
              BoxedSelectStatement<'a, ST, QS, DB, GB>
              SelectStatement<F, S, D, W, O, LOf, G, H, LC>
+             diesel::query_builder::combination_clause::CombinationClause<Combinator, Rule, Source, Rhs>
    = note: required because of the requirements on the impl of `diesel::Expression` for `diesel::expression::subselect::Subselect<bool, Bool>`
    = note: 1 redundant requirement hidden
    = note: required because of the requirements on the impl of `diesel::Expression` for `diesel::expression::exists::Exists<bool>`
@@ -21,6 +22,7 @@ error[E0277]: the trait bound `users::columns::id: SelectQuery` is not satisfied
    = help: the following other types implement trait `SelectQuery`:
              BoxedSelectStatement<'a, ST, QS, DB, GB>
              SelectStatement<F, S, D, W, O, LOf, G, H, LC>
+             diesel::query_builder::combination_clause::CombinationClause<Combinator, Rule, Source, Rhs>
    = note: required because of the requirements on the impl of `diesel::Expression` for `diesel::expression::subselect::Subselect<users::columns::id, Bool>`
    = note: 1 redundant requirement hidden
    = note: required because of the requirements on the impl of `diesel::Expression` for `diesel::expression::exists::Exists<users::columns::id>`
diff --git a/diesel_tests/tests/combination.rs b/diesel_tests/tests/combination.rs
index 262fcde7e..ea6a05e68 100644
--- a/diesel_tests/tests/combination.rs
+++ b/diesel_tests/tests/combination.rs
@@ -146,3 +146,33 @@ fn union_with_order() {
 
     assert_eq!(vec![String::from("Jim"), "Sean".into()], users);
 }
+
+#[test]
+fn as_subquery_for_eq_in() {
+    let conn = &mut connection_with_sean_and_tess_in_users_table();
+
+    insert_into(posts::table)
+        .values(&[
+            (posts::user_id.eq(1), posts::title.eq("First post")),
+            (posts::user_id.eq(2), posts::title.eq("Second post")),
+        ])
+        .execute(conn)
+        .unwrap();
+
+    let subquery = users::table
+        .select(users::id)
+        .filter(users::name.eq("Sean"))
+        .union(
+            users::table
+                .select(users::id)
+                .filter(users::name.ne("Sean")),
+        );
+
+    let out = posts::table
+        .filter(posts::user_id.eq_any(subquery))
+        .select(posts::title)
+        .load::<String>(conn)
+        .unwrap();
+
+    assert_eq!(out, vec!["First post", "Second post"]);
+}
