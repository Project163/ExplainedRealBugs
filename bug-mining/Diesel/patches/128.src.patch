diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9f24ec37c..33cead750 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -36,6 +36,9 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * Subselects can now reference columns from the outer table. For example,
   `users.filter(exists(posts.filter(user_id.eq(users::id))))` will now compile.
 
+* `TextExpressionMethods` is now implemented for expressions of type
+  `Nullable<Text>` as well as `Text`.
+
 ### Changed
 
 * The signatures of `QueryId`, `Column`, and `FromSqlRow` have all changed to
diff --git a/diesel/src/expression/operators.rs b/diesel/src/expression/operators.rs
index 08436b4ea..b75c03a75 100644
--- a/diesel/src/expression/operators.rs
+++ b/diesel/src/expression/operators.rs
@@ -1,6 +1,54 @@
 #[macro_export]
 #[doc(hidden)]
 macro_rules! __diesel_operator_body {
+    (
+        notation = $notation:ident,
+        struct_name = $name:ident,
+        operator = $operator:expr,
+        return_ty = ReturnBasedOnArgs,
+        ty_params = ($($ty_param:ident,)+),
+        field_names = $field_names:tt,
+        backend_ty_params = $backend_ty_params:tt,
+        backend_ty = $backend_ty:ty,
+    ) => {
+        __diesel_operator_body! {
+            notation = $notation,
+            struct_name = $name,
+            operator = $operator,
+            return_ty = ST,
+            ty_params = ($($ty_param,)+),
+            field_names = $field_names,
+            backend_ty_params = $backend_ty_params,
+            backend_ty = $backend_ty,
+            expression_ty_params = (ST,),
+            expression_bounds = ($($ty_param: $crate::expression::Expression<SqlType = ST>,)+),
+        }
+    };
+
+    (
+        notation = $notation:ident,
+        struct_name = $name:ident,
+        operator = $operator:expr,
+        return_ty = $return_ty:ty,
+        ty_params = ($($ty_param:ident,)+),
+        field_names = $field_names:tt,
+        backend_ty_params = $backend_ty_params:tt,
+        backend_ty = $backend_ty:ty,
+    ) => {
+        __diesel_operator_body! {
+            notation = $notation,
+            struct_name = $name,
+            operator = $operator,
+            return_ty = $return_ty,
+            ty_params = ($($ty_param,)+),
+            field_names = $field_names,
+            backend_ty_params = $backend_ty_params,
+            backend_ty = $backend_ty,
+            expression_ty_params = (),
+            expression_bounds = ($($ty_param: $crate::expression::Expression,)+),
+        }
+    };
+
     (
         notation = $notation:ident,
         struct_name = $name:ident,
@@ -10,6 +58,8 @@ macro_rules! __diesel_operator_body {
         field_names = ($($field_name:ident,)+),
         backend_ty_params = ($($backend_ty_param:ident,)*),
         backend_ty = $backend_ty:ty,
+        expression_ty_params = ($($expression_ty_params:ident,)*),
+        expression_bounds = ($($expression_bounds:tt)*),
     ) => {
         #[derive(Debug, Clone, Copy)]
         #[doc(hidden)]
@@ -26,8 +76,8 @@ macro_rules! __diesel_operator_body {
         impl_query_id!($name<$($ty_param),+>);
         impl_selectable_expression!($name<$($ty_param),+>);
 
-        impl<$($ty_param,)+> $crate::expression::Expression for $name<$($ty_param,)+> where
-            $($ty_param: $crate::expression::Expression,)+
+        impl<$($ty_param,)+ $($expression_ty_params,)*> $crate::expression::Expression for $name<$($ty_param,)+> where
+            $($expression_bounds)*
         {
             type SqlType = $return_ty;
         }
@@ -175,12 +225,12 @@ macro_rules! diesel_infix_operator {
         diesel_infix_operator!($name, $operator, $crate::types::Bool, backend: $backend);
     };
 
-    ($name:ident, $operator:expr, $return_ty:ty) => {
+    ($name:ident, $operator:expr, $($return_ty:tt)::*) => {
         __diesel_operator_body!(
             notation = infix,
             struct_name = $name,
             operator = $operator,
-            return_ty = $return_ty,
+            return_ty = $($return_ty)::*,
             ty_params = (T, U,),
             field_names = (left, right,),
             backend_ty_params = (DB,),
@@ -292,7 +342,7 @@ macro_rules! diesel_prefix_operator {
     };
 }
 
-diesel_infix_operator!(Concat, " || ", ::types::Text);
+diesel_infix_operator!(Concat, " || ", ReturnBasedOnArgs);
 diesel_infix_operator!(And, " AND ");
 diesel_infix_operator!(Between, " BETWEEN ");
 diesel_infix_operator!(Escape, " ESCAPE ");
diff --git a/diesel/src/expression_methods/text_expression_methods.rs b/diesel/src/expression_methods/text_expression_methods.rs
index 4cd6330f9..66ab1bcd9 100644
--- a/diesel/src/expression_methods/text_expression_methods.rs
+++ b/diesel/src/expression_methods/text_expression_methods.rs
@@ -1,8 +1,8 @@
 use expression::{AsExpression, Expression};
 use expression::operators::{Concat, Like, NotLike};
-use types::Text;
+use types::{Nullable, Text};
 
-pub trait TextExpressionMethods: Expression<SqlType = Text> + Sized {
+pub trait TextExpressionMethods: Expression + Sized {
     /// Concatenates two strings using the `||` operator.
     ///
     /// # Example
@@ -15,12 +15,28 @@ pub trait TextExpressionMethods: Expression<SqlType = Text> + Sized {
     /// #     users {
     /// #         id -> Integer,
     /// #         name -> VarChar,
+    /// #         hair_color -> Nullable<Text>,
     /// #     }
     /// # }
     /// #
     /// # fn main() {
     /// #     use self::users::dsl::*;
-    /// #     let connection = establish_connection();
+    /// #     use diesel::insert_into;
+    /// #
+    /// #     let connection = connection_no_data();
+    /// #     connection.execute("CREATE TABLE users (
+    /// #         id INTEGER PRIMARY KEY,
+    /// #         name VARCHAR(255) NOT NULL,
+    /// #         hair_color VARCHAR(255)
+    /// #     )").unwrap();
+    /// #
+    /// #     insert_into(users)
+    /// #         .values(&vec![
+    /// #             (id.eq(1), name.eq("Sean"), hair_color.eq(Some("Green"))),
+    /// #             (id.eq(2), name.eq("Tess"), hair_color.eq(None)),
+    /// #         ])
+    /// #         .execute(&connection)
+    /// #         .unwrap();
     /// #
     /// let names = users.select(name.concat(" the Greatest")).load(&connection);
     /// let expected_names = vec![
@@ -28,21 +44,40 @@ pub trait TextExpressionMethods: Expression<SqlType = Text> + Sized {
     ///     "Tess the Greatest".to_string(),
     /// ];
     /// assert_eq!(Ok(expected_names), names);
+    ///
+    /// // If the value is nullable, the output will be nullable
+    /// let names = users.select(hair_color.concat("ish")).load(&connection);
+    /// let expected_names = vec![
+    ///     Some("Greenish".to_string()),
+    ///     None,
+    /// ];
+    /// assert_eq!(Ok(expected_names), names);
     /// # }
     /// ```
-    fn concat<T: AsExpression<Text>>(self, other: T) -> Concat<Self, T::Expression> {
+    fn concat<T: AsExpression<Self::SqlType>>(self, other: T) -> Concat<Self, T::Expression> {
         Concat::new(self, other.as_expression())
     }
 
     /// Returns a SQL `LIKE` expression
-    fn like<T: AsExpression<Text>>(self, other: T) -> Like<Self, T::Expression> {
+    fn like<T: AsExpression<Self::SqlType>>(self, other: T) -> Like<Self, T::Expression> {
         Like::new(self.as_expression(), other.as_expression())
     }
 
     /// Returns a SQL `NOT LIKE` expression
-    fn not_like<T: AsExpression<Text>>(self, other: T) -> NotLike<Self, T::Expression> {
+    fn not_like<T: AsExpression<Self::SqlType>>(self, other: T) -> NotLike<Self, T::Expression> {
         NotLike::new(self.as_expression(), other.as_expression())
     }
 }
 
-impl<T: Expression<SqlType = Text>> TextExpressionMethods for T {}
+#[doc(hidden)]
+pub trait TextOrNullableText {}
+
+impl TextOrNullableText for Text {}
+impl TextOrNullableText for Nullable<Text> {}
+
+impl<T> TextExpressionMethods for T
+where
+    T: Expression,
+    T::SqlType: TextOrNullableText,
+{
+}
