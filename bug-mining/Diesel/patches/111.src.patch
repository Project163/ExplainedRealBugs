diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1a7a90bb3..eadac01e9 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -16,6 +16,12 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
   common cases. You will likely need to delete any manual invocations of this
   macro.
 
+* `Insertable` no longer treats all fields as nullable for type checking. What
+  this means for you is that if you had an impl like `impl
+  AsExpression<Nullable<SqlType>, DB> for CustomType` in your code base, you can
+  remove the `Nullable` portion (Unless you are using it with fields that are
+  actually nullable)
+
 ## [0.14.0] - 2017-07-04
 
 ### Added
diff --git a/diesel/src/expression/helper_types.rs b/diesel/src/expression/helper_types.rs
index bb419d2f3..58919dbdb 100644
--- a/diesel/src/expression/helper_types.rs
+++ b/diesel/src/expression/helper_types.rs
@@ -43,7 +43,3 @@ pub type Not<Expr> = super::operators::Not<Grouped<AsExprOf<Expr, types::Bool>>>
 pub use super::operators::{IsNull, IsNotNull, Asc, Desc};
 #[doc(inline)]
 pub use super::array_comparison::EqAny;
-
-#[doc(hidden)]
-pub type AsNullableExpr<Item, TargetExpr> = AsExprOf<Item,
-    <SqlTypeOf<TargetExpr> as types::IntoNullable>::Nullable>;
diff --git a/diesel/src/insertable.rs b/diesel/src/insertable.rs
index 182187bb8..eb224af0c 100644
--- a/diesel/src/insertable.rs
+++ b/diesel/src/insertable.rs
@@ -1,11 +1,9 @@
 use std::iter;
 
 use backend::{Backend, SupportsDefaultKeyword};
-use expression::Expression;
 use result::QueryResult;
 use query_builder::AstPass;
-use query_source::{Table, Column};
-use types::IntoNullable;
+use query_source::Table;
 
 /// Represents that a structure can be used to to insert a new row into the
 /// database. This is automatically implemented for `&[T]` and `&Vec<T>` for
@@ -30,11 +28,7 @@ pub trait InsertValues<DB: Backend> {
 }
 
 #[derive(Debug, Copy, Clone)]
-pub enum ColumnInsertValue<Col, Expr> where
-    Col: Column,
-    Col::SqlType: IntoNullable,
-    Expr: Expression<SqlType=<Col::SqlType as IntoNullable>::Nullable>,
-{
+pub enum ColumnInsertValue<Col, Expr> {
     Expression(Col, Expr),
     Default(Col),
 }
diff --git a/diesel/src/macros/insertable.rs b/diesel/src/macros/insertable.rs
index 862b21d4c..397c76c4c 100644
--- a/diesel/src/macros/insertable.rs
+++ b/diesel/src/macros/insertable.rs
@@ -117,8 +117,9 @@ macro_rules! impl_Insertable {
         ),
         fields = [$({
             column_name: $column_name:ident,
-            field_ty: $field_ty:ty,
+            field_ty: $ignore:ty,
             field_kind: $field_kind:ident,
+            inner_field_ty: $field_ty:ty,
             $($rest:tt)*
         })+],
     ) => {
@@ -138,8 +139,9 @@ macro_rules! impl_Insertable {
         fields = [$({
             field_name: $field_name:ident,
             column_name: $column_name:ident,
-            field_ty: $field_ty:ty,
+            field_ty: $ignore:ty,
             field_kind: $field_kind:ident,
+            inner_field_ty: $field_ty:ty,
             $($rest:tt)*
         })+],
     ) => {
@@ -163,7 +165,7 @@ macro_rules! impl_Insertable {
                 ($(
                     $crate::insertable::ColumnInsertValue<
                         $table_name::$column_name,
-                        $crate::expression::helper_types::AsNullableExpr<
+                        $crate::expression::helper_types::AsExpr<
                             &'insert $field_ty,
                             $table_name::$column_name,
                         >,
@@ -173,7 +175,7 @@ macro_rules! impl_Insertable {
             type Values = ($(
                 $crate::insertable::ColumnInsertValue<
                     $table_name::$column_name,
-                    $crate::expression::helper_types::AsNullableExpr<
+                    $crate::expression::helper_types::AsExpr<
                         &'insert $field_ty,
                         $table_name::$column_name,
                     >,
@@ -184,7 +186,6 @@ macro_rules! impl_Insertable {
             fn values(self) -> Self::Values {
                 use $crate::expression::{AsExpression, Expression};
                 use $crate::insertable::ColumnInsertValue;
-                use $crate::types::IntoNullable;
                 let $self_to_columns = *self;
                 ($(
                     Insertable_column_expr!($table_name::$column_name, $column_name, $field_kind)
@@ -218,16 +219,16 @@ macro_rules! impl_Insertable {
 #[macro_export]
 macro_rules! Insertable_column_expr {
     ($column:path, $field_access:expr, option) => {
-        match $field_access {
-            value @ &Some(_) => Insertable_column_expr!($column, value, regular),
-            &None => ColumnInsertValue::Default($column),
+        match *$field_access {
+            Some(ref value) => Insertable_column_expr!($column, value, regular),
+            None => ColumnInsertValue::Default($column),
         }
     };
 
     ($column:path, $field_access:expr, regular) => {
         ColumnInsertValue::Expression(
             $column,
-            AsExpression::<<<$column as Expression>::SqlType as IntoNullable>::Nullable>
+            AsExpression::<<$column as Expression>::SqlType>
                 ::as_expression($field_access),
         )
     };
diff --git a/diesel/src/types/impls/tuples.rs b/diesel/src/types/impls/tuples.rs
index 072dcc87d..bd3f63d62 100644
--- a/diesel/src/types/impls/tuples.rs
+++ b/diesel/src/types/impls/tuples.rs
@@ -8,7 +8,7 @@ use query_builder::*;
 use query_source::{QuerySource, Queryable, Table, Column};
 use result::QueryResult;
 use row::Row;
-use types::{HasSqlType, FromSqlRow, Nullable, IntoNullable, NotNull};
+use types::{HasSqlType, FromSqlRow, Nullable, NotNull};
 use util::TupleAppend;
 
 macro_rules! tuple_impls {
@@ -116,8 +116,7 @@ macro_rules! tuple_impls {
                     DB: Backend + SupportsDefaultKeyword,
                     Tab: Table,
                     $($T: Column<Table=Tab>,)+
-                    $($T::SqlType: IntoNullable,)+
-                    $($ST: Expression<SqlType=<$T::SqlType as IntoNullable>::Nullable> + QueryFragment<DB>,)+
+                    $($ST: Expression<SqlType=$T::SqlType> + QueryFragment<DB>,)+
             {
                 fn column_names(&self, out: &mut DB::QueryBuilder) -> QueryResult<()> {
                     $(
@@ -151,8 +150,7 @@ macro_rules! tuple_impls {
                 for ($(ColumnInsertValue<$T, $ST>,)+) where
                     Tab: Table,
                     $($T: Column<Table=Tab>,)+
-                    $($T::SqlType: IntoNullable,)+
-                    $($ST: Expression<SqlType=<$T::SqlType as IntoNullable>::Nullable> + QueryFragment<::sqlite::Sqlite>,)+
+                    $($ST: Expression<SqlType=$T::SqlType> + QueryFragment<::sqlite::Sqlite>,)+
             {
                 #[allow(unused_assignments)]
                 fn column_names(&self, out: &mut ::sqlite::SqliteQueryBuilder) -> QueryResult<()> {
diff --git a/diesel_tests/tests/annotations.rs b/diesel_tests/tests/annotations.rs
index 5fa76654e..186a85c0d 100644
--- a/diesel_tests/tests/annotations.rs
+++ b/diesel_tests/tests/annotations.rs
@@ -251,3 +251,25 @@ fn derive_insertable_with_option_for_not_null_field_with_default() {
     assert!(jim.is_some());
     assert_eq!(Some(&User::new(123, "Bob")), bob);
 }
+
+#[test]
+#[cfg(feature="postgres")]
+fn derive_insertable_with_field_that_cannot_convert_expression_to_nullable() {
+    use diesel::types::{Text, Serial};
+    sql_function!(nextval, nextval_t, (a: Text) -> Serial);
+    #[derive(Insertable)]
+    #[table_name="users"]
+    struct NewUser {
+        id: nextval<&'static str>,
+        name: &'static str,
+    }
+
+    let conn = connection();
+    let data = NewUser { id: nextval("users_id_seq"), name: "Jim" };
+    assert_eq!(Ok(1), insert(&data).into(users::table).execute(&conn));
+
+    let users = users::table.load::<User>(&conn).unwrap();
+    let jim = users.iter().find(|u| u.name == "Jim");
+
+    assert!(jim.is_some());
+}
