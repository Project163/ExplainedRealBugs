diff --git a/CHANGELOG.md b/CHANGELOG.md
index 545c56b84..9e6adbc43 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -29,6 +29,9 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
   instead of skipping the field entirely. The default value of the option is
   `false`, as we think the current behavior is a much more common use case.
 
+* Added `Expression#nullable()`, to allow comparisons of not null columns with
+  nullable ones when required.
+
 ### Changed
 
 * Rename both the `#[derive(Queriable)]` attribute and the `Queriable` trait to
diff --git a/diesel/src/expression/expression_methods/global_expression_methods.rs b/diesel/src/expression/expression_methods/global_expression_methods.rs
index aaed70ca8..adaef96fc 100644
--- a/diesel/src/expression/expression_methods/global_expression_methods.rs
+++ b/diesel/src/expression/expression_methods/global_expression_methods.rs
@@ -1,7 +1,6 @@
-use expression::{Expression, AsExpression};
+use expression::{Expression, AsExpression, ordering, nullable};
 use expression::aliased::Aliased;
 use expression::predicates::*;
-use expression::ordering;
 
 pub trait ExpressionMethods: Expression + Sized {
     /// Alias an expression for use alongside
@@ -249,6 +248,63 @@ pub trait ExpressionMethods: Expression + Sized {
     fn asc(self) -> ordering::Asc<Self> {
         ordering::Asc::new(self)
     }
+
+    /// Converts this potentially non-null expression into one which is treated
+    /// as nullable. This method has no impact on the generated SQL, and is only
+    /// used to allow certain comparisons that would otherwise fail to compile.
+    ///
+    /// # Example
+    /// ```no_run
+    /// # #![allow(dead_code)]
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("src/doctest_setup.rs");
+    /// # use self::diesel::types::*;
+    /// #
+    /// table! {
+    ///     users {
+    ///         id -> Serial,
+    ///         name -> VarChar,
+    ///     }
+    /// }
+    ///
+    /// table! {
+    ///     posts {
+    ///         id -> Serial,
+    ///         user_id -> Integer,
+    ///         author_name -> Nullable<VarChar>,
+    ///     }
+    /// }
+    /// #
+    /// #  pub struct User {
+    /// #      id: i32,
+    /// #      name: VarChar,
+    /// #  }
+    /// #
+    /// #  pub struct Post {
+    /// #      id: i32,
+    /// #      user_id: i32,
+    /// #      author_name: Option<VarChar>,
+    /// #  }
+    /// #
+    /// #  joinable!(posts -> users (user_id = id));
+    /// #  select_column_workaround!(posts -> users (id, user_id, author_name));
+    /// #  select_column_workaround!(users -> posts (id, name));
+    ///
+    /// fn main() {
+    ///     use self::users::dsl::*;
+    ///     use self::posts::dsl::{posts, author_name};
+    ///     let connection = establish_connection();
+    ///
+    ///     let data = users.inner_join(posts)
+    ///         .filter(name.nullable().eq(author_name))
+    ///         .select(name)
+    ///         .load(&connection).unwrap()
+    ///         .collect::<Vec<String>>();
+    ///     println!("{:?}", data);
+    /// }
+    fn nullable(self) -> nullable::Nullable<Self> {
+        nullable::Nullable::new(self)
+    }
 }
 
 impl<T: Expression> ExpressionMethods for T {}
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index f80d75daf..c4ca5a273 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -35,6 +35,8 @@ pub mod functions;
 pub mod grouped;
 pub mod helper_types;
 #[doc(hidden)]
+pub mod nullable;
+#[doc(hidden)]
 pub mod ordering;
 #[doc(hidden)]
 pub mod predicates;
diff --git a/diesel/src/expression/nullable.rs b/diesel/src/expression/nullable.rs
new file mode 100644
index 000000000..2599b4f65
--- /dev/null
+++ b/diesel/src/expression/nullable.rs
@@ -0,0 +1,38 @@
+use expression::{Expression, SelectableExpression, NonAggregate};
+use query_builder::{QueryBuilder, BuildQueryResult};
+use types::IntoNullable;
+
+pub struct Nullable<T>(T);
+
+impl<T> Nullable<T> {
+    pub fn new(expr: T) -> Self {
+        Nullable(expr)
+    }
+}
+
+impl<T> Expression for Nullable<T> where
+    T: Expression,
+    <T as Expression>::SqlType: IntoNullable,
+{
+    type SqlType = <<T as Expression>::SqlType as IntoNullable>::Nullable;
+
+    fn to_sql(&self, out: &mut QueryBuilder) -> BuildQueryResult {
+        self.0.to_sql(out)
+    }
+
+    fn to_insert_sql(&self, out: &mut QueryBuilder) -> BuildQueryResult {
+        self.0.to_insert_sql(out)
+    }
+}
+
+impl<T, QS> SelectableExpression<QS> for Nullable<T> where
+    T: SelectableExpression<QS>,
+    Nullable<T>: Expression,
+{
+}
+
+impl<T> NonAggregate for Nullable<T> where
+    T: NonAggregate,
+    Nullable<T>: Expression,
+{
+}
diff --git a/diesel/src/macros.rs b/diesel/src/macros.rs
index 922b79404..9b4618c54 100644
--- a/diesel/src/macros.rs
+++ b/diesel/src/macros.rs
@@ -287,7 +287,7 @@ macro_rules! joinable_inner {
                 try!($parent::table.from_clause(out));
                 out.push_sql(" ON ");
 
-                $child::$source.eq($parent::$target).to_sql(out)
+                $child::$source.nullable().eq($parent::$target.nullable()).to_sql(out)
             }
         }
     }
diff --git a/diesel_codegen/src/associations/belongs_to.rs b/diesel_codegen/src/associations/belongs_to.rs
index 055fd6003..29714d19d 100644
--- a/diesel_codegen/src/associations/belongs_to.rs
+++ b/diesel_codegen/src/associations/belongs_to.rs
@@ -10,6 +10,7 @@ use syntax::ptr::P;
 
 use model::Model;
 use super::{parse_association_options, AssociationOptions, to_foreign_key};
+use util::ty_param_of_option;
 
 pub fn expand_belongs_to(
     cx: &mut ExtCtxt,
@@ -87,6 +88,12 @@ impl<'a, 'b> BelongsToAssociationBuilder<'a, 'b> {
         str_to_ident("id")
     }
 
+    fn primary_key_type(&self) -> P<ast::Ty> {
+        let ty = self.foreign_key_type();
+        ty_param_of_option(&ty).map(|t| t.clone())
+            .unwrap_or(ty)
+    }
+
     fn column_path(&self, column_name: ast::Ident) -> ast::Path {
         self.cx.path(self.span, vec![self.child_table_name(), column_name])
     }
@@ -109,7 +116,7 @@ fn belonging_to_dsl_impl(builder: &BelongsToAssociationBuilder) -> P<ast::Item>
     let child_struct_name = builder.child_struct_name();
     let child_table = builder.child_table();
     let foreign_key = builder.foreign_key();
-    let foreign_key_type = builder.foreign_key_type();
+    let primary_key_type = builder.primary_key_type();
     let primary_key_name = builder.primary_key_name();
 
     quote_item!(builder.cx,
@@ -117,7 +124,7 @@ fn belonging_to_dsl_impl(builder: &BelongsToAssociationBuilder) -> P<ast::Item>
             type Output = ::diesel::helper_types::FindBy<
                 $child_table,
                 $foreign_key,
-                $foreign_key_type,
+                $primary_key_type,
             >;
 
             fn belonging_to(model: &$parent_struct_name) -> Self::Output {
@@ -139,7 +146,7 @@ fn join_to_impl(builder: &BelongsToAssociationBuilder) -> P<ast::Item> {
             {
                 try!($parent_table.from_clause(out));
                 out.push_sql(" ON ");
-                $foreign_key.eq($parent_table.primary_key()).to_sql(out)
+                $foreign_key.nullable().eq($parent_table.primary_key().nullable()).to_sql(out)
             }
         }
     ).unwrap()
diff --git a/diesel_codegen/src/associations/has_many.rs b/diesel_codegen/src/associations/has_many.rs
index 34c4577c3..f3247d6cc 100644
--- a/diesel_codegen/src/associations/has_many.rs
+++ b/diesel_codegen/src/associations/has_many.rs
@@ -83,7 +83,7 @@ fn join_to_impl(builder: &HasManyAssociationBuilder) -> P<ast::Item> {
                 try!($foreign_table.from_clause(out));
                 out.push_sql(" ON ");
                 ::diesel::expression::Expression::to_sql(
-                    &$foreign_key.eq($table.primary_key()),
+                    &$foreign_key.nullable().eq($table.primary_key().nullable()),
                     out,
                 )
             }
diff --git a/diesel_codegen/src/update.rs b/diesel_codegen/src/update.rs
index b564ae3da..1896691e6 100644
--- a/diesel_codegen/src/update.rs
+++ b/diesel_codegen/src/update.rs
@@ -1,13 +1,14 @@
-use syntax::ast::{self, MetaItem, TyPath};
+use syntax::ast::{self, MetaItem};
 use syntax::attr::AttrMetaMethods;
 use syntax::codemap::Span;
 use syntax::ext::base::{Annotatable, ExtCtxt};
 use syntax::ext::build::AstBuilder;
 use syntax::ptr::P;
-use syntax::parse::token::{InternedString, intern_and_get_ident, str_to_ident};
+use syntax::parse::token::{InternedString, str_to_ident};
 
 use attr::Attr;
 use model::Model;
+use util::ty_param_of_option;
 
 pub fn expand_changeset_for(
     cx: &mut ExtCtxt,
@@ -196,18 +197,6 @@ fn changeset_expr(
     }
 }
 
-fn ty_param_of_option(ty: &ast::Ty) -> Option<&P<ast::Ty>> {
-    match ty.node {
-        TyPath(_, ref path) => {
-            path.segments.first().iter()
-                .filter(|s| s.identifier.name.as_str() == intern_and_get_ident("Option"))
-                .flat_map(|s| s.parameters.types().first().map(|p| *p))
-                .next()
-        }
-        _ => None,
-    }
-}
-
 fn is_option_ty(ty: &ast::Ty) -> bool {
     ty_param_of_option(ty).is_some()
 }
diff --git a/diesel_codegen/src/util.rs b/diesel_codegen/src/util.rs
index 88190b385..0f9f4502c 100644
--- a/diesel_codegen/src/util.rs
+++ b/diesel_codegen/src/util.rs
@@ -3,7 +3,7 @@ use syntax::attr::AttrMetaMethods;
 use syntax::codemap::Span;
 use syntax::ext::base::ExtCtxt;
 use syntax::ext::build::AstBuilder;
-use syntax::parse::token::str_to_ident;
+use syntax::parse::token::{str_to_ident, intern_and_get_ident};
 use syntax::ptr::P;
 
 fn str_value_of_attr(
@@ -65,3 +65,15 @@ pub fn struct_ty(
         .collect();
     cx.ty_path(cx.path_all(span, false, vec![name], lifetimes, ty_params, Vec::new()))
 }
+
+pub fn ty_param_of_option(ty: &ast::Ty) -> Option<&P<ast::Ty>> {
+    match ty.node {
+        ast::TyPath(_, ref path) => {
+            path.segments.first().iter()
+                .filter(|s| s.identifier.name.as_str() == intern_and_get_ident("Option"))
+                .flat_map(|s| s.parameters.types().first().map(|p| *p))
+                .next()
+        }
+        _ => None,
+    }
+}
diff --git a/diesel_tests/tests/annotations.rs b/diesel_tests/tests/annotations.rs
index 25c3ebd8b..556bf16f9 100644
--- a/diesel_tests/tests/annotations.rs
+++ b/diesel_tests/tests/annotations.rs
@@ -86,3 +86,33 @@ fn association_where_parent_and_child_have_underscores() {
 
     assert_eq!(special_post.id, comment.special_post_id);
 }
+
+// This module has no test functions, as it's only to test compilation.
+mod associations_can_have_nullable_foreign_keys {
+    #![allow(dead_code)]
+    use diesel::prelude::*;
+
+    table! {
+        foos{
+            id -> Serial,
+        }
+    }
+
+    table! {
+        bars {
+            id -> Serial,
+            foo_id -> Nullable<Integer>,
+        }
+    }
+    // This test has no assertions, as it is for compilation purposes only.
+    #[has_many(bars)]
+    pub struct Foo {
+        id: i32,
+    }
+
+    #[belongs_to(foo)]
+    pub struct Bar {
+        id: i32,
+        foo_id: Option<i32>,
+    }
+}
