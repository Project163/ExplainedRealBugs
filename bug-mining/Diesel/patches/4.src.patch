diff --git a/README.md b/README.md
index a5674fa29..687b3b9ed 100644
--- a/README.md
+++ b/README.md
@@ -177,7 +177,7 @@ fn change_users_name(connection: &Connection, target: i32, new_name: &str) -> Qu
     use users::dsl::*;
 
     let command = update(users.filter(id.eq(target))).set(name.eq(new_name));
-    connection.query_one(&command)
+    connection.query_one(command)
         .map(|r| r.unwrap())
 }
 ```
@@ -191,30 +191,32 @@ right types. If you do not want to use the returned record(s), you should call
 `execute_returning_count` instead of `query_one` or `query_all`.
 
 You can also use a struct to represent the changes, if it implements
-`AsChangeset`. You can generate that from a macro (FIXME: This should be a
-compiler annotation not long after the time of writing this. If it is later than
-12/5/15, please open an issue as I'm being lazy).
+`AsChangeset`. Again, `yaqb_codegen` can generate this for us automatically.
 
 ```rust
-changeset! {
-    User => users {
-        name -> String,
-        favorite_color -> Option<String>,
-    }
+#[changeset_for(users)]
+pub struct User {
+    id: i32,
+    name: String,
+    favorite_color: Option<String>,
 }
 
 fn save_user(connection: &Connection, user: &mut User) -> QueryResult<()> {
-    let command = update(users::table.filter(users::id.eq(user.id)))
-        .set(user);
-    let updated_user = try!(connection.query_one(&command)).unwrap();
-    *user = updated_user;
+    use self::users::dsl::*;
+
+    *user = {
+        let command = update(users.filter(id.eq(user.id))).set(&*user);
+        try!(connection.query_one(command)).unwrap()
+    };
     Ok(())
 }
 ```
 
-Note that even though we've implemented `AsChangeset`, we still need to specify
-what records we want to update. There will likely be changes that make it harder
-to accidentally update the entire table before 1.0.
+We need to set `&*user` here, because we've taken a mutable reference, and
+`AsChangeset` is only implemented for `&User`, not `&mut User`. Note that even
+though we've implemented `AsChangeset`, we still need to specify what records we
+want to update. There will likely be changes that make it harder to accidentally
+update the entire table before 1.0.
 
 Delete
 ------
diff --git a/yaqb/src/macros.rs b/yaqb/src/macros.rs
index af02f5567..ccc834193 100644
--- a/yaqb/src/macros.rs
+++ b/yaqb/src/macros.rs
@@ -262,35 +262,6 @@ macro_rules! table_body {
     }
 }
 
-#[macro_export]
-macro_rules! changeset {
-    (
-        $Struct:ty => $table_mod:ident {
-            $($field_name:ident -> $Type:ty,)+
-        }
-    ) => {
-        impl<'a: 'update, 'update> $crate::query_builder::AsChangeset
-            for &'update $Struct
-        {
-            type Changeset = ($(
-                $crate::expression::predicates::Eq<
-                    $table_mod::$field_name,
-                    $crate::expression::bound::Bound<
-                        <$table_mod::$field_name as $crate::expression::Expression>::SqlType,
-                        &'update $Type,
-                    >,
-                >
-            ),+);
-
-            fn as_changeset(self) -> Self::Changeset {
-                ($(
-                    $table_mod::$field_name.eq(&self.$field_name)
-                ),+)
-            }
-        }
-    };
-}
-
 #[macro_export]
 macro_rules! joinable {
     ($child:ident -> $parent:ident ($source:ident = $target:ident)) => {
diff --git a/yaqb_codegen/src/associations/belongs_to.rs b/yaqb_codegen/src/associations/belongs_to.rs
index be8bd2a51..a8fc7506c 100644
--- a/yaqb_codegen/src/associations/belongs_to.rs
+++ b/yaqb_codegen/src/associations/belongs_to.rs
@@ -10,7 +10,6 @@ use syntax::parse::token::str_to_ident;
 use syntax::ptr::P;
 
 use model::Model;
-use attr::Attr;
 use super::{parse_association_options, AssociationOptions, to_foreign_key};
 
 pub fn expand_belongs_to(
diff --git a/yaqb_codegen/src/associations/has_many.rs b/yaqb_codegen/src/associations/has_many.rs
index 82966f5f4..7f03ddb21 100644
--- a/yaqb_codegen/src/associations/has_many.rs
+++ b/yaqb_codegen/src/associations/has_many.rs
@@ -6,11 +6,10 @@ use syntax::ast::{
 };
 use syntax::codemap::Span;
 use syntax::ext::base::{Annotatable, ExtCtxt};
-use syntax::parse::token::str_to_ident;
 use syntax::ptr::P;
+use syntax::parse::token::str_to_ident;
 
 use model::Model;
-use attr::Attr;
 use super::{parse_association_options, AssociationOptions, to_foreign_key};
 
 pub fn expand_has_many(
@@ -41,18 +40,10 @@ struct HasManyAssociationBuilder {
 }
 
 impl HasManyAssociationBuilder {
-    fn struct_name(&self) -> &P<ast::Ty> {
-        &self.model.ty
-    }
-
     fn association_name(&self) -> ast::Ident {
         self.options.name
     }
 
-    fn primary_key(&self) -> &Attr {
-        self.model.primary_key()
-    }
-
     fn foreign_table(&self) -> ast::Path {
         self.builder.path()
             .segment(self.association_name()).build()
diff --git a/yaqb_codegen/src/associations/mod.rs b/yaqb_codegen/src/associations/mod.rs
index 26fb16b22..8b5e322a1 100644
--- a/yaqb_codegen/src/associations/mod.rs
+++ b/yaqb_codegen/src/associations/mod.rs
@@ -1,16 +1,10 @@
 use aster;
-use syntax::ast::{
-    self,
-    Item,
-    MetaItem,
-};
+use syntax::ast::{self, MetaItem};
 use syntax::codemap::Span;
 use syntax::ext::base::{Annotatable, ExtCtxt};
 use syntax::parse::token::str_to_ident;
-use syntax::ptr::P;
 
 use model::Model;
-use attr::Attr;
 
 mod has_many;
 mod belongs_to;
diff --git a/yaqb_codegen/src/attr.rs b/yaqb_codegen/src/attr.rs
index d2b865e31..e2b2a778f 100644
--- a/yaqb_codegen/src/attr.rs
+++ b/yaqb_codegen/src/attr.rs
@@ -4,6 +4,7 @@ use syntax::ext::base::ExtCtxt;
 use syntax::ptr::P;
 use syntax::parse::token::str_to_ident;
 
+#[derive(Debug, PartialEq, Eq)]
 pub struct Attr {
     pub column_name: ast::Ident,
     pub field_name: Option<ast::Ident>,
diff --git a/yaqb_codegen/src/lib.rs b/yaqb_codegen/src/lib.rs
index 2c3efd74d..b76bad889 100644
--- a/yaqb_codegen/src/lib.rs
+++ b/yaqb_codegen/src/lib.rs
@@ -1,5 +1,6 @@
 #![feature(rustc_private, plugin, plugin_registrar)]
 #![plugin(quasi_macros)]
+#![deny(warnings)]
 
 extern crate aster;
 extern crate quasi;
@@ -12,6 +13,7 @@ mod attr;
 mod insertable;
 mod model;
 mod queriable;
+mod update;
 
 #[plugin_registrar]
 pub fn register(reg: &mut rustc_plugin::Registry) {
@@ -25,6 +27,10 @@ pub fn register(reg: &mut rustc_plugin::Registry) {
         intern("insertable_into"),
         MultiDecorator(Box::new(insertable::expand_insert))
     );
+    reg.register_syntax_extension(
+        intern("changeset_for"),
+        MultiDecorator(Box::new(update::expand_changeset_for)),
+    );
     reg.register_syntax_extension(
         intern("has_many"),
         MultiDecorator(Box::new(associations::expand_has_many))
diff --git a/yaqb_codegen/src/model.rs b/yaqb_codegen/src/model.rs
index cb217b2c2..077ea9a34 100644
--- a/yaqb_codegen/src/model.rs
+++ b/yaqb_codegen/src/model.rs
@@ -19,8 +19,10 @@ impl Model {
         annotatable: &Annotatable,
     ) -> Option<Self> {
         if let Annotatable::Item(ref item) = *annotatable {
-            let ty = builder.ty().id(item.ident);
-            Attr::from_item(cx, item).map(|(_, attrs)| {
+            Attr::from_item(cx, item).map(|(generics, attrs)| {
+                let ty = builder.ty().path()
+                    .segment(item.ident).with_generics(generics.clone())
+                    .build().build();
                 Model {
                     ty: ty,
                     attrs: attrs,
@@ -32,10 +34,8 @@ impl Model {
         }
     }
 
-    pub fn primary_key(&self) -> &Attr {
-        self.attrs.iter().find(|attr| {
-            attr.field_name == Some(str_to_ident("id"))
-        }).expect("primary key must be named `id` for now")
+    pub fn primary_key_name(&self) -> ast::Ident {
+        str_to_ident("id")
     }
 
     pub fn table_name(&self) -> ast::Ident {
diff --git a/yaqb_codegen/src/update.rs b/yaqb_codegen/src/update.rs
new file mode 100644
index 000000000..bb322f45a
--- /dev/null
+++ b/yaqb_codegen/src/update.rs
@@ -0,0 +1,114 @@
+use aster;
+use syntax::ast::{self, MetaItem};
+use syntax::codemap::Span;
+use syntax::ext::base::{Annotatable, ExtCtxt};
+use syntax::ptr::P;
+use syntax::parse::token::InternedString;
+
+use attr::Attr;
+use model::Model;
+
+pub fn expand_changeset_for(
+    cx: &mut ExtCtxt,
+    span: Span,
+    meta_item: &MetaItem,
+    annotatable: &Annotatable,
+    push: &mut FnMut(Annotatable),
+) {
+    let builder = aster::AstBuilder::new().span(span);
+
+    if let Some(model) = Model::from_annotable(cx, &builder, annotatable) {
+        let table = changeset_tables(cx, meta_item).unwrap();
+        push(Annotatable::Item(changeset_impl(cx, builder, table, &model).unwrap()));
+    } else {
+        cx.span_err(meta_item.span,
+            "`changeset_for` may only be apllied to enums and structs");
+    }
+}
+
+fn changeset_tables(cx: &mut ExtCtxt, meta_item: &MetaItem) -> Option<InternedString> {
+    match meta_item.node {
+        ast::MetaList(_, ref meta_items) => {
+            meta_items.iter().filter_map(|i| table_name(cx, i)).nth(0)
+        }
+        _ => usage_error(cx, meta_item),
+    }
+}
+
+fn table_name(cx: &mut ExtCtxt, meta_item: &MetaItem) -> Option<InternedString> {
+    match meta_item.node {
+        ast::MetaWord(ref word) => Some(word.clone()),
+        _ => usage_error(cx, meta_item),
+    }
+}
+
+fn usage_error<T>(cx: &mut ExtCtxt, meta_item: &MetaItem) -> Option<T> {
+    cx.span_err(meta_item.span,
+        "`changeset_for` must be used in the form `#[changeset_for(table1)]`");
+    None
+}
+
+fn changeset_impl(
+    cx: &mut ExtCtxt,
+    builder: aster::AstBuilder,
+    table: InternedString,
+    model: &Model,
+) -> Option<P<ast::Item>> {
+    let ref struct_name = model.ty;
+    let pk = model.primary_key_name();
+    let attrs_for_changeset = model.attrs.iter().filter(|a| a.column_name != pk)
+        .collect::<Vec<_>>();
+    let changeset_ty = builder.ty().tuple()
+        .with_tys(attrs_for_changeset.iter().map(|a| changeset_ty(cx, builder, &table, a)))
+        .build();
+    let changeset_body = builder.expr().tuple()
+        .with_exprs(attrs_for_changeset.iter().map(|a| changeset_expr(cx, builder, &table, a)))
+        .build();
+    quote_item!(cx,
+        impl<'a: 'update, 'update> ::yaqb::query_builder::AsChangeset for
+            &'update $struct_name
+        {
+            type Changeset = $changeset_ty;
+
+            fn as_changeset(self) -> Self::Changeset {
+                $changeset_body
+            }
+        }
+    )
+}
+
+fn changeset_ty(
+    cx: &mut ExtCtxt,
+    builder: aster::AstBuilder,
+    table: &str,
+    attr: &Attr,
+) -> P<ast::Ty> {
+    let column = builder.path()
+        .segment(table).build()
+        .segment(attr.column_name).build()
+        .build();
+    let field_ty = &attr.ty;
+    quote_ty!(cx,
+        ::yaqb::expression::predicates::Eq<
+            $column,
+            ::yaqb::expression::bound::Bound<
+                <$column as ::yaqb::expression::Expression>::SqlType,
+                &'update $field_ty,
+            >,
+        >
+    )
+}
+
+fn changeset_expr(
+    cx: &mut ExtCtxt,
+    builder: aster::AstBuilder,
+    table: &str,
+    attr: &Attr,
+) -> P<ast::Expr> {
+    let column = builder.path()
+        .segment(table).build()
+        .segment(attr.column_name).build()
+        .build();
+    let field_name = &attr.field_name.unwrap();
+    quote_expr!(cx, $column.eq(&self.$field_name))
+}
diff --git a/yaqb_tests/tests/schema.rs b/yaqb_tests/tests/schema.rs
index e164c5b97..bef57e336 100644
--- a/yaqb_tests/tests/schema.rs
+++ b/yaqb_tests/tests/schema.rs
@@ -2,6 +2,7 @@ use yaqb::*;
 extern crate dotenv;
 
 #[derive(PartialEq, Eq, Debug, Clone, Queriable)]
+#[changeset_for(users)]
 #[has_many(posts)]
 pub struct User {
     pub id: i32,
@@ -89,6 +90,7 @@ join_through!(users -> posts -> comments);
 
 #[derive(Debug, PartialEq, Eq, Queriable)]
 #[insertable_into(users)]
+#[changeset_for(users)]
 pub struct NewUser {
     pub name: String,
     pub hair_color: Option<String>,
@@ -103,13 +105,6 @@ impl NewUser {
     }
 }
 
-changeset! {
-    NewUser => users {
-        name -> String,
-        hair_color -> Option<String>,
-    }
-}
-
 #[insertable_into(posts)]
 pub struct NewPost {
     user_id: i32,
diff --git a/yaqb_tests/tests/update.rs b/yaqb_tests/tests/update.rs
index b445b62e3..8ad24678f 100644
--- a/yaqb_tests/tests/update.rs
+++ b/yaqb_tests/tests/update.rs
@@ -101,3 +101,17 @@ fn update_with_struct_as_changes() {
 
     assert_eq!(Some(expected_user), user);
 }
+
+#[test]
+fn update_with_struct_does_not_set_primary_key() {
+    use schema::users::dsl::*;
+
+    let connection = connection_with_sean_and_tess_in_users_table();
+    let changes = User::with_hair_color(2, "Jim", "blue");
+    let command = update(users.filter(id.eq(1))).set(&changes);
+
+    let user = connection.query_one(command).unwrap();
+    let expected_user = User::with_hair_color(1, "Jim", "blue");
+
+    assert_eq!(Some(expected_user), user);
+}
