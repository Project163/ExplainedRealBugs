diff --git a/CHANGELOG.md b/CHANGELOG.md
index b057115c6..70ed5f71d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -22,6 +22,18 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
   The generated module will still be called `table_1`.
 
+* The `infer_table_from_schema!` macro now allows custom schemas to be
+  specified. Example:
+
+  ```rust
+  infer_table_from_schema!("dotenv:DATABASE_URL", "schema_1.table_1");
+  ```
+
+* The `infer_schema!` optionally allows a schema name as the second argument. Any
+  schemas other than `public` will be wrapped in a module with the same name as
+  the schema. For example, `schema_1.table_1` would be referenced as
+  `schema_1::table_1`.
+
 * Added support for batch insert on SQLite. This means that you can now pass a
   slice or vector to [`diesel::insert`][insert] on all backends.
 
diff --git a/diesel/src/macros/macros_from_codegen.rs b/diesel/src/macros/macros_from_codegen.rs
index 7a7455333..5b4d22fd6 100644
--- a/diesel/src/macros/macros_from_codegen.rs
+++ b/diesel/src/macros/macros_from_codegen.rs
@@ -1,11 +1,13 @@
 #[macro_export]
 /// Queries the database for the names of all tables, and calls
 /// [`infer_table_from_schema!`](macro.infer_table_from_schema!.html) for each
-/// one.
+/// one. A schema name can optionally be passed to load from schemas other than
+/// the default. If a schema name is given, the inferred tables will be wrapped
+/// in a module with the same name.
 ///
-/// Attempting to use the `env!` or `dotenv!` macros here will not work due to limitations of
-/// the Macros 1.1 system, but you can pass a string in the form `"env:SOME_ENV_VAR"` or
-/// `"dotenv:SOME_ENV_VAR"` to achieve the same effect.
+/// Attempting to use the `env!` or `dotenv!` macros here will not work due to
+/// limitations of the Macros 1.1 system, but you can pass a string in the form
+/// `"env:SOME_ENV_VAR"` or `"dotenv:SOME_ENV_VAR"` to achieve the same effect.
 ///
 /// This macro can only be used in combination with the `diesel_codegen` or
 /// `diesel_codegen_syntex` crates. It will not work on its own.
@@ -17,20 +19,33 @@ macro_rules! infer_schema {
             struct _Dummy;
         }
         pub use self::__diesel_infer_schema::*;
-    }
+    };
+
+    ($database_url: expr, $schema_name: expr) => {
+        mod __diesel_infer_schema {
+            #[derive(InferSchema)]
+            #[options(database_url=$database_url, schema_name=$schema_name)]
+            struct _Dummy;
+        }
+        pub use self::__diesel_infer_schema::*;
+    };
 }
 
 #[macro_export]
-/// Establishes a database connection at compile time, loads the schema information about a table's
-/// columns, and invokes [`table!`](macro.table!.html) for you automatically.
+/// Establishes a database connection at compile time, loads the schema
+/// information about a table's columns, and invokes
+/// [`table!`](macro.table!.html) for you automatically. For tables in a schema
+/// other than the default, the table name should be given as
+/// `"schema_name.table_name"`.
 ///
-/// Attempting to use the `env!` or `dotenv!` macros here will not work due to limitations of the
-/// Macros 1.1 system, but you can pass a string in the form `"env:SOME_ENV_VAR"` or
-/// `"dotenv:SOME_ENV_VAR"` to achieve the same effect.
+/// Attempting to use the `env!` or `dotenv!` macros here will not work due to
+/// limitations of the Macros 1.1 system, but you can pass a string in the form
+/// `"env:SOME_ENV_VAR"` or `"dotenv:SOME_ENV_VAR"` to achieve the same effect.
 ///
-/// At this time, the schema inference macros do not support types from third party crates, and
-/// having any columns with a type not supported by the diesel core crate will result in a compiler
-/// error (please [open an issue](https://github.com/diesel-rs/diesel/issues/new) if this happens
+/// At this time, the schema inference macros do not support types from third
+/// party crates, and having any columns with a type not supported by the diesel
+/// core crate will result in a compiler error (please [open an
+/// issue](https://github.com/diesel-rs/diesel/issues/new) if this happens
 /// unexpectedly for a type listed in our docs.)
 ///
 /// This macro can only be used in combination with the `diesel_codegen` or
diff --git a/diesel_codegen/src/schema_inference.rs b/diesel_codegen/src/schema_inference.rs
index 09e94bff8..f043f9fa5 100644
--- a/diesel_codegen/src/schema_inference.rs
+++ b/diesel_codegen/src/schema_inference.rs
@@ -3,7 +3,7 @@ use quote;
 
 use diesel_codegen_shared::*;
 
-use util::{get_options_from_input, get_option};
+use util::{get_options_from_input, get_option, get_optional_option};
 
 pub fn derive_infer_schema(input: syn::MacroInput) -> quote::Tokens {
     fn bug() -> ! {
@@ -13,19 +13,9 @@ pub fn derive_infer_schema(input: syn::MacroInput) -> quote::Tokens {
 
     let options = get_options_from_input(&input.attrs, bug).unwrap_or_else(|| bug());
     let database_url = get_option(&options, "database_url", bug);
+    let schema_name = get_optional_option(&options, "schema_name");
 
-    let table_names = load_table_names(&database_url).unwrap();
-    let schema_inferences = table_names.into_iter().map(|table_name| {
-        let mod_ident = syn::Ident::new(format!("infer_{}", table_name));
-        quote! {
-            mod #mod_ident {
-                infer_table_from_schema!(#database_url, #table_name);
-            }
-            pub use self::#mod_ident::*;
-        }
-    });
-
-    quote!(#(#schema_inferences)*)
+    infer_schema_for_schema_name(&database_url, schema_name.as_ref().map(|s| &**s))
 }
 
 pub fn derive_infer_table_from_schema(input: syn::MacroInput) -> quote::Tokens {
@@ -53,6 +43,31 @@ pub fn derive_infer_table_from_schema(input: syn::MacroInput) -> quote::Tokens {
     })
 }
 
+fn infer_schema_for_schema_name(database_url: &str, schema_name: Option<&str>) -> quote::Tokens {
+    let table_names = load_table_names(&database_url, schema_name).unwrap();
+    let schema_inferences = table_names.into_iter().map(|table_name| {
+        let mod_ident = syn::Ident::new(format!("infer_{}", table_name));
+        let table_name = match schema_name {
+            Some(name) => format!("{}.{}", name, table_name),
+            None => table_name,
+        };
+        quote! {
+            mod #mod_ident {
+                infer_table_from_schema!(#database_url, #table_name);
+            }
+            pub use self::#mod_ident::*;
+        }
+    });
+
+    match schema_name {
+        Some(name) => {
+            let schema_ident = syn::Ident::new(name);
+            quote! { pub mod #schema_ident { #(#schema_inferences)* } }
+        }
+        None => quote!(#(#schema_inferences)*),
+    }
+}
+
 fn column_def_tokens(
     column: &ColumnInformation,
     connection: &InferConnection,
diff --git a/diesel_codegen/src/util.rs b/diesel_codegen/src/util.rs
index 0f5ede463..e03e222da 100644
--- a/diesel_codegen/src/util.rs
+++ b/diesel_codegen/src/util.rs
@@ -122,7 +122,14 @@ pub fn get_option<'a>(
     option_name: &str,
     on_bug: fn() -> !,
 ) -> &'a str {
+    get_optional_option(options, option_name)
+        .unwrap_or_else(|| on_bug())
+}
+
+pub fn get_optional_option<'a>(
+    options: &'a [MetaItem],
+    option_name: &str,
+) -> Option<&'a str> {
     options.iter().find(|a| a.name() == option_name)
         .map(|a| str_value_of_meta_item(a, option_name))
-        .unwrap_or_else(|| on_bug())
 }
diff --git a/diesel_codegen_shared/src/schema_inference/mod.rs b/diesel_codegen_shared/src/schema_inference/mod.rs
index 65305a79f..9166b3afd 100644
--- a/diesel_codegen_shared/src/schema_inference/mod.rs
+++ b/diesel_codegen_shared/src/schema_inference/mod.rs
@@ -12,14 +12,16 @@ use InferConnection;
 use database_url::extract_database_url;
 pub use self::data_structures::{ColumnInformation, ColumnType};
 
-pub fn load_table_names(database_url: &str) -> Result<Vec<String>, Box<Error>> {
+pub fn load_table_names(database_url: &str, schema_name: Option<&str>)
+    -> Result<Vec<String>, Box<Error>>
+{
     let connection = try!(establish_connection(database_url));
 
     match connection {
         #[cfg(feature = "sqlite")]
-        InferConnection::Sqlite(c) => sqlite::load_table_names(&c),
+        InferConnection::Sqlite(c) => sqlite::load_table_names(&c, schema_name),
         #[cfg(feature = "postgres")]
-        InferConnection::Pg(c) => pg::load_table_names(&c),
+        InferConnection::Pg(c) => pg::load_table_names(&c, schema_name),
     }
 }
 
@@ -106,4 +108,3 @@ pub fn get_primary_keys(
         Ok(primary_keys)
     }
 }
-
diff --git a/diesel_codegen_shared/src/schema_inference/pg.rs b/diesel_codegen_shared/src/schema_inference/pg.rs
index dccd5ab98..3952b9197 100644
--- a/diesel_codegen_shared/src/schema_inference/pg.rs
+++ b/diesel_codegen_shared/src/schema_inference/pg.rs
@@ -1,5 +1,7 @@
 use diesel::*;
-use diesel::pg::PgConnection;
+use diesel::query_builder::BoxedSelectStatement;
+use diesel::types::Oid;
+use diesel::pg::{PgConnection, Pg};
 use std::error::Error;
 
 use super::data_structures::*;
@@ -43,6 +45,15 @@ table! {
     pg_class (oid) {
         oid -> Oid,
         relname -> VarChar,
+        relnamespace -> Oid,
+    }
+}
+
+// https://www.postgresql.org/docs/9.5/static/catalog-pg-namespace.html
+table! {
+    pg_namespace (oid) {
+        oid -> Oid,
+        nspname -> VarChar,
     }
 }
 
@@ -55,6 +66,12 @@ mod information_schema {
             table_type -> VarChar,
         }
     }
+
+    table! {
+        information_schema.schemata (schema_name) {
+            schema_name -> VarChar,
+        }
+    }
 }
 
 pub fn determine_column_type(attr: &ColumnInformation) -> Result<ColumnType, Box<Error>> {
@@ -79,13 +96,10 @@ fn capitalize(name: &str) -> String {
 pub fn get_table_data(conn: &PgConnection, table_name: &str) -> QueryResult<Vec<ColumnInformation>> {
     use self::pg_attribute::dsl::*;
     use self::pg_type::dsl::{pg_type, typname};
-    use self::pg_class::dsl::*;
-
-    let table_oid = pg_class.select(oid).filter(relname.eq(table_name)).limit(1);
 
     pg_attribute.inner_join(pg_type)
         .select((attname, typname, attnotnull))
-        .filter(attrelid.eq_any(table_oid))
+        .filter(attrelid.eq_any(table_oid(table_name)))
         .filter(attnum.gt(0).and(attisdropped.ne(true)))
         .order(attnum)
         .load(conn)
@@ -95,12 +109,9 @@ pub fn get_table_data(conn: &PgConnection, table_name: &str) -> QueryResult<Vec<
 pub fn get_primary_keys(conn: &PgConnection, table_name: &str) -> QueryResult<Vec<String>> {
     use self::pg_attribute::dsl::*;
     use self::pg_index::dsl::{pg_index, indisprimary, indexrelid, indrelid};
-    use self::pg_class::dsl::*;
-
-    let table_oid = pg_class.select(oid).filter(relname.eq(table_name)).limit(1);
 
     let pk_query = pg_index.select(indexrelid)
-        .filter(indrelid.eq_any(table_oid))
+        .filter(indrelid.eq_any(table_oid(table_name)))
         .filter(indisprimary.eq(true));
 
     pg_attribute.select(attname)
@@ -109,11 +120,33 @@ pub fn get_primary_keys(conn: &PgConnection, table_name: &str) -> QueryResult<Ve
         .load(conn)
 }
 
-pub fn load_table_names(connection: &PgConnection) -> Result<Vec<String>, Box<Error>> {
+fn table_oid<'a>(table_name: &'a str) -> BoxedSelectStatement<'a, Oid, pg_class::table, Pg> {
+    use self::pg_class::dsl::*;
+    use self::pg_namespace::{table as pg_namespace, oid as nsoid, nspname};
+
+    let mut parts = table_name.split('.');
+    let (schema_name, table_name) = match (parts.next(), parts.next()) {
+        (Some(schema), Some(table)) => (schema, table),
+        (Some(table), None) => ("public", table),
+        _ => panic!("Unable to load schema for {}", table_name),
+    };
+
+    let schema_oid = pg_namespace.select(nsoid).filter(nspname.eq(schema_name)).limit(1);
+    pg_class.select(oid)
+        .filter(relname.eq(table_name))
+        .filter(relnamespace.eq_any(schema_oid))
+        .limit(1)
+        .into_boxed()
+}
+
+pub fn load_table_names(connection: &PgConnection, schema_name: Option<&str>)
+    -> Result<Vec<String>, Box<Error>>
+{
     use self::information_schema::tables::dsl::*;
 
+    let schema_name = schema_name.unwrap_or("public");
     let query = tables.select(table_name)
-        .filter(table_schema.eq("public"))
+        .filter(table_schema.eq(schema_name))
         .filter(table_name.not_like("\\_\\_%"))
         .filter(table_type.like("BASE TABLE"));
     Ok(try!(query.load(connection)))
@@ -133,7 +166,7 @@ fn skip_views() {
     connection.execute("CREATE TABLE a_regular_table (id SERIAL PRIMARY KEY)").unwrap();
     connection.execute("CREATE VIEW a_view AS SELECT 42").unwrap();
 
-    let table_names = load_table_names(&connection).unwrap();
+    let table_names = load_table_names(&connection, None).unwrap();
 
     assert!(table_names.contains(&"a_regular_table".to_string()));
     assert!(!table_names.contains(&"a_view".to_string()));
diff --git a/diesel_codegen_shared/src/schema_inference/sqlite.rs b/diesel_codegen_shared/src/schema_inference/sqlite.rs
index f1cafbc2b..a67b5c648 100644
--- a/diesel_codegen_shared/src/schema_inference/sqlite.rs
+++ b/diesel_codegen_shared/src/schema_inference/sqlite.rs
@@ -22,9 +22,16 @@ table!{
     }
 }
 
-pub fn load_table_names(connection: &SqliteConnection) -> Result<Vec<String>, Box<Error>> {
+pub fn load_table_names(connection: &SqliteConnection, schema_name: Option<&str>)
+    -> Result<Vec<String>, Box<Error>>
+{
     use self::sqlite_master::dsl::*;
 
+    if !schema_name.is_none() {
+        return Err("sqlite cannot infer schema for databases other than the \
+                    main database".into());
+    }
+
     sqlite_master.select(name)
         .filter(name.not_like("\\_\\_%").escape('\\'))
         .filter(name.not_like("sqlite%"))
@@ -136,14 +143,14 @@ fn is_double(type_name: &str) -> bool {
 #[test]
 fn load_table_names_returns_nothing_when_no_tables_exist() {
     let conn = SqliteConnection::establish(":memory:").unwrap();
-    assert_eq!(Vec::<String>::new(), load_table_names(&conn).unwrap());
+    assert_eq!(Vec::<String>::new(), load_table_names(&conn, None).unwrap());
 }
 
 #[test]
 fn load_table_names_includes_tables_that_exist() {
     let conn = SqliteConnection::establish(":memory:").unwrap();
     conn.execute("CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT)").unwrap();
-    let table_names = load_table_names(&conn).unwrap();
+    let table_names = load_table_names(&conn, None).unwrap();
     assert!(table_names.contains(&String::from("users")));
 }
 
@@ -151,7 +158,7 @@ fn load_table_names_includes_tables_that_exist() {
 fn load_table_names_excludes_diesel_metadata_tables() {
     let conn = SqliteConnection::establish(":memory:").unwrap();
     conn.execute("CREATE TABLE __diesel_metadata (id INTEGER PRIMARY KEY AUTOINCREMENT)").unwrap();
-    let table_names = load_table_names(&conn).unwrap();
+    let table_names = load_table_names(&conn, None).unwrap();
     assert!(!table_names.contains(&String::from("__diesel_metadata")));
 }
 
@@ -160,7 +167,7 @@ fn load_table_names_excludes_sqlite_metadata_tables() {
     let conn = SqliteConnection::establish(":memory:").unwrap();
     conn.execute("CREATE TABLE __diesel_metadata (id INTEGER PRIMARY KEY AUTOINCREMENT)").unwrap();
     conn.execute("CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT)").unwrap();
-    let table_names = load_table_names(&conn);
+    let table_names = load_table_names(&conn, None);
     assert_eq!(vec![String::from("users")], table_names.unwrap());
 }
 
@@ -169,6 +176,19 @@ fn load_table_names_excludes_views() {
     let conn = SqliteConnection::establish(":memory:").unwrap();
     conn.execute("CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT)").unwrap();
     conn.execute("CREATE VIEW answer AS SELECT 42").unwrap();
-    let table_names = load_table_names(&conn);
+    let table_names = load_table_names(&conn, None);
     assert_eq!(vec![String::from("users")], table_names.unwrap());
 }
+
+#[test]
+fn load_table_names_returns_error_when_given_schema_name() {
+    let conn = SqliteConnection::establish(":memory:").unwrap();
+    // We're testing the error message rather than using #[should_panic]
+    // to ensure this is returning an error and not actually panicking.
+    let table_names = load_table_names(&conn, Some("stuff"));
+    match table_names {
+        Ok(_) => panic!("Expected load_table_names to return an error"),
+        Err(e) => assert!(e.description().starts_with("sqlite cannot infer \
+            schema for databases")),
+    }
+}
diff --git a/diesel_codegen_syntex/src/schema_inference/mod.rs b/diesel_codegen_syntex/src/schema_inference/mod.rs
index 25c5a3574..874272c52 100644
--- a/diesel_codegen_syntex/src/schema_inference/mod.rs
+++ b/diesel_codegen_syntex/src/schema_inference/mod.rs
@@ -53,12 +53,12 @@ pub fn expand_infer_schema<'cx>(
     sp: Span,
     tts: &[TokenTree]
 ) -> Box<MacResult+'cx> {
-    let mut exprs = match get_exprs_from_tts(cx, sp, tts) {
+    let exprs = match get_exprs_from_tts(cx, sp, tts) {
         Some(exprs) => exprs.into_iter(),
         None => return DummyResult::any(sp),
     };
 
-    match infer_schema_body(cx, sp, &mut exprs) {
+    match infer_schema_body(cx, sp, exprs) {
         Ok(res) => res,
         Err(res) => res,
     }
@@ -67,14 +67,46 @@ pub fn expand_infer_schema<'cx>(
 pub fn infer_schema_body<T: Iterator<Item=P<ast::Expr>>>(
     cx: &mut ExtCtxt,
     sp: Span,
-    exprs: &mut T,
+    exprs: T,
 ) -> Result<Box<MacResult>, Box<MacResult>> {
-    let database_url = try!(next_str_lit(cx, sp, exprs));
-    let table_names = load_table_names(&database_url).unwrap();
+    let mut exprs = exprs.peekable();
+    let database_url = try!(next_str_lit(cx, sp, &mut exprs));
+    let schema_name = if exprs.peek().is_some() {
+        Some(try!(next_str_lit(cx, sp, &mut exprs)))
+    } else {
+        None
+    };
+    let schema_inferences = infer_schema_for_schema_name(
+        cx,
+        &database_url,
+        schema_name.as_ref().map(|s| &**s),
+    );
+    Ok(MacEager::items(SmallVector::many(schema_inferences)))
+}
+
+fn infer_schema_for_schema_name(
+    cx: &mut ExtCtxt,
+    database_url: &str,
+    schema_name: Option<&str>,
+) -> Vec<P<ast::Item>> {
+    let table_names = load_table_names(&database_url, schema_name).unwrap();
     let impls = table_names.into_iter()
-        .map(|n| quote_item!(cx, infer_table_from_schema!($database_url, $n);).unwrap())
-        .collect();
-    Ok(MacEager::items(SmallVector::many(impls)))
+        .map(|table_name| {
+            let table_name = match schema_name {
+                Some(name) => format!("{}.{}", name, table_name),
+                None => table_name,
+            };
+            quote_item!(cx, infer_table_from_schema!($database_url, $table_name);).unwrap()
+        })
+        .collect::<Vec<_>>();
+    match schema_name {
+        Some(name) => {
+            let schema_ident = str_to_ident(name);
+            let item = quote_item!(cx, pub mod $schema_ident { $impls }).unwrap();
+            vec![item]
+        }
+        None => impls,
+    }
 }
 
 fn table_macro_call(
diff --git a/diesel_tests/tests/custom_schemas.rs b/diesel_tests/tests/custom_schemas.rs
new file mode 100644
index 000000000..105560eef
--- /dev/null
+++ b/diesel_tests/tests/custom_schemas.rs
@@ -0,0 +1,22 @@
+use diesel::*;
+use schema::connection;
+
+infer_schema!("dotenv:DATABASE_URL", "custom_schema");
+use self::custom_schema::users;
+
+#[derive(Insertable)]
+#[table_name="users"]
+struct NewUser {
+    id: i32,
+}
+
+#[test]
+fn custom_schemas_are_loaded_by_infer_schema() {
+    let conn = connection();
+    insert(&NewUser { id: 1 }).into(users::table)
+        .execute(&conn).unwrap();
+    let users = users::table.select(users::id)
+        .load(&conn);
+
+    assert_eq!(Ok(vec![1]), users);
+}
diff --git a/diesel_tests/tests/lib.rs b/diesel_tests/tests/lib.rs
index a1b20478b..bfd408f6d 100644
--- a/diesel_tests/tests/lib.rs
+++ b/diesel_tests/tests/lib.rs
@@ -15,6 +15,11 @@ include!(concat!(env!("OUT_DIR"), "/lib.rs"));
 
 mod boxed_queries;
 mod connection;
+// This should be in lib.in.rs restricted to PG, but
+// syntex compiles the file even if the feature is unset,
+// and the macro call is invalid on SQLite.
+#[cfg(all(feature = "unstable", feature = "postgres"))]
+mod custom_schemas;
 mod debug;
 mod delete;
 mod errors;
diff --git a/migrations/postgresql/20161206123630_create_table_custom_schema/down.sql b/migrations/postgresql/20161206123630_create_table_custom_schema/down.sql
new file mode 100644
index 000000000..53533bb59
--- /dev/null
+++ b/migrations/postgresql/20161206123630_create_table_custom_schema/down.sql
@@ -0,0 +1 @@
+DROP SCHEMA custom_schema CASCADE;
diff --git a/migrations/postgresql/20161206123630_create_table_custom_schema/up.sql b/migrations/postgresql/20161206123630_create_table_custom_schema/up.sql
new file mode 100644
index 000000000..13df19cfb
--- /dev/null
+++ b/migrations/postgresql/20161206123630_create_table_custom_schema/up.sql
@@ -0,0 +1,2 @@
+CREATE SCHEMA custom_schema;
+CREATE TABLE custom_schema.users (id SERIAL PRIMARY KEY);
