diff --git a/CHANGELOG.md b/CHANGELOG.md
index 391cf716c..61a345bc2 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -30,6 +30,11 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * Struct fields annotated with `#[column_name="name"]` should be changed to
   `#[column_name(name)]`.
 
+* The structure of `DatabaseError` has changed to hold more information. See
+  http://docs.diesel.rs/diesel/result/enum.Error.html and
+  http://docs.diesel.rs/diesel/result/trait.DatabaseErrorInformation.html for
+  more information
+
 ### Fixed
 
 * `&&[T]` can now be used in queries. This allows using slices with things like
diff --git a/diesel/src/pg/connection/raw.rs b/diesel/src/pg/connection/raw.rs
index 061092e3f..e3a257c08 100644
--- a/diesel/src/pg/connection/raw.rs
+++ b/diesel/src/pg/connection/raw.rs
@@ -43,7 +43,10 @@ impl RawConnection {
         ) };
 
         if result_ptr.is_null() {
-            Err(Error::DatabaseError(Box::new(last_error_message(self.internal_connection))))
+            Err(Error::DatabaseError(
+                DatabaseErrorKind::__Unknown,
+                Box::new(last_error_message(self.internal_connection)),
+            ))
         } else {
             unsafe {
                 Ok(PgString::new(result_ptr))
diff --git a/diesel/src/pg/connection/result.rs b/diesel/src/pg/connection/result.rs
index 3a8714378..1f884d18e 100644
--- a/diesel/src/pg/connection/result.rs
+++ b/diesel/src/pg/connection/result.rs
@@ -1,7 +1,7 @@
 extern crate pq_sys;
 extern crate libc;
 
-use result::{Error, QueryResult, DatabaseErrorInformation};
+use result::{Error, QueryResult, DatabaseErrorInformation, DatabaseErrorKind};
 use super::row::PgRow;
 
 use self::pq_sys::*;
@@ -23,7 +23,11 @@ impl PgResult {
             },
             _ => {
                 let error_information = Box::new(PgErrorInformation(internal_result));
-                Err(Error::DatabaseError(error_information))
+                let error_kind = match get_result_field(internal_result, ResultField::SqlState) {
+                    Some(error_codes::UNIQUE_VIOLATION) => DatabaseErrorKind::UniqueViolation,
+                    _ => DatabaseErrorKind::__Unknown,
+                };
+                Err(Error::DatabaseError(error_kind, error_information))
             }
         }
     }
@@ -92,38 +96,49 @@ impl Drop for PgErrorInformation {
 
 impl DatabaseErrorInformation for PgErrorInformation {
     fn message(&self) -> &str {
-        match get_result_field(self.0, 'M') {
+        match get_result_field(self.0, ResultField::MessagePrimary) {
             Some(e) => e,
             None => unreachable!("Per PGs documentation, all errors should have a message"),
         }
     }
 
     fn details(&self) -> Option<&str> {
-        get_result_field(self.0, 'D')
+        get_result_field(self.0, ResultField::MessageDetail)
     }
 
     fn hint(&self) -> Option<&str> {
-        get_result_field(self.0, 'H')
+        get_result_field(self.0, ResultField::MessageHint)
     }
 
     fn table_name(&self) -> Option<&str> {
-        get_result_field(self.0, 't')
+        get_result_field(self.0, ResultField::TableName)
     }
 
     fn column_name(&self) -> Option<&str> {
-        get_result_field(self.0, 'c')
+        get_result_field(self.0, ResultField::ColumnName)
     }
 
     fn constraint_name(&self) -> Option<&str> {
-        get_result_field(self.0, 'n')
+        get_result_field(self.0, ResultField::ConstraintName)
     }
 }
 
-/// `field` is one of the valid options to
+/// Represents valid options to
 /// [`PQresultErrorField`](https://www.postgresql.org/docs/current/static/libpq-exec.html#LIBPQ-PQRESULTERRORFIELD)
 /// Their values are defined as C preprocessor macros, and therefore are not exported by libpq-sys.
 /// Their values can be found in `postgres_ext.h`
-fn get_result_field<'a>(res: *mut PGresult, field: char) -> Option<&'a str> {
+#[repr(i32)]
+enum ResultField {
+    SqlState = 'C' as i32,
+    MessagePrimary = 'M' as i32,
+    MessageDetail = 'D' as i32,
+    MessageHint = 'H' as i32,
+    TableName = 't' as i32,
+    ColumnName = 'c' as i32,
+    ConstraintName = 'n' as i32,
+}
+
+fn get_result_field<'a>(res: *mut PGresult, field: ResultField) -> Option<&'a str> {
     let ptr = unsafe { PQresultErrorField(res, field as libc::c_int) };
     if ptr.is_null() {
         return None;
@@ -132,3 +147,11 @@ fn get_result_field<'a>(res: *mut PGresult, field: char) -> Option<&'a str> {
     let c_str = unsafe { CStr::from_ptr(ptr) };
     c_str.to_str().ok()
 }
+
+mod error_codes {
+    //! These error codes are documented at
+    //! https://www.postgresql.org/docs/9.5/static/errcodes-appendix.html
+    //!
+    //! They are not exposed programatically through libpq.
+    pub const UNIQUE_VIOLATION: &'static str = "23505";
+}
diff --git a/diesel/src/result.rs b/diesel/src/result.rs
index f58e9cd92..4c2bdb81a 100644
--- a/diesel/src/result.rs
+++ b/diesel/src/result.rs
@@ -9,7 +9,7 @@ use std::ffi::NulError;
 /// future without a major version bump.
 pub enum Error {
     InvalidCString(NulError),
-    DatabaseError(Box<DatabaseErrorInformation+Send>),
+    DatabaseError(DatabaseErrorKind, Box<DatabaseErrorInformation+Send>),
     NotFound,
     QueryBuilderError(Box<StdError+Send>),
     DeserializationError(Box<StdError+Send+Sync>),
@@ -18,6 +18,18 @@ pub enum Error {
     __Nonexhaustive,
 }
 
+#[derive(Debug, Clone, Copy)]
+/// The kind of database error that occurred. This is not meant to exhaustively
+/// cover all possible errors, but is used to identify errors which are commonly
+/// recovered from programatically. This enum is not intended to be exhaustively
+/// matched, and new variants may be added in the future without a major version
+/// bump.
+pub enum DatabaseErrorKind {
+    UniqueViolation,
+    #[doc(hidden)]
+    __Unknown, // Match against _ instead, more variants may be added in the future
+}
+
 pub trait DatabaseErrorInformation {
     fn message(&self) -> &str;
     fn details(&self) -> Option<&str>;
@@ -106,7 +118,7 @@ impl Display for Error {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match self {
             &Error::InvalidCString(ref nul_err) => nul_err.fmt(f),
-            &Error::DatabaseError(ref e) => write!(f, "{}", e.message()),
+            &Error::DatabaseError(_, ref e) => write!(f, "{}", e.message()),
             &Error::NotFound => f.write_str("NotFound"),
             &Error::QueryBuilderError(ref e) => e.fmt(f),
             &Error::DeserializationError(ref e) => e.fmt(f),
@@ -120,7 +132,7 @@ impl StdError for Error {
     fn description(&self) -> &str {
         match self {
             &Error::InvalidCString(ref nul_err) => nul_err.description(),
-            &Error::DatabaseError(ref e) => e.message(),
+            &Error::DatabaseError(_, ref e) => e.message(),
             &Error::NotFound => "Record not found",
             &Error::QueryBuilderError(ref e) => e.description(),
             &Error::DeserializationError(ref e) => e.description(),
@@ -170,7 +182,7 @@ impl PartialEq for Error {
     fn eq(&self, other: &Error) -> bool {
         match (self, other) {
             (&Error::InvalidCString(ref a), &Error::InvalidCString(ref b)) => a == b,
-            (&Error::DatabaseError(ref a), &Error::DatabaseError(ref b)) =>
+            (&Error::DatabaseError(_, ref a), &Error::DatabaseError(_, ref b)) =>
                 a.message() == b.message(),
             (&Error::NotFound, &Error::NotFound) => true,
             _ => false,
diff --git a/diesel/src/sqlite/connection/raw.rs b/diesel/src/sqlite/connection/raw.rs
index 435b6d420..414f47390 100644
--- a/diesel/src/sqlite/connection/raw.rs
+++ b/diesel/src/sqlite/connection/raw.rs
@@ -49,7 +49,8 @@ impl RawConnection {
 
         if !err_msg.is_null() {
             let msg = convert_to_string_and_free(err_msg);
-            Err(DatabaseError(Box::new(msg)))
+            let error_kind = DatabaseErrorKind::__Unknown;
+            Err(DatabaseError(error_kind, Box::new(msg)))
         } else {
             Ok(())
         }
@@ -63,6 +64,10 @@ impl RawConnection {
         let c_str = unsafe { CStr::from_ptr(ffi::sqlite3_errmsg(self.internal_connection)) };
         c_str.to_string_lossy().into_owned()
     }
+
+    pub fn last_error_code(&self) -> libc::c_int {
+        unsafe { ffi::sqlite3_extended_errcode(self.internal_connection) }
+    }
 }
 
 impl Drop for RawConnection {
diff --git a/diesel/src/sqlite/connection/stmt.rs b/diesel/src/sqlite/connection/stmt.rs
index 54e9dc17e..2f230b465 100644
--- a/diesel/src/sqlite/connection/stmt.rs
+++ b/diesel/src/sqlite/connection/stmt.rs
@@ -145,7 +145,12 @@ fn ensure_sqlite_ok(code: libc::c_int, raw_connection: &RawConnection) -> QueryR
 fn last_error(raw_connection: &RawConnection) -> Error {
     let error_message = raw_connection.last_error_message();
     let error_information = Box::new(error_message);
-    DatabaseError(error_information)
+    let error_kind = match raw_connection.last_error_code() {
+        ffi::SQLITE_CONSTRAINT_UNIQUE | ffi::SQLITE_CONSTRAINT_PRIMARYKEY =>
+            DatabaseErrorKind::UniqueViolation,
+        _ => DatabaseErrorKind::__Unknown,
+    };
+    DatabaseError(error_kind, error_information)
 }
 
 impl Drop for Statement {
diff --git a/diesel_tests/tests/errors.rs b/diesel_tests/tests/errors.rs
index 93965df2c..500f3c553 100644
--- a/diesel_tests/tests/errors.rs
+++ b/diesel_tests/tests/errors.rs
@@ -1,8 +1,40 @@
 use diesel;
 use diesel::prelude::*;
 use diesel::result::Error::DatabaseError;
+use diesel::result::DatabaseErrorKind::UniqueViolation;
 use schema::*;
 
+#[test]
+fn unique_constraints_are_detected() {
+    let connection = connection();
+    diesel::insert(&User::new(1, "Sean")).into(users::table)
+        .execute(&connection).unwrap();
+
+    let failure = diesel::insert(&User::new(1, "Jim")).into(users::table)
+        .execute(&connection);
+    assert_matches!(failure, Err(DatabaseError(UniqueViolation, _)));
+}
+
+#[test]
+#[cfg(feature = "postgres")]
+fn unique_constraints_report_correct_constraint_name() {
+    let connection = connection();
+    connection.execute("CREATE UNIQUE INDEX users_name ON users (name)").unwrap();
+    diesel::insert(&User::new(1, "Sean")).into(users::table)
+        .execute(&connection).unwrap();
+
+    let failure = diesel::insert(&User::new(2, "Sean")).into(users::table)
+        .execute(&connection);
+    match failure {
+        Err(DatabaseError(UniqueViolation, e)) => {
+            assert_eq!(Some("users"), e.table_name());
+            assert_eq!(None, e.column_name());
+            assert_eq!(Some("users_name"), e.constraint_name());
+        },
+        _ => panic!("{:?} did not match Err(DatabaseError(UniqueViolation, e))", failure),
+    };
+}
+
 macro_rules! try_no_coerce {
     ($e:expr) => ({
         match $e {
@@ -22,7 +54,7 @@ fn cached_prepared_statements_can_be_reused_after_error() {
         try_no_coerce!(query.execute(&connection));
 
         let failure = query.execute(&connection);
-        assert_matches!(failure, Err(DatabaseError(_)));
+        assert_matches!(failure, Err(DatabaseError(UniqueViolation, _)));
         Ok(())
     });
 
diff --git a/diesel_tests/tests/types_roundtrip.rs b/diesel_tests/tests/types_roundtrip.rs
index cf9d708b6..95622990f 100644
--- a/diesel_tests/tests/types_roundtrip.rs
+++ b/diesel_tests/tests/types_roundtrip.rs
@@ -31,7 +31,7 @@ pub fn test_type_round_trips<ST, T>(value: T) -> bool where
                 true
             }
         }
-        Err(Error::DatabaseError(ref e))
+        Err(Error::DatabaseError(_, ref e))
             if e.message() == "invalid byte sequence for encoding \"UTF8\": 0x00" => true,
         Err(e) => panic!("Query failed: {:?}", e),
     }
