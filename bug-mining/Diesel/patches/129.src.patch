diff --git a/diesel/src/associations/belongs_to.rs b/diesel/src/associations/belongs_to.rs
index 9c78afdde..3bae5ef7e 100644
--- a/diesel/src/associations/belongs_to.rs
+++ b/diesel/src/associations/belongs_to.rs
@@ -15,6 +15,68 @@ pub trait BelongsTo<Parent> {
     fn foreign_key_column() -> Self::ForeignKeyColumn;
 }
 
+/// The `grouped_by` function groups records by their parent.
+///
+/// `grouped_by` is called on a `Vec<Child>` with a `&Vec<Parent>` and returns a `Vec<Vec<Child>>`
+/// where the index of the children matches the index of the parent they belong to. This function
+/// does not generate a `GROUP BY` SQL statement, as it operates on data structures already loaded
+/// from the database backend.
+///
+/// **Child** refers to the *many* part of a *one to many* relationship and has *one parent*.
+/// **Parent** refers to the *one* part of a *one to many* relationship and can *have many children*.
+/// In the following relationship, User has many Posts,
+/// so User is the parent and Posts are children.
+///
+/// # Example
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # #[macro_use] extern crate diesel_codegen;
+/// # include!("../doctest_setup.rs");
+/// # use schema::users;
+/// # use schema::posts;
+/// #
+/// # #[derive(Debug, Identifiable, Queryable)]
+/// # pub struct User {
+/// #     id: i32,
+/// #     name: String,
+/// # }
+/// #
+/// # #[derive(Debug, PartialEq, Identifiable, Queryable, Associations)]
+/// # #[belongs_to(User)]
+/// # pub struct Post {
+/// #     id: i32,
+/// #     user_id: i32,
+/// #     title: String,
+/// # }
+/// #
+/// # fn main() {
+/// #   use users::dsl::*;
+/// #   use posts::dsl::*;
+/// #   let connection = establish_connection();
+/// #
+/// let user_list = users.load::<User>(&connection).expect("Couldn't load users");
+/// let post_list = posts.load::<Post>(&connection).expect("Couldn't load posts");
+///
+/// // Group Posts by Users
+/// let posts_grouped_by_user: Vec<Vec<Post>> = post_list.grouped_by(&user_list);
+/// let expected = vec![
+///     vec![
+///         Post { id: 1, user_id: 1, title: "My first post".to_string() },
+///         Post { id: 2, user_id: 1, title: "About Rust".to_string() }
+///     ],
+///     vec![
+///         Post { id: 3, user_id: 2, title: "My first post too".to_string() }
+///     ]
+/// ];
+///
+/// assert_eq!(posts_grouped_by_user, expected);
+/// # }
+/// ```
+///
+/// View the [associations] doc for more `grouped_by()` code examples
+///
+/// [associations]: ../associations/index.html
 pub trait GroupedBy<'a, Parent>: IntoIterator + Sized {
     fn grouped_by(self, parents: &'a [Parent]) -> Vec<Vec<Self::Item>>;
 }
diff --git a/diesel/src/associations/mod.rs b/diesel/src/associations/mod.rs
index 769c23d00..a7d67d891 100644
--- a/diesel/src/associations/mod.rs
+++ b/diesel/src/associations/mod.rs
@@ -67,8 +67,8 @@
 //! Once the associations are defined, you can join between the two tables using the
 //! [`inner_join`][inner-join] or [`left_outer_join`][left-outer-join].
 //!
-//! [inner-join]: ../query_source/trait.Table.html#method.inner_join
-//! [left-outer-join]: ../query_source/trait.Table.html#method.left_outer_join
+//! [inner-join]: ../prelude/trait.JoinDsl.html#method.inner_join
+//! [left-outer-join]: ../prelude/trait.JoinDsl.html#method.left_outer_join
 //!
 //! ```rust
 //! # #[macro_use] extern crate diesel;
@@ -231,7 +231,7 @@
 //! assert_eq!(result, expected);
 //! # }
 //! ```
-//! [`grouped_by`][grouped-by] takes a `Vec<Child>` and a `Vec<Parent>` and returns a
+//! [`grouped_by`][grouped-by] is called on a `Vec<Child>` with their `&Vec<Parent>` and returns a
 //! `Vec<Vec<Child>>` where the index of the children matches the index of the parent they belong
 //! to. Or to put it another way, it returns them in an order ready to be `zip`ed with the parents. You
 //! can do this multiple times. For example, if you wanted to load the comments for all the posts
diff --git a/diesel/src/macros/macros_from_codegen.rs b/diesel/src/macros/macros_from_codegen.rs
index a3b32420b..e4eb13df3 100644
--- a/diesel/src/macros/macros_from_codegen.rs
+++ b/diesel/src/macros/macros_from_codegen.rs
@@ -15,6 +15,11 @@
 /// If any column name would collide with a rust keyword, a `_` will
 /// automatically be placed at the end of the name. For example, a column called
 /// `type` will be referenced as `type_` in the generated module.
+///
+/// Using the `infer_schema!` macro enables Diesel to automatically detect which
+/// tables can be joined.
+/// You must have foreign key constraints on the child table's foreign key column
+/// for this feature to work.
 macro_rules! infer_schema {
     ($database_url: expr) => {
         mod __diesel_infer_schema {
@@ -54,6 +59,10 @@ macro_rules! infer_schema {
 ///
 /// This macro can only be used in combination with the `diesel_codegen` or
 /// `diesel_codegen_syntex` crates. It will not work on its own.
+///
+/// When using the `infer_table_from_schema!` macro,
+/// Diesel can't automatically detect which tables can be joined.
+/// Use the `joinable!` macro in your schema to specify how tables can be joined
 macro_rules! infer_table_from_schema {
     ($database_url: expr, $table_name: expr) => {
         #[derive(InferTableFromSchema)]
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index bd2058e06..6eec54dc3 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -8,8 +8,17 @@ use super::insert_statement::{Insert, Replace};
 use super::{IncompleteInsertStatement, IncompleteUpdateStatement, IntoUpdateTarget,
             SelectStatement};
 
-/// Creates an update statement. Helpers for updating a single row can be
-/// generated by deriving [`AsChangeset`](query_builder/trait.AsChangeset.html)
+/// Creates an `UPDATE` statement. Helpers for updating a single row can be
+/// generated by deriving [`AsChangeset`](../trait.AsChangeset.html)
+///
+/// When a table is passed to `update`, every row in the table will be updated.
+/// You can narrow this scope by calling [`filter`] on the table before passing it in,
+/// which will result in `UPDATE your_table SET ... WHERE args_to_filter`.
+///
+/// Passing a type which implements `Identifiable` is the same as passing
+/// `some_table.find(some_struct.id())`.
+///
+/// [`filter`]: ../diesel/query_builder/update_statement/struct.IncompleteUpdateStatement.html#method.filter
 ///
 /// # Examples
 ///
@@ -28,7 +37,7 @@ use super::{IncompleteInsertStatement, IncompleteUpdateStatement, IntoUpdateTarg
 /// # fn main() {
 /// #     use users::dsl::*;
 /// #     let connection = establish_connection();
-/// let updated_row = diesel::update(users.find(1))
+/// let updated_row = diesel::update(users.filter(id.eq(1)))
 ///     .set(name.eq("James"))
 ///     .get_result(&connection);
 /// // On backends that support it, you can call `get_result` instead of `execute`
@@ -41,7 +50,9 @@ use super::{IncompleteInsertStatement, IncompleteUpdateStatement, IntoUpdateTarg
 /// # fn main() {}
 /// ```
 ///
-/// To update multiple columns, give `set` a tuple argument:
+/// To update multiple columns, give [`set`] a tuple argument:
+///
+/// [`set`]: ../diesel/query_builder/struct.IncompleteUpdateStatement.html#method.set
 ///
 /// ```rust
 /// # #[macro_use] extern crate diesel;
@@ -66,7 +77,7 @@ use super::{IncompleteInsertStatement, IncompleteUpdateStatement, IntoUpdateTarg
 /// #     surname VARCHAR)").unwrap();
 /// # connection.execute("INSERT INTO users(name, surname) VALUES('Sean', 'Griffin')").unwrap();
 ///
-/// let updated_row = diesel::update(users.find(1))
+/// let updated_row = diesel::update(users.filter(id.eq(1)))
 ///     .set((name.eq("James"), surname.eq("Bond")))
 ///     .get_result(&connection);
 ///
@@ -81,9 +92,14 @@ pub fn update<T: IntoUpdateTarget>(
     IncompleteUpdateStatement::new(source.into_update_target())
 }
 
-/// Creates a delete statement. Will delete the records in the given set.
-/// Because this function has a very generic name, it is not exported by
-/// default.
+/// Creates a `DELETE` statement.
+///
+/// When a table is passed to `delete`,
+/// every row in the table will be deleted.
+/// This scope can be narrowed by calling [`filter`]
+/// on the table before it is passed in.
+///
+/// [`filter`]: ../diesel/query_builder/struct.DeleteStatement.html#method.filter
 ///
 /// # Examples
 ///
@@ -146,9 +162,14 @@ pub fn delete<T: IntoUpdateTarget>(source: T) -> DeleteStatement<T::Table, T::Wh
     DeleteStatement::new(target.table, target.where_clause)
 }
 
-/// Creates an insert statement. Will add the given data to a table. This
-/// function is not exported by default. As with other commands, the resulting
-/// query can return the inserted rows if you choose.
+/// Creates an `INSERT` statement.
+///
+/// Will add the given data to a table.
+/// Backends that support the `RETURNING` clause, such as PostgreSQL,
+/// can return the inserted rows by calling [`.get_results`] instead of [`.execute`].
+///
+/// [`.get_results`]: ../diesel/prelude/trait.LoadDsl.html#method.get_results
+/// [`.execute`]: ../diesel/prelude/trait.ExecuteDsl.html#tymethod.execute
 ///
 /// # Examples
 ///
@@ -299,9 +320,19 @@ pub fn insert<T: ?Sized>(records: &T) -> DeprecatedIncompleteInsertStatement<&T,
     DeprecatedIncompleteInsertStatement::new(records, Insert)
 }
 
-/// Creates an `INSERT` statement. Will add the given data to a table. As with
-/// other commands, the resulting query can return the inserted rows if you
-/// choose if you are using PostgreSQL.
+/// Creates an `INSERT` statement for the target table.
+///
+/// You may add data by calling [`values()`] or [`default_values()`]
+/// as shown in the examples.
+///
+/// [`values()`]: ../diesel/query_builder/insert_statement/struct.IncompleteInsertStatement.html#method.values
+/// [`default_values()`]: ../diesel/query_builder/insert_statement/struct.IncompleteInsertStatement.html#method.default_values
+///
+/// Backends that support the `RETURNING` clause, such as PostgreSQL,
+/// can return the inserted rows by calling [`.get_results`] instead of [`.execute`].
+///
+/// [`.get_results`]: ../diesel/prelude/trait.LoadDsl.html#method.get_results
+/// [`.execute`]: ../diesel/prelude/trait.ExecuteDsl.html#tymethod.execute
 ///
 /// # Examples
 ///
@@ -463,8 +494,6 @@ where
 
 /// Creates an insert statement with default values.
 ///
-/// This function is not exported by default. As with other commands, the resulting
-/// query can return the inserted rows if you choose.
 #[cfg(feature = "with-deprecated")]
 #[deprecated(since = "0.99.0", note = "use `insert_into(table).default_values()` instead")]
 #[allow(deprecated)]
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index e42f83035..48607b26f 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -16,6 +16,9 @@ use sqlite::{Sqlite, SqliteConnection};
 use super::returning_clause::*;
 
 /// The structure returned by [`insert_into`](../../fn.insert_into.html).
+///
+/// The provided methods [`values()`] and [`default_values()`] will insert
+/// data into the targeted table.
 #[derive(Debug, Clone, Copy)]
 pub struct IncompleteInsertStatement<T, Op> {
     target: T,
@@ -82,7 +85,7 @@ impl<T, Op> IncompleteInsertStatement<T, Op> {
     }
 }
 
-/// The structure returned by [`insert`](/diesel/fn.insert.html). The only thing that can be done with it
+/// The structure returned by [`insert`](../../fn.insert.html). The only thing that can be done with it
 /// is call `into`.
 #[derive(Debug, Copy, Clone)]
 #[cfg(feature = "with-deprecated")]
diff --git a/diesel/src/query_builder/update_statement/target.rs b/diesel/src/query_builder/update_statement/target.rs
index c9facfd62..2a0a5d5da 100644
--- a/diesel/src/query_builder/update_statement/target.rs
+++ b/diesel/src/query_builder/update_statement/target.rs
@@ -10,7 +10,7 @@ pub struct UpdateTarget<Table, WhereClause> {
     pub where_clause: WhereClause,
 }
 
-/// A type which can be passed to `update`.
+/// A type which can be passed to `update` or `delete`.
 ///
 /// Apps will never need to implement this type directly. There are three kinds
 /// of things which implement this trait. Tables, queries which have only had
diff --git a/diesel/src/query_dsl/limit_dsl.rs b/diesel/src/query_dsl/limit_dsl.rs
index 0f2aeb580..fe714039f 100644
--- a/diesel/src/query_dsl/limit_dsl.rs
+++ b/diesel/src/query_dsl/limit_dsl.rs
@@ -6,6 +6,49 @@ use query_source::Table;
 pub trait LimitDsl {
     type Output;
 
+    /// Creates a `SQL LIMIT` statement.
+    /// Limits the number of records returned by the integer passed in.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// # use schema::users;
+    /// #
+    /// # fn main() {
+    /// #   use users::dsl::*;
+    /// #   let connection = establish_connection();
+    /// #   diesel::delete(users).execute(&connection).unwrap();
+    /// #
+    /// # let new_users = vec![
+    /// #    NewUser { name: "Sean".to_string(), },
+    /// #    NewUser { name: "Bastien".to_string(), },
+    /// #    NewUser { name: "Pascal".to_string(), },
+    /// # ];
+    /// #
+    /// # diesel::insert_into(users)
+    /// #    .values(&new_users)
+    /// #    .execute(&connection)
+    /// #    .unwrap();
+    /// #
+    /// // Using a limit
+    /// let limited = users.select(name)
+    ///     .order(id)
+    ///     .limit(1)
+    ///     .load::<String>(&connection)
+    ///     .unwrap();
+    ///
+    /// // Without a limit
+    /// let no_limit = users.select(name)
+    ///     .order(id)
+    ///     .load::<String>(&connection)
+    ///     .unwrap();
+    ///
+    /// assert_eq!(vec!["Sean".to_string()], limited);
+    /// assert_eq!(vec!["Sean".to_string(), "Bastien".to_string(), "Pascal".to_string()], no_limit);
+    /// # }
+    /// ```
     fn limit(self, limit: i64) -> Self::Output;
 }
 
diff --git a/diesel/src/query_dsl/offset_dsl.rs b/diesel/src/query_dsl/offset_dsl.rs
index e1ff3b4eb..357e872a0 100644
--- a/diesel/src/query_dsl/offset_dsl.rs
+++ b/diesel/src/query_dsl/offset_dsl.rs
@@ -6,6 +6,51 @@ use query_source::Table;
 pub trait OffsetDsl {
     type Output;
 
+    /// Creates a `SQL OFFSET` statement.
+    /// Offsets the number of records returned by the integer passed in.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// # use schema::users;
+    /// #
+    /// # fn main() {
+    /// #   use users::dsl::*;
+    /// #   let connection = establish_connection();
+    /// #   diesel::delete(users).execute(&connection).unwrap();
+    /// #
+    /// # let new_users = vec![
+    /// #    NewUser { name: "Sean".to_string(), },
+    /// #    NewUser { name: "Bastien".to_string(), },
+    /// #    NewUser { name: "Pascal".to_string(), },
+    /// # ];
+    /// #
+    /// # diesel::insert_into(users)
+    /// #    .values(&new_users)
+    /// #    .execute(&connection)
+    /// #    .unwrap();
+    /// #
+    /// // Using an offset
+    /// let offset = users.select(name)
+    ///     .order(id)
+    ///     .limit(2)
+    ///     .offset(1)
+    ///     .load::<String>(&connection)
+    ///     .unwrap();
+    ///
+    /// // No Offset
+    /// let no_offset = users.select(name)
+    ///     .order(id)
+    ///     .limit(2)
+    ///     .load::<String>(&connection)
+    ///     .unwrap();
+    ///
+    /// assert_eq!(vec!["Bastien".to_string(), "Pascal".to_string()], offset);
+    /// assert_eq!(vec!["Sean".to_string(), "Bastien".to_string()], no_offset);
+    /// # }
+    /// ```
     fn offset(self, offset: i64) -> Self::Output;
 }
 
diff --git a/diesel/src/query_dsl/save_changes_dsl.rs b/diesel/src/query_dsl/save_changes_dsl.rs
index 3b00b0644..1194451ab 100644
--- a/diesel/src/query_dsl/save_changes_dsl.rs
+++ b/diesel/src/query_dsl/save_changes_dsl.rs
@@ -61,6 +61,41 @@ pub trait SaveChangesDsl<Conn> {
     ///
     /// `foo.save_changes(&conn)` is equivalent to
     /// `update(foo::table().find(foo.id())).set(&foo).get_result(&conn)`
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # #[macro_use] extern crate diesel_codegen;
+    /// # include!("../doctest_setup.rs");
+    /// # use schema::users;
+    /// #
+    /// # #[derive(AsChangeset, Debug, PartialEq, Identifiable, Queryable)]
+    /// # struct Animal {
+    /// #    id: i32,
+    /// #    species: String,
+    /// #    legs: i32,
+    /// #    name: Option<String>,
+    /// # }
+    /// #
+    /// # fn main() {
+    /// #     use animals::dsl::*;
+    /// #     let connection = establish_connection();
+    /// let mut spider = animals.filter(species.eq("spider"))
+    ///     .first::<Animal>(&connection)
+    ///     .expect("Too scary to load");
+    ///
+    /// spider.species = String::from("solifuge");
+    /// spider.legs = 10;
+    ///
+    /// spider.save_changes::<Animal>(&connection).expect("Error saving changes");
+    ///
+    /// let changed_animal = animals.find(spider.id())
+    ///     .first::<Animal>(&connection);
+    ///
+    /// assert_eq!(Ok(Animal { id: 2, species: "solifuge".to_string(), legs: 10, name: None }), changed_animal);
+    /// # }
+    /// ```
     fn save_changes<T>(self, connection: &Conn) -> QueryResult<T>
     where
         Self: InternalSaveChangesDsl<Conn, T>,
