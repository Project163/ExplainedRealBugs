diff --git a/CHANGELOG.md b/CHANGELOG.md
index f9f6bc841..3950d8cb4 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -13,6 +13,12 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 * Updated chrono to version 0.3.
 
+* [`max`][max-0.11.0] and [`min`][min-0.11.0] are now always nullable. The database will
+  return `NULL` when the table is empty.
+
+[max-0.11.0]: http://docs.diesel.rs/diesel/expression/dsl/fn.max.html
+[min-0.11.0]: http://docs.diesel.rs/diesel/expression/dsl/fn.min.html
+
 ## [0.10.1] - 2017-02-08
 
 ### Fixed
diff --git a/diesel/src/expression/functions/aggregate_ordering.rs b/diesel/src/expression/functions/aggregate_ordering.rs
index 97abdf27c..d497edc0d 100644
--- a/diesel/src/expression/functions/aggregate_ordering.rs
+++ b/diesel/src/expression/functions/aggregate_ordering.rs
@@ -2,7 +2,7 @@ use backend::Backend;
 use expression::{Expression, SelectableExpression};
 use query_builder::*;
 use result::QueryResult;
-use types::{SqlOrd, HasSqlType};
+use types::{SqlOrd, HasSqlType, IntoNullable};
 
 macro_rules! ord_function {
     ($fn_name:ident, $type_name:ident, $operator:expr, $docs:expr) => {
@@ -21,8 +21,10 @@ macro_rules! ord_function {
             target: T,
         }
 
-        impl<T: Expression> Expression for $type_name<T> {
-            type SqlType = T::SqlType;
+        impl<T: Expression> Expression for $type_name<T> where
+            T::SqlType: IntoNullable,
+        {
+            type SqlType = <T::SqlType as IntoNullable>::Nullable;
         }
 
         impl<T, DB> QueryFragment<DB> for $type_name<T> where
@@ -48,7 +50,9 @@ macro_rules! ord_function {
 
         impl_query_id!($type_name<T>);
 
-        impl<T: Expression, QS> SelectableExpression<QS> for $type_name<T> {
+        impl<T, QS> SelectableExpression<QS> for $type_name<T> where
+            $type_name<T>: Expression,
+        {
         }
     }
 }
diff --git a/diesel/src/migrations/connection.rs b/diesel/src/migrations/connection.rs
index ea3b852ee..3022bc2b1 100644
--- a/diesel/src/migrations/connection.rs
+++ b/diesel/src/migrations/connection.rs
@@ -12,7 +12,7 @@ use types::{FromSql, VarChar};
 /// should be useable where this trait is required.
 pub trait MigrationConnection: Connection {
     fn previously_run_migration_versions(&self) -> QueryResult<HashSet<String>>;
-    fn latest_run_migration_version(&self) -> QueryResult<String>;
+    fn latest_run_migration_version(&self) -> QueryResult<Option<String>>;
     fn insert_new_migration(&self, version: &str) -> QueryResult<()>;
 }
 
@@ -27,7 +27,7 @@ impl<T> MigrationConnection for T where
             .map(FromIterator::from_iter)
     }
 
-    fn latest_run_migration_version(&self) -> QueryResult<String> {
+    fn latest_run_migration_version(&self) -> QueryResult<Option<String>> {
         use ::expression::dsl::max;
         __diesel_schema_migrations.select(max(version))
             .first(self)
diff --git a/diesel/src/migrations/migration_error.rs b/diesel/src/migrations/migration_error.rs
index 8afa5cdd6..9f6bd738d 100644
--- a/diesel/src/migrations/migration_error.rs
+++ b/diesel/src/migrations/migration_error.rs
@@ -11,6 +11,7 @@ pub enum MigrationError {
     UnknownMigrationFormat(PathBuf),
     IoError(io::Error),
     UnknownMigrationVersion(String),
+    NoMigrationRun,
 }
 
 impl Error for MigrationError {
@@ -25,6 +26,8 @@ impl Error for MigrationError {
                 error.description(),
             MigrationError::UnknownMigrationVersion(_) =>
                 "Unable to find migration version to revert in the migrations directory.",
+            MigrationError::NoMigrationRun =>
+                "No migrations have been run. Did you forget `diesel migration run`?",
         }
     }
 }
diff --git a/diesel/src/migrations/mod.rs b/diesel/src/migrations/mod.rs
index 952dac00e..d17d5f2bf 100644
--- a/diesel/src/migrations/mod.rs
+++ b/diesel/src/migrations/mod.rs
@@ -117,7 +117,8 @@ pub fn revert_latest_migration<Conn>(conn: &Conn) -> Result<String, RunMigration
     Conn: MigrationConnection,
 {
     try!(setup_database(conn));
-    let latest_migration_version = try!(conn.latest_run_migration_version());
+    let latest_migration_version = conn.latest_run_migration_version()?
+        .ok_or_else(|| RunMigrationsError::MigrationError(MigrationError::NoMigrationRun))?;
     revert_migration_with_version(conn, &latest_migration_version, &mut stdout())
         .map(|_| latest_migration_version)
 }
diff --git a/diesel_tests/tests/expressions/mod.rs b/diesel_tests/tests/expressions/mod.rs
index b9e8d0506..c8626d53e 100644
--- a/diesel_tests/tests/expressions/mod.rs
+++ b/diesel_tests/tests/expressions/mod.rs
@@ -63,9 +63,11 @@ fn test_count_max() {
     connection.execute("INSERT INTO numbers (n) VALUES (2), (1), (5)").unwrap();
     let source = numbers.select(max(n));
 
-    assert_eq!(Ok(5), source.first(&connection));
+    assert_eq!(Ok(Some(5)), source.first(&connection));
     connection.execute("DELETE FROM numbers WHERE n = 5").unwrap();
-    assert_eq!(Ok(2), source.first(&connection));
+    assert_eq!(Ok(Some(2)), source.first(&connection));
+    connection.execute("DELETE FROM numbers").unwrap();
+    assert_eq!(Ok(None::<i32>), source.first(&connection));
 }
 
 #[test]
@@ -79,9 +81,11 @@ fn max_returns_same_type_as_expression_being_maximized() {
         NewUser::new("A", None),
     ];
     insert(data).into(users).execute(&connection).unwrap();
-    assert_eq!(Ok("C".to_string()), source.first(&connection));
+    assert_eq!(Ok(Some("C".to_string())), source.first(&connection));
     connection.execute("DELETE FROM users WHERE name = 'C'").unwrap();
-    assert_eq!(Ok("B".to_string()), source.first(&connection));
+    assert_eq!(Ok(Some("B".to_string())), source.first(&connection));
+    connection.execute("DELETE FROM users").unwrap();
+    assert_eq!(Ok(None::<String>), source.first(&connection));
 }
 
 use std::marker::PhantomData;
@@ -146,9 +150,11 @@ fn test_min() {
     connection.execute("INSERT INTO numbers (n) VALUES (2), (1), (5)").unwrap();
     let source = numbers.select(min(n));
 
-    assert_eq!(Ok(1), source.first(&connection));
+    assert_eq!(Ok(Some(1)), source.first(&connection));
     connection.execute("DELETE FROM numbers WHERE n = 1").unwrap();
-    assert_eq!(Ok(2), source.first(&connection));
+    assert_eq!(Ok(Some(2)), source.first(&connection));
+    connection.execute("DELETE FROM numbers").unwrap();
+    assert_eq!(Ok(None::<i32>), source.first(&connection));
 }
 
 sql_function!(coalesce, coalesce_t, (x: types::Nullable<types::VarChar>, y: types::VarChar) -> types::VarChar);
