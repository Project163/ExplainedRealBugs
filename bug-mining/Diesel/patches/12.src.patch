diff --git a/CHANGELOG.md b/CHANGELOG.md
index 474e5103f..2fd1ce334 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -36,6 +36,11 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 * Implemented `Send` on `Connection` (required for R2D2 support)
 
+* Added `infer_schema!` and `infer_table_from_schema!`. Both macros take a
+  database URL, and will invoke `table!` for you automatically based on the
+  schema. `infer_schema!` queries for the table names, while
+  `infer_table_from_schema!` takes a table name as the second argument.
+
 ## [0.2.0] - 2015-11-30
 
 ### Added
diff --git a/README.md b/README.md
index 3ecda67bb..fcf9596cd 100644
--- a/README.md
+++ b/README.md
@@ -52,6 +52,29 @@ only the users table, and not have to qualify everything. If we did not have
 this import, we'd need to put `users::` before each column, and reference the
 table as `users::table`.
 
+You can also use
+[diesel_codegen](https://github.com/sgrif/diesel/tree/master/diesel_codegen) to
+call [`table!`][table] for you automatically, based on your existing database
+schema. See the [diesel_codegen
+README](https://github.com/sgrif/diesel/tree/master/diesel_codegen) for details
+on how to get started. Here's the same code with Diesel Codegen.
+
+```rust
+#[macro_use] extern crate diesel;
+
+use diesel::*;
+
+infer_schema!(dotenv!("DATABASE_URL"));
+
+fn users_with_name(connection: &Connection, target_name: &str)
+    -> QueryResult<Vec<(i32, String, Option<String>)>>
+{
+    use self::users::dsl::*;
+    users.filter(name.eq(target_name)).load(connection)
+        .map(|x| x.collect())
+}
+```
+
 If you want to be able to query for a struct, you'll need to implement the
 [`Queriable` trait][queriable] Luckily,
 [diesel_codegen](https://github.com/sgrif/diesel/tree/master/diesel_codegen) can do
diff --git a/diesel_codegen/README.md b/diesel_codegen/README.md
index 0c2c5caa4..493d2d434 100644
--- a/diesel_codegen/README.md
+++ b/diesel_codegen/README.md
@@ -125,3 +125,28 @@ Field annotations
 
 Any field can be annotated with `column_name=` to have it map to a column with a
 different name. This is required for all fields of tuple structs.
+
+Macros (Experimental)
+---------------------
+
+### `infer_schema!("database_url")`
+
+Queries the database for the names of all tables, and calls
+`infer_table_from_schema!` for each one. We recommend using with the
+[`dotenv`](https://github.com/slapresta/rust-dotenv) crate, and invoking this as
+`infer_schema!(dotenv!("DATABASE_URL"))`
+
+### `infer_table_from_schema!("database_url", "table_name")`
+
+Establishes a database connection at compile time, loads the schema information
+about a table's columns, and invokes
+[`table`](http://sgrif.github.io/diesel/diesel/macro.table!.html) for you
+automatically. We recommend using with the
+[`dotenv`](https://github.com/slapresta/rust-dotenv) crate, and invoking this as
+`infer_table_from_schema!(dotenv!("DATABASE_URL"), "table_name")`
+
+At this time, the schema inference macros do not support types from third party
+crates, and having any columns with a type not already supported will result in
+a compiler error (please open an issue if this happens unexpectedly for a type
+listed in [our
+docs](http://sgrif.github.io/diesel/diesel/types/index.html#structs).)
diff --git a/diesel_codegen/src/lib.rs b/diesel_codegen/src/lib.rs
index 7331d6521..00883fa67 100644
--- a/diesel_codegen/src/lib.rs
+++ b/diesel_codegen/src/lib.rs
@@ -34,7 +34,8 @@ pub fn register(reg: &mut syntex::Registry) {
     reg.add_decorator("changeset_for", update::expand_changeset_for);
     reg.add_decorator("has_many", associations::expand_has_many);
     reg.add_decorator("belongs_to", associations::expand_belongs_to);
-    reg.add_macro("load_table_from_schema", schema_inference::expand_load_table);
+    reg.add_macro("infer_table_from_schema", schema_inference::expand_load_table);
+    reg.add_macro("infer_schema", schema_inference::expand_infer_schema);
 }
 
 #[cfg_attr(not(feature = "with-syntex"), plugin_registrar)]
@@ -62,5 +63,6 @@ pub fn register(reg: &mut rustc_plugin::Registry) {
         intern("belongs_to"),
         MultiDecorator(Box::new(associations::expand_belongs_to))
     );
-    reg.register_macro("load_table_from_schema", schema_inference::expand_load_table);
+    reg.register_macro("infer_table_from_schema", schema_inference::expand_load_table);
+    reg.register_macro("infer_schema", schema_inference::expand_infer_schema);
 }
diff --git a/diesel_codegen/src/schema_inference/mod.rs b/diesel_codegen/src/schema_inference/mod.rs
index 20aa6e63e..6f97a6893 100644
--- a/diesel_codegen/src/schema_inference/mod.rs
+++ b/diesel_codegen/src/schema_inference/mod.rs
@@ -37,15 +37,61 @@ pub fn load_table_body<T: Iterator<Item=P<ast::Expr>>>(
 ) -> Result<Box<MacResult>, Box<MacResult>> {
     let database_url = try!(next_str_lit(cx, sp, exprs));
     let table_name = try!(next_str_lit(cx, sp, exprs));
+    let connection = try!(establish_connection(cx, sp, &database_url));
+    table_macro_call(cx, sp, &connection, &table_name)
+        .map(|item| MacEager::items(SmallVector::one(item)))
+}
+
+pub fn expand_infer_schema<'cx>(
+    cx: &'cx mut ExtCtxt,
+    sp: Span,
+    tts: &[ast::TokenTree]
+) -> Box<MacResult+'cx> {
+    let mut exprs = match get_exprs_from_tts(cx, sp, tts) {
+        Some(exprs) => exprs.into_iter(),
+        None => return DummyResult::any(sp),
+    };
+
+    match infer_schema_body(cx, sp, &mut exprs) {
+        Ok(res) => res,
+        Err(res) => res,
+    }
+}
+
+pub fn infer_schema_body<T: Iterator<Item=P<ast::Expr>>>(
+    cx: &mut ExtCtxt,
+    sp: Span,
+    exprs: &mut T,
+) -> Result<Box<MacResult>, Box<MacResult>> {
+    let database_url = try!(next_str_lit(cx, sp, exprs));
+    let connection = try!(establish_connection(cx, sp, &database_url));
+    let table_names = try!(load_table_names(cx, sp, &connection));
+    let impls = table_names.into_iter()
+        .map(|n| table_macro_call(cx, sp, &connection, &n))
+        .collect();
+    Ok(MacEager::items(SmallVector::many(try!(impls))))
+}
 
-    let connection = try!(Connection::establish(&database_url).map_err(|_| {
+fn establish_connection(
+    cx: &mut ExtCtxt,
+    sp: Span,
+    database_url: &str,
+) -> Result<Connection, Box<MacResult>> {
+    Connection::establish(database_url).map_err(|_| {
         cx.span_err(sp, "failed to establish a database connection");
         DummyResult::any(sp)
-    }));
+    })
+}
 
-    match get_table_data(&connection, &table_name) {
+fn table_macro_call(
+    cx: &mut ExtCtxt,
+    sp: Span,
+    connection: &Connection,
+    table_name: &str,
+) -> Result<P<ast::Item>, Box<MacResult>> {
+    match get_table_data(&connection, table_name) {
         Err(NotFound) => {
-            cx.span_err(sp, &format!("no table exists named {}", &table_name));
+            cx.span_err(sp, &format!("no table exists named {}", table_name));
             Err(DummyResult::any(sp))
         }
         Err(_) => {
@@ -55,13 +101,13 @@ pub fn load_table_body<T: Iterator<Item=P<ast::Expr>>>(
         Ok(data) => {
             let tokens = data.iter().map(|a| column_def_tokens(cx, a))
                 .collect::<Vec<_>>();
-            let table_name = str_to_ident(&table_name);
+            let table_name = str_to_ident(table_name);
             let item = quote_item!(cx, table! {
                 $table_name {
                     $tokens
                 }
             }).unwrap();
-            Ok(MacEager::items(SmallVector::one(item)))
+            Ok(item)
         }
     }
 }
@@ -109,3 +155,17 @@ fn column_def_tokens(cx: &mut ExtCtxt, attr: &PgAttr) -> Vec<ast::TokenTree> {
 fn capitalize(name: &str) -> String {
     name[..1].to_uppercase() + &name[1..]
 }
+
+fn load_table_names(
+    cx: &mut ExtCtxt,
+    sp: Span,
+    connection: &Connection,
+) -> Result<Vec<String>, Box<MacResult>> {
+    connection.query_sql::<types::VarChar, String>(
+        "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'")
+        .map(|r| r.collect())
+        .map_err(|_| {
+            cx.span_err(sp, "Error loading table names");
+            DummyResult::any(sp)
+        })
+}
diff --git a/diesel_tests/tests/schema.rs b/diesel_tests/tests/schema.rs
index 66c829eae..2cb9d3aa3 100644
--- a/diesel_tests/tests/schema.rs
+++ b/diesel_tests/tests/schema.rs
@@ -57,9 +57,7 @@ pub struct Comment {
     text: String,
 }
 
-load_table_from_schema!(dotenv!("DATABASE_URL_FOR_SCHEMA"), "users");
-load_table_from_schema!(dotenv!("DATABASE_URL_FOR_SCHEMA"), "posts");
-load_table_from_schema!(dotenv!("DATABASE_URL_FOR_SCHEMA"), "comments");
+infer_schema!(dotenv!("DATABASE_URL_FOR_SCHEMA"));
 numeric_expr!(users::id);
 
 select_column_workaround!(users -> comments (id, name, hair_color));
