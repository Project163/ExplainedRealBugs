diff --git a/diesel/src/mysql/connection/mod.rs b/diesel/src/mysql/connection/mod.rs
index 050f4e3ea..12bcbf719 100644
--- a/diesel/src/mysql/connection/mod.rs
+++ b/diesel/src/mysql/connection/mod.rs
@@ -123,3 +123,42 @@ impl MysqlConnection {
         Ok(())
     }
 }
+
+#[cfg(test)]
+mod tests {
+    extern crate dotenv;
+
+    use super::*;
+    use std::env;
+
+    fn connection() -> MysqlConnection {
+        let _ = dotenv::dotenv();
+        let database_url = env::var("MYSQL_UNIT_TEST_DATABASE_URL")
+            .or_else(|_| env::var("MYSQL_DATABASE_URL"))
+            .or_else(|_| env::var("DATABASE_URL"))
+            .expect("DATABASE_URL must be set in order to run unit tests");
+        MysqlConnection::establish(&database_url).unwrap()
+    }
+
+    #[test]
+    fn batch_execute_handles_single_queries_with_results() {
+        let connection = connection();
+        assert!(connection.batch_execute("SELECT 1").is_ok());
+        assert!(connection.batch_execute("SELECT 1").is_ok());
+    }
+
+    #[test]
+    fn batch_execute_handles_multi_queries_with_results() {
+        let connection = connection();
+        let query = "SELECT 1; SELECT 2; SELECT 3;";
+        assert!(connection.batch_execute(query).is_ok());
+        assert!(connection.batch_execute(query).is_ok());
+    }
+
+    #[test]
+    fn execute_handles_queries_which_return_results() {
+        let connection = connection();
+        assert!(connection.execute("SELECT 1").is_ok());
+        assert!(connection.execute("SELECT 1").is_ok());
+    }
+}
diff --git a/diesel/src/mysql/connection/raw.rs b/diesel/src/mysql/connection/raw.rs
index fa35ef3a2..1b87d8de1 100644
--- a/diesel/src/mysql/connection/raw.rs
+++ b/diesel/src/mysql/connection/raw.rs
@@ -79,7 +79,9 @@ impl RawConnection {
                 query.len() as libc::c_ulong,
             );
         }
-        self.did_an_error_occur()
+        self.did_an_error_occur()?;
+        self.flush_pending_results()?;
+        Ok(())
     }
 
     pub fn enable_multi_statements<T, F>(&self, f: F) -> QueryResult<T> where
@@ -95,12 +97,6 @@ impl RawConnection {
 
         let result = f();
 
-        unsafe {
-            while ffi::mysql_next_result(self.0) != -1 {
-                self.did_an_error_occur()?;
-            }
-        }
-
         unsafe {
             ffi::mysql_set_server_option(
                 self.0,
@@ -142,6 +138,36 @@ impl RawConnection {
             ))
         }
     }
+
+    fn flush_pending_results(&self) -> QueryResult<()> {
+        // We may have a result to process before advancing
+        self.consume_current_result()?;
+        while self.next_result()? {
+            self.consume_current_result()?;
+        }
+        // next_result returns whether we've advanced to the *last* one, not
+        // whether we're completely done.
+        self.consume_current_result()?;
+        Ok(())
+    }
+
+    fn consume_current_result(&self) -> QueryResult<()> {
+        unsafe {
+            let res = ffi::mysql_store_result(self.0);
+            if !res.is_null() {
+                ffi::mysql_free_result(res);
+            }
+        }
+        self.did_an_error_occur()
+    }
+
+    /// Calls `mysql_next_result` and returns whether there are more results
+    /// after this one.
+    fn next_result(&self) -> QueryResult<bool> {
+        let more_results = unsafe { ffi::mysql_next_result(self.0) == 0 };
+        self.did_an_error_occur()?;
+        Ok(more_results)
+    }
 }
 
 impl Drop for RawConnection {
