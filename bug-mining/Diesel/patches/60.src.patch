diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7f785db0b..153cbabe6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -6,6 +6,10 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 ## [0.8.2] - 2016-11-22
 
+### Added
+
+* Added support for SQL `NOT IN` using the `ne_any` method.
+
 ### Changed
 
 * Fixed support for nightlies later than 2016-11-07
diff --git a/diesel/src/expression/array_comparison.rs b/diesel/src/expression/array_comparison.rs
index d7a23a94d..ac0a4f31b 100644
--- a/diesel/src/expression/array_comparison.rs
+++ b/diesel/src/expression/array_comparison.rs
@@ -11,7 +11,13 @@ pub struct In<T, U> {
     values: U,
 }
 
+#[derive(Debug, Copy, Clone)]
+pub struct NotIn<T, U> {
+    in_expr: In<T, U>
+}
+
 pub type EqAny<T, U> = In<T, <U as AsInExpression<SqlTypeOf<T>>>::InExpression>;
+pub type NeAny<T, U> = NotIn<T, <U as AsInExpression<SqlTypeOf<T>>>::InExpression>;
 
 impl<T, U> In<T, U> {
     pub fn new(left: T, values: U) -> Self {
@@ -22,6 +28,14 @@ impl<T, U> In<T, U> {
     }
 }
 
+impl<T, U> NotIn<T, U> {
+    pub fn new(left: T, values: U) -> Self {
+        NotIn {
+            in_expr: In::new(left, values),
+        }
+    }
+}
+
 impl<T, U> Expression for In<T, U> where
     T: Expression,
     U: Expression<SqlType=T::SqlType>,
@@ -29,6 +43,11 @@ impl<T, U> Expression for In<T, U> where
     type SqlType = Bool;
 }
 
+impl<T, U> Expression for NotIn<T, U> where In<T, U>: Expression,
+{
+    type SqlType = Bool;
+}
+
 impl<T, U, QS> SelectableExpression<QS> for In<T, U> where
     In<T, U>: Expression,
     T: SelectableExpression<QS>,
@@ -36,11 +55,21 @@ impl<T, U, QS> SelectableExpression<QS> for In<T, U> where
 {
 }
 
+impl<T, U, QS> SelectableExpression<QS> for NotIn<T, U> where
+    In<T, U>: SelectableExpression<QS>,
+{
+}
+
 impl<T, U> NonAggregate for In<T, U> where
     In<T, U>: Expression,
 {
 }
 
+impl<T, U> NonAggregate for NotIn<T, U> where
+    NotIn<T, U>: Expression,
+{
+}
+
 impl<T, U, DB> QueryFragment<DB> for In<T, U> where
     DB: Backend,
     T: QueryFragment<DB>,
@@ -66,7 +95,26 @@ impl<T, U, DB> QueryFragment<DB> for In<T, U> where
     }
 }
 
+impl<T, U, DB> QueryFragment<DB> for NotIn<T, U> where
+    DB: Backend,
+    In<T, U>: QueryFragment<DB>,
+{
+    fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
+        out.push_sql("NOT ");
+        self.in_expr.to_sql(out)
+    }
+
+    fn collect_binds(&self, out: &mut DB::BindCollector) -> QueryResult<()> {
+        self.in_expr.collect_binds(out)
+    }
+
+    fn is_safe_to_cache_prepared(&self) -> bool {
+        self.in_expr.is_safe_to_cache_prepared()
+    }
+}
+
 impl_query_id!(In<T, U>);
+impl_query_id!(NotIn<T, U>);
 
 use std::marker::PhantomData;
 use query_builder::SelectStatement;
diff --git a/diesel/src/expression/expression_methods/global_expression_methods.rs b/diesel/src/expression/expression_methods/global_expression_methods.rs
index 39550233f..970c9e60a 100644
--- a/diesel/src/expression/expression_methods/global_expression_methods.rs
+++ b/diesel/src/expression/expression_methods/global_expression_methods.rs
@@ -1,6 +1,6 @@
 use expression::{Expression, AsExpression, nullable};
 use expression::aliased::Aliased;
-use expression::array_comparison::{In, AsInExpression};
+use expression::array_comparison::{In, NotIn, AsInExpression};
 use expression::predicates::*;
 
 pub trait ExpressionMethods: Expression + Sized {
@@ -109,6 +109,41 @@ pub trait ExpressionMethods: Expression + Sized {
         In::new(self, values.as_in_expression())
     }
 
+    /// Creates a SQL `NOT IN` statement. Queries using this method will not be
+    /// placed in the prepared statement cache. On PostgreSQL, you should use
+    /// `ne(any())` instead. This method may change in the future to
+    /// automatically perform `!= ANY` on PostgreSQL.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("src/doctest_setup.rs");
+    /// #
+    /// # table! {
+    /// #     users {
+    /// #         id -> Integer,
+    /// #         name -> VarChar,
+    /// #     }
+    /// # }
+    /// #
+    /// # fn main() {
+    /// #     use self::users::dsl::*;
+    /// #     let connection = establish_connection();
+    /// #     connection.execute("INSERT INTO users (name) VALUES
+    /// #         ('Jim')").unwrap();
+    /// let data = users.select(id).filter(name.ne_any(vec!["Sean", "Jim"]));
+    /// assert_eq!(Ok(vec![2]), data.load(&connection));
+    /// let data = users.select(id).filter(name.ne_any(vec!["Tess"]));
+    /// assert_eq!(Ok(vec![1, 3]), data.load(&connection));
+    /// # }
+    /// ```
+    fn ne_any<T>(self, values: T) -> NotIn<Self, T::InExpression> where
+        T: AsInExpression<Self::SqlType>,
+    {
+        NotIn::new(self, values.as_in_expression())
+    }
+
     /// Creates a SQL `IS NULL` expression.
     fn is_null(self) -> IsNull<Self> {
        IsNull::new(self)
diff --git a/diesel_tests/Cargo.toml b/diesel_tests/Cargo.toml
index f76a99455..366067f20 100644
--- a/diesel_tests/Cargo.toml
+++ b/diesel_tests/Cargo.toml
@@ -31,10 +31,6 @@ stable_sqlite = ["with-syntex", "sqlite", "diesel_codegen_syntex/sqlite"]
 unstable_postgres = ["unstable", "postgres", "diesel_codegen/postgres"]
 unstable_sqlite = ["unstable", "sqlite", "diesel_codegen/sqlite"]
 
-[lib]
-name = "integration_tests"
-path = "tests/lib.rs"
-
 [[test]]
 name = "integration_tests"
 path = "tests/lib.rs"
