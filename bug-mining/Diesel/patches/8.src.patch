diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9e88bf8c0..ff9229bda 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -18,6 +18,8 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
   like `create` and `update`. In the future, `get_result` may also check that
   only a single row was affected.
 
+* Added [`insert`][insert], which mirrors the pattern of `update` and `delete`.
+
 ### Changed
 
 * Added a hidden `__Nonexhaustive` variant to `result::Error`. This is not
@@ -30,6 +32,13 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
   method has been added to the result, in case having a `Result<Option<T>>` is
   more ideomatic than checking for `Err(NotFound)`.
 
+### Deprecated
+
+* `Connection#insert` and `Connection#insert_returning_count` have been
+  deprecated in favor of [`insert`][insert]
+
+[insert]: http://sgrif.github.io/diesel/diesel/query_builder/fn.insert.html
+
 ## [0.1.0] - 2015-11-29
 
 * Initial release
diff --git a/README.md b/README.md
index b6202d123..83650cf77 100644
--- a/README.md
+++ b/README.md
@@ -99,14 +99,13 @@ fn create_user(connection: &Connection, name: &str, favorite_color: Option<&str>
         name: name,
         favorite_color: favorite_color,
     };
-    connection.insert(&users::table, &new_user)
-        .map(|mut result| result.nth(0).unwrap())
+    insert(&new_user).into(users::table).get_result(connection)
 }
 ```
 
 [`insert`][insert] can return any struct which implements
 [`Queriable`][queriable] for the right type. If you don't actually want to use
-the results, you should call [`insert_returning_count`][insert_returning_count]
+the results, you should call [`execute`][execute]
 instead, or the compiler will complain that it can't infer what type you meant
 to return. You can use the same struct for inserting and querying if you'd like,
 but you'll need to make columns that are not present during the insert optional
@@ -139,8 +138,7 @@ fn create_user(connection: &Connection, name: &str, favorite_color: Option<&str>
   -> QueryResult<User>
 {
     let new_user = NewUser(name, favorite_color);
-    connection.insert(&users::table, &new_user)
-        .map(|mut result| result.nth(0).unwrap())
+    insert(&new_user).into(users::table).get_result(connection)
 }
 ```
 
@@ -233,8 +231,7 @@ you can go about getting the data structures set up.
 [table]: http://sgrif.github.io/diesel/diesel/macro.table!.html
 [queriable]: http://sgrif.github.io/diesel/diesel/query_source/trait.Queriable.html
 [insertable]: http://sgrif.github.io/diesel/diesel/trait.Insertable.html
-[insert]: http://sgrif.github.io/diesel/diesel/struct.Connection.html#method.insert
-[insert_returning_count]: http://sgrif.github.io/diesel/diesel/struct.Connection.html#method.insert_returning_count
+[insert]: http://sgrif.github.io/diesel/diesel/query_builder/fn.insert.html
 [execute]: http://sgrif.github.io/diesel/diesel/trait.ExecuteDsl.html#method.execute
 [run]: http://sgrif.github.io/diesel/diesel/trait.LoadDsl.html#method.run
 [run_all]: http://sgrif.github.io/diesel/diesel/trait.LoadDsl.html#method.run_all
diff --git a/diesel/src/connection/mod.rs b/diesel/src/connection/mod.rs
index 4d3f367b5..92a042f3f 100644
--- a/diesel/src/connection/mod.rs
+++ b/diesel/src/connection/mod.rs
@@ -212,10 +212,7 @@ impl Connection {
         self.query_one(source.filter(pk.eq(id)).limit(1))
     }
 
-    /// Inserts new records in the database, and returns an `Iterator` of models
-    /// created from the inserted rows. If you do not want to use the returned
-    /// models, you should call [`insert_returning_count`](#method.insert_returning_count)
-    /// instead.
+    #[doc(hidden)]
     pub fn insert<T, U, Out>(&self, _source: &T, records: U)
         -> QueryResult<Cursor<<T::AllColumns as Expression>::SqlType, Out>> where
         T: Table,
@@ -234,8 +231,7 @@ impl Connection {
         self.exec_sql_params(&sql, &params, &Some(param_types)).map(Cursor::new)
     }
 
-    /// Inserts new records into the database, returning the number of rows that
-    /// were saved.
+    #[doc(hidden)]
     pub fn insert_returning_count<T, U>(&self, _source: &T, records: U)
         -> QueryResult<usize> where
         T: Table,
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index 784e8a108..51ce6e5aa 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -94,6 +94,9 @@ pub fn delete<T: UpdateTarget>(source: T) -> DeleteStatement<T> {
     DeleteStatement::new(source)
 }
 
+/// Creates an insert statement. Will add the given data to a table. This
+/// function is not exported by default. As with other commands, the resulting
+/// query can return the inserted rows if you choose.
 pub fn insert<T>(records: T) -> IncompleteInsertStatement<T> {
     IncompleteInsertStatement::new(records)
 }
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index 291692a4c..5d6461011 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -3,6 +3,8 @@ use expression::Expression;
 use query_builder::*;
 use query_source::Table;
 
+/// The structure returned by [`insert`](fn.insert.html). The only thing that can be done with it
+/// is call `into`.
 pub struct IncompleteInsertStatement<T> {
     records: T,
 }
@@ -15,6 +17,7 @@ impl<T> IncompleteInsertStatement<T> {
         }
     }
 
+    /// Specify which table the data passed to `insert` should be added to.
     pub fn into<S>(self, target: S) -> InsertStatement<S, T> where
         InsertStatement<S, T>: QueryFragment,
     {
diff --git a/diesel_tests/tests/associations.rs b/diesel_tests/tests/associations.rs
index 3beb19524..a6daa16d0 100644
--- a/diesel_tests/tests/associations.rs
+++ b/diesel_tests/tests/associations.rs
@@ -8,12 +8,16 @@ fn one_to_many_returns_query_source_for_association() {
 
     let sean: User = connection.find(users::table, 1).unwrap();
     let tess: User = connection.find(users::table, 2).unwrap();
-    let seans_posts: Vec<Post> = connection.insert(&posts::table, &vec![
-        sean.new_post("Hello", None), sean.new_post("World", None),
-    ]).unwrap().collect();
-    let tess_posts: Vec<Post> = connection.insert(&posts::table, &vec![
+    let seans_posts: Vec<Post> =  insert(&vec![
+        sean.new_post("Hello", None), sean.new_post("World", None)
+        ]).into(posts::table)
+        .get_results(&connection)
+        .unwrap().collect();
+    let tess_posts: Vec<Post> = insert(&vec![
         tess.new_post("Hello 2", None), tess.new_post("World 2", None),
-    ]).unwrap().collect();
+        ]).into(posts::table)
+        .get_results(&connection)
+        .unwrap().collect();
 
     let found_posts: Vec<_> = Post::belonging_to(&sean).load(&connection).unwrap().collect();
     assert_eq!(seans_posts, found_posts);
diff --git a/diesel_tests/tests/bench.rs b/diesel_tests/tests/bench.rs
index 5d00153f8..39296b349 100644
--- a/diesel_tests/tests/bench.rs
+++ b/diesel_tests/tests/bench.rs
@@ -8,6 +8,7 @@ mod schema;
 use self::test::Bencher;
 use self::schema::*;
 use diesel::*;
+use diesel::query_builder::insert;
 
 #[bench]
 fn bench_selecting_0_rows_with_trivial_query(b: &mut Bencher) {
@@ -26,7 +27,7 @@ fn bench_selecting_10k_rows_with_trivial_query(b: &mut Bencher) {
     let data: Vec<_> = (0..10_000).map(|i| {
         NewUser::new(&format!("User {}", i), None)
     }).collect();
-    conn.insert_returning_count(&users::table, &data).unwrap();
+    insert(&data).into(&users::table).execute(&connection).unwrap();
 
     b.iter(|| {
         users::table.load(&conn).unwrap().collect::<Vec<User>>()
@@ -58,7 +59,7 @@ fn bench_selecting_10k_rows_with_medium_complex_query(b: &mut Bencher) {
         let hair_color = if i % 2 == 0 { "black" } else { "brown" };
         NewUser::new(&format!("User {}", i), Some(hair_color))
     }).collect();
-    conn.insert_returning_count(&users::table, &data).unwrap();
+    insert(&data).into(&users::table).execute(&connection).unwrap();
 
     b.iter(|| {
         use schema::users::dsl::*;
diff --git a/diesel_tests/tests/expressions/mod.rs b/diesel_tests/tests/expressions/mod.rs
index e6e377f49..ee56db411 100644
--- a/diesel_tests/tests/expressions/mod.rs
+++ b/diesel_tests/tests/expressions/mod.rs
@@ -14,7 +14,7 @@ fn test_count_counts_the_rows() {
     let source = users.select(count(users.star()));
 
     assert_eq!(Ok(0), source.first(&connection));
-    connection.insert_returning_count(&users, &NewUser::new("Sean", None)).unwrap();
+    insert(&NewUser::new("Sean", None)).into(users).execute(&connection).unwrap();
     assert_eq!(Ok(1), source.first(&connection));
 }
 
@@ -25,7 +25,7 @@ fn test_count_star() {
     let source = users.count();
 
     assert_eq!(Ok(0), source.first(&connection));
-    connection.insert_returning_count(&users, &NewUser::new("Sean", None)).unwrap();
+    insert(&NewUser::new("Sean", None)).into(users).execute(&connection).unwrap();
     assert_eq!(Ok(1), source.first(&connection));
 
     // Ensure we're doing COUNT(*) instead of COUNT(table.*) which is going to be more efficient
@@ -83,7 +83,7 @@ fn max_returns_same_type_as_expression_being_maxed() {
         NewUser::new("C", None),
         NewUser::new("A", None),
     ];
-    connection.insert_returning_count(&users, data).unwrap();
+    insert(data).into(users).execute(&connection).unwrap();
     assert_eq!(Ok("C".to_string()), source.first(&connection));
     connection.execute("DELETE FROM users WHERE name = 'C'").unwrap();
     assert_eq!(Ok("B".to_string()), source.first(&connection));
@@ -144,8 +144,9 @@ fn function_with_multiple_arguments() {
 
     let connection = connection();
     setup_users_table(&connection);
-    connection.insert_returning_count(&users,
-        &vec![NewUser::new("Sean", Some("black")), NewUser::new("Tess", None)])
+    insert(&vec![NewUser::new("Sean", Some("black")), NewUser::new("Tess", None)])
+        .into(users)
+        .execute(&connection)
         .unwrap();
 
     let expected_data = vec!["black".to_string(), "Tess".to_string()];
diff --git a/diesel_tests/tests/expressions/ops.rs b/diesel_tests/tests/expressions/ops.rs
index 59e8c8257..7f8f4aff8 100644
--- a/diesel_tests/tests/expressions/ops.rs
+++ b/diesel_tests/tests/expressions/ops.rs
@@ -96,7 +96,7 @@ fn mix_and_match_all_numeric_ops() {
 
     let connection = connection_with_sean_and_tess_in_users_table();
     let data = vec![NewUser::new("Jim", None), NewUser::new("Bob", None)];
-    connection.insert_returning_count(&users, &data).unwrap();
+    insert(&data).into(users).execute(&connection).unwrap();
 
     let expected_data = vec![4, 6, 7, 9];
     let data: Vec<_> = users.select(id * 3 / 2 + 4 - 1).load(&connection)
diff --git a/diesel_tests/tests/filter.rs b/diesel_tests/tests/filter.rs
index 11a0c726f..d4b48671d 100644
--- a/diesel_tests/tests/filter.rs
+++ b/diesel_tests/tests/filter.rs
@@ -38,7 +38,7 @@ fn filter_by_equality_on_nullable_columns() {
         NewUser::new("Tess", Some("brown")),
         NewUser::new("Jim", Some("black")),
     ];
-    connection.insert_returning_count(&users, &data).unwrap();
+    insert(&data).into(users).execute(&connection).unwrap();
 
     let sean = User::with_hair_color(1, "Sean", "black");
     let tess = User::with_hair_color(2, "Tess", "brown");
@@ -59,7 +59,7 @@ fn filter_by_is_not_null_on_nullable_columns() {
         NewUser::new("Derek", Some("red")),
         NewUser::new("Gordon", None),
     ];
-    connection.insert_returning_count(&users, &data).unwrap();
+    insert(&data).into(users).execute(&connection).unwrap();
 
     let derek = User::with_hair_color(1, "Derek", "red");
     let source = users.filter(hair_color.is_not_null());
@@ -76,7 +76,7 @@ fn filter_by_is_null_on_nullable_columns() {
         NewUser::new("Derek", Some("red")),
         NewUser::new("Gordon", None),
     ];
-    connection.insert_returning_count(&users, &data).unwrap();
+    insert(&data).into(users).execute(&connection).unwrap();
 
     let gordon = User::new(2, "Gordon");
     let source = users.filter(hair_color.is_null());
@@ -126,7 +126,7 @@ fn filter_then_select() {
     let connection = connection();
     setup_users_table(&connection);
     let data = vec![NewUser::new("Sean", None), NewUser::new("Tess", None)];
-    connection.insert_returning_count(&users, &data).unwrap();
+    insert(&data).into(users).execute(&connection).unwrap();
 
     assert_eq!(Ok("Sean".to_string()),
         users.filter(name.eq("Sean")).select(name).first(&connection));
@@ -149,7 +149,7 @@ fn filter_on_multiple_columns() {
         NewUser::new("Tess", Some("black")),
         NewUser::new("Tess", Some("brown")),
     ];
-    assert_eq!(5, connection.insert_returning_count(&users, data).unwrap());
+    assert_eq!(5, insert(data).into(users).execute(&connection).unwrap());
 
     let black_haired_sean = User::with_hair_color(1, "Sean", "black");
     let brown_haired_sean = User::with_hair_color(2, "Sean", "brown");
@@ -187,7 +187,7 @@ fn filter_called_twice_means_same_thing_as_and() {
         NewUser::new("Tess", Some("black")),
         NewUser::new("Tess", Some("brown")),
     ];
-    assert_eq!(5, connection.insert_returning_count(&users, data).unwrap());
+    assert_eq!(5, insert(data).into(users).execute(&connection).unwrap());
 
     let black_haired_sean = User::with_hair_color(1, "Sean", "black");
     let brown_haired_sean = User::with_hair_color(2, "Sean", "brown");
@@ -238,8 +238,7 @@ fn filter_with_or() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
-    connection.insert_returning_count(&users, &NewUser::new("Jim", None))
-        .unwrap();
+    insert(&NewUser::new("Jim", None)).into(users).execute(&connection).unwrap();
 
     let expected_users = vec![User::new(1, "Sean"), User::new(2, "Tess")];
     let data: Vec<_> = users.filter(name.eq("Sean").or(name.eq("Tess")))
diff --git a/diesel_tests/tests/filter_operators.rs b/diesel_tests/tests/filter_operators.rs
index 22f28251f..fbdcc3d1b 100644
--- a/diesel_tests/tests/filter_operators.rs
+++ b/diesel_tests/tests/filter_operators.rs
@@ -92,7 +92,7 @@ fn filter_by_like() {
         NewUser::new("Tess Griffin", None),
         NewUser::new("Jim", None),
     ];
-    connection.insert_returning_count(&users, &data).unwrap();
+    insert(&data).into(users).execute(&connection).unwrap();
 
     let sean = User::new(1, "Sean Griffin");
     let tess = User::new(2, "Tess Griffin");
@@ -141,6 +141,6 @@ fn connection_with_3_users() -> Connection {
         NewUser::new("Tess", None),
         NewUser::new("Jim", None),
     ];
-    connection.insert_returning_count(&users::table, &data).unwrap();
+    insert(&data).into(users::table).execute(&connection).unwrap();
     connection
 }
diff --git a/diesel_tests/tests/insert.rs b/diesel_tests/tests/insert.rs
index b27f09517..df8078b32 100644
--- a/diesel_tests/tests/insert.rs
+++ b/diesel_tests/tests/insert.rs
@@ -1,6 +1,5 @@
 use super::schema::*;
 use diesel::*;
-use diesel::query_builder::insert;
 
 #[test]
 fn insert_records() {
@@ -12,7 +11,7 @@ fn insert_records() {
         NewUser::new("Sean", Some("Black")),
         NewUser::new("Tess", None),
     ];
-    let inserted_users: Vec<_> = connection.insert(&users, new_users).unwrap().collect();
+    let inserted_users: Vec<_> = insert(new_users).into(users).get_results(&connection).unwrap().collect();
 
     let expected_users = vec![
         User { id: 1, name: "Sean".to_string(), hair_color: Some("Black".to_string()) },
@@ -37,7 +36,7 @@ fn insert_with_defaults() {
         NewUser::new("Sean", Some("Black")),
         NewUser::new("Tess", None),
     ];
-    let inserted_users: Vec<_> = connection.insert(&users, new_users).unwrap().collect();
+    let inserted_users: Vec<_> = insert(new_users).into(users).get_results(&connection).unwrap().collect();
 
     let expected_users = vec![
         User { id: 1, name: "Sean".to_string(), hair_color: Some("Black".to_string()) },
@@ -62,7 +61,7 @@ fn insert_with_defaults_not_provided() {
         BaldUser { name: "Sean".to_string() },
         BaldUser { name: "Tess".to_string() },
     ];
-    let inserted_users: Vec<_> = connection.insert(&users, new_users).unwrap().collect();
+    let inserted_users: Vec<_> = insert(new_users).into(users).get_results(&connection).unwrap().collect();
 
     let expected_users = vec![
         User { id: 1, name: "Sean".to_string(), hair_color: Some("Green".to_string()) },
@@ -87,8 +86,8 @@ fn insert_returning_count_returns_number_of_rows_inserted() {
         BaldUser { name: "Sean".to_string() },
         BaldUser { name: "Tess".to_string() },
     ];
-    let count = connection.insert_returning_count(&users, new_users).unwrap();
-    let second_count = connection.insert_returning_count(&users, &BaldUser { name: "Guy".to_string() }).unwrap();
+    let count = insert(new_users).into(users).execute(&connection).unwrap();
+    let second_count = insert(&BaldUser { name: "Guy".to_string() }).into(users).execute(&connection).unwrap();
 
     assert_eq!(2, count);
     assert_eq!(1, second_count);
@@ -113,7 +112,8 @@ fn insert_borrowed_content() {
         BorrowedUser { name: "Sean" },
         BorrowedUser { name: "Tess" },
     ];
-    let inserted_users: Vec<_> = insert(new_users).into(users).load(&connection).unwrap().collect();
+    let inserted_users: Vec<_> = insert(new_users).into(users).get_results(&connection)
+        .unwrap().collect();
 
     let expected_users = vec![
         User::new(1, "Sean"),
diff --git a/diesel_tests/tests/joins.rs b/diesel_tests/tests/joins.rs
index b917b0486..96ba751fd 100644
--- a/diesel_tests/tests/joins.rs
+++ b/diesel_tests/tests/joins.rs
@@ -258,15 +258,17 @@ fn join_through_other() {
     setup_posts_table(&connection);
     setup_comments_table(&connection);
 
-    connection.insert_returning_count(&users, &NewUser::new("Jim", None))
-        .unwrap();
-    connection.insert_returning_count(&posts::table, &vec![
+    insert(&NewUser::new("Jim", None)).into(users).execute(&connection).unwrap();
+    insert(&vec![
         NewPost::new(1, "Hello", None), NewPost::new(2, "World", None),
         NewPost::new(1, "Hello again!", None),
-    ]).unwrap();
-    let comments: Vec<Comment> = connection.insert(&comments::table, &vec![
+        ]).into(posts::table)
+        .execute(&connection)
+        .unwrap();
+    let comments: Vec<Comment> = insert(&vec![
         NewComment(1, "OMG"), NewComment(2, "WTF"),
-        NewComment(3, "Best post ever!!!")]).unwrap().collect();
+        NewComment(3, "Best post ever!!!")
+    ]).into(comments).get_results(&connection).unwrap().collect();
 
     let data: Vec<_> = users.inner_join(comments::table).load(&connection)
         .unwrap().collect();
diff --git a/diesel_tests/tests/order.rs b/diesel_tests/tests/order.rs
index fd6a219dd..13da9b4e6 100644
--- a/diesel_tests/tests/order.rs
+++ b/diesel_tests/tests/order.rs
@@ -12,7 +12,7 @@ fn order_by_column() {
         NewUser::new("Tess", None),
         NewUser::new("Jim", None),
     ];
-    conn.insert_returning_count(&users, &data).unwrap();
+    insert(&data).into(users).execute(&conn).unwrap();
 
     let expected_data = vec![
         User::new(3, "Jim"),
@@ -22,7 +22,7 @@ fn order_by_column() {
     let data: Vec<_> = users.order(name).load(&conn).unwrap().collect();
     assert_eq!(expected_data, data);
 
-    conn.insert_returning_count(&users, &NewUser::new("Aaron", None)).unwrap();
+    insert(&NewUser::new("Aaron", None)).into(users).execute(&conn).unwrap();
     let expected_data = vec![
         User::new(4, "Aaron"),
         User::new(3, "Jim"),
@@ -44,7 +44,7 @@ fn order_by_descending_column() {
         NewUser::new("Tess", None),
         NewUser::new("Jim", None),
     ];
-    conn.insert_returning_count(&users, &data).unwrap();
+    insert(&data).into(users).execute(&conn).unwrap();
 
     let expected_data = vec![
         User::new(2, "Tess"),
@@ -54,7 +54,7 @@ fn order_by_descending_column() {
     let data: Vec<_> = users.order(name.desc()).load(&conn).unwrap().collect();
     assert_eq!(expected_data, data);
 
-    conn.insert_returning_count(&users, &NewUser::new("Aaron", None)).unwrap();
+    insert(&NewUser::new("Aaron", None)).into(users).execute(&conn).unwrap();
     let expected_data = vec![
         User::new(2, "Tess"),
         User::new(1, "Sean"),
diff --git a/diesel_tests/tests/schema.rs b/diesel_tests/tests/schema.rs
index da6067932..d80148fbc 100644
--- a/diesel_tests/tests/schema.rs
+++ b/diesel_tests/tests/schema.rs
@@ -1,4 +1,5 @@
 use diesel::*;
+pub use diesel::query_builder::insert;
 extern crate dotenv;
 
 #[derive(PartialEq, Eq, Debug, Clone, Queriable)]
@@ -174,6 +175,6 @@ pub fn connection_with_sean_and_tess_in_users_table() -> Connection {
     let connection = connection();
     setup_users_table(&connection);
     let data: &[_] = &[NewUser::new("Sean", None), NewUser::new("Tess", None)];
-    connection.insert_returning_count(&users::table, data).unwrap();
+    insert(data).into(users::table).execute(&connection).unwrap();
     connection
 }
