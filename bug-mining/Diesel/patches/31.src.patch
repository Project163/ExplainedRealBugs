diff --git a/diesel/src/migrations/mod.rs b/diesel/src/migrations/mod.rs
index dc95e4e28..bb63323d1 100644
--- a/diesel/src/migrations/mod.rs
+++ b/diesel/src/migrations/mod.rs
@@ -63,8 +63,9 @@ pub use self::migration_error::*;
 
 use std::io::{stdout, Write};
 
-use ::expression::expression_methods::*;
-use ::query_dsl::*;
+use expression::expression_methods::*;
+use persistable::Insertable;
+use query_dsl::*;
 use self::migration::*;
 use self::migration_error::MigrationError::*;
 use self::schema::NewMigration;
@@ -92,6 +93,7 @@ use std::path::{PathBuf, Path};
 pub fn run_pending_migrations<Conn>(conn: &Conn) -> Result<(), RunMigrationsError> where
     Conn: Connection,
     String: FromSql<VarChar, Conn::Backend>,
+    for<'a> &'a NewMigration<'a>: Insertable<__diesel_schema_migrations, Conn::Backend>,
 {
     let migrations_dir = try!(find_migrations_directory());
     run_pending_migrations_in_directory(conn, &migrations_dir, &mut stdout())
@@ -102,6 +104,7 @@ pub fn run_pending_migrations_in_directory<Conn>(conn: &Conn, migrations_dir: &P
     -> Result<(), RunMigrationsError> where
         Conn: Connection,
         String: FromSql<VarChar, Conn::Backend>,
+        for<'a> &'a NewMigration<'a>: Insertable<__diesel_schema_migrations, Conn::Backend>,
 {
     try!(create_schema_migrations_table_if_needed(conn));
     let already_run = try!(previously_run_migration_versions(conn));
@@ -138,7 +141,8 @@ pub fn revert_migration_with_version<Conn: Connection>(conn: &Conn, ver: &str, o
 
 #[doc(hidden)]
 pub fn run_migration_with_version<Conn: Connection>(conn: &Conn, ver: &str, output: &mut Write)
-    -> Result<(), RunMigrationsError>
+    -> Result<(), RunMigrationsError> where
+        for<'a> &'a NewMigration<'a>: Insertable<__diesel_schema_migrations, Conn::Backend>,
 {
     migration_with_version(ver)
         .map_err(|e| e.into())
@@ -203,7 +207,8 @@ fn migrations_in_directory(path: &Path) -> Result<Vec<Box<Migration>>, Migration
 }
 
 fn run_migrations<Conn: Connection>(conn: &Conn, mut migrations: Vec<Box<Migration>>, output: &mut Write)
-    -> Result<(), RunMigrationsError>
+    -> Result<(), RunMigrationsError> where
+        for<'a> &'a NewMigration<'a>: Insertable<__diesel_schema_migrations, Conn::Backend>,
 {
     migrations.sort_by(|a, b| a.version().cmp(b.version()));
     for migration in migrations {
@@ -213,7 +218,8 @@ fn run_migrations<Conn: Connection>(conn: &Conn, mut migrations: Vec<Box<Migrati
 }
 
 fn run_migration<Conn: Connection>(conn: &Conn, migration: Box<Migration>, output: &mut Write)
-    -> Result<(), RunMigrationsError>
+    -> Result<(), RunMigrationsError> where
+        for<'a> &'a NewMigration<'a>: Insertable<__diesel_schema_migrations, Conn::Backend>,
 {
     conn.transaction(|| {
         try!(writeln!(output, "Running migration {}", migration.version()));
diff --git a/diesel/src/migrations/schema.rs b/diesel/src/migrations/schema.rs
index fb65fd055..263e7a624 100644
--- a/diesel/src/migrations/schema.rs
+++ b/diesel/src/migrations/schema.rs
@@ -7,21 +7,28 @@ table! {
 
 pub struct NewMigration<'a>(pub &'a str);
 
+use backend::Backend;
 use expression::AsExpression;
-use expression::grouped::Grouped;
 use expression::helper_types::AsExpr;
-use {Insertable, types};
+use persistable::{Insertable, ColumnInsertValue, InsertValues};
 
 impl<'update: 'a, 'a, DB> Insertable<__diesel_schema_migrations::table, DB>
-for &'update NewMigration<'a> {
-    type Columns = __diesel_schema_migrations::version;
-    type Values = Grouped<AsExpr<&'a str, Self::Columns>>;
-
-    fn columns() -> Self::Columns {
-        __diesel_schema_migrations::version
-    }
+    for &'update NewMigration<'a> where
+        DB: Backend,
+        (ColumnInsertValue<
+            __diesel_schema_migrations::version,
+            AsExpr<&'a str, __diesel_schema_migrations::version>,
+        >,): InsertValues<DB>,
+{
+    type Values = (ColumnInsertValue<
+        __diesel_schema_migrations::version,
+        AsExpr<&'a str, __diesel_schema_migrations::version>,
+    >,);
 
     fn values(self) -> Self::Values {
-        Grouped(AsExpression::<types::VarChar>::as_expression(self.0))
+        (ColumnInsertValue::Expression(
+            __diesel_schema_migrations::version,
+            AsExpression::<::types::VarChar>::as_expression(self.0),
+        ),)
     }
 }
diff --git a/diesel/src/persistable.rs b/diesel/src/persistable.rs
index 1d51f0fd1..fb462d58c 100644
--- a/diesel/src/persistable.rs
+++ b/diesel/src/persistable.rs
@@ -2,7 +2,7 @@ use std::marker::PhantomData;
 
 use backend::{Backend, SupportsDefaultKeyword};
 use expression::Expression;
-use query_builder::{QueryBuilder, BuildQueryResult, QueryFragment};
+use query_builder::{QueryBuilder, BuildQueryResult};
 use query_source::{Table, Column};
 
 /// Represents that a structure can be used to to insert a new row into the database.
@@ -10,35 +10,35 @@ use query_source::{Table, Column};
 /// [`#[insertable_into]`](https://github.com/sgrif/diesel/tree/master/diesel_codegen#insertable_intotable_name).
 /// This is automatically implemented for `&[T]`, `Vec<T>` and `&Vec<T>` for inserting more than
 /// one record.
-pub trait Insertable<T: Table, DB> {
-    type Columns: InsertableColumns<T>;
-    type Values: Expression<SqlType=<Self::Columns as InsertableColumns<T>>::SqlType>;
-
-    fn columns() -> Self::Columns;
+pub trait Insertable<T: Table, DB: Backend> {
+    type Values: InsertValues<DB>;
 
     fn values(self) -> Self::Values;
 }
 
-pub trait InsertableColumns<T: Table> {
-    type SqlType;
+pub trait InsertValues<DB: Backend> {
+    fn column_names(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult;
+    fn values_clause(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult;
+}
 
-    fn names(&self) -> String;
+pub enum ColumnInsertValue<Col, Expr> where
+    Col: Column,
+    Expr: Expression<SqlType=Col::SqlType>,
+{
+    Expression(Col, Expr),
+    Default(Col),
 }
 
-impl<'a, T, U, DB> Insertable<T, DB> for &'a [U] where
+impl<'a, T, U: 'a, DB> Insertable<T, DB> for &'a [U] where
     T: Table,
+    DB: Backend,
     &'a U: Insertable<T, DB>,
     DB: SupportsDefaultKeyword,
 {
-    type Columns = <&'a U as Insertable<T, DB>>::Columns;
-    type Values = InsertValues<'a, T, U, DB>;
-
-    fn columns() -> Self::Columns {
-        <&'a U>::columns()
-    }
+    type Values = BatchInsertValues<'a, T, U, DB>;
 
     fn values(self) -> Self::Values {
-        InsertValues {
+        BatchInsertValues {
             values: self,
             _marker: PhantomData,
         }
@@ -47,54 +47,38 @@ impl<'a, T, U, DB> Insertable<T, DB> for &'a [U] where
 
 impl<'a, T, U, DB> Insertable<T, DB> for &'a Vec<U> where
     T: Table,
+    DB: Backend,
     &'a [U]: Insertable<T, DB>,
 {
-    type Columns = <&'a [U] as Insertable<T, DB>>::Columns;
     type Values = <&'a [U] as Insertable<T, DB>>::Values;
 
-    fn columns() -> Self::Columns {
-        <&'a [U]>::columns()
-    }
-
     fn values(self) -> Self::Values {
         (self as &'a [U]).values()
     }
 }
 
 
-pub struct InsertValues<'a, T, U: 'a, DB> {
+pub struct BatchInsertValues<'a, T, U: 'a, DB> {
     values: &'a [U],
     _marker: PhantomData<(T, DB)>,
 }
 
-impl<'a, T, U, DB> Expression for InsertValues<'a, T, U, DB> where
+impl<'a, T, U: 'a, DB> InsertValues<DB> for BatchInsertValues<'a, T, U, DB> where
     T: Table,
-    &'a U: Insertable<T, DB>,
-{
-    type SqlType = <<&'a U as Insertable<T, DB>>::Columns as InsertableColumns<T>>::SqlType;
-}
-
-impl<'a, T, U, DB> QueryFragment<DB> for InsertValues<'a, T, U, DB> where
     DB: Backend,
-    T: Table,
     &'a U: Insertable<T, DB>,
-    <&'a U as Insertable<T, DB>>::Values: QueryFragment<DB>,
 {
-    fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
+    fn column_names(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
+        self.values[0].values().column_names(out)
+    }
+
+    fn values_clause(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
         for (i, record) in self.values.into_iter().enumerate() {
             if i != 0 {
                 out.push_sql(", ");
             }
-            try!(record.values().to_sql(out));
+            try!(record.values().values_clause(out));
         }
         Ok(())
     }
 }
-
-impl<C: Column<Table=T>, T: Table> InsertableColumns<T> for C {
-    type SqlType = <Self as Expression>::SqlType;
-
-    fn names(&self) -> String {
-        Self::name().to_string()
-    }
-}
diff --git a/diesel/src/query_builder/debug.rs b/diesel/src/query_builder/debug.rs
index 5052fda55..5f7556658 100644
--- a/diesel/src/query_builder/debug.rs
+++ b/diesel/src/query_builder/debug.rs
@@ -1,12 +1,11 @@
 use backend::Debug;
-use super::{QueryBuilder, BuildQueryResult, Context};
+use super::{QueryBuilder, BuildQueryResult};
 use types::HasSqlType;
 
 #[doc(hidden)]
 pub struct DebugQueryBuilder {
     pub sql: String,
     pub bind_types: Vec<u32>,
-    context_stack: Vec<Context>,
 }
 
 impl DebugQueryBuilder {
@@ -14,7 +13,6 @@ impl DebugQueryBuilder {
         DebugQueryBuilder {
             sql: String::new(),
             bind_types: Vec::new(),
-            context_stack: Vec::new(),
         }
     }
 }
@@ -31,20 +29,10 @@ impl QueryBuilder<Debug> for DebugQueryBuilder {
         Ok(())
     }
 
+    #[allow(unused_variables)]
     fn push_bound_value<T>(&mut self, bind: Option<Vec<u8>>) where
         Debug: HasSqlType<T>,
     {
-        match (self.context_stack.first(), bind) {
-            (Some(&Context::Insert), None) => self.push_sql("DEFAULT"),
-            _ => self.push_sql("?"),
-        }
-    }
-
-    fn push_context(&mut self, context: Context) {
-        self.context_stack.push(context);
-    }
-
-    fn pop_context(&mut self) {
-        self.context_stack.pop();
+        self.push_sql("?");
     }
 }
diff --git a/diesel/src/query_builder/delete_statement.rs b/diesel/src/query_builder/delete_statement.rs
index e6dc8f02f..51a4afe0e 100644
--- a/diesel/src/query_builder/delete_statement.rs
+++ b/diesel/src/query_builder/delete_statement.rs
@@ -17,14 +17,12 @@ impl<T, DB> QueryFragment<DB> for DeleteStatement<T> where
     T::FromClause: QueryFragment<DB>,
 {
     fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
-        out.push_context(Context::Delete);
         out.push_sql("DELETE FROM ");
         try!(self.0.from_clause().to_sql(out));
         if let Some(clause) = self.0.where_clause() {
             out.push_sql(" WHERE ");
             try!(clause.to_sql(out));
         }
-        out.pop_context();
         Ok(())
     }
 }
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index 146f9813e..83e0d2cf4 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -1,5 +1,5 @@
 use backend::{Backend, SupportsReturningClause};
-use persistable::{Insertable, InsertableColumns};
+use persistable::{Insertable, InsertValues};
 use expression::Expression;
 use query_builder::*;
 use query_source::Table;
@@ -40,17 +40,15 @@ impl<T, U, DB> QueryFragment<DB> for InsertStatement<T, U> where
     T: Table,
     T::FromClause: QueryFragment<DB>,
     U: Insertable<T, DB> + Copy,
-    U::Values: QueryFragment<DB>,
 {
     fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
-        out.push_context(Context::Insert);
+        let values = self.records.values();
         out.push_sql("INSERT INTO ");
         try!(self.target.from_clause().to_sql(out));
         out.push_sql(" (");
-        out.push_sql(&U::columns().names());
+        try!(values.column_names(out));
         out.push_sql(") VALUES ");
-        try!(QueryFragment::to_sql(&self.records.values(), out));
-        out.pop_context();
+        try!(values.values_clause(out));
         Ok(())
     }
 }
@@ -88,11 +86,9 @@ impl<T, U, DB> QueryFragment<DB> for InsertQuery<T, U> where
     U: QueryFragment<DB>,
 {
     fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
-        out.push_context(Context::Insert);
         try!(self.statement.to_sql(out));
         out.push_sql(" RETURNING ");
         try!(self.returning.to_sql(out));
-        out.pop_context();
         Ok(())
     }
 }
diff --git a/diesel/src/query_builder/mod.rs b/diesel/src/query_builder/mod.rs
index 0a9c97e7f..bcc0a886e 100644
--- a/diesel/src/query_builder/mod.rs
+++ b/diesel/src/query_builder/mod.rs
@@ -45,19 +45,6 @@ pub trait QueryBuilder<DB: Backend> {
     fn push_identifier(&mut self, identifier: &str) -> BuildQueryResult;
     fn push_bound_value<T>(&mut self, binds: Option<Vec<u8>>) where
         DB: HasSqlType<T>;
-    fn push_context(&mut self, context: Context);
-    fn pop_context(&mut self);
-}
-
-/// Represents the current overall type of query being constructed. Used for
-/// example, to place the keyword `DEFAULT` instead of a bind param when a null
-/// bind param is pushed on insert.
-#[derive(Debug, Clone, Copy)]
-pub enum Context {
-    Select,
-    Insert,
-    Update,
-    Delete,
 }
 
 /// A complete SQL query with a return type. This can be a select statement, or
diff --git a/diesel/src/query_builder/pg.rs b/diesel/src/query_builder/pg.rs
index 24e6b5f01..4852d8515 100644
--- a/diesel/src/query_builder/pg.rs
+++ b/diesel/src/query_builder/pg.rs
@@ -2,7 +2,7 @@ use std::rc::Rc;
 
 use backend::Pg;
 use connection::pg::raw::RawConnection;
-use super::{QueryBuilder, Binds, BuildQueryResult, Context};
+use super::{QueryBuilder, Binds, BuildQueryResult};
 use types::HasSqlType;
 
 pub struct PgQueryBuilder {
@@ -11,7 +11,6 @@ pub struct PgQueryBuilder {
     pub binds: Binds,
     pub bind_types: Vec<u32>,
     bind_idx: u32,
-    context_stack: Vec<Context>,
 }
 
 impl PgQueryBuilder {
@@ -22,7 +21,6 @@ impl PgQueryBuilder {
             binds: Vec::new(),
             bind_types: Vec::new(),
             bind_idx: 0,
-            context_stack: Vec::new(),
         }
     }
 }
@@ -40,23 +38,10 @@ impl QueryBuilder<Pg> for PgQueryBuilder {
     fn push_bound_value<T>(&mut self, bind: Option<Vec<u8>>) where
         Pg: HasSqlType<T>,
     {
-        match (self.context_stack.first(), bind) {
-            (Some(&Context::Insert), None) => self.push_sql("DEFAULT"),
-            (_, bind) => {
-                self.bind_idx += 1;
-                let sql = format!("${}", self.bind_idx);
-                self.push_sql(&sql);
-                self.binds.push(bind);
-                self.bind_types.push(Pg::metadata().oid);
-            }
-        }
-    }
-
-    fn push_context(&mut self, context: Context) {
-        self.context_stack.push(context);
-    }
-
-    fn pop_context(&mut self) {
-        self.context_stack.pop();
+        self.bind_idx += 1;
+        let sql = format!("${}", self.bind_idx);
+        self.push_sql(&sql);
+        self.binds.push(bind);
+        self.bind_types.push(Pg::metadata().oid);
     }
 }
diff --git a/diesel/src/query_builder/select_statement/mod.rs b/diesel/src/query_builder/select_statement/mod.rs
index e62066868..0cf8ea869 100644
--- a/diesel/src/query_builder/select_statement/mod.rs
+++ b/diesel/src/query_builder/select_statement/mod.rs
@@ -4,7 +4,7 @@ use backend::Backend;
 use expression::*;
 use query_source::*;
 use std::marker::PhantomData;
-use super::{Query, QueryBuilder, QueryFragment, BuildQueryResult, Context};
+use super::{Query, QueryBuilder, QueryFragment, BuildQueryResult};
 use super::limit_clause::NoLimitClause;
 use super::offset_clause::NoOffsetClause;
 use super::order_clause::NoOrderClause;
@@ -92,7 +92,6 @@ impl<ST, S, F, W, O, L, Of, DB> QueryFragment<DB> for SelectStatement<ST, S, F,
     Of: QueryFragment<DB>,
 {
     fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
-        out.push_context(Context::Select);
         out.push_sql("SELECT ");
         try!(self.select.to_sql(out));
         out.push_sql(" FROM ");
@@ -101,7 +100,6 @@ impl<ST, S, F, W, O, L, Of, DB> QueryFragment<DB> for SelectStatement<ST, S, F,
         try!(self.order.to_sql(out));
         try!(self.limit.to_sql(out));
         try!(self.offset.to_sql(out));
-        out.pop_context();
         Ok(())
     }
 }
@@ -115,14 +113,12 @@ impl<ST, S, W, O, L, Of, DB> QueryFragment<DB> for SelectStatement<ST, S, (), W,
     Of: QueryFragment<DB>,
 {
     fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
-        out.push_context(Context::Select);
         out.push_sql("SELECT ");
         try!(self.select.to_sql(out));
         try!(self.where_clause.to_sql(out));
         try!(self.order.to_sql(out));
         try!(self.limit.to_sql(out));
         try!(self.offset.to_sql(out));
-        out.pop_context();
         Ok(())
     }
 }
diff --git a/diesel/src/query_builder/sqlite.rs b/diesel/src/query_builder/sqlite.rs
index 74f0fa261..ee6530ff6 100644
--- a/diesel/src/query_builder/sqlite.rs
+++ b/diesel/src/query_builder/sqlite.rs
@@ -1,5 +1,5 @@
 use backend::{Sqlite, SqliteType};
-use super::{QueryBuilder, BuildQueryResult, Context};
+use super::{QueryBuilder, BuildQueryResult};
 use types::HasSqlType;
 
 #[doc(hidden)]
@@ -35,10 +35,4 @@ impl QueryBuilder<Sqlite> for SqliteQueryBuilder {
         self.push_sql("?");
         self.bind_params.push((Sqlite::metadata(), bind));
     }
-
-    fn push_context(&mut self, _context: Context) {
-    }
-
-    fn pop_context(&mut self) {
-    }
 }
diff --git a/diesel/src/query_builder/update_statement/mod.rs b/diesel/src/query_builder/update_statement/mod.rs
index 4cf22db83..1ff94beef 100644
--- a/diesel/src/query_builder/update_statement/mod.rs
+++ b/diesel/src/query_builder/update_statement/mod.rs
@@ -6,7 +6,7 @@ pub use self::target::UpdateTarget;
 
 use backend::{Backend, SupportsReturningClause};
 use expression::Expression;
-use query_builder::{Query, AsQuery, QueryFragment, QueryBuilder, BuildQueryResult, Context};
+use query_builder::{Query, AsQuery, QueryFragment, QueryBuilder, BuildQueryResult};
 use query_source::Table;
 
 /// The type returned by [`update`](fn.update.html). The only thing you can do
@@ -46,7 +46,6 @@ impl<T, U, DB> QueryFragment<DB> for UpdateStatement<T, U> where
     U: changeset::Changeset<DB>,
 {
     fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
-        out.push_context(Context::Update);
         out.push_sql("UPDATE ");
         try!(self.target.from_clause().to_sql(out));
         out.push_sql(" SET ");
@@ -55,7 +54,6 @@ impl<T, U, DB> QueryFragment<DB> for UpdateStatement<T, U> where
             out.push_sql(" WHERE ");
             try!(clause.to_sql(out));
         }
-        out.pop_context();
         Ok(())
     }
 }
@@ -81,11 +79,9 @@ impl<T, U, DB> QueryFragment<DB> for UpdateQuery<T, U> where
     UpdateStatement<T, U>: QueryFragment<DB>,
 {
     fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
-        out.push_context(Context::Update);
         try!(self.0.to_sql(out));
         out.push_sql(" RETURNING ");
         try!(T::Table::all_columns().to_sql(out));
-        out.pop_context();
         Ok(())
     }
 }
diff --git a/diesel/src/types/impls/tuples.rs b/diesel/src/types/impls/tuples.rs
index 876e886ce..f4b9131d7 100644
--- a/diesel/src/types/impls/tuples.rs
+++ b/diesel/src/types/impls/tuples.rs
@@ -1,7 +1,8 @@
-use backend::Backend;
+use backend::{Backend, Sqlite, SupportsDefaultKeyword};
 use expression::{Expression, SelectableExpression, NonAggregate};
-use persistable::InsertableColumns;
+use persistable::{ColumnInsertValue, InsertValues};
 use query_builder::{Changeset, AsChangeset, QueryBuilder, BuildQueryResult, QueryFragment};
+use query_builder::sqlite::SqliteQueryBuilder;
 use query_source::{QuerySource, Queryable, Table, Column};
 use row::Row;
 use std::error::Error;
@@ -90,12 +91,83 @@ macro_rules! tuple_impls {
             impl<$($T: Expression + NonAggregate),+> NonAggregate for ($($T,)+) {
             }
 
-            impl<$($T: Column<Table=Tab>),+, Tab: Table> InsertableColumns<Tab> for ($($T,)+) {
-                type SqlType = ($(<$T as Expression>::SqlType),+);
+            impl<$($T,)+ $($ST,)+ Tab, DB> InsertValues<DB>
+                for ($(ColumnInsertValue<$T, $ST>,)+) where
+                    DB: Backend + SupportsDefaultKeyword,
+                    Tab: Table,
+                    $($T: Column<Table=Tab>,)+
+                    $($ST: Expression<SqlType=$T::SqlType> + QueryFragment<DB>,)+
+            {
+                fn column_names(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
+                    $(
+                        if e!($idx) != 0 {
+                            out.push_sql(", ");
+                        }
+                        try!(out.push_identifier($T::name()));
+                    )+
+                    Ok(())
+                }
 
-                fn names(&self) -> String {
-                    let parts: &[&str] = &[$($T::name()),*];
-                    parts.join(", ")
+                fn values_clause(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
+                    out.push_sql("(");
+                    $(
+                        if e!($idx) != 0 {
+                            out.push_sql(", ");
+                        }
+                        match e!(&self.$idx) {
+                            &ColumnInsertValue::Expression(_, ref value) => {
+                                try!(value.to_sql(out));
+                            }
+                            _ => out.push_sql("DEFAULT"),
+                        }
+                    )+
+                    out.push_sql(")");
+                    Ok(())
+                }
+            }
+
+            impl<$($T,)+ $($ST,)+ Tab> InsertValues<Sqlite>
+                for ($(ColumnInsertValue<$T, $ST>,)+) where
+                    Tab: Table,
+                    $($T: Column<Table=Tab>,)+
+                    $($ST: Expression<SqlType=$T::SqlType> + QueryFragment<Sqlite>,)+
+            {
+                #[allow(unused_assignments)]
+                fn column_names(&self, out: &mut SqliteQueryBuilder) -> BuildQueryResult {
+                    let mut columns_present = false;
+                    $(
+                        match e!(&self.$idx) {
+                            &ColumnInsertValue::Expression(..) => {
+                                if columns_present {
+                                    out.push_sql(", ");
+                                }
+                                try!(out.push_identifier($T::name()));
+                                columns_present = true;
+                            }
+                            _ => {}
+                        }
+                    )+
+                    Ok(())
+                }
+
+                #[allow(unused_assignments)]
+                fn values_clause(&self, out: &mut SqliteQueryBuilder) -> BuildQueryResult {
+                    out.push_sql("(");
+                    let mut columns_present = false;
+                    $(
+                        match e!(&self.$idx) {
+                            &ColumnInsertValue::Expression(_, ref value) => {
+                                if columns_present {
+                                    out.push_sql(", ");
+                                }
+                                try!(value.to_sql(out));
+                                columns_present = true;
+                            }
+                            _ => {}
+                        }
+                    )+
+                    out.push_sql(")");
+                    Ok(())
                 }
             }
 
diff --git a/diesel_codegen/src/insertable.rs b/diesel_codegen/src/insertable.rs
index 9810e857e..a83946f55 100644
--- a/diesel_codegen/src/insertable.rs
+++ b/diesel_codegen/src/insertable.rs
@@ -11,7 +11,7 @@ use syntax::ptr::P;
 use syntax::parse::token::{InternedString, str_to_ident};
 
 use attr::Attr;
-use util::struct_ty;
+use util::{struct_ty, is_option_ty};
 
 pub fn expand_insert(
     cx: &mut ExtCtxt,
@@ -69,42 +69,25 @@ fn insertable_impl(
     };
     let ty = struct_ty(cx, span, item.ident, &generics);
     let table_mod = str_to_ident(&table);
-    let columns_ty = columns_ty(cx, span, table_mod, &fields);
     let values_ty = values_ty(cx, span, table_mod, &fields);
-    let columns_expr = columns_expr(cx, span, table_mod, &fields);
     let values_expr = values_expr(cx, span, table_mod, &fields);
 
     quote_item!(cx,
-        impl<'a: 'insert, 'insert, DB> ::diesel::persistable::Insertable<$table_mod::table, DB> for
-            &'insert $ty
+        impl<'a: 'insert, 'insert, DB> ::diesel::persistable::Insertable<$table_mod::table, DB>
+            for &'insert $ty where
+                DB: ::diesel::backend::Backend,
+                $values_ty: ::diesel::persistable::InsertValues<DB>,
         {
-            type Columns = $columns_ty;
-
-            type Values = ::diesel::expression::grouped::Grouped<$values_ty>;
-
-            fn columns() -> Self::Columns {
-                $columns_expr
-            }
+            type Values = $values_ty;
 
             fn values(self) -> Self::Values {
                 use ::diesel::expression::{AsExpression, Expression};
-                use ::diesel::expression::grouped::Grouped;
-                Grouped($values_expr)
+                $values_expr
             }
         }
     )
 }
 
-fn columns_ty(
-    cx: &ExtCtxt,
-    span: Span,
-    table_mod: ast::Ident,
-    fields: &[Attr],
-) -> P<ast::Ty> {
-    tuple_ty_from(cx, span, fields,
-                  |f| cx.ty_path(column_field_ty(cx, span, table_mod, f)))
-}
-
 fn values_ty(
     cx: &ExtCtxt,
     span: Span,
@@ -114,8 +97,13 @@ fn values_ty(
     tuple_ty_from(cx, span, fields, |f| {
         let ref field_ty = f.ty;
         let column_field_ty = column_field_ty(cx, span, table_mod, f);
-        quote_ty!(cx,
-            ::diesel::expression::helper_types::AsExpr<&'insert $field_ty, $column_field_ty>)
+        quote_ty!(cx, ::diesel::persistable::ColumnInsertValue<
+            $column_field_ty,
+            ::diesel::expression::bound::Bound<
+                <$column_field_ty as ::diesel::expression::Expression>::SqlType,
+                &'insert $field_ty,
+            >,
+        >)
     })
 }
 
@@ -128,16 +116,6 @@ fn column_field_ty(
     cx.path(span, vec![table_mod, field.column_name])
 }
 
-fn columns_expr(
-    cx: &ExtCtxt,
-    span: Span,
-    table_mod: ast::Ident,
-    fields: &[Attr],
-) -> P<ast::Expr> {
-    tuple_expr_from(cx, span, fields, |(_, f)|
-        cx.expr_path(column_field_ty(cx, span, table_mod, f)))
-}
-
 fn values_expr(
     cx: &ExtCtxt,
     span: Span,
@@ -151,9 +129,25 @@ fn values_expr(
             None => cx.expr_tup_field_access(span, self_, i),
         };
         let field_ty = column_field_ty(cx, span, table_mod, f);
-        quote_expr!(cx,
-            AsExpression::<<$field_ty as Expression>::SqlType>::as_expression(&$field_access))
+        let not_none_expr = quote_expr!(cx,
+            ::diesel::persistable::ColumnInsertValue::Expression(
+                $field_ty,
+                AsExpression::<<$field_ty as Expression>::SqlType>::as_expression(&$field_access),
+            )
+        );
+        if is_option_ty(&f.ty) {
+            quote_expr!(cx,
+                if $field_access.is_none() {
+                    ::diesel::persistable::ColumnInsertValue::Default($field_ty)
+                } else {
+                    $not_none_expr
+                }
+            )
+        } else {
+            not_none_expr
+        }
     })
+
 }
 
 fn tuple_ty_from<F: Fn(&Attr) -> P<ast::Ty>>(
diff --git a/diesel_codegen/src/update.rs b/diesel_codegen/src/update.rs
index bc8d550ac..08dd6849a 100644
--- a/diesel_codegen/src/update.rs
+++ b/diesel_codegen/src/update.rs
@@ -8,7 +8,7 @@ use syntax::parse::token::{InternedString, str_to_ident};
 
 use attr::Attr;
 use model::Model;
-use util::ty_param_of_option;
+use util::{ty_param_of_option, is_option_ty};
 
 pub fn expand_changeset_for(
     cx: &mut ExtCtxt,
@@ -206,7 +206,3 @@ fn changeset_expr(
         quote_expr!(cx, $column.eq(&self.$field_name))
     }
 }
-
-fn is_option_ty(ty: &ast::Ty) -> bool {
-    ty_param_of_option(ty).is_some()
-}
diff --git a/diesel_codegen/src/util.rs b/diesel_codegen/src/util.rs
index 0f9f4502c..bc8fdcf9f 100644
--- a/diesel_codegen/src/util.rs
+++ b/diesel_codegen/src/util.rs
@@ -77,3 +77,7 @@ pub fn ty_param_of_option(ty: &ast::Ty) -> Option<&P<ast::Ty>> {
         _ => None,
     }
 }
+
+pub fn is_option_ty(ty: &ast::Ty) -> bool {
+    ty_param_of_option(ty).is_some()
+}
diff --git a/diesel_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs b/diesel_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs
index 9c79a13d5..2976ff07e 100644
--- a/diesel_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs
+++ b/diesel_tests/tests/compile-fail/batch_insert_is_not_supported_on_sqlite.rs
@@ -2,7 +2,6 @@
 extern crate diesel;
 
 use diesel::*;
-use diesel::backend::Backend;
 use diesel::connection::SqliteConnection;
 use diesel::types::{Integer, VarChar};
 
@@ -13,43 +12,31 @@ table! {
     }
 }
 
-pub struct User {
-    id: i32,
-    name: String,
-}
-
-use diesel::types::FromSqlRow;
+pub struct NewUser(String);
 
-impl<DB: Backend> Queryable<(Integer, VarChar), DB> for User where
-    (i32, String): FromSqlRow<(Integer, VarChar), DB>,
-{
-    type Row = (i32, String);
+use diesel::backend::Sqlite;
+use diesel::persistable::InsertValues;
+use diesel::query_builder::BuildQueryResult;
+use diesel::query_builder::sqlite::SqliteQueryBuilder;
+
+// It doesn't actually matter if this would work. We're testing that insert fails
+// to compile here.
+pub struct MyValues;
+impl InsertValues<Sqlite> for MyValues {
+    fn column_names(&self, out: &mut SqliteQueryBuilder) -> BuildQueryResult {
+        Ok(())
+    }
 
-    fn build(row: Self::Row) -> Self {
-        User {
-            id: row.0,
-            name: row.1,
-        }
+    fn values_clause(&self, out: &mut SqliteQueryBuilder) -> BuildQueryResult {
+        Ok(())
     }
 }
 
-pub struct NewUser(String);
-
-use diesel::backend::Sqlite;
-use diesel::expression::AsExpression;
-use diesel::expression::grouped::Grouped;
-use diesel::expression::helper_types::AsExpr;
-
 impl<'a> Insertable<users::table, Sqlite> for &'a NewUser {
-    type Columns = users::name;
-    type Values = Grouped<AsExpr<&'a String, users::name>>;
-
-    fn columns() -> Self::Columns {
-        users::name
-    }
+    type Values = MyValues;
 
     fn values(self) -> Self::Values {
-        Grouped(<&'a String as AsExpression<VarChar>>::as_expression(&self.0))
+        MyValues
     }
 }
 
diff --git a/diesel_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs b/diesel_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs
index 34fbfdf10..2bc6ff938 100644
--- a/diesel_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs
+++ b/diesel_tests/tests/compile-fail/insert_statement_does_not_support_returning_methods_on_sqlite.rs
@@ -36,20 +36,28 @@ impl<DB: Backend> Queryable<(Integer, VarChar), DB> for User where
 pub struct NewUser(String);
 
 use diesel::backend::Sqlite;
-use diesel::expression::AsExpression;
-use diesel::expression::grouped::Grouped;
-use diesel::expression::helper_types::AsExpr;
+use diesel::persistable::InsertValues;
+use diesel::query_builder::BuildQueryResult;
+use diesel::query_builder::sqlite::SqliteQueryBuilder;
 
-impl<'a> Insertable<users::table, Sqlite> for &'a NewUser {
-    type Columns = users::name;
-    type Values = Grouped<AsExpr<&'a String, users::name>>;
+// It doesn't actually matter if this would work. We're testing that insert fails
+// to compile here.
+pub struct MyValues;
+impl InsertValues<Sqlite> for MyValues {
+    fn column_names(&self, out: &mut SqliteQueryBuilder) -> BuildQueryResult {
+        Ok(())
+    }
 
-    fn columns() -> Self::Columns {
-        users::name
+    fn values_clause(&self, out: &mut SqliteQueryBuilder) -> BuildQueryResult {
+        Ok(())
     }
+}
+
+impl<'a> Insertable<users::table, Sqlite> for &'a NewUser {
+    type Values = MyValues;
 
     fn values(self) -> Self::Values {
-        Grouped(<&'a String as AsExpression<VarChar>>::as_expression(&self.0))
+        MyValues
     }
 }
 
diff --git a/diesel_tests/tests/insert.rs b/diesel_tests/tests/insert.rs
index 25ee24c99..c97441fcc 100644
--- a/diesel_tests/tests/insert.rs
+++ b/diesel_tests/tests/insert.rs
@@ -87,7 +87,6 @@ fn insert_with_defaults() {
 }
 
 #[test]
-#[should_panic] // FIXME: SQLite has no DEFAULT keyword. We need to work around this.
 #[cfg(feature = "sqlite")] // FIXME: This test should run on everything, the only difference is create table syntax.
 fn insert_with_defaults() {
     use schema::users::table as users;
