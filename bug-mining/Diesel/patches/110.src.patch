diff --git a/CHANGELOG.md b/CHANGELOG.md
index c3cb9f78c..514488f9c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -43,6 +43,9 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * Trait bounds along the lines of `T: LoadDsl<Conn>, U: Queryable<T::SqlType,
   Conn::Backend>` should be changed to `T: LoadQuery<Conn, U>`.
 
+* Diesel now uses a migration to set up its timestamp helpers. To generate this
+  migration for your project, run `diesel database setup`.
+
 ### Removed
 
 * `#[has_many]` has been removed. Its functionality is now provided by
diff --git a/diesel/src/connection/mod.rs b/diesel/src/connection/mod.rs
index fe8e47ace..bde91f721 100644
--- a/diesel/src/connection/mod.rs
+++ b/diesel/src/connection/mod.rs
@@ -148,5 +148,4 @@ pub trait Connection: SimpleConnection + Sized + Send {
 
     #[doc(hidden)] fn silence_notices<F: FnOnce() -> T, T>(&self, f: F) -> T;
     #[doc(hidden)] fn transaction_manager(&self) -> &Self::TransactionManager;
-    #[doc(hidden)] fn setup_helper_functions(&self);
 }
diff --git a/diesel/src/migrations/mod.rs b/diesel/src/migrations/mod.rs
index f84019bf5..7ea87ddad 100644
--- a/diesel/src/migrations/mod.rs
+++ b/diesel/src/migrations/mod.rs
@@ -203,7 +203,6 @@ fn migration_with_version(migrations_dir: &Path, ver: &str) -> Result<Box<Migrat
 
 #[doc(hidden)]
 pub fn setup_database<Conn: Connection>(conn: &Conn) -> QueryResult<usize> {
-    conn.setup_helper_functions();
     create_schema_migrations_table_if_needed(conn)
 }
 
diff --git a/diesel/src/mysql/connection/mod.rs b/diesel/src/mysql/connection/mod.rs
index 5c1700329..058129901 100644
--- a/diesel/src/mysql/connection/mod.rs
+++ b/diesel/src/mysql/connection/mod.rs
@@ -97,11 +97,6 @@ impl Connection for MysqlConnection {
     fn transaction_manager(&self) -> &Self::TransactionManager {
         &self.transaction_manager
     }
-
-    #[doc(hidden)]
-    fn setup_helper_functions(&self) {
-        // FIXME: We can implement this pretty easily
-    }
 }
 
 impl MysqlConnection {
diff --git a/diesel/src/pg/connection/mod.rs b/diesel/src/pg/connection/mod.rs
index f172938ef..1e6778cfa 100644
--- a/diesel/src/pg/connection/mod.rs
+++ b/diesel/src/pg/connection/mod.rs
@@ -95,13 +95,6 @@ impl Connection for PgConnection {
     fn transaction_manager(&self) -> &Self::TransactionManager {
         &self.transaction_manager
     }
-
-    #[doc(hidden)]
-    fn setup_helper_functions(&self) {
-        self.batch_execute(
-            include_str!("setup/timestamp_helpers.sql")
-        ).expect("Error creating timestamp helper functions for Pg");
-    }
 }
 
 impl PgConnection {
diff --git a/diesel/src/pg/connection/setup/timestamp_helpers.sql b/diesel/src/pg/connection/setup/timestamp_helpers.sql
deleted file mode 100644
index 9babb7c4c..000000000
--- a/diesel/src/pg/connection/setup/timestamp_helpers.sql
+++ /dev/null
@@ -1,18 +0,0 @@
-CREATE OR REPLACE FUNCTION diesel_set_updated_at() RETURNS trigger AS $$
-BEGIN
-    IF (
-        NEW IS DISTINCT FROM OLD AND
-        NEW.updated_at IS NOT DISTINCT FROM OLD.updated_at
-    ) THEN
-        NEW.updated_at := current_timestamp;
-    END IF;
-    RETURN NEW;
-END;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION diesel_manage_updated_at(_tbl regclass) RETURNS VOID AS $$
-BEGIN
-    EXECUTE format('CREATE TRIGGER set_updated_at BEFORE UPDATE ON %s
-                    FOR EACH ROW EXECUTE PROCEDURE diesel_set_updated_at()', _tbl);
-END;
-$$ LANGUAGE plpgsql;
diff --git a/diesel/src/sqlite/connection/mod.rs b/diesel/src/sqlite/connection/mod.rs
index e92893802..8d7fcbcea 100644
--- a/diesel/src/sqlite/connection/mod.rs
+++ b/diesel/src/sqlite/connection/mod.rs
@@ -92,11 +92,6 @@ impl Connection for SqliteConnection {
     fn transaction_manager(&self) -> &Self::TransactionManager {
         &self.transaction_manager
     }
-
-    #[doc(hidden)]
-    fn setup_helper_functions(&self) {
-        // this will be implemented at least when timestamps are supported in SQLite
-    }
 }
 
 impl SqliteConnection {
diff --git a/diesel_cli/src/database.rs b/diesel_cli/src/database.rs
index 64e880b4c..a4cd1778c 100644
--- a/diesel_cli/src/database.rs
+++ b/diesel_cli/src/database.rs
@@ -18,6 +18,10 @@ use std::error::Error;
 use std::env;
 use std::io::stdout;
 use std::path::Path;
+#[cfg(feature="postgres")]
+use std::fs::{self, File};
+#[cfg(feature="postgres")]
+use std::io::Write;
 
 enum Backend {
     #[cfg(feature="postgres")]
@@ -116,8 +120,10 @@ pub fn reset_database(args: &ArgMatches, migrations_dir: &Path) -> DatabaseResul
 pub fn setup_database(args: &ArgMatches, migrations_dir: &Path) -> DatabaseResult<()> {
     let database_url = database_url(args);
 
-    try!(create_database_if_needed(&database_url));
-    create_schema_table_and_run_migrations_if_needed(&database_url, migrations_dir)
+    create_database_if_needed(&database_url)?;
+    create_default_migration_if_needed(&database_url, migrations_dir)?;
+    create_schema_table_and_run_migrations_if_needed(&database_url, migrations_dir)?;
+    Ok(())
 }
 
 pub fn drop_database_command(args: &ArgMatches) -> DatabaseResult<()> {
@@ -158,6 +164,30 @@ fn create_database_if_needed(database_url: &str) -> DatabaseResult<()> {
     Ok(())
 }
 
+fn create_default_migration_if_needed(database_url: &str, migrations_dir: &Path)
+    -> DatabaseResult<()>
+{
+    let initial_migration_path = migrations_dir.join("00000000000000_diesel_initial_setup");
+    if initial_migration_path.exists() {
+        return Ok(())
+    }
+
+    #[allow(unreachable_patterns)]
+    match Backend::for_url(database_url) {
+        #[cfg(feature="postgres")]
+        Backend::Pg => {
+            fs::create_dir_all(&initial_migration_path)?;
+            let mut up_sql = File::create(initial_migration_path.join("up.sql"))?;
+            up_sql.write_all(include_bytes!("setup_sql/postgres/initial_setup/up.sql"))?;
+            let mut down_sql = File::create(initial_migration_path.join("down.sql"))?;
+            down_sql.write_all(include_bytes!("setup_sql/postgres/initial_setup/down.sql"))?;
+        }
+        _ => {} // No default migration for this backend
+    }
+
+    Ok(())
+}
+
 /// Creates the `__diesel_schema_migrations` table if it doesn't exist. If the
 /// table didn't exist, it also runs any pending migrations. Returns a
 /// `DatabaseError::ConnectionError` if it can't create the table, and exits
diff --git a/diesel_cli/src/setup_sql/postgres/initial_setup/down.sql b/diesel_cli/src/setup_sql/postgres/initial_setup/down.sql
new file mode 100644
index 000000000..8fb31a8e5
--- /dev/null
+++ b/diesel_cli/src/setup_sql/postgres/initial_setup/down.sql
@@ -0,0 +1,2 @@
+DROP FUNCTION IF EXISTS diesel_manage_updated_at(_tbl regclass);
+DROP FUNCTION IF EXISTS diesel_set_updated_at();
diff --git a/diesel_cli/src/setup_sql/postgres/initial_setup/up.sql b/diesel_cli/src/setup_sql/postgres/initial_setup/up.sql
new file mode 100644
index 000000000..d68895b1a
--- /dev/null
+++ b/diesel_cli/src/setup_sql/postgres/initial_setup/up.sql
@@ -0,0 +1,36 @@
+-- This file was automatically created by Diesel to setup helper functions
+-- and other internal bookkeeping. This file is safe to edit, any future
+-- changes will be added to existing projects as new migrations.
+
+
+
+
+-- Sets up a trigger for the given table to automatically set a column called
+-- `updated_at` whenever the row is modified (unless `updated_at` was included
+-- in the modified columns)
+--
+-- # Example
+--
+-- ```sql
+-- CREATE TABLE users (id SERIAL PRIMARY KEY, updated_at TIMESTAMP NOT NULL DEFAULT NOW());
+--
+-- SELECT diesel_manage_updated_at('users');
+-- ```
+CREATE OR REPLACE FUNCTION diesel_manage_updated_at(_tbl regclass) RETURNS VOID AS $$
+BEGIN
+    EXECUTE format('CREATE TRIGGER set_updated_at BEFORE UPDATE ON %s
+                    FOR EACH ROW EXECUTE PROCEDURE diesel_set_updated_at()', _tbl);
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE FUNCTION diesel_set_updated_at() RETURNS trigger AS $$
+BEGIN
+    IF (
+        NEW IS DISTINCT FROM OLD AND
+        NEW.updated_at IS NOT DISTINCT FROM OLD.updated_at
+    ) THEN
+        NEW.updated_at := current_timestamp;
+    END IF;
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
diff --git a/diesel_cli/tests/migration_run.rs b/diesel_cli/tests/migration_run.rs
index df2bcb335..289471747 100644
--- a/diesel_cli/tests/migration_run.rs
+++ b/diesel_cli/tests/migration_run.rs
@@ -44,7 +44,7 @@ fn migration_run_inserts_run_on_timestamps() {
                        "DROP TABLE users");
 
     let migrations_done: bool = select(sql::<Bool>(
-            "EXISTS (SELECT * FROM __diesel_schema_migrations)"))
+            "EXISTS (SELECT * FROM __diesel_schema_migrations WHERE version >= '1')"))
         .get_result(&db.conn())
         .unwrap();
     assert!(!migrations_done, "Migrations table should be empty");
diff --git a/diesel_cli/tests/setup.rs b/diesel_cli/tests/setup.rs
index 628378ce6..c6fbe9824 100644
--- a/diesel_cli/tests/setup.rs
+++ b/diesel_cli/tests/setup.rs
@@ -1,3 +1,6 @@
+#[cfg(feature="postgres")]
+use std::path::Path;
+
 use support::{database, project};
 
 #[test]
@@ -27,6 +30,33 @@ fn setup_creates_migrations_directory() {
     assert!(p.has_file("migrations"));
 }
 
+#[test]
+#[cfg(feature="postgres")]
+fn setup_creates_default_migration_file() {
+    let p = project("setup_creates_default_migration_file").build();
+
+    let result = p.command("setup").run();
+
+    assert!(result.is_success(), "Result was unsuccessful {:?}", result);
+    assert!(p.has_file(Path::new("migrations").join("00000000000000_diesel_initial_setup")));
+}
+
+#[test]
+#[cfg(feature="postgres")]
+fn setup_creates_default_migration_file_if_project_is_otherwise_setup() {
+    let p = project("setup_creates_default_migration_file_if_project_is_otherwise_setup").build();
+
+    let initial_migration_path = Path::new("migrations").join("00000000000000_diesel_initial_setup");
+    let result = p.command("setup").run();
+    assert!(result.is_success(), "Result was unsuccessful {:?}", result);
+
+    p.delete_file(&initial_migration_path);
+    let result = p.command("setup").run();
+
+    assert!(result.is_success(), "Result was unsuccessful {:?}", result);
+    assert!(p.has_file(&initial_migration_path));
+}
+
 #[test]
 fn setup_creates_schema_table() {
     let p = project("setup_creates_schema_table").build();
diff --git a/diesel_cli/tests/support/project_builder.rs b/diesel_cli/tests/support/project_builder.rs
index 22b6ff16a..eba70c4c5 100644
--- a/diesel_cli/tests/support/project_builder.rs
+++ b/diesel_cli/tests/support/project_builder.rs
@@ -106,10 +106,16 @@ impl Project {
             .into_string().unwrap()
     }
 
-    pub fn has_file(&self, path: &str) -> bool {
+    pub fn has_file<P: AsRef<Path>>(&self, path: P) -> bool {
         self.directory.path().join(path).exists()
     }
 
+    #[cfg(feature="postgres")]
+    pub fn delete_file<P: AsRef<Path>>(&self, path: P) {
+        let file = self.directory.path().join(path);
+        fs::remove_dir_all(file).unwrap();
+    }
+
     pub fn create_migration(&self, name: &str, up: &str, down: &str) {
         self.create_migration_in_directory("migrations", name, up, down);
     }
diff --git a/migrations/postgresql/00000000000000_diesel_initial_setup/down.sql b/migrations/postgresql/00000000000000_diesel_initial_setup/down.sql
new file mode 100644
index 000000000..8fb31a8e5
--- /dev/null
+++ b/migrations/postgresql/00000000000000_diesel_initial_setup/down.sql
@@ -0,0 +1,2 @@
+DROP FUNCTION IF EXISTS diesel_manage_updated_at(_tbl regclass);
+DROP FUNCTION IF EXISTS diesel_set_updated_at();
diff --git a/migrations/postgresql/00000000000000_diesel_initial_setup/up.sql b/migrations/postgresql/00000000000000_diesel_initial_setup/up.sql
new file mode 100644
index 000000000..d68895b1a
--- /dev/null
+++ b/migrations/postgresql/00000000000000_diesel_initial_setup/up.sql
@@ -0,0 +1,36 @@
+-- This file was automatically created by Diesel to setup helper functions
+-- and other internal bookkeeping. This file is safe to edit, any future
+-- changes will be added to existing projects as new migrations.
+
+
+
+
+-- Sets up a trigger for the given table to automatically set a column called
+-- `updated_at` whenever the row is modified (unless `updated_at` was included
+-- in the modified columns)
+--
+-- # Example
+--
+-- ```sql
+-- CREATE TABLE users (id SERIAL PRIMARY KEY, updated_at TIMESTAMP NOT NULL DEFAULT NOW());
+--
+-- SELECT diesel_manage_updated_at('users');
+-- ```
+CREATE OR REPLACE FUNCTION diesel_manage_updated_at(_tbl regclass) RETURNS VOID AS $$
+BEGIN
+    EXECUTE format('CREATE TRIGGER set_updated_at BEFORE UPDATE ON %s
+                    FOR EACH ROW EXECUTE PROCEDURE diesel_set_updated_at()', _tbl);
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE FUNCTION diesel_set_updated_at() RETURNS trigger AS $$
+BEGIN
+    IF (
+        NEW IS DISTINCT FROM OLD AND
+        NEW.updated_at IS NOT DISTINCT FROM OLD.updated_at
+    ) THEN
+        NEW.updated_at := current_timestamp;
+    END IF;
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
