diff --git a/diesel/src/query_dsl/mod.rs b/diesel/src/query_dsl/mod.rs
index 202870b82..9202c5423 100644
--- a/diesel/src/query_dsl/mod.rs
+++ b/diesel/src/query_dsl/mod.rs
@@ -8,6 +8,7 @@ pub mod load_dsl;
 pub mod select_dsl;
 #[doc(hidden)]
 pub mod filter_dsl;
+mod save_changes_dsl;
 mod offset_dsl;
 mod order_dsl;
 mod with_dsl;
@@ -19,5 +20,6 @@ pub use self::limit_dsl::LimitDsl;
 pub use self::load_dsl::{LoadDsl, ExecuteDsl};
 pub use self::offset_dsl::OffsetDsl;
 pub use self::order_dsl::OrderDsl;
+pub use self::save_changes_dsl::SaveChangesDsl;
 pub use self::select_dsl::{SelectDsl, SelectSqlDsl};
 pub use self::with_dsl::{WithDsl, WithQuerySource};
diff --git a/diesel/src/query_dsl/save_changes_dsl.rs b/diesel/src/query_dsl/save_changes_dsl.rs
new file mode 100644
index 000000000..5613f7669
--- /dev/null
+++ b/diesel/src/query_dsl/save_changes_dsl.rs
@@ -0,0 +1,12 @@
+use connection::Connection;
+use query_source::Queryable;
+use result::QueryResult;
+use types::HasSqlType;
+
+pub trait SaveChangesDsl<Conn, ST> where
+    Conn: Connection,
+    Conn::Backend: HasSqlType<ST>,
+{
+    fn save_changes<T>(&self, connection: &Conn) -> QueryResult<T> where
+        T: Queryable<ST, Conn::Backend>;
+}
diff --git a/diesel/src/sqlite/types/mod.rs b/diesel/src/sqlite/types/mod.rs
index 67297032f..b5f2b12e0 100644
--- a/diesel/src/sqlite/types/mod.rs
+++ b/diesel/src/sqlite/types/mod.rs
@@ -1,10 +1,11 @@
 mod date_and_time;
 
+use std::io::prelude::*;
 use std::error::Error;
 
 use super::Sqlite;
 use super::connection::SqliteValue;
-use types::{self, FromSql};
+use types::{self, FromSql, ToSql, IsNull};
 
 impl FromSql<types::VarChar, Sqlite> for String {
     fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error>> {
@@ -55,3 +56,14 @@ impl FromSql<types::Double, Sqlite> for f64 {
         Ok(not_none!(value).read_double())
     }
 }
+
+impl ToSql<types::Bool, Sqlite> for bool {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+        let int_value = if *self {
+            1
+        } else {
+            0
+        };
+        <i32 as ToSql<types::Integer, Sqlite>>::to_sql(&int_value, out)
+    }
+}
diff --git a/diesel_codegen/Cargo.toml b/diesel_codegen/Cargo.toml
index 490aa4a74..600843b43 100644
--- a/diesel_codegen/Cargo.toml
+++ b/diesel_codegen/Cargo.toml
@@ -24,6 +24,7 @@ default = ["with-syntex", "postgres"]
 nightly = []
 with-syntex = ["syntex", "syntex_syntax"]
 postgres = ["diesel/postgres"]
+sqlite = ["diesel/sqlite"]
 
 [lib]
 name = "diesel_codegen"
diff --git a/diesel_codegen/src/update.rs b/diesel_codegen/src/update.rs
index 08dd6849a..4fa922c37 100644
--- a/diesel_codegen/src/update.rs
+++ b/diesel_codegen/src/update.rs
@@ -20,7 +20,8 @@ pub fn expand_changeset_for(
     if let Some(model) = Model::from_annotable(cx, span, annotatable) {
         let options = changeset_options(cx, meta_item).unwrap();
         push(Annotatable::Item(changeset_impl(cx, span, &options, &model).unwrap()));
-        if let Some(item) = save_changes_impl(cx, span, &options, &model) {
+        let items = save_changes_impl(cx, span, &options, &model);
+        for item in items.into_iter().filter_map(|x| x) {
             push(Annotatable::Item(item));
         }
     } else {
@@ -31,7 +32,6 @@ pub fn expand_changeset_for(
 
 struct ChangesetOptions {
     table_name: ast::Ident,
-    skip_visibility: bool,
     treat_none_as_null: bool,
 }
 
@@ -39,13 +39,10 @@ fn changeset_options(cx: &mut ExtCtxt, meta_item: &MetaItem) -> Result<Changeset
     match meta_item.node {
         ast::MetaList(_, ref meta_items) => {
             let table_name = try!(table_name(cx, &meta_items[0]));
-            let skip_visibility = try!(boolean_option(cx, &meta_items[1..], "__skip_visibility"))
-                .unwrap_or(false);
             let treat_none_as_null = try!(boolean_option(cx, &meta_items[1..], "treat_none_as_null"))
                 .unwrap_or(false);
             Ok(ChangesetOptions {
                 table_name: str_to_ident(&table_name),
-                skip_visibility: skip_visibility,
                 treat_none_as_null: treat_none_as_null,
             })
         }
@@ -124,40 +121,57 @@ fn save_changes_impl(
     span: Span,
     options: &ChangesetOptions,
     model: &Model,
-) -> Option<P<ast::Item>> {
+) -> Vec<Option<P<ast::Item>>> {
     let ref struct_name = model.ty;
     let pk = model.primary_key_name();
     let sql_type = cx.path(span, vec![options.table_name, str_to_ident("SqlType")]);
     let table = cx.path(span, vec![options.table_name, str_to_ident("table")]);
-    let _pub = if options.skip_visibility {
-        Vec::new()
-    } else {
-        quote_tokens!(cx, pub)
-    };
-    model.attrs.iter().find(|a| a.column_name == pk).and_then(|pk| {
+    let mut result = Vec::new();
+    if let Some(pk) = model.attrs.iter().find(|a| a.column_name == pk) {
         let pk_field = pk.field_name.unwrap();
-        quote_item!(cx,
-            impl<'a> $struct_name {
-                $_pub fn save_changes<'update, T, Conn>(&'update self, connection: &Conn)
-                    -> ::diesel::QueryResult<T> where
-                    Conn::Backend: ::diesel::types::HasSqlType<$sql_type> +
-                        ::diesel::backend::SupportsReturningClause +
-                        ::diesel::types::HasSqlType<
-                            <<$table as ::diesel::query_source::Table>::PrimaryKey
-                            as ::diesel::expression::Expression>::SqlType>,
-                    <&'update Self as ::diesel::query_builder::AsChangeset>::Changeset:
-                        ::diesel::query_builder::Changeset<Conn::Backend>,
-                    T: Queryable<$sql_type, Conn::Backend>,
-                    Conn: Connection,
-                {
-                    use ::diesel::update;
-                    update($table.filter($table.primary_key().eq(&self.$pk_field)))
-                        .set(self)
-                        .get_result(connection)
+        if cfg!(feature = "postgres") {
+            result.push(quote_item!(cx,
+                impl<'a> SaveChangesDsl<
+                    ::diesel::pg::PgConnection,
+                    $sql_type,
+                > for $struct_name {
+                    fn save_changes<T>(
+                        &self,
+                        connection: &::diesel::pg::PgConnection,
+                    ) -> ::diesel::QueryResult<T> where
+                        T: Queryable<$sql_type, ::diesel::pg::Pg>,
+                    {
+                        use ::diesel::update;
+                        update($table.filter($table.primary_key().eq(&self.$pk_field)))
+                            .set(self)
+                            .get_result(connection)
+                    }
                 }
-            }
-        )
-    })
+            ));
+        }
+        if cfg!(feature = "sqlite") {
+            result.push(quote_item!(cx,
+                impl<'a> SaveChangesDsl<
+                    ::diesel::sqlite::SqliteConnection,
+                    $sql_type,
+                > for $struct_name {
+                    fn save_changes<T>(
+                        &self,
+                        connection: &::diesel::sqlite::SqliteConnection,
+                    ) -> ::diesel::QueryResult<T> where
+                        T: Queryable<$sql_type, ::diesel::sqlite::Sqlite>,
+                    {
+                        use ::diesel::update;
+                        try!(update($table.filter($table.primary_key().eq(&self.$pk_field)))
+                            .set(self)
+                            .execute(connection));
+                        $table.find(&self.$pk_field).first(connection)
+                    }
+                }
+            ));
+        }
+    }
+    result
 }
 
 fn changeset_ty(
diff --git a/diesel_tests/Cargo.toml b/diesel_tests/Cargo.toml
index 107532ae2..d31836e08 100644
--- a/diesel_tests/Cargo.toml
+++ b/diesel_tests/Cargo.toml
@@ -26,7 +26,7 @@ default = ["syntex", "diesel_codegen/with-syntex", "dotenv_codegen"]
 unstable = ["diesel_codegen/nightly", "diesel/unstable",
   "quickcheck/unstable", "dotenv_macros"]
 postgres = ["diesel/postgres", "diesel_codegen/postgres"]
-sqlite = ["diesel/sqlite"]
+sqlite = ["diesel/sqlite", "diesel_codegen/sqlite"]
 
 [[test]]
 name = "integration_tests"
diff --git a/diesel_tests/tests/associations.rs b/diesel_tests/tests/associations.rs
index 1bf2a40b2..6916a726b 100644
--- a/diesel_tests/tests/associations.rs
+++ b/diesel_tests/tests/associations.rs
@@ -7,15 +7,15 @@ fn one_to_many_returns_query_source_for_association() {
 
     let sean = find_user_by_name("Sean", &connection);
     let tess = find_user_by_name("Tess", &connection);
-    let seans_posts: Vec<Post> =  insert(&vec![
-        sean.new_post("Hello", None), sean.new_post("World", None)
-        ]).into(posts::table)
-        .get_results(&connection)
+    let new_posts = vec![sean.new_post("Hello", None), sean.new_post("World", None)];
+    batch_insert(&new_posts, posts::table, &connection);
+    let new_posts = vec![tess.new_post("Hello 2", None), tess.new_post("World 2", None)];
+    batch_insert(&new_posts, posts::table, &connection);
+    let seans_posts = posts::table.filter(posts::user_id.eq(sean.id))
+        .load::<Post>(&connection)
         .unwrap();
-    let tess_posts: Vec<Post> = insert(&vec![
-        tess.new_post("Hello 2", None), tess.new_post("World 2", None),
-        ]).into(posts::table)
-        .get_results(&connection)
+    let tess_posts = posts::table.filter(posts::user_id.eq(tess.id))
+        .load::<Post>(&connection)
         .unwrap();
 
     let found_posts: Vec<_> = Post::belonging_to(&sean).load(&connection).unwrap();
diff --git a/diesel_tests/tests/filter.rs b/diesel_tests/tests/filter.rs
index e94426f15..312a47897 100644
--- a/diesel_tests/tests/filter.rs
+++ b/diesel_tests/tests/filter.rs
@@ -88,7 +88,6 @@ fn filter_by_is_null_on_nullable_columns() {
 }
 
 #[test]
-#[cfg(feature = "postgres")] // FIXME: There are valuable tests for SQLite here
 fn filter_after_joining() {
     use schema::users::name;
 
@@ -240,7 +239,6 @@ fn filter_with_or() {
 }
 
 #[test]
-#[cfg(feature = "postgres")] // FIXME: There are valuable tests for SQLite here
 fn or_doesnt_mess_with_precidence_of_previous_statements() {
     use schema::users::dsl::*;
     use diesel::expression::AsExpression;
@@ -262,9 +260,8 @@ use diesel::types::VarChar;
 sql_function!(lower, lower_t, (x: VarChar) -> VarChar);
 
 #[test]
-#[cfg(feature = "postgres")] // FIXME: There are valuable tests for SQLite here
 fn filter_by_boxed_predicate() {
-    fn by_name(name: &str) -> Box<BoxableExpression<users::table, types::Bool, pg::Pg, SqlType=types::Bool>> {
+    fn by_name(name: &str) -> Box<BoxableExpression<users::table, types::Bool, TestBackend, SqlType=types::Bool>> {
         Box::new(lower(users::name).eq(name.to_string()))
     }
 
diff --git a/diesel_tests/tests/lib.rs b/diesel_tests/tests/lib.rs
index a973a2d5d..3ba5a16b7 100644
--- a/diesel_tests/tests/lib.rs
+++ b/diesel_tests/tests/lib.rs
@@ -10,7 +10,6 @@ include!("lib.in.rs");
 #[cfg(not(feature = "unstable"))]
 include!(concat!(env!("OUT_DIR"), "/lib.rs"));
 
-#[cfg(feature = "postgres")] // FIXME: There are valuable tests for SQLite here
 mod associations;
 mod expressions;
 mod filter;
diff --git a/diesel_tests/tests/update.rs b/diesel_tests/tests/update.rs
index acc6b431f..6baaff543 100644
--- a/diesel_tests/tests/update.rs
+++ b/diesel_tests/tests/update.rs
@@ -85,7 +85,6 @@ fn update_returning_struct() {
 }
 
 #[test]
-#[cfg(not(feature="sqlite"))] // FIXME: This test is probably still valid without using RETURNING
 fn update_with_struct_as_changes() {
     use schema::users::dsl::*;
 
@@ -93,15 +92,15 @@ fn update_with_struct_as_changes() {
     let sean = find_user_by_name("Sean", &connection);
     let changes = NewUser::new("Jim", Some("blue"));
 
-    let user = update(users.filter(id.eq(sean.id))).set(&changes)
-        .get_result(&connection);
+    update(users.filter(id.eq(sean.id))).set(&changes)
+        .execute(&connection).unwrap();
+    let user = users.find(sean.id).first(&connection);
     let expected_user = User::with_hair_color(sean.id, "Jim", "blue");
 
     assert_eq!(Ok(expected_user), user);
 }
 
 #[test]
-#[cfg(not(feature="sqlite"))] // FIXME: This test is probably still valid without using RETURNING
 fn update_with_struct_does_not_set_primary_key() {
     use schema::users::dsl::*;
 
@@ -110,21 +109,21 @@ fn update_with_struct_does_not_set_primary_key() {
     let other_id = sean.id + 1;
     let changes = User::with_hair_color(other_id, "Jim", "blue");
 
-    let user = update(users.filter(id.eq(sean.id))).set(&changes)
-        .get_result(&connection);
+    update(users.filter(id.eq(sean.id))).set(&changes)
+        .execute(&connection).unwrap();
+    let user = users.find(sean.id).first(&connection);
     let expected_user = User::with_hair_color(sean.id, "Jim", "blue");
 
     assert_eq!(Ok(expected_user), user);
 }
 
 #[test]
-#[cfg(not(feature="sqlite"))] // FIXME: `save_changes` is still useful on SQLite, we need to support it
 fn save_on_struct_with_primary_key_changes_that_struct() {
     use schema::users::dsl::*;
 
     let connection = connection_with_sean_and_tess_in_users_table();
     let sean = find_user_by_name("Sean", &connection);
-    let user = User::with_hair_color(sean.id, "Jim", "blue").save_changes::<User, _>(&connection);
+    let user = User::with_hair_color(sean.id, "Jim", "blue").save_changes::<User>(&connection);
 
     let user_in_db = users.find(sean.id).first(&connection);
 
@@ -132,7 +131,6 @@ fn save_on_struct_with_primary_key_changes_that_struct() {
 }
 
 #[test]
-#[cfg(not(feature="sqlite"))] // FIXME: `save_changes` is still useful on SQLite, we need to support it
 fn option_fields_on_structs_are_not_assigned() {
     use schema::users::dsl::*;
 
@@ -148,7 +146,6 @@ fn option_fields_on_structs_are_not_assigned() {
 }
 
 #[test]
-#[cfg(not(feature="sqlite"))] // FIXME: This test is probably still valid without using RETURNING
 fn sql_syntax_is_correct_when_option_field_comes_before_non_option() {
     #[changeset_for(users)]
     struct Changes {
@@ -159,15 +156,15 @@ fn sql_syntax_is_correct_when_option_field_comes_before_non_option() {
     let changes = Changes { hair_color: None, name: "Jim".into() };
     let connection = connection_with_sean_and_tess_in_users_table();
     let sean = find_user_by_name("Sean", &connection);
-    let user = update(users::table.filter(users::id.eq(sean.id))).set(&changes)
-        .get_result(&connection);
+    update(users::table.filter(users::id.eq(sean.id))).set(&changes)
+        .execute(&connection).unwrap();
+    let user = users::table.find(sean.id).first(&connection);
 
     let expected_user = User::new(sean.id, "Jim");
     assert_eq!(Ok(expected_user), user);
 }
 
 #[test]
-#[cfg(not(feature="sqlite"))] // FIXME: This test is probably still valid without using RETURNING
 fn sql_syntax_is_correct_when_option_field_comes_mixed_with_non_option() {
     #[changeset_for(posts)]
     struct Changes {
@@ -182,17 +179,17 @@ fn sql_syntax_is_correct_when_option_field_comes_mixed_with_non_option() {
     insert(&new_post).into(posts::table).execute(&connection).unwrap();
 
     let changes = Changes { user_id: 1, title: None, body: "earth".into() };
-    let post = update(posts::table)
+    update(posts::table)
         .set(&changes)
-        .get_result::<Post>(&connection)
+        .execute(&connection)
         .unwrap();
+    let post = posts::table.order(posts::id.desc()).first::<Post>(&connection).unwrap();
 
     let expected_post = Post::new(post.id, sean.id, "Hello".into(), Some("earth".into()));
     assert_eq!(expected_post, post);
 }
 
 #[test]
-#[cfg(not(feature="sqlite"))] // FIXME: This test is probably still valid without using RETURNING
 fn can_update_with_struct_containing_single_field() {
     #[changeset_for(posts)]
     struct SetBody {
@@ -205,19 +202,19 @@ fn can_update_with_struct_containing_single_field() {
     insert(&new_post).into(posts::table).execute(&connection).unwrap();
 
     let changes = SetBody { body: "earth".into() };
-    let post = update(posts::table)
+    update(posts::table)
         .set(&changes)
-        .get_result::<Post>(&connection)
+        .execute(&connection)
         .unwrap();
+    let post = posts::table.order(posts::id.desc()).first::<Post>(&connection).unwrap();
 
     let expected_post = Post::new(post.id, sean.id, "Hello".into(), Some("earth".into()));
     assert_eq!(expected_post, post);
 }
 
 #[test]
-#[cfg(not(feature="sqlite"))] // FIXME: This test is probably still valid without using RETURNING
 fn struct_with_option_fields_treated_as_null() {
-    #[changeset_for(posts, treat_none_as_null="true", __skip_visibility="true")]
+    #[changeset_for(posts, treat_none_as_null="true")]
     struct UpdatePost {
         id: i32,
         title: String,
@@ -227,8 +224,9 @@ fn struct_with_option_fields_treated_as_null() {
     let connection = connection_with_sean_and_tess_in_users_table();
     let sean = find_user_by_name("Sean", &connection);
     let new_post = sean.new_post("Hello", Some("world"));
-    let post = insert(&new_post).into(posts::table)
-        .get_result::<Post>(&connection).unwrap();
+    insert(&new_post).into(posts::table)
+        .execute(&connection).unwrap();
+    let post = posts::table.order(posts::id.desc()).first::<Post>(&connection).unwrap();
 
     let changes = UpdatePost { id: post.id, title: "Hello again".into(), body: None };
     let expected_post = Post::new(post.id, sean.id, "Hello again".into(), None);
