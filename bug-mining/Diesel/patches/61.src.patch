diff --git a/CHANGELOG.md b/CHANGELOG.md
index 153cbabe6..507f5e3f4 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,6 +4,12 @@ All user visible changes to this project will be documented in this file.
 This project adheres to [Semantic Versioning](http://semver.org/), as described
 for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md)
 
+## Unreleased
+
+### Fixed
+
+* `#[derive(Identifiable)]` now works on structs with lifetimes
+
 ## [0.8.2] - 2016-11-22
 
 ### Added
diff --git a/diesel/src/macros/identifiable.rs b/diesel/src/macros/identifiable.rs
index 7eafa1af6..38755a42c 100644
--- a/diesel/src/macros/identifiable.rs
+++ b/diesel/src/macros/identifiable.rs
@@ -71,6 +71,7 @@ macro_rules! _Identifiable {
         (
             table_name = $table_name:ident,
             struct_ty = $struct_ty:ty,
+            lifetimes = ($($lifetimes:tt),*),
         ),
         fields = [{
             field_name: id,
@@ -80,7 +81,7 @@ macro_rules! _Identifiable {
             $($rest:tt)*
         } $($fields:tt)*],
     ) => {
-        impl $crate::associations::HasTable for $struct_ty {
+        impl<$($lifetimes),*> $crate::associations::HasTable for $struct_ty {
             type Table = $table_name::table;
 
             fn table() -> Self::Table {
@@ -88,8 +89,8 @@ macro_rules! _Identifiable {
             }
         }
 
-        impl<'a> $crate::associations::Identifiable for &'a $struct_ty {
-            type Id = &'a $field_ty;
+        impl<'ident $(,$lifetimes)*> $crate::associations::Identifiable for &'ident $struct_ty {
+            type Id = &'ident $field_ty;
 
             fn id(self) -> Self::Id {
                 &self.id
@@ -114,6 +115,23 @@ macro_rules! _Identifiable {
         }
     };
 
+    // Handle struct with generic lifetimes
+    (
+        ($($args:tt)*)
+        $struct_name:ident <$($lifetimes:tt),*>
+        $body:tt $(;)*
+    ) => {
+        __diesel_parse_struct_body! {
+            (
+                $($args)*
+                struct_ty = $struct_name<$($lifetimes),*>,
+                lifetimes = ($($lifetimes),*),
+            ),
+            callback = _Identifiable,
+            body = $body,
+        }
+    };
+
     // Handle struct with no generics
     (
         ($($args:tt)*)
@@ -124,6 +142,7 @@ macro_rules! _Identifiable {
             (
                 $($args)*
                 struct_ty = $struct_name,
+                lifetimes = (),
             ),
             callback = _Identifiable,
             body = $body,
@@ -217,3 +236,28 @@ fn derive_identifiable_on_struct_with_non_integer_pk() {
     assert_eq!(&"hi", foo1.id());
     assert_eq!(&"there", foo2.id());
 }
+
+#[test]
+fn derive_identifiable_on_struct_with_lifetime() {
+    use associations::Identifiable;
+
+    #[allow(missing_debug_implementations, missing_copy_implementations)]
+    struct Foo<'a> {
+        id: &'a str,
+        #[allow(dead_code)]
+        foo: i32,
+    }
+
+    Identifiable! {
+        #[table_name(bars)]
+        struct Foo<'a> {
+            id: &'a str,
+            foo: i32,
+        }
+    }
+
+    let foo1 = Foo { id: "hi", foo: 2 };
+    let foo2 = Foo { id: "there", foo: 3 };
+    assert_eq!(&"hi", foo1.id());
+    assert_eq!(&"there", foo2.id());
+}
diff --git a/diesel_codegen/src/identifiable.rs b/diesel_codegen/src/identifiable.rs
index 8d07c44d2..9aa00f38b 100644
--- a/diesel_codegen/src/identifiable.rs
+++ b/diesel_codegen/src/identifiable.rs
@@ -7,6 +7,7 @@ pub fn derive_identifiable(item: syn::MacroInput) -> Tokens {
     let model = t!(Model::from_item(&item, "Identifiable"));
     let table_name = model.table_name();
     let struct_ty = &model.ty;
+    let lifetimes = model.generics.lifetimes;
     let fields = model.attrs;
     if !fields.iter().any(|f| f.field_name == Some(syn::Ident::new("id"))) {
         panic!("Could not find a field named `id` on `{}`", &model.name);
@@ -16,6 +17,7 @@ pub fn derive_identifiable(item: syn::MacroInput) -> Tokens {
         (
             table_name = #table_name,
             struct_ty = #struct_ty,
+            lifetimes = (#(lifetimes),*),
         ),
         fields = [#(fields)*],
     })
diff --git a/diesel_codegen_syntex/src/identifiable.rs b/diesel_codegen_syntex/src/identifiable.rs
index ba9ca567a..83f3e2c8e 100644
--- a/diesel_codegen_syntex/src/identifiable.rs
+++ b/diesel_codegen_syntex/src/identifiable.rs
@@ -4,6 +4,7 @@ use syntax::ext::base::{Annotatable, ExtCtxt};
 use syntax::parse::token::str_to_ident;
 
 use model::Model;
+use util::lifetime_list_tokens;
 
 pub fn expand_derive_identifiable(
     cx: &mut ExtCtxt,
@@ -15,12 +16,14 @@ pub fn expand_derive_identifiable(
     if let Some(model) = Model::from_annotable(cx, span, annotatable) {
         let table_name = model.table_name();
         let struct_ty = &model.ty;
+        let lifetimes = lifetime_list_tokens(&model.generics.lifetimes, span);
         let fields = model.field_tokens_for_stable_macro(cx);
         if model.attr_named(str_to_ident("id")).is_some() {
             push(Annotatable::Item(quote_item!(cx, Identifiable! {
                 (
                     table_name = $table_name,
                     struct_ty = $struct_ty,
+                    lifetimes = ($lifetimes),
                 ),
                 fields = [$fields],
             }).unwrap()));
diff --git a/diesel_tests/tests/annotations.rs b/diesel_tests/tests/annotations.rs
index fb7b4fbd2..80bb24b86 100644
--- a/diesel_tests/tests/annotations.rs
+++ b/diesel_tests/tests/annotations.rs
@@ -162,3 +162,13 @@ mod custom_foreign_keys_are_respected_on_belongs_to {
         author_id: i32,
     }
 }
+
+mod derive_identifiable_with_lifetime {
+    #![allow(dead_code)]
+    use schema::posts;
+
+    #[derive(Identifiable)]
+    pub struct Post<'a> {
+        id: &'a i32
+    }
+}
