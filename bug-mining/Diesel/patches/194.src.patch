diff --git a/CHANGELOG.md b/CHANGELOG.md
index ba53656b8..2d8a60870 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -119,6 +119,9 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
   so non generic code does not require any change. For generic code you likely need to
   replace a trait bound on `Queryable<ST, DB>` with a trait bound on `FromSqlRow<ST, DB>`
   and a bound to `QueryableByName<DB>` with `FromSqlRow<Untyped, DB>`.
+  
+* Diesel's dsl now accept not nullable expressions in positions where nullable expressions 
+  are expected, without needing to call `.nullable()` explicitly
 
 
 ### Fixed
@@ -159,6 +162,8 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * We've refactored our type level representation of nullable values. This allowed us to
   fix multiple long standing bugs regarding the correct handling of nullable values in some
   corner cases (#104, #2274)
+  
+* Parenthesis are now inserted around all infix operations provided by diesel's `ExpressionMethods` traits
 
 ### Deprecated
 
diff --git a/diesel/src/expression/array_comparison.rs b/diesel/src/expression/array_comparison.rs
index ca90e3950..83a47ca41 100644
--- a/diesel/src/expression/array_comparison.rs
+++ b/diesel/src/expression/array_comparison.rs
@@ -108,7 +108,10 @@ where
     type InExpression = Many<T::Expression>;
 
     fn as_in_expression(self) -> Self::InExpression {
-        let expressions = self.into_iter().map(AsExpression::as_expression).collect();
+        let expressions = self
+            .into_iter()
+            .map(<T as AsExpression<ST>>::as_expression)
+            .collect();
         Many(expressions)
     }
 }
diff --git a/diesel/src/expression/count.rs b/diesel/src/expression/count.rs
index 6502340fc..a941b7cd7 100644
--- a/diesel/src/expression/count.rs
+++ b/diesel/src/expression/count.rs
@@ -3,7 +3,7 @@ use super::{Expression, ValidGrouping};
 use crate::backend::Backend;
 use crate::query_builder::*;
 use crate::result::QueryResult;
-use crate::sql_types::{BigInt, DieselNumericOps, SingleValue, SqlType};
+use crate::sql_types::{BigInt, DieselNumericOps, Nullable, SingleValue, SqlType};
 
 sql_function! {
     /// Creates a SQL `COUNT` expression
@@ -25,7 +25,7 @@ sql_function! {
     /// # }
     /// ```
     #[aggregate]
-    fn count<T: SqlType + SingleValue>(expr: T) -> BigInt;
+    fn count<T: SqlType + SingleValue>(expr: Nullable<T>) -> BigInt;
 }
 
 /// Creates a SQL `COUNT(*)` expression
diff --git a/diesel/src/expression/functions/aggregate_folding.rs b/diesel/src/expression/functions/aggregate_folding.rs
index b544c39f1..1896e21fe 100644
--- a/diesel/src/expression/functions/aggregate_folding.rs
+++ b/diesel/src/expression/functions/aggregate_folding.rs
@@ -1,5 +1,5 @@
 use crate::expression::functions::sql_function;
-use crate::sql_types::Foldable;
+use crate::sql_types::{Foldable, Nullable};
 
 sql_function! {
     /// Represents a SQL `SUM` function. This function can only take types which are
@@ -18,7 +18,7 @@ sql_function! {
     /// # }
     /// ```
     #[aggregate]
-    fn sum<ST: Foldable>(expr: ST) -> ST::Sum;
+    fn sum<ST: Foldable>(expr: Nullable<ST>) -> ST::Sum;
 }
 
 sql_function! {
@@ -64,5 +64,5 @@ sql_function! {
     /// #     Ok(())
     /// # }
     #[aggregate]
-    fn avg<ST: Foldable>(expr: ST) -> ST::Avg;
+    fn avg<ST: Foldable>(expr: Nullable<ST>) -> ST::Avg;
 }
diff --git a/diesel/src/expression/functions/aggregate_ordering.rs b/diesel/src/expression/functions/aggregate_ordering.rs
index bb2889590..4b398ce09 100644
--- a/diesel/src/expression/functions/aggregate_ordering.rs
+++ b/diesel/src/expression/functions/aggregate_ordering.rs
@@ -1,16 +1,16 @@
 use crate::expression::functions::sql_function;
-use crate::sql_types::{IntoNullable, SingleValue, SqlOrd, SqlType};
+use crate::sql_types::{IntoNullable, Nullable, SingleValue, SqlOrd, SqlType};
 
 pub trait SqlOrdAggregate: SingleValue {
     type Ret: SqlType + SingleValue;
 }
 
-impl<T> SqlOrdAggregate for T
+impl<ST> SqlOrdAggregate for ST
 where
-    T: SqlOrd + IntoNullable + SingleValue,
-    T::Nullable: SqlType + SingleValue,
+    ST: SqlOrd + SingleValue + IntoNullable,
+    ST::Nullable: SingleValue,
 {
-    type Ret = T::Nullable;
+    type Ret = <Self as IntoNullable>::Nullable;
 }
 
 sql_function! {
@@ -29,7 +29,7 @@ sql_function! {
     /// assert_eq!(Ok(Some(8)), animals.select(max(legs)).first(&connection));
     /// # }
     #[aggregate]
-    fn max<ST: SqlOrdAggregate>(expr: ST) -> ST::Ret;
+    fn max<ST: SqlOrdAggregate>(expr: Nullable<ST>) -> ST::Ret;
 }
 
 sql_function! {
@@ -48,5 +48,5 @@ sql_function! {
     /// assert_eq!(Ok(Some(4)), animals.select(min(legs)).first(&connection));
     /// # }
     #[aggregate]
-    fn min<ST: SqlOrdAggregate>(expr: ST) -> ST::Ret;
+    fn min<ST: SqlOrdAggregate>(expr: Nullable<ST>) -> ST::Ret;
 }
diff --git a/diesel/src/expression/functions/date_and_time.rs b/diesel/src/expression/functions/date_and_time.rs
index 51d44189a..d6cef53d2 100644
--- a/diesel/src/expression/functions/date_and_time.rs
+++ b/diesel/src/expression/functions/date_and_time.rs
@@ -1,7 +1,8 @@
 use crate::backend::Backend;
-use crate::expression::coerce::Coerce;
 use crate::expression::functions::sql_function;
-use crate::expression::{AsExpression, Expression, ValidGrouping};
+#[cfg(feature = "postgres")]
+use crate::expression::{coerce::Coerce, AsExpression};
+use crate::expression::{Expression, ValidGrouping};
 use crate::query_builder::*;
 use crate::result::QueryResult;
 use crate::sql_types::*;
@@ -46,14 +47,6 @@ sql_function! {
     fn date(expr: Timestamp) -> Date;
 }
 
-impl AsExpression<Nullable<Timestamp>> for now {
-    type Expression = Coerce<now, Nullable<Timestamp>>;
-
-    fn as_expression(self) -> Self::Expression {
-        Coerce::new(self)
-    }
-}
-
 #[cfg(feature = "postgres")]
 impl AsExpression<Timestamptz> for now {
     type Expression = Coerce<now, Timestamptz>;
@@ -92,11 +85,3 @@ impl_selectable_expression!(today);
 
 operator_allowed!(today, Add, add);
 operator_allowed!(today, Sub, sub);
-
-impl AsExpression<Nullable<Date>> for today {
-    type Expression = Coerce<today, Nullable<Date>>;
-
-    fn as_expression(self) -> Self::Expression {
-        Coerce::new(self)
-    }
-}
diff --git a/diesel/src/expression/functions/helper_types.rs b/diesel/src/expression/functions/helper_types.rs
index 07395a762..0ccf8e530 100644
--- a/diesel/src/expression/functions/helper_types.rs
+++ b/diesel/src/expression/functions/helper_types.rs
@@ -3,10 +3,10 @@
 use crate::dsl::{AsExprOf, SqlTypeOf};
 use crate::expression::grouped::Grouped;
 use crate::expression::operators;
-use crate::sql_types::Bool;
+use crate::sql_types::{Bool, Nullable};
 
 /// The return type of [`not(expr)`](../dsl/fn.not.html)
-pub type not<Expr> = operators::Not<Grouped<AsExprOf<Expr, Bool>>>;
+pub type not<Expr> = operators::Not<Grouped<AsExprOf<Expr, Nullable<Bool>>>>;
 
 /// The return type of [`max(expr)`](../dsl/fn.max.html)
 pub type max<Expr> = super::aggregate_ordering::max::HelperType<SqlTypeOf<Expr>, Expr>;
diff --git a/diesel/src/expression/helper_types.rs b/diesel/src/expression/helper_types.rs
index cb123edd2..3b3e8e557 100644
--- a/diesel/src/expression/helper_types.rs
+++ b/diesel/src/expression/helper_types.rs
@@ -17,56 +17,64 @@ pub type AsExprOf<Item, Type> = <Item as AsExpression<Type>>::Expression;
 
 /// The return type of
 /// [`lhs.eq(rhs)`](../expression_methods/trait.ExpressionMethods.html#method.eq)
-pub type Eq<Lhs, Rhs> = super::operators::Eq<Lhs, AsExpr<Rhs, Lhs>>;
+pub type Eq<Lhs, Rhs> = Grouped<super::operators::Eq<Lhs, AsExpr<Rhs, Lhs>>>;
 
 /// The return type of
 /// [`lhs.ne(rhs)`](../expression_methods/trait.ExpressionMethods.html#method.ne)
-pub type NotEq<Lhs, Rhs> = super::operators::NotEq<Lhs, AsExpr<Rhs, Lhs>>;
+pub type NotEq<Lhs, Rhs> = Grouped<super::operators::NotEq<Lhs, AsExpr<Rhs, Lhs>>>;
 
 /// The return type of
 /// [`lhs.eq_any(rhs)`](../expression_methods/trait.ExpressionMethods.html#method.eq_any)
-pub type EqAny<Lhs, Rhs> = In<Lhs, <Rhs as AsInExpression<SqlTypeOf<Lhs>>>::InExpression>;
+pub type EqAny<Lhs, Rhs> = Grouped<In<Lhs, <Rhs as AsInExpression<SqlTypeOf<Lhs>>>::InExpression>>;
 
 /// The return type of
 /// [`lhs.ne_any(rhs)`](../expression_methods/trait.ExpressionMethods.html#method.ne_any)
-pub type NeAny<Lhs, Rhs> = NotIn<Lhs, <Rhs as AsInExpression<SqlTypeOf<Lhs>>>::InExpression>;
+pub type NeAny<Lhs, Rhs> =
+    Grouped<NotIn<Lhs, <Rhs as AsInExpression<SqlTypeOf<Lhs>>>::InExpression>>;
 
 /// The return type of
 /// [`expr.is_null()`](../expression_methods/trait.ExpressionMethods.html#method.is_null)
-pub type IsNull<Expr> = super::operators::IsNull<Expr>;
+pub type IsNull<Expr> = Grouped<super::operators::IsNull<Expr>>;
 
 /// The return type of
 /// [`expr.is_not_null()`](../expression_methods/trait.ExpressionMethods.html#method.is_not_null)
-pub type IsNotNull<Expr> = super::operators::IsNotNull<Expr>;
+pub type IsNotNull<Expr> = Grouped<super::operators::IsNotNull<Expr>>;
 
 /// The return type of
 /// [`lhs.gt(rhs)`](../expression_methods/trait.ExpressionMethods.html#method.gt)
-pub type Gt<Lhs, Rhs> = super::operators::Gt<Lhs, AsExpr<Rhs, Lhs>>;
+pub type Gt<Lhs, Rhs> = Grouped<super::operators::Gt<Lhs, AsExpr<Rhs, Lhs>>>;
 
 /// The return type of
 /// [`lhs.ge(rhs)`](../expression_methods/trait.ExpressionMethods.html#method.ge)
-pub type GtEq<Lhs, Rhs> = super::operators::GtEq<Lhs, AsExpr<Rhs, Lhs>>;
+pub type GtEq<Lhs, Rhs> = Grouped<super::operators::GtEq<Lhs, AsExpr<Rhs, Lhs>>>;
 
 /// The return type of
 /// [`lhs.lt(rhs)`](../expression_methods/trait.ExpressionMethods.html#method.lt)
-pub type Lt<Lhs, Rhs> = super::operators::Lt<Lhs, AsExpr<Rhs, Lhs>>;
+pub type Lt<Lhs, Rhs> = Grouped<super::operators::Lt<Lhs, AsExpr<Rhs, Lhs>>>;
 
 /// The return type of
 /// [`lhs.le(rhs)`](../expression_methods/trait.ExpressionMethods.html#method.le)
-pub type LtEq<Lhs, Rhs> = super::operators::LtEq<Lhs, AsExpr<Rhs, Lhs>>;
+pub type LtEq<Lhs, Rhs> = Grouped<super::operators::LtEq<Lhs, AsExpr<Rhs, Lhs>>>;
 
 /// The return type of
 /// [`lhs.between(lower, upper)`](../expression_methods/trait.ExpressionMethods.html#method.between)
-pub type Between<Lhs, Lower, Upper> =
-    super::operators::Between<Lhs, super::operators::And<AsExpr<Lower, Lhs>, AsExpr<Upper, Lhs>>>;
+pub type Between<Lhs, Lower, Upper> = Grouped<
+    super::operators::Between<Lhs, super::operators::And<AsExpr<Lower, Lhs>, AsExpr<Upper, Lhs>>>,
+>;
 
 /// The return type of
 /// [`lhs.not_between(lower, upper)`](../expression_methods/trait.ExpressionMethods.html#method.not_between)
-pub type NotBetween<Lhs, Lower, Upper> = super::operators::NotBetween<
-    Lhs,
-    super::operators::And<AsExpr<Lower, Lhs>, AsExpr<Upper, Lhs>>,
+pub type NotBetween<Lhs, Lower, Upper> = Grouped<
+    super::operators::NotBetween<
+        Lhs,
+        super::operators::And<AsExpr<Lower, Lhs>, AsExpr<Upper, Lhs>>,
+    >,
 >;
 
+/// The return type of
+/// [`lhs.concat(rhs)`](../expression_methods/trait.TextExpressionMethods.html#method.concat)
+pub type Concat<Lhs, Rhs> = Grouped<super::operators::Concat<Lhs, AsExpr<Rhs, Lhs>>>;
+
 /// The return type of
 /// [`expr.desc()`](../expression_methods/trait.ExpressionMethods.html#method.desc)
 pub type Desc<Expr> = super::operators::Desc<Expr>;
@@ -81,23 +89,32 @@ pub type Nullable<Expr> = super::nullable::Nullable<Expr>;
 
 /// The return type of
 /// [`lhs.and(rhs)`](../expression_methods/trait.BoolExpressionMethods.html#method.and)
-pub type And<Lhs, Rhs> = super::operators::And<Lhs, AsExprOf<Rhs, sql_types::Bool>>;
+pub type And<Lhs, Rhs> = Grouped<super::operators::And<Nullable<Lhs>, AsExpr<Rhs, Nullable<Lhs>>>>;
 
 /// The return type of
 /// [`lhs.or(rhs)`](../expression_methods/trait.BoolExpressionMethods.html#method.or)
-pub type Or<Lhs, Rhs> = Grouped<super::operators::Or<Lhs, AsExprOf<Rhs, sql_types::Bool>>>;
+pub type Or<Lhs, Rhs> = Grouped<super::operators::Or<Lhs, AsExpr<Rhs, Nullable<Lhs>>>>;
 
 /// The return type of
 /// [`lhs.escape('x')`](../expression_methods/trait.EscapeExpressionMethods.html#method.escape)
-pub type Escape<Lhs> = super::operators::Escape<Lhs, AsExprOf<String, sql_types::VarChar>>;
+pub type Escape<Lhs> = Grouped<
+    super::operators::Escape<
+        <Lhs as crate::expression_methods::EscapeExpressionMethods>::TextExpression,
+        AsExprOf<String, sql_types::VarChar>,
+    >,
+>;
 
 /// The return type of
 /// [`lhs.like(rhs)`](../expression_methods/trait.TextExpressionMethods.html#method.like)
-pub type Like<Lhs, Rhs> = super::operators::Like<Lhs, AsExprOf<Rhs, sql_types::VarChar>>;
+pub type Like<Lhs, Rhs> = Grouped<super::operators::Like<Lhs, AsExprOf<Rhs, SqlTypeOf<Lhs>>>>;
 
 /// The return type of
 /// [`lhs.not_like(rhs)`](../expression_methods/trait.TextExpressionMethods.html#method.not_like)
-pub type NotLike<Lhs, Rhs> = super::operators::NotLike<Lhs, AsExprOf<Rhs, sql_types::VarChar>>;
+pub type NotLike<Lhs, Rhs> = Grouped<super::operators::NotLike<Lhs, AsExprOf<Rhs, SqlTypeOf<Lhs>>>>;
 
 #[doc(inline)]
 pub use super::functions::helper_types::*;
+
+#[doc(inline)]
+#[cfg(feature = "postgres")]
+pub use crate::pg::expression::helper_types::*;
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index 542c5d823..ba74fee81 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -82,7 +82,7 @@ pub use self::sql_literal::{SqlLiteral, UncheckedBind};
 
 use crate::backend::Backend;
 use crate::dsl::AsExprOf;
-use crate::sql_types::{HasSqlType, SingleValue, SqlType};
+use crate::sql_types::{HasSqlType, IntoNotNullable, SingleValue, SqlType};
 
 /// Represents a typed fragment of SQL.
 ///
@@ -208,14 +208,101 @@ pub use diesel_derives::AsExpression;
 
 impl<T, ST> AsExpression<ST> for T
 where
-    T: Expression<SqlType = ST>,
-    ST: SqlType + TypedExpressionType,
+    ST: SqlType + IntoNotNullable + TypedExpressionType,
+    ST::NotNullable: SingleValue,
+    self::as_expression_impl::ExpressionImplHelper<T, ST::IsNull, <T::SqlType as SqlType>::IsNull>:
+        self::as_expression_impl::AsExpressionHelper<ST>,
+    T: Expression,
+    T::SqlType: SqlType,
 {
-    type Expression = Self;
+    type Expression = <self::as_expression_impl::ExpressionImplHelper<
+        T,
+        ST::IsNull,
+        <T::SqlType as SqlType>::IsNull,
+    > as self::as_expression_impl::AsExpressionHelper<ST>>::Expression;
+
+    fn as_expression(self) -> Self::Expression {
+        use self::as_expression_impl::AsExpressionHelper;
+
+        let t = self::as_expression_impl::ExpressionImplHelper::<
+            _,
+            ST::IsNull,
+            <T::SqlType as SqlType>::IsNull,
+        >(self, std::marker::PhantomData);
+        t.as_expression()
+    }
+}
+
+mod as_expression_impl {
+    use super::*;
+    use crate::sql_types::is_nullable;
+
+    #[allow(missing_debug_implementations)]
+    pub struct ExpressionImplHelper<T, IsNullExpr, IsNullAsExpr>(
+        pub T,
+        pub std::marker::PhantomData<(IsNullExpr, IsNullAsExpr)>,
+    );
+
+    // We could use `AsExpression` here instead of defining a new trait in theory
+    // in practice we hit https://github.com/rust-lang/rust/issues/77446 then
+    // when defining a custom type in a third party crate
+    pub trait AsExpressionHelper<ST: TypedExpressionType> {
+        type Expression: Expression<SqlType = ST>;
+
+        fn as_expression(self) -> Self::Expression;
+    }
+
+    // This impl is for accepting a not nullable expression in a position where
+    // a not nullable expression is expected
+    impl<T, ST> AsExpressionHelper<ST>
+        for ExpressionImplHelper<T, is_nullable::NotNull, is_nullable::NotNull>
+    where
+        ST: SqlType<IsNull = is_nullable::NotNull> + TypedExpressionType,
+        T: Expression<SqlType = ST>,
+    {
+        type Expression = T;
+
+        fn as_expression(self) -> Self::Expression {
+            self.0
+        }
+    }
+
+    // This impl is for accepting a not nullable expression in a position where
+    // a nullable expression is expected
+    impl<T, ST> AsExpressionHelper<ST>
+        for ExpressionImplHelper<T, is_nullable::IsNullable, is_nullable::NotNull>
+    where
+        ST: SqlType<IsNull = is_nullable::IsNullable> + IntoNotNullable + TypedExpressionType,
+        ST::NotNullable: TypedExpressionType + SqlType,
+        T: Expression<SqlType = ST::NotNullable>,
+        super::nullable::Nullable<T>: Expression<SqlType = ST>,
+    {
+        type Expression = super::nullable::Nullable<T>;
 
-    fn as_expression(self) -> Self {
-        self
+        fn as_expression(self) -> Self::Expression {
+            super::nullable::Nullable::new(self.0)
+        }
     }
+
+    // This impl is for accepting a nullable expression in a position where
+    // a nullable expression is expected
+    impl<T, ST> AsExpressionHelper<ST>
+        for ExpressionImplHelper<T, is_nullable::IsNullable, is_nullable::IsNullable>
+    where
+        ST: SqlType<IsNull = is_nullable::IsNullable> + TypedExpressionType,
+        T: Expression<SqlType = ST>,
+    {
+        type Expression = T;
+
+        fn as_expression(self) -> Self::Expression {
+            self.0
+        }
+    }
+
+    // impl<T, ST> AsExpressionHelper<ST> for
+    //     ExpressionImplHelper<T, is_nullable::NotNull, is_nullable::IsNullable>
+    // is missing because we don't want to accept a nullable expression in possition where
+    // where a not nullable expression is expected
 }
 
 /// Converts a type to its representation for use in Diesel's query builder.
@@ -266,7 +353,7 @@ pub trait IntoSql {
         &'a Self: AsExpression<T>,
         T: SqlType + TypedExpressionType,
     {
-        self.as_expression()
+        <&'a Self as AsExpression<T>>::as_expression(self)
     }
 }
 
diff --git a/diesel/src/expression/not.rs b/diesel/src/expression/not.rs
index cd46aaeb2..96b7916c3 100644
--- a/diesel/src/expression/not.rs
+++ b/diesel/src/expression/not.rs
@@ -1,7 +1,7 @@
 use crate::expression::grouped::Grouped;
 use crate::expression::AsExpression;
 use crate::helper_types::not;
-use crate::sql_types::Bool;
+use crate::sql_types::{Bool, Nullable};
 
 /// Creates a SQL `NOT` expression
 ///
@@ -23,6 +23,9 @@ use crate::sql_types::Bool;
 /// assert_eq!(Ok(2), users_not_with_name.first(&connection));
 /// # }
 /// ```
-pub fn not<T: AsExpression<Bool>>(expr: T) -> not<T> {
+pub fn not<T>(expr: T) -> not<T>
+where
+    T: AsExpression<Nullable<Bool>>,
+{
     super::operators::Not::new(Grouped(expr.as_expression()))
 }
diff --git a/diesel/src/expression/nullable.rs b/diesel/src/expression/nullable.rs
index 13a5bc268..ee4b23481 100644
--- a/diesel/src/expression/nullable.rs
+++ b/diesel/src/expression/nullable.rs
@@ -56,3 +56,5 @@ where
     T: SelectableExpression<QS::InnerJoin>,
 {
 }
+
+impl<T> SelectableExpression<()> for Nullable<T> where Self: AppearsOnTable<()> {}
diff --git a/diesel/src/expression/operators.rs b/diesel/src/expression/operators.rs
index 02e9d9481..aab5858fc 100644
--- a/diesel/src/expression/operators.rs
+++ b/diesel/src/expression/operators.rs
@@ -421,7 +421,6 @@ macro_rules! diesel_prefix_operator {
 }
 
 infix_operator!(And, " AND ");
-infix_operator!(Between, " BETWEEN ");
 infix_operator!(Escape, " ESCAPE ");
 infix_operator!(Eq, " = ");
 infix_operator!(Gt, " > ");
@@ -429,9 +428,10 @@ infix_operator!(GtEq, " >= ");
 infix_operator!(Like, " LIKE ");
 infix_operator!(Lt, " < ");
 infix_operator!(LtEq, " <= ");
-infix_operator!(NotBetween, " NOT BETWEEN ");
 infix_operator!(NotEq, " != ");
 infix_operator!(NotLike, " NOT LIKE ");
+infix_operator!(Between, " BETWEEN ");
+infix_operator!(NotBetween, " NOT BETWEEN ");
 
 postfix_operator!(IsNull, " IS NULL");
 postfix_operator!(IsNotNull, " IS NOT NULL");
@@ -446,11 +446,16 @@ postfix_operator!(
     crate::expression::expression_types::NotSelectable
 );
 
-prefix_operator!(Not, "NOT ");
+prefix_operator!(
+    Not,
+    " NOT ",
+    crate::sql_types::Nullable<crate::sql_types::Bool>
+);
 
+use crate::backend::Backend;
 use crate::expression::{TypedExpressionType, ValidGrouping};
 use crate::insertable::{ColumnInsertValue, Insertable};
-use crate::query_builder::{QueryId, ValuesClause};
+use crate::query_builder::{QueryFragment, QueryId, ValuesClause};
 use crate::query_source::Column;
 use crate::sql_types::{
     is_nullable, AllAreNullable, Bool, DieselNumericOps, MaybeNullableType, SqlType,
@@ -504,11 +509,11 @@ where
 
 impl_selectable_expression!(Concat<L, R>);
 
-impl<L, R, DB> crate::query_builder::QueryFragment<DB> for Concat<L, R>
+impl<L, R, DB> QueryFragment<DB> for Concat<L, R>
 where
-    L: crate::query_builder::QueryFragment<DB>,
-    R: crate::query_builder::QueryFragment<DB>,
-    DB: crate::backend::Backend,
+    L: QueryFragment<DB>,
+    R: QueryFragment<DB>,
+    DB: Backend,
 {
     fn walk_ast(
         &self,
diff --git a/diesel/src/expression_methods/bool_expression_methods.rs b/diesel/src/expression_methods/bool_expression_methods.rs
index 3125e321b..9db25db86 100644
--- a/diesel/src/expression_methods/bool_expression_methods.rs
+++ b/diesel/src/expression_methods/bool_expression_methods.rs
@@ -1,7 +1,8 @@
+use crate::dsl;
 use crate::expression::grouped::Grouped;
 use crate::expression::operators::{And, Or};
-use crate::expression::{AsExpression, Expression, TypedExpressionType};
-use crate::sql_types::{BoolOrNullableBool, SqlType};
+use crate::expression::{AsExpression, Expression};
+use crate::sql_types::{BoolOrNullableBool, IntoNullable, SingleValue, SqlType};
 
 /// Methods present on boolean expressions
 pub trait BoolExpressionMethods: Expression + Sized {
@@ -36,14 +37,17 @@ pub trait BoolExpressionMethods: Expression + Sized {
     /// assert_eq!(expected, data);
     /// #     Ok(())
     /// # }
-    fn and<T, ST>(self, other: T) -> And<Self, T::Expression>
+    fn and<T>(self, other: T) -> dsl::And<Self, T>
     where
-        Self::SqlType: SqlType,
-        ST: SqlType + TypedExpressionType,
-        T: AsExpression<ST>,
+        Self::SqlType: SqlType + IntoNullable,
+        <Self::SqlType as IntoNullable>::Nullable: SingleValue,
+        T: AsExpression<<Self::SqlType as IntoNullable>::Nullable>,
         And<Self, T::Expression>: Expression,
     {
-        And::new(self, other.as_expression())
+        Grouped(And::new(
+            crate::expression::nullable::Nullable::new(self),
+            other.as_expression(),
+        ))
     }
 
     /// Creates a SQL `OR` expression
@@ -83,11 +87,11 @@ pub trait BoolExpressionMethods: Expression + Sized {
     /// assert_eq!(expected, data);
     /// #     Ok(())
     /// # }
-    fn or<T, ST>(self, other: T) -> Grouped<Or<Self, T::Expression>>
+    fn or<T>(self, other: T) -> dsl::Or<Self, T>
     where
-        Self::SqlType: SqlType,
-        ST: SqlType + TypedExpressionType,
-        T: AsExpression<ST>,
+        Self::SqlType: SqlType + IntoNullable,
+        <Self::SqlType as IntoNullable>::Nullable: SingleValue,
+        T: AsExpression<<Self::SqlType as IntoNullable>::Nullable>,
         Or<Self, T::Expression>: Expression,
     {
         Grouped(Or::new(self, other.as_expression()))
diff --git a/diesel/src/expression_methods/eq_all.rs b/diesel/src/expression_methods/eq_all.rs
index c78df53df..9efce1faa 100644
--- a/diesel/src/expression_methods/eq_all.rs
+++ b/diesel/src/expression_methods/eq_all.rs
@@ -1,14 +1,16 @@
+use crate::expression::grouped::Grouped;
+use crate::expression::nullable::Nullable;
 use crate::expression::operators::And;
 use crate::expression::Expression;
 use crate::expression_methods::*;
-use crate::sql_types::Bool;
+use crate::sql_types::{self, Bool};
 
 /// This method is used by `FindDsl` to work with tuples. Because we cannot
 /// express this without specialization or overlapping impls, it is brute force
 /// implemented on columns in the `column!` macro.
 #[doc(hidden)]
 pub trait EqAll<Rhs> {
-    type Output: Expression<SqlType = Bool>;
+    type Output: Expression<SqlType = sql_types::Nullable<Bool>>;
 
     fn eq_all(self, rhs: Rhs) -> Self::Output;
 }
@@ -26,10 +28,10 @@ macro_rules! impl_eq_all {
             $Left1: EqAll<$Right1>,
             ($($Left,)+): EqAll<($($Right,)+)>,
         {
-            type Output = And<
-                <$Left1 as EqAll<$Right1>>::Output,
+            type Output = Grouped<And<
+                Nullable<<$Left1 as EqAll<$Right1>>::Output>,
                 <($($Left,)+) as EqAll<($($Right,)+)>>::Output,
-            >;
+            >>;
 
             fn eq_all(self, rhs: ($Right1, $($Right,)+)) -> Self::Output {
                 let ($Left1, $($Left,)+) = self;
diff --git a/diesel/src/expression_methods/escape_expression_methods.rs b/diesel/src/expression_methods/escape_expression_methods.rs
index d7914de54..e7525e0e9 100644
--- a/diesel/src/expression_methods/escape_expression_methods.rs
+++ b/diesel/src/expression_methods/escape_expression_methods.rs
@@ -1,4 +1,5 @@
-use crate::dsl::AsExprOf;
+use crate::dsl;
+use crate::expression::grouped::Grouped;
 use crate::expression::operators::{Escape, Like, NotLike};
 use crate::expression::IntoSql;
 use crate::sql_types::VarChar;
@@ -31,12 +32,31 @@ use crate::sql_types::VarChar;
 /// # }
 /// ```
 pub trait EscapeExpressionMethods: Sized {
+    #[doc(hidden)]
+    type TextExpression;
+
     /// See the trait documentation.
-    fn escape(self, character: char) -> Escape<Self, AsExprOf<String, VarChar>> {
-        Escape::new(self, character.to_string().into_sql::<VarChar>())
+    fn escape(self, _character: char) -> dsl::Escape<Self>;
+}
+
+impl<T, U> EscapeExpressionMethods for Grouped<Like<T, U>> {
+    type TextExpression = Like<T, U>;
+
+    fn escape(self, character: char) -> dsl::Escape<Self> {
+        Grouped(Escape::new(
+            self.0,
+            character.to_string().into_sql::<VarChar>(),
+        ))
     }
 }
 
-impl<T, U> EscapeExpressionMethods for Like<T, U> {}
+impl<T, U> EscapeExpressionMethods for Grouped<NotLike<T, U>> {
+    type TextExpression = NotLike<T, U>;
 
-impl<T, U> EscapeExpressionMethods for NotLike<T, U> {}
+    fn escape(self, character: char) -> dsl::Escape<Self> {
+        Grouped(Escape::new(
+            self.0,
+            character.to_string().into_sql::<VarChar>(),
+        ))
+    }
+}
diff --git a/diesel/src/expression_methods/global_expression_methods.rs b/diesel/src/expression_methods/global_expression_methods.rs
index c0d4f7c79..2831b91fb 100644
--- a/diesel/src/expression_methods/global_expression_methods.rs
+++ b/diesel/src/expression_methods/global_expression_methods.rs
@@ -1,4 +1,6 @@
+use crate::dsl;
 use crate::expression::array_comparison::{AsInExpression, In, NotIn};
+use crate::expression::grouped::Grouped;
 use crate::expression::operators::*;
 use crate::expression::{nullable, AsExpression, Expression};
 use crate::sql_types::{SingleValue, SqlType};
@@ -19,12 +21,12 @@ pub trait ExpressionMethods: Expression + Sized {
     /// assert_eq!(Ok(1), data.first(&connection));
     /// # }
     /// ```
-    fn eq<T>(self, other: T) -> Eq<Self, T::Expression>
+    fn eq<T>(self, other: T) -> dsl::Eq<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        Eq::new(self, other.as_expression())
+        Grouped(Eq::new(self, other.as_expression()))
     }
 
     /// Creates a SQL `!=` expression.
@@ -41,12 +43,12 @@ pub trait ExpressionMethods: Expression + Sized {
     /// assert_eq!(Ok(2), data.first(&connection));
     /// # }
     /// ```
-    fn ne<T>(self, other: T) -> NotEq<Self, T::Expression>
+    fn ne<T>(self, other: T) -> dsl::NotEq<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        NotEq::new(self, other.as_expression())
+        Grouped(NotEq::new(self, other.as_expression()))
     }
 
     /// Creates a SQL `IN` statement.
@@ -74,12 +76,12 @@ pub trait ExpressionMethods: Expression + Sized {
     /// assert_eq!(Ok(vec![]), data.load::<i32>(&connection));
     /// # }
     /// ```
-    fn eq_any<T>(self, values: T) -> In<Self, T::InExpression>
+    fn eq_any<T>(self, values: T) -> dsl::EqAny<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsInExpression<Self::SqlType>,
     {
-        In::new(self, values.as_in_expression())
+        Grouped(In::new(self, values.as_in_expression()))
     }
 
     /// Creates a SQL `NOT IN` statement.
@@ -110,12 +112,12 @@ pub trait ExpressionMethods: Expression + Sized {
     /// assert_eq!(Ok(vec![1, 2, 3]), data.load(&connection));
     /// # }
     /// ```
-    fn ne_all<T>(self, values: T) -> NotIn<Self, T::InExpression>
+    fn ne_all<T>(self, values: T) -> dsl::NeAny<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsInExpression<Self::SqlType>,
     {
-        NotIn::new(self, values.as_in_expression())
+        Grouped(NotIn::new(self, values.as_in_expression()))
     }
 
     /// Creates a SQL `IS NULL` expression.
@@ -140,8 +142,8 @@ pub trait ExpressionMethods: Expression + Sized {
     /// assert_eq!("spider", data);
     /// #     Ok(())
     /// # }
-    fn is_null(self) -> IsNull<Self> {
-        IsNull::new(self)
+    fn is_null(self) -> dsl::IsNull<Self> {
+        Grouped(IsNull::new(self))
     }
 
     /// Creates a SQL `IS NOT NULL` expression.
@@ -166,8 +168,8 @@ pub trait ExpressionMethods: Expression + Sized {
     /// assert_eq!("dog", data);
     /// #     Ok(())
     /// # }
-    fn is_not_null(self) -> IsNotNull<Self> {
-        IsNotNull::new(self)
+    fn is_not_null(self) -> dsl::IsNotNull<Self> {
+        Grouped(IsNotNull::new(self))
     }
 
     /// Creates a SQL `>` expression.
@@ -192,12 +194,12 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn gt<T>(self, other: T) -> Gt<Self, T::Expression>
+    fn gt<T>(self, other: T) -> dsl::Gt<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        Gt::new(self, other.as_expression())
+        Grouped(Gt::new(self, other.as_expression()))
     }
 
     /// Creates a SQL `>=` expression.
@@ -222,12 +224,12 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn ge<T>(self, other: T) -> GtEq<Self, T::Expression>
+    fn ge<T>(self, other: T) -> dsl::GtEq<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        GtEq::new(self, other.as_expression())
+        Grouped(GtEq::new(self, other.as_expression()))
     }
 
     /// Creates a SQL `<` expression.
@@ -252,12 +254,12 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn lt<T>(self, other: T) -> Lt<Self, T::Expression>
+    fn lt<T>(self, other: T) -> dsl::Lt<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        Lt::new(self, other.as_expression())
+        Grouped(Lt::new(self, other.as_expression()))
     }
 
     /// Creates a SQL `<=` expression.
@@ -281,12 +283,12 @@ pub trait ExpressionMethods: Expression + Sized {
     /// assert_eq!("Sean", data);
     /// #     Ok(())
     /// # }
-    fn le<T>(self, other: T) -> LtEq<Self, T::Expression>
+    fn le<T>(self, other: T) -> dsl::LtEq<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        LtEq::new(self, other.as_expression())
+        Grouped(LtEq::new(self, other.as_expression()))
     }
 
     /// Creates a SQL `BETWEEN` expression using the given lower and upper
@@ -309,13 +311,16 @@ pub trait ExpressionMethods: Expression + Sized {
     /// assert_eq!(Ok("dog".to_string()), data);
     /// # }
     /// ```
-    fn between<T, U>(self, lower: T, upper: U) -> Between<Self, And<T::Expression, U::Expression>>
+    fn between<T, U>(self, lower: T, upper: U) -> dsl::Between<Self, T, U>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
         U: AsExpression<Self::SqlType>,
     {
-        Between::new(self, And::new(lower.as_expression(), upper.as_expression()))
+        Grouped(Between::new(
+            self,
+            And::new(lower.as_expression(), upper.as_expression()),
+        ))
     }
 
     /// Creates a SQL `NOT BETWEEN` expression using the given lower and upper
@@ -341,17 +346,16 @@ pub trait ExpressionMethods: Expression + Sized {
     /// assert_eq!("spider", data);
     /// #     Ok(())
     /// # }
-    fn not_between<T, U>(
-        self,
-        lower: T,
-        upper: U,
-    ) -> NotBetween<Self, And<T::Expression, U::Expression>>
+    fn not_between<T, U>(self, lower: T, upper: U) -> dsl::NotBetween<Self, T, U>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
         U: AsExpression<Self::SqlType>,
     {
-        NotBetween::new(self, And::new(lower.as_expression(), upper.as_expression()))
+        Grouped(NotBetween::new(
+            self,
+            And::new(lower.as_expression(), upper.as_expression()),
+        ))
     }
 
     /// Creates a SQL `DESC` expression, representing this expression in
@@ -378,7 +382,7 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn desc(self) -> Desc<Self> {
+    fn desc(self) -> dsl::Desc<Self> {
         Desc::new(self)
     }
 
@@ -406,7 +410,7 @@ pub trait ExpressionMethods: Expression + Sized {
     ///     };
     /// # }
     /// ```
-    fn asc(self) -> Asc<Self> {
+    fn asc(self) -> dsl::Asc<Self> {
         Asc::new(self)
     }
 }
@@ -454,7 +458,7 @@ pub trait NullableExpressionMethods: Expression + Sized {
     ///     println!("{:?}", data);
     /// }
     /// ```
-    fn nullable(self) -> nullable::Nullable<Self> {
+    fn nullable(self) -> dsl::Nullable<Self> {
         nullable::Nullable::new(self)
     }
 }
diff --git a/diesel/src/expression_methods/text_expression_methods.rs b/diesel/src/expression_methods/text_expression_methods.rs
index 8527edc68..0e8170605 100644
--- a/diesel/src/expression_methods/text_expression_methods.rs
+++ b/diesel/src/expression_methods/text_expression_methods.rs
@@ -1,3 +1,5 @@
+use crate::dsl;
+use crate::expression::grouped::Grouped;
 use crate::expression::operators::{Concat, Like, NotLike};
 use crate::expression::{AsExpression, Expression};
 use crate::sql_types::{Nullable, SqlType, Text};
@@ -54,12 +56,12 @@ pub trait TextExpressionMethods: Expression + Sized {
     /// assert_eq!(Ok(expected_names), names);
     /// # }
     /// ```
-    fn concat<T>(self, other: T) -> Concat<Self, T::Expression>
+    fn concat<T>(self, other: T) -> dsl::Concat<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        Concat::new(self, other.as_expression())
+        Grouped(Concat::new(self, other.as_expression()))
     }
 
     /// Returns a SQL `LIKE` expression
@@ -90,12 +92,12 @@ pub trait TextExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn like<T>(self, other: T) -> Like<Self, T::Expression>
+    fn like<T>(self, other: T) -> dsl::Like<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        Like::new(self, other.as_expression())
+        Grouped(Like::new(self, other.as_expression()))
     }
 
     /// Returns a SQL `NOT LIKE` expression
@@ -126,12 +128,12 @@ pub trait TextExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn not_like<T>(self, other: T) -> NotLike<Self, T::Expression>
+    fn not_like<T>(self, other: T) -> dsl::NotLike<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        NotLike::new(self, other.as_expression())
+        Grouped(NotLike::new(self, other.as_expression()))
     }
 }
 
diff --git a/diesel/src/insertable.rs b/diesel/src/insertable.rs
index 305623448..f7fa3fa8f 100644
--- a/diesel/src/insertable.rs
+++ b/diesel/src/insertable.rs
@@ -1,6 +1,7 @@
 use std::marker::PhantomData;
 
 use crate::backend::{Backend, SupportsDefaultKeyword};
+use crate::expression::grouped::Grouped;
 use crate::expression::{AppearsOnTable, Expression};
 use crate::query_builder::{
     AstPass, InsertStatement, QueryFragment, UndecoratedInsertRecord, ValuesClause,
@@ -257,6 +258,28 @@ where
     }
 }
 
+impl<L, R, Tab> Insertable<Tab> for Grouped<crate::expression::operators::Eq<L, R>>
+where
+    crate::expression::operators::Eq<L, R>: Insertable<Tab>,
+{
+    type Values = <crate::expression::operators::Eq<L, R> as Insertable<Tab>>::Values;
+
+    fn values(self) -> Self::Values {
+        self.0.values()
+    }
+}
+
+impl<'a, L, R, Tab> Insertable<Tab> for &'a Grouped<crate::expression::operators::Eq<L, R>>
+where
+    &'a crate::expression::operators::Eq<L, R>: Insertable<Tab>,
+{
+    type Values = <&'a crate::expression::operators::Eq<L, R> as Insertable<Tab>>::Values;
+
+    fn values(self) -> Self::Values {
+        self.0.values()
+    }
+}
+
 #[derive(Debug, Clone, Copy)]
 pub struct BatchInsert<'a, T: 'a, Tab> {
     pub records: &'a [T],
diff --git a/diesel/src/macros/mod.rs b/diesel/src/macros/mod.rs
index 3a7e0424f..f2dca012d 100644
--- a/diesel/src/macros/mod.rs
+++ b/diesel/src/macros/mod.rs
@@ -101,12 +101,16 @@ macro_rules! __diesel_column {
 
         impl<T> $crate::EqAll<T> for $column_name where
             T: $crate::expression::AsExpression<$($Type)*>,
-            $crate::dsl::Eq<$column_name, T::Expression>: $crate::Expression<SqlType=$crate::sql_types::Bool>,
+            $crate::dsl::Nullable<$crate::dsl::Eq<$column_name, T::Expression>>:
+            $crate::Expression<SqlType = $crate::sql_types::Nullable<$crate::sql_types::Bool>>,
         {
-            type Output = $crate::dsl::Eq<Self, T::Expression>;
+            type Output = $crate::dsl::Nullable<$crate::dsl::Eq<Self, T::Expression>>;
 
             fn eq_all(self, rhs: T) -> Self::Output {
-                $crate::expression::operators::Eq::new(self, rhs.as_expression())
+                use $crate::expression_methods::ExpressionMethods;
+                use $crate::expression_methods::NullableExpressionMethods;
+
+                self.eq(rhs).nullable()
             }
         }
 
@@ -1157,7 +1161,7 @@ mod tests {
     fn table_with_column_renaming_postgres() {
         use crate::pg::Pg;
         let expected_sql =
-            r#"SELECT "foo"."id", "foo"."type", "foo"."bleh" FROM "foo" WHERE "foo"."type" = $1 -- binds: [1]"#;
+            r#"SELECT "foo"."id", "foo"."type", "foo"."bleh" FROM "foo" WHERE ("foo"."type" = $1) -- binds: [1]"#;
         assert_eq!(
             expected_sql,
             crate::debug_query::<Pg, _>(&foo::table.filter(foo::mytype.eq(1))).to_string()
@@ -1169,7 +1173,7 @@ mod tests {
     fn table_with_column_renaming_mysql() {
         use crate::mysql::Mysql;
         let expected_sql =
-            r#"SELECT `foo`.`id`, `foo`.`type`, `foo`.`bleh` FROM `foo` WHERE `foo`.`type` = ? -- binds: [1]"#;
+            r#"SELECT `foo`.`id`, `foo`.`type`, `foo`.`bleh` FROM `foo` WHERE (`foo`.`type` = ?) -- binds: [1]"#;
         assert_eq!(
             expected_sql,
             crate::debug_query::<Mysql, _>(&foo::table.filter(foo::mytype.eq(1))).to_string()
@@ -1181,7 +1185,7 @@ mod tests {
     fn table_with_column_renaming_sqlite() {
         use crate::sqlite::Sqlite;
         let expected_sql =
-            r#"SELECT `foo`.`id`, `foo`.`type`, `foo`.`bleh` FROM `foo` WHERE `foo`.`type` = ? -- binds: [1]"#;
+            r#"SELECT `foo`.`id`, `foo`.`type`, `foo`.`bleh` FROM `foo` WHERE (`foo`.`type` = ?) -- binds: [1]"#;
         assert_eq!(
             expected_sql,
             crate::debug_query::<Sqlite, _>(&foo::table.filter(foo::mytype.eq(1))).to_string()
diff --git a/diesel/src/pg/expression/array_comparison.rs b/diesel/src/pg/expression/array_comparison.rs
index 0dd1fc4cb..7c24847f2 100644
--- a/diesel/src/pg/expression/array_comparison.rs
+++ b/diesel/src/pg/expression/array_comparison.rs
@@ -141,7 +141,7 @@ where
     type Expression = <T as AsExpression<Array<ST>>>::Expression;
 
     fn as_expression(self) -> Self::Expression {
-        AsExpression::as_expression(self)
+        <T as AsExpression<Array<ST>>>::as_expression(self)
     }
 }
 
diff --git a/diesel/src/pg/expression/expression_methods.rs b/diesel/src/pg/expression/expression_methods.rs
index 9abf426f3..4f2e73fa4 100644
--- a/diesel/src/pg/expression/expression_methods.rs
+++ b/diesel/src/pg/expression/expression_methods.rs
@@ -1,7 +1,9 @@
 //! PostgreSQL specific expression methods
 
 use super::operators::*;
-use crate::expression::{AsExpression, Expression, TypedExpressionType};
+use crate::dsl;
+use crate::expression::grouped::Grouped;
+use crate::expression::{AsExpression, Expression, IntoSql, TypedExpressionType};
 use crate::sql_types::{Array, Nullable, Range, SqlType, Text};
 
 /// PostgreSQL specific methods which are present on all expressions.
@@ -25,12 +27,12 @@ pub trait PgExpressionMethods: Expression + Sized {
     /// assert_eq!(Ok(1), not_distinct.first(&connection));
     /// # }
     /// ```
-    fn is_not_distinct_from<T>(self, other: T) -> IsNotDistinctFrom<Self, T::Expression>
+    fn is_not_distinct_from<T>(self, other: T) -> dsl::IsNotDistinctFrom<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        IsNotDistinctFrom::new(self, other.as_expression())
+        Grouped(IsNotDistinctFrom::new(self, other.as_expression()))
     }
 
     /// Creates a PostgreSQL `IS DISTINCT FROM` expression.
@@ -52,12 +54,12 @@ pub trait PgExpressionMethods: Expression + Sized {
     /// assert_eq!(Ok(1), not_distinct.first(&connection));
     /// # }
     /// ```
-    fn is_distinct_from<T>(self, other: T) -> IsDistinctFrom<Self, T::Expression>
+    fn is_distinct_from<T>(self, other: T) -> dsl::IsDistinctFrom<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        IsDistinctFrom::new(self, other.as_expression())
+        Grouped(IsDistinctFrom::new(self, other.as_expression()))
     }
 }
 
@@ -124,11 +126,11 @@ pub trait PgTimestampExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn at_time_zone<T>(self, timezone: T) -> AtTimeZone<Self, T::Expression>
+    fn at_time_zone<T>(self, timezone: T) -> dsl::AtTimeZone<Self, T>
     where
         T: AsExpression<VarChar>,
     {
-        AtTimeZone::new(self, timezone.as_expression())
+        Grouped(AtTimeZone::new(self, timezone.as_expression()))
     }
 }
 
@@ -187,12 +189,12 @@ pub trait PgArrayExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn overlaps_with<T>(self, other: T) -> OverlapsWith<Self, T::Expression>
+    fn overlaps_with<T>(self, other: T) -> dsl::OverlapsWith<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        OverlapsWith::new(self, other.as_expression())
+        Grouped(OverlapsWith::new(self, other.as_expression()))
     }
 
     /// Creates a PostgreSQL `@>` expression.
@@ -237,12 +239,12 @@ pub trait PgArrayExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn contains<T>(self, other: T) -> Contains<Self, T::Expression>
+    fn contains<T>(self, other: T) -> dsl::ArrayContains<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        Contains::new(self, other.as_expression())
+        Grouped(Contains::new(self, other.as_expression()))
     }
 
     /// Creates a PostgreSQL `<@` expression.
@@ -288,12 +290,12 @@ pub trait PgArrayExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn is_contained_by<T>(self, other: T) -> IsContainedBy<Self, T::Expression>
+    fn is_contained_by<T>(self, other: T) -> dsl::IsContainedBy<Self, T>
     where
         Self::SqlType: SqlType,
         T: AsExpression<Self::SqlType>,
     {
-        IsContainedBy::new(self, other.as_expression())
+        Grouped(IsContainedBy::new(self, other.as_expression()))
     }
 }
 
@@ -366,7 +368,7 @@ pub trait PgSortExpressionMethods: Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn nulls_first(self) -> NullsFirst<Self> {
+    fn nulls_first(self) -> dsl::NullsFirst<Self> {
         NullsFirst::new(self)
     }
 
@@ -414,7 +416,7 @@ pub trait PgSortExpressionMethods: Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn nulls_last(self) -> NullsLast<Self> {
+    fn nulls_last(self) -> dsl::NullsLast<Self> {
         NullsLast::new(self)
     }
 }
@@ -446,11 +448,11 @@ pub trait PgTextExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn ilike<T>(self, other: T) -> ILike<Self, T::Expression>
+    fn ilike<T>(self, other: T) -> dsl::ILike<Self, T>
     where
         T: AsExpression<Text>,
     {
-        ILike::new(self, other.as_expression())
+        Grouped(ILike::new(self, other.as_expression()))
     }
 
     /// Creates a PostgreSQL `NOT ILIKE` expression
@@ -475,11 +477,11 @@ pub trait PgTextExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn not_ilike<T>(self, other: T) -> NotILike<Self, T::Expression>
+    fn not_ilike<T>(self, other: T) -> dsl::NotILike<Self, T>
     where
         T: AsExpression<Text>,
     {
-        NotILike::new(self, other.as_expression())
+        Grouped(NotILike::new(self, other.as_expression()))
     }
 }
 
@@ -499,8 +501,27 @@ where
 {
 }
 
-impl<T, U> EscapeExpressionMethods for ILike<T, U> {}
-impl<T, U> EscapeExpressionMethods for NotILike<T, U> {}
+impl<T, U> EscapeExpressionMethods for Grouped<ILike<T, U>> {
+    type TextExpression = ILike<T, U>;
+
+    fn escape(self, character: char) -> dsl::Escape<Self> {
+        Grouped(crate::expression::operators::Escape::new(
+            self.0,
+            character.to_string().into_sql::<VarChar>(),
+        ))
+    }
+}
+
+impl<T, U> EscapeExpressionMethods for Grouped<NotILike<T, U>> {
+    type TextExpression = NotILike<T, U>;
+
+    fn escape(self, character: char) -> dsl::Escape<Self> {
+        Grouped(crate::expression::operators::Escape::new(
+            self.0,
+            character.to_string().into_sql::<VarChar>(),
+        ))
+    }
+}
 
 #[doc(hidden)]
 /// Marker trait used to extract the inner type
@@ -559,13 +580,13 @@ pub trait PgRangeExpressionMethods: Expression + Sized {
     /// #     Ok(())
     /// # }
     /// ```
-    fn contains<T>(self, other: T) -> Contains<Self, T::Expression>
+    fn contains<T>(self, other: T) -> dsl::RangeContains<Self, T>
     where
         Self::SqlType: RangeHelper,
         <Self::SqlType as RangeHelper>::Inner: SqlType + TypedExpressionType,
         T: AsExpression<<Self::SqlType as RangeHelper>::Inner>,
     {
-        Contains::new(self, other.as_expression())
+        Grouped(Contains::new(self, other.as_expression()))
     }
 }
 
diff --git a/diesel/src/pg/expression/helper_types.rs b/diesel/src/pg/expression/helper_types.rs
index 0f96fe832..411ced878 100644
--- a/diesel/src/pg/expression/helper_types.rs
+++ b/diesel/src/pg/expression/helper_types.rs
@@ -1,8 +1,44 @@
-use crate::dsl::AsExprOf;
+use crate::dsl::{AsExpr, AsExprOf, SqlTypeOf};
+use crate::expression::grouped::Grouped;
 use crate::sql_types::VarChar;
 
 /// The return type of `lhs.ilike(rhs)`
-pub type ILike<Lhs, Rhs> = super::operators::ILike<Lhs, AsExprOf<Rhs, VarChar>>;
+pub type ILike<Lhs, Rhs> = Grouped<super::operators::ILike<Lhs, AsExprOf<Rhs, VarChar>>>;
 
 /// The return type of `lhs.not_ilike(rhs)`
-pub type NotILike<Lhs, Rhs> = super::operators::NotILike<Lhs, AsExprOf<Rhs, VarChar>>;
+pub type NotILike<Lhs, Rhs> = Grouped<super::operators::NotILike<Lhs, AsExprOf<Rhs, VarChar>>>;
+
+/// The return type of `lhs.is_not_distinct_from(rhs)`
+pub type IsNotDistinctFrom<Lhs, Rhs> =
+    Grouped<super::operators::IsNotDistinctFrom<Lhs, AsExpr<Rhs, Lhs>>>;
+
+/// The return type of `lhs.is_distinct_from(rhs)`
+pub type IsDistinctFrom<Lhs, Rhs> =
+    Grouped<super::operators::IsDistinctFrom<Lhs, AsExpr<Rhs, Lhs>>>;
+
+/// The return type of `lhs.overlaps_with(rhs)`
+pub type OverlapsWith<Lhs, Rhs> = Grouped<super::operators::OverlapsWith<Lhs, AsExpr<Rhs, Lhs>>>;
+
+/// The return type of `lhs.contains(rhs)` for array expressions
+pub type ArrayContains<Lhs, Rhs> = Grouped<super::operators::Contains<Lhs, AsExpr<Rhs, Lhs>>>;
+
+/// The return type of `lhs.contains(rhs)` for range expressions
+pub type RangeContains<Lhs, Rhs> = Grouped<
+    super::operators::Contains<
+        Lhs,
+        AsExprOf<Rhs, <SqlTypeOf<Lhs> as super::expression_methods::RangeHelper>::Inner>,
+    >,
+>;
+
+/// The return type of `lhs.is_contained_by(rhs)`
+pub type IsContainedBy<Lhs, Rhs> = Grouped<super::operators::IsContainedBy<Lhs, AsExpr<Rhs, Lhs>>>;
+
+/// The return type of `expr.nulls_first()`
+pub type NullsFirst<T> = super::operators::NullsFirst<T>;
+
+/// The return type of `expr.nulls_last()`
+pub type NullsLast<T> = super::operators::NullsLast<T>;
+
+/// The return type of `expr.at_time_zone(tz)`
+pub type AtTimeZone<Lhs, Rhs> =
+    Grouped<super::date_and_time::AtTimeZone<Lhs, AsExprOf<Rhs, VarChar>>>;
diff --git a/diesel/src/query_builder/insert_statement/mod.rs b/diesel/src/query_builder/insert_statement/mod.rs
index b252c7271..69f0c9f20 100644
--- a/diesel/src/query_builder/insert_statement/mod.rs
+++ b/diesel/src/query_builder/insert_statement/mod.rs
@@ -11,6 +11,7 @@ use std::marker::PhantomData;
 
 use super::returning_clause::*;
 use crate::backend::Backend;
+use crate::expression::grouped::Grouped;
 use crate::expression::operators::Eq;
 use crate::expression::{Expression, NonAggregate, SelectableExpression};
 use crate::insertable::*;
@@ -512,6 +513,13 @@ impl<Lhs, Rhs, Tab> UndecoratedInsertRecord<Tab> for Option<Eq<Lhs, Rhs>> where
 {
 }
 
+impl<Lhs, Rhs> UndecoratedInsertRecord<Lhs::Table> for Grouped<Eq<Lhs, Rhs>> where Lhs: Column {}
+
+impl<Lhs, Rhs, Tab> UndecoratedInsertRecord<Tab> for Option<Grouped<Eq<Lhs, Rhs>>> where
+    Eq<Lhs, Rhs>: UndecoratedInsertRecord<Tab>
+{
+}
+
 impl<T, Table> UndecoratedInsertRecord<Table> for ValuesClause<T, Table> where
     T: UndecoratedInsertRecord<Table>
 {
diff --git a/diesel/src/query_builder/mod.rs b/diesel/src/query_builder/mod.rs
index ce2c56d3a..e26311293 100644
--- a/diesel/src/query_builder/mod.rs
+++ b/diesel/src/query_builder/mod.rs
@@ -310,17 +310,17 @@ impl<T: Query> AsQuery for T {
 /// let debug = debug_query::<DB, _>(&query);
 /// # if cfg!(feature = "postgres") {
 /// #     assert_eq!(debug.to_string(), "SELECT \"users\".\"id\", \"users\".\"name\" \
-/// #         FROM \"users\" WHERE \"users\".\"id\" = $1 -- binds: [1]");
+/// #         FROM \"users\" WHERE (\"users\".\"id\" = $1) -- binds: [1]");
 /// # } else {
 /// assert_eq!(debug.to_string(), "SELECT `users`.`id`, `users`.`name` FROM `users` \
-///     WHERE `users`.`id` = ? -- binds: [1]");
+///     WHERE (`users`.`id` = ?) -- binds: [1]");
 /// # }
 ///
 /// let debug = format!("{:?}", debug);
 /// # if !cfg!(feature = "postgres") { // Escaping that string is a pain
 /// let expected = "Query { \
 ///     sql: \"SELECT `users`.`id`, `users`.`name` FROM `users` WHERE \
-///         `users`.`id` = ?\", \
+///         (`users`.`id` = ?)\", \
 ///     binds: [1] \
 /// }";
 /// assert_eq!(debug, expected);
diff --git a/diesel/src/query_builder/update_statement/changeset.rs b/diesel/src/query_builder/update_statement/changeset.rs
index afd587c5a..75b7d3234 100644
--- a/diesel/src/query_builder/update_statement/changeset.rs
+++ b/diesel/src/query_builder/update_statement/changeset.rs
@@ -1,4 +1,5 @@
 use crate::backend::Backend;
+use crate::expression::grouped::Grouped;
 use crate::expression::operators::Eq;
 use crate::expression::AppearsOnTable;
 use crate::query_builder::*;
@@ -48,6 +49,19 @@ where
     }
 }
 
+impl<Left, Right> AsChangeset for Grouped<Eq<Left, Right>>
+where
+    Eq<Left, Right>: AsChangeset,
+{
+    type Target = <Eq<Left, Right> as AsChangeset>::Target;
+
+    type Changeset = <Eq<Left, Right> as AsChangeset>::Changeset;
+
+    fn as_changeset(self) -> Self::Changeset {
+        self.0.as_changeset()
+    }
+}
+
 #[derive(Debug, Clone, Copy)]
 pub struct Assign<Col, Expr> {
     _column: Col,
diff --git a/diesel/src/query_builder/where_clause.rs b/diesel/src/query_builder/where_clause.rs
index a16e1704b..ac53f0da4 100644
--- a/diesel/src/query_builder/where_clause.rs
+++ b/diesel/src/query_builder/where_clause.rs
@@ -1,5 +1,6 @@
 use super::*;
 use crate::backend::Backend;
+use crate::expression::grouped::Grouped;
 use crate::expression::operators::{And, Or};
 use crate::expression::*;
 use crate::result::QueryResult;
@@ -88,10 +89,10 @@ where
     Predicate: Expression,
     Predicate::SqlType: BoolOrNullableBool,
 {
-    type Output = WhereClause<And<Expr, Predicate>>;
+    type Output = WhereClause<Grouped<And<Expr, Predicate>>>;
 
     fn and(self, predicate: Predicate) -> Self::Output {
-        WhereClause(And::new(self.0, predicate))
+        WhereClause(Grouped(And::new(self.0, predicate)))
     }
 }
 
@@ -102,10 +103,10 @@ where
     Predicate: Expression,
     Predicate::SqlType: BoolOrNullableBool,
 {
-    type Output = WhereClause<Or<Expr, Predicate>>;
+    type Output = WhereClause<Grouped<Or<Expr, Predicate>>>;
 
     fn or(self, predicate: Predicate) -> Self::Output {
-        WhereClause(Or::new(self.0, predicate))
+        WhereClause(Grouped(Or::new(self.0, predicate)))
     }
 }
 
@@ -165,7 +166,7 @@ where
         use self::BoxedWhereClause::Where;
 
         match self {
-            Where(where_clause) => Where(Box::new(And::new(where_clause, predicate))),
+            Where(where_clause) => Where(Box::new(Grouped(And::new(where_clause, predicate)))),
             BoxedWhereClause::None => Where(Box::new(predicate)),
         }
     }
@@ -180,7 +181,6 @@ where
 
     fn or(self, predicate: Predicate) -> Self::Output {
         use self::BoxedWhereClause::Where;
-        use crate::expression::grouped::Grouped;
 
         match self {
             Where(where_clause) => Where(Box::new(Grouped(Or::new(where_clause, predicate)))),
diff --git a/diesel/src/type_impls/option.rs b/diesel/src/type_impls/option.rs
index 1929df7b8..c49a9c94c 100644
--- a/diesel/src/type_impls/option.rs
+++ b/diesel/src/type_impls/option.rs
@@ -60,12 +60,11 @@ where
     }
 }
 
-impl<T, ST> AsExpression<Nullable<ST>> for Option<T>
+impl<T, ST> AsExpression<ST> for Option<T>
 where
-    ST: SqlType<IsNull = is_nullable::NotNull>,
-    Nullable<ST>: TypedExpressionType,
+    ST: SqlType<IsNull = is_nullable::IsNullable> + SingleValue,
 {
-    type Expression = Bound<Nullable<ST>, Self>;
+    type Expression = Bound<ST, Self>;
 
     fn as_expression(self) -> Self::Expression {
         Bound::new(self)
diff --git a/diesel_compile_tests/tests/compile-fail/right_side_of_left_join_requires_nullable.rs b/diesel_compile_tests/tests/compile-fail/right_side_of_left_join_requires_nullable.rs
index 0fd459b41..00a08bd4d 100644
--- a/diesel_compile_tests/tests/compile-fail/right_side_of_left_join_requires_nullable.rs
+++ b/diesel_compile_tests/tests/compile-fail/right_side_of_left_join_requires_nullable.rs
@@ -51,7 +51,7 @@ fn direct_joins() {
     //~| ERROR E0277
     // Invalid, Nullable<title> is selectable, but lower expects not-null
     let _ = join.select(lower(posts::title.nullable()));
-    //~^ ERROR E0271
+    //~^ ERROR E0277
 }
 
 fn nested_outer_joins_left_associative() {
@@ -72,7 +72,7 @@ fn nested_outer_joins_left_associative() {
     //~| ERROR E0277
     // Invalid, Nullable<title> is selectable, but lower expects not-null
     let _ = join.select(lower(posts::title.nullable()));
-    //~^ ERROR E0271
+    //~^ ERROR E0277
 }
 
 fn nested_mixed_joins_left_associative() {
@@ -92,7 +92,7 @@ fn nested_mixed_joins_left_associative() {
     //~| ERROR E0277
     // Invalid, Nullable<title> is selectable, but lower expects not-null
     let _ = join.select(lower(posts::title.nullable()));
-    //~^ ERROR E0271
+    //~^ ERROR E0277
 }
 
 fn nested_outer_joins_right_associative() {
@@ -112,7 +112,7 @@ fn nested_outer_joins_right_associative() {
     //~| ERROR E0277
     // Invalid, Nullable<title> is selectable, but lower expects not-null
     let _ = join.select(lower(posts::title.nullable()));
-    //~^ ERROR E0271
+    //~^ ERROR E0277
 }
 
 fn nested_mixed_joins_right_associative() {
@@ -132,5 +132,5 @@ fn nested_mixed_joins_right_associative() {
     //~| ERROR E0277
     // Invalid, Nullable<title> is selectable, but lower expects not-null
     let _ = join.select(lower(posts::title.nullable()));
-    //~^ ERROR E0271
+    //~^ ERROR E0277
 }
diff --git a/diesel_derives/src/lib.rs b/diesel_derives/src/lib.rs
index 7805f8bb0..6f766f4ca 100644
--- a/diesel_derives/src/lib.rs
+++ b/diesel_derives/src/lib.rs
@@ -849,12 +849,12 @@ pub fn derive_valid_grouping(input: TokenStream) -> TokenStream {
 /// #
 /// # table! { crates { id -> Integer, name -> VarChar, } }
 /// #
-/// use diesel::sql_types::Foldable;
+/// use diesel::sql_types::{Foldable, Nullable};
 ///
 /// sql_function! {
 ///     #[aggregate]
 ///     #[sql_name = "SUM"]
-///     fn sum<ST: Foldable>(expr: ST) -> ST::Sum;
+///     fn sum<ST: Foldable>(expr: Nullable<ST>) -> ST::Sum;
 /// }
 ///
 /// # fn main() {
diff --git a/diesel_tests/tests/debug/mod.rs b/diesel_tests/tests/debug/mod.rs
index 0d2d1a08d..8bdd2ab36 100644
--- a/diesel_tests/tests/debug/mod.rs
+++ b/diesel_tests/tests/debug/mod.rs
@@ -20,12 +20,12 @@ fn test_debug_output() {
     if cfg!(feature = "postgres") {
         assert_eq!(
             sql,
-            r#"UPDATE "users" SET "name" = $1 WHERE "users"."id" = $2 -- binds: ["new_name", 1]"#
+            r#"UPDATE "users" SET "name" = $1 WHERE ("users"."id" = $2) -- binds: ["new_name", 1]"#
         )
     } else {
         assert_eq!(
             sql,
-            r#"UPDATE `users` SET `name` = ? WHERE `users`.`id` = ? -- binds: ["new_name", 1]"#
+            r#"UPDATE `users` SET `name` = ? WHERE (`users`.`id` = ?) -- binds: ["new_name", 1]"#
         )
     }
 }
@@ -137,7 +137,7 @@ fn test_upsert() {
 
     assert_eq!(
         upsert_single_where_sql_display,
-        r#"INSERT INTO "users" ("name", "hair_color") VALUES ($1, $2), ($3, $4) ON CONFLICT ("hair_color") WHERE "users"."hair_color" = $5 DO NOTHING -- binds: ["Sean", Some("black"), "Tess", None, "black"]"#
+        r#"INSERT INTO "users" ("name", "hair_color") VALUES ($1, $2), ($3, $4) ON CONFLICT ("hair_color") WHERE ("users"."hair_color" = $5) DO NOTHING -- binds: ["Sean", Some("black"), "Tess", None, "black"]"#
     );
 
     let upsert_command_second_where = insert_into(users)
@@ -152,6 +152,6 @@ fn test_upsert() {
 
     assert_eq!(
         upsert_second_where_sql_display,
-        r#"INSERT INTO "users" ("name", "hair_color") VALUES ($1, $2), ($3, $4) ON CONFLICT ("hair_color") WHERE "users"."hair_color" = $5 AND "users"."name" = $6 DO NOTHING -- binds: ["Sean", Some("black"), "Tess", None, "black", "Sean"]"#
+        r#"INSERT INTO "users" ("name", "hair_color") VALUES ($1, $2), ($3, $4) ON CONFLICT ("hair_color") WHERE (("users"."hair_color" = $5) AND ("users"."name" = $6)) DO NOTHING -- binds: ["Sean", Some("black"), "Tess", None, "black", "Sean"]"#
     );
 }
diff --git a/diesel_tests/tests/expressions/mod.rs b/diesel_tests/tests/expressions/mod.rs
index 6d6702b7d..378c7e8b9 100644
--- a/diesel_tests/tests/expressions/mod.rs
+++ b/diesel_tests/tests/expressions/mod.rs
@@ -460,3 +460,16 @@ fn test_arrays_b() {
 
     assert_eq!(value, vec![7, 14]);
 }
+
+#[test]
+fn test_operator_precedence() {
+    use self::numbers;
+
+    let connection = connection();
+    connection
+        .execute("INSERT INTO numbers (n) VALUES (2)")
+        .unwrap();
+    let source = numbers::table.select(numbers::n.gt(0).eq(true));
+
+    assert_eq!(Ok(true), source.first(&connection));
+}
diff --git a/diesel_tests/tests/group_by.rs b/diesel_tests/tests/group_by.rs
index 668fd14d4..4d29ef24c 100644
--- a/diesel_tests/tests/group_by.rs
+++ b/diesel_tests/tests/group_by.rs
@@ -11,7 +11,7 @@ fn group_by_generates_group_by_sql() {
         .select(users::name)
         .filter(users::hair_color.is_null());
     let mut expected_sql = "SELECT `users`.`name` FROM `users` \
-                            WHERE `users`.`hair_color` IS NULL \
+                            WHERE (`users`.`hair_color` IS NULL) \
                             GROUP BY `users`.`name` \
                             -- binds: []"
         .to_string();
@@ -33,7 +33,7 @@ fn group_by_mixed_aggregate_column_and_aggregate_function() {
         .select((max(users::id), users::name))
         .filter(users::hair_color.is_null());
     let mut expected_sql = "SELECT max(`users`.`id`), `users`.`name` FROM `users` \
-                            WHERE `users`.`hair_color` IS NULL \
+                            WHERE (`users`.`hair_color` IS NULL) \
                             GROUP BY `users`.`name` \
                             -- binds: []"
         .to_string();
@@ -58,7 +58,7 @@ fn boxed_queries_have_group_by_method() {
         .select(users::name)
         .filter(users::hair_color.is_null());
     let mut expected_sql = "SELECT `users`.`name` FROM `users` \
-                            WHERE `users`.`hair_color` IS NULL \
+                            WHERE (`users`.`hair_color` IS NULL) \
                             GROUP BY `users`.`name` \
                             -- binds: []"
         .to_string();
diff --git a/diesel_tests/tests/types.rs b/diesel_tests/tests/types.rs
index 0e1bf368c..e8755f5f6 100644
--- a/diesel_tests/tests/types.rs
+++ b/diesel_tests/tests/types.rs
@@ -1251,27 +1251,21 @@ where
     select(sql::<T>(sql_str)).first(&connection).unwrap()
 }
 
-use diesel::dsl::{And, AsExprOf, Eq, IsNull};
+use diesel::dsl::Eq;
 use diesel::expression::{is_aggregate, AsExpression, SqlLiteral, ValidGrouping};
 use diesel::query_builder::{QueryFragment, QueryId};
 use std::fmt::Debug;
 
 fn query_to_sql_equality<T, U>(sql_str: &str, value: U) -> bool
 where
-    U: AsExpression<T> + Debug + Clone,
-    U::Expression: SelectableExpression<(), SqlType = T>
-        + ValidGrouping<(), IsAggregate = is_aggregate::Never>,
-    U::Expression: QueryFragment<TestBackend> + QueryId,
-    T: QueryId + SingleValue + SqlType,
-    T::IsNull: OneIsNullable<T::IsNull, Out = T::IsNull>,
-    T::IsNull: MaybeNullableType<Bool>,
-    <T::IsNull as MaybeNullableType<Bool>>::Out: SqlType,
-    diesel::sql_types::is_nullable::NotNull: diesel::sql_types::AllAreNullable<
-        <<T::IsNull as MaybeNullableType<Bool>>::Out as SqlType>::IsNull,
-        Out = diesel::sql_types::is_nullable::NotNull,
-    >,
-    Eq<SqlLiteral<T>, U>: Expression<SqlType = <T::IsNull as MaybeNullableType<Bool>>::Out>,
-    And<IsNull<SqlLiteral<T>>, IsNull<AsExprOf<U, T>>>: Expression<SqlType = Bool>,
+    U: AsExpression<T::Nullable> + Debug + Clone,
+    U::Expression: SelectableExpression<(), SqlType = T::Nullable>
+        + ValidGrouping<(), IsAggregate = is_aggregate::Never>
+        + QueryFragment<TestBackend>
+        + QueryId,
+    T: QueryId + SingleValue + SqlType + IntoNullable,
+    T::Nullable: SqlType + SingleValue,
+    Eq<SqlLiteral<T::Nullable>, U>: Expression<SqlType = Nullable<Bool>> + SelectableExpression<()>,
 {
     use diesel::dsl::sql;
     let connection = connection();
@@ -1279,11 +1273,12 @@ where
         sql::<T>(sql_str)
             .is_null()
             .and(value.clone().as_expression().is_null())
-            .or(sql::<T>(sql_str).eq(value.clone())),
+            .or(sql::<T::Nullable>(sql_str).eq(value.clone())),
     );
     query
-        .get_result::<bool>(&connection)
+        .get_result::<Option<bool>>(&connection)
         .expect(&format!("Error comparing {}, {:?}", sql_str, value))
+        .unwrap_or(false)
 }
 
 #[cfg(feature = "postgres")]
diff --git a/examples/postgres/all_about_updates/src/lib.rs b/examples/postgres/all_about_updates/src/lib.rs
index 629ce58d2..c02fbeda7 100644
--- a/examples/postgres/all_about_updates/src/lib.rs
+++ b/examples/postgres/all_about_updates/src/lib.rs
@@ -63,7 +63,7 @@ fn examine_sql_from_publish_pending_posts() {
         .set(draft.eq(false));
     assert_eq!(
         "UPDATE \"posts\" SET \"draft\" = $1 \
-         WHERE \"posts\".\"publish_at\" < CURRENT_TIMESTAMP \
+         WHERE (\"posts\".\"publish_at\" < CURRENT_TIMESTAMP) \
          -- binds: [false]",
         debug_query(&query).to_string()
     );
@@ -86,7 +86,7 @@ fn examine_sql_from_publish_post() {
         visit_count: 0,
     };
     assert_eq!(
-        "UPDATE \"posts\" SET \"draft\" = $1 WHERE \"posts\".\"id\" = $2 \
+        "UPDATE \"posts\" SET \"draft\" = $1 WHERE (\"posts\".\"id\" = $2) \
          -- binds: [false, 1]",
         debug_query(&diesel::update(&post).set(posts::draft.eq(false))).to_string()
     );
