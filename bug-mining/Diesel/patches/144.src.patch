diff --git a/CHANGELOG.md b/CHANGELOG.md
index a18cdbaab..921375b92 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -6,6 +6,13 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 ## Unreleased
 
+### Added
+
+* Added support for specifying `ISOLATION LEVEL`, `DEFERRABLE`, and `READ ONLY`
+  on PG transactions. See [`PgConnection::build_transaction`] for details.
+
+[`PgConnection::build_transaction`]: http://docs.diesel.rs/diesel/pg/struct.PgConnection.html#method.build_transaction
+
 ### Deprecated
 
 * `ne_any` has been renamed to `ne_all`.
diff --git a/diesel/src/connection/transaction_manager.rs b/diesel/src/connection/transaction_manager.rs
index cd1f6d4da..72cc25bf1 100644
--- a/diesel/src/connection/transaction_manager.rs
+++ b/diesel/src/connection/transaction_manager.rs
@@ -1,5 +1,5 @@
 use backend::UsesAnsiSavepointSyntax;
-use connection::Connection;
+use connection::{Connection, SimpleConnection};
 use result::QueryResult;
 
 /// Manages the internal transaction state for a connection.
@@ -58,6 +58,24 @@ impl AnsiTransactionManager {
         }
         query
     }
+
+    /// Begin a transaction with custom SQL
+    ///
+    /// This is used by connections to implement more complex transaction APIs
+    /// to set things such as isolation levels.
+    /// Returns an error if already inside of a transaction.
+    pub fn begin_transaction_sql<Conn>(&self, conn: &Conn, sql: &str) -> QueryResult<()>
+    where
+        Conn: SimpleConnection,
+    {
+        use result::Error::AlreadyInTransaction;
+
+        if self.transaction_depth.get() == 0 {
+            self.change_transaction_depth(1, conn.batch_execute(sql))
+        } else {
+            Err(AlreadyInTransaction)
+        }
+    }
 }
 
 impl<Conn> TransactionManager<Conn> for AnsiTransactionManager
diff --git a/diesel/src/doctest_setup.rs b/diesel/src/doctest_setup.rs
index f8c4a3611..c3c98c153 100644
--- a/diesel/src/doctest_setup.rs
+++ b/diesel/src/doctest_setup.rs
@@ -9,9 +9,13 @@ cfg_if! {
         #[allow(dead_code)]
         type DB = diesel::pg::Pg;
 
-        fn connection_no_data() -> PgConnection {
+        fn connection_no_transaction() -> PgConnection {
             let connection_url = database_url_from_env("PG_DATABASE_URL");
-            let connection = PgConnection::establish(&connection_url).unwrap();
+            PgConnection::establish(&connection_url).unwrap()
+        }
+
+        fn connection_no_data() -> PgConnection {
+            let connection = connection_no_transaction();
             connection.begin_test_transaction().unwrap();
             connection.execute("DROP TABLE IF EXISTS users CASCADE").unwrap();
             connection.execute("DROP TABLE IF EXISTS animals CASCADE").unwrap();
diff --git a/diesel/src/pg/connection/mod.rs b/diesel/src/pg/connection/mod.rs
index e4972e496..2c2ca8f64 100644
--- a/diesel/src/pg/connection/mod.rs
+++ b/diesel/src/pg/connection/mod.rs
@@ -10,7 +10,7 @@ use std::os::raw as libc;
 
 use connection::*;
 use deserialize::{Queryable, QueryableByName};
-use pg::{Pg, PgMetadataLookup};
+use pg::{Pg, PgMetadataLookup, TransactionBuilder};
 use query_builder::*;
 use query_builder::bind_collector::RawBytesBindCollector;
 use result::*;
@@ -108,6 +108,34 @@ impl Connection for PgConnection {
 }
 
 impl PgConnection {
+    /// Build a transaction, specifying additional details such as isolation level
+    ///
+    /// See [`TransactionBuilder`] for more examples.
+    ///
+    /// [`TransactionBuilder`]: ../pg/struct.TransactionBuilder.html
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../../doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use schema::users::dsl::*;
+    /// #     let conn = connection_no_transaction();
+    /// conn.build_transaction()
+    ///     .read_only()
+    ///     .serializable()
+    ///     .deferrable()
+    ///     .run(|| Ok(()))
+    /// # }
+    /// ```
+    pub fn build_transaction(&self) -> TransactionBuilder {
+        TransactionBuilder::new(self)
+    }
+
     #[cfg_attr(feature = "clippy", allow(type_complexity))]
     fn prepare_query<T: QueryFragment<Pg> + QueryId>(
         &self,
diff --git a/diesel/src/pg/mod.rs b/diesel/src/pg/mod.rs
index f7abf5d4b..9ef27e850 100644
--- a/diesel/src/pg/mod.rs
+++ b/diesel/src/pg/mod.rs
@@ -5,19 +5,21 @@
 //! PostgreSQL, you may need to work with this module directly.
 
 pub mod expression;
+pub mod types;
+pub mod upsert;
 
 mod backend;
+mod connection;
 mod metadata_lookup;
 mod query_builder;
-mod connection;
-pub mod types;
-pub mod upsert;
+mod transaction;
 
 pub use self::backend::{Pg, PgTypeMetadata};
 pub use self::connection::PgConnection;
 pub use self::metadata_lookup::PgMetadataLookup;
 pub use self::query_builder::PgQueryBuilder;
 pub use self::query_builder::DistinctOnClause;
+pub use self::transaction::TransactionBuilder;
 
 /// Data structures for PG types which have no corresponding Rust type
 ///
diff --git a/diesel/src/pg/transaction.rs b/diesel/src/pg/transaction.rs
new file mode 100644
index 000000000..5541d7741
--- /dev/null
+++ b/diesel/src/pg/transaction.rs
@@ -0,0 +1,401 @@
+#![allow(dead_code)]
+use backend::Backend;
+use connection::TransactionManager;
+use pg::Pg;
+use prelude::*;
+use query_builder::{AstPass, QueryBuilder, QueryFragment};
+use result::Error;
+
+/// Used to build a transaction, specifying additional details.
+///
+/// This struct is returned by [`.build_transaction`].
+/// See the documentation for methods on this struct for usage examples.
+/// See [the PostgreSQL documentation for `SET TRANSACTION`][pg-docs]
+/// for details on the behavior of each option.
+///
+/// [`.build_transaction`]: struct.PgConnection.html#method.build_transaction
+/// [pg-docs]: https://www.postgresql.org/docs/current/static/sql-set-transaction.html
+#[allow(missing_debug_implementations)] // False positive. Connection isn't Debug.
+#[derive(Clone, Copy)]
+#[must_use = "Transaction builder does nothing unless you call `run` on it"]
+pub struct TransactionBuilder<'a> {
+    connection: &'a PgConnection,
+    isolation_level: Option<IsolationLevel>,
+    read_mode: Option<ReadMode>,
+    deferrable: Option<Deferrable>,
+}
+
+impl<'a> TransactionBuilder<'a> {
+    pub(crate) fn new(connection: &'a PgConnection) -> Self {
+        Self {
+            connection,
+            isolation_level: None,
+            read_mode: None,
+            deferrable: None,
+        }
+    }
+
+    /// Makes the transaction `READ ONLY`
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// # use diesel::sql_query;
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # table! {
+    /// #     users_for_read_only {
+    /// #         id -> Integer,
+    /// #         name -> Text,
+    /// #     }
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use users_for_read_only::table as users;
+    /// #     use users_for_read_only::columns::*;
+    /// #     let conn = connection_no_transaction();
+    /// #     sql_query("CREATE TABLE IF NOT EXISTS users_for_read_only (
+    /// #       id SERIAL PRIMARY KEY,
+    /// #       name TEXT NOT NULL
+    /// #     )").execute(&conn)?;
+    /// conn.build_transaction()
+    ///     .read_only()
+    ///     .run::<_, diesel::result::Error, _>(|| {
+    ///         let read_attempt = users.select(name).load::<String>(&conn);
+    ///         assert!(read_attempt.is_ok());
+    ///
+    ///         let write_attempt = diesel::insert_into(users)
+    ///             .values(name.eq("Ruby"))
+    ///             .execute(&conn);
+    ///         assert!(write_attempt.is_err());
+    ///
+    ///         Ok(())
+    ///     })?;
+    /// #     sql_query("DROP TABLE users_for_read_only").execute(&conn)?;
+    /// #     Ok(())
+    /// # }
+    /// ```
+    pub fn read_only(mut self) -> Self {
+        self.read_mode = Some(ReadMode::ReadOnly);
+        self
+    }
+
+    /// Makes the transaction `READ WRITE`
+    ///
+    /// This is the default, unless you've changed the
+    /// `default_transaction_read_only` configuration parameter.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// # use diesel::result::Error::RollbackTransaction;
+    /// # use diesel::sql_query;
+    /// #
+    /// # fn main() {
+    /// #     assert_eq!(run_test(), Err(RollbackTransaction));
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use schema::users::dsl::*;
+    /// #     let conn = connection_no_transaction();
+    /// conn.build_transaction()
+    ///     .read_write()
+    ///     .run(|| {
+    /// #         sql_query("CREATE TABLE IF NOT EXISTS users (
+    /// #             id SERIAL PRIMARY KEY,
+    /// #             name TEXT NOT NULL
+    /// #         )").execute(&conn)?;
+    ///         let read_attempt = users.select(name).load::<String>(&conn);
+    ///         assert!(read_attempt.is_ok());
+    ///
+    ///         let write_attempt = diesel::insert_into(users)
+    ///             .values(name.eq("Ruby"))
+    ///             .execute(&conn);
+    ///         assert!(write_attempt.is_ok());
+    ///
+    /// #       Err(RollbackTransaction)
+    /// #       /*
+    ///         Ok(())
+    /// #       */
+    ///     })
+    /// # }
+    /// ```
+    pub fn read_write(mut self) -> Self {
+        self.read_mode = Some(ReadMode::ReadWrite);
+        self
+    }
+
+    /// Makes the transaction `DEFERRABLE`
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use schema::users::dsl::*;
+    /// #     let conn = connection_no_transaction();
+    /// conn.build_transaction()
+    ///     .deferrable()
+    ///     .run(|| Ok(()))
+    /// # }
+    /// ```
+    pub fn deferrable(mut self) -> Self {
+        self.deferrable = Some(Deferrable::Deferrable);
+        self
+    }
+
+    /// Makes the transaction `NOT DEFERRABLE`
+    ///
+    /// This is the default, unless you've changed the
+    /// `default_transaction_deferrable` configuration parameter.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use schema::users::dsl::*;
+    /// #     let conn = connection_no_transaction();
+    /// conn.build_transaction()
+    ///     .not_deferrable()
+    ///     .run(|| Ok(()))
+    /// # }
+    /// ```
+    pub fn not_deferrable(mut self) -> Self {
+        self.deferrable = Some(Deferrable::NotDeferrable);
+        self
+    }
+
+    /// Makes the transaction `ISOLATION LEVEL READ COMMITTED`
+    ///
+    /// This is the default, unless you've changed the
+    /// `default_transaction_isolation_level` configuration parameter.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use schema::users::dsl::*;
+    /// #     let conn = connection_no_transaction();
+    /// conn.build_transaction()
+    ///     .read_committed()
+    ///     .run(|| Ok(()))
+    /// # }
+    /// ```
+    pub fn read_committed(mut self) -> Self {
+        self.isolation_level = Some(IsolationLevel::ReadCommitted);
+        self
+    }
+
+    /// Makes the transaction `ISOLATION LEVEL REPEATABLE READ`
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use schema::users::dsl::*;
+    /// #     let conn = connection_no_transaction();
+    /// conn.build_transaction()
+    ///     .repeatable_read()
+    ///     .run(|| Ok(()))
+    /// # }
+    /// ```
+    pub fn repeatable_read(mut self) -> Self {
+        self.isolation_level = Some(IsolationLevel::RepeatableRead);
+        self
+    }
+
+    /// Makes the transaction `ISOLATION LEVEL SERIALIZABLE`
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("../doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use schema::users::dsl::*;
+    /// #     let conn = connection_no_transaction();
+    /// conn.build_transaction()
+    ///     .serializable()
+    ///     .run(|| Ok(()))
+    /// # }
+    /// ```
+    pub fn serializable(mut self) -> Self {
+        self.isolation_level = Some(IsolationLevel::Serializable);
+        self
+    }
+
+    /// Runs the given function inside of the transaction
+    /// with the parameters given to this builder.
+    ///
+    /// Returns an error if the connection is already inside a transaction.
+    pub fn run<T, E, F>(&self, f: F) -> Result<T, E>
+    where
+        F: FnOnce() -> Result<T, E>,
+        E: From<Error>,
+    {
+        let mut query_builder = <Pg as Backend>::QueryBuilder::default();
+        self.to_sql(&mut query_builder)?;
+        let sql = query_builder.finish();
+        let transaction_manager = self.connection.transaction_manager();
+
+        transaction_manager.begin_transaction_sql(self.connection, &sql)?;
+        match f() {
+            Ok(value) => {
+                transaction_manager.commit_transaction(self.connection)?;
+                Ok(value)
+            }
+            Err(e) => {
+                transaction_manager.rollback_transaction(self.connection)?;
+                Err(e)
+            }
+        }
+    }
+}
+
+impl<'a> QueryFragment<Pg> for TransactionBuilder<'a> {
+    fn walk_ast(&self, mut out: AstPass<Pg>) -> QueryResult<()> {
+        out.push_sql("BEGIN TRANSACTION");
+        if let Some(ref isolation_level) = self.isolation_level {
+            isolation_level.walk_ast(out.reborrow())?;
+        }
+        if let Some(ref read_mode) = self.read_mode {
+            read_mode.walk_ast(out.reborrow())?;
+        }
+        if let Some(ref deferrable) = self.deferrable {
+            deferrable.walk_ast(out.reborrow())?;
+        }
+        Ok(())
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+enum IsolationLevel {
+    ReadCommitted,
+    RepeatableRead,
+    Serializable,
+}
+
+impl QueryFragment<Pg> for IsolationLevel {
+    fn walk_ast(&self, mut out: AstPass<Pg>) -> QueryResult<()> {
+        out.push_sql(" ISOLATION LEVEL ");
+        match *self {
+            IsolationLevel::ReadCommitted => out.push_sql("READ COMMITTED"),
+            IsolationLevel::RepeatableRead => out.push_sql("REPEATABLE READ"),
+            IsolationLevel::Serializable => out.push_sql("SERIALIZABLE"),
+        }
+        Ok(())
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+enum ReadMode {
+    ReadOnly,
+    ReadWrite,
+}
+
+impl QueryFragment<Pg> for ReadMode {
+    fn walk_ast(&self, mut out: AstPass<Pg>) -> QueryResult<()> {
+        match *self {
+            ReadMode::ReadOnly => out.push_sql(" READ ONLY"),
+            ReadMode::ReadWrite => out.push_sql(" READ WRITE"),
+        }
+        Ok(())
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+enum Deferrable {
+    Deferrable,
+    NotDeferrable,
+}
+
+impl QueryFragment<Pg> for Deferrable {
+    fn walk_ast(&self, mut out: AstPass<Pg>) -> QueryResult<()> {
+        match *self {
+            Deferrable::Deferrable => out.push_sql(" DEFERRABLE"),
+            Deferrable::NotDeferrable => out.push_sql(" NOT DEFERRABLE"),
+        }
+        Ok(())
+    }
+}
+
+#[test]
+fn test_transaction_builder_generates_correct_sql() {
+    extern crate dotenv;
+
+    macro_rules! assert_sql {
+        ($query:expr, $sql:expr) => {
+            let mut query_builder = <Pg as Backend>::QueryBuilder::default();
+            $query.to_sql(&mut query_builder).unwrap();
+            let sql = query_builder.finish();
+            assert_eq!(sql, $sql);
+        }
+    }
+
+    let database_url = dotenv::var("PG_DATABASE_URL")
+        .or_else(|_| dotenv::var("DATABASE_URL"))
+        .expect("DATABASE_URL must be set in order to run tests");
+    let conn = PgConnection::establish(&database_url).unwrap();
+
+    let t = conn.build_transaction();
+    assert_sql!(t, "BEGIN TRANSACTION");
+    assert_sql!(t.read_only(), "BEGIN TRANSACTION READ ONLY");
+    assert_sql!(t.read_write(), "BEGIN TRANSACTION READ WRITE");
+    assert_sql!(t.deferrable(), "BEGIN TRANSACTION DEFERRABLE");
+    assert_sql!(t.not_deferrable(), "BEGIN TRANSACTION NOT DEFERRABLE");
+    assert_sql!(
+        t.read_committed(),
+        "BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED"
+    );
+    assert_sql!(
+        t.repeatable_read(),
+        "BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ"
+    );
+    assert_sql!(
+        t.serializable(),
+        "BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE"
+    );
+    assert_sql!(
+        t.serializable().deferrable().read_only(),
+        "BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE"
+    );
+}
diff --git a/diesel/src/result.rs b/diesel/src/result.rs
index 3def89550..4a4951c5e 100644
--- a/diesel/src/result.rs
+++ b/diesel/src/result.rs
@@ -16,6 +16,7 @@ pub enum Error {
     ///
     /// This should never occur in normal usage.
     InvalidCString(NulError),
+
     /// The database returned an error.
     ///
     /// While Diesel prevents almost all sources of runtime errors at compile
@@ -26,6 +27,7 @@ pub enum Error {
         DatabaseErrorKind,
         Box<DatabaseErrorInformation + Send + Sync>,
     ),
+
     /// No rows were returned by a query expected to return at least one row.
     ///
     /// This variant is only returned by [`get_result`] and [`first`]. [`load`]
@@ -37,24 +39,28 @@ pub enum Error {
     /// [`load`]: ../query_dsl/trait.RunQueryDsl.html#method.load
     /// [`optional`]: trait.OptionalExtension.html#tymethod.optional
     NotFound,
+
     /// The query could not be constructed
     ///
     /// An example of when this error could occur is if you are attempting to
     /// construct an update statement with no changes (e.g. all fields on the
     /// struct are `None`).
     QueryBuilderError(Box<StdError + Send + Sync>),
+
     /// An error occurred deserializing the data being sent to the database.
     ///
     /// Typically this error means that the stated type of the query is
     /// incorrect. An example of when this error might occur in normal usage is
     /// attempting to deserialize an infinite date into chrono.
     DeserializationError(Box<StdError + Send + Sync>),
+
     /// An error occurred serializing the data being sent to the database.
     ///
     /// An example of when this error would be returned is if you attempted to
     /// serialize a `chrono::NaiveDate` earlier than the earliest date supported
     /// by PostgreSQL.
     SerializationError(Box<StdError + Send + Sync>),
+
     /// Roll back the current transaction.
     ///
     /// You can return this variant inside of a transaction when you want to
@@ -62,6 +68,11 @@ pub enum Error {
     /// return this variant unless you gave it to us, and it can be safely
     /// ignored in error handling.
     RollbackTransaction,
+
+    /// Attempted to perform an operation that cannot be done inside a transaction
+    /// when a transaction was already open.
+    AlreadyInTransaction,
+
     #[doc(hidden)] __Nonexhaustive,
 }
 
@@ -241,6 +252,7 @@ impl Display for Error {
             Error::DeserializationError(ref e) => e.fmt(f),
             Error::SerializationError(ref e) => e.fmt(f),
             Error::RollbackTransaction => write!(f, "{}", self.description()),
+            Error::AlreadyInTransaction => write!(f, "{}", self.description()),
             Error::__Nonexhaustive => unreachable!(),
         }
     }
@@ -256,6 +268,9 @@ impl StdError for Error {
             Error::DeserializationError(ref e) => e.description(),
             Error::SerializationError(ref e) => e.description(),
             Error::RollbackTransaction => "The current transaction was aborted",
+            Error::AlreadyInTransaction => {
+                "Cannot perform this operation while a transaction is open"
+            }
             Error::__Nonexhaustive => unreachable!(),
         }
     }
@@ -311,6 +326,8 @@ impl PartialEq for Error {
                 a.message() == b.message()
             }
             (&Error::NotFound, &Error::NotFound) => true,
+            (&Error::RollbackTransaction, &Error::RollbackTransaction) => true,
+            (&Error::AlreadyInTransaction, &Error::AlreadyInTransaction) => true,
             _ => false,
         }
     }
