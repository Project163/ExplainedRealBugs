diff --git a/CHANGELOG.md b/CHANGELOG.md
index 76483c9e1..9e59736ad 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,10 +4,19 @@ All user visible changes to this project will be documented in this file.
 This project adheres to [Semantic Versioning](http://semver.org/), as described
 for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md)
 
+## Unreleased
+
 ### Added
 
 * Added helper types for inner join and left outer join
 
+### Fixed
+
+* `BigDecimal` now properly encodes numbers starting with `10000` on postgres.
+  See [issue #1044][] for details.
+
+[issue #1044]: https://github.com/diesel-rs/diesel/issues/1044
+
 ## [0.15.1] - 2017-07-24
 
 * No changes to public API
diff --git a/diesel/src/pg/types/numeric.rs b/diesel/src/pg/types/numeric.rs
index 14f3a1d7c..cf1ccffa3 100644
--- a/diesel/src/pg/types/numeric.rs
+++ b/diesel/src/pg/types/numeric.rs
@@ -26,7 +26,7 @@ mod bigdecimal {
 
         let mut integer_part = absolute.to_bigint().expect("Can always take integer part of BigDecimal");
 
-        while ten_k < integer_part {
+        while ten_k <= integer_part {
             weight += 1;
             // digit is integer_part REM 10_000
             let (div, digit) = integer_part.div_rem(&ten_k);
diff --git a/diesel_tests/tests/types.rs b/diesel_tests/tests/types.rs
index 9e7e7fff7..84e5b0f29 100644
--- a/diesel_tests/tests/types.rs
+++ b/diesel_tests/tests/types.rs
@@ -441,6 +441,25 @@ fn pg_numeric_bigdecimal_to_sql() {
     }
 
     quickcheck(correct_rep as fn(u64, u64) -> bool);
+
+    let test_values = vec![
+        "1.0",
+        "141.0",
+        "-1.0",
+        // Larger than u64
+        "18446744073709551616",
+        // Powers of 10k (numeric is represented in base 10k)
+        "10000",
+        "100000000",
+        "1.100001",
+        "10000.100001",
+    ];
+
+    for value in test_values {
+        let expected = format!("'{}'::numeric", value);
+        let value = value.parse::<BigDecimal>().unwrap();
+        query_to_sql_equality::<Numeric, _>(&expected, value);
+    }
 }
 
 #[test]
@@ -448,18 +467,24 @@ fn pg_numeric_bigdecimal_to_sql() {
 fn pg_numeric_bigdecimal_from_sql() {
     use self::bigdecimal::BigDecimal;
 
-    let query = "1.0::numeric";
-    let expected_value: BigDecimal = "1.0".parse().expect("Could not parse to a BigDecimal");
-    assert_eq!(expected_value, query_single_value::<Numeric, BigDecimal>(query));
-
-    let query = "141.00::numeric";
-    let expected_value: BigDecimal = "141.00".parse().expect("Could not parse to a BigDecimal");
-    assert_eq!(expected_value, query_single_value::<Numeric, BigDecimal>(query));
+    let values = vec![
+        "1.0",
+        "141.0",
+        "-1.0",
+        // Larger than u64
+        "18446744073709551616",
+        // Powers of 10k (numeric is represented in base 10k)
+        "10000",
+        "100000000",
+        "1.100001",
+        "10000.100001",
+    ];
 
-    // Some non standard values:
-    let query = "18446744073709551616::numeric"; // 2^64; doesn't fit in u64
-    let expected_value: BigDecimal = "18446744073709551616.00".parse().expect("Could not parse to a BigDecimal");
-    assert_eq!(expected_value, query_single_value::<Numeric, BigDecimal>(query));
+    for value in values {
+        let query = format!("'{}'::numeric", value);
+        let expected = value.parse::<BigDecimal>().unwrap();
+        assert_eq!(expected, query_single_value::<Numeric, BigDecimal>(&query));
+    }
 }
 
 #[test]
