diff --git a/CHANGELOG.md b/CHANGELOG.md
index f42935c9c..f109bc9e8 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -12,11 +12,28 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 [record-1-3-0]: http://docs.diesel.rs/diesel/pg/types/sql_types/struct.Record.html
 
+### Changed
+
+* `sql_function!` has been redesigned. The syntax is now `sql_function!(fn
+  lower(x: Text) -> Text);`. The output of the new syntax is slightly different
+  than what was generated in the past. See [the documentation for
+  `sql_function!`][sql-function-1-3-0] for more details.
+
 ### Fixed
 
 * `diesel print-schema` and `infer_schema!` now properly handle unsigned types
   in MySQL
 
+### Deprecated
+
+* Uses of `sql_function!` in the form `sql_function!(foo, foo_t, (x: Integer))`
+  have been deprecated in favor of a new design (listed above). Note: Due to [a
+  bug in Rust](https://github.com/rust-lang/rust/issues/49912), you may not see
+  a deprecation warning from usage of the old form. As always, if you're
+  concerned about relying on deprecated code, we recommend attempting to build
+  your app with `default-features` turned off (specifically excluding the
+  `with-deprecated` feature).
+
 ## [1.2.2] - 2018-04-12
 
 ### Changed
diff --git a/diesel/src/expression/functions/date_and_time.rs b/diesel/src/expression/functions/date_and_time.rs
index 1461b8e7e..004220023 100644
--- a/diesel/src/expression/functions/date_and_time.rs
+++ b/diesel/src/expression/functions/date_and_time.rs
@@ -27,24 +27,25 @@ impl_selectable_expression!(now);
 
 operator_allowed!(now, Add, add);
 operator_allowed!(now, Sub, sub);
-sql_function!(date, date_t, (expr: Timestamp) -> Date,
-"Represents the SQL `DATE` function. The argument should be a Timestamp
-expression, and the return value will be an expression of type Date.
+sql_function! {
+    /// Represents the SQL `DATE` function. The argument should be a Timestamp
+    /// expression, and the return value will be an expression of type Date.
 
-# Examples
+    /// # Examples
 
-```ignore
-# #[macro_use] extern crate diesel;
-# extern crate chrono;
-# include!(\"../../doctest_setup.rs\");
-# use diesel::dsl::*;
-#
-# fn main() {
-#     let connection = establish_connection();
-let today: chrono::NaiveDate = diesel::select(date(now)).first(&connection).unwrap();
-# }
-",
-"The return type of [`date(expr)`](../dsl/fn.date.html)");
+    /// ```ignore
+    /// # #[macro_use] extern crate diesel;
+    /// # extern crate chrono;
+    /// # include!(\"../../doctest_setup.rs\");
+    /// # use diesel::dsl::*;
+    /// #
+    /// # fn main() {
+    /// #     let connection = establish_connection();
+    /// let today: chrono::NaiveDate = diesel::select(date(now)).first(&connection).unwrap();
+    /// # }
+    /// ```
+    fn date(expr: Timestamp) -> Date;
+}
 
 #[cfg(feature = "postgres")]
 use expression::AsExpression;
diff --git a/diesel/src/expression/functions/mod.rs b/diesel/src/expression/functions/mod.rs
index c57067ed7..0816a13b2 100644
--- a/diesel/src/expression/functions/mod.rs
+++ b/diesel/src/expression/functions/mod.rs
@@ -1,5 +1,7 @@
 #[macro_export]
 #[doc(hidden)]
+#[cfg(feature = "with-deprecated")]
+#[deprecated(since = "1.3.0", note = "The syntax of `sql_function!` and its output have changed significantly. This form has been deprecated. See the documentation of `sql_function!` for details on the new syntax.")]
 macro_rules! sql_function_body {
     (
         $fn_name:ident,
@@ -77,15 +79,154 @@ macro_rules! sql_function_body {
 }
 
 #[macro_export]
-/// Declare a sql function for use in your code. Useful if you have your own SQL functions that
-/// you'd like to use. You can optionally provide a doc string as well. `$struct_name` should just
-/// be any unique name. You will not need to reference it in your code, but it is required due to
-/// the fact that [`concat_idents!` is
-/// useless](https://github.com/rust-lang/rust/issues/29599#issuecomment-153927167).
+#[doc(hidden)]
+#[cfg(not(feature = "with-deprecated"))]
+macro_rules! sql_function_body {
+    ($($args:tt)*) => {
+        compile_error!("You are using a deprecated form of `sql_function!`. \
+        You must enable the `with-deprecated` feature on `diesel`.");
+    }
+}
+
+#[macro_export]
+#[doc(hidden)]
+macro_rules! __diesel_sql_function_body {
+    (
+        meta = ($($meta:tt)*),
+        fn_name = $fn_name:ident,
+        args = ($($arg_name:ident: $arg_type:ty),*),
+        return_type = $return_type:ty,
+    ) => {
+        $($meta)*
+        #[allow(non_camel_case_types)]
+        pub fn $fn_name<$($arg_name),*>($($arg_name: $arg_name),*)
+            -> $fn_name::HelperType<$($arg_name),*>
+        where
+            $($arg_name: $crate::expression::AsExpression<$arg_type>),+
+        {
+            $fn_name::$fn_name {
+                $($arg_name: $arg_name.as_expression()),+
+            }
+        }
+
+        #[doc(hidden)]
+        #[allow(non_camel_case_types, unused_imports)]
+        pub(crate) mod $fn_name {
+            use super::*;
+            use $crate::sql_types::*;
+
+            #[derive(Debug, Clone, Copy, QueryId)]
+            pub struct $fn_name<$($arg_name),*> {
+                $(pub(in super) $arg_name: $arg_name),*
+            }
+
+            pub type HelperType<$($arg_name),*> = $fn_name<$(
+                <$arg_name as $crate::expression::AsExpression<$arg_type>>::Expression
+            ),*>;
+
+            impl<$($arg_name),*> $crate::expression::Expression for $fn_name<$($arg_name),*> where
+                for <'a> ($(&'a $arg_name),*): $crate::expression::Expression,
+            {
+                type SqlType = $return_type;
+            }
+
+            impl<$($arg_name),*, DB> $crate::query_builder::QueryFragment<DB> for $fn_name<$($arg_name),*> where
+                DB: $crate::backend::Backend,
+                for<'a> ($(&'a $arg_name),*): $crate::query_builder::QueryFragment<DB>,
+            {
+                fn walk_ast(&self, mut out: $crate::query_builder::AstPass<DB>) -> $crate::result::QueryResult<()> {
+                    out.push_sql(concat!(stringify!($fn_name), "("));
+                    $crate::query_builder::QueryFragment::walk_ast(
+                        &($(&self.$arg_name),*), out.reborrow())?;
+                    out.push_sql(")");
+                    Ok(())
+                }
+            }
+
+            impl<$($arg_name),*, QS> $crate::expression::SelectableExpression<QS> for $fn_name<$($arg_name),*>
+            where
+                $($arg_name: $crate::expression::SelectableExpression<QS>,)*
+                Self: $crate::expression::AppearsOnTable<QS>,
+            {
+            }
+
+            impl<$($arg_name),*, QS> $crate::expression::AppearsOnTable<QS> for $fn_name<$($arg_name),*>
+            where
+                $($arg_name: $crate::expression::AppearsOnTable<QS>,)*
+                Self: $crate::expression::Expression,
+            {
+            }
+
+            impl<$($arg_name),*> $crate::expression::NonAggregate for $fn_name<$($arg_name),*>
+            where
+                $($arg_name: $crate::expression::NonAggregate,)*
+                Self: $crate::expression::Expression,
+            {
+            }
+        }
+    }
+}
+
+#[macro_export]
+/// Declare a sql function for use in your code.
 ///
-/// This will generate a rust function with the same name to construct the expression, and a helper
-/// type which represents the return type of that function. The function will automatically convert
-/// its arguments to expressions.
+/// Diesel only provides support for a very small number of SQL functions.
+/// This macro enables you to add additional functions from the SQL standard,
+/// as well as any custom functions your application might have.
+///
+/// The syntax for this macro is very similar to that of a normal Rust function,
+/// except the argument and return types will be the SQL types being used.
+/// Typically these types will come from [`diesel::sql_types`].
+///
+/// This macro will generate two items. A function with the name that you've
+/// given, and a module with a helper type representing the return type of your
+/// function. For example, this invocation:
+///
+/// ```ignore
+/// sql_function!(fn lower(x: Text) -> Text);
+/// ```
+///
+/// will generate this code:
+///
+/// ```ignore
+/// pub fn lower<X>(x: X) -> lower::HelperType<X> {
+///     ...
+/// }
+///
+/// pub(crate) mod lower {
+///     pub type HelperType<X> = ...;
+/// }
+/// ```
+///
+/// If you are using this macro for part of a library, where the function is
+/// part of your public API, it is highly recommended that you re-export this
+/// helper type with the same name as your function. This is the standard
+/// structure:
+///
+/// ```ignore
+/// pub mod functions {
+///     use super::types::*;
+///     use diesel::sql_types::*;
+///
+///     sql_function! {
+///         /// Represents the Pg `LENGTH` function used with `tsvector`s.
+///         fn length(x: TsVector) -> Integer;
+///     }
+/// }
+///
+/// pub mod helper_types {
+///     /// The return type of `length(expr)`
+///     pub type Length<Expr> = functions::length::HelperType<Expr>;
+/// }
+///
+/// pub mod dsl {
+///     pub use functions::*;
+///     pub use helper_types::*;
+/// }
+/// ```
+///
+/// Any attributes given to this macro will be put on the generated function
+/// (including doc comments).
 ///
 /// # Example
 ///
@@ -95,7 +236,13 @@ macro_rules! sql_function_body {
 /// #
 /// # table! { crates { id -> Integer, name -> VarChar, } }
 /// #
-/// sql_function!(canon_crate_name, canon_crate_name_t, (a: sql_types::VarChar) -> sql_types::VarChar);
+/// use diesel::sql_types::Text;
+///
+/// sql_function! {
+///     /// Represents the `canon_crate_name` SQL function, created in
+///     /// migration ....
+///     fn canon_crate_name(a: Text) -> Text;
+/// }
 ///
 /// # fn main() {
 /// # use self::crates::dsl::*;
@@ -106,6 +253,19 @@ macro_rules! sql_function_body {
 /// # }
 /// ```
 macro_rules! sql_function {
+    ($(#[$meta:meta])* fn $fn_name:ident $args:tt $(;)*) => {
+        sql_function!($(#[$meta])* fn $fn_name $args -> ());
+    };
+
+    ($(#[$meta:meta])* fn $fn_name:ident $args:tt -> $return_type:ty $(;)*) => {
+        __diesel_sql_function_body!(
+            meta = ($(#[$meta])*),
+            fn_name = $fn_name,
+            args = $args,
+            return_type = $return_type,
+        );
+    };
+
     ($fn_name:ident, $struct_name:ident, $args:tt -> $return_type:ty) => {
         sql_function!($fn_name, $struct_name, $args -> $return_type, "");
     };
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index 818487144..a899a03b3 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -65,6 +65,10 @@ pub mod dsl {
 
     #[cfg(feature = "postgres")]
     pub use pg::expression::dsl::*;
+
+    /// The return type of [`date(expr)`](../dsl/fn.date.html)
+    #[allow(non_camel_case_types)]
+    pub type date<Expr> = super::functions::date_and_time::date::HelperType<Expr>;
 }
 
 #[doc(inline)]
diff --git a/diesel/src/pg/connection/mod.rs b/diesel/src/pg/connection/mod.rs
index 2c2ca8f64..5f39eb5c2 100644
--- a/diesel/src/pg/connection/mod.rs
+++ b/diesel/src/pg/connection/mod.rs
@@ -233,7 +233,7 @@ mod tests {
     fn queries_with_identical_types_and_binds_but_different_sql_are_cached_separately() {
         let connection = connection();
 
-        sql_function!(lower, lower_t, (x: VarChar) -> VarChar);
+        sql_function!(fn lower(x: VarChar) -> VarChar);
         let hi = "HI".into_sql::<VarChar>();
         let query = ::select(hi).into_boxed::<Pg>();
         let query2 = ::select(lower(hi)).into_boxed::<Pg>();
diff --git a/diesel/src/sqlite/types/date_and_time/chrono.rs b/diesel/src/sqlite/types/date_and_time/chrono.rs
index 82a14b3a3..e7a1b03c8 100644
--- a/diesel/src/sqlite/types/date_and_time/chrono.rs
+++ b/diesel/src/sqlite/types/date_and_time/chrono.rs
@@ -121,9 +121,9 @@ mod tests {
     use prelude::*;
     use sql_types::{Date, Text, Time, Timestamp};
 
-    sql_function!(datetime, datetime_t, (x: Text) -> Timestamp);
-    sql_function!(time, time_t, (x: Text) -> Time);
-    sql_function!(date, date_t, (x: Text) -> Date);
+    sql_function!(fn datetime(x: Text) -> Timestamp);
+    sql_function!(fn time(x: Text) -> Time);
+    sql_function!(fn date(x: Text) -> Date);
 
     fn connection() -> SqliteConnection {
         dotenv().ok();
diff --git a/diesel_compile_tests/tests/compile-fail/pg_on_conflict_requires_valid_conflict_target.rs b/diesel_compile_tests/tests/compile-fail/pg_on_conflict_requires_valid_conflict_target.rs
index 6c4169eb8..db75eda3e 100644
--- a/diesel_compile_tests/tests/compile-fail/pg_on_conflict_requires_valid_conflict_target.rs
+++ b/diesel_compile_tests/tests/compile-fail/pg_on_conflict_requires_valid_conflict_target.rs
@@ -21,7 +21,7 @@ table! {
 #[table_name = "users"]
 pub struct NewUser(#[column_name = "name"] &'static str);
 
-sql_function!(lower, lower_t, (x: diesel::sql_types::Text) -> diesel::sql_types::Text);
+sql_function!(fn lower(x: diesel::sql_types::Text) -> diesel::sql_types::Text);
 
 fn main() {
     use self::users::dsl::*;
@@ -38,7 +38,7 @@ fn main() {
     let expression_using_column_from_other_table = insert_into(users)
         .values(&NewUser("Sean"))
         .on_conflict(lower(posts::title));
-        //~^ ERROR the trait bound `lower_t<posts::columns::title>: diesel::Column` is not satisfied
+        //~^ ERROR the trait bound `lower::lower<posts::columns::title>: diesel::Column` is not satisfied
 
     let random_non_expression = insert_into(users)
         .values(&NewUser("Sean"))
diff --git a/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs b/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs
index b313c36ba..03792c872 100644
--- a/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs
+++ b/diesel_compile_tests/tests/compile-fail/pg_specific_expressions_cant_be_used_in_a_sqlite_query.rs
@@ -11,7 +11,7 @@ table! {
     }
 }
 
-sql_function!(lower, lower_t, (x: VarChar) -> VarChar);
+sql_function!(fn lower(x: VarChar) -> VarChar);
 
 #[derive(Insertable)]
 #[table_name="users"]
diff --git a/diesel_compile_tests/tests/compile-fail/right_side_of_left_join_requires_nullable.rs b/diesel_compile_tests/tests/compile-fail/right_side_of_left_join_requires_nullable.rs
index 7021278fe..ec0ee9f4a 100644
--- a/diesel_compile_tests/tests/compile-fail/right_side_of_left_join_requires_nullable.rs
+++ b/diesel_compile_tests/tests/compile-fail/right_side_of_left_join_requires_nullable.rs
@@ -20,7 +20,7 @@ table! {
 
 joinable!(posts -> users (user_id));
 allow_tables_to_appear_in_same_query!(posts, users);
-sql_function!(lower, lower_t, (x: Text) -> Text);
+sql_function!(fn lower(x: Text) -> Text);
 
 fn main() {
     let conn = PgConnection::establish("some url").unwrap();
diff --git a/diesel_compile_tests/tests/compile-fail/user_defined_functions_follow_same_selection_rules.rs b/diesel_compile_tests/tests/compile-fail/user_defined_functions_follow_same_selection_rules.rs
index 15527785f..24a02aa34 100644
--- a/diesel_compile_tests/tests/compile-fail/user_defined_functions_follow_same_selection_rules.rs
+++ b/diesel_compile_tests/tests/compile-fail/user_defined_functions_follow_same_selection_rules.rs
@@ -23,8 +23,8 @@ struct User {
     name: String,
 }
 
-sql_function!(foo, foo_t, (x: Integer) -> Integer);
-sql_function!(bar, bar_t, (x: VarChar) -> VarChar);
+sql_function!(fn foo(x: Integer) -> Integer);
+sql_function!(fn bar(x: VarChar) -> VarChar);
 
 fn main() {
     use self::users::name;
diff --git a/diesel_tests/tests/annotations.rs b/diesel_tests/tests/annotations.rs
index e653a3172..4427b64f9 100644
--- a/diesel_tests/tests/annotations.rs
+++ b/diesel_tests/tests/annotations.rs
@@ -1,4 +1,5 @@
 use diesel::*;
+use diesel::sql_types::{Integer, Text};
 use schema::*;
 
 #[test]
@@ -288,15 +289,15 @@ fn derive_insertable_with_option_for_not_null_field_with_default() {
     assert_eq!(Some(&User::new(123, "Bob")), bob);
 }
 
+sql_function!(fn nextval(a: Text) -> Integer);
+
 #[test]
 #[cfg(feature = "postgres")]
 fn derive_insertable_with_field_that_cannot_convert_expression_to_nullable() {
-    use diesel::sql_types::{Serial, Text};
-    sql_function!(nextval, nextval_t, (a: Text) -> Serial);
     #[derive(Insertable)]
     #[table_name = "users"]
     struct NewUser {
-        id: nextval<&'static str>,
+        id: nextval::HelperType<&'static str>,
         name: &'static str,
     }
 
diff --git a/diesel_tests/tests/expressions/mod.rs b/diesel_tests/tests/expressions/mod.rs
index 4bbe40023..0411c27d3 100644
--- a/diesel_tests/tests/expressions/mod.rs
+++ b/diesel_tests/tests/expressions/mod.rs
@@ -216,7 +216,7 @@ fn test_min() {
     assert_eq!(Ok(None::<i32>), source.first(&connection));
 }
 
-sql_function!(coalesce, coalesce_t, (x: sql_types::Nullable<sql_types::VarChar>, y: sql_types::VarChar) -> sql_types::VarChar);
+sql_function!(fn coalesce(x: sql_types::Nullable<sql_types::VarChar>, y: sql_types::VarChar) -> sql_types::VarChar);
 
 #[test]
 fn function_with_multiple_arguments() {
@@ -436,7 +436,7 @@ fn test_arrays_a() {
 #[cfg(feature = "postgres")]
 fn test_arrays_b() {
     use diesel::sql_types::{Array, Int4};
-    sql_function!(unnest, unnest_t, (a: Array<Int4>) -> Int4);
+    sql_function!(fn unnest(a: Array<Int4>) -> Int4);
 
     use self::numbers::columns::*;
     use self::numbers::table as numbers;
diff --git a/diesel_tests/tests/filter.rs b/diesel_tests/tests/filter.rs
index a46aae3a7..cbe5a2ee9 100644
--- a/diesel_tests/tests/filter.rs
+++ b/diesel_tests/tests/filter.rs
@@ -366,7 +366,7 @@ fn not_affects_arguments_passed_when_they_contain_higher_operator_precedence() {
 }
 
 use diesel::sql_types::VarChar;
-sql_function!(lower, lower_t, (x: VarChar) -> VarChar);
+sql_function!(fn lower(x: VarChar) -> VarChar);
 
 #[test]
 fn filter_by_boxed_predicate() {
diff --git a/diesel_tests/tests/joins.rs b/diesel_tests/tests/joins.rs
index bf69bfc10..0d5bae39a 100644
--- a/diesel_tests/tests/joins.rs
+++ b/diesel_tests/tests/joins.rs
@@ -334,7 +334,7 @@ fn selecting_complex_expression_from_right_side_of_left_join() {
         .values(&new_posts)
         .execute(&connection)
         .unwrap();
-    sql_function!(lower, lower_t, (x: Text) -> Text);
+    sql_function!(fn lower(x: Text) -> Text);
 
     let titles = users::table
         .left_outer_join(posts::table)
diff --git a/diesel_tests/tests/macros.rs b/diesel_tests/tests/macros.rs
index 334758882..5422ef110 100644
--- a/diesel_tests/tests/macros.rs
+++ b/diesel_tests/tests/macros.rs
@@ -7,7 +7,7 @@ use schema::*;
 use diesel::*;
 use diesel::sql_types::{BigInt, VarChar};
 
-sql_function!(my_lower, my_lower_t, (x: VarChar) -> VarChar);
+sql_function!(fn my_lower(x: VarChar) -> VarChar);
 
 #[test]
 fn test_sql_function() {
@@ -40,8 +40,8 @@ fn test_sql_function() {
     );
 }
 
-sql_function!(setval, setval_t, (x: VarChar, y: BigInt));
-sql_function!(currval, currval_t, (x: VarChar) -> BigInt);
+sql_function!(fn setval(x: VarChar, y: BigInt));
+sql_function!(fn currval(x: VarChar) -> BigInt);
 
 #[test]
 fn sql_function_without_return_type() {
diff --git a/diesel_tests/tests/schema.rs b/diesel_tests/tests/schema.rs
index ef602c7ee..5984bc4c6 100644
--- a/diesel_tests/tests/schema.rs
+++ b/diesel_tests/tests/schema.rs
@@ -246,7 +246,7 @@ pub fn drop_table_cascade(connection: &TestConnection, table: &str) {
         .unwrap();
 }
 
-sql_function!(nextval, nextval_t, (a: sql_types::VarChar) -> sql_types::BigInt);
+sql_function!(fn nextval(a: sql_types::VarChar) -> sql_types::BigInt);
 
 pub fn connection_with_sean_and_tess_in_users_table() -> TestConnection {
     let connection = connection();
