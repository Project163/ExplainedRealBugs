diff --git a/diesel/src/deserialize.rs b/diesel/src/deserialize.rs
index 0e35bf996..4994e5a5d 100644
--- a/diesel/src/deserialize.rs
+++ b/diesel/src/deserialize.rs
@@ -434,9 +434,9 @@ where
 
 impl<T, ST, DB> StaticallySizedRow<ST, DB> for T
 where
-    ST: SqlType + crate::type_impls::tuples::TupleSize,
+    ST: SqlType + crate::util::TupleSize,
     T: Queryable<ST, DB>,
     DB: Backend,
 {
-    const FIELD_COUNT: usize = <ST as crate::type_impls::tuples::TupleSize>::SIZE;
+    const FIELD_COUNT: usize = <ST as crate::util::TupleSize>::SIZE;
 }
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index ba74fee81..1af1f954f 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -444,6 +444,34 @@ impl<'a, T: ValidGrouping<GB> + ?Sized, GB> ValidGrouping<GB> for &'a T {
 #[doc(inline)]
 pub use diesel_derives::ValidGrouping;
 
+#[doc(hidden)]
+pub trait IsContainedInGroupBy<T> {
+    type Output;
+}
+
+#[doc(hidden)]
+#[allow(missing_debug_implementations, missing_copy_implementations)]
+pub mod is_contained_in_group_by {
+    pub struct Yes;
+    pub struct No;
+
+    pub trait IsAny<O> {
+        type Output;
+    }
+
+    impl<T> IsAny<T> for Yes {
+        type Output = Yes;
+    }
+
+    impl IsAny<Yes> for No {
+        type Output = Yes;
+    }
+
+    impl IsAny<No> for No {
+        type Output = No;
+    }
+}
+
 /// Can two `IsAggregate` types appear in the same expression?
 ///
 /// You should never implement this trait. It will eventually become a trait
diff --git a/diesel/src/macros/mod.rs b/diesel/src/macros/mod.rs
index 7a8360f75..b6f5407e3 100644
--- a/diesel/src/macros/mod.rs
+++ b/diesel/src/macros/mod.rs
@@ -4,6 +4,7 @@
 pub(crate) mod prelude {
     #[doc(inline)]
     pub use crate::{
+        allow_columns_to_appear_in_same_group_by_clause,
         allow_tables_to_appear_in_same_query,
         joinable,
         table,
@@ -86,12 +87,18 @@ macro_rules! __diesel_column {
         {
         }
 
+        impl<__GB> $crate::expression::ValidGrouping<__GB> for $column_name
+        where __GB: $crate::expression::IsContainedInGroupBy<$column_name, Output = $crate::expression::is_contained_in_group_by::Yes>,
+        {
+            type IsAggregate = $crate::expression::is_aggregate::Yes;
+        }
+
         impl $crate::expression::ValidGrouping<()> for $column_name {
             type IsAggregate = $crate::expression::is_aggregate::No;
         }
 
-        impl $crate::expression::ValidGrouping<$column_name> for $column_name {
-            type IsAggregate = $crate::expression::is_aggregate::Yes;
+        impl $crate::expression::IsContainedInGroupBy<$column_name> for $column_name {
+            type Output = $crate::expression::is_contained_in_group_by::Yes;
         }
 
         impl $crate::query_source::Column for $column_name {
@@ -838,11 +845,59 @@ macro_rules! __diesel_table_impl {
                     ty = ($($column_ty)*),
                     $($column)*
                 })+
+
+                $crate::__diesel_valid_grouping_for_table_columns! {
+                    primary_key = $primary_key, $($column_name,)*
+                }
             }
         }
     }
 }
 
+#[macro_export]
+#[doc(hidden)]
+macro_rules! __diesel_valid_grouping_for_table_columns {
+    (primary_key = ($primary_key: tt), $($cols: ident,)* ) => {
+        $crate::__diesel_valid_grouping_for_table_columns! {
+            primary_key = $primary_key,
+            $($cols,)*
+        }
+    };
+    (primary_key = $primary_key: tt, $left_col: ident, $($right_col: ident,)+) => {
+        $(
+            $crate::static_cond! {
+                if $left_col == $primary_key {
+                    impl $crate::expression::IsContainedInGroupBy<$right_col> for $left_col {
+                        type Output = $crate::expression::is_contained_in_group_by::Yes;
+                    }
+                } else {
+                    impl $crate::expression::IsContainedInGroupBy<$right_col> for $left_col {
+                        type Output = $crate::expression::is_contained_in_group_by::No;
+                    }
+                }
+            }
+
+            $crate::static_cond! {
+                if $right_col == $primary_key {
+                    impl $crate::expression::IsContainedInGroupBy<$left_col> for $right_col {
+                        type Output = $crate::expression::is_contained_in_group_by::Yes;
+                    }
+                } else {
+                    impl $crate::expression::IsContainedInGroupBy<$left_col> for $right_col {
+                        type Output = $crate::expression::is_contained_in_group_by::No;
+                    }
+                }
+            }
+       )*
+        $crate::__diesel_valid_grouping_for_table_columns! {
+            primary_key = $primary_key,
+            $($right_col,)*
+        }
+    };
+    (primary_key = $primary_key: tt, $left_col: ident,) => {};
+    (primary_key = $primary_key: tt) => {};
+}
+
 #[macro_export]
 #[doc(hidden)]
 macro_rules! __diesel_table_query_source_impl {
@@ -1008,7 +1063,7 @@ macro_rules! joinable_inner {
 /// in a subselect. When this macro is invoked with more than 2 tables, every
 /// combination of those tables will be allowed to appear together.
 ///
-/// If you are using `infer_schema!` or `diesel print-schema`, an invocation of
+/// If you are using `diesel print-schema`, an invocation of
 /// this macro will be generated for you for all tables in your schema.
 ///
 /// # Example
@@ -1051,6 +1106,181 @@ macro_rules! allow_tables_to_appear_in_same_query {
     () => {};
 }
 
+#[doc(hidden)]
+#[macro_export(local_inner_macros)]
+macro_rules! __diesel_impl_allow_in_same_group_by_clause {
+    (
+        left = [$($left_path:tt)::+],
+    ) => {};
+    (
+        left = [$($left_path:tt)::+],
+        $($right_path:tt)::+
+    ) => {
+        __diesel_impl_allow_in_same_group_by_clause! {
+            left = [$($left_path)+],
+            right = [$($right_path)+],
+            left_tbl = [],
+            left_path = [],
+        }
+    };
+    (
+        left = [$($left_path:tt)::+],
+        $($right_path:tt)::+,
+        $($other:tt)*
+    ) => {
+        __diesel_impl_allow_in_same_group_by_clause! {
+            left = [$($left_path)+],
+            right = [$($right_path)+],
+            left_tbl = [],
+            left_path = [],
+        }
+        __diesel_impl_allow_in_same_group_by_clause! {
+            left = [$($left_path)::+],
+            $($other)*
+        }
+    };
+    (
+        left = [$left_path_p1: tt  $($left_path: tt)+],
+        right = [$($right_path: tt)*],
+        left_tbl = [$($left_tbl:tt)?],
+        left_path = [$($left_out_path:tt)*],
+    ) => {
+        __diesel_impl_allow_in_same_group_by_clause! {
+            left = [$($left_path)+],
+            right = [$($right_path)*],
+            left_tbl = [$left_path_p1],
+            left_path = [$($left_out_path)* $($left_tbl)?],
+        }
+    };
+    (
+        left = [$left_col: tt],
+        right = [$($right_path: tt)*],
+        left_tbl = [$($left_tbl:tt)?],
+        left_path = [$($left_out_path:tt)*],
+    ) => {
+        __diesel_impl_allow_in_same_group_by_clause! {
+            left = [$left_col],
+            right = [$($right_path)*],
+            left_tbl = [$($left_tbl)?],
+            left_path = [$($left_out_path)*],
+            right_tbl = [],
+            right_path = [],
+        }
+    };
+    (
+        left = [$left_col: tt ],
+        right = [$right_path_p1: tt  $($right_path: tt)+],
+        left_tbl = [$($left_tbl:tt)?],
+        left_path = [$($left_out_path:tt)*],
+        right_tbl = [$($right_tbl:tt)?],
+        right_path = [$($right_out_path:tt)*],
+    ) => {
+        __diesel_impl_allow_in_same_group_by_clause! {
+            left = [$left_col],
+            right = [$($right_path)+],
+            left_tbl = [$($left_tbl)?],
+            left_path = [$($left_out_path)*],
+            right_tbl = [$right_path_p1],
+            right_path = [$($right_out_path)* $($right_tbl)?],
+        }
+    };
+    (
+        left = [$left_col: tt],
+        right = [$right_col: tt],
+        left_tbl = [$left_tbl:tt],
+        left_path = [$($left_begin:tt)*],
+        right_tbl = [$right_tbl:tt],
+        right_path = [$($right_begin:tt)*],
+    ) => {
+        $crate::static_cond! {
+            if $left_tbl != $right_tbl {
+                impl $crate::expression::IsContainedInGroupBy<$($left_begin ::)* $left_tbl :: $left_col> for $($right_begin ::)* $right_tbl :: $right_col {
+                    type Output = $crate::expression::is_contained_in_group_by::No;
+                }
+
+                impl $crate::expression::IsContainedInGroupBy<$($right_begin ::)* $right_tbl :: $right_col> for $($left_begin ::)* $left_tbl :: $left_col {
+                    type Output = $crate::expression::is_contained_in_group_by::No;
+                }
+            }
+        }
+    };
+    (
+        left = [$left_col: tt],
+        right = [$right_col: tt],
+        left_tbl = [$($left_tbl:tt)?],
+        left_path = [$($left_begin:tt)*],
+        right_tbl = [$($right_tbl:tt)?],
+        right_path = [$($right_begin:tt)*],
+    ) => {
+        impl $crate::expression::IsContainedInGroupBy<$($left_begin ::)* $($left_tbl ::)? $left_col> for $($right_begin ::)* $($right_tbl ::)? $right_col {
+            type Output = $crate::expression::is_contained_in_group_by::No;
+        }
+
+        impl $crate::expression::IsContainedInGroupBy<$($right_begin ::)* $($right_tbl ::)? $right_col> for $($left_begin ::)* $($left_tbl ::)? $left_col {
+            type Output = $crate::expression::is_contained_in_group_by::No;
+        }
+    };
+
+}
+
+
+/// Allow two or more columns which are otherwise unrelated to be used together
+/// in a group by clause.
+///
+/// This macro must be invoked any time two columns need to appear in the same
+/// group by clause. When this macro is invoked with more than 2 columns, every
+/// combination of those columns will be allowed to appear together.
+///
+/// # Example
+///
+/// ```ignore
+/// // This would be required to do
+/// // `users::table.inner_join(posts::table).group_by((users::name, users::hair_color, posts::id))`
+/// allow_columns_to_appear_in_same_group_by_clause!(users::name, users::hair_color, posts::id);
+/// ```
+///
+/// When more than two columns are passed, the relevant code is generated for
+/// every combination of those columns. This code would be equivalent to the
+/// previous example.
+///
+/// ```ignore
+/// allow_columns_to_appear_in_same_group_by_clause!(users::name, users::hair_color);
+/// allow_columns_to_appear_in_same_group_by_clause!(users::name, posts::id);
+/// allow_columns_to_appear_in_same_group_by_clause!(users::hair_color, posts::id);
+/// ```
+#[macro_export(local_inner_macros)]
+macro_rules! allow_columns_to_appear_in_same_group_by_clause {
+    ($($left_path:tt)::+, $($right_path:tt)::+ $(,)?) => {
+        __diesel_impl_allow_in_same_group_by_clause! {
+            left = [$($left_path)::+],
+            $($right_path)::+,
+        }
+    };
+    ($($left_path:tt)::+, $($right_path:tt)::+, $($other: tt)*) => {
+        __diesel_impl_allow_in_same_group_by_clause! {
+            left = [$($left_path)::+],
+            $($right_path)::+,
+            $($other)*
+        }
+        allow_columns_to_appear_in_same_group_by_clause! {
+            $($right_path)::+,
+            $($other)*
+        }
+    };
+    ($last_col:ty,) => {};
+    () => {};
+}
+
+#[macro_export]
+#[doc(hidden)]
+macro_rules! __diesel_with_dollar_sign {
+    ($($body:tt)*) => {
+        macro_rules! __with_dollar_sign { $($body)* }
+        __with_dollar_sign!($);
+    }
+}
+
+
 // The order of these modules is important (at least for those which have tests).
 // Utility macros which don't call any others need to come first.
 #[macro_use]
@@ -1224,4 +1454,55 @@ mod tests {
             crate::debug_query::<Sqlite, _>(&bar::table.select(bar::id)).to_string()
         );
     }
+
+    mod tests_for_allow_combined_group_by_syntax {
+        table! {
+            a(b) {
+                b -> Text,
+                c -> Text,
+                d -> Text,
+                e -> Text,
+            }
+        }
+
+        table! {
+            b(a) {
+                a -> Text,
+                c -> Text,
+                d -> Text,
+            }
+        }
+
+        table! {
+            c(a) {
+                a -> Text,
+                b -> Text,
+                d -> Text,
+            }
+        }
+
+        // allow using table::collumn
+        allow_columns_to_appear_in_same_group_by_clause!(
+            a::b, b::a, a::d,
+        );
+
+        // allow using full paths
+        allow_columns_to_appear_in_same_group_by_clause!(
+            self::a::c, self::b::c, self::b::d,
+        );
+
+        use self::a::d as a_d;
+        use self::b::d as b_d;
+        use self::c::d as c_d;
+
+        // allow using plain identifiers
+        allow_columns_to_appear_in_same_group_by_clause!(
+            a_d, b_d, c_d
+        );
+
+        // allow mixing all variants
+        allow_columns_to_appear_in_same_group_by_clause!(
+            c_d, self::b::a, a::e,
+        );
+    }
 }
diff --git a/diesel/src/type_impls/tuples.rs b/diesel/src/type_impls/tuples.rs
index edf313025..9ebad84ed 100644
--- a/diesel/src/type_impls/tuples.rs
+++ b/diesel/src/type_impls/tuples.rs
@@ -2,8 +2,8 @@ use crate::associations::BelongsTo;
 use crate::backend::Backend;
 use crate::deserialize::{self, FromSqlRow, FromStaticSqlRow, Queryable, StaticallySizedRow};
 use crate::expression::{
-    AppearsOnTable, AsExpression, AsExpressionList, Expression, QueryMetadata,
-    SelectableExpression, TypedExpressionType, ValidGrouping,
+    is_contained_in_group_by, AppearsOnTable, AsExpression, AsExpressionList, Expression,
+    IsContainedInGroupBy, QueryMetadata, SelectableExpression, TypedExpressionType, ValidGrouping,
 };
 use crate::insertable::{CanInsertInSingleQuery, InsertValues, Insertable};
 use crate::query_builder::*;
@@ -11,11 +11,7 @@ use crate::query_source::*;
 use crate::result::QueryResult;
 use crate::row::*;
 use crate::sql_types::{HasSqlType, IntoNullable, Nullable, OneIsNullable, SqlType};
-use crate::util::TupleAppend;
-
-pub trait TupleSize {
-    const SIZE: usize;
-}
+use crate::util::{TupleAppend, TupleSize};
 
 impl<T> TupleSize for T
 where
@@ -107,6 +103,8 @@ macro_rules! tuple_impls {
                 struct TupleWrapper<$($T,)*>(($($T,)*));
             };
 
+            impl_valid_grouping_for_tuple_of_columns!($($T,)*);
+
             impl<$($T,)+ Tab> UndecoratedInsertRecord<Tab> for ($($T,)+)
             where
                 $($T: UndecoratedInsertRecord<Tab>,)+
@@ -394,6 +392,62 @@ macro_rules! impl_from_sql_row {
     }
 }
 
+macro_rules! impl_valid_grouping_for_tuple_of_columns {
+    (
+        @build
+        start_ts = [$($ST: ident,)*],
+        ts = [$T1: ident,],
+        bounds = [$($bounds: tt)*],
+        is_aggregate = [$($is_aggregate: tt)*],
+    ) => {
+        impl<$($ST,)* Col> IsContainedInGroupBy<Col> for ($($ST,)*)
+        where Col: Column,
+            $($ST: IsContainedInGroupBy<Col>,)*
+            $($bounds)*
+            <$T1 as IsContainedInGroupBy<Col>>::Output: is_contained_in_group_by::IsAny<$($is_aggregate)*>,
+        {
+            type Output = <<$T1 as IsContainedInGroupBy<Col>>::Output as is_contained_in_group_by::IsAny<$($is_aggregate)*>>::Output;
+        }
+    };
+    (
+        @build
+        start_ts = [$($ST: ident,)*],
+        ts = [$T1: ident, $($T: ident,)+],
+        bounds = [$($bounds: tt)*],
+        is_aggregate = [$($is_aggregate: tt)*],
+    ) => {
+        impl_valid_grouping_for_tuple_of_columns! {
+            @build
+            start_ts = [$($ST,)*],
+            ts = [$($T,)*],
+            bounds = [
+                $($bounds)*
+                <$T1 as IsContainedInGroupBy<Col>>::Output: is_contained_in_group_by::IsAny<$($is_aggregate)*>,
+            ],
+            is_aggregate = [
+                <<$T1 as IsContainedInGroupBy<Col>>::Output as is_contained_in_group_by::IsAny<$($is_aggregate)*>>::Output
+            ],
+        }
+    };
+    ($T1: ident, $($T: ident,)+) => {
+        impl_valid_grouping_for_tuple_of_columns! {
+            @build
+            start_ts = [$T1, $($T,)*],
+            ts = [$($T,)*],
+            bounds = [],
+            is_aggregate = [<$T1 as IsContainedInGroupBy<Col>>::Output],
+        }
+    };
+    ($T1: ident,) => {
+        impl<$T1, Col> IsContainedInGroupBy<Col> for ($T1,)
+        where Col: Column,
+              $T1: IsContainedInGroupBy<Col>
+        {
+            type Output = <$T1 as IsContainedInGroupBy<Col>>::Output;
+        }
+    };
+}
+
 macro_rules! impl_sql_type {
     (
         @build
diff --git a/diesel/src/util.rs b/diesel/src/util.rs
index 70e8d6b07..ed0439d49 100644
--- a/diesel/src/util.rs
+++ b/diesel/src/util.rs
@@ -5,3 +5,7 @@ pub trait TupleAppend<T> {
 
     fn tuple_append(self, right: T) -> Self::Output;
 }
+
+pub trait TupleSize {
+    const SIZE: usize;
+}
diff --git a/diesel_compile_tests/tests/compile-fail/cannot_load_default_select_with_group_by.rs b/diesel_compile_tests/tests/compile-fail/cannot_load_default_select_with_group_by.rs
index 5c7bd9a87..84394e4f9 100644
--- a/diesel_compile_tests/tests/compile-fail/cannot_load_default_select_with_group_by.rs
+++ b/diesel_compile_tests/tests/compile-fail/cannot_load_default_select_with_group_by.rs
@@ -1,8 +1,8 @@
 #[macro_use]
 extern crate diesel;
 
-use diesel::*;
 use diesel::dsl::count;
+use diesel::*;
 
 table! {
     users {
@@ -13,7 +13,8 @@ table! {
 
 fn main() {
     let conn = PgConnection::establish("").unwrap();
-    let _ = users::table.group_by(users::name)
+    let _ = users::table
+        .group_by(users::name)
         .load::<(i32, String)>(&conn);
-    //~^ ERROR ValidGrouping
+    //~^ ERROR IsContainedInGroupBy
 }
diff --git a/diesel_compile_tests/tests/compile-fail/select_requires_valid_grouping.rs b/diesel_compile_tests/tests/compile-fail/select_requires_valid_grouping.rs
new file mode 100644
index 000000000..ac08a8adc
--- /dev/null
+++ b/diesel_compile_tests/tests/compile-fail/select_requires_valid_grouping.rs
@@ -0,0 +1,110 @@
+#[macro_use]
+extern crate diesel;
+use diesel::prelude::*;
+
+table! {
+    users {
+        id -> Integer,
+        name -> Text,
+        hair_color -> Nullable<Text>,
+    }
+}
+
+table! {
+    posts {
+        id -> Integer,
+        title -> Text,
+        user_id -> Integer,
+    }
+}
+
+table! {
+    comments {
+        id -> Integer,
+        text -> Text,
+        post_id -> Integer,
+    }
+}
+
+joinable!(comments -> posts (post_id));
+joinable!(posts -> users (user_id));
+
+allow_tables_to_appear_in_same_query!(users, posts, comments);
+allow_columns_to_appear_in_same_group_by_clause!(
+    posts::title,
+    users::id,
+    posts::user_id,
+    users::name,
+    posts::id,
+    users::hair_color
+);
+
+fn main() {
+    use diesel::dsl;
+    // cases thas should compile
+
+    // A column appering in the group by clause should be considered valid for the select clause
+    let source = users::table.group_by(users::name).select(users::name);
+    // If the column appearing in the group by clause is the primary key, any column of that table is a
+    // valid group by clause
+    let source = users::table.group_by(users::id).select(users::name);
+    let source = users::table
+        .group_by(users::id)
+        .select((users::name, users::hair_color));
+    // It's valid to use a aggregate function on a column that does not appear in the group by clause)
+    let source = users::table
+        .group_by(users::name)
+        .select(dsl::max(users::id));
+    // If the group by clause consists of multiple columns it's fine for the select clause to contain
+    // any of those
+    let source = users::table
+        .group_by((users::name, users::hair_color))
+        .select(users::name);
+    let source = users::table
+        .group_by((users::name, users::hair_color))
+        .select(users::hair_color);
+    let source = users::table
+        .group_by((users::name, users::hair_color))
+        .select((users::name, users::hair_color));
+    // It's fine to select all columns of a table as long as the primary key appears in the group by clause
+    let source = users::table
+        .inner_join(posts::table)
+        .group_by(users::id)
+        .select(users::all_columns);
+    // This also work for group by clauses with multiple columns
+    let source = users::table
+        .inner_join(posts::table)
+        .group_by((users::id, posts::title))
+        .select((users::all_columns, posts::title));
+    let source = users::table
+        .inner_join(posts::table.inner_join(comments::table))
+        .group_by((users::id, posts::id))
+        .select((users::all_columns, posts::all_columns));
+
+    // cases that should fail to compile
+    let source = users::table.group_by(users::name).select(users::id);
+    //~^ ERROR IsContainedInGroupBy
+    let source = users::table
+        .group_by((users::name, users::hair_color))
+        .select(users::id);
+    //~^ ERROR IsContainedInGroupBy
+    let source = users::table
+        .group_by(users::name)
+        .select((users::name, users::id));
+    //~^ ERROR IsContainedInGroupBy
+    let source = users::table
+        .group_by((users::name, users::hair_color))
+        .select(users::id);
+    //~^ ERROR IsContainedInGroupBy
+    let source = users::table
+        .inner_join(posts::table)
+        .group_by((users::id, posts::title))
+        .select((users::all_columns, posts::id));
+    //~^ ERROR IsContainedInGroupBy
+    let source = users::table
+        .inner_join(posts::table.inner_join(comments::table))
+        .group_by((users::id, posts::id))
+        .select((users::all_columns, posts::all_columns, comments::id));
+    //~^ ERROR IsContainedInGroupBy
+    //~| E0277
+}
diff --git a/diesel_tests/tests/group_by.rs b/diesel_tests/tests/group_by.rs
index 4d29ef24c..8b9f8f512 100644
--- a/diesel_tests/tests/group_by.rs
+++ b/diesel_tests/tests/group_by.rs
@@ -23,6 +23,9 @@ fn group_by_generates_group_by_sql() {
         expected_sql,
         debug_query::<TestBackend, _>(&source).to_string()
     );
+    let conn = connection();
+
+    assert!(source.execute(&conn).is_ok());
 }
 
 #[test]
@@ -45,6 +48,10 @@ fn group_by_mixed_aggregate_column_and_aggregate_function() {
         expected_sql,
         debug_query::<TestBackend, _>(&source).to_string()
     );
+
+    let conn = connection();
+
+    assert!(source.execute(&conn).is_ok());
 }
 
 #[test]
@@ -67,4 +74,116 @@ fn boxed_queries_have_group_by_method() {
     }
 
     assert_eq!(expected_sql, debug_query(&source).to_string());
+
+    let conn = connection();
+
+    assert!(source.execute(&conn).is_ok());
+}
+
+#[test]
+fn check_group_by_primary_key_allows_other_columns_in_select_clause() {
+    let source = users::table
+        .group_by(users::id)
+        .select(users::name)
+        .filter(users::hair_color.is_null());
+
+    let mut expected_sql = "SELECT `users`.`name` FROM `users` \
+                            WHERE (`users`.`hair_color` IS NULL) \
+                            GROUP BY `users`.`id` \
+                            -- binds: []"
+        .to_string();
+
+    if cfg!(feature = "postgres") {
+        expected_sql = expected_sql.replace('`', "\"");
+    }
+
+    assert_eq!(expected_sql, debug_query(&source).to_string());
+
+    let conn = connection();
+
+    assert!(source.execute(&conn).is_ok());
+}
+
+#[test]
+fn check_group_by_multiple_columns_in_group_by_clause_single_select() {
+    let source = users::table
+        .group_by((users::name, users::hair_color))
+        .select(users::name)
+        .filter(users::id.nullable().is_null());
+
+    let mut expected_sql = "SELECT `users`.`name` \
+                            FROM `users` WHERE (`users`.`id` IS NULL) \
+                            GROUP BY `users`.`name`, `users`.`hair_color` \
+                            -- binds: []"
+        .to_string();
+
+    if cfg!(feature = "postgres") {
+        expected_sql = expected_sql.replace('`', "\"");
+    }
+
+    assert_eq!(expected_sql, debug_query(&source).to_string());
+
+    let conn = connection();
+
+    assert!(source.execute(&conn).is_ok());
+}
+
+#[test]
+fn check_group_by_multiple_columns_in_group_by_clause_complex_select() {
+    let source = users::table
+        .group_by((users::name, users::hair_color))
+        .select((users::name, users::hair_color, diesel::dsl::max(users::id)))
+        .filter(users::id.nullable().is_null());
+
+    let mut expected_sql = "SELECT `users`.`name`, `users`.`hair_color`, max(`users`.`id`) \
+                            FROM `users` WHERE (`users`.`id` IS NULL) \
+                            GROUP BY `users`.`name`, `users`.`hair_color` \
+                            -- binds: []"
+        .to_string();
+
+    if cfg!(feature = "postgres") {
+        expected_sql = expected_sql.replace('`', "\"");
+    }
+
+    assert_eq!(expected_sql, debug_query(&source).to_string());
+
+    let conn = connection();
+
+    assert!(source.execute(&conn).is_ok());
+}
+
+diesel::allow_columns_to_appear_in_same_group_by_clause!(
+    posts::id,
+    users::id,
+    posts::title,
+    users::name
+);
+
+#[test]
+fn check_group_by_multiple_tables() {
+    let source = users::table
+        .inner_join(posts::table.inner_join(comments::table))
+        .group_by((users::id, posts::id))
+        .select((users::name, posts::title, diesel::dsl::count(comments::id)))
+        .filter(comments::text.nullable().is_null());
+
+    let mut expected_sql = "SELECT `users`.`name`, `posts`.`title`, count(`comments`.`id`) \
+                            FROM (`users` \
+                            INNER JOIN (`posts` \
+                            INNER JOIN `comments` ON (`comments`.`post_id` = `posts`.`id`)) \
+                            ON (`posts`.`user_id` = `users`.`id`)) \
+                            WHERE (`comments`.`text` IS NULL) \
+                            GROUP BY `users`.`id`, `posts`.`id` \
+                            -- binds: []"
+        .to_string();
+
+    if cfg!(feature = "postgres") {
+        expected_sql = expected_sql.replace('`', "\"");
+    }
+
+    assert_eq!(expected_sql, debug_query(&source).to_string());
+
+    let conn = connection();
+
+    assert!(source.execute(&conn).is_ok());
 }
