diff --git a/CHANGELOG.md b/CHANGELOG.md
index 216c063b2..ba27e646b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -22,10 +22,28 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
   The generated module will still be called `table_1`.
 
+* Added support for batch insert on SQLite. This means that you can now pass a
+  slice or vector to [`diesel::insert`][insert] on all backends.
+
+[insert]: http://docs.diesel.rs/diesel/fn.insert.html
+
 ### Fixed
 
 * `#[derive(Identifiable)]` now works on structs with lifetimes
 
+* Attempting to insert an empty slice will no longer panic. It does not execute
+  any queries, but the result will indicate that we successfully inserted 0
+  rows.
+
+* Attempting to update a record with no changes will no longer generate invalid
+  SQL. The result of attempting to execute the query will still be an error, but
+  but it will be a `Error::QueryBuilderError`, rather than a database error.
+  This means that it will not abort the current transaction, and can be handled
+  by applications.
+
+* Calling `eq_any` or `ne_any` with an empty array no longer panics.
+  `eq_any(vec![])` will return no rows. `ne_any(vec![])` will return all rows.
+
 ## [0.8.2] - 2016-11-22
 
 ### Changed
diff --git a/diesel/src/doctest_setup.rs b/diesel/src/doctest_setup.rs
index d41328402..738bc27cf 100644
--- a/diesel/src/doctest_setup.rs
+++ b/diesel/src/doctest_setup.rs
@@ -1,9 +1,6 @@
 extern crate dotenv;
 
-use diesel::backend;
-use diesel::persistable::{InsertValues};
 use diesel::prelude::*;
-use diesel::query_builder::{QueryBuilder, BuildQueryResult};
 use self::dotenv::dotenv;
 
 #[cfg(feature = "postgres")]
diff --git a/diesel/src/expression/array_comparison.rs b/diesel/src/expression/array_comparison.rs
index ac0a4f31b..07429d5e3 100644
--- a/diesel/src/expression/array_comparison.rs
+++ b/diesel/src/expression/array_comparison.rs
@@ -73,13 +73,17 @@ impl<T, U> NonAggregate for NotIn<T, U> where
 impl<T, U, DB> QueryFragment<DB> for In<T, U> where
     DB: Backend,
     T: QueryFragment<DB>,
-    U: QueryFragment<DB>,
+    U: QueryFragment<DB> + MaybeEmpty,
 {
     fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
-        try!(self.left.to_sql(out));
-        out.push_sql(" IN (");
-        try!(self.values.to_sql(out));
-        out.push_sql(")");
+        if self.values.is_empty() {
+            out.push_sql("1=0");
+        } else {
+            try!(self.left.to_sql(out));
+            out.push_sql(" IN (");
+            try!(self.values.to_sql(out));
+            out.push_sql(")");
+        }
         Ok(())
     }
 
@@ -120,7 +124,7 @@ use std::marker::PhantomData;
 use query_builder::SelectStatement;
 
 pub trait AsInExpression<T> {
-    type InExpression: Expression<SqlType=T>;
+    type InExpression: MaybeEmpty + Expression<SqlType=T>;
 
     fn as_in_expression(self) -> Self::InExpression;
 }
@@ -138,6 +142,10 @@ impl<I, T, ST> AsInExpression<ST> for I where
     }
 }
 
+pub trait MaybeEmpty {
+    fn is_empty(&self) -> bool;
+}
+
 impl<ST, S, F, W, O, L, Of> AsInExpression<ST>
     for SelectStatement<ST, S, F, W, O, L, Of> where
         SelectStatement<ST, S, F, W, O, L, Of>: Expression,
@@ -156,6 +164,12 @@ impl<T: Expression> Expression for Many<T> {
     type SqlType = T::SqlType;
 }
 
+impl<T> MaybeEmpty for Many<T> {
+    fn is_empty(&self) -> bool {
+        self.0.is_empty()
+    }
+}
+
 impl<T, QS> SelectableExpression<QS> for Many<T> where
     Many<T>: Expression,
     T: SelectableExpression<QS>,
@@ -199,6 +213,12 @@ impl<T: Expression, ST> Expression for Subselect<T, ST> {
     type SqlType = ST;
 }
 
+impl<T, ST> MaybeEmpty for Subselect<T, ST> {
+    fn is_empty(&self) -> bool {
+        false
+    }
+}
+
 impl<T, ST, QS> SelectableExpression<QS> for Subselect<T, ST> where
     Subselect<T, ST>: Expression,
     T: SelectableExpression<QS>,
diff --git a/diesel/src/expression/expression_methods/global_expression_methods.rs b/diesel/src/expression/expression_methods/global_expression_methods.rs
index 970c9e60a..7a0683f15 100644
--- a/diesel/src/expression/expression_methods/global_expression_methods.rs
+++ b/diesel/src/expression/expression_methods/global_expression_methods.rs
@@ -101,6 +101,10 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #         ('Jim')").unwrap();
     /// let data = users.select(id).filter(name.eq_any(vec!["Sean", "Jim"]));
     /// assert_eq!(Ok(vec![1, 3]), data.load(&connection));
+    ///
+    /// // Calling `eq_any` with an empty array is the same as doing `WHERE 1=0`
+    /// let data = users.select(id).filter(name.eq_any(Vec::<String>::new()));
+    /// assert_eq!(Ok(vec![]), data.load::<i32>(&connection));
     /// # }
     /// ```
     fn eq_any<T>(self, values: T) -> In<Self, T::InExpression> where
@@ -134,8 +138,13 @@ pub trait ExpressionMethods: Expression + Sized {
     /// #         ('Jim')").unwrap();
     /// let data = users.select(id).filter(name.ne_any(vec!["Sean", "Jim"]));
     /// assert_eq!(Ok(vec![2]), data.load(&connection));
+    ///
     /// let data = users.select(id).filter(name.ne_any(vec!["Tess"]));
     /// assert_eq!(Ok(vec![1, 3]), data.load(&connection));
+    ///
+    /// // Calling `ne_any` with an empty array is the same as doing `WHERE 1=1`
+    /// let data = users.select(id).filter(name.ne_any(Vec::<String>::new()));
+    /// assert_eq!(Ok(vec![1, 2, 3]), data.load(&connection));
     /// # }
     /// ```
     fn ne_any<T>(self, values: T) -> NotIn<Self, T::InExpression> where
