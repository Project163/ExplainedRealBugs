diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7bfd83bac..483f4149f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -26,6 +26,11 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 * Struct fields annotated with `#[column_name="name"]` should be changed to
   `#[column_name(name)]`.
 
+### Fixed
+
+* `&&[T]` can now be used in queries. This allows using slices with things like
+  `#[insertable_into]`.
+
 ## [0.6.1] 2016-04-14
 
 ### Added
diff --git a/diesel/src/macros/insertable.rs b/diesel/src/macros/insertable.rs
index 6e3dc7458..1aea72c5e 100644
--- a/diesel/src/macros/insertable.rs
+++ b/diesel/src/macros/insertable.rs
@@ -435,6 +435,31 @@ mod tests {
         assert_eq!(Ok(expected), saved);
     }
 
+    // FIXME: This can be moved into the function once `pub` is allowed
+    #[cfg(feature = "postgres")]
+    table! {
+        posts {
+            id -> Serial,
+            tags -> Array<Text>,
+        }
+    }
+
+    #[cfg(feature = "postgres")]
+    #[test]
+    fn insertable_with_slice_of_borrowed() {
+        struct NewPost<'a> { tags: &'a [&'a str], }
+        Insertable! { (posts) struct NewPost<'a> { tags: &'a [&'a str], } }
+
+        let conn = ::test_helpers::pg_helpers::connection();
+        conn.execute("DROP TABLE IF EXISTS posts").unwrap();
+        conn.execute("CREATE TABLE posts (id SERIAL PRIMARY KEY, tags TEXT[] NOT NULL)").unwrap();
+        let new_post = NewPost { tags: &["hi", "there"] };
+        ::insert(&new_post).into(posts::table).execute(&conn).unwrap();
+
+        let saved = posts::table.select(posts::tags).load::<Vec<String>>(&conn);
+        let expected = vec![vec![String::from("hi"), String::from("there")]];
+        assert_eq!(Ok(expected), saved);
+    }
 
     #[cfg(feature = "sqlite")]
     fn connection() -> ::test_helpers::TestConnection {
diff --git a/diesel/src/pg/types/array.rs b/diesel/src/pg/types/array.rs
index 3ea78e538..ddb479a88 100644
--- a/diesel/src/pg/types/array.rs
+++ b/diesel/src/pg/types/array.rs
@@ -102,6 +102,8 @@ macro_rules! array_as_expression {
 
 array_as_expression!(&'a [T], Array<ST>);
 array_as_expression!(&'a [T], Nullable<Array<ST>>);
+array_as_expression!(&'a &'a [T], Array<ST>);
+array_as_expression!(&'a &'a [T], Nullable<Array<ST>>);
 array_as_expression!(Vec<T>, Array<ST>);
 array_as_expression!(Vec<T>, Nullable<Array<ST>>);
 array_as_expression!(&'a Vec<T>, Array<ST>);
diff --git a/diesel/src/test_helpers.rs b/diesel/src/test_helpers.rs
index 486c863f3..6ff0ace2e 100644
--- a/diesel/src/test_helpers.rs
+++ b/diesel/src/test_helpers.rs
@@ -1,5 +1,5 @@
 #[cfg(feature = "sqlite")]
-mod database_specific_helpers {
+pub mod sqlite_helpers {
     use prelude::*;
     use sqlite::SqliteConnection;
 
@@ -10,8 +10,8 @@ mod database_specific_helpers {
     }
 }
 
-#[cfg(all(feature = "postgres", not(feature = "sqlite")))]
-mod database_specific_helpers {
+#[cfg(feature = "postgres")]
+pub mod pg_helpers {
     extern crate dotenv;
 
     use self::dotenv::dotenv;
@@ -32,4 +32,8 @@ mod database_specific_helpers {
     }
 }
 
-pub use self::database_specific_helpers::*;
+#[cfg(all(feature = "postgres", not(feature = "sqlite")))]
+pub use self::pg_helpers::*;
+
+#[cfg(feature = "sqlite")]
+pub use self::sqlite_helpers::*;
