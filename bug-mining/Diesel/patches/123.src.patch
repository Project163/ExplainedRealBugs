diff --git a/diesel/src/insertable.rs b/diesel/src/insertable.rs
index 253352749..9ccc4e3b5 100644
--- a/diesel/src/insertable.rs
+++ b/diesel/src/insertable.rs
@@ -48,7 +48,13 @@ pub trait InsertValues<T: Table, DB: Backend> {
 #[derive(Debug, Copy, Clone)]
 pub enum ColumnInsertValue<Col, Expr> {
     Expression(Col, Expr),
-    Default(Col),
+    Default,
+}
+
+impl<Col, Expr> Default for ColumnInsertValue<Col, Expr> {
+    fn default() -> Self {
+        ColumnInsertValue::Default
+    }
 }
 
 impl<Col, Expr, DB> InsertValues<Col::Table, DB> for ColumnInsertValue<Col, Expr>
@@ -110,6 +116,7 @@ where
     Tab: Table,
     DB: Backend,
     BatchInsertValues<'a, T>: InsertValues<Tab, DB>,
+    &'a T: UndecoratedInsertRecord<Tab>,
 {
     type Values = BatchInsertValues<'a, T>;
 
@@ -121,7 +128,6 @@ where
 impl<'a, T, DB> CanInsertInSingleQuery<DB> for &'a [T]
 where
     DB: Backend + SupportsDefaultKeyword,
-    &'a T: UndecoratedInsertRecord<T>,
 {
     fn rows_to_insert(&self) -> usize {
         self.len()
@@ -160,6 +166,23 @@ where
     }
 }
 
+impl<'a, T, Tab, DB> Insertable<Tab, DB> for &'a Option<T>
+where
+    Tab: Table,
+    DB: Backend,
+    &'a T: Insertable<Tab, DB>,
+    <&'a T as Insertable<Tab, DB>>::Values: Default,
+{
+    type Values = <&'a T as Insertable<Tab, DB>>::Values;
+
+    fn values(self) -> Self::Values {
+        match *self {
+            Some(ref v) => v.values(),
+            None => Default::default(),
+        }
+    }
+}
+
 #[derive(Debug, Clone)]
 pub struct BatchInsertValues<'a, T: 'a> {
     records: &'a [T],
diff --git a/diesel/src/macros/insertable.rs b/diesel/src/macros/insertable.rs
index 379088a33..a8fafd9d3 100644
--- a/diesel/src/macros/insertable.rs
+++ b/diesel/src/macros/insertable.rs
@@ -216,7 +216,7 @@ macro_rules! Insertable_column_expr {
     ($column:path, $field_access:expr, option) => {
         match *$field_access {
             Some(ref value) => Insertable_column_expr!($column, value, regular),
-            None => ColumnInsertValue::Default($column),
+            None => ColumnInsertValue::Default,
         }
     };
 
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index 3cb40ee1b..d19e4f5a9 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -183,6 +183,43 @@ pub fn delete<T: IntoUpdateTarget>(source: T) -> DeleteStatement<T::Table, T::Wh
 /// # }
 /// ```
 ///
+/// ### Using a tuple for values
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # include!("../doctest_setup.rs");
+/// #
+/// # table! {
+/// #     users {
+/// #         id -> Integer,
+/// #         name -> Text,
+/// #     }
+/// # }
+/// #
+/// # fn main() {
+/// #     use self::users::dsl::*;
+/// #     let connection = establish_connection();
+/// #     diesel::delete(users).execute(&connection).unwrap();
+/// let new_user = (id.eq(1), name.eq("Sean"));
+/// let rows_inserted = diesel::insert(&new_user)
+///     .into(users)
+///     .execute(&connection);
+///
+/// assert_eq!(Ok(1), rows_inserted);
+///
+/// let new_users = vec![
+///     (id.eq(2), name.eq("Tess")),
+///     (id.eq(2), name.eq("Jim")),
+/// ];
+///
+/// let rows_inserted = diesel::insert(&new_users)
+///     .into(users)
+///     .execute(&connection);
+///
+/// // assert_eq!(Ok(2), rows_inserted);
+/// # }
+/// ```
+///
 /// ### Using struct for values
 ///
 /// ```rust
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement.rs
index 671d5f204..e5af404ba 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement.rs
@@ -279,6 +279,12 @@ where
 {
 }
 
+impl<'a, Lhs, Rhs, Tab> UndecoratedInsertRecord<Tab> for &'a Option<Eq<Lhs, Rhs>>
+where
+    &'a Eq<Lhs, Rhs>: UndecoratedInsertRecord<Tab>,
+{
+}
+
 #[derive(Debug, Clone, Copy)]
 #[doc(hidden)]
 pub struct DefaultValues;
diff --git a/diesel/src/types/impls/tuples.rs b/diesel/src/types/impls/tuples.rs
index 8d52b5184..11d168003 100644
--- a/diesel/src/types/impls/tuples.rs
+++ b/diesel/src/types/impls/tuples.rs
@@ -3,8 +3,9 @@ use std::error::Error;
 use associations::BelongsTo;
 use backend::Backend;
 use expression::{AppearsOnTable, Expression, NonAggregate, SelectableExpression};
-use insertable::InsertValues;
+use insertable::{CanInsertInSingleQuery, InsertValues, Insertable};
 use query_builder::*;
+use query_builder::insert_statement::UndecoratedInsertRecord;
 use query_source::{QuerySource, Queryable, Table};
 use result::QueryResult;
 use row::Row;
@@ -85,6 +86,38 @@ macro_rules! tuple_impls {
             impl<$($T: Expression + NonAggregate),+> NonAggregate for ($($T,)+) {
             }
 
+            impl<'a, $($T,)+ Tab> UndecoratedInsertRecord<Tab> for &'a ($($T,)+)
+            where
+                $(&'a $T: UndecoratedInsertRecord<Tab>,)+
+            {
+            }
+
+            impl<'a, $($T,)+ DB> CanInsertInSingleQuery<DB> for &'a ($($T,)+)
+            where
+                DB: Backend,
+                $(&'a $T: CanInsertInSingleQuery<DB>,)+
+            {
+                fn rows_to_insert(&self) -> usize {
+                    $(debug_assert_eq!((&self.$idx).rows_to_insert(), 1);)+
+                    1
+                }
+            }
+
+            impl<'a, $($T,)+ Tab, DB> Insertable<Tab, DB> for &'a ($($T,)+)
+            where
+                Tab: Table,
+                DB: Backend,
+                $(&'a $T: Insertable<Tab, DB> + UndecoratedInsertRecord<Tab>,)+
+            {
+                type Values = ($(
+                    <&'a $T as Insertable<Tab, DB>>::Values,
+                )+);
+
+                fn values(self) -> Self::Values {
+                    ($(self.$idx.values(),)+)
+                }
+            }
+
             #[allow(unused_assignments)]
             impl<$($T,)+ Tab, DB> InsertValues<Tab, DB> for ($($T,)+)
             where
diff --git a/diesel_compile_tests/tests/compile-fail/default_values_cannot_be_used_in_tuple_insert.rs b/diesel_compile_tests/tests/compile-fail/default_values_cannot_be_used_in_tuple_insert.rs
new file mode 100644
index 000000000..4f0c91aca
--- /dev/null
+++ b/diesel_compile_tests/tests/compile-fail/default_values_cannot_be_used_in_tuple_insert.rs
@@ -0,0 +1,24 @@
+#[macro_use]
+extern crate diesel;
+
+use diesel::*;
+use diesel::pg::PgConnection;
+
+table! {
+    users {
+        id -> Integer,
+        name -> Text,
+        hair_color -> Text,
+    }
+}
+
+fn main() {
+    use users::dsl::*;
+    let conn = PgConnection::establish("").unwrap();
+
+    ExecuteDsl::execute(
+    //~^ ERROR ExecuteDsl
+        insert(&(default_values(), name.eq("Sean"))).into(users),
+        &conn,
+    );
+}
diff --git a/diesel_compile_tests/tests/compile-fail/insert_cannot_reference_columns_from_other_table.rs b/diesel_compile_tests/tests/compile-fail/insert_cannot_reference_columns_from_other_table.rs
index 0c22c43d3..735e97b8e 100644
--- a/diesel_compile_tests/tests/compile-fail/insert_cannot_reference_columns_from_other_table.rs
+++ b/diesel_compile_tests/tests/compile-fail/insert_cannot_reference_columns_from_other_table.rs
@@ -24,4 +24,10 @@ fn main() {
         .execute(&conn)
         //~^ ERROR E0599
         .unwrap();
+
+    insert(&(posts::id.eq(1), users::id.eq(2)))
+        .into(users::table)
+        .execute(&conn)
+        //~^ ERROR E0599
+        .unwrap();
 }
diff --git a/diesel_compile_tests/tests/compile-fail/upsert_cannot_be_nested.rs b/diesel_compile_tests/tests/compile-fail/upsert_cannot_be_nested.rs
index a70238536..7d2b88ad8 100644
--- a/diesel_compile_tests/tests/compile-fail/upsert_cannot_be_nested.rs
+++ b/diesel_compile_tests/tests/compile-fail/upsert_cannot_be_nested.rs
@@ -33,4 +33,6 @@ fn main() {
     //~^ ERROR E0599
     insert(&vec![&NewUser("Sean").on_conflict(id, do_nothing())]).into(users).execute(&connection);
     //~^ ERROR E0599
+    insert(&(name.eq("Sean").on_conflict_do_nothing(),)).into(users).execute(&connection);
+    //~^ ERROR E0599
 }
diff --git a/diesel_tests/tests/insert.rs b/diesel_tests/tests/insert.rs
index 665bd6512..5c04c6c5b 100644
--- a/diesel_tests/tests/insert.rs
+++ b/diesel_tests/tests/insert.rs
@@ -411,3 +411,121 @@ fn insert_multiple_bare_values() {
     let actual_names = users.select(name).load(&connection);
     assert_eq!(Ok(expected_names), actual_names);
 }
+
+#[test]
+fn insert_single_tuple() {
+    use schema::users::dsl::*;
+    let connection = connection();
+
+    insert(&(name.eq("Sean"), hair_color.eq("Brown")))
+        .into(users)
+        .execute(&connection)
+        .unwrap();
+
+    let expected_data = vec![("Sean".to_string(), Some("Brown".to_string()))];
+    let actual_data = users.select((name, hair_color)).load(&connection);
+    assert_eq!(Ok(expected_data), actual_data);
+}
+
+#[test]
+#[should_panic] // FIXME: We need to rejigger where the parens are added for values
+fn insert_nested_tuples() {
+    use schema::users::dsl::*;
+    let connection = connection();
+
+    insert(&(id.eq(1), (name.eq("Sean"), hair_color.eq("Brown"))))
+        .into(users)
+        .execute(&connection)
+        .unwrap();
+
+    let expected_data = vec![User::with_hair_color(1, "Sean", "Brown")];
+    let actual_data = users.load(&connection);
+    assert_eq!(Ok(expected_data), actual_data);
+}
+
+#[test]
+#[should_panic] // FIXME: We need to rejigger where the parens are added for values
+fn insert_mixed_tuple_and_insertable_struct() {
+    use schema::users::dsl::*;
+    let connection = connection();
+
+    let new_user = NewUser::new("Sean", Some("Brown"));
+    insert(&(id.eq(3), new_user))
+        .into(users)
+        .execute(&connection)
+        .unwrap();
+
+    let expected_data = vec![User::with_hair_color(3, "Sean", "Brown")];
+    let actual_data = users.load(&connection);
+    assert_eq!(Ok(expected_data), actual_data);
+}
+
+#[test]
+fn insert_multiple_tuples() {
+    use schema::users::dsl::*;
+    let connection = connection();
+
+    let new_users = vec![
+        (name.eq("Sean"), hair_color.eq("Brown")),
+        (name.eq("Tess"), hair_color.eq("Green")),
+    ];
+    insert(&new_users).into(users).execute(&connection).unwrap();
+
+    let expected_data = vec![
+        ("Sean".to_string(), Some("Brown".to_string())),
+        ("Tess".to_string(), Some("Green".to_string())),
+    ];
+    let actual_data = users.select((name, hair_color)).load(&connection);
+    assert_eq!(Ok(expected_data), actual_data);
+}
+
+#[test]
+fn insert_optional_field_with_null() {
+    use schema::users::dsl::*;
+    let connection = connection();
+
+    let new_users = vec![
+        (name.eq("Sean"), hair_color.eq(Some("Brown"))),
+        (name.eq("Tess"), hair_color.eq(None)),
+    ];
+    insert(&new_users).into(users).execute(&connection).unwrap();
+
+    let expected_data = vec![
+        ("Sean".to_string(), Some("Brown".to_string())),
+        ("Tess".to_string(), None),
+    ];
+    let actual_data = users.select((name, hair_color)).load(&connection);
+    assert_eq!(Ok(expected_data), actual_data);
+}
+
+#[test]
+#[cfg(not(feature = "mysql"))]
+#[cfg_attr(feature = "postgres", should_panic)] // FIXME: We need to rejigger where the parens are added for values
+fn insert_optional_field_with_default() {
+    use schema::users::dsl::*;
+    use schema_dsl::*;
+    let connection = connection();
+    drop_table_cascade(&connection, "users");
+    create_table(
+        "users",
+        (
+            integer("id").primary_key().auto_increment(),
+            string("name").not_null(),
+            string("hair_color").not_null().default("'Green'"),
+        ),
+    ).execute(&connection)
+        .unwrap();
+
+    let new_users = vec![
+        (name.eq("Sean"), Some(hair_color.eq("Brown"))),
+        (name.eq("Tess"), None),
+    ];
+    insert(&new_users).into(users).execute(&connection).unwrap();
+
+    let expected_data = vec![
+        ("Sean".to_string(), Some("Brown".to_string())),
+        ("Tess".to_string(), Some("Green".to_string())),
+    ];
+    let actual_data = users.select((name, hair_color)).load(&connection);
+    assert_eq!(Ok(expected_data), actual_data);
+}
