diff --git a/diesel/src/pg/metadata_lookup.rs b/diesel/src/pg/metadata_lookup.rs
index 8de80c256..9d8167bcc 100644
--- a/diesel/src/pg/metadata_lookup.rs
+++ b/diesel/src/pg/metadata_lookup.rs
@@ -3,6 +3,7 @@
 use super::{PgConnection, PgTypeMetadata};
 use crate::prelude::*;
 
+use std::borrow::Cow;
 use std::cell::RefCell;
 use std::collections::HashMap;
 
@@ -24,26 +25,87 @@ impl PgMetadataLookup {
     /// This function should only be used for user defined types, or types which
     /// come from an extension. This function may perform a SQL query to look
     /// up the type. For built-in types, a static OID should be preferred.
-    pub fn lookup_type(&self, type_name: &str) -> PgTypeMetadata {
+    pub fn lookup_type(&self, type_name: &str, schema: Option<&str>) -> PgTypeMetadata {
         let metadata_cache = self.conn.get_metadata_cache();
-        metadata_cache.lookup_type(type_name).unwrap_or_else(|| {
-            use self::pg_type::dsl::*;
-
-            let type_metadata = pg_type
-                .select((oid, typarray))
-                .filter(typname.eq(type_name))
-                .first(&self.conn)
-                .unwrap_or_default();
-            metadata_cache.store_type(type_name, type_metadata);
-            type_metadata
+        let cache_key = PgMetadataCacheKey {
+            schema: schema.map(Cow::Borrowed),
+            type_name: Cow::Borrowed(type_name),
+        };
+
+        metadata_cache.lookup_type(&cache_key).unwrap_or_else(|| {
+            let r = lookup_type(&cache_key, &self.conn);
+
+            match r {
+                Ok(type_metadata) => {
+                    metadata_cache.store_type(cache_key, type_metadata);
+                    type_metadata
+                }
+                Err(_e) => {
+                    eprintln!("Failed to find oid for type `{}`", type_name);
+                    // We return 0 as type oid here
+                    // because most of the time postgres
+                    // can figure out the type on its own
+                    PgTypeMetadata {
+                        oid: 0,
+                        array_oid: 0,
+                    }
+                }
+            }
         })
     }
 }
 
+fn lookup_type(
+    cache_key: &PgMetadataCacheKey<'_>,
+    conn: &PgConnection,
+) -> QueryResult<PgTypeMetadata> {
+    let search_path: String;
+
+    let search_schema = if let Some(schema) = cache_key.schema.as_ref() {
+        vec![schema.as_ref()]
+    } else {
+        search_path = crate::dsl::sql("SHOW search_path").get_result::<String>(conn)?;
+
+        search_path
+            .split(',')
+            // skip the `$user` entry for now
+            .filter(|f| !f.starts_with("\"$"))
+            .map(|s| s.trim())
+            .collect()
+    };
+
+    let metadata = pg_type::table
+        .inner_join(pg_namespace::table)
+        .filter(pg_namespace::nspname.eq(crate::dsl::any(search_schema)))
+        .filter(pg_type::typname.eq(&cache_key.type_name))
+        .select((pg_type::oid, pg_type::typarray))
+        .first(conn)?;
+
+    Ok(metadata)
+}
+
+#[derive(Hash, PartialEq, Eq)]
+struct PgMetadataCacheKey<'a> {
+    schema: Option<Cow<'a, str>>,
+    type_name: Cow<'a, str>,
+}
+
+impl<'a> PgMetadataCacheKey<'a> {
+    fn as_owned(&self) -> PgMetadataCacheKey<'static> {
+        PgMetadataCacheKey {
+            schema: self
+                .schema
+                .as_ref()
+                .map(|schema| Cow::Owned(schema.as_ref().to_owned())),
+            type_name: Cow::Owned(self.type_name.as_ref().to_owned()),
+        }
+    }
+}
+
 /// Stores a cache for the OID of custom types
 #[allow(missing_debug_implementations)]
 pub struct PgMetadataCache {
-    cache: RefCell<HashMap<String, PgTypeMetadata>>,
+    cache: RefCell<HashMap<PgMetadataCacheKey<'static>, PgTypeMetadata>>,
 }
 
 impl PgMetadataCache {
@@ -53,14 +115,14 @@ impl PgMetadataCache {
         }
     }
 
-    fn lookup_type(&self, type_name: &str) -> Option<PgTypeMetadata> {
+    fn lookup_type(&self, type_name: &PgMetadataCacheKey) -> Option<PgTypeMetadata> {
         Some(*self.cache.borrow().get(type_name)?)
     }
 
-    fn store_type(&self, type_name: &str, type_metadata: PgTypeMetadata) {
+    fn store_type(&self, type_name: PgMetadataCacheKey, type_metadata: PgTypeMetadata) {
         self.cache
             .borrow_mut()
-            .insert(type_name.to_owned(), type_metadata);
+            .insert(type_name.as_owned(), type_metadata);
     }
 }
 
@@ -69,5 +131,16 @@ table! {
         oid -> Oid,
         typname -> Text,
         typarray -> Oid,
+        typnamespace -> Oid,
+    }
+}
+
+table! {
+    pg_namespace (oid) {
+        oid -> Oid,
+        nspname -> Text,
     }
 }
+
+joinable!(pg_type -> pg_namespace(typnamespace));
+allow_tables_to_appear_in_same_query!(pg_type, pg_namespace);
diff --git a/diesel_derives/src/lib.rs b/diesel_derives/src/lib.rs
index 0e4b60ed0..579279b8b 100644
--- a/diesel_derives/src/lib.rs
+++ b/diesel_derives/src/lib.rs
@@ -752,7 +752,7 @@ pub fn derive_queryable_by_name(input: TokenStream) -> TokenStream {
 /// You don't need to specify every backend,
 /// only the ones supported by your type.
 ///
-/// For PostgreSQL, add  `#[postgres(type_name = "pg_type_name")]`
+/// For PostgreSQL, add  `#[postgres(type_name = "pg_type_name", type_schema = "pg_schema_name")]`
 /// or `#[postgres(oid = "some_oid", array_oid = "some_oid")]` for
 /// builtin types.
 /// For MySQL, specify which variant of `MysqlType` should be used
@@ -764,9 +764,10 @@ pub fn derive_queryable_by_name(input: TokenStream) -> TokenStream {
 ///
 /// ## Type attributes
 ///
-/// * `#[postgres(type_name = "TypeName")]` specifies support for
-/// a postgresql type with the name `TypeName`. Prefer this variant
-/// for types with no stable OID (== everything but the builtin types)
+/// * `#[postgres(type_name = "TypeName", type_schema = "public")]` specifies support for
+/// a postgresql type with the name `TypeName` in the schema `public`. Prefer this variant
+/// for types with no stable OID (== everything but the builtin types). It's possible to leaf
+/// of the `type_schema` part. In that case diesel defaults to the default postgres search path.
 /// * `#[postgres(oid = 42, array_oid = 142)]`, specifies support for a
 /// postgresql type with the given `oid` and `array_oid`. This variant
 /// should only be used with types that have a stable OID.
diff --git a/diesel_derives/src/sql_type.rs b/diesel_derives/src/sql_type.rs
index 2f8ea7a2b..49d89d551 100644
--- a/diesel_derives/src/sql_type.rs
+++ b/diesel_derives/src/sql_type.rs
@@ -112,9 +112,14 @@ fn pg_tokens(item: &syn::DeriveInput) -> Option<proc_macro2::TokenStream> {
                         }
                     }
                 ),
-                PgType::Lookup(type_name) => quote!(
+                PgType::Lookup(type_name, Some(type_schema)) => quote!(
                     fn metadata(lookup: &PgMetadataLookup) -> PgTypeMetadata {
-                        lookup.lookup_type(#type_name)
+                        lookup.lookup_type(#type_name, Some(#type_schema))
+                    }
+                ),
+                PgType::Lookup(type_name, None) => quote!(
+                    fn metadata(lookup: &PgMetadataLookup) -> PgTypeMetadata {
+                        lookup.lookup_type(#type_name, None)
                     }
                 ),
             };
@@ -133,9 +138,13 @@ fn pg_tokens(item: &syn::DeriveInput) -> Option<proc_macro2::TokenStream> {
 }
 
 fn get_type_name(attr: &MetaItem) -> Result<Option<PgType>, Diagnostic> {
+    let schema = attr.nested_item("type_schema")?;
     Ok(attr.nested_item("type_name")?.map(|ty| {
-        attr.warn_if_other_options(&["type_name"]);
-        PgType::Lookup(ty.expect_str_value())
+        attr.warn_if_other_options(&["type_name", "type_schema"]);
+        PgType::Lookup(
+            ty.expect_str_value(),
+            schema.map(|schema| schema.expect_str_value()),
+        )
     }))
 }
 
@@ -155,5 +164,5 @@ fn get_oids(attr: &MetaItem) -> Result<Option<PgType>, Diagnostic> {
 
 enum PgType {
     Fixed { oid: u32, array_oid: u32 },
-    Lookup(String),
+    Lookup(String, Option<String>),
 }
diff --git a/diesel_tests/tests/custom_types.rs b/diesel_tests/tests/custom_types.rs
index 915e81703..5bb6f6a71 100644
--- a/diesel_tests/tests/custom_types.rs
+++ b/diesel_tests/tests/custom_types.rs
@@ -84,3 +84,83 @@ fn custom_types_round_trip() {
         .unwrap();
     assert_eq!(data, inserted);
 }
+
+table! {
+    use diesel::sql_types::*;
+    use super::MyTypeInCustomSchema;
+    custom_schema.custom_types_with_custom_schema {
+        id -> Integer,
+        custom_enum -> MyTypeInCustomSchema,
+    }
+}
+
+#[derive(SqlType)]
+#[postgres(type_name = "my_type", type_schema = "custom_schema")]
+pub struct MyTypeInCustomSchema;
+
+#[derive(Debug, PartialEq, FromSqlRow, AsExpression)]
+#[sql_type = "MyTypeInCustomSchema"]
+pub enum MyEnumInCustomSchema {
+    Foo,
+    Bar,
+}
+
+impl ToSql<MyTypeInCustomSchema, Pg> for MyEnumInCustomSchema {
+    fn to_sql<W: Write>(&self, out: &mut Output<W, Pg>) -> serialize::Result {
+        match *self {
+            MyEnumInCustomSchema::Foo => out.write_all(b"foo")?,
+            MyEnumInCustomSchema::Bar => out.write_all(b"bar")?,
+        }
+        Ok(IsNull::No)
+    }
+}
+
+impl FromSql<MyTypeInCustomSchema, Pg> for MyEnumInCustomSchema {
+    fn from_sql(bytes: PgValue<'_>) -> deserialize::Result<Self> {
+        match bytes.as_bytes() {
+            b"foo" => Ok(MyEnumInCustomSchema::Foo),
+            b"bar" => Ok(MyEnumInCustomSchema::Bar),
+            _ => Err("Unrecognized enum variant".into()),
+        }
+    }
+}
+
+#[derive(Insertable, Queryable, Identifiable, Debug, PartialEq)]
+#[table_name = "custom_types_with_custom_schema"]
+struct HasCustomTypesInCustomSchema {
+    id: i32,
+    custom_enum: MyEnumInCustomSchema,
+}
+
+#[test]
+fn custom_types_in_custom_schema_round_trip() {
+    let data = vec![
+        HasCustomTypesInCustomSchema {
+            id: 1,
+            custom_enum: MyEnumInCustomSchema::Foo,
+        },
+        HasCustomTypesInCustomSchema {
+            id: 2,
+            custom_enum: MyEnumInCustomSchema::Bar,
+        },
+    ];
+    let connection = connection();
+    connection
+        .batch_execute(
+            r#"
+        CREATE SCHEMA IF NOT EXISTS custom_schema;
+        CREATE TYPE custom_schema.my_type AS ENUM ('foo', 'bar');
+        CREATE TABLE custom_schema.custom_types_with_custom_schema (
+            id SERIAL PRIMARY KEY,
+            custom_enum custom_schema.my_type NOT NULL
+        );
+    "#,
+        )
+        .unwrap();
+
+    let inserted = insert_into(custom_types_with_custom_schema::table)
+        .values(&data)
+        .get_results(&connection)
+        .unwrap();
+    assert_eq!(data, inserted);
+}
