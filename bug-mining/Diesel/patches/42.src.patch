diff --git a/CHANGELOG.md b/CHANGELOG.md
index 903047881..76eec00f1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -9,6 +9,12 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 * `infer_schema!` is now supported for use with SQLite3.
 
+### Changed
+
+* `diesel::result::Error` now implements `Send` and `Sync`. This required a
+  change in the return type of `ToSql` and `FromSql` to have those bounds as
+  well.
+
 ## [0.5.4] 2016-03-23
 
 * Updated `diesel_codegen` to allow syntex versions up to 0.30.0.
diff --git a/diesel/src/pg/types/array.rs b/diesel/src/pg/types/array.rs
index fd14b2be5..e02a716c0 100644
--- a/diesel/src/pg/types/array.rs
+++ b/diesel/src/pg/types/array.rs
@@ -34,7 +34,7 @@ impl<T, ST> FromSql<Array<ST>, Pg> for Vec<T> where
     T: FromSql<ST, Pg>,
     Pg: HasSqlType<ST>,
 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let mut bytes = not_none!(bytes);
         let num_dimensions = try!(bytes.read_i32::<BigEndian>());
         let has_null = try!(bytes.read_i32::<BigEndian>()) != 0;
@@ -67,7 +67,7 @@ impl<T, ST> FromSqlRow<Array<ST>, Pg> for Vec<T> where
     Pg: HasSqlType<ST>,
     Vec<T>: FromSql<Array<ST>, Pg>,
 {
-    fn build_from_row<R: Row<Pg>>(row: &mut R) -> Result<Self, Box<Error>> {
+    fn build_from_row<R: Row<Pg>>(row: &mut R) -> Result<Self, Box<Error+Send+Sync>> {
         FromSql::<Array<ST>, Pg>::from_sql(row.take())
     }
 }
@@ -119,7 +119,7 @@ impl<'a, ST, T> ToSql<Array<ST>, Pg> for &'a [T] where
     Pg: HasSqlType<ST>,
     T: ToSql<ST, Pg>,
 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         let num_dimensions = 1;
         try!(out.write_i32::<BigEndian>(num_dimensions));
         let flags = 0;
@@ -146,7 +146,7 @@ impl<ST, T> ToSql<Array<ST>, Pg> for Vec<T> where
     Pg: HasSqlType<ST>,
     for<'a> &'a [T]: ToSql<Array<ST>, Pg>,
 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         (&self as &[T]).to_sql(out)
     }
 }
diff --git a/diesel/src/pg/types/date_and_time/chrono.rs b/diesel/src/pg/types/date_and_time/chrono.rs
index dd7368d5e..8f14fadcf 100644
--- a/diesel/src/pg/types/date_and_time/chrono.rs
+++ b/diesel/src/pg/types/date_and_time/chrono.rs
@@ -29,7 +29,7 @@ fn pg_epoch() -> NaiveDateTime {
 }
 
 impl FromSql<Timestamp, Pg> for NaiveDateTime {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let PgTimestamp(offset) = try!(FromSql::<Timestamp, Pg>::from_sql(bytes));
         match pg_epoch().checked_add(Duration::microseconds(offset)) {
             Some(v) => Ok(v),
@@ -42,7 +42,7 @@ impl FromSql<Timestamp, Pg> for NaiveDateTime {
 }
 
 impl ToSql<Timestamp, Pg> for NaiveDateTime {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         let time = match (*self - pg_epoch()).num_microseconds() {
             Some(time) => time,
             None => {
@@ -59,7 +59,7 @@ fn midnight() -> NaiveTime {
 }
 
 impl ToSql<Time, Pg> for NaiveTime {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         let duration = *self - midnight();
         match duration.num_microseconds() {
             Some(offset) => ToSql::<Time, Pg>::to_sql(&PgTime(offset), out),
@@ -69,7 +69,7 @@ impl ToSql<Time, Pg> for NaiveTime {
 }
 
 impl FromSql<Time, Pg> for NaiveTime {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let PgTime(offset) = try!(FromSql::<Time, Pg>::from_sql(bytes));
         let duration = Duration::microseconds(offset);
         Ok(midnight() + duration)
@@ -81,14 +81,14 @@ fn pg_epoch_date() -> NaiveDate {
 }
 
 impl ToSql<Date, Pg> for NaiveDate {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         let days_since_epoch = (*self - pg_epoch_date()).num_days();
         ToSql::<Date, Pg>::to_sql(&PgDate(days_since_epoch as i32), out)
     }
 }
 
 impl FromSql<Date, Pg> for NaiveDate {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let PgDate(offset) = try!(FromSql::<Date, Pg>::from_sql(bytes));
         match pg_epoch_date().checked_add(Duration::days(offset as i64)) {
             Some(date) => Ok(date),
diff --git a/diesel/src/pg/types/date_and_time/mod.rs b/diesel/src/pg/types/date_and_time/mod.rs
index 0dd306443..2ded5371d 100644
--- a/diesel/src/pg/types/date_and_time/mod.rs
+++ b/diesel/src/pg/types/date_and_time/mod.rs
@@ -103,46 +103,46 @@ impl HasSqlType<types::Timestamp> for Pg {
 }
 
 impl ToSql<types::Timestamp, Pg> for PgTimestamp {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         ToSql::<types::BigInt, Pg>::to_sql(&self.0, out)
     }
 }
 
 impl FromSql<types::Timestamp, Pg> for PgTimestamp {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         FromSql::<types::BigInt, Pg>::from_sql(bytes)
             .map(PgTimestamp)
     }
 }
 
 impl ToSql<types::Date, Pg> for PgDate {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         ToSql::<types::Integer, Pg>::to_sql(&self.0, out)
     }
 }
 
 impl FromSql<types::Date, Pg> for PgDate {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         FromSql::<types::Integer, Pg>::from_sql(bytes)
             .map(PgDate)
     }
 }
 
 impl ToSql<types::Time, Pg> for PgTime {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         ToSql::<types::BigInt, Pg>::to_sql(&self.0, out)
     }
 }
 
 impl FromSql<types::Time, Pg> for PgTime {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         FromSql::<types::BigInt, Pg>::from_sql(bytes)
             .map(PgTime)
     }
 }
 
 impl ToSql<types::Interval, Pg> for PgInterval {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         try!(ToSql::<types::BigInt, Pg>::to_sql(&self.microseconds, out));
         try!(ToSql::<types::Integer, Pg>::to_sql(&self.days, out));
         try!(ToSql::<types::Integer, Pg>::to_sql(&self.months, out));
@@ -151,7 +151,7 @@ impl ToSql<types::Interval, Pg> for PgInterval {
 }
 
 impl FromSql<types::Interval, Pg> for PgInterval {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let bytes = not_none!(bytes);
         Ok(PgInterval {
             microseconds: try!(FromSql::<types::BigInt, Pg>::from_sql(Some(&bytes[..8]))),
diff --git a/diesel/src/pg/types/date_and_time/std_time.rs b/diesel/src/pg/types/date_and_time/std_time.rs
index 6a6cc99e5..7a77bcbf7 100644
--- a/diesel/src/pg/types/date_and_time/std_time.rs
+++ b/diesel/src/pg/types/date_and_time/std_time.rs
@@ -19,7 +19,7 @@ fn pg_epoch() -> SystemTime {
 }
 
 impl ToSql<types::Timestamp, Pg> for SystemTime {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         let (before_epoch, duration) = match self.duration_since(pg_epoch()) {
             Ok(duration) => (false, duration),
             Err(time_err) => (true, time_err.duration()),
@@ -34,7 +34,7 @@ impl ToSql<types::Timestamp, Pg> for SystemTime {
 }
 
 impl FromSql<types::Timestamp, Pg> for SystemTime {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let usecs_passed = try!(<i64 as FromSql<types::BigInt, Pg>>::from_sql(bytes));
         let before_epoch = usecs_passed < 0;
         let time_passed = usecs_to_duration(usecs_passed.abs() as u64);
diff --git a/diesel/src/pg/types/floats/mod.rs b/diesel/src/pg/types/floats/mod.rs
index f58dc3774..d4fced06a 100644
--- a/diesel/src/pg/types/floats/mod.rs
+++ b/diesel/src/pg/types/floats/mod.rs
@@ -41,7 +41,7 @@ impl Error for InvalidNumericSign {
 }
 
 impl FromSql<types::Numeric, Pg> for PgNumeric {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let mut bytes = not_none!(bytes);
         let ndigits = try!(bytes.read_u16::<BigEndian>());
         let mut digits = Vec::with_capacity(ndigits as usize);
@@ -70,7 +70,7 @@ impl FromSql<types::Numeric, Pg> for PgNumeric {
 }
 
 impl ToSql<types::Numeric, Pg> for PgNumeric {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         let sign = match self {
             &PgNumeric::Positive { .. } => 0,
             &PgNumeric::Negative { .. } => 0x4000,
diff --git a/diesel/src/pg/types/integers.rs b/diesel/src/pg/types/integers.rs
index 82c37b9e7..e2e4aed95 100644
--- a/diesel/src/pg/types/integers.rs
+++ b/diesel/src/pg/types/integers.rs
@@ -10,14 +10,14 @@ use types::{self, ToSql, IsNull, FromSql};
 primitive_impls!(Oid -> (u32, pg: (26, 1018)));
 
 impl FromSql<types::Oid, Pg> for u32 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let mut bytes = not_none!(bytes);
         bytes.read_u32::<BigEndian>().map_err(|e| e.into())
     }
 }
 
 impl ToSql<types::Oid, Pg> for u32 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         out.write_u32::<BigEndian>(*self)
             .map(|_| IsNull::No)
             .map_err(|e| e.into())
diff --git a/diesel/src/pg/types/primitives.rs b/diesel/src/pg/types/primitives.rs
index 1e2c5743b..7a8983a37 100644
--- a/diesel/src/pg/types/primitives.rs
+++ b/diesel/src/pg/types/primitives.rs
@@ -8,7 +8,7 @@ use types::{self, ToSql, IsNull, FromSql};
 primitive_impls!(Numeric -> (PgNumeric, pg: (1700, 1231)));
 
 impl FromSql<types::Bool, Pg> for bool {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         match bytes {
             Some(bytes) => Ok(bytes[0] != 0),
             None => Ok(false),
@@ -17,7 +17,7 @@ impl FromSql<types::Bool, Pg> for bool {
 }
 
 impl ToSql<types::Bool, Pg> for bool {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         let write_result = if *self {
             out.write_all(&[1])
         } else {
@@ -25,7 +25,7 @@ impl ToSql<types::Bool, Pg> for bool {
         };
         write_result
             .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
+            .map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
diff --git a/diesel/src/query_builder/mod.rs b/diesel/src/query_builder/mod.rs
index 2558b1217..47edc5c15 100644
--- a/diesel/src/query_builder/mod.rs
+++ b/diesel/src/query_builder/mod.rs
@@ -31,7 +31,7 @@ use types::HasSqlType;
 
 #[doc(hidden)]
 pub type Binds = Vec<Option<Vec<u8>>>;
-pub type BuildQueryResult = Result<(), Box<Error>>;
+pub type BuildQueryResult = Result<(), Box<Error+Send+Sync>>;
 
 /// Apps should not need to concern themselves with this trait.
 ///
diff --git a/diesel/src/result.rs b/diesel/src/result.rs
index 69c56836b..14cdeca83 100644
--- a/diesel/src/result.rs
+++ b/diesel/src/result.rs
@@ -11,8 +11,8 @@ pub enum Error {
     InvalidCString(NulError),
     DatabaseError(String),
     NotFound,
-    QueryBuilderError(Box<StdError>),
-    DeserializationError(Box<StdError>),
+    QueryBuilderError(Box<StdError+Send+Sync>),
+    DeserializationError(Box<StdError+Send+Sync>),
     #[doc(hidden)]
     __Nonexhaustive,
 }
@@ -146,3 +146,11 @@ impl PartialEq for Error {
         }
     }
 }
+
+#[cfg(test)]
+#[allow(warnings)]
+fn error_impls_send_and_sync() {
+    let err: Error = unimplemented!();
+    let x: &Send = &err;
+    let x: &Sync = &err;
+}
diff --git a/diesel/src/sqlite/types/mod.rs b/diesel/src/sqlite/types/mod.rs
index b5f2b12e0..582d12978 100644
--- a/diesel/src/sqlite/types/mod.rs
+++ b/diesel/src/sqlite/types/mod.rs
@@ -8,57 +8,57 @@ use super::connection::SqliteValue;
 use types::{self, FromSql, ToSql, IsNull};
 
 impl FromSql<types::VarChar, Sqlite> for String {
-    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error+Send+Sync>> {
         let text = not_none!(value).read_text();
         Ok(text.into())
     }
 }
 
 impl FromSql<types::Binary, Sqlite> for Vec<u8> {
-    fn from_sql(bytes: Option<&SqliteValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&SqliteValue>) -> Result<Self, Box<Error+Send+Sync>> {
         let bytes = not_none!(bytes).read_blob();
         Ok(bytes.into())
     }
 }
 
 impl FromSql<types::SmallInt, Sqlite> for i16 {
-    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error+Send+Sync>> {
         Ok(not_none!(value).read_integer() as i16)
     }
 }
 
 impl FromSql<types::Integer, Sqlite> for i32 {
-    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error+Send+Sync>> {
         Ok(not_none!(value).read_integer())
     }
 }
 
 impl FromSql<types::Bool, Sqlite> for bool {
-    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error+Send+Sync>> {
         Ok(not_none!(value).read_integer() != 0)
     }
 }
 
 impl FromSql<types::BigInt, Sqlite> for i64 {
-    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error+Send+Sync>> {
         Ok(not_none!(value).read_long())
     }
 }
 
 impl FromSql<types::Float, Sqlite> for f32 {
-    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error+Send+Sync>> {
         Ok(not_none!(value).read_double() as f32)
     }
 }
 
 impl FromSql<types::Double, Sqlite> for f64 {
-    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(value: Option<&SqliteValue>) -> Result<Self, Box<Error+Send+Sync>> {
         Ok(not_none!(value).read_double())
     }
 }
 
 impl ToSql<types::Bool, Sqlite> for bool {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         let int_value = if *self {
             1
         } else {
diff --git a/diesel/src/types/impls/floats.rs b/diesel/src/types/impls/floats.rs
index e22d4c580..19f120160 100644
--- a/diesel/src/types/impls/floats.rs
+++ b/diesel/src/types/impls/floats.rs
@@ -8,31 +8,31 @@ use self::byteorder::{ReadBytesExt, WriteBytesExt, BigEndian};
 use types::{self, FromSql, ToSql, IsNull};
 
 impl<DB: Backend<RawValue=[u8]>> FromSql<types::Float, DB> for f32 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let mut bytes = not_none!(bytes);
-        bytes.read_f32::<BigEndian>().map_err(|e| Box::new(e) as Box<Error>)
+        bytes.read_f32::<BigEndian>().map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
 impl<DB: Backend> ToSql<types::Float, DB> for f32 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         out.write_f32::<BigEndian>(*self)
             .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
+            .map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
 impl<DB: Backend<RawValue=[u8]>> FromSql<types::Double, DB> for f64 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let mut bytes = not_none!(bytes);
-        bytes.read_f64::<BigEndian>().map_err(|e| Box::new(e) as Box<Error>)
+        bytes.read_f64::<BigEndian>().map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
 impl<DB: Backend> ToSql<types::Double, DB> for f64 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         out.write_f64::<BigEndian>(*self)
             .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
+            .map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
diff --git a/diesel/src/types/impls/integers.rs b/diesel/src/types/impls/integers.rs
index 6ada12ede..1fdb36052 100644
--- a/diesel/src/types/impls/integers.rs
+++ b/diesel/src/types/impls/integers.rs
@@ -8,46 +8,46 @@ use backend::Backend;
 use types::{self, FromSql, ToSql, IsNull};
 
 impl<DB: Backend<RawValue=[u8]>> FromSql<types::SmallInt, DB> for i16 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let mut bytes = not_none!(bytes);
-        bytes.read_i16::<BigEndian>().map_err(|e| Box::new(e) as Box<Error>)
+        bytes.read_i16::<BigEndian>().map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
 impl<DB: Backend> ToSql<types::SmallInt, DB> for i16 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         out.write_i16::<BigEndian>(*self)
             .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
+            .map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
 impl<DB: Backend<RawValue=[u8]>> FromSql<types::Integer, DB> for i32 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let mut bytes = not_none!(bytes);
-        bytes.read_i32::<BigEndian>().map_err(|e| Box::new(e) as Box<Error>)
+        bytes.read_i32::<BigEndian>().map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
 impl<DB: Backend> ToSql<types::Integer, DB> for i32 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         out.write_i32::<BigEndian>(*self)
             .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
+            .map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
 impl<DB: Backend<RawValue=[u8]>> FromSql<types::BigInt, DB> for i64 {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let mut bytes = not_none!(bytes);
-        bytes.read_i64::<BigEndian>().map_err(|e| Box::new(e) as Box<Error>)
+        bytes.read_i64::<BigEndian>().map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
 impl<DB: Backend> ToSql<types::BigInt, DB> for i64 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         out.write_i64::<BigEndian>(*self)
             .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
+            .map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
diff --git a/diesel/src/types/impls/mod.rs b/diesel/src/types/impls/mod.rs
index 2c6efbf25..93a3c86e0 100644
--- a/diesel/src/types/impls/mod.rs
+++ b/diesel/src/types/impls/mod.rs
@@ -48,7 +48,7 @@ macro_rules! expression_impls {
                 DB: $crate::backend::Backend + $crate::types::HasSqlType<types::$Source>,
                 $Target: $crate::types::ToSql<types::$Source, DB>,
             {
-                fn to_sql<W: ::std::io::Write>(&self, out: &mut W) -> Result<$crate::types::IsNull, Box<::std::error::Error>> {
+                fn to_sql<W: ::std::io::Write>(&self, out: &mut W) -> Result<$crate::types::IsNull, Box<::std::error::Error+Send+Sync>> {
                     $crate::types::ToSql::<types::$Source, DB>::to_sql(self, out)
                 }
             }
@@ -63,7 +63,7 @@ macro_rules! queryable_impls {
             DB: $crate::backend::Backend + $crate::types::HasSqlType<types::$Source>,
             $Target: $crate::types::FromSql<types::$Source, DB>,
         {
-            fn build_from_row<R: $crate::row::Row<DB>>(row: &mut R) -> Result<Self, Box<::std::error::Error>> {
+            fn build_from_row<R: $crate::row::Row<DB>>(row: &mut R) -> Result<Self, Box<::std::error::Error+Send+Sync>> {
                 $crate::types::FromSql::<types::$Source, DB>::from_sql(row.take())
             }
         }
@@ -73,7 +73,7 @@ macro_rules! queryable_impls {
             DB: $crate::backend::Backend + $crate::types::HasSqlType<types::$Source>,
             Option<$Target>: $crate::types::FromSql<$crate::types::Nullable<types::$Source>, DB>,
         {
-            fn build_from_row<R: $crate::row::Row<DB>>(row: &mut R) -> Result<Self, Box<::std::error::Error>> {
+            fn build_from_row<R: $crate::row::Row<DB>>(row: &mut R) -> Result<Self, Box<::std::error::Error+Send+Sync>> {
                 $crate::types::FromSql::<$crate::types::Nullable<types::$Source>, DB>::from_sql(row.take())
             }
         }
diff --git a/diesel/src/types/impls/option.rs b/diesel/src/types/impls/option.rs
index 7bfedf035..a71f741b2 100644
--- a/diesel/src/types/impls/option.rs
+++ b/diesel/src/types/impls/option.rs
@@ -20,7 +20,7 @@ impl<T, ST, DB> FromSql<Nullable<ST>, DB> for Option<T> where
     T: FromSql<ST, DB>,
     DB: Backend + HasSqlType<ST>, ST: NotNull,
 {
-    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error+Send+Sync>> {
         match bytes {
             Some(_) => T::from_sql(bytes).map(Some),
             None => Ok(None)
@@ -46,7 +46,7 @@ impl<T, ST, DB> ToSql<Nullable<ST>, DB> for Option<T> where
     DB: Backend + HasSqlType<ST>,
     ST: NotNull,
 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         if let &Some(ref value) = self {
             value.to_sql(out)
         } else {
diff --git a/diesel/src/types/impls/primitives.rs b/diesel/src/types/impls/primitives.rs
index 896fcbe43..299d6892d 100644
--- a/diesel/src/types/impls/primitives.rs
+++ b/diesel/src/types/impls/primitives.rs
@@ -32,9 +32,9 @@ expression_impls! {
 impl NotNull for () {}
 
 impl<DB: Backend<RawValue=[u8]>> FromSql<types::VarChar, DB> for String {
-    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
         let bytes = not_none!(bytes);
-        String::from_utf8(bytes.into()).map_err(|e| Box::new(e) as Box<Error>)
+        String::from_utf8(bytes.into()).map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
@@ -42,16 +42,16 @@ impl<DB> ToSql<types::VarChar, DB> for String where
     DB: Backend,
     for<'a> &'a str: ToSql<types::VarChar, DB>,
 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         (&self as &str).to_sql(out)
     }
 }
 
 impl<'a, DB: Backend> ToSql<types::VarChar, DB> for &'a str {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         out.write_all(self.as_bytes())
             .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
+            .map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
@@ -59,7 +59,7 @@ impl<DB> FromSql<types::Text, DB> for String where
     DB: Backend,
     String: FromSql<types::VarChar, DB>,
 {
-    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error+Send+Sync>> {
         <Self as FromSql<types::VarChar, DB>>::from_sql(bytes)
     }
 }
@@ -68,7 +68,7 @@ impl<DB> ToSql<types::Text, DB> for String where
     DB: Backend,
     for<'a> &'a str: ToSql<types::Text, DB>,
 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         (&self as &str).to_sql(out)
     }
 }
@@ -77,13 +77,13 @@ impl<'a, DB> ToSql<types::Text, DB> for &'a str where
     DB: Backend,
     &'a str: ToSql<types::VarChar, DB>,
 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         ToSql::<types::VarChar, DB>::to_sql(self, out)
     }
 }
 
 impl<DB: Backend<RawValue=[u8]>> FromSql<types::Binary, DB> for Vec<u8> {
-    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error+Send+Sync>> {
         Ok(not_none!(bytes).into())
     }
 }
@@ -92,16 +92,16 @@ impl<DB> ToSql<types::Binary, DB> for Vec<u8> where
     DB: Backend,
     for<'a> &'a [u8]: ToSql<types::Binary, DB>,
 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         (&self as &[u8]).to_sql(out)
     }
 }
 
 impl<'a, DB: Backend> ToSql<types::Binary, DB> for &'a [u8] {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         out.write_all(self)
             .map(|_| IsNull::No)
-            .map_err(|e| Box::new(e) as Box<Error>)
+            .map_err(|e| Box::new(e) as Box<Error+Send+Sync>)
     }
 }
 
@@ -111,7 +111,7 @@ impl<'a, T: ?Sized, ST, DB> ToSql<ST, DB> for Cow<'a, T> where
     DB: Backend + HasSqlType<ST>,
     T::Owned: ToSql<ST, DB>,
 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         match self {
             &Cow::Borrowed(ref t) => t.to_sql(out),
             &Cow::Owned(ref t) => t.to_sql(out),
@@ -124,7 +124,7 @@ impl<'a, T: ?Sized, ST, DB> FromSql<ST, DB> for Cow<'a, T> where
     DB: Backend + HasSqlType<ST>,
     T::Owned: FromSql<ST, DB>,
 {
-    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error>> {
+    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error+Send+Sync>> {
         T::Owned::from_sql(bytes).map(Cow::Owned)
     }
 }
@@ -134,7 +134,7 @@ impl <'a, T: ?Sized, ST, DB> ::types::FromSqlRow<ST, DB> for Cow<'a, T> where
     DB: Backend + HasSqlType<ST>,
     Cow<'a, T>: FromSql<ST, DB>,
 {
-    fn build_from_row<R: ::row::Row<DB>>(row: &mut R) -> Result<Self, Box<Error>> {
+    fn build_from_row<R: ::row::Row<DB>>(row: &mut R) -> Result<Self, Box<Error+Send+Sync>> {
         FromSql::<ST, DB>::from_sql(row.take())
     }
 }
diff --git a/diesel/src/types/impls/tuples.rs b/diesel/src/types/impls/tuples.rs
index 869409ec1..c3f073217 100644
--- a/diesel/src/types/impls/tuples.rs
+++ b/diesel/src/types/impls/tuples.rs
@@ -37,7 +37,7 @@ macro_rules! tuple_impls {
                 $(DB: HasSqlType<$ST>),+,
                 DB: HasSqlType<($($ST,)+)>,
             {
-                fn build_from_row<RowT: Row<DB>>(row: &mut RowT) -> Result<Self, Box<Error>> {
+                fn build_from_row<RowT: Row<DB>>(row: &mut RowT) -> Result<Self, Box<Error+Send+Sync>> {
                     Ok(($(try!($T::build_from_row(row)),)+))
                 }
             }
@@ -48,7 +48,7 @@ macro_rules! tuple_impls {
                 $(DB: HasSqlType<$ST>),+,
                 DB: HasSqlType<($($ST,)+)>,
             {
-                fn build_from_row<RowT: Row<DB>>(row: &mut RowT) -> Result<Self, Box<Error>> {
+                fn build_from_row<RowT: Row<DB>>(row: &mut RowT) -> Result<Self, Box<Error+Send+Sync>> {
                     if e!(row.next_is_null($Tuple)) {
                         Ok(None)
                     } else {
diff --git a/diesel/src/types/mod.rs b/diesel/src/types/mod.rs
index 60d7d8386..335d1a1b9 100644
--- a/diesel/src/types/mod.rs
+++ b/diesel/src/types/mod.rs
@@ -85,13 +85,13 @@ impl<T: NotNull> IntoNullable for Nullable<T> {
 /// How to deserialize a single field of a given type. The input will always be
 /// the binary representation, not the text.
 pub trait FromSql<A, DB: Backend + HasSqlType<A>>: Sized {
-    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error>>;
+    fn from_sql(bytes: Option<&DB::RawValue>) -> Result<Self, Box<Error+Send+Sync>>;
 }
 
 /// How to deserialize multiple fields, with a known type. This type is
 /// implemented for tuples of various sizes.
 pub trait FromSqlRow<A, DB: Backend + HasSqlType<A>>: Sized {
-    fn build_from_row<T: Row<DB>>(row: &mut T) -> Result<Self, Box<Error>>;
+    fn build_from_row<T: Row<DB>>(row: &mut T) -> Result<Self, Box<Error+Send+Sync>>;
 }
 
 #[derive(Debug, PartialEq, Eq)]
@@ -105,14 +105,14 @@ pub enum IsNull {
 /// included as a bind parameter, and is expected to be the binary format, not
 /// text.
 pub trait ToSql<A, DB: Backend + HasSqlType<A>> {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>>;
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>>;
 }
 
 impl<'a, A, T, DB> ToSql<A, DB> for &'a T where
     DB: Backend + HasSqlType<A>,
     T: ToSql<A, DB>,
 {
-    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error>> {
+    fn to_sql<W: Write>(&self, out: &mut W) -> Result<IsNull, Box<Error+Send+Sync>> {
         (*self).to_sql(out)
     }
 }
diff --git a/diesel_tests/tests/types.rs b/diesel_tests/tests/types.rs
index cca8d2405..01235b606 100644
--- a/diesel_tests/tests/types.rs
+++ b/diesel_tests/tests/types.rs
@@ -372,13 +372,13 @@ fn third_party_crates_can_add_new_types() {
     }
 
     impl FromSql<MyInt, Pg> for i32 {
-        fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
+        fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error+Send+Sync>> {
             FromSql::<Integer, Pg>::from_sql(bytes)
         }
     }
 
     impl FromSqlRow<MyInt, Pg> for i32 {
-        fn build_from_row<R: ::diesel::row::Row<Pg>>(row: &mut R) -> Result<Self, Box<Error>> {
+        fn build_from_row<R: ::diesel::row::Row<Pg>>(row: &mut R) -> Result<Self, Box<Error+Send+Sync>> {
             FromSql::<MyInt, Pg>::from_sql(row.take())
         }
     }
