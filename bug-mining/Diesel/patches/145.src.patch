diff --git a/CHANGELOG.md b/CHANGELOG.md
index c65687ed1..9fd5579ca 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -8,6 +8,15 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 
 ### Added
 
+* Added support for `INSERT INTO table (...) SELECT ...` queries. Tables, select
+  select statements, and boxed select statements can now be used just like any
+  other `Insertable` value.
+
+* Any insert query written as `insert_into(table).values(values)` can now be
+  written as `values.insert_into(table)`. This is particularly useful when
+  inserting from a select statement, as select statements tend to span multiple
+  lines.
+
 * Added support for specifying `ISOLATION LEVEL`, `DEFERRABLE`, and `READ ONLY`
   on PG transactions. See [`PgConnection::build_transaction`] for details.
 
diff --git a/diesel/src/insertable.rs b/diesel/src/insertable.rs
index e352645e2..ba6aa0a34 100644
--- a/diesel/src/insertable.rs
+++ b/diesel/src/insertable.rs
@@ -3,7 +3,7 @@ use std::marker::PhantomData;
 use backend::{Backend, SupportsDefaultKeyword};
 use expression::{AppearsOnTable, Expression};
 use result::QueryResult;
-use query_builder::{AstPass, QueryFragment, UndecoratedInsertRecord, ValuesClause};
+use query_builder::{AstPass, InsertStatement, QueryFragment, UndecoratedInsertRecord, ValuesClause};
 use query_source::{Column, Table};
 #[cfg(feature = "sqlite")]
 use sqlite::Sqlite;
@@ -20,13 +20,71 @@ use sqlite::Sqlite;
 /// struct differs from the name of the column, you can annotate the field
 /// with `#[column_name = "some_column_name"]`.
 pub trait Insertable<T> {
+    /// The `VALUES` clause to insert these records
+    ///
+    /// The types used here are generally internal to Diesel.
+    /// Implementations of this trait should use the `Values`
+    /// type of other `Insertable` types.
+    /// For example `<diesel::dsl::Eq<column, &str> as Insertable<table>>::Values`.
     type Values;
 
+    /// Construct `Self::Values`
+    ///
+    /// Implementations of this trait typically call `.values`
+    /// on other `Insertable` types.
     fn values(self) -> Self::Values;
+
+    /// Insert `self` into a given table.
+    ///
+    /// `foo.insert_into(table)` is identical to `insert_into(table).values(foo)`.
+    /// However, when inserting from a select statement,
+    /// this form is generally preferred.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # #[macro_use] extern crate diesel;
+    /// # include!("doctest_setup.rs");
+    /// #
+    /// # fn main() {
+    /// #     run_test().unwrap();
+    /// # }
+    /// #
+    /// # fn run_test() -> QueryResult<()> {
+    /// #     use schema::{posts, users};
+    /// #     let conn = establish_connection();
+    /// #     diesel::delete(posts::table).execute(&conn)?;
+    /// users::table
+    ///     .select((
+    ///         users::name.concat("'s First Post"),
+    ///         users::id,
+    ///     ))
+    ///     .insert_into(posts::table)
+    ///     .into_columns((posts::title, posts::user_id))
+    ///     .execute(&conn)?;
+    ///
+    /// let inserted_posts = posts::table
+    ///     .select(posts::title)
+    ///     .load::<String>(&conn)?;
+    /// let expected = vec!["Sean's First Post", "Tess's First Post"];
+    /// assert_eq!(expected, inserted_posts);
+    /// #     Ok(())
+    /// # }
+    /// ```
+    fn insert_into(self, table: T) -> InsertStatement<T, Self::Values>
+    where
+        Self: Sized,
+    {
+        ::insert_into(table).values(self)
+    }
 }
 
 pub trait CanInsertInSingleQuery<DB: Backend> {
-    fn rows_to_insert(&self) -> usize;
+    /// How many rows will this query insert?
+    ///
+    /// This function should only return `None` when the query is valid on all
+    /// backends, regardless of how many rows get inserted.
+    fn rows_to_insert(&self) -> Option<usize>;
 }
 
 impl<'a, T, DB> CanInsertInSingleQuery<DB> for &'a T
@@ -34,7 +92,7 @@ where
     T: ?Sized + CanInsertInSingleQuery<DB>,
     DB: Backend,
 {
-    fn rows_to_insert(&self) -> usize {
+    fn rows_to_insert(&self) -> Option<usize> {
         (*self).rows_to_insert()
     }
 }
@@ -43,8 +101,8 @@ impl<'a, T, Tab, DB> CanInsertInSingleQuery<DB> for BatchInsert<'a, T, Tab>
 where
     DB: Backend + SupportsDefaultKeyword,
 {
-    fn rows_to_insert(&self) -> usize {
-        self.records.len()
+    fn rows_to_insert(&self) -> Option<usize> {
+        Some(self.records.len())
     }
 }
 
@@ -52,8 +110,8 @@ impl<T, U, DB> CanInsertInSingleQuery<DB> for ColumnInsertValue<T, U>
 where
     DB: Backend,
 {
-    fn rows_to_insert(&self) -> usize {
-        1
+    fn rows_to_insert(&self) -> Option<usize> {
+        Some(1)
     }
 }
 
diff --git a/diesel/src/macros/mod.rs b/diesel/src/macros/mod.rs
index 2094b99d7..56d61f546 100644
--- a/diesel/src/macros/mod.rs
+++ b/diesel/src/macros/mod.rs
@@ -707,6 +707,7 @@ macro_rules! table_body {
                 JoinTo,
             };
             use $crate::associations::HasTable;
+            use $crate::insertable::Insertable;
             use $crate::query_builder::*;
             use $crate::query_builder::nodes::Identifier;
             use $crate::query_source::{AppearsInFromClause, Once, Never};
@@ -861,6 +862,30 @@ macro_rules! table_body {
                 }
             }
 
+            // This impl should be able to live in Diesel,
+            // but Rust tries to recurse for no reason
+            impl<T> Insertable<T> for table
+            where
+                <table as AsQuery>::Query: Insertable<T>,
+            {
+                type Values = <<table as AsQuery>::Query as Insertable<T>>::Values;
+
+                fn values(self) -> Self::Values {
+                    self.as_query().values()
+                }
+            }
+
+            impl<'a, T> Insertable<T> for &'a table
+            where
+                table: Insertable<T>,
+            {
+                type Values = <table as Insertable<T>>::Values;
+
+                fn values(self) -> Self::Values {
+                    (*self).values()
+                }
+            }
+
             /// Contains all of the columns of this table
             pub mod columns {
                 use super::table;
diff --git a/diesel/src/pg/upsert/on_conflict_clause.rs b/diesel/src/pg/upsert/on_conflict_clause.rs
index 628d3c09f..7a6726d66 100644
--- a/diesel/src/pg/upsert/on_conflict_clause.rs
+++ b/diesel/src/pg/upsert/on_conflict_clause.rs
@@ -33,7 +33,7 @@ impl<Values, Target, Action> CanInsertInSingleQuery<Pg> for OnConflictValues<Val
 where
     Values: CanInsertInSingleQuery<Pg>,
 {
-    fn rows_to_insert(&self) -> usize {
+    fn rows_to_insert(&self) -> Option<usize> {
         self.values.rows_to_insert()
     }
 }
diff --git a/diesel/src/query_builder/functions.rs b/diesel/src/query_builder/functions.rs
index df75de232..638dff740 100644
--- a/diesel/src/query_builder/functions.rs
+++ b/diesel/src/query_builder/functions.rs
@@ -249,6 +249,47 @@ pub fn delete<T: IntoUpdateTarget>(source: T) -> DeleteStatement<T::Table, T::Wh
 /// # }
 /// ```
 ///
+/// ### Insert from select
+///
+/// When inserting from a select statement,
+/// the column list can be specified with [`.into_columns`].
+/// (See also [`SelectStatement::insert_into`], which generally
+/// reads better for select statements)
+///
+/// [`SelectStatement::insert_into`]: prelude/trait.Insertable.html#method.insert_into
+/// [`.into_columns`]: query_builder/struct.InsertStatement.html#method.into_columns
+///
+/// ```rust
+/// # #[macro_use] extern crate diesel;
+/// # include!("../doctest_setup.rs");
+/// #
+/// # fn main() {
+/// #     run_test().unwrap();
+/// # }
+/// #
+/// # fn run_test() -> QueryResult<()> {
+/// #     use schema::{posts, users};
+/// #     let conn = establish_connection();
+/// #     diesel::delete(posts::table).execute(&conn)?;
+/// let new_posts = users::table
+///     .select((
+///         users::name.concat("'s First Post"),
+///         users::id,
+///     ));
+/// diesel::insert_into(posts::table)
+///     .values(new_posts)
+///     .into_columns((posts::title, posts::user_id))
+///     .execute(&conn)?;
+///
+/// let inserted_posts = posts::table
+///     .select(posts::title)
+///     .load::<String>(&conn)?;
+/// let expected = vec!["Sean's First Post", "Tess's First Post"];
+/// assert_eq!(expected, inserted_posts);
+/// #     Ok(())
+/// # }
+/// ```
+///
 /// ### With return value
 ///
 /// ```rust
diff --git a/diesel/src/query_builder/insert_statement/column_list.rs b/diesel/src/query_builder/insert_statement/column_list.rs
new file mode 100644
index 000000000..d25f41969
--- /dev/null
+++ b/diesel/src/query_builder/insert_statement/column_list.rs
@@ -0,0 +1,29 @@
+use backend::Backend;
+use query_builder::*;
+use query_source::Column;
+use result::QueryResult;
+
+/// Represents the column list for use in an insert statement.
+///
+/// This trait is implemented by columns and tuples of columns.
+pub trait ColumnList {
+    /// The table these columns belong to
+    type Table;
+
+    /// Generate the SQL for this column list.
+    ///
+    /// Column names must *not* be qualified.
+    fn walk_ast<DB: Backend>(&self, out: AstPass<DB>) -> QueryResult<()>;
+}
+
+impl<C> ColumnList for C
+where
+    C: Column,
+{
+    type Table = <C as Column>::Table;
+
+    fn walk_ast<DB: Backend>(&self, mut out: AstPass<DB>) -> QueryResult<()> {
+        out.push_identifier(C::NAME)?;
+        Ok(())
+    }
+}
diff --git a/diesel/src/query_builder/insert_statement/insert_from_select.rs b/diesel/src/query_builder/insert_statement/insert_from_select.rs
new file mode 100644
index 000000000..e3db2fd12
--- /dev/null
+++ b/diesel/src/query_builder/insert_statement/insert_from_select.rs
@@ -0,0 +1,66 @@
+use backend::Backend;
+use expression::{Expression, NonAggregate, SelectableExpression};
+use insertable::*;
+use query_builder::*;
+use query_source::Table;
+
+/// Represents `(Columns) SELECT FROM ...` for use in an `INSERT` statement
+#[derive(Debug, Clone, Copy)]
+pub struct InsertFromSelect<Select, Columns> {
+    query: Select,
+    columns: Columns,
+}
+
+impl<Select, Columns> InsertFromSelect<Select, Columns> {
+    /// Construct a new `InsertFromSelect` where the target column list is
+    /// `T::AllColumns`.
+    pub fn new<T>(query: Select) -> Self
+    where
+        T: Table<AllColumns = Columns>,
+        Columns: SelectableExpression<T> + NonAggregate,
+    {
+        Self {
+            query,
+            columns: T::all_columns(),
+        }
+    }
+
+    /// Replace the target column list
+    pub fn with_columns<C>(self, columns: C) -> InsertFromSelect<Select, C> {
+        InsertFromSelect {
+            query: self.query,
+            columns,
+        }
+    }
+}
+
+impl<DB, Select, Columns> CanInsertInSingleQuery<DB> for InsertFromSelect<Select, Columns>
+where
+    DB: Backend,
+{
+    fn rows_to_insert(&self) -> Option<usize> {
+        None
+    }
+}
+
+impl<DB, Select, Columns> QueryFragment<DB> for InsertFromSelect<Select, Columns>
+where
+    DB: Backend,
+    Columns: ColumnList + Expression<SqlType = Select::SqlType>,
+    Select: Query + QueryFragment<DB>,
+{
+    fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
+        out.push_sql("(");
+        self.columns.walk_ast(out.reborrow())?;
+        out.push_sql(") ");
+        self.query.walk_ast(out.reborrow())?;
+        Ok(())
+    }
+}
+
+impl<Select, Columns> UndecoratedInsertRecord<Columns::Table> for InsertFromSelect<Select, Columns>
+where
+    Columns: ColumnList + Expression<SqlType = Select::SqlType>,
+    Select: Query,
+{
+}
diff --git a/diesel/src/query_builder/insert_statement.rs b/diesel/src/query_builder/insert_statement/mod.rs
similarity index 92%
rename from diesel/src/query_builder/insert_statement.rs
rename to diesel/src/query_builder/insert_statement/mod.rs
index 5334c3e23..48c067ad7 100644
--- a/diesel/src/query_builder/insert_statement.rs
+++ b/diesel/src/query_builder/insert_statement/mod.rs
@@ -1,3 +1,9 @@
+mod column_list;
+mod insert_from_select;
+
+pub(crate) use self::column_list::ColumnList;
+pub(crate) use self::insert_from_select::InsertFromSelect;
+
 use std::any::*;
 use std::marker::PhantomData;
 
@@ -40,7 +46,7 @@ impl<T, Op> IncompleteInsertStatement<T, Op> {
     ///
     /// ```rust
     /// # #[macro_use] extern crate diesel;
-    /// # include!("../doctest_setup.rs");
+    /// # include!("../../doctest_setup.rs");
     /// #
     /// # table! {
     /// #     users (name) {
@@ -141,6 +147,29 @@ impl<T, U, Op, Ret> InsertStatement<T, U, Op, Ret> {
     }
 }
 
+impl<T, U, C, Op, Ret> InsertStatement<T, InsertFromSelect<U, C>, Op, Ret> {
+    /// Set the column list when inserting from a select statement
+    ///
+    /// See the documentation for [`insert_into`] for usage examples.
+    ///
+    /// [`insert_into`]: ../fn.insert_into.html
+    pub fn into_columns<C2>(
+        self,
+        columns: C2,
+    ) -> InsertStatement<T, InsertFromSelect<U, C2>, Op, Ret>
+    where
+        C2: ColumnList<Table = T> + Expression<SqlType = U::SqlType>,
+        U: Query,
+    {
+        InsertStatement::new(
+            self.target,
+            self.records.with_columns(columns),
+            self.operator,
+            self.returning,
+        )
+    }
+}
+
 impl<T, U, Op, Ret, DB> QueryFragment<DB> for InsertStatement<T, U, Op, Ret>
 where
     DB: Backend,
@@ -153,7 +182,7 @@ where
     fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
         out.unsafe_to_cache_prepared();
 
-        if self.records.rows_to_insert() == 0 {
+        if self.records.rows_to_insert() == Some(0) {
             out.push_sql("SELECT 1 FROM ");
             self.target.from_clause().walk_ast(out.reborrow())?;
             out.push_sql(" WHERE 1=0");
@@ -247,7 +276,7 @@ impl<T, U, Op> InsertStatement<T, U, Op> {
     ///
     /// ```rust
     /// # #[macro_use] extern crate diesel;
-    /// # include!("../doctest_setup.rs");
+    /// # include!("../../doctest_setup.rs");
     /// #
     /// # #[cfg(feature = "postgres")]
     /// # fn main() {
@@ -387,8 +416,8 @@ where
 pub struct DefaultValues;
 
 impl<DB: Backend> CanInsertInSingleQuery<DB> for DefaultValues {
-    fn rows_to_insert(&self) -> usize {
-        1
+    fn rows_to_insert(&self) -> Option<usize> {
+        Some(1)
     }
 }
 
@@ -449,7 +478,7 @@ where
     DB: Backend,
     T: CanInsertInSingleQuery<DB>,
 {
-    fn rows_to_insert(&self) -> usize {
+    fn rows_to_insert(&self) -> Option<usize> {
         self.values.rows_to_insert()
     }
 }
diff --git a/diesel/src/query_builder/mod.rs b/diesel/src/query_builder/mod.rs
index ea7d2299a..14d26678c 100644
--- a/diesel/src/query_builder/mod.rs
+++ b/diesel/src/query_builder/mod.rs
@@ -46,6 +46,8 @@ pub use self::sql_query::SqlQuery;
 pub use self::update_statement::{AsChangeset, IncompleteUpdateStatement, IntoUpdateTarget,
                                  UpdateStatement, UpdateTarget};
 
+pub(crate) use self::insert_statement::ColumnList;
+
 use std::error::Error;
 
 use backend::Backend;
diff --git a/diesel/src/query_builder/select_statement/boxed.rs b/diesel/src/query_builder/select_statement/boxed.rs
index eef10c9b7..e9365b870 100644
--- a/diesel/src/query_builder/select_statement/boxed.rs
+++ b/diesel/src/query_builder/select_statement/boxed.rs
@@ -3,16 +3,18 @@ use std::marker::PhantomData;
 use backend::Backend;
 use dsl::AsExprOf;
 use expression::*;
+use insertable::Insertable;
 use query_builder::*;
 use query_builder::distinct_clause::DistinctClause;
 use query_builder::group_by_clause::GroupByClause;
+use query_builder::insert_statement::InsertFromSelect;
 use query_builder::limit_clause::LimitClause;
 use query_builder::offset_clause::OffsetClause;
 use query_builder::order_clause::OrderClause;
 use query_dsl::*;
 use query_dsl::methods::*;
-use query_source::QuerySource;
 use query_source::joins::*;
+use query_source::{QuerySource, Table};
 use result::QueryResult;
 use sql_types::{BigInt, Bool};
 
@@ -292,3 +294,27 @@ where
 impl<'a, ST, QS, DB> QueryDsl for BoxedSelectStatement<'a, ST, QS, DB> {}
 
 impl<'a, ST, QS, DB, Conn> RunQueryDsl<Conn> for BoxedSelectStatement<'a, ST, QS, DB> {}
+
+impl<'a, ST, QS, DB, T> Insertable<T> for BoxedSelectStatement<'a, ST, QS, DB>
+where
+    T: Table,
+    Self: Query,
+{
+    type Values = InsertFromSelect<Self, T::AllColumns>;
+
+    fn values(self) -> Self::Values {
+        InsertFromSelect::new(self)
+    }
+}
+
+impl<'a, 'b, ST, QS, DB, T> Insertable<T> for &'b BoxedSelectStatement<'a, ST, QS, DB>
+where
+    T: Table,
+    Self: Query,
+{
+    type Values = InsertFromSelect<Self, T::AllColumns>;
+
+    fn values(self) -> Self::Values {
+        InsertFromSelect::new(self)
+    }
+}
diff --git a/diesel/src/query_builder/select_statement/dsl_impls.rs b/diesel/src/query_builder/select_statement/dsl_impls.rs
index 513428362..72e929597 100644
--- a/diesel/src/query_builder/select_statement/dsl_impls.rs
+++ b/diesel/src/query_builder/select_statement/dsl_impls.rs
@@ -2,9 +2,11 @@ use associations::HasTable;
 use backend::Backend;
 use dsl::AsExprOf;
 use expression::*;
+use insertable::Insertable;
 use query_builder::distinct_clause::*;
 use query_builder::for_update_clause::*;
 use query_builder::group_by_clause::*;
+use query_builder::insert_statement::InsertFromSelect;
 use query_builder::limit_clause::*;
 use query_builder::offset_clause::*;
 use query_builder::order_clause::*;
@@ -375,3 +377,29 @@ impl<F, S, D, W, O, L, Of, G, FU> QueryDsl for SelectStatement<F, S, D, W, O, L,
 impl<F, S, D, W, O, L, Of, G, FU, Conn> RunQueryDsl<Conn>
     for SelectStatement<F, S, D, W, O, L, Of, G, FU> {
 }
+
+impl<F, S, D, W, O, L, Of, G, FU, Tab> Insertable<Tab>
+    for SelectStatement<F, S, D, W, O, L, Of, G, FU>
+where
+    Tab: Table,
+    Self: Query,
+{
+    type Values = InsertFromSelect<Self, Tab::AllColumns>;
+
+    fn values(self) -> Self::Values {
+        InsertFromSelect::new(self)
+    }
+}
+
+impl<'a, F, S, D, W, O, L, Of, G, FU, Tab> Insertable<Tab>
+    for &'a SelectStatement<F, S, D, W, O, L, Of, G, FU>
+where
+    Tab: Table,
+    Self: Query,
+{
+    type Values = InsertFromSelect<Self, Tab::AllColumns>;
+
+    fn values(self) -> Self::Values {
+        InsertFromSelect::new(self)
+    }
+}
diff --git a/diesel/src/type_impls/tuples.rs b/diesel/src/type_impls/tuples.rs
index 656398fe3..64aa7938a 100644
--- a/diesel/src/type_impls/tuples.rs
+++ b/diesel/src/type_impls/tuples.rs
@@ -89,6 +89,23 @@ macro_rules! tuple_impls {
                 }
             }
 
+            impl<$($T,)+ Tab> ColumnList for ($($T,)+)
+            where
+                $($T: ColumnList<Table = Tab>,)+
+            {
+                type Table = Tab;
+
+                fn walk_ast<DB: Backend>(&self, mut out: AstPass<DB>) -> QueryResult<()> {
+                    $(
+                        if $idx != 0 {
+                            out.push_sql(", ");
+                        }
+                        self.$idx.walk_ast(out.reborrow())?;
+                    )+
+                    Ok(())
+                }
+            }
+
             impl<$($T: QueryId),+> QueryId for ($($T,)+) {
                 type QueryId = ($($T::QueryId,)+);
 
@@ -109,9 +126,9 @@ macro_rules! tuple_impls {
                 DB: Backend,
                 $($T: CanInsertInSingleQuery<DB>,)+
             {
-                fn rows_to_insert(&self) -> usize {
-                    $(debug_assert_eq!(self.$idx.rows_to_insert(), 1);)+
-                    1
+                fn rows_to_insert(&self) -> Option<usize> {
+                    $(debug_assert_eq!(self.$idx.rows_to_insert(), Some(1));)+
+                    Some(1)
                 }
             }
 
diff --git a/diesel_compile_tests/tests/compile-fail/insert_from_select_cant_be_used_with_tuples_or_arrays.rs b/diesel_compile_tests/tests/compile-fail/insert_from_select_cant_be_used_with_tuples_or_arrays.rs
new file mode 100644
index 000000000..1e157c1cc
--- /dev/null
+++ b/diesel_compile_tests/tests/compile-fail/insert_from_select_cant_be_used_with_tuples_or_arrays.rs
@@ -0,0 +1,41 @@
+#[macro_use]
+extern crate diesel;
+
+use diesel::*;
+use diesel::pg::PgConnection;
+
+table! {
+    users {
+        id -> Integer,
+        name -> Text,
+        hair_color -> Nullable<Text>,
+    }
+}
+
+table! {
+    posts (user_id) {
+        user_id -> Integer,
+        title -> Text,
+        body -> Nullable<Text>,
+    }
+}
+
+fn main() {
+    use users::dsl::*;
+    use posts::dsl::*;
+    let conn = PgConnection::establish("").unwrap();
+
+    // Sanity check, valid query
+    insert_into(posts)
+        .values(users)
+        .execute(&conn)
+        .unwrap();
+
+    insert_into(posts)
+        .values(vec![users, users]);
+        //~^ ERROR E0277
+
+    insert_into(posts)
+        .values((users, users));
+        //~^ ERROR E0271
+}
diff --git a/diesel_compile_tests/tests/compile-fail/insert_from_select_requires_valid_column_list.rs b/diesel_compile_tests/tests/compile-fail/insert_from_select_requires_valid_column_list.rs
new file mode 100644
index 000000000..25f9f4a7c
--- /dev/null
+++ b/diesel_compile_tests/tests/compile-fail/insert_from_select_requires_valid_column_list.rs
@@ -0,0 +1,98 @@
+#[macro_use]
+extern crate diesel;
+
+use diesel::*;
+use diesel::pg::PgConnection;
+
+table! {
+    users {
+        id -> Integer,
+        name -> Text,
+        hair_color -> Nullable<Text>,
+    }
+}
+
+table! {
+    posts (user_id) {
+        user_id -> Integer,
+        title -> Text,
+        body -> Nullable<Text>,
+    }
+}
+
+table! {
+    comments (post_id) {
+        post_id -> Integer,
+        body -> Nullable<Text>,
+    }
+}
+
+fn main() {
+    use users::dsl::*;
+    use posts::dsl::*;
+    let conn = PgConnection::establish("").unwrap();
+
+    // Sanity check, valid query with no column list
+    users
+        .insert_into(posts)
+        .execute(&conn)
+        .unwrap();
+
+    // Sanity check, valid query with single column
+    users.select(id)
+        .insert_into(posts)
+        .into_columns(user_id)
+        .execute(&conn)
+        .unwrap();
+
+    // Sanity check, valid query with column list
+    users.select((name, hair_color))
+        .insert_into(posts)
+        .into_columns((title, body))
+        .execute(&conn)
+        .unwrap();
+
+    // No column list, mismatched types
+    users.select((name, hair_color))
+        .insert_into(posts)
+        .execute(&conn)
+        //~^ ERROR type mismatch
+        .unwrap();
+
+    // Single column, wrong table
+    users.select(id)
+        .insert_into(posts)
+        .into_columns(comments::post_id);
+        //~^ ERROR type mismatch
+
+    // Single column, wrong type
+    users.select(id)
+        .insert_into(posts)
+        .into_columns(title);
+        //~^ ERROR type mismatch
+
+    // Multiple columns, one from wrong table
+    users.select((id, name))
+        .insert_into(posts)
+        .into_columns((comments::post_id, title));
+        //~^ ERROR E0277
+
+    // Multiple columns, both from wrong table
+    users.select((id, hair_color))
+        .insert_into(posts)
+        .into_columns((comments::post_id, comments::body));
+        //~^ ERROR type mismatch
+        //~| ERROR type mismatch
+
+    // Multiple columns, one wrong type
+    users.select((id, name))
+        .insert_into(posts)
+        .into_columns((user_id, body));
+        //~^ ERROR type mismatch
+
+    // Multiple columns, both wrong types
+    users.select((id, name))
+        .insert_into(posts)
+        .into_columns((title, body));
+        //~^ ERROR type mismatch
+}
diff --git a/diesel_tests/tests/insert_from_select.rs b/diesel_tests/tests/insert_from_select.rs
new file mode 100644
index 000000000..9d02588c2
--- /dev/null
+++ b/diesel_tests/tests/insert_from_select.rs
@@ -0,0 +1,269 @@
+use diesel::*;
+use schema::*;
+
+#[test]
+fn insert_from_table() {
+    use schema::posts::dsl::*;
+    let conn = connection_with_sean_and_tess_in_users_table();
+    insert_into(posts)
+        .values(users::table)
+        .into_columns((user_id, title, body))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select((user_id, title, body)).load(&conn);
+    let expected = vec![
+        (1, String::from("Sean"), None::<String>),
+        (2, String::from("Tess"), None),
+    ];
+    assert_eq!(Ok(expected), data);
+}
+
+#[test]
+fn insert_from_table_reference() {
+    use schema::posts::dsl::*;
+    let conn = connection_with_sean_and_tess_in_users_table();
+    insert_into(posts)
+        .values(&users::table)
+        .into_columns((user_id, title, body))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select((user_id, title, body)).load(&conn);
+    let expected = vec![
+        (1, String::from("Sean"), None::<String>),
+        (2, String::from("Tess"), None),
+    ];
+    assert_eq!(Ok(expected), data);
+}
+
+#[test]
+fn insert_from_select() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+    users
+        .select((id, name.concat(" says hi")))
+        .insert_into(posts)
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select(title).load::<String>(&conn).unwrap();
+    let expected = vec!["Sean says hi", "Tess says hi"];
+    assert_eq!(expected, data);
+}
+
+#[test]
+fn insert_from_select_reference() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+    let select = users.select((id, name.concat(" says hi")));
+    insert_into(posts)
+        .values(&select)
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select(title).load::<String>(&conn).unwrap();
+    let expected = vec!["Sean says hi", "Tess says hi"];
+    assert_eq!(expected, data);
+}
+
+#[test]
+fn insert_from_boxed() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+    users
+        .select((id, name.concat(" says hi")))
+        .into_boxed()
+        .insert_into(posts)
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select(title).load::<String>(&conn).unwrap();
+    let expected = vec!["Sean says hi", "Tess says hi"];
+    assert_eq!(expected, data);
+}
+
+#[test]
+fn insert_from_boxed_reference() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+    let select = users.select((id, name.concat(" says hi"))).into_boxed();
+    insert_into(posts)
+        .values(&select)
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select(title).load::<String>(&conn).unwrap();
+    let expected = vec!["Sean says hi", "Tess says hi"];
+    assert_eq!(expected, data);
+}
+
+#[test]
+#[cfg(feature = "sqlite")]
+fn insert_or_ignore_with_select() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+    sql_query("CREATE UNIQUE INDEX foo ON posts (user_id)")
+        .execute(&conn)
+        .unwrap();
+
+    insert_or_ignore_into(posts)
+        .values(users.select((id, name.concat(" says hi"))))
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+    insert_or_ignore_into(posts)
+        .values(users.select((id, name.concat(" says bye"))))
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select(title).load::<String>(&conn).unwrap();
+    let expected = vec!["Sean says hi", "Tess says hi"];
+    assert_eq!(expected, data);
+}
+
+#[test]
+#[cfg(feature = "sqlite")]
+fn insert_or_replace_with_select() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+    sql_query("CREATE UNIQUE INDEX foo ON posts (user_id)")
+        .execute(&conn)
+        .unwrap();
+
+    replace_into(posts)
+        .values(users.select((id, name.concat(" says hi"))))
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+    replace_into(posts)
+        .values(users.select((id, name.concat(" says bye"))))
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select(title).load::<String>(&conn).unwrap();
+    let expected = vec!["Sean says bye", "Tess says bye"];
+    assert_eq!(expected, data);
+}
+
+#[test]
+#[cfg(feature = "mysql")]
+// We can't share the test with SQLite because it modifies
+// schema, but we can at least make sure the query is *syntactically* valid.
+fn insert_or_ignore_with_select() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+
+    insert_or_ignore_into(posts)
+        .values(users.select((id, name.concat(" says hi"))))
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select(title).load::<String>(&conn).unwrap();
+    let expected = vec!["Sean says hi", "Tess says hi"];
+    assert_eq!(expected, data);
+}
+
+#[test]
+#[cfg(feature = "mysql")]
+// We can't share the test with SQLite because it modifies
+// schema, but we can at least make sure the query is *syntactically* valid.
+fn insert_or_replace_with_select() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+
+    replace_into(posts)
+        .values(users.select((id, name.concat(" says hi"))))
+        .into_columns((user_id, title))
+        .execute(&conn)
+        .unwrap();
+
+    let data = posts.select(title).load::<String>(&conn).unwrap();
+    let expected = vec!["Sean says hi", "Tess says hi"];
+    assert_eq!(expected, data);
+}
+
+#[test]
+#[cfg(feature = "postgres")]
+fn on_conflict_do_nothing_with_select() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+    sql_query("CREATE UNIQUE INDEX ON posts (title)")
+        .execute(&conn)
+        .unwrap();
+    let query = users
+        .select((id, name.concat(" says hi")))
+        .insert_into(posts)
+        .into_columns((user_id, title))
+        .on_conflict_do_nothing();
+
+    let inserted_rows = query.execute(&conn).unwrap();
+    assert_eq!(2, inserted_rows);
+    let inserted_rows = query.execute(&conn).unwrap();
+    assert_eq!(0, inserted_rows);
+
+    let data = posts.select(title).load::<String>(&conn).unwrap();
+    let expected = vec!["Sean says hi", "Tess says hi"];
+    assert_eq!(expected, data);
+}
+
+#[test]
+#[cfg(feature = "postgres")]
+fn on_conflict_do_update_with_select() {
+    use schema::posts::dsl::*;
+    use schema::users::dsl::{id, name, users};
+
+    let conn = connection_with_sean_and_tess_in_users_table();
+    sql_query("CREATE UNIQUE INDEX ON posts (title)")
+        .execute(&conn)
+        .unwrap();
+    let query = users
+        .select((id, name.concat(" says hi")))
+        .insert_into(posts)
+        .into_columns((user_id, title))
+        .on_conflict(title)
+        .do_update()
+        .set(body.eq("updated"));
+
+    query.execute(&conn).unwrap();
+
+    insert_into(users)
+        .values(name.eq("Ruby"))
+        .execute(&conn)
+        .unwrap();
+
+    query.execute(&conn).unwrap();
+
+    let data = posts.select((title, body)).load(&conn).unwrap();
+    let expected = vec![
+        (String::from("Sean says hi"), Some(String::from("updated"))),
+        (String::from("Tess says hi"), Some(String::from("updated"))),
+        (String::from("Ruby says hi"), None),
+    ];
+    assert_eq!(expected, data);
+}
diff --git a/diesel_tests/tests/lib.rs b/diesel_tests/tests/lib.rs
index 785eee3fa..4da6ac877 100644
--- a/diesel_tests/tests/lib.rs
+++ b/diesel_tests/tests/lib.rs
@@ -33,6 +33,7 @@ mod filter_operators;
 mod find;
 mod group_by;
 mod insert;
+mod insert_from_select;
 mod internal_details;
 mod joins;
 mod macros;
