diff --git a/CHANGELOG.md b/CHANGELOG.md
index 499f9adc7..c53a4c6ec 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -27,6 +27,10 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
 [max-0.11.0]: http://docs.diesel.rs/diesel/expression/dsl/fn.max.html
 [min-0.11.0]: http://docs.diesel.rs/diesel/expression/dsl/fn.min.html
 
+* [`now`][now-0.11.0] can now be used as an expression of type `Timestamptz`.
+
+[now-0.11.0]: http://docs.diesel.rs/diesel/expression/dsl/struct.now.html
+
 ## [0.10.1] - 2017-02-08
 
 ### Fixed
diff --git a/diesel/src/expression/coerce.rs b/diesel/src/expression/coerce.rs
new file mode 100644
index 000000000..665367a04
--- /dev/null
+++ b/diesel/src/expression/coerce.rs
@@ -0,0 +1,75 @@
+use std::marker::PhantomData;
+
+use backend::Backend;
+use expression::{Expression, SelectableExpression, NonAggregate};
+use query_builder::*;
+use result::QueryResult;
+
+#[derive(Debug, Copy, Clone)]
+#[doc(hidden)]
+/// Coerces an expression to be another type. No checks are performed to ensure
+/// that the new type is valid in all positions that the previous type was.
+/// This does not perform an actual cast, it just lies to our type system.
+///
+/// This is used for a few expressions where we know that the types are actually
+/// always interchangeable. (Examples of this include `Timestamp` vs
+/// `Timestamptz`, `VarChar` vs `Text`, and `Json` vs `Jsonb`).
+///
+/// This struct should not be considered a general solution to equivalent types.
+/// It is a short term workaround for expressions which are known to be commonly
+/// used.
+pub struct Coerce<T, ST> {
+    expr: T,
+    _marker: PhantomData<ST>,
+}
+
+impl<T, ST> Coerce<T, ST> {
+    pub fn new(expr: T) -> Self {
+        Coerce {
+            expr: expr,
+            _marker: PhantomData,
+        }
+    }
+}
+
+impl<T, ST> Expression for Coerce<T, ST> where
+    T: Expression,
+{
+    type SqlType = ST;
+}
+
+impl<T, ST, QS> SelectableExpression<QS> for Coerce<T, ST> where
+    T: SelectableExpression<QS>,
+{
+}
+
+impl<T, ST, DB> QueryFragment<DB> for Coerce<T, ST> where
+    T: QueryFragment<DB>,
+    DB: Backend,
+{
+    fn to_sql(&self, out: &mut DB::QueryBuilder) -> BuildQueryResult {
+        self.expr.to_sql(out)
+    }
+
+    fn collect_binds(&self, out: &mut DB::BindCollector) -> QueryResult<()> {
+        self.expr.collect_binds(out)
+    }
+
+    fn is_safe_to_cache_prepared(&self) -> bool {
+        self.expr.is_safe_to_cache_prepared()
+    }
+}
+
+impl<T: QueryId, ST: 'static> QueryId for Coerce<T, ST> {
+    type QueryId = Coerce<T::QueryId, ST>;
+
+    fn has_static_query_id() -> bool {
+        true
+    }
+}
+
+impl<T, ST> NonAggregate for Coerce<T, ST> where
+    T: NonAggregate,
+    Coerce<T, ST>: Expression,
+{
+}
diff --git a/diesel/src/expression/functions/date_and_time.rs b/diesel/src/expression/functions/date_and_time.rs
index e03e63625..4a58b5258 100644
--- a/diesel/src/expression/functions/date_and_time.rs
+++ b/diesel/src/expression/functions/date_and_time.rs
@@ -42,3 +42,19 @@ operator_allowed!(now, Sub, sub);
 sql_function!(date, date_t, (x: Timestamp) -> Date,
 "Represents the SQL DATE() function. The argument should be a Timestamp
 expression, and the return value will be an expression of type Date");
+
+#[cfg(feature="postgres")]
+use expression::AsExpression;
+#[cfg(feature="postgres")]
+use expression::coerce::Coerce;
+#[cfg(feature="postgres")]
+use types::Timestamptz;
+
+#[cfg(feature="postgres")]
+impl AsExpression<Timestamptz> for now {
+    type Expression = Coerce<now, Timestamptz>;
+
+    fn as_expression(self) -> Self::Expression {
+        Coerce::new(self)
+    }
+}
diff --git a/diesel/src/expression/mod.rs b/diesel/src/expression/mod.rs
index 5e962dfc6..b7d97661b 100644
--- a/diesel/src/expression/mod.rs
+++ b/diesel/src/expression/mod.rs
@@ -24,6 +24,8 @@ pub mod array_comparison;
 #[doc(hidden)]
 pub mod bound;
 #[doc(hidden)]
+pub mod coerce;
+#[doc(hidden)]
 pub mod count;
 #[doc(hidden)]
 pub mod exists;
diff --git a/diesel_tests/tests/expressions/date_and_time.rs b/diesel_tests/tests/expressions/date_and_time.rs
index 4704d1aa8..0ebe44163 100644
--- a/diesel_tests/tests/expressions/date_and_time.rs
+++ b/diesel_tests/tests/expressions/date_and_time.rs
@@ -40,6 +40,25 @@ fn now_executes_sql_function_now() {
     assert_eq!(Ok(vec![2]), after_today);
 }
 
+#[test]
+#[cfg(feature = "postgres")]
+// FIXME: Replace this with an actual timestamptz expression
+fn now_can_be_used_as_timestamptz() {
+    use self::has_timestamps::dsl::*;
+    use diesel::types::Timestamptz;
+
+    let connection = connection();
+    setup_test_table(&connection);
+    connection.execute("INSERT INTO has_timestamps (created_at) VALUES \
+                        (NOW() - '1 day'::interval)").unwrap();
+
+    let created_at_tz = sql::<Timestamptz>("created_at");
+    let before_now = has_timestamps.select(id)
+        .filter(created_at_tz.lt(now))
+        .load::<i32>(&connection);
+    assert_eq!(Ok(vec![1]), before_now);
+}
+
 #[test]
 #[cfg(feature = "sqlite")]
 fn now_executes_sql_function_now() {
