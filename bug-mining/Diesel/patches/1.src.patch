diff --git a/src/types/impls/primitives.rs b/src/types/impls/primitives.rs
index b61861b48..e9f7a88fd 100644
--- a/src/types/impls/primitives.rs
+++ b/src/types/impls/primitives.rs
@@ -26,6 +26,14 @@ macro_rules! primitive_impls {
                     Bound::new(self)
                 }
             }
+
+            impl AsExpression<types::Nullable<types::$Source>> for $Target {
+                type Expression = <Self as AsExpression<types::$Source>>::Expression;
+
+                fn as_expression(self) -> Self::Expression {
+                    AsExpression::<types::$Source>::as_expression(self)
+                }
+            }
         )+
     }
 }
@@ -101,6 +109,14 @@ impl<'a> AsExpression<types::VarChar> for &'a str {
     }
 }
 
+impl<'a> AsExpression<types::Nullable<types::VarChar>> for &'a str {
+    type Expression = <Self as AsExpression<types::VarChar>>::Expression;
+
+    fn as_expression(self) -> Self::Expression {
+        AsExpression::<types::VarChar>::as_expression(self)
+    }
+}
+
 impl<'a> AsExpression<types::Text> for &'a str {
     type Expression = Bound<types::Text, Self>;
 
@@ -109,6 +125,14 @@ impl<'a> AsExpression<types::Text> for &'a str {
     }
 }
 
+impl<'a> AsExpression<types::Nullable<types::Text>> for &'a str {
+    type Expression = <Self as AsExpression<types::Text>>::Expression;
+
+    fn as_expression(self) -> Self::Expression {
+        AsExpression::<types::Text>::as_expression(self)
+    }
+}
+
 impl FromSql<types::Text> for String {
     fn from_sql(bytes: Option<&[u8]>) -> Result<Self, Box<Error>> {
         <Self as FromSql<types::VarChar>>::from_sql(bytes)
diff --git a/tests/filter.rs b/tests/filter.rs
index 4add87325..1ffd19513 100644
--- a/tests/filter.rs
+++ b/tests/filter.rs
@@ -27,6 +27,28 @@ fn filter_by_string_equality() {
     assert_eq!(None::<User>, connection.query_one(users.filter(name.eq("Jim"))).unwrap());
 }
 
+#[test]
+fn filter_by_equality_on_nullable_columns() {
+    use schema::users::dsl::*;
+
+    let connection = connection();
+    setup_users_table(&connection);
+    let data = vec![
+        NewUser::new("Sean", Some("black")),
+        NewUser::new("Tess", Some("brown")),
+        NewUser::new("Jim", Some("black")),
+    ];
+    connection.insert_without_return(&users, &data).unwrap();
+
+    let sean = User::with_hair_color(1, "Sean", "black");
+    let tess = User::with_hair_color(2, "Tess", "brown");
+    let jim = User::with_hair_color(3, "Jim", "black");
+    let source = users.filter(hair_color.eq("black"));
+    assert_eq!(vec![sean, jim], connection.query_all(source).unwrap().collect::<Vec<_>>());
+    let source = users.filter(hair_color.eq("brown"));
+    assert_eq!(vec![tess], connection.query_all(source).unwrap().collect::<Vec<_>>());
+}
+
 #[test]
 fn filter_after_joining() {
     use schema::users::name;
diff --git a/tests/schema.rs b/tests/schema.rs
index 6ec451007..67039e328 100644
--- a/tests/schema.rs
+++ b/tests/schema.rs
@@ -9,6 +9,14 @@ impl User {
     pub fn new(id: i32, name: &str) -> Self {
         User { id: id, name: name.to_string(), hair_color: None }
     }
+
+    pub fn with_hair_color(id: i32, name: &str, hair_color: &str) -> Self {
+        User {
+            id: id,
+            name: name.to_string(),
+            hair_color: Some(hair_color.to_string()),
+        }
+    }
 }
 
 #[derive(PartialEq, Eq, Debug)]
