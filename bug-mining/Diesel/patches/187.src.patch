diff --git a/diesel/src/mysql/connection/bind.rs b/diesel/src/mysql/connection/bind.rs
index 2268ee0fd..918ed34ca 100644
--- a/diesel/src/mysql/connection/bind.rs
+++ b/diesel/src/mysql/connection/bind.rs
@@ -4,6 +4,7 @@ use std::mem;
 use std::os::raw as libc;
 
 use super::stmt::Statement;
+use crate::mysql::types::MYSQL_TIME;
 use crate::mysql::{MysqlType, MysqlValue};
 use crate::result::QueryResult;
 
@@ -421,7 +422,7 @@ fn known_buffer_size_for_ffi_type(tpe: ffi::enum_field_types) -> Option<usize> {
         t::MYSQL_TYPE_TIME
         | t::MYSQL_TYPE_DATE
         | t::MYSQL_TYPE_DATETIME
-        | t::MYSQL_TYPE_TIMESTAMP => Some(size_of::<ffi::MYSQL_TIME>()),
+        | t::MYSQL_TYPE_TIMESTAMP => Some(size_of::<MYSQL_TIME>()),
         _ => None,
     }
 }
diff --git a/diesel/src/mysql/types/date_and_time.rs b/diesel/src/mysql/types/date_and_time.rs
index c345b342d..9709c1d2e 100644
--- a/diesel/src/mysql/types/date_and_time.rs
+++ b/diesel/src/mysql/types/date_and_time.rs
@@ -1,11 +1,10 @@
-extern crate chrono;
-extern crate mysqlclient_sys as ffi;
-
-use self::chrono::*;
+use chrono::*;
+use mysqlclient_sys as ffi;
 use std::io::Write;
 use std::os::raw as libc;
 use std::{mem, slice};
 
+use super::MYSQL_TIME;
 use crate::deserialize::{self, FromSql};
 use crate::mysql::{Mysql, MysqlValue};
 use crate::serialize::{self, IsNull, Output, ToSql};
@@ -13,18 +12,18 @@ use crate::sql_types::{Date, Datetime, Time, Timestamp};
 
 macro_rules! mysql_time_impls {
     ($ty:ty) => {
-        impl ToSql<$ty, Mysql> for ffi::MYSQL_TIME {
+        impl ToSql<$ty, Mysql> for MYSQL_TIME {
             fn to_sql<W: Write>(&self, out: &mut Output<W, Mysql>) -> serialize::Result {
                 let bytes = unsafe {
-                    let bytes_ptr = self as *const ffi::MYSQL_TIME as *const u8;
-                    slice::from_raw_parts(bytes_ptr, mem::size_of::<ffi::MYSQL_TIME>())
+                    let bytes_ptr = self as *const MYSQL_TIME as *const u8;
+                    slice::from_raw_parts(bytes_ptr, mem::size_of::<MYSQL_TIME>())
                 };
                 out.write_all(bytes)?;
                 Ok(IsNull::No)
             }
         }
 
-        impl FromSql<$ty, Mysql> for ffi::MYSQL_TIME {
+        impl FromSql<$ty, Mysql> for MYSQL_TIME {
             fn from_sql(value: Option<MysqlValue<'_>>) -> deserialize::Result<Self> {
                 let data = not_none!(value);
                 data.time_value()
@@ -52,7 +51,7 @@ impl FromSql<Datetime, Mysql> for NaiveDateTime {
 
 impl ToSql<Timestamp, Mysql> for NaiveDateTime {
     fn to_sql<W: Write>(&self, out: &mut Output<W, Mysql>) -> serialize::Result {
-        let mysql_time = ffi::MYSQL_TIME {
+        let mysql_time = MYSQL_TIME {
             year: self.year() as libc::c_uint,
             month: self.month() as libc::c_uint,
             day: self.day() as libc::c_uint,
@@ -60,17 +59,18 @@ impl ToSql<Timestamp, Mysql> for NaiveDateTime {
             minute: self.minute() as libc::c_uint,
             second: self.second() as libc::c_uint,
             second_part: libc::c_ulong::from(self.timestamp_subsec_micros()),
-            neg: 0,
+            neg: false,
             time_type: ffi::enum_mysql_timestamp_type::MYSQL_TIMESTAMP_DATETIME,
+            time_zone_displacement: 0,
         };
 
-        <ffi::MYSQL_TIME as ToSql<Timestamp, Mysql>>::to_sql(&mysql_time, out)
+        <MYSQL_TIME as ToSql<Timestamp, Mysql>>::to_sql(&mysql_time, out)
     }
 }
 
 impl FromSql<Timestamp, Mysql> for NaiveDateTime {
     fn from_sql(bytes: Option<MysqlValue<'_>>) -> deserialize::Result<Self> {
-        let mysql_time = <ffi::MYSQL_TIME as FromSql<Timestamp, Mysql>>::from_sql(bytes)?;
+        let mysql_time = <MYSQL_TIME as FromSql<Timestamp, Mysql>>::from_sql(bytes)?;
 
         NaiveDate::from_ymd_opt(
             mysql_time.year as i32,
@@ -91,7 +91,7 @@ impl FromSql<Timestamp, Mysql> for NaiveDateTime {
 
 impl ToSql<Time, Mysql> for NaiveTime {
     fn to_sql<W: Write>(&self, out: &mut serialize::Output<W, Mysql>) -> serialize::Result {
-        let mysql_time = ffi::MYSQL_TIME {
+        let mysql_time = MYSQL_TIME {
             hour: self.hour() as libc::c_uint,
             minute: self.minute() as libc::c_uint,
             second: self.second() as libc::c_uint,
@@ -99,17 +99,18 @@ impl ToSql<Time, Mysql> for NaiveTime {
             month: 0,
             second_part: 0,
             year: 0,
-            neg: 0,
+            neg: false,
             time_type: ffi::enum_mysql_timestamp_type::MYSQL_TIMESTAMP_TIME,
+            time_zone_displacement: 0,
         };
 
-        <ffi::MYSQL_TIME as ToSql<Time, Mysql>>::to_sql(&mysql_time, out)
+        <MYSQL_TIME as ToSql<Time, Mysql>>::to_sql(&mysql_time, out)
     }
 }
 
 impl FromSql<Time, Mysql> for NaiveTime {
     fn from_sql(bytes: Option<MysqlValue<'_>>) -> deserialize::Result<Self> {
-        let mysql_time = <ffi::MYSQL_TIME as FromSql<Time, Mysql>>::from_sql(bytes)?;
+        let mysql_time = <MYSQL_TIME as FromSql<Time, Mysql>>::from_sql(bytes)?;
         NaiveTime::from_hms_opt(
             mysql_time.hour as u32,
             mysql_time.minute as u32,
@@ -121,7 +122,7 @@ impl FromSql<Time, Mysql> for NaiveTime {
 
 impl ToSql<Date, Mysql> for NaiveDate {
     fn to_sql<W: Write>(&self, out: &mut Output<W, Mysql>) -> serialize::Result {
-        let mysql_time = ffi::MYSQL_TIME {
+        let mysql_time = MYSQL_TIME {
             year: self.year() as libc::c_uint,
             month: self.month() as libc::c_uint,
             day: self.day() as libc::c_uint,
@@ -129,17 +130,18 @@ impl ToSql<Date, Mysql> for NaiveDate {
             minute: 0,
             second: 0,
             second_part: 0,
-            neg: 0,
+            neg: false,
             time_type: ffi::enum_mysql_timestamp_type::MYSQL_TIMESTAMP_DATE,
+            time_zone_displacement: 0,
         };
 
-        <ffi::MYSQL_TIME as ToSql<Date, Mysql>>::to_sql(&mysql_time, out)
+        <MYSQL_TIME as ToSql<Date, Mysql>>::to_sql(&mysql_time, out)
     }
 }
 
 impl FromSql<Date, Mysql> for NaiveDate {
     fn from_sql(bytes: Option<MysqlValue<'_>>) -> deserialize::Result<Self> {
-        let mysql_time = <ffi::MYSQL_TIME as FromSql<Date, Mysql>>::from_sql(bytes)?;
+        let mysql_time = <MYSQL_TIME as FromSql<Date, Mysql>>::from_sql(bytes)?;
         NaiveDate::from_ymd_opt(
             mysql_time.year as i32,
             mysql_time.month as u32,
diff --git a/diesel/src/mysql/types/mod.rs b/diesel/src/mysql/types/mod.rs
index 48d6aa05e..1bda52895 100644
--- a/diesel/src/mysql/types/mod.rs
+++ b/diesel/src/mysql/types/mod.rs
@@ -8,7 +8,9 @@ mod numeric;
 mod primitives;
 
 use byteorder::WriteBytesExt;
+use mysqlclient_sys as ffi;
 use std::io::Write;
+use std::os::raw as libc;
 
 use crate::deserialize::{self, FromSql};
 use crate::mysql::{Mysql, MysqlType, MysqlValue};
@@ -17,6 +19,21 @@ use crate::serialize::{self, IsNull, Output, ToSql};
 use crate::sql_types::ops::*;
 use crate::sql_types::*;
 
+#[repr(C)]
+#[derive(Debug, Clone, Copy)]
+pub(crate) struct MYSQL_TIME {
+    pub year: libc::c_uint,
+    pub month: libc::c_uint,
+    pub day: libc::c_uint,
+    pub hour: libc::c_uint,
+    pub minute: libc::c_uint,
+    pub second: libc::c_uint,
+    pub second_part: libc::c_ulong,
+    pub neg: bool,
+    pub time_type: ffi::enum_mysql_timestamp_type,
+    pub time_zone_displacement: libc::c_int,
+}
+
 impl ToSql<TinyInt, Mysql> for i8 {
     fn to_sql<W: Write>(&self, out: &mut Output<W, Mysql>) -> serialize::Result {
         out.write_i8(*self).map(|_| IsNull::No).map_err(Into::into)
diff --git a/diesel/src/mysql/value.rs b/diesel/src/mysql/value.rs
index a9e6e5ce1..8b33bffc7 100644
--- a/diesel/src/mysql/value.rs
+++ b/diesel/src/mysql/value.rs
@@ -1,6 +1,6 @@
 use super::MysqlType;
 use crate::deserialize;
-use mysqlclient_sys as ffi;
+use crate::mysql::types::MYSQL_TIME;
 use std::error::Error;
 
 /// Raw mysql value as received from the database
@@ -26,15 +26,15 @@ impl<'a> MysqlValue<'a> {
     // so clippy is clearly wrong here
     // https://github.com/rust-lang/rust-clippy/issues/2881
     #[allow(dead_code, clippy::cast_ptr_alignment)]
-    pub(crate) fn time_value(&self) -> deserialize::Result<ffi::MYSQL_TIME> {
+    pub(crate) fn time_value(&self) -> deserialize::Result<MYSQL_TIME> {
         match self.tpe {
             MysqlType::Time | MysqlType::Date | MysqlType::DateTime | MysqlType::Timestamp => {
-                let ptr = self.raw.as_ptr() as *const ffi::MYSQL_TIME;
+                let ptr = self.raw.as_ptr() as *const MYSQL_TIME;
                 let result = unsafe { ptr.read_unaligned() };
-                if result.neg == 0 {
-                    Ok(result)
-                } else {
+                if result.neg {
                     Err("Negative dates/times are not yet supported".into())
+                } else {
+                    Ok(result)
                 }
             }
             _ => Err(self.invalid_type_code("timestamp")),
