diff --git a/CHANGELOG.md b/CHANGELOG.md
index ca6b02387..4c59fb60e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -18,6 +18,11 @@ for Rust libraries in [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/
   array that contains null, but a `table!` definition which specifies a type of
   `Array<Nullable<X>>` can now be deserialized to `Vec<Option<T>>`
 
+* [`#[belongs_to]`][belongs-to-0.11.0] associations can now be self referential.
+  This will generate the code required for
+  [`belonging_to`][belonging-to-0.11.0], without generating code for performing
+  a join.
+
 ### Changed
 
 * It is no longer possible to exhaustively match against
diff --git a/diesel/src/macros/associations/belongs_to.rs b/diesel/src/macros/associations/belongs_to.rs
index ad90633ad..15e280a9f 100644
--- a/diesel/src/macros/associations/belongs_to.rs
+++ b/diesel/src/macros/associations/belongs_to.rs
@@ -226,25 +226,27 @@ macro_rules! BelongsTo {
             $($rest:tt)*
         })+],
     ) => {
-        joinable_inner!(
-            left_table_ty = $child_table_name::table,
-            right_table_ty = <$parent_struct as $crate::associations::HasTable>::Table,
-            right_table_expr = <$parent_struct as $crate::associations::HasTable>::table(),
-            foreign_key = $child_table_name::$foreign_key_name,
-            primary_key_ty = <<$parent_struct as $crate::associations::HasTable>::Table as $crate::Table>::PrimaryKey,
-            primary_key_expr = $crate::Table::primary_key(&<$parent_struct as $crate::associations::HasTable>::table()),
-        );
+        static_cond!(if $struct_name != $parent_struct {
+            joinable_inner!(
+                left_table_ty = $child_table_name::table,
+                right_table_ty = <$parent_struct as $crate::associations::HasTable>::Table,
+                right_table_expr = <$parent_struct as $crate::associations::HasTable>::table(),
+                foreign_key = $child_table_name::$foreign_key_name,
+                primary_key_ty = <<$parent_struct as $crate::associations::HasTable>::Table as $crate::Table>::PrimaryKey,
+                primary_key_expr = $crate::Table::primary_key(&<$parent_struct as $crate::associations::HasTable>::table()),
+            );
 
-        $(select_column_inner!(
-            $child_table_name::table,
-            <$parent_struct as $crate::associations::HasTable>::Table,
-            $child_table_name::$column_name,
-        );)+
-        select_column_inner!(
-            $child_table_name::table,
-            <$parent_struct as $crate::associations::HasTable>::Table,
-            $child_table_name::star,
-        );
+            $(select_column_inner!(
+                $child_table_name::table,
+                <$parent_struct as $crate::associations::HasTable>::Table,
+                $child_table_name::$column_name,
+            );)+
+            select_column_inner!(
+                $child_table_name::table,
+                <$parent_struct as $crate::associations::HasTable>::Table,
+                $child_table_name::star,
+            );
+        });
     };
 
     // Handle struct with no generics
diff --git a/diesel_tests/tests/associations.rs b/diesel_tests/tests/associations.rs
index c980d1c74..6c82b1e27 100644
--- a/diesel_tests/tests/associations.rs
+++ b/diesel_tests/tests/associations.rs
@@ -135,6 +135,42 @@ fn associations_can_be_grouped_multiple_levels_deep() {
     assert_eq!(expected_data, data);
 }
 
+#[test]
+fn self_referencing_associations() {
+    #[derive(Insertable, Queryable, Associations, Identifiable)]
+    #[derive(Debug, Clone, Copy, PartialEq)]
+    #[table_name="trees"]
+    #[belongs_to(Tree, foreign_key="parent_id")]
+    struct Tree {
+        id: i32,
+        parent_id: Option<i32>,
+    }
+
+    let conn = connection();
+    let test_data = vec![
+        Tree { id: 1, parent_id: None },
+        Tree { id: 2, parent_id: None },
+        Tree { id: 3, parent_id: Some(1) },
+        Tree { id: 4, parent_id: Some(2) },
+        Tree { id: 5, parent_id: Some(1) },
+    ];
+    insert(&test_data).into(trees::table)
+        .execute(&conn).unwrap();
+
+    let parents = trees::table.filter(trees::parent_id.is_null())
+        .load::<Tree>(&conn).unwrap();
+    let children = Tree::belonging_to(&parents)
+        .load::<Tree>(&conn).unwrap();
+    let children = children.grouped_by(&parents);
+    let data = parents.into_iter().zip(children).collect::<Vec<_>>();
+
+    let expected_data = vec![
+        (test_data[0], vec![test_data[2], test_data[4]]),
+        (test_data[1], vec![test_data[3]]),
+    ];
+    assert_eq!(expected_data, data);
+}
+
 fn conn_with_test_data() -> (TestConnection, User, User, User) {
     let connection = connection_with_sean_and_tess_in_users_table();
     insert(&NewUser::new("Jim", None)).into(users::table).execute(&connection).unwrap();
diff --git a/migrations/mysql/20170215170122_create_trees/down.sql b/migrations/mysql/20170215170122_create_trees/down.sql
new file mode 100644
index 000000000..1135e76a6
--- /dev/null
+++ b/migrations/mysql/20170215170122_create_trees/down.sql
@@ -0,0 +1 @@
+DROP TABLE trees;
diff --git a/migrations/mysql/20170215170122_create_trees/up.sql b/migrations/mysql/20170215170122_create_trees/up.sql
new file mode 100644
index 000000000..4e0db46f3
--- /dev/null
+++ b/migrations/mysql/20170215170122_create_trees/up.sql
@@ -0,0 +1,4 @@
+CREATE TABLE trees (
+  id INTEGER PRIMARY KEY,
+  parent_id INTEGER
+);
diff --git a/migrations/postgresql/20170215170122_create_trees/down.sql b/migrations/postgresql/20170215170122_create_trees/down.sql
new file mode 100644
index 000000000..1135e76a6
--- /dev/null
+++ b/migrations/postgresql/20170215170122_create_trees/down.sql
@@ -0,0 +1 @@
+DROP TABLE trees;
diff --git a/migrations/postgresql/20170215170122_create_trees/up.sql b/migrations/postgresql/20170215170122_create_trees/up.sql
new file mode 100644
index 000000000..c9b7c62a0
--- /dev/null
+++ b/migrations/postgresql/20170215170122_create_trees/up.sql
@@ -0,0 +1,4 @@
+CREATE TABLE trees (
+  id SERIAL PRIMARY KEY,
+  parent_id INTEGER
+);
diff --git a/migrations/sqlite/20170215170122_create_trees/down.sql b/migrations/sqlite/20170215170122_create_trees/down.sql
new file mode 100644
index 000000000..1135e76a6
--- /dev/null
+++ b/migrations/sqlite/20170215170122_create_trees/down.sql
@@ -0,0 +1 @@
+DROP TABLE trees;
diff --git a/migrations/sqlite/20170215170122_create_trees/up.sql b/migrations/sqlite/20170215170122_create_trees/up.sql
new file mode 100644
index 000000000..1b07e5cfe
--- /dev/null
+++ b/migrations/sqlite/20170215170122_create_trees/up.sql
@@ -0,0 +1,4 @@
+CREATE TABLE trees (
+  id INTEGER PRIMARY KEY NOT NULL,
+  parent_id INTEGER
+);
