{"url":"https://api.github.com/repos/diesel-rs/diesel/issues/2071","repository_url":"https://api.github.com/repos/diesel-rs/diesel","labels_url":"https://api.github.com/repos/diesel-rs/diesel/issues/2071/labels{/name}","comments_url":"https://api.github.com/repos/diesel-rs/diesel/issues/2071/comments","events_url":"https://api.github.com/repos/diesel-rs/diesel/issues/2071/events","html_url":"https://github.com/diesel-rs/diesel/issues/2071","id":446676401,"node_id":"MDU6SXNzdWU0NDY2NzY0MDE=","number":2071,"title":"Postgres: We should avoid sending one query per custom type bind","user":{"login":"Ten0","id":9094255,"node_id":"MDQ6VXNlcjkwOTQyNTU=","avatar_url":"https://avatars.githubusercontent.com/u/9094255?v=4","gravatar_id":"","url":"https://api.github.com/users/Ten0","html_url":"https://github.com/Ten0","followers_url":"https://api.github.com/users/Ten0/followers","following_url":"https://api.github.com/users/Ten0/following{/other_user}","gists_url":"https://api.github.com/users/Ten0/gists{/gist_id}","starred_url":"https://api.github.com/users/Ten0/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ten0/subscriptions","organizations_url":"https://api.github.com/users/Ten0/orgs","repos_url":"https://api.github.com/users/Ten0/repos","events_url":"https://api.github.com/users/Ten0/events{/privacy}","received_events_url":"https://api.github.com/users/Ten0/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":254193215,"node_id":"MDU6TGFiZWwyNTQxOTMyMTU=","url":"https://api.github.com/repos/diesel-rs/diesel/labels/help%20wanted","name":"help wanted","color":"159818","default":true,"description":null},{"id":536100334,"node_id":"MDU6TGFiZWw1MzYxMDAzMzQ=","url":"https://api.github.com/repos/diesel-rs/diesel/labels/postgres","name":"postgres","color":"c5def5","default":false,"description":null},{"id":681468190,"node_id":"MDU6TGFiZWw2ODE0NjgxOTA=","url":"https://api.github.com/repos/diesel-rs/diesel/labels/assigned","name":"assigned","color":"0e8a16","default":false,"description":null},{"id":693731039,"node_id":"MDU6TGFiZWw2OTM3MzEwMzk=","url":"https://api.github.com/repos/diesel-rs/diesel/labels/mentoring%20available","name":"mentoring available","color":"0e8a16","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"Ten0","id":9094255,"node_id":"MDQ6VXNlcjkwOTQyNTU=","avatar_url":"https://avatars.githubusercontent.com/u/9094255?v=4","gravatar_id":"","url":"https://api.github.com/users/Ten0","html_url":"https://github.com/Ten0","followers_url":"https://api.github.com/users/Ten0/followers","following_url":"https://api.github.com/users/Ten0/following{/other_user}","gists_url":"https://api.github.com/users/Ten0/gists{/gist_id}","starred_url":"https://api.github.com/users/Ten0/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ten0/subscriptions","organizations_url":"https://api.github.com/users/Ten0/orgs","repos_url":"https://api.github.com/users/Ten0/repos","events_url":"https://api.github.com/users/Ten0/events{/privacy}","received_events_url":"https://api.github.com/users/Ten0/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"Ten0","id":9094255,"node_id":"MDQ6VXNlcjkwOTQyNTU=","avatar_url":"https://avatars.githubusercontent.com/u/9094255?v=4","gravatar_id":"","url":"https://api.github.com/users/Ten0","html_url":"https://github.com/Ten0","followers_url":"https://api.github.com/users/Ten0/followers","following_url":"https://api.github.com/users/Ten0/following{/other_user}","gists_url":"https://api.github.com/users/Ten0/gists{/gist_id}","starred_url":"https://api.github.com/users/Ten0/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ten0/subscriptions","organizations_url":"https://api.github.com/users/Ten0/orgs","repos_url":"https://api.github.com/users/Ten0/repos","events_url":"https://api.github.com/users/Ten0/events{/privacy}","received_events_url":"https://api.github.com/users/Ten0/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":0,"created_at":"2019-05-21T15:11:44Z","updated_at":"2019-06-07T07:57:23Z","closed_at":"2019-06-07T07:57:23Z","author_association":"MEMBER","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"(From gitter)\r\n\r\n@Ten0: \r\nI'm using a custom type in postgres in an app where I need performance and minimal database charge.\r\nHowever, the serialization system seems to be sending queries everytime I serialize one of them:\r\n`SELECT \"pg_type\".\"oid\", \"pg_type\".\"typarray\" FROM \"pg_type\" WHERE \"pg_type\".\"typname\" = $1 LIMIT $2`\r\nThis results in a very large amount of queries that should be avoided.\r\nDo you know why that is, and how I can avoid that ?\r\n\r\n@weiznich : \r\nPostgres requires passing the oid of a bind/return value while executing query. For builtin types those oid's are static so they are hard coded in diesel itself. For custom types they my change, therefore we need to query the oid on use. Probably we could do some caching there so that this query is only executed once, but it seems like nobody hit that as a performance problem yet. I'm willing to provide some mentoring on that if you want.\r\n\r\n@Ten0:\r\nI'm very interested :) How would you go about implementing this ?\r\n\r\n@weiznich: \r\nThe building blocks are already here. PgMetadataLookup needs to be extended to contain/access some kind of connection local lookup table for cashing the results of the queries executed in fn lookup_type(). I would think a HashMap<String, Oid> will be sufficient there.\r\nAdditionally we need to figure out a way to store that lookup table inside of a PgConnection and then pass everything together to the relevant functions. (That's the hard part.) The probably right approach is to look at the change sean has done to Backend::RawValue diesel-rs/diesel@ddf5b46 and do something similar with the Metadata lookup infrastructure. (Which allows us having lifetimes there, which should simplify everything)\r\n\r\nDL;DR rest is implementations discussions\r\n\r\n@Ten0:\r\n That is exactly what I would have done (though not as complex as what is done with RawValue). One of my issues issue was that prepare_query takes a non-mutable reference to the connection and yet has to edit its cache, and I was wondering what was the best way to get around this and what were the constraints on PgConnection (Sync?...), but I've realized that's the same thing for the query cache, which uses a RefCell, so I would use that. (is that ok?)\r\nMy second issue is that the DB::MetadataLookup has to hold a reference to the PgConnection, which means it can't be directly stored in PgConnection itself. So I would still instantiate it in prepare_query and just pass it a reference to the RefCell<HashMap<...>> stored in PgConnection. Storing it directly would not be very flexible and somewhat exposes the internals of PgMetadataLookup, which is unclean. So we would need to create an intermediate structure (PgMetadataCache) holding the RefCell<HashMap<...>> and stored in PgConnection, which then passes a reference to the RefCell to a newly instantiated PgMetadataLookup, but then we get to a point where we have RefCells with sub-structures that hold references on RefCells and it starts to feel somewhat unclean as well.\r\nDo you think it's acceptable to change the public API a bit by making the &PgMetadataLookups mut in addition to the previously described implementation, to get rid of the &RefCell ? This would aply to AstPass that is already accessible mutably whereever it is used (correct me if I'm wrong), and it would seem cleaner to me than having an &RefCell roaming around. Plus it exposes the idea that this may be used to store cache, which would indeed be one of its purposes. Otherwise, would you be satisfied with the previously described implementation ?\r\n\r\n@weiznich: \r\n> I was wondering what was the best way to get around this and what were the constraints on PgConnection (Sync?...), but I've realized that's the same thing for the query cache, which uses a RefCell, so I would use that. (is that ok?)\r\n\r\nPgConnection is Send but not Sync and that should not be changed, so using a RefCell seems fine.\r\n\r\n> Storing it directly would not be very flexible and somewhat exposes the internals of PgMetadataLookup, which is unclean. So we would need to create an intermediate structure (PgMetadataCache) holding the RefCell<HashMap<...>> and stored in PgConnection, which then passes a reference to the RefCell to a newly instantiated PgMetadataLookup, but then we get to a point where we have RefCells with sub-structures that hold references on RefCells and it starts to feel somewhat unclean as well.\r\n\r\nUsing a wrapper struct for RefCell<HashMap<â€¦>> seems like a good idea, but I'm not sure I understand where the second RefCell is coming from. I do not think changing the API from &PgMetadataLookup to &mut PgMetadataLookup is a great idea because that would require a lot of code to be changed.\r\n\r\n> Otherwise, would you be satisfied with the previously described implementation ?\r\n\r\nFrom the rough outline this sounds good, but it's easier to discuss such things on the actual changes on a pull request :wink:\r\n\r\n--- \r\nSo here's the tracking issue.\r\n\r\nAdditionally:  \r\n> I'm not sure I understand where the second RefCell is coming from\r\n\r\nRight, we could just store a reference to the `PgMetadataCache`, but it still means moving around a `!Sync` value that could be `Sync` and some having some `store_metadata(&self)` which feels weird to me since it obviously mutates data. I read the code and it felt like only ~10 lines would need to be changed but I gues we could try the implementation in a PR and see how it feels.\r\n\r\nOpening a PR soon.","closed_by":{"login":"weiznich","id":1674512,"node_id":"MDQ6VXNlcjE2NzQ1MTI=","avatar_url":"https://avatars.githubusercontent.com/u/1674512?v=4","gravatar_id":"","url":"https://api.github.com/users/weiznich","html_url":"https://github.com/weiznich","followers_url":"https://api.github.com/users/weiznich/followers","following_url":"https://api.github.com/users/weiznich/following{/other_user}","gists_url":"https://api.github.com/users/weiznich/gists{/gist_id}","starred_url":"https://api.github.com/users/weiznich/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/weiznich/subscriptions","organizations_url":"https://api.github.com/users/weiznich/orgs","repos_url":"https://api.github.com/users/weiznich/repos","events_url":"https://api.github.com/users/weiznich/events{/privacy}","received_events_url":"https://api.github.com/users/weiznich/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/diesel-rs/diesel/issues/2071/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/diesel-rs/diesel/issues/2071/timeline","performed_via_github_app":null,"state_reason":"completed"}