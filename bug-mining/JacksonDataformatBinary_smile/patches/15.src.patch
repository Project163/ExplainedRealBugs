diff --git a/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileGenerator.java b/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileGenerator.java
index b75cf645..9c61bc26 100644
--- a/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileGenerator.java
+++ b/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileGenerator.java
@@ -82,7 +82,20 @@ public class SmileGenerator
          * this option is disabled by default, and should only be enabled if it is likely that
          * same values repeat relatively often.
          */
-        CHECK_SHARED_STRING_VALUES(false)
+        CHECK_SHARED_STRING_VALUES(false),
+
+        /**
+         * Feature that determines if an invalid surrogate encoding found in the
+         * incoming String should fail with an exception or silently be output
+         * as the Unicode 'REPLACEMENT CHARACTER' (U+FFFD) or not; if not,
+         * an exception will be thrown to indicate invalid content.
+         *<p>
+         * Default value is {@code false} (for backwards compatibility) meaning that
+         * an invalid surrogate will result in exception ({@link IllegalArgumentException}
+         *
+         * @since 2.13
+         */
+        LENIENT_UTF_ENCODING(false),
         ;
 
         protected final boolean _defaultState;
@@ -156,6 +169,14 @@ public class SmileGenerator
     protected final static long MIN_INT_AS_LONG = (long) Integer.MIN_VALUE;
     protected final static long MAX_INT_AS_LONG = (long) Integer.MAX_VALUE;
 
+    /**
+     * The replacement character to use to fix invalid Unicode sequences
+     * (mismatched surrogate pair).
+     *
+     * @since 2.13
+     */
+    protected final static int REPLACEMENT_CHAR = 0xfffd;
+
     /*
     /**********************************************************
     /* Configuration
@@ -1929,22 +1950,19 @@ public class SmileGenerator
                 outBuf[outputPtr++] = (byte) (0x80 | (c & 0x3f));
                 continue;
             }
-            // Yup, a surrogate pair
-            if (c > SURR1_LAST) { // must be from first range; second won't do
-                _throwIllegalSurrogate(c);
-            }
-            // ... meaning it must have a pair
-            if (i >= end) {
-                _throwIllegalSurrogate(c);
-            }
-            c = _convertSurrogate(c, str[i++]);
-            if (c > 0x10FFFF) { // illegal in JSON as well as in XML
-                _throwIllegalSurrogate(c);
+            // Yup, looks like a surrogate pair... but is it?
+            if ((c <= SURR1_LAST) && (i < end)) { // must be from first range and have another char
+                final int d = str[i];
+                if ((d <= SURR2_LAST) && (d >= SURR2_FIRST)) {
+                    ++i;
+                    outputPtr = _decodeAndWriteSurrogate(c, d, outBuf, outputPtr);
+                    continue;
+                }
+                outputPtr = _invalidSurrogateEnd(c, d, outBuf, outputPtr);
+                continue;
             }
-            outBuf[outputPtr++] = (byte) (0xf0 | (c >> 18));
-            outBuf[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));
-            outBuf[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));
-            outBuf[outputPtr++] = (byte) (0x80 | (c & 0x3f));
+            // Nah, something wrong
+            outputPtr = _invalidSurrogateStart(c, outBuf, outputPtr);
         }
         int codedLen = outputPtr - _outputTail;
         _outputTail = outputPtr;
@@ -1993,22 +2011,19 @@ public class SmileGenerator
                 outBuf[outputPtr++] = (byte) (0x80 | (c & 0x3f));
                 continue;
             }
-            // Yup, a surrogate pair
-            if (c > SURR1_LAST) { // must be from first range; second won't do
-                _throwIllegalSurrogate(c);
-            }
-            // ... meaning it must have a pair
-            if (i >= end) {
-                _throwIllegalSurrogate(c);
-            }
-            c = _convertSurrogate(c, str.charAt(i++));
-            if (c > 0x10FFFF) { // illegal in JSON as well as in XML
-                _throwIllegalSurrogate(c);
+            // Yup, looks like a surrogate pair... but is it?
+            if ((c <= SURR1_LAST) && (i < end)) { // must be from first range and have another char
+                final int d = str.charAt(i);
+                if ((d <= SURR2_LAST) && (d >= SURR2_FIRST)) {
+                    ++i;
+                    outputPtr = _decodeAndWriteSurrogate(c, d, outBuf, outputPtr);
+                    continue;
+                }
+                outputPtr = _invalidSurrogateEnd(c, d, outBuf, outputPtr);
+                continue;
             }
-            outBuf[outputPtr++] = (byte) (0xf0 | (c >> 18));
-            outBuf[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));
-            outBuf[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));
-            outBuf[outputPtr++] = (byte) (0x80 | (c & 0x3f));
+            // Nah, something wrong
+            outputPtr = _invalidSurrogateStart(c, outBuf, outputPtr);
         }
         int codedLen = outputPtr - _outputTail;
         _outputTail = outputPtr;
@@ -2021,9 +2036,8 @@ public class SmileGenerator
         
         output_loop:
         while (inputPtr < inputEnd) {
-            /* First, let's ensure we can output at least 4 bytes
-             * (longest UTF-8 encoded codepoint):
-             */
+            // First, let's ensure we can output at least 4 bytes
+            // (longest UTF-8 encoded codepoint):
             if (_outputTail >= bufferEnd) {
                 _flushBuffer();
             }
@@ -2064,22 +2078,19 @@ public class SmileGenerator
                     _outputBuffer[_outputTail++] = (byte) (0x80 | (c & 0x3f));
                     continue;
                 }
-                // Yup, a surrogate:
-                if (c > SURR1_LAST) { // must be from first range
-                    _throwIllegalSurrogate(c);
-                }
-                // and if so, followed by another from next range
-                if (inputPtr >= inputEnd) {
-                    _throwIllegalSurrogate(c);
-                }
-                c = _convertSurrogate(c, str[inputPtr++]);
-                if (c > 0x10FFFF) { // illegal, as per RFC 4627
-                    _throwIllegalSurrogate(c);
+                // Yup, looks like a surrogate pair... but is it?
+                if ((c <= SURR1_LAST) && (inputPtr < inputEnd)) { // must be from first range and have another char
+                    final int d = str[inputPtr];
+                    if ((d <= SURR2_LAST) && (d >= SURR2_FIRST)) {
+                        ++inputPtr;
+                        _outputTail = _decodeAndWriteSurrogate(c, d, _outputBuffer, _outputTail);
+                        continue;
+                    }
+                    _outputTail = _invalidSurrogateEnd(c, d, _outputBuffer, _outputTail);
+                    continue;
                 }
-                _outputBuffer[_outputTail++] = (byte) (0xf0 | (c >> 18));
-                _outputBuffer[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));
-                _outputBuffer[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));
-                _outputBuffer[_outputTail++] = (byte) (0x80 | (c & 0x3f));
+                // Nah, something wrong
+                _outputTail = _invalidSurrogateStart(c, _outputBuffer, _outputTail);
             }
         }
     }
@@ -2090,9 +2101,8 @@ public class SmileGenerator
         
         output_loop:
         while (inputPtr < inputEnd) {
-            /* First, let's ensure we can output at least 4 bytes
-             * (longest UTF-8 encoded codepoint):
-             */
+            // First, let's ensure we can output at least 4 bytes
+            // (longest UTF-8 encoded codepoint):
             if (_outputTail >= bufferEnd) {
                 _flushBuffer();
             }
@@ -2133,63 +2143,88 @@ public class SmileGenerator
                     _outputBuffer[_outputTail++] = (byte) (0x80 | (c & 0x3f));
                     continue;
                 }
-                // Yup, a surrogate:
-                if (c > SURR1_LAST) { // must be from first range
-                    _throwIllegalSurrogate(c);
-                }
-                // and if so, followed by another from next range
-                if (inputPtr >= inputEnd) {
-                    _throwIllegalSurrogate(c);
-                }
-                c = _convertSurrogate(c, str.charAt(inputPtr++));
-                if (c > 0x10FFFF) { // illegal, as per RFC 4627
-                    _throwIllegalSurrogate(c);
+                // Yup, looks like a surrogate pair... but is it?
+                if ((c <= SURR1_LAST) && (inputPtr < inputEnd)) { // must be from first range and have another char
+                    final int d = str.charAt(inputPtr);
+                    if ((d <= SURR2_LAST) && (d >= SURR2_FIRST)) {
+                        ++inputPtr;
+                        _outputTail = _decodeAndWriteSurrogate(c, d, _outputBuffer, _outputTail);
+                        continue;
+                    }
+                    _outputTail = _invalidSurrogateEnd(c, d, _outputBuffer, _outputTail);
+                    continue;
                 }
-                _outputBuffer[_outputTail++] = (byte) (0xf0 | (c >> 18));
-                _outputBuffer[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));
-                _outputBuffer[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));
-                _outputBuffer[_outputTail++] = (byte) (0x80 | (c & 0x3f));
+                // Nah, something wrong
+                _outputTail = _invalidSurrogateStart(c, _outputBuffer, _outputTail);
             }
         }
     }
-    
-    /**
-     * Method called to calculate UTF codepoint, from a surrogate pair.
+
+    /*
+    /**********************************************************************
+    /* Internal methods, surrogate pair handling
+    /**********************************************************************
      */
-    private int _convertSurrogate(int firstPart, int secondPart) throws IOException
+
+    private int _invalidSurrogateStart(int code, byte[] outBuf, int outputPtr)
+        throws IOException
     {
-        // Ok, then, is the second part valid?
-        if (secondPart < SURR2_FIRST || secondPart > SURR2_LAST) {
-            String msg = String.format("Broken surrogate pair: first char 0x%04X, second 0x%04X; illegal combination",
-                    firstPart, secondPart);
-            _reportError(msg);
+        if (isEnabled(Feature.LENIENT_UTF_ENCODING)) {
+            return _appendReplacementChar(outBuf, outputPtr);
+        }
+        // Will be called in two distinct cases: either first character is
+        // invalid (code range of second part), or first character is valid
+        // but there is no second part to encode
+        if (code <= SURR1_LAST) {
+            // Unmatched first part (closing without second part?)
+            _reportError(String.format(
+"Unmatched surrogate pair, starts with valid high surrogate (0x%04X) but ends without low surrogate",
+code));
         }
-        return 0x10000 + ((firstPart - SURR1_FIRST) << 10) + (secondPart - SURR2_FIRST);
+        _reportError(String.format(
+"Invalid surrogate pair, starts with invalid high surrogate (0x%04X), not in valid range [0xD800, 0xDBFF]",
+code));
+        return 0; // never gets here
     }
 
-    private void _throwIllegalSurrogate(int code) throws IOException
+    private int _invalidSurrogateEnd(int surr1, int surr2,
+            byte[] outBuf, int outputPtr)
+        throws IOException
     {
-        if (code > 0x10FFFF) { // over max?
-            _reportError(String.format(
-                    "Illegal character point (0x%X) to output; max is 0x10FFFF as per RFC 4627", code));
-        }
-        if (code >= SURR1_FIRST) {
-            if (code <= SURR1_LAST) { // Unmatched first part (closing without second part?)
-                _reportError(String.format(
-                    "Unmatched first part of surrogate pair (0x%04X)", code));
-            }
-            _reportError(String.format(
-                    "Unmatched second part of surrogate pair (0x%04X)", code));
+        if (isEnabled(Feature.LENIENT_UTF_ENCODING)) {
+            return _appendReplacementChar(outBuf, outputPtr);
         }
-        // should we ever get this?
-        _reportError(String.format("Illegal character point (0x%X) to output", code));
+        _reportError(String.format(
+"Invalid surrogate pair, starts with valid high surrogate (0x%04X)"
++" but ends with invalid low surrogate (0x%04X), not in valid range [0xDC00, 0xDFFF]",
+surr1, surr2));
+        return 0; // never gets here
+    }
+
+    private int _appendReplacementChar(byte[] outBuf, int outputPtr) {
+        outBuf[outputPtr++] = (byte) (0xe0 | (REPLACEMENT_CHAR >> 12));
+        outBuf[outputPtr++] = (byte) (0x80 | ((REPLACEMENT_CHAR >> 6) & 0x3f));
+        outBuf[outputPtr++] = (byte) (0x80 | (REPLACEMENT_CHAR & 0x3f));
+        return outputPtr;
+    }
+
+    private int _decodeAndWriteSurrogate(int surr1, int surr2,
+            byte[] outBuf, int outputPtr)
+    {
+        final int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10)
+                + (surr2 - SURR2_FIRST);
+        outBuf[outputPtr++] = (byte) (0xf0 | (c >> 18));
+        outBuf[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));
+        outBuf[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));
+        outBuf[outputPtr++] = (byte) (0x80 | (c & 0x3f));
+        return outputPtr;
     }
 
     /*
     /**********************************************************
     /* Internal methods, writing bytes
     /**********************************************************
-    */
+     */
 
     private final void _ensureRoomForOutput(int needed) throws IOException
     {
diff --git a/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/gen/LenientUnicodeSmileGenerationTest.java b/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/gen/LenientUnicodeSmileGenerationTest.java
new file mode 100644
index 00000000..0f193414
--- /dev/null
+++ b/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/gen/LenientUnicodeSmileGenerationTest.java
@@ -0,0 +1,116 @@
+package com.fasterxml.jackson.dataformat.smile.gen;
+
+import java.io.ByteArrayOutputStream;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.core.exc.StreamWriteException;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import com.fasterxml.jackson.dataformat.smile.*;
+import com.fasterxml.jackson.dataformat.smile.databind.SmileMapper;
+
+public class LenientUnicodeSmileGenerationTest extends BaseTestForSmile
+{
+    private final SmileMapper MAPPER = smileMapper();
+
+    private final ObjectWriter LENIENT_WRITER = MAPPER.writer()
+            .with(SmileGenerator.Feature.LENIENT_UTF_ENCODING);
+
+    /**
+     * Test that encoding a String containing invalid surrogates fail with an exception
+     */
+    public void testFailForInvalidSurrogate() throws Exception
+    {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+        try (JsonGenerator gen = MAPPER.createGenerator(out)) {
+            assertEquals(0, gen.getOutputBuffered());
+            try {
+                // Invalid first surrogate character
+                gen.writeString("x\ud83d");
+                fail("Should not pass");
+            } catch (StreamWriteException e) {
+                verifyException(e, "Unmatched surrogate pair");
+                verifyException(e, "0xD83D");
+                verifyException(e, "without low surrogate");
+            }
+            assertEquals(1, gen.getOutputBuffered());
+        }
+    
+        try (JsonGenerator gen = MAPPER.createGenerator(out)) {
+            try {
+                // Missing second surrogate character
+                gen.writeString("x\ude01");
+                fail("Should not pass");
+            } catch (StreamWriteException e) {
+                verifyException(e, "Invalid surrogate pair");
+                verifyException(e, "0xDE01");
+                verifyException(e, "invalid high surrogate");
+            }
+            assertEquals(1, gen.getOutputBuffered());
+        }
+
+        try (JsonGenerator gen = MAPPER.createGenerator(out)) {
+            try {
+                // Invalid second surrogate character (1)
+                gen.writeString("x\ud801\ud802");
+                fail("Should not pass");
+            } catch (StreamWriteException e) {
+                verifyException(e, "Invalid surrogate pair");
+                verifyException(e, "0xD801");
+                verifyException(e, "0xD802");
+                verifyException(e, "valid high surrogate");
+                verifyException(e, "invalid low surrogate");
+            }
+            assertEquals(1, gen.getOutputBuffered());
+        }
+
+        try (JsonGenerator gen = MAPPER.createGenerator(out)) {
+            try {
+                gen.writeString("x\ud83dx");
+                fail("Should not pass");
+            } catch (StreamWriteException e) {
+                verifyException(e, "Invalid surrogate pair");
+                verifyException(e, "0xD83D");
+                verifyException(e, "0x0078");
+                verifyException(e, "valid high surrogate");
+                verifyException(e, "invalid low surrogate");
+            }
+            assertEquals(1, gen.getOutputBuffered());
+        }
+    }
+
+    /**
+     * Test that when the lenient unicode feature is enabled, the replacement character is used to fix invalid sequences
+     */
+    public void testRecoverInvalidSurrogate1() throws Exception
+    {
+        // Unmatched first surrogate character
+        _writeAndVerifyLenientString("x\ud83d", "x\ufffd");
+
+        // Unmatched second surrogate character
+        _writeAndVerifyLenientString("x\ude01", "x\ufffd");
+
+        // Unmatched second surrogate character (2)
+        _writeAndVerifyLenientString("x\ude01x", "x\ufffdx");
+    }
+
+    public void testRecoverInvalidSurrogate2() throws Exception
+    {
+        _writeAndVerifyLenientString("X\ud83dY", "X\ufffdY");
+    }
+
+    private void _writeAndVerifyLenientString(String inputText, String expText) throws Exception
+    {
+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+        try (JsonGenerator g = LENIENT_WRITER.createGenerator(bytes)) {
+            g.writeString(inputText);
+        }
+        try (JsonParser p = MAPPER.createParser(bytes.toByteArray())) {
+            assertToken(JsonToken.VALUE_STRING, p.nextToken());
+            assertEquals(expText, p.getText());
+            assertNull(p.nextToken());
+        }
+    }
+}
