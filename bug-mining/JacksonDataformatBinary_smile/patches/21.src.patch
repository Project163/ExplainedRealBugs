diff --git a/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileParser.java b/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileParser.java
index e6590768..b67ab588 100644
--- a/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileParser.java
+++ b/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileParser.java
@@ -276,6 +276,7 @@ versionBits));
         if (_inputStream != null) {
             int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);
             _currInputProcessed += _inputEnd;
+            _streamReadConstraints.validateDocumentLength(_currInputProcessed);
             _inputPtr = 0;
             if (count > 0) {
                 _inputEnd = count;
@@ -334,6 +335,7 @@ versionBits));
         // Need to move remaining data in front?
         int amount = _inputEnd - _inputPtr;
         _currInputProcessed += _inputPtr;
+        _streamReadConstraints.validateDocumentLength(_currInputProcessed);
         if (amount > 0 && _inputPtr > 0) {
             //_currInputRowStart -= _inputPtr;
             System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);
@@ -2246,7 +2248,7 @@ versionBits));
         if (raw.length == 0) {
             _numberBigInt = BigInteger.ZERO;
         } else {
-            streamReadConstraints().validateIntegerLength(raw.length);
+            _streamReadConstraints.validateIntegerLength(raw.length);
             _numberBigInt = new BigInteger(raw);
         }
         _numTypesValid = NR_BIGINT;
@@ -2294,7 +2296,7 @@ versionBits));
         if (raw.length == 0) {
             _numberBigDecimal = BigDecimal.ZERO;
         } else {
-            streamReadConstraints().validateFPLength(raw.length);
+            _streamReadConstraints.validateFPLength(raw.length);
             BigInteger unscaledValue = new BigInteger(raw);
             _numberBigDecimal = new BigDecimal(unscaledValue, scale);
         }
@@ -3129,12 +3131,12 @@ strLenBytes, firstUTFByteValue, truncatedCharOffset, bytesExpected));
 
     private void createChildArrayContext(final int lineNr, final int colNr) throws IOException {
         _streamReadContext = _streamReadContext.createChildArrayContext(lineNr, colNr);
-        streamReadConstraints().validateNestingDepth(_streamReadContext.getNestingDepth());
+        _streamReadConstraints.validateNestingDepth(_streamReadContext.getNestingDepth());
     }
 
     private void createChildObjectContext(final int lineNr, final int colNr) throws IOException {
         _streamReadContext = _streamReadContext.createChildObjectContext(lineNr, colNr);
-        streamReadConstraints().validateNestingDepth(_streamReadContext.getNestingDepth());
+        _streamReadConstraints.validateNestingDepth(_streamReadContext.getNestingDepth());
     }
 }
 
diff --git a/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileParserBase.java b/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileParserBase.java
index 0313869d..6e6c33d7 100644
--- a/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileParserBase.java
+++ b/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/SmileParserBase.java
@@ -71,6 +71,11 @@ public abstract class SmileParserBase extends ParserMinimalBase
      */
     protected final IOContext _ioContext;
 
+    /**
+     * @since 2.17
+     */
+    protected final StreamReadConstraints _streamReadConstraints;
+
     /**
      * Flag that indicates whether parser is closed or not. Gets
      * set when parser is either closed by explicit call
@@ -252,6 +257,7 @@ public abstract class SmileParserBase extends ParserMinimalBase
         super(parserFeatures);
         _formatFeatures = formatFeatures;
         _ioContext = ctxt;
+        _streamReadConstraints = ctxt.streamReadConstraints();
         _symbols = sym;
         _symbolsCanonical = sym.isCanonicalizing();
         DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(parserFeatures)
@@ -262,7 +268,7 @@ public abstract class SmileParserBase extends ParserMinimalBase
 
     @Override
     public StreamReadConstraints streamReadConstraints() {
-        return _ioContext.streamReadConstraints();
+        return _streamReadConstraints;
     }
 
     /*
@@ -678,7 +684,7 @@ public abstract class SmileParserBase extends ParserMinimalBase
     {
         if ((_numTypesValid & NR_BIGDECIMAL) != 0) {
             // here it'll just get truncated, no exceptions thrown
-            streamReadConstraints().validateBigIntegerScale(_numberBigDecimal.scale());
+            _streamReadConstraints.validateBigIntegerScale(_numberBigDecimal.scale());
             _numberBigInt = _numberBigDecimal.toBigInteger();
         } else if ((_numTypesValid & NR_LONG) != 0) {
             _numberBigInt = BigInteger.valueOf(_numberLong);
diff --git a/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/async/NonBlockingByteArrayParser.java b/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/async/NonBlockingByteArrayParser.java
index 5b148de4..ce7f4511 100644
--- a/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/async/NonBlockingByteArrayParser.java
+++ b/smile/src/main/java/com/fasterxml/jackson/dataformat/smile/async/NonBlockingByteArrayParser.java
@@ -90,6 +90,7 @@ public class NonBlockingByteArrayParser
         }
         // Time to update pointers first
         _currInputProcessed += _origBufferLen;
+        _streamReadConstraints.validateDocumentLength(_currInputProcessed);
 
         // And then update buffer settings
         _inputBuffer = buf;
@@ -1291,7 +1292,7 @@ public class NonBlockingByteArrayParser
     {
         if (_decode7BitEncoded()) { // got it all!
             final byte[] array = _byteArrayBuilder.toByteArray();
-            streamReadConstraints().validateIntegerLength(array.length);
+            _streamReadConstraints.validateIntegerLength(array.length);
             _numberBigInt = new BigInteger(array);
             _numberType = NumberType.BIG_INTEGER;
             _numTypesValid = NR_BIGINT;
@@ -1440,7 +1441,7 @@ public class NonBlockingByteArrayParser
             // note: scale value is signed, needs zigzag, so:
             final int scale = SmileUtil.zigzagDecode((int) _pending64);
             final byte[] array = _byteArrayBuilder.toByteArray();
-            streamReadConstraints().validateFPLength(array.length);
+            _streamReadConstraints.validateFPLength(array.length);
             BigInteger bigInt = new BigInteger(array);
             _numberBigDecimal = new BigDecimal(bigInt, scale);
             _numberType = NumberType.BIG_DECIMAL;
diff --git a/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/constraints/DeeplyNestedSmileReadWriteTest.java b/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/constraints/DeeplyNestedSmileReadWriteTest.java
index 26f258e8..9955c037 100644
--- a/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/constraints/DeeplyNestedSmileReadWriteTest.java
+++ b/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/constraints/DeeplyNestedSmileReadWriteTest.java
@@ -7,6 +7,7 @@ import com.fasterxml.jackson.core.exc.StreamConstraintsException;
 
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.fasterxml.jackson.databind.node.ObjectNode;
 
 import com.fasterxml.jackson.dataformat.smile.SmileFactory;
@@ -15,7 +16,7 @@ import com.fasterxml.jackson.dataformat.smile.BaseTestForSmile;
 
 public class DeeplyNestedSmileReadWriteTest extends BaseTestForSmile
 {
-    private final ObjectMapper MAPPER_VANILLA = smileMapper();
+    private final ObjectMapper MAPPER_VANILLA = smileMapper(false, true, false);
 
     private final ObjectMapper MAPPER_CONSTRAINED = new SmileMapper(
             SmileFactory.builder()
@@ -27,17 +28,18 @@ public class DeeplyNestedSmileReadWriteTest extends BaseTestForSmile
             .build()
             );
 
-    public void testDeepNestingRead() throws Exception
-    {
-        final byte[] DOC = MAPPER_CONSTRAINED.writeValueAsBytes(createDeepNestedDoc(11));
-        try (JsonParser p = MAPPER_CONSTRAINED.createParser(DOC)) {
-            _testDeepNestingRead(p);
-        }
+    public void testDeepNestingArrayRead() throws Exception {
+        _testDeepNestingRead(createDeepNestedArrayDoc(13));
+    }
+
+    public void testDeepNestingObjectRead() throws Exception {
+        _testDeepNestingRead(createDeepNestedObjectDoc(13));
     }
 
-    private void _testDeepNestingRead(JsonParser p) throws Exception
+    private void _testDeepNestingRead(JsonNode docRoot) throws Exception
     {
-        try {
+        byte[] doc = MAPPER_VANILLA.writeValueAsBytes(docRoot);
+        try (JsonParser p = MAPPER_CONSTRAINED.createParser(doc)) {
             while (p.nextToken() != null) { }
             fail("expected StreamConstraintsException");
         } catch (StreamConstraintsException e) {
@@ -46,9 +48,16 @@ public class DeeplyNestedSmileReadWriteTest extends BaseTestForSmile
         }
     }
 
-    public void testDeepNestingWrite() throws Exception
+    public void testDeepNestingArrayWrite() throws Exception {
+        _testDeepNestingWrite(createDeepNestedArrayDoc(13));
+    }
+
+    public void testDeepNestingObjectWrite() throws Exception {
+        _testDeepNestingWrite(createDeepNestedObjectDoc(13));
+    }
+
+    private void _testDeepNestingWrite(JsonNode docRoot) throws Exception
     {
-        final JsonNode docRoot = createDeepNestedDoc(13);
         try {
             MAPPER_CONSTRAINED.writeValueAsBytes(docRoot);
             fail("Should not pass");
@@ -58,7 +67,19 @@ public class DeeplyNestedSmileReadWriteTest extends BaseTestForSmile
         }
     }
 
-    private JsonNode createDeepNestedDoc(final int depth) throws Exception
+    private JsonNode createDeepNestedArrayDoc(final int depth) throws Exception
+    {
+        final ArrayNode root = MAPPER_VANILLA.createArrayNode();
+        ArrayNode curr = root;
+        for (int i = 0; i < depth; ++i) {
+            curr.add(42);
+            curr = curr.addArray();
+        }
+        curr.add("text");
+        return root;
+    }
+
+    private JsonNode createDeepNestedObjectDoc(final int depth) throws Exception
     {
         final ObjectNode root = MAPPER_VANILLA.createObjectNode();
         ObjectNode curr = root;
diff --git a/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/constraints/LongDocumentSmileReadTest.java b/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/constraints/LongDocumentSmileReadTest.java
new file mode 100644
index 00000000..7d650545
--- /dev/null
+++ b/smile/src/test/java/com/fasterxml/jackson/dataformat/smile/constraints/LongDocumentSmileReadTest.java
@@ -0,0 +1,64 @@
+package com.fasterxml.jackson.dataformat.smile.constraints;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.util.UUID;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.StreamReadConstraints;
+import com.fasterxml.jackson.core.exc.StreamConstraintsException;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.dataformat.smile.SmileFactory;
+import com.fasterxml.jackson.dataformat.smile.databind.SmileMapper;
+import com.fasterxml.jackson.dataformat.smile.BaseTestForSmile;
+
+public class LongDocumentSmileReadTest extends BaseTestForSmile
+{
+    private final ObjectMapper MAPPER_VANILLA = new SmileMapper();
+
+    private final ObjectMapper MAPPER_CONSTRAINED = new SmileMapper(
+            SmileFactory.builder()
+            // limit to 100kB doc reads
+                .streamReadConstraints(StreamReadConstraints.builder()
+                    .maxDocumentLength(50_000)
+            .build()
+            ).build());
+
+    public void testLongDocumentConstraint() throws Exception
+    {
+        // Need a bit longer than minimum since checking is approximate, not exact
+        byte[] doc = createBigDoc(60_000);
+        // Must read from `InputStream` as validation is during "loadMore()":
+        try (JsonParser p = MAPPER_CONSTRAINED.createParser(new ByteArrayInputStream(doc))) {
+            while (p.nextToken() != null) { }
+            fail("expected StreamConstraintsException");
+        } catch (StreamConstraintsException e) {
+            final String msg = e.getMessage();
+
+            assertTrue(msg.contains("Document length ("));
+            assertTrue(msg.contains("exceeds the maximum allowed (50000"));
+        }
+    }
+    
+    private byte[] createBigDoc(final int size) throws Exception
+    {
+        ByteArrayOutputStream bytes = new ByteArrayOutputStream(size + 1000);
+        try (JsonGenerator g = MAPPER_VANILLA.createGenerator(bytes)) {
+            g.writeStartArray();
+
+            do {
+                g.writeStartObject();
+                g.writeStringField("id", UUID.randomUUID().toString());
+                g.writeNumberField("size", bytes.size());
+                g.writeNumberField("stuff", Long.MAX_VALUE);
+                g.writeEndObject();
+                
+                g.flush();
+            } while (bytes.size() < size);
+            g.writeEndArray();
+        }
+        return bytes.toByteArray();
+    }
+}
