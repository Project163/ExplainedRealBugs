diff --git a/mapping/reflect.go b/mapping/reflect.go
index 59bde993..3068b190 100644
--- a/mapping/reflect.go
+++ b/mapping/reflect.go
@@ -51,6 +51,11 @@ func lookupPropertyPathPart(data interface{}, part string) interface{} {
 		if field.IsValid() && field.CanInterface() {
 			return field.Interface()
 		}
+	case reflect.Ptr:
+		ptrElem := val.Elem()
+		if ptrElem.IsValid() && ptrElem.CanInterface() {
+			return lookupPropertyPathPart(ptrElem.Interface(), part)
+		}
 	}
 	return nil
 }
diff --git a/mapping/reflect_test.go b/mapping/reflect_test.go
new file mode 100644
index 00000000..fdba06f8
--- /dev/null
+++ b/mapping/reflect_test.go
@@ -0,0 +1,47 @@
+package mapping
+
+import (
+	"reflect"
+	"testing"
+)
+
+func TestLookupPropertyPath(t *testing.T) {
+	tests := []struct {
+		input  interface{}
+		path   string
+		output interface{}
+	}{
+		{
+			input: map[string]interface{}{
+				"Type": "a",
+			},
+			path:   "Type",
+			output: "a",
+		},
+		{
+			input: struct {
+				Type string
+			}{
+				Type: "b",
+			},
+			path:   "Type",
+			output: "b",
+		},
+		{
+			input: &struct {
+				Type string
+			}{
+				Type: "b",
+			},
+			path:   "Type",
+			output: "b",
+		},
+	}
+
+	for _, test := range tests {
+		actual := lookupPropertyPath(test.input, test.path)
+		if !reflect.DeepEqual(actual, test.output) {
+			t.Fatalf("expected '%v', got '%v', for path '%s' in  %+v", test.output, actual, test.path, test.input)
+		}
+	}
+}
