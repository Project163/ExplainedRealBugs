diff --git a/analysis/token/edgengram/edgengram.go b/analysis/token/edgengram/edgengram.go
index e17db9e7..1628193d 100644
--- a/analysis/token/edgengram/edgengram.go
+++ b/analysis/token/edgengram/edgengram.go
@@ -55,7 +55,7 @@ func (s *EdgeNgramFilter) Filter(input analysis.TokenStream) analysis.TokenStrea
 			// index of the starting rune for this token
 			for ngramSize := s.minLength; ngramSize <= s.maxLength; ngramSize++ {
 				// build an ngram of this size starting at i
-				if i-ngramSize > 0 {
+				if i-ngramSize >= 0 {
 					ngramTerm := analysis.BuildTermFromRunes(runes[i-ngramSize : i])
 					token := analysis.Token{
 						Position: token.Position,
diff --git a/analysis/token/edgengram/edgengram_test.go b/analysis/token/edgengram/edgengram_test.go
index 19edf0e5..1be4db38 100644
--- a/analysis/token/edgengram/edgengram_test.go
+++ b/analysis/token/edgengram/edgengram_test.go
@@ -135,6 +135,48 @@ func TestEdgeNgramFilter(t *testing.T) {
 				},
 			},
 		},
+		{
+			side: BACK,
+			min:  3,
+			max:  5,
+			input: analysis.TokenStream{
+				&analysis.Token{
+					Term: []byte("Beryl"),
+				},
+			},
+			output: analysis.TokenStream{
+				&analysis.Token{
+					Term: []byte("ryl"),
+				},
+				&analysis.Token{
+					Term: []byte("eryl"),
+				},
+				&analysis.Token{
+					Term: []byte("Beryl"),
+				},
+			},
+		},
+		{
+			side: FRONT,
+			min:  3,
+			max:  5,
+			input: analysis.TokenStream{
+				&analysis.Token{
+					Term: []byte("Beryl"),
+				},
+			},
+			output: analysis.TokenStream{
+				&analysis.Token{
+					Term: []byte("Ber"),
+				},
+				&analysis.Token{
+					Term: []byte("Bery"),
+				},
+				&analysis.Token{
+					Term: []byte("Beryl"),
+				},
+			},
+		},
 	}
 
 	for _, test := range tests {
