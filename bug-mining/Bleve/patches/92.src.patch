diff --git a/query_boolean.go b/query_boolean.go
index 46dc4db4..16e59504 100644
--- a/query_boolean.go
+++ b/query_boolean.go
@@ -31,14 +31,10 @@ type booleanQuery struct {
 // must Queries.
 // Result documents must satisfy NONE of the must not
 // Queries.
-// If there are any should queries, result documents
-// must satisfy at least one of them.
+// Result documents that ALSO satisfy any of the should
+// Queries will score higher.
 func NewBooleanQuery(must []Query, should []Query, mustNot []Query) *booleanQuery {
-	min := 0.0
-	if len(should) > 0 {
-		min = 1.0
-	}
-	return NewBooleanQueryMinShould(must, should, mustNot, min)
+	return NewBooleanQueryMinShould(must, should, mustNot, 0.0)
 }
 
 // NewBooleanQueryMinShould is the same as
@@ -63,6 +59,12 @@ func NewBooleanQueryMinShould(must []Query, should []Query, mustNot []Query, min
 	return &rv
 }
 
+// SetMinShould requires that at least minShould of the
+// should Queries must be satisfied.
+func (q *booleanQuery) SetMinShould(minShould float64) {
+	q.Should.(*disjunctionQuery).SetMin(minShould)
+}
+
 func (q *booleanQuery) AddMust(m Query) {
 	if q.Must == nil {
 		q.Must = NewConjunctionQuery([]Query{})
@@ -75,7 +77,6 @@ func (q *booleanQuery) AddShould(m Query) {
 		q.Should = NewDisjunctionQuery([]Query{})
 	}
 	q.Should.(*disjunctionQuery).AddQuery(m)
-	q.Should.(*disjunctionQuery).SetMin(1)
 }
 
 func (q *booleanQuery) AddMustNot(m Query) {
diff --git a/query_test.go b/query_test.go
index d5281f59..91c27619 100644
--- a/query_test.go
+++ b/query_test.go
@@ -40,10 +40,11 @@ func TestParseQuery(t *testing.T) {
 		},
 		{
 			input: []byte(`{"must":{"conjuncts": [{"match":"beer","field":"desc"}]},"should":{"disjuncts": [{"match":"water","field":"desc"}],"min":1.0},"must_not":{"disjuncts": [{"match":"devon","field":"desc"}]}}`),
-			output: NewBooleanQuery(
+			output: NewBooleanQueryMinShould(
 				[]Query{NewMatchQuery("beer").SetField("desc")},
 				[]Query{NewMatchQuery("water").SetField("desc")},
-				[]Query{NewMatchQuery("devon").SetField("desc")}),
+				[]Query{NewMatchQuery("devon").SetField("desc")},
+				1.0),
 		},
 		{
 			input:  []byte(`{"terms":["watered","down"],"field":"desc"}`),
@@ -96,7 +97,6 @@ func TestParseQuery(t *testing.T) {
 
 		if !reflect.DeepEqual(test.output, actual) {
 			t.Errorf("expected: %#v, got: %#v", test.output, actual)
-			// t.Errorf("expected: %#v, got: %#v", test.output.(*BooleanQuery).Should, actual.(*BooleanQuery).Should)
 		}
 	}
 }
@@ -280,7 +280,7 @@ func TestDumpQuery(t *testing.T) {
       }
     ],
     "boost": 1,
-    "min": 1
+    "min": 0
   },
   "must_not": {
     "disjuncts": [
diff --git a/test/tests/basic/searches.json b/test/tests/basic/searches.json
index d6f457ef..daeee938 100644
--- a/test/tests/basic/searches.json
+++ b/test/tests/basic/searches.json
@@ -60,7 +60,7 @@
 		"result": {
 			"total_hits": 0,
 			"hits": []
-		} 
+		}
 	},
 	{
 		"search": {
@@ -558,5 +558,29 @@
 				}
 			]
 		}
+	},
+	{
+		"comment": "test query string MUST and SHOULD",
+		"search": {
+			"from": 0,
+			"size": 10,
+			"query": {
+				"query": "+age:>20 missess"
+			}
+		},
+		"result": {
+			"total_hits": 3,
+			"hits": [
+				{
+					"id": "b"
+				},
+				{
+					"id": "d"
+				},
+				{
+					"id": "c"
+				}
+			]
+		}
 	}
-]
\ No newline at end of file
+]
