diff --git a/index/upside_down/row.go b/index/upside_down/row.go
index d5cec28b..1e3bb942 100644
--- a/index/upside_down/row.go
+++ b/index/upside_down/row.go
@@ -191,10 +191,8 @@ func (dr *DictionaryRow) Key() []byte {
 
 func (dr *DictionaryRow) Value() []byte {
 	used := 0
-	buf := make([]byte, 8)
-
-	used += binary.PutUvarint(buf[used:used+8], dr.count)
-
+	buf := make([]byte, binary.MaxVarintLen64)
+	used += binary.PutUvarint(buf, dr.count)
 	return buf[0:used]
 }
 
diff --git a/index/upside_down/row_test.go b/index/upside_down/row_test.go
index 98c7affa..b7ce53c9 100644
--- a/index/upside_down/row_test.go
+++ b/index/upside_down/row_test.go
@@ -10,6 +10,7 @@
 package upside_down
 
 import (
+	"math"
 	"reflect"
 	"testing"
 
@@ -230,6 +231,24 @@ func TestInvalidRows(t *testing.T) {
 	}
 }
 
+func TestDictionaryRowValueBug197(t *testing.T) {
+	// this was the smallest value that would trigger a crash
+	dr := &DictionaryRow{
+		field: 0,
+		term:  []byte("marty"),
+		count: 72057594037927936,
+	}
+	dr.Value()
+	// this is the maximum possible value
+	dr = &DictionaryRow{
+		field: 0,
+		term:  []byte("marty"),
+		count: math.MaxUint64,
+	}
+	dr.Value()
+	// neither of these should panic
+}
+
 func BenchmarkTermFrequencyRowEncode(b *testing.B) {
 	for i := 0; i < b.N; i++ {
 		row := NewTermFrequencyRowWithTermVectors(
