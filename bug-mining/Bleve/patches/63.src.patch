diff --git a/search/highlight/fragment_formatters/ansi/fragment_formatter_ansi.go b/search/highlight/fragment_formatters/ansi/fragment_formatter_ansi.go
index ae393e26..f5c74c5c 100644
--- a/search/highlight/fragment_formatters/ansi/fragment_formatter_ansi.go
+++ b/search/highlight/fragment_formatters/ansi/fragment_formatter_ansi.go
@@ -11,7 +11,6 @@ package ansi
 
 import (
 	"github.com/blevesearch/bleve/registry"
-	"github.com/blevesearch/bleve/search"
 	"github.com/blevesearch/bleve/search/highlight"
 )
 
@@ -29,11 +28,13 @@ func NewFragmentFormatter(color string) *FragmentFormatter {
 	}
 }
 
-func (a *FragmentFormatter) Format(f *highlight.Fragment, tlm search.TermLocationMap) string {
-	orderedTermLocations := highlight.OrderTermLocations(tlm)
+func (a *FragmentFormatter) Format(f *highlight.Fragment, orderedTermLocations highlight.TermLocations) string {
 	rv := ""
 	curr := f.Start
 	for _, termLocation := range orderedTermLocations {
+		if termLocation == nil {
+			continue
+		}
 		if termLocation.Start < curr {
 			continue
 		}
diff --git a/search/highlight/fragment_formatters/html/fragment_formatter_html.go b/search/highlight/fragment_formatters/html/fragment_formatter_html.go
index e5fa6417..cd774fbe 100644
--- a/search/highlight/fragment_formatters/html/fragment_formatter_html.go
+++ b/search/highlight/fragment_formatters/html/fragment_formatter_html.go
@@ -11,7 +11,6 @@ package html
 
 import (
 	"github.com/blevesearch/bleve/registry"
-	"github.com/blevesearch/bleve/search"
 	"github.com/blevesearch/bleve/search/highlight"
 )
 
@@ -32,11 +31,13 @@ func NewFragmentFormatter(before, after string) *FragmentFormatter {
 	}
 }
 
-func (a *FragmentFormatter) Format(f *highlight.Fragment, tlm search.TermLocationMap) string {
-	orderedTermLocations := highlight.OrderTermLocations(tlm)
+func (a *FragmentFormatter) Format(f *highlight.Fragment, orderedTermLocations highlight.TermLocations) string {
 	rv := ""
 	curr := f.Start
 	for _, termLocation := range orderedTermLocations {
+		if termLocation == nil {
+			continue
+		}
 		if termLocation.Start < curr {
 			continue
 		}
diff --git a/search/highlight/fragment_formatters/html/fragment_formatter_html_test.go b/search/highlight/fragment_formatters/html/fragment_formatter_html_test.go
index 56a04c4d..c5914f6f 100644
--- a/search/highlight/fragment_formatters/html/fragment_formatter_html_test.go
+++ b/search/highlight/fragment_formatters/html/fragment_formatter_html_test.go
@@ -43,7 +43,8 @@ func TestHTMLFragmentFormatter1(t *testing.T) {
 
 	emHTMLFormatter := NewFragmentFormatter("<b>", "</b>")
 	for _, test := range tests {
-		result := emHTMLFormatter.Format(test.fragment, test.tlm)
+		otl := highlight.OrderTermLocations(test.tlm)
+		result := emHTMLFormatter.Format(test.fragment, otl)
 		if result != test.output {
 			t.Errorf("expected `%s`, got `%s`", test.output, result)
 		}
@@ -77,7 +78,8 @@ func TestHTMLFragmentFormatter2(t *testing.T) {
 
 	emHTMLFormatter := NewFragmentFormatter("<em>", "</em>")
 	for _, test := range tests {
-		result := emHTMLFormatter.Format(test.fragment, test.tlm)
+		otl := highlight.OrderTermLocations(test.tlm)
+		result := emHTMLFormatter.Format(test.fragment, otl)
 		if result != test.output {
 			t.Errorf("expected `%s`, got `%s`", test.output, result)
 		}
diff --git a/search/highlight/fragmenters/simple/fragmenter_simple.go b/search/highlight/fragmenters/simple/fragmenter_simple.go
index d78aacaa..55b33afe 100644
--- a/search/highlight/fragmenters/simple/fragmenter_simple.go
+++ b/search/highlight/fragmenters/simple/fragmenter_simple.go
@@ -79,7 +79,10 @@ OUTER:
 
 		// find the smaller of the two rooms to move
 		roomToMove := utf8.RuneCount(orig[minend:end])
-		roomToMoveStart := utf8.RuneCount(orig[maxbegin:start])
+		roomToMoveStart := 0
+		if start >= maxbegin {
+			roomToMoveStart = utf8.RuneCount(orig[maxbegin:start])
+		}
 		if roomToMoveStart < roomToMove {
 			roomToMove = roomToMoveStart
 		}
diff --git a/search/highlight/fragmenters/simple/fragmenter_simple_test.go b/search/highlight/fragmenters/simple/fragmenter_simple_test.go
index 99ada6e1..03c20417 100644
--- a/search/highlight/fragmenters/simple/fragmenter_simple_test.go
+++ b/search/highlight/fragmenters/simple/fragmenter_simple_test.go
@@ -199,6 +199,36 @@ func TestSimpleFragmenter(t *testing.T) {
 			},
 			size: 200,
 		},
+		{
+			orig: []byte("交换机"),
+			fragments: []*highlight.Fragment{
+				&highlight.Fragment{
+					Orig:  []byte("交换机"),
+					Start: 0,
+					End:   9,
+				},
+				&highlight.Fragment{
+					Orig:  []byte("交换机"),
+					Start: 3,
+					End:   9,
+				},
+			},
+			ot: highlight.TermLocations{
+				&highlight.TermLocation{
+					Term:  "交换",
+					Pos:   1,
+					Start: 0,
+					End:   6,
+				},
+				&highlight.TermLocation{
+					Term:  "换机",
+					Pos:   2,
+					Start: 3,
+					End:   9,
+				},
+			},
+			size: 200,
+		},
 	}
 
 	for _, test := range tests {
diff --git a/search/highlight/highlighter.go b/search/highlight/highlighter.go
index 82440945..2d178b3e 100644
--- a/search/highlight/highlighter.go
+++ b/search/highlight/highlighter.go
@@ -36,7 +36,7 @@ type Fragmenter interface {
 }
 
 type FragmentFormatter interface {
-	Format(f *Fragment, tlm search.TermLocationMap) string
+	Format(f *Fragment, orderedTermLocations TermLocations) string
 }
 
 type FragmentScorer interface {
diff --git a/search/highlight/highlighters/simple/highlighter_simple.go b/search/highlight/highlighters/simple/highlighter_simple.go
index 2d8c41f8..e297fd4a 100644
--- a/search/highlight/highlighters/simple/highlighter_simple.go
+++ b/search/highlight/highlighters/simple/highlighter_simple.go
@@ -71,7 +71,7 @@ func (s *Highlighter) BestFragmentInField(dm *search.DocumentMatch, doc *documen
 func (s *Highlighter) BestFragmentsInField(dm *search.DocumentMatch, doc *document.Document, field string, num int) []string {
 	tlm := dm.Locations[field]
 	orderedTermLocations := highlight.OrderTermLocations(tlm)
-	scorer := NewFragmentScorer(dm.Locations[field])
+	scorer := NewFragmentScorer(tlm)
 
 	// score the fragments and put them into a priority queue ordered by score
 	fq := make(FragmentQueue, 0)
@@ -120,13 +120,14 @@ func (s *Highlighter) BestFragmentsInField(dm *search.DocumentMatch, doc *docume
 	}
 
 	// now that we have the best fragments, we can format them
+	orderedTermLocations.MergeOverlapping()
 	formattedFragments := make([]string, len(bestFragments))
 	for i, fragment := range bestFragments {
 		formattedFragments[i] = ""
 		if fragment.Start != 0 {
 			formattedFragments[i] += s.sep
 		}
-		formattedFragments[i] += s.formatter.Format(fragment, dm.Locations[field])
+		formattedFragments[i] += s.formatter.Format(fragment, orderedTermLocations)
 		if fragment.End != len(fragment.Orig) {
 			formattedFragments[i] += s.sep
 		}
diff --git a/search/highlight/term_locations.go b/search/highlight/term_locations.go
index 541957a0..4a9817c9 100644
--- a/search/highlight/term_locations.go
+++ b/search/highlight/term_locations.go
@@ -22,12 +22,36 @@ type TermLocation struct {
 	End   int
 }
 
+func (tl *TermLocation) Overlaps(other *TermLocation) bool {
+	if other.Start >= tl.Start && other.Start < tl.End {
+		return true
+	} else if tl.Start >= other.Start && tl.Start < other.End {
+		return true
+	}
+	return false
+}
+
 type TermLocations []*TermLocation
 
 func (t TermLocations) Len() int           { return len(t) }
 func (t TermLocations) Swap(i, j int)      { t[i], t[j] = t[j], t[i] }
 func (t TermLocations) Less(i, j int) bool { return t[i].Start < t[j].Start }
 
+func (t TermLocations) MergeOverlapping() {
+	var lastTl *TermLocation
+	for i, tl := range t {
+		if lastTl == nil && tl != nil {
+			lastTl = tl
+		} else if lastTl != nil && tl != nil {
+			if lastTl.Overlaps(tl) {
+				// ok merge this with previous
+				lastTl.End = tl.End
+				t[i] = nil
+			}
+		}
+	}
+}
+
 func OrderTermLocations(tlm search.TermLocationMap) TermLocations {
 	rv := make(TermLocations, 0)
 	for term, locations := range tlm {
diff --git a/search/highlight/term_locations_test.go b/search/highlight/term_locations_test.go
new file mode 100644
index 00000000..edaf315c
--- /dev/null
+++ b/search/highlight/term_locations_test.go
@@ -0,0 +1,173 @@
+package highlight
+
+import (
+	"reflect"
+	"testing"
+)
+
+func TestTermLocationOverlaps(t *testing.T) {
+
+	tests := []struct {
+		left     *TermLocation
+		right    *TermLocation
+		expected bool
+	}{
+		{
+			left: &TermLocation{
+				Start: 0,
+				End:   5,
+			},
+			right: &TermLocation{
+				Start: 3,
+				End:   7,
+			},
+			expected: true,
+		},
+		{
+			left: &TermLocation{
+				Start: 0,
+				End:   5,
+			},
+			right: &TermLocation{
+				Start: 5,
+				End:   7,
+			},
+			expected: false,
+		},
+		{
+			left: &TermLocation{
+				Start: 0,
+				End:   5,
+			},
+			right: &TermLocation{
+				Start: 7,
+				End:   11,
+			},
+			expected: false,
+		},
+	}
+
+	for _, test := range tests {
+		actual := test.left.Overlaps(test.right)
+		if actual != test.expected {
+			t.Errorf("expected %t got %t for %#v", test.expected, actual, test)
+		}
+	}
+}
+
+func TestTermLocationsMergeOverlapping(t *testing.T) {
+
+	tests := []struct {
+		input  TermLocations
+		output TermLocations
+	}{
+		{
+			input:  TermLocations{},
+			output: TermLocations{},
+		},
+		{
+			input: TermLocations{
+				&TermLocation{
+					Start: 0,
+					End:   5,
+				},
+				&TermLocation{
+					Start: 7,
+					End:   11,
+				},
+			},
+			output: TermLocations{
+				&TermLocation{
+					Start: 0,
+					End:   5,
+				},
+				&TermLocation{
+					Start: 7,
+					End:   11,
+				},
+			},
+		},
+		{
+			input: TermLocations{
+				&TermLocation{
+					Start: 0,
+					End:   5,
+				},
+				&TermLocation{
+					Start: 4,
+					End:   11,
+				},
+			},
+			output: TermLocations{
+				&TermLocation{
+					Start: 0,
+					End:   11,
+				},
+				nil,
+			},
+		},
+		{
+			input: TermLocations{
+				&TermLocation{
+					Start: 0,
+					End:   5,
+				},
+				&TermLocation{
+					Start: 4,
+					End:   11,
+				},
+				&TermLocation{
+					Start: 9,
+					End:   13,
+				},
+			},
+			output: TermLocations{
+				&TermLocation{
+					Start: 0,
+					End:   13,
+				},
+				nil,
+				nil,
+			},
+		},
+		{
+			input: TermLocations{
+				&TermLocation{
+					Start: 0,
+					End:   5,
+				},
+				&TermLocation{
+					Start: 4,
+					End:   11,
+				},
+				&TermLocation{
+					Start: 9,
+					End:   13,
+				},
+				&TermLocation{
+					Start: 15,
+					End:   21,
+				},
+			},
+			output: TermLocations{
+				&TermLocation{
+					Start: 0,
+					End:   13,
+				},
+				nil,
+				nil,
+				&TermLocation{
+					Start: 15,
+					End:   21,
+				},
+			},
+		},
+	}
+
+	for _, test := range tests {
+		test.input.MergeOverlapping()
+		if !reflect.DeepEqual(test.input, test.output) {
+			t.Errorf("expected: %#v got %#v", test.output, test.input)
+		}
+	}
+}
