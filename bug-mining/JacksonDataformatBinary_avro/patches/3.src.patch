diff --git a/avro/release-notes/VERSION b/avro/release-notes/VERSION
deleted file mode 100644
index 72a28191..00000000
--- a/avro/release-notes/VERSION
+++ /dev/null
@@ -1,134 +0,0 @@
-Project: jackson-dataformat-avro
-
-------------------------------------------------------------------------
-= Releases
-------------------------------------------------------------------------
-
-2.8.0 (not yet released)
-
-No changes since 2.7
-
-2.7.4 (29-Apr-2016)
-
-#39: Byte arrays are represented as strings in generated avro schema
- (reported by asmaier@github)
-
-2.7.3 (16-Mar-2016)
-
-#35: Not able to serialize avro generated object having schema$ object
- (reported by Anand S)
-#38: Problems serializing `OffsetDateTime` (Java8 date/time)
- (reported by asmaier@github)
-#41: Problems with type `Number`, with schema
-
-2.7.2 (27-Feb-2016)
-
-- Change build to produce JDK6-compatible jar, to allow use on JDK6 runtime
-
-2.7.1 (02-Feb-2016)
-
-No changes since 2.7.0
-
-2.7.0 (10-Jan-2016)
-
-#21: Add AVRO_BUFFERING feature (enabled by default/existing behavior)
- (contributed by Alex D)
-
-2.6.5 (19-Jan-2016)
-
-No changes since 2.6.4
-
-2.6.4 (07-Dec-2015)
-
-#23: MapWriteContext.createChildObjectContext() should call _schema.getValueType()
- (reported by shoeree@github, cresny@github)
-#26: Should indicate type that was requested when complaining about Any not being supported
- (reported by Peter R)
-#27: Support serialization of `BigDecimal` values
- (contributed by Peter R)
-
-2.6.3 (12-Oct-2015)
-2.6.2 (15-Sep-2015)
-2.6.1 (09-Aug-2015)
-2.6.0 (19-Jul-2015)
-
-No changes since 2.5.
-
-2.5.5 (not yet released)
-
-#19: "Current context not an object but ARRAY" when encountering nested object and using
-  JsonGenerator.Feature.IGNORE_UNKNOWN = true
- (reported by Sterling Hm shoeree@github)
-
-2.5.4 (09-Jun-2015)
-2.5.3 (24-Apr-2015)
-2.5.2 (29-Mar-2015)
-2.5.1 (06-Feb-2015)
-
-No changes since 2.5.0
-
-2.5.0 (01-Jan-2015)
-
-#11: Add convenience methods in `AvroMapper` for Schema-generation from POJO
-#12: Problem serializing optional Enum (in union)
-#14: Support serializing "fixed" fields
- (contributed by Josh G)
-#15: AvroSchemaGenerator should support generation of "fixed" field-types
- (contributed by Josh G)
-- Upgrade to Avro 1.7.7
-- Deprecate `AvroGenerator.Feature.IGNORE_UNKWNOWN` (mis-spellt, but more
-  importantly obsoleted by addition of `JsonGenerator.Feature.IGNORE_UNKNOWN`)
-
-2.4.3 (04-Oct-2014)
-2.4.2 (15-Aug-2014)
-
-No changes since 2.4.1
-
-2.4.1 (17-Jun-2014)
-
-#8: Error in creating Avro Schema for `java.util.Date` (and related) type.
- (reported by aufZone@github)
-
-2.4.0 (02-Jun-2014)
-
-No functional changes since 2.3.x.
-
-2.3.3 (10-Apr-2014)
-
-#6: Nested Map type fields do not work
- (reported by cresny@github)
-#7: Add `AvroGenerator.Feature.IGNORE_UNKWNOWN` to allow filtering of
-  properties that are not defined in Schema, during output
- (suggested by cresny@github)
-
-
-2.3.2 (01-Mar-2014)
-
-#5: Support byte[] fields
- (reported by clarkbreyman@github)
-
-2.3.1 (28-Dec-2013)
-
-#1: Add `AvroMapper` for convenience
-
-2.3.0 (14-Nov-2013)
-
-- Add 'requiresPropertyOrdering()'
-
-2.2.3 (23-Aug-2013)
-2.2.2 (27-May-2013)
-2.2.1 (03-May-2013)
-
-- Fixed issue with AvroFactory.copy()
-
-2.2.0 (22-Apr-2013)
-
-* Uses new Bean property introspection for better mapping of data types.
-
-2.1.1 (12-Nov-2012)
-
-Minor update with performance improvements
-
-2.1.0 (05-Nov-2012)
-
-The very first public release!
diff --git a/avro/src/main/java/com/fasterxml/jackson/dataformat/avro/deser/RecordReader.java b/avro/src/main/java/com/fasterxml/jackson/dataformat/avro/deser/RecordReader.java
index 46352f38..a83fd1d4 100644
--- a/avro/src/main/java/com/fasterxml/jackson/dataformat/avro/deser/RecordReader.java
+++ b/avro/src/main/java/com/fasterxml/jackson/dataformat/avro/deser/RecordReader.java
@@ -19,10 +19,10 @@ final class RecordReader extends AvroStructureReader
     private final AvroParserImpl _parser;
 
     protected String _currentName;
-    
+
     protected int _state;
     protected final int _count;
-    
+
     public RecordReader(AvroFieldWrapper[] fieldReaders) {
         this(null, fieldReaders, null, null);
     }
@@ -37,7 +37,7 @@ final class RecordReader extends AvroStructureReader
         _parser = parser;
         _count = fieldReaders.length;
     }
-    
+
     @Override
     public RecordReader newReader(AvroReadContext parent,
             AvroParserImpl parser, BinaryDecoder decoder) {
@@ -60,26 +60,20 @@ final class RecordReader extends AvroStructureReader
                 return t;
             }
         case STATE_NAME:
-            if (_index < _count) {
-                _currentName = _fieldReaders[_index].getName();
-                _state = STATE_VALUE;
-                {
-                    JsonToken t = JsonToken.FIELD_NAME;
-                    _currToken = t;
-                    return t;
-                }
+            if (_index >= _count) {
+                return _nextAtEndObject();
             }
-            // done; fall through
-        case STATE_END:
-            _state = STATE_DONE;
-            _parser.setAvroContext(getParent());
+            _currentName = _fieldReaders[_index].getName();
+            _state = STATE_VALUE;
             {
-                JsonToken t = JsonToken.END_OBJECT;
+                JsonToken t = JsonToken.FIELD_NAME;
                 _currToken = t;
                 return t;
             }
         case STATE_VALUE:
             break;
+        case STATE_END:
+            return _nextAtEndObject();
         case STATE_DONE:
         default:
             throwIllegalState(_state);
@@ -92,6 +86,22 @@ final class RecordReader extends AvroStructureReader
         return t;
     }        
 
+    private final JsonToken _nextAtEndObject() throws IOException
+    {
+        AvroReadContext parent = getParent();
+        // as per [dataformats-binary#38], may need to reset, instead of bailing out
+        if (parent.inRoot()) {
+            if (!_decoder.isEnd()) {
+                _state = STATE_START;
+                _index = 0;
+                return (_currToken = JsonToken.END_OBJECT);
+            }
+        }
+        _state = STATE_DONE;
+        _parser.setAvroContext(getParent());
+        return (_currToken = JsonToken.END_OBJECT);
+    }
+
     @Override
     public String nextFieldName() throws IOException
     {
@@ -103,13 +113,10 @@ final class RecordReader extends AvroStructureReader
                 _currToken = JsonToken.FIELD_NAME;
                 return name;
             }
-            // falling through to STATE_END handling
-            _state = STATE_DONE;
-            _parser.setAvroContext(getParent());
-            _currToken = JsonToken.END_OBJECT;
-            return null;
+            _nextAtEndObject();
+        } else {
+            nextToken();
         }
-        nextToken();
         return null;
     }
     
diff --git a/avro/src/test/java/com/fasterxml/jackson/dataformat/avro/RootSequenceTest.java b/avro/src/test/java/com/fasterxml/jackson/dataformat/avro/RootSequenceTest.java
new file mode 100644
index 00000000..a968f698
--- /dev/null
+++ b/avro/src/test/java/com/fasterxml/jackson/dataformat/avro/RootSequenceTest.java
@@ -0,0 +1,69 @@
+package com.fasterxml.jackson.dataformat.avro;
+
+import java.io.ByteArrayOutputStream;
+
+import com.fasterxml.jackson.databind.MappingIterator;
+import com.fasterxml.jackson.databind.SequenceWriter;
+
+import static org.junit.Assert.assertArrayEquals;
+
+/**
+ * Tests to ensure that it is possible to read a sequence of root-level
+ * values from a stream.
+ */
+public class RootSequenceTest extends AvroTestBase
+{
+    public void testReadWriteEmployees() throws Exception
+    {
+        AvroMapper mapper = getMapper();
+        ByteArrayOutputStream b = new ByteArrayOutputStream(1000);
+        Employee boss = new Employee("Bossman", 55, new String[] { "boss@company.com" }, null);
+        Employee peon1 = new Employee("Worker#1", 24, new String[] { "worker1@company.com" }, boss);
+        Employee peon2 = new Employee("Worker#2", 42, new String[] { "worker2@company.com" }, boss);
+
+        // First: write a sequence of 3 root-level Employee Objects
+        
+        SequenceWriter sw = mapper.writerFor(Employee.class)
+                .with(getEmployeeSchema())
+                .writeValues(b);
+        sw.write(boss);
+        int curr = b.size();
+        sw.write(peon1);
+        int diff = b.size() - curr;
+        if (diff == 0) {
+            fail("Should have output more bytes for second entry, did not, total: "+curr);
+        }
+        sw.write(peon2);
+        sw.close();
+
+        byte[] bytes = b.toByteArray();
+
+        assertNotNull(bytes);
+
+        // So far so good: writing seems to work. How about reading?
+        MappingIterator<Employee> it = mapper.readerFor(Employee.class)
+                .with(getEmployeeSchema())
+                .readValues(bytes);
+        assertTrue(it.hasNextValue());
+        Employee boss2 = it.nextValue();
+        assertEquals(boss.age, boss2.age);
+        assertEquals(boss.name, boss2.name);
+        assertArrayEquals(boss.emails, boss2.emails);
+
+        assertTrue(it.hasNextValue());
+        Employee worker1 = it.nextValue();
+        assertEquals(peon1.age, worker1.age);
+        assertEquals(peon1.name, worker1.name);
+        assertArrayEquals(peon1.emails, worker1.emails);
+
+        assertTrue(it.hasNextValue());
+        Employee worker2 = it.nextValue();
+        assertEquals(peon2.age, worker2.age);
+        assertEquals(peon2.name, worker2.name);
+        assertArrayEquals(peon2.emails, worker2.emails);
+
+        assertFalse(it.hasNextValue());
+        it.close();
+    }
+}
+
