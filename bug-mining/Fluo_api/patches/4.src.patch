diff --git a/modules/api/src/main/java/io/fluo/api/data/Bytes.java b/modules/api/src/main/java/io/fluo/api/data/Bytes.java
index d5d60ec4..a7aa16fd 100644
--- a/modules/api/src/main/java/io/fluo/api/data/Bytes.java
+++ b/modules/api/src/main/java/io/fluo/api/data/Bytes.java
@@ -24,12 +24,13 @@ import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.EOFException;
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 
-import io.fluo.api.data.impl.ArrayBytes;
 import org.apache.hadoop.io.WritableUtils;
 
 /**
@@ -38,6 +39,8 @@ import org.apache.hadoop.io.WritableUtils;
 public abstract class Bytes implements Comparable<Bytes> {
   
   public static final Bytes EMPTY = Bytes.wrap(new byte[0]);
+  
+  public Bytes() {}
 
   /**
    * Gets a byte within this sequence of bytes
@@ -181,6 +184,19 @@ public abstract class Bytes implements Comparable<Bytes> {
   public static Bytes wrap(byte[] array) {
     return new ArrayBytes(array);
   }
+  
+  /**
+   * Creates a Bytes object by wrapping a subsequence of the given byte array. 
+   * The given byte array is used directly as the backing array, so later changes
+   * made to the (relevant portion of the) array reflect into the new Byte array.
+   *
+   * @param data Byte data
+   * @param offset Starting offset in byte array (inclusive)
+   * @param length Number of bytes to include
+   */
+  public static Bytes wrap(byte data[], int offset, int length) {
+    return new ArrayBytes(data, offset, length);
+  }
 
   /**
    * Wraps ByteBuffer as Bytes
@@ -304,4 +320,153 @@ public abstract class Bytes implements Comparable<Bytes> {
     }
     return ret;
   }
+  
+  /**
+  * An implementation of {@link Bytes} that uses a backing byte array.
+  */
+  private static class ArrayBytes extends Bytes implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+
+    protected byte data[];
+    protected int offset;
+    protected int length;
+
+    /**
+     * Creates a new ArrayBytes. The given byte array is used directly as the
+     * backing array, so later changes made to the array reflect into the new
+     * sequence.
+     *
+     * @param data byte data
+     */
+    private ArrayBytes(byte data[]) {
+      this.data = data;
+      this.offset = 0;
+      this.length = data.length;
+    }
+
+    /**
+     * Creates a new ArrayBytes from a subsequence of the given byte array. The
+     * given byte array is used directly as the backing array, so later changes
+     * made to the (relevant portion of the) array reflect into the new sequence.
+     *
+     * @param data byte data
+     * @param offset starting offset in byte array (inclusive)
+     * @param length number of bytes to include in sequence
+     * @throws IllegalArgumentException if the offset or length are out of bounds
+     * for the given byte array
+     */
+    private ArrayBytes(byte data[], int offset, int length) {
+      if (offset < 0 || offset > data.length || length < 0 || (offset + length) > data.length) {
+        throw new IllegalArgumentException(" Bad offset and/or length data.length = " + data.length + " offset = " + offset + " length = " + length);
+      }
+      this.data = data;
+      this.offset = offset;
+      this.length = length;
+    }
+
+    /**
+     * Creates a new ArrayBytes from the given string. The bytes are determined from
+     * the string using UTF-8 encoding
+     *
+     * @param s String to represent as Bytes
+     */
+    private ArrayBytes(String s) {
+      this(s.getBytes(StandardCharsets.UTF_8));
+    }
+    
+    /**
+     * Creates a new ArrayBytes from the given string. The bytes are determined from
+     * the string using the specified charset
+     *
+     * @param s String to represent as Bytes
+     * @param cs Charset
+     */
+    private ArrayBytes(String s, Charset cs) {
+      this(s.getBytes(cs));
+    }
+
+    /**
+     * Creates a new ArrayBytes based on a ByteBuffer. If the byte buffer has an
+     * array, that array (and the buffer's offset and limit) are used; otherwise,
+     * a new backing array is created and a relative bulk get is performed to
+     * transfer the buffer's contents (starting at its current position and
+     * not beyond its limit).
+     *
+     * @param buffer byte buffer
+     */
+    private ArrayBytes(ByteBuffer buffer) {
+      this.length = buffer.remaining();
+
+      if (buffer.hasArray()) {
+        this.data = buffer.array();
+        this.offset = buffer.position();
+      } else {
+        this.data = new byte[length];
+        this.offset = 0;
+        buffer.get(data);
+      }
+    }
+    
+    @Override
+    public byte byteAt(int i) {
+
+      if (i < 0) {
+        throw new IllegalArgumentException("i < 0, " + i);
+      }
+
+      if (i >= length) {
+        throw new IllegalArgumentException("i >= length, " + i + " >= " + length);
+      }
+
+      return data[offset + i];
+    }
+
+    @Override
+    public byte[] getBackingArray() {
+      return data;
+    }
+
+    @Override
+    public boolean isBackedByArray() {
+      return true;
+    }
+
+    @Override
+    public int length() {
+      return length;
+    }
+
+    @Override
+    public int offset() {
+      return offset;
+    }
+
+    @Override
+    public Bytes subSequence(int start, int end) {
+      if (start > end || start < 0 || end > length) {
+        throw new IllegalArgumentException("Bad start and/end start = " + start + " end=" + end + " offset=" + offset + " length=" + length);
+      }
+      return new ArrayBytes(data, offset + start, end - start);
+    }
+
+    @Override
+    public byte[] toArray() {
+      if (offset == 0 && length == data.length)
+        return data;
+
+      byte[] copy = new byte[length];
+      System.arraycopy(data, offset, copy, 0, length);
+      return copy;
+    }
+
+    /** 
+     * Creates UTF-8 String using Bytes data
+     */
+    public String toString() {
+      return new String(data, offset, length, StandardCharsets.UTF_8);
+    }
+  }
 }
+
+
diff --git a/modules/api/src/main/java/io/fluo/api/data/impl/ArrayBytes.java b/modules/api/src/main/java/io/fluo/api/data/impl/ArrayBytes.java
deleted file mode 100644
index b0cd49fa..00000000
--- a/modules/api/src/main/java/io/fluo/api/data/impl/ArrayBytes.java
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.data.impl;
-
-import java.io.Serializable;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
-
-import io.fluo.api.data.Bytes;
-
-import org.apache.accumulo.core.data.ArrayByteSequence;
-import org.apache.accumulo.core.data.ByteSequence;
-import org.apache.hadoop.io.Text;
-
-/**
-* An implementation of {@link Bytes} that uses a backing byte array.
-*/
-public class ArrayBytes extends Bytes implements Serializable {
-
-  private static final long serialVersionUID = 1L;
-
-  protected byte data[];
-  protected int offset;
-  protected int length;
-
-  /**
-   * Creates a new ArrayBytes. The given byte array is used directly as the
-   * backing array, so later changes made to the array reflect into the new
-   * sequence.
-   *
-   * @param data byte data
-   */
-  public ArrayBytes(byte data[]) {
-    this.data = data;
-    this.offset = 0;
-    this.length = data.length;
-  }
-
-  /**
-   * Creates a new ArrayBytes from a subsequence of the given byte array. The
-   * given byte array is used directly as the backing array, so later changes
-   * made to the (relevant portion of the) array reflect into the new sequence.
-   *
-   * @param data byte data
-   * @param offset starting offset in byte array (inclusive)
-   * @param length number of bytes to include in sequence
-   * @throws IllegalArgumentException if the offset or length are out of bounds
-   * for the given byte array
-   */
-  public ArrayBytes(byte data[], int offset, int length) {
-    if (offset < 0 || offset > data.length || length < 0 || (offset + length) > data.length) {
-      throw new IllegalArgumentException(" Bad offset and/or length data.length = " + data.length + " offset = " + offset + " length = " + length);
-    }
-    this.data = data;
-    this.offset = offset;
-    this.length = length;
-  }
-
-  /**
-   * Creates a new ArrayBytes from the given string. The bytes are determined from
-   * the string using the default platform encoding.
-   *
-   * @param s String to represent as Bytes
-   */
-  public ArrayBytes(String s) {
-    this(s.getBytes(StandardCharsets.UTF_8));
-  }
-  
-  /**
-   * Creates a new ArrayBytes from the given string. The bytes are determined from
-   * the string using the default platform encoding.
-   *
-   * @param s String to represent as Bytes
-   */
-  public ArrayBytes(String s, Charset cs) {
-    this(s.getBytes(cs));
-  }
-
-  /**
-   * Creates a new ArrayBytes based on a ByteBuffer. If the byte buffer has an
-   * array, that array (and the buffer's offset and limit) are used; otherwise,
-   * a new backing array is created and a relative bulk get is performed to
-   * transfer the buffer's contents (starting at its current position and
-   * not beyond its limit).
-   *
-   * @param buffer byte buffer
-   */
-  public ArrayBytes(ByteBuffer buffer) {
-    this.length = buffer.remaining();
-
-    if (buffer.hasArray()) {
-      this.data = buffer.array();
-      this.offset = buffer.position();
-    } else {
-      this.data = new byte[length];
-      this.offset = 0;
-      buffer.get(data);
-    }
-  }
-  
-  /**
-   * Creates a new ArrayBytes based on a ByteSequence. If the byte buffer has an
-   * array, that array (and the buffer's offset and limit) are used; otherwise,
-   * a new backing array is created and a relative bulk get is performed to
-   * transfer the buffer's contents (starting at its current position and
-   * not beyond its limit).
-   *
-   * @param bs ByteSequence
-   */
-  public ArrayBytes(ByteSequence bs) {
-    this.length = bs.length();
-
-    if (bs.isBackedByArray()) {
-      this.data = bs.getBackingArray();
-      this.offset = bs.offset();
-    } else {
-      this.data = bs.toArray();
-      this.offset = 0;
-    }
-  }
-  
-  public ArrayBytes(Text t) {
-    this.length = t.getLength();
-    this.data = t.getBytes();
-    this.offset = 0;
-  }
-
-  @Override
-  public byte byteAt(int i) {
-
-    if (i < 0) {
-      throw new IllegalArgumentException("i < 0, " + i);
-    }
-
-    if (i >= length) {
-      throw new IllegalArgumentException("i >= length, " + i + " >= " + length);
-    }
-
-    return data[offset + i];
-  }
-
-  @Override
-  public byte[] getBackingArray() {
-    return data;
-  }
-
-  @Override
-  public boolean isBackedByArray() {
-    return true;
-  }
-
-  @Override
-  public int length() {
-    return length;
-  }
-
-  @Override
-  public int offset() {
-    return offset;
-  }
-
-  @Override
-  public Bytes subSequence(int start, int end) {
-
-    if (start > end || start < 0 || end > length) {
-      throw new IllegalArgumentException("Bad start and/end start = " + start + " end=" + end + " offset=" + offset + " length=" + length);
-    }
-
-    return new ArrayBytes(data, offset + start, end - start);
-  }
-
-  @Override
-  public byte[] toArray() {
-    if (offset == 0 && length == data.length)
-      return data;
-
-    byte[] copy = new byte[length];
-    System.arraycopy(data, offset, copy, 0, length);
-    return copy;
-  }
-
-  /** 
-   * Creates UTF-8 String using Bytes data
-   */
-  public String toString() {
-    return new String(data, offset, length, StandardCharsets.UTF_8);
-  }
-
-  /**
-   * Creates ByteSequence using Bytes data
-   * 
-   * @return ByteSequence
-   */
-  public ByteSequence toByteSequence() {
-    return new ArrayByteSequence(data, offset, length);
-  }
-
-  /**
-   * Creates Hadoop Text object using Bytes Data
-   * 
-   * @return Hadoop Text object 
-   */
-  public Text toText() {
-    Text t = new Text();
-    t.set(data, offset, length);
-    return t;
-  }
-}
diff --git a/modules/api/src/test/java/io/fluo/api/data/BytesTest.java b/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
index 22c404dd..649a67e5 100644
--- a/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
+++ b/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
@@ -19,15 +19,11 @@ package io.fluo.api.data;
 import java.nio.ByteBuffer;
 import java.util.List;
 
-import io.fluo.api.data.impl.ArrayBytes;
-import org.apache.accumulo.core.data.ArrayByteSequence;
-import org.apache.accumulo.core.data.ByteSequence;
-import org.apache.hadoop.io.Text;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
- * Tests Bytes & ArrayBytes classes
+ * Unit test for Bytes class
  */
 public class BytesTest {
 
@@ -46,21 +42,9 @@ public class BytesTest {
     Assert.assertEquals(s2, b2.toString());
     
     String s3 = "test3";
-    ByteSequence bs = new ArrayByteSequence(s3);
-    ArrayBytes b3 = new ArrayBytes(bs);
+    Bytes b3 = Bytes.wrap(s3.getBytes());
     Assert.assertArrayEquals(s3.getBytes(), b3.toArray());
     Assert.assertEquals(s3, b3.toString());
-    Assert.assertEquals(bs, b3.toByteSequence());
-    
-    String s4 = "test4";
-    Bytes b4 = Bytes.wrap(s4.getBytes());
-    Assert.assertArrayEquals(s4.getBytes(), b4.toArray());
-    Assert.assertEquals(s4, b4.toString());
-    
-    String s5 = "test5";
-    Text t5 = new Text(s5);
-    ArrayBytes b5 = new ArrayBytes(s5);
-    Assert.assertEquals(t5, b5.toText());
   }
   
   @Test
