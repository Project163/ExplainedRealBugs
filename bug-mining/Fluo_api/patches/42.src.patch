diff --git a/modules/api/src/main/java/io/fluo/api/data/Column.java b/modules/api/src/main/java/io/fluo/api/data/Column.java
index c4a37fe4..24b73cef 100644
--- a/modules/api/src/main/java/io/fluo/api/data/Column.java
+++ b/modules/api/src/main/java/io/fluo/api/data/Column.java
@@ -23,25 +23,25 @@ import com.google.common.base.Preconditions;
 import org.apache.hadoop.io.Writable;
 
 /**
- * Represents Column in Fluo.
+ * Represents Column in Fluo
  */
 public class Column implements Writable {
   
-  public static final Column EMPTY = new Column();
+  public static final Bytes UNSET = Bytes.wrap(new byte[0]);
+  
+  private Bytes family = UNSET;
+  private Bytes qualifier = UNSET;
+  private Bytes visibility = UNSET;
   
-  private Bytes family = Bytes.EMPTY;
-  private Bytes qualifier = Bytes.EMPTY;
-  private Bytes visibility = Bytes.EMPTY;
+  public static final Column EMPTY = new Column();
 
   /**
-   * Creates Column with family, qualifier and visibility
-   * set to Bytes.EMPTY
+   * Creates an empty Column where family, qualifier and visibility are not set
    */
   public Column() {}
   
   /**
-   * Creates Column with family and sets qualifier and visibility
-   * to Bytes.EMPTY
+   * Creates Column with only a family.
    */
   public Column(Bytes family) {
     Preconditions.checkNotNull(family, "Family must not be null");
@@ -49,16 +49,14 @@ public class Column implements Writable {
   }
   
   /**
-   * Creates Column with family and sets qualifier and visibility 
-   * to Bytes.EMPTY.  String parameter will be encoded as UTF-8.
+   * Creates Column with only a family. String parameter will be encoded as UTF-8.
    */
   public Column(String family) {
     this(family == null ? null : Bytes.wrap(family));
   }
 
   /**
-   * Creates Column with family and qualifier and sets visibility
-   * to Bytes.EMPTY
+   * Creates Column with a family and qualifier.
    */
   public Column(Bytes family, Bytes qualifier) {
     Preconditions.checkNotNull(family, "Family must not be null");
@@ -68,8 +66,7 @@ public class Column implements Writable {
   }
   
   /**
-   * Creates Column with family and qualifier and sets visibility
-   * to Bytes.EMPTY.  String parameters will be encoded as UTF-8.
+   * Creates Column with a family and qualifier.  String parameters will be encoded as UTF-8.
    */
   public Column(String family, String qualifier) {
     this(family == null ? null : Bytes.wrap(family), 
@@ -89,8 +86,7 @@ public class Column implements Writable {
   }
   
   /** 
-   * Creates Column with family, qualifier, and visibility.
-   * String parameters will be encoded as UTF-8.
+   * Creates Column with family, qualifier, and visibility. String parameters will be encoded as UTF-8.
    */
   public Column(String family, String qualifier, String visibility) {
     this(family == null ? null : Bytes.wrap(family), 
@@ -99,48 +95,54 @@ public class Column implements Writable {
   }
   
   /**
-   * Retrieves Family of Column
-   * 
-   * @return Bytes Family 
+   * Returns true if family is set
+   */
+  public boolean isFamilySet() {
+    return family != UNSET;
+  }
+  
+  /**
+   * Retrieves Column Family (in Bytes).  Returns {@link Bytes.EMPTY} if not set.
    */
   public Bytes getFamily() {
+    if (!isFamilySet()) {
+      return Bytes.EMPTY;
+    }
     return family;
   }
   
   /**
-   * Retrieves Qualifier of Column
-   * 
-   * @return Bytes Qualifier
+   * Returns true if qualifier is set
    */
-  public Bytes getQualifier() {
-    return qualifier;
+  public boolean isQualifierSet() {
+    return qualifier != UNSET;
   }
   
   /**
-   * Retrieves Visibility of Column
-   * 
-   * @return Bytes Visibility
+   * Retrieves Column Qualifier (in Bytes). Returns {@link Bytes.EMPTY} if not set.
    */
-  public Bytes getVisibility() {
-    return visibility;
+  public Bytes getQualifier() {
+    if (!isQualifierSet()) {
+      return Bytes.EMPTY;
+    }
+    return qualifier;
   }
-
+  
   /**
-   * Sets visibility of Column
-   * 
+   * Returns true if visibility is set. 
    */
-  public Column setVisibility(String visibilty) {
-    this.visibility = Bytes.wrap(visibilty);
-    return this;
+  public boolean isVisibilitySet() {
+    return visibility != UNSET;
   }
-
+  
   /**
-   * Sets visibility of Column
-   * 
+   * Retrieves Column Visibility (in Bytes). Returns {@link Bytes.EMPTY} if not set.
    */
-  public Column setVisibility(Bytes visibilty) {
-    this.visibility = visibilty;
-    return this;
+  public Bytes getVisibility() {
+    if (!isVisibilitySet()) {
+      return Bytes.EMPTY;
+    }
+    return visibility;
   }
   
   @Override
@@ -154,11 +156,10 @@ public class Column implements Writable {
   }
   
   @Override
-  public boolean equals(Object o) {
+  public boolean equals(Object o) {    
     if (o instanceof Column) {
       Column oc = (Column) o;
-      return family.equals(oc.family) && qualifier.equals(oc.qualifier)
-          && visibility.equals(oc.visibility);
+      return family.equals(oc.getFamily()) && qualifier.equals(oc.getQualifier()) && visibility.equals(oc.getVisibility());
     }
     return false;
   }
diff --git a/modules/api/src/main/java/io/fluo/api/data/RowColumn.java b/modules/api/src/main/java/io/fluo/api/data/RowColumn.java
index 8ac5f258..d5a5ce38 100644
--- a/modules/api/src/main/java/io/fluo/api/data/RowColumn.java
+++ b/modules/api/src/main/java/io/fluo/api/data/RowColumn.java
@@ -124,9 +124,9 @@ public class RowColumn {
       return RowColumn.EMPTY;
     } else if (col.equals(Column.EMPTY)) {
       return new RowColumn(followingBytes(row));
-    } else if (col.getQualifier().equals(Bytes.EMPTY)) {
+    } else if (!col.isQualifierSet()) {
       return new RowColumn(row, new Column(followingBytes(col.getFamily())));
-    } else if (col.getVisibility().equals(Bytes.EMPTY)) {
+    } else if (!col.isVisibilitySet()) {
       return new RowColumn(row, new Column(col.getFamily(), followingBytes(col.getQualifier())));
     } else {
       return new RowColumn(row, new Column(col.getFamily(), col.getQualifier(), followingBytes(col.getVisibility())));
diff --git a/modules/api/src/main/java/io/fluo/api/data/Span.java b/modules/api/src/main/java/io/fluo/api/data/Span.java
index 6bd19610..b24ce246 100644
--- a/modules/api/src/main/java/io/fluo/api/data/Span.java
+++ b/modules/api/src/main/java/io/fluo/api/data/Span.java
@@ -194,6 +194,7 @@ public class Span {
    * Creates a span that covers an exact row
    */
   public static Span exact(Bytes row) {
+    Preconditions.checkNotNull(row);
     return new Span(row, true, row, true);
   }
   
@@ -202,55 +203,29 @@ public class Span {
    * String parameters will be encoded as UTF-8
    */
   public static Span exact(String row) {
+    Preconditions.checkNotNull(row);
     return exact(Bytes.wrap(row));
   }
   
   /**
-   * Creates a Span that covers an exact row and column family
+   * Creates a Span that covers an exact row and {@link Column}. The {@link Column} passed to this method can be constructed without a qualifier or visibility
+   * to create a Span at the family or qualifier level.
    */
-  public static Span exact(Bytes row, Bytes cf) {
-    RowColumn start = new RowColumn(row, new Column(cf));
+  public static Span exact(Bytes row, Column col) {
+    Preconditions.checkNotNull(row);
+    Preconditions.checkNotNull(col);
+    RowColumn start = new RowColumn(row, col);
     return new Span(start, true, start.following(), false);
   }
   
   /**
-   * Creates a Span that covers an exact row and column family
-   * String parameters will be encoded as UTF-8
-   */
-  public static Span exact(String row, String cf) {
-    return exact(Bytes.wrap(row), Bytes.wrap(cf));
-  }
-  
-  /**
-   * Creates a Span that covers an exact row, column family, and column qualifier
-   */
-  public static Span exact(Bytes row, Bytes cf, Bytes cq) {
-    RowColumn start = new RowColumn(row, new Column(cf, cq));
-    return new Span(start, true, start.following(), false);
-  }
-  
-  /**
-   * Creates a Span that covers an exact row, column family, and column qualifier
-   * String parameters will be encoded as UTF-8
+   * Creates a Span that covers an exact row and {@link Column}. The {@link Column} passed to this method can be constructed without a qualifier or visibility
+   * to create a Span at the family or qualifier level. String parameters will be encoded as UTF-8
    */
-  public static Span exact(String row, String cf, String cq) {
-    return exact(Bytes.wrap(row), Bytes.wrap(cf), Bytes.wrap(cq));
-  }
-  
-  /**
-   * Creates a Span that covers an exact row, column family, column qualifier, and column visibility
-   */
-  public static Span exact(Bytes row, Bytes cf, Bytes cq, Bytes cv) {
-    RowColumn start = new RowColumn(row, new Column(cf, cq, cv));
-    return new Span(start, true, start.following(), false);
-  }
-  
-  /**
-   * Creates a Span that covers an exact row, column family, column qualifier, and column visibility
-   * String parameters will be encoded as UTF-8
-   */
-  public static Span exact(String row, String cf, String cq, String cv) {
-    return exact(Bytes.wrap(row), Bytes.wrap(cf), Bytes.wrap(cq), Bytes.wrap(cv));
+  public static Span exact(String row, Column col) {
+    Preconditions.checkNotNull(row);
+    Preconditions.checkNotNull(col);
+    return exact(Bytes.wrap(row), col);
   }
   
   private static Bytes followingPrefix(Bytes prefix) {
@@ -273,9 +248,10 @@ public class Span {
   }
   
   /**
-   * Returns a Span that covers all rows beginning with a prefix
+   * Returns a Span that covers all rows beginning with a prefix. 
    */
   public static Span prefix(Bytes rowPrefix) {
+    Preconditions.checkNotNull(rowPrefix);
     Bytes fp = followingPrefix(rowPrefix);
     return new Span(rowPrefix, true, fp == null ? Bytes.EMPTY : fp, false);
   }
@@ -285,60 +261,46 @@ public class Span {
    * String parameters will be encoded as UTF-8
    */
   public static Span prefix(String rowPrefix) {
+    Preconditions.checkNotNull(rowPrefix);
     return prefix(Bytes.wrap(rowPrefix));
   }
-  
-  /**
-   * Returns a Span that covers all column families beginning with a prefix within a given row
-   */
-  public static Span prefix(Bytes row, Bytes cfPrefix) {
-    Bytes fp = followingPrefix(cfPrefix);
-    RowColumn end = (fp == null ? new RowColumn(row).following() : new RowColumn(row, new Column(fp)));
-    return new Span(new RowColumn(row, new Column(cfPrefix)), true, end, false);
-  }
-  
-  /**
-   * Returns a Span that covers all column families beginning with a prefix within a given row
-   * String parameters will be encoded as UTF-8
-   */
-  public static Span prefix(String row, String cfPrefix) {
-    return prefix(Bytes.wrap(row), Bytes.wrap(cfPrefix));
-  }
-  
-  /**
-   * Returns a Span that covers all column qualifiers beginning with a prefix within a given row
-   * and column family
-   */
-  public static Span prefix(Bytes row, Bytes cf, Bytes cqPrefix) {
-    Bytes fp = followingPrefix(cqPrefix);
-    RowColumn end = (fp == null ? new RowColumn(row, new Column(cf)).following() : new RowColumn(row, new Column(cf, fp)));
-    return new Span(new RowColumn(row, new Column(cf, cqPrefix)), true, end, false);
-  }
-  
-  /**
-   * Returns a Span that covers all column qualifiers beginning with a prefix within a given row
-   * String parameters will be encoded as UTF-8
-   */
-  public static Span prefix(String row, String cf, String cqPrefix) {
-    return prefix(Bytes.wrap(row), Bytes.wrap(cf), Bytes.wrap(cqPrefix));
-  }
-  
+    
   /**
-   * Returns a Span that covers all column visibilities beginning with a prefix within a given row,
-   * column family, and column qualifier.
+   * Returns a Span that covers all columns beginning with a row and {@link Column} prefix. The {@link Column} passed to this method can be constructed without
+   * a qualifier or visibility to create a prefix Span at the family or qualifier level.
    */
-  public static Span prefix(Bytes row, Bytes cf, Bytes cq, Bytes cvPrefix) {
-    Bytes fp = followingPrefix(cvPrefix);
-    RowColumn end = (fp == null ? new RowColumn(row, new Column(cf, cq)).following() : new RowColumn(row, new Column(cf, cq, fp)));
-    return new Span(new RowColumn(row, new Column(cf, cq, cvPrefix)), true, end, false);
+  public static Span prefix(Bytes row, Column colPrefix) {
+    Preconditions.checkNotNull(row);
+    Preconditions.checkNotNull(colPrefix);
+    Bytes cf = colPrefix.getFamily();
+    Bytes cq = colPrefix.getQualifier();
+    Bytes cv = colPrefix.getVisibility();
+    
+    if (colPrefix.isVisibilitySet()) {
+      Bytes fp = followingPrefix(cv);
+      RowColumn end = (fp == null ? new RowColumn(row, new Column(cf, cq)).following() : new RowColumn(row, new Column(cf, cq, fp)));
+      return new Span(new RowColumn(row, colPrefix), true, end, false);
+    } else if (colPrefix.isQualifierSet()) {
+      Bytes fp = followingPrefix(cq);
+      RowColumn end = (fp == null ? new RowColumn(row, new Column(cf)).following() : new RowColumn(row, new Column(cf, fp)));
+      return new Span(new RowColumn(row, colPrefix), true, end, false);
+    } else if (colPrefix.isFamilySet()) {
+      Bytes fp = followingPrefix(cf);
+      RowColumn end = (fp == null ? new RowColumn(row).following() : new RowColumn(row, new Column(fp)));
+      return new Span(new RowColumn(row, colPrefix), true, end, false);
+    } else {
+      return prefix(row);
+    }
   }
   
   /**
-   * Returns a Span that covers all column visibilities beginning with a prefix within a given row
-   * String parameters will be encoded as UTF-8
+   * Returns a Span that covers all columns beginning with a row and {@link Column} prefix. The {@link Column} passed to this method can be constructed without
+   * a qualifier or visibility to create a prefix Span at the family or qualifier level. String parameters will be encoded as UTF-8
    */
-  public static Span prefix(String row, String cf, String cq, String cvPrefix) {
-    return prefix(Bytes.wrap(row), Bytes.wrap(cf), Bytes.wrap(cq), Bytes.wrap(cvPrefix));
+  public static Span prefix(String row, Column colPrefix) {
+    Preconditions.checkNotNull(row);
+    Preconditions.checkNotNull(colPrefix);
+    return prefix(Bytes.wrap(row), colPrefix);
   }
   
   public static class KeyBuilder {
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java b/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java
index baac26de..a37949d3 100644
--- a/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java
+++ b/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java
@@ -233,10 +233,13 @@ public class TypeLayer {
     Bytes vis;
 
     Column getCol() {
-      if (vis == null)
+      if (qual == null) {
+        return new Column(family);
+      } else if (vis == null) {
         return new Column(family, qual);
-      else
+      } else {
         return new Column(family, qual, vis);
+      }
     }
   }
 
diff --git a/modules/api/src/test/java/io/fluo/api/data/ColumnTest.java b/modules/api/src/test/java/io/fluo/api/data/ColumnTest.java
new file mode 100644
index 00000000..3a1faa24
--- /dev/null
+++ b/modules/api/src/test/java/io/fluo/api/data/ColumnTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2014 Fluo authors (see AUTHORS)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Unit test for {@link Column}
+ */
+public class ColumnTest {
+  
+  @Test
+  public void testCreation() {
+    Column col = new Column();
+    Assert.assertFalse(col.isFamilySet());
+    Assert.assertFalse(col.isQualifierSet());
+    Assert.assertFalse(col.isVisibilitySet());
+    Assert.assertSame(Bytes.EMPTY, col.getFamily());
+    Assert.assertSame(Bytes.EMPTY, col.getQualifier());
+    Assert.assertSame(Bytes.EMPTY, col.getVisibility());
+    
+    col = Column.EMPTY;
+    Assert.assertFalse(col.isFamilySet());
+    Assert.assertFalse(col.isQualifierSet());
+    Assert.assertFalse(col.isVisibilitySet());
+    
+    Assert.assertEquals(new Column(), new Column());
+    Assert.assertEquals(Column.EMPTY, Column.EMPTY);
+    Assert.assertEquals(Column.EMPTY, new Column());
+    
+    Assert.assertEquals(new Column("a"), new Column(Bytes.wrap("a")));
+    Assert.assertEquals(new Column("a"), new Column(Bytes.wrap("a"), Bytes.EMPTY, Bytes.EMPTY));
+    Assert.assertEquals(new Column("a").hashCode(), new Column(Bytes.wrap("a"), Bytes.EMPTY, Bytes.EMPTY).hashCode());
+    
+    col = new Column("cf1");
+    Assert.assertTrue(col.isFamilySet());
+    Assert.assertFalse(col.isQualifierSet());
+    Assert.assertFalse(col.isVisibilitySet());
+    Assert.assertEquals(Bytes.wrap("cf1"), col.getFamily());
+    Assert.assertSame(Bytes.EMPTY, col.getQualifier());
+    Assert.assertSame(Bytes.EMPTY, col.getVisibility());
+    Assert.assertEquals(new Column("cf1"), col);
+    
+    col = new Column("cf2", "cq2");
+    Assert.assertTrue(col.isFamilySet());
+    Assert.assertTrue(col.isQualifierSet());
+    Assert.assertFalse(col.isVisibilitySet());
+    Assert.assertEquals(Bytes.wrap("cf2"), col.getFamily());
+    Assert.assertEquals(Bytes.wrap("cq2"), col.getQualifier());
+    Assert.assertSame(Bytes.EMPTY, col.getVisibility());
+    Assert.assertEquals(new Column("cf2", "cq2"), col);
+    
+    col = new Column("cf3", "cq3", "cv3");
+    Assert.assertTrue(col.isFamilySet());
+    Assert.assertTrue(col.isQualifierSet());
+    Assert.assertTrue(col.isVisibilitySet());
+    Assert.assertEquals(Bytes.wrap("cf3"), col.getFamily());
+    Assert.assertEquals(Bytes.wrap("cq3"), col.getQualifier());
+    Assert.assertEquals(Bytes.wrap("cv3"), col.getVisibility());
+    Assert.assertEquals(new Column("cf3", "cq3", "cv3"), col);
+  }
+}
diff --git a/modules/api/src/test/java/io/fluo/api/data/SpanTest.java b/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
index 37f3d6ce..11e8fff8 100644
--- a/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
+++ b/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
@@ -139,33 +139,41 @@ public class SpanTest {
     Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
     Assert.assertFalse(s.isEndInclusive());
     
-    s = Span.exact(rw1b, cf1b);
+    s = Span.exact(rw1b, Column.EMPTY);
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(Column.EMPTY, s.getStart().getColumn());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(new RowColumn(rw1b).following().getRow(), s.getEnd().getRow());
+    Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
+    Assert.assertFalse(s.isEndInclusive());
+    
+    s = Span.exact(rw1b, new Column(cf1b));
     Assert.assertEquals(rw1b, s.getStart().getRow());
     Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
-    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getQualifier());
-    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getVisibility());
+    Assert.assertFalse(s.getStart().getColumn().isQualifierSet());
+    Assert.assertFalse(s.getStart().getColumn().isVisibilitySet());
     Assert.assertTrue(s.isStartInclusive());
     Assert.assertEquals(rw1b, s.getEnd().getRow());
     Assert.assertEquals(new RowColumn(rw1b, new Column(cf1b)).following().getColumn().getFamily(),
                         s.getEnd().getColumn().getFamily());
-    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getQualifier());
-    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.getEnd().getColumn().isQualifierSet());
+    Assert.assertFalse(s.getEnd().getColumn().isVisibilitySet());
     Assert.assertFalse(s.isEndInclusive());
     
-    s = Span.exact(rw1b, cf1b, cq1b);
+    s = Span.exact(rw1b, new Column(cf1b, cq1b));
     Assert.assertEquals(rw1b, s.getStart().getRow());
     Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
     Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier()); 
-    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getVisibility());
+    Assert.assertFalse(s.getStart().getColumn().isVisibilitySet());
     Assert.assertTrue(s.isStartInclusive());
     Assert.assertEquals(rw1b, s.getEnd().getRow());
     Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
     Assert.assertEquals(new RowColumn(rw1b, new Column(cf1b, cq1b)).following().getColumn().getQualifier(),
                         s.getEnd().getColumn().getQualifier());
-    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.getEnd().getColumn().isVisibilitySet());
     Assert.assertFalse(s.isEndInclusive());
     
-    s = Span.exact(rw1b, cf1b, cq1b, cv1b);
+    s = Span.exact(rw1b, new Column(cf1b, cq1b, cv1b));
     Assert.assertEquals(rw1b, s.getStart().getRow());
     Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
     Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier()); 
@@ -189,31 +197,39 @@ public class SpanTest {
     Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
     Assert.assertFalse(s.isEndInclusive());
     
-    s = Span.prefix(rw1b, cf1b);
+    s = Span.prefix(rw1b, new Column());
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(Column.EMPTY, s.getStart().getColumn());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(rw2b, s.getEnd().getRow());
+    Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
+    Assert.assertFalse(s.isEndInclusive());
+    
+    s = Span.prefix(rw1b, new Column(cf1b));
     Assert.assertEquals(rw1b, s.getStart().getRow());
     Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
-    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getQualifier());
-    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getVisibility());
+    Assert.assertFalse(s.getStart().getColumn().isQualifierSet());
+    Assert.assertFalse(s.getStart().getColumn().isVisibilitySet());
     Assert.assertTrue(s.isStartInclusive());
     Assert.assertEquals(rw1b, s.getStart().getRow());
     Assert.assertEquals(cf2b, s.getEnd().getColumn().getFamily());
-    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getQualifier());
-    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.getEnd().getColumn().isQualifierSet());
+    Assert.assertFalse(s.getEnd().getColumn().isVisibilitySet());
     Assert.assertFalse(s.isEndInclusive());
     
-    s = Span.prefix(rw1b, cf1b, cq1b);
+    s = Span.prefix(rw1b, new Column(cf1b, cq1b));
     Assert.assertEquals(rw1b, s.getStart().getRow());
     Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
     Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier());
-    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getVisibility());
+    Assert.assertFalse(s.getStart().getColumn().isVisibilitySet());
     Assert.assertTrue(s.isStartInclusive());
     Assert.assertEquals(rw1b, s.getStart().getRow());
     Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
     Assert.assertEquals(cq2b, s.getEnd().getColumn().getQualifier());
-    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.getEnd().getColumn().isVisibilitySet());
     Assert.assertFalse(s.isEndInclusive());
     
-    s = Span.prefix(rw1b, cf1b, cq1b, cv1b);
+    s = Span.prefix(rw1b, new Column(cf1b, cq1b, cv1b));
     Assert.assertEquals(rw1b, s.getStart().getRow());
     Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
     Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier());
diff --git a/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java b/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java
index f9c31b44..d8330b8a 100644
--- a/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java
+++ b/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java
@@ -95,12 +95,15 @@ public class MockSnapshotBase implements SnapshotBase {
 
       Bytes row = Bytes.wrap(rcv[0]);
       String[] colFields = rcv[1].split(":");
-      if (colFields.length != 2 && colFields.length != 3)
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
 
-      Column col = new Column(colFields[0], colFields[1]);
-      if (colFields.length == 3)
-        col.setVisibility(colFields[2]);
+      Column col;
+      if (colFields.length == 3) {
+        col = new Column(colFields[0], colFields[1], colFields[2]);
+      } else if (colFields.length == 2) {
+        col = new Column(colFields[0], colFields[1]);
+      } else {
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
+      }
 
       Bytes val;
       if (rcv.length == 2)
@@ -133,12 +136,15 @@ public class MockSnapshotBase implements SnapshotBase {
 
       Bytes row = Bytes.wrap(rcv[0]);
       String[] colFields = rcv[1].split(":");
-      if (colFields.length != 2 && colFields.length != 3)
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis] but saw : " + entry);
 
-      Column col = new Column(colFields[0], colFields[1]);
-      if (colFields.length == 3)
-        col.setVisibility(colFields[2]);
+      Column col;
+      if (colFields.length == 3) {
+        col = new Column(colFields[0], colFields[1], colFields[2]);
+      } else if (colFields.length == 2) {
+        col = new Column(colFields[0], colFields[1]);
+      } else {
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
+      }
 
       Set<Column> cols = ret.get(row);
       if (cols == null) {
diff --git a/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java b/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
index 40ee47d8..2705eea2 100644
--- a/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
+++ b/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
@@ -117,10 +117,10 @@ public class TypeLayerTest {
     Assert.assertEquals(new Column("5", "7"), tl.bc().fam(Bytes.wrap("5")).qual(Bytes.wrap("7")).vis());
     Assert.assertEquals(new Column("5", "7"), tl.bc().fam(ByteBuffer.wrap("5".getBytes())).qual(ByteBuffer.wrap("7".getBytes())).vis());
 
-    Assert.assertEquals(new Column("f0", "q0").setVisibility("A&B"), tl.bc().fam("f0".getBytes()).qual("q0".getBytes()).vis("A&B"));
-    Assert.assertEquals(new Column("f0", "q0").setVisibility("A&C"), tl.bc().fam("f0").qual("q0").vis("A&C".getBytes()));
-    Assert.assertEquals(new Column("5", "7").setVisibility("A&D"), tl.bc().fam(5).qual(7).vis(Bytes.wrap("A&D")));
-    Assert.assertEquals(new Column("5", "7").setVisibility("A&D"), tl.bc().fam(5).qual(7).vis(ByteBuffer.wrap("A&D".getBytes())));
+    Assert.assertEquals(new Column("f0", "q0", "A&B"), tl.bc().fam("f0".getBytes()).qual("q0".getBytes()).vis("A&B"));
+    Assert.assertEquals(new Column("f0", "q0", "A&C"), tl.bc().fam("f0").qual("q0").vis("A&C".getBytes()));
+    Assert.assertEquals(new Column("5", "7", "A&D"), tl.bc().fam(5).qual(7).vis(Bytes.wrap("A&D")));
+    Assert.assertEquals(new Column("5", "7", "A&D"), tl.bc().fam(5).qual(7).vis(ByteBuffer.wrap("A&D".getBytes())));
   }
 
   @Test
