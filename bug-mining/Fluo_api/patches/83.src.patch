diff --git a/modules/api/src/main/java/org/apache/fluo/api/types/Encoder.java b/modules/api/src/main/java/org/apache/fluo/api/types/Encoder.java
deleted file mode 100644
index 886a03cc..00000000
--- a/modules/api/src/main/java/org/apache/fluo/api/types/Encoder.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.fluo.api.types;
-
-import org.apache.fluo.api.data.Bytes;
-
-/**
- * Transforms Java primitives to and from bytes using desired encoding
- *
- * @since 1.0.0
- */
-public interface Encoder {
-
-  /**
-   * Encodes an integer to {@link Bytes}
-   */
-  Bytes encode(int i);
-
-  /**
-   * Encodes a long to {@link Bytes}
-   */
-  Bytes encode(long l);
-
-  /**
-   * Encodes a String to {@link Bytes}
-   */
-  Bytes encode(String s);
-
-  /**
-   * Encodes a float to {@link Bytes}
-   */
-  Bytes encode(float f);
-
-  /**
-   * Encodes a double to {@link Bytes}
-   */
-  Bytes encode(double d);
-
-  /**
-   * Encodes a boolean to {@link Bytes}
-   */
-  Bytes encode(boolean b);
-
-  /**
-   * Decodes an integer from {@link Bytes}
-   */
-  int decodeInteger(Bytes b);
-
-  /**
-   * Decodes a long from {@link Bytes}
-   */
-  long decodeLong(Bytes b);
-
-  /**
-   * Decodes a String from {@link Bytes}
-   */
-  String decodeString(Bytes b);
-
-  /**
-   * Decodes a float from {@link Bytes}
-   */
-  float decodeFloat(Bytes b);
-
-  /**
-   * Decodes a double from {@link Bytes}
-   */
-  double decodeDouble(Bytes b);
-
-  /**
-   * Decodes a boolean from {@link Bytes}
-   */
-  boolean decodeBoolean(Bytes b);
-}
diff --git a/modules/api/src/main/java/org/apache/fluo/api/types/StringEncoder.java b/modules/api/src/main/java/org/apache/fluo/api/types/StringEncoder.java
deleted file mode 100644
index 4393f7fa..00000000
--- a/modules/api/src/main/java/org/apache/fluo/api/types/StringEncoder.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.fluo.api.types;
-
-import org.apache.fluo.api.data.Bytes;
-
-/**
- * Transforms Java primitives to and from bytes using a String encoding
- *
- * @since 1.0.0
- */
-public class StringEncoder implements Encoder {
-
-  @Override
-  public Bytes encode(int i) {
-    return encode(Integer.toString(i));
-  }
-
-  @Override
-  public Bytes encode(long l) {
-    return encode(Long.toString(l));
-  }
-
-  @Override
-  public Bytes encode(String s) {
-    return Bytes.of(s);
-  }
-
-  @Override
-  public Bytes encode(float f) {
-    return encode(Float.toString(f));
-  }
-
-  @Override
-  public Bytes encode(double d) {
-    return encode(Double.toString(d));
-  }
-
-  @Override
-  public Bytes encode(boolean b) {
-    return encode(Boolean.toString(b));
-  }
-
-  @Override
-  public int decodeInteger(Bytes b) {
-    return Integer.parseInt(decodeString(b));
-  }
-
-  @Override
-  public long decodeLong(Bytes b) {
-    return Long.parseLong(decodeString(b));
-  }
-
-  @Override
-  public String decodeString(Bytes b) {
-    return b.toString();
-  }
-
-  @Override
-  public float decodeFloat(Bytes b) {
-    return Float.parseFloat(decodeString(b));
-  }
-
-  @Override
-  public double decodeDouble(Bytes b) {
-    return Double.parseDouble(decodeString(b));
-  }
-
-  @Override
-  public boolean decodeBoolean(Bytes b) {
-    return Boolean.parseBoolean(decodeString(b));
-  }
-}
diff --git a/modules/api/src/main/java/org/apache/fluo/api/types/TypeLayer.java b/modules/api/src/main/java/org/apache/fluo/api/types/TypeLayer.java
deleted file mode 100644
index ca20485b..00000000
--- a/modules/api/src/main/java/org/apache/fluo/api/types/TypeLayer.java
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.fluo.api.types;
-
-import java.nio.ByteBuffer;
-
-import org.apache.fluo.api.client.Snapshot;
-import org.apache.fluo.api.client.Transaction;
-import org.apache.fluo.api.client.TransactionBase;
-import org.apache.fluo.api.data.Bytes;
-import org.apache.fluo.api.data.Column;
-
-/**
- * A simple convenience layer for Fluo. This layer attempts to make the following common operations
- * easier.
- *
- * <UL>
- * <LI>Working with different types.
- * <LI>Supplying default values
- * <LI>Dealing with null return types.
- * <LI>Working with row/column and column maps
- * </UL>
- *
- * <p>
- * This layer was intentionally loosely coupled with the basic API. This allows other convenience
- * layers for Fluo to build directly on the basic API w/o having to consider the particulars of this
- * layer. Also its expected that integration with other languages may only use the basic API.
- * </p>
- *
- * <h3>Using</h3>
- *
- * <p>
- * A TypeLayer is created with a certain encoder that is used for converting from bytes to
- * primitives and visa versa. In order to ensure that all of your code uses the same encoder, its
- * probably best to centralize the choice of an encoder within your project. There are many ways do
- * to this, below is an example of one way to centralize and use.
- * </p>
- *
- * <pre>
- * <code>
- * 
- *   public class MyTypeLayer extends TypeLayer {
- *     public MyTypeLayer() {
- *       super(new MyEncoder());
- *     }
- *   }
- * 
- *   public class MyObserver extends TypedObserver {
- *     MyObserver(){
- *       super(new MyTypeLayer());
- *     }
- * 
- *     public abstract void process(TypedTransaction tx, Bytes row, Column col){
- *       //do something w/ typed transaction
- *     }
- *   }
- * 
- *   public class MyUtil {
- *      //A little util to print out some stuff
- *      public void printStuff(Snapshot snap, byte[] row){
- *        TypedSnapshot tsnap = new MytTypeLayer().wrap(snap);
- * 
- *        System.out.println(tsnap.get().row(row).fam("b90000").qual(137).toString("NP"));
- *      }
- *   }
- * </code>
- * </pre>
- *
- * <h3>Working with different types</h3>
- *
- * <p>
- * The following example code shows using the basic fluo API with different types.
- * </p>
- *
- * <pre>
- * <code>
- * 
- *   void process(Transaction tx, byte[] row, byte[] cf, int cq, long val){
- *     tx.set(Bytes.of(row), new Column(Bytes.of(cf), Bytes.of(Integer.toString(cq))),
- *        Bytes.of(Long.toString(val));
- *   }
- * </code>
- * </pre>
- *
- * <p>
- * Alternatively, the same thing can be written using a {@link TypedTransactionBase} in the
- * following way. Because row(), fam(), qual(), and set() each take many different types, this
- * enables many different permutations that would not be achievable with overloading.
- * </p>
- *
- * <pre>
- * <code>
- * 
- *   void process(TypedTransaction tx, byte[] r, byte[] cf, int cq, long v){
- *     tx.mutate().row(r).fam(cf).qual(cq).set(v);
- *   }
- * </code>
- * </pre>
- *
- * <h3>Default values</h3>
- *
- * <p>
- * The following example code shows using the basic fluo API to read a value and default to zero if
- * it does not exist.
- * </p>
- *
- * <pre>
- * <code>
- * 
- *   void add(Transaction tx, byte[] row, Column col, long amount){
- * 
- *     long balance = 0;
- *     Bytes bval = tx.get(Bytes.of(row), col);
- *     if(bval != null)
- *       balance = Long.parseLong(bval.toString());
- * 
- *     balance += amount;
- * 
- *     tx.set(Bytes.of(row), col, Bytes.of(Long.toString(amount)));
- * 
- *   }
- * </code>
- * </pre>
- *
- * <p>
- * Alternatively, the same thing can be written using a {@link TypedTransactionBase} in the
- * following way. This code avoids the null check by supplying a default value of zero.
- * </p>
- *
- * <pre>
- * <code>
- * 
- *   void add(TypedTransaction tx, byte[] r, Column c, long amount){
- *     long balance = tx.get().row(r).col(c).toLong(0);
- *     balance += amount;
- *     tx.mutate().row(r).col(c).set(balance);
- *   }
- * </code>
- * </pre>
- *
- * <p>
- * For this particular case, shorter code can be written by using the increment method.
- * </p>
- *
- * <pre>
- * <code>
- * 
- *   void add(TypedTransaction tx, byte[] r, Column c, long amount){
- *     tx.mutate().row(r).col(c).increment(amount);
- *   }
- * </code>
- * </pre>
- *
- * <h3>Null return types</h3>
- *
- * <p>
- * When using the basic API, you must ensure the return type is not null before converting a string
- * or long.
- * </p>
- *
- * <pre>
- * <code>
- * 
- *   void process(Transaction tx, byte[] row, Column col, long amount) {
- *     Bytes val =  tx.get(Bytes.of(row), col);
- *     if(val == null)
- *       return;
- *     long balance = Long.parseLong(val.toString());
- *   }
- * </code>
- * </pre>
- *
- * <p>
- * With {@link TypedTransactionBase} if no default value is supplied, then the null is passed
- * through.
- * </p>
- *
- * <pre>
- * <code>
- * 
- *   void process(TypedTransaction tx, byte[] r, Column c, long amount){
- *     Long balance =  tx.get().row(r).col(c).toLong();
- *     if(balance == null)
- *       return;
- *   }
- * </code>
- * </pre>
- *
- * <h3>Defaulted maps</h3>
- *
- * <p>
- * The operations that return maps, return defaulted maps which make it easy to specify defaults and
- * avoid null.
- * </p>
- *
- * <pre>
- * {@code
- *   // pretend this method has curly braces.  javadoc has issues with less than.
- * 
- *   void process(TypedTransaction tx, byte[] r, Column c1, Column c2, Column c3, long amount)
- * 
- *     Map<Column, Value> columns = tx.get().row(r).columns(c1,c2,c3);
- * 
- *     // If c1 does not exist in map, a Value that wraps null will be returned.
- *     // When c1 does not exist val1 will be set to null and no NPE will be thrown.
- *     String val1 = columns.get(c1).toString();
- * 
- *     // If c2 does not exist in map, then val2 will be set to empty string.
- *     String val2 = columns.get(c2).toString("");
- * 
- *     // If c3 does not exist in map, then val9 will be set to 9.
- *     Long val3 = columns.get(c3).toLong(9);
- * }
- * </pre>
- *
- * <p>
- * This also applies to getting sets of rows.
- * </p>
- *
- * <pre>
- * {@code
- *   // pretend this method has curly braces.  javadoc has issues with less than.
- * 
- *   void process(TypedTransaction tx, List<String> rows, Column c1, Column c2, Column c3,
- *     long amount)
- * 
- *     Map<String,Map<Column,Value>> rowCols =
- *        tx.get().rowsString(rows).columns(c1,c2,c3).toStringMap();
- * 
- *     // this will set val1 to null if row does not exist in map and/or column does not
- *     // exist in child map
- *     String val1 = rowCols.get("row1").get(c1).toString();
- * }
- * </pre>
- *
- * @since 1.0.0
- */
-public class TypeLayer {
-
-  private Encoder encoder;
-
-  static class Data {
-    Bytes row;
-    Bytes family;
-    Bytes qual;
-    Bytes vis;
-
-    Column getCol() {
-      if (qual == null) {
-        return new Column(family);
-      } else if (vis == null) {
-        return new Column(family, qual);
-      } else {
-        return new Column(family, qual, vis);
-      }
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public abstract class RowMethods<R> {
-
-    abstract R create(Data data);
-
-    public R row(String row) {
-      return row(encoder.encode(row));
-    }
-
-    public R row(int row) {
-      return row(encoder.encode(row));
-    }
-
-    public R row(long row) {
-      return row(encoder.encode(row));
-    }
-
-    public R row(byte[] row) {
-      return row(Bytes.of(row));
-    }
-
-    public R row(ByteBuffer row) {
-      return row(Bytes.of(row));
-    }
-
-    public R row(Bytes row) {
-      Data data = new Data();
-      data.row = row;
-      R result = create(data);
-      return result;
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public abstract class SimpleFamilyMethods<R1> {
-
-    Data data;
-
-    SimpleFamilyMethods(Data data) {
-      this.data = data;
-    }
-
-    abstract R1 create1(Data data);
-
-    public R1 fam(String family) {
-      return fam(encoder.encode(family));
-    }
-
-    public R1 fam(int family) {
-      return fam(encoder.encode(family));
-    }
-
-    public R1 fam(long family) {
-      return fam(encoder.encode(family));
-    }
-
-    public R1 fam(byte[] family) {
-      return fam(Bytes.of(family));
-    }
-
-    public R1 fam(ByteBuffer family) {
-      return fam(Bytes.of(family));
-    }
-
-    public R1 fam(Bytes family) {
-      data.family = family;
-      return create1(data);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public abstract class FamilyMethods<R1, R2> extends SimpleFamilyMethods<R1> {
-
-    FamilyMethods(Data data) {
-      super(data);
-    }
-
-    abstract R2 create2(Data data);
-
-    public R2 col(Column col) {
-      data.family = col.getFamily();
-      data.qual = col.getQualifier();
-      data.vis = col.getVisibility();
-      return create2(data);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public abstract class QualifierMethods<R> {
-
-    private Data data;
-
-    QualifierMethods(Data data) {
-      this.data = data;
-    }
-
-    abstract R create(Data data);
-
-    public R qual(String qualifier) {
-      return qual(encoder.encode(qualifier));
-    }
-
-    public R qual(int qualifier) {
-      return qual(encoder.encode(qualifier));
-    }
-
-    public R qual(long qualifier) {
-      return qual(encoder.encode(qualifier));
-    }
-
-    public R qual(byte[] qualifier) {
-      return qual(Bytes.of(qualifier));
-    }
-
-    public R qual(ByteBuffer qualifier) {
-      return qual(Bytes.of(qualifier));
-    }
-
-    public R qual(Bytes qualifier) {
-      data.qual = qualifier;
-      return create(data);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public static class VisibilityMethods {
-
-    private Data data;
-
-    VisibilityMethods(Data data) {
-      this.data = data;
-    }
-
-    public Column vis() {
-      return new Column(data.family, data.qual);
-    }
-
-    public Column vis(String cv) {
-      return vis(Bytes.of(cv));
-    }
-
-    public Column vis(Bytes cv) {
-      return new Column(data.family, data.qual, cv);
-    }
-
-    public Column vis(ByteBuffer cv) {
-      return vis(Bytes.of(cv));
-    }
-
-    public Column vis(byte[] cv) {
-      return vis(Bytes.of(cv));
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class CQB extends QualifierMethods<VisibilityMethods> {
-    CQB(Data data) {
-      super(data);
-    }
-
-    @Override
-    VisibilityMethods create(Data data) {
-      return new VisibilityMethods(data);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class CFB extends SimpleFamilyMethods<CQB> {
-    CFB() {
-      super(new Data());
-    }
-
-    @Override
-    CQB create1(Data data) {
-      return new CQB(data);
-    }
-  }
-
-  public TypeLayer(Encoder encoder) {
-    this.encoder = encoder;
-  }
-
-  /**
-   * Initiates the chain of calls needed to build a column.
-   *
-   * @return a column builder
-   */
-  public CFB bc() {
-    return new CFB();
-  }
-
-  public TypedSnapshot wrap(Snapshot snap) {
-    return new TypedSnapshot(snap, encoder, this);
-  }
-
-  public TypedTransactionBase wrap(TransactionBase tx) {
-    return new TypedTransactionBase(tx, encoder, this);
-  }
-
-  public TypedTransaction wrap(Transaction tx) {
-    return new TypedTransaction(tx, encoder, this);
-  }
-}
diff --git a/modules/api/src/main/java/org/apache/fluo/api/types/TypedLoader.java b/modules/api/src/main/java/org/apache/fluo/api/types/TypedLoader.java
deleted file mode 100644
index 86c31bb2..00000000
--- a/modules/api/src/main/java/org/apache/fluo/api/types/TypedLoader.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.fluo.api.types;
-
-import org.apache.fluo.api.client.Loader;
-import org.apache.fluo.api.client.TransactionBase;
-
-/**
- * A {@link Loader} that uses a {@link TypeLayer}
- *
- * @since 1.0.0
- */
-public abstract class TypedLoader implements Loader {
-
-  private final TypeLayer tl;
-
-  public TypedLoader() {
-    tl = new TypeLayer(new StringEncoder());
-  }
-
-  public TypedLoader(TypeLayer tl) {
-    this.tl = tl;
-  }
-
-  @Override
-  public void load(TransactionBase tx, Context context) throws Exception {
-    load(tl.wrap(tx), context);
-  }
-
-  public abstract void load(TypedTransactionBase tx, Context context) throws Exception;
-
-}
diff --git a/modules/api/src/main/java/org/apache/fluo/api/types/TypedObserver.java b/modules/api/src/main/java/org/apache/fluo/api/types/TypedObserver.java
deleted file mode 100644
index 302f382b..00000000
--- a/modules/api/src/main/java/org/apache/fluo/api/types/TypedObserver.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.fluo.api.types;
-
-import org.apache.fluo.api.client.TransactionBase;
-import org.apache.fluo.api.data.Bytes;
-import org.apache.fluo.api.data.Column;
-import org.apache.fluo.api.observer.AbstractObserver;
-
-/**
- * An {@link AbstractObserver} that uses a {@link TypeLayer}
- *
- * @since 1.0.0
- */
-public abstract class TypedObserver extends AbstractObserver {
-
-  private final TypeLayer tl;
-
-  public TypedObserver() {
-    tl = new TypeLayer(new StringEncoder());
-  }
-
-  public TypedObserver(TypeLayer tl) {
-    this.tl = tl;
-  }
-
-  @Override
-  public void process(TransactionBase tx, Bytes row, Column col) {
-    process(tl.wrap(tx), row, col);
-  }
-
-  public abstract void process(TypedTransactionBase tx, Bytes row, Column col);
-}
diff --git a/modules/api/src/main/java/org/apache/fluo/api/types/TypedSnapshot.java b/modules/api/src/main/java/org/apache/fluo/api/types/TypedSnapshot.java
deleted file mode 100644
index 97c7f1cb..00000000
--- a/modules/api/src/main/java/org/apache/fluo/api/types/TypedSnapshot.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.fluo.api.types;
-
-import org.apache.fluo.api.client.Snapshot;
-
-/**
- * A {@link Snapshot} that uses a {@link TypeLayer}
- *
- * @since 1.0.0
- */
-public class TypedSnapshot extends TypedSnapshotBase implements Snapshot {
-
-  private final Snapshot closeSnapshot;
-
-  TypedSnapshot(Snapshot snapshot, Encoder encoder, TypeLayer tl) {
-    super(snapshot, encoder, tl);
-    closeSnapshot = snapshot;
-  }
-
-  @Override
-  public void close() {
-    closeSnapshot.close();
-  }
-}
diff --git a/modules/api/src/main/java/org/apache/fluo/api/types/TypedSnapshotBase.java b/modules/api/src/main/java/org/apache/fluo/api/types/TypedSnapshotBase.java
deleted file mode 100644
index 95c46a1e..00000000
--- a/modules/api/src/main/java/org/apache/fluo/api/types/TypedSnapshotBase.java
+++ /dev/null
@@ -1,562 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.fluo.api.types;
-
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-
-import com.google.common.base.Function;
-import com.google.common.collect.Maps;
-import org.apache.commons.collections.map.DefaultedMap;
-import org.apache.fluo.api.client.SnapshotBase;
-import org.apache.fluo.api.config.ScannerConfiguration;
-import org.apache.fluo.api.data.Bytes;
-import org.apache.fluo.api.data.Column;
-import org.apache.fluo.api.data.RowColumn;
-import org.apache.fluo.api.iterator.RowIterator;
-import org.apache.fluo.api.types.TypeLayer.Data;
-import org.apache.fluo.api.types.TypeLayer.FamilyMethods;
-import org.apache.fluo.api.types.TypeLayer.QualifierMethods;
-import org.apache.fluo.api.types.TypeLayer.RowMethods;
-
-// TODO need to refactor column to use Encoder
-
-/**
- * A {@link SnapshotBase} that uses a {@link TypeLayer}
- *
- * @since 1.0.0
- */
-public class TypedSnapshotBase implements SnapshotBase {
-
-  private SnapshotBase snapshot;
-  private Encoder encoder;
-  private TypeLayer tl;
-
-  /**
-   * @since 1.0.0
-   */
-  public class VisibilityMethods extends Value {
-
-    VisibilityMethods(Data data) {
-      super(data);
-    }
-
-    public Value vis(Bytes cv) {
-      data.vis = cv;
-      return new Value(data);
-    }
-
-    public Value vis(byte[] cv) {
-      data.vis = Bytes.of(cv);
-      return new Value(data);
-    }
-
-    public Value vis(ByteBuffer bb) {
-      data.vis = Bytes.of(bb);
-      return new Value(data);
-    }
-
-    public Value vis(String cv) {
-      data.vis = Bytes.of(cv);
-      return new Value(data);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class Value {
-    private Bytes bytes;
-    private boolean gotBytes = false;
-    Data data;
-
-    public Bytes getBytes() {
-      if (!gotBytes) {
-        try {
-          bytes = snapshot.get(data.row, data.getCol());
-          gotBytes = true;
-        } catch (Exception e) {
-          if (e instanceof RuntimeException) {
-            throw (RuntimeException) e;
-          }
-          throw new RuntimeException(e);
-        }
-      }
-
-      return bytes;
-    }
-
-    private Value(Bytes bytes) {
-      this.bytes = bytes;
-      this.gotBytes = true;
-    }
-
-    private Value(Data data) {
-      this.data = data;
-      this.gotBytes = false;
-    }
-
-    public Integer toInteger() {
-      if (getBytes() == null) {
-        return null;
-      }
-      return encoder.decodeInteger(getBytes());
-    }
-
-    public int toInteger(int defaultValue) {
-      if (getBytes() == null) {
-        return defaultValue;
-      }
-      return encoder.decodeInteger(getBytes());
-    }
-
-    public Long toLong() {
-      if (getBytes() == null) {
-        return null;
-      }
-      return encoder.decodeLong(getBytes());
-    }
-
-    public long toLong(long defaultValue) {
-      if (getBytes() == null) {
-        return defaultValue;
-      }
-      return encoder.decodeLong(getBytes());
-    }
-
-    @Override
-    public String toString() {
-      if (getBytes() == null) {
-        return null;
-      }
-      return encoder.decodeString(getBytes());
-    }
-
-    public String toString(String defaultValue) {
-      if (getBytes() == null) {
-        return defaultValue;
-      }
-      return encoder.decodeString(getBytes());
-    }
-
-    public Float toFloat() {
-      if (getBytes() == null) {
-        return null;
-      }
-      return encoder.decodeFloat(getBytes());
-    }
-
-    public float toFloat(float defaultValue) {
-      if (getBytes() == null) {
-        return defaultValue;
-      }
-      return encoder.decodeFloat(getBytes());
-    }
-
-    public Double toDouble() {
-      if (getBytes() == null) {
-        return null;
-      }
-      return encoder.decodeDouble(getBytes());
-    }
-
-    public double toDouble(double defaultValue) {
-      if (getBytes() == null) {
-        return defaultValue;
-      }
-      return encoder.decodeDouble(getBytes());
-    }
-
-    public Boolean toBoolean() {
-      if (getBytes() == null) {
-        return null;
-      }
-      return encoder.decodeBoolean(getBytes());
-    }
-
-    public boolean toBoolean(boolean defaultValue) {
-      if (getBytes() == null) {
-        return defaultValue;
-      }
-      return encoder.decodeBoolean(getBytes());
-    }
-
-    public byte[] toBytes() {
-      if (getBytes() == null) {
-        return null;
-      }
-      return getBytes().toArray();
-    }
-
-    public byte[] toBytes(byte[] defaultValue) {
-      if (getBytes() == null) {
-        return defaultValue;
-      }
-      return getBytes().toArray();
-    }
-
-    public ByteBuffer toByteBuffer() {
-      if (getBytes() == null) {
-        return null;
-      }
-      return ByteBuffer.wrap(getBytes().toArray());
-    }
-
-    public ByteBuffer toByteBuffer(ByteBuffer defaultValue) {
-      if (getBytes() == null) {
-        return defaultValue;
-      }
-      return toByteBuffer();
-    }
-
-    @Override
-    public int hashCode() {
-      if (getBytes() == null) {
-        return 0;
-      }
-
-      return getBytes().hashCode();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof Value) {
-        Value ov = (Value) o;
-        if (getBytes() == null) {
-          return ov.getBytes() == null;
-        } else {
-          return getBytes().equals(ov.getBytes());
-        }
-      }
-
-      return false;
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class ValueQualifierBuilder extends QualifierMethods<VisibilityMethods> {
-
-    ValueQualifierBuilder(Data data) {
-      tl.super(data);
-    }
-
-    @Override
-    VisibilityMethods create(Data data) {
-      return new VisibilityMethods(data);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class ValueFamilyMethods extends FamilyMethods<ValueQualifierBuilder, Value> {
-
-    ValueFamilyMethods(Data data) {
-      tl.super(data);
-    }
-
-    @Override
-    ValueQualifierBuilder create1(Data data) {
-      return new ValueQualifierBuilder(data);
-    }
-
-    @Override
-    Value create2(Data data) {
-      return new Value(data);
-    }
-
-    public Map<Column, Value> columns(Set<Column> columns) {
-      try {
-        return wrap(snapshot.get(data.row, columns));
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    public Map<Column, Value> columns(Column... columns) {
-      try {
-        return wrap(snapshot.get(data.row, new HashSet<>(Arrays.asList(columns))));
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class MapConverter {
-    private Collection<Bytes> rows;
-    private Set<Column> columns;
-
-    public MapConverter(Collection<Bytes> rows, Set<Column> columns) {
-      this.rows = rows;
-      this.columns = columns;
-    }
-
-    private Map<Bytes, Map<Column, Bytes>> getInput() {
-      try {
-        return snapshot.get(rows, columns);
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    @SuppressWarnings({"rawtypes", "unchecked"})
-    private Map wrap2(Map m) {
-      return Collections.unmodifiableMap(DefaultedMap.decorate(m, new DefaultedMap(new Value(
-          (Bytes) null))));
-    }
-
-    @SuppressWarnings("unchecked")
-    public Map<String, Map<Column, Value>> toStringMap() {
-      Map<Bytes, Map<Column, Bytes>> in = getInput();
-      Map<String, Map<Column, Value>> out = new HashMap<>();
-
-      for (Entry<Bytes, Map<Column, Bytes>> rowEntry : in.entrySet()) {
-        out.put(encoder.decodeString(rowEntry.getKey()), wrap(rowEntry.getValue()));
-      }
-
-      return wrap2(out);
-    }
-
-    @SuppressWarnings("unchecked")
-    public Map<Long, Map<Column, Value>> toLongMap() {
-      Map<Bytes, Map<Column, Bytes>> in = getInput();
-      Map<Long, Map<Column, Value>> out = new HashMap<>();
-
-      for (Entry<Bytes, Map<Column, Bytes>> rowEntry : in.entrySet()) {
-        out.put(encoder.decodeLong(rowEntry.getKey()), wrap(rowEntry.getValue()));
-      }
-
-      return wrap2(out);
-    }
-
-    @SuppressWarnings("unchecked")
-    public Map<Integer, Map<Column, Value>> toIntegerMap() {
-      Map<Bytes, Map<Column, Bytes>> in = getInput();
-      Map<Integer, Map<Column, Value>> out = new HashMap<>();
-
-      for (Entry<Bytes, Map<Column, Bytes>> rowEntry : in.entrySet()) {
-        out.put(encoder.decodeInteger(rowEntry.getKey()), wrap(rowEntry.getValue()));
-      }
-
-      return wrap2(out);
-    }
-
-    @SuppressWarnings("unchecked")
-    public Map<Bytes, Map<Column, Value>> toBytesMap() {
-      Map<Bytes, Map<Column, Bytes>> in = getInput();
-      Map<Bytes, Map<Column, Value>> out = new HashMap<>();
-
-      for (Entry<Bytes, Map<Column, Bytes>> rowEntry : in.entrySet()) {
-        out.put(rowEntry.getKey(), wrap(rowEntry.getValue()));
-      }
-
-      return wrap2(out);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class ColumnsMethods {
-    private Collection<Bytes> rows;
-
-    public ColumnsMethods(Collection<Bytes> rows) {
-      this.rows = rows;
-    }
-
-    public MapConverter columns(Set<Column> columns) {
-      return new MapConverter(rows, columns);
-    }
-
-    public MapConverter columns(Column... columns) {
-      return columns(new HashSet<>(Arrays.asList(columns)));
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class ValueRowMethods extends RowMethods<ValueFamilyMethods> {
-
-    ValueRowMethods() {
-      tl.super();
-    }
-
-    @Override
-    ValueFamilyMethods create(Data data) {
-      return new ValueFamilyMethods(data);
-    }
-
-    public ColumnsMethods rows(Collection<Bytes> rows) {
-      return new ColumnsMethods(rows);
-    }
-
-    public ColumnsMethods rows(Bytes... rows) {
-      return new ColumnsMethods(Arrays.asList(rows));
-    }
-
-    public ColumnsMethods rowsString(String... rows) {
-      return rowsString(Arrays.asList(rows));
-    }
-
-    public ColumnsMethods rowsString(Collection<String> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (String row : rows) {
-        conv.add(encoder.encode(row));
-      }
-
-      return rows(conv);
-    }
-
-    public ColumnsMethods rowsLong(Long... rows) {
-      return rowsLong(Arrays.asList(rows));
-    }
-
-    public ColumnsMethods rowsLong(Collection<Long> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (Long row : rows) {
-        conv.add(encoder.encode(row));
-      }
-
-      return rows(conv);
-    }
-
-    public ColumnsMethods rowsInteger(Integer... rows) {
-      return rowsInteger(Arrays.asList(rows));
-    }
-
-    public ColumnsMethods rowsInteger(Collection<Integer> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (Integer row : rows) {
-        conv.add(encoder.encode(row));
-      }
-
-      return rows(conv);
-    }
-
-    public ColumnsMethods rowsBytes(byte[]... rows) {
-      return rowsBytes(Arrays.asList(rows));
-    }
-
-    public ColumnsMethods rowsBytes(Collection<byte[]> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (byte[] row : rows) {
-        conv.add(Bytes.of(row));
-      }
-
-      return rows(conv);
-    }
-
-    public ColumnsMethods rowsByteBuffers(ByteBuffer... rows) {
-      return rowsByteBuffers(Arrays.asList(rows));
-    }
-
-    public ColumnsMethods rowsByteBuffers(Collection<ByteBuffer> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (ByteBuffer row : rows) {
-        conv.add(Bytes.of(row));
-      }
-
-      return rows(conv);
-    }
-
-  }
-
-  TypedSnapshotBase(SnapshotBase snapshot, Encoder encoder, TypeLayer tl) {
-    this.snapshot = snapshot;
-    this.encoder = encoder;
-    this.tl = tl;
-  }
-
-  @Override
-  public Bytes get(Bytes row, Column column) {
-    return snapshot.get(row, column);
-  }
-
-  @Override
-  public Map<Column, Bytes> get(Bytes row, Set<Column> columns) {
-    return snapshot.get(row, columns);
-  }
-
-  @Override
-  public Map<Bytes, Map<Column, Bytes>> get(Collection<RowColumn> rowColumns) {
-    return snapshot.get(rowColumns);
-  }
-
-  @Override
-  public RowIterator get(ScannerConfiguration config) {
-    return snapshot.get(config);
-  }
-
-  @Override
-  public Map<Bytes, Map<Column, Bytes>> get(Collection<Bytes> rows, Set<Column> columns) {
-    return snapshot.get(rows, columns);
-  }
-
-  public ValueRowMethods get() {
-    return new ValueRowMethods();
-  }
-
-  @SuppressWarnings({"unchecked"})
-  private Map<Column, Value> wrap(Map<Column, Bytes> map) {
-    Map<Column, Value> ret = Maps.transformValues(map, new Function<Bytes, Value>() {
-      @Override
-      public Value apply(Bytes input) {
-        return new Value(input);
-      }
-    });
-
-    return Collections.unmodifiableMap(DefaultedMap.decorate(ret, new Value((Bytes) null)));
-  }
-
-  @Override
-  public long getStartTimestamp() {
-    return snapshot.getStartTimestamp();
-  }
-
-  @Override
-  public String gets(String row, Column column) {
-    return snapshot.gets(row, column);
-  }
-
-  @Override
-  public Map<Column, String> gets(String row, Set<Column> columns) {
-    return snapshot.gets(row, columns);
-  }
-
-  @Override
-  public Map<String, Map<Column, String>> gets(Collection<String> rows, Set<Column> columns) {
-    return snapshot.gets(rows, columns);
-  }
-
-  @Override
-  public Map<String, Map<Column, String>> gets(Collection<RowColumn> rowColumns) {
-    return snapshot.gets(rowColumns);
-  }
-}
diff --git a/modules/api/src/main/java/org/apache/fluo/api/types/TypedTransaction.java b/modules/api/src/main/java/org/apache/fluo/api/types/TypedTransaction.java
deleted file mode 100644
index 62b32c2e..00000000
--- a/modules/api/src/main/java/org/apache/fluo/api/types/TypedTransaction.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.fluo.api.types;
-
-import com.google.common.annotations.VisibleForTesting;
-import org.apache.fluo.api.client.Transaction;
-import org.apache.fluo.api.exceptions.CommitException;
-
-/**
- * A {@link Transaction} that uses a {@link TypeLayer}
- *
- * @since 1.0.0
- */
-public class TypedTransaction extends TypedTransactionBase implements Transaction {
-
-  private final Transaction closeTx;
-
-  @VisibleForTesting
-  protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) {
-    super(tx, encoder, tl);
-    closeTx = tx;
-  }
-
-  @Override
-  public void commit() throws CommitException {
-    closeTx.commit();
-  }
-
-  @Override
-  public void close() {
-    closeTx.close();
-  }
-}
diff --git a/modules/api/src/main/java/org/apache/fluo/api/types/TypedTransactionBase.java b/modules/api/src/main/java/org/apache/fluo/api/types/TypedTransactionBase.java
deleted file mode 100644
index a45bff16..00000000
--- a/modules/api/src/main/java/org/apache/fluo/api/types/TypedTransactionBase.java
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.fluo.api.types;
-
-import java.nio.ByteBuffer;
-
-import com.google.common.annotations.VisibleForTesting;
-import org.apache.fluo.api.client.TransactionBase;
-import org.apache.fluo.api.data.Bytes;
-import org.apache.fluo.api.data.Column;
-import org.apache.fluo.api.exceptions.AlreadySetException;
-import org.apache.fluo.api.types.TypeLayer.Data;
-import org.apache.fluo.api.types.TypeLayer.FamilyMethods;
-import org.apache.fluo.api.types.TypeLayer.QualifierMethods;
-import org.apache.fluo.api.types.TypeLayer.RowMethods;
-
-/**
- * A {@link TransactionBase} that uses a {@link TypeLayer}
- *
- * @since 1.0.0
- */
-public class TypedTransactionBase extends TypedSnapshotBase implements TransactionBase {
-
-  private final TransactionBase tx;
-  private final Encoder encoder;
-  private final TypeLayer tl;
-
-  /**
-   * @since 1.0.0
-   */
-  public class Mutator {
-
-    private boolean set = false;
-    Data data;
-
-    Mutator(Data data) {
-      this.data = data;
-    }
-
-    void checkNotSet() {
-      if (set) {
-        throw new IllegalStateException("Already set value");
-      }
-    }
-
-    public void set(Bytes bytes) throws AlreadySetException {
-      checkNotSet();
-      tx.set(data.row, data.getCol(), bytes);
-      set = true;
-    }
-
-    public void set(String s) throws AlreadySetException {
-      set(encoder.encode(s));
-    }
-
-    public void set(int i) throws AlreadySetException {
-      set(encoder.encode(i));
-    }
-
-    public void set(long l) throws AlreadySetException {
-      set(encoder.encode(l));
-    }
-
-    public void set(float f) throws AlreadySetException {
-      set(encoder.encode(f));
-    }
-
-    public void set(double d) throws AlreadySetException {
-      set(encoder.encode(d));
-    }
-
-    public void set(boolean b) throws AlreadySetException {
-      set(encoder.encode(b));
-    }
-
-    public void set(byte[] ba) throws AlreadySetException {
-      set(Bytes.of(ba));
-    }
-
-    public void set(ByteBuffer bb) throws AlreadySetException {
-      set(Bytes.of(bb));
-    }
-
-    /**
-     * Set an empty value
-     */
-    public void set() throws AlreadySetException {
-      set(Bytes.EMPTY);
-    }
-
-    /**
-     * Reads the current value of the row/column, adds i, sets the sum. If the row/column does not
-     * have a current value, then it defaults to zero.
-     *
-     * @param i Integer increment amount
-     * @throws AlreadySetException if value was previously set in transaction
-     */
-    public void increment(int i) throws AlreadySetException {
-      checkNotSet();
-      Bytes val = tx.get(data.row, data.getCol());
-      int v = 0;
-      if (val != null) {
-        v = encoder.decodeInteger(val);
-      }
-      tx.set(data.row, data.getCol(), encoder.encode(v + i));
-    }
-
-    /**
-     * Reads the current value of the row/column, adds l, sets the sum. If the row/column does not
-     * have a current value, then it defaults to zero.
-     *
-     * @param l Long increment amount
-     * @throws AlreadySetException if value was previously set in transaction
-     */
-    public void increment(long l) throws AlreadySetException {
-      checkNotSet();
-      Bytes val = tx.get(data.row, data.getCol());
-      long v = 0;
-      if (val != null) {
-        v = encoder.decodeLong(val);
-      }
-      tx.set(data.row, data.getCol(), encoder.encode(v + l));
-    }
-
-    public void delete() throws AlreadySetException {
-      checkNotSet();
-      tx.delete(data.row, data.getCol());
-      set = true;
-    }
-
-    public void weaklyNotify() {
-      checkNotSet();
-      tx.setWeakNotification(data.row, data.getCol());
-      set = true;
-    }
-
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class VisibilityMutator extends Mutator {
-
-    VisibilityMutator(Data data) {
-      super(data);
-    }
-
-    public Mutator vis(String cv) {
-      checkNotSet();
-      data.vis = Bytes.of(cv);
-      return new Mutator(data);
-    }
-
-    public Mutator vis(Bytes cv) {
-      checkNotSet();
-      data.vis = cv;
-      return new Mutator(data);
-    }
-
-    public Mutator vis(byte[] cv) {
-      checkNotSet();
-      data.vis = Bytes.of(cv);
-      return new Mutator(data);
-    }
-
-    public Mutator vis(ByteBuffer cv) {
-      checkNotSet();
-      data.vis = Bytes.of(cv);
-      return new Mutator(data);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class MutatorQualifierMethods extends QualifierMethods<VisibilityMutator> {
-
-    MutatorQualifierMethods(Data data) {
-      tl.super(data);
-    }
-
-    @Override
-    VisibilityMutator create(Data data) {
-      return new VisibilityMutator(data);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class MutatorFamilyMethods extends FamilyMethods<MutatorQualifierMethods, Mutator> {
-
-    MutatorFamilyMethods(Data data) {
-      tl.super(data);
-    }
-
-    @Override
-    MutatorQualifierMethods create1(Data data) {
-      return new MutatorQualifierMethods(data);
-    }
-
-    @Override
-    Mutator create2(Data data) {
-      return new Mutator(data);
-    }
-  }
-
-  /**
-   * @since 1.0.0
-   */
-  public class MutatorRowMethods extends RowMethods<MutatorFamilyMethods> {
-
-    MutatorRowMethods() {
-      tl.super();
-    }
-
-    @Override
-    MutatorFamilyMethods create(Data data) {
-      return new MutatorFamilyMethods(data);
-    }
-
-  }
-
-  @VisibleForTesting
-  protected TypedTransactionBase(TransactionBase tx, Encoder encoder, TypeLayer tl) {
-    super(tx, encoder, tl);
-    this.tx = tx;
-    this.encoder = encoder;
-    this.tl = tl;
-  }
-
-  public MutatorRowMethods mutate() {
-    return new MutatorRowMethods();
-  }
-
-  @Override
-  public void set(Bytes row, Column col, Bytes value) throws AlreadySetException {
-    tx.set(row, col, value);
-  }
-
-  @Override
-  public void set(String row, Column col, String value) throws AlreadySetException {
-    tx.set(row, col, value);
-  }
-
-  @Override
-  public void setWeakNotification(Bytes row, Column col) {
-    tx.setWeakNotification(row, col);
-  }
-
-  @Override
-  public void setWeakNotification(String row, Column col) {
-    tx.setWeakNotification(row, col);
-  }
-
-  @Override
-  public void delete(Bytes row, Column col) throws AlreadySetException {
-    tx.delete(row, col);
-  }
-
-  @Override
-  public void delete(String row, Column col) {
-    tx.delete(row, col);
-  }
-}
