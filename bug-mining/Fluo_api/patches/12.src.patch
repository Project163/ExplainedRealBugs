diff --git a/modules/api/pom.xml b/modules/api/pom.xml
index bfc41280..397c8554 100644
--- a/modules/api/pom.xml
+++ b/modules/api/pom.xml
@@ -53,9 +53,19 @@
       <scope>compile</scope>
     </dependency>
     <dependency>
-      <artifactId>commons-configuration</artifactId>
       <groupId>commons-configuration</groupId>
+      <artifactId>commons-configuration</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>commons-collections</groupId>
+      <artifactId>commons-collections</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+
+
     <dependency>
       <groupId>org.apache.hadoop</groupId>
       <artifactId>hadoop-client</artifactId>
diff --git a/modules/api/src/main/java/io/fluo/api/client/Transaction.java b/modules/api/src/main/java/io/fluo/api/client/Transaction.java
index 054c8d67..db517fb0 100644
--- a/modules/api/src/main/java/io/fluo/api/client/Transaction.java
+++ b/modules/api/src/main/java/io/fluo/api/client/Transaction.java
@@ -28,5 +28,4 @@ public interface Transaction extends Snapshot {
   public abstract void set(Bytes row, Column col, Bytes value);
   
   public abstract void delete(Bytes row, Column col);
-  
 }
diff --git a/modules/api/src/main/java/io/fluo/api/types/LexicoEncoder.java b/modules/api/src/main/java/io/fluo/api/types/LexicoEncoder.java
deleted file mode 100644
index ea4d8e12..00000000
--- a/modules/api/src/main/java/io/fluo/api/types/LexicoEncoder.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.types;
-
-import io.fluo.api.data.Bytes;
-import org.apache.accumulo.core.client.lexicoder.IntegerLexicoder;
-import org.apache.accumulo.core.client.lexicoder.LongLexicoder;
-
-public class LexicoEncoder implements Encoder {
-
-  private IntegerLexicoder il = new IntegerLexicoder();
-  private LongLexicoder ll = new LongLexicoder();
-  
-  @Override
-  public int decodeInteger(Bytes b) {
-    return il.decode(b.toArray());
-  }
-
-  @Override
-  public Bytes encode(int i) {
-    return Bytes.wrap(il.encode(i));
-  }
-
-  @Override
-  public long decodeLong(Bytes b) {
-    return ll.decode(b.toArray());
-  }
-
-  @Override
-  public Bytes encode(long l) {
-    return Bytes.wrap(ll.encode(l));
-  }
-
-  @Override
-  public String decodeString(Bytes b) {
-    return b.toString();
-  }
-
-  @Override
-  public Bytes encode(String s) {
-    return Bytes.wrap(s);
-  }
-}
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java b/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java
index b1c2ff5c..efa66e3e 100644
--- a/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java
+++ b/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java
@@ -15,195 +15,425 @@
  */
 package io.fluo.api.types;
 
-import io.fluo.api.client.FluoClient;
 import io.fluo.api.client.Snapshot;
 import io.fluo.api.client.Transaction;
 import io.fluo.api.data.Bytes;
 import io.fluo.api.data.Column;
-import org.apache.accumulo.core.security.ColumnVisibility;
 
-public class TypeLayer {
+import java.nio.ByteBuffer;
 
-  private Encoder encoder;
+import org.apache.accumulo.core.security.ColumnVisibility;
 
-  abstract static class RowColumnBuilder<TC,TQ> {
-    abstract void setRow(Bytes r);
+/**
+ * A simple convenience layer for Fluo. This layer attempts to make the following common operations easier.
+ * 
+ * <UL>
+ * <LI>Working with different types.
+ * <LI>Supplying default values
+ * <LI>Dealing with null return types.
+ * <LI>Working with row/column and column maps
+ * </UL>
+ * 
+ * <p>
+ * This layer was intentionally loosely coupled with the basic API. This allows other convenience layers for Fluo to build directly on the basic API w/o having
+ * to consider the particulars of this layer. Also its expected that integration with other languages may only use the basic API.
+ * </p>
+ * 
+ * <h3>Using</h3>
+ * 
+ * <p>
+ * A TypeLayer is created with a certain encoder thats used for converting from bytes to primitives and visa versa. In order to ensure that all of your code
+ * uses the same encoder, its probably best to centralize the choice of an encoder within your project. There are many ways do to this, below is an example of
+ * one way to centralize and use.
+ * </p>
+ * 
+ * <pre>
+ * <code>
+ *   public class MyTypeLayer extends TypeLayer {
+ *     public MyTypeLayer() {
+ *       super(new MyEncoder());
+ *     }
+ *   }
+ *   
+ *   public class MyObserver extends TypedObserver {
+ *     MyObserver(){
+ *       super(new MyTypeLayer());
+ *     }
+ *     
+ *     public abstract void process(TypedTransaction tx, Bytes row, Column col){
+ *       //do something w/ typed transaction
+ *     }
+ *   }
+ *   
+ *   public class MyUtil {
+ *      //A little util to print out some stuff
+ *      public void printStuff(Snapshot snap, byte[] row){
+ *        TypedSnapshot tsnap = new MytTypeLayer().wrap(snap);
+ *        
+ *        System.out.println(tsnap.get().row(row).fam("b90000").qual(137).toString("NP"));
+ *      } 
+ *   }
+ * </code>
+ * </pre>
+ * 
+ * <h3>Working with different types</h3>
+ * 
+ * <p>
+ * The following example code shows using the basic fluo API with different types.
+ * </p>
+ * 
+ * <pre>
+ * <code>
+ *   void process(Transaction tx, byte[] row, byte[] cf, int cq, long val){
+ *     tx.set(Bytes.wrap(row), new Column(Bytes.wrap(cf), Bytes.wrap(Integer.toString(cq))), Bytes.wrap(Long.toString(val));
+ *   }
+ * </code>
+ * </pre>
+ * 
+ * <p>
+ * Alternatively, the same thing can be written using a {@link TypedTransaction} in the following way. Because row(), fam(), qual(), and set() each take many
+ * different types, this enables many different permutations that would not be achievable with overloading.
+ * </p>
+ * 
+ * <pre>
+ * <code>
+ *   void process(TypedTransaction tx, byte[] r, byte[] cf, int cq, long v){
+ *     tx.mutate().row(r).fam(cf).qual(cq).set(v);
+ *   }
+ * </code>
+ * </pre>
+ * 
+ * <h3>Default values</h3>
+ * 
+ * <p>
+ * The following example code shows using the basic fluo API to read a value and default to zero if it does not exist.
+ * </p>
+ * 
+ * <pre>
+ * <code>
+ *   void add(Transaction tx, byte[] row, Column col, long amount){
+ *     
+ *     long balance = 0;
+ *     Bytes bval = tx.get(Bytes.wrap(row), col);
+ *     if(bval != null)
+ *       balance = Long.parseLong(bval.toString());
+ *     
+ *     balance += amount;
+ *     
+ *     tx.set(Bytes.wrap(row), col, Bytes.wrap(Long.toString(amount)));
+ *     
+ *   }
+ * </code>
+ * </pre>
+ * 
+ * <p>
+ * Alternatively, the same thing can be written using a {@link TypedTransaction} in the following way. This code avoids the null check by supplying a default
+ * value of zero.
+ * </p>
+ * 
+ * <pre>
+ * <code>
+ *   void add(TypedTransaction tx, byte[] r, Column c, long amount){
+ *     long balance = tx.get().row(r).col(c).toLong(0);
+ *     balance += amount;
+ *     tx.mutate().row(r).col(c).set(balance);
+ *   }
+ * </code>
+ * </pre>
+ * 
+ * <p>
+ * For this particular case, shorter code can be written by using the increment method.
+ * </p>
+ * 
+ * <pre>
+ * <code>
+ *   void add(TypedTransaction tx, byte[] r, Column c, long amount){
+ *     tx.mutate().row(r).col(c).increment(amount);
+ *   }
+ * </code>
+ * </pre>
+ * 
+ * <h3>Null return types</h3>
+ * 
+ * <p>
+ * When using the basic API, you must ensure the return type is not null before converting a string or long.
+ * </p>
+ * 
+ * <pre>
+ * <code>
+ *   void process(Transaction tx, byte[] row, Column col, long amount){
+ *     Bytes val =  tx.get(Bytes.wrap(row), col);
+ *     if(val == null)
+ *       return;   
+ *     long balance = Long.parseLong(val.toString());
+ *   }
+ * </code>
+ * </pre>
+ * 
+ * <p>
+ * With {@link TypedTransaction} if no default value is supplied, then the null is passed through.
+ * </p>
+ * 
+ * <pre>
+ * <code>
+ *   void process(TypedTransaction tx, byte[] r, Column c, long amount){
+ *     Long balance =  tx.get().row(r).col(c).toLong();
+ *     if(balance == null)
+ *       return;   
+ *   }
+ * </code>
+ * </pre>
+ * 
+ * <h3>Defaulted maps</h3>
+ * 
+ * <p>
+ * The operations that return maps, return defaulted maps which make it easy to specify defaults and avoid null.
+ * </p>
+ * 
+ * <pre>
+ * {@code
+ *   //pretend this method has curly braces, getting javadoc to work w/ less than and curly braces is too hard
+ *   void process(TypedTransaction tx, byte[] r, Column c1, Column c2, Column c3, long amount)
+ *     Map<Column, Value> columns = tx.get().row(r).columns(c1,c2,c3);
+ *     
+ *     //If c1 does not exist in map, a Value that wraps null will be returned.  When c1 does not exist val1 will be set to null and no NPE will be thrown.
+ *     String val1 = columns.get(c1).toString();
+ *     
+ *     //If c2 does not exist in map, then val2 will be set to empty string.
+ *     String val2 = columns.get(c2).toString("");
+ *     
+ *     //If c3 does not exist in map, then val9 will be set to 9.
+ *     Long val3 = columns.get(c3).toLong(9);
+ * }
+ * </pre>
+ * 
+ * <p>
+ * This also applies to getting sets of rows.
+ * </p>
+ * 
+ * <pre>
+ * {@code
+ *   //also pretend this method has curly braces
+ *   void process(TypedTransaction tx, List<String> rows, Column c1, Column c2, Column c3, long amount)
+ *     Map<String,Map<Column,Value>> rowCols = tx.get().rowsString(rows).columns(c1,c2,c3).toStringMap();
+ *     
+ *     //this will set val1 to null if row does not exist in map and/or column does not exist in child map
+ *     String val1 = rowCols.get("row1").get(c1).toString();
+ *  }
+ * </pre>
+ */
 
-    abstract void setFamily(Bytes f);
+public class TypeLayer {
 
-    abstract TQ setQualifier(Bytes q);
+  private Encoder encoder;
 
-    abstract TC setColumn(Column c);
+  static class Data {
+    Bytes row;
+    Bytes family;
+    Bytes qual;
+    Bytes vis;
+
+    Column getCol() {
+      if (vis == null)
+        return new Column(family, qual);
+      else
+        return new Column(family, qual, vis);
+    }
   }
 
-  private static class ColumnBuilder extends RowColumnBuilder<Column,VisibilityBuilder> {
-
-    private Bytes family;
+  public abstract class RowMethods<R> {
 
-    @Override
-    void setRow(Bytes r) {
-      throw new UnsupportedOperationException();
-    }
+    abstract R create(Data data);
 
-    @Override
-    void setFamily(Bytes f) {
-      this.family = f;
+    public R row(String row) {
+      return row(encoder.encode(row));
     }
 
-    @Override
-    VisibilityBuilder setQualifier(Bytes q) {
-      return new VisibilityBuilder(new Column(family, q));
+    public R row(int row) {
+      return row(encoder.encode(row));
     }
 
-    @Override
-    Column setColumn(Column c) {
-      return c;
+    public R row(long row) {
+      return row(encoder.encode(row));
     }
 
-  }
-
-  public static class VisibilityBuilder {
-    private Column column;
-
-    private VisibilityBuilder(Column column) {
-      this.column = column;
+    public R row(byte[] row) {
+      return row(Bytes.wrap(row));
     }
 
-    public Column vis() {
-      return column;
+    public R row(ByteBuffer row) {
+      return row(Bytes.wrap(row));
     }
 
-    public Column vis(ColumnVisibility cv) {
-      column.setVisibility(cv);
-      return column;
+    public R row(Bytes row) {
+      Data data = new Data();
+      data.row = row;
+      R result = create(data);
+      return result;
     }
   }
 
-  public class RowAction<TC,TQ,R extends RowColumnBuilder<TC,TQ>> {
+  public abstract class SimpleFamilyMethods<R1> {
+
+    protected Data data;
+
+    SimpleFamilyMethods(Data data) {
+      this.data = data;
+    }
 
-    private R result;
+    abstract R1 create1(Data data);
 
-    RowAction(R result) {
-      this.result = result;
+    public R1 fam(String family) {
+      return fam(encoder.encode(family));
     }
 
-    public FamilyAction<TC,TQ,R> row(String row) {
-      result.setRow(encoder.encode(row));
-      return new FamilyAction<TC,TQ,R>(result);
+    public R1 fam(int family) {
+      return fam(encoder.encode(family));
     }
 
-    public FamilyAction<TC,TQ,R> row(int row) {
-      result.setRow(encoder.encode(row));
-      return new FamilyAction<TC,TQ,R>(result);
+    public R1 fam(long family) {
+      return fam(encoder.encode(family));
     }
 
-    public FamilyAction<TC,TQ,R> row(long row) {
-      result.setRow(encoder.encode(row));
-      return new FamilyAction<TC,TQ,R>(result);
+    public R1 fam(byte[] family) {
+      return fam(Bytes.wrap(family));
     }
 
-    public FamilyAction<TC,TQ,R> row(byte[] row) {
-      result.setRow(Bytes.wrap(row));
-      return new FamilyAction<TC,TQ,R>(result);
+    public R1 fam(ByteBuffer family) {
+      return fam(Bytes.wrap(family));
     }
 
-    public FamilyAction<TC,TQ,R> row(Bytes row) {
-      result.setRow(row);
-      return new FamilyAction<TC,TQ,R>(result);
+    public R1 fam(Bytes family) {
+      data.family = family;
+      return create1(data);
     }
   }
 
+  public abstract class FamilyMethods<R1,R2> extends SimpleFamilyMethods<R1> {
 
+    FamilyMethods(Data data) {
+      super(data);
+    }
+
+    abstract R2 create2(Data data);
+
+    public R2 col(Column col) {
+      data.family = col.getFamily();
+      data.qual = col.getQualifier();
+      data.vis = col.getVisibility();
+      return create2(data);
+    }
+  }
 
-  public class FamilyAction<TC,TQ,R extends RowColumnBuilder<TC,TQ>> {
+  public abstract class QualifierMethods<R> {
 
-    private R result;
+    protected Data data;
 
-    FamilyAction(R result) {
-      this.result = result;
+    QualifierMethods(Data data) {
+      this.data = data;
     }
 
-    public QualifierAction<TC,TQ,R> fam(String family) {
-      result.setFamily(encoder.encode(family));
-      return new QualifierAction<TC,TQ,R>(result);
+    abstract R create(Data data);
+
+    public R qual(String qualifier) {
+      return qual(encoder.encode(qualifier));
     }
 
-    public QualifierAction<TC,TQ,R> fam(int family) {
-      result.setFamily(encoder.encode(family));
-      return new QualifierAction<TC,TQ,R>(result);
+    public R qual(int qualifier) {
+      return qual(encoder.encode(qualifier));
     }
 
-    public QualifierAction<TC,TQ,R> fam(long family) {
-      result.setFamily(encoder.encode(family));
-      return new QualifierAction<TC,TQ,R>(result);
+    public R qual(long qualifier) {
+      return qual(encoder.encode(qualifier));
     }
 
-    public QualifierAction<TC,TQ,R> fam(byte[] family) {
-      result.setFamily(Bytes.wrap(family));
-      return new QualifierAction<TC,TQ,R>(result);
+    public R qual(byte[] qualifier) {
+      return qual(Bytes.wrap(qualifier));
     }
 
-    public QualifierAction<TC,TQ,R> fam(Bytes family) {
-      result.setFamily(family);
-      return new QualifierAction<TC,TQ,R>(result);
+    public R qual(ByteBuffer qualifier) {
+      return qual(Bytes.wrap(qualifier));
     }
 
-    public TC col(Column c) {
-      return result.setColumn(c);
+    public R qual(Bytes qualifier) {
+      data.qual = qualifier;
+      return create(data);
     }
   }
 
-  public class QualifierAction<TC,TQ,R extends RowColumnBuilder<TC,TQ>> {
+  public static class VisibilityMethods {
 
-    private R result;
+    private Data data;
 
-    QualifierAction(R result) {
-      this.result = result;
+    public VisibilityMethods(Data data) {
+      this.data = data;
     }
 
-    public TQ qual(String qualifier) {
-      return result.setQualifier(encoder.encode(qualifier));
+    public Column vis() {
+      return new Column(data.family, data.qual);
     }
 
-    public TQ qual(int qualifier) {
-      return result.setQualifier(encoder.encode(qualifier));
+    public Column vis(ColumnVisibility cv) {
+      return new Column(data.family, data.qual, cv);
     }
 
-    public TQ qual(long qualifier) {
-      return result.setQualifier(encoder.encode(qualifier));
+    public Column vis(String cv) {
+      return vis(Bytes.wrap(cv));
     }
 
-    public TQ qual(byte[] qualifier) {
-      return result.setQualifier(Bytes.wrap(qualifier));
+    public Column vis(Bytes cv) {
+      return new Column(data.family, data.qual, cv);
     }
 
-    public TQ qual(Bytes qualifier) {
-      return result.setQualifier(qualifier);
+    public Column vis(ByteBuffer cv) {
+      return vis(Bytes.wrap(cv));
     }
 
+    public Column vis(byte[] cv) {
+      return vis(Bytes.wrap(cv));
+    }
   }
 
-  public TypeLayer(Encoder encoder) {
-    this.encoder = encoder;
+  public class CQB extends QualifierMethods<VisibilityMethods> {
+    CQB(Data data) {
+      super(data);
+    }
+
+    @Override
+    VisibilityMethods create(Data data) {
+      return new VisibilityMethods(data);
+    }
   }
 
-  public Column newColumn(String cf, String cq) {
-    return newColumn().fam(cf).qual(cq).vis();
+  public class CFB extends SimpleFamilyMethods<CQB> {
+    CFB() {
+      super(new Data());
+    }
+
+    @Override
+    CQB create1(Data data) {
+      return new CQB(data);
+    }
   }
 
-  public FamilyAction<Column,VisibilityBuilder,ColumnBuilder> newColumn() {
-    return new FamilyAction<Column,VisibilityBuilder,ColumnBuilder>(new ColumnBuilder());
+  public TypeLayer(Encoder encoder) {
+    this.encoder = encoder;
   }
 
-  public TypedSnapshot snapshot(FluoClient client) {
-    return snapshot(client.newSnapshot());
+  /**
+   * Intiates the chain of calls needed to build a column.
+   * 
+   * @return a column builder
+   */
+  public CFB bc() {
+    return new CFB();
   }
-  
-  public TypedSnapshot snapshot(Snapshot snap) {
+
+  public TypedSnapshot wrap(Snapshot snap) {
     return new TypedSnapshot(snap, encoder, this);
   }
 
-  public TypedTransaction transaction(Transaction tx) {
+  public TypedTransaction wrap(Transaction tx) {
     return new TypedTransaction(tx, encoder, this);
   }
 }
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedLoader.java b/modules/api/src/main/java/io/fluo/api/types/TypedLoader.java
new file mode 100644
index 00000000..df63e8c6
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedLoader.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2014 Fluo authors (see AUTHORS)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.types;
+
+import io.fluo.api.client.Loader;
+import io.fluo.api.client.Transaction;
+
+public abstract class TypedLoader implements Loader {
+
+  private TypeLayer tl;
+
+  public TypedLoader() {
+    tl = new TypeLayer(new StringEncoder());
+  }
+
+  public TypedLoader(TypeLayer tl) {
+    this.tl = tl;
+  }
+
+  @Override
+  public void load(Transaction tx) throws Exception {
+    load(tl.wrap(tx));
+  }
+
+  public abstract void load(TypedTransaction tx) throws Exception;
+
+}
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedObserver.java b/modules/api/src/main/java/io/fluo/api/types/TypedObserver.java
new file mode 100644
index 00000000..f1e5c49e
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedObserver.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2014 Fluo authors (see AUTHORS)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.types;
+
+import io.fluo.api.client.Transaction;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.observer.AbstractObserver;
+
+public abstract class TypedObserver extends AbstractObserver {
+
+  private TypeLayer tl;
+
+  public TypedObserver() {
+    tl = new TypeLayer(new StringEncoder());
+  }
+
+  public TypedObserver(TypeLayer tl) {
+    this.tl = tl;
+  }
+
+  @Override
+  public void process(Transaction tx, Bytes row, Column col) {
+    process(tl.wrap(tx), row, col);
+  }
+
+  public abstract void process(TypedTransaction tx, Bytes row, Column col);
+}
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java
index 0e1395e5..7c725200 100644
--- a/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java
@@ -15,75 +15,86 @@
  */
 package io.fluo.api.types;
 
+import io.fluo.api.client.Snapshot;
+import io.fluo.api.config.ScannerConfiguration;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.iterator.RowIterator;
+import io.fluo.api.types.TypeLayer.Data;
+import io.fluo.api.types.TypeLayer.FamilyMethods;
+import io.fluo.api.types.TypeLayer.QualifierMethods;
+import io.fluo.api.types.TypeLayer.RowMethods;
+
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 
-import io.fluo.api.client.Snapshot;
-import io.fluo.api.config.ScannerConfiguration;
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-import io.fluo.api.iterator.RowIterator;
-import io.fluo.api.types.TypeLayer.RowAction;
-import io.fluo.api.types.TypeLayer.RowColumnBuilder;
 import org.apache.accumulo.core.security.ColumnVisibility;
 import org.apache.commons.collections.map.DefaultedMap;
 
+import com.google.common.base.Function;
+import com.google.common.collect.Maps;
+
 //TODO need to refactor column to use Encoder
 
+/**
+ * See {@link TypeLayer} javadocs.
+ */
+
 public class TypedSnapshot implements Snapshot {
 
   private Snapshot snapshot;
   private Encoder encoder;
   private TypeLayer tl;
 
-  private class KeyBuilder extends RowColumnBuilder<Value,VisBytesDecoder> {
+  public class VisibilityMethods extends Value {
 
-    private Bytes family;
-    private Bytes row;
+    public VisibilityMethods(Data data) {
+      super(data);
+    }
 
-    @Override
-    void setRow(Bytes r) {
-      this.row = r;
+    public Value vis(Bytes cv) {
+      data.vis = cv;
+      return new Value(data);
     }
 
-    @Override
-    void setFamily(Bytes f) {
-      this.family = f;
+    public Value vis(byte[] cv) {
+      data.vis = Bytes.wrap(cv);
+      return new Value(data);
     }
 
-    @Override
-    public VisBytesDecoder setQualifier(Bytes q) {
-      return new VisBytesDecoder(row, new Column(family, q));
+    public Value vis(ByteBuffer bb) {
+      data.vis = Bytes.wrap(bb);
+      return new Value(data);
     }
 
-    @Override
-    public Value setColumn(Column c) {
-      try {
-        return new Value(snapshot.get(row, c));
-      } catch (Exception e) {
-        // TODO
-        if (e instanceof RuntimeException)
-          throw (RuntimeException) e;
-        throw new RuntimeException(e);
-      }
+    public Value vis(String cv) {
+      data.vis = Bytes.wrap(cv);
+      return new Value(data);
     }
 
+    public Value vis(ColumnVisibility cv) {
+      data.vis = Bytes.wrap(cv.flatten());
+      return new Value(data);
+    }
   }
 
-  public class VisBytesDecoder extends Value {
-
-    private Bytes row;
-    private Column col;
+  public class Value {
+    private Bytes bytes;
     private boolean gotBytes = false;
+    protected Data data;
 
-    Bytes getBytes() {
+    public Bytes getBytes() {
       if (!gotBytes) {
         try {
-          super.bytes = snapshot.get(row, col);
+          bytes = snapshot.get(data.row, data.getCol());
           gotBytes = true;
         } catch (Exception e) {
           if (e instanceof RuntimeException)
@@ -92,31 +103,17 @@ public class TypedSnapshot implements Snapshot {
         }
       }
 
-      return super.getBytes();
-    }
-
-    VisBytesDecoder(Bytes row, Column col) {
-      super(null);
-      this.row = row;
-      this.col = col;
-    }
-
-    public Value vis(ColumnVisibility cv) {
-      col.setVisibility(cv);
-      gotBytes = false;
-      return new Value(getBytes());
-    }
-  }
-
-  public class Value {
-    Bytes bytes;
-
-    Bytes getBytes() {
       return bytes;
     }
 
     private Value(Bytes bytes) {
       this.bytes = bytes;
+      this.gotBytes = true;
+    }
+
+    private Value(Data data) {
+      this.data = data;
+      this.gotBytes = false;
     }
 
     public Integer toInteger() {
@@ -137,7 +134,7 @@ public class TypedSnapshot implements Snapshot {
       return encoder.decodeLong(getBytes());
     }
 
-    public long toLong(int defaultValue) {
+    public long toLong(long defaultValue) {
       if (getBytes() == null)
         return defaultValue;
       return encoder.decodeLong(getBytes());
@@ -167,6 +164,234 @@ public class TypedSnapshot implements Snapshot {
         return defaultValue;
       return getBytes().toArray();
     }
+
+    public ByteBuffer toByteBuffer() {
+      if (getBytes() == null)
+        return null;
+      if (getBytes().isBackedByArray()) {
+        return ByteBuffer.wrap(getBytes().getBackingArray(), getBytes().offset(), getBytes().length());
+      } else {
+        return ByteBuffer.wrap(getBytes().toArray());
+      }
+    }
+
+    public ByteBuffer toByteBuffer(ByteBuffer defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return toByteBuffer();
+    }
+
+    @Override
+    public int hashCode() {
+      if (getBytes() == null) {
+        return 0;
+      }
+
+      return getBytes().hashCode();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Value) {
+        Value ov = (Value) o;
+        if (getBytes() == null)
+          return ov.getBytes() == null;
+        else
+          return getBytes().equals(ov.getBytes());
+      }
+
+      return false;
+    }
+  }
+
+  public class ValueQualifierBuilder extends QualifierMethods<VisibilityMethods> {
+
+    ValueQualifierBuilder(Data data) {
+      tl.super(data);
+    }
+
+    @Override
+    VisibilityMethods create(Data data) {
+      return new VisibilityMethods(data);
+    }
+  }
+
+  public class ValueFamilyMethods extends FamilyMethods<ValueQualifierBuilder,Value> {
+
+    ValueFamilyMethods(Data data) {
+      tl.super(data);
+    }
+
+    @Override
+    ValueQualifierBuilder create1(Data data) {
+      return new ValueQualifierBuilder(data);
+    }
+
+    @Override
+    Value create2(Data data) {
+      return new Value(data);
+    }
+
+    public Map<Column,Value> columns(Set<Column> columns) {
+      try {
+        return wrap(snapshot.get(data.row, columns));
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    public Map<Column,Value> columns(Column... columns) {
+      try {
+        return wrap(snapshot.get(data.row, new HashSet<Column>(Arrays.asList(columns))));
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+
+  public class MapConverter {
+    private Collection<Bytes> rows;
+    private Set<Column> columns;
+
+    public MapConverter(Collection<Bytes> rows, Set<Column> columns) {
+      this.rows = rows;
+      this.columns = columns;
+    }
+
+    private Map<Bytes,Map<Column,Bytes>> getInput() {
+      try {
+        return snapshot.get(rows, columns);
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    private Map wrap2(Map m) {
+      return Collections.unmodifiableMap(DefaultedMap.decorate(m, new DefaultedMap(new Value((Bytes) null))));
+    }
+
+    @SuppressWarnings("unchecked")
+    public Map<String,Map<Column,Value>> toStringMap() {
+      Map<Bytes,Map<Column,Bytes>> in = getInput();
+      Map<String,Map<Column,Value>> out = new HashMap<>();
+
+      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
+        out.put(encoder.decodeString(rowEntry.getKey()), wrap(rowEntry.getValue()));
+
+      return wrap2(out);
+    }
+
+    @SuppressWarnings("unchecked")
+    public Map<Long,Map<Column,Value>> toLongMap() {
+      Map<Bytes,Map<Column,Bytes>> in = getInput();
+      Map<Long,Map<Column,Value>> out = new HashMap<>();
+
+      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
+        out.put(encoder.decodeLong(rowEntry.getKey()), wrap(rowEntry.getValue()));
+
+      return wrap2(out);
+    }
+
+    @SuppressWarnings("unchecked")
+    public Map<Integer,Map<Column,Value>> toIntegerMap() {
+      Map<Bytes,Map<Column,Bytes>> in = getInput();
+      Map<Integer,Map<Column,Value>> out = new HashMap<>();
+
+      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
+        out.put(encoder.decodeInteger(rowEntry.getKey()), wrap(rowEntry.getValue()));
+
+      return wrap2(out);
+    }
+
+    @SuppressWarnings("unchecked")
+    public Map<Bytes,Map<Column,Value>> toBytesMap() {
+      Map<Bytes,Map<Column,Bytes>> in = getInput();
+      Map<Bytes,Map<Column,Value>> out = new HashMap<>();
+
+      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
+        out.put(rowEntry.getKey(), wrap(rowEntry.getValue()));
+
+      return wrap2(out);
+    }
+  }
+
+  public class ColumnsMethods {
+    private Collection<Bytes> rows;
+
+    public ColumnsMethods(Collection<Bytes> rows) {
+      this.rows = rows;
+    }
+
+    public MapConverter columns(Set<Column> columns) {
+      return new MapConverter(rows, columns);
+    }
+
+    public MapConverter columns(Column... columns) {
+      return columns(new HashSet<Column>(Arrays.asList(columns)));
+    }
+  }
+
+  public class ValueRowMethods extends RowMethods<ValueFamilyMethods> {
+
+    ValueRowMethods() {
+      tl.super();
+    }
+
+    @Override
+    ValueFamilyMethods create(Data data) {
+      return new ValueFamilyMethods(data);
+    }
+
+    public ColumnsMethods rows(Collection<Bytes> rows) {
+      return new ColumnsMethods(rows);
+    }
+
+    public ColumnsMethods rowsString(Collection<String> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (String row : rows) {
+        conv.add(encoder.encode(row));
+      }
+
+      return rows(conv);
+    }
+
+    public ColumnsMethods rowsLong(Collection<Long> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (Long row : rows) {
+        conv.add(encoder.encode(row));
+      }
+
+      return rows(conv);
+    }
+
+    public ColumnsMethods rowsInteger(Collection<Integer> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (Integer row : rows) {
+        conv.add(encoder.encode(row));
+      }
+
+      return rows(conv);
+    }
+
+    public ColumnsMethods rowsBytes(Collection<byte[]> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (byte[] row : rows) {
+        conv.add(Bytes.wrap(row));
+      }
+
+      return rows(conv);
+    }
+
+    public ColumnsMethods rowsByteBuffers(Collection<ByteBuffer> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (ByteBuffer row : rows) {
+        conv.add(Bytes.wrap(row));
+      }
+
+      return rows(conv);
+    }
+
   }
 
   TypedSnapshot(Snapshot snapshot, Encoder encoder, TypeLayer tl) {
@@ -195,46 +420,20 @@ public class TypedSnapshot implements Snapshot {
     return snapshot.get(rows, columns);
   }
 
-  public RowAction<Value,VisBytesDecoder,KeyBuilder> get() {
-    return tl.new RowAction<Value,VisBytesDecoder,KeyBuilder>(new KeyBuilder());
-  }
-
-
-  @SuppressWarnings("unchecked")
-  public Map<Column,Value> getd(Bytes row, Set<Column> columns) throws Exception {
-    Map<Column,Bytes> map = snapshot.get(row, columns);
-    Map<Column,Value> ret = new HashMap<Column,Value>();
-
-    Set<Entry<Column,Bytes>> es = map.entrySet();
-    for (Entry<Column,Bytes> entry : es) {
-      ret.put(entry.getKey(), new Value(entry.getValue()));
-    }
-
-    return DefaultedMap.decorate(ret, new Value(null));
-  }
-
-  public Map<Column,Value> getd(String row, Set<Column> columns) throws Exception {
-    return getd(encoder.encode(row), columns);
+  public ValueRowMethods get() {
+    return new ValueRowMethods();
   }
 
-  @SuppressWarnings("unchecked")
-  public Map<String,Map<Column,Value>> getd(Collection<String> rows, Set<Column> columns) throws Exception {
-    ArrayList<Bytes> bsRows = new ArrayList<Bytes>(rows.size());
-    for (String row : rows) {
-      bsRows.add(encoder.encode(row));
-    }
-
-    Map<Bytes,Map<Column,Bytes>> in = snapshot.get(bsRows, columns);
-    Map<String,Map<Column,Value>> out = new HashMap<String,Map<Column,Value>>();
-
-    for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet()) {
-      Map<Column,Value> outCols = new HashMap<Column,Value>();
-      for (Entry<Column,Bytes> colEntry : rowEntry.getValue().entrySet()) {
-        outCols.put(colEntry.getKey(), new Value(colEntry.getValue()));
+  @SuppressWarnings({"unchecked"})
+  private Map<Column,Value> wrap(Map<Column,Bytes> map) {
+    Map<Column,Value> ret = Maps.transformValues(map, new Function<Bytes,Value>() {
+      @Override
+      public Value apply(Bytes input) {
+        return new Value(input);
       }
-      out.put(encoder.decodeString(rowEntry.getKey()), DefaultedMap.decorate(outCols, new Value(null)));
-    }
+    });
 
-    return DefaultedMap.decorate(out, new DefaultedMap(new Value(null)));
+    return Collections.unmodifiableMap(DefaultedMap.decorate(ret, new Value((Bytes) null)));
   }
+
 }
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java b/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java
index 691d17b2..259748ff 100644
--- a/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java
@@ -18,140 +18,198 @@ package io.fluo.api.types;
 import io.fluo.api.client.Transaction;
 import io.fluo.api.data.Bytes;
 import io.fluo.api.data.Column;
-import io.fluo.api.types.TypeLayer.RowAction;
-import io.fluo.api.types.TypeLayer.RowColumnBuilder;
+import io.fluo.api.types.TypeLayer.Data;
+import io.fluo.api.types.TypeLayer.FamilyMethods;
+import io.fluo.api.types.TypeLayer.QualifierMethods;
+import io.fluo.api.types.TypeLayer.RowMethods;
+
+import java.nio.ByteBuffer;
+
 import org.apache.accumulo.core.security.ColumnVisibility;
 
+import com.google.common.annotations.VisibleForTesting;
+
+/**
+ * See {@link TypeLayer} javadocs.
+ */
+
 public class TypedTransaction extends TypedSnapshot implements Transaction {
 
   private Transaction tx;
   private Encoder encoder;
   private TypeLayer tl;
 
-  private class MutateKeyBuilder extends RowColumnBuilder<Mutator,VisibilityMutator> {
-
-    private Bytes row;
-    private Bytes cf;
-
-    @Override
-    void setRow(Bytes r) {
-      this.row = r;
-    }
-
-    @Override
-    void setFamily(Bytes f) {
-      this.cf = f;
-    }
-
-    @Override
-    VisibilityMutator setQualifier(Bytes q) {
-      return new VisibilityMutator(row, new Column(cf, q));
-    }
-
-    @Override
-    Mutator setColumn(Column c) {
-      return new Mutator(row, c);
-    }
-
-  }
-
   public class Mutator {
 
-    private Bytes row;
-    private Column col;
     private boolean set = false;
+    protected Data data;
+
+    public Mutator(Data data) {
+      this.data = data;
+    }
 
     void checkNotSet() {
       if (set)
         throw new IllegalStateException("Already set value");
     }
 
-    Mutator(Bytes row, Column column) {
-      this.row = row;
-      this.col = column;
+    public void set(Bytes bytes) {
+      checkNotSet();
+      tx.set(data.row, data.getCol(), bytes);
+      set = true;
     }
 
     public void set(String s) {
-      checkNotSet();
-      tx.set(row, col, encoder.encode(s));
-      set = true;
+      set(encoder.encode(s));
     }
 
     public void set(int i) {
-      checkNotSet();
-      tx.set(row, col, encoder.encode(i));
-      set = true;
+      set(encoder.encode(i));
     }
 
     public void set(long l) {
-      checkNotSet();
-      tx.set(row, col, encoder.encode(l));
-      set = true;
+      set(encoder.encode(l));
+    }
+
+    public void set(byte[] ba) {
+      set(Bytes.wrap(ba));
+    }
+
+    public void set(ByteBuffer bb) {
+      set(Bytes.wrap(bb));
     }
 
+    /**
+     * Set an empty value
+     */
+    public void set() {
+      set(Bytes.EMPTY);
+    }
+
+    /**
+     * Reads the current value of the row/column, adds i, sets the sum. If the row/column does not have a current value, then it defaults to zero.
+     * 
+     * @param i
+     * @throws Exception
+     */
     public void increment(int i) throws Exception {
       checkNotSet();
-      Bytes val = tx.get(row, col);
+      Bytes val = tx.get(data.row, data.getCol());
       int v = 0;
       if (val != null)
         v = encoder.decodeInteger(val);
-      tx.set(row, col, encoder.encode(v + i));
+      tx.set(data.row, data.getCol(), encoder.encode(v + i));
     }
 
+    /**
+     * Reads the current value of the row/column, adds l, sets the sum. If the row/column does not have a current value, then it defaults to zero.
+     * 
+     * @param i
+     * @throws Exception
+     */
     public void increment(long l) throws Exception {
       checkNotSet();
-      Bytes val = tx.get(row, col);
+      Bytes val = tx.get(data.row, data.getCol());
       long v = 0;
       if (val != null)
         v = encoder.decodeLong(val);
-      tx.set(row, col, encoder.encode(v + l));
+      tx.set(data.row, data.getCol(), encoder.encode(v + l));
     }
 
-    public void set(byte[] ba) {
+    public void delete() {
       checkNotSet();
-      tx.set(row, col, Bytes.wrap(ba));
+      tx.delete(data.row, data.getCol());
       set = true;
     }
 
-    /**
-     * Set an empty value
-     */
-    public void set() {
+    public void weaklyNotify() {
       checkNotSet();
-      tx.set(row, col, Bytes.wrap(new byte[0]));
+      tx.setWeakNotification(data.row, data.getCol());
       set = true;
     }
 
-    public void delete() {
-      checkNotSet();
-      tx.delete(row, col);
-      set = true;
+  }
+
+  public class VisibilityMutator extends Mutator {
+
+    public VisibilityMutator(Data data) {
+      super(data);
     }
 
-    public void weaklyNotify() {
+    public Mutator vis(String cv) {
       checkNotSet();
-      tx.setWeakNotification(row, col);
-      set = true;
+      data.vis = Bytes.wrap(cv);
+      return new Mutator(data);
     }
 
-  }
+    public Mutator vis(Bytes cv) {
+      checkNotSet();
+      data.vis = cv;
+      return new Mutator(data);
+    }
 
-  public class VisibilityMutator extends Mutator {
+    public Mutator vis(byte[] cv) {
+      checkNotSet();
+      data.vis = Bytes.wrap(cv);
+      return new Mutator(data);
+    }
 
-    VisibilityMutator(Bytes row, Column column) {
-      super(row, column);
+    public Mutator vis(ByteBuffer cv) {
+      checkNotSet();
+      data.vis = Bytes.wrap(cv);
+      return new Mutator(data);
     }
 
     public Mutator vis(ColumnVisibility cv) {
       checkNotSet();
-      super.col.setVisibility(cv);
-      super.set = true;
-      return new Mutator(super.row, super.col);
+      data.vis = Bytes.wrap(cv.getExpression());
+      return new Mutator(data);
+    }
+  }
+
+  public class MutatorQualifierMethods extends QualifierMethods<VisibilityMutator> {
+
+    MutatorQualifierMethods(Data data) {
+      tl.super(data);
+    }
+
+    @Override
+    VisibilityMutator create(Data data) {
+      return new VisibilityMutator(data);
     }
   }
 
+  public class MutatorFamilyMethods extends FamilyMethods<MutatorQualifierMethods,Mutator> {
+
+    MutatorFamilyMethods(Data data) {
+      tl.super(data);
+    }
+
+    @Override
+    MutatorQualifierMethods create1(Data data) {
+      return new MutatorQualifierMethods(data);
+    }
+
+    @Override
+    Mutator create2(Data data) {
+      return new Mutator(data);
+    }
+  }
+
+  public class MutatorRowMethods extends RowMethods<MutatorFamilyMethods> {
+
+    MutatorRowMethods() {
+      tl.super();
+    }
+
+    @Override
+    MutatorFamilyMethods create(Data data) {
+      return new MutatorFamilyMethods(data);
+    }
+
+  }
 
-  // TODO make private.. test depend on it
+  @VisibleForTesting
   protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) {
     super(tx, encoder, tl);
     this.tx = tx;
@@ -159,8 +217,8 @@ public class TypedTransaction extends TypedSnapshot implements Transaction {
     this.tl = tl;
   }
 
-  public RowAction<Mutator,VisibilityMutator,MutateKeyBuilder> mutate() {
-    return tl.new RowAction<Mutator,VisibilityMutator,MutateKeyBuilder>(new MutateKeyBuilder());
+  public MutatorRowMethods mutate() {
+    return new MutatorRowMethods();
   }
 
   @Override
diff --git a/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java b/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java
new file mode 100644
index 00000000..8bab9d1f
--- /dev/null
+++ b/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright 2014 Fluo authors (see AUTHORS)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.types;
+
+import io.fluo.api.client.Transaction;
+import io.fluo.api.config.ScannerConfiguration;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.iterator.RowIterator;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.accumulo.core.security.ColumnVisibility;
+
+/**
+ * A very simple implementation of {@link Transaction} used for testing. All reads are serviced from {@link #getData}. Updates are stored in {@link #setData},
+ * {@link #deletes}, or {@link #weakNotifications} depending on the update type.
+ */
+public class MockTransaction implements Transaction {
+
+  Map<Bytes,Map<Column,Bytes>> getData = new HashMap<>();
+  Map<Bytes,Map<Column,Bytes>> setData = new HashMap<>();
+  Map<Bytes,Set<Column>> deletes = new HashMap<>();
+  Map<Bytes,Set<Column>> weakNotifications = new HashMap<>();
+
+  /**
+   * Initializes {@link #getData} using {@link #toRCVM(String...)}
+   */
+  MockTransaction(String... entries) {
+    getData = toRCVM(entries);
+  }
+
+  @Override
+  public Bytes get(Bytes row, Column column) throws Exception {
+    Map<Column,Bytes> cols = getData.get(row);
+    if (cols != null)
+      return cols.get(column);
+
+    return null;
+  }
+
+  @Override
+  public Map<Column,Bytes> get(Bytes row, Set<Column> columns) throws Exception {
+    Map<Column,Bytes> ret = new HashMap<Column,Bytes>();
+    Map<Column,Bytes> cols = getData.get(row);
+    if (cols != null) {
+      for (Column column : columns) {
+        Bytes val = cols.get(column);
+        if (val != null)
+          ret.put(column, val);
+      }
+    }
+    return ret;
+  }
+
+  @Override
+  public Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) throws Exception {
+
+    Map<Bytes,Map<Column,Bytes>> ret = new HashMap<>();
+
+    for (Bytes row : rows) {
+      Map<Column,Bytes> colMap = get(row, columns);
+      if (colMap != null && colMap.size() > 0) {
+        ret.put(row, colMap);
+      }
+    }
+
+    return ret;
+  }
+
+  @Override
+  public RowIterator get(ScannerConfiguration config) throws Exception {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setWeakNotification(Bytes row, Column col) {
+    Set<Column> cols = weakNotifications.get(row);
+    if (cols == null) {
+      cols = new HashSet<>();
+      weakNotifications.put(row, cols);
+    }
+
+    cols.add(col);
+  }
+
+  @Override
+  public void set(Bytes row, Column col, Bytes value) {
+    Map<Column,Bytes> cols = setData.get(row);
+    if (cols == null) {
+      cols = new HashMap<>();
+      setData.put(row, cols);
+    }
+
+    cols.put(col, value);
+
+  }
+
+  @Override
+  public void delete(Bytes row, Column col) {
+    Set<Column> cols = deletes.get(row);
+    if (cols == null) {
+      cols = new HashSet<>();
+      deletes.put(row, cols);
+    }
+
+    cols.add(col);
+  }
+
+  /**
+   * toRCVM stands for "To Row Column Value Map". This is a convenience function that takes strings of the format
+   * {@code <row>,<col fam>:<col qual>[:col vis],<value>} and generates a row, column, value map.
+   */
+  public static Map<Bytes,Map<Column,Bytes>> toRCVM(String... entries) {
+    Map<Bytes,Map<Column,Bytes>> ret = new HashMap<>();
+
+    for (String entry : entries) {
+      String[] rcv = entry.split(",");
+      if (rcv.length != 3 && !(rcv.length == 2 && entry.trim().endsWith(",")))
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
+
+      Bytes row = Bytes.wrap(rcv[0]);
+      String[] colFields = rcv[1].split(":");
+      if (colFields.length != 2 && colFields.length != 3)
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
+
+      Column col = new Column(colFields[0], colFields[1]);
+      if (colFields.length == 3)
+        col.setVisibility(new ColumnVisibility(colFields[2]));
+
+      Bytes val;
+      if (rcv.length == 2)
+        val = Bytes.EMPTY;
+      else
+        val = Bytes.wrap(rcv[2]);
+
+      Map<Column,Bytes> cols = ret.get(row);
+      if (cols == null) {
+        cols = new HashMap<>();
+        ret.put(row, cols);
+      }
+
+      cols.put(col, val);
+    }
+    return ret;
+  }
+
+  /**
+   * toRCM stands for "To Row Column Map". This is a convenience function that takes strings of the format {@code <row>,<col fam>:<col qual>[:col vis]} and
+   * generates a row, column map.
+   */
+  public static Map<Bytes,Set<Column>> toRCM(String... entries) {
+    Map<Bytes,Set<Column>> ret = new HashMap<>();
+
+    for (String entry : entries) {
+      String[] rcv = entry.split(",");
+      if (rcv.length != 2)
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis] but saw : " + entry);
+
+      Bytes row = Bytes.wrap(rcv[0]);
+      String[] colFields = rcv[1].split(":");
+      if (colFields.length != 2 && colFields.length != 3)
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis] but saw : " + entry);
+
+      Column col = new Column(colFields[0], colFields[1]);
+      if (colFields.length == 3)
+        col.setVisibility(new ColumnVisibility(colFields[2]));
+
+      Set<Column> cols = ret.get(row);
+      if (cols == null) {
+        cols = new HashSet<>();
+        ret.put(row, cols);
+      }
+
+      cols.add(col);
+    }
+    return ret;
+  }
+}
\ No newline at end of file
diff --git a/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java b/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
new file mode 100644
index 00000000..d87d0ab4
--- /dev/null
+++ b/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
@@ -0,0 +1,389 @@
+/*
+ * Copyright 2014 Fluo authors (see AUTHORS)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.types;
+
+import io.fluo.api.client.Snapshot;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.types.TypedSnapshot.Value;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.Map;
+
+import org.apache.accumulo.core.security.ColumnVisibility;
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.google.common.collect.ImmutableSet;
+
+public class TypeLayerTest {
+
+  @Test
+  public void testColumns() throws Exception {
+    TypeLayer tl = new TypeLayer(new StringEncoder());
+
+    MockTransaction tt = new MockTransaction("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
+        "13,9:19,20", "13,9:20,20");
+
+    TypedTransaction ttx = tl.wrap(tt);
+
+    Map<Column,Value> results = ttx.get().row("r2").columns(ImmutableSet.of(new Column("cf2", "6"), new Column("cf2", "7")));
+
+    Assert.assertNull(results.get(new Column("cf2", "6")).toInteger());
+    Assert.assertEquals(0, results.get(new Column("cf2", "6")).toInteger(0));
+    Assert.assertEquals(12, (int) results.get(new Column("cf2", "7")).toInteger());
+    Assert.assertEquals(12, results.get(new Column("cf2", "7")).toInteger(0));
+
+    Assert.assertEquals(1, results.size());
+
+    results = ttx.get().row("r2").columns(ImmutableSet.of(new Column("cf2", "6"), new Column("cf2", "7"), new Column("cf2", "8")));
+
+    Assert.assertNull(results.get(new Column("cf2", "6")).toInteger());
+    Assert.assertEquals(0, results.get(new Column("cf2", "6")).toInteger(0));
+    Assert.assertEquals(12, (int) results.get(new Column("cf2", "7")).toInteger());
+    Assert.assertEquals(12, results.get(new Column("cf2", "7")).toInteger(0));
+    Assert.assertEquals(13, (int) results.get(new Column("cf2", "8")).toInteger());
+    Assert.assertEquals(13, results.get(new Column("cf2", "8")).toInteger(0));
+
+    Assert.assertEquals(2, results.size());
+
+    // test var args
+    Map<Column,Value> results2 = ttx.get().row("r2").columns(new Column("cf2", "6"), new Column("cf2", "7"), new Column("cf2", "8"));
+    Assert.assertEquals(results, results2);
+  }
+
+  @Test
+  public void testVis() throws Exception {
+    TypeLayer tl = new TypeLayer(new StringEncoder());
+
+    MockTransaction tt = new MockTransaction("r1,cf1:cq1:A,v1", "r1,cf1:cq2:A&B,v2");
+
+    TypedTransaction ttx = tl.wrap(tt);
+
+    Assert.assertNull(ttx.get().row("r1").fam("cf1").qual("cq1").toString());
+    Assert.assertEquals("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A").toString());
+    Assert.assertEquals("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A".getBytes()).toString());
+    Assert.assertEquals("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A")).toString());
+    Assert.assertEquals("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A".getBytes())).toString());
+    Assert.assertEquals("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(new ColumnVisibility("A")).toString());
+
+    Assert.assertNull("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A&B").toString());
+    Assert.assertNull("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A&B".getBytes()).toString());
+    Assert.assertNull("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A&B")).toString());
+    Assert.assertNull("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A&B".getBytes())).toString());
+    Assert.assertNull("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(new ColumnVisibility("A&B")).toString());
+
+    Assert.assertEquals("v3", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A&B").toString("v3"));
+    Assert.assertEquals("v3", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A&B".getBytes()).toString("v3"));
+    Assert.assertEquals("v3", ttx.get().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A&B")).toString("v3"));
+    Assert.assertEquals("v3", ttx.get().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A&B".getBytes())).toString("v3"));
+    Assert.assertEquals("v3", ttx.get().row("r1").fam("cf1").qual("cq1").vis(new ColumnVisibility("A&B")).toString("v3"));
+
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis("A&B").set(3);
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis("A&C".getBytes()).set(4);
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A&D")).set(5);
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(new ColumnVisibility("A&E")).set(6);
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A&F".getBytes())).set(7);
+
+    Assert.assertEquals(MockTransaction.toRCVM("r1,cf1:cq1:A&B,3", "r1,cf1:cq1:A&C,4", "r1,cf1:cq1:A&D,5", "r1,cf1:cq1:A&E,6", "r1,cf1:cq1:A&F,7"), tt.setData);
+    tt.setData.clear();
+
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis("A&B").delete();
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis("A&C".getBytes()).delete();
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A&D")).delete();
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(new ColumnVisibility("A&E")).delete();
+    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A&F".getBytes())).delete();
+
+    Assert.assertEquals(MockTransaction.toRCM("r1,cf1:cq1:A&B", "r1,cf1:cq1:A&C", "r1,cf1:cq1:A&D", "r1,cf1:cq1:A&E", "r1,cf1:cq1:A&F"), tt.deletes);
+    tt.deletes.clear();
+    Assert.assertEquals(0, tt.setData.size());
+    Assert.assertEquals(0, tt.weakNotifications.size());
+
+  }
+
+  @Test
+  public void testBuildColumn() {
+    TypeLayer tl = new TypeLayer(new StringEncoder());
+
+    Assert.assertEquals(new Column("f0", "q0"), tl.bc().fam("f0".getBytes()).qual("q0".getBytes()).vis());
+    Assert.assertEquals(new Column("f0", "q0"), tl.bc().fam("f0").qual("q0").vis());
+    Assert.assertEquals(new Column("5", "7"), tl.bc().fam(5).qual(7).vis());
+    Assert.assertEquals(new Column("5", "7"), tl.bc().fam(5l).qual(7l).vis());
+    Assert.assertEquals(new Column("5", "7"), tl.bc().fam(Bytes.wrap("5")).qual(Bytes.wrap("7")).vis());
+    Assert.assertEquals(new Column("5", "7"), tl.bc().fam(ByteBuffer.wrap("5".getBytes())).qual(ByteBuffer.wrap("7".getBytes())).vis());
+
+    Assert.assertEquals(new Column("f0", "q0").setVisibility(new ColumnVisibility("A&B")), tl.bc().fam("f0".getBytes()).qual("q0".getBytes()).vis("A&B"));
+    Assert.assertEquals(new Column("f0", "q0").setVisibility(new ColumnVisibility("A&C")), tl.bc().fam("f0").qual("q0").vis("A&C".getBytes()));
+    Assert.assertEquals(new Column("5", "7").setVisibility(new ColumnVisibility("A&D")), tl.bc().fam(5).qual(7).vis(Bytes.wrap("A&D")));
+    Assert.assertEquals(new Column("5", "7").setVisibility(new ColumnVisibility("A&D")), tl.bc().fam(5).qual(7).vis(ByteBuffer.wrap("A&D".getBytes())));
+
+  }
+
+  @Test
+  public void testRead() throws Exception {
+    TypeLayer tl = new TypeLayer(new StringEncoder());
+
+    MockTransaction tt = new MockTransaction("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
+        "13,9:19,20", "13,9:20,20");
+
+    TypedSnapshot tts = tl.wrap((Snapshot) tt);
+
+    Assert.assertEquals("v1", tts.get().row("r1").fam("cf1").qual("cq1").toString());
+    Assert.assertEquals("v1", tts.get().row("r1").fam("cf1").qual("cq1").toString("b"));
+    Assert.assertEquals("13", tts.get().row("r2").fam("cf2").qual("8").toString());
+    Assert.assertEquals("13", tts.get().row("r2").fam("cf2").qual("8").toString("b"));
+
+    // try converting to different types
+    Assert.assertEquals("13", tts.get().row("r2").fam("cf2").qual(8).toString());
+    Assert.assertEquals("13", tts.get().row("r2").fam("cf2").qual(8).toString("b"));
+    Assert.assertEquals((Integer) 13, tts.get().row("r2").fam("cf2").qual(8).toInteger());
+    Assert.assertEquals(13, tts.get().row("r2").fam("cf2").qual(8).toInteger(14));
+    Assert.assertEquals((Long) 13l, (Long) tts.get().row("r2").fam("cf2").qual(8).toLong());
+    Assert.assertEquals(13l, tts.get().row("r2").fam("cf2").qual(8).toLong(14l));
+    Assert.assertEquals("13", new String(tts.get().row("r2").fam("cf2").qual(8).toBytes()));
+    Assert.assertEquals("13", new String(tts.get().row("r2").fam("cf2").qual(8).toBytes("14".getBytes())));
+    Assert.assertEquals("13", new String(tts.get().row("r2").col(new Column("cf2", "8")).toBytes()));
+    Assert.assertEquals("13", new String(tts.get().row("r2").col(new Column("cf2", "8")).toBytes("14".getBytes())));
+    Assert.assertEquals("13", Bytes.wrap(tts.get().row("r2").col(new Column("cf2", "8")).toByteBuffer()).toString());
+    Assert.assertEquals("13", Bytes.wrap(tts.get().row("r2").col(new Column("cf2", "8")).toByteBuffer(ByteBuffer.wrap("14".getBytes()))).toString());
+
+    // test non-existant
+    Assert.assertNull(tts.get().row("r2").fam("cf3").qual(8).toInteger());
+    Assert.assertEquals(14, tts.get().row("r2").fam("cf3").qual(8).toInteger(14));
+    Assert.assertNull(tts.get().row("r2").fam("cf3").qual(8).toLong());
+    Assert.assertEquals(14l, tts.get().row("r2").fam("cf3").qual(8).toLong(14l));
+    Assert.assertNull(tts.get().row("r2").fam("cf3").qual(8).toString());
+    Assert.assertEquals("14", tts.get().row("r2").fam("cf3").qual(8).toString("14"));
+    Assert.assertNull(tts.get().row("r2").fam("cf3").qual(8).toBytes());
+    Assert.assertEquals("14", new String(tts.get().row("r2").fam("cf3").qual(8).toBytes("14".getBytes())));
+    Assert.assertNull(tts.get().row("r2").col(new Column("cf3", "8")).toBytes());
+    Assert.assertEquals("14", new String(tts.get().row("r2").col(new Column("cf3", "8")).toBytes("14".getBytes())));
+    Assert.assertNull(tts.get().row("r2").col(new Column("cf3", "8")).toByteBuffer());
+    Assert.assertEquals("14", Bytes.wrap(tts.get().row("r2").col(new Column("cf3", "8")).toByteBuffer(ByteBuffer.wrap("14".getBytes()))).toString());
+
+    // try different types for row
+    Assert.assertEquals("20", tts.get().row(13).fam("9").qual("17").toString());
+    Assert.assertEquals("20", tts.get().row(13l).fam("9").qual("17").toString());
+    Assert.assertEquals("20", tts.get().row("13").fam("9").qual("17").toString());
+    Assert.assertEquals("20", tts.get().row("13".getBytes()).fam("9").qual("17").toString());
+    Assert.assertEquals("20", tts.get().row(ByteBuffer.wrap("13".getBytes())).fam("9").qual("17").toString());
+
+    // try different types for cf
+    Assert.assertEquals("20", tts.get().row("13").fam(9).qual("17").toString());
+    Assert.assertEquals("20", tts.get().row("13").fam(9l).qual("17").toString());
+    Assert.assertEquals("20", tts.get().row("13").fam("9").qual("17").toString());
+    Assert.assertEquals("20", tts.get().row("13").fam("9".getBytes()).qual("17").toString());
+    Assert.assertEquals("20", tts.get().row("13").fam(ByteBuffer.wrap("9".getBytes())).qual("17").toString());
+
+    // try different types for cq
+    Assert.assertEquals("20", tts.get().row("13").fam("9").qual("17").toString());
+    Assert.assertEquals("20", tts.get().row("13").fam("9").qual(17l).toString());
+    Assert.assertEquals("20", tts.get().row("13").fam("9").qual(17).toString());
+    Assert.assertEquals("20", tts.get().row("13").fam("9").qual("17".getBytes()).toString());
+    Assert.assertEquals("20", tts.get().row("13").fam("9").qual(ByteBuffer.wrap("17".getBytes())).toString());
+  }
+
+  @Test
+  public void testWrite() throws Exception {
+
+    TypeLayer tl = new TypeLayer(new StringEncoder());
+
+    MockTransaction tt = new MockTransaction("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
+        "13,9:19,20", "13,9:20,20");
+
+    TypedTransaction ttx = tl.wrap(tt);
+
+    // test increments data
+    ttx.mutate().row("13").fam("9").qual("17").increment(1);
+    ttx.mutate().row("13").fam("9").qual(18).increment(2);
+    ttx.mutate().row("13").fam("9").qual(19l).increment(3);
+    ttx.mutate().row("13").fam("9").qual("20".getBytes()).increment(4);
+    ttx.mutate().row("13").fam("9").qual(Bytes.wrap("21")).increment(5); // increment non existant
+    ttx.mutate().row("13").col(new Column("9", "22")).increment(6); // increment non existant
+    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("23".getBytes())).increment(7); // increment non existant
+
+    Assert.assertEquals(MockTransaction.toRCVM("13,9:17,21", "13,9:18,22", "13,9:19,23", "13,9:20,24", "13,9:21,5", "13,9:22,6", "13,9:23,7"), tt.setData);
+    tt.setData.clear();
+
+    // test increments long
+    ttx.mutate().row("13").fam("9").qual("17").increment(1l);
+    ttx.mutate().row("13").fam("9").qual(18).increment(2l);
+    ttx.mutate().row("13").fam("9").qual(19l).increment(3l);
+    ttx.mutate().row("13").fam("9").qual("20".getBytes()).increment(4l);
+    ttx.mutate().row("13").fam("9").qual(Bytes.wrap("21")).increment(5l); // increment non existant
+    ttx.mutate().row("13").col(new Column("9", "22")).increment(6l); // increment non existant
+    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("23".getBytes())).increment(7l); // increment non existant
+
+    Assert.assertEquals(MockTransaction.toRCVM("13,9:17,21", "13,9:18,22", "13,9:19,23", "13,9:20,24", "13,9:21,5", "13,9:22,6", "13,9:23,7"), tt.setData);
+    tt.setData.clear();
+
+    // test setting data
+    ttx.mutate().row("13").fam("9").qual("16").set();
+    ttx.mutate().row("13").fam("9").qual("17").set(3);
+    ttx.mutate().row("13").fam("9").qual(18).set(4l);
+    ttx.mutate().row("13").fam("9").qual(19l).set("5");
+    ttx.mutate().row("13").fam("9").qual("20".getBytes()).set("6".getBytes());
+    ttx.mutate().row("13").col(new Column("9", "21")).set("7".getBytes());
+    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("22".getBytes())).set(ByteBuffer.wrap("8".getBytes()));
+
+    Assert.assertEquals(MockTransaction.toRCVM("13,9:16,", "13,9:17,3", "13,9:18,4", "13,9:19,5", "13,9:20,6", "13,9:21,7", "13,9:22,8"), tt.setData);
+    tt.setData.clear();
+
+    // test deleting data
+    ttx.mutate().row("13").fam("9").qual("17").delete();
+    ttx.mutate().row("13").fam("9").qual(18).delete();
+    ttx.mutate().row("13").fam("9").qual(19l).delete();
+    ttx.mutate().row("13").fam("9").qual("20".getBytes()).delete();
+    ttx.mutate().row("13").col(new Column("9", "21")).delete();
+    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("22".getBytes())).delete();
+
+    Assert.assertEquals(MockTransaction.toRCM("13,9:17", "13,9:18", "13,9:19", "13,9:20", "13,9:21", "13,9:22"), tt.deletes);
+    tt.deletes.clear();
+    Assert.assertEquals(0, tt.setData.size());
+    Assert.assertEquals(0, tt.weakNotifications.size());
+
+    // test weak notifications
+    ttx.mutate().row("13").fam("9").qual("17").weaklyNotify();
+    ttx.mutate().row("13").fam("9").qual(18).weaklyNotify();
+    ttx.mutate().row("13").fam("9").qual(19l).weaklyNotify();
+    ttx.mutate().row("13").fam("9").qual("20".getBytes()).weaklyNotify();
+    ttx.mutate().row("13").col(new Column("9", "21")).weaklyNotify();
+    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("22".getBytes())).weaklyNotify();
+
+    Assert.assertEquals(MockTransaction.toRCM("13,9:17", "13,9:18", "13,9:19", "13,9:20", "13,9:21", "13,9:22"), tt.weakNotifications);
+    tt.weakNotifications.clear();
+    Assert.assertEquals(0, tt.setData.size());
+    Assert.assertEquals(0, tt.deletes.size());
+  }
+
+  @Test
+  public void testMultiRow() throws Exception {
+    TypeLayer tl = new TypeLayer(new StringEncoder());
+
+    MockTransaction tt = new MockTransaction("11,cf1:cq1,1", "11,cf1:cq2,2", "12,cf1:cq1,3", "12,cf1:cq2,4", "13,cf1:cq1,5", "13,cf1:cq2,6");
+
+    TypedTransaction ttx = tl.wrap(tt);
+
+    Bytes br1 = Bytes.wrap("11");
+    Bytes br2 = Bytes.wrap("12");
+    Bytes br3 = Bytes.wrap("13");
+
+    Column c1 = new Column("cf1", "cq1");
+    Column c2 = new Column("cf1", "cq2");
+
+    Map<Bytes,Map<Column,Value>> map1 = ttx.get().rows(Arrays.asList(br1, br2)).columns(c1).toBytesMap();
+
+    Assert.assertEquals("1", map1.get(br1).get(c1).toString());
+    Assert.assertEquals("1", map1.get(br1).get(c1).toString("5"));
+    Assert.assertEquals((Long) (1l), map1.get(br1).get(c1).toLong());
+    Assert.assertEquals(1l, map1.get(br1).get(c1).toLong(5));
+    Assert.assertEquals((Integer) (1), map1.get(br1).get(c1).toInteger());
+    Assert.assertEquals(1, map1.get(br1).get(c1).toInteger(5));
+
+    Assert.assertEquals("5", map1.get(br3).get(c1).toString("5"));
+    Assert.assertNull(map1.get(br3).get(c1).toString());
+    Assert.assertEquals(5l, map1.get(br3).get(c1).toLong(5l));
+    Assert.assertNull(map1.get(br3).get(c1).toLong());
+    Assert.assertEquals(5, map1.get(br1).get(c2).toInteger(5));
+    Assert.assertNull(map1.get(br1).get(c2).toInteger());
+
+    Assert.assertEquals(2, map1.size());
+    Assert.assertEquals(1, map1.get(br1).size());
+    Assert.assertEquals(1, map1.get(br2).size());
+    Assert.assertEquals("3", map1.get(br2).get(c1).toString());
+
+    Map<String,Map<Column,Value>> map2 = ttx.get().rowsString(Arrays.asList("11", "13")).columns(c1).toStringMap();
+
+    Assert.assertEquals(2, map2.size());
+    Assert.assertEquals(1, map2.get("11").size());
+    Assert.assertEquals(1, map2.get("13").size());
+    Assert.assertEquals((Long) (1l), map2.get("11").get(c1).toLong());
+    Assert.assertEquals(5l, map2.get("13").get(c1).toLong(6));
+
+    Map<Long,Map<Column,Value>> map3 = ttx.get().rowsLong(Arrays.asList(11l, 13l)).columns(c1).toLongMap();
+
+    Assert.assertEquals(2, map3.size());
+    Assert.assertEquals(1, map3.get(11l).size());
+    Assert.assertEquals(1, map3.get(13l).size());
+    Assert.assertEquals((Long) (1l), map3.get(11l).get(c1).toLong());
+    Assert.assertEquals(5l, map3.get(13l).get(c1).toLong(6));
+
+    Map<Integer,Map<Column,Value>> map4 = ttx.get().rowsInteger(Arrays.asList(11, 13)).columns(c1).toIntegerMap();
+
+    Assert.assertEquals(2, map4.size());
+    Assert.assertEquals(1, map4.get(11).size());
+    Assert.assertEquals(1, map4.get(13).size());
+    Assert.assertEquals((Long) (1l), map4.get(11).get(c1).toLong());
+    Assert.assertEquals(5l, map4.get(13).get(c1).toLong(6));
+
+    Map<Integer,Map<Column,Value>> map5 = ttx.get().rowsBytes(Arrays.asList("11".getBytes(), "13".getBytes())).columns(c1).toIntegerMap();
+
+    Assert.assertEquals(2, map5.size());
+    Assert.assertEquals(1, map5.get(11).size());
+    Assert.assertEquals(1, map5.get(13).size());
+    Assert.assertEquals((Long) (1l), map5.get(11).get(c1).toLong());
+    Assert.assertEquals(5l, map5.get(13).get(c1).toLong(6));
+
+    Map<Integer,Map<Column,Value>> map6 = ttx.get().rowsByteBuffers(Arrays.asList(ByteBuffer.wrap("11".getBytes()), ByteBuffer.wrap("13".getBytes())))
+        .columns(c1).toIntegerMap();
+
+    Assert.assertEquals(2, map6.size());
+    Assert.assertEquals(1, map6.get(11).size());
+    Assert.assertEquals(1, map6.get(13).size());
+    Assert.assertEquals((Long) (1l), map6.get(11).get(c1).toLong());
+    Assert.assertEquals(5l, map6.get(13).get(c1).toLong(6));
+
+  }
+
+  @Test
+  public void testBasic() throws Exception {
+    TypeLayer tl = new TypeLayer(new StringEncoder());
+
+    MockTransaction tt = new MockTransaction("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
+        "13,9:19,20", "13,9:20,20");
+
+    TypedTransaction ttx = tl.wrap(tt);
+
+    Assert.assertEquals(Bytes.wrap("12"), ttx.get(Bytes.wrap("r2"), new Column("cf2", "7")));
+    Assert.assertNull(ttx.get(Bytes.wrap("r2"), new Column("cf2", "9")));
+
+    Map<Column,Bytes> map = ttx.get(Bytes.wrap("r2"), ImmutableSet.of(new Column("cf2", "7"), new Column("cf2", "8")));
+    Assert.assertEquals(2, map.size());
+    Assert.assertEquals("12", map.get(new Column("cf2", "7")).toString());
+    Assert.assertEquals("13", map.get(new Column("cf2", "8")).toString());
+
+    map = ttx.get(Bytes.wrap("r6"), ImmutableSet.of(new Column("cf2", "7"), new Column("cf2", "8")));
+    Assert.assertEquals(0, map.size());
+
+    ttx.set(Bytes.wrap("r6"), new Column("cf2", "7"), Bytes.wrap("3"));
+    Assert.assertEquals(MockTransaction.toRCVM("r6,cf2:7,3"), tt.setData);
+    tt.setData.clear();
+
+    Map<Bytes,Map<Column,Bytes>> map2 = ttx.get(ImmutableSet.of(Bytes.wrap("r1"), Bytes.wrap("r2")),
+        ImmutableSet.of(new Column("cf1", "cq1"), new Column("cf2", "8")));
+    Assert.assertEquals(MockTransaction.toRCVM("r1,cf1:cq1,v1", "r2,cf2:8,13"), map2);
+
+    ttx.delete(Bytes.wrap("r6"), new Column("cf2", "7"));
+    Assert.assertEquals(MockTransaction.toRCM("r6,cf2:7"), tt.deletes);
+    tt.deletes.clear();
+
+    ttx.setWeakNotification(Bytes.wrap("r6"), new Column("cf2", "8"));
+    Assert.assertEquals(MockTransaction.toRCM("r6,cf2:8"), tt.weakNotifications);
+    tt.weakNotifications.clear();
+
+  }
+}
