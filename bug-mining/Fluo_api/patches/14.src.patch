diff --git a/modules/api/src/main/java/io/fluo/api/client/Snapshot.java b/modules/api/src/main/java/io/fluo/api/client/Snapshot.java
index 5974d37f..18a2172f 100644
--- a/modules/api/src/main/java/io/fluo/api/client/Snapshot.java
+++ b/modules/api/src/main/java/io/fluo/api/client/Snapshot.java
@@ -15,25 +15,14 @@
  */
 package io.fluo.api.client;
 
-import java.util.Collection;
-import java.util.Map;
-import java.util.Set;
-
-import io.fluo.api.config.ScannerConfiguration;
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-import io.fluo.api.iterator.RowIterator;
-
 /**
- * Implementations of this interface should provide snapshot isolation across rows when reading from a table.
+ * An AutoCloseable version of SnapshotBase. 
+ * See {@link io.fluo.api.client.SnapshotBase} for available methods.
  */
-public interface Snapshot {
-
-  public abstract Bytes get(Bytes row, Column column) throws Exception;
-
-  public abstract Map<Column,Bytes> get(Bytes row, Set<Column> columns) throws Exception;
-
-  public abstract Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) throws Exception;
-
-  public abstract RowIterator get(ScannerConfiguration config) throws Exception;
+public interface Snapshot extends SnapshotBase, AutoCloseable {
+  
+  @Override
+  public void close();
+  
+  // See SnapshotBase for other methods
 }
diff --git a/modules/api/src/main/java/io/fluo/api/client/SnapshotBase.java b/modules/api/src/main/java/io/fluo/api/client/SnapshotBase.java
new file mode 100644
index 00000000..ffb75a87
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/client/SnapshotBase.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2014 Fluo authors (see AUTHORS)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.client;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
+import io.fluo.api.config.ScannerConfiguration;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.iterator.RowIterator;
+
+/**
+ * Allows users to read from a Fluo table at a certain point in time
+ */
+public interface SnapshotBase {
+  
+  public Bytes get(Bytes row, Column column) throws Exception;
+
+  public Map<Column,Bytes> get(Bytes row, Set<Column> columns) throws Exception;
+
+  public Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) throws Exception;
+
+  public RowIterator get(ScannerConfiguration config) throws Exception;
+
+}
diff --git a/modules/api/src/main/java/io/fluo/api/client/Transaction.java b/modules/api/src/main/java/io/fluo/api/client/Transaction.java
index db517fb0..1ed71522 100644
--- a/modules/api/src/main/java/io/fluo/api/client/Transaction.java
+++ b/modules/api/src/main/java/io/fluo/api/client/Transaction.java
@@ -19,13 +19,14 @@ import io.fluo.api.data.Bytes;
 import io.fluo.api.data.Column;
 
 /**
- * Transaction interface
+ * Enables users to read and write to a Fluo table at certain point in time.
+ * See {@link io.fluo.api.client.SnapshotBase} for available read methods.
  */
-public interface Transaction extends Snapshot {
+public interface Transaction extends SnapshotBase {
   
-  public abstract void setWeakNotification(Bytes row, Column col);
+  public void setWeakNotification(Bytes row, Column col);
 
-  public abstract void set(Bytes row, Column col, Bytes value);
+  public void set(Bytes row, Column col, Bytes value);
   
-  public abstract void delete(Bytes row, Column col);
+  public void delete(Bytes row, Column col);
 }
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java
index 7c725200..a27035f1 100644
--- a/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java
@@ -16,424 +16,20 @@
 package io.fluo.api.types;
 
 import io.fluo.api.client.Snapshot;
-import io.fluo.api.config.ScannerConfiguration;
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-import io.fluo.api.iterator.RowIterator;
-import io.fluo.api.types.TypeLayer.Data;
-import io.fluo.api.types.TypeLayer.FamilyMethods;
-import io.fluo.api.types.TypeLayer.QualifierMethods;
-import io.fluo.api.types.TypeLayer.RowMethods;
-
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-
-import org.apache.accumulo.core.security.ColumnVisibility;
-import org.apache.commons.collections.map.DefaultedMap;
-
-import com.google.common.base.Function;
-import com.google.common.collect.Maps;
-
-//TODO need to refactor column to use Encoder
 
 /**
- * See {@link TypeLayer} javadocs.
+ * An AutoCloseable version of TypedSnapshotBase
  */
+public class TypedSnapshot extends TypedSnapshotBase implements AutoCloseable {
 
-public class TypedSnapshot implements Snapshot {
-
-  private Snapshot snapshot;
-  private Encoder encoder;
-  private TypeLayer tl;
-
-  public class VisibilityMethods extends Value {
-
-    public VisibilityMethods(Data data) {
-      super(data);
-    }
-
-    public Value vis(Bytes cv) {
-      data.vis = cv;
-      return new Value(data);
-    }
-
-    public Value vis(byte[] cv) {
-      data.vis = Bytes.wrap(cv);
-      return new Value(data);
-    }
-
-    public Value vis(ByteBuffer bb) {
-      data.vis = Bytes.wrap(bb);
-      return new Value(data);
-    }
-
-    public Value vis(String cv) {
-      data.vis = Bytes.wrap(cv);
-      return new Value(data);
-    }
-
-    public Value vis(ColumnVisibility cv) {
-      data.vis = Bytes.wrap(cv.flatten());
-      return new Value(data);
-    }
-  }
-
-  public class Value {
-    private Bytes bytes;
-    private boolean gotBytes = false;
-    protected Data data;
-
-    public Bytes getBytes() {
-      if (!gotBytes) {
-        try {
-          bytes = snapshot.get(data.row, data.getCol());
-          gotBytes = true;
-        } catch (Exception e) {
-          if (e instanceof RuntimeException)
-            throw (RuntimeException) e;
-          throw new RuntimeException(e);
-        }
-      }
-
-      return bytes;
-    }
-
-    private Value(Bytes bytes) {
-      this.bytes = bytes;
-      this.gotBytes = true;
-    }
-
-    private Value(Data data) {
-      this.data = data;
-      this.gotBytes = false;
-    }
-
-    public Integer toInteger() {
-      if (getBytes() == null)
-        return null;
-      return encoder.decodeInteger(getBytes());
-    }
-
-    public int toInteger(int defaultValue) {
-      if (getBytes() == null)
-        return defaultValue;
-      return encoder.decodeInteger(getBytes());
-    }
-
-    public Long toLong() {
-      if (getBytes() == null)
-        return null;
-      return encoder.decodeLong(getBytes());
-    }
-
-    public long toLong(long defaultValue) {
-      if (getBytes() == null)
-        return defaultValue;
-      return encoder.decodeLong(getBytes());
-    }
-
-    @Override
-    public String toString() {
-      if (getBytes() == null)
-        return null;
-      return encoder.decodeString(getBytes());
-    }
-
-    public String toString(String defaultValue) {
-      if (getBytes() == null)
-        return defaultValue;
-      return encoder.decodeString(getBytes());
-    }
-
-    public byte[] toBytes() {
-      if (getBytes() == null)
-        return null;
-      return getBytes().toArray();
-    }
-
-    public byte[] toBytes(byte[] defaultValue) {
-      if (getBytes() == null)
-        return defaultValue;
-      return getBytes().toArray();
-    }
-
-    public ByteBuffer toByteBuffer() {
-      if (getBytes() == null)
-        return null;
-      if (getBytes().isBackedByArray()) {
-        return ByteBuffer.wrap(getBytes().getBackingArray(), getBytes().offset(), getBytes().length());
-      } else {
-        return ByteBuffer.wrap(getBytes().toArray());
-      }
-    }
-
-    public ByteBuffer toByteBuffer(ByteBuffer defaultValue) {
-      if (getBytes() == null)
-        return defaultValue;
-      return toByteBuffer();
-    }
-
-    @Override
-    public int hashCode() {
-      if (getBytes() == null) {
-        return 0;
-      }
-
-      return getBytes().hashCode();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof Value) {
-        Value ov = (Value) o;
-        if (getBytes() == null)
-          return ov.getBytes() == null;
-        else
-          return getBytes().equals(ov.getBytes());
-      }
-
-      return false;
-    }
-  }
-
-  public class ValueQualifierBuilder extends QualifierMethods<VisibilityMethods> {
-
-    ValueQualifierBuilder(Data data) {
-      tl.super(data);
-    }
-
-    @Override
-    VisibilityMethods create(Data data) {
-      return new VisibilityMethods(data);
-    }
-  }
-
-  public class ValueFamilyMethods extends FamilyMethods<ValueQualifierBuilder,Value> {
-
-    ValueFamilyMethods(Data data) {
-      tl.super(data);
-    }
-
-    @Override
-    ValueQualifierBuilder create1(Data data) {
-      return new ValueQualifierBuilder(data);
-    }
-
-    @Override
-    Value create2(Data data) {
-      return new Value(data);
-    }
-
-    public Map<Column,Value> columns(Set<Column> columns) {
-      try {
-        return wrap(snapshot.get(data.row, columns));
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    public Map<Column,Value> columns(Column... columns) {
-      try {
-        return wrap(snapshot.get(data.row, new HashSet<Column>(Arrays.asList(columns))));
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-
-  public class MapConverter {
-    private Collection<Bytes> rows;
-    private Set<Column> columns;
-
-    public MapConverter(Collection<Bytes> rows, Set<Column> columns) {
-      this.rows = rows;
-      this.columns = columns;
-    }
-
-    private Map<Bytes,Map<Column,Bytes>> getInput() {
-      try {
-        return snapshot.get(rows, columns);
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    @SuppressWarnings({"rawtypes", "unchecked"})
-    private Map wrap2(Map m) {
-      return Collections.unmodifiableMap(DefaultedMap.decorate(m, new DefaultedMap(new Value((Bytes) null))));
-    }
-
-    @SuppressWarnings("unchecked")
-    public Map<String,Map<Column,Value>> toStringMap() {
-      Map<Bytes,Map<Column,Bytes>> in = getInput();
-      Map<String,Map<Column,Value>> out = new HashMap<>();
-
-      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
-        out.put(encoder.decodeString(rowEntry.getKey()), wrap(rowEntry.getValue()));
-
-      return wrap2(out);
-    }
-
-    @SuppressWarnings("unchecked")
-    public Map<Long,Map<Column,Value>> toLongMap() {
-      Map<Bytes,Map<Column,Bytes>> in = getInput();
-      Map<Long,Map<Column,Value>> out = new HashMap<>();
-
-      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
-        out.put(encoder.decodeLong(rowEntry.getKey()), wrap(rowEntry.getValue()));
-
-      return wrap2(out);
-    }
-
-    @SuppressWarnings("unchecked")
-    public Map<Integer,Map<Column,Value>> toIntegerMap() {
-      Map<Bytes,Map<Column,Bytes>> in = getInput();
-      Map<Integer,Map<Column,Value>> out = new HashMap<>();
-
-      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
-        out.put(encoder.decodeInteger(rowEntry.getKey()), wrap(rowEntry.getValue()));
-
-      return wrap2(out);
-    }
-
-    @SuppressWarnings("unchecked")
-    public Map<Bytes,Map<Column,Value>> toBytesMap() {
-      Map<Bytes,Map<Column,Bytes>> in = getInput();
-      Map<Bytes,Map<Column,Value>> out = new HashMap<>();
-
-      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
-        out.put(rowEntry.getKey(), wrap(rowEntry.getValue()));
-
-      return wrap2(out);
-    }
-  }
-
-  public class ColumnsMethods {
-    private Collection<Bytes> rows;
-
-    public ColumnsMethods(Collection<Bytes> rows) {
-      this.rows = rows;
-    }
-
-    public MapConverter columns(Set<Column> columns) {
-      return new MapConverter(rows, columns);
-    }
-
-    public MapConverter columns(Column... columns) {
-      return columns(new HashSet<Column>(Arrays.asList(columns)));
-    }
-  }
-
-  public class ValueRowMethods extends RowMethods<ValueFamilyMethods> {
-
-    ValueRowMethods() {
-      tl.super();
-    }
-
-    @Override
-    ValueFamilyMethods create(Data data) {
-      return new ValueFamilyMethods(data);
-    }
-
-    public ColumnsMethods rows(Collection<Bytes> rows) {
-      return new ColumnsMethods(rows);
-    }
-
-    public ColumnsMethods rowsString(Collection<String> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (String row : rows) {
-        conv.add(encoder.encode(row));
-      }
-
-      return rows(conv);
-    }
-
-    public ColumnsMethods rowsLong(Collection<Long> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (Long row : rows) {
-        conv.add(encoder.encode(row));
-      }
-
-      return rows(conv);
-    }
-
-    public ColumnsMethods rowsInteger(Collection<Integer> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (Integer row : rows) {
-        conv.add(encoder.encode(row));
-      }
-
-      return rows(conv);
-    }
-
-    public ColumnsMethods rowsBytes(Collection<byte[]> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (byte[] row : rows) {
-        conv.add(Bytes.wrap(row));
-      }
-
-      return rows(conv);
-    }
-
-    public ColumnsMethods rowsByteBuffers(Collection<ByteBuffer> rows) {
-      ArrayList<Bytes> conv = new ArrayList<>();
-      for (ByteBuffer row : rows) {
-        conv.add(Bytes.wrap(row));
-      }
-
-      return rows(conv);
-    }
-
-  }
+  private Snapshot cSnapshot;
 
   TypedSnapshot(Snapshot snapshot, Encoder encoder, TypeLayer tl) {
-    this.snapshot = snapshot;
-    this.encoder = encoder;
-    this.tl = tl;
+    super(snapshot, encoder, tl);
+    cSnapshot = snapshot;
   }
 
-  @Override
-  public Bytes get(Bytes row, Column column) throws Exception {
-    return snapshot.get(row, column);
+  public void close() {
+    cSnapshot.close();
   }
-
-  @Override
-  public Map<Column,Bytes> get(Bytes row, Set<Column> columns) throws Exception {
-    return snapshot.get(row, columns);
-  }
-
-  @Override
-  public RowIterator get(ScannerConfiguration config) throws Exception {
-    return snapshot.get(config);
-  }
-
-  @Override
-  public Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) throws Exception {
-    return snapshot.get(rows, columns);
-  }
-
-  public ValueRowMethods get() {
-    return new ValueRowMethods();
-  }
-
-  @SuppressWarnings({"unchecked"})
-  private Map<Column,Value> wrap(Map<Column,Bytes> map) {
-    Map<Column,Value> ret = Maps.transformValues(map, new Function<Bytes,Value>() {
-      @Override
-      public Value apply(Bytes input) {
-        return new Value(input);
-      }
-    });
-
-    return Collections.unmodifiableMap(DefaultedMap.decorate(ret, new Value((Bytes) null)));
-  }
-
 }
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedSnapshotBase.java b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshotBase.java
new file mode 100644
index 00000000..04c0dd3e
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshotBase.java
@@ -0,0 +1,435 @@
+/*
+ * Copyright 2014 Fluo authors (see AUTHORS)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.types;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Maps;
+import io.fluo.api.client.SnapshotBase;
+import io.fluo.api.config.ScannerConfiguration;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.iterator.RowIterator;
+import io.fluo.api.types.TypeLayer.Data;
+import io.fluo.api.types.TypeLayer.FamilyMethods;
+import io.fluo.api.types.TypeLayer.QualifierMethods;
+import io.fluo.api.types.TypeLayer.RowMethods;
+import org.apache.accumulo.core.security.ColumnVisibility;
+import org.apache.commons.collections.map.DefaultedMap;
+
+//TODO need to refactor column to use Encoder
+
+/**
+ * See {@link TypeLayer} javadocs.
+ */
+public class TypedSnapshotBase implements SnapshotBase {
+
+  private SnapshotBase snapshot;
+  private Encoder encoder;
+  private TypeLayer tl;
+
+  public class VisibilityMethods extends Value {
+
+    public VisibilityMethods(Data data) {
+      super(data);
+    }
+
+    public Value vis(Bytes cv) {
+      data.vis = cv;
+      return new Value(data);
+    }
+
+    public Value vis(byte[] cv) {
+      data.vis = Bytes.wrap(cv);
+      return new Value(data);
+    }
+
+    public Value vis(ByteBuffer bb) {
+      data.vis = Bytes.wrap(bb);
+      return new Value(data);
+    }
+
+    public Value vis(String cv) {
+      data.vis = Bytes.wrap(cv);
+      return new Value(data);
+    }
+
+    public Value vis(ColumnVisibility cv) {
+      data.vis = Bytes.wrap(cv.flatten());
+      return new Value(data);
+    }
+  }
+
+  public class Value {
+    private Bytes bytes;
+    private boolean gotBytes = false;
+    protected Data data;
+
+    public Bytes getBytes() {
+      if (!gotBytes) {
+        try {
+          bytes = snapshot.get(data.row, data.getCol());
+          gotBytes = true;
+        } catch (Exception e) {
+          if (e instanceof RuntimeException)
+            throw (RuntimeException) e;
+          throw new RuntimeException(e);
+        }
+      }
+
+      return bytes;
+    }
+
+    private Value(Bytes bytes) {
+      this.bytes = bytes;
+      this.gotBytes = true;
+    }
+
+    private Value(Data data) {
+      this.data = data;
+      this.gotBytes = false;
+    }
+
+    public Integer toInteger() {
+      if (getBytes() == null)
+        return null;
+      return encoder.decodeInteger(getBytes());
+    }
+
+    public int toInteger(int defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return encoder.decodeInteger(getBytes());
+    }
+
+    public Long toLong() {
+      if (getBytes() == null)
+        return null;
+      return encoder.decodeLong(getBytes());
+    }
+
+    public long toLong(long defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return encoder.decodeLong(getBytes());
+    }
+
+    @Override
+    public String toString() {
+      if (getBytes() == null)
+        return null;
+      return encoder.decodeString(getBytes());
+    }
+
+    public String toString(String defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return encoder.decodeString(getBytes());
+    }
+
+    public byte[] toBytes() {
+      if (getBytes() == null)
+        return null;
+      return getBytes().toArray();
+    }
+
+    public byte[] toBytes(byte[] defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return getBytes().toArray();
+    }
+
+    public ByteBuffer toByteBuffer() {
+      if (getBytes() == null)
+        return null;
+      if (getBytes().isBackedByArray()) {
+        return ByteBuffer.wrap(getBytes().getBackingArray(), getBytes().offset(), getBytes().length());
+      } else {
+        return ByteBuffer.wrap(getBytes().toArray());
+      }
+    }
+
+    public ByteBuffer toByteBuffer(ByteBuffer defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return toByteBuffer();
+    }
+
+    @Override
+    public int hashCode() {
+      if (getBytes() == null) {
+        return 0;
+      }
+
+      return getBytes().hashCode();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Value) {
+        Value ov = (Value) o;
+        if (getBytes() == null)
+          return ov.getBytes() == null;
+        else
+          return getBytes().equals(ov.getBytes());
+      }
+
+      return false;
+    }
+  }
+
+  public class ValueQualifierBuilder extends QualifierMethods<VisibilityMethods> {
+
+    ValueQualifierBuilder(Data data) {
+      tl.super(data);
+    }
+
+    @Override
+    VisibilityMethods create(Data data) {
+      return new VisibilityMethods(data);
+    }
+  }
+
+  public class ValueFamilyMethods extends FamilyMethods<ValueQualifierBuilder,Value> {
+
+    ValueFamilyMethods(Data data) {
+      tl.super(data);
+    }
+
+    @Override
+    ValueQualifierBuilder create1(Data data) {
+      return new ValueQualifierBuilder(data);
+    }
+
+    @Override
+    Value create2(Data data) {
+      return new Value(data);
+    }
+
+    public Map<Column,Value> columns(Set<Column> columns) {
+      try {
+        return wrap(snapshot.get(data.row, columns));
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    public Map<Column,Value> columns(Column... columns) {
+      try {
+        return wrap(snapshot.get(data.row, new HashSet<Column>(Arrays.asList(columns))));
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+
+  public class MapConverter {
+    private Collection<Bytes> rows;
+    private Set<Column> columns;
+
+    public MapConverter(Collection<Bytes> rows, Set<Column> columns) {
+      this.rows = rows;
+      this.columns = columns;
+    }
+
+    private Map<Bytes,Map<Column,Bytes>> getInput() {
+      try {
+        return snapshot.get(rows, columns);
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    private Map wrap2(Map m) {
+      return Collections.unmodifiableMap(DefaultedMap.decorate(m, new DefaultedMap(new Value((Bytes) null))));
+    }
+
+    @SuppressWarnings("unchecked")
+    public Map<String,Map<Column,Value>> toStringMap() {
+      Map<Bytes,Map<Column,Bytes>> in = getInput();
+      Map<String,Map<Column,Value>> out = new HashMap<>();
+
+      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
+        out.put(encoder.decodeString(rowEntry.getKey()), wrap(rowEntry.getValue()));
+
+      return wrap2(out);
+    }
+
+    @SuppressWarnings("unchecked")
+    public Map<Long,Map<Column,Value>> toLongMap() {
+      Map<Bytes,Map<Column,Bytes>> in = getInput();
+      Map<Long,Map<Column,Value>> out = new HashMap<>();
+
+      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
+        out.put(encoder.decodeLong(rowEntry.getKey()), wrap(rowEntry.getValue()));
+
+      return wrap2(out);
+    }
+
+    @SuppressWarnings("unchecked")
+    public Map<Integer,Map<Column,Value>> toIntegerMap() {
+      Map<Bytes,Map<Column,Bytes>> in = getInput();
+      Map<Integer,Map<Column,Value>> out = new HashMap<>();
+
+      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
+        out.put(encoder.decodeInteger(rowEntry.getKey()), wrap(rowEntry.getValue()));
+
+      return wrap2(out);
+    }
+
+    @SuppressWarnings("unchecked")
+    public Map<Bytes,Map<Column,Value>> toBytesMap() {
+      Map<Bytes,Map<Column,Bytes>> in = getInput();
+      Map<Bytes,Map<Column,Value>> out = new HashMap<>();
+
+      for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet())
+        out.put(rowEntry.getKey(), wrap(rowEntry.getValue()));
+
+      return wrap2(out);
+    }
+  }
+
+  public class ColumnsMethods {
+    private Collection<Bytes> rows;
+
+    public ColumnsMethods(Collection<Bytes> rows) {
+      this.rows = rows;
+    }
+
+    public MapConverter columns(Set<Column> columns) {
+      return new MapConverter(rows, columns);
+    }
+
+    public MapConverter columns(Column... columns) {
+      return columns(new HashSet<Column>(Arrays.asList(columns)));
+    }
+  }
+
+  public class ValueRowMethods extends RowMethods<ValueFamilyMethods> {
+
+    ValueRowMethods() {
+      tl.super();
+    }
+
+    @Override
+    ValueFamilyMethods create(Data data) {
+      return new ValueFamilyMethods(data);
+    }
+
+    public ColumnsMethods rows(Collection<Bytes> rows) {
+      return new ColumnsMethods(rows);
+    }
+
+    public ColumnsMethods rowsString(Collection<String> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (String row : rows) {
+        conv.add(encoder.encode(row));
+      }
+
+      return rows(conv);
+    }
+
+    public ColumnsMethods rowsLong(Collection<Long> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (Long row : rows) {
+        conv.add(encoder.encode(row));
+      }
+
+      return rows(conv);
+    }
+
+    public ColumnsMethods rowsInteger(Collection<Integer> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (Integer row : rows) {
+        conv.add(encoder.encode(row));
+      }
+
+      return rows(conv);
+    }
+
+    public ColumnsMethods rowsBytes(Collection<byte[]> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (byte[] row : rows) {
+        conv.add(Bytes.wrap(row));
+      }
+
+      return rows(conv);
+    }
+
+    public ColumnsMethods rowsByteBuffers(Collection<ByteBuffer> rows) {
+      ArrayList<Bytes> conv = new ArrayList<>();
+      for (ByteBuffer row : rows) {
+        conv.add(Bytes.wrap(row));
+      }
+
+      return rows(conv);
+    }
+
+  }
+
+  TypedSnapshotBase(SnapshotBase snapshot, Encoder encoder, TypeLayer tl) {
+    this.snapshot = snapshot;
+    this.encoder = encoder;
+    this.tl = tl;
+  }
+
+  @Override
+  public Bytes get(Bytes row, Column column) throws Exception {
+    return snapshot.get(row, column);
+  }
+
+  @Override
+  public Map<Column,Bytes> get(Bytes row, Set<Column> columns) throws Exception {
+    return snapshot.get(row, columns);
+  }
+
+  @Override
+  public RowIterator get(ScannerConfiguration config) throws Exception {
+    return snapshot.get(config);
+  }
+
+  @Override
+  public Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) throws Exception {
+    return snapshot.get(rows, columns);
+  }
+
+  public ValueRowMethods get() {
+    return new ValueRowMethods();
+  }
+
+  @SuppressWarnings({"unchecked"})
+  private Map<Column,Value> wrap(Map<Column,Bytes> map) {
+    Map<Column,Value> ret = Maps.transformValues(map, new Function<Bytes,Value>() {
+      @Override
+      public Value apply(Bytes input) {
+        return new Value(input);
+      }
+    });
+
+    return Collections.unmodifiableMap(DefaultedMap.decorate(ret, new Value((Bytes) null)));
+  }
+}
\ No newline at end of file
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java b/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java
index 259748ff..e9a1148d 100644
--- a/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java
@@ -15,6 +15,9 @@
  */
 package io.fluo.api.types;
 
+import java.nio.ByteBuffer;
+
+import com.google.common.annotations.VisibleForTesting;
 import io.fluo.api.client.Transaction;
 import io.fluo.api.data.Bytes;
 import io.fluo.api.data.Column;
@@ -22,18 +25,12 @@ import io.fluo.api.types.TypeLayer.Data;
 import io.fluo.api.types.TypeLayer.FamilyMethods;
 import io.fluo.api.types.TypeLayer.QualifierMethods;
 import io.fluo.api.types.TypeLayer.RowMethods;
-
-import java.nio.ByteBuffer;
-
 import org.apache.accumulo.core.security.ColumnVisibility;
 
-import com.google.common.annotations.VisibleForTesting;
-
 /**
  * See {@link TypeLayer} javadocs.
  */
-
-public class TypedTransaction extends TypedSnapshot implements Transaction {
+public class TypedTransaction extends TypedSnapshotBase implements Transaction {
 
   private Transaction tx;
   private Encoder encoder;
diff --git a/modules/api/src/test/java/io/fluo/api/types/MockSnapshot.java b/modules/api/src/test/java/io/fluo/api/types/MockSnapshot.java
new file mode 100644
index 00000000..e8a41ecc
--- /dev/null
+++ b/modules/api/src/test/java/io/fluo/api/types/MockSnapshot.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2014 Fluo authors (see AUTHORS)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.types;
+
+import io.fluo.api.client.Snapshot;
+
+public class MockSnapshot extends MockSnapshotBase implements Snapshot {
+
+  MockSnapshot(String... entries) {
+    super(entries);
+  }
+
+  @Override
+  public void close() {
+    // no resources need to be closed
+  }
+}
\ No newline at end of file
diff --git a/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java b/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java
new file mode 100644
index 00000000..ef4dd9f9
--- /dev/null
+++ b/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2014 Fluo authors (see AUTHORS)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.types;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import io.fluo.api.client.SnapshotBase;
+import io.fluo.api.config.ScannerConfiguration;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.iterator.RowIterator;
+import org.apache.accumulo.core.security.ColumnVisibility;
+
+public class MockSnapshotBase implements SnapshotBase {
+
+  Map<Bytes,Map<Column,Bytes>> getData = new HashMap<>();
+
+  /**
+   * Initializes {@link #getData} using {@link #toRCVM(String...)}
+   */
+  MockSnapshotBase(String... entries) {
+    getData = toRCVM(entries);
+  }
+
+  @Override
+  public Bytes get(Bytes row, Column column) throws Exception {
+    Map<Column,Bytes> cols = getData.get(row);
+    if (cols != null)
+      return cols.get(column);
+
+    return null;
+  }
+
+  @Override
+  public Map<Column,Bytes> get(Bytes row, Set<Column> columns) throws Exception {
+    Map<Column,Bytes> ret = new HashMap<Column,Bytes>();
+    Map<Column,Bytes> cols = getData.get(row);
+    if (cols != null) {
+      for (Column column : columns) {
+        Bytes val = cols.get(column);
+        if (val != null)
+          ret.put(column, val);
+      }
+    }
+    return ret;
+  }
+
+  @Override
+  public Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) throws Exception {
+
+    Map<Bytes,Map<Column,Bytes>> ret = new HashMap<>();
+
+    for (Bytes row : rows) {
+      Map<Column,Bytes> colMap = get(row, columns);
+      if (colMap != null && colMap.size() > 0) {
+        ret.put(row, colMap);
+      }
+    }
+
+    return ret;
+  }
+
+  @Override
+  public RowIterator get(ScannerConfiguration config) throws Exception {
+    throw new UnsupportedOperationException();
+  }
+
+  /**
+   * toRCVM stands for "To Row Column Value Map". This is a convenience function that takes strings of the format
+   * {@code <row>,<col fam>:<col qual>[:col vis],<value>} and generates a row, column, value map.
+   */
+  public static Map<Bytes,Map<Column,Bytes>> toRCVM(String... entries) {
+    Map<Bytes,Map<Column,Bytes>> ret = new HashMap<>();
+
+    for (String entry : entries) {
+      String[] rcv = entry.split(",");
+      if (rcv.length != 3 && !(rcv.length == 2 && entry.trim().endsWith(",")))
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
+
+      Bytes row = Bytes.wrap(rcv[0]);
+      String[] colFields = rcv[1].split(":");
+      if (colFields.length != 2 && colFields.length != 3)
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
+
+      Column col = new Column(colFields[0], colFields[1]);
+      if (colFields.length == 3)
+        col.setVisibility(new ColumnVisibility(colFields[2]));
+
+      Bytes val;
+      if (rcv.length == 2)
+        val = Bytes.EMPTY;
+      else
+        val = Bytes.wrap(rcv[2]);
+
+      Map<Column,Bytes> cols = ret.get(row);
+      if (cols == null) {
+        cols = new HashMap<>();
+        ret.put(row, cols);
+      }
+
+      cols.put(col, val);
+    }
+    return ret;
+  }
+
+  /**
+   * toRCM stands for "To Row Column Map". This is a convenience function that takes strings of the format {@code <row>,<col fam>:<col qual>[:col vis]} and
+   * generates a row, column map.
+   */
+  public static Map<Bytes,Set<Column>> toRCM(String... entries) {
+    Map<Bytes,Set<Column>> ret = new HashMap<>();
+
+    for (String entry : entries) {
+      String[] rcv = entry.split(",");
+      if (rcv.length != 2)
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis] but saw : " + entry);
+
+      Bytes row = Bytes.wrap(rcv[0]);
+      String[] colFields = rcv[1].split(":");
+      if (colFields.length != 2 && colFields.length != 3)
+        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis] but saw : " + entry);
+
+      Column col = new Column(colFields[0], colFields[1]);
+      if (colFields.length == 3)
+        col.setVisibility(new ColumnVisibility(colFields[2]));
+
+      Set<Column> cols = ret.get(row);
+      if (cols == null) {
+        cols = new HashSet<>();
+        ret.put(row, cols);
+      }
+
+      cols.add(col);
+    }
+    return ret;
+  }
+}
diff --git a/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java b/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java
index 8bab9d1f..7c4fe8d4 100644
--- a/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java
+++ b/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java
@@ -15,79 +15,27 @@
  */
 package io.fluo.api.types;
 
-import io.fluo.api.client.Transaction;
-import io.fluo.api.config.ScannerConfiguration;
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-import io.fluo.api.iterator.RowIterator;
-
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
-import org.apache.accumulo.core.security.ColumnVisibility;
+import io.fluo.api.client.Transaction;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
 
 /**
  * A very simple implementation of {@link Transaction} used for testing. All reads are serviced from {@link #getData}. Updates are stored in {@link #setData},
  * {@link #deletes}, or {@link #weakNotifications} depending on the update type.
  */
-public class MockTransaction implements Transaction {
+public class MockTransaction extends MockSnapshotBase implements Transaction {
 
-  Map<Bytes,Map<Column,Bytes>> getData = new HashMap<>();
   Map<Bytes,Map<Column,Bytes>> setData = new HashMap<>();
   Map<Bytes,Set<Column>> deletes = new HashMap<>();
   Map<Bytes,Set<Column>> weakNotifications = new HashMap<>();
 
-  /**
-   * Initializes {@link #getData} using {@link #toRCVM(String...)}
-   */
   MockTransaction(String... entries) {
-    getData = toRCVM(entries);
-  }
-
-  @Override
-  public Bytes get(Bytes row, Column column) throws Exception {
-    Map<Column,Bytes> cols = getData.get(row);
-    if (cols != null)
-      return cols.get(column);
-
-    return null;
-  }
-
-  @Override
-  public Map<Column,Bytes> get(Bytes row, Set<Column> columns) throws Exception {
-    Map<Column,Bytes> ret = new HashMap<Column,Bytes>();
-    Map<Column,Bytes> cols = getData.get(row);
-    if (cols != null) {
-      for (Column column : columns) {
-        Bytes val = cols.get(column);
-        if (val != null)
-          ret.put(column, val);
-      }
-    }
-    return ret;
-  }
-
-  @Override
-  public Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) throws Exception {
-
-    Map<Bytes,Map<Column,Bytes>> ret = new HashMap<>();
-
-    for (Bytes row : rows) {
-      Map<Column,Bytes> colMap = get(row, columns);
-      if (colMap != null && colMap.size() > 0) {
-        ret.put(row, colMap);
-      }
-    }
-
-    return ret;
-  }
-
-  @Override
-  public RowIterator get(ScannerConfiguration config) throws Exception {
-    throw new UnsupportedOperationException();
+    super(entries);
   }
 
   @Override
@@ -110,7 +58,6 @@ public class MockTransaction implements Transaction {
     }
 
     cols.put(col, value);
-
   }
 
   @Override
@@ -123,74 +70,4 @@ public class MockTransaction implements Transaction {
 
     cols.add(col);
   }
-
-  /**
-   * toRCVM stands for "To Row Column Value Map". This is a convenience function that takes strings of the format
-   * {@code <row>,<col fam>:<col qual>[:col vis],<value>} and generates a row, column, value map.
-   */
-  public static Map<Bytes,Map<Column,Bytes>> toRCVM(String... entries) {
-    Map<Bytes,Map<Column,Bytes>> ret = new HashMap<>();
-
-    for (String entry : entries) {
-      String[] rcv = entry.split(",");
-      if (rcv.length != 3 && !(rcv.length == 2 && entry.trim().endsWith(",")))
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
-
-      Bytes row = Bytes.wrap(rcv[0]);
-      String[] colFields = rcv[1].split(":");
-      if (colFields.length != 2 && colFields.length != 3)
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
-
-      Column col = new Column(colFields[0], colFields[1]);
-      if (colFields.length == 3)
-        col.setVisibility(new ColumnVisibility(colFields[2]));
-
-      Bytes val;
-      if (rcv.length == 2)
-        val = Bytes.EMPTY;
-      else
-        val = Bytes.wrap(rcv[2]);
-
-      Map<Column,Bytes> cols = ret.get(row);
-      if (cols == null) {
-        cols = new HashMap<>();
-        ret.put(row, cols);
-      }
-
-      cols.put(col, val);
-    }
-    return ret;
-  }
-
-  /**
-   * toRCM stands for "To Row Column Map". This is a convenience function that takes strings of the format {@code <row>,<col fam>:<col qual>[:col vis]} and
-   * generates a row, column map.
-   */
-  public static Map<Bytes,Set<Column>> toRCM(String... entries) {
-    Map<Bytes,Set<Column>> ret = new HashMap<>();
-
-    for (String entry : entries) {
-      String[] rcv = entry.split(",");
-      if (rcv.length != 2)
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis] but saw : " + entry);
-
-      Bytes row = Bytes.wrap(rcv[0]);
-      String[] colFields = rcv[1].split(":");
-      if (colFields.length != 2 && colFields.length != 3)
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis] but saw : " + entry);
-
-      Column col = new Column(colFields[0], colFields[1]);
-      if (colFields.length == 3)
-        col.setVisibility(new ColumnVisibility(colFields[2]));
-
-      Set<Column> cols = ret.get(row);
-      if (cols == null) {
-        cols = new HashSet<>();
-        ret.put(row, cols);
-      }
-
-      cols.add(col);
-    }
-    return ret;
-  }
 }
\ No newline at end of file
diff --git a/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java b/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
index d87d0ab4..27f1ef82 100644
--- a/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
+++ b/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
@@ -15,21 +15,18 @@
  */
 package io.fluo.api.types;
 
-import io.fluo.api.client.Snapshot;
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-import io.fluo.api.types.TypedSnapshot.Value;
-
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 import java.util.Map;
 
+import com.google.common.collect.ImmutableSet;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.types.TypedSnapshotBase.Value;
 import org.apache.accumulo.core.security.ColumnVisibility;
 import org.junit.Assert;
 import org.junit.Test;
 
-import com.google.common.collect.ImmutableSet;
-
 public class TypeLayerTest {
 
   @Test
@@ -130,17 +127,16 @@ public class TypeLayerTest {
     Assert.assertEquals(new Column("f0", "q0").setVisibility(new ColumnVisibility("A&C")), tl.bc().fam("f0").qual("q0").vis("A&C".getBytes()));
     Assert.assertEquals(new Column("5", "7").setVisibility(new ColumnVisibility("A&D")), tl.bc().fam(5).qual(7).vis(Bytes.wrap("A&D")));
     Assert.assertEquals(new Column("5", "7").setVisibility(new ColumnVisibility("A&D")), tl.bc().fam(5).qual(7).vis(ByteBuffer.wrap("A&D".getBytes())));
-
   }
 
   @Test
   public void testRead() throws Exception {
     TypeLayer tl = new TypeLayer(new StringEncoder());
 
-    MockTransaction tt = new MockTransaction("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
+    MockSnapshot ms = new MockSnapshot("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
         "13,9:19,20", "13,9:20,20");
 
-    TypedSnapshot tts = tl.wrap((Snapshot) tt);
+    TypedSnapshot tts = tl.wrap(ms);
 
     Assert.assertEquals("v1", tts.get().row("r1").fam("cf1").qual("cq1").toString());
     Assert.assertEquals("v1", tts.get().row("r1").fam("cf1").qual("cq1").toString("b"));
