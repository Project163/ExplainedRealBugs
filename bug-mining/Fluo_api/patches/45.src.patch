diff --git a/modules/api/src/main/java/io/fluo/api/data/Bytes.java b/modules/api/src/main/java/io/fluo/api/data/Bytes.java
index d37ab7cc..51f2f704 100644
--- a/modules/api/src/main/java/io/fluo/api/data/Bytes.java
+++ b/modules/api/src/main/java/io/fluo/api/data/Bytes.java
@@ -23,7 +23,6 @@ import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.EOFException;
 import java.io.IOException;
-import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
@@ -34,12 +33,31 @@ import org.apache.accumulo.core.data.ByteSequence;
 import org.apache.hadoop.io.WritableUtils;
 
 /**
- * Represents bytes in Fluo. Similar to an Accumulo {@link ByteSequence}
+ * Represents bytes in Fluo. Similar to an Accumulo {@link ByteSequence}. Bytes is immutable after it is created. {@link Bytes.EMPTY} is used to represent a
+ * Bytes object with no data.
  */
 public abstract class Bytes implements Comparable<Bytes> {
   
+  private static final String BYTES_FACTORY_CLASS = "io.fluo.core.data.MutableBytesFactory";
+
+  public interface BytesFactory {
+    Bytes get(byte[] data);
+  }
+
+  private static BytesFactory bytesFactory;
+
+  static {
+    try {
+      bytesFactory = (BytesFactory) Class.forName(BYTES_FACTORY_CLASS).getDeclaredConstructor().newInstance();
+    } catch (Exception e) {
+      throw new IllegalStateException(e);
+    }
+  }
+
   public static final Bytes EMPTY = Bytes.wrap(new byte[0]);
-  
+
+  private Integer hashCode = null;
+
   public Bytes() {}
 
   /**
@@ -52,14 +70,12 @@ public abstract class Bytes implements Comparable<Bytes> {
   public abstract byte byteAt(int i);
 
   /**
-   * Gets the length of this sequence.
-   *
-   * @return sequence length
+   * Gets the length of bytes
    */
   public abstract int length();
 
   /**
-   * Returns a portion of this bytes sequence.
+   * Returns a portion of the Bytes object
    *
    * @param start index of subsequence start (inclusive)
    * @param end index of subsequence end (exclusive)
@@ -67,35 +83,10 @@ public abstract class Bytes implements Comparable<Bytes> {
   public abstract Bytes subSequence(int start, int end);
 
   /**
-   * Returns a byte array containing the bytes in this sequence. This method
-   * may copy the sequence data or may return a backing byte array directly.
-   *
-   * @return byte array
+   * Returns a byte array containing a copy of the bytes
    */
   public abstract byte[] toArray();
   
-  /**
-   * Determines whether this sequence is backed by a byte array.
-   *
-   * @return true if sequence is backed by a byte array
-   */
-  public abstract boolean isBackedByArray();
-
-  /**
-   * Gets the backing byte array for this sequence.
-   *
-   * @return byte array
-   */
-  public abstract byte[] getBackingArray();
-
-  /**
-   * Gets the offset for this byte sequence. This value represents the starting
-   * point for the sequence in the backing array, if there is one.
-   *
-   * @return offset (inclusive)
-   */
-  public abstract int offset();
-
   /**
    * Compares the two given byte sequences, byte by byte, returning a negative,
    * zero, or positive result if the first sequence is less than, equal to, or
@@ -108,7 +99,7 @@ public abstract class Bytes implements Comparable<Bytes> {
    * @param b2 second byte sequence to compare
    * @return comparison result
    */
-  public static int compareBytes(Bytes b1, Bytes b2) {
+  final public static int compareBytes(Bytes b1, Bytes b2) {
 
     int minLen = Math.min(b1.length(), b2.length());
 
@@ -124,24 +115,18 @@ public abstract class Bytes implements Comparable<Bytes> {
   }
 
   /**
-   * Compares this Bytes to another.
-   *
-   * @param other Bytes
-   * @return comparison result
+   * Compares this Bytes object to another.
    */
   @Override
-  public int compareTo(Bytes other) {      
+  final public int compareTo(Bytes other) {      
     return compareBytes(this, other);
   }
 
   /**
-   * Determines if this Bytes equals another.
-   *
-   * @param other object
-   * @return true if equal
+   * Returns true if this Bytes object equals another.
    */
   @Override
-  public boolean equals(Object other) {
+  final public boolean equals(Object other) {
     if (other instanceof Bytes) {
       Bytes ob = (Bytes) other;
 
@@ -156,77 +141,63 @@ public abstract class Bytes implements Comparable<Bytes> {
     return false;
   }
 
-  /**
-   * Computes hash code of Bytes
-   * 
-   * @return hash code
-   */
   @Override
-  public int hashCode() {
-    int hash = 1;
-    if (isBackedByArray()) {
-      byte[] data = getBackingArray();
-      int end = offset() + length();
-      for (int i = offset(); i < end; i++)
-        hash = (31 * hash) + data[i];
-    } else {
-      for (int i = 0; i < length(); i++)
+  final public int hashCode() {
+    if (hashCode == null) {
+      int hash = 1;
+      for (int i = 0; i < length(); i++) {
         hash = (31 * hash) + byteAt(i);
+      }
+      hashCode = hash;
     }
-    return hash;
+    return hashCode;
   }
   
   /**
-   * Wraps byte array as Bytes
-   * 
-   * @param array byte array
-   * @return Bytes
+   * Creates a Bytes object by copying the given byte array
    */
-  public static Bytes wrap(byte[] array) {
-    return new ArrayBytes(array);
+  final public static Bytes wrap(byte[] array) {
+    byte[] copy = new byte[array.length];
+    System.arraycopy(array, 0, copy, 0, array.length);
+    return bytesFactory.get(copy);
   }
   
   /**
-   * Creates a Bytes object by wrapping a subsequence of the given byte array. 
-   * The given byte array is used directly as the backing array, so later changes
-   * made to the (relevant portion of the) array reflect into the new Byte array.
+   * Creates a Bytes object by copying a subsequence of the given byte array 
    *
    * @param data Byte data
    * @param offset Starting offset in byte array (inclusive)
    * @param length Number of bytes to include
    */
-  public static Bytes wrap(byte data[], int offset, int length) {
-    return new ArrayBytes(data, offset, length);
+  final public static Bytes wrap(byte data[], int offset, int length) {
+    byte[] copy = new byte[length];
+    System.arraycopy(data, offset, copy, 0, length);
+    return bytesFactory.get(copy);
   }
 
   /**
-   * Wraps ByteBuffer as Bytes
-   * 
-   * @param bb ByteBuffer
-   * @return Bytes
+   * Creates a Bytes object by copying data from a ByteBuffer
    */
-  public static Bytes wrap(ByteBuffer bb) {
-    return new ArrayBytes(bb);
+  final public static Bytes wrap(ByteBuffer bb) {
+    byte[] data = new byte[bb.remaining()];
+    bb.get(data);
+    return bytesFactory.get(data);
   }
   
   /**
-   * Wraps a UTF-8 String as Bytes
-   * 
-   * @param s String
-   * @return Bytes
+   * Creates a Bytes object from a String
    */
-  public static Bytes wrap(String s) {
-    return new ArrayBytes(s);
+  final public static Bytes wrap(String s) {
+    byte[] data = s.getBytes(StandardCharsets.UTF_8);
+    return bytesFactory.get(data);
   }
   
   /**
-   * Wraps a String with a given charset as Bytes
-   * 
-   * @param s String
-   * @return Bytes
+   * Creates a Bytes object from String with a given charset
    */
-  public static Bytes wrap(String s, Charset c) {
-    return new ArrayBytes(s, c);
+  final public static Bytes wrap(String s, Charset c) {
+    byte[] data = s.getBytes(c);
+    return bytesFactory.get(data);
   }
   
   /**
@@ -236,14 +207,10 @@ public abstract class Bytes implements Comparable<Bytes> {
    * @param b Bytes
    * @throws IOException
    */
-  public static void write(DataOutput out, Bytes b) throws IOException {
+  final public static void write(DataOutput out, Bytes b) throws IOException {
     WritableUtils.writeVInt(out, b.length());
-    if (b.isBackedByArray()) {
-      out.write(b.getBackingArray(), b.offset(), b.length());
-    } else {
-      for (int i = 0; i < b.length(); i++) {
-        out.write(b.byteAt(i) & 0xff);
-      }
+    for (int i = 0; i < b.length(); i++) {
+      out.write(b.byteAt(i) & 0xff);
     }
   }
 
@@ -254,7 +221,7 @@ public abstract class Bytes implements Comparable<Bytes> {
    * @return Bytes
    * @throws IOException
    */
-  public static Bytes read(DataInput in) throws IOException {
+  final public static Bytes read(DataInput in) throws IOException {
     int len = WritableUtils.readVInt(in);
     byte b[] = new byte[len];
     in.readFully(b);
@@ -267,7 +234,7 @@ public abstract class Bytes implements Comparable<Bytes> {
    * @param listOfBytes
    * @return Bytes
    */
-  public static Bytes concat(Bytes... listOfBytes) {
+  final public static Bytes concat(Bytes... listOfBytes) {
     try {
       // TODO calculate exact array size needed
       ByteArrayOutputStream baos = new ByteArrayOutputStream();
@@ -275,11 +242,7 @@ public abstract class Bytes implements Comparable<Bytes> {
       
       for (Bytes b : listOfBytes) {
         WritableUtils.writeVInt(dos, b.length());
-        if (b.isBackedByArray()) {
-          dos.write(b.getBackingArray(), b.offset(), b.length());
-        } else {
-          dos.write(b.toArray());
-        }
+        dos.write(b.toArray());
       }
       
       dos.close();
@@ -295,12 +258,9 @@ public abstract class Bytes implements Comparable<Bytes> {
    * @param b Original bytes object
    * @return List of bytes objects
    */
-  public static List<Bytes> split(Bytes b) {
+  final public static List<Bytes> split(Bytes b) {
     ByteArrayInputStream bais;
-    if (b.isBackedByArray())
-      bais = new ByteArrayInputStream(b.getBackingArray(), b.offset(), b.length());
-    else
-      bais = new ByteArrayInputStream(b.toArray());
+    bais = new ByteArrayInputStream(b.toArray());
     
     DataInputStream dis = new DataInputStream(bais);
     
@@ -321,154 +281,6 @@ public abstract class Bytes implements Comparable<Bytes> {
     }
     return ret;
   }
-  
-  /**
-  * An implementation of {@link Bytes} that uses a backing byte array.
-  */
-  private static class ArrayBytes extends Bytes implements Serializable {
-
-    private static final long serialVersionUID = 1L;
-
-    protected final byte data[];
-    protected final int offset;
-    protected final int length;
-
-    /**
-     * Creates a new ArrayBytes. The given byte array is used directly as the
-     * backing array, so later changes made to the array reflect into the new
-     * sequence.
-     *
-     * @param data byte data
-     */
-    private ArrayBytes(byte data[]) {
-      this.data = data;
-      this.offset = 0;
-      this.length = data.length;
-    }
-
-    /**
-     * Creates a new ArrayBytes from a subsequence of the given byte array. The
-     * given byte array is used directly as the backing array, so later changes
-     * made to the (relevant portion of the) array reflect into the new sequence.
-     *
-     * @param data byte data
-     * @param offset starting offset in byte array (inclusive)
-     * @param length number of bytes to include in sequence
-     * @throws IllegalArgumentException if the offset or length are out of bounds
-     * for the given byte array
-     */
-    private ArrayBytes(byte data[], int offset, int length) {
-      if (offset < 0 || offset > data.length || length < 0 || (offset + length) > data.length) {
-        throw new IllegalArgumentException(" Bad offset and/or length data.length = " + data.length + " offset = " + offset + " length = " + length);
-      }
-      this.data = data;
-      this.offset = offset;
-      this.length = length;
-    }
-
-    /**
-     * Creates a new ArrayBytes from the given string. The bytes are determined from
-     * the string using UTF-8 encoding
-     *
-     * @param s String to represent as Bytes
-     */
-    private ArrayBytes(String s) {
-      this(s.getBytes(StandardCharsets.UTF_8));
-    }
-    
-    /**
-     * Creates a new ArrayBytes from the given string. The bytes are determined from
-     * the string using the specified charset
-     *
-     * @param s String to represent as Bytes
-     * @param cs Charset
-     */
-    private ArrayBytes(String s, Charset cs) {
-      this(s.getBytes(cs));
-    }
-
-    /**
-     * Creates a new ArrayBytes based on a ByteBuffer. If the byte buffer has an
-     * array, that array (and the buffer's offset and limit) are used; otherwise,
-     * a new backing array is created and a relative bulk get is performed to
-     * transfer the buffer's contents (starting at its current position and
-     * not beyond its limit).
-     *
-     * @param buffer byte buffer
-     */
-    private ArrayBytes(ByteBuffer buffer) {
-      this.length = buffer.remaining();
-
-      if (buffer.hasArray()) {
-        this.data = buffer.array();
-        this.offset = buffer.position();
-      } else {
-        this.data = new byte[length];
-        this.offset = 0;
-        buffer.get(data);
-      }
-    }
-    
-    @Override
-    public byte byteAt(int i) {
-
-      if (i < 0) {
-        throw new IllegalArgumentException("i < 0, " + i);
-      }
-
-      if (i >= length) {
-        throw new IllegalArgumentException("i >= length, " + i + " >= " + length);
-      }
-
-      return data[offset + i];
-    }
-
-    @Override
-    public byte[] getBackingArray() {
-      return data;
-    }
-
-    @Override
-    public boolean isBackedByArray() {
-      return true;
-    }
-
-    @Override
-    public int length() {
-      return length;
-    }
-
-    @Override
-    public int offset() {
-      return offset;
-    }
-
-    @Override
-    public Bytes subSequence(int start, int end) {
-      if (start > end || start < 0 || end > length) {
-        throw new IllegalArgumentException("Bad start and/end start = " + start + " end=" + end + " offset=" + offset + " length=" + length);
-      }
-      return new ArrayBytes(data, offset + start, end - start);
-    }
-
-    @Override
-    public byte[] toArray() {
-      if (offset == 0 && length == data.length)
-        return data;
-
-      byte[] copy = new byte[length];
-      System.arraycopy(data, offset, copy, 0, length);
-      return copy;
-    }
-
-    /** 
-     * Creates UTF-8 String using Bytes data
-     */
-    @Override
-    public String toString() {
-      return new String(data, offset, length, StandardCharsets.UTF_8);
-    }
-  }
 }
 
 
diff --git a/modules/api/src/main/java/io/fluo/api/data/Column.java b/modules/api/src/main/java/io/fluo/api/data/Column.java
index 24b73cef..060428b9 100644
--- a/modules/api/src/main/java/io/fluo/api/data/Column.java
+++ b/modules/api/src/main/java/io/fluo/api/data/Column.java
@@ -15,17 +15,13 @@
  */
 package io.fluo.api.data;
 
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-
 import com.google.common.base.Preconditions;
-import org.apache.hadoop.io.Writable;
 
 /**
- * Represents Column in Fluo
+ * Represents all or a subset of the column family, column qualifier, and column visibility fields. A column with no fields set is represented by
+ * {@link Column.EMPTY}. Column is immutable after it is created.
  */
-public class Column implements Writable {
+public class Column {
   
   public static final Bytes UNSET = Bytes.wrap(new byte[0]);
   
@@ -163,19 +159,4 @@ public class Column implements Writable {
     }
     return false;
   }
-
-  // TODO remove from public API
-  @Override
-  public void write(DataOutput out) throws IOException {
-    Bytes.write(out, family);
-    Bytes.write(out, qualifier);
-    Bytes.write(out, visibility);    
-  }
-
-  @Override
-  public void readFields(DataInput in) throws IOException {
-    family = Bytes.read(in);
-    qualifier = Bytes.read(in);
-    visibility = Bytes.read(in);
-  }
 }
diff --git a/modules/api/src/main/java/io/fluo/api/data/RowColumn.java b/modules/api/src/main/java/io/fluo/api/data/RowColumn.java
index d5a5ce38..4dc4aa8b 100644
--- a/modules/api/src/main/java/io/fluo/api/data/RowColumn.java
+++ b/modules/api/src/main/java/io/fluo/api/data/RowColumn.java
@@ -18,7 +18,7 @@ package io.fluo.api.data;
 import com.google.common.base.Preconditions;
 
 /**
- * Represents a Row & Column in Fluo. Similar to an Accumulo Key.
+ * Represents all or subset of a Fluo row and {@link Column}.  RowColumn is similar to an Accumulo Key.  RowColumn is immutable after it is created.
  */
 public class RowColumn {
   
@@ -28,14 +28,12 @@ public class RowColumn {
   private Column col = Column.EMPTY;
   
   /** 
-   * Constructs a RowColumn with row set to Bytes.EMPTY
-   * and column set to Column.EMPTY 
+   * Constructs a RowColumn with row set to Bytes.EMPTY and column set to Column.EMPTY 
    */
   public RowColumn() {}
   
   /**
-   * Constructs a RowColumn with only a row.  
-   * Column will be set to Column.EMPTY
+   * Constructs a RowColumn with only a row.  Column will be set to Column.EMPTY
    * 
    * @param row Bytes Row
    */
@@ -45,8 +43,7 @@ public class RowColumn {
   }
   
   /**
-   * Constructs a RowColumn with only a row.
-   * Column will be set to Column.EMPTY
+   * Constructs a RowColumn with only a row. Column will be set to Column.EMPTY
    * 
    * @param row (will be UTF-8 encoded)
    */
diff --git a/modules/api/src/main/java/io/fluo/api/data/Span.java b/modules/api/src/main/java/io/fluo/api/data/Span.java
index b24ce246..17d7f719 100644
--- a/modules/api/src/main/java/io/fluo/api/data/Span.java
+++ b/modules/api/src/main/java/io/fluo/api/data/Span.java
@@ -18,7 +18,7 @@ package io.fluo.api.data;
 import com.google.common.base.Preconditions;
 
 /**
- * Used to specify a span between two row/columns in a Fluo table. Similar to an Accumulo Range.
+ * Represents a range between two {@link RowColumn}s in a Fluo table. Similar to an Accumulo Range. Span is immutable after it is created.
  */
 public class Span {
     
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedSnapshotBase.java b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshotBase.java
index 65051f6b..ba7ff448 100644
--- a/modules/api/src/main/java/io/fluo/api/types/TypedSnapshotBase.java
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshotBase.java
@@ -195,11 +195,7 @@ public class TypedSnapshotBase implements SnapshotBase {
     public ByteBuffer toByteBuffer() {
       if (getBytes() == null)
         return null;
-      if (getBytes().isBackedByArray()) {
-        return ByteBuffer.wrap(getBytes().getBackingArray(), getBytes().offset(), getBytes().length());
-      } else {
-        return ByteBuffer.wrap(getBytes().toArray());
-      }
+      return ByteBuffer.wrap(getBytes().toArray());
     }
 
     public ByteBuffer toByteBuffer(ByteBuffer defaultValue) {
diff --git a/modules/api/src/test/java/io/fluo/api/config/ScannerConfigurationTest.java b/modules/api/src/test/java/io/fluo/api/config/ScannerConfigurationTest.java
deleted file mode 100644
index c5820677..00000000
--- a/modules/api/src/test/java/io/fluo/api/config/ScannerConfigurationTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.config;
-
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-import io.fluo.api.data.Span;
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- * Unit test for ScannerConfiguration class
- */
-public class ScannerConfigurationTest {
-  
-  @Test
-  public void testSetGet() {
-    
-    ScannerConfiguration config = new ScannerConfiguration();
-    Assert.assertEquals(new Span(), config.getSpan());
-    Assert.assertEquals(0, config.getColumns().size());
-    
-    config = new ScannerConfiguration();
-    config.setSpan(Span.exact("row1"));
-    Assert.assertEquals(Span.exact("row1"), config.getSpan());
-    Assert.assertEquals(0, config.getColumns().size());
-    
-    config = new ScannerConfiguration();
-    config.fetchColumnFamily(Bytes.wrap("cf1"));
-    Assert.assertEquals(1, config.getColumns().size());
-    Assert.assertEquals(new Column("cf1"), config.getColumns().iterator().next());
-    
-    config = new ScannerConfiguration();
-    config.fetchColumn(Bytes.wrap("cf2"), Bytes.wrap("cq2"));
-    Assert.assertEquals(1, config.getColumns().size());
-    Assert.assertEquals(new Column("cf2", "cq2"), config.getColumns().iterator().next());
-    
-    config = new ScannerConfiguration();
-    config.fetchColumnFamily(Bytes.wrap("a"));
-    config.fetchColumnFamily(Bytes.wrap("b"));
-    config.fetchColumnFamily(Bytes.wrap("a"));
-    Assert.assertEquals(2, config.getColumns().size());
-    
-    config.clearColumns();
-    Assert.assertEquals(0, config.getColumns().size());
-  }
-  
-  @Test
-  public void testNullSet() {
-    
-    ScannerConfiguration config = new ScannerConfiguration();
-    
-    try {
-      config.setSpan(null);
-      Assert.fail();
-    } catch (NullPointerException e) { }
-    
-    try {
-      config.fetchColumnFamily(null);
-      Assert.fail();
-    } catch (NullPointerException e) { }
-    
-    try {
-      config.fetchColumn(null, Bytes.wrap("qual"));
-      Assert.fail();
-    } catch (NullPointerException e) { }
-    
-    try {
-      config.fetchColumn(Bytes.wrap("fam"), null);
-      Assert.fail();
-    } catch (NullPointerException e) { }
-    
-  }
-}
diff --git a/modules/api/src/test/java/io/fluo/api/data/BytesTest.java b/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
deleted file mode 100644
index e22a719b..00000000
--- a/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.data;
-
-import java.nio.ByteBuffer;
-import java.util.List;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- * Unit test for {@link Bytes}
- */
-public class BytesTest {
-
-  @Test
-  public void testBytesWrap() {
-    
-    String s1 = "test1";
-    Bytes b1 = Bytes.wrap(s1);
-    Assert.assertArrayEquals(s1.getBytes(), b1.toArray());
-    Assert.assertEquals(s1, b1.toString());
-    
-    String s2 = "test2";
-    ByteBuffer bb = ByteBuffer.wrap(s2.getBytes());
-    Bytes b2 = Bytes.wrap(bb);
-    Assert.assertArrayEquals(s2.getBytes(), b2.toArray());
-    Assert.assertEquals(s2, b2.toString());
-    
-    String s3 = "test3";
-    Bytes b3 = Bytes.wrap(s3.getBytes());
-    Assert.assertArrayEquals(s3.getBytes(), b3.toArray());
-    Assert.assertEquals(s3, b3.toString());
-  }
-  
-  @Test
-  public void testConcatSplit() {
-    
-    Bytes b1 = Bytes.wrap("str1");
-    Bytes b2 = Bytes.wrap("string2");
-    Bytes b3 = Bytes.wrap("s3");
-    Bytes ball = Bytes.concat(b1, b2, b3);
-    
-    List<Bytes> blist = Bytes.split(ball);
-    
-    Assert.assertEquals(b1, blist.get(0));
-    Assert.assertEquals(b2, blist.get(1));
-    Assert.assertEquals(b3, blist.get(2));
-  }
-}
diff --git a/modules/api/src/test/java/io/fluo/api/data/ColumnTest.java b/modules/api/src/test/java/io/fluo/api/data/ColumnTest.java
deleted file mode 100644
index 3a1faa24..00000000
--- a/modules/api/src/test/java/io/fluo/api/data/ColumnTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.data;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- * Unit test for {@link Column}
- */
-public class ColumnTest {
-  
-  @Test
-  public void testCreation() {
-    Column col = new Column();
-    Assert.assertFalse(col.isFamilySet());
-    Assert.assertFalse(col.isQualifierSet());
-    Assert.assertFalse(col.isVisibilitySet());
-    Assert.assertSame(Bytes.EMPTY, col.getFamily());
-    Assert.assertSame(Bytes.EMPTY, col.getQualifier());
-    Assert.assertSame(Bytes.EMPTY, col.getVisibility());
-    
-    col = Column.EMPTY;
-    Assert.assertFalse(col.isFamilySet());
-    Assert.assertFalse(col.isQualifierSet());
-    Assert.assertFalse(col.isVisibilitySet());
-    
-    Assert.assertEquals(new Column(), new Column());
-    Assert.assertEquals(Column.EMPTY, Column.EMPTY);
-    Assert.assertEquals(Column.EMPTY, new Column());
-    
-    Assert.assertEquals(new Column("a"), new Column(Bytes.wrap("a")));
-    Assert.assertEquals(new Column("a"), new Column(Bytes.wrap("a"), Bytes.EMPTY, Bytes.EMPTY));
-    Assert.assertEquals(new Column("a").hashCode(), new Column(Bytes.wrap("a"), Bytes.EMPTY, Bytes.EMPTY).hashCode());
-    
-    col = new Column("cf1");
-    Assert.assertTrue(col.isFamilySet());
-    Assert.assertFalse(col.isQualifierSet());
-    Assert.assertFalse(col.isVisibilitySet());
-    Assert.assertEquals(Bytes.wrap("cf1"), col.getFamily());
-    Assert.assertSame(Bytes.EMPTY, col.getQualifier());
-    Assert.assertSame(Bytes.EMPTY, col.getVisibility());
-    Assert.assertEquals(new Column("cf1"), col);
-    
-    col = new Column("cf2", "cq2");
-    Assert.assertTrue(col.isFamilySet());
-    Assert.assertTrue(col.isQualifierSet());
-    Assert.assertFalse(col.isVisibilitySet());
-    Assert.assertEquals(Bytes.wrap("cf2"), col.getFamily());
-    Assert.assertEquals(Bytes.wrap("cq2"), col.getQualifier());
-    Assert.assertSame(Bytes.EMPTY, col.getVisibility());
-    Assert.assertEquals(new Column("cf2", "cq2"), col);
-    
-    col = new Column("cf3", "cq3", "cv3");
-    Assert.assertTrue(col.isFamilySet());
-    Assert.assertTrue(col.isQualifierSet());
-    Assert.assertTrue(col.isVisibilitySet());
-    Assert.assertEquals(Bytes.wrap("cf3"), col.getFamily());
-    Assert.assertEquals(Bytes.wrap("cq3"), col.getQualifier());
-    Assert.assertEquals(Bytes.wrap("cv3"), col.getVisibility());
-    Assert.assertEquals(new Column("cf3", "cq3", "cv3"), col);
-  }
-}
diff --git a/modules/api/src/test/java/io/fluo/api/data/RowColumnTest.java b/modules/api/src/test/java/io/fluo/api/data/RowColumnTest.java
deleted file mode 100644
index b3dc70d8..00000000
--- a/modules/api/src/test/java/io/fluo/api/data/RowColumnTest.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.data;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- * Unit test for {@link RowColumn}
- */
-public class RowColumnTest {
-
-  @Test
-  public void testBasic() {
-   
-    RowColumn rc = new RowColumn();
-    Assert.assertEquals(RowColumn.EMPTY, rc);
-    Assert.assertEquals(Bytes.EMPTY, rc.getRow());
-    Assert.assertEquals(Column.EMPTY, rc.getColumn());
-    Assert.assertEquals("   ", rc.toString());
-    Assert.assertNotEquals(RowColumn.EMPTY, Column.EMPTY);
-    
-    rc = new RowColumn(Bytes.wrap("r1"));
-    Assert.assertEquals(Bytes.wrap("r1"), rc.getRow());
-    Assert.assertEquals(Column.EMPTY, rc.getColumn());
-    Assert.assertEquals(new RowColumn("r1"), rc);
-    Assert.assertEquals("r1   ", rc.toString());
-    
-    rc = new RowColumn("r2", new Column("cf2"));
-    Assert.assertEquals(Bytes.wrap("r2"), rc.getRow());
-    Assert.assertEquals(new Column("cf2"), rc.getColumn());
-    Assert.assertEquals(new RowColumn(Bytes.wrap("r2"), new Column("cf2")), rc);
-    Assert.assertEquals("r2 cf2  ", rc.toString());
-    Assert.assertEquals(132689, rc.hashCode());
-  }
-  
-  @Test
-  public void testFollowing() {
-    byte[] fdata = new String("data1").getBytes();
-    fdata[4] = (byte) 0x00;
-    Bytes fb = Bytes.wrap(fdata);
-    
-    Assert.assertEquals(RowColumn.EMPTY, new RowColumn().following());
-    Assert.assertEquals(new RowColumn(fb), new RowColumn("data").following());
-    Assert.assertEquals(new RowColumn("row", new Column(fb)), new RowColumn("row", new Column("data")).following());
-    Assert.assertEquals(new RowColumn("row", new Column(Bytes.wrap("cf"), fb)), new RowColumn("row", new Column("cf", "data")).following());
-    Assert.assertEquals(new RowColumn("row", new Column(Bytes.wrap("cf"), Bytes.wrap("cq"), fb)), new RowColumn("row", new Column("cf", "cq", "data")).following());
-  }
-}
diff --git a/modules/api/src/test/java/io/fluo/api/data/SpanTest.java b/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
deleted file mode 100644
index 11e8fff8..00000000
--- a/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.data;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- * Unit test for {@link Span}
- */
-public class SpanTest {
-  
-  String rw1s = "rw1";
-  String cf1s = "cf1";
-  String cq1s = "cq1";
-  String cv1s = "cv1";
-  long ts1 = 51;
-  String rw2s = "rw2";
-  String cf2s = "cf2";
-  String cq2s = "cq2";
-  String cv2s = "cv2";
-  long ts2 = 51;  
-  Bytes rw1b = Bytes.wrap(rw1s);
-  Bytes cf1b = Bytes.wrap(cf1s);
-  Bytes cq1b = Bytes.wrap(cq1s);
-  Bytes cv1b = Bytes.wrap(cv1s);
-  Bytes rw2b = Bytes.wrap(rw2s);
-  Bytes cf2b = Bytes.wrap(cf2s);
-  Bytes cq2b = Bytes.wrap(cq2s);
-  Bytes cv2b = Bytes.wrap(cv2s);
-  
-  @Test
-  public void testRowRange() {
-    // Test with Bytes input
-    Assert.assertEquals(new Span(rw1b, true, rw2b, false), 
-        new Span.Builder().startRow(rw1b).endRow(rw2b).exclusive().build());
-    Assert.assertEquals(new Span(rw1b, false, rw2b, false), 
-        new Span.Builder().startRow(rw1b).exclusive().endRow(rw2b).exclusive().build());
-    Assert.assertEquals(new Span(rw1b, true, rw2b, true), 
-        new Span.Builder().startRow(rw1b).endRow(rw2b).build());
-    Assert.assertEquals(new Span(rw1b, false, rw2b, true), 
-        new Span.Builder().startRow(rw1b).exclusive().endRow(rw2b).build());
-    
-    // Test with String input
-    Assert.assertEquals(new Span(rw1b, true, rw2b, false), 
-        new Span.Builder().startRow(rw1s).endRow(rw2s).exclusive().build());
-    Assert.assertEquals(new Span(rw1b, false, rw2b, false), 
-        new Span.Builder().startRow(rw1s).exclusive().endRow(rw2s).exclusive().build());
-    Assert.assertEquals(new Span(rw1b, true, rw2b, true), 
-        new Span.Builder().startRow(rw1s).endRow(rw2s).build());
-    Assert.assertEquals(new Span(rw1b, false, rw2b, true), 
-        new Span.Builder().startRow(rw1s).exclusive().endRow(rw2s).build());
-  }
-  
-  @Test 
-  public void testInfiniteRanges() {
-    RowColumn rc1 = new RowColumn(rw1b, new Column(cf1b));
-    RowColumn frc1 = rc1.following();
-    RowColumn rc2 = new RowColumn(rw2b, new Column(cf2b));
-    RowColumn frc2 = rc2.following();
-    
-    Assert.assertEquals(new Span(RowColumn.EMPTY, true, frc2, false), new Span.Builder().endRow(rw2b).fam(cf2b).build());
-    Assert.assertEquals(new Span(RowColumn.EMPTY, true, rc2, false), new Span.Builder().endRow(rw2b).fam(cf2b).exclusive().build());
-    Assert.assertEquals(new Span(rc1, true, RowColumn.EMPTY, true), new Span.Builder().startRow(rw1b).fam(cf1b).build());
-    Assert.assertEquals(new Span(frc1, true, RowColumn.EMPTY, true), new Span.Builder().startRow(rw1b).fam(cf1b).exclusive().build());   
-  }
-  
-  @Test
-  public void testRowCFRange() {
-    RowColumn rc1 = new RowColumn(rw1b, new Column(cf1b));
-    RowColumn frc1 = rc1.following();
-    RowColumn rc2 = new RowColumn(rw2b, new Column(cf2b));
-    RowColumn frc2 = rc2.following();
-    
-    Assert.assertEquals(new Span(rc1, true, frc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).endRow(rw2b).fam(cf2b).build());
-    Assert.assertEquals(new Span(rc1, true, rc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).endRow(rw2b).fam(cf2b).exclusive().build());
-    Assert.assertEquals(new Span(frc1, true, frc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).exclusive().endRow(rw2b).fam(cf2b).build());
-    Assert.assertEquals(new Span(frc1, true, rc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).exclusive().endRow(rw2b).fam(cf2b).exclusive().build());
-  }
-  
-  @Test
-  public void testRowCFCQRange() {
-    RowColumn rc1 = new RowColumn(rw1b, new Column(cf1b, cq1b));
-    RowColumn frc1 = rc1.following();
-    RowColumn rc2 = new RowColumn(rw2b, new Column(cf2b, cq2b));
-    RowColumn frc2 = rc2.following();
-    
-    Assert.assertEquals(new Span(rc1, true, frc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).qual(cq1b).endRow(rw2b).fam(cf2b).qual(cq2b).build());
-    Assert.assertEquals(new Span(rc1, true, rc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).qual(cq1b).endRow(rw2b).fam(cf2b).qual(cq2b).exclusive().build());
-    Assert.assertEquals(new Span(frc1, true, frc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).qual(cq1b).exclusive().endRow(rw2b).fam(cf2b).qual(cq2b).build());
-    Assert.assertEquals(new Span(frc1, true, rc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).qual(cq1b).exclusive().endRow(rw2b).fam(cf2b).qual(cq2b).exclusive().build());
-  }
-  
-  @Test
-  public void testRowCFCQCVRange() {
-    RowColumn rc1 = new RowColumn(rw1b, new Column(cf1b, cq1b, Bytes.wrap(cv1s)));
-    RowColumn frc1 = rc1.following();
-    RowColumn rc2 = new RowColumn(rw2b, new Column(cf2b, cq2b, Bytes.wrap(cv2s)));
-    RowColumn frc2 = rc2.following();
-    
-    Assert.assertEquals(new Span(rc1, true, frc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).qual(cq1b).vis(cv1b).endRow(rw2b).fam(cf2b).qual(cq2b).vis(cv2b).build());
-    Assert.assertEquals(new Span(rc1, true, rc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).qual(cq1b).vis(cv1b).endRow(rw2b).fam(cf2b).qual(cq2b).vis(cv2b).exclusive().build());
-    Assert.assertEquals(new Span(frc1, true, frc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).qual(cq1b).vis(cv1b).exclusive().endRow(rw2b).fam(cf2b).qual(cq2b).vis(cv2b).build());
-    Assert.assertEquals(new Span(frc1, true, rc2, false), 
-        new Span.Builder().startRow(rw1b).fam(cf1b).qual(cq1b).vis(cv1b).exclusive().endRow(rw2b).fam(cf2b).qual(cq2b).vis(cv2b).exclusive().build());
-  }
-  
-  @Test
-  public void testExactSpan() {
-    Span s = Span.exact(rw1b);
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(Column.EMPTY, s.getStart().getColumn());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(new RowColumn(rw1b).following().getRow(), s.getEnd().getRow());
-    Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
-    Assert.assertFalse(s.isEndInclusive());
-    
-    s = Span.exact(rw1b, Column.EMPTY);
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(Column.EMPTY, s.getStart().getColumn());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(new RowColumn(rw1b).following().getRow(), s.getEnd().getRow());
-    Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
-    Assert.assertFalse(s.isEndInclusive());
-    
-    s = Span.exact(rw1b, new Column(cf1b));
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
-    Assert.assertFalse(s.getStart().getColumn().isQualifierSet());
-    Assert.assertFalse(s.getStart().getColumn().isVisibilitySet());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(rw1b, s.getEnd().getRow());
-    Assert.assertEquals(new RowColumn(rw1b, new Column(cf1b)).following().getColumn().getFamily(),
-                        s.getEnd().getColumn().getFamily());
-    Assert.assertFalse(s.getEnd().getColumn().isQualifierSet());
-    Assert.assertFalse(s.getEnd().getColumn().isVisibilitySet());
-    Assert.assertFalse(s.isEndInclusive());
-    
-    s = Span.exact(rw1b, new Column(cf1b, cq1b));
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
-    Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier()); 
-    Assert.assertFalse(s.getStart().getColumn().isVisibilitySet());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(rw1b, s.getEnd().getRow());
-    Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
-    Assert.assertEquals(new RowColumn(rw1b, new Column(cf1b, cq1b)).following().getColumn().getQualifier(),
-                        s.getEnd().getColumn().getQualifier());
-    Assert.assertFalse(s.getEnd().getColumn().isVisibilitySet());
-    Assert.assertFalse(s.isEndInclusive());
-    
-    s = Span.exact(rw1b, new Column(cf1b, cq1b, cv1b));
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
-    Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier()); 
-    Assert.assertEquals(cv1b, s.getStart().getColumn().getVisibility());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(rw1b, s.getEnd().getRow());
-    Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
-    Assert.assertEquals(cq1b, s.getEnd().getColumn().getQualifier());
-    Assert.assertEquals(new RowColumn(rw1b, new Column(cf1b, cq1b, cv1b)).following().getColumn().getVisibility(),
-                        s.getEnd().getColumn().getVisibility());
-    Assert.assertFalse(s.isEndInclusive());
-  }
-  
-  @Test
-  public void testPrefixSpan() {
-    Span s = Span.prefix(rw1b);
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(Column.EMPTY, s.getStart().getColumn());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(rw2b, s.getEnd().getRow());
-    Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
-    Assert.assertFalse(s.isEndInclusive());
-    
-    s = Span.prefix(rw1b, new Column());
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(Column.EMPTY, s.getStart().getColumn());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(rw2b, s.getEnd().getRow());
-    Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
-    Assert.assertFalse(s.isEndInclusive());
-    
-    s = Span.prefix(rw1b, new Column(cf1b));
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
-    Assert.assertFalse(s.getStart().getColumn().isQualifierSet());
-    Assert.assertFalse(s.getStart().getColumn().isVisibilitySet());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(cf2b, s.getEnd().getColumn().getFamily());
-    Assert.assertFalse(s.getEnd().getColumn().isQualifierSet());
-    Assert.assertFalse(s.getEnd().getColumn().isVisibilitySet());
-    Assert.assertFalse(s.isEndInclusive());
-    
-    s = Span.prefix(rw1b, new Column(cf1b, cq1b));
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
-    Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier());
-    Assert.assertFalse(s.getStart().getColumn().isVisibilitySet());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
-    Assert.assertEquals(cq2b, s.getEnd().getColumn().getQualifier());
-    Assert.assertFalse(s.getEnd().getColumn().isVisibilitySet());
-    Assert.assertFalse(s.isEndInclusive());
-    
-    s = Span.prefix(rw1b, new Column(cf1b, cq1b, cv1b));
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
-    Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier());
-    Assert.assertEquals(cv1b, s.getStart().getColumn().getVisibility());
-    Assert.assertTrue(s.isStartInclusive());
-    Assert.assertEquals(rw1b, s.getStart().getRow());
-    Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
-    Assert.assertEquals(cq1b, s.getEnd().getColumn().getQualifier());
-    Assert.assertEquals(cv2b, s.getEnd().getColumn().getVisibility());
-    Assert.assertFalse(s.isEndInclusive());
-  }
-}
diff --git a/modules/api/src/test/java/io/fluo/api/types/MockSnapshot.java b/modules/api/src/test/java/io/fluo/api/types/MockSnapshot.java
deleted file mode 100644
index e8a41ecc..00000000
--- a/modules/api/src/test/java/io/fluo/api/types/MockSnapshot.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.types;
-
-import io.fluo.api.client.Snapshot;
-
-public class MockSnapshot extends MockSnapshotBase implements Snapshot {
-
-  MockSnapshot(String... entries) {
-    super(entries);
-  }
-
-  @Override
-  public void close() {
-    // no resources need to be closed
-  }
-}
\ No newline at end of file
diff --git a/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java b/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java
deleted file mode 100644
index d8330b8a..00000000
--- a/modules/api/src/test/java/io/fluo/api/types/MockSnapshotBase.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.types;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-import io.fluo.api.client.SnapshotBase;
-import io.fluo.api.config.ScannerConfiguration;
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-import io.fluo.api.iterator.RowIterator;
-
-public class MockSnapshotBase implements SnapshotBase {
-
-  final Map<Bytes,Map<Column,Bytes>> getData;
-
-  /**
-   * Initializes {@link #getData} using {@link #toRCVM(String...)}
-   */
-  MockSnapshotBase(String... entries) {
-    getData = toRCVM(entries);
-  }
-
-  @Override
-  public Bytes get(Bytes row, Column column) {
-    Map<Column,Bytes> cols = getData.get(row);
-    if (cols != null)
-      return cols.get(column);
-
-    return null;
-  }
-
-  @Override
-  public Map<Column,Bytes> get(Bytes row, Set<Column> columns) {
-    Map<Column,Bytes> ret = new HashMap<>();
-    Map<Column,Bytes> cols = getData.get(row);
-    if (cols != null) {
-      for (Column column : columns) {
-        Bytes val = cols.get(column);
-        if (val != null)
-          ret.put(column, val);
-      }
-    }
-    return ret;
-  }
-
-  @Override
-  public Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) {
-
-    Map<Bytes,Map<Column,Bytes>> ret = new HashMap<>();
-
-    for (Bytes row : rows) {
-      Map<Column,Bytes> colMap = get(row, columns);
-      if (colMap != null && colMap.size() > 0) {
-        ret.put(row, colMap);
-      }
-    }
-
-    return ret;
-  }
-
-  @Override
-  public RowIterator get(ScannerConfiguration config) {
-    throw new UnsupportedOperationException();
-  }
-
-  /**
-   * toRCVM stands for "To Row Column Value Map". This is a convenience function that takes strings of the format
-   * {@code <row>,<col fam>:<col qual>[:col vis],<value>} and generates a row, column, value map.
-   */
-  public static Map<Bytes,Map<Column,Bytes>> toRCVM(String... entries) {
-    Map<Bytes,Map<Column,Bytes>> ret = new HashMap<>();
-
-    for (String entry : entries) {
-      String[] rcv = entry.split(",");
-      if (rcv.length != 3 && !(rcv.length == 2 && entry.trim().endsWith(",")))
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
-
-      Bytes row = Bytes.wrap(rcv[0]);
-      String[] colFields = rcv[1].split(":");
-
-      Column col;
-      if (colFields.length == 3) {
-        col = new Column(colFields[0], colFields[1], colFields[2]);
-      } else if (colFields.length == 2) {
-        col = new Column(colFields[0], colFields[1]);
-      } else {
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
-      }
-
-      Bytes val;
-      if (rcv.length == 2)
-        val = Bytes.EMPTY;
-      else
-        val = Bytes.wrap(rcv[2]);
-
-      Map<Column,Bytes> cols = ret.get(row);
-      if (cols == null) {
-        cols = new HashMap<>();
-        ret.put(row, cols);
-      }
-
-      cols.put(col, val);
-    }
-    return ret;
-  }
-
-  /**
-   * toRCM stands for "To Row Column Map". This is a convenience function that takes strings of the format {@code <row>,<col fam>:<col qual>[:col vis]} and
-   * generates a row, column map.
-   */
-  public static Map<Bytes,Set<Column>> toRCM(String... entries) {
-    Map<Bytes,Set<Column>> ret = new HashMap<>();
-
-    for (String entry : entries) {
-      String[] rcv = entry.split(",");
-      if (rcv.length != 2)
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis] but saw : " + entry);
-
-      Bytes row = Bytes.wrap(rcv[0]);
-      String[] colFields = rcv[1].split(":");
-
-      Column col;
-      if (colFields.length == 3) {
-        col = new Column(colFields[0], colFields[1], colFields[2]);
-      } else if (colFields.length == 2) {
-        col = new Column(colFields[0], colFields[1]);
-      } else {
-        throw new IllegalArgumentException("expected <row>,<col fam>:<col qual>[:col vis],<value> but saw : " + entry);
-      }
-
-      Set<Column> cols = ret.get(row);
-      if (cols == null) {
-        cols = new HashSet<>();
-        ret.put(row, cols);
-      }
-
-      cols.add(col);
-    }
-    return ret;
-  }
-}
diff --git a/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java b/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java
deleted file mode 100644
index 8d2604ec..00000000
--- a/modules/api/src/test/java/io/fluo/api/types/MockTransaction.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.types;
-
-import io.fluo.api.client.Transaction;
-import io.fluo.api.exceptions.CommitException;
-
-public class MockTransaction extends MockTransactionBase implements Transaction {
-
-  MockTransaction(String... entries) {
-    super(entries);
-  }
-
-  @Override
-  public void commit() throws CommitException {
-    // does nothing
-  }
-
-  @Override
-  public void close() {
-    // no resources to close
-  }
-}
diff --git a/modules/api/src/test/java/io/fluo/api/types/MockTransactionBase.java b/modules/api/src/test/java/io/fluo/api/types/MockTransactionBase.java
deleted file mode 100644
index 9349f104..00000000
--- a/modules/api/src/test/java/io/fluo/api/types/MockTransactionBase.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.types;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-import io.fluo.api.client.TransactionBase;
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-
-/**
- * A very simple implementation of {@link TransactionBase} used for testing. All reads are serviced from {@link #getData}. Updates are stored in {@link #setData},
- * {@link #deletes}, or {@link #weakNotifications} depending on the update type.
- */
-public class MockTransactionBase extends MockSnapshotBase implements TransactionBase {
-
-  final Map<Bytes,Map<Column,Bytes>> setData = new HashMap<>();
-  final Map<Bytes,Set<Column>> deletes = new HashMap<>();
-  final Map<Bytes,Set<Column>> weakNotifications = new HashMap<>();
-
-  MockTransactionBase(String... entries) {
-    super(entries);
-  }
-
-  @Override
-  public void setWeakNotification(Bytes row, Column col) {
-    Set<Column> cols = weakNotifications.get(row);
-    if (cols == null) {
-      cols = new HashSet<>();
-      weakNotifications.put(row, cols);
-    }
-
-    cols.add(col);
-  }
-
-  @Override
-  public void set(Bytes row, Column col, Bytes value) {
-    Map<Column,Bytes> cols = setData.get(row);
-    if (cols == null) {
-      cols = new HashMap<>();
-      setData.put(row, cols);
-    }
-
-    cols.put(col, value);
-  }
-
-  @Override
-  public void delete(Bytes row, Column col) {
-    Set<Column> cols = deletes.get(row);
-    if (cols == null) {
-      cols = new HashSet<>();
-      deletes.put(row, cols);
-    }
-
-    cols.add(col);
-  }
-}
\ No newline at end of file
diff --git a/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java b/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
deleted file mode 100644
index 2705eea2..00000000
--- a/modules/api/src/test/java/io/fluo/api/types/TypeLayerTest.java
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- * Copyright 2014 Fluo authors (see AUTHORS)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.types;
-
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-import java.util.Map;
-
-import com.google.common.collect.ImmutableSet;
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-import io.fluo.api.types.TypedSnapshotBase.Value;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class TypeLayerTest {
-
-  @Test
-  public void testColumns() throws Exception {
-    TypeLayer tl = new TypeLayer(new StringEncoder());
-
-    MockTransactionBase tt = new MockTransactionBase("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
-        "13,9:19,20", "13,9:20,20");
-
-    TypedTransactionBase ttx = tl.wrap(tt);
-
-    Map<Column,Value> results = ttx.get().row("r2").columns(ImmutableSet.of(new Column("cf2", "6"), new Column("cf2", "7")));
-
-    Assert.assertNull(results.get(new Column("cf2", "6")).toInteger());
-    Assert.assertEquals(0, results.get(new Column("cf2", "6")).toInteger(0));
-    Assert.assertEquals(12, (int) results.get(new Column("cf2", "7")).toInteger());
-    Assert.assertEquals(12, results.get(new Column("cf2", "7")).toInteger(0));
-
-    Assert.assertEquals(1, results.size());
-
-    results = ttx.get().row("r2").columns(ImmutableSet.of(new Column("cf2", "6"), new Column("cf2", "7"), new Column("cf2", "8")));
-
-    Assert.assertNull(results.get(new Column("cf2", "6")).toInteger());
-    Assert.assertEquals(0, results.get(new Column("cf2", "6")).toInteger(0));
-    Assert.assertEquals(12, (int) results.get(new Column("cf2", "7")).toInteger());
-    Assert.assertEquals(12, results.get(new Column("cf2", "7")).toInteger(0));
-    Assert.assertEquals(13, (int) results.get(new Column("cf2", "8")).toInteger());
-    Assert.assertEquals(13, results.get(new Column("cf2", "8")).toInteger(0));
-
-    Assert.assertEquals(2, results.size());
-
-    // test var args
-    Map<Column,Value> results2 = ttx.get().row("r2").columns(new Column("cf2", "6"), new Column("cf2", "7"), new Column("cf2", "8"));
-    Assert.assertEquals(results, results2);
-  }
-
-  @Test
-  public void testVis() throws Exception {
-    TypeLayer tl = new TypeLayer(new StringEncoder());
-
-    MockTransactionBase tt = new MockTransactionBase("r1,cf1:cq1:A,v1", "r1,cf1:cq2:A&B,v2");
-
-    TypedTransactionBase ttx = tl.wrap(tt);
-
-    Assert.assertNull(ttx.get().row("r1").fam("cf1").qual("cq1").toString());
-    Assert.assertEquals("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A").toString());
-    Assert.assertEquals("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A".getBytes()).toString());
-    Assert.assertEquals("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A")).toString());
-    Assert.assertEquals("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A".getBytes())).toString());
-
-    Assert.assertNull("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A&B").toString());
-    Assert.assertNull("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A&B".getBytes()).toString());
-    Assert.assertNull("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A&B")).toString());
-    Assert.assertNull("v1", ttx.get().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A&B".getBytes())).toString());
-
-    Assert.assertEquals("v3", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A&B").toString("v3"));
-    Assert.assertEquals("v3", ttx.get().row("r1").fam("cf1").qual("cq1").vis("A&B".getBytes()).toString("v3"));
-    Assert.assertEquals("v3", ttx.get().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A&B")).toString("v3"));
-    Assert.assertEquals("v3", ttx.get().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A&B".getBytes())).toString("v3"));
-
-    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis("A&B").set(3);
-    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis("A&C".getBytes()).set(4);
-    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A&D")).set(5);
-    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A&F".getBytes())).set(7);
-
-    Assert.assertEquals(MockTransactionBase.toRCVM("r1,cf1:cq1:A&B,3", "r1,cf1:cq1:A&C,4", "r1,cf1:cq1:A&D,5", "r1,cf1:cq1:A&F,7"), tt.setData);
-    tt.setData.clear();
-
-    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis("A&B").delete();
-    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis("A&C".getBytes()).delete();
-    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(Bytes.wrap("A&D")).delete();
-    ttx.mutate().row("r1").fam("cf1").qual("cq1").vis(ByteBuffer.wrap("A&F".getBytes())).delete();
-
-    Assert.assertEquals(MockTransactionBase.toRCM("r1,cf1:cq1:A&B", "r1,cf1:cq1:A&C", "r1,cf1:cq1:A&D", "r1,cf1:cq1:A&F"), tt.deletes);
-    tt.deletes.clear();
-    Assert.assertEquals(0, tt.setData.size());
-    Assert.assertEquals(0, tt.weakNotifications.size());
-
-  }
-
-  @Test
-  public void testBuildColumn() {
-    TypeLayer tl = new TypeLayer(new StringEncoder());
-
-    Assert.assertEquals(new Column("f0", "q0"), tl.bc().fam("f0".getBytes()).qual("q0".getBytes()).vis());
-    Assert.assertEquals(new Column("f0", "q0"), tl.bc().fam("f0").qual("q0").vis());
-    Assert.assertEquals(new Column("5", "7"), tl.bc().fam(5).qual(7).vis());
-    Assert.assertEquals(new Column("5", "7"), tl.bc().fam(5l).qual(7l).vis());
-    Assert.assertEquals(new Column("5", "7"), tl.bc().fam(Bytes.wrap("5")).qual(Bytes.wrap("7")).vis());
-    Assert.assertEquals(new Column("5", "7"), tl.bc().fam(ByteBuffer.wrap("5".getBytes())).qual(ByteBuffer.wrap("7".getBytes())).vis());
-
-    Assert.assertEquals(new Column("f0", "q0", "A&B"), tl.bc().fam("f0".getBytes()).qual("q0".getBytes()).vis("A&B"));
-    Assert.assertEquals(new Column("f0", "q0", "A&C"), tl.bc().fam("f0").qual("q0").vis("A&C".getBytes()));
-    Assert.assertEquals(new Column("5", "7", "A&D"), tl.bc().fam(5).qual(7).vis(Bytes.wrap("A&D")));
-    Assert.assertEquals(new Column("5", "7", "A&D"), tl.bc().fam(5).qual(7).vis(ByteBuffer.wrap("A&D".getBytes())));
-  }
-
-  @Test
-  public void testRead() throws Exception {
-    TypeLayer tl = new TypeLayer(new StringEncoder());
-
-    MockSnapshot ms = new MockSnapshot("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
-        "13,9:19,20", "13,9:20,20", "r3,cf3:cq3,28.195", "r4,cf4:cq4,true");
-
-    TypedSnapshot tts = tl.wrap(ms);
-
-    Assert.assertEquals("v1", tts.get().row("r1").fam("cf1").qual("cq1").toString());
-    Assert.assertEquals("v1", tts.get().row("r1").fam("cf1").qual("cq1").toString("b"));
-    Assert.assertEquals("13", tts.get().row("r2").fam("cf2").qual("8").toString());
-    Assert.assertEquals("13", tts.get().row("r2").fam("cf2").qual("8").toString("b"));
-    Assert.assertEquals("28.195", tts.get().row("r3").fam("cf3").qual("cq3").toString());
-    Assert.assertEquals("28.195", tts.get().row("r3").fam("cf3").qual("cq3").toString("b"));
-    Assert.assertEquals("true", tts.get().row("r4").fam("cf4").qual("cq4").toString());
-    Assert.assertEquals("true", tts.get().row("r4").fam("cf4").qual("cq4").toString("b"));
-
-    // try converting to different types
-    Assert.assertEquals("13", tts.get().row("r2").fam("cf2").qual(8).toString());
-    Assert.assertEquals("13", tts.get().row("r2").fam("cf2").qual(8).toString("b"));
-    Assert.assertEquals((Integer) 13, tts.get().row("r2").fam("cf2").qual(8).toInteger());
-    Assert.assertEquals(13, tts.get().row("r2").fam("cf2").qual(8).toInteger(14));
-    Assert.assertEquals((Long) 13l, (Long) tts.get().row("r2").fam("cf2").qual(8).toLong());
-    Assert.assertEquals(13l, tts.get().row("r2").fam("cf2").qual(8).toLong(14l));
-    Assert.assertEquals("13", new String(tts.get().row("r2").fam("cf2").qual(8).toBytes()));
-    Assert.assertEquals("13", new String(tts.get().row("r2").fam("cf2").qual(8).toBytes("14".getBytes())));
-    Assert.assertEquals("13", new String(tts.get().row("r2").col(new Column("cf2", "8")).toBytes()));
-    Assert.assertEquals("13", new String(tts.get().row("r2").col(new Column("cf2", "8")).toBytes("14".getBytes())));
-    Assert.assertEquals("13", Bytes.wrap(tts.get().row("r2").col(new Column("cf2", "8")).toByteBuffer()).toString());
-    Assert.assertEquals("13", Bytes.wrap(tts.get().row("r2").col(new Column("cf2", "8")).toByteBuffer(ByteBuffer.wrap("14".getBytes()))).toString());
-
-    // test non-existant
-    Assert.assertNull(tts.get().row("r2").fam("cf3").qual(8).toInteger());
-    Assert.assertEquals(14, tts.get().row("r2").fam("cf3").qual(8).toInteger(14));
-    Assert.assertNull(tts.get().row("r2").fam("cf3").qual(8).toLong());
-    Assert.assertEquals(14l, tts.get().row("r2").fam("cf3").qual(8).toLong(14l));
-    Assert.assertNull(tts.get().row("r2").fam("cf3").qual(8).toString());
-    Assert.assertEquals("14", tts.get().row("r2").fam("cf3").qual(8).toString("14"));
-    Assert.assertNull(tts.get().row("r2").fam("cf3").qual(8).toBytes());
-    Assert.assertEquals("14", new String(tts.get().row("r2").fam("cf3").qual(8).toBytes("14".getBytes())));
-    Assert.assertNull(tts.get().row("r2").col(new Column("cf3", "8")).toBytes());
-    Assert.assertEquals("14", new String(tts.get().row("r2").col(new Column("cf3", "8")).toBytes("14".getBytes())));
-    Assert.assertNull(tts.get().row("r2").col(new Column("cf3", "8")).toByteBuffer());
-    Assert.assertEquals("14", Bytes.wrap(tts.get().row("r2").col(new Column("cf3", "8")).toByteBuffer(ByteBuffer.wrap("14".getBytes()))).toString());
-
-    // test float & double
-    Assert.assertEquals((Float) 28.195f, tts.get().row("r3").fam("cf3").qual("cq3").toFloat());
-    Assert.assertEquals(28.195f, tts.get().row("r3").fam("cf3").qual("cq3").toFloat(39.383f), 0.0);
-    Assert.assertEquals((Double) 28.195d, tts.get().row("r3").fam("cf3").qual("cq3").toDouble());
-    Assert.assertEquals(28.195d, tts.get().row("r3").fam("cf3").qual("cq3").toDouble(39.383d), 0.0);
-
-    // test boolean
-    Assert.assertEquals((Boolean) true, tts.get().row("r4").fam("cf4").qual("cq4").toBoolean());
-    Assert.assertEquals(true, tts.get().row("r4").fam("cf4").qual("cq4").toBoolean());
-    Assert.assertEquals((Boolean) true, tts.get().row("r4").fam("cf4").qual("cq4").toBoolean(false));
-    Assert.assertEquals(true, tts.get().row("r4").fam("cf4").qual("cq4").toBoolean(false));
-
-    // try different types for row
-    Assert.assertEquals("20", tts.get().row(13).fam("9").qual("17").toString());
-    Assert.assertEquals("20", tts.get().row(13l).fam("9").qual("17").toString());
-    Assert.assertEquals("20", tts.get().row("13").fam("9").qual("17").toString());
-    Assert.assertEquals("20", tts.get().row("13".getBytes()).fam("9").qual("17").toString());
-    Assert.assertEquals("20", tts.get().row(ByteBuffer.wrap("13".getBytes())).fam("9").qual("17").toString());
-
-    // try different types for cf
-    Assert.assertEquals("20", tts.get().row("13").fam(9).qual("17").toString());
-    Assert.assertEquals("20", tts.get().row("13").fam(9l).qual("17").toString());
-    Assert.assertEquals("20", tts.get().row("13").fam("9").qual("17").toString());
-    Assert.assertEquals("20", tts.get().row("13").fam("9".getBytes()).qual("17").toString());
-    Assert.assertEquals("20", tts.get().row("13").fam(ByteBuffer.wrap("9".getBytes())).qual("17").toString());
-
-    // try different types for cq
-    Assert.assertEquals("20", tts.get().row("13").fam("9").qual("17").toString());
-    Assert.assertEquals("20", tts.get().row("13").fam("9").qual(17l).toString());
-    Assert.assertEquals("20", tts.get().row("13").fam("9").qual(17).toString());
-    Assert.assertEquals("20", tts.get().row("13").fam("9").qual("17".getBytes()).toString());
-    Assert.assertEquals("20", tts.get().row("13").fam("9").qual(ByteBuffer.wrap("17".getBytes())).toString());
-
-    ms.close();
-    tts.close();
-  }
-
-  @Test
-  public void testWrite() throws Exception {
-
-    TypeLayer tl = new TypeLayer(new StringEncoder());
-
-    MockTransactionBase tt = new MockTransactionBase("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
-        "13,9:19,20", "13,9:20,20");
-
-    TypedTransactionBase ttx = tl.wrap(tt);
-
-    // test increments data
-    ttx.mutate().row("13").fam("9").qual("17").increment(1);
-    ttx.mutate().row("13").fam("9").qual(18).increment(2);
-    ttx.mutate().row("13").fam("9").qual(19l).increment(3);
-    ttx.mutate().row("13").fam("9").qual("20".getBytes()).increment(4);
-    ttx.mutate().row("13").fam("9").qual(Bytes.wrap("21")).increment(5); // increment non existant
-    ttx.mutate().row("13").col(new Column("9", "22")).increment(6); // increment non existant
-    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("23".getBytes())).increment(7); // increment non existant
-
-    Assert.assertEquals(MockTransactionBase.toRCVM("13,9:17,21", "13,9:18,22", "13,9:19,23", "13,9:20,24", "13,9:21,5", "13,9:22,6", "13,9:23,7"), tt.setData);
-    tt.setData.clear();
-
-    // test increments long
-    ttx.mutate().row("13").fam("9").qual("17").increment(1l);
-    ttx.mutate().row("13").fam("9").qual(18).increment(2l);
-    ttx.mutate().row("13").fam("9").qual(19l).increment(3l);
-    ttx.mutate().row("13").fam("9").qual("20".getBytes()).increment(4l);
-    ttx.mutate().row("13").fam("9").qual(Bytes.wrap("21")).increment(5l); // increment non existant
-    ttx.mutate().row("13").col(new Column("9", "22")).increment(6l); // increment non existant
-    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("23".getBytes())).increment(7l); // increment non existant
-
-    Assert.assertEquals(MockTransactionBase.toRCVM("13,9:17,21", "13,9:18,22", "13,9:19,23", "13,9:20,24", "13,9:21,5", "13,9:22,6", "13,9:23,7"), tt.setData);
-    tt.setData.clear();
-
-    // test setting data
-    ttx.mutate().row("13").fam("9").qual("16").set();
-    ttx.mutate().row("13").fam("9").qual("17").set(3);
-    ttx.mutate().row("13").fam("9").qual(18).set(4l);
-    ttx.mutate().row("13").fam("9").qual(19l).set("5");
-    ttx.mutate().row("13").fam("9").qual("20".getBytes()).set("6".getBytes());
-    ttx.mutate().row("13").col(new Column("9", "21")).set("7".getBytes());
-    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("22".getBytes())).set(ByteBuffer.wrap("8".getBytes()));
-    ttx.mutate().row("13").fam("9").qual("23").set(2.54f);
-    ttx.mutate().row("13").fam("9").qual("24").set(-6.135d);
-    ttx.mutate().row("13").fam("9").qual("25").set(false);
-
-    Assert.assertEquals(
-MockTransactionBase.toRCVM("13,9:16,", "13,9:17,3", "13,9:18,4", "13,9:19,5", "13,9:20,6", "13,9:21,7", "13,9:22,8", "13,9:23,2.54",
-        "13,9:24,-6.135", "13,9:25,false"), tt.setData);
-    tt.setData.clear();
-
-    // test deleting data
-    ttx.mutate().row("13").fam("9").qual("17").delete();
-    ttx.mutate().row("13").fam("9").qual(18).delete();
-    ttx.mutate().row("13").fam("9").qual(19l).delete();
-    ttx.mutate().row("13").fam("9").qual("20".getBytes()).delete();
-    ttx.mutate().row("13").col(new Column("9", "21")).delete();
-    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("22".getBytes())).delete();
-
-    Assert.assertEquals(MockTransactionBase.toRCM("13,9:17", "13,9:18", "13,9:19", "13,9:20", "13,9:21", "13,9:22"), tt.deletes);
-    tt.deletes.clear();
-    Assert.assertEquals(0, tt.setData.size());
-    Assert.assertEquals(0, tt.weakNotifications.size());
-
-    // test weak notifications
-    ttx.mutate().row("13").fam("9").qual("17").weaklyNotify();
-    ttx.mutate().row("13").fam("9").qual(18).weaklyNotify();
-    ttx.mutate().row("13").fam("9").qual(19l).weaklyNotify();
-    ttx.mutate().row("13").fam("9").qual("20".getBytes()).weaklyNotify();
-    ttx.mutate().row("13").col(new Column("9", "21")).weaklyNotify();
-    ttx.mutate().row("13").fam("9").qual(ByteBuffer.wrap("22".getBytes())).weaklyNotify();
-
-    Assert.assertEquals(MockTransactionBase.toRCM("13,9:17", "13,9:18", "13,9:19", "13,9:20", "13,9:21", "13,9:22"), tt.weakNotifications);
-    tt.weakNotifications.clear();
-    Assert.assertEquals(0, tt.setData.size());
-    Assert.assertEquals(0, tt.deletes.size());
-  }
-
-  @Test
-  public void testMultiRow() throws Exception {
-    TypeLayer tl = new TypeLayer(new StringEncoder());
-
-    MockTransactionBase tt = new MockTransactionBase("11,cf1:cq1,1", "11,cf1:cq2,2", "12,cf1:cq1,3", "12,cf1:cq2,4", "13,cf1:cq1,5", "13,cf1:cq2,6");
-
-    TypedTransactionBase ttx = tl.wrap(tt);
-
-    Bytes br1 = Bytes.wrap("11");
-    Bytes br2 = Bytes.wrap("12");
-    Bytes br3 = Bytes.wrap("13");
-
-    Column c1 = new Column("cf1", "cq1");
-    Column c2 = new Column("cf1", "cq2");
-
-    Map<Bytes,Map<Column,Value>> map1 = ttx.get().rows(Arrays.asList(br1, br2)).columns(c1).toBytesMap();
-
-    Assert.assertEquals("1", map1.get(br1).get(c1).toString());
-    Assert.assertEquals("1", map1.get(br1).get(c1).toString("5"));
-    Assert.assertEquals((Long) (1l), map1.get(br1).get(c1).toLong());
-    Assert.assertEquals(1l, map1.get(br1).get(c1).toLong(5));
-    Assert.assertEquals((Integer) (1), map1.get(br1).get(c1).toInteger());
-    Assert.assertEquals(1, map1.get(br1).get(c1).toInteger(5));
-
-    Assert.assertEquals("5", map1.get(br3).get(c1).toString("5"));
-    Assert.assertNull(map1.get(br3).get(c1).toString());
-    Assert.assertEquals(5l, map1.get(br3).get(c1).toLong(5l));
-    Assert.assertNull(map1.get(br3).get(c1).toLong());
-    Assert.assertEquals(5, map1.get(br1).get(c2).toInteger(5));
-    Assert.assertNull(map1.get(br1).get(c2).toInteger());
-
-    Assert.assertEquals(2, map1.size());
-    Assert.assertEquals(1, map1.get(br1).size());
-    Assert.assertEquals(1, map1.get(br2).size());
-    Assert.assertEquals("3", map1.get(br2).get(c1).toString());
-
-    Map<String,Map<Column,Value>> map2 = ttx.get().rowsString(Arrays.asList("11", "13")).columns(c1).toStringMap();
-
-    Assert.assertEquals(2, map2.size());
-    Assert.assertEquals(1, map2.get("11").size());
-    Assert.assertEquals(1, map2.get("13").size());
-    Assert.assertEquals((Long) (1l), map2.get("11").get(c1).toLong());
-    Assert.assertEquals(5l, map2.get("13").get(c1).toLong(6));
-
-    Map<Long,Map<Column,Value>> map3 = ttx.get().rowsLong(Arrays.asList(11l, 13l)).columns(c1).toLongMap();
-
-    Assert.assertEquals(2, map3.size());
-    Assert.assertEquals(1, map3.get(11l).size());
-    Assert.assertEquals(1, map3.get(13l).size());
-    Assert.assertEquals((Long) (1l), map3.get(11l).get(c1).toLong());
-    Assert.assertEquals(5l, map3.get(13l).get(c1).toLong(6));
-
-    Map<Integer,Map<Column,Value>> map4 = ttx.get().rowsInteger(Arrays.asList(11, 13)).columns(c1).toIntegerMap();
-
-    Assert.assertEquals(2, map4.size());
-    Assert.assertEquals(1, map4.get(11).size());
-    Assert.assertEquals(1, map4.get(13).size());
-    Assert.assertEquals((Long) (1l), map4.get(11).get(c1).toLong());
-    Assert.assertEquals(5l, map4.get(13).get(c1).toLong(6));
-
-    Map<Integer,Map<Column,Value>> map5 = ttx.get().rowsBytes(Arrays.asList("11".getBytes(), "13".getBytes())).columns(c1).toIntegerMap();
-
-    Assert.assertEquals(2, map5.size());
-    Assert.assertEquals(1, map5.get(11).size());
-    Assert.assertEquals(1, map5.get(13).size());
-    Assert.assertEquals((Long) (1l), map5.get(11).get(c1).toLong());
-    Assert.assertEquals(5l, map5.get(13).get(c1).toLong(6));
-
-    Map<Integer,Map<Column,Value>> map6 = ttx.get().rowsByteBuffers(Arrays.asList(ByteBuffer.wrap("11".getBytes()), ByteBuffer.wrap("13".getBytes())))
-        .columns(c1).toIntegerMap();
-
-    Assert.assertEquals(2, map6.size());
-    Assert.assertEquals(1, map6.get(11).size());
-    Assert.assertEquals(1, map6.get(13).size());
-    Assert.assertEquals((Long) (1l), map6.get(11).get(c1).toLong());
-    Assert.assertEquals(5l, map6.get(13).get(c1).toLong(6));
-
-  }
-
-  @Test
-  public void testBasic() throws Exception {
-    TypeLayer tl = new TypeLayer(new StringEncoder());
-
-    MockTransactionBase tt = new MockTransactionBase("r1,cf1:cq1,v1", "r1,cf1:cq2,v2", "r1,cf1:cq3,9", "r2,cf2:7,12", "r2,cf2:8,13", "13,9:17,20", "13,9:18,20",
-        "13,9:19,20", "13,9:20,20");
-
-    TypedTransactionBase ttx = tl.wrap(tt);
-
-    Assert.assertEquals(Bytes.wrap("12"), ttx.get(Bytes.wrap("r2"), new Column("cf2", "7")));
-    Assert.assertNull(ttx.get(Bytes.wrap("r2"), new Column("cf2", "9")));
-
-    Map<Column,Bytes> map = ttx.get(Bytes.wrap("r2"), ImmutableSet.of(new Column("cf2", "7"), new Column("cf2", "8")));
-    Assert.assertEquals(2, map.size());
-    Assert.assertEquals("12", map.get(new Column("cf2", "7")).toString());
-    Assert.assertEquals("13", map.get(new Column("cf2", "8")).toString());
-
-    map = ttx.get(Bytes.wrap("r6"), ImmutableSet.of(new Column("cf2", "7"), new Column("cf2", "8")));
-    Assert.assertEquals(0, map.size());
-
-    ttx.set(Bytes.wrap("r6"), new Column("cf2", "7"), Bytes.wrap("3"));
-    Assert.assertEquals(MockTransactionBase.toRCVM("r6,cf2:7,3"), tt.setData);
-    tt.setData.clear();
-
-    Map<Bytes,Map<Column,Bytes>> map2 = ttx.get(ImmutableSet.of(Bytes.wrap("r1"), Bytes.wrap("r2")),
-        ImmutableSet.of(new Column("cf1", "cq1"), new Column("cf2", "8")));
-    Assert.assertEquals(MockTransactionBase.toRCVM("r1,cf1:cq1,v1", "r2,cf2:8,13"), map2);
-
-    ttx.delete(Bytes.wrap("r6"), new Column("cf2", "7"));
-    Assert.assertEquals(MockTransactionBase.toRCM("r6,cf2:7"), tt.deletes);
-    tt.deletes.clear();
-
-    ttx.setWeakNotification(Bytes.wrap("r6"), new Column("cf2", "8"));
-    Assert.assertEquals(MockTransactionBase.toRCM("r6,cf2:8"), tt.weakNotifications);
-    tt.weakNotifications.clear();
-
-  }
-}
