diff --git a/modules/api/pom.xml b/modules/api/pom.xml
new file mode 100644
index 00000000..e0ac1584
--- /dev/null
+++ b/modules/api/pom.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>fluo</groupId>
+    <artifactId>fluo-parent</artifactId>
+    <version>1.0.0-alpha-1-SNAPSHOT</version>
+    <relativePath>../../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>fluo-api</artifactId>
+  <packaging>jar</packaging>
+
+  <name>API</name>
+
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-failsafe-plugin</artifactId>
+      </plugin>
+    </plugins>
+  </build>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-api</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-log4j12</artifactId>
+      <scope>compile</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.hadoop</groupId>
+      <artifactId>hadoop-client</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.accumulo</groupId>
+      <artifactId>accumulo-core</artifactId>
+    </dependency>
+
+    <!-- Test Dependencies -->
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/modules/api/src/main/java/io/fluo/api/client/FluoAdmin.java b/modules/api/src/main/java/io/fluo/api/client/FluoAdmin.java
new file mode 100644
index 00000000..59c38ca6
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/client/FluoAdmin.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.client;
+
+import java.util.Properties;
+
+/**
+ * Fluo Administration
+ */
+public interface FluoAdmin {
+
+  public static class AlreadyInitializedException extends Exception {
+    private static final long serialVersionUID = 1L;
+
+    public AlreadyInitializedException(Exception e) {
+      super(e);
+    }
+  }
+
+  public void initialize(Properties props) throws AlreadyInitializedException;
+
+  public void updateWorkerConfig(Properties props);
+}
diff --git a/modules/api/src/main/java/io/fluo/api/client/FluoClient.java b/modules/api/src/main/java/io/fluo/api/client/FluoClient.java
new file mode 100644
index 00000000..927786c8
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/client/FluoClient.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.client;
+
+import java.io.Closeable;
+
+/**
+ * Client interface for Fluo. Fluo clients will have shared resources 
+ * used by all objects created by the client.  Therefore, close() must 
+ * called when you are finished using a client.
+ */
+public interface FluoClient extends Closeable {
+  
+  public LoaderExecutor newLoaderExecutor();
+  
+  public Snapshot newSnapshot();
+  
+  public void close();
+  
+}
\ No newline at end of file
diff --git a/modules/api/src/main/java/io/fluo/api/client/FluoFactory.java b/modules/api/src/main/java/io/fluo/api/client/FluoFactory.java
new file mode 100644
index 00000000..47db7643
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/client/FluoFactory.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.client;
+
+import java.util.Properties;
+
+import io.fluo.api.config.ConnectionProperties;
+import io.fluo.api.config.InitializationProperties;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Factory for creating FluoClient objects
+ */
+public class FluoFactory {
+
+  private static Logger log = LoggerFactory.getLogger(FluoFactory.class);
+
+  /**
+   * Create a Fluo client 
+   * 
+   * @param props see {@link io.fluo.api.config.ConnectionProperties}
+   * @return FluoClient
+   */
+  public static FluoClient newClient(Properties props) {
+    String clientClassName = props.getProperty(ConnectionProperties.CLIENT_CLASS_PROP, 
+                                               ConnectionProperties.DEFAULT_CLIENT_CLASS);
+    try {
+      return (FluoClient) Class.forName(clientClassName).getDeclaredConstructor(Properties.class).newInstance(props);
+    } catch (Exception e) {
+      log.error("Could not instantiate Client class - " + clientClassName);
+      throw new IllegalStateException(e);
+    }
+  }
+  
+  /**
+   * Create a FluoAdmin client
+   * 
+   * @param props see {@link io.fluo.api.config.InitializationProperties}
+   * @return FluoAdmin
+   */
+  public static FluoAdmin newAdmin(Properties props) {
+    String adminClassName = props.getProperty(InitializationProperties.ADMIN_CLASS_PROP, 
+                                               InitializationProperties.DEFAULT_ADMIN_CLASS);
+    try {
+      return (FluoAdmin) Class.forName(adminClassName).newInstance();
+    } catch (Exception e) {
+      log.error("Could not instantiate Admin class - " + adminClassName);
+      throw new IllegalStateException(e);
+    }
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/client/Loader.java b/modules/api/src/main/java/io/fluo/api/client/Loader.java
new file mode 100644
index 00000000..5f629796
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/client/Loader.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.client;
+
+/**
+ * Interface that needs to be implemented to load data into Fluo
+ */
+public interface Loader {
+  
+  /**
+   * Users implement this method to load data into Fluo using
+   * the provided transaction.  The transaction will be committed
+   * after method returns
+   * 
+   * @param tx Transaction provided for loading data
+   * @throws Exception
+   */
+  public abstract void load(Transaction tx) throws Exception;
+}
diff --git a/modules/api/src/main/java/io/fluo/api/client/LoaderExecutor.java b/modules/api/src/main/java/io/fluo/api/client/LoaderExecutor.java
new file mode 100644
index 00000000..a543ad36
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/client/LoaderExecutor.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.client;
+
+/**
+ * Executes Fluo Loader classes 
+ */
+public interface LoaderExecutor {
+
+  public void execute(Loader loader);
+
+  public void shutdown();
+}
diff --git a/modules/api/src/main/java/io/fluo/api/client/Snapshot.java b/modules/api/src/main/java/io/fluo/api/client/Snapshot.java
new file mode 100644
index 00000000..ad9148dd
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/client/Snapshot.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.client;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
+import io.fluo.api.config.ScannerConfiguration;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.iterator.RowIterator;
+
+/**
+ * Implementations of this interface should provide snapshot isolation across rows when reading from a table.
+ */
+public interface Snapshot {
+
+  public abstract Bytes get(Bytes row, Column column) throws Exception;
+
+  public abstract Map<Column,Bytes> get(Bytes row, Set<Column> columns) throws Exception;
+
+  public abstract Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) throws Exception;
+
+  public abstract RowIterator get(ScannerConfiguration config) throws Exception;
+}
diff --git a/modules/api/src/main/java/io/fluo/api/client/Transaction.java b/modules/api/src/main/java/io/fluo/api/client/Transaction.java
new file mode 100644
index 00000000..83d55918
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/client/Transaction.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.client;
+
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+
+/**
+ * Transaction interface
+ */
+public interface Transaction extends Snapshot {
+  
+  public abstract void setWeakNotification(Bytes row, Column col);
+
+  public abstract void set(Bytes row, Column col, Bytes value);
+  
+  public abstract void delete(Bytes row, Column col);
+  
+}
diff --git a/modules/api/src/main/java/io/fluo/api/config/ConnectionProperties.java b/modules/api/src/main/java/io/fluo/api/config/ConnectionProperties.java
new file mode 100644
index 00000000..6f5cd006
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/config/ConnectionProperties.java
@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.config;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Properties;
+import java.util.Set;
+
+/**
+ * The class helps create a properties object with the key/values required to connect to a Fluo instance.
+ */
+public class ConnectionProperties extends Properties {
+  
+  private static final long serialVersionUID = 1L;
+  
+  public static final String FLUO_PREFIX = "io.fluo";
+
+  public static final String ACCUMULO_PASSWORD_PROP = FLUO_PREFIX + ".accumulo.password";
+  public static final String ACCUMULO_USER_PROP = FLUO_PREFIX + ".accumulo.user";
+  public static final String ACCUMULO_INSTANCE_PROP = FLUO_PREFIX + ".accumulo.instance";
+
+  public static final String ZOOKEEPER_ROOT_PROP = FLUO_PREFIX + ".zookeeper.root";
+  public static final String ZOOKEEPER_TIMEOUT_PROP = FLUO_PREFIX + ".zookeeper.timeout";
+  public static final String ZOOKEEPER_CONNECT_PROP = FLUO_PREFIX + ".zookeeper.connect";
+  
+  public static final String CLIENT_CLASS_PROP = FLUO_PREFIX + ".client.class";
+  public static final String DEFAULT_CLIENT_CLASS = FLUO_PREFIX + ".core.client.FluoClientImpl";
+  
+  public ConnectionProperties() {
+    super(getDefaultProperties());
+  }
+  
+  public ConnectionProperties(File file) throws FileNotFoundException, IOException {
+    this();
+    load(new FileInputStream(file));
+  }
+
+  public ConnectionProperties(Properties props) {
+    super(props);
+    Set<java.util.Map.Entry<Object,Object>> es = getDefaultProperties().entrySet();
+    for (java.util.Map.Entry<Object,Object> entry : es) {
+      setDefault((String) entry.getKey(), (String) entry.getValue());
+    }
+  }
+
+  public ConnectionProperties setZookeepers(String zookeepers) {
+    setProperty(ZOOKEEPER_CONNECT_PROP, zookeepers);
+    return this;
+  }
+  
+  public ConnectionProperties setTimeout(int timeout) {
+    setProperty(ZOOKEEPER_TIMEOUT_PROP, timeout + "");
+    return this;
+  }
+  
+  public ConnectionProperties setZookeeperRoot(String zookeeperRoot) {
+    setProperty(ZOOKEEPER_ROOT_PROP, zookeeperRoot);
+    return this;
+  }
+  
+  public ConnectionProperties setAccumuloInstance(String accumuloInstance) {
+    setProperty(ACCUMULO_INSTANCE_PROP, accumuloInstance);
+    return this;
+  }
+  
+  public ConnectionProperties setAccumuloUser(String accumuloUser) {
+    setProperty(ACCUMULO_USER_PROP, accumuloUser);
+    return this;
+  }
+  
+  public ConnectionProperties setAccumuloPassword(String accumuloPassword) {
+    setProperty(ACCUMULO_PASSWORD_PROP, accumuloPassword);
+    return this;
+  }
+    
+  protected void setDefault(String key, String val) {
+    if (getProperty(key) == null)
+      setProperty(key, val);
+  }
+  
+  public static Properties getDefaultProperties() {
+    Properties props = new Properties();
+    setDefaultProperties(props);
+    return props;
+  }
+  
+  public static void setDefaultProperties(Properties props) {
+      props.put(ZOOKEEPER_CONNECT_PROP, "localhost");
+      props.put(ZOOKEEPER_ROOT_PROP, "/fluo");
+      props.put(ZOOKEEPER_TIMEOUT_PROP, "30000");
+      props.put(ACCUMULO_INSTANCE_PROP, "accumulo1");
+      props.put(ACCUMULO_USER_PROP, "fluo");
+      props.put(ACCUMULO_PASSWORD_PROP, "secret"); 
+      props.put(CLIENT_CLASS_PROP, DEFAULT_CLIENT_CLASS);
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/config/InitializationProperties.java b/modules/api/src/main/java/io/fluo/api/config/InitializationProperties.java
new file mode 100644
index 00000000..098b52c1
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/config/InitializationProperties.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.config;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Properties;
+
+/**
+ * Properties for Initializing Fluo Instance
+ */
+public class InitializationProperties extends WorkerProperties {
+  private static final long serialVersionUID = 1L;
+
+  public static final String CLEAR_ZOOKEEPER_PROP = FLUO_PREFIX + ".init.zookeeper.clear";
+  public static final String TABLE_PROP = FLUO_PREFIX + ".init.accumulo.table";
+  public static final String CLASSPATH_PROP = FLUO_PREFIX + ".init.accumulo.classpath";
+  
+  public static final String ADMIN_CLASS_PROP = FLUO_PREFIX + ".admin.class";
+  public static final String DEFAULT_ADMIN_CLASS = FLUO_PREFIX + ".core.client.FluoAdminImpl";
+
+  private void setDefaults() {
+    setDefault(CLEAR_ZOOKEEPER_PROP, "false");
+    setDefault(ADMIN_CLASS_PROP, DEFAULT_ADMIN_CLASS);
+  }
+
+  public InitializationProperties() {
+    super();
+  }
+
+  public InitializationProperties(File file) throws FileNotFoundException, IOException {
+    super(file);
+    setDefaults();
+  }
+
+  public InitializationProperties(Properties props) {
+    super(props);
+    setDefaults();
+  }
+
+  public InitializationProperties setAccumuloTable(String table) {
+    setProperty(TABLE_PROP, table);
+    return this;
+  }
+
+  public InitializationProperties setAccumuloClasspath(String path) {
+    setProperty(CLASSPATH_PROP, path);
+    return this;
+  }
+
+  public InitializationProperties setClearZookeeper(boolean clear) {
+    setProperty(CLEAR_ZOOKEEPER_PROP, clear + "");
+    return this;
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/config/LoaderExecutorProperties.java b/modules/api/src/main/java/io/fluo/api/config/LoaderExecutorProperties.java
new file mode 100644
index 00000000..15055515
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/config/LoaderExecutorProperties.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.config;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Properties;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * This class helps setting the properties need to create a {@link LoaderExecutor}
+ */
+public class LoaderExecutorProperties extends ConnectionProperties implements TransactionConfiguration {
+
+  private static final long serialVersionUID = 1L;
+  public static final String NUM_THREADS_PROP = FLUO_PREFIX + ".loader.executor.numThreads";
+  public static final String QUEUE_SIZE_PROP = FLUO_PREFIX + ".loader.executor.queueSize";
+  
+  public LoaderExecutorProperties() {
+    super();
+  }
+
+  public LoaderExecutorProperties(File file) throws FileNotFoundException, IOException {
+    super(file);
+    setDefaults();
+  }
+  
+  public LoaderExecutorProperties(Properties props) {
+    super(props);
+    setDefaults();
+  }
+
+  public LoaderExecutorProperties setNumThreads(int numThreads) {
+    setProperty(NUM_THREADS_PROP, numThreads + "");
+    return this;
+  }
+  
+  public LoaderExecutorProperties setQueueSize(int queueSize) {
+    setProperty(QUEUE_SIZE_PROP, queueSize + "");
+    return this;
+  }
+
+  private void setDefaults() {
+    setDefault(NUM_THREADS_PROP, "10");
+    setDefault(QUEUE_SIZE_PROP, "10");
+  }
+
+  @Override
+  public void setRollbackTime(long time, TimeUnit tu) {
+    // TODO implement this, currently only gets rollback time for worker props in zookeeper
+    throw new UnsupportedOperationException();
+  }
+
+}
diff --git a/modules/api/src/main/java/io/fluo/api/config/ObserverConfiguration.java b/modules/api/src/main/java/io/fluo/api/config/ObserverConfiguration.java
new file mode 100644
index 00000000..756164c9
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/config/ObserverConfiguration.java
@@ -0,0 +1,29 @@
+package io.fluo.api.config;
+
+import java.util.Collections;
+import java.util.Map;
+
+public class ObserverConfiguration {
+  private String className;
+  private Map<String,String> params = Collections.emptyMap();
+
+  public ObserverConfiguration(String className) {
+    this.className = className;
+  }
+
+  public String getClassName() {
+    return className;
+  }
+
+  public ObserverConfiguration setParameters(Map<String,String> params) {
+    if (params == null)
+      throw new IllegalArgumentException();
+    this.params = params;
+    return this;
+  }
+
+  public Map<String,String> getParameters() {
+    return params;
+  }
+
+}
diff --git a/modules/api/src/main/java/io/fluo/api/config/OracleProperties.java b/modules/api/src/main/java/io/fluo/api/config/OracleProperties.java
new file mode 100644
index 00000000..419fbf9e
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/config/OracleProperties.java
@@ -0,0 +1,47 @@
+package io.fluo.api.config;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Properties;
+
+public class OracleProperties extends ConnectionProperties {
+ 
+  private static final long serialVersionUID = 1L;
+ 
+  public static final String ORACLE_PORT_PROP = FLUO_PREFIX + ".oracle.port";
+  public static final String ORACLE_MAX_MEMORY_PROP = FLUO_PREFIX + ".oracle.max.memory.mb";
+
+  public static final int ORACLE_DEFAULT_PORT = 9913;
+  
+  public OracleProperties() {
+    super();
+    setDefaults();
+  }
+
+  public OracleProperties(File file) throws FileNotFoundException, IOException {
+    this();
+    load(new FileInputStream(file));
+    setDefaults();
+  }
+
+  public OracleProperties(Properties props) {
+    super(props);
+    setDefaults();
+  }
+
+  public OracleProperties setOracleMaxMemory(String oracleMaxMemory) {
+    setProperty(OracleProperties.ORACLE_MAX_MEMORY_PROP, oracleMaxMemory);
+    return this;
+  }
+
+  public OracleProperties setOraclePort(int oraclePort) {
+    setProperty(OracleProperties.ORACLE_PORT_PROP, Integer.toString(oraclePort));
+    return this;
+  }
+  
+  private void setDefaults() {
+    setDefault(ORACLE_PORT_PROP, ORACLE_DEFAULT_PORT+"");
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/config/ScannerConfiguration.java b/modules/api/src/main/java/io/fluo/api/config/ScannerConfiguration.java
new file mode 100644
index 00000000..f65ad7da
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/config/ScannerConfiguration.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.config;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.data.Span;
+import org.apache.accumulo.core.util.ArgumentChecker;
+
+/**
+ * Configures Scanner
+ */
+public class ScannerConfiguration implements Cloneable {
+
+  private Span span = new Span();
+  // TODO use a set
+  private ArrayList<Column> columns = new ArrayList<Column>();
+
+  public ScannerConfiguration setSpan(Span span) {
+    this.span = span;
+    return this;
+  }
+
+  public Span getSpan() {
+    return span;
+  }
+
+  public List<Column> getColumns() {
+    return Collections.unmodifiableList(columns);
+  }
+
+  // TODO document SnapshotIterator
+
+  public ScannerConfiguration fetchColumnFamily(Bytes col) {
+    ArgumentChecker.notNull(col);
+    // TODO causes NPE w/ set, add unit test
+    columns.add(new Column(col, null));
+    return this;
+  }
+
+  public ScannerConfiguration fetchColumn(Bytes colFam, Bytes colQual) {
+    ArgumentChecker.notNull(colFam, colQual);
+    columns.add(new Column(colFam, colQual));
+    return this;
+  }
+
+  public void clearColumns() {
+    columns.clear();
+  }
+
+  @SuppressWarnings("unchecked")
+  public Object clone() throws CloneNotSupportedException {
+    ScannerConfiguration sc = (ScannerConfiguration) super.clone();
+
+    sc.columns = (ArrayList<Column>) columns.clone();
+    sc.span = span;
+
+    return sc;
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/config/TransactionConfiguration.java b/modules/api/src/main/java/io/fluo/api/config/TransactionConfiguration.java
new file mode 100644
index 00000000..dced4d17
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/config/TransactionConfiguration.java
@@ -0,0 +1,14 @@
+package io.fluo.api.config;
+
+import java.util.concurrent.TimeUnit;
+
+import static io.fluo.api.config.ConnectionProperties.FLUO_PREFIX;
+
+public interface TransactionConfiguration {
+  public static final String TRANSACTION_PREFIX = FLUO_PREFIX + ".tx";
+  public static final String ROLLBACK_TIME_PROP = TRANSACTION_PREFIX + ".rollbackTime";
+  
+  public static final long ROLLBACK_TIME_DEFAULT = 300000;
+
+  public void setRollbackTime(long time, TimeUnit tu);
+}
diff --git a/modules/api/src/main/java/io/fluo/api/config/WorkerProperties.java b/modules/api/src/main/java/io/fluo/api/config/WorkerProperties.java
new file mode 100644
index 00000000..f66bcb40
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/config/WorkerProperties.java
@@ -0,0 +1,125 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.config;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Properties to configure Fluo Workers
+ */
+public class WorkerProperties extends ConnectionProperties implements TransactionConfiguration {
+
+  private static final long serialVersionUID = 1L;
+  public static final String WORKER_PREFIX = FLUO_PREFIX + ".worker";
+  public static final String WORKER_NUM_THREADS_PROP = WORKER_PREFIX + ".numThreads";
+  public static final String OBSERVER_PREFIX_PROP = WORKER_PREFIX + ".observer.";
+  public static final String WORKER_INSTANCES_PROP = WORKER_PREFIX + ".instances";
+  public static final String WORKER_MAX_MEMORY_PROP = WORKER_PREFIX + ".max.memory.mb";
+  
+  public WorkerProperties() {
+    super();
+    setDefaults();
+  }
+
+  public WorkerProperties(File file) throws FileNotFoundException, IOException {
+    this();
+    load(new FileInputStream(file));
+    setDefaults();
+  }
+
+  public WorkerProperties(Properties props) {
+    super(props);
+    setDefaults();
+  }
+
+  private void setDefaults() {
+    setDefault(WORKER_NUM_THREADS_PROP, "10");
+    setDefault(ROLLBACK_TIME_PROP, ROLLBACK_TIME_DEFAULT + "");
+  }
+
+  public WorkerProperties setNumThreads(int num) {
+    if (num <= 0)
+      throw new IllegalArgumentException("Must be positive " + num);
+    setProperty(WORKER_NUM_THREADS_PROP, num + "");
+    return this;
+  }
+
+  public WorkerProperties setObservers(List<ObserverConfiguration> observers) {
+    String prefix = OBSERVER_PREFIX_PROP;
+
+    Iterator<java.util.Map.Entry<Object,Object>> iter = entrySet().iterator();
+    while (iter.hasNext()) {
+      String key = iter.next().getKey().toString();
+      if (key.startsWith(prefix) && key.substring(prefix.length()).matches("\\d+")) {
+        iter.remove();
+      }
+    }
+
+    int count = 0;
+    for (ObserverConfiguration oconf : observers) {
+
+      Map<String,String> params = oconf.getParameters();
+      StringBuilder paramString = new StringBuilder();
+      for (java.util.Map.Entry<String,String> pentry : params.entrySet()) {
+        paramString.append(',');
+        paramString.append(pentry.getKey());
+        paramString.append('=');
+        paramString.append(pentry.getValue());
+      }
+
+      setProperty(prefix + "" + count, oconf.getClassName() + paramString);
+      count++;
+    }
+
+    return this;
+  }
+
+  @Override
+  public void setRollbackTime(long time, TimeUnit tu) {
+    setProperty(ROLLBACK_TIME_PROP, tu.toMillis(time) + "");
+  }
+
+  public WorkerProperties setWorkerInstances(String workerInstances) {
+    setProperty(WorkerProperties.WORKER_INSTANCES_PROP, workerInstances);
+    return this;
+  }
+
+  public WorkerProperties setWorkerMaxMemory(String workerMaxMemory) {
+    setProperty(WorkerProperties.WORKER_MAX_MEMORY_PROP, workerMaxMemory);
+    return this;
+  }
+  
+  public static Properties getDefaultProperties() {
+    Properties props = new Properties();
+    setDefaultProperties(props);
+    return props;
+  }
+  
+  public static void setDefaultProperties(Properties props) {
+      props.put(WORKER_NUM_THREADS_PROP, "10");
+      props.put(WORKER_INSTANCES_PROP, "1");
+      props.put(WORKER_MAX_MEMORY_PROP, "256");
+  }
+}
\ No newline at end of file
diff --git a/modules/api/src/main/java/io/fluo/api/data/Bytes.java b/modules/api/src/main/java/io/fluo/api/data/Bytes.java
new file mode 100644
index 00000000..d5d60ec4
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/data/Bytes.java
@@ -0,0 +1,307 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+
+import io.fluo.api.data.impl.ArrayBytes;
+import org.apache.hadoop.io.WritableUtils;
+
+/**
+ * Represents a sequence of bytes in Fluo
+ */
+public abstract class Bytes implements Comparable<Bytes> {
+  
+  public static final Bytes EMPTY = Bytes.wrap(new byte[0]);
+
+  /**
+   * Gets a byte within this sequence of bytes
+   *
+   * @param i index into sequence
+   * @return byte
+   * @throws IllegalArgumentException if i is out of range
+   */
+  public abstract byte byteAt(int i);
+
+  /**
+   * Gets the length of this sequence.
+   *
+   * @return sequence length
+   */
+  public abstract int length();
+
+  /**
+   * Returns a portion of this bytes sequence.
+   *
+   * @param start index of subsequence start (inclusive)
+   * @param end index of subsequence end (exclusive)
+   */
+  public abstract Bytes subSequence(int start, int end);
+
+  /**
+   * Returns a byte array containing the bytes in this sequence. This method
+   * may copy the sequence data or may return a backing byte array directly.
+   *
+   * @return byte array
+   */
+  public abstract byte[] toArray();
+  
+  /**
+   * Determines whether this sequence is backed by a byte array.
+   *
+   * @return true if sequence is backed by a byte array
+   */
+  public abstract boolean isBackedByArray();
+
+  /**
+   * Gets the backing byte array for this sequence.
+   *
+   * @return byte array
+   */
+  public abstract byte[] getBackingArray();
+
+  /**
+   * Gets the offset for this byte sequence. This value represents the starting
+   * point for the sequence in the backing array, if there is one.
+   *
+   * @return offset (inclusive)
+   */
+  public abstract int offset();
+
+  /**
+   * Compares the two given byte sequences, byte by byte, returning a negative,
+   * zero, or positive result if the first sequence is less than, equal to, or
+   * greater than the second. The comparison is performed starting with the
+   * first byte of each sequence, and proceeds until a pair of bytes differs,
+   * or one sequence runs out of byte (is shorter). A shorter sequence is
+   * considered less than a longer one.
+   *
+   * @param b1 first byte sequence to compare
+   * @param b2 second byte sequence to compare
+   * @return comparison result
+   */
+  public static int compareBytes(Bytes b1, Bytes b2) {
+
+    int minLen = Math.min(b1.length(), b2.length());
+
+    for (int i = 0; i < minLen; i++) {
+      int a = (b1.byteAt(i) & 0xff);
+      int b = (b2.byteAt(i) & 0xff);
+
+      if (a != b) {
+        return a - b;
+      }
+    }
+    return b1.length() - b2.length();
+  }
+
+  /**
+   * Compares this Bytes to another.
+   *
+   * @param other Bytes
+   * @return comparison result
+   */
+  public int compareTo(Bytes other) {      
+    return compareBytes(this, other);
+  }
+
+  /**
+   * Determines if this Bytes equals another.
+   *
+   * @param other object
+   * @return true if equal
+   */
+  @Override
+  public boolean equals(Object other) {
+    if (other instanceof Bytes) {
+      Bytes ob = (Bytes) other;
+
+      if (this == other)
+        return true;
+
+      if (length() != ob.length())
+        return false;
+
+      return compareTo(ob) == 0;
+    }
+    return false;
+  }
+
+  /**
+   * Computes hash code of Bytes
+   * 
+   * @return hash code
+   */
+  @Override
+  public int hashCode() {
+    int hash = 1;
+    if (isBackedByArray()) {
+      byte[] data = getBackingArray();
+      int end = offset() + length();
+      for (int i = offset(); i < end; i++)
+        hash = (31 * hash) + data[i];
+    } else {
+      for (int i = 0; i < length(); i++)
+        hash = (31 * hash) + byteAt(i);
+    }
+    return hash;
+  }
+  
+  /**
+   * Wraps byte array as Bytes
+   * 
+   * @param array byte array
+   * @return Bytes
+   */
+  public static Bytes wrap(byte[] array) {
+    return new ArrayBytes(array);
+  }
+
+  /**
+   * Wraps ByteBuffer as Bytes
+   * 
+   * @param bb ByteBuffer
+   * @return Bytes
+   */
+  public static Bytes wrap(ByteBuffer bb) {
+    return new ArrayBytes(bb);
+  }
+  
+  /**
+   * Wraps a UTF-8 String as Bytes
+   * 
+   * @param s String
+   * @return Bytes
+   */
+  public static Bytes wrap(String s) {
+    return new ArrayBytes(s);
+  }
+  
+  /**
+   * Wraps a String with a given charset as Bytes
+   * 
+   * @param s String
+   * @return Bytes
+   */
+  public static Bytes wrap(String s, Charset c) {
+    return new ArrayBytes(s, c);
+  }
+  
+  /**
+   * Writes Bytes to DataOutput 
+   * 
+   * @param out DataOutput
+   * @param b Bytes
+   * @throws IOException
+   */
+  public static void write(DataOutput out, Bytes b) throws IOException {
+    WritableUtils.writeVInt(out, b.length());
+    if (b.isBackedByArray()) {
+      out.write(b.getBackingArray(), b.offset(), b.length());
+    } else {
+      for (int i = 0; i < b.length(); i++) {
+        out.write(b.byteAt(i) & 0xff);
+      }
+    }
+  }
+
+  /**
+   * Wraps data input as Bytes
+   * 
+   * @param in DataInput
+   * @return Bytes
+   * @throws IOException
+   */
+  public static Bytes read(DataInput in) throws IOException {
+    int len = WritableUtils.readVInt(in);
+    byte b[] = new byte[len];
+    in.readFully(b);
+    return wrap(b);
+  }
+  
+  /**
+   * Concatenates of list of Bytes objects to create a byte array
+   * 
+   * @param listOfBytes
+   * @return Bytes
+   */
+  public static Bytes concat(Bytes... listOfBytes) {
+    try {
+      // TODO calculate exact array size needed
+      ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      DataOutputStream dos = new DataOutputStream(baos);
+      
+      for (Bytes b : listOfBytes) {
+        WritableUtils.writeVInt(dos, b.length());
+        if (b.isBackedByArray()) {
+          dos.write(b.getBackingArray(), b.offset(), b.length());
+        } else {
+          dos.write(b.toArray());
+        }
+      }
+      
+      dos.close();
+      return wrap(baos.toByteArray());
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+  
+  /**
+   * Splits a bytes object into several bytes objects
+   * 
+   * @param b Original bytes object
+   * @return List of bytes objects
+   */
+  public static List<Bytes> split(Bytes b) {
+    ByteArrayInputStream bais;
+    if (b.isBackedByArray())
+      bais = new ByteArrayInputStream(b.getBackingArray(), b.offset(), b.length());
+    else
+      bais = new ByteArrayInputStream(b.toArray());
+    
+    DataInputStream dis = new DataInputStream(bais);
+    
+    ArrayList<Bytes> ret = new ArrayList<Bytes>();
+    
+    try {
+      while (true) {
+        int len = WritableUtils.readVInt(dis);
+        // TODO could get pointers into original byte seq
+        byte field[] = new byte[len];
+        dis.readFully(field);
+        ret.add(wrap(field));
+      }
+    } catch (EOFException ee) {
+      
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+    return ret;
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/data/Column.java b/modules/api/src/main/java/io/fluo/api/data/Column.java
new file mode 100644
index 00000000..a1cab696
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/data/Column.java
@@ -0,0 +1,199 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import com.google.common.base.Preconditions;
+import org.apache.accumulo.core.security.ColumnVisibility;
+import org.apache.hadoop.io.Writable;
+
+/**
+ * Represents Column in Fluo
+ */
+public class Column implements Writable {
+  
+  public static final Column EMPTY = new Column();
+  
+  private Bytes family = Bytes.EMPTY;
+  private Bytes qualifier = Bytes.EMPTY;
+  private Bytes visibility = Bytes.EMPTY;
+
+  /**
+   * Creates Column with family, qualifier and visibility
+   * set to Bytes.EMPTY
+   */
+  public Column() {}
+  
+  /**
+   * Creates Column with family and sets qualifier and visibility
+   * to Bytes.EMPTY
+   */
+  public Column(Bytes family) {
+    Preconditions.checkNotNull(family, "Family must not be null");
+    this.family = family;
+  }
+  
+  /**
+   * Creates Column with family and sets qualifier and visibility 
+   * to Bytes.EMPTY.  String parameter will be encoded as UTF-8.
+   */
+  public Column(String family) {
+    this(family == null ? null : Bytes.wrap(family));
+  }
+
+  /**
+   * Creates Column with family and qualifier and sets visibility
+   * to Bytes.EMPTY
+   */
+  public Column(Bytes family, Bytes qualifier) {
+    Preconditions.checkNotNull(family, "Family must not be null");
+    Preconditions.checkNotNull(qualifier, "Qualifier must not be null");
+    this.family = family;
+    this.qualifier = qualifier;
+  }
+  
+  /**
+   * Creates Column with family and qualifier and sets visibility
+   * to Bytes.EMPTY.  String parameters will be encoded as UTF-8.
+   */
+  public Column(String family, String qualifier) {
+    this(family == null ? null : Bytes.wrap(family), qualifier == null ? null : Bytes.wrap(qualifier));
+  }
+  
+  /** 
+   * Creates Column with family, qualifier, and visibility
+   */
+  public Column(Bytes family, Bytes qualifier, ColumnVisibility cv) {
+    this(family, qualifier, cv == null ? null : Bytes.wrap(cv.getExpression()));
+  }
+  
+  /**
+   * Creates Column with family, qualifier, and visibility.
+   * String parameters will be encoded as UTF-8.
+   */
+  public Column(String family, String qualifier, ColumnVisibility cv) {
+    this(family == null ? null : Bytes.wrap(family), qualifier == null ? null : Bytes.wrap(qualifier), cv);
+  }
+  
+  /** 
+   * Creates Column with family, qualifier, and visibility
+   */
+  public Column(Bytes family, Bytes qualifier, Bytes visibility) {
+    Preconditions.checkNotNull(family, "Family must not be null");
+    Preconditions.checkNotNull(qualifier, "Qualifier must not be null");
+    Preconditions.checkNotNull(visibility, "Visibility must not be null");
+    this.family = family;
+    this.qualifier = qualifier;
+    this.visibility = visibility;
+  }
+  
+  /** 
+   * Creates Column with family, qualifier, and visibility.
+   * String parameters will be encoded as UTF-8.
+   */
+  public Column(String family, String qualifier, String visibility) {
+    this(family == null ? null : Bytes.wrap(family), qualifier == null ? null : Bytes.wrap(qualifier), 
+        visibility == null ? null : Bytes.wrap(visibility));
+  }
+  
+  /**
+   * Retrieves Family of Column
+   * 
+   * @return Bytes Family 
+   */
+  public Bytes getFamily() {
+    return family;
+  }
+  
+  /**
+   * Retrieves Qualifier of Column
+   * 
+   * @return Bytes Qualifier
+   */
+  public Bytes getQualifier() {
+    return qualifier;
+  }
+  
+  /**
+   * Retrieves Visibility of Column
+   * 
+   * @return Bytes Visibility
+   */
+  public Bytes getVisibility() {
+    return visibility;
+  }
+
+  /**
+   * Sets visibility of Column
+   * TODO - should not have ColumnVisibility directly 
+   * in public API... wrap it
+   *  
+   * @param cv ColumnVisibility
+   * @return Column
+   */
+  public Column setVisibility(ColumnVisibility cv) {
+    this.visibility = Bytes.wrap(cv.getExpression());
+    return this;
+  }
+  
+  /**
+   * Retries visibility parsed as ColumnVisibility
+   * WARNING - Can caused performance issues as ColumnVisibility
+   * is created every time
+   * 
+   * @return ColumnVisibility
+   */
+  public ColumnVisibility getVisibilityParsed() {
+    return new ColumnVisibility(visibility.toArray());
+  }
+
+  @Override
+  public String toString() {
+    return family + " " + qualifier + " " + visibility;
+  }
+  
+  @Override
+  public int hashCode() {
+    return family.hashCode() + qualifier.hashCode() + visibility.hashCode();
+  }
+  
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof Column) {
+      Column oc = (Column) o;
+      return family.equals(oc.family) && qualifier.equals(oc.qualifier)
+          && visibility.equals(oc.visibility);
+    }
+    return false;
+  }
+
+  // TODO remove from public API
+  public void write(DataOutput out) throws IOException {
+    Bytes.write(out, family);
+    Bytes.write(out, qualifier);
+    Bytes.write(out, visibility);    
+  }
+
+  public void readFields(DataInput in) throws IOException {
+    family = Bytes.read(in);
+    qualifier = Bytes.read(in);
+    visibility = Bytes.read(in);
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/data/RowColumn.java b/modules/api/src/main/java/io/fluo/api/data/RowColumn.java
new file mode 100644
index 00000000..1851ccc6
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/data/RowColumn.java
@@ -0,0 +1,127 @@
+package io.fluo.api.data;
+
+import com.google.common.base.Preconditions;
+
+/**
+ * Represents a Row & Column in Fluo. 
+ * Similiar to an Accumulo Key.
+ */
+public class RowColumn {
+  
+  public static RowColumn EMPTY = new RowColumn();
+  
+  private Bytes row = Bytes.EMPTY;
+  private Column col = Column.EMPTY;
+  
+  /** 
+   * Constructs a RowColumn with row set to Bytes.EMPTY
+   * and column set to Column.EMPTY 
+   */
+  public RowColumn() {}
+  
+  /**
+   * Constructs a RowColumn with only a row.  
+   * Column will be set to Column.EMPTY
+   * 
+   * @param row Bytes Row
+   */
+  public RowColumn(Bytes row) {
+    Preconditions.checkNotNull(row, "Row must not be null");
+    this.row = row;
+  }
+  
+  /**
+   * Constructs a RowColumn with only a row.
+   * Column will be set to Column.EMPTY
+   * 
+   * @param row (will be UTF-8 encoded)
+   */
+  public RowColumn(String row) {
+    this(row == null ? null : Bytes.wrap(row));
+  }
+  
+  /**
+   * Constructs a RowColumn
+   * 
+   * @param row Bytes Row
+   * @param col Column
+   */
+  public RowColumn(Bytes row, Column col) {
+    Preconditions.checkNotNull(row, "Row must not be null");
+    Preconditions.checkNotNull(col, "Col must not be null");
+    this.row = row;
+    this.col = col;
+  }
+  
+  /**
+   * Constructs a RowColumn
+   * 
+   * @param row Row String (will be UTF-8 encoded)
+   * @param col Column
+   */
+  public RowColumn(String row, Column col) {
+    this(row == null ? null : Bytes.wrap(row), col);
+  }
+
+  /**
+   * Retrieves Row in RowColumn
+   * 
+   * @return Row
+   */
+  public Bytes getRow() {
+    return row;
+  }
+
+  /**
+   * Retrieves Column in RowColumn
+   * 
+   * @return Column
+   */
+  public Column getColumn() {
+    return col;
+  }
+  
+  @Override
+  public String toString() {
+    return row + " " + col;
+  }
+  
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof RowColumn) { 
+      RowColumn other = (RowColumn) o;
+      return row.equals(other.row) && col.equals(other.col);
+    }
+    return false;
+  }
+  
+  /**
+   * Returns a RowColumn following the current one
+   * 
+   * @return RowColumn following this one
+   */
+  public RowColumn following() {
+    if (row.equals(Bytes.EMPTY)) {
+      return RowColumn.EMPTY;
+    } else if (col.equals(Column.EMPTY)) {
+      return new RowColumn(followingBytes(row));
+    } else if (col.getQualifier().equals(Bytes.EMPTY)) {
+      return new RowColumn(row, new Column(followingBytes(col.getFamily())));
+    } else if (col.getVisibility().equals(Bytes.EMPTY)) {
+      return new RowColumn(row, new Column(col.getFamily(), followingBytes(col.getQualifier())));
+    } else {
+      return new RowColumn(row, new Column(col.getFamily(), col.getQualifier(), followingBytes(col.getVisibility())));
+    }
+  }
+  
+  private byte[] followingArray(byte ba[]) {
+    byte[] fba = new byte[ba.length + 1];
+    System.arraycopy(ba, 0, fba, 0, ba.length);
+    fba[ba.length] = (byte) 0x00;
+    return fba;
+  }
+  
+  private Bytes followingBytes(Bytes b) {
+    return Bytes.wrap(followingArray(b.toArray()));
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/data/Span.java b/modules/api/src/main/java/io/fluo/api/data/Span.java
new file mode 100644
index 00000000..241b8d8f
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/data/Span.java
@@ -0,0 +1,572 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data;
+
+import com.google.common.base.Preconditions;
+
+import io.fluo.api.data.impl.SpanUtil;
+import io.fluo.api.data.impl.ByteUtil;
+import org.apache.accumulo.core.data.Range;
+
+/**
+ * Used to specify a span between two row/columns in a Fluo table
+ */
+public class Span {
+    
+  private RowColumn start = RowColumn.EMPTY;
+  private boolean startInclusive = true;
+  private RowColumn end = RowColumn.EMPTY;
+  private boolean endInclusive = true;
+      
+  /**
+   * Constructs a span with infinite start & end
+   */
+  public Span() { }
+  
+  /**
+   * Construct a new Range using a builder class
+   * 
+   * @param builder
+   */
+  public Span(Builder builder) {
+    this.startInclusive = builder.start.inclusive;
+    if (!builder.start.infinite) {
+      start = buildRowColumn(builder.start);
+      if (startInclusive == false) {
+        start = start.following();
+        startInclusive = true;
+      }
+    }
+    this.endInclusive = builder.end.inclusive;
+    if (!builder.end.infinite) {
+      end = buildRowColumn(builder.end);
+      if (endInclusive) {
+        end = end.following();
+        endInclusive = false;
+      }
+    }
+  }
+ 
+  private static RowColumn buildRowColumn(KeyBuilder key) {
+    if (key.infinite || key.row.equals(Bytes.EMPTY)) {
+      return RowColumn.EMPTY;
+    } else if (key.cf.equals(Bytes.EMPTY)) {
+      return new RowColumn(key.row);
+    } else if (key.cq.equals(Bytes.EMPTY)) {
+      return new RowColumn(key.row, new Column(key.cf));
+    } else if (key.cv.equals(Bytes.EMPTY)) {
+      return new RowColumn(key.row, new Column(key.cf, key.cq));
+    }
+    return new RowColumn(key.row, new Column(key.cf, key.cq, key.cv));
+  }
+  
+  /**
+   * Construct a new span from a start and end RowColumn.  Set either key
+   * to RowColumn.EMPTY to indicate positive or negative infinite
+   * 
+   * @param startKey Start key
+   * @param startKeyInclusive Include start key in Range
+   * @param endKey End Key
+   * @param endKeyInclusive Include end key in Range
+   */
+  public Span(RowColumn start, boolean startInclusive, RowColumn end, boolean endInclusive) {
+    Preconditions.checkNotNull(start, "start must not be null");
+    Preconditions.checkNotNull(end, "end must not be null");
+    this.start = start;
+    this.startInclusive = startInclusive;
+    this.end = end;
+    this.endInclusive = endInclusive;
+  }
+    
+  /**
+   * Construct a new Span from a start and end row
+   * 
+   * @param startRow Start row
+   * @param startRowInclusive Start row inclusive
+   * @param endRow End row
+   * @param endRowInclusive End row inclusive
+   */
+  public Span(Bytes startRow, boolean startRowInclusive, Bytes endRow, boolean endRowInclusive) {
+    Preconditions.checkNotNull(startRow, "startRow must not be null");
+    Preconditions.checkNotNull(endRow, "endRow must not be null");
+    this.startInclusive = startRowInclusive;
+    if (!startRow.equals(Bytes.EMPTY)) {
+      this.start = new RowColumn(startRow);
+      if (startInclusive == false) {
+        this.start = start.following();
+        this.startInclusive = true;
+      }
+    }
+    this.endInclusive = endRowInclusive;
+    if (!endRow.equals(Bytes.EMPTY)) {
+      this.end = new RowColumn(endRow);
+      if (endInclusive) {
+        end = end.following();
+        endInclusive = false;
+      }
+    }
+  }
+  
+  /**
+   * Construct a new Span from a start and end row.
+   * Strings will be encoded as UTF-8.
+   * 
+   * @param startRow Start row
+   * @param startRowInclusive Start row inclusive
+   * @param endRow End row
+   * @param endRowInclusive End row inclusive
+   */
+  public Span(String startRow, boolean startRowInclusive, String endRow, boolean endRowInclusive) {
+    this(Bytes.wrap(startRow), startRowInclusive, Bytes.wrap(endRow), endRowInclusive);
+  }
+  
+  private Span(Range range) {
+    this.start = SpanUtil.toRowColumn(range.getStartKey());
+    this.startInclusive = range.isStartKeyInclusive();
+    this.end = SpanUtil.toRowColumn(range.getEndKey());
+    this.endInclusive = range.isEndKeyInclusive();
+  }
+  
+  /**
+   * Return start RowColumn of Span. 
+   * 
+   * @return start or RowColumn.EMPTY if infinite start
+   */
+  public RowColumn getStart() {
+    return start;
+  }
+ 
+  /**
+   * Return end RowColumn of Span
+   * 
+   * @return end or RowColumn.EMPTY if infinite end
+   */
+  public RowColumn getEnd() {
+    return end;
+  }
+  
+  /**
+   * Checks if start RowColumn is inclusive
+   * 
+   * @return True if start key is inclusive
+   */
+  public boolean isStartInclusive() {
+    return startInclusive;
+  }
+
+  /**
+   * Check if end RowColumn is inclusive
+   * 
+   * @return True if end key is inclusive
+   */
+  public boolean isEndInclusive() {
+    return endInclusive;
+  }
+        
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof Span)
+      return equals((Span) o);
+    return false;
+  }
+  
+  /**
+   * Checks if span is equal to another span
+   * 
+   * @param other Span
+   * @return true if equal
+   */
+  public boolean equals(Span other) {
+    return start.equals(other.start) && (startInclusive == other.startInclusive) 
+        && end.equals(other.end) && (endInclusive == other.endInclusive);
+  }
+  
+  @Override
+  public String toString() {
+    return ((startInclusive && !start.equals(RowColumn.EMPTY)) ? "[" : "(") + (start.equals(RowColumn.EMPTY) ? "-inf" : start) + "," + 
+        (end.equals(RowColumn.EMPTY) ? "+inf" : end) + ((endInclusive && !end.equals(RowColumn.EMPTY)) ? "]" : ")");
+  }
+  
+  /**
+   * Creates a span that covers an exact row
+   */
+  public static Span exact(Bytes row) {
+    return new Span(Range.exact(ByteUtil.toText(row)));
+  }
+  
+  /**
+   * Creates a Span that covers an exact row.
+   * String parameters will be encoded as UTF-8
+   */
+  public static Span exact(String row) {
+    return exact(Bytes.wrap(row));
+  }
+  
+  /**
+   * Creates a Span that covers an exact row and column family
+   */
+  public static Span exact(Bytes row, Bytes cf) {
+    return new Span(Range.exact(ByteUtil.toText(row), ByteUtil.toText(cf)));
+  }
+  
+  /**
+   * Creates a Span that covers an exact row and column family
+   * String parameters will be encoded as UTF-8
+   */
+  public static Span exact(String row, String cf) {
+    return exact(Bytes.wrap(row), Bytes.wrap(cf));
+  }
+  
+  /**
+   * Creates a Span that covers an exact row, column family, and column qualifier
+   */
+  public static Span exact(Bytes row, Bytes cf, Bytes cq) {
+    return new Span(Range.exact(ByteUtil.toText(row), 
+        ByteUtil.toText(cf), ByteUtil.toText(cq)));
+  }
+  
+  /**
+   * Creates a Span that covers an exact row, column family, and column qualifier
+   * String parameters will be encoded as UTF-8
+   */
+  public static Span exact(String row, String cf, String cq) {
+    return exact(Bytes.wrap(row), Bytes.wrap(cf), Bytes.wrap(cq));
+  }
+  
+  /**
+   * Creates a Span that covers an exact row, column family, column qualifier, and column visibility
+   */
+  public static Span exact(Bytes row, Bytes cf, Bytes cq, Bytes cv) {
+    return new Span(Range.exact(ByteUtil.toText(row), 
+        ByteUtil.toText(cf), ByteUtil.toText(cq), ByteUtil.toText(cv)));
+  }
+  
+  /**
+   * Creates a Span that covers an exact row, column family, column qualifier, and column visibility
+   * String parameters will be encoded as UTF-8
+   */
+  public static Span exact(String row, String cf, String cq, String cv) {
+    return exact(Bytes.wrap(row), Bytes.wrap(cf), Bytes.wrap(cq), Bytes.wrap(cv));
+  }
+  
+  /**
+   * Returns a Span that covers all rows beginning with a prefix
+   */
+  public static Span prefix(Bytes rowPrefix) {
+    return new Span(Range.prefix(ByteUtil.toText(rowPrefix)));
+  }
+  
+  /**
+   * Returns a Span that covers all rows beginning with a prefix
+   * String parameters will be encoded as UTF-8
+   */
+  public static Span prefix(String rowPrefix) {
+    return prefix(Bytes.wrap(rowPrefix));
+  }
+  
+  /**
+   * Returns a Span that covers all column families beginning with a prefix within a given row
+   */
+  public static Span prefix(Bytes row, Bytes cfPrefix) {
+    return new Span(Range.prefix(ByteUtil.toText(row), 
+        ByteUtil.toText(cfPrefix)));
+  }
+  
+  /**
+   * Returns a Span that covers all column families beginning with a prefix within a given row
+   * String parameters will be encoded as UTF-8
+   */
+  public static Span prefix(String row, String cfPrefix) {
+    return prefix(Bytes.wrap(row), Bytes.wrap(cfPrefix));
+  }
+  
+  /**
+   * Returns a Span that covers all column qualifiers beginning with a prefix within a given row
+   * and column family
+   */
+  public static Span prefix(Bytes row, Bytes cf, Bytes cqPrefix) {
+    return new Span(Range.prefix(ByteUtil.toText(row), 
+        ByteUtil.toText(cf), ByteUtil.toText(cqPrefix)));
+  }
+  
+  /**
+   * Returns a Span that covers all column qualifiers beginning with a prefix within a given row
+   * String parameters will be encoded as UTF-8
+   */
+  public static Span prefix(String row, String cf, String cqPrefix) {
+    return prefix(Bytes.wrap(row), Bytes.wrap(cf), Bytes.wrap(cqPrefix));
+  }
+  
+  /**
+   * Returns a Span that covers all column visibilities beginning with a prefix within a given row,
+   * column family, and column qualifier.
+   */
+  public static Span prefix(Bytes row, Bytes cf, Bytes cq, Bytes cvPrefix) {
+    return new Span(Range.prefix(ByteUtil.toText(row), 
+        ByteUtil.toText(cf), ByteUtil.toText(cq), ByteUtil.toText(cvPrefix)));
+  }
+  
+  /**
+   * Returns a Span that covers all column visibilities beginning with a prefix within a given row
+   * String parameters will be encoded as UTF-8
+   */
+  public static Span prefix(String row, String cf, String cq, String cvPrefix) {
+    return prefix(Bytes.wrap(row), Bytes.wrap(cf), Bytes.wrap(cq), Bytes.wrap(cvPrefix));
+  }
+  
+  public static class KeyBuilder {
+    protected Bytes row = Bytes.EMPTY;
+    protected Bytes cf = Bytes.EMPTY;
+    protected Bytes cq = Bytes.EMPTY;
+    protected Bytes cv = Bytes.EMPTY;
+    protected boolean inclusive = true;
+    protected boolean infinite = true;
+  }
+  
+  public static class Builder {
+    
+    private KeyBuilder start = new KeyBuilder();
+    private KeyBuilder end = new KeyBuilder();
+    
+    /**
+     * Build start of Span starting with row
+     */
+    public StartCFBuilder startRow(Bytes row) {
+      this.start.row = row;
+      this.start.infinite = false;
+      return new StartCFBuilder(this);
+    }
+    
+    /**
+     * Build start of Span starting with row (will be encoded UTF-8)
+     */
+    public StartCFBuilder startRow(String row) {
+      return startRow(Bytes.wrap(row));
+    }
+    
+    /**
+     * Build end of Span starting with row
+     */
+    public EndCFBuilder endRow(Bytes row) {
+      this.end.row = row;
+      this.end.infinite = false;
+      return new EndCFBuilder(this);
+    }
+    
+    /**
+     * Build end of Span starting with row (will be encoded UTF-8) 
+     */
+    public EndCFBuilder endRow(String row) {
+      return endRow(Bytes.wrap(row));
+    }
+        
+    public Span build() {
+      return new Span(this);
+    }
+  }
+    
+  public static class StartBuilder {
+    
+    protected Builder builder;
+    
+    public StartBuilder(Builder builder) {
+      this.builder = builder;
+    }
+    
+    /**
+     * Build Span end starting with row 
+     */
+    public EndCFBuilder endRow(Bytes row) {
+      return this.builder.endRow(row);
+    }
+    
+    /**
+     * Build Span end starting with row (will be encoded UTF-8)
+     */
+    public EndCFBuilder endRow(String row) {
+      return endRow(Bytes.wrap(row));
+    }
+    
+    /**
+     * Exclude start from Span
+     */
+    public StartBuilder exclusive() {
+      this.builder.start.inclusive = false;
+      return this;
+    }
+    
+    public Span build() {
+      return new Span(builder);
+    }
+  }
+  
+  public static class EndBuilder {
+    
+    protected Builder builder;
+    
+    public EndBuilder(Builder builder) {
+      this.builder = builder;
+    }
+        
+    /**
+     * Exclude end from Span
+     */
+    public EndBuilder exclusive() {
+      this.builder.end.inclusive = false;
+      return this;
+    }
+    
+    /**
+     * Build Span
+     */
+    public Span build() {
+      return new Span(builder);
+    }
+  }
+    
+  public static class StartCVBuilder extends StartBuilder {
+    
+    public StartCVBuilder(Builder builder) {
+      super(builder);
+    }
+    
+    /**
+     * Add column visibility to Span start
+     */
+    public StartBuilder cv(Bytes cv) {
+      this.builder.start.cv = cv;
+      return new StartBuilder(this.builder);
+    }
+    
+    /**
+     * Add column visibility (will be encoded UTF-8) to Span start
+     */
+    public StartBuilder cv(String cv) {
+      return cv(Bytes.wrap(cv));
+    }
+  }
+  
+  public static class StartCQBuilder extends StartBuilder {
+    
+    public StartCQBuilder(Builder builder) {
+      super(builder);
+    }
+    
+    /**
+     * Add column qualifier to Span start
+     */
+    public StartCVBuilder cq(Bytes cq) {
+      this.builder.start.cq = cq;
+      return new StartCVBuilder(this.builder);
+    }
+    
+    /**
+     * Add column qualifier (will be encoded UTF-8) to Span start 
+     */
+    public StartCVBuilder cq(String cq) {
+      return cq(Bytes.wrap(cq));
+    }
+  }
+  
+  public static class StartCFBuilder extends StartBuilder {
+    
+    public StartCFBuilder(Builder builder) {
+      super(builder);
+    }
+    
+    /**
+     * Add column family to Span start
+     */
+    public StartCQBuilder cf(Bytes cf) {
+      this.builder.start.cf = cf;
+      return new StartCQBuilder(this.builder);
+    }
+    
+    /**
+     * Add column family (will be encoded UTF-8) to Span start
+     */
+    public StartCQBuilder cf(String cf) {
+      return cf(Bytes.wrap(cf));
+    }
+  }
+  
+  public static class EndCVBuilder extends EndBuilder {
+    
+    public EndCVBuilder(Builder builder) {
+      super(builder);
+    }
+    
+    /**
+     * Add column visibility to Span end
+     */
+    public EndBuilder cv(Bytes cv) {
+      this.builder.end.cv = cv;
+      return this;
+    }
+    
+    /**
+     * Add column visibility (will be encoded UTF-8) to Span end
+     */
+    public EndBuilder cv(String cv) {
+      return cv(Bytes.wrap(cv));
+    }
+  }
+  
+  public static class EndCQBuilder extends EndBuilder {
+    
+    public EndCQBuilder(Builder builder) {
+      super(builder);
+    }
+    
+    /**
+     * Add column qualifier to Span end
+     */
+    public EndCVBuilder cq(Bytes cq) {
+      this.builder.end.cq = cq;
+      return new EndCVBuilder(this.builder);
+    }
+    
+    /**
+     * Add column qualifier (will be encoded UTF-8) to Span end
+     */
+    public EndCVBuilder cq(String cq) {
+      return cq(Bytes.wrap(cq));
+    }
+  }
+  
+  public static class EndCFBuilder extends EndBuilder {
+    
+    public EndCFBuilder(Builder builder) {
+      super(builder);
+    }
+    
+    /**
+     * Add column family to an Span end
+     */
+    public EndCQBuilder cf(Bytes cf) {
+      this.builder.end.cf = cf;
+      return new EndCQBuilder(this.builder);
+    }
+    
+    /**
+     * Add column family (will be encoded UTF-8) to an Span end
+     */
+    public EndCQBuilder cf(String cf) {
+      return cf(Bytes.wrap(cf));
+    }
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/data/impl/ArrayBytes.java b/modules/api/src/main/java/io/fluo/api/data/impl/ArrayBytes.java
new file mode 100644
index 00000000..b0cd49fa
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/data/impl/ArrayBytes.java
@@ -0,0 +1,223 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data.impl;
+
+import java.io.Serializable;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+
+import io.fluo.api.data.Bytes;
+
+import org.apache.accumulo.core.data.ArrayByteSequence;
+import org.apache.accumulo.core.data.ByteSequence;
+import org.apache.hadoop.io.Text;
+
+/**
+* An implementation of {@link Bytes} that uses a backing byte array.
+*/
+public class ArrayBytes extends Bytes implements Serializable {
+
+  private static final long serialVersionUID = 1L;
+
+  protected byte data[];
+  protected int offset;
+  protected int length;
+
+  /**
+   * Creates a new ArrayBytes. The given byte array is used directly as the
+   * backing array, so later changes made to the array reflect into the new
+   * sequence.
+   *
+   * @param data byte data
+   */
+  public ArrayBytes(byte data[]) {
+    this.data = data;
+    this.offset = 0;
+    this.length = data.length;
+  }
+
+  /**
+   * Creates a new ArrayBytes from a subsequence of the given byte array. The
+   * given byte array is used directly as the backing array, so later changes
+   * made to the (relevant portion of the) array reflect into the new sequence.
+   *
+   * @param data byte data
+   * @param offset starting offset in byte array (inclusive)
+   * @param length number of bytes to include in sequence
+   * @throws IllegalArgumentException if the offset or length are out of bounds
+   * for the given byte array
+   */
+  public ArrayBytes(byte data[], int offset, int length) {
+    if (offset < 0 || offset > data.length || length < 0 || (offset + length) > data.length) {
+      throw new IllegalArgumentException(" Bad offset and/or length data.length = " + data.length + " offset = " + offset + " length = " + length);
+    }
+    this.data = data;
+    this.offset = offset;
+    this.length = length;
+  }
+
+  /**
+   * Creates a new ArrayBytes from the given string. The bytes are determined from
+   * the string using the default platform encoding.
+   *
+   * @param s String to represent as Bytes
+   */
+  public ArrayBytes(String s) {
+    this(s.getBytes(StandardCharsets.UTF_8));
+  }
+  
+  /**
+   * Creates a new ArrayBytes from the given string. The bytes are determined from
+   * the string using the default platform encoding.
+   *
+   * @param s String to represent as Bytes
+   */
+  public ArrayBytes(String s, Charset cs) {
+    this(s.getBytes(cs));
+  }
+
+  /**
+   * Creates a new ArrayBytes based on a ByteBuffer. If the byte buffer has an
+   * array, that array (and the buffer's offset and limit) are used; otherwise,
+   * a new backing array is created and a relative bulk get is performed to
+   * transfer the buffer's contents (starting at its current position and
+   * not beyond its limit).
+   *
+   * @param buffer byte buffer
+   */
+  public ArrayBytes(ByteBuffer buffer) {
+    this.length = buffer.remaining();
+
+    if (buffer.hasArray()) {
+      this.data = buffer.array();
+      this.offset = buffer.position();
+    } else {
+      this.data = new byte[length];
+      this.offset = 0;
+      buffer.get(data);
+    }
+  }
+  
+  /**
+   * Creates a new ArrayBytes based on a ByteSequence. If the byte buffer has an
+   * array, that array (and the buffer's offset and limit) are used; otherwise,
+   * a new backing array is created and a relative bulk get is performed to
+   * transfer the buffer's contents (starting at its current position and
+   * not beyond its limit).
+   *
+   * @param bs ByteSequence
+   */
+  public ArrayBytes(ByteSequence bs) {
+    this.length = bs.length();
+
+    if (bs.isBackedByArray()) {
+      this.data = bs.getBackingArray();
+      this.offset = bs.offset();
+    } else {
+      this.data = bs.toArray();
+      this.offset = 0;
+    }
+  }
+  
+  public ArrayBytes(Text t) {
+    this.length = t.getLength();
+    this.data = t.getBytes();
+    this.offset = 0;
+  }
+
+  @Override
+  public byte byteAt(int i) {
+
+    if (i < 0) {
+      throw new IllegalArgumentException("i < 0, " + i);
+    }
+
+    if (i >= length) {
+      throw new IllegalArgumentException("i >= length, " + i + " >= " + length);
+    }
+
+    return data[offset + i];
+  }
+
+  @Override
+  public byte[] getBackingArray() {
+    return data;
+  }
+
+  @Override
+  public boolean isBackedByArray() {
+    return true;
+  }
+
+  @Override
+  public int length() {
+    return length;
+  }
+
+  @Override
+  public int offset() {
+    return offset;
+  }
+
+  @Override
+  public Bytes subSequence(int start, int end) {
+
+    if (start > end || start < 0 || end > length) {
+      throw new IllegalArgumentException("Bad start and/end start = " + start + " end=" + end + " offset=" + offset + " length=" + length);
+    }
+
+    return new ArrayBytes(data, offset + start, end - start);
+  }
+
+  @Override
+  public byte[] toArray() {
+    if (offset == 0 && length == data.length)
+      return data;
+
+    byte[] copy = new byte[length];
+    System.arraycopy(data, offset, copy, 0, length);
+    return copy;
+  }
+
+  /** 
+   * Creates UTF-8 String using Bytes data
+   */
+  public String toString() {
+    return new String(data, offset, length, StandardCharsets.UTF_8);
+  }
+
+  /**
+   * Creates ByteSequence using Bytes data
+   * 
+   * @return ByteSequence
+   */
+  public ByteSequence toByteSequence() {
+    return new ArrayByteSequence(data, offset, length);
+  }
+
+  /**
+   * Creates Hadoop Text object using Bytes Data
+   * 
+   * @return Hadoop Text object 
+   */
+  public Text toText() {
+    Text t = new Text();
+    t.set(data, offset, length);
+    return t;
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/data/impl/ByteUtil.java b/modules/api/src/main/java/io/fluo/api/data/impl/ByteUtil.java
new file mode 100644
index 00000000..1c79e211
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/data/impl/ByteUtil.java
@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data.impl;
+
+import io.fluo.api.data.Bytes;
+import org.apache.accumulo.core.data.ArrayByteSequence;
+import org.apache.accumulo.core.data.ByteSequence;
+import org.apache.hadoop.io.Text;
+
+/**
+ * Utilities for modifying byte arrays and converting
+ * Bytes objects to external formats
+ */
+public class ByteUtil {
+  
+  public static final byte[] EMPTY = new byte[0];
+  
+  private ByteUtil() {}
+
+  /**
+   * Encode long as byte array
+   * 
+   * @param v Long value
+   * @return byte array
+   */
+  public static byte[] encode(long v) {
+    byte ba[] = new byte[8];
+    encode(ba, 0, v);
+    return ba;
+  }
+
+  /**
+   * Encode a long into a byte array at an offset
+   * 
+   * @param ba Byte array
+   * @param offset Offset
+   * @param v Long value
+   * @return byte array given in input
+   */
+  public static byte[] encode(byte[] ba, int offset, long v) {
+    ba[offset + 0] = (byte) (v >>> 56);
+    ba[offset + 1] = (byte) (v >>> 48);
+    ba[offset + 2] = (byte) (v >>> 40);
+    ba[offset + 3] = (byte) (v >>> 32);
+    ba[offset + 4] = (byte) (v >>> 24);
+    ba[offset + 5] = (byte) (v >>> 16);
+    ba[offset + 6] = (byte) (v >>> 8);
+    ba[offset + 7] = (byte) (v >>> 0);
+    return ba;
+  }
+
+  /**
+   * Decode long from byte array at offset
+   * 
+   * @param ba byte array
+   * @param offset Offset 
+   * @return long value
+   */
+  public static long decodeLong(byte[] ba, int offset) {
+    return ((((long) ba[offset + 0] << 56) + ((long) (ba[offset + 1] & 255) << 48) + ((long) (ba[offset + 2] & 255) << 40)
+        + ((long) (ba[offset + 3] & 255) << 32) + ((long) (ba[offset + 4] & 255) << 24) + ((ba[offset + 5] & 255) << 16) + ((ba[offset + 6] & 255) << 8) + ((ba[offset + 7] & 255) << 0)));
+  }
+
+  /**
+   * Decode long from byte array
+   * 
+   * @param ba byte array
+   * @return long value
+   */
+  public static long decodeLong(byte[] ba) {
+    return ((((long) ba[0] << 56) + ((long) (ba[1] & 255) << 48) + ((long) (ba[2] & 255) << 40) + ((long) (ba[3] & 255) << 32) + ((long) (ba[4] & 255) << 24)
+        + ((ba[5] & 255) << 16) + ((ba[6] & 255) << 8) + ((ba[7] & 255) << 0)));
+  
+  }
+
+  /**
+   * Concatenate several byte arrays into one
+   * 
+   * @param byteArrays List of byte arrays
+   * @return concatenated byte array
+   */
+  public static byte[] concat(byte[]... byteArrays) {
+    ArrayBytes[] bs = new ArrayBytes[byteArrays.length];
+    for (int i = 0; i < byteArrays.length; i++) {
+      bs[i] = new ArrayBytes(byteArrays[i]);
+    }
+    return Bytes.concat(bs).toArray();
+  }
+
+  /**
+   * Convert a Bytes object to Hadoop Text object
+   * 
+   * @param b Bytes
+   * @return Text object
+   */
+  public static Text toText(Bytes b) {
+    if (b.isBackedByArray()) {
+      Text t = new Text(EMPTY);
+      t.set(b.getBackingArray(), b.offset(), b.length());
+      return t;
+    } else {
+      return new Text(b.toArray());
+    }
+  }
+  
+  /**
+   * Convert a Bytes object to ByteSequence object
+   * 
+   * @param b Bytes
+   * @return ByteSequence object
+   */
+  public static ByteSequence toByteSequence(Bytes b) {
+    if (b.isBackedByArray()) {
+      return new ArrayByteSequence(b.getBackingArray(), b.offset(), b.length());
+    } else {
+      return new ArrayByteSequence(b.toArray());
+    }
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/data/impl/SpanUtil.java b/modules/api/src/main/java/io/fluo/api/data/impl/SpanUtil.java
new file mode 100644
index 00000000..b17d3985
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/data/impl/SpanUtil.java
@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data.impl;
+
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.data.RowColumn;
+import io.fluo.api.data.Span;
+import org.apache.accumulo.core.data.Key;
+import org.apache.accumulo.core.data.Range;
+import org.apache.hadoop.io.Text;
+
+/**
+ * Utility methods for manipulating Spans
+ */
+public class SpanUtil {
+  
+  private SpanUtil() {}
+  
+  /**
+   * Converts a Fluo Span to Accumulo Range
+   * 
+   * @param span Span
+   * @return Range
+   */
+  public static Range toRange(Span span) {
+    return new Range(toKey(span.getStart()), span.isStartInclusive(), toKey(span.getEnd()), span.isEndInclusive());
+  }
+  
+  /**
+   * Converts from a Fluo RowColumn to a Accumulo Key
+   * 
+   * @param rc RowColumn
+   * @return Key
+   */
+  public static Key toKey(RowColumn rc) {
+    if ((rc == null) || (rc.getRow().equals(Bytes.EMPTY))) {
+      return null;
+    }
+    Text row = ByteUtil.toText(rc.getRow());
+    if ((rc.getColumn().equals(Column.EMPTY)) || (rc.getColumn().getFamily().equals(Bytes.EMPTY))) {
+      return new Key(row);
+    }
+    Text cf = ByteUtil.toText(rc.getColumn().getFamily());
+    if (rc.getColumn().getQualifier().equals(Bytes.EMPTY)) {
+      return new Key(row, cf);
+    }
+    Text cq = ByteUtil.toText(rc.getColumn().getQualifier());
+    if (rc.getColumn().getVisibility().equals(Bytes.EMPTY)) {
+      return new Key(row, cf, cq);
+    }
+    Text cv = ByteUtil.toText(rc.getColumn().getVisibility());
+    return new Key(row, cf, cq, cv);
+  }
+  
+  /**
+   * Converts an Accumulo Range to a Fluo Span
+   * 
+   * @param range Range
+   * @return Span
+   */
+  public static Span toSpan(Range range) {
+    return new Span(toRowColumn(range.getStartKey()), range.isStartKeyInclusive(), 
+                    toRowColumn(range.getEndKey()), range.isEndKeyInclusive());
+  }
+  
+  /**
+   * Converts from an Accumulo Key to a Fluo RowColumn
+   * 
+   * @param key Key
+   * @return RowColumn
+   */
+  public static RowColumn toRowColumn(Key key) {
+    if (key == null) {
+      return RowColumn.EMPTY;
+    }
+    if ((key.getRow() == null) || key.getRow().getLength() == 0) {
+      return RowColumn.EMPTY;
+    }
+    Bytes row = new ArrayBytes(key.getRow());
+    if ((key.getColumnFamily() == null) || key.getColumnFamily().getLength() == 0) {
+      return new RowColumn(row);
+    }
+    Bytes cf = new ArrayBytes(key.getColumnFamily());
+    if ((key.getColumnQualifier() == null) || key.getColumnQualifier().getLength() == 0) {
+      return new RowColumn(row, new Column(cf));
+    }
+    Bytes cq = new ArrayBytes(key.getColumnQualifier());
+    if ((key.getColumnVisibility() == null) || key.getColumnVisibility().getLength() == 0) {
+      return new RowColumn(row, new Column(cf, cq));
+    }
+    Bytes cv = new ArrayBytes(key.getColumnVisibility());
+    return new RowColumn(row, new Column(cf, cq, cv));
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/iterator/ColumnIterator.java b/modules/api/src/main/java/io/fluo/api/iterator/ColumnIterator.java
new file mode 100644
index 00000000..5bb14c89
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/iterator/ColumnIterator.java
@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.iterator;
+
+import java.util.Iterator;
+import java.util.Map.Entry;
+
+import io.fluo.api.data.Bytes;
+
+import io.fluo.api.data.Column;
+
+/**
+ * Iterator for Fluo Columns
+ */
+public interface ColumnIterator extends Iterator<Entry<Column,Bytes>> {
+  
+}
diff --git a/modules/api/src/main/java/io/fluo/api/iterator/RowIterator.java b/modules/api/src/main/java/io/fluo/api/iterator/RowIterator.java
new file mode 100644
index 00000000..86544f64
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/iterator/RowIterator.java
@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.iterator;
+
+import java.util.Iterator;
+import java.util.Map.Entry;
+
+import io.fluo.api.iterator.ColumnIterator;
+
+import io.fluo.api.data.Bytes;
+
+/**
+ * Iterator for Fluo rows
+ */
+public interface RowIterator extends Iterator<Entry<Bytes,ColumnIterator>> {
+  
+}
diff --git a/modules/api/src/main/java/io/fluo/api/observer/AbstractObserver.java b/modules/api/src/main/java/io/fluo/api/observer/AbstractObserver.java
new file mode 100644
index 00000000..be01fef6
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/observer/AbstractObserver.java
@@ -0,0 +1,13 @@
+package io.fluo.api.observer;
+
+import java.util.Map;
+
+public abstract class AbstractObserver implements Observer {
+
+  @Override
+  public void init(Map<String,String> config) throws Exception {}
+
+  @Override
+  public void close() {}
+
+}
diff --git a/modules/api/src/main/java/io/fluo/api/observer/Observer.java b/modules/api/src/main/java/io/fluo/api/observer/Observer.java
new file mode 100644
index 00000000..9fde3026
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/observer/Observer.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.observer;
+
+import java.util.Map;
+
+import io.fluo.api.client.Transaction;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+
+/**
+ * An observer is created for each worker thread and re-used for the lifetime of a worker thread.
+ * 
+ * Consider extending {@link AbstractObserver} instead of implementing this. The abstract class will shield you from the addition of interface methods.
+ */
+public interface Observer {
+
+  public static enum NotificationType {
+    WEAK, STRONG
+  }
+
+  public static class ObservedColumn {
+    private Column col;
+    private NotificationType notificationType;
+
+    public ObservedColumn(Column col, NotificationType notificationType) {
+      this.col = col;
+      this.notificationType = notificationType;
+    }
+
+    public Column getColumn() {
+      return col;
+    }
+
+    public NotificationType getType() {
+      return notificationType;
+    }
+  }
+
+  public void init(Map<String,String> config) throws Exception;
+
+  public void process(Transaction tx, Bytes row, Column col) throws Exception;
+
+  /**
+   * Its safe to assume that {@link #init(Map)} will be called before this method. If the return value of the method is derived from whats passed to
+   * {@link #init(Map)}, then the derivation process should be deterministic.
+   * 
+   * @return The column that will trigger this observer. During initialization this information is stored in zookeeper so that workers have a consistent view.
+   *         If a worker loads an Observer and the information returned differs from whats in zookeeper then an exception will be thrown.
+   */
+  public ObservedColumn getObservedColumn();
+
+  public void close();
+}
diff --git a/modules/api/src/main/java/io/fluo/api/types/Encoder.java b/modules/api/src/main/java/io/fluo/api/types/Encoder.java
new file mode 100644
index 00000000..eda17636
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/types/Encoder.java
@@ -0,0 +1,17 @@
+package io.fluo.api.types;
+
+import io.fluo.api.data.Bytes;
+
+public interface Encoder {
+  public int decodeInteger(Bytes b);
+
+  public Bytes encode(int i);
+
+  public long decodeLong(Bytes b);
+
+  public Bytes encode(long l);
+
+  public String decodeString(Bytes b);
+
+  public Bytes encode(String s);
+}
diff --git a/modules/api/src/main/java/io/fluo/api/types/LexicoEncoder.java b/modules/api/src/main/java/io/fluo/api/types/LexicoEncoder.java
new file mode 100644
index 00000000..fda656fa
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/types/LexicoEncoder.java
@@ -0,0 +1,41 @@
+package io.fluo.api.types;
+
+import io.fluo.api.data.Bytes;
+import org.apache.accumulo.core.client.lexicoder.IntegerLexicoder;
+import org.apache.accumulo.core.client.lexicoder.LongLexicoder;
+
+public class LexicoEncoder implements Encoder {
+
+  private IntegerLexicoder il = new IntegerLexicoder();
+  private LongLexicoder ll = new LongLexicoder();
+  
+  @Override
+  public int decodeInteger(Bytes b) {
+    return il.decode(b.toArray());
+  }
+
+  @Override
+  public Bytes encode(int i) {
+    return Bytes.wrap(il.encode(i));
+  }
+
+  @Override
+  public long decodeLong(Bytes b) {
+    return ll.decode(b.toArray());
+  }
+
+  @Override
+  public Bytes encode(long l) {
+    return Bytes.wrap(ll.encode(l));
+  }
+
+  @Override
+  public String decodeString(Bytes b) {
+    return b.toString();
+  }
+
+  @Override
+  public Bytes encode(String s) {
+    return Bytes.wrap(s);
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/types/StringEncoder.java b/modules/api/src/main/java/io/fluo/api/types/StringEncoder.java
new file mode 100644
index 00000000..9714cde2
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/types/StringEncoder.java
@@ -0,0 +1,36 @@
+package io.fluo.api.types;
+
+import io.fluo.api.data.Bytes;
+
+public class StringEncoder implements Encoder {
+
+  @Override
+  public int decodeInteger(Bytes b) {
+    return Integer.parseInt(decodeString(b));
+  }
+
+  @Override
+  public Bytes encode(int i) {
+    return encode(Integer.toString(i));
+  }
+
+  @Override
+  public long decodeLong(Bytes b) {
+    return Long.parseLong(decodeString(b));
+  }
+
+  @Override
+  public Bytes encode(long l) {
+    return encode(Long.toString(l));
+  }
+
+  @Override
+  public String decodeString(Bytes b) {
+    return b.toString();
+  }
+
+  @Override
+  public Bytes encode(String s) {
+    return Bytes.wrap(s);
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java b/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java
new file mode 100644
index 00000000..f7f2d4d8
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/types/TypeLayer.java
@@ -0,0 +1,194 @@
+package io.fluo.api.types;
+
+import io.fluo.api.client.FluoClient;
+import io.fluo.api.client.Snapshot;
+import io.fluo.api.client.Transaction;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import org.apache.accumulo.core.security.ColumnVisibility;
+
+public class TypeLayer {
+
+  private Encoder encoder;
+
+  abstract static class RowColumnBuilder<TC,TQ> {
+    abstract void setRow(Bytes r);
+
+    abstract void setFamily(Bytes f);
+
+    abstract TQ setQualifier(Bytes q);
+
+    abstract TC setColumn(Column c);
+  }
+
+  private static class ColumnBuilder extends RowColumnBuilder<Column,VisibilityBuilder> {
+
+    private Bytes family;
+
+    @Override
+    void setRow(Bytes r) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    void setFamily(Bytes f) {
+      this.family = f;
+    }
+
+    @Override
+    VisibilityBuilder setQualifier(Bytes q) {
+      return new VisibilityBuilder(new Column(family, q));
+    }
+
+    @Override
+    Column setColumn(Column c) {
+      return c;
+    }
+
+  }
+
+  public static class VisibilityBuilder {
+    private Column column;
+
+    private VisibilityBuilder(Column column) {
+      this.column = column;
+    }
+
+    public Column vis() {
+      return column;
+    }
+
+    public Column vis(ColumnVisibility cv) {
+      column.setVisibility(cv);
+      return column;
+    }
+  }
+
+  public class RowAction<TC,TQ,R extends RowColumnBuilder<TC,TQ>> {
+
+    private R result;
+
+    RowAction(R result) {
+      this.result = result;
+    }
+
+    public FamilyAction<TC,TQ,R> row(String row) {
+      result.setRow(encoder.encode(row));
+      return new FamilyAction<TC,TQ,R>(result);
+    }
+
+    public FamilyAction<TC,TQ,R> row(int row) {
+      result.setRow(encoder.encode(row));
+      return new FamilyAction<TC,TQ,R>(result);
+    }
+
+    public FamilyAction<TC,TQ,R> row(long row) {
+      result.setRow(encoder.encode(row));
+      return new FamilyAction<TC,TQ,R>(result);
+    }
+
+    public FamilyAction<TC,TQ,R> row(byte[] row) {
+      result.setRow(Bytes.wrap(row));
+      return new FamilyAction<TC,TQ,R>(result);
+    }
+
+    public FamilyAction<TC,TQ,R> row(Bytes row) {
+      result.setRow(row);
+      return new FamilyAction<TC,TQ,R>(result);
+    }
+  }
+
+
+
+  public class FamilyAction<TC,TQ,R extends RowColumnBuilder<TC,TQ>> {
+
+    private R result;
+
+    FamilyAction(R result) {
+      this.result = result;
+    }
+
+    public QualifierAction<TC,TQ,R> fam(String family) {
+      result.setFamily(encoder.encode(family));
+      return new QualifierAction<TC,TQ,R>(result);
+    }
+
+    public QualifierAction<TC,TQ,R> fam(int family) {
+      result.setFamily(encoder.encode(family));
+      return new QualifierAction<TC,TQ,R>(result);
+    }
+
+    public QualifierAction<TC,TQ,R> fam(long family) {
+      result.setFamily(encoder.encode(family));
+      return new QualifierAction<TC,TQ,R>(result);
+    }
+
+    public QualifierAction<TC,TQ,R> fam(byte[] family) {
+      result.setFamily(Bytes.wrap(family));
+      return new QualifierAction<TC,TQ,R>(result);
+    }
+
+    public QualifierAction<TC,TQ,R> fam(Bytes family) {
+      result.setFamily(family);
+      return new QualifierAction<TC,TQ,R>(result);
+    }
+
+    public TC col(Column c) {
+      return result.setColumn(c);
+    }
+  }
+
+  public class QualifierAction<TC,TQ,R extends RowColumnBuilder<TC,TQ>> {
+
+    private R result;
+
+    QualifierAction(R result) {
+      this.result = result;
+    }
+
+    public TQ qual(String qualifier) {
+      return result.setQualifier(encoder.encode(qualifier));
+    }
+
+    public TQ qual(int qualifier) {
+      return result.setQualifier(encoder.encode(qualifier));
+    }
+
+    public TQ qual(long qualifier) {
+      return result.setQualifier(encoder.encode(qualifier));
+    }
+
+    public TQ qual(byte[] qualifier) {
+      return result.setQualifier(Bytes.wrap(qualifier));
+    }
+
+    public TQ qual(Bytes qualifier) {
+      return result.setQualifier(qualifier);
+    }
+
+  }
+
+  public TypeLayer(Encoder encoder) {
+    this.encoder = encoder;
+  }
+
+  public Column newColumn(String cf, String cq) {
+    return newColumn().fam(cf).qual(cq).vis();
+  }
+
+  public FamilyAction<Column,VisibilityBuilder,ColumnBuilder> newColumn() {
+    return new FamilyAction<Column,VisibilityBuilder,ColumnBuilder>(new ColumnBuilder());
+  }
+
+  public TypedSnapshot snapshot(FluoClient client) {
+    return snapshot(client.newSnapshot());
+  }
+  
+  public TypedSnapshot snapshot(Snapshot snap) {
+    return new TypedSnapshot(snap, encoder, this);
+  }
+
+  public TypedTransaction transaction(Transaction tx) {
+    return new TypedTransaction(tx, encoder, this);
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java
new file mode 100644
index 00000000..4db6987c
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedSnapshot.java
@@ -0,0 +1,225 @@
+package io.fluo.api.types;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import io.fluo.api.client.Snapshot;
+import io.fluo.api.config.ScannerConfiguration;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.iterator.RowIterator;
+import io.fluo.api.types.TypeLayer.RowAction;
+import io.fluo.api.types.TypeLayer.RowColumnBuilder;
+import org.apache.accumulo.core.security.ColumnVisibility;
+import org.apache.commons.collections.map.DefaultedMap;
+
+//TODO need to refactor column to use Encoder
+
+public class TypedSnapshot implements Snapshot {
+
+  private Snapshot snapshot;
+  private Encoder encoder;
+  private TypeLayer tl;
+
+  private class KeyBuilder extends RowColumnBuilder<Value,VisBytesDecoder> {
+
+    private Bytes family;
+    private Bytes row;
+
+    @Override
+    void setRow(Bytes r) {
+      this.row = r;
+    }
+
+    @Override
+    void setFamily(Bytes f) {
+      this.family = f;
+    }
+
+    @Override
+    public VisBytesDecoder setQualifier(Bytes q) {
+      return new VisBytesDecoder(row, new Column(family, q));
+    }
+
+    @Override
+    public Value setColumn(Column c) {
+      try {
+        return new Value(snapshot.get(row, c));
+      } catch (Exception e) {
+        // TODO
+        if (e instanceof RuntimeException)
+          throw (RuntimeException) e;
+        throw new RuntimeException(e);
+      }
+    }
+
+  }
+
+  public class VisBytesDecoder extends Value {
+
+    private Bytes row;
+    private Column col;
+    private boolean gotBytes = false;
+
+    Bytes getBytes() {
+      if (!gotBytes) {
+        try {
+          super.bytes = snapshot.get(row, col);
+          gotBytes = true;
+        } catch (Exception e) {
+          if (e instanceof RuntimeException)
+            throw (RuntimeException) e;
+          throw new RuntimeException(e);
+        }
+      }
+
+      return super.getBytes();
+    }
+
+    VisBytesDecoder(Bytes row, Column col) {
+      super(null);
+      this.row = row;
+      this.col = col;
+    }
+
+    public Value vis(ColumnVisibility cv) {
+      col.setVisibility(cv);
+      gotBytes = false;
+      return new Value(getBytes());
+    }
+  }
+
+  public class Value {
+    Bytes bytes;
+
+    Bytes getBytes() {
+      return bytes;
+    }
+
+    private Value(Bytes bytes) {
+      this.bytes = bytes;
+    }
+
+    public Integer toInteger() {
+      if (getBytes() == null)
+        return null;
+      return encoder.decodeInteger(getBytes());
+    }
+
+    public int toInteger(int defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return encoder.decodeInteger(getBytes());
+    }
+
+    public Long toLong() {
+      if (getBytes() == null)
+        return null;
+      return encoder.decodeLong(getBytes());
+    }
+
+    public long toLong(int defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return encoder.decodeLong(getBytes());
+    }
+
+    @Override
+    public String toString() {
+      if (getBytes() == null)
+        return null;
+      return encoder.decodeString(getBytes());
+    }
+
+    public String toString(String defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return encoder.decodeString(getBytes());
+    }
+
+    public byte[] toBytes() {
+      if (getBytes() == null)
+        return null;
+      return getBytes().toArray();
+    }
+
+    public byte[] toBytes(byte[] defaultValue) {
+      if (getBytes() == null)
+        return defaultValue;
+      return getBytes().toArray();
+    }
+  }
+
+  TypedSnapshot(Snapshot snapshot, Encoder encoder, TypeLayer tl) {
+    this.snapshot = snapshot;
+    this.encoder = encoder;
+    this.tl = tl;
+  }
+
+  @Override
+  public Bytes get(Bytes row, Column column) throws Exception {
+    return snapshot.get(row, column);
+  }
+
+  @Override
+  public Map<Column,Bytes> get(Bytes row, Set<Column> columns) throws Exception {
+    return snapshot.get(row, columns);
+  }
+
+  @Override
+  public RowIterator get(ScannerConfiguration config) throws Exception {
+    return snapshot.get(config);
+  }
+
+  @Override
+  public Map<Bytes,Map<Column,Bytes>> get(Collection<Bytes> rows, Set<Column> columns) throws Exception {
+    return snapshot.get(rows, columns);
+  }
+
+  public RowAction<Value,VisBytesDecoder,KeyBuilder> get() {
+    return tl.new RowAction<Value,VisBytesDecoder,KeyBuilder>(new KeyBuilder());
+  }
+
+
+  @SuppressWarnings("unchecked")
+  public Map<Column,Value> getd(Bytes row, Set<Column> columns) throws Exception {
+    Map<Column,Bytes> map = snapshot.get(row, columns);
+    Map<Column,Value> ret = new HashMap<Column,Value>();
+
+    Set<Entry<Column,Bytes>> es = map.entrySet();
+    for (Entry<Column,Bytes> entry : es) {
+      ret.put(entry.getKey(), new Value(entry.getValue()));
+    }
+
+    return DefaultedMap.decorate(ret, new Value(null));
+  }
+
+  public Map<Column,Value> getd(String row, Set<Column> columns) throws Exception {
+    return getd(encoder.encode(row), columns);
+  }
+
+  @SuppressWarnings("unchecked")
+  public Map<String,Map<Column,Value>> getd(Collection<String> rows, Set<Column> columns) throws Exception {
+    ArrayList<Bytes> bsRows = new ArrayList<Bytes>(rows.size());
+    for (String row : rows) {
+      bsRows.add(encoder.encode(row));
+    }
+
+    Map<Bytes,Map<Column,Bytes>> in = snapshot.get(bsRows, columns);
+    Map<String,Map<Column,Value>> out = new HashMap<String,Map<Column,Value>>();
+
+    for (Entry<Bytes,Map<Column,Bytes>> rowEntry : in.entrySet()) {
+      Map<Column,Value> outCols = new HashMap<Column,Value>();
+      for (Entry<Column,Bytes> colEntry : rowEntry.getValue().entrySet()) {
+        outCols.put(colEntry.getKey(), new Value(colEntry.getValue()));
+      }
+      out.put(encoder.decodeString(rowEntry.getKey()), DefaultedMap.decorate(outCols, new Value(null)));
+    }
+
+    return DefaultedMap.decorate(out, new DefaultedMap(new Value(null)));
+  }
+}
diff --git a/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java b/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java
new file mode 100644
index 00000000..676b31da
--- /dev/null
+++ b/modules/api/src/main/java/io/fluo/api/types/TypedTransaction.java
@@ -0,0 +1,165 @@
+package io.fluo.api.types;
+
+import io.fluo.api.client.Transaction;
+import io.fluo.api.data.Bytes;
+import io.fluo.api.data.Column;
+import io.fluo.api.types.TypeLayer.RowAction;
+import io.fluo.api.types.TypeLayer.RowColumnBuilder;
+import org.apache.accumulo.core.security.ColumnVisibility;
+
+public class TypedTransaction extends TypedSnapshot implements Transaction {
+
+  private Transaction tx;
+  private Encoder encoder;
+  private TypeLayer tl;
+
+  private class MutateKeyBuilder extends RowColumnBuilder<Mutator,VisibilityMutator> {
+
+    private Bytes row;
+    private Bytes cf;
+
+    @Override
+    void setRow(Bytes r) {
+      this.row = r;
+    }
+
+    @Override
+    void setFamily(Bytes f) {
+      this.cf = f;
+    }
+
+    @Override
+    VisibilityMutator setQualifier(Bytes q) {
+      return new VisibilityMutator(row, new Column(cf, q));
+    }
+
+    @Override
+    Mutator setColumn(Column c) {
+      return new Mutator(row, c);
+    }
+
+  }
+
+  public class Mutator {
+
+    private Bytes row;
+    private Column col;
+    private boolean set = false;
+
+    void checkNotSet() {
+      if (set)
+        throw new IllegalStateException("Already set value");
+    }
+
+    Mutator(Bytes row, Column column) {
+      this.row = row;
+      this.col = column;
+    }
+
+    public void set(String s) {
+      checkNotSet();
+      tx.set(row, col, encoder.encode(s));
+      set = true;
+    }
+
+    public void set(int i) {
+      checkNotSet();
+      tx.set(row, col, encoder.encode(i));
+      set = true;
+    }
+
+    public void set(long l) {
+      checkNotSet();
+      tx.set(row, col, encoder.encode(l));
+      set = true;
+    }
+
+    public void increment(int i) throws Exception {
+      checkNotSet();
+      Bytes val = tx.get(row, col);
+      int v = 0;
+      if (val != null)
+        v = encoder.decodeInteger(val);
+      tx.set(row, col, encoder.encode(v + i));
+    }
+
+    public void increment(long l) throws Exception {
+      checkNotSet();
+      Bytes val = tx.get(row, col);
+      long v = 0;
+      if (val != null)
+        v = encoder.decodeLong(val);
+      tx.set(row, col, encoder.encode(v + l));
+    }
+
+    public void set(byte[] ba) {
+      checkNotSet();
+      tx.set(row, col, Bytes.wrap(ba));
+      set = true;
+    }
+
+    /**
+     * Set an empty value
+     */
+    public void set() {
+      checkNotSet();
+      tx.set(row, col, Bytes.wrap(new byte[0]));
+      set = true;
+    }
+
+    public void delete() {
+      checkNotSet();
+      tx.delete(row, col);
+      set = true;
+    }
+
+    public void weaklyNotify() {
+      checkNotSet();
+      tx.setWeakNotification(row, col);
+      set = true;
+    }
+
+  }
+
+  public class VisibilityMutator extends Mutator {
+
+    VisibilityMutator(Bytes row, Column column) {
+      super(row, column);
+    }
+
+    public Mutator vis(ColumnVisibility cv) {
+      checkNotSet();
+      super.col.setVisibility(cv);
+      super.set = true;
+      return new Mutator(super.row, super.col);
+    }
+  }
+
+
+  // TODO make private.. test depend on it
+  protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) {
+    super(tx, encoder, tl);
+    this.tx = tx;
+    this.encoder = encoder;
+    this.tl = tl;
+  }
+
+  public RowAction<Mutator,VisibilityMutator,MutateKeyBuilder> mutate() {
+    return tl.new RowAction<Mutator,VisibilityMutator,MutateKeyBuilder>(new MutateKeyBuilder());
+  }
+
+  @Override
+  public void set(Bytes row, Column col, Bytes value) {
+    tx.set(row, col, value);
+  }
+
+  @Override
+  public void setWeakNotification(Bytes row, Column col) {
+    tx.setWeakNotification(row, col);
+  }
+
+  @Override
+  public void delete(Bytes row, Column col) {
+    tx.delete(row, col);
+  }
+}
diff --git a/modules/api/src/test/java/io/fluo/api/data/BytesTest.java b/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
new file mode 100644
index 00000000..7c703a75
--- /dev/null
+++ b/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data;
+
+import java.nio.ByteBuffer;
+import java.util.List;
+
+import io.fluo.api.data.impl.ArrayBytes;
+import io.fluo.api.data.impl.ByteUtil;
+import org.apache.accumulo.core.data.ArrayByteSequence;
+import org.apache.accumulo.core.data.ByteSequence;
+import org.apache.hadoop.io.Text;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Tests Bytes & ArrayBytes classes
+ */
+public class BytesTest {
+
+  @Test
+  public void testBytesWrap() {
+    
+    String s1 = "test1";
+    Bytes b1 = Bytes.wrap(s1);
+    Assert.assertArrayEquals(s1.getBytes(), b1.toArray());
+    Assert.assertEquals(s1, b1.toString());
+    
+    String s2 = "test2";
+    ByteBuffer bb = ByteBuffer.wrap(s2.getBytes());
+    Bytes b2 = Bytes.wrap(bb);
+    Assert.assertArrayEquals(s2.getBytes(), b2.toArray());
+    Assert.assertEquals(s2, b2.toString());
+    
+    String s3 = "test3";
+    ByteSequence bs = new ArrayByteSequence(s3);
+    ArrayBytes b3 = new ArrayBytes(bs);
+    Assert.assertArrayEquals(s3.getBytes(), b3.toArray());
+    Assert.assertEquals(s3, b3.toString());
+    Assert.assertEquals(bs, b3.toByteSequence());
+    
+    String s4 = "test4";
+    Bytes b4 = Bytes.wrap(s4.getBytes());
+    Assert.assertArrayEquals(s4.getBytes(), b4.toArray());
+    Assert.assertEquals(s4, b4.toString());
+    
+    String s5 = "test5";
+    Text t5 = new Text(s5);
+    ArrayBytes b5 = new ArrayBytes(s5);
+    Assert.assertEquals(t5, b5.toText());
+    Assert.assertEquals(t5, ByteUtil.toText(b5));
+  }
+  
+  @Test
+  public void testConcatSplit() {
+    
+    Bytes b1 = Bytes.wrap("str1");
+    Bytes b2 = Bytes.wrap("string2");
+    Bytes b3 = Bytes.wrap("s3");
+    Bytes ball = Bytes.concat(b1, b2, b3);
+    
+    List<Bytes> blist = Bytes.split(ball);
+    
+    Assert.assertEquals(b1, blist.get(0));
+    Assert.assertEquals(b2, blist.get(1));
+    Assert.assertEquals(b3, blist.get(2));
+  }
+}
diff --git a/modules/api/src/test/java/io/fluo/api/data/SpanTest.java b/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
new file mode 100644
index 00000000..d0744f48
--- /dev/null
+++ b/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data;
+
+import org.apache.accumulo.core.security.ColumnVisibility;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Tests Span class
+ */
+public class SpanTest {
+  
+  String rw1s = "rw1";
+  String cf1s = "cf1";
+  String cq1s = "cq1";
+  String cv1s = "cv1";
+  long ts1 = 51;
+  String rw2s = "rw2";
+  String cf2s = "cf2";
+  String cq2s = "cq2";
+  String cv2s = "cv2";
+  long ts2 = 51;  
+  Bytes rw1b = Bytes.wrap(rw1s);
+  Bytes cf1b = Bytes.wrap(cf1s);
+  Bytes cq1b = Bytes.wrap(cq1s);
+  Bytes cv1b = Bytes.wrap(cv1s);
+  Bytes rw2b = Bytes.wrap(rw2s);
+  Bytes cf2b = Bytes.wrap(cf2s);
+  Bytes cq2b = Bytes.wrap(cq2s);
+  Bytes cv2b = Bytes.wrap(cv2s);
+  
+  @Test
+  public void testRowRange() {
+    // Test with Bytes input
+    Assert.assertEquals(new Span(rw1b, true, rw2b, false), 
+        new Span.Builder().startRow(rw1b).endRow(rw2b).exclusive().build());
+    Assert.assertEquals(new Span(rw1b, false, rw2b, false), 
+        new Span.Builder().startRow(rw1b).exclusive().endRow(rw2b).exclusive().build());
+    Assert.assertEquals(new Span(rw1b, true, rw2b, true), 
+        new Span.Builder().startRow(rw1b).endRow(rw2b).build());
+    Assert.assertEquals(new Span(rw1b, false, rw2b, true), 
+        new Span.Builder().startRow(rw1b).exclusive().endRow(rw2b).build());
+    
+    // Test with String input
+    Assert.assertEquals(new Span(rw1b, true, rw2b, false), 
+        new Span.Builder().startRow(rw1s).endRow(rw2s).exclusive().build());
+    Assert.assertEquals(new Span(rw1b, false, rw2b, false), 
+        new Span.Builder().startRow(rw1s).exclusive().endRow(rw2s).exclusive().build());
+    Assert.assertEquals(new Span(rw1b, true, rw2b, true), 
+        new Span.Builder().startRow(rw1s).endRow(rw2s).build());
+    Assert.assertEquals(new Span(rw1b, false, rw2b, true), 
+        new Span.Builder().startRow(rw1s).exclusive().endRow(rw2s).build());
+  }
+  
+  @Test 
+  public void testInfiniteRanges() {
+    RowColumn rc1 = new RowColumn(rw1b, new Column(cf1b));
+    RowColumn frc1 = rc1.following();
+    RowColumn rc2 = new RowColumn(rw2b, new Column(cf2b));
+    RowColumn frc2 = rc2.following();
+    
+    Assert.assertEquals(new Span(RowColumn.EMPTY, true, frc2, false), new Span.Builder().endRow(rw2b).cf(cf2b).build());
+    Assert.assertEquals(new Span(RowColumn.EMPTY, true, rc2, false), new Span.Builder().endRow(rw2b).cf(cf2b).exclusive().build());
+    Assert.assertEquals(new Span(rc1, true, RowColumn.EMPTY, true), new Span.Builder().startRow(rw1b).cf(cf1b).build());
+    Assert.assertEquals(new Span(frc1, true, RowColumn.EMPTY, true), new Span.Builder().startRow(rw1b).cf(cf1b).exclusive().build());   
+  }
+  
+  @Test
+  public void testRowCFRange() {
+    RowColumn rc1 = new RowColumn(rw1b, new Column(cf1b));
+    RowColumn frc1 = rc1.following();
+    RowColumn rc2 = new RowColumn(rw2b, new Column(cf2b));
+    RowColumn frc2 = rc2.following();
+    
+    Assert.assertEquals(new Span(rc1, true, frc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).endRow(rw2b).cf(cf2b).build());
+    Assert.assertEquals(new Span(rc1, true, rc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).endRow(rw2b).cf(cf2b).exclusive().build());
+    Assert.assertEquals(new Span(frc1, true, frc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).exclusive().endRow(rw2b).cf(cf2b).build());
+    Assert.assertEquals(new Span(frc1, true, rc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).exclusive().endRow(rw2b).cf(cf2b).exclusive().build());
+  }
+  
+  @Test
+  public void testRowCFCQRange() {
+    RowColumn rc1 = new RowColumn(rw1b, new Column(cf1b, cq1b));
+    RowColumn frc1 = rc1.following();
+    RowColumn rc2 = new RowColumn(rw2b, new Column(cf2b, cq2b));
+    RowColumn frc2 = rc2.following();
+    
+    Assert.assertEquals(new Span(rc1, true, frc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).cq(cq1b).endRow(rw2b).cf(cf2b).cq(cq2b).build());
+    Assert.assertEquals(new Span(rc1, true, rc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).cq(cq1b).endRow(rw2b).cf(cf2b).cq(cq2b).exclusive().build());
+    Assert.assertEquals(new Span(frc1, true, frc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).cq(cq1b).exclusive().endRow(rw2b).cf(cf2b).cq(cq2b).build());
+    Assert.assertEquals(new Span(frc1, true, rc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).cq(cq1b).exclusive().endRow(rw2b).cf(cf2b).cq(cq2b).exclusive().build());
+  }
+  
+  @Test
+  public void testRowCFCQCVRange() {
+    RowColumn rc1 = new RowColumn(rw1b, new Column(cf1b, cq1b, new ColumnVisibility(cv1s)));
+    RowColumn frc1 = rc1.following();
+    RowColumn rc2 = new RowColumn(rw2b, new Column(cf2b, cq2b, new ColumnVisibility(cv2s)));
+    RowColumn frc2 = rc2.following();
+    
+    Assert.assertEquals(new Span(rc1, true, frc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).cq(cq1b).cv(cv1b).endRow(rw2b).cf(cf2b).cq(cq2b).cv(cv2b).build());
+    Assert.assertEquals(new Span(rc1, true, rc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).cq(cq1b).cv(cv1b).endRow(rw2b).cf(cf2b).cq(cq2b).cv(cv2b).exclusive().build());
+    Assert.assertEquals(new Span(frc1, true, frc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).cq(cq1b).cv(cv1b).exclusive().endRow(rw2b).cf(cf2b).cq(cq2b).cv(cv2b).build());
+    Assert.assertEquals(new Span(frc1, true, rc2, false), 
+        new Span.Builder().startRow(rw1b).cf(cf1b).cq(cq1b).cv(cv1b).exclusive().endRow(rw2b).cf(cf2b).cq(cq2b).cv(cv2b).exclusive().build());
+  }
+}
diff --git a/modules/api/src/test/java/io/fluo/api/data/impl/SpanUtilTest.java b/modules/api/src/test/java/io/fluo/api/data/impl/SpanUtilTest.java
new file mode 100644
index 00000000..5dbf1dcc
--- /dev/null
+++ b/modules/api/src/test/java/io/fluo/api/data/impl/SpanUtilTest.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.fluo.api.data.impl;
+
+import io.fluo.api.data.Column;
+import io.fluo.api.data.RowColumn;
+import org.apache.accumulo.core.data.Key;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Tests SpanUtil Class
+ */
+public class SpanUtilTest {
+  
+  @Test
+  public void testToKey() {
+    Assert.assertEquals(null, SpanUtil.toKey(null));
+    Assert.assertEquals(new Key("row"), SpanUtil.toKey(new RowColumn("row")));
+    Assert.assertEquals(new Key("row", "cf"), SpanUtil.toKey(new RowColumn("row", new Column("cf"))));
+    Assert.assertEquals(new Key("row", "cf", "cq"), SpanUtil.toKey(new RowColumn("row", new Column("cf", "cq"))));
+    Assert.assertEquals(new Key("row", "cf", "cq", "cv"), SpanUtil.toKey(new RowColumn("row", new Column("cf", "cq", "cv"))));
+  }
+  
+  @Test
+  public void testToRowColumn() {
+    Assert.assertEquals(RowColumn.EMPTY, SpanUtil.toRowColumn(null));
+    Assert.assertEquals(new RowColumn("row"), SpanUtil.toRowColumn(new Key("row")));
+    Assert.assertEquals(new RowColumn("row", new Column("cf")), SpanUtil.toRowColumn(new Key("row", "cf")));
+    Assert.assertEquals(new RowColumn("row", new Column("cf", "cq")), SpanUtil.toRowColumn(new Key("row", "cf", "cq")));
+    Assert.assertEquals(new RowColumn("row", new Column("cf", "cq", "cv")), SpanUtil.toRowColumn(new Key("row", "cf", "cq", "cv")));
+  }
+}
diff --git a/modules/api/src/test/resources/log4j.properties b/modules/api/src/test/resources/log4j.properties
new file mode 100644
index 00000000..f562b606
--- /dev/null
+++ b/modules/api/src/test/resources/log4j.properties
@@ -0,0 +1,36 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+log4j.rootLogger=INFO, CA
+log4j.appender.CA=org.apache.log4j.ConsoleAppender
+log4j.appender.CA.layout=org.apache.log4j.PatternLayout
+log4j.appender.CA.layout.ConversionPattern=%d{ISO8601} [%c{2}] %-5p: %m%n
+
+log4j.logger.org.apache.curator=ERROR
+log4j.logger.org.apache.accumulo.core.client.impl.ServerClient=ERROR
+log4j.logger.org.apache.accumulo.core.util.shell.Shell.audit=off
+log4j.logger.org.apache.accumulo.core.util.shell.Shell=FATAL
+log4j.logger.org.apache.commons.vfs2.impl.DefaultFileSystemManager=WARN
+log4j.logger.org.apache.hadoop.io.compress.CodecPool=WARN
+log4j.logger.org.apache.hadoop.metrics=WARN
+log4j.logger.org.apache.hadoop.mapred=ERROR
+log4j.logger.org.apache.hadoop.mapreduce=ERROR
+log4j.logger.org.apache.hadoop.conf=ERROR
+log4j.logger.org.apache.hadoop.tools.DistCp=WARN
+log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR
+log4j.logger.org.apache.hadoop.util.ProcessTree=WARN
+log4j.logger.org.apache.zookeeper.ClientCnxn=FATAL
+log4j.logger.org.apache.zookeeper.ZooKeeper=WARN
+log4j.logger.io.fluo=ERROR
