diff --git a/modules/api/src/main/java/io/fluo/api/data/Span.java b/modules/api/src/main/java/io/fluo/api/data/Span.java
index 241b8d8f..348ba70b 100644
--- a/modules/api/src/main/java/io/fluo/api/data/Span.java
+++ b/modules/api/src/main/java/io/fluo/api/data/Span.java
@@ -18,10 +18,6 @@ package io.fluo.api.data;
 
 import com.google.common.base.Preconditions;
 
-import io.fluo.api.data.impl.SpanUtil;
-import io.fluo.api.data.impl.ByteUtil;
-import org.apache.accumulo.core.data.Range;
-
 /**
  * Used to specify a span between two row/columns in a Fluo table
  */
@@ -93,7 +89,8 @@ public class Span {
   }
     
   /**
-   * Construct a new Span from a start and end row
+   * Construct a new Span from a start and end row.  Set either row to
+   * Bytes.EMPTY to indicate positive or negative infinite.
    * 
    * @param startRow Start row
    * @param startRowInclusive Start row inclusive
@@ -133,14 +130,7 @@ public class Span {
   public Span(String startRow, boolean startRowInclusive, String endRow, boolean endRowInclusive) {
     this(Bytes.wrap(startRow), startRowInclusive, Bytes.wrap(endRow), endRowInclusive);
   }
-  
-  private Span(Range range) {
-    this.start = SpanUtil.toRowColumn(range.getStartKey());
-    this.startInclusive = range.isStartKeyInclusive();
-    this.end = SpanUtil.toRowColumn(range.getEndKey());
-    this.endInclusive = range.isEndKeyInclusive();
-  }
-  
+    
   /**
    * Return start RowColumn of Span. 
    * 
@@ -205,7 +195,7 @@ public class Span {
    * Creates a span that covers an exact row
    */
   public static Span exact(Bytes row) {
-    return new Span(Range.exact(ByteUtil.toText(row)));
+    return new Span(row, true, row, true);
   }
   
   /**
@@ -220,7 +210,8 @@ public class Span {
    * Creates a Span that covers an exact row and column family
    */
   public static Span exact(Bytes row, Bytes cf) {
-    return new Span(Range.exact(ByteUtil.toText(row), ByteUtil.toText(cf)));
+    RowColumn start = new RowColumn(row, new Column(cf));
+    return new Span(start, true, start.following(), false);
   }
   
   /**
@@ -235,8 +226,8 @@ public class Span {
    * Creates a Span that covers an exact row, column family, and column qualifier
    */
   public static Span exact(Bytes row, Bytes cf, Bytes cq) {
-    return new Span(Range.exact(ByteUtil.toText(row), 
-        ByteUtil.toText(cf), ByteUtil.toText(cq)));
+    RowColumn start = new RowColumn(row, new Column(cf, cq));
+    return new Span(start, true, start.following(), false);
   }
   
   /**
@@ -251,8 +242,8 @@ public class Span {
    * Creates a Span that covers an exact row, column family, column qualifier, and column visibility
    */
   public static Span exact(Bytes row, Bytes cf, Bytes cq, Bytes cv) {
-    return new Span(Range.exact(ByteUtil.toText(row), 
-        ByteUtil.toText(cf), ByteUtil.toText(cq), ByteUtil.toText(cv)));
+    RowColumn start = new RowColumn(row, new Column(cf, cq, cv));
+    return new Span(start, true, start.following(), false);
   }
   
   /**
@@ -263,11 +254,31 @@ public class Span {
     return exact(Bytes.wrap(row), Bytes.wrap(cf), Bytes.wrap(cq), Bytes.wrap(cv));
   }
   
+  private static Bytes followingPrefix(Bytes prefix) {
+    byte[] prefixBytes = prefix.toArray();
+    
+    // find the last byte in the array that is not 0xff
+    int changeIndex = prefix.length() - 1;
+    while (changeIndex >= 0 && prefixBytes[changeIndex] == (byte) 0xff)
+      changeIndex--;
+    if (changeIndex < 0)
+      return null;
+    
+    // copy prefix bytes into new array
+    byte[] newBytes = new byte[changeIndex + 1];
+    System.arraycopy(prefixBytes, 0, newBytes, 0, changeIndex + 1);
+    
+    // increment the selected byte
+    newBytes[changeIndex]++;
+    return Bytes.wrap(newBytes);
+  }
+  
   /**
    * Returns a Span that covers all rows beginning with a prefix
    */
   public static Span prefix(Bytes rowPrefix) {
-    return new Span(Range.prefix(ByteUtil.toText(rowPrefix)));
+    Bytes fp = followingPrefix(rowPrefix);
+    return new Span(rowPrefix, true, fp == null ? Bytes.EMPTY : fp, false);
   }
   
   /**
@@ -282,8 +293,9 @@ public class Span {
    * Returns a Span that covers all column families beginning with a prefix within a given row
    */
   public static Span prefix(Bytes row, Bytes cfPrefix) {
-    return new Span(Range.prefix(ByteUtil.toText(row), 
-        ByteUtil.toText(cfPrefix)));
+    Bytes fp = followingPrefix(cfPrefix);
+    RowColumn end = (fp == null ? new RowColumn(row).following() : new RowColumn(row, new Column(fp)));
+    return new Span(new RowColumn(row, new Column(cfPrefix)), true, end, false);
   }
   
   /**
@@ -299,8 +311,9 @@ public class Span {
    * and column family
    */
   public static Span prefix(Bytes row, Bytes cf, Bytes cqPrefix) {
-    return new Span(Range.prefix(ByteUtil.toText(row), 
-        ByteUtil.toText(cf), ByteUtil.toText(cqPrefix)));
+    Bytes fp = followingPrefix(cqPrefix);
+    RowColumn end = (fp == null ? new RowColumn(row, new Column(cf)).following() : new RowColumn(row, new Column(cf, fp)));
+    return new Span(new RowColumn(row, new Column(cf, cqPrefix)), true, end, false);
   }
   
   /**
@@ -316,8 +329,9 @@ public class Span {
    * column family, and column qualifier.
    */
   public static Span prefix(Bytes row, Bytes cf, Bytes cq, Bytes cvPrefix) {
-    return new Span(Range.prefix(ByteUtil.toText(row), 
-        ByteUtil.toText(cf), ByteUtil.toText(cq), ByteUtil.toText(cvPrefix)));
+    Bytes fp = followingPrefix(cvPrefix);
+    RowColumn end = (fp == null ? new RowColumn(row, new Column(cf, cq)).following() : new RowColumn(row, new Column(cf, cq, fp)));
+    return new Span(new RowColumn(row, new Column(cf, cq, cvPrefix)), true, end, false);
   }
   
   /**
diff --git a/modules/api/src/main/java/io/fluo/api/data/impl/ByteUtil.java b/modules/api/src/main/java/io/fluo/api/data/impl/ByteUtil.java
deleted file mode 100644
index 1c79e211..00000000
--- a/modules/api/src/main/java/io/fluo/api/data/impl/ByteUtil.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.data.impl;
-
-import io.fluo.api.data.Bytes;
-import org.apache.accumulo.core.data.ArrayByteSequence;
-import org.apache.accumulo.core.data.ByteSequence;
-import org.apache.hadoop.io.Text;
-
-/**
- * Utilities for modifying byte arrays and converting
- * Bytes objects to external formats
- */
-public class ByteUtil {
-  
-  public static final byte[] EMPTY = new byte[0];
-  
-  private ByteUtil() {}
-
-  /**
-   * Encode long as byte array
-   * 
-   * @param v Long value
-   * @return byte array
-   */
-  public static byte[] encode(long v) {
-    byte ba[] = new byte[8];
-    encode(ba, 0, v);
-    return ba;
-  }
-
-  /**
-   * Encode a long into a byte array at an offset
-   * 
-   * @param ba Byte array
-   * @param offset Offset
-   * @param v Long value
-   * @return byte array given in input
-   */
-  public static byte[] encode(byte[] ba, int offset, long v) {
-    ba[offset + 0] = (byte) (v >>> 56);
-    ba[offset + 1] = (byte) (v >>> 48);
-    ba[offset + 2] = (byte) (v >>> 40);
-    ba[offset + 3] = (byte) (v >>> 32);
-    ba[offset + 4] = (byte) (v >>> 24);
-    ba[offset + 5] = (byte) (v >>> 16);
-    ba[offset + 6] = (byte) (v >>> 8);
-    ba[offset + 7] = (byte) (v >>> 0);
-    return ba;
-  }
-
-  /**
-   * Decode long from byte array at offset
-   * 
-   * @param ba byte array
-   * @param offset Offset 
-   * @return long value
-   */
-  public static long decodeLong(byte[] ba, int offset) {
-    return ((((long) ba[offset + 0] << 56) + ((long) (ba[offset + 1] & 255) << 48) + ((long) (ba[offset + 2] & 255) << 40)
-        + ((long) (ba[offset + 3] & 255) << 32) + ((long) (ba[offset + 4] & 255) << 24) + ((ba[offset + 5] & 255) << 16) + ((ba[offset + 6] & 255) << 8) + ((ba[offset + 7] & 255) << 0)));
-  }
-
-  /**
-   * Decode long from byte array
-   * 
-   * @param ba byte array
-   * @return long value
-   */
-  public static long decodeLong(byte[] ba) {
-    return ((((long) ba[0] << 56) + ((long) (ba[1] & 255) << 48) + ((long) (ba[2] & 255) << 40) + ((long) (ba[3] & 255) << 32) + ((long) (ba[4] & 255) << 24)
-        + ((ba[5] & 255) << 16) + ((ba[6] & 255) << 8) + ((ba[7] & 255) << 0)));
-  
-  }
-
-  /**
-   * Concatenate several byte arrays into one
-   * 
-   * @param byteArrays List of byte arrays
-   * @return concatenated byte array
-   */
-  public static byte[] concat(byte[]... byteArrays) {
-    ArrayBytes[] bs = new ArrayBytes[byteArrays.length];
-    for (int i = 0; i < byteArrays.length; i++) {
-      bs[i] = new ArrayBytes(byteArrays[i]);
-    }
-    return Bytes.concat(bs).toArray();
-  }
-
-  /**
-   * Convert a Bytes object to Hadoop Text object
-   * 
-   * @param b Bytes
-   * @return Text object
-   */
-  public static Text toText(Bytes b) {
-    if (b.isBackedByArray()) {
-      Text t = new Text(EMPTY);
-      t.set(b.getBackingArray(), b.offset(), b.length());
-      return t;
-    } else {
-      return new Text(b.toArray());
-    }
-  }
-  
-  /**
-   * Convert a Bytes object to ByteSequence object
-   * 
-   * @param b Bytes
-   * @return ByteSequence object
-   */
-  public static ByteSequence toByteSequence(Bytes b) {
-    if (b.isBackedByArray()) {
-      return new ArrayByteSequence(b.getBackingArray(), b.offset(), b.length());
-    } else {
-      return new ArrayByteSequence(b.toArray());
-    }
-  }
-}
diff --git a/modules/api/src/main/java/io/fluo/api/data/impl/SpanUtil.java b/modules/api/src/main/java/io/fluo/api/data/impl/SpanUtil.java
deleted file mode 100644
index b17d3985..00000000
--- a/modules/api/src/main/java/io/fluo/api/data/impl/SpanUtil.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.data.impl;
-
-import io.fluo.api.data.Bytes;
-import io.fluo.api.data.Column;
-import io.fluo.api.data.RowColumn;
-import io.fluo.api.data.Span;
-import org.apache.accumulo.core.data.Key;
-import org.apache.accumulo.core.data.Range;
-import org.apache.hadoop.io.Text;
-
-/**
- * Utility methods for manipulating Spans
- */
-public class SpanUtil {
-  
-  private SpanUtil() {}
-  
-  /**
-   * Converts a Fluo Span to Accumulo Range
-   * 
-   * @param span Span
-   * @return Range
-   */
-  public static Range toRange(Span span) {
-    return new Range(toKey(span.getStart()), span.isStartInclusive(), toKey(span.getEnd()), span.isEndInclusive());
-  }
-  
-  /**
-   * Converts from a Fluo RowColumn to a Accumulo Key
-   * 
-   * @param rc RowColumn
-   * @return Key
-   */
-  public static Key toKey(RowColumn rc) {
-    if ((rc == null) || (rc.getRow().equals(Bytes.EMPTY))) {
-      return null;
-    }
-    Text row = ByteUtil.toText(rc.getRow());
-    if ((rc.getColumn().equals(Column.EMPTY)) || (rc.getColumn().getFamily().equals(Bytes.EMPTY))) {
-      return new Key(row);
-    }
-    Text cf = ByteUtil.toText(rc.getColumn().getFamily());
-    if (rc.getColumn().getQualifier().equals(Bytes.EMPTY)) {
-      return new Key(row, cf);
-    }
-    Text cq = ByteUtil.toText(rc.getColumn().getQualifier());
-    if (rc.getColumn().getVisibility().equals(Bytes.EMPTY)) {
-      return new Key(row, cf, cq);
-    }
-    Text cv = ByteUtil.toText(rc.getColumn().getVisibility());
-    return new Key(row, cf, cq, cv);
-  }
-  
-  /**
-   * Converts an Accumulo Range to a Fluo Span
-   * 
-   * @param range Range
-   * @return Span
-   */
-  public static Span toSpan(Range range) {
-    return new Span(toRowColumn(range.getStartKey()), range.isStartKeyInclusive(), 
-                    toRowColumn(range.getEndKey()), range.isEndKeyInclusive());
-  }
-  
-  /**
-   * Converts from an Accumulo Key to a Fluo RowColumn
-   * 
-   * @param key Key
-   * @return RowColumn
-   */
-  public static RowColumn toRowColumn(Key key) {
-    if (key == null) {
-      return RowColumn.EMPTY;
-    }
-    if ((key.getRow() == null) || key.getRow().getLength() == 0) {
-      return RowColumn.EMPTY;
-    }
-    Bytes row = new ArrayBytes(key.getRow());
-    if ((key.getColumnFamily() == null) || key.getColumnFamily().getLength() == 0) {
-      return new RowColumn(row);
-    }
-    Bytes cf = new ArrayBytes(key.getColumnFamily());
-    if ((key.getColumnQualifier() == null) || key.getColumnQualifier().getLength() == 0) {
-      return new RowColumn(row, new Column(cf));
-    }
-    Bytes cq = new ArrayBytes(key.getColumnQualifier());
-    if ((key.getColumnVisibility() == null) || key.getColumnVisibility().getLength() == 0) {
-      return new RowColumn(row, new Column(cf, cq));
-    }
-    Bytes cv = new ArrayBytes(key.getColumnVisibility());
-    return new RowColumn(row, new Column(cf, cq, cv));
-  }
-}
diff --git a/modules/api/src/test/java/io/fluo/api/data/BytesTest.java b/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
index 7c703a75..22c404dd 100644
--- a/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
+++ b/modules/api/src/test/java/io/fluo/api/data/BytesTest.java
@@ -20,7 +20,6 @@ import java.nio.ByteBuffer;
 import java.util.List;
 
 import io.fluo.api.data.impl.ArrayBytes;
-import io.fluo.api.data.impl.ByteUtil;
 import org.apache.accumulo.core.data.ArrayByteSequence;
 import org.apache.accumulo.core.data.ByteSequence;
 import org.apache.hadoop.io.Text;
@@ -62,7 +61,6 @@ public class BytesTest {
     Text t5 = new Text(s5);
     ArrayBytes b5 = new ArrayBytes(s5);
     Assert.assertEquals(t5, b5.toText());
-    Assert.assertEquals(t5, ByteUtil.toText(b5));
   }
   
   @Test
diff --git a/modules/api/src/test/java/io/fluo/api/data/SpanTest.java b/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
index d0744f48..504bde61 100644
--- a/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
+++ b/modules/api/src/test/java/io/fluo/api/data/SpanTest.java
@@ -130,4 +130,101 @@ public class SpanTest {
     Assert.assertEquals(new Span(frc1, true, rc2, false), 
         new Span.Builder().startRow(rw1b).cf(cf1b).cq(cq1b).cv(cv1b).exclusive().endRow(rw2b).cf(cf2b).cq(cq2b).cv(cv2b).exclusive().build());
   }
+  
+  @Test
+  public void testExactSpan() {
+    Span s = Span.exact(rw1b);
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(Column.EMPTY, s.getStart().getColumn());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(new RowColumn(rw1b).following().getRow(), s.getEnd().getRow());
+    Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
+    Assert.assertFalse(s.isEndInclusive());
+    
+    s = Span.exact(rw1b, cf1b);
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
+    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getQualifier());
+    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getVisibility());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(rw1b, s.getEnd().getRow());
+    Assert.assertEquals(new RowColumn(rw1b, new Column(cf1b)).following().getColumn().getFamily(),
+                        s.getEnd().getColumn().getFamily());
+    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getQualifier());
+    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.isEndInclusive());
+    
+    s = Span.exact(rw1b, cf1b, cq1b);
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
+    Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier()); 
+    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getVisibility());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(rw1b, s.getEnd().getRow());
+    Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
+    Assert.assertEquals(new RowColumn(rw1b, new Column(cf1b, cq1b)).following().getColumn().getQualifier(),
+                        s.getEnd().getColumn().getQualifier());
+    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.isEndInclusive());
+    
+    s = Span.exact(rw1b, cf1b, cq1b, cv1b);
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
+    Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier()); 
+    Assert.assertEquals(cv1b, s.getStart().getColumn().getVisibility());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(rw1b, s.getEnd().getRow());
+    Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
+    Assert.assertEquals(cq1b, s.getEnd().getColumn().getQualifier());
+    Assert.assertEquals(new RowColumn(rw1b, new Column(cf1b, cq1b, cv1b)).following().getColumn().getVisibility(),
+                        s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.isEndInclusive());
+  }
+  
+  @Test
+  public void testPrefixSpan() {
+    Span s = Span.prefix(rw1b);
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(Column.EMPTY, s.getStart().getColumn());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(rw2b, s.getEnd().getRow());
+    Assert.assertEquals(Column.EMPTY, s.getEnd().getColumn());
+    Assert.assertFalse(s.isEndInclusive());
+    
+    s = Span.prefix(rw1b, cf1b);
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
+    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getQualifier());
+    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getVisibility());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(cf2b, s.getEnd().getColumn().getFamily());
+    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getQualifier());
+    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.isEndInclusive());
+    
+    s = Span.prefix(rw1b, cf1b, cq1b);
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
+    Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier());
+    Assert.assertEquals(Bytes.EMPTY, s.getStart().getColumn().getVisibility());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
+    Assert.assertEquals(cq2b, s.getEnd().getColumn().getQualifier());
+    Assert.assertEquals(Bytes.EMPTY, s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.isEndInclusive());
+    
+    s = Span.prefix(rw1b, cf1b, cq1b, cv1b);
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(cf1b, s.getStart().getColumn().getFamily());
+    Assert.assertEquals(cq1b, s.getStart().getColumn().getQualifier());
+    Assert.assertEquals(cv1b, s.getStart().getColumn().getVisibility());
+    Assert.assertTrue(s.isStartInclusive());
+    Assert.assertEquals(rw1b, s.getStart().getRow());
+    Assert.assertEquals(cf1b, s.getEnd().getColumn().getFamily());
+    Assert.assertEquals(cq1b, s.getEnd().getColumn().getQualifier());
+    Assert.assertEquals(cv2b, s.getEnd().getColumn().getVisibility());
+    Assert.assertFalse(s.isEndInclusive());
+  }
 }
diff --git a/modules/api/src/test/java/io/fluo/api/data/impl/SpanUtilTest.java b/modules/api/src/test/java/io/fluo/api/data/impl/SpanUtilTest.java
deleted file mode 100644
index 5dbf1dcc..00000000
--- a/modules/api/src/test/java/io/fluo/api/data/impl/SpanUtilTest.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.fluo.api.data.impl;
-
-import io.fluo.api.data.Column;
-import io.fluo.api.data.RowColumn;
-import org.apache.accumulo.core.data.Key;
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- * Tests SpanUtil Class
- */
-public class SpanUtilTest {
-  
-  @Test
-  public void testToKey() {
-    Assert.assertEquals(null, SpanUtil.toKey(null));
-    Assert.assertEquals(new Key("row"), SpanUtil.toKey(new RowColumn("row")));
-    Assert.assertEquals(new Key("row", "cf"), SpanUtil.toKey(new RowColumn("row", new Column("cf"))));
-    Assert.assertEquals(new Key("row", "cf", "cq"), SpanUtil.toKey(new RowColumn("row", new Column("cf", "cq"))));
-    Assert.assertEquals(new Key("row", "cf", "cq", "cv"), SpanUtil.toKey(new RowColumn("row", new Column("cf", "cq", "cv"))));
-  }
-  
-  @Test
-  public void testToRowColumn() {
-    Assert.assertEquals(RowColumn.EMPTY, SpanUtil.toRowColumn(null));
-    Assert.assertEquals(new RowColumn("row"), SpanUtil.toRowColumn(new Key("row")));
-    Assert.assertEquals(new RowColumn("row", new Column("cf")), SpanUtil.toRowColumn(new Key("row", "cf")));
-    Assert.assertEquals(new RowColumn("row", new Column("cf", "cq")), SpanUtil.toRowColumn(new Key("row", "cf", "cq")));
-    Assert.assertEquals(new RowColumn("row", new Column("cf", "cq", "cv")), SpanUtil.toRowColumn(new Key("row", "cf", "cq", "cv")));
-  }
-}
