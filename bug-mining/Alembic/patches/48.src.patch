diff --git a/alembic/autogenerate/compare.py b/alembic/autogenerate/compare.py
index bba6740..3a35208 100644
--- a/alembic/autogenerate/compare.py
+++ b/alembic/autogenerate/compare.py
@@ -119,6 +119,7 @@ def _compare_tables(conn_table_names, metadata_table_names,
 
 
 def _make_index(params, conn_table):
+    # TODO: add .info such as 'duplicates_constraint'
     return sa_schema.Index(
         params['name'],
         *[conn_table.c[cname] for cname in params['column_names']],
@@ -127,6 +128,7 @@ def _make_index(params, conn_table):
 
 
 def _make_unique_constraint(params, conn_table):
+    # TODO: add .info such as 'duplicates_index'
     return sa_schema.UniqueConstraint(
         *[conn_table.c[cname] for cname in params['column_names']],
         name=params['name']
diff --git a/alembic/ddl/mysql.py b/alembic/ddl/mysql.py
index 29973fe..aac8184 100644
--- a/alembic/ddl/mysql.py
+++ b/alembic/ddl/mysql.py
@@ -92,6 +92,10 @@ class MySQLImpl(DefaultImpl):
                                         conn_indexes,
                                         metadata_unique_constraints,
                                         metadata_indexes):
+
+        # TODO: if SQLA 1.0, make use of "duplicates_index"
+        # metadata
+
         removed = set()
         for idx in list(conn_indexes):
             # MySQL puts implicit indexes on FK columns, even if
diff --git a/alembic/ddl/postgresql.py b/alembic/ddl/postgresql.py
index 5156cea..0877c95 100644
--- a/alembic/ddl/postgresql.py
+++ b/alembic/ddl/postgresql.py
@@ -75,6 +75,25 @@ class PostgresqlImpl(DefaultImpl):
                         # its a SERIAL - whack it!
                         del column_info['default']
 
+    def correct_for_autogen_constraints(self, conn_unique_constraints,
+                                        conn_indexes,
+                                        metadata_unique_constraints,
+                                        metadata_indexes):
+        conn_uniques_by_name = dict(
+            (c.name, c) for c in conn_unique_constraints)
+        conn_indexes_by_name = dict(
+            (c.name, c) for c in conn_indexes)
+
+        # TODO: if SQLA 1.0, make use of "duplicates_constraint"
+        # metadata
+        doubled_constraints = dict(
+            (name, (conn_uniques_by_name[name], conn_indexes_by_name[name]))
+            for name in set(conn_uniques_by_name).intersection(
+                conn_indexes_by_name)
+        )
+        for name, (uq, ix) in doubled_constraints.items():
+            conn_indexes.remove(ix)
+
 
 @compiles(RenameTable, "postgresql")
 def visit_rename_table(element, compiler, **kw):
diff --git a/docs/build/changelog.rst b/docs/build/changelog.rst
index 0fb0bb4..36a5e77 100644
--- a/docs/build/changelog.rst
+++ b/docs/build/changelog.rst
@@ -56,6 +56,16 @@ Changelog
 
           :ref:`batch_migrations`
 
+    .. change::
+      :tags: bug, autogenerate, postgresql
+      :tickets: 247
+
+      Added a rule for Postgresql to not render a "drop unique" and "drop index"
+      given the same name; for now it is assumed that the "index" is the
+      implicit one Postgreql generates.   Future integration with
+      new SQLAlchemy 1.0 features will improve this to be more
+      resilient.
+
     .. change::
       :tags: bug, autogenerate
       :tickets: 247
diff --git a/tests/test_autogen_indexes.py b/tests/test_autogen_indexes.py
index 86d4af6..ad839c8 100644
--- a/tests/test_autogen_indexes.py
+++ b/tests/test_autogen_indexes.py
@@ -553,6 +553,25 @@ class PGUniqueIndexTest(AutogenerateUniqueIndexTest):
         eq_(diffs[0][0], "add_table")
         eq_(len(diffs), 1)
 
+    def test_uq_dropped(self):
+        m1 = MetaData()
+        m2 = MetaData()
+        Table(
+            'add_uq', m1,
+            Column('id', Integer, primary_key=True),
+            Column('name', String),
+            UniqueConstraint('name', name='uq_name')
+        )
+        Table(
+            'add_uq', m2,
+            Column('id', Integer, primary_key=True),
+            Column('name', String),
+        )
+        diffs = self._fixture(m1, m2, include_schemas=True)
+        eq_(diffs[0][0], "remove_constraint")
+        eq_(diffs[0][1].name, "uq_name")
+        eq_(len(diffs), 1)
+
 
 class MySQLUniqueIndexTest(AutogenerateUniqueIndexTest):
     reports_unnamed_constraints = True
