{"url":"https://api.github.com/repos/sqlalchemy/alembic/issues/167","repository_url":"https://api.github.com/repos/sqlalchemy/alembic","labels_url":"https://api.github.com/repos/sqlalchemy/alembic/issues/167/labels{/name}","comments_url":"https://api.github.com/repos/sqlalchemy/alembic/issues/167/comments","events_url":"https://api.github.com/repos/sqlalchemy/alembic/issues/167/events","html_url":"https://github.com/sqlalchemy/alembic/issues/167","id":384601158,"node_id":"MDU6SXNzdWUzODQ2MDExNTg=","number":167,"title":"multiple heads / branch resolution support","user":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":1141242821,"node_id":"MDU6TGFiZWwxMTQxMjQyODIx","url":"https://api.github.com/repos/sqlalchemy/alembic/labels/feature","name":"feature","color":"801010","default":false,"description":null},{"id":1141243076,"node_id":"MDU6TGFiZWwxMTQxMjQzMDc2","url":"https://api.github.com/repos/sqlalchemy/alembic/labels/high%20priority","name":"high priority","color":"8030B0","default":false,"description":null},{"id":1141243687,"node_id":"MDU6TGFiZWwxMTQxMjQzNjg3","url":"https://api.github.com/repos/sqlalchemy/alembic/labels/versioning%20model","name":"versioning model","color":"F06040","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":{"url":"https://api.github.com/repos/sqlalchemy/alembic/milestones/2","html_url":"https://github.com/sqlalchemy/alembic/milestone/2","labels_url":"https://api.github.com/repos/sqlalchemy/alembic/milestones/2/labels","id":3850498,"node_id":"MDk6TWlsZXN0b25lMzg1MDQ5OA==","number":2,"title":"tier 1","description":null,"creator":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":0,"closed_issues":24,"state":"closed","created_at":"2018-11-27T03:04:06Z","updated_at":"2020-04-10T15:00:48Z","due_on":null,"closed_at":"2020-04-10T15:00:48Z"},"comments":18,"created_at":"2014-01-20T18:10:07Z","updated_at":"2014-11-23T15:04:06Z","closed_at":"2014-11-20T23:18:49Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"**Migrated issue, originally created by Michael Bayer ([@zzzeek](https://github.com/zzzeek))**\n\nthis is a continuation of issue #114, which introduces the problem of merging revision branches that are also applied to target databases already.   In that issue, it took me a *really* long time to get my sluggish mind around it and even after I \"got it\" I think my thinking was still muddy.   Perhaps it still is now, but I'd like to re-establish this as a feature add with my latest thinking on it.\n\nI've spent many months thinking about #114 and what always disturbed me was how to cleanly address my notion that to support a DAG (directed acyclic graph), we need to store *every node* that's been invoked in the versions table.    Doing so would mean that all existing alembic version tables would need to be \"upgraded\", having every version that's been invoked be written out to the table.  This in itself is extremely difficult to manage, especially for shops using flat SQL files to maintain versions on production databases which would need some special migration script that has a huge series of INSERT statements.   And then, once the version table has been populated in this new way, now you can't use an older version of Alembic anymore either.    *And*, you can't even easily tell what the \"head\" version is anymore without reconciling the version table with the structure of the version scripts themselves.\n\nI can only assume that the use case I was thinking was needed, is the one that we talk about in the documentation; that of knitting together two branches into a single line:\n\n    A -> B -> Cb1 -> Db1 -> Eb1\n\n    A -> B -> Cb2 -> Db2\n\nbecomes\n\n    A -> B -> Cb1 -> Db1 -> Eb1 -> Cb2 -> Db2\n\nthat is, we knitted 'b1' and 'b2' into a single line - this is how we say to do it in the \"Working with Branches\" documentation (e.g. \"splice\").  So for alembic to figure out on databases that previously only had \"b2\" applied that \"b1\" also needs to be applied,  it needs to examine the version table for every version and find those that aren't present.\n\nBut this really shouldn't be necessary.    My thinking above is still missing the fact that as we support a DAG, we support *multiple heads*, which can be reconciled in the traditional way, using a branch point.    For Alembic to determine which migrations are necessary in order to reconcile multiple heads only needs to store just what any other VCS stores, *the heads*.\n\nThe use case in the docs of \"splicing\" two branch points into a single line just wouldn't be necessary anymore.  And in fact the manual editing of files wouldn't be needed anymore.  The `ScriptDirectory` object already knows how to recognize multiple heads.   All we need to do is have the migration system track these multiple heads as it proceeds.   It also makes trivial the notion of an \"alembic merge\" command, which does nothing more than create a migration file that declares all the current heads as its dependencies.  The only need for this file is to keep the migration stream clean; it would not be at all necessary and the system could be used in the \"pure DAG\" format suggested in #114 as an alternative mode of operation.\n\nSuppose we start with a migration series like the above, with two heads:\n\n    A -> B -> Cb1 -> Db1 -> Eb1\n           -> Cb2 -> Db2\n\nA target database which is at version `Db1` would proceed as follows:\n\n1. Identify `Db1` from `alembic_version` as the current \"head\".\n\n2. Identify `Eb1` and `Db2` as the current target heads.\n\n3. As `Db1` is the actual head invoked, we can determine that the full set of migration files that have been run is `A`, `B`, `Cb1`, `Db1`.  We automatically know that `Cb2` and `Db2` also need to be run.\n\n4. We invoke `Eb1`, and upgrade this particular branch point in the version table.    The current SQL for this is `UPDATE alembic_version SET version='Eb1'`.   All we have to do is change this SQL to read `UPDATE alembic_version SET version='Eb1' WHERE version='Db1'`.  That is, our UPDATE statements are now always local to a single head, and other heads in the version table remain unaffected.\n\n5. We then attend to `b2`.  We invoke `Cb2`, and upgrade this particular branch point in the version table.  We know that this branch isn't present, so we invoke `INSERT INTO alembic_version VALUES ('Cb2')`.\n\n6. We continue on `b2` and invoke `Db2`.   We upgrade in alembic version via `UPDATE alembic_version SET version='Db2' WHERE version='Cb2'`.  \n\n7. We now have two heads in the alembic_version table, and we are done.\n\nNow, most users probably don't want to work in this mode, where they just maintain two heads like that.  These users will want to create a \"merge point\", like this:\n\n\n    A -> B -> Cb1 -> Db1 -> Eb1  -> Eb1Db2_merge\n           -> Cb2 -> Db2         ->\n\nAlembic can by default deliver its usual message, \"version history has two heads\" (or three, or whatever), and suggest running `alembic merge` to create a merge point.  The command just creates a new version file corresponding above to `Eb1Db2_merge`.\n\nThe process for taking our database from version `Db1` to `Eb1Db2_merge` looks like this:\n\n1. Identify `Db1` from `alembic_version` as the current \"head\".\n\n2. Identify `Eb1Db2_merge` as the current target head.\n\n3. Upon detection that `Eb1Db2_merge` has multiple parents, we again move to handle multiple heads at this point, and we go back to step 2 from the previous list of instructions.\n\n4. Upon completion of the \"multiple heads\" use case, we now have `Eb1` and `Db2` in alembic_version.  We choose a single one of the heads as the UPDATE target and delete the rest:   `DELETE FROM alembic_version WHERE version='Db2'`;   `UPDATE alembic_version SET version='Eb1Db2_merge' WHERE version='Eb1'`.\n\n5. We're back to a single head.\n\nUsing this system, we now no longer have *any* upgrade path for users that upgrade to an Alembic that supports this feature; their alembic_version table is already in the correct format.  These users can, if they choose, immediately start working with multiple heads and/or merge points, or not; the data written to alembic_version doesn't change.  \n\nThe `alembic revision` command will behave as follows:\n\n1. When run on a series of migration files that only have a single head, the behavior is as it is now; a new file is created with the parent referring to this single head.\n\n2. When run on a series of files that have multiple heads, currently we deliver an error about \"only a single head supported; manually edit the files\".   This error will be altered to read: \"multiple heads are present.  Please merge these using `alembic merge`, or specify an explicit parent revision to work with multiple heads\".\n\n3. The user can either specify an explicit parent revision, as in `alembic revision -p <parent_revision>`, which will make this new file refer to that parent alone, or they can run `alembic merge`, which will create a do-nothing \"merge point\" which specifies all current heads as parents.   This \"merge point\" file can of course be edited to refer only to specific heads if desired.  The \"merge point\" reconciles the multiple heads back into one version, and invoking `alembic revision` again would use this merge point as the parent.\n\n4. the `-p` / `--parent` option to `alembic revision` must validate that the given parent version is in fact a head.\n\n","closed_by":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sqlalchemy/alembic/issues/167/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sqlalchemy/alembic/issues/167/timeline","performed_via_github_app":null,"state_reason":"completed"}