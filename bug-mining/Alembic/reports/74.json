{"url":"https://api.github.com/repos/sqlalchemy/alembic/issues/297","repository_url":"https://api.github.com/repos/sqlalchemy/alembic","labels_url":"https://api.github.com/repos/sqlalchemy/alembic/issues/297/labels{/name}","comments_url":"https://api.github.com/repos/sqlalchemy/alembic/issues/297/comments","events_url":"https://api.github.com/repos/sqlalchemy/alembic/issues/297/events","html_url":"https://github.com/sqlalchemy/alembic/issues/297","id":384602373,"node_id":"MDU6SXNzdWUzODQ2MDIzNzM=","number":297,"title":"transition from multiple revs to one as a mergepoint, however a different merge from the same revs has already proceeded","user":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":1141241826,"node_id":"MDU6TGFiZWwxMTQxMjQxODI2","url":"https://api.github.com/repos/sqlalchemy/alembic/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"},{"id":1141243076,"node_id":"MDU6TGFiZWwxMTQxMjQzMDc2","url":"https://api.github.com/repos/sqlalchemy/alembic/labels/high%20priority","name":"high priority","color":"8030B0","default":false,"description":null},{"id":1141243687,"node_id":"MDU6TGFiZWwxMTQxMjQzNjg3","url":"https://api.github.com/repos/sqlalchemy/alembic/labels/versioning%20model","name":"versioning model","color":"F06040","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":{"url":"https://api.github.com/repos/sqlalchemy/alembic/milestones/4","html_url":"https://github.com/sqlalchemy/alembic/milestone/4","labels_url":"https://api.github.com/repos/sqlalchemy/alembic/milestones/4/labels","id":3850500,"node_id":"MDk6TWlsZXN0b25lMzg1MDUwMA==","number":4,"title":"fasttrack","description":null,"creator":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":0,"closed_issues":47,"state":"closed","created_at":"2018-11-27T03:05:33Z","updated_at":"2020-04-10T15:00:46Z","due_on":null,"closed_at":"2020-04-10T15:00:46Z"},"comments":2,"created_at":"2015-05-03T23:58:49Z","updated_at":"2015-05-04T00:17:38Z","closed_at":"2015-05-04T00:17:38Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"**Migrated issue, originally created by Michael Bayer ([@zzzeek](https://github.com/zzzeek))**\n\n\n```\nclass TwinMergeTest(MigrationTest):\n    \"\"\"Test #XYZ, where we have two mergepoints from the same set of\n    originating branches.\n\n    \"\"\"\n    @classmethod\n    def setup_class(cls):\n        \"\"\"\n\n        33e21c000cfe -> 178d4e761bbd (head),\n        2bef33cb3a58, 3904558db1c6, 968330f320d -> 33e21c000cfe (mergepoint)\n        46c99f866004 -> 18f46b42410d (head),\n        2bef33cb3a58, 3904558db1c6, 968330f320d -> 46c99f866004 (mergepoint)\n        f0fa4315825 -> 3904558db1c6 (branchpoint),\n\n        --------------------------\n\n        A -> B2 (branchpoint),\n\n        B1, B2, B3 -> C1 (mergepoint)\n        B1, B2, B3 -> C2 (mergepoint)\n\n        C1 -> D1 (head),\n\n        C2 -> D2 (head),\n\n\n        \"\"\"\n        cls.env = env = staging_env()\n\n        cls.a = env.generate_revision(\n            'a', 'a'\n        )\n        cls.b1 = env.generate_revision('b1', 'b1',\n                                       head=cls.a.revision)\n        cls.b2 = env.generate_revision('b2', 'b2',\n                                       splice=True,\n                                       head=cls.a.revision)\n        cls.b3 = env.generate_revision('b3', 'b3',\n                                       splice=True,\n                                       head=cls.a.revision)\n\n        cls.c1 = env.generate_revision(\n            'c1', 'c1',\n            head=(cls.b1.revision, cls.b2.revision, cls.b3.revision))\n\n        cls.c2 = env.generate_revision(\n            'c2', 'c2',\n            splice=True,\n            head=(cls.b1.revision, cls.b2.revision, cls.b3.revision))\n\n        cls.d1 = env.generate_revision(\n            'd1', 'd1', head=cls.c1.revision)\n\n        cls.d2 = env.generate_revision(\n            'd2', 'd2', head=cls.c2.revision)\n\n    def test_upgrade(self):\n        head = HeadMaintainer(mock.Mock(), [self.a.revision])\n\n        steps = [\n            (self.up_(self.b3), ('b3',)),\n            (self.up_(self.b1), ('b1', 'b3',)),\n            (self.up_(self.b2), ('b1', 'b2', 'b3',)),\n            (self.up_(self.c2), ('c2',)),\n            (self.up_(self.d2), ('d2',)),\n            (self.up_(self.c1), ('c1', 'd2')),\n            (self.up_(self.d1), ('d1', 'd2')),\n        ]\n        for step, assert_ in steps:\n            head.update_to_step(step)\n            eq_(head.heads, set(assert_))\n\n```\n\n```\n#!\n\n\n\nTraceback (most recent call last):\n  File \"/Users/classic/dev/alembic/tests/test_version_traversal.py\", line 507, in test_upgrade\n    head.update_to_step(step)\n  File \"/Users/classic/dev/alembic/alembic/migration.py\", line 495, in update_to_step\n    from_, to_ = step.update_version_num(self.heads)\n  File \"/Users/classic/dev/alembic/alembic/migration.py\", line 709, in update_version_num\n    \"Can't do an UPDATE because downrevision is ambiguous\"\nAssertionError: Can't do an UPDATE because downrevision is ambiguous\n```\n\n\nAssume a tree like this:\n\n```\n#!\n\n\n        A -> B1,\n        A -> B2,\n        A -> B3,\n\n        B1, B2, B3 -> C1\n        B1, B2, B3 -> C2\n\n        C1 -> D1 (head),\n\n        C2 -> D2 (head),\n\n```\n\nThe steps to upgrade from A to D1/D2 come out normally:\n\n\n```\n#!\n\nupgrade a -> b3, b3\nupgrade a -> b1, b1\nupgrade a -> b2, b2\nupgrade b1, b2, b3 -> c2, c2\nupgrade c2 -> d2, d2\nupgrade b1, b2, b3 -> c1, c1\nupgrade c1 -> d1, d1\n\n```\n\nThe transitions come out as:\n\n\n```\n#!\n\nDEBUG:alembic.migration:update a to b3\nDEBUG:alembic.migration:new branch insert b1\nDEBUG:alembic.migration:new branch insert b2\nDEBUG:alembic.migration:merge, delete ['b1', 'b2'], update b3 to c2\nDEBUG:alembic.migration:update c2 to d2\n\n```\n\nIt then crashes on b1, b2, b3 -> c1, because it thinks it's supposed to to an UPDATE, but there is no row to UPDATE because all three of b1, b2, b3 are gone.  What it really should do here is an INSERT of c1.   \n\nThe internal mechanics ask the question, \"if we have more than one anscestor, we're a MERGE point, therefore we definitely aren't INSERTing an identifier\".  They also assert that, \"if we have only one anscestor, we're not a MERGE point, so if our ansestor *is* in the current heads, we do an UPDATE and if it isn't, we do an INSERT\".     The logic here can be simplified, such that, \"if none of our ancestors are in the current heads, we do an INSERT\":\n\n\n\n```\ndiff --git a/alembic/migration.py b/alembic/migration.py\nindex 9bd34ed..d94db2e 100644\n--- a/alembic/migration.py\n+++ b/alembic/migration.py\n@@ -670,14 +670,15 @@ class RevisionStep(MigrationStep):\n         if not downrevs:\n             # is a base\n             return True\n-        elif len(downrevs) == 1:\n-            if downrevs[0] in heads:\n-                return False\n-            else:\n-                return True\n         else:\n-            # is a merge point\n-            return False\n+            # none of our downrevs are present, so...\n+            # we have to insert our version.   This is true whether\n+            # or not there is only one downrev, or multiple (in the latter\n+            # case, we're a merge point.)\n+            if not heads.intersection(downrevs):\n+                return True\n+            else:\n+                return False\n \n     def should_merge_branches(self, heads):\n         if not self.is_upgrade:\n\n```\n\n","closed_by":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sqlalchemy/alembic/issues/297/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sqlalchemy/alembic/issues/297/timeline","performed_via_github_app":null,"state_reason":"completed"}