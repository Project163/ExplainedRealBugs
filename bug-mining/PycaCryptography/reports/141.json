{"url":"https://api.github.com/repos/pyca/cryptography/issues/10553","repository_url":"https://api.github.com/repos/pyca/cryptography","labels_url":"https://api.github.com/repos/pyca/cryptography/issues/10553/labels{/name}","comments_url":"https://api.github.com/repos/pyca/cryptography/issues/10553/comments","events_url":"https://api.github.com/repos/pyca/cryptography/issues/10553/events","html_url":"https://github.com/pyca/cryptography/issues/10553","id":2176471556,"node_id":"I_kwDOALYunM6BulIE","number":10553,"title":"X509 CommonName fields are not validated for length during certificate creation","user":{"login":"vEpiphyte","id":26100278,"node_id":"MDQ6VXNlcjI2MTAwMjc4","avatar_url":"https://avatars.githubusercontent.com/u/26100278?v=4","gravatar_id":"","url":"https://api.github.com/users/vEpiphyte","html_url":"https://github.com/vEpiphyte","followers_url":"https://api.github.com/users/vEpiphyte/followers","following_url":"https://api.github.com/users/vEpiphyte/following{/other_user}","gists_url":"https://api.github.com/users/vEpiphyte/gists{/gist_id}","starred_url":"https://api.github.com/users/vEpiphyte/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vEpiphyte/subscriptions","organizations_url":"https://api.github.com/users/vEpiphyte/orgs","repos_url":"https://api.github.com/users/vEpiphyte/repos","events_url":"https://api.github.com/users/vEpiphyte/events{/privacy}","received_events_url":"https://api.github.com/users/vEpiphyte/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":198687536,"node_id":"MDU6TGFiZWwxOTg2ODc1MzY=","url":"https://api.github.com/repos/pyca/cryptography/labels/x509","name":"x509","color":"fef2c0","default":false,"description":null}],"state":"closed","locked":true,"assignee":null,"assignees":[],"milestone":{"url":"https://api.github.com/repos/pyca/cryptography/milestones/45","html_url":"https://github.com/pyca/cryptography/milestone/45","labels_url":"https://api.github.com/repos/pyca/cryptography/milestones/45/labels","id":10277798,"node_id":"MI_kwDOALYunM4AnNOm","number":45,"title":"Forty Third Release","description":"","creator":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":0,"closed_issues":20,"state":"closed","created_at":"2023-12-06T22:44:54Z","updated_at":"2024-07-20T16:40:26Z","due_on":null,"closed_at":"2024-07-20T16:40:26Z"},"comments":0,"created_at":"2024-03-08T17:28:02Z","updated_at":"2024-10-04T03:08:14Z","closed_at":"2024-07-05T23:27:41Z","author_association":"NONE","type":null,"active_lock_reason":"resolved","sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Hi PYCA team!\r\n\r\nWhen investigating a difference in behavior with PyOpenSSL behavior, I came across potential issue with X509 certificate creation in cryptography. The current version of the cryptography package can be used to **create** X509 certificates with common name values as empty strings, and with strings that are >64 characters in length. This is a deviation from rfc5280 ( https://datatracker.ietf.org/doc/html/rfc5280#appendix-A.1 ) where ``CommonName`` is defined as ``CommonName ::= PrintableString (SIZE (1..ub-common-name-length))`` and ``ub-common-name-length`` is`` ub-common-name-length INTEGER ::= 64``. The cryptography library allows setting common name values to zero length strings and strings > 64 characters in length.\r\n\r\nI am **not** concerned about the ability to **read** a certificate with a CN field that is not conforming with the length specifications, as its clearly possible for in-the-wild certificates to be created with these values. Similar to #10247 there is a good value in being able to read such certificates.\r\n\r\nPython version and library components:\r\n\r\n```\r\n$ python -V\r\nPython 3.11.4\r\n$ python -m pip list | grep -E \"cryptography|pip|cffi|setuptools\"\r\ncffi                          1.15.1\r\ncryptography                  42.0.5\r\npip                           23.2.1\r\nsetuptools                    68.0.0\r\n```\r\n\r\nCryptography was installed from pypi using the cryptography-42.0.5-cp39-abi3-manylinux_2_28_x86_64.whl\r\n\r\nExample code to make some CA certs with these invalid properties:\r\n\r\n```\r\nimport os\r\nimport sys\r\nimport binascii\r\nimport datetime\r\n\r\nONE_YEAR_TD = datetime.timedelta(days=365)\r\n\r\nimport cryptography.x509 as c_x509\r\nimport cryptography.hazmat.primitives.hashes as c_hashes\r\nimport cryptography.hazmat.primitives.asymmetric.rsa as c_rsa\r\nimport cryptography.hazmat.primitives.serialization as c_serialization\r\n\r\ndef genCert(cname: str, prvkey: c_rsa.RSAPrivateKey) -> c_x509.Certificate:\r\n\r\n    pubkey = prvkey.public_key()\r\n    builder = c_x509.CertificateBuilder()\r\n    builder = builder.subject_name(c_x509.Name([\r\n        c_x509.NameAttribute(c_x509.NameOID.COMMON_NAME, cname),\r\n    ]))\r\n\r\n    now = datetime.datetime.now(datetime.UTC)\r\n    builder = builder.not_valid_before(now)\r\n    builder = builder.not_valid_after(now + ONE_YEAR_TD)  # certificates are good for 1 years\r\n    builder = builder.serial_number(int(binascii.hexlify(os.urandom(16)).decode('utf8'), 16))\r\n    builder = builder.public_key(pubkey)\r\n\r\n    # Mark the cert as a CA - it's just an example\r\n    builder = builder.add_extension(c_x509.BasicConstraints(ca=True, path_length=None), critical=False)\r\n\r\n    # Self sign the cert\r\n    builder = builder.issuer_name(c_x509.Name([\r\n        c_x509.NameAttribute(c_x509.NameOID.COMMON_NAME, cname),\r\n    ]))\r\n\r\n    certificate = builder.sign(\r\n        private_key=prvkey, algorithm=c_hashes.SHA256(),\r\n    )\r\n\r\n    return certificate\r\n\r\n\r\ndef main():\r\n\r\n    pkey = c_rsa.generate_private_key(65537, 4096)\r\n\r\n    # Per RFC5280 common-name has a length of 1 to 64 characters ?\r\n    # https://datatracker.ietf.org/doc/html/rfc5280#appendix-A.1\r\n    # CommonName ::= PrintableString (SIZE (1..ub-common-name-length))\r\n\r\n    # cname with 64 + 1 characters\r\n    cname = 'A' * 65\r\n    print(f'Making a CA cert with common name {cname=} {len(cname)=}')\r\n    cert = genCert(cname=cname, prvkey=pkey)\r\n    print(cert)\r\n\r\n    byts = cert.public_bytes(c_serialization.Encoding.PEM)\r\n    with open('long_ca.pem', 'wb') as fd:\r\n        fd.truncate(0)\r\n        fd.write(byts)\r\n    with open('long_ca.key', 'wb') as fd:\r\n        fd.truncate(0)\r\n        fd.write(pkey.private_bytes(encoding=c_serialization.Encoding.PEM,\r\n                                    format=c_serialization.PrivateFormat.TraditionalOpenSSL,\r\n                                    encryption_algorithm=c_serialization.NoEncryption()))\r\n\r\n    # Assert the long common name in new cert object can be read and matches cname\r\n    newcert = c_x509.load_pem_x509_certificate(byts)\r\n    newcert_cname = newcert.subject.get_attributes_for_oid(c_x509.NameOID.COMMON_NAME)[0]\r\n    assert newcert_cname.value == cname\r\n\r\n    # cname with 0 length string\r\n    cname = ''\r\n    print(f'Making a CA cert with common name {cname=} {len(cname)=}')\r\n    cert = genCert(cname=cname, prvkey=pkey)\r\n    print(cert)\r\n\r\n    byts = cert.public_bytes(c_serialization.Encoding.PEM)\r\n    with open('short_ca.pem', 'wb') as fd:\r\n        fd.truncate(0)\r\n        fd.write(byts)\r\n    with open('short_ca.key', 'wb') as fd:\r\n        fd.truncate(0)\r\n        fd.write(pkey.private_bytes(encoding=c_serialization.Encoding.PEM,\r\n                                    format=c_serialization.PrivateFormat.TraditionalOpenSSL,\r\n                                    encryption_algorithm=c_serialization.NoEncryption()))\r\n\r\n    # Assert the long common name in new cert object can be read and matches cname\r\n    newcert = c_x509.load_pem_x509_certificate(byts)\r\n    newcert_cname = newcert.subject.get_attributes_for_oid(c_x509.NameOID.COMMON_NAME)[0]\r\n    assert newcert_cname.value == cname\r\n\r\n    return 0\r\n\r\nif __name__ == '__main__':\r\n    sys.exit(main())\r\n```\r\n\r\nOpenssl ( from ubuntu 22.04 ) is able to read these certificates:\r\n\r\n```\r\n$ openssl version\r\nOpenSSL 3.0.2 15 Mar 2022 (Library: OpenSSL 3.0.2 15 Mar 2022)\r\n$ openssl x509 --noout -subject -in short_ca.pem \r\nsubject=CN = \r\n$ openssl x509 --noout -subject -in long_ca.pem \r\nsubject=CN = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\n\r\n```\r\n\r\nBut openssl cannot create these certificates\r\n\r\n```\r\n$ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 3650 \r\n-nodes -subj \"/CN=qwertyuiopasdfghjklzxcvbnmqwertyuiopasdfghjklzxcvbnm123456789.com\" \r\n<...snip...>\r\n-----\r\n800B18F4C87F0000:error:06800097:asn1 encoding routines:ASN1_mbstring_ncopy:string too long:../crypto/asn1/a_mbstr.c:106:maxsize=64\r\nreq: Error adding subject name attribute \"/CN=qwertyuiopasdfghjklzxcvbnmqwertyuiopasdfghjklzxcvbnm123456789.com\"\r\n```\r\n\r\nLikewise, pyopenssl would fail to make such certificates:\r\n\r\n```\r\n$ python pyopenssl_long_cname.py \r\nMaking a CA cert with common name cname='AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' len(cname)=65\r\n/home/epiphyte/PycharmProjects/synapse/pyopenssl_long_cname.py:22: DeprecationWarning: X509Extension support in pyOpenSSL is deprecated. You should use the APIs in cryptography.\r\n  cert.add_extensions([crypto.X509Extension(b'basicConstraints', False, b'CA:TRUE')])\r\nTraceback (most recent call last):\r\n  File \"/home/epiphyte/PycharmProjects/synapse/pyopenssl_long_cname.py\", line 64, in <module>\r\n    sys.exit(main())\r\n             ^^^^^^\r\n  File \"/home/epiphyte/PycharmProjects/synapse/pyopenssl_long_cname.py\", line 45, in main\r\n    cert = genCert(cname=cname, prvkey=pkey)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/epiphyte/PycharmProjects/synapse/pyopenssl_long_cname.py\", line 25, in genCert\r\n    cert.get_subject().CN = cname\r\n    ^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/epiphyte/.pyenv/versions/3.11.4/envs/syn3114/lib/python3.11/site-packages/OpenSSL/crypto.py\", line 655, in __setattr__\r\n    _raise_current_error()\r\n  File \"/home/epiphyte/.pyenv/versions/3.11.4/envs/syn3114/lib/python3.11/site-packages/OpenSSL/_util.py\", line 57, in exception_from_error_queue\r\n    raise exception_type(errors)\r\nOpenSSL.crypto.Error: [('asn1 encoding routines', '', 'string too long')]\r\n\r\n$ python pyopenssl_short_cname.py \r\nMaking a CA cert with common name cname='' len(cname)=0\r\n/home/epiphyte/PycharmProjects/synapse/pyopenssl_short_cname.py:22: DeprecationWarning: X509Extension support in pyOpenSSL is deprecated. You should use the APIs in cryptography.\r\n  cert.add_extensions([crypto.X509Extension(b'basicConstraints', False, b'CA:TRUE')])\r\nTraceback (most recent call last):\r\n  File \"/home/epiphyte/PycharmProjects/synapse/pyopenssl_short_cname.py\", line 63, in <module>\r\n    sys.exit(main())\r\n             ^^^^^^\r\n  File \"/home/epiphyte/PycharmProjects/synapse/pyopenssl_short_cname.py\", line 45, in main\r\n    cert = genCert(cname=cname, prvkey=pkey)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/epiphyte/PycharmProjects/synapse/pyopenssl_short_cname.py\", line 25, in genCert\r\n    cert.get_subject().CN = cname\r\n    ^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/epiphyte/.pyenv/versions/3.11.4/envs/syn3114/lib/python3.11/site-packages/OpenSSL/crypto.py\", line 655, in __setattr__\r\n    _raise_current_error()\r\n  File \"/home/epiphyte/.pyenv/versions/3.11.4/envs/syn3114/lib/python3.11/site-packages/OpenSSL/_util.py\", line 57, in exception_from_error_queue\r\n    raise exception_type(errors)\r\nOpenSSL.crypto.Error: [('asn1 encoding routines', '', 'string too short')]\r\n```\r\n\r\nThe pyopenssl code for reference:\r\n\r\n```\r\n$ cat pyopenssl_long_cname.py \r\nimport os\r\nimport sys\r\nimport binascii\r\nimport datetime\r\n\r\nfrom OpenSSL import crypto\r\n\r\nONE_YEAR_TD = datetime.timedelta(days=365)\r\n\r\ndef genCert(cname: str, prvkey: crypto.PKey) -> crypto.X509:\r\n\r\n    cert = crypto.X509()\r\n    cert.set_pubkey(prvkey)\r\n    cert.set_version(2)\r\n\r\n    cert.gmtime_adj_notBefore(0)\r\n    cert.gmtime_adj_notAfter(ONE_YEAR_TD.seconds)  # Certpairs are good for 10 years\r\n\r\n    cert.set_serial_number(int(binascii.hexlify(os.urandom(16)).decode('utf8'), 16))\r\n\r\n    # Mark the cert as a CA - it's just an example\r\n    cert.add_extensions([crypto.X509Extension(b'basicConstraints', False, b'CA:TRUE')])\r\n\r\n    # Set the common name - this raises if cname is invalid length :(\r\n    cert.get_subject().CN = cname\r\n\r\n    # Self sign the cert\r\n    cert.set_issuer(cert.get_subject())\r\n    cert.sign(prvkey, 'sha256')\r\n    return cert\r\n\r\n\r\ndef main():\r\n\r\n    pkey = crypto.PKey()\r\n    pkey.generate_key(crypto.TYPE_RSA, 4096)\r\n\r\n    # Per RFC5280 common-name has a length of 1 to 64 characters ?\r\n    # https://datatracker.ietf.org/doc/html/rfc5280#appendix-A.1\r\n    # CommonName ::= PrintableString (SIZE (1..ub-common-name-length))\r\n\r\n    # cname with 64 + 1 characters\r\n    cname = 'A' * 65\r\n    print(f'Making a CA cert with common name {cname=} {len(cname)=}')\r\n    cert = genCert(cname=cname, prvkey=pkey)\r\n    print(cert)\r\n\r\n    byts = crypto.dump_certificate(crypto.FILETYPE_PEM, cert)\r\n    with open('pyopenssl_long_ca.pem', 'wb') as fd:\r\n        fd.truncate(0)\r\n        fd.write(byts)\r\n    with open('pyopenssl_long_ca.key', 'wb') as fd:\r\n        fd.truncate(0)\r\n        fd.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, pkey))\r\n\r\n    # Assert the long common name in new cert object can be read and matches cname\r\n    newcert = crypto.load_certificate(crypto.FILETYPE_PEM, byts)\r\n    newcert_cname = newcert.get_subject().CN\r\n    assert newcert_cname == cname\r\n\r\n    return 0\r\n\r\nif __name__ == '__main__':\r\n    sys.exit(main())\r\n    \r\n$ cat pyopenssl_short_cname.py \r\nimport os\r\nimport sys\r\nimport binascii\r\nimport datetime\r\n\r\nfrom OpenSSL import crypto\r\n\r\nONE_YEAR_TD = datetime.timedelta(days=365)\r\n\r\ndef genCert(cname: str, prvkey: crypto.PKey) -> crypto.X509:\r\n\r\n    cert = crypto.X509()\r\n    cert.set_pubkey(prvkey)\r\n    cert.set_version(2)\r\n\r\n    cert.gmtime_adj_notBefore(0)\r\n    cert.gmtime_adj_notAfter(ONE_YEAR_TD.seconds)  # Certpairs are good for 10 years\r\n\r\n    cert.set_serial_number(int(binascii.hexlify(os.urandom(16)).decode('utf8'), 16))\r\n\r\n    # Mark the cert as a CA - it's just an example\r\n    cert.add_extensions([crypto.X509Extension(b'basicConstraints', False, b'CA:TRUE')])\r\n\r\n    # Set the common name - this raises if cname is invalid length :(\r\n    cert.get_subject().CN = cname\r\n\r\n    # Self sign the cert\r\n    cert.set_issuer(cert.get_subject())\r\n    cert.sign(prvkey, 'sha256')\r\n    return cert\r\n\r\n\r\ndef main():\r\n\r\n    pkey = crypto.PKey()\r\n    pkey.generate_key(crypto.TYPE_RSA, 4096)\r\n\r\n    # Per RFC5280 common-name has a length of 1 to 64 characters ?\r\n    # https://datatracker.ietf.org/doc/html/rfc5280#appendix-A.1\r\n    # CommonName ::= PrintableString (SIZE (1..ub-common-name-length))\r\n\r\n    # cname with 0 length string\r\n    cname = ''\r\n    print(f'Making a CA cert with common name {cname=} {len(cname)=}')\r\n    cert = genCert(cname=cname, prvkey=pkey)\r\n    print(cert)\r\n\r\n    byts = crypto.dump_certificate(crypto.FILETYPE_PEM, cert)\r\n    with open('pyopenssl_short_ca.pem', 'wb') as fd:\r\n        fd.truncate(0)\r\n        fd.write(byts)\r\n    with open('pyopenssl_short_ca.key', 'wb') as fd:\r\n        fd.truncate(0)\r\n        fd.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, pkey))\r\n\r\n    newcert = crypto.load_certificate(crypto.FILETYPE_PEM, byts)\r\n    newcert_cname = newcert.get_subject().CN\r\n    assert newcert_cname == cname\r\n\r\n    return 0\r\n\r\nif __name__ == '__main__':\r\n    sys.exit(main())\r\n```\r\n\r\nI have not dug into any of the rust specific interfaces to see what may differ between the two libraries when calling into openssl library components.\r\n\r\n","closed_by":{"login":"reaperhulk","id":161495,"node_id":"MDQ6VXNlcjE2MTQ5NQ==","avatar_url":"https://avatars.githubusercontent.com/u/161495?v=4","gravatar_id":"","url":"https://api.github.com/users/reaperhulk","html_url":"https://github.com/reaperhulk","followers_url":"https://api.github.com/users/reaperhulk/followers","following_url":"https://api.github.com/users/reaperhulk/following{/other_user}","gists_url":"https://api.github.com/users/reaperhulk/gists{/gist_id}","starred_url":"https://api.github.com/users/reaperhulk/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/reaperhulk/subscriptions","organizations_url":"https://api.github.com/users/reaperhulk/orgs","repos_url":"https://api.github.com/users/reaperhulk/repos","events_url":"https://api.github.com/users/reaperhulk/events{/privacy}","received_events_url":"https://api.github.com/users/reaperhulk/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/pyca/cryptography/issues/10553/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/pyca/cryptography/issues/10553/timeline","performed_via_github_app":null,"state_reason":"completed"}