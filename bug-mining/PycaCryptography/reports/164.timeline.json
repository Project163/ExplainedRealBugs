[{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2478640298","html_url":"https://github.com/pyca/cryptography/issues/11955#issuecomment-2478640298","issue_url":"https://api.github.com/repos/pyca/cryptography/issues/11955","id":2478640298,"node_id":"IC_kwDOALYunM6TvQyq","user":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2024-11-15T11:46:14Z","updated_at":"2024-11-15T11:46:14Z","body":"We previously added https://cryptography.io/en/latest/x509/ocsp/#cryptography.x509.ocsp.OCSPRequestBuilder.add_certificate_by_hash on OCSP requests. We'd be ok adding an analogous API on responses.\r\n\r\nAre you interested in submitting a PR?","author_association":"MEMBER","reactions":{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2478640298/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2478668056","html_url":"https://github.com/pyca/cryptography/issues/11955#issuecomment-2478668056","issue_url":"https://api.github.com/repos/pyca/cryptography/issues/11955","id":2478668056,"node_id":"IC_kwDOALYunM6TvXkY","user":{"login":"jackenbaer","id":47692397,"node_id":"MDQ6VXNlcjQ3NjkyMzk3","avatar_url":"https://avatars.githubusercontent.com/u/47692397?v=4","gravatar_id":"","url":"https://api.github.com/users/jackenbaer","html_url":"https://github.com/jackenbaer","followers_url":"https://api.github.com/users/jackenbaer/followers","following_url":"https://api.github.com/users/jackenbaer/following{/other_user}","gists_url":"https://api.github.com/users/jackenbaer/gists{/gist_id}","starred_url":"https://api.github.com/users/jackenbaer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jackenbaer/subscriptions","organizations_url":"https://api.github.com/users/jackenbaer/orgs","repos_url":"https://api.github.com/users/jackenbaer/repos","events_url":"https://api.github.com/users/jackenbaer/events{/privacy}","received_events_url":"https://api.github.com/users/jackenbaer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2024-11-15T12:03:33Z","updated_at":"2024-11-15T12:03:33Z","body":"Ah, yes ! Exactly this for responses. \r\nYes, I will look into this ! ","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2478668056/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"jackenbaer","id":47692397,"node_id":"MDQ6VXNlcjQ3NjkyMzk3","avatar_url":"https://avatars.githubusercontent.com/u/47692397?v=4","gravatar_id":"","url":"https://api.github.com/users/jackenbaer","html_url":"https://github.com/jackenbaer","followers_url":"https://api.github.com/users/jackenbaer/followers","following_url":"https://api.github.com/users/jackenbaer/following{/other_user}","gists_url":"https://api.github.com/users/jackenbaer/gists{/gist_id}","starred_url":"https://api.github.com/users/jackenbaer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jackenbaer/subscriptions","organizations_url":"https://api.github.com/users/jackenbaer/orgs","repos_url":"https://api.github.com/users/jackenbaer/repos","events_url":"https://api.github.com/users/jackenbaer/events{/privacy}","received_events_url":"https://api.github.com/users/jackenbaer/received_events","type":"User","user_view_type":"public","site_admin":false}},{"id":16133131375,"node_id":"RTE_lADOALYunM6epYkmzwAAAAPBnAxv","url":"https://api.github.com/repos/pyca/cryptography/issues/events/16133131375","actor":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"renamed","commit_id":null,"commit_url":null,"created_at":"2025-01-31T02:32:09Z","rename":{"from":"OCSP Response Builder ","to":"Add OCSP Response Builder APIs to add certificates by hash"},"performed_via_github_app":null},{"id":16152287706,"node_id":"SE_lADOALYunM6epYkmzwAAAAPCwFna","url":"https://api.github.com/repos/pyca/cryptography/issues/events/16152287706","actor":{"login":"GalaxySnail","id":53637421,"node_id":"MDQ6VXNlcjUzNjM3NDIx","avatar_url":"https://avatars.githubusercontent.com/u/53637421?v=4","gravatar_id":"","url":"https://api.github.com/users/GalaxySnail","html_url":"https://github.com/GalaxySnail","followers_url":"https://api.github.com/users/GalaxySnail/followers","following_url":"https://api.github.com/users/GalaxySnail/following{/other_user}","gists_url":"https://api.github.com/users/GalaxySnail/gists{/gist_id}","starred_url":"https://api.github.com/users/GalaxySnail/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/GalaxySnail/subscriptions","organizations_url":"https://api.github.com/users/GalaxySnail/orgs","repos_url":"https://api.github.com/users/GalaxySnail/repos","events_url":"https://api.github.com/users/GalaxySnail/events{/privacy}","received_events_url":"https://api.github.com/users/GalaxySnail/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"subscribed","commit_id":null,"commit_url":null,"created_at":"2025-02-02T09:35:14Z","performed_via_github_app":null},{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2666517314","html_url":"https://github.com/pyca/cryptography/issues/11955#issuecomment-2666517314","issue_url":"https://api.github.com/repos/pyca/cryptography/issues/11955","id":2666517314,"node_id":"IC_kwDOALYunM6e79NC","user":{"login":"aschaubamd","id":137115676,"node_id":"U_kgDOCCw4HA","avatar_url":"https://avatars.githubusercontent.com/u/137115676?v=4","gravatar_id":"","url":"https://api.github.com/users/aschaubamd","html_url":"https://github.com/aschaubamd","followers_url":"https://api.github.com/users/aschaubamd/followers","following_url":"https://api.github.com/users/aschaubamd/following{/other_user}","gists_url":"https://api.github.com/users/aschaubamd/gists{/gist_id}","starred_url":"https://api.github.com/users/aschaubamd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aschaubamd/subscriptions","organizations_url":"https://api.github.com/users/aschaubamd/orgs","repos_url":"https://api.github.com/users/aschaubamd/repos","events_url":"https://api.github.com/users/aschaubamd/events{/privacy}","received_events_url":"https://api.github.com/users/aschaubamd/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2025-02-18T18:14:32Z","updated_at":"2025-02-18T18:14:32Z","body":"I wanted to follow up on this. I would also be interested in this change. Has any progress been made on this request?","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2666517314/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"aschaubamd","id":137115676,"node_id":"U_kgDOCCw4HA","avatar_url":"https://avatars.githubusercontent.com/u/137115676?v=4","gravatar_id":"","url":"https://api.github.com/users/aschaubamd","html_url":"https://github.com/aschaubamd","followers_url":"https://api.github.com/users/aschaubamd/followers","following_url":"https://api.github.com/users/aschaubamd/following{/other_user}","gists_url":"https://api.github.com/users/aschaubamd/gists{/gist_id}","starred_url":"https://api.github.com/users/aschaubamd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aschaubamd/subscriptions","organizations_url":"https://api.github.com/users/aschaubamd/orgs","repos_url":"https://api.github.com/users/aschaubamd/repos","events_url":"https://api.github.com/users/aschaubamd/events{/privacy}","received_events_url":"https://api.github.com/users/aschaubamd/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2666535641","html_url":"https://github.com/pyca/cryptography/issues/11955#issuecomment-2666535641","issue_url":"https://api.github.com/repos/pyca/cryptography/issues/11955","id":2666535641,"node_id":"IC_kwDOALYunM6e8BrZ","user":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2025-02-18T18:23:22Z","updated_at":"2025-02-18T18:23:22Z","body":"Not to my knowledge. We're still happy to take a PR for it.","author_association":"MEMBER","reactions":{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2666535641/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2726994237","html_url":"https://github.com/pyca/cryptography/issues/11955#issuecomment-2726994237","issue_url":"https://api.github.com/repos/pyca/cryptography/issues/11955","id":2726994237,"node_id":"IC_kwDOALYunM6iiqE9","user":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2025-03-15T20:50:25Z","updated_at":"2025-03-15T20:50:25Z","body":"I let an LLM spin on this for a while, it just its mind repeatedly and so the implementation isn't very useful. But the tests and docs might be useful for whoever takes this on.\n\n<details>\n\n```\ndiff --git a/docs/x509/ocsp.rst b/docs/x509/ocsp.rst\nindex beaa3537c..409f48bac 100644\n--- a/docs/x509/ocsp.rst\n+++ b/docs/x509/ocsp.rst\n@@ -285,6 +285,56 @@ Creating Responses\n             :class:`~cryptography.x509.ReasonFlags` enumeration or ``None`` if\n             the ``cert`` is not revoked.\n \n+    .. method:: add_response_by_hash(issuer_name_hash, issuer_key_hash, serial_number, algorithm, cert_status, this_update, next_update, revocation_time, revocation_reason)\n+\n+        .. versionadded:: 43.0.0\n+\n+        Like :meth:`~cryptography.x509.ocsp.OCSPResponseBuilder.add_response`,\n+        but takes the hash of the issuer's name and key instead of requiring\n+        the full certificates. This is useful when generating OCSP responses\n+        when you don't have access to the full certificate objects, but you do\n+        have the relevant hashes.\n+\n+        :param issuer_name_hash: The hash of the issuer's DER encoded name using\n+            the same hash algorithm as the one specified in the ``algorithm`` parameter.\n+        :type issuer_name_hash: bytes\n+\n+        :param issuer_key_hash: The hash of the issuer's public key bit string\n+            DER encoding using the same hash algorithm as the one specified in\n+            the ``algorithm`` parameter.\n+        :type issuer_key_hash: bytes\n+\n+        :param serial_number: The serial number of the certificate being checked.\n+        :type serial_number: int\n+\n+        :param algorithm: A\n+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`\n+            instance. For OCSP only\n+            :class:`~cryptography.hazmat.primitives.hashes.SHA1`,\n+            :class:`~cryptography.hazmat.primitives.hashes.SHA224`,\n+            :class:`~cryptography.hazmat.primitives.hashes.SHA256`,\n+            :class:`~cryptography.hazmat.primitives.hashes.SHA384`, and\n+            :class:`~cryptography.hazmat.primitives.hashes.SHA512` are allowed.\n+\n+        :param cert_status: An item from the\n+            :class:`~cryptography.x509.ocsp.OCSPCertStatus` enumeration.\n+\n+        :param this_update: A naïve :class:`datetime.datetime` object\n+            representing the most recent time in UTC at which the status being\n+            indicated is known by the responder to be correct.\n+\n+        :param next_update: A naïve :class:`datetime.datetime` object or\n+            ``None``. The time in UTC at or before which newer information will\n+            be available about the status of the certificate.\n+\n+        :param revocation_time: A naïve :class:`datetime.datetime` object or\n+            ``None`` if the certificate is not revoked. The time in UTC at which\n+            the certificate was revoked.\n+\n+        :param revocation_reason: An item from the\n+            :class:`~cryptography.x509.ReasonFlags` enumeration or ``None`` if\n+            the certificate is not revoked.\n+\n     .. method:: certificates(certs)\n \n         Add additional certificates that should be used to verify the\ndiff --git a/src/cryptography/x509/ocsp.py b/src/cryptography/x509/ocsp.py\nindex 513db6e1e..eb7811f33 100644\n--- a/src/cryptography/x509/ocsp.py\n+++ b/src/cryptography/x509/ocsp.py\n@@ -59,31 +59,80 @@ class OCSPCertStatus(utils.Enum):\n class _SingleResponse:\n     def __init__(\n         self,\n-        cert: x509.Certificate,\n-        issuer: x509.Certificate,\n-        algorithm: hashes.HashAlgorithm,\n-        cert_status: OCSPCertStatus,\n-        this_update: datetime.datetime,\n-        next_update: datetime.datetime | None,\n-        revocation_time: datetime.datetime | None,\n-        revocation_reason: x509.ReasonFlags | None,\n+        cert: x509.Certificate | None = None,\n+        issuer: x509.Certificate | None = None,\n+        algorithm: hashes.HashAlgorithm | None = None,\n+        cert_status: OCSPCertStatus | None = None,\n+        this_update: datetime.datetime | None = None,\n+        next_update: datetime.datetime | None = None,\n+        revocation_time: datetime.datetime | None = None,\n+        revocation_reason: x509.ReasonFlags | None = None,\n+        issuer_name_hash: bytes | None = None,\n+        issuer_key_hash: bytes | None = None,\n+        serial_number: int | None = None,\n     ):\n-        if not isinstance(cert, x509.Certificate) or not isinstance(\n-            issuer, x509.Certificate\n+        self._using_hashes = False\n+\n+        # Hash-based initialization\n+        if (\n+            issuer_name_hash is not None\n+            and issuer_key_hash is not None\n+            and serial_number is not None\n         ):\n-            raise TypeError(\"cert and issuer must be a Certificate\")\n+            if cert is not None or issuer is not None:\n+                raise ValueError(\"Cannot provide both certificates and hashes\")\n+\n+            self._using_hashes = True\n+            self._issuer_name_hash = issuer_name_hash\n+            self._issuer_key_hash = issuer_key_hash\n+            self._serial_number = serial_number\n+\n+            if algorithm is None:\n+                raise ValueError(\n+                    \"Algorithm must be provided when using hashes\"\n+                )\n+\n+            _verify_algorithm(algorithm)\n+            self._algorithm = algorithm\n+\n+        # Certificate-based initialization\n+        elif cert is not None and issuer is not None:\n+            if not isinstance(cert, x509.Certificate) or not isinstance(\n+                issuer, x509.Certificate\n+            ):\n+                raise TypeError(\"cert and issuer must be a Certificate\")\n+\n+            if algorithm is None:\n+                raise ValueError(\n+                    \"Algorithm must be provided when using certificates\"\n+                )\n+\n+            _verify_algorithm(algorithm)\n+\n+            self._cert = cert\n+            self._issuer = issuer\n+            self._algorithm = algorithm\n+        else:\n+            raise ValueError(\n+                \"Must provide either (cert, issuer) or \"\n+                \"(issuer_name_hash, issuer_key_hash, serial_number)\"\n+            )\n+\n+        # Common validation\n+        if cert_status is None:\n+            raise ValueError(\"cert_status must be provided\")\n+\n+        if this_update is None:\n+            raise ValueError(\"this_update must be provided\")\n \n-        _verify_algorithm(algorithm)\n         if not isinstance(this_update, datetime.datetime):\n             raise TypeError(\"this_update must be a datetime object\")\n+\n         if next_update is not None and not isinstance(\n             next_update, datetime.datetime\n         ):\n             raise TypeError(\"next_update must be a datetime object or None\")\n \n-        self._cert = cert\n-        self._issuer = issuer\n-        self._algorithm = algorithm\n         self._this_update = this_update\n         self._next_update = next_update\n \n@@ -91,6 +140,7 @@ class _SingleResponse:\n             raise TypeError(\n                 \"cert_status must be an item from the OCSPCertStatus enum\"\n             )\n+\n         if cert_status is not OCSPCertStatus.REVOKED:\n             if revocation_time is not None:\n                 raise ValueError(\n@@ -125,6 +175,9 @@ class _SingleResponse:\n         self._revocation_reason = revocation_reason\n \n \n+# No longer needed since we're using threading.local\n+\n+\n OCSPRequest = ocsp.OCSPRequest\n OCSPResponse = ocsp.OCSPResponse\n OCSPSingleResponse = ocsp.OCSPSingleResponse\n@@ -259,6 +312,99 @@ class OCSPResponseBuilder:\n             self._extensions,\n         )\n \n+    def add_response_by_hash(\n+        self,\n+        issuer_name_hash: bytes,\n+        issuer_key_hash: bytes,\n+        serial_number: int,\n+        algorithm: hashes.HashAlgorithm,\n+        cert_status: OCSPCertStatus,\n+        this_update: datetime.datetime,\n+        next_update: datetime.datetime | None,\n+        revocation_time: datetime.datetime | None,\n+        revocation_reason: x509.ReasonFlags | None,\n+    ) -> OCSPResponseBuilder:\n+        \"\"\"\n+        Like add_response, but takes the hash of the issuer's name and\n+        public key instead of requiring the full certificates.\n+        \"\"\"\n+        if self._response is not None:\n+            raise ValueError(\"Only one response per OCSPResponse.\")\n+\n+        if not isinstance(serial_number, int):\n+            raise TypeError(\"serial_number must be an integer\")\n+\n+        _verify_algorithm(algorithm)\n+        utils._check_bytes(\"issuer_name_hash\", issuer_name_hash)\n+        utils._check_bytes(\"issuer_key_hash\", issuer_key_hash)\n+        if algorithm.digest_size != len(\n+            issuer_name_hash\n+        ) or algorithm.digest_size != len(issuer_key_hash):\n+            raise ValueError(\n+                \"issuer_name_hash and issuer_key_hash must be the same length \"\n+                \"as the digest size of the algorithm\"\n+            )\n+\n+        if not isinstance(cert_status, OCSPCertStatus):\n+            raise TypeError(\n+                \"cert_status must be an item from the OCSPCertStatus enum\"\n+            )\n+        if not isinstance(this_update, datetime.datetime):\n+            raise TypeError(\"this_update must be a datetime object\")\n+        if next_update is not None and not isinstance(\n+            next_update, datetime.datetime\n+        ):\n+            raise TypeError(\"next_update must be a datetime object or None\")\n+\n+        if cert_status is not OCSPCertStatus.REVOKED:\n+            if revocation_time is not None:\n+                raise ValueError(\n+                    \"revocation_time can only be provided if the certificate \"\n+                    \"is revoked\"\n+                )\n+            if revocation_reason is not None:\n+                raise ValueError(\n+                    \"revocation_reason can only be provided if the certificate\"\n+                    \" is revoked\"\n+                )\n+        else:\n+            if not isinstance(revocation_time, datetime.datetime):\n+                raise TypeError(\"revocation_time must be a datetime object\")\n+\n+            revocation_time = _convert_to_naive_utc_time(revocation_time)\n+            if revocation_time < _EARLIEST_UTC_TIME:\n+                raise ValueError(\n+                    \"The revocation_time must be on or after 1950 January 1.\"\n+                )\n+\n+            if revocation_reason is not None and not isinstance(\n+                revocation_reason, x509.ReasonFlags\n+            ):\n+                raise TypeError(\n+                    \"revocation_reason must be an item from the ReasonFlags \"\n+                    \"enum or None\"\n+                )\n+\n+        # Create a _SingleResponse with hash-based initialization\n+        singleresp = _SingleResponse(\n+            cert_status=cert_status,\n+            this_update=this_update,\n+            next_update=next_update,\n+            revocation_time=revocation_time,\n+            revocation_reason=revocation_reason,\n+            algorithm=algorithm,\n+            issuer_name_hash=issuer_name_hash,\n+            issuer_key_hash=issuer_key_hash,\n+            serial_number=serial_number,\n+        )\n+\n+        return OCSPResponseBuilder(\n+            singleresp,\n+            self._responder_id,\n+            self._certs,\n+            self._extensions,\n+        )\n+\n     def responder_id(\n         self, encoding: OCSPResponderEncoding, responder_cert: x509.Certificate\n     ) -> OCSPResponseBuilder:\ndiff --git a/src/rust/src/x509/ocsp.rs b/src/rust/src/x509/ocsp.rs\nindex b632532f1..e81f65b2f 100644\n--- a/src/rust/src/x509/ocsp.rs\n+++ b/src/rust/src/x509/ocsp.rs\n@@ -79,6 +79,7 @@ pub(crate) fn certid_new<'p>(\n     issuer: &'p Certificate,\n     hash_algorithm: &pyo3::Bound<'p, pyo3::PyAny>,\n ) -> CryptographyResult<CertID<'p>> {\n+    // Compute hashes from the certificates\n     let issuer_der = asn1::write_single(&cert.raw.borrow_dependent().tbs_cert.issuer)?;\n     let issuer_name_hash =\n         pyo3::pybacked::PyBackedBytes::from(hash_data(py, hash_algorithm, &issuer_der)?);\ndiff --git a/src/rust/src/x509/ocsp_resp.rs b/src/rust/src/x509/ocsp_resp.rs\nindex 706b68c6a..12d8f6499 100644\n--- a/src/rust/src/x509/ocsp_resp.rs\n+++ b/src/rust/src/x509/ocsp_resp.rs\n@@ -4,6 +4,7 @@\n \n use std::sync::Arc;\n \n+use cryptography_x509::ocsp_req::CertID;\n use cryptography_x509::ocsp_resp::{\n     self, OCSPResponse as RawOCSPResponse, SingleResponse, SingleResponse as RawSingleResponse,\n };\n@@ -666,6 +667,9 @@ fn singleresp_py_revocation_time_utc<'p>(\n     }\n }\n \n+// The create_ocsp_response_by_hash function has been replaced by a more integrated\n+// approach using _SingleResponse with hash-based initialization\n+\n #[pyo3::pyfunction]\n pub(crate) fn create_ocsp_response(\n     py: pyo3::Python<'_>,\n@@ -678,8 +682,6 @@ pub(crate) fn create_ocsp_response(\n         .getattr(pyo3::intern!(py, \"value\"))?\n         .extract::<u32>()?;\n \n-    let py_cert: pyo3::PyRef<'_, x509::certificate::Certificate>;\n-    let py_issuer: pyo3::PyRef<'_, x509::certificate::Certificate>;\n     let borrowed_cert;\n     let py_certs: Option<Vec<pyo3::PyRef<'_, x509::certificate::Certificate>>>;\n     if response_status != SUCCESSFUL_RESPONSE {\n@@ -692,13 +694,8 @@ pub(crate) fn create_ocsp_response(\n     }\n \n     let py_single_resp = builder.getattr(pyo3::intern!(py, \"_response\"))?;\n-    py_cert = py_single_resp\n-        .getattr(pyo3::intern!(py, \"_cert\"))?\n-        .extract()?;\n-    py_issuer = py_single_resp\n-        .getattr(pyo3::intern!(py, \"_issuer\"))?\n-        .extract()?;\n-    let py_cert_hash_algorithm = py_single_resp.getattr(pyo3::intern!(py, \"_algorithm\"))?;\n+\n+    // Check if the response is a dictionary (from add_response_by_hash) or a _SingleResponse object\n     let (responder_cert, responder_encoding): (\n         pyo3::Bound<'_, x509::certificate::Certificate>,\n         pyo3::Bound<'_, pyo3::PyAny>,\n@@ -706,6 +703,16 @@ pub(crate) fn create_ocsp_response(\n         .getattr(pyo3::intern!(py, \"_responder_id\"))?\n         .extract()?;\n \n+    let ka_vec = cryptography_keepalive::KeepAlive::new();\n+    let ka_bytes = cryptography_keepalive::KeepAlive::new();\n+\n+    // Check if the _SingleResponse is using hashes (has _using_hashes attribute set to True)\n+    let is_by_hash = py_single_resp.hasattr(pyo3::intern!(py, \"_using_hashes\"))?\n+        && py_single_resp\n+            .getattr(pyo3::intern!(py, \"_using_hashes\"))?\n+            .extract::<bool>()?;\n+\n+    // Common code to process cert_status, next_update, this_update regardless of the source\n     let py_cert_status = py_single_resp.getattr(pyo3::intern!(py, \"_cert_status\"))?;\n     let cert_status = if py_cert_status.is(&types::OCSP_CERT_STATUS_GOOD.get(py)?) {\n         ocsp_resp::CertStatus::Good(())\n@@ -733,6 +740,7 @@ pub(crate) fn create_ocsp_response(\n             revocation_reason,\n         })\n     };\n+\n     let next_update = if !py_single_resp\n         .getattr(pyo3::intern!(py, \"_next_update\"))?\n         .is_none()\n@@ -745,19 +753,159 @@ pub(crate) fn create_ocsp_response(\n     } else {\n         None\n     };\n+\n     let py_this_update = py_single_resp.getattr(pyo3::intern!(py, \"_this_update\"))?;\n     let this_update = asn1::X509GeneralizedTime::new(py_to_datetime(py, py_this_update)?)?;\n \n-    let ka_vec = cryptography_keepalive::KeepAlive::new();\n-    let ka_bytes = cryptography_keepalive::KeepAlive::new();\n+    // Get the hash algorithm\n+    let py_hash_algorithm = py_single_resp.getattr(pyo3::intern!(py, \"_algorithm\"))?;\n+\n+    let responses = if is_by_hash {\n+        // This is from a _SingleResponse with hash-based initialization\n+        // Get the hash algorithm name first\n+        let hash_name: pyo3::pybacked::PyBackedStr = py_hash_algorithm\n+            .getattr(pyo3::intern!(py, \"name\"))?\n+            .extract()?;\n+\n+        // Extract required Python objects\n+        let issuer_name_hash_obj =\n+            py_single_resp.getattr(pyo3::intern!(py, \"_issuer_name_hash\"))?;\n+        let issuer_key_hash_obj = py_single_resp.getattr(pyo3::intern!(py, \"_issuer_key_hash\"))?;\n+        let serial_number_obj = py_single_resp.getattr(pyo3::intern!(py, \"_serial_number\"))?;\n+\n+        // Extract bytes and store in keepalive to extend their lifetime\n+        let issuer_name_hash_bytes: Vec<u8> = issuer_name_hash_obj.extract()?;\n+        let issuer_key_hash_bytes: Vec<u8> = issuer_key_hash_obj.extract()?;\n+\n+        // Convert Vec<u8> to Python bytes and store in keepalive\n+        let issuer_name_hash_py = pyo3::types::PyBytes::new(py, &issuer_name_hash_bytes);\n+        let issuer_key_hash_py = pyo3::types::PyBytes::new(py, &issuer_key_hash_bytes);\n+\n+        // Store in keepalive for extended lifetime\n+        let issuer_name_hash =\n+            ka_bytes.add(pyo3::pybacked::PyBackedBytes::from(issuer_name_hash_py));\n+        let issuer_key_hash = ka_bytes.add(pyo3::pybacked::PyBackedBytes::from(issuer_key_hash_py));\n+\n+        // Create serial number\n+        let bit_length = serial_number_obj\n+            .call_method0(pyo3::intern!(py, \"bit_length\"))?\n+            .extract::<usize>()?;\n+        let byte_length = (bit_length + 7) / 8;\n+\n+        let serial_bytes_py = py.import(pyo3::intern!(py, \"int\"))?.call_method1(\n+            pyo3::intern!(py, \"to_bytes\"),\n+            (\n+                &serial_number_obj,\n+                byte_length,\n+                pyo3::intern!(py, \"big\"),\n+                pyo3::intern!(py, \"True\"),\n+            ),\n+        )?;\n+\n+        let serial_bytes: Vec<u8> = serial_bytes_py.extract()?;\n+        // Convert to Python bytes and store in keepalive\n+        let serial_bytes_py_obj = pyo3::types::PyBytes::new(py, &serial_bytes);\n+        let serial_bytes_ref =\n+            ka_bytes.add(pyo3::pybacked::PyBackedBytes::from(serial_bytes_py_obj));\n+\n+        // Create BigInt from the keepalive bytes\n+        let serial = asn1::BigInt::new(serial_bytes_ref)\n+            .ok_or_else(|| pyo3::exceptions::PyValueError::new_err(\"Invalid serial number\"))?;\n+\n+        // Create CertID with the extended lifetime values\n+        let cert_id = CertID {\n+            hash_algorithm: ocsp::HASH_NAME_TO_ALGORITHM_IDENTIFIERS[&*hash_name].clone(),\n+            issuer_name_hash,\n+            issuer_key_hash,\n+            serial_number: serial,\n+        };\n+\n+        vec![SingleResponse {\n+            cert_id,\n+            cert_status,\n+            next_update,\n+            this_update,\n+            raw_single_extensions: None,\n+        }]\n+    } else {\n+        // This is from add_response with the _SingleResponse object\n+        let py_cert_obj = py_single_resp.getattr(pyo3::intern!(py, \"_cert\"))?;\n+        let py_issuer_obj = py_single_resp.getattr(pyo3::intern!(py, \"_issuer\"))?;\n+\n+        // Create a scope for handling all the lifetime-bounded objects\n+        let cert_id = {\n+            // Extract certificates within this scope\n+            let py_cert =\n+                py_cert_obj.extract::<pyo3::PyRef<'_, x509::certificate::Certificate>>()?;\n+            let py_issuer =\n+                py_issuer_obj.extract::<pyo3::PyRef<'_, x509::certificate::Certificate>>()?;\n+\n+            // Get the hash name for the algorithm identifier\n+            let hash_name: pyo3::pybacked::PyBackedStr = py_hash_algorithm\n+                .getattr(pyo3::intern!(py, \"name\"))?\n+                .extract()?;\n+\n+            // 1. Get issuer name hash\n+            let issuer_der = asn1::write_single(&py_cert.raw.borrow_dependent().tbs_cert.issuer)?;\n+            let issuer_name_hash_py = ocsp::hash_data(py, &py_hash_algorithm, &issuer_der)?;\n+            let issuer_name_hash_vec: Vec<u8> = issuer_name_hash_py.extract()?;\n+\n+            // 2. Get issuer key hash\n+            let issuer_key_bytes = py_issuer\n+                .raw\n+                .borrow_dependent()\n+                .tbs_cert\n+                .spki\n+                .subject_public_key\n+                .as_bytes();\n+            let issuer_key_hash_py = ocsp::hash_data(py, &py_hash_algorithm, issuer_key_bytes)?;\n+            let issuer_key_hash_vec: Vec<u8> = issuer_key_hash_py.extract()?;\n \n-    let responses = vec![SingleResponse {\n-        cert_id: ocsp::certid_new(py, &ka_bytes, &py_cert, &py_issuer, &py_cert_hash_algorithm)?,\n-        cert_status,\n-        next_update,\n-        this_update,\n-        raw_single_extensions: None,\n-    }];\n+            // 3. Get serial number bytes\n+            let serial_bytes = py_cert\n+                .raw\n+                .borrow_dependent()\n+                .tbs_cert\n+                .serial\n+                .as_bytes()\n+                .to_vec();\n+\n+            // Convert to Python objects and store in keepalive\n+            let issuer_name_hash_py_bytes = pyo3::types::PyBytes::new(py, &issuer_name_hash_vec);\n+            let issuer_key_hash_py_bytes = pyo3::types::PyBytes::new(py, &issuer_key_hash_vec);\n+            let serial_py_bytes = pyo3::types::PyBytes::new(py, &serial_bytes);\n+\n+            // Add to keepalive\n+            let issuer_name_hash = ka_bytes.add(pyo3::pybacked::PyBackedBytes::from(\n+                issuer_name_hash_py_bytes,\n+            ));\n+            let issuer_key_hash = ka_bytes.add(pyo3::pybacked::PyBackedBytes::from(\n+                issuer_key_hash_py_bytes,\n+            ));\n+            let serial_bytes_ka =\n+                ka_bytes.add(pyo3::pybacked::PyBackedBytes::from(serial_py_bytes));\n+\n+            // Create BigInt from the bytes\n+            let serial_number = asn1::BigInt::new(serial_bytes_ka)\n+                .ok_or_else(|| pyo3::exceptions::PyValueError::new_err(\"Invalid serial number\"))?;\n+\n+            // Create and return the CertID\n+            CertID {\n+                hash_algorithm: ocsp::HASH_NAME_TO_ALGORITHM_IDENTIFIERS[&*hash_name].clone(),\n+                issuer_name_hash,\n+                issuer_key_hash,\n+                serial_number,\n+            }\n+        };\n+\n+        vec![SingleResponse {\n+            cert_id,\n+            cert_status,\n+            next_update,\n+            this_update,\n+            raw_single_extensions: None,\n+        }]\n+    };\n \n     borrowed_cert = responder_cert.borrow();\n     let by_key_hash;\ndiff --git a/tests/x509/test_ocsp.py b/tests/x509/test_ocsp.py\nindex d7723b288..783238256 100644\n--- a/tests/x509/test_ocsp.py\n+++ b/tests/x509/test_ocsp.py\n@@ -387,53 +387,210 @@ class TestOCSPResponseBuilder:\n                 None,\n             )\n \n-    def test_invalid_add_response(self):\n+    def test_add_response_by_hash_custom(self):\n+        # First create a response the normal way\n         cert, issuer = _cert_and_issuer()\n-        time = datetime.datetime.now(datetime.timezone.utc).replace(\n-            tzinfo=None\n+        private_key = _generate_root()[1]\n+        current_time = datetime.datetime.now().replace(microsecond=0)\n+\n+        # Get hash values from the certificate\n+        h_name = hashes.Hash(hashes.SHA1())\n+        h_name.update(cert.issuer.public_bytes())\n+        issuer_name_hash = h_name.finalize()\n+\n+        h_key = hashes.Hash(hashes.SHA1())\n+        h_key.update(\n+            issuer.public_key().public_bytes(\n+                serialization.Encoding.DER,\n+                serialization.PublicFormat.PKCS1,\n+            )\n+        )\n+        issuer_key_hash = h_key.finalize()\n+\n+        # Create a response using certificate objects\n+        cert_builder = ocsp.OCSPResponseBuilder()\n+        cert_builder = cert_builder.add_response(\n+            cert,\n+            issuer,\n+            hashes.SHA1(),\n+            ocsp.OCSPCertStatus.GOOD,\n+            current_time,\n+            current_time,\n+            None,\n+            None,\n         )\n-        reason = x509.ReasonFlags.cessation_of_operation\n+        cert_builder = cert_builder.responder_id(\n+            ocsp.OCSPResponderEncoding.HASH, issuer\n+        )\n+        cert_response = cert_builder.sign(private_key, hashes.SHA256())\n+\n+        # Create an equivalent response using hashes\n+        hash_builder = ocsp.OCSPResponseBuilder()\n+        hash_builder = hash_builder.add_response_by_hash(\n+            issuer_name_hash,\n+            issuer_key_hash,\n+            cert.serial_number,\n+            hashes.SHA1(),\n+            ocsp.OCSPCertStatus.GOOD,\n+            current_time,\n+            current_time,\n+            None,\n+            None,\n+        )\n+        hash_builder = hash_builder.responder_id(\n+            ocsp.OCSPResponderEncoding.HASH, issuer\n+        )\n+        hash_response = hash_builder.sign(private_key, hashes.SHA256())\n+\n+        # Both responses should have the same hash and key values\n+        assert cert_response.issuer_key_hash == hash_response.issuer_key_hash\n+        assert cert_response.issuer_name_hash == hash_response.issuer_name_hash\n+        assert cert_response.serial_number == hash_response.serial_number\n+        assert cert_response.this_update == hash_response.this_update\n+        assert cert_response.next_update == hash_response.next_update\n+\n+    def test_add_response_by_hash_revoked_custom(self):\n+        # Test creating a revoked response with the hash-based API\n+        cert, issuer = _cert_and_issuer()\n+        private_key = _generate_root()[1]\n+        current_time = datetime.datetime.now().replace(microsecond=0)\n+        revocation_time = current_time - datetime.timedelta(days=1)\n+        revocation_reason = x509.ReasonFlags.key_compromise\n+\n+        # Get hash values\n+        h_name = hashes.Hash(hashes.SHA256())\n+        h_name.update(cert.issuer.public_bytes())\n+        issuer_name_hash = h_name.finalize()\n+\n+        h_key = hashes.Hash(hashes.SHA256())\n+        h_key.update(\n+            issuer.public_key().public_bytes(\n+                serialization.Encoding.DER,\n+                serialization.PublicFormat.PKCS1,\n+            )\n+        )\n+        issuer_key_hash = h_key.finalize()\n+\n+        # Create a revoked response with hashes\n         builder = ocsp.OCSPResponseBuilder()\n-        with pytest.raises(TypeError):\n-            builder.add_response(\n-                \"bad\",  # type:ignore[arg-type]\n-                issuer,\n-                hashes.SHA256(),\n+        builder = builder.add_response_by_hash(\n+            issuer_name_hash,\n+            issuer_key_hash,\n+            cert.serial_number,\n+            hashes.SHA256(),\n+            ocsp.OCSPCertStatus.REVOKED,\n+            current_time,\n+            current_time + datetime.timedelta(days=7),\n+            revocation_time,\n+            revocation_reason,\n+        )\n+        builder = builder.responder_id(ocsp.OCSPResponderEncoding.NAME, issuer)\n+        response = builder.sign(private_key, hashes.SHA256())\n+\n+        # Verify the response attributes\n+        assert response.certificate_status == ocsp.OCSPCertStatus.REVOKED\n+        assert response.revocation_time == revocation_time\n+        assert response.revocation_reason == revocation_reason\n+        assert response.this_update == current_time\n+        assert response.next_update == current_time + datetime.timedelta(\n+            days=7\n+        )\n+\n+    def test_add_response_by_hash_twice(self):\n+        time = datetime.datetime.now()\n+        builder = ocsp.OCSPResponseBuilder()\n+        builder = builder.add_response_by_hash(\n+            b\"0\" * 20,\n+            b\"0\" * 20,\n+            1,\n+            hashes.SHA1(),\n+            ocsp.OCSPCertStatus.GOOD,\n+            time,\n+            time,\n+            None,\n+            None,\n+        )\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                b\"0\" * 20,\n+                b\"0\" * 20,\n+                1,\n+                hashes.SHA1(),\n                 ocsp.OCSPCertStatus.GOOD,\n                 time,\n                 time,\n                 None,\n                 None,\n             )\n-        with pytest.raises(TypeError):\n-            builder.add_response(\n-                cert,\n-                \"bad\",  # type:ignore[arg-type]\n-                hashes.SHA256(),\n+\n+    def test_response_methods_exclusivity(self):\n+        \"\"\"Test add_response and add_response_by_hash exclusivity\"\"\"\n+        cert, issuer = _cert_and_issuer()\n+        time = datetime.datetime.now()\n+\n+        # Test add_response followed by add_response_by_hash\n+        builder = ocsp.OCSPResponseBuilder()\n+        builder = builder.add_response(\n+            cert,\n+            issuer,\n+            hashes.SHA1(),\n+            ocsp.OCSPCertStatus.GOOD,\n+            time,\n+            time,\n+            None,\n+            None,\n+        )\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                b\"0\" * 20,\n+                b\"0\" * 20,\n+                1,\n+                hashes.SHA1(),\n                 ocsp.OCSPCertStatus.GOOD,\n                 time,\n                 time,\n                 None,\n                 None,\n             )\n+\n+        # Test add_response_by_hash followed by add_response\n+        builder = ocsp.OCSPResponseBuilder()\n+        builder = builder.add_response_by_hash(\n+            b\"0\" * 20,\n+            b\"0\" * 20,\n+            1,\n+            hashes.SHA1(),\n+            ocsp.OCSPCertStatus.GOOD,\n+            time,\n+            time,\n+            None,\n+            None,\n+        )\n         with pytest.raises(ValueError):\n             builder.add_response(\n                 cert,\n                 issuer,\n-                \"notahash\",  # type:ignore[arg-type]\n+                hashes.SHA1(),\n                 ocsp.OCSPCertStatus.GOOD,\n                 time,\n                 time,\n                 None,\n                 None,\n             )\n+\n+    def test_invalid_add_response(self):\n+        cert, issuer = _cert_and_issuer()\n+        time = datetime.datetime.now(datetime.timezone.utc).replace(\n+            tzinfo=None\n+        )\n+        builder = ocsp.OCSPResponseBuilder()\n         with pytest.raises(TypeError):\n             builder.add_response(\n-                cert,\n+                \"bad\",  # type:ignore[arg-type]\n                 issuer,\n                 hashes.SHA256(),\n                 ocsp.OCSPCertStatus.GOOD,\n-                \"bad\",  # type:ignore[arg-type]\n+                time,\n                 time,\n                 None,\n                 None,\n@@ -441,69 +598,112 @@ class TestOCSPResponseBuilder:\n         with pytest.raises(TypeError):\n             builder.add_response(\n                 cert,\n-                issuer,\n+                \"bad\",  # type:ignore[arg-type]\n                 hashes.SHA256(),\n                 ocsp.OCSPCertStatus.GOOD,\n                 time,\n-                \"bad\",  # type:ignore[arg-type]\n+                time,\n                 None,\n                 None,\n             )\n \n+    def test_invalid_add_response_by_hash(self):\n+        builder = ocsp.OCSPResponseBuilder()\n+        time = datetime.datetime.now()\n+        cert, issuer = _cert_and_issuer()\n+\n+        # Test invalid hash types\n         with pytest.raises(TypeError):\n-            builder.add_response(\n-                cert,\n-                issuer,\n-                hashes.SHA256(),\n-                0,  # type:ignore[arg-type]\n+            builder.add_response_by_hash(\n+                \"not-bytes\",  # type:ignore[arg-type]\n+                b\"0\" * 20,\n+                1,\n+                hashes.SHA1(),\n+                ocsp.OCSPCertStatus.GOOD,\n                 time,\n                 time,\n                 None,\n                 None,\n             )\n-        with pytest.raises(ValueError):\n-            builder.add_response(\n-                cert,\n-                issuer,\n-                hashes.SHA256(),\n+        with pytest.raises(TypeError):\n+            builder.add_response_by_hash(\n+                b\"0\" * 20,\n+                \"not-bytes\",  # type:ignore[arg-type]\n+                1,\n+                hashes.SHA1(),\n                 ocsp.OCSPCertStatus.GOOD,\n                 time,\n                 time,\n+                None,\n+                None,\n+            )\n+\n+        # Test invalid serial number\n+        with pytest.raises(TypeError):\n+            builder.add_response_by_hash(\n+                b\"0\" * 20,\n+                b\"0\" * 20,\n+                \"not-an-int\",  # type:ignore[arg-type]\n+                hashes.SHA1(),\n+                ocsp.OCSPCertStatus.GOOD,\n                 time,\n+                time,\n+                None,\n                 None,\n             )\n+\n+        # Test invalid algorithm\n         with pytest.raises(ValueError):\n-            builder.add_response(\n-                cert,\n-                issuer,\n-                hashes.SHA256(),\n+            builder.add_response_by_hash(\n+                b\"0\" * 20,\n+                b\"0\" * 20,\n+                1,\n+                \"invalid-algorithm\",  # type:ignore[arg-type]\n                 ocsp.OCSPCertStatus.GOOD,\n                 time,\n                 time,\n                 None,\n-                reason,\n+                None,\n             )\n-        with pytest.raises(TypeError):\n-            builder.add_response(\n-                cert,\n-                issuer,\n-                hashes.SHA256(),\n-                ocsp.OCSPCertStatus.REVOKED,\n+\n+        # Test hash length validation\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                b\"0\" * 19,  # Wrong length for SHA1\n+                b\"0\" * 20,\n+                1,\n+                hashes.SHA1(),\n+                ocsp.OCSPCertStatus.GOOD,\n                 time,\n                 time,\n                 None,\n-                reason,\n+                None,\n             )\n-        with pytest.raises(TypeError):\n-            builder.add_response(\n-                cert,\n-                issuer,\n-                hashes.SHA256(),\n-                ocsp.OCSPCertStatus.REVOKED,\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                b\"0\" * 20,\n+                b\"0\" * 19,  # Wrong length for SHA1\n+                1,\n+                hashes.SHA1(),\n+                ocsp.OCSPCertStatus.GOOD,\n                 time,\n                 time,\n+                None,\n+                None,\n+            )\n+\n+        # Test disallowed hash algorithm\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                b\"0\" * 16,\n+                b\"0\" * 16,\n+                1,\n+                hashes.MD5(),\n+                ocsp.OCSPCertStatus.GOOD,\n+                time,\n                 time,\n-                0,  # type:ignore[arg-type]\n+                None,\n+                None,\n             )\n         with pytest.raises(ValueError):\n             builder.add_response(\n@@ -1067,6 +1267,203 @@ class TestOCSPResponseBuilder:\n         with pytest.raises(TypeError):\n             builder.sign(private_key, None)\n \n+    def test_add_response_by_hash(self):\n+        cert, issuer = _cert_and_issuer()\n+        root_cert, private_key = _generate_root()\n+\n+        # Generate standard response\n+        standard_builder = ocsp.OCSPResponseBuilder()\n+        this_update = (\n+            datetime.datetime.now().replace(tzinfo=None).replace(microsecond=0)\n+        )\n+        next_update = this_update + datetime.timedelta(days=1)\n+\n+        standard_builder = standard_builder.add_response(\n+            cert=cert,\n+            issuer=issuer,\n+            algorithm=hashes.SHA256(),\n+            cert_status=ocsp.OCSPCertStatus.GOOD,\n+            this_update=this_update,\n+            next_update=next_update,\n+            revocation_time=None,\n+            revocation_reason=None,\n+        ).responder_id(ocsp.OCSPResponderEncoding.NAME, root_cert)\n+\n+        standard_response = standard_builder.sign(private_key, hashes.SHA256())\n+\n+        # Now generate the same response using add_response_by_hash\n+        # First, compute the hashes manually\n+        issuer_name = issuer.subject.public_bytes()\n+        issuer_key = issuer.public_key().public_bytes(\n+            encoding=serialization.Encoding.DER,\n+            format=serialization.PublicFormat.PKCS1,\n+        )\n+\n+        digest = hashes.Hash(hashes.SHA256())\n+        digest.update(issuer_name)\n+        issuer_name_hash = digest.finalize()\n+\n+        digest = hashes.Hash(hashes.SHA256())\n+        digest.update(issuer_key)\n+        issuer_key_hash = digest.finalize()\n+\n+        # Create response by hash\n+        hash_builder = ocsp.OCSPResponseBuilder()\n+        hash_builder = hash_builder.add_response_by_hash(\n+            issuer_name_hash=issuer_name_hash,\n+            issuer_key_hash=issuer_key_hash,\n+            serial_number=cert.serial_number,\n+            algorithm=hashes.SHA256(),\n+            cert_status=ocsp.OCSPCertStatus.GOOD,\n+            this_update=this_update,\n+            next_update=next_update,\n+            revocation_time=None,\n+            revocation_reason=None,\n+        ).responder_id(ocsp.OCSPResponderEncoding.NAME, root_cert)\n+\n+        hash_response = hash_builder.sign(private_key, hashes.SHA256())\n+\n+        # The two responses should contain the same CertID\n+        assert (\n+            hash_response.issuer_name_hash\n+            == standard_response.issuer_name_hash\n+        )\n+        assert (\n+            hash_response.issuer_key_hash == standard_response.issuer_key_hash\n+        )\n+        assert hash_response.serial_number == standard_response.serial_number\n+\n+    def test_add_response_by_hash_revoked(self):\n+        cert, issuer = _cert_and_issuer()\n+        root_cert, private_key = _generate_root()\n+\n+        # Compute the hashes manually\n+        issuer_name = issuer.subject.public_bytes()\n+        issuer_key = issuer.public_key().public_bytes(\n+            encoding=serialization.Encoding.DER,\n+            format=serialization.PublicFormat.PKCS1,\n+        )\n+\n+        digest = hashes.Hash(hashes.SHA256())\n+        digest.update(issuer_name)\n+        issuer_name_hash = digest.finalize()\n+\n+        digest = hashes.Hash(hashes.SHA256())\n+        digest.update(issuer_key)\n+        issuer_key_hash = digest.finalize()\n+\n+        # Create response by hash with revoked status\n+        this_update = (\n+            datetime.datetime.now().replace(tzinfo=None).replace(microsecond=0)\n+        )\n+        next_update = this_update + datetime.timedelta(days=1)\n+        revocation_time = this_update - datetime.timedelta(days=1)\n+\n+        hash_builder = ocsp.OCSPResponseBuilder()\n+        hash_builder = hash_builder.add_response_by_hash(\n+            issuer_name_hash=issuer_name_hash,\n+            issuer_key_hash=issuer_key_hash,\n+            serial_number=cert.serial_number,\n+            algorithm=hashes.SHA256(),\n+            cert_status=ocsp.OCSPCertStatus.REVOKED,\n+            this_update=this_update,\n+            next_update=next_update,\n+            revocation_time=revocation_time,\n+            revocation_reason=x509.ReasonFlags.key_compromise,\n+        ).responder_id(ocsp.OCSPResponderEncoding.NAME, root_cert)\n+\n+        hash_response = hash_builder.sign(private_key, hashes.SHA256())\n+\n+        # Check that the status is set correctly\n+        assert hash_response.certificate_status == ocsp.OCSPCertStatus.REVOKED\n+        assert (\n+            hash_response.revocation_reason == x509.ReasonFlags.key_compromise\n+        )\n+        _check_ocsp_response_times(\n+            hash_response, this_update, next_update, revocation_time\n+        )\n+\n+    def test_add_response_by_hash_validates_parameters(self):\n+        cert, issuer = _cert_and_issuer()\n+\n+        # Compute hashes\n+        issuer_name = issuer.subject.public_bytes()\n+        issuer_key = issuer.public_key().public_bytes(\n+            encoding=serialization.Encoding.DER,\n+            format=serialization.PublicFormat.PKCS1,\n+        )\n+\n+        digest = hashes.Hash(hashes.SHA256())\n+        digest.update(issuer_name)\n+        issuer_name_hash = digest.finalize()\n+\n+        digest = hashes.Hash(hashes.SHA256())\n+        digest.update(issuer_key)\n+        issuer_key_hash = digest.finalize()\n+\n+        # Test parameters validation\n+        builder = ocsp.OCSPResponseBuilder()\n+        this_update = (\n+            datetime.datetime.now().replace(tzinfo=None).replace(microsecond=0)\n+        )\n+        next_update = this_update + datetime.timedelta(days=1)\n+\n+        # Test invalid serial_number\n+        with pytest.raises(TypeError):\n+            builder.add_response_by_hash(\n+                issuer_name_hash=issuer_name_hash,\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=\"not an integer\",  # type: ignore[arg-type]\n+                algorithm=hashes.SHA256(),\n+                cert_status=ocsp.OCSPCertStatus.GOOD,\n+                this_update=this_update,\n+                next_update=next_update,\n+                revocation_time=None,\n+                revocation_reason=None,\n+            )\n+\n+        # Test invalid hashes\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                issuer_name_hash=b\"too-short\",\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=cert.serial_number,\n+                algorithm=hashes.SHA256(),\n+                cert_status=ocsp.OCSPCertStatus.GOOD,\n+                this_update=this_update,\n+                next_update=next_update,\n+                revocation_time=None,\n+                revocation_reason=None,\n+            )\n+\n+        # Test invalid cert_status\n+        with pytest.raises(TypeError):\n+            builder.add_response_by_hash(\n+                issuer_name_hash=issuer_name_hash,\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=cert.serial_number,\n+                algorithm=hashes.SHA256(),\n+                cert_status=\"invalid status\",  # type: ignore[arg-type]\n+                this_update=this_update,\n+                next_update=next_update,\n+                revocation_time=None,\n+                revocation_reason=None,\n+            )\n+\n+        # Test revocation_time without revoked status\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                issuer_name_hash=issuer_name_hash,\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=cert.serial_number,\n+                algorithm=hashes.SHA256(),\n+                cert_status=ocsp.OCSPCertStatus.GOOD,\n+                this_update=this_update,\n+                next_update=next_update,\n+                revocation_time=datetime.datetime.now(),\n+                revocation_reason=None,\n+            )\n+\n \n class TestSignedCertificateTimestampsExtension:\n     def test_init(self):\n@@ -1557,6 +1954,275 @@ class TestOCSPEdDSA:\n         with pytest.raises(ValueError):\n             builder.sign(private_key, hashes.SHA256())\n \n+    def test_add_response_by_hash(self):\n+        builder = ocsp.OCSPResponseBuilder()\n+        cert, issuer = _cert_and_issuer()\n+        root_cert, private_key = _generate_root()\n+        current_time = (\n+            datetime.datetime.now(datetime.timezone.utc)\n+            .replace(tzinfo=None)\n+            .replace(microsecond=0)\n+        )\n+        this_update = current_time - datetime.timedelta(days=1)\n+        next_update = this_update + datetime.timedelta(days=7)\n+\n+        # Generate the issuer name hash and key hash\n+        hash_alg = hashes.SHA1()\n+        h = hashes.Hash(hash_alg)\n+        h.update(issuer.subject.public_bytes())\n+        issuer_name_hash = h.finalize()\n+\n+        h = hashes.Hash(hash_alg)\n+        h.update(\n+            issuer.public_key().public_bytes(\n+                serialization.Encoding.DER,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        issuer_key_hash = h.finalize()\n+\n+        builder = builder.responder_id(\n+            ocsp.OCSPResponderEncoding.NAME, root_cert\n+        ).add_response_by_hash(\n+            issuer_name_hash=issuer_name_hash,\n+            issuer_key_hash=issuer_key_hash,\n+            serial_number=cert.serial_number,\n+            algorithm=hash_alg,\n+            cert_status=ocsp.OCSPCertStatus.GOOD,\n+            this_update=this_update,\n+            next_update=next_update,\n+            revocation_time=None,\n+            revocation_reason=None,\n+        )\n+        resp = builder.sign(private_key, hashes.SHA256())\n+        assert resp.certificate_status == ocsp.OCSPCertStatus.GOOD\n+        _check_ocsp_response_times(\n+            resp,\n+            this_update=this_update,\n+            next_update=next_update,\n+            revocation_time=None,\n+        )\n+        assert resp.serial_number == cert.serial_number\n+        assert resp.issuer_name_hash == issuer_name_hash\n+        assert resp.issuer_key_hash == issuer_key_hash\n+\n+    def test_add_response_by_hash_revoked(self):\n+        builder = ocsp.OCSPResponseBuilder()\n+        cert, issuer = _cert_and_issuer()\n+        root_cert, private_key = _generate_root()\n+        current_time = (\n+            datetime.datetime.now(datetime.timezone.utc)\n+            .replace(tzinfo=None)\n+            .replace(microsecond=0)\n+        )\n+        this_update = current_time - datetime.timedelta(days=1)\n+        next_update = this_update + datetime.timedelta(days=7)\n+        revoked_date = this_update - datetime.timedelta(days=300)\n+\n+        # Generate the issuer name hash and key hash\n+        hash_alg = hashes.SHA1()\n+        h = hashes.Hash(hash_alg)\n+        h.update(issuer.subject.public_bytes())\n+        issuer_name_hash = h.finalize()\n+\n+        h = hashes.Hash(hash_alg)\n+        h.update(\n+            issuer.public_key().public_bytes(\n+                serialization.Encoding.DER,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        issuer_key_hash = h.finalize()\n+\n+        builder = builder.responder_id(\n+            ocsp.OCSPResponderEncoding.NAME, root_cert\n+        ).add_response_by_hash(\n+            issuer_name_hash=issuer_name_hash,\n+            issuer_key_hash=issuer_key_hash,\n+            serial_number=cert.serial_number,\n+            algorithm=hash_alg,\n+            cert_status=ocsp.OCSPCertStatus.REVOKED,\n+            this_update=this_update,\n+            next_update=next_update,\n+            revocation_time=revoked_date,\n+            revocation_reason=x509.ReasonFlags.key_compromise,\n+        )\n+        resp = builder.sign(private_key, hashes.SHA256())\n+        assert resp.certificate_status == ocsp.OCSPCertStatus.REVOKED\n+        assert resp.revocation_reason is x509.ReasonFlags.key_compromise\n+        _check_ocsp_response_times(\n+            resp,\n+            this_update=this_update,\n+            next_update=next_update,\n+            revocation_time=revoked_date,\n+        )\n+        assert resp.serial_number == cert.serial_number\n+        assert resp.issuer_name_hash == issuer_name_hash\n+        assert resp.issuer_key_hash == issuer_key_hash\n+\n+    def test_add_response_and_add_response_by_hash_validation(self):\n+        builder = ocsp.OCSPResponseBuilder()\n+        cert, issuer = _cert_and_issuer()\n+        root_cert, private_key = _generate_root()\n+        current_time = (\n+            datetime.datetime.now(datetime.timezone.utc)\n+            .replace(tzinfo=None)\n+            .replace(microsecond=0)\n+        )\n+        this_update = current_time - datetime.timedelta(days=1)\n+        next_update = this_update + datetime.timedelta(days=7)\n+\n+        # Build first response with add_response\n+        builder1 = builder.responder_id(\n+            ocsp.OCSPResponderEncoding.NAME, root_cert\n+        ).add_response(\n+            cert,\n+            issuer,\n+            hashes.SHA1(),\n+            ocsp.OCSPCertStatus.GOOD,\n+            this_update,\n+            next_update,\n+            None,\n+            None,\n+        )\n+        resp1 = builder1.sign(private_key, hashes.SHA256())\n+\n+        # Build second response with add_response_by_hash using the same params\n+        hash_alg = hashes.SHA1()\n+        h = hashes.Hash(hash_alg)\n+        h.update(issuer.subject.public_bytes())\n+        issuer_name_hash = h.finalize()\n+\n+        h = hashes.Hash(hash_alg)\n+        h.update(\n+            issuer.public_key().public_bytes(\n+                serialization.Encoding.DER,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        issuer_key_hash = h.finalize()\n+\n+        builder2 = (\n+            ocsp.OCSPResponseBuilder()\n+            .responder_id(ocsp.OCSPResponderEncoding.NAME, root_cert)\n+            .add_response_by_hash(\n+                issuer_name_hash=issuer_name_hash,\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=cert.serial_number,\n+                algorithm=hash_alg,\n+                cert_status=ocsp.OCSPCertStatus.GOOD,\n+                this_update=this_update,\n+                next_update=next_update,\n+                revocation_time=None,\n+                revocation_reason=None,\n+            )\n+        )\n+        resp2 = builder2.sign(private_key, hashes.SHA256())\n+\n+        # The two responses should contain identical information\n+        assert resp1.certificate_status == resp2.certificate_status\n+        assert resp1.issuer_name_hash == resp2.issuer_name_hash\n+        assert resp1.issuer_key_hash == resp2.issuer_key_hash\n+        assert resp1.serial_number == resp2.serial_number\n+        assert resp1.hash_algorithm.name == resp2.hash_algorithm.name\n+\n+    def test_add_response_by_hash_validations(self):\n+        builder = ocsp.OCSPResponseBuilder()\n+        cert, issuer = _cert_and_issuer()\n+        root_cert, private_key = _generate_root()\n+        current_time = (\n+            datetime.datetime.now(datetime.timezone.utc)\n+            .replace(tzinfo=None)\n+            .replace(microsecond=0)\n+        )\n+        this_update = current_time - datetime.timedelta(days=1)\n+        next_update = this_update + datetime.timedelta(days=7)\n+\n+        # Generate valid hashes\n+        hash_alg = hashes.SHA1()\n+        h = hashes.Hash(hash_alg)\n+        h.update(issuer.subject.public_bytes())\n+        issuer_name_hash = h.finalize()\n+\n+        h = hashes.Hash(hash_alg)\n+        h.update(\n+            issuer.public_key().public_bytes(\n+                serialization.Encoding.DER,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        issuer_key_hash = h.finalize()\n+\n+        # Test with non-integer serial number\n+        with pytest.raises(TypeError):\n+            builder.add_response_by_hash(\n+                issuer_name_hash=issuer_name_hash,\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=\"not an int\",\n+                algorithm=hash_alg,\n+                cert_status=ocsp.OCSPCertStatus.GOOD,\n+                this_update=this_update,\n+                next_update=next_update,\n+                revocation_time=None,\n+                revocation_reason=None,\n+            )\n+\n+        # Test with invalid algorithm\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                issuer_name_hash=issuer_name_hash,\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=cert.serial_number,\n+                algorithm=hashes.MD5(),\n+                cert_status=ocsp.OCSPCertStatus.GOOD,\n+                this_update=this_update,\n+                next_update=next_update,\n+                revocation_time=None,\n+                revocation_reason=None,\n+            )\n+\n+        # Test with mis-sized hash\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                issuer_name_hash=issuer_name_hash[:-1],  # Wrong size\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=cert.serial_number,\n+                algorithm=hash_alg,\n+                cert_status=ocsp.OCSPCertStatus.GOOD,\n+                this_update=this_update,\n+                next_update=next_update,\n+                revocation_time=None,\n+                revocation_reason=None,\n+            )\n+\n+        # Test with invalid this_update\n+        with pytest.raises(TypeError):\n+            builder.add_response_by_hash(\n+                issuer_name_hash=issuer_name_hash,\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=cert.serial_number,\n+                algorithm=hash_alg,\n+                cert_status=ocsp.OCSPCertStatus.GOOD,\n+                this_update=\"not a datetime\",\n+                next_update=next_update,\n+                revocation_time=None,\n+                revocation_reason=None,\n+            )\n+\n+        # Test with revocation_time on a good certificate\n+        with pytest.raises(ValueError):\n+            builder.add_response_by_hash(\n+                issuer_name_hash=issuer_name_hash,\n+                issuer_key_hash=issuer_key_hash,\n+                serial_number=cert.serial_number,\n+                algorithm=hash_alg,\n+                cert_status=ocsp.OCSPCertStatus.GOOD,\n+                this_update=this_update,\n+                next_update=next_update,\n+                revocation_time=current_time,\n+                revocation_reason=None,\n+            )\n+\n     @pytest.mark.supported(\n         only_if=lambda backend: backend.ed25519_supported(),\n         skip_message=\"Requires OpenSSL with Ed25519 support / OCSP\",\n```","author_association":"MEMBER","reactions":{"url":"https://api.github.com/repos/pyca/cryptography/issues/comments/2726994237/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false}},{"id":17016808606,"node_id":"REFE_lADOALYunM6epYkmzwAAAAP2R-Se","url":"https://api.github.com/repos/pyca/cryptography/issues/events/17016808606","actor":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"e461ebb6e1ad75faee008b45c88f2e605f6fad4c","commit_url":"https://api.github.com/repos/alex/cryptography/commits/e461ebb6e1ad75faee008b45c88f2e605f6fad4c","created_at":"2025-03-27T15:53:57Z","performed_via_github_app":null},{"id":17021516197,"node_id":"REFE_lADOALYunM6epYkmzwAAAAP2j7ml","url":"https://api.github.com/repos/pyca/cryptography/issues/events/17021516197","actor":{"login":"alex","id":772,"node_id":"MDQ6VXNlcjc3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/772?v=4","gravatar_id":"","url":"https://api.github.com/users/alex","html_url":"https://github.com/alex","followers_url":"https://api.github.com/users/alex/followers","following_url":"https://api.github.com/users/alex/following{/other_user}","gists_url":"https://api.github.com/users/alex/gists{/gist_id}","starred_url":"https://api.github.com/users/alex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alex/subscriptions","organizations_url":"https://api.github.com/users/alex/orgs","repos_url":"https://api.github.com/users/alex/repos","events_url":"https://api.github.com/users/alex/events{/privacy}","received_events_url":"https://api.github.com/users/alex/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"becb0a08a52191c82d08710a31f94ead72db6997","commit_url":"https://api.github.com/repos/alex/cryptography/commits/becb0a08a52191c82d08710a31f94ead72db6997","created_at":"2025-03-27T20:20:06Z","performed_via_github_app":null},{"id":17021834203,"node_id":"CE_lADOALYunM6epYkmzwAAAAP2lJPb","url":"https://api.github.com/repos/pyca/cryptography/issues/events/17021834203","actor":{"login":"reaperhulk","id":161495,"node_id":"MDQ6VXNlcjE2MTQ5NQ==","avatar_url":"https://avatars.githubusercontent.com/u/161495?v=4","gravatar_id":"","url":"https://api.github.com/users/reaperhulk","html_url":"https://github.com/reaperhulk","followers_url":"https://api.github.com/users/reaperhulk/followers","following_url":"https://api.github.com/users/reaperhulk/following{/other_user}","gists_url":"https://api.github.com/users/reaperhulk/gists{/gist_id}","starred_url":"https://api.github.com/users/reaperhulk/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/reaperhulk/subscriptions","organizations_url":"https://api.github.com/users/reaperhulk/orgs","repos_url":"https://api.github.com/users/reaperhulk/repos","events_url":"https://api.github.com/users/reaperhulk/events{/privacy}","received_events_url":"https://api.github.com/users/reaperhulk/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"closed","commit_id":"0e855f952693c8b730abb2fc5a84dfc69562f210","commit_url":"https://api.github.com/repos/pyca/cryptography/commits/0e855f952693c8b730abb2fc5a84dfc69562f210","created_at":"2025-03-27T20:46:42Z","state_reason":null,"performed_via_github_app":null},{"id":17022650460,"node_id":"REFE_lADOALYunM6epYkmzwAAAAP2oQhc","url":"https://api.github.com/repos/pyca/cryptography/issues/events/17022650460","actor":{"login":"pull[bot]","id":39814207,"node_id":"MDM6Qm90Mzk4MTQyMDc=","avatar_url":"https://avatars.githubusercontent.com/in/12910?v=4","gravatar_id":"","url":"https://api.github.com/users/pull%5Bbot%5D","html_url":"https://github.com/apps/pull","followers_url":"https://api.github.com/users/pull%5Bbot%5D/followers","following_url":"https://api.github.com/users/pull%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/pull%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/pull%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/pull%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/pull%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/pull%5Bbot%5D/repos","events_url":"https://api.github.com/users/pull%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/pull%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"0e855f952693c8b730abb2fc5a84dfc69562f210","commit_url":"https://api.github.com/repos/Stars1233/cryptography/commits/0e855f952693c8b730abb2fc5a84dfc69562f210","created_at":"2025-03-27T22:14:27Z","performed_via_github_app":null},{"id":18327854457,"node_id":"LOE_lADOALYunM6epYkmzwAAAAREbN15","url":"https://api.github.com/repos/pyca/cryptography/issues/events/18327854457","actor":{"login":"github-actions[bot]","id":41898282,"node_id":"MDM6Qm90NDE4OTgyODI=","avatar_url":"https://avatars.githubusercontent.com/in/15368?v=4","gravatar_id":"","url":"https://api.github.com/users/github-actions%5Bbot%5D","html_url":"https://github.com/apps/github-actions","followers_url":"https://api.github.com/users/github-actions%5Bbot%5D/followers","following_url":"https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/github-actions%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/github-actions%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/github-actions%5Bbot%5D/repos","events_url":"https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/github-actions%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"event":"locked","commit_id":null,"commit_url":null,"created_at":"2025-06-26T03:26:52Z","lock_reason":"resolved","performed_via_github_app":null}]