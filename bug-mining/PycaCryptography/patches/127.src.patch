diff --git a/src/rust/src/backend/dh.rs b/src/rust/src/backend/dh.rs
index 9cf631d7e..cbfd0d374 100644
--- a/src/rust/src/backend/dh.rs
+++ b/src/rust/src/backend/dh.rs
@@ -352,6 +352,10 @@ impl DHPublicKey {
             _ => Err(pyo3::exceptions::PyTypeError::new_err("Cannot be ordered")),
         }
     }
+
+    fn __copy__(slf: pyo3::PyRef<'_, Self>) -> pyo3::PyRef<'_, Self> {
+        slf
+    }
 }
 
 #[pyo3::prelude::pymethods]
diff --git a/src/rust/src/backend/dsa.rs b/src/rust/src/backend/dsa.rs
index db328336e..7d740d281 100644
--- a/src/rust/src/backend/dsa.rs
+++ b/src/rust/src/backend/dsa.rs
@@ -295,6 +295,10 @@ impl DsaPublicKey {
             _ => Err(pyo3::exceptions::PyTypeError::new_err("Cannot be ordered")),
         }
     }
+
+    fn __copy__(slf: pyo3::PyRef<'_, Self>) -> pyo3::PyRef<'_, Self> {
+        slf
+    }
 }
 
 #[pyo3::prelude::pymethods]
diff --git a/src/rust/src/backend/ec.rs b/src/rust/src/backend/ec.rs
index 766094b2a..a4c4afc9d 100644
--- a/src/rust/src/backend/ec.rs
+++ b/src/rust/src/backend/ec.rs
@@ -558,7 +558,12 @@ impl ECPublicKey {
             _ => Err(pyo3::exceptions::PyTypeError::new_err("Cannot be ordered")),
         }
     }
+
+    fn __copy__(slf: pyo3::PyRef<'_, Self>) -> pyo3::PyRef<'_, Self> {
+        slf
+    }
 }
+
 pub(crate) fn create_module(py: pyo3::Python<'_>) -> pyo3::PyResult<&pyo3::prelude::PyModule> {
     let m = pyo3::prelude::PyModule::new(py, "ec")?;
     m.add_function(pyo3::wrap_pyfunction!(curve_supported, m)?)?;
diff --git a/src/rust/src/backend/ed25519.rs b/src/rust/src/backend/ed25519.rs
index d0baba7e4..5a51cd7d8 100644
--- a/src/rust/src/backend/ed25519.rs
+++ b/src/rust/src/backend/ed25519.rs
@@ -160,6 +160,10 @@ impl Ed25519PublicKey {
             _ => Err(pyo3::exceptions::PyTypeError::new_err("Cannot be ordered")),
         }
     }
+
+    fn __copy__(slf: pyo3::PyRef<'_, Self>) -> pyo3::PyRef<'_, Self> {
+        slf
+    }
 }
 
 pub(crate) fn create_module(py: pyo3::Python<'_>) -> pyo3::PyResult<&pyo3::prelude::PyModule> {
diff --git a/src/rust/src/backend/ed448.rs b/src/rust/src/backend/ed448.rs
index 25d782fd3..0706e4a95 100644
--- a/src/rust/src/backend/ed448.rs
+++ b/src/rust/src/backend/ed448.rs
@@ -158,6 +158,10 @@ impl Ed448PublicKey {
             _ => Err(pyo3::exceptions::PyTypeError::new_err("Cannot be ordered")),
         }
     }
+
+    fn __copy__(slf: pyo3::PyRef<'_, Self>) -> pyo3::PyRef<'_, Self> {
+        slf
+    }
 }
 
 pub(crate) fn create_module(py: pyo3::Python<'_>) -> pyo3::PyResult<&pyo3::prelude::PyModule> {
diff --git a/src/rust/src/backend/x25519.rs b/src/rust/src/backend/x25519.rs
index 728f0231c..6b34842a6 100644
--- a/src/rust/src/backend/x25519.rs
+++ b/src/rust/src/backend/x25519.rs
@@ -149,6 +149,10 @@ impl X25519PublicKey {
             _ => Err(pyo3::exceptions::PyTypeError::new_err("Cannot be ordered")),
         }
     }
+
+    fn __copy__(slf: pyo3::PyRef<'_, Self>) -> pyo3::PyRef<'_, Self> {
+        slf
+    }
 }
 
 pub(crate) fn create_module(py: pyo3::Python<'_>) -> pyo3::PyResult<&pyo3::prelude::PyModule> {
diff --git a/src/rust/src/backend/x448.rs b/src/rust/src/backend/x448.rs
index 4c6da8c7d..65f3249ef 100644
--- a/src/rust/src/backend/x448.rs
+++ b/src/rust/src/backend/x448.rs
@@ -148,6 +148,10 @@ impl X448PublicKey {
             _ => Err(pyo3::exceptions::PyTypeError::new_err("Cannot be ordered")),
         }
     }
+
+    fn __copy__(slf: pyo3::PyRef<'_, Self>) -> pyo3::PyRef<'_, Self> {
+        slf
+    }
 }
 
 pub(crate) fn create_module(py: pyo3::Python<'_>) -> pyo3::PyResult<&pyo3::prelude::PyModule> {
diff --git a/tests/hazmat/primitives/test_dh.py b/tests/hazmat/primitives/test_dh.py
index 4a9afc15a..3fc3ef17e 100644
--- a/tests/hazmat/primitives/test_dh.py
+++ b/tests/hazmat/primitives/test_dh.py
@@ -4,6 +4,7 @@
 
 
 import binascii
+import copy
 import itertools
 import os
 import typing
@@ -489,6 +490,21 @@ class TestDH:
         with pytest.raises(TypeError):
             key1 < key2  # type: ignore[operator]
 
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.dh_x942_serialization_supported(),
+        skip_message="DH X9.42 not supported",
+    )
+    def test_public_key_copy(self):
+        key_bytes = load_vectors_from_file(
+            os.path.join("asymmetric", "DH", "dhpub.pem"),
+            lambda pemfile: pemfile.read(),
+            mode="rb",
+        )
+        key1 = serialization.load_pem_public_key(key_bytes)
+        key2 = copy.copy(key1)
+
+        assert key1 == key2
+
 
 @pytest.mark.supported(
     only_if=lambda backend: backend.dh_supported(),
diff --git a/tests/hazmat/primitives/test_dsa.py b/tests/hazmat/primitives/test_dsa.py
index bf50c47c4..936b1a80f 100644
--- a/tests/hazmat/primitives/test_dsa.py
+++ b/tests/hazmat/primitives/test_dsa.py
@@ -3,6 +3,7 @@
 # for complete details.
 
 
+import copy
 import itertools
 import os
 import typing
@@ -398,6 +399,16 @@ class TestDSA:
         with pytest.raises(TypeError):
             key1 < key2  # type: ignore[operator]
 
+    def test_public_key_copy(self):
+        key_bytes = load_vectors_from_file(
+            os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pem"),
+            lambda pemfile: pemfile.read().encode(),
+        )
+        key1 = serialization.load_pem_private_key(key_bytes, None).public_key()
+        key2 = copy.copy(key1)
+
+        assert key1 == key2
+
 
 @pytest.mark.supported(
     only_if=lambda backend: backend.dsa_supported(),
diff --git a/tests/hazmat/primitives/test_ec.py b/tests/hazmat/primitives/test_ec.py
index 1da36b86a..cf96bfc51 100644
--- a/tests/hazmat/primitives/test_ec.py
+++ b/tests/hazmat/primitives/test_ec.py
@@ -2,8 +2,8 @@
 # 2.0, and the BSD License. See the LICENSE file in the root of this repository
 # for complete details.
 
-
 import binascii
+import copy
 import itertools
 import os
 import textwrap
@@ -617,6 +617,17 @@ class TestECEquality:
         with pytest.raises(TypeError):
             key1 < key2  # type: ignore[operator]
 
+    def test_public_key_copy(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key_bytes = load_vectors_from_file(
+            os.path.join("asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: pemfile.read().encode(),
+        )
+        key1 = serialization.load_pem_private_key(key_bytes, None).public_key()
+        key2 = copy.copy(key1)
+
+        assert key1 == key2
+
 
 class TestECSerialization:
     @pytest.mark.parametrize(
diff --git a/tests/hazmat/primitives/test_ed25519.py b/tests/hazmat/primitives/test_ed25519.py
index 2501f1cf1..8e6b33b1f 100644
--- a/tests/hazmat/primitives/test_ed25519.py
+++ b/tests/hazmat/primitives/test_ed25519.py
@@ -4,6 +4,7 @@
 
 
 import binascii
+import copy
 import os
 
 import pytest
@@ -294,3 +295,19 @@ def test_public_key_equality(backend):
 
     with pytest.raises(TypeError):
         key1 < key2  # type: ignore[operator]
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.ed25519_supported(),
+    skip_message="Requires OpenSSL with Ed25519 support",
+)
+def test_public_key_copy(backend):
+    key_bytes = load_vectors_from_file(
+        os.path.join("asymmetric", "Ed25519", "ed25519-pkcs8.der"),
+        lambda derfile: derfile.read(),
+        mode="rb",
+    )
+    key1 = serialization.load_der_private_key(key_bytes, None).public_key()
+    key2 = copy.copy(key1)
+
+    assert key1 == key2
diff --git a/tests/hazmat/primitives/test_ed448.py b/tests/hazmat/primitives/test_ed448.py
index 650cdda79..d363f38df 100644
--- a/tests/hazmat/primitives/test_ed448.py
+++ b/tests/hazmat/primitives/test_ed448.py
@@ -4,6 +4,7 @@
 
 
 import binascii
+import copy
 import os
 
 import pytest
@@ -288,3 +289,19 @@ def test_public_key_equality(backend):
 
     with pytest.raises(TypeError):
         key1 < key2  # type: ignore[operator]
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.ed448_supported(),
+    skip_message="Requires OpenSSL with Ed448 support",
+)
+def test_public_key_copy(backend):
+    key_bytes = load_vectors_from_file(
+        os.path.join("asymmetric", "Ed448", "ed448-pkcs8.der"),
+        lambda derfile: derfile.read(),
+        mode="rb",
+    )
+    key1 = serialization.load_der_private_key(key_bytes, None).public_key()
+    key2 = copy.copy(key1)
+
+    assert key1 == key2
diff --git a/tests/hazmat/primitives/test_rsa.py b/tests/hazmat/primitives/test_rsa.py
index 3cb3b17ef..eda445b8e 100644
--- a/tests/hazmat/primitives/test_rsa.py
+++ b/tests/hazmat/primitives/test_rsa.py
@@ -4,6 +4,7 @@
 
 
 import binascii
+import copy
 import itertools
 import os
 
@@ -2734,3 +2735,9 @@ class TestRSAPEMPublicKeySerialization:
         assert key1 == key2
         assert key1 != key3
         assert key1 != object()
+
+    def test_public_key_copy(self, rsa_key_2048: rsa.RSAPrivateKey):
+        key1 = rsa_key_2048.public_key()
+        key2 = copy.copy(key1)
+
+        assert key1 == key2
diff --git a/tests/hazmat/primitives/test_x25519.py b/tests/hazmat/primitives/test_x25519.py
index 2b86d3d5e..f81a14930 100644
--- a/tests/hazmat/primitives/test_x25519.py
+++ b/tests/hazmat/primitives/test_x25519.py
@@ -4,6 +4,7 @@
 
 
 import binascii
+import copy
 import os
 
 import pytest
@@ -351,3 +352,19 @@ def test_public_key_equality(backend):
     assert key1 != object()
     with pytest.raises(TypeError):
         key1 < key2  # type: ignore[operator]
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.x25519_supported(),
+    skip_message="Requires OpenSSL with X25519 support",
+)
+def test_public_key_copy(backend):
+    key_bytes = load_vectors_from_file(
+        os.path.join("asymmetric", "X25519", "x25519-pkcs8.der"),
+        lambda derfile: derfile.read(),
+        mode="rb",
+    )
+    key1 = serialization.load_der_private_key(key_bytes, None).public_key()
+    key2 = copy.copy(key1)
+
+    assert key1 == key2
diff --git a/tests/hazmat/primitives/test_x448.py b/tests/hazmat/primitives/test_x448.py
index e2f840fa8..46f4856c1 100644
--- a/tests/hazmat/primitives/test_x448.py
+++ b/tests/hazmat/primitives/test_x448.py
@@ -4,6 +4,7 @@
 
 
 import binascii
+import copy
 import os
 
 import pytest
@@ -280,3 +281,19 @@ def test_public_key_equality(backend):
     assert key1 != object()
     with pytest.raises(TypeError):
         key1 < key2  # type: ignore[operator]
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.x448_supported(),
+    skip_message="Requires OpenSSL with X448 support",
+)
+def test_public_key_copy(backend):
+    key_bytes = load_vectors_from_file(
+        os.path.join("asymmetric", "X448", "x448-pkcs8.der"),
+        lambda derfile: derfile.read(),
+        mode="rb",
+    )
+    key1 = serialization.load_der_private_key(key_bytes, None).public_key()
+    key2 = copy.copy(key1)
+
+    assert key1 == key2
