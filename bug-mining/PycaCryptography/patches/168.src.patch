diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index b07112a46..a21b6518a 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -67,6 +67,8 @@ Changelog
 * We now publish ``py311`` wheels that utilize the faster ``pyo3::buffer::PyBuffer``
   interface, resulting in significantly improved performance for operations
   involving small buffers.
+* Added :func:`~cryptography.hazmat.primitives.serialization.ssh_key_fingerprint`
+  for computing fingerprints of SSH public keys.
 
 .. _v44-0-3:
 
diff --git a/docs/hazmat/primitives/asymmetric/serialization.rst b/docs/hazmat/primitives/asymmetric/serialization.rst
index 42e879ce2..fb49c7d14 100644
--- a/docs/hazmat/primitives/asymmetric/serialization.rst
+++ b/docs/hazmat/primitives/asymmetric/serialization.rst
@@ -426,6 +426,37 @@ DSA keys look almost identical but begin with ``ssh-dss`` rather than
     :raises cryptography.exceptions.UnsupportedAlgorithm: If the serialized
         key is of a type that is not supported.
 
+
+.. function:: ssh_key_fingerprint(key, hash_algorithm)
+
+    .. versionadded:: 45.0.0
+
+    Computes the fingerprint of an SSH public key. The fingerprint is the raw
+    bytes of the hash, depending on your use you may need to encode the data as
+    base64 or hex.
+
+    :param key: The public key to compute the fingerprint for.
+    :type key: One of :data:`SSHPublicKeyTypes`
+
+    :param hash_algorithm: The hash algorithm to use, either ``MD5()`` or
+        ``SHA256()``.
+
+    :return: The key fingerprint.
+    :rtype: bytes
+
+    .. code-block:: pycon
+
+        >>> from cryptography.hazmat.primitives.serialization import load_ssh_public_key, ssh_key_fingerprint
+        >>> key_data = b"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAhVNvf1vigXfagQXKjdKN5zEF12KWVMVdDrU3sVLhgd user@example.com"
+        >>> public_key = load_ssh_public_key(key_data)
+        >>> md5_fingerprint = ssh_key_fingerprint(public_key, hashes.MD5())
+        >>> md5_fingerprint
+        b'\x95\xf6\xc0\xe3so\xaen\xcc\x98\xbb\xf4\xd8BJ\x15'
+        >>> sha256_fingerprint = ssh_key_fingerprint(public_key, hashes.SHA256())
+        >>> sha256_fingerprint
+        b'R\x0f*!\x99f9\x9a\xcd\x98[\xe8-&\xbah\xa6x\x96\x87\xb3\xf9\xe0\x9b\xb1,\xcc\xbdt\xd4\xc3\xb7'
+
+
 OpenSSH Private Key
 ~~~~~~~~~~~~~~~~~~~
 
diff --git a/src/cryptography/hazmat/primitives/serialization/__init__.py b/src/cryptography/hazmat/primitives/serialization/__init__.py
index 07b2264b9..62283cc70 100644
--- a/src/cryptography/hazmat/primitives/serialization/__init__.py
+++ b/src/cryptography/hazmat/primitives/serialization/__init__.py
@@ -33,6 +33,7 @@ from cryptography.hazmat.primitives.serialization.ssh import (
     load_ssh_private_key,
     load_ssh_public_identity,
     load_ssh_public_key,
+    ssh_key_fingerprint,
 )
 
 __all__ = [
@@ -60,4 +61,5 @@ __all__ = [
     "load_ssh_private_key",
     "load_ssh_public_identity",
     "load_ssh_public_key",
+    "ssh_key_fingerprint",
 ]
diff --git a/src/cryptography/hazmat/primitives/serialization/ssh.py b/src/cryptography/hazmat/primitives/serialization/ssh.py
index 89ccd810c..3ef08b03f 100644
--- a/src/cryptography/hazmat/primitives/serialization/ssh.py
+++ b/src/cryptography/hazmat/primitives/serialization/ssh.py
@@ -1152,6 +1152,28 @@ def _parse_exts_opts(exts_opts: memoryview) -> dict[bytes, bytes]:
     return result
 
 
+def ssh_key_fingerprint(
+    key: SSHPublicKeyTypes,
+    hash_algorithm: hashes.MD5 | hashes.SHA256,
+) -> bytes:
+    if not isinstance(hash_algorithm, (hashes.MD5, hashes.SHA256)):
+        raise TypeError("hash_algorithm must be either MD5 or SHA256")
+
+    key_type = _get_ssh_key_type(key)
+    kformat = _lookup_kformat(key_type)
+
+    f_pub = _FragList()
+    f_pub.put_sshstr(key_type)
+    kformat.encode_public(key, f_pub)
+
+    ssh_binary_data = f_pub.tobytes()
+
+    # Hash the binary data
+    hash_obj = hashes.Hash(hash_algorithm)
+    hash_obj.update(ssh_binary_data)
+    return hash_obj.finalize()
+
+
 def load_ssh_public_key(
     data: utils.Buffer, backend: typing.Any = None
 ) -> SSHPublicKeyTypes:
diff --git a/tests/hazmat/primitives/test_ssh.py b/tests/hazmat/primitives/test_ssh.py
index 47dd7a545..db1d100a9 100644
--- a/tests/hazmat/primitives/test_ssh.py
+++ b/tests/hazmat/primitives/test_ssh.py
@@ -15,6 +15,7 @@ from cryptography.exceptions import (
     InvalidTag,
     UnsupportedAlgorithm,
 )
+from cryptography.hazmat.primitives import hashes
 from cryptography.hazmat.primitives.asymmetric import (
     dsa,
     ec,
@@ -36,6 +37,7 @@ from cryptography.hazmat.primitives.serialization import (
     load_ssh_public_identity,
     load_ssh_public_key,
     ssh,
+    ssh_key_fingerprint,
 )
 
 from ...doubles import DummyKeySerializationEncryption
@@ -1868,3 +1870,105 @@ class TestSSHSK:
     def test_load_application_valueerror(self):
         with pytest.raises(ValueError):
             ssh.load_application(self.ssh_str("hss:test"))
+
+
+class TestSSHKeyFingerprint:
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hash_supported(hashes.MD5()),
+        skip_message="Does not support MD5",
+    )
+    def test_ssh_key_fingerprint_rsa_md5(self):
+        ssh_key = load_vectors_from_file(
+            os.path.join("asymmetric", "OpenSSH", "rsa-nopsw.key.pub"),
+            lambda f: f.read(),
+            mode="rb",
+        )
+        public_key = load_ssh_public_key(ssh_key)
+        fingerprint = ssh_key_fingerprint(public_key, hashes.MD5())
+        assert fingerprint == b"\x10G\xc2es\xd6QIH\x0b\x81\x1f6\x04{R"
+
+    def test_ssh_key_fingerprint_rsa_sha256(self):
+        ssh_key = load_vectors_from_file(
+            os.path.join("asymmetric", "OpenSSH", "rsa-nopsw.key.pub"),
+            lambda f: f.read(),
+            mode="rb",
+        )
+        public_key = load_ssh_public_key(ssh_key)
+        fingerprint = ssh_key_fingerprint(public_key, hashes.SHA256())
+        assert fingerprint == (
+            b"\x80\xc0u\xcaV$\xfc\xeb\x04\xb1\x83]\x9a\x1e\xa1\x8d\x17"
+            b"\xc4d\xa23\xbek\xa4\xe9 \x92j\x89\xe6\xe8%"
+        )
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hash_supported(hashes.MD5())
+        and backend.ed25519_supported(),
+        skip_message="Does not support MD5 or Ed25519",
+    )
+    def test_ssh_key_fingerprint_ed25519_md5(self):
+        ssh_key = load_vectors_from_file(
+            os.path.join("asymmetric", "OpenSSH", "ed25519-nopsw.key.pub"),
+            lambda f: f.read(),
+            mode="rb",
+        )
+        public_key = load_ssh_public_key(ssh_key)
+        fingerprint = ssh_key_fingerprint(public_key, hashes.MD5())
+        assert fingerprint == b"\xe5R=\x01\x9e\xa0\xc1\xe9\x8c?L|\xc5\x94W\x85"
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.ed25519_supported(),
+        skip_message="Ed25519 not supported",
+    )
+    def test_ssh_key_fingerprint_ed25519_sha256(self):
+        ssh_key = load_vectors_from_file(
+            os.path.join("asymmetric", "OpenSSH", "ed25519-nopsw.key.pub"),
+            lambda f: f.read(),
+            mode="rb",
+        )
+        public_key = load_ssh_public_key(ssh_key)
+        fingerprint = ssh_key_fingerprint(public_key, hashes.SHA256())
+        assert fingerprint == (
+            b'\x92z-\xb4\xaf\xf4,\x15\xa5\xc6\xf36p83\xcc"]CJi\x16V?\x879'
+            b"GZVS8\xb9"
+        )
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hash_supported(hashes.MD5()),
+        skip_message="Does not support MD5",
+    )
+    def test_ssh_key_fingerprint_ecdsa_md5(self):
+        ssh_key = load_vectors_from_file(
+            os.path.join("asymmetric", "OpenSSH", "ecdsa-nopsw.key.pub"),
+            lambda f: f.read(),
+            mode="rb",
+        )
+        public_key = load_ssh_public_key(ssh_key)
+        fingerprint = ssh_key_fingerprint(public_key, hashes.MD5())
+        assert fingerprint == b"\re\xf2-\xfaGq\x8c^\x16\xb05+\x06\x1b7"
+
+    def test_ssh_key_fingerprint_ecdsa_sha256(self):
+        ssh_key = load_vectors_from_file(
+            os.path.join("asymmetric", "OpenSSH", "ecdsa-nopsw.key.pub"),
+            lambda f: f.read(),
+            mode="rb",
+        )
+        public_key = load_ssh_public_key(ssh_key)
+        fingerprint = ssh_key_fingerprint(public_key, hashes.SHA256())
+        assert fingerprint == (
+            b"[\xa5\xab\xe9\xdf\r\xe5\x1er\xd6\xbc\xd9\x97\xc2\xf4\xdc"
+            b"\xd4\xe0\xaf\x17<i\xdc^\x11>\xc6\x91wIJ\xf5"
+        )
+
+    def test_ssh_key_fingerprint_unsupported_hash(self):
+        ssh_key = load_vectors_from_file(
+            os.path.join("asymmetric", "OpenSSH", "rsa-nopsw.key.pub"),
+            lambda f: f.read(),
+            mode="rb",
+        )
+        public_key = load_ssh_public_key(ssh_key)
+        with pytest.raises(TypeError):
+            ssh_key_fingerprint(public_key, hashes.SHA1())  # type: ignore[arg-type]
+
+    def test_ssh_key_fingerprint_unsupported_key(self):
+        with pytest.raises(ValueError):
+            ssh_key_fingerprint(object(), hashes.SHA256())  # type: ignore[arg-type]
