diff --git a/src/rust/cryptography-key-parsing/src/lib.rs b/src/rust/cryptography-key-parsing/src/lib.rs
index 8d54f3adf..0c5139af3 100644
--- a/src/rust/cryptography-key-parsing/src/lib.rs
+++ b/src/rust/cryptography-key-parsing/src/lib.rs
@@ -12,6 +12,8 @@ pub mod pkcs8;
 pub mod rsa;
 pub mod spki;
 
+pub const MIN_DH_MODULUS_SIZE: u32 = 512;
+
 pub enum KeyParsingError {
     InvalidKey,
     ExplicitCurveUnsupported,
diff --git a/src/rust/cryptography-key-parsing/src/pkcs8.rs b/src/rust/cryptography-key-parsing/src/pkcs8.rs
index f65a82be2..1111ab024 100644
--- a/src/rust/cryptography-key-parsing/src/pkcs8.rs
+++ b/src/rust/cryptography-key-parsing/src/pkcs8.rs
@@ -8,6 +8,8 @@ use cryptography_x509::common::{
 use cryptography_x509::csr::Attributes;
 use cryptography_x509::pkcs8::EncryptedPrivateKeyInfo;
 
+#[cfg(not(CRYPTOGRAPHY_IS_BORINGSSL))]
+use crate::MIN_DH_MODULUS_SIZE;
 use crate::{ec, rsa, KeyParsingError, KeyParsingResult};
 
 // RFC 5208 Section 5
@@ -54,29 +56,17 @@ pub fn parse_private_key(
 
         #[cfg(not(CRYPTOGRAPHY_IS_BORINGSSL))]
         AlgorithmParameters::Dh(dh_params) => {
-            let private_key_bytes =
-                asn1::parse_single::<asn1::BigUint<'_>>(k.private_key)?.as_bytes();
-            let dh_private_key = openssl::bn::BigNum::from_slice(private_key_bytes)?;
             let p = openssl::bn::BigNum::from_slice(dh_params.p.as_bytes())?;
             let g = openssl::bn::BigNum::from_slice(dh_params.g.as_bytes())?;
-            let q = openssl::bn::BigNum::from_slice(dh_params.q.as_bytes())?;
-
-            let dh = openssl::dh::Dh::from_params(p, g, q)?;
-            let dh = dh.set_private_key(dh_private_key)?;
-            Ok(openssl::pkey::PKey::from_dh(dh)?)
+            let q = Some(openssl::bn::BigNum::from_slice(dh_params.q.as_bytes())?);
+            parse_dh_private_key(k.private_key, p, g, q)
         }
 
         #[cfg(not(CRYPTOGRAPHY_IS_BORINGSSL))]
         AlgorithmParameters::DhKeyAgreement(dh_params) => {
-            let private_key_bytes =
-                asn1::parse_single::<asn1::BigUint<'_>>(k.private_key)?.as_bytes();
-            let dh_private_key = openssl::bn::BigNum::from_slice(private_key_bytes)?;
             let p = openssl::bn::BigNum::from_slice(dh_params.p.as_bytes())?;
             let g = openssl::bn::BigNum::from_slice(dh_params.g.as_bytes())?;
-
-            let dh = openssl::dh::Dh::from_pqg(p, None, g)?;
-            let dh = dh.set_private_key(dh_private_key)?;
-            Ok(openssl::pkey::PKey::from_dh(dh)?)
+            parse_dh_private_key(k.private_key, p, g, None)
         }
 
         AlgorithmParameters::X25519 => {
@@ -124,6 +114,25 @@ pub fn parse_private_key(
     }
 }
 
+#[cfg(not(CRYPTOGRAPHY_IS_BORINGSSL))]
+fn parse_dh_private_key(
+    private_key_data: &[u8],
+    p: openssl::bn::BigNum,
+    g: openssl::bn::BigNum,
+    q: Option<openssl::bn::BigNum>,
+) -> KeyParsingResult<openssl::pkey::PKey<openssl::pkey::Private>> {
+    let private_key_bytes = asn1::parse_single::<asn1::BigUint<'_>>(private_key_data)?.as_bytes();
+    let dh_private_key = openssl::bn::BigNum::from_slice(private_key_bytes)?;
+
+    if p.num_bits() < MIN_DH_MODULUS_SIZE as i32 {
+        return Err(KeyParsingError::InvalidKey);
+    }
+
+    let dh = openssl::dh::Dh::from_pqg(p, q, g)?;
+    let dh = dh.set_private_key(dh_private_key)?;
+    Ok(openssl::pkey::PKey::from_dh(dh)?)
+}
+
 fn pkcs12_pbe_decrypt(
     data: &[u8],
     password: &[u8],
diff --git a/src/rust/src/backend/dh.rs b/src/rust/src/backend/dh.rs
index b831036b9..e419485f0 100644
--- a/src/rust/src/backend/dh.rs
+++ b/src/rust/src/backend/dh.rs
@@ -10,8 +10,6 @@ use crate::backend::utils;
 use crate::error::{CryptographyError, CryptographyResult};
 use crate::{types, x509};
 
-const MIN_MODULUS_SIZE: u32 = 512;
-
 #[pyo3::pyclass(frozen, module = "cryptography.hazmat.bindings._rust.openssl.dh")]
 pub(crate) struct DHPrivateKey {
     pkey: openssl::pkey::PKey<openssl::pkey::Private>,
@@ -36,10 +34,11 @@ fn generate_parameters(
 ) -> CryptographyResult<DHParameters> {
     let _ = backend;
 
-    if key_size < MIN_MODULUS_SIZE {
+    if key_size < cryptography_key_parsing::MIN_DH_MODULUS_SIZE {
         return Err(CryptographyError::from(
             pyo3::exceptions::PyValueError::new_err(format!(
-                "DH key_size must be at least {MIN_MODULUS_SIZE} bits"
+                "DH key_size must be at least {} bits",
+                cryptography_key_parsing::MIN_DH_MODULUS_SIZE
             )),
         ));
     }
@@ -501,11 +500,12 @@ impl DHParameterNumbers {
 
         if p.bind(py)
             .call_method0("bit_length")?
-            .lt(MIN_MODULUS_SIZE)?
+            .lt(cryptography_key_parsing::MIN_DH_MODULUS_SIZE)?
         {
             return Err(CryptographyError::from(
                 pyo3::exceptions::PyValueError::new_err(format!(
-                    "p (modulus) must be at least {MIN_MODULUS_SIZE}-bit"
+                    "p (modulus) must be at least {}-bit",
+                    cryptography_key_parsing::MIN_DH_MODULUS_SIZE
                 )),
             ));
         }
diff --git a/tests/hazmat/primitives/test_dh.py b/tests/hazmat/primitives/test_dh.py
index a09f77863..fc86c1af4 100644
--- a/tests/hazmat/primitives/test_dh.py
+++ b/tests/hazmat/primitives/test_dh.py
@@ -11,7 +11,6 @@ import typing
 
 import pytest
 
-from cryptography.hazmat.bindings._rust import openssl as rust_openssl
 from cryptography.hazmat.primitives import serialization
 from cryptography.hazmat.primitives.asymmetric import dh
 
@@ -385,22 +384,14 @@ class TestDH:
         with pytest.raises(ValueError):
             key2.exchange(pub_key1)
 
-    @pytest.mark.skip_fips(reason="key_size too small for FIPS")
-    @pytest.mark.supported(
-        only_if=lambda backend: (
-            not rust_openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
-        ),
-        skip_message="256-bit DH keys are not supported in OpenSSL 3.0.0+",
-    )
     def test_load_256bit_key_from_pkcs8(self, backend):
         data = load_vectors_from_file(
             os.path.join("asymmetric", "DH", "dh_key_256.pem"),
             lambda pemfile: pemfile.read(),
             mode="rb",
         )
-        key = serialization.load_pem_private_key(data, None, backend)
-        assert isinstance(key, dh.DHPrivateKey)
-        assert key.key_size == 256
+        with pytest.raises(ValueError):
+            serialization.load_pem_private_key(data, None, backend)
 
     @pytest.mark.parametrize(
         "vector",
