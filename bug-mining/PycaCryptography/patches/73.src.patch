diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index 98f9d5406..b497933fd 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -29,6 +29,8 @@ Changelog
 * Added support for multiple
   :class:`~cryptography.x509.ocsp.OCSPSingleResponse` in a
   :class:`~cryptography.x509.ocsp.OCSPResponse`. 
+* Restored support for signing certificates and other structures in
+  :doc:`/x509/index` with SHA3 hash algorithms.
 
 .. _v36-0-1:
 
diff --git a/src/rust/src/x509/oid.rs b/src/rust/src/x509/oid.rs
index 7ddd64e9a..7d5eb611a 100644
--- a/src/rust/src/x509/oid.rs
+++ b/src/rust/src/x509/oid.rs
@@ -41,6 +41,10 @@ lazy_static::lazy_static! {
     pub(crate) static ref ECDSA_WITH_SHA256_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("1.2.840.10045.4.3.2").unwrap();
     pub(crate) static ref ECDSA_WITH_SHA384_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("1.2.840.10045.4.3.3").unwrap();
     pub(crate) static ref ECDSA_WITH_SHA512_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("1.2.840.10045.4.3.4").unwrap();
+    pub(crate) static ref ECDSA_WITH_SHA3_224_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("2.16.840.1.101.3.4.3.9").unwrap();
+    pub(crate) static ref ECDSA_WITH_SHA3_256_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("2.16.840.1.101.3.4.3.10").unwrap();
+    pub(crate) static ref ECDSA_WITH_SHA3_384_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("2.16.840.1.101.3.4.3.11").unwrap();
+    pub(crate) static ref ECDSA_WITH_SHA3_512_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("2.16.840.1.101.3.4.3.12").unwrap();
 
     pub(crate) static ref RSA_WITH_MD5_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("1.2.840.113549.1.1.4").unwrap();
     pub(crate) static ref RSA_WITH_SHA1_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("1.2.840.113549.1.1.5").unwrap();
@@ -48,6 +52,10 @@ lazy_static::lazy_static! {
     pub(crate) static ref RSA_WITH_SHA256_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("1.2.840.113549.1.1.11").unwrap();
     pub(crate) static ref RSA_WITH_SHA384_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("1.2.840.113549.1.1.12").unwrap();
     pub(crate) static ref RSA_WITH_SHA512_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("1.2.840.113549.1.1.13").unwrap();
+    pub(crate) static ref RSA_WITH_SHA3_224_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("2.16.840.1.101.3.4.3.13").unwrap();
+    pub(crate) static ref RSA_WITH_SHA3_256_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("2.16.840.1.101.3.4.3.14").unwrap();
+    pub(crate) static ref RSA_WITH_SHA3_384_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("2.16.840.1.101.3.4.3.15").unwrap();
+    pub(crate) static ref RSA_WITH_SHA3_512_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("2.16.840.1.101.3.4.3.16").unwrap();
 
     pub(crate) static ref DSA_WITH_SHA1_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("1.2.840.10040.4.3").unwrap();
     pub(crate) static ref DSA_WITH_SHA224_OID: asn1::ObjectIdentifier<'static> = asn1::ObjectIdentifier::from_string("2.16.840.1.101.3.4.3.1").unwrap();
diff --git a/src/rust/src/x509/sign.rs b/src/rust/src/x509/sign.rs
index e15794818..bf17df9b5 100644
--- a/src/rust/src/x509/sign.rs
+++ b/src/rust/src/x509/sign.rs
@@ -27,6 +27,10 @@ enum HashType {
     Sha256,
     Sha384,
     Sha512,
+    Sha3_224,
+    Sha3_256,
+    Sha3_384,
+    Sha3_512,
 }
 
 fn identify_key_type(py: pyo3::Python<'_>, private_key: &pyo3::PyAny) -> pyo3::PyResult<KeyType> {
@@ -93,6 +97,10 @@ fn identify_hash_type(
         "sha256" => Ok(HashType::Sha256),
         "sha384" => Ok(HashType::Sha384),
         "sha512" => Ok(HashType::Sha512),
+        "sha3-224" => Ok(HashType::Sha3_224),
+        "sha3-256" => Ok(HashType::Sha3_256),
+        "sha3-384" => Ok(HashType::Sha3_384),
+        "sha3-512" => Ok(HashType::Sha3_512),
         name => Err(pyo3::exceptions::PyValueError::new_err(format!(
             "Hash algorithm {:?} not supported for signatures",
             name
@@ -143,6 +151,22 @@ pub(crate) fn compute_signature_algorithm<'p>(
             oid: (*oid::ECDSA_WITH_SHA512_OID).clone(),
             params: None,
         }),
+        (KeyType::Ec, HashType::Sha3_224) => Ok(x509::AlgorithmIdentifier {
+            oid: (*oid::ECDSA_WITH_SHA3_224_OID).clone(),
+            params: None,
+        }),
+        (KeyType::Ec, HashType::Sha3_256) => Ok(x509::AlgorithmIdentifier {
+            oid: (*oid::ECDSA_WITH_SHA3_256_OID).clone(),
+            params: None,
+        }),
+        (KeyType::Ec, HashType::Sha3_384) => Ok(x509::AlgorithmIdentifier {
+            oid: (*oid::ECDSA_WITH_SHA3_384_OID).clone(),
+            params: None,
+        }),
+        (KeyType::Ec, HashType::Sha3_512) => Ok(x509::AlgorithmIdentifier {
+            oid: (*oid::ECDSA_WITH_SHA3_512_OID).clone(),
+            params: None,
+        }),
 
         (KeyType::Rsa, HashType::Md5) => Ok(x509::AlgorithmIdentifier {
             oid: (*oid::RSA_WITH_MD5_OID).clone(),
@@ -168,6 +192,22 @@ pub(crate) fn compute_signature_algorithm<'p>(
             oid: (*oid::RSA_WITH_SHA512_OID).clone(),
             params: Some(*NULL_TLV),
         }),
+        (KeyType::Rsa, HashType::Sha3_224) => Ok(x509::AlgorithmIdentifier {
+            oid: (*oid::RSA_WITH_SHA3_224_OID).clone(),
+            params: Some(*NULL_TLV),
+        }),
+        (KeyType::Rsa, HashType::Sha3_256) => Ok(x509::AlgorithmIdentifier {
+            oid: (*oid::RSA_WITH_SHA3_256_OID).clone(),
+            params: Some(*NULL_TLV),
+        }),
+        (KeyType::Rsa, HashType::Sha3_384) => Ok(x509::AlgorithmIdentifier {
+            oid: (*oid::RSA_WITH_SHA3_384_OID).clone(),
+            params: Some(*NULL_TLV),
+        }),
+        (KeyType::Rsa, HashType::Sha3_512) => Ok(x509::AlgorithmIdentifier {
+            oid: (*oid::RSA_WITH_SHA3_512_OID).clone(),
+            params: Some(*NULL_TLV),
+        }),
 
         (KeyType::Dsa, HashType::Sha1) => Ok(x509::AlgorithmIdentifier {
             oid: (*oid::DSA_WITH_SHA1_OID).clone(),
@@ -189,6 +229,12 @@ pub(crate) fn compute_signature_algorithm<'p>(
             oid: (*oid::DSA_WITH_SHA512_OID).clone(),
             params: None,
         }),
+        (KeyType::Dsa, HashType::Sha3_224)
+        | (KeyType::Dsa, HashType::Sha3_256)
+        | (KeyType::Dsa, HashType::Sha3_384)
+        | (KeyType::Dsa, HashType::Sha3_512) => Err(pyo3::exceptions::PyValueError::new_err(
+            "SHA3 hashes are not supported with DSA keys",
+        )),
 
         (_, HashType::None) => Err(pyo3::exceptions::PyTypeError::new_err(
             "Algorithm must be a registered hash algorithm, not None.",
diff --git a/tests/x509/test_x509.py b/tests/x509/test_x509.py
index 119fd60d6..6e25baa2e 100644
--- a/tests/x509/test_x509.py
+++ b/tests/x509/test_x509.py
@@ -1769,11 +1769,15 @@ class TestRSACertificateRequest:
             (hashes.SHA256, x509.SignatureAlgorithmOID.RSA_WITH_SHA256),
             (hashes.SHA384, x509.SignatureAlgorithmOID.RSA_WITH_SHA384),
             (hashes.SHA512, x509.SignatureAlgorithmOID.RSA_WITH_SHA512),
+            (hashes.SHA3_224, x509.SignatureAlgorithmOID.RSA_WITH_SHA3_224),
+            (hashes.SHA3_256, x509.SignatureAlgorithmOID.RSA_WITH_SHA3_256),
+            (hashes.SHA3_384, x509.SignatureAlgorithmOID.RSA_WITH_SHA3_384),
+            (hashes.SHA3_512, x509.SignatureAlgorithmOID.RSA_WITH_SHA3_512),
         ],
     )
     def test_build_cert(self, hashalg, hashalg_oid, backend):
-        if backend._fips_enabled and hashalg is hashes.SHA1:
-            pytest.skip("SHA1 not supported in FIPS mode")
+        if not backend.hash_supported(hashalg()):
+            pytest.skip(f"{hashalg} not supported in FIPS mode")
 
         issuer_private_key = RSA_KEY_2048.private_key(backend)
         subject_private_key = RSA_KEY_2048.private_key(backend)
@@ -2570,7 +2574,17 @@ class TestCertificateBuilder:
         only_if=lambda backend: backend.hash_supported(hashes.MD5()),
         skip_message="Requires OpenSSL with MD5 support",
     )
-    def test_sign_dsa_with_md5(self, backend):
+    @pytest.mark.parametrize(
+        "hash_algorithm",
+        [
+            hashes.MD5(),
+            hashes.SHA3_224(),
+            hashes.SHA3_256(),
+            hashes.SHA3_384(),
+            hashes.SHA3_512(),
+        ],
+    )
+    def test_sign_dsa_with_unsupported_hash(self, hash_algorithm, backend):
         private_key = DSA_KEY_2048.private_key(backend)
         builder = x509.CertificateBuilder()
         builder = (
@@ -2586,7 +2600,7 @@ class TestCertificateBuilder:
             .not_valid_after(datetime.datetime(2032, 1, 1, 12, 1))
         )
         with pytest.raises(ValueError):
-            builder.sign(private_key, hashes.MD5(), backend)
+            builder.sign(private_key, hash_algorithm, backend)
 
     @pytest.mark.supported(
         only_if=lambda backend: backend.hash_supported(hashes.MD5()),
@@ -2685,14 +2699,18 @@ class TestCertificateBuilder:
             (hashes.SHA256, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA256),
             (hashes.SHA384, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA384),
             (hashes.SHA512, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA512),
+            (hashes.SHA3_224, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA3_224),
+            (hashes.SHA3_256, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA3_256),
+            (hashes.SHA3_384, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA3_384),
+            (hashes.SHA3_512, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA3_512),
         ],
     )
     def test_build_cert_with_ec_private_key(
         self, hashalg, hashalg_oid, backend
     ):
         _skip_curve_unsupported(backend, ec.SECP256R1())
-        if backend._fips_enabled and hashalg is hashes.SHA1:
-            pytest.skip("SHA1 not supported in FIPS mode")
+        if not backend.hash_supported(hashalg()):
+            pytest.skip(f"{hashalg} not supported in FIPS mode")
 
         issuer_private_key = ec.generate_private_key(ec.SECP256R1(), backend)
         subject_private_key = ec.generate_private_key(ec.SECP256R1(), backend)
