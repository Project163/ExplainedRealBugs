diff --git a/src/rust/cryptography-x509-verification/src/lib.rs b/src/rust/cryptography-x509-verification/src/lib.rs
index ab73cd209..730a9ac4f 100644
--- a/src/rust/cryptography-x509-verification/src/lib.rs
+++ b/src/rust/cryptography-x509-verification/src/lib.rs
@@ -45,7 +45,6 @@ pub enum ValidationErrorKind<'chain, B: CryptoOps> {
 
 pub struct ValidationError<'chain, B: CryptoOps> {
     kind: ValidationErrorKind<'chain, B>,
-    #[allow(dead_code)]
     cert: Option<VerificationCertificate<'chain, B>>,
 }
 
@@ -53,6 +52,15 @@ impl<'chain, B: CryptoOps> ValidationError<'chain, B> {
     pub(crate) fn new(kind: ValidationErrorKind<'chain, B>) -> Self {
         ValidationError { kind, cert: None }
     }
+
+    pub(crate) fn set_cert(mut self, cert: VerificationCertificate<'chain, B>) -> Self {
+        self.cert = Some(cert);
+        self
+    }
+
+    pub fn certificate(&self) -> Option<&VerificationCertificate<'chain, B>> {
+        self.cert.as_ref()
+    }
 }
 
 pub type ValidationResult<'chain, T, B> = Result<T, ValidationError<'chain, B>>;
@@ -447,7 +455,8 @@ impl<'a, 'chain, B: CryptoOps> ChainBuilder<'a, 'chain, B> {
         let leaf_extensions = leaf.certificate().extensions()?;
 
         self.policy
-            .permits_ee(leaf.certificate(), &leaf_extensions)?;
+            .permits_ee(leaf.certificate(), &leaf_extensions)
+            .map_err(|e| e.set_cert(leaf.clone()))?;
 
         let mut chain = self.build_chain_inner(
             leaf,
diff --git a/src/rust/cryptography-x509-verification/src/policy/mod.rs b/src/rust/cryptography-x509-verification/src/policy/mod.rs
index e13e1afcb..f124d17d3 100644
--- a/src/rust/cryptography-x509-verification/src/policy/mod.rs
+++ b/src/rust/cryptography-x509-verification/src/policy/mod.rs
@@ -509,7 +509,8 @@ impl<'a, B: CryptoOps> Policy<'a, B> {
         issuer_extensions: &Extensions<'_>,
     ) -> ValidationResult<'chain, (), B> {
         // The issuer needs to be a valid CA at the current depth.
-        self.permits_ca(issuer.certificate(), current_depth, issuer_extensions)?;
+        self.permits_ca(issuer.certificate(), current_depth, issuer_extensions)
+            .map_err(|e| e.set_cert(issuer.clone()))?;
 
         // CA/B 7.1.3.1 SubjectPublicKeyInfo
         // NOTE: We check the issuer's SPKI here, since the issuer is
diff --git a/src/rust/src/x509/verify.rs b/src/rust/src/x509/verify.rs
index 0d67c5077..20121f0a4 100644
--- a/src/rust/src/x509/verify.rs
+++ b/src/rust/src/x509/verify.rs
@@ -296,7 +296,7 @@ impl PyClientVerifier {
             policy,
             store.raw.borrow_dependent(),
         )
-        .map_err(|e| VerificationError::new_err(format!("validation failed: {e}")))?;
+        .or_else(|e| handle_validation_error(py, e))?;
 
         let py_chain = pyo3::types::PyList::empty_bound(py);
         for c in &chain {
@@ -380,7 +380,7 @@ impl PyServerVerifier {
             policy,
             store.raw.borrow_dependent(),
         )
-        .map_err(|e| VerificationError::new_err(format!("validation failed: {e}")))?;
+        .or_else(|e| handle_validation_error(py, e))?;
 
         let result = pyo3::types::PyList::empty_bound(py);
         for c in chain {
@@ -437,6 +437,19 @@ fn build_subject<'a>(
     }
 }
 
+fn handle_validation_error<T>(
+    py: pyo3::Python<'_>,
+    e: cryptography_x509_verification::ValidationError<'_, PyCryptoOps>,
+) -> CryptographyResult<T> {
+    let mut msg = format!("validation failed: {e}");
+    if let Some(cert) = e.certificate() {
+        let cert_repr = cert.extra().bind(py).repr()?;
+        msg = format!("{msg} (encountered processing {cert_repr})");
+    }
+
+    Err(CryptographyError::from(VerificationError::new_err(msg)))
+}
+
 type PyCryptoOpsStore<'a> = Store<'a, PyCryptoOps>;
 
 self_cell::self_cell!(
diff --git a/tests/x509/verification/test_verification.py b/tests/x509/verification/test_verification.py
index 1d2f9261c..879f41c3e 100644
--- a/tests/x509/verification/test_verification.py
+++ b/tests/x509/verification/test_verification.py
@@ -204,3 +204,21 @@ class TestServerVerifier:
                 match="cert is not valid at validation time",
             ):
                 verifier.verify(leaf, [])
+
+    def test_error_message(self):
+        # expires 2018-11-16 01:15:03 UTC
+        leaf = _load_cert(
+            os.path.join("x509", "cryptography.io.pem"),
+            x509.load_pem_x509_certificate,
+        )
+
+        store = Store([leaf])
+
+        builder = PolicyBuilder().store(store)
+        verifier = builder.build_server_verifier(DNSName("cryptography.io"))
+
+        with pytest.raises(
+            x509.verification.VerificationError,
+            match=r"<Certificate\(subject=.*?CN=www.cryptography.io.*?\)>",
+        ):
+            verifier.verify(leaf, [])
