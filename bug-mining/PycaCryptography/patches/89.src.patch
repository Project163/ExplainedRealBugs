diff --git a/src/cryptography/hazmat/backends/openssl/ec.py b/src/cryptography/hazmat/backends/openssl/ec.py
index 32ae1e07e..9bc6dd384 100644
--- a/src/cryptography/hazmat/backends/openssl/ec.py
+++ b/src/cryptography/hazmat/backends/openssl/ec.py
@@ -72,6 +72,17 @@ def _mark_asn1_named_ec_curve(backend: "Backend", ec_cdata):
     )
 
 
+def _check_key_infinity(backend: "Backend", ec_cdata) -> None:
+    point = backend._lib.EC_KEY_get0_public_key(ec_cdata)
+    backend.openssl_assert(point != backend._ffi.NULL)
+    group = backend._lib.EC_KEY_get0_group(ec_cdata)
+    backend.openssl_assert(group != backend._ffi.NULL)
+    if backend._lib.EC_POINT_is_at_infinity(group, point):
+        raise ValueError(
+            "Cannot load an EC public key where the point is at infinity"
+        )
+
+
 def _sn_to_elliptic_curve(backend: "Backend", sn: str) -> ec.EllipticCurve:
     try:
         return ec._CURVE_TYPES[sn]()
@@ -120,6 +131,7 @@ class _EllipticCurvePrivateKey(ec.EllipticCurvePrivateKey):
         sn = _ec_key_curve_sn(backend, ec_key_cdata)
         self._curve = _sn_to_elliptic_curve(backend, sn)
         _mark_asn1_named_ec_curve(backend, ec_key_cdata)
+        _check_key_infinity(backend, ec_key_cdata)
 
     @property
     def curve(self) -> ec.EllipticCurve:
@@ -211,6 +223,7 @@ class _EllipticCurvePublicKey(ec.EllipticCurvePublicKey):
         sn = _ec_key_curve_sn(backend, ec_key_cdata)
         self._curve = _sn_to_elliptic_curve(backend, sn)
         _mark_asn1_named_ec_curve(backend, ec_key_cdata)
+        _check_key_infinity(backend, ec_key_cdata)
 
     @property
     def curve(self) -> ec.EllipticCurve:
diff --git a/tests/hazmat/primitives/test_ec.py b/tests/hazmat/primitives/test_ec.py
index 52b699550..707d23360 100644
--- a/tests/hazmat/primitives/test_ec.py
+++ b/tests/hazmat/primitives/test_ec.py
@@ -6,6 +6,7 @@
 import binascii
 import itertools
 import os
+import textwrap
 import typing
 from binascii import hexlify
 
@@ -472,6 +473,39 @@ class TestECDSAVectors:
         with pytest.raises(ValueError):
             numbers.public_key(backend)
 
+    def test_load_invalid_ec_key_from_pem(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+
+        # BoringSSL rejects infinity points before it ever gets to us, so it
+        # uses a more generic error message.
+        match = (
+            "infinity" if not backend._lib.CRYPTOGRAPHY_IS_BORINGSSL else None
+        )
+        with pytest.raises(ValueError, match=match):
+            serialization.load_pem_public_key(
+                textwrap.dedent(
+                    """
+            -----BEGIN PUBLIC KEY-----
+            MBkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDAgAA
+            -----END PUBLIC KEY-----
+            """
+                ).encode(),
+                backend=backend,
+            )
+        with pytest.raises(ValueError, match=match):
+            serialization.load_pem_private_key(
+                textwrap.dedent(
+                    """
+            -----BEGIN PRIVATE KEY-----
+            MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCD/////AAAAAP//////
+            ////vOb6racXnoTzucrC/GMlUQ==
+            -----END PRIVATE KEY-----
+            """
+                ).encode(),
+                password=None,
+                backend=backend,
+            )
+
     def test_signatures(self, backend, subtests):
         vectors = itertools.chain(
             load_vectors_from_file(
