diff --git a/src/rust/src/asn1.rs b/src/rust/src/asn1.rs
index 51e44e3aa..65105b11c 100644
--- a/src/rust/src/asn1.rs
+++ b/src/rust/src/asn1.rs
@@ -50,6 +50,15 @@ impl From<PyAsn1Error> for pyo3::PyErr {
 // https://github.com/pyca/cryptography/pull/6173
 pub(crate) type PyAsn1Result<T = pyo3::PyObject> = Result<T, PyAsn1Error>;
 
+pub(crate) fn py_oid_to_oid(py_oid: &pyo3::PyAny) -> pyo3::PyResult<asn1::ObjectIdentifier<'_>> {
+    match asn1::ObjectIdentifier::from_string(py_oid.getattr("dotted_string")?.extract::<&str>()?) {
+        Some(oid) => Ok(oid),
+        None => Err(pyo3::exceptions::PyValueError::new_err(
+            "ObjectIdentifier was not valid (perhaps its arcs were too large)",
+        )),
+    }
+}
+
 #[derive(asn1::Asn1Read)]
 struct AlgorithmIdentifier<'a> {
     _oid: asn1::ObjectIdentifier<'a>,
diff --git a/src/rust/src/x509/common.rs b/src/rust/src/x509/common.rs
index 48ad7fea9..4772040e5 100644
--- a/src/rust/src/x509/common.rs
+++ b/src/rust/src/x509/common.rs
@@ -2,7 +2,7 @@
 // 2.0, and the BSD License. See the LICENSE file in the root of this repository
 // for complete details.
 
-use crate::asn1::PyAsn1Error;
+use crate::asn1::{py_oid_to_oid, PyAsn1Error};
 use crate::x509;
 use chrono::{Datelike, TimeZone, Timelike};
 use pyo3::types::IntoPyDict;
@@ -124,13 +124,7 @@ pub(crate) fn encode_name_entry<'p>(
     } else {
         value = py_name_entry.getattr("value")?.extract()?;
     }
-    let oid = asn1::ObjectIdentifier::from_string(
-        py_name_entry
-            .getattr("oid")?
-            .getattr("dotted_string")?
-            .extract::<&str>()?,
-    )
-    .unwrap();
+    let oid = py_oid_to_oid(py_name_entry.getattr("oid")?)?;
 
     Ok(AttributeTypeValue {
         type_id: oid,
@@ -244,12 +238,7 @@ pub(crate) fn encode_general_name<'a>(
         Ok(GeneralName::DirectoryName(name))
     } else if gn_type == gn_module.getattr("OtherName")? {
         Ok(GeneralName::OtherName(OtherName {
-            type_id: asn1::ObjectIdentifier::from_string(
-                gn.getattr("type_id")?
-                    .getattr("dotted_string")?
-                    .extract::<&str>()?,
-            )
-            .unwrap(),
+            type_id: py_oid_to_oid(gn.getattr("type_id")?)?,
             value: asn1::parse_single(gn_value.extract::<&[u8]>()?)?,
         }))
     } else if gn_type == gn_module.getattr("UniformResourceIdentifier")? {
@@ -261,10 +250,7 @@ pub(crate) fn encode_general_name<'a>(
             gn.call_method0("_packed")?.extract::<&[u8]>()?,
         ))
     } else if gn_type == gn_module.getattr("RegisteredID")? {
-        let oid = asn1::ObjectIdentifier::from_string(
-            gn_value.getattr("dotted_string")?.extract::<&str>()?,
-        )
-        .unwrap();
+        let oid = py_oid_to_oid(gn_value)?;
         Ok(GeneralName::RegisteredID(oid))
     } else {
         Err(PyAsn1Error::from(pyo3::exceptions::PyValueError::new_err(
@@ -292,13 +278,7 @@ pub(crate) fn encode_access_descriptions<'a>(
     let mut ads = vec![];
     for py_ad in py_ads.iter()? {
         let py_ad = py_ad?;
-        let access_method = asn1::ObjectIdentifier::from_string(
-            py_ad
-                .getattr("access_method")?
-                .getattr("dotted_string")?
-                .extract::<&str>()?,
-        )
-        .unwrap();
+        let access_method = py_oid_to_oid(py_ad.getattr("access_method")?)?;
         let access_location = encode_general_name(py, py_ad.getattr("access_location")?)?;
         ads.push(AccessDescription {
             access_method,
@@ -605,13 +585,7 @@ pub(crate) fn encode_extensions<
     let mut exts = vec![];
     for py_ext in py_exts.iter()? {
         let py_ext = py_ext?;
-        let oid = asn1::ObjectIdentifier::from_string(
-            py_ext
-                .getattr("oid")?
-                .getattr("dotted_string")?
-                .extract::<&str>()?,
-        )
-        .unwrap();
+        let oid = py_oid_to_oid(py_ext.getattr("oid")?)?;
 
         let ext_val = py_ext.getattr("value")?;
         if unrecognized_extension_type.is_instance(ext_val)? {
@@ -653,13 +627,7 @@ fn encode_extension_value<'p>(
     py: pyo3::Python<'p>,
     py_ext: &'p pyo3::PyAny,
 ) -> pyo3::PyResult<&'p pyo3::types::PyBytes> {
-    let oid = asn1::ObjectIdentifier::from_string(
-        py_ext
-            .getattr("oid")?
-            .getattr("dotted_string")?
-            .extract::<&str>()?,
-    )
-    .unwrap();
+    let oid = py_oid_to_oid(py_ext.getattr("oid")?)?;
 
     if let Some(data) = x509::extensions::encode_extension(&oid, py_ext)? {
         // TODO: extra copy
diff --git a/src/rust/src/x509/csr.rs b/src/rust/src/x509/csr.rs
index 268f4a3dc..45c107778 100644
--- a/src/rust/src/x509/csr.rs
+++ b/src/rust/src/x509/csr.rs
@@ -2,7 +2,7 @@
 // 2.0, and the BSD License. See the LICENSE file in the root of this repository
 // for complete details.
 
-use crate::asn1::{PyAsn1Error, PyAsn1Result};
+use crate::asn1::{py_oid_to_oid, PyAsn1Error, PyAsn1Result};
 use crate::x509;
 use crate::x509::{certificate, oid};
 use asn1::SimpleAsn1Readable;
@@ -224,8 +224,7 @@ impl CertificateSigningRequest {
                 cryptography_warning,
             ),
         )?;
-        let oid_str = oid.getattr("dotted_string")?.extract::<&str>()?;
-        let rust_oid = asn1::ObjectIdentifier::from_string(oid_str).unwrap();
+        let rust_oid = py_oid_to_oid(oid)?;
         for attribute in self
             .raw
             .borrow_value()
@@ -255,7 +254,7 @@ impl CertificateSigningRequest {
         Err(pyo3::PyErr::from_instance(
             py.import("cryptography.x509")?.call_method1(
                 "AttributeNotFound",
-                (format!("No {} attribute was found", oid_str), oid),
+                (format!("No {} attribute was found", oid), oid),
             )?,
         ))
     }
@@ -423,10 +422,7 @@ fn create_x509_csr(
 
     for py_attr in builder.getattr("_attributes")?.iter()? {
         let (py_oid, value): (&pyo3::PyAny, &[u8]) = py_attr?.extract()?;
-        let oid = asn1::ObjectIdentifier::from_string(
-            py_oid.getattr("dotted_string")?.extract::<&str>()?,
-        )
-        .unwrap();
+        let oid = py_oid_to_oid(py_oid)?;
         let tag = if std::str::from_utf8(value).is_ok() {
             asn1::Utf8String::TAG
         } else {
diff --git a/src/rust/src/x509/extensions.rs b/src/rust/src/x509/extensions.rs
index 606566dd9..72f930404 100644
--- a/src/rust/src/x509/extensions.rs
+++ b/src/rust/src/x509/extensions.rs
@@ -2,7 +2,7 @@
 // 2.0, and the BSD License. See the LICENSE file in the root of this repository
 // for complete details.
 
-use crate::asn1::{py_uint_to_big_endian_bytes, PyAsn1Error};
+use crate::asn1::{py_oid_to_oid, py_uint_to_big_endian_bytes, PyAsn1Error};
 use crate::x509;
 use crate::x509::{certificate, crl, oid, sct};
 
@@ -149,10 +149,7 @@ pub(crate) fn encode_extension(
     } else if oid == &*oid::EXTENDED_KEY_USAGE_OID {
         let mut oids = vec![];
         for el in ext.iter()? {
-            let oid = asn1::ObjectIdentifier::from_string(
-                el?.getattr("dotted_string")?.extract::<&str>()?,
-            )
-            .unwrap();
+            let oid = py_oid_to_oid(el?)?;
             oids.push(oid);
         }
         Ok(Some(asn1::write_single(&asn1::SequenceOfWriter::new(oids))))
@@ -229,13 +226,7 @@ pub(crate) fn encode_extension(
                 None
             };
             policy_informations.push(certificate::PolicyInformation {
-                policy_identifier: asn1::ObjectIdentifier::from_string(
-                    py_policy_info
-                        .getattr("policy_identifier")?
-                        .getattr("dotted_string")?
-                        .extract()?,
-                )
-                .unwrap(),
+                policy_identifier: py_oid_to_oid(py_policy_info.getattr("policy_identifier")?)?,
                 policy_qualifiers: qualifiers,
             });
         }
diff --git a/tests/x509/test_x509.py b/tests/x509/test_x509.py
index 1c32fe813..d811cd1d5 100644
--- a/tests/x509/test_x509.py
+++ b/tests/x509/test_x509.py
@@ -3588,6 +3588,31 @@ class TestCertificateBuilder(object):
 
         assert ext.value == unrecognized
 
+    def test_extension_with_too_large_oid(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        builder = (
+            x509.CertificateBuilder()
+            .subject_name(
+                x509.Name([x509.NameAttribute(x509.OID_COUNTRY_NAME, "US")])
+            )
+            .issuer_name(
+                x509.Name([x509.NameAttribute(x509.OID_COUNTRY_NAME, "US")])
+            )
+            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))
+            .not_valid_after(datetime.datetime(2030, 12, 31, 8, 30))
+            .public_key(private_key.public_key())
+            .serial_number(123)
+            .add_extension(
+                x509.UnrecognizedExtension(
+                    x509.ObjectIdentifier(f"2.25.{2**128 - 1}"), b""
+                ),
+                critical=False,
+            )
+        )
+        with pytest.raises(ValueError):
+            builder.sign(private_key, hashes.SHA256(), backend)
+
 
 class TestCertificateSigningRequestBuilder(object):
     def test_sign_invalid_hash_algorithm(self, backend):
