diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index d4f8b08d4..b07112a46 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -8,10 +8,13 @@ Changelog
 
 .. note:: This version is not yet released and is under active development.
 
-* Added support for serialization of PKCS#12 Java truststores in
-  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.serialize_java_truststore`
 * Support for Python 3.7 is deprecated and will be removed in the next
   ``cryptography`` release.
+* Added support for serialization of PKCS#12 Java truststores in
+  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.serialize_java_truststore`
+* Added :meth:`~cryptography.hazmat.primitives.kdf.argon2.Argon2id.derive_phc_encoded` and
+  :meth:`~cryptography.hazmat.primitives.kdf.argon2.Argon2id.verify_phc_encoded` methods
+  to support password hashing in the PHC string format
 * Added support for PKCS7 decryption and encryption using AES-256 as the
   content algorithm, in addition to AES-128.
 * **BACKWARDS INCOMPATIBLE:** Made SSH private key loading more consistent with
diff --git a/Cargo.lock b/Cargo.lock
index 0cc137075..ec9550088 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -107,6 +107,7 @@ name = "cryptography-rust"
 version = "0.1.0"
 dependencies = [
  "asn1",
+ "base64",
  "cfg-if",
  "cryptography-cffi",
  "cryptography-crypto",
diff --git a/docs/hazmat/primitives/key-derivation-functions.rst b/docs/hazmat/primitives/key-derivation-functions.rst
index f6dcdbdd2..ced988855 100644
--- a/docs/hazmat/primitives/key-derivation-functions.rst
+++ b/docs/hazmat/primitives/key-derivation-functions.rst
@@ -130,6 +130,67 @@ Argon2id
         checking whether the password a user provides matches the stored derived
         key.
 
+    .. method:: derive_phc_encoded(key_material)
+
+        .. versionadded:: 45.0.0
+
+        :param key_material: The input key material.
+        :type key_material: :term:`bytes-like`
+        :return str: A PHC-formatted string containing the parameters, salt, and derived key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          any method is
+                                                          called more than
+                                                          once.
+
+        This method generates and returns a new key from the supplied password,
+        formatting the result as a string according to the Password Hashing
+        Competition (PHC) format. The returned string includes the algorithm,
+        all parameters, the salt, and the derived key in a standardized format:
+        ``$argon2id$v=19$m=<memory_cost>,t=<iterations>,p=<lanes>$<salt>$<key>``
+
+        This format is suitable for password storage and is compatible with other
+        Argon2id implementations that support the PHC format.
+
+    .. classmethod:: verify_phc_encoded(key_material, phc_encoded, secret=None)
+
+        .. versionadded:: 45.0.0
+
+        :param bytes key_material: The input key material. This is the same as
+                                   ``key_material`` in :meth:`derive_phc_encoded`.
+        :param str phc_encoded: A PHC-formatted string as returned by
+                                :meth:`derive_phc_encoded`.
+        :param bytes secret: Optional secret data; used for keyed hashing.
+        :raises cryptography.exceptions.InvalidKey: This is raised when the
+                                                    derived key does not match
+                                                    the key in the encoded string
+                                                    or when the format of the
+                                                    encoded string is invalid.
+
+        This class method verifies whether the supplied ``key_material`` matches
+        the key contained in the PHC-formatted string. It extracts the parameters
+        from the string, recomputes the key with those parameters, and compares
+        the result to the key in the string.
+
+        This is useful for validating a password against a stored PHC-formatted
+        hash string.
+
+        .. doctest::
+
+            >>> import os
+            >>> from cryptography.hazmat.primitives.kdf.argon2 import Argon2id
+            >>> salt = os.urandom(16)
+            >>> # Create an Argon2id instance and derive a PHC-formatted string
+            >>> kdf = Argon2id(
+            ...     salt=salt,
+            ...     length=32,
+            ...     iterations=1,
+            ...     lanes=4,
+            ...     memory_cost=64 * 1024,
+            ... )
+            >>> encoded = kdf.derive_phc_encoded(b"my great password")
+            >>> # later, verify the password
+            >>> Argon2id.verify_phc_encoded(b"my great password", encoded)
+
 
 PBKDF2
 ------
diff --git a/docs/spelling_wordlist.txt b/docs/spelling_wordlist.txt
index 80160dc57..831369fe9 100644
--- a/docs/spelling_wordlist.txt
+++ b/docs/spelling_wordlist.txt
@@ -106,6 +106,7 @@ RHEL
 parsers
 Parsers
 PEM
+PHC
 pickleable
 plaintext
 Poly
diff --git a/src/cryptography/hazmat/bindings/_rust/openssl/kdf.pyi b/src/cryptography/hazmat/bindings/_rust/openssl/kdf.pyi
index cdcd812db..9979e42db 100644
--- a/src/cryptography/hazmat/bindings/_rust/openssl/kdf.pyi
+++ b/src/cryptography/hazmat/bindings/_rust/openssl/kdf.pyi
@@ -42,3 +42,8 @@ class Argon2id:
     ) -> None: ...
     def derive(self, key_material: bytes) -> bytes: ...
     def verify(self, key_material: bytes, expected_key: bytes) -> None: ...
+    def derive_phc_encoded(self, key_material: bytes) -> str: ...
+    @classmethod
+    def verify_phc_encoded(
+        cls, key_material: bytes, phc_encoded: str, secret: bytes | None = None
+    ) -> None: ...
diff --git a/src/rust/Cargo.toml b/src/rust/Cargo.toml
index 7ff0c9936..28a7cd2b9 100644
--- a/src/rust/Cargo.toml
+++ b/src/rust/Cargo.toml
@@ -7,6 +7,7 @@ publish.workspace = true
 rust-version.workspace = true
 
 [dependencies]
+base64 = "0.22"
 once_cell = "1"
 cfg-if = "1"
 pyo3.workspace = true
diff --git a/src/rust/src/backend/kdf.rs b/src/rust/src/backend/kdf.rs
index 2144caf1e..413472954 100644
--- a/src/rust/src/backend/kdf.rs
+++ b/src/rust/src/backend/kdf.rs
@@ -2,6 +2,10 @@
 // 2.0, and the BSD License. See the LICENSE file in the root of this repository
 // for complete details.
 
+#[cfg(CRYPTOGRAPHY_OPENSSL_320_OR_GREATER)]
+use base64::engine::general_purpose::STANDARD_NO_PAD;
+#[cfg(CRYPTOGRAPHY_OPENSSL_320_OR_GREATER)]
+use base64::engine::Engine;
 #[cfg(not(CRYPTOGRAPHY_IS_LIBRESSL))]
 use pyo3::types::PyBytesMethods;
 
@@ -320,6 +324,127 @@ impl Argon2id {
 
         Ok(())
     }
+
+    #[cfg(CRYPTOGRAPHY_OPENSSL_320_OR_GREATER)]
+    fn derive_phc_encoded<'p>(
+        &mut self,
+        py: pyo3::Python<'p>,
+        key_material: CffiBuf<'_>,
+    ) -> CryptographyResult<pyo3::Bound<'p, pyo3::types::PyString>> {
+        let derived_key = self.derive(py, key_material)?;
+        let salt_bytes = self.salt.as_bytes(py);
+
+        let salt_b64 = STANDARD_NO_PAD.encode(salt_bytes);
+        let hash_b64 = STANDARD_NO_PAD.encode(derived_key.as_bytes());
+
+        // Format the PHC string
+        let phc_string = format!(
+            "$argon2id$v=19$m={},t={},p={}${}${}",
+            self.memory_cost, self.iterations, self.lanes, salt_b64, hash_b64
+        );
+
+        Ok(pyo3::types::PyString::new(py, &phc_string))
+    }
+
+    #[cfg(CRYPTOGRAPHY_OPENSSL_320_OR_GREATER)]
+    #[staticmethod]
+    #[pyo3(signature = (key_material, phc_encoded, secret=None))]
+    fn verify_phc_encoded(
+        py: pyo3::Python<'_>,
+        key_material: CffiBuf<'_>,
+        phc_encoded: &str,
+        secret: Option<pyo3::Py<pyo3::types::PyBytes>>,
+    ) -> CryptographyResult<()> {
+        let parts: Vec<_> = phc_encoded.split('$').collect();
+
+        if parts.len() != 6 || !parts[0].is_empty() || parts[1] != "argon2id" {
+            return Err(CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Invalid PHC string format.",
+            )));
+        }
+
+        if parts[2] != "v=19" {
+            return Err(CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Invalid version in PHC string.",
+            )));
+        }
+
+        // Parse parameters
+        let param_parts: Vec<&str> = parts[3].split(',').collect();
+        if param_parts.len() != 3 {
+            return Err(CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Invalid parameters in PHC string.",
+            )));
+        }
+
+        // Check parameters are in correct order: m, t, p
+        if !param_parts[0].starts_with("m=")
+            || !param_parts[1].starts_with("t=")
+            || !param_parts[2].starts_with("p=")
+        {
+            return Err(CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Parameters must be in order: m, t, p.",
+            )));
+        }
+
+        // Parse memory cost (m)
+        let memory_cost = param_parts[0][2..].parse::<u32>().map_err(|_| {
+            CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Invalid memory cost in PHC string.",
+            ))
+        })?;
+
+        // Parse iterations (t)
+        let iterations = param_parts[1][2..].parse::<u32>().map_err(|_| {
+            CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Invalid iterations in PHC string.",
+            ))
+        })?;
+
+        // Parse lanes/parallelism (p)
+        let lanes = param_parts[2][2..].parse::<u32>().map_err(|_| {
+            CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Invalid parallelism in PHC string.",
+            ))
+        })?;
+
+        let salt_bytes = STANDARD_NO_PAD.decode(parts[4]).map_err(|_| {
+            CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Invalid base64 salt in PHC string.",
+            ))
+        })?;
+
+        let hash_bytes = STANDARD_NO_PAD.decode(parts[5]).map_err(|_| {
+            CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Invalid base64 hash in PHC string.",
+            ))
+        })?;
+
+        let salt = pyo3::types::PyBytes::new(py, &salt_bytes);
+        let mut argon2 = Argon2id::new(
+            py,
+            salt.into(),
+            hash_bytes.len(),
+            iterations,
+            lanes,
+            memory_cost,
+            None,
+            secret,
+        )?;
+
+        let derived_key = argon2.derive(py, key_material)?;
+        let derived_bytes = derived_key.as_bytes();
+
+        if derived_bytes.len() != hash_bytes.len()
+            || !openssl::memcmp::eq(derived_bytes, &hash_bytes)
+        {
+            return Err(CryptographyError::from(exceptions::InvalidKey::new_err(
+                "Keys do not match.",
+            )));
+        }
+
+        Ok(())
+    }
 }
 
 #[pyo3::pymodule]
diff --git a/tests/hazmat/primitives/test_argon2.py b/tests/hazmat/primitives/test_argon2.py
index 7ea79d8b9..8db9c8cf0 100644
--- a/tests/hazmat/primitives/test_argon2.py
+++ b/tests/hazmat/primitives/test_argon2.py
@@ -3,6 +3,7 @@
 # for complete details.
 
 
+import base64
 import binascii
 import os
 
@@ -158,3 +159,112 @@ class TestArgon2id:
         Argon2id(
             salt=b"salt" * 2, length=32, iterations=1, lanes=1, memory_cost=32
         ).verify(b"password", digest)
+
+    def test_derive_phc_encoded(self, backend):
+        # Test that we can generate a PHC formatted string
+        argon2id = Argon2id(
+            salt=b"0" * 8,
+            length=32,
+            iterations=2,
+            lanes=2,
+            memory_cost=64,
+        )
+        encoded = argon2id.derive_phc_encoded(b"password")
+
+        # Verify the general format is correct
+        assert encoded == (
+            "$argon2id$v=19$m=64,t=2,p=2$"
+            "MDAwMDAwMDA$"
+            "jFn1qYAgmfVKFWVeUGQcVK4d8RSiQJFTS7R7VII+fRk"
+        )
+
+    def test_verify_phc_encoded(self):
+        # First generate a PHC string
+        argon2id = Argon2id(
+            salt=b"0" * 8,
+            length=32,
+            iterations=1,
+            lanes=1,
+            memory_cost=32,
+        )
+        encoded = argon2id.derive_phc_encoded(b"password")
+
+        Argon2id.verify_phc_encoded(b"password", encoded)
+        Argon2id(
+            salt=b"0" * 8,
+            length=32,
+            iterations=1,
+            lanes=1,
+            memory_cost=32,
+        ).verify(b"password", base64.b64decode(encoded.split("$")[-1] + "="))
+
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(b"wrong_password", encoded)
+
+    def test_verify_phc_vector(self):
+        # From https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md#example
+        Argon2id.verify_phc_encoded(
+            b"hunter2",
+            "$argon2id$v=19$m=65536,t=2,p=1$gZiV/M1gPc22ElAH/Jh1Hw$CWOrkoo7oJBQ/iyh7uJ0LO2aLEfrHwTWllSAxT0zRno",
+            secret=b"pepper",
+        )
+
+    def test_verify_phc_encoded_invalid_format(self):
+        # Totally invalid string
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(b"password", "not-a-valid-format")
+
+        # Invalid algorithm
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(
+                b"password", "$argon2i$v=19$m=32,t=1,p=1$c2FsdHNhbHQ$hash"
+            )
+
+        # Invalid version
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(
+                b"password", "$argon2id$v=18$m=32,t=1,p=1$c2FsdHNhbHQ$hash"
+            )
+
+        # Missing parameters
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(
+                b"password", "$argon2id$v=19$m=32,t=1$c2FsdHNhbHQ$hash"
+            )
+
+        # Parameters in wrong order
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(
+                b"password", "$argon2id$v=19$t=1,m=32,p=1$c2FsdHNhbHQ$hash"
+            )
+
+        # Invalid memory cost
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(
+                b"password", "$argon2id$v=19$m=abc,t=1,p=1$!invalid!$hash"
+            )
+
+        # Invalid iterations
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(
+                b"password", "$argon2id$v=19$m=32,t=abc,p=1$!invalid!$hash"
+            )
+
+        # Invalid lanes
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(
+                b"password", "$argon2id$v=19$m=32,t=1,p=abc$!invalid!$hash"
+            )
+
+        # Invalid base64 in salt
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(
+                b"password", "$argon2id$v=19$m=32,t=1,p=1$!invalid!$hash"
+            )
+
+        # Invalid base64 in hash
+        with pytest.raises(InvalidKey):
+            Argon2id.verify_phc_encoded(
+                b"password",
+                "$argon2id$v=19$m=32,t=1,p=1$c2FsdHNhbHQ$!invalid!",
+            )
