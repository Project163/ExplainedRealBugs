diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index 02a640505..8c68083b1 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -24,6 +24,10 @@ Changelog
 * Added :class:`~cryptography.hazmat.primitives.hashes.XOFHash` to support
   repeated :meth:`~cryptography.hazmat.primitives.hashes.XOFHash.squeeze`
   operations on extendable output functions.
+* Added
+  :meth:`~cryptography.x509.ocsp.OCSPResponseBuilder.add_response_by_hash`
+  method to allow creating OCSP responses using certificate hash values rather
+  than full certificates.
 * Extended the :mod:`X.509 path validation <cryptography.x509.verification>` API to
   support user-configured extension policies via the
   :meth:`PolicyBuilder.extension_policies <cryptography.x509.verification.PolicyBuilder.extension_policies>` method.
diff --git a/docs/x509/ocsp.rst b/docs/x509/ocsp.rst
index 22189141e..58878cc7a 100644
--- a/docs/x509/ocsp.rst
+++ b/docs/x509/ocsp.rst
@@ -157,7 +157,7 @@ Creating Requests
         .. versionadded:: 39.0.0
 
         Adds a request using the issuer's name hash, key hash, the certificate
-        serial number and hash algorithm. You can call this method or
+        serial number, and hash algorithm. You can call this method or
         ``add_certificate`` only once.
 
         :param issuer_name_hash: The hash of the issuer's DER encoded name using the
@@ -249,7 +249,8 @@ Creating Responses
     .. method:: add_response(cert, issuer, algorithm, cert_status, this_update, next_update, revocation_time, revocation_reason)
 
         This method adds status information about the certificate that was
-        requested to the response.
+        requested to the response. You can call this method or ``add_response_by_hash``
+        only once.
 
         :param cert: The :class:`~cryptography.x509.Certificate` whose validity
             is being checked.
@@ -288,6 +289,58 @@ Creating Responses
             :class:`~cryptography.x509.ReasonFlags` enumeration or ``None`` if
             the ``cert`` is not revoked.
 
+    .. method:: add_response_by_hash(issuer_name_hash, issuer_key_hash, serial_number, algorithm, cert_status, this_update, next_update, revocation_time, revocation_reason)
+
+        .. versionadded:: 45.0.0
+
+        This method adds status information about the certificate that was
+        requested to the response using the hash values directly, rather than requiring
+        the full certificates. You can call this method or ``add_response``
+        only once.
+
+        :param issuer_name_hash: The hash of the issuer's DER encoded name using the
+            same hash algorithm as the one specified in the ``algorithm`` parameter.
+        :type issuer_name_hash: bytes
+
+        :param issuer_key_hash: The hash of the issuer's public key bit string
+            DER encoding using the same hash algorithm as the one specified in
+            the ``algorithm`` parameter.
+        :type issuer_key_hash: bytes
+
+        :param serial_number: The serial number of the certificate being checked.
+        :type serial_number: int
+
+        :param algorithm: A
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            instance. For OCSP only
+            :class:`~cryptography.hazmat.primitives.hashes.SHA1`,
+            :class:`~cryptography.hazmat.primitives.hashes.SHA224`,
+            :class:`~cryptography.hazmat.primitives.hashes.SHA256`,
+            :class:`~cryptography.hazmat.primitives.hashes.SHA384`, and
+            :class:`~cryptography.hazmat.primitives.hashes.SHA512` are allowed.
+
+        :param cert_status: An item from the
+            :class:`~cryptography.x509.ocsp.OCSPCertStatus` enumeration.
+
+        :param this_update: A :class:`datetime.datetime` object representing
+            the most recent time at which the status being indicated is known
+            by the responder to be correct. If it does not have a timezone, it
+            is assumed to be in UTC.
+
+        :param next_update: A :class:`datetime.datetime` object or ``None``.
+            The time at or before which newer information will be available
+            about the status of the certificate. If it does not have a
+            timezone, it is assumed to be in UTC.
+
+        :param revocation_time: A :class:`datetime.datetime` object or ``None``
+            if the ``cert`` is not revoked. The time at which the certificate
+            was revoked. If it does not have a timezone, it is assumed to be in
+            UTC.
+
+        :param revocation_reason: An item from the
+            :class:`~cryptography.x509.ReasonFlags` enumeration or ``None`` if
+            the ``cert`` is not revoked.
+
     .. method:: certificates(certs)
 
         Add additional certificates that should be used to verify the
diff --git a/src/cryptography/x509/ocsp.py b/src/cryptography/x509/ocsp.py
index 0e8d1cc8f..f61ed80b8 100644
--- a/src/cryptography/x509/ocsp.py
+++ b/src/cryptography/x509/ocsp.py
@@ -55,8 +55,8 @@ class OCSPCertStatus(utils.Enum):
 class _SingleResponse:
     def __init__(
         self,
-        cert: x509.Certificate,
-        issuer: x509.Certificate,
+        resp: tuple[x509.Certificate, x509.Certificate] | None,
+        resp_hash: tuple[bytes, bytes, int] | None,
         algorithm: hashes.HashAlgorithm,
         cert_status: OCSPCertStatus,
         this_update: datetime.datetime,
@@ -64,11 +64,6 @@ class _SingleResponse:
         revocation_time: datetime.datetime | None,
         revocation_reason: x509.ReasonFlags | None,
     ):
-        if not isinstance(cert, x509.Certificate) or not isinstance(
-            issuer, x509.Certificate
-        ):
-            raise TypeError("cert and issuer must be a Certificate")
-
         _verify_algorithm(algorithm)
         if not isinstance(this_update, datetime.datetime):
             raise TypeError("this_update must be a datetime object")
@@ -77,8 +72,8 @@ class _SingleResponse:
         ):
             raise TypeError("next_update must be a datetime object or None")
 
-        self._cert = cert
-        self._issuer = issuer
+        self._resp = resp
+        self._resp_hash = resp_hash
         self._algorithm = algorithm
         self._this_update = this_update
         self._next_update = next_update
@@ -232,9 +227,60 @@ class OCSPResponseBuilder:
         if self._response is not None:
             raise ValueError("Only one response per OCSPResponse.")
 
+        if not isinstance(cert, x509.Certificate) or not isinstance(
+            issuer, x509.Certificate
+        ):
+            raise TypeError("cert and issuer must be a Certificate")
+
+        singleresp = _SingleResponse(
+            (cert, issuer),
+            None,
+            algorithm,
+            cert_status,
+            this_update,
+            next_update,
+            revocation_time,
+            revocation_reason,
+        )
+        return OCSPResponseBuilder(
+            singleresp,
+            self._responder_id,
+            self._certs,
+            self._extensions,
+        )
+
+    def add_response_by_hash(
+        self,
+        issuer_name_hash: bytes,
+        issuer_key_hash: bytes,
+        serial_number: int,
+        algorithm: hashes.HashAlgorithm,
+        cert_status: OCSPCertStatus,
+        this_update: datetime.datetime,
+        next_update: datetime.datetime | None,
+        revocation_time: datetime.datetime | None,
+        revocation_reason: x509.ReasonFlags | None,
+    ) -> OCSPResponseBuilder:
+        if self._response is not None:
+            raise ValueError("Only one response per OCSPResponse.")
+
+        if not isinstance(serial_number, int):
+            raise TypeError("serial_number must be an integer")
+
+        utils._check_bytes("issuer_name_hash", issuer_name_hash)
+        utils._check_bytes("issuer_key_hash", issuer_key_hash)
+        _verify_algorithm(algorithm)
+        if algorithm.digest_size != len(
+            issuer_name_hash
+        ) or algorithm.digest_size != len(issuer_key_hash):
+            raise ValueError(
+                "issuer_name_hash and issuer_key_hash must be the same length "
+                "as the digest size of the algorithm"
+            )
+
         singleresp = _SingleResponse(
-            cert,
-            issuer,
+            None,
+            (issuer_name_hash, issuer_key_hash, serial_number),
             algorithm,
             cert_status,
             this_update,
diff --git a/src/rust/src/x509/ocsp_resp.rs b/src/rust/src/x509/ocsp_resp.rs
index 706b68c6a..9d21333c9 100644
--- a/src/rust/src/x509/ocsp_resp.rs
+++ b/src/rust/src/x509/ocsp_resp.rs
@@ -10,7 +10,7 @@ use cryptography_x509::ocsp_resp::{
 use cryptography_x509::{common, oid};
 use pyo3::types::{PyAnyMethods, PyBytesMethods, PyListMethods};
 
-use crate::asn1::{big_byte_slice_to_py_int, oid_to_py_oid};
+use crate::asn1::{big_byte_slice_to_py_int, oid_to_py_oid, py_uint_to_big_endian_bytes};
 use crate::error::{CryptographyError, CryptographyResult};
 use crate::utils::cstr_from_literal;
 use crate::x509::{certificate, crl, extensions, ocsp, py_to_datetime, sct};
@@ -678,8 +678,6 @@ pub(crate) fn create_ocsp_response(
         .getattr(pyo3::intern!(py, "value"))?
         .extract::<u32>()?;
 
-    let py_cert: pyo3::PyRef<'_, x509::certificate::Certificate>;
-    let py_issuer: pyo3::PyRef<'_, x509::certificate::Certificate>;
     let borrowed_cert;
     let py_certs: Option<Vec<pyo3::PyRef<'_, x509::certificate::Certificate>>>;
     if response_status != SUCCESSFUL_RESPONSE {
@@ -692,12 +690,6 @@ pub(crate) fn create_ocsp_response(
     }
 
     let py_single_resp = builder.getattr(pyo3::intern!(py, "_response"))?;
-    py_cert = py_single_resp
-        .getattr(pyo3::intern!(py, "_cert"))?
-        .extract()?;
-    py_issuer = py_single_resp
-        .getattr(pyo3::intern!(py, "_issuer"))?
-        .extract()?;
     let py_cert_hash_algorithm = py_single_resp.getattr(pyo3::intern!(py, "_algorithm"))?;
     let (responder_cert, responder_encoding): (
         pyo3::Bound<'_, x509::certificate::Certificate>,
@@ -751,8 +743,36 @@ pub(crate) fn create_ocsp_response(
     let ka_vec = cryptography_keepalive::KeepAlive::new();
     let ka_bytes = cryptography_keepalive::KeepAlive::new();
 
+    // Declare outside the if-block so the lifetimes are right.
+    let (py_cert, py_issuer, issuer_name_hash, issuer_key_hash, serial_number_bytes): (
+        pyo3::PyRef<'_, x509::certificate::Certificate>,
+        pyo3::PyRef<'_, x509::certificate::Certificate>,
+        pyo3::pybacked::PyBackedBytes,
+        pyo3::pybacked::PyBackedBytes,
+        pyo3::pybacked::PyBackedBytes,
+    );
+    let single_resp_resp = py_single_resp.getattr(pyo3::intern!(py, "_resp"))?;
+    let cert_id = if !single_resp_resp.is_none() {
+        (py_cert, py_issuer) = single_resp_resp.extract()?;
+        ocsp::certid_new(py, &ka_bytes, &py_cert, &py_issuer, &py_cert_hash_algorithm)?
+    } else {
+        let py_serial: pyo3::Bound<'_, pyo3::types::PyInt>;
+        (issuer_name_hash, issuer_key_hash, py_serial) = py_single_resp
+            .getattr(pyo3::intern!(py, "_resp_hash"))?
+            .extract()?;
+        serial_number_bytes = py_uint_to_big_endian_bytes(py, py_serial)?;
+        let serial_number = asn1::BigInt::new(&serial_number_bytes).unwrap();
+        ocsp::certid_new_from_hash(
+            py,
+            &issuer_name_hash,
+            &issuer_key_hash,
+            serial_number,
+            py_cert_hash_algorithm,
+        )?
+    };
+
     let responses = vec![SingleResponse {
-        cert_id: ocsp::certid_new(py, &ka_bytes, &py_cert, &py_issuer, &py_cert_hash_algorithm)?,
+        cert_id,
         cert_status,
         next_update,
         this_update,
diff --git a/tests/x509/test_ocsp.py b/tests/x509/test_ocsp.py
index a5f51e7bc..dab29943f 100644
--- a/tests/x509/test_ocsp.py
+++ b/tests/x509/test_ocsp.py
@@ -997,6 +997,130 @@ class TestOCSPResponseBuilder:
         with pytest.raises(TypeError):
             builder.sign(object(), hashes.SHA256())  # type:ignore[arg-type]
 
+    def test_add_response_by_hash(self):
+        builder = ocsp.OCSPResponseBuilder()
+        current_time = (
+            datetime.datetime.now(datetime.timezone.utc)
+            .replace(tzinfo=None)
+            .replace(microsecond=0)
+        )
+        this_update = current_time - datetime.timedelta(days=1)
+        next_update = this_update + datetime.timedelta(days=7)
+
+        # These values would typically be derived from real certificates
+        issuer_name_hash = b"a" * 32
+        issuer_key_hash = b"b" * 32
+        serial_number = 12345
+
+        builder = builder.add_response_by_hash(
+            issuer_name_hash,
+            issuer_key_hash,
+            serial_number,
+            hashes.SHA256(),
+            ocsp.OCSPCertStatus.GOOD,
+            this_update,
+            next_update,
+            None,
+            None,
+        )
+
+        root_cert, private_key = _generate_root()
+        builder = builder.responder_id(
+            ocsp.OCSPResponderEncoding.NAME, root_cert
+        )
+        resp = builder.sign(private_key, hashes.SHA256())
+
+        # These assertions validate the expected values are in the response
+        assert resp.certificate_status == ocsp.OCSPCertStatus.GOOD
+        assert resp.issuer_key_hash == issuer_key_hash
+        assert resp.issuer_name_hash == issuer_name_hash
+        assert resp.serial_number == serial_number
+        assert isinstance(resp.hash_algorithm, hashes.SHA256)
+
+    def test_add_response_then_add_response_by_hash(self):
+        cert, issuer = _cert_and_issuer()
+        builder = ocsp.OCSPResponseBuilder()
+        time = datetime.datetime.now(datetime.timezone.utc).replace(
+            tzinfo=None
+        )
+        builder = builder.add_response(
+            cert,
+            issuer,
+            hashes.SHA1(),
+            ocsp.OCSPCertStatus.GOOD,
+            time,
+            time,
+            None,
+            None,
+        )
+        # Fails calling a second time with add_response_by_hash
+        with pytest.raises(ValueError):
+            builder.add_response_by_hash(
+                b"0" * 20,
+                b"0" * 20,
+                1,
+                hashes.SHA1(),
+                ocsp.OCSPCertStatus.GOOD,
+                time,
+                time,
+                None,
+                None,
+            )
+
+    def test_add_response_by_hash_bad_hash(self):
+        builder = ocsp.OCSPResponseBuilder()
+        time = datetime.datetime.now(datetime.timezone.utc).replace(
+            tzinfo=None
+        )
+        with pytest.raises(ValueError):
+            builder.add_response_by_hash(
+                b"0" * 20,
+                b"0" * 20,
+                1,
+                "notahash",  # type: ignore[arg-type]
+                ocsp.OCSPCertStatus.GOOD,
+                time,
+                time,
+                None,
+                None,
+            )
+        with pytest.raises(ValueError):
+            builder.add_response_by_hash(
+                b"0" * 19,
+                b"0" * 20,
+                1,
+                hashes.SHA1(),
+                ocsp.OCSPCertStatus.GOOD,
+                time,
+                time,
+                None,
+                None,
+            )
+        with pytest.raises(ValueError):
+            builder.add_response_by_hash(
+                b"0" * 20,
+                b"0" * 21,
+                1,
+                hashes.SHA1(),
+                ocsp.OCSPCertStatus.GOOD,
+                time,
+                time,
+                None,
+                None,
+            )
+        with pytest.raises(TypeError):
+            builder.add_response_by_hash(
+                b"0" * 20,
+                b"0" * 20,
+                "notanint",  # type: ignore[arg-type]
+                hashes.SHA1(),
+                ocsp.OCSPCertStatus.GOOD,
+                time,
+                time,
+                None,
+                None,
+            )
+
     @pytest.mark.supported(
         only_if=lambda backend: backend.hash_supported(
             hashes.BLAKE2b(digest_size=64)
