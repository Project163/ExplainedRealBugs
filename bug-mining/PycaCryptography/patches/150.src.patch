diff --git a/src/rust/src/backend/aead.rs b/src/rust/src/backend/aead.rs
index 46a13b9c0..72b986e4b 100644
--- a/src/rust/src/backend/aead.rs
+++ b/src/rust/src/backend/aead.rs
@@ -703,6 +703,7 @@ impl AesGcm {
 )]
 struct AesCcm {
     ctx: LazyEvpCipherAead,
+    tag_length: usize,
 }
 
 #[pyo3::pymethods]
@@ -748,6 +749,7 @@ impl AesCcm {
 
                 Ok(AesCcm {
                     ctx: LazyEvpCipherAead::new(cipher, key, tag_length, false, true),
+                    tag_length
                 })
             }
         }
@@ -824,7 +826,8 @@ impl AesCcm {
         let max_length = 1usize.checked_shl(8 * l_val as u32);
         // If `max_length` overflowed, then it's not possible for data to be
         // longer than it.
-        if max_length.map(|v| v < data_bytes.len()).unwrap_or(false) {
+        let pt_length = data_bytes.len().saturating_sub(self.tag_length);
+        if max_length.map(|v| v < pt_length).unwrap_or(false) {
             return Err(CryptographyError::from(
                 pyo3::exceptions::PyValueError::new_err("Data too long for nonce"),
             ));
diff --git a/tests/hazmat/primitives/test_aead.py b/tests/hazmat/primitives/test_aead.py
index 80850b689..b94ee52ad 100644
--- a/tests/hazmat/primitives/test_aead.py
+++ b/tests/hazmat/primitives/test_aead.py
@@ -363,6 +363,16 @@ class TestAESCCM:
         computed_pt2 = aesccm2.decrypt(bytearray(nonce), ct2, ad)
         assert computed_pt2 == pt
 
+    def test_max_data_length(self):
+        plaintext = b"A" * 65535
+        aad = b"authenticated but unencrypted data"
+        aesccm = AESCCM(AESCCM.generate_key(128))
+        nonce = os.urandom(13)
+
+        ciphertext = aesccm.encrypt(nonce, plaintext, aad)
+        decrypted_data = aesccm.decrypt(nonce, ciphertext, aad)
+        assert decrypted_data == plaintext
+
 
 def _load_gcm_vectors():
     vectors = _load_all_params(
