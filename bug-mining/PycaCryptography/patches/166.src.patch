diff --git a/src/rust/cryptography-x509/src/certificate.rs b/src/rust/cryptography-x509/src/certificate.rs
index 2c21257ae..73565d3cc 100644
--- a/src/rust/cryptography-x509/src/certificate.rs
+++ b/src/rust/cryptography-x509/src/certificate.rs
@@ -31,12 +31,17 @@ impl<'a> Certificate<'a> {
     }
 }
 
+// This should really be a wrapper around `BigUint` that rejects 0s, however
+// for the time being we support invalid serial numbers (mostly because the MS
+// trust store has a certificate with a negative serial number).
+pub type SerialNumber<'a> = asn1::BigInt<'a>;
+
 #[derive(asn1::Asn1Read, asn1::Asn1Write, Hash, PartialEq, Eq, Clone)]
 pub struct TbsCertificate<'a> {
     #[explicit(0)]
     #[default(0)]
     pub version: u8,
-    pub serial: asn1::BigInt<'a>,
+    pub serial: SerialNumber<'a>,
     pub signature_alg: common::AlgorithmIdentifier<'a>,
 
     pub issuer: name::Name<'a>,
diff --git a/src/rust/cryptography-x509/src/crl.rs b/src/rust/cryptography-x509/src/crl.rs
index ced8fb8e2..77b303a0c 100644
--- a/src/rust/cryptography-x509/src/crl.rs
+++ b/src/rust/cryptography-x509/src/crl.rs
@@ -2,6 +2,7 @@
 // 2.0, and the BSD License. See the LICENSE file in the root of this repository
 // for complete details.
 
+use crate::certificate::SerialNumber;
 use crate::common::Asn1Operation;
 use crate::{common, extensions, name};
 
@@ -35,7 +36,7 @@ pub struct TBSCertList<'a> {
 
 #[derive(asn1::Asn1Read, asn1::Asn1Write, PartialEq, Eq, Hash, Clone)]
 pub struct RevokedCertificate<'a> {
-    pub user_certificate: asn1::BigUint<'a>,
+    pub user_certificate: SerialNumber<'a>,
     pub revocation_date: common::Time,
     pub raw_crl_entry_extensions: Option<extensions::RawExtensions<'a>>,
 }
diff --git a/src/rust/cryptography-x509/src/extensions.rs b/src/rust/cryptography-x509/src/extensions.rs
index ea0ae9428..8a9df2a16 100644
--- a/src/rust/cryptography-x509/src/extensions.rs
+++ b/src/rust/cryptography-x509/src/extensions.rs
@@ -4,6 +4,7 @@
 
 use std::collections::HashSet;
 
+use crate::certificate::SerialNumber;
 use crate::common::Asn1Operation;
 use crate::{common, crl, name};
 
@@ -198,7 +199,7 @@ pub struct AuthorityKeyIdentifier<'a, Op: Asn1Operation> {
     #[implicit(1)]
     pub authority_cert_issuer: Option<name::SequenceOfGeneralName<'a, Op>>,
     #[implicit(2)]
-    pub authority_cert_serial_number: Option<asn1::BigUint<'a>>,
+    pub authority_cert_serial_number: Option<SerialNumber<'a>>,
 }
 
 #[derive(asn1::Asn1Read, asn1::Asn1Write)]
diff --git a/src/rust/src/x509/certificate.rs b/src/rust/src/x509/certificate.rs
index 7ba74d745..14d37657e 100644
--- a/src/rust/src/x509/certificate.rs
+++ b/src/rust/src/x509/certificate.rs
@@ -115,7 +115,7 @@ impl Certificate {
         py: pyo3::Python<'p>,
     ) -> Result<pyo3::Bound<'p, pyo3::PyAny>, CryptographyError> {
         let bytes = self.raw.borrow_dependent().tbs_cert.serial.as_bytes();
-        warn_if_negative_serial(py, bytes)?;
+        warn_if_not_positive(py, bytes)?;
         Ok(big_byte_slice_to_py_int(py, bytes)?)
     }
 
@@ -418,9 +418,9 @@ pub(crate) fn load_der_x509_certificate(
     let raw = OwnedCertificate::try_new(data, |data| asn1::parse_single(data.as_bytes(py)))?;
     // Parse cert version immediately so we can raise error on parse if it is invalid.
     cert_version(py, raw.borrow_dependent().tbs_cert.version)?;
-    // determine if the serial is negative and raise a warning if it is. We want to drop support
-    // for this sort of invalid encoding eventually.
-    warn_if_negative_serial(py, raw.borrow_dependent().tbs_cert.serial.as_bytes())?;
+    // determine if the serial is not positive and raise a warning if it is. We
+    // want to drop support for this sort of invalid encoding eventually.
+    warn_if_not_positive(py, raw.borrow_dependent().tbs_cert.serial.as_bytes())?;
     // determine if the signature algorithm has incorrect parameters and raise a warning if it
     // does. this is a bug in the JDK and we want to drop support for it eventually.
     // ECDSA was fixed in Java 16, DSA in Java 21.
@@ -436,10 +436,10 @@ pub(crate) fn load_der_x509_certificate(
     })
 }
 
-fn warn_if_negative_serial(py: pyo3::Python<'_>, bytes: &'_ [u8]) -> pyo3::PyResult<()> {
-    if bytes[0] & 0x80 != 0 {
+fn warn_if_not_positive(py: pyo3::Python<'_>, bytes: &[u8]) -> pyo3::PyResult<()> {
+    if bytes[0] & 0x80 != 0 || bytes == [0] {
         let warning_cls = types::DEPRECATED_IN_36.get(py)?;
-        let message = cstr_from_literal!("Parsed a negative serial number, which is disallowed by RFC 5280. Loading this certificate will cause an exception in a future release of cryptography.");
+        let message = cstr_from_literal!("Parsed a serial number which wasn't positive (i.e., it was negative or zero), which is disallowed by RFC 5280. Loading this certificate will cause an exception in a future release of cryptography.");
         pyo3::PyErr::warn(py, &warning_cls, message, 1)?;
     }
     Ok(())
@@ -674,7 +674,10 @@ pub(crate) fn parse_authority_key_identifier<'p>(
 ) -> Result<pyo3::Bound<'p, pyo3::PyAny>, CryptographyError> {
     let aki = ext.value::<AuthorityKeyIdentifier<'_, Asn1Read>>()?;
     let serial = match aki.authority_cert_serial_number {
-        Some(biguint) => big_byte_slice_to_py_int(py, biguint.as_bytes())?.unbind(),
+        Some(biguint) => {
+            warn_if_not_positive(py, biguint.as_bytes())?;
+            big_byte_slice_to_py_int(py, biguint.as_bytes())?.unbind()
+        }
         None => py.None(),
     };
     let issuer = match aki.authority_cert_issuer {
diff --git a/src/rust/src/x509/crl.rs b/src/rust/src/x509/crl.rs
index 5effe7128..36a4545a6 100644
--- a/src/rust/src/x509/crl.rs
+++ b/src/rust/src/x509/crl.rs
@@ -4,6 +4,7 @@
 
 use std::sync::Arc;
 
+use cryptography_x509::certificate::SerialNumber;
 use cryptography_x509::common::{self, Asn1Read};
 use cryptography_x509::crl::{
     self, CertificateRevocationList as RawCertificateRevocationList,
@@ -650,7 +651,7 @@ pub(crate) fn create_x509_crl(
             py_revoked_cert.getattr(pyo3::intern!(py, "revocation_date_utc"))?;
         let serial_bytes = ka_bytes.add(py_uint_to_big_endian_bytes(py, serial_number)?);
         revoked_certs.push(crl::RevokedCertificate {
-            user_certificate: asn1::BigUint::new(serial_bytes).unwrap(),
+            user_certificate: SerialNumber::new(serial_bytes).unwrap(),
             revocation_date: x509::certificate::time_from_py(py, &py_revocation_date)?,
             raw_crl_entry_extensions: x509::common::encode_extensions(
                 py,
diff --git a/src/rust/src/x509/extensions.rs b/src/rust/src/x509/extensions.rs
index 6321b74c4..739455fa4 100644
--- a/src/rust/src/x509/extensions.rs
+++ b/src/rust/src/x509/extensions.rs
@@ -2,6 +2,7 @@
 // 2.0, and the BSD License. See the LICENSE file in the root of this repository
 // for complete details.
 
+use cryptography_x509::certificate::SerialNumber;
 use cryptography_x509::common::Asn1Write;
 use cryptography_x509::{crl, extensions, oid};
 use pyo3::pybacked::PyBackedStr;
@@ -59,7 +60,7 @@ pub(crate) fn encode_authority_key_identifier<'a>(
     let authority_cert_serial_number =
         if let Some(authority_cert_serial_number) = aki.authority_cert_serial_number {
             serial_bytes = py_uint_to_big_endian_bytes(py, authority_cert_serial_number)?;
-            Some(asn1::BigUint::new(&serial_bytes).unwrap())
+            Some(SerialNumber::new(&serial_bytes).unwrap())
         } else {
             None
         };
