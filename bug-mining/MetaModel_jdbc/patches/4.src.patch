diff --git a/jdbc/src/main/java/org/apache/metamodel/jdbc/JdbcUpdateBuilder.java b/jdbc/src/main/java/org/apache/metamodel/jdbc/JdbcUpdateBuilder.java
index 9355968b..6610a7e9 100644
--- a/jdbc/src/main/java/org/apache/metamodel/jdbc/JdbcUpdateBuilder.java
+++ b/jdbc/src/main/java/org/apache/metamodel/jdbc/JdbcUpdateBuilder.java
@@ -72,8 +72,8 @@ final class JdbcUpdateBuilder extends AbstractRowUpdationBuilder {
                 for (int i = 0; i < columns.length; i++) {
                     boolean explicitNull = explicitNulls[i];
                     if (values[i] != null || explicitNull) {
-                    	JdbcUtils.setStatementValue(st, valueCounter, columns[i], values[i]);
-                    	
+                        JdbcUtils.setStatementValue(st, valueCounter, columns[i], values[i]);
+
                         valueCounter++;
                     }
                 }
@@ -83,9 +83,9 @@ final class JdbcUpdateBuilder extends AbstractRowUpdationBuilder {
                     if (JdbcUtils.isPreparedParameterCandidate(whereItem)) {
                         final Object operand = whereItem.getOperand();
                         final Column column = whereItem.getSelectItem().getColumn();
-                        
-						JdbcUtils.setStatementValue(st, valueCounter, column, operand);
-                        
+
+                        JdbcUtils.setStatementValue(st, valueCounter, column, operand);
+
                         valueCounter++;
                     }
                 }
@@ -99,7 +99,7 @@ final class JdbcUpdateBuilder extends AbstractRowUpdationBuilder {
             }
         }
     }
-    
+
     protected String createSqlStatement() {
         return createSqlStatement(_inlineValues);
     }
@@ -119,7 +119,8 @@ final class JdbcUpdateBuilder extends AbstractRowUpdationBuilder {
         boolean[] explicitNulls = getExplicitNulls();
         boolean firstValue = true;
         for (int i = 0; i < columns.length; i++) {
-            if (values[i] != null || explicitNulls[i]) {
+            final Object value = values[i];
+            if (value != null || explicitNulls[i]) {
                 if (firstValue) {
                     firstValue = false;
                 } else {
@@ -130,9 +131,8 @@ final class JdbcUpdateBuilder extends AbstractRowUpdationBuilder {
                 sb.append(columnName);
 
                 sb.append('=');
-
                 if (inlineValues) {
-                    sb.append(JdbcUtils.getValueAsSql(columns[i], values[i], _queryRewriter));
+                    sb.append(JdbcUtils.getValueAsSql(columns[i], value, _queryRewriter));
                 } else {
                     sb.append('?');
                 }
diff --git a/jdbc/src/main/java/org/apache/metamodel/jdbc/JdbcUtils.java b/jdbc/src/main/java/org/apache/metamodel/jdbc/JdbcUtils.java
index 4969bae3..a6065ae3 100644
--- a/jdbc/src/main/java/org/apache/metamodel/jdbc/JdbcUtils.java
+++ b/jdbc/src/main/java/org/apache/metamodel/jdbc/JdbcUtils.java
@@ -47,222 +47,203 @@ import org.slf4j.LoggerFactory;
  */
 public final class JdbcUtils {
 
-	private static final Logger logger = LoggerFactory
-			.getLogger(JdbcUtils.class);
-
-	public static MetaModelException wrapException(SQLException e,
-			String actionDescription) throws MetaModelException {
-		String message = e.getMessage();
-		if (message == null || message.isEmpty()) {
-			message = "Could not " + actionDescription;
-		} else {
-			message = "Could not " + actionDescription + ": " + message;
-		}
-
-		logger.error(message, e);
-		logger.error("Error code={}, SQL state={}", e.getErrorCode(),
-				e.getSQLState());
-
-		final SQLException nextException = e.getNextException();
-		if (nextException != null) {
-			logger.error("Next SQL exception: " + nextException.getMessage(),
-					nextException);
-		}
-
-		return new MetaModelException(message, e);
-	}
-
-	/**
-	 * Method which handles the action of setting a parameterized value on a
-	 * statement. Traditionally this is done using the
-	 * {@link PreparedStatement#setObject(int, Object)} method but for some
-	 * types we use more specific setter methods.
-	 * 
-	 * @param st
-	 * @param valueIndex
-	 * @param column
-	 * @param value
-	 * @throws SQLException
-	 */
-	public static void setStatementValue(final PreparedStatement st,
-			final int valueIndex, final Column column, Object value)
-			throws SQLException {
-		final ColumnType type = (column == null ? null : column.getType());
-
-		if (type == null || type == ColumnType.OTHER) {
-			// type is not known - nothing more we can do to narrow the type
-			st.setObject(valueIndex, value);
-			return;
-		}
-
-		if (value == null && type != null) {
-			try {
-				final int jdbcType = type.getJdbcType();
-				st.setNull(valueIndex, jdbcType);
-				return;
-			} catch (Exception e) {
-				logger.warn(
-						"Exception occurred while calling setNull(...) for value index "
-								+ valueIndex
-								+ ". Attempting value-based setter method instead.",
-						e);
-			}
-		}
-
-		if (type == ColumnType.VARCHAR && value instanceof Date) {
-			// some drivers (SQLite and JTDS for MS SQL server) treat dates as
-			// VARCHARS. In that case we need to convert the dates to the
-			// correct format
-			String nativeType = column.getNativeType();
-			Date date = (Date) value;
-			if ("DATE".equalsIgnoreCase(nativeType)) {
-				value = FormatHelper
-						.formatSqlTime(ColumnType.DATE, date, false);
-			} else if ("TIME".equalsIgnoreCase(nativeType)) {
-				value = FormatHelper
-						.formatSqlTime(ColumnType.TIME, date, false);
-			} else if ("TIMESTAMP".equalsIgnoreCase(nativeType)
-					|| "DATETIME".equalsIgnoreCase(nativeType)) {
-				value = FormatHelper.formatSqlTime(ColumnType.TIMESTAMP, date,
-						false);
-			}
-		}
-
-		if (type != null && type.isTimeBased() && value instanceof String) {
-			value = FormatHelper.parseSqlTime(type, (String) value);
-		}
-
-		try {
-			if (type == ColumnType.DATE && value instanceof Date) {
-				Calendar cal = Calendar.getInstance();
-				cal.setTime((Date) value);
-				st.setDate(valueIndex,
-						new java.sql.Date(cal.getTimeInMillis()), cal);
-			} else if (type == ColumnType.TIME && value instanceof Date) {
-				Calendar cal = Calendar.getInstance();
-				cal.setTime((Date) value);
-				st.setTime(valueIndex,
-						new java.sql.Time(cal.getTimeInMillis()), cal);
-			} else if (type == ColumnType.TIMESTAMP && value instanceof Date) {
-				Calendar cal = Calendar.getInstance();
-				cal.setTime((Date) value);
-				st.setTimestamp(valueIndex,
-						new java.sql.Timestamp(cal.getTimeInMillis()), cal);
-			} else if (type == ColumnType.CLOB || type == ColumnType.NCLOB) {
-				if (value instanceof InputStream) {
-					InputStream inputStream = (InputStream) value;
-					st.setAsciiStream(valueIndex, inputStream);
-				} else if (value instanceof Reader) {
-					Reader reader = (Reader) value;
-					st.setCharacterStream(valueIndex, reader);
-				} else if (value instanceof NClob) {
-					NClob nclob = (NClob) value;
-					st.setNClob(valueIndex, nclob);
-				} else if (value instanceof Clob) {
-					Clob clob = (Clob) value;
-					st.setClob(valueIndex, clob);
-				} else if (value instanceof String) {
-					st.setString(valueIndex, (String) value);
-				} else {
-					st.setObject(valueIndex, value);
-				}
-			} else if (type == ColumnType.BLOB || type == ColumnType.BINARY) {
-				if (value instanceof byte[]) {
-					byte[] bytes = (byte[]) value;
-					st.setBytes(valueIndex, bytes);
-				} else if (value instanceof InputStream) {
-					InputStream inputStream = (InputStream) value;
-					st.setBinaryStream(valueIndex, inputStream);
-				} else if (value instanceof Blob) {
-					Blob blob = (Blob) value;
-					st.setBlob(valueIndex, blob);
-				} else {
-					st.setObject(valueIndex, value);
-				}
-			} else if (type.isLiteral()) {
-				final String str;
-				if (value instanceof Reader) {
-					Reader reader = (Reader) value;
-					str = FileHelper.readAsString(reader);
-				} else {
-					str = value.toString();
-				}
-				st.setString(valueIndex, str);
-			} else {
-				st.setObject(valueIndex, value);
-			}
-		} catch (SQLException e) {
-			logger.error("Failed to set parameter {} to value: {}", valueIndex,
-					value);
-			throw e;
-		}
-	}
-
-	public static String getValueAsSql(Column column, Object value,
-			IQueryRewriter queryRewriter) {
-		if (value == null) {
-			return "NULL";
-		}
-		final ColumnType columnType = column.getType();
-		if (columnType.isLiteral() && value instanceof String) {
-			value = queryRewriter.escapeQuotes((String) value);
-		}
-		String formatSqlValue = FormatHelper.formatSqlValue(columnType, value);
-		return formatSqlValue;
-	}
-
-	public static String createWhereClause(List<FilterItem> whereItems,
-			IQueryRewriter queryRewriter, boolean inlineValues) {
-		if (whereItems.isEmpty()) {
-			return "";
-		}
-		StringBuilder sb = new StringBuilder();
-		sb.append(" WHERE ");
-		boolean firstValue = true;
-		for (FilterItem whereItem : whereItems) {
-			if (firstValue) {
-				firstValue = false;
-			} else {
-				sb.append(" AND ");
-			}
-			if (!inlineValues) {
-				if (isPreparedParameterCandidate(whereItem)) {
-					// replace operator with parameter
-					whereItem = new FilterItem(whereItem.getSelectItem(),
-							whereItem.getOperator(), new QueryParameter());
-				}
-			}
-			final String whereItemLabel = queryRewriter
-					.rewriteFilterItem(whereItem);
-			sb.append(whereItemLabel);
-		}
-		return sb.toString();
-	}
-
-	/**
-	 * Determines if a particular {@link FilterItem} will have it's parameter
-	 * (operand) replaced during SQL generation. Such filter items should
-	 * succesively have their parameters set at execution time.
-	 * 
-	 * @param whereItem
-	 * @return
-	 */
-	public static boolean isPreparedParameterCandidate(FilterItem whereItem) {
-		return !whereItem.isCompoundFilter()
-				&& whereItem.getOperator() != OperatorType.IN;
-	}
-
-	public static String[] getTableTypesAsStrings(TableType[] tableTypes) {
-		String[] types = new String[tableTypes.length];
-		for (int i = 0; i < types.length; i++) {
-			if (tableTypes[i] == TableType.OTHER) {
-				// if the OTHER type has been selected, don't use a table
-				// pattern (ie. include all types)
-				types = null;
-				break;
-			}
-			types[i] = tableTypes[i].toString();
-		}
-		return types;
-	}
+    private static final Logger logger = LoggerFactory.getLogger(JdbcUtils.class);
+
+    public static MetaModelException wrapException(SQLException e, String actionDescription) throws MetaModelException {
+        String message = e.getMessage();
+        if (message == null || message.isEmpty()) {
+            message = "Could not " + actionDescription;
+        } else {
+            message = "Could not " + actionDescription + ": " + message;
+        }
+
+        logger.error(message, e);
+        logger.error("Error code={}, SQL state={}", e.getErrorCode(), e.getSQLState());
+
+        final SQLException nextException = e.getNextException();
+        if (nextException != null) {
+            logger.error("Next SQL exception: " + nextException.getMessage(), nextException);
+        }
+
+        return new MetaModelException(message, e);
+    }
+
+    /**
+     * Method which handles the action of setting a parameterized value on a
+     * statement. Traditionally this is done using the
+     * {@link PreparedStatement#setObject(int, Object)} method but for some
+     * types we use more specific setter methods.
+     * 
+     * @param st
+     * @param valueIndex
+     * @param column
+     * @param value
+     * @throws SQLException
+     */
+    public static void setStatementValue(final PreparedStatement st, final int valueIndex, final Column column,
+            Object value) throws SQLException {
+        final ColumnType type = (column == null ? null : column.getType());
+
+        if (type == null || type == ColumnType.OTHER) {
+            // type is not known - nothing more we can do to narrow the type
+            st.setObject(valueIndex, value);
+            return;
+        }
+
+        if (value == null && type != null) {
+            try {
+                final int jdbcType = type.getJdbcType();
+                st.setNull(valueIndex, jdbcType);
+                return;
+            } catch (Exception e) {
+                logger.warn("Exception occurred while calling setNull(...) for value index " + valueIndex
+                        + ". Attempting value-based setter method instead.", e);
+            }
+        }
+
+        if (type == ColumnType.VARCHAR && value instanceof Date) {
+            // some drivers (SQLite and JTDS for MS SQL server) treat dates as
+            // VARCHARS. In that case we need to convert the dates to the
+            // correct format
+            String nativeType = column.getNativeType();
+            Date date = (Date) value;
+            if ("DATE".equalsIgnoreCase(nativeType)) {
+                value = FormatHelper.formatSqlTime(ColumnType.DATE, date, false);
+            } else if ("TIME".equalsIgnoreCase(nativeType)) {
+                value = FormatHelper.formatSqlTime(ColumnType.TIME, date, false);
+            } else if ("TIMESTAMP".equalsIgnoreCase(nativeType) || "DATETIME".equalsIgnoreCase(nativeType)) {
+                value = FormatHelper.formatSqlTime(ColumnType.TIMESTAMP, date, false);
+            }
+        }
+
+        if (type != null && type.isTimeBased() && value instanceof String) {
+            value = FormatHelper.parseSqlTime(type, (String) value);
+        }
+
+        try {
+            if (type == ColumnType.DATE && value instanceof Date) {
+                Calendar cal = Calendar.getInstance();
+                cal.setTime((Date) value);
+                st.setDate(valueIndex, new java.sql.Date(cal.getTimeInMillis()), cal);
+            } else if (type == ColumnType.TIME && value instanceof Date) {
+                Calendar cal = Calendar.getInstance();
+                cal.setTime((Date) value);
+                st.setTime(valueIndex, new java.sql.Time(cal.getTimeInMillis()), cal);
+            } else if (type == ColumnType.TIMESTAMP && value instanceof Date) {
+                Calendar cal = Calendar.getInstance();
+                cal.setTime((Date) value);
+                st.setTimestamp(valueIndex, new java.sql.Timestamp(cal.getTimeInMillis()), cal);
+            } else if (type == ColumnType.CLOB || type == ColumnType.NCLOB) {
+                if (value instanceof InputStream) {
+                    InputStream inputStream = (InputStream) value;
+                    st.setAsciiStream(valueIndex, inputStream);
+                } else if (value instanceof Reader) {
+                    Reader reader = (Reader) value;
+                    st.setCharacterStream(valueIndex, reader);
+                } else if (value instanceof NClob) {
+                    NClob nclob = (NClob) value;
+                    st.setNClob(valueIndex, nclob);
+                } else if (value instanceof Clob) {
+                    Clob clob = (Clob) value;
+                    st.setClob(valueIndex, clob);
+                } else if (value instanceof String) {
+                    st.setString(valueIndex, (String) value);
+                } else {
+                    st.setObject(valueIndex, value);
+                }
+            } else if (type == ColumnType.BLOB || type == ColumnType.BINARY) {
+                if (value instanceof byte[]) {
+                    byte[] bytes = (byte[]) value;
+                    st.setBytes(valueIndex, bytes);
+                } else if (value instanceof InputStream) {
+                    InputStream inputStream = (InputStream) value;
+                    st.setBinaryStream(valueIndex, inputStream);
+                } else if (value instanceof Blob) {
+                    Blob blob = (Blob) value;
+                    st.setBlob(valueIndex, blob);
+                } else {
+                    st.setObject(valueIndex, value);
+                }
+            } else if (type.isLiteral()) {
+                final String str;
+                if (value instanceof Reader) {
+                    Reader reader = (Reader) value;
+                    str = FileHelper.readAsString(reader);
+                } else {
+                    str = value.toString();
+                }
+                st.setString(valueIndex, str);
+            } else {
+                st.setObject(valueIndex, value);
+            }
+        } catch (SQLException e) {
+            logger.error("Failed to set parameter {} to value: {}", valueIndex, value);
+            throw e;
+        }
+    }
+
+    public static String getValueAsSql(Column column, Object value, IQueryRewriter queryRewriter) {
+        if (value == null) {
+            return "NULL";
+        }
+        final ColumnType columnType = column.getType();
+        if (columnType.isLiteral() && value instanceof String) {
+            value = queryRewriter.escapeQuotes((String) value);
+        }
+        String formatSqlValue = FormatHelper.formatSqlValue(columnType, value);
+        return formatSqlValue;
+    }
+
+    public static String createWhereClause(List<FilterItem> whereItems, IQueryRewriter queryRewriter,
+            boolean inlineValues) {
+        if (whereItems.isEmpty()) {
+            return "";
+        }
+        StringBuilder sb = new StringBuilder();
+        sb.append(" WHERE ");
+        boolean firstValue = true;
+        for (FilterItem whereItem : whereItems) {
+            if (firstValue) {
+                firstValue = false;
+            } else {
+                sb.append(" AND ");
+            }
+            if (!inlineValues) {
+                if (isPreparedParameterCandidate(whereItem)) {
+                    // replace operator with parameter
+                    whereItem = new FilterItem(whereItem.getSelectItem(), whereItem.getOperator(), new QueryParameter());
+                }
+            }
+            final String whereItemLabel = queryRewriter.rewriteFilterItem(whereItem);
+            sb.append(whereItemLabel);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Determines if a particular {@link FilterItem} will have it's parameter
+     * (operand) replaced during SQL generation. Such filter items should
+     * succesively have their parameters set at execution time.
+     * 
+     * @param whereItem
+     * @return
+     */
+    public static boolean isPreparedParameterCandidate(FilterItem whereItem) {
+        return !whereItem.isCompoundFilter() && whereItem.getOperator() != OperatorType.IN
+                && whereItem.getOperand() != null;
+    }
+
+    public static String[] getTableTypesAsStrings(TableType[] tableTypes) {
+        String[] types = new String[tableTypes.length];
+        for (int i = 0; i < types.length; i++) {
+            if (tableTypes[i] == TableType.OTHER) {
+                // if the OTHER type has been selected, don't use a table
+                // pattern (ie. include all types)
+                types = null;
+                break;
+            }
+            types[i] = tableTypes[i].toString();
+        }
+        return types;
+    }
 }
diff --git a/jdbc/src/test/java/org/apache/metamodel/jdbc/JdbcDeleteBuilderTest.java b/jdbc/src/test/java/org/apache/metamodel/jdbc/JdbcDeleteBuilderTest.java
index a5309676..dbade6aa 100644
--- a/jdbc/src/test/java/org/apache/metamodel/jdbc/JdbcDeleteBuilderTest.java
+++ b/jdbc/src/test/java/org/apache/metamodel/jdbc/JdbcDeleteBuilderTest.java
@@ -33,8 +33,8 @@ public class JdbcDeleteBuilderTest extends JdbcTestCase {
                 dataContext), true);
 
         updateBuilder.where("REPORTSTO").eq(1234);
-        assertEquals("DELETE FROM PUBLIC._EMPLOYEES_ WHERE _EMPLOYEES_._REPORTSTO_ = 1234",
-                updateBuilder.createSqlStatement().replaceAll("\"", "_"));
+        assertEquals("DELETE FROM PUBLIC._EMPLOYEES_ WHERE _EMPLOYEES_._REPORTSTO_ = 1234", updateBuilder
+                .createSqlStatement().replaceAll("\"", "_"));
 
         updateBuilder.where("JOBTITLE").eq("Sales rep");
         assertEquals(
@@ -53,8 +53,25 @@ public class JdbcDeleteBuilderTest extends JdbcTestCase {
                 Arrays.toString(table.getColumnNames()));
 
         updateBuilder.where("firstname").isNull().where("lastname").isNotNull();
-        assertEquals("DELETE FROM PUBLIC._EMPLOYEES_ WHERE _EMPLOYEES_._FIRSTNAME_ IS NULL AND _EMPLOYEES_._LASTNAME_ IS NOT NULL", updateBuilder
-                .createSqlStatement().replaceAll("\"", "_"));
+        assertEquals(
+                "DELETE FROM PUBLIC._EMPLOYEES_ WHERE _EMPLOYEES_._FIRSTNAME_ IS NULL AND _EMPLOYEES_._LASTNAME_ IS NOT NULL",
+                updateBuilder.createSqlStatement().replaceAll("\"", "_"));
+    }
+
+    public void testUpdateWhereSomethingIsOrIsNotNull() throws Exception {
+        JdbcDataContext dataContext = new JdbcDataContext(getTestDbConnection());
+        Table table = dataContext.getTableByQualifiedLabel("PUBLIC.EMPLOYEES");
+        JdbcUpdateCallback updateCallback = new JdbcSimpleUpdateCallback(dataContext);
+
+        assertEquals("[EMPLOYEENUMBER, LASTNAME, FIRSTNAME, EXTENSION, EMAIL, OFFICECODE, REPORTSTO, JOBTITLE]",
+                Arrays.toString(table.getColumnNames()));
+
+        JdbcDeleteBuilder updateBuilder = new JdbcDeleteBuilder(updateCallback, table, new DefaultQueryRewriter(
+                dataContext), false);
+        updateBuilder.where("email").isNull().where("officecode").isNotNull();
+        assertEquals(
+                "DELETE FROM PUBLIC._EMPLOYEES_ WHERE _EMPLOYEES_._EMAIL_ IS NULL AND _EMPLOYEES_._OFFICECODE_ IS NOT NULL",
+                updateBuilder.createSqlStatement().replaceAll("\"", "_"));
     }
 
     public void testCreateSqlStatementWithQuotesInValue() throws Exception {
@@ -63,10 +80,9 @@ public class JdbcDeleteBuilderTest extends JdbcTestCase {
         JdbcUpdateCallback updateCallback = new JdbcSimpleUpdateCallback(dataContext);
         JdbcDeleteBuilder updateBuilder = new JdbcDeleteBuilder(updateCallback, table, new DefaultQueryRewriter(
                 dataContext), true);
-        
+
         updateBuilder.where("OFFICECODE").isEquals("ro'om");
-        assertEquals(
-                "DELETE FROM PUBLIC._EMPLOYEES_ WHERE _EMPLOYEES_._OFFICECODE_ = 'ro''om'",
-                updateBuilder.createSqlStatement().replaceAll("\"", "_"));
+        assertEquals("DELETE FROM PUBLIC._EMPLOYEES_ WHERE _EMPLOYEES_._OFFICECODE_ = 'ro''om'", updateBuilder
+                .createSqlStatement().replaceAll("\"", "_"));
     }
 }
diff --git a/jdbc/src/test/java/org/apache/metamodel/jdbc/JdbcUpdateBuilderTest.java b/jdbc/src/test/java/org/apache/metamodel/jdbc/JdbcUpdateBuilderTest.java
index 08a82293..f44c77b5 100644
--- a/jdbc/src/test/java/org/apache/metamodel/jdbc/JdbcUpdateBuilderTest.java
+++ b/jdbc/src/test/java/org/apache/metamodel/jdbc/JdbcUpdateBuilderTest.java
@@ -65,6 +65,22 @@ public class JdbcUpdateBuilderTest extends JdbcTestCase {
                 .replaceAll("\"", "_"));
     }
 
+    public void testUpdateWhereSomethingIsOrIsNotNull() throws Exception {
+        JdbcDataContext dataContext = new JdbcDataContext(getTestDbConnection());
+        Table table = dataContext.getTableByQualifiedLabel("PUBLIC.EMPLOYEES");
+        JdbcUpdateCallback updateCallback = new JdbcSimpleUpdateCallback(dataContext);
+
+        assertEquals("[EMPLOYEENUMBER, LASTNAME, FIRSTNAME, EXTENSION, EMAIL, OFFICECODE, REPORTSTO, JOBTITLE]",
+                Arrays.toString(table.getColumnNames()));
+
+        JdbcUpdateBuilder updateBuilder = new JdbcUpdateBuilder(updateCallback, table, new DefaultQueryRewriter(
+                dataContext), false);
+        updateBuilder.value("LASTNAME", "foo").where("email").isNull().where("officecode").isNotNull();
+        assertEquals(
+                "UPDATE PUBLIC._EMPLOYEES_ SET LASTNAME=? WHERE _EMPLOYEES_._EMAIL_ IS NULL AND _EMPLOYEES_._OFFICECODE_ IS NOT NULL",
+                updateBuilder.createSqlStatement().replaceAll("\"", "_"));
+    }
+
     public void testCreateSqlStatementWithQuotesInValue() throws Exception {
         JdbcDataContext dataContext = new JdbcDataContext(getTestDbConnection());
         Table table = dataContext.getTableByQualifiedLabel("PUBLIC.EMPLOYEES");
