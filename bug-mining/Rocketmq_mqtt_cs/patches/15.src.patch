diff --git a/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/session/Session.java b/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/session/Session.java
index 06e0700..0424b7c 100644
--- a/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/session/Session.java
+++ b/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/session/Session.java
@@ -142,9 +142,7 @@ public class Session {
             }
             Map<Queue, QueueOffset> queueMap = new HashMap<>(8);
             tmp.put(subscription, queueMap);
-            for (Map.Entry<Queue, QueueOffset> entry : offsetMap.get(queueName).entrySet()) {
-                queueMap.put(entry.getKey(), entry.getValue());
-            }
+            queueMap.putAll(offsetMap.get(queueName));
         }
         return tmp;
     }
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestPushAction.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestPushAction.java
deleted file mode 100644
index 633f3f2..0000000
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestPushAction.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- *
- *  * Licensed to the Apache Software Foundation (ASF) under one or more
- *  * contributor license agreements.  See the NOTICE file distributed with
- *  * this work for additional information regarding copyright ownership.
- *  * The ASF licenses this file to You under the Apache License, Version 2.0
- *  * (the "License"); you may not use this file except in compliance with
- *  * the License.  You may obtain a copy of the License at
- *  *
- *  *     http://www.apache.org/licenses/LICENSE-2.0
- *  *
- *  * Unless required by applicable law or agreed to in writing, software
- *  * distributed under the License is distributed on an "AS IS" BASIS,
- *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  * See the License for the specific language governing permissions and
- *  * limitations under the License.
- *
- */
-
-package org.apache.rocketmq.mqtt.cs.test;
-
-import org.apache.commons.lang3.reflect.FieldUtils;
-import org.apache.rocketmq.mqtt.common.model.Message;
-import org.apache.rocketmq.mqtt.common.model.Queue;
-import org.apache.rocketmq.mqtt.common.model.Subscription;
-import org.apache.rocketmq.mqtt.cs.config.ConnectConf;
-import org.apache.rocketmq.mqtt.cs.session.Session;
-import org.apache.rocketmq.mqtt.cs.session.infly.InFlyCache;
-import org.apache.rocketmq.mqtt.cs.session.infly.MqttMsgId;
-import org.apache.rocketmq.mqtt.cs.session.infly.PushAction;
-import org.apache.rocketmq.mqtt.cs.session.infly.RetryDriver;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.junit.MockitoJUnitRunner;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.doNothing;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(MockitoJUnitRunner.class)
-public class TestPushAction {
-
-    @Mock
-    private MqttMsgId mqttMsgId;
-
-    @Mock
-    private RetryDriver retryDriver;
-
-    @Mock
-    private InFlyCache inFlyCache;
-
-    @Mock
-    private ConnectConf connectConf;
-
-    private PushAction pushAction = new PushAction();
-
-    @Before
-    public void before() throws IllegalAccessException {
-        FieldUtils.writeDeclaredField(pushAction, "mqttMsgId", mqttMsgId, true);
-        FieldUtils.writeDeclaredField(pushAction, "retryDriver", retryDriver, true);
-        FieldUtils.writeDeclaredField(pushAction, "inFlyCache", inFlyCache, true);
-        FieldUtils.writeDeclaredField(pushAction, "connectConf", connectConf, true);
-    }
-
-    @Test
-    public void testMessageArrive() {
-        Session session = mock(Session.class);
-        Subscription subscription = mock(Subscription.class);
-        Queue queue = mock(Queue.class);
-        List<Message> messages = new ArrayList<>();
-        messages.add(mock(Message.class));
-        when(session.pendMessageList(any(), any())).thenReturn(messages);
-        when(connectConf.isOrder()).thenReturn(false);
-        PushAction spyPushAction = spy(pushAction);
-        doNothing().when(spyPushAction).push(any(), any(), any(), any());
-        spyPushAction.messageArrive(session, subscription, queue);
-        verify(spyPushAction, atLeastOnce()).push(any(), any(), any(), any());
-    }
-
-    @Test
-    public void testPush() {
-        Session session = mock(Session.class);
-        when(session.getChannelId()).thenReturn("test");
-        when(session.getClientId()).thenReturn("test");
-        PushAction spyPushAction = spy(pushAction);
-        doNothing().when(spyPushAction).write(any(), any(), anyInt(), anyInt(), any());
-        when(inFlyCache.getPendingDownCache()).thenReturn(new InFlyCache().getPendingDownCache());
-        spyPushAction.push(mock(Message.class), mock(Subscription.class), session, mock(Queue.class));
-        verify(spyPushAction, atLeastOnce()).write(any(), any(), anyInt(), anyInt(), any());
-    }
-
-}
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestSession.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestSession.java
deleted file mode 100644
index 563940e..0000000
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestSession.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- *
- *  * Licensed to the Apache Software Foundation (ASF) under one or more
- *  * contributor license agreements.  See the NOTICE file distributed with
- *  * this work for additional information regarding copyright ownership.
- *  * The ASF licenses this file to You under the Apache License, Version 2.0
- *  * (the "License"); you may not use this file except in compliance with
- *  * the License.  You may obtain a copy of the License at
- *  *
- *  *     http://www.apache.org/licenses/LICENSE-2.0
- *  *
- *  * Unless required by applicable law or agreed to in writing, software
- *  * distributed under the License is distributed on an "AS IS" BASIS,
- *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  * See the License for the specific language governing permissions and
- *  * limitations under the License.
- *
- */
-
-package org.apache.rocketmq.mqtt.cs.test;
-
-import org.apache.rocketmq.mqtt.common.model.Message;
-import org.apache.rocketmq.mqtt.common.model.Queue;
-import org.apache.rocketmq.mqtt.common.model.QueueOffset;
-import org.apache.rocketmq.mqtt.common.model.Subscription;
-import org.apache.rocketmq.mqtt.cs.session.Session;
-import org.junit.Assert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.junit.MockitoJUnitRunner;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-@RunWith(MockitoJUnitRunner.class)
-public class TestSession {
-
-    @Test
-    public void test() {
-        Session session = new Session();
-
-        Set<Subscription> subscriptions = new HashSet<>();
-        Subscription subscription = new Subscription("test");
-        subscriptions.add(subscription);
-        session.addSubscription(subscriptions);
-        Set<Subscription> subscriptionSnapshot = session.subscriptionSnapshot();
-        Assert.assertTrue(subscriptionSnapshot.iterator().next().equals(subscription));
-
-        Queue queue = new Queue(0, "test", "test");
-        QueueOffset queueOffset = new QueueOffset();
-        Map<Queue, QueueOffset> offsetMap = new HashMap<>();
-        offsetMap.put(queue, queueOffset);
-        session.addOffset(subscription.toQueueName(), offsetMap);
-        Assert.assertTrue(queueOffset.equals(session.getQueueOffset(subscription, queue)));
-
-        session.freshQueue(subscription, new HashSet<>(Arrays.asList(queue)));
-        List<Message> messages = new ArrayList<>();
-        Message message = new Message();
-        message.setOffset(1);
-        messages.add(message);
-        session.addSendingMessages(subscription, queue, messages);
-        Assert.assertFalse(session.sendingMessageIsEmpty(subscription, queue));
-        Assert.assertTrue(message.equals(session.nextSendMessageByOrder(subscription,queue)));
-        Assert.assertTrue(message.equals(session.pendMessageList(subscription,queue).iterator().next()));
-
-        session.ack(subscription,queue,1);
-        Assert.assertTrue(session.sendingMessageIsEmpty(subscription, queue));
-    }
-
-}
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/TestQueueFresh.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/TestQueueFresh.java
new file mode 100644
index 0000000..126a343
--- /dev/null
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/TestQueueFresh.java
@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.mqtt.cs.test.session;
+
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.rocketmq.mqtt.common.facade.LmqQueueStore;
+import org.apache.rocketmq.mqtt.common.model.Queue;
+import org.apache.rocketmq.mqtt.common.model.Subscription;
+import org.apache.rocketmq.mqtt.cs.session.QueueFresh;
+import org.apache.rocketmq.mqtt.cs.session.Session;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.util.Collections;
+import java.util.Set;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anySet;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(MockitoJUnitRunner.class)
+public class TestQueueFresh {
+
+    private QueueFresh queueFresh;
+    private Subscription subscription;
+    final String firstTopic = "testQueueFresh";
+    final String p2pFilter = "/p2p/test";
+    final String retryFilter = "/retry/test";
+    final String brokerName = "localhost";
+    final Set<String> brokers = Collections.singleton(brokerName);
+
+    @Mock
+    private LmqQueueStore lmqQueueStore;
+
+    @Mock
+    private Session session;
+
+    @Before
+    public void setUp() throws IllegalAccessException {
+        queueFresh = new QueueFresh();
+        FieldUtils.writeDeclaredField(queueFresh, "lmqQueueStore", lmqQueueStore, true);
+        subscription = new Subscription();
+    }
+
+    @Test
+    public void testP2pQueue() {
+        subscription.setTopicFilter(p2pFilter);
+        doReturn(null).when(lmqQueueStore).getClientP2pTopic();
+        doReturn(null).when(lmqQueueStore).getClientRetryTopic();
+        when(lmqQueueStore.getReadableBrokers(any())).thenReturn(brokers);
+
+        Set<Queue> queues = queueFresh.freshQueue(session, subscription);
+
+        verify(lmqQueueStore).getClientP2pTopic();
+        verify(lmqQueueStore).getClientRetryTopic();
+        verify(lmqQueueStore).getReadableBrokers(any());
+        verify(session).freshQueue(eq(subscription), anySet());
+        verifyNoMoreInteractions(session, lmqQueueStore);
+
+        Assert.assertEquals(p2pFilter, queues.iterator().next().getQueueName());
+        Assert.assertEquals(brokerName, queues.iterator().next().getBrokerName());
+    }
+
+    @Test
+    public void testRetryQueue() {
+        subscription.setTopicFilter(retryFilter);
+        doReturn(null).when(lmqQueueStore).getClientRetryTopic();
+        when(lmqQueueStore.getReadableBrokers(any())).thenReturn(brokers);
+
+        Set<Queue> queues = queueFresh.freshQueue(session, subscription);
+
+        verify(lmqQueueStore).getClientRetryTopic();
+        verify(lmqQueueStore).getReadableBrokers(any());
+        verify(session).freshQueue(eq(subscription), anySet());
+        verifyNoMoreInteractions(session, lmqQueueStore);
+
+        Assert.assertEquals(retryFilter, queues.iterator().next().getQueueName());
+        Assert.assertEquals(brokerName, queues.iterator().next().getBrokerName());
+    }
+
+    @Test
+    public void testOther() {
+        subscription.setTopicFilter(firstTopic);
+        doReturn(null).when(lmqQueueStore).getReadableBrokers(firstTopic);
+
+        Set<Queue> queues = queueFresh.freshQueue(session, subscription);
+
+        verify(lmqQueueStore).getReadableBrokers(eq(firstTopic));
+        verifyNoMoreInteractions(session, lmqQueueStore);
+
+        Assert.assertTrue(queues.isEmpty());
+    }
+
+}
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/TestSession.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/TestSession.java
new file mode 100644
index 0000000..df121b9
--- /dev/null
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/TestSession.java
@@ -0,0 +1,109 @@
+/*
+ *
+ *  * Licensed to the Apache Software Foundation (ASF) under one or more
+ *  * contributor license agreements.  See the NOTICE file distributed with
+ *  * this work for additional information regarding copyright ownership.
+ *  * The ASF licenses this file to You under the Apache License, Version 2.0
+ *  * (the "License"); you may not use this file except in compliance with
+ *  * the License.  You may obtain a copy of the License at
+ *  *
+ *  *     http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  * Unless required by applicable law or agreed to in writing, software
+ *  * distributed under the License is distributed on an "AS IS" BASIS,
+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  * See the License for the specific language governing permissions and
+ *  * limitations under the License.
+ *
+ */
+
+package org.apache.rocketmq.mqtt.cs.test.session;
+
+import org.apache.rocketmq.mqtt.common.model.Message;
+import org.apache.rocketmq.mqtt.common.model.Queue;
+import org.apache.rocketmq.mqtt.common.model.QueueOffset;
+import org.apache.rocketmq.mqtt.common.model.Subscription;
+import org.apache.rocketmq.mqtt.cs.session.Session;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+@RunWith(MockitoJUnitRunner.class)
+public class TestSession {
+    final String topicFilter = "testSession";
+    final String queueName = topicFilter;
+    final String brokerName = "localhost";
+    final int firstMsgOffset = 1;
+    final int secondMsgOffset = 2;
+
+    @Test
+    public void test() {
+        Session session = new Session();
+
+        Set<Subscription> subscriptions = new HashSet<>();
+        Subscription subscription = new Subscription(topicFilter);
+        subscriptions.add(subscription);
+        session.addSubscription(subscriptions);
+        Set<Subscription> subscriptionSnapshot = session.subscriptionSnapshot();
+        Assert.assertEquals(subscription, subscriptionSnapshot.iterator().next());
+
+        Queue queue = new Queue(0, queueName, brokerName);
+        QueueOffset queueOffset = new QueueOffset();
+        Map<Queue, QueueOffset> offsetMap = new HashMap<>();
+        offsetMap.put(queue, queueOffset);
+        Map<String, Map<Queue, QueueOffset>> offsetMapParam = new HashMap<>();
+        offsetMapParam.put(queueName, offsetMap);
+
+        session.addOffset(offsetMapParam);
+        Assert.assertEquals(queueOffset, session.getQueueOffset(subscription, queue));
+        Assert.assertEquals(offsetMap, session.getQueueOffset(subscription));
+        Map<Subscription, Map<Queue, QueueOffset>> offsetSnapshot = session.offsetMapSnapshot();
+        Assert.assertEquals(1, offsetSnapshot.size());
+        Assert.assertEquals(subscription, offsetSnapshot.keySet().iterator().next());
+        Assert.assertEquals(offsetMap, offsetSnapshot.values().iterator().next());
+
+        session.freshQueue(subscription, new HashSet<>(Arrays.asList(queue)));
+        List<Message> messages = new ArrayList<>();
+        Message message = new Message();
+        message.setOffset(firstMsgOffset);
+        messages.add(message);
+        session.addSendingMessages(subscription, queue, messages);
+        Assert.assertFalse(session.sendingMessageIsEmpty(subscription, queue));
+        Assert.assertEquals(message, session.nextSendMessageByOrder(subscription, queue));
+        Assert.assertEquals(message, session.pendMessageList(subscription, queue).iterator().next());
+
+        Message secondMessage = new Message();
+        secondMessage.setOffset(secondMsgOffset);
+        session.addSendingMessages(subscription, queue, Arrays.asList(secondMessage));
+        Assert.assertEquals(2, session.pendMessageList(subscription, queue).size());
+
+        // when ack larger offset, the Msg will not be removed
+        session.ack(subscription, queue, secondMsgOffset);
+        Assert.assertEquals(Long.MAX_VALUE, session.getQueueOffset(subscription, queue).getOffset());
+        Assert.assertEquals(1, session.pendMessageList(subscription, queue).size());
+        Assert.assertFalse(session.getPersistOffsetFlag());
+
+        // test rollNext
+        Message nextMsg = session.rollNext(subscription, queue, firstMsgOffset);
+        Assert.assertTrue(session.getPersistOffsetFlag());
+        Assert.assertEquals(secondMsgOffset, session.getQueueOffset(subscription, queue).getOffset());
+        Assert.assertEquals(secondMessage, nextMsg);
+
+        // when ack next-offset, the last time acked Msg will be removed
+        session.ack(subscription, queue, secondMsgOffset + 1);
+        Assert.assertTrue(session.sendingMessageIsEmpty(subscription, queue));
+
+        session.removeSubscription(subscription);
+        Assert.assertEquals(0, session.subscriptionSnapshot().size());
+        session.destroy();
+    }
+}
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestInFlyCache.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestInFlyCache.java
similarity index 98%
rename from mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestInFlyCache.java
rename to mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestInFlyCache.java
index e341caa..9fc7803 100644
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestInFlyCache.java
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestInFlyCache.java
@@ -17,7 +17,7 @@
  *
  */
 
-package org.apache.rocketmq.mqtt.cs.test;
+package org.apache.rocketmq.mqtt.cs.test.session.infly;
 
 import org.apache.commons.lang3.reflect.FieldUtils;
 import org.apache.rocketmq.mqtt.common.model.Message;
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestMqttMsgId.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestMqttMsgId.java
similarity index 96%
rename from mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestMqttMsgId.java
rename to mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestMqttMsgId.java
index 97ed83f..34b1576 100644
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestMqttMsgId.java
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestMqttMsgId.java
@@ -17,7 +17,7 @@
  *
  */
 
-package org.apache.rocketmq.mqtt.cs.test;
+package org.apache.rocketmq.mqtt.cs.test.session.infly;
 
 import org.apache.rocketmq.mqtt.cs.session.infly.MqttMsgId;
 import org.junit.Assert;
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestPushAction.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestPushAction.java
new file mode 100644
index 0000000..ee82d9a
--- /dev/null
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestPushAction.java
@@ -0,0 +1,237 @@
+/*
+ *
+ *  * Licensed to the Apache Software Foundation (ASF) under one or more
+ *  * contributor license agreements.  See the NOTICE file distributed with
+ *  * this work for additional information regarding copyright ownership.
+ *  * The ASF licenses this file to You under the Apache License, Version 2.0
+ *  * (the "License"); you may not use this file except in compliance with
+ *  * the License.  You may obtain a copy of the License at
+ *  *
+ *  *     http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  * Unless required by applicable law or agreed to in writing, software
+ *  * distributed under the License is distributed on an "AS IS" BASIS,
+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  * See the License for the specific language governing permissions and
+ *  * limitations under the License.
+ *
+ */
+
+package org.apache.rocketmq.mqtt.cs.test.session.infly;
+
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.rocketmq.mqtt.common.model.Message;
+import org.apache.rocketmq.mqtt.common.model.Queue;
+import org.apache.rocketmq.mqtt.common.model.Subscription;
+import org.apache.rocketmq.mqtt.cs.config.ConnectConf;
+import org.apache.rocketmq.mqtt.cs.session.Session;
+import org.apache.rocketmq.mqtt.cs.session.infly.InFlyCache;
+import org.apache.rocketmq.mqtt.cs.session.infly.MqttMsgId;
+import org.apache.rocketmq.mqtt.cs.session.infly.PushAction;
+import org.apache.rocketmq.mqtt.cs.session.infly.RetryDriver;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Spy;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(MockitoJUnitRunner.class)
+public class TestPushAction {
+    @Mock
+    private MqttMsgId mqttMsgId;
+
+    @Mock
+    private RetryDriver retryDriver;
+
+    @Mock
+    private InFlyCache inFlyCache;
+
+    @Mock
+    private ConnectConf connectConf;
+
+    @Mock
+    private Session session;
+
+    @Mock
+    private Queue queue;
+
+    @Mock
+    private Message message;
+
+    @Spy
+    private NioSocketChannel channel;
+
+    @Spy
+    private ChannelFuture channelFuture;
+
+    private PushAction pushAction;
+    private Subscription subscription;
+
+    final String p2pTopic = "/p2p/test";
+    final String channelId = "testPushAction";
+    final int qos = 1;
+    final int mqttId = 666;
+    final long offset = 3;
+
+    @Before
+    public void before() throws IllegalAccessException {
+        subscription = new Subscription(p2pTopic, qos);
+        pushAction = new PushAction();
+        FieldUtils.writeDeclaredField(pushAction, "mqttMsgId", mqttMsgId, true);
+        FieldUtils.writeDeclaredField(pushAction, "retryDriver", retryDriver, true);
+        FieldUtils.writeDeclaredField(pushAction, "inFlyCache", inFlyCache, true);
+        FieldUtils.writeDeclaredField(pushAction, "connectConf", connectConf, true);
+
+        when(session.getChannel()).thenReturn(channel);
+        when(session.getChannelId()).thenReturn(channelId);
+        when(session.getClientId()).thenReturn(channelId);
+        when(message.getOffset()).thenReturn(offset);
+    }
+
+    @Test
+    public void testMessageArriveNotOrder() {
+        List<Message> messages = new ArrayList<>(Arrays.asList(message));
+        when(session.pendMessageList(any(), any())).thenReturn(messages);
+        when(connectConf.isOrder()).thenReturn(false);
+        PushAction spyPushAction = spy(pushAction);
+        doNothing().when(spyPushAction).push(any(), any(), any(), any());
+
+        spyPushAction.messageArrive(session, subscription, queue);
+        verify(connectConf).isOrder();
+        verify(session).pendMessageList(any(), any());
+        verify(spyPushAction, times(messages.size())).push(any(), any(), any(), any());
+        verifyNoMoreInteractions(session, connectConf);
+    }
+
+    @Test
+    public void testMessageArriveByOrder() {
+        when(connectConf.isOrder()).thenReturn(true);
+        when(retryDriver.needRetryBefore(any(), any(), any())).thenReturn(false);
+        when(session.nextSendMessageByOrder(any(), any())).thenReturn(message);
+        PushAction spyPushAction = spy(pushAction);
+        doNothing().when(spyPushAction).push(any(), any(), any(), any());
+
+        spyPushAction.messageArrive(session, subscription, queue);
+        verify(connectConf).isOrder();
+        verify(retryDriver).needRetryBefore(any(), any(), any());
+        verify(session).nextSendMessageByOrder(any(), any());
+        verify(spyPushAction).push(any(), any(), any(), any());
+        verifyNoMoreInteractions(session, connectConf);
+    }
+
+    @Test
+    public void testPushWhenNotClean() {
+        when(session.isClean()).thenReturn(false);
+        PushAction spyPushAction = spy(pushAction);
+        doNothing().when(spyPushAction).write(any(), any(), anyInt(), anyInt(), any());
+        when(inFlyCache.getPendingDownCache()).thenReturn(new InFlyCache().getPendingDownCache());
+
+        spyPushAction.push(message, subscription, session, queue);
+        verify(spyPushAction).write(any(), any(), anyInt(), anyInt(), any());
+    }
+
+    @Test
+    public void testPushWhenIsClean() {
+        when(session.isClean()).thenReturn(true);
+        long msgStoreTime = 1000;
+        long sessionStartTime = 2000;
+        when(message.getStoreTimestamp()).thenReturn(msgStoreTime);
+        when(session.getStartTime()).thenReturn(sessionStartTime);
+
+        PushAction spyPushAction = spy(pushAction);
+        doNothing().when(spyPushAction).rollNext(any(), anyInt());
+        when(inFlyCache.getPendingDownCache()).thenReturn(new InFlyCache().getPendingDownCache());
+
+        spyPushAction.push(message, subscription, session, queue);
+        verify(spyPushAction).rollNext(any(), anyInt());
+        verify(spyPushAction, times(0)).write(any(), any(), anyInt(), anyInt(), any());
+    }
+
+    @Test
+    public void testPushWhenQosZero() {
+        subscription.setQos(0);
+        when(session.isClean()).thenReturn(false);
+        PushAction spyPushAction = spy(pushAction);
+        doNothing().when(spyPushAction).write(any(), any(), anyInt(), anyInt(), any());
+        doNothing().when(spyPushAction).rollNextByAck(any(), anyInt());
+        when(inFlyCache.getPendingDownCache()).thenReturn(new InFlyCache().getPendingDownCache());
+
+        spyPushAction.push(message, subscription, session, queue);
+        verify(spyPushAction).write(any(), any(), anyInt(), anyInt(), any());
+        verify(spyPushAction).rollNextByAck(any(), anyInt());
+    }
+
+    @Test
+    public void testWrite() {
+        doReturn(channelFuture).when(channel).writeAndFlush(any());
+        when(message.getOriginTopic()).thenReturn(p2pTopic);
+        when(message.getPayload()).thenReturn("test".getBytes(StandardCharsets.UTF_8));
+
+        pushAction.write(session, message, mqttId, qos, subscription);
+        verify(channel).writeAndFlush(any());
+        verify(channelFuture).addListener(any());
+    }
+
+    @Test
+    public void testRollNextByAck() {
+        doNothing().when(mqttMsgId).releaseId(anyInt(), anyString());
+        InFlyCache.PendingDownCache cache = new InFlyCache().getPendingDownCache();
+        cache.put(channelId, mqttId, subscription, queue, message);
+        when(inFlyCache.getPendingDownCache()).thenReturn(cache);
+        when(connectConf.isOrder()).thenReturn(true);
+        when(session.rollNext(subscription, queue, offset)).thenReturn(message);
+
+        PushAction spyPushAction = spy(pushAction);
+        doNothing().when(spyPushAction).push(any(), any(), any(), any());
+
+        spyPushAction.rollNextByAck(session, mqttId);
+        verify(spyPushAction).rollNextByAck(any(), anyInt());
+        verify(spyPushAction).rollNext(any(), anyInt());
+        verify(spyPushAction)._rollNext(any(), any());
+        verify(spyPushAction).push(any(), any(), any(), any());
+        verify(mqttMsgId, times(2)).releaseId(anyInt(), anyString());
+        verify(inFlyCache, times(2)).getPendingDownCache();
+        verifyNoMoreInteractions(spyPushAction, mqttMsgId, inFlyCache);
+    }
+
+    @Test
+    public void testRollNexNoWaitRetry() {
+        when(inFlyCache.getPendingDownCache()).thenReturn(new InFlyCache().getPendingDownCache());
+        PushAction spyPushAction = spy(pushAction);
+        spyPushAction.rollNextNoWaitRetry(session, 666);
+        verify(spyPushAction).rollNextNoWaitRetry(any(), anyInt());
+        verifyNoMoreInteractions(spyPushAction);
+    }
+
+    @Test
+    public void testRollNextIsNotOrder() {
+        InFlyCache.PendingDown pendingDown = new InFlyCache().getPendingDownCache().put(
+            channelId, mqttId, subscription, queue, message);
+        when(connectConf.isOrder()).thenReturn(false);
+
+        pushAction._rollNext(session, pendingDown);
+        verify(session).ack(eq(subscription), eq(queue), eq(offset));
+        verifyNoMoreInteractions(session);
+    }
+
+}
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestRetryDriver.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestRetryDriver.java
similarity index 98%
rename from mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestRetryDriver.java
rename to mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestRetryDriver.java
index b2e9cd4..76ab6c5 100644
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestRetryDriver.java
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/infly/TestRetryDriver.java
@@ -17,7 +17,7 @@
  *
  */
 
-package org.apache.rocketmq.mqtt.cs.test;
+package org.apache.rocketmq.mqtt.cs.test.session.infly;
 
 import org.apache.commons.lang3.reflect.FieldUtils;
 import org.apache.commons.lang3.reflect.MethodUtils;
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestQueueCache.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/loop/TestQueueCache.java
similarity index 98%
rename from mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestQueueCache.java
rename to mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/loop/TestQueueCache.java
index d0d736f..845192c 100644
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestQueueCache.java
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/loop/TestQueueCache.java
@@ -17,7 +17,7 @@
  *
  */
 
-package org.apache.rocketmq.mqtt.cs.test;
+package org.apache.rocketmq.mqtt.cs.test.session.loop;
 
 import org.apache.commons.lang3.reflect.FieldUtils;
 import org.apache.commons.lang3.tuple.Pair;
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestSessionLoopImpl.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/loop/TestSessionLoopImpl.java
similarity index 99%
rename from mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestSessionLoopImpl.java
rename to mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/loop/TestSessionLoopImpl.java
index 32bdd7e..79a0d15 100644
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestSessionLoopImpl.java
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/loop/TestSessionLoopImpl.java
@@ -17,7 +17,7 @@
  *
  */
 
-package org.apache.rocketmq.mqtt.cs.test;
+package org.apache.rocketmq.mqtt.cs.test.session.loop;
 
 import io.netty.channel.socket.nio.NioSocketChannel;
 import org.apache.commons.lang3.reflect.FieldUtils;
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestMatchAction.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/match/TestMatchAction.java
similarity index 50%
rename from mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestMatchAction.java
rename to mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/match/TestMatchAction.java
index 0369b70..cc15ec9 100644
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestMatchAction.java
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/match/TestMatchAction.java
@@ -17,7 +17,7 @@
  *
  */
 
-package org.apache.rocketmq.mqtt.cs.test;
+package org.apache.rocketmq.mqtt.cs.test.session.match;
 
 import org.apache.commons.lang3.reflect.FieldUtils;
 import org.apache.commons.lang3.tuple.Pair;
@@ -26,44 +26,82 @@ import org.apache.rocketmq.mqtt.cs.session.Session;
 import org.apache.rocketmq.mqtt.cs.session.loop.SessionLoop;
 import org.apache.rocketmq.mqtt.cs.session.match.MatchAction;
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
 
-import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
 import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 @RunWith(MockitoJUnitRunner.class)
 public class TestMatchAction {
 
+    private MatchAction matchAction;
+    private Subscription subscription;
+    private Set<Subscription> subscriptionSet;
+    private Set<Pair<Session, Subscription>> set;
+
+    final String channelId = "testMatchAction";
+    final String testTopic = "test";
+    final String p2pTopic = "/p2p/test";
+    final String retryTopic = "/retry/test";
+    final String p2pSecondTopic = "test/p2p/test";
+
+    @Mock
+    private Session session;
+
     @Mock
     private SessionLoop sessionLoop;
 
-    @Test
-    public void test() throws IllegalAccessException {
-        MatchAction matchAction = new MatchAction();
+    @Before
+    public void setUp() throws Exception {
+        matchAction = new MatchAction();
         FieldUtils.writeDeclaredField(matchAction, "sessionLoop", sessionLoop, true);
 
-        Session session = mock(Session.class);
-        when(session.getChannelId()).thenReturn("test");
+        subscription = new Subscription(testTopic);
+        subscriptionSet = new HashSet<>(Collections.singletonList(subscription));
+    }
+
+    @Test
+    public void testNormalTopic() {
+        when(session.getChannelId()).thenReturn(channelId);
         when(sessionLoop.getSession(any())).thenReturn(session);
-        Subscription subscription = new Subscription("test");
-        Set<Subscription> subscriptions = new HashSet<>(Arrays.asList(subscription));
-        when(session.subscriptionSnapshot()).thenReturn(subscriptions);
+        when(session.subscriptionSnapshot()).thenReturn(subscriptionSet);
 
-        matchAction.addSubscription(session, subscriptions);
-        Set<Pair<Session, Subscription>> set =  matchAction.matchClients("test","");
+        matchAction.addSubscription(session, subscriptionSet);
+        set = matchAction.matchClients(testTopic, "");
         Assert.assertFalse(set.isEmpty());
 
-        matchAction.removeSubscription(session,subscriptions);
-        set =  matchAction.matchClients("test","");
+        matchAction.removeSubscription(session, subscriptionSet);
+        set = matchAction.matchClients(testTopic, "");
         Assert.assertTrue(set.isEmpty());
     }
 
+    @Test
+    public void testRetryTopic() {
+        when(sessionLoop.getSessionList(any())).thenReturn(Collections.singletonList(session));
+        set = matchAction.matchClients(retryTopic,"");
+        Assert.assertFalse(set.isEmpty());
+    }
+
+    @Test
+    public void testP2pTopic() {
+        when(sessionLoop.getSessionList(any())).thenReturn(Collections.singletonList(session));
+        set = matchAction.matchClients(p2pTopic, "");
+        Assert.assertFalse(set.isEmpty());
+    }
+
+    @Test
+    public void testP2pSecondTopic() {
+        when(sessionLoop.getSessionList(any())).thenReturn(Collections.singletonList(session));
+        set = matchAction.matchClients(p2pSecondTopic, "");
+        Assert.assertFalse(set.isEmpty());
+    }
+
 }
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestMessageNotifyAction.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/notify/TestMessageNotifyAction.java
similarity index 98%
rename from mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestMessageNotifyAction.java
rename to mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/notify/TestMessageNotifyAction.java
index 36d251a..002a47b 100644
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestMessageNotifyAction.java
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/session/notify/TestMessageNotifyAction.java
@@ -17,7 +17,7 @@
  *
  */
 
-package org.apache.rocketmq.mqtt.cs.test;
+package org.apache.rocketmq.mqtt.cs.test.session.notify;
 
 import org.apache.commons.lang3.reflect.FieldUtils;
 import org.apache.rocketmq.mqtt.common.model.MessageEvent;
