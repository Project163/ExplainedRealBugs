diff --git a/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/MqttPacketDispatcher.java b/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/MqttPacketDispatcher.java
index 5acf48d..3b6623c 100644
--- a/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/MqttPacketDispatcher.java
+++ b/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/MqttPacketDispatcher.java
@@ -35,7 +35,6 @@ import org.apache.rocketmq.mqtt.common.util.HostInfo;
 import org.apache.rocketmq.mqtt.cs.channel.ChannelDecodeException;
 import org.apache.rocketmq.mqtt.cs.channel.ChannelException;
 import org.apache.rocketmq.mqtt.cs.channel.ChannelInfo;
-import org.apache.rocketmq.mqtt.cs.channel.ChannelManager;
 import org.apache.rocketmq.mqtt.cs.protocol.mqtt.handler.MqttConnectHandler;
 import org.apache.rocketmq.mqtt.cs.protocol.mqtt.handler.MqttDisconnectHandler;
 import org.apache.rocketmq.mqtt.cs.protocol.mqtt.handler.MqttPingHandler;
@@ -92,9 +91,6 @@ public class MqttPacketDispatcher extends SimpleChannelInboundHandler<MqttMessag
     @Resource
     private UpstreamHookManager upstreamHookManager;
 
-    @Resource
-    private ChannelManager channelManager;
-
     @Override
     protected void channelRead0(ChannelHandlerContext ctx, MqttMessage msg) throws Exception {
         if (!ctx.channel().isActive()) {
diff --git a/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/handler/MqttSubscribeHandler.java b/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/handler/MqttSubscribeHandler.java
index 59e167f..7d37402 100644
--- a/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/handler/MqttSubscribeHandler.java
+++ b/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/handler/MqttSubscribeHandler.java
@@ -34,7 +34,6 @@ import org.apache.rocketmq.mqtt.common.util.TopicUtils;
 import org.apache.rocketmq.mqtt.cs.channel.ChannelCloseFrom;
 import org.apache.rocketmq.mqtt.cs.channel.ChannelInfo;
 import org.apache.rocketmq.mqtt.cs.channel.ChannelManager;
-import org.apache.rocketmq.mqtt.cs.config.ConnectConf;
 import org.apache.rocketmq.mqtt.cs.protocol.mqtt.MqttPacketHandler;
 import org.apache.rocketmq.mqtt.cs.session.loop.SessionLoop;
 import org.slf4j.Logger;
@@ -54,21 +53,16 @@ import static io.netty.handler.codec.mqtt.MqttMessageType.SUBACK;
 import static io.netty.handler.codec.mqtt.MqttQoS.AT_MOST_ONCE;
 
 
-
 @Component
 public class MqttSubscribeHandler implements MqttPacketHandler<MqttSubscribeMessage> {
     private static Logger logger = LoggerFactory.getLogger(MqttSubscribeHandler.class);
 
-
     @Resource
     private SessionLoop sessionLoop;
 
     @Resource
     private ChannelManager channelManager;
 
-    @Resource
-    private ConnectConf connectConf;
-
     private ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1, new ThreadFactoryImpl("check_subscribe_future"));
 
     @Override
@@ -113,7 +107,6 @@ public class MqttSubscribeHandler implements MqttPacketHandler<MqttSubscribeMess
         }
     }
 
-
     private MqttSubAckMessage getResponse(MqttSubscribeMessage mqttSubscribeMessage) {
         MqttSubscribePayload payload = mqttSubscribeMessage.payload();
         List<MqttTopicSubscription> mqttTopicSubscriptions = payload.topicSubscriptions();
diff --git a/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/handler/MqttUnSubscribeHandler.java b/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/handler/MqttUnSubscribeHandler.java
index efc144f..73b8c1f 100644
--- a/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/handler/MqttUnSubscribeHandler.java
+++ b/mqtt-cs/src/main/java/org/apache/rocketmq/mqtt/cs/protocol/mqtt/handler/MqttUnSubscribeHandler.java
@@ -17,7 +17,6 @@
 
 package org.apache.rocketmq.mqtt.cs.protocol.mqtt.handler;
 
-
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.mqtt.MqttFixedHeader;
@@ -44,12 +43,10 @@ import java.util.Set;
 import static io.netty.handler.codec.mqtt.MqttMessageType.UNSUBACK;
 import static io.netty.handler.codec.mqtt.MqttQoS.AT_MOST_ONCE;
 
-
 @Component
 public class MqttUnSubscribeHandler implements MqttPacketHandler<MqttUnsubscribeMessage> {
     private static Logger logger = LoggerFactory.getLogger(MqttUnSubscribeHandler.class);
 
-
     @Resource
     private SessionLoop sessionLoop;
 
@@ -58,7 +55,6 @@ public class MqttUnSubscribeHandler implements MqttPacketHandler<MqttUnsubscribe
 
     @Override
     public void doHandler(ChannelHandlerContext ctx, MqttUnsubscribeMessage mqttMessage, HookResult upstreamHookResult) {
-        long start = System.currentTimeMillis();
         String clientId = ChannelInfo.getClientId(ctx.channel());
         Channel channel = ctx.channel();
         String remark = upstreamHookResult.getRemark();
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestConnectHandler.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestConnectHandler.java
deleted file mode 100644
index 87bb6bf..0000000
--- a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/TestConnectHandler.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- *
- *  * Licensed to the Apache Software Foundation (ASF) under one or more
- *  * contributor license agreements.  See the NOTICE file distributed with
- *  * this work for additional information regarding copyright ownership.
- *  * The ASF licenses this file to You under the Apache License, Version 2.0
- *  * (the "License"); you may not use this file except in compliance with
- *  * the License.  You may obtain a copy of the License at
- *  *
- *  *     http://www.apache.org/licenses/LICENSE-2.0
- *  *
- *  * Unless required by applicable law or agreed to in writing, software
- *  * distributed under the License is distributed on an "AS IS" BASIS,
- *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  * See the License for the specific language governing permissions and
- *  * limitations under the License.
- *
- */
-
-package org.apache.rocketmq.mqtt.cs.test;
-
-import org.apache.commons.lang3.reflect.FieldUtils;
-import org.apache.rocketmq.mqtt.cs.channel.ChannelCloseFrom;
-import org.apache.rocketmq.mqtt.cs.channel.ChannelManager;
-import org.apache.rocketmq.mqtt.cs.channel.ConnectHandler;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.junit.MockitoJUnitRunner;
-import org.slf4j.Logger;
-
-import static org.mockito.ArgumentMatchers.*;
-import static org.mockito.Mockito.*;
-
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandlerContext;
-
-@RunWith(MockitoJUnitRunner.class)
-public class TestConnectHandler {
-
-    @Mock
-    private ChannelHandlerContext ctx;
-    @Mock
-    private Logger logger;
-    @Mock
-    private Channel channel;
-    @Mock
-    private ChannelManager channelManager;
-
-    @Test
-    public void test() throws Exception {
-        ConnectHandler connectHandler=new ConnectHandler();
-        Throwable throwable=new Exception("Connection reset by peer");
-        when(ctx.channel()).thenReturn(channel);
-        FieldUtils.writeDeclaredField(connectHandler,"channelManager",channelManager,true);
-        FieldUtils.writeDeclaredField(connectHandler,"logger",logger,true);
-        connectHandler.exceptionCaught(ctx,throwable);
-        verify(logger,never()).error(anyString(),any(),any());
-        verify(channelManager).closeConnect(channel,ChannelCloseFrom.SERVER, throwable.getMessage());
-
-        connectHandler.exceptionCaught(ctx,new Exception("test exception"));
-        verify(logger,only()).error(anyString(),any(),any());
-        verify(channelManager).closeConnect(channel,ChannelCloseFrom.SERVER, throwable.getMessage());
-    }
-}
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/mqtt/TestMqttPacketDispatcher.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/mqtt/TestMqttPacketDispatcher.java
new file mode 100644
index 0000000..d5bcd1b
--- /dev/null
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/mqtt/TestMqttPacketDispatcher.java
@@ -0,0 +1,121 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.mqtt.cs.test.protocol.mqtt;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.DecoderResult;
+import io.netty.handler.codec.mqtt.MqttFixedHeader;
+import io.netty.handler.codec.mqtt.MqttMessage;
+import io.netty.handler.codec.mqtt.MqttMessageType;
+import io.netty.handler.codec.mqtt.MqttQoS;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.commons.lang3.reflect.MethodUtils;
+import org.apache.rocketmq.mqtt.common.hook.HookResult;
+import org.apache.rocketmq.mqtt.common.hook.UpstreamHookManager;
+import org.apache.rocketmq.mqtt.cs.protocol.mqtt.MqttPacketDispatcher;
+import org.apache.rocketmq.mqtt.cs.protocol.mqtt.handler.MqttPingHandler;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Spy;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.concurrent.CompletableFuture;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(MockitoJUnitRunner.class)
+public class TestMqttPacketDispatcher {
+    private CompletableFuture<HookResult> upstreamHookResult = new CompletableFuture<>();
+
+    private MqttPacketDispatcher packetDispatcher;
+    private MqttFixedHeader mqttFixedHeader;
+    private MqttMessage mqttMessage;
+
+    @Spy
+    private NioSocketChannel channel;
+
+    @Mock
+    private ChannelHandlerContext ctx;
+
+    @Mock
+    private UpstreamHookManager upstreamHookManager;
+
+    @Mock
+    private MqttPingHandler mqttPingHandler;
+
+    @Before
+    public void setUp() throws Exception {
+        packetDispatcher = new MqttPacketDispatcher();
+        mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PINGREQ, false, MqttQoS.AT_MOST_ONCE, false, 0);
+        FieldUtils.writeDeclaredField(packetDispatcher, "upstreamHookManager", upstreamHookManager, true);
+        FieldUtils.writeDeclaredField(packetDispatcher, "mqttPingHandler", mqttPingHandler, true);
+
+        when(ctx.channel()).thenReturn(channel);
+        doReturn(true).when(channel).isActive();
+    }
+
+    @Test
+    public void testRead0ChannelInActive() throws Exception {
+        mqttMessage = new MqttMessage(mqttFixedHeader, null, null, DecoderResult.SUCCESS);
+        doReturn(false).when(channel).isActive();
+
+        MethodUtils.invokeMethod(packetDispatcher, true, "channelRead0", ctx, mqttMessage);
+
+        verify(ctx).channel();
+        verify(channel).isActive();
+        verifyNoMoreInteractions(ctx, channel, upstreamHookManager, mqttPingHandler);
+    }
+
+    @Test (expected = InvocationTargetException.class)
+    public void testRead0DecoderFail() throws Exception {
+        mqttMessage = new MqttMessage(mqttFixedHeader, null, null, DecoderResult.UNFINISHED);
+        MethodUtils.invokeMethod(packetDispatcher, true, "channelRead0", ctx, mqttMessage);
+    }
+
+    @Test
+    public void testRead0Success() throws Exception {
+        mqttMessage = new MqttMessage(mqttFixedHeader, null, null, DecoderResult.SUCCESS);
+        doReturn(upstreamHookResult).when(upstreamHookManager).doUpstreamHook(any(), any());
+        upstreamHookResult.complete(new HookResult(HookResult.SUCCESS, -1, null, null));
+
+        MethodUtils.invokeMethod(packetDispatcher, true, "channelRead0", ctx, mqttMessage);
+
+        // include ctx.channel within buildMqttMessageUpContext
+        verify(ctx, times(3)).channel();
+        verify(channel).isActive();
+        verify(upstreamHookManager).doUpstreamHook(any(), any());
+        verify(mqttPingHandler).doHandler(eq(ctx), any(), any());
+        verifyNoMoreInteractions(ctx, upstreamHookManager, mqttPingHandler);
+    }
+
+    @Test
+    public void testBuildMqttMessageUpContext() {
+        packetDispatcher.buildMqttMessageUpContext(ctx);
+        verify(ctx).channel();
+    }
+}
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/mqtt/handler/TestMqttSubscribeHandler.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/mqtt/handler/TestMqttSubscribeHandler.java
new file mode 100644
index 0000000..306f433
--- /dev/null
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/mqtt/handler/TestMqttSubscribeHandler.java
@@ -0,0 +1,148 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.mqtt.cs.test.protocol.mqtt.handler;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
+import io.netty.handler.codec.mqtt.MqttFixedHeader;
+import io.netty.handler.codec.mqtt.MqttMessageIdVariableHeader;
+import io.netty.handler.codec.mqtt.MqttMessageType;
+import io.netty.handler.codec.mqtt.MqttQoS;
+import io.netty.handler.codec.mqtt.MqttSubAckMessage;
+import io.netty.handler.codec.mqtt.MqttSubscribeMessage;
+import io.netty.handler.codec.mqtt.MqttSubscribePayload;
+import io.netty.handler.codec.mqtt.MqttTopicSubscription;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.rocketmq.mqtt.common.hook.HookResult;
+import org.apache.rocketmq.mqtt.common.model.Remark;
+import org.apache.rocketmq.mqtt.cs.channel.ChannelCloseFrom;
+import org.apache.rocketmq.mqtt.cs.channel.DefaultChannelManager;
+import org.apache.rocketmq.mqtt.cs.protocol.mqtt.handler.MqttSubscribeHandler;
+import org.apache.rocketmq.mqtt.cs.session.loop.SessionLoop;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Spy;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.util.ArrayList;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anySet;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(MockitoJUnitRunner.class)
+public class TestMqttSubscribeHandler {
+    private final int messageId = 666;
+    private final MqttMessageIdVariableHeader idVariableHeader = MqttMessageIdVariableHeader.from(messageId);
+    private final String topicFilter = "test/subscribe/#/";
+
+    private MqttSubscribeHandler subscribeHandler;
+    private MqttFixedHeader mqttFixedHeader;
+    private MqttSubscribeMessage subscribeMessage;
+    private MqttSubscribePayload subscribePayload;
+    private MqttTopicSubscription topicSubscription;
+    private ArrayList<MqttTopicSubscription> subscriptionsList;
+
+    @Spy
+    private NioSocketChannel channel;
+
+    @Mock
+    private ChannelHandlerContext ctx;
+
+    @Mock
+    private DefaultChannelManager channelManager;
+
+    @Mock
+    private SessionLoop sessionLoop;
+
+    @Before
+    public void setUp() throws Exception {
+        mqttFixedHeader = new MqttFixedHeader(MqttMessageType.SUBSCRIBE, false, MqttQoS.AT_MOST_ONCE, false, 0);
+        topicSubscription = new MqttTopicSubscription(topicFilter, MqttQoS.AT_LEAST_ONCE);
+        subscriptionsList = new ArrayList<>();
+        subscriptionsList.add(topicSubscription);
+        subscribePayload = new MqttSubscribePayload(subscriptionsList);
+        subscribeMessage = new MqttSubscribeMessage(mqttFixedHeader, idVariableHeader, subscribePayload);
+
+        subscribeHandler = new MqttSubscribeHandler();
+        FieldUtils.writeDeclaredField(subscribeHandler, "channelManager", channelManager, true);
+        FieldUtils.writeDeclaredField(subscribeHandler, "sessionLoop", sessionLoop, true);
+
+        when(ctx.channel()).thenReturn(channel);
+    }
+
+    @Test
+    public void testDoHandlerAuthFailed() {
+        HookResult authFailHook = new HookResult(HookResult.FAIL,
+                MqttConnectReturnCode.CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD.byteValue(), Remark.AUTH_FAILED, null);
+        doNothing().when(channelManager).closeConnect(channel, ChannelCloseFrom.SERVER, Remark.AUTH_FAILED);
+
+        subscribeHandler.doHandler(ctx, subscribeMessage, authFailHook);
+
+        verify(ctx, times(2)).channel();
+        verify(channelManager).closeConnect(channel, ChannelCloseFrom.SERVER, Remark.AUTH_FAILED);
+        verifyNoMoreInteractions(channelManager, sessionLoop, ctx);
+    }
+
+    @Test
+    public void testDoHandlerChannelInActive() {
+        HookResult hookResult = new HookResult(HookResult.SUCCESS, Remark.SUCCESS, null);
+        doReturn(false).when(channel).isActive();
+        doNothing().when(sessionLoop).addSubscription(anyString(), anySet());
+
+        subscribeHandler.doHandler(ctx, subscribeMessage, hookResult);
+
+        // wait scheduler execution
+        try {
+            Thread.sleep(2000);
+        } catch (InterruptedException ignored) {}
+
+        verify(ctx, times(3)).channel();
+        verify(sessionLoop).addSubscription(anyString(), anySet());
+        verifyNoMoreInteractions(channelManager, sessionLoop, ctx);
+    }
+
+    @Test
+    public void testDoHandlerSuccess() {
+        HookResult hookResult = new HookResult(HookResult.SUCCESS, Remark.SUCCESS, null);
+        doReturn(true).when(channel).isActive();
+        doNothing().when(sessionLoop).addSubscription(anyString(), anySet());
+
+        subscribeHandler.doHandler(ctx, subscribeMessage, hookResult);
+
+        // wait scheduler execution
+        try {
+            Thread.sleep(2000);
+        } catch (InterruptedException ignored) {}
+
+        verify(ctx, times(3)).channel();
+        verify(sessionLoop).addSubscription(anyString(), anySet());
+        verify(channel).writeAndFlush(any(MqttSubAckMessage.class));
+        verifyNoMoreInteractions(channelManager, sessionLoop, ctx);
+    }
+
+}
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/mqtt/handler/TestMqttUnSubscribeHandler.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/mqtt/handler/TestMqttUnSubscribeHandler.java
new file mode 100644
index 0000000..b618adc
--- /dev/null
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/mqtt/handler/TestMqttUnSubscribeHandler.java
@@ -0,0 +1,124 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.mqtt.cs.test.protocol.mqtt.handler;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
+import io.netty.handler.codec.mqtt.MqttFixedHeader;
+import io.netty.handler.codec.mqtt.MqttMessageIdVariableHeader;
+import io.netty.handler.codec.mqtt.MqttMessageType;
+import io.netty.handler.codec.mqtt.MqttQoS;
+import io.netty.handler.codec.mqtt.MqttUnsubAckMessage;
+import io.netty.handler.codec.mqtt.MqttUnsubscribeMessage;
+import io.netty.handler.codec.mqtt.MqttUnsubscribePayload;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.rocketmq.mqtt.common.hook.HookResult;
+import org.apache.rocketmq.mqtt.common.model.Remark;
+import org.apache.rocketmq.mqtt.cs.channel.ChannelCloseFrom;
+import org.apache.rocketmq.mqtt.cs.channel.DefaultChannelManager;
+import org.apache.rocketmq.mqtt.cs.protocol.mqtt.handler.MqttUnSubscribeHandler;
+import org.apache.rocketmq.mqtt.cs.session.loop.SessionLoop;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Spy;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anySet;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(MockitoJUnitRunner.class)
+public class TestMqttUnSubscribeHandler {
+    private final int messageId = 666;
+    private final MqttMessageIdVariableHeader idVariableHeader = MqttMessageIdVariableHeader.from(messageId);
+    private final String topicFilter = "test/unSubscribe/#/";
+
+    private MqttFixedHeader mqttFixedHeader;
+    private MqttUnsubscribePayload unsubscribePayload;
+    private MqttUnsubscribeMessage unsubscribeMessage;
+    private List<String> topicList;
+
+    private MqttUnSubscribeHandler unSubscribeHandler;
+
+    @Spy
+    private NioSocketChannel channel;
+
+    @Mock
+    private ChannelHandlerContext ctx;
+
+    @Mock
+    private DefaultChannelManager channelManager;
+
+    @Mock
+    private SessionLoop sessionLoop;
+
+    @Before
+    public void setUp() throws Exception {
+        mqttFixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBSCRIBE, false, MqttQoS.AT_MOST_ONCE, false, 0);
+        topicList = new ArrayList<>();
+        topicList.add(topicFilter);
+        unsubscribePayload = new MqttUnsubscribePayload(topicList);
+        unsubscribeMessage = new MqttUnsubscribeMessage(mqttFixedHeader, idVariableHeader, unsubscribePayload);
+
+        unSubscribeHandler = new MqttUnSubscribeHandler();
+        FieldUtils.writeDeclaredField(unSubscribeHandler, "channelManager", channelManager, true);
+        FieldUtils.writeDeclaredField(unSubscribeHandler, "sessionLoop", sessionLoop, true);
+
+        when(ctx.channel()).thenReturn(channel);
+    }
+
+    @Test
+    public void testDoHandlerAuthFailed() {
+        HookResult authFailHook = new HookResult(HookResult.FAIL,
+                MqttConnectReturnCode.CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD.byteValue(), Remark.AUTH_FAILED, null);
+        doNothing().when(channelManager).closeConnect(channel, ChannelCloseFrom.SERVER, Remark.AUTH_FAILED);
+
+        unSubscribeHandler.doHandler(ctx, unsubscribeMessage, authFailHook);
+
+        verify(ctx, times(2)).channel();
+        verify(channelManager).closeConnect(channel, ChannelCloseFrom.SERVER, Remark.AUTH_FAILED);
+        verifyNoMoreInteractions(channelManager, sessionLoop, ctx);
+    }
+
+    @Test
+    public void testDoHandlerSuccess() {
+        HookResult hookResult = new HookResult(HookResult.SUCCESS, Remark.SUCCESS, null);
+        doNothing().when(sessionLoop).removeSubscription(anyString(), anySet());
+        doReturn(null).when(channel).writeAndFlush(any(MqttUnsubAckMessage.class));
+
+        unSubscribeHandler.doHandler(ctx, unsubscribeMessage, hookResult);
+
+        verify(ctx, times(3)).channel();
+        verify(sessionLoop).removeSubscription(anyString(), anySet());
+        verify(channel).writeAndFlush(any(MqttUnsubAckMessage.class));
+        verifyNoMoreInteractions(channelManager, sessionLoop, ctx);
+    }
+
+}
\ No newline at end of file
diff --git a/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/rpc/TestRpcPacketDispatcher.java b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/rpc/TestRpcPacketDispatcher.java
new file mode 100644
index 0000000..548be02
--- /dev/null
+++ b/mqtt-cs/src/test/java/org/apache/rocketmq/mqtt/cs/test/protocol/rpc/TestRpcPacketDispatcher.java
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.mqtt.cs.test.protocol.rpc;
+
+import com.alibaba.fastjson.JSON;
+import io.netty.channel.ChannelHandlerContext;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.rocketmq.mqtt.common.model.RpcCode;
+import org.apache.rocketmq.mqtt.cs.channel.ChannelManager;
+import org.apache.rocketmq.mqtt.cs.protocol.rpc.RpcPacketDispatcher;
+import org.apache.rocketmq.mqtt.cs.session.notify.MessageNotifyAction;
+import org.apache.rocketmq.remoting.protocol.RemotingCommand;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.util.HashSet;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyList;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(MockitoJUnitRunner.class)
+public class TestRpcPacketDispatcher {
+    private RemotingCommand notifyCommand = RemotingCommand.createResponseCommand(RpcCode.CMD_NOTIFY_MQTT_MESSAGE, null);
+    private RemotingCommand closeCommand = RemotingCommand.createResponseCommand(RpcCode.CMD_CLOSE_CHANNEL, null);
+
+    private RpcPacketDispatcher packetDispatcher;
+
+    @Mock
+    private MessageNotifyAction messageNotifyAction;
+
+    @Mock
+    private ChannelManager channelManager;
+
+    @Mock
+    private ChannelHandlerContext ctx;
+
+    @Before
+    public void setUp() throws Exception {
+        packetDispatcher = new RpcPacketDispatcher();
+        FieldUtils.writeDeclaredField(packetDispatcher, "messageNotifyAction", messageNotifyAction, true);
+        FieldUtils.writeDeclaredField(packetDispatcher, "channelManager", channelManager, true);
+    }
+
+    @Test
+    public void testProcessRequestNotify() throws Exception {
+        notifyCommand.setBody(JSON.toJSONBytes(new HashSet<>()));
+        packetDispatcher.processRequest(ctx, notifyCommand);
+
+        verify(messageNotifyAction).notify(anyList());
+        verifyNoMoreInteractions(messageNotifyAction, channelManager, ctx);
+    }
+
+    @Test
+    public void testProcessRequestClose() throws Exception {
+        closeCommand.setBody(JSON.toJSONBytes(new HashSet<>()));
+        packetDispatcher.processRequest(ctx, closeCommand);
+
+        verify(channelManager).closeConnect(any(), any());
+        verifyNoMoreInteractions(messageNotifyAction, channelManager, ctx);
+    }
+
+    @Test
+    public void testProcessRequestFail() throws Exception {
+        // set notifyCommand body null to throw NPE exception
+        RemotingCommand response = packetDispatcher.processRequest(ctx, notifyCommand);
+        Assert.assertEquals(RpcCode.FAIL, response.getCode());
+        verifyNoMoreInteractions(messageNotifyAction, channelManager, ctx);
+    }
+
+    @Test
+    public void testRejectRequest() {
+        Assert.assertFalse(packetDispatcher.rejectRequest());
+    }
+}
