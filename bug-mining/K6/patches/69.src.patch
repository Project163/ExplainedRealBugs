diff --git a/cmd/archive.go b/cmd/archive.go
new file mode 100644
index 000000000..d19d9250b
--- /dev/null
+++ b/cmd/archive.go
@@ -0,0 +1,92 @@
+/*
+ *
+ * k6 - a next-generation load testing tool
+ * Copyright (C) 2016 Load Impact
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+package cmd
+
+import (
+	"os"
+
+	"github.com/spf13/afero"
+	"github.com/spf13/cobra"
+)
+
+var archiveOut = "archive.tar"
+
+// archiveCmd represents the pause command
+var archiveCmd = &cobra.Command{
+	Use:   "archive",
+	Short: "Create an archive",
+	Long: `Create an archive.
+	 
+An archive is a fully self-contained test run, and can be executed identically elsewhere.`,
+	Example: `
+  # Archive a test run.
+  k6 archive -u 10 -d 10s -O myarchive.tar script.js
+  
+  # Run the resulting archive.
+  k6 run myarchive.tar`[1:],
+	Args: cobra.ExactArgs(1),
+	RunE: func(cmd *cobra.Command, args []string) error {
+		// Runner.
+		pwd, err := os.Getwd()
+		if err != nil {
+			return err
+		}
+		filename := args[0]
+		src, err := readSource(filename, pwd, afero.NewOsFs(), os.Stdin)
+		if err != nil {
+			return err
+		}
+		r, err := newRunner(src, runType, afero.NewOsFs())
+		if err != nil {
+			return err
+		}
+
+		// Options.
+		cliConf, err := getConfig(cmd.Flags())
+		if err != nil {
+			return err
+		}
+		fileConf, _, err := readDiskConfig()
+		if err != nil {
+			return err
+		}
+		envConf, err := readEnvConfig()
+		if err != nil {
+			return err
+		}
+		opts := cliConf.Apply(fileConf).Apply(Config{Options: r.GetOptions()}).Apply(envConf).Apply(cliConf).Options
+		r.SetOptions(opts)
+
+		// Archive.
+		arc := r.MakeArchive()
+		f, err := os.Create(archiveOut)
+		if err != nil {
+			return err
+		}
+		return arc.Write(f)
+	},
+}
+
+func init() {
+	RootCmd.AddCommand(archiveCmd)
+	archiveCmd.Flags().AddFlagSet(optionFlagSet())
+	archiveCmd.Flags().StringVarP(&archiveOut, "archive-out", "O", archiveOut, "archive output filename")
+}
diff --git a/cmd/common.go b/cmd/common.go
index d3460a7e8..7ffd3b758 100644
--- a/cmd/common.go
+++ b/cmd/common.go
@@ -61,33 +61,21 @@ func (w consoleWriter) Write(p []byte) (n int, err error) {
 }
 
 func getNullBool(flags *pflag.FlagSet, key string) null.Bool {
-	v, err := flags.GetBool(key)
-	if err != nil {
-		panic(err)
-	}
+	v, _ := flags.GetBool(key)
 	return null.NewBool(v, flags.Changed(key))
 }
 
 func getNullInt64(flags *pflag.FlagSet, key string) null.Int {
-	v, err := flags.GetInt64(key)
-	if err != nil {
-		panic(err)
-	}
+	v, _ := flags.GetInt64(key)
 	return null.NewInt(v, flags.Changed(key))
 }
 
 func getNullDuration(flags *pflag.FlagSet, key string) lib.NullDuration {
-	v, err := flags.GetDuration(key)
-	if err != nil {
-		panic(err)
-	}
+	v, _ := flags.GetDuration(key)
 	return lib.NullDuration{Duration: lib.Duration(v), Valid: flags.Changed(key)}
 }
 
 func getNullString(flags *pflag.FlagSet, key string) null.String {
-	v, err := flags.GetString(key)
-	if err != nil {
-		panic(err)
-	}
+	v, _ := flags.GetString(key)
 	return null.NewString(v, flags.Changed(key))
 }
diff --git a/cmd/config.go b/cmd/config.go
index a20bf5c2f..e297b3a80 100644
--- a/cmd/config.go
+++ b/cmd/config.go
@@ -34,17 +34,16 @@ import (
 
 const configFilename = "config.json"
 
-var (
-	configDirs    = configdir.New("loadimpact", "k6")
-	configFlagSet = pflag.NewFlagSet("", 0)
-)
+var configDirs = configdir.New("loadimpact", "k6")
 
-func init() {
-	configFlagSet.SortFlags = false
-	configFlagSet.StringP("out", "o", "", "`uri` for an external metrics database")
-	configFlagSet.BoolP("linger", "l", false, "keep the API server alive past test end")
-	configFlagSet.Bool("no-usage-report", false, "don't send anonymous stats to the developers")
-	configFlagSet.Bool("no-thresholds", false, "don't run thresholds")
+func configFlagSet() *pflag.FlagSet {
+	flags := pflag.NewFlagSet("", 0)
+	flags.SortFlags = false
+	flags.StringP("out", "o", "", "`uri` for an external metrics database")
+	flags.BoolP("linger", "l", false, "keep the API server alive past test end")
+	flags.Bool("no-usage-report", false, "don't send anonymous stats to the developers")
+	flags.Bool("no-thresholds", false, "don't run thresholds")
+	return flags
 }
 
 type Config struct {
diff --git a/cmd/options.go b/cmd/options.go
index d19ad271f..2220862e0 100644
--- a/cmd/options.go
+++ b/cmd/options.go
@@ -28,24 +28,24 @@ import (
 	"github.com/spf13/pflag"
 )
 
-var optionFlagSet = pflag.NewFlagSet("", 0)
-
-func init() {
-	optionFlagSet.SortFlags = false
-	optionFlagSet.Int64P("vus", "u", 1, "number of virtual users")
-	optionFlagSet.Int64P("max", "m", 0, "max available virtual users")
-	optionFlagSet.DurationP("duration", "d", 0, "test duration limit")
-	optionFlagSet.Int64P("iterations", "i", 0, "script iteration limit")
-	optionFlagSet.StringSliceP("stage", "s", nil, "add a `stage`, as `[duration]:[target]`")
-	optionFlagSet.BoolP("paused", "p", false, "start the test in a paused state")
-	optionFlagSet.Int64("max-redirects", 10, "follow at most n redirects")
-	optionFlagSet.Int64("batch", 10, "max parallel batch reqs")
-	optionFlagSet.Int64("batch-per-host", 0, "max parallel batch reqs per host")
-	optionFlagSet.String("user-agent", "", "user agent for http requests")
-	optionFlagSet.Bool("insecure-skip-tls-verify", false, "skip verification of TLS certificates")
-	optionFlagSet.Bool("no-connection-reuse", false, "don't reuse connections between iterations")
-	optionFlagSet.BoolP("throw", "w", false, "throw warnings (like failed http requests) as errors")
-	optionFlagSet.StringSlice("blacklist-ip", nil, "blacklist an `ip range` from being called")
+func optionFlagSet() *pflag.FlagSet {
+	flags := pflag.NewFlagSet("", 0)
+	flags.SortFlags = false
+	flags.Int64P("vus", "u", 1, "number of virtual users")
+	flags.Int64P("max", "m", 0, "max available virtual users")
+	flags.DurationP("duration", "d", 0, "test duration limit")
+	flags.Int64P("iterations", "i", 0, "script iteration limit")
+	flags.StringSliceP("stage", "s", nil, "add a `stage`, as `[duration]:[target]`")
+	flags.BoolP("paused", "p", false, "start the test in a paused state")
+	flags.Int64("max-redirects", 10, "follow at most n redirects")
+	flags.Int64("batch", 10, "max parallel batch reqs")
+	flags.Int64("batch-per-host", 0, "max parallel batch reqs per host")
+	flags.String("user-agent", "", "user agent for http requests")
+	flags.Bool("insecure-skip-tls-verify", false, "skip verification of TLS certificates")
+	flags.Bool("no-connection-reuse", false, "don't reuse connections between iterations")
+	flags.BoolP("throw", "w", false, "throw warnings (like failed http requests) as errors")
+	flags.StringSlice("blacklist-ip", nil, "blacklist an `ip range` from being called")
+	return flags
 }
 
 func getOptions(flags *pflag.FlagSet) (lib.Options, error) {
diff --git a/cmd/run.go b/cmd/run.go
index de5b9f067..d6d1df010 100644
--- a/cmd/run.go
+++ b/cmd/run.go
@@ -401,8 +401,8 @@ func init() {
 	RootCmd.AddCommand(runCmd)
 
 	runCmd.Flags().SortFlags = false
-	runCmd.Flags().AddFlagSet(optionFlagSet)
-	runCmd.Flags().AddFlagSet(configFlagSet)
+	runCmd.Flags().AddFlagSet(optionFlagSet())
+	runCmd.Flags().AddFlagSet(configFlagSet())
 	runCmd.Flags().StringVarP(&runType, "type", "t", runType, "override file `type`, \"js\" or \"archive\"")
 }
 
