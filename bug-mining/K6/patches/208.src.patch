diff --git a/js/console.go b/js/console.go
index 997db6baf..f81aee73b 100644
--- a/js/console.go
+++ b/js/console.go
@@ -21,7 +21,9 @@
 package js
 
 import (
+	"encoding/json"
 	"os"
+	"reflect"
 	"strings"
 
 	"github.com/dop251/goja"
@@ -52,17 +54,16 @@ func newFileConsole(filepath string, formatter logrus.Formatter) (*console, erro
 	return &console{l}, nil
 }
 
-func (c console) log(level logrus.Level, msgobj goja.Value, args ...goja.Value) {
-	msg := msgobj.String()
-	if len(args) > 0 {
-		strs := make([]string, 1+len(args))
-		strs[0] = msg
-		for i, v := range args {
-			strs[i+1] = v.String()
+func (c console) log(level logrus.Level, args ...goja.Value) {
+	var strs strings.Builder
+	for i := 0; i < len(args); i++ {
+		if i > 0 {
+			strs.WriteString(" ")
 		}
-
-		msg = strings.Join(strs, " ")
+		strs.WriteString(c.valueString(args[i]))
 	}
+	msg := strs.String()
+
 	switch level { //nolint:exhaustive
 	case logrus.DebugLevel:
 		c.logger.Debug(msg)
@@ -75,22 +76,40 @@ func (c console) log(level logrus.Level, msgobj goja.Value, args ...goja.Value)
 	}
 }
 
-func (c console) Log(msg goja.Value, args ...goja.Value) {
-	c.Info(msg, args...)
+func (c console) Log(args ...goja.Value) {
+	c.Info(args...)
 }
 
-func (c console) Debug(msg goja.Value, args ...goja.Value) {
-	c.log(logrus.DebugLevel, msg, args...)
+func (c console) Debug(args ...goja.Value) {
+	c.log(logrus.DebugLevel, args...)
 }
 
-func (c console) Info(msg goja.Value, args ...goja.Value) {
-	c.log(logrus.InfoLevel, msg, args...)
+func (c console) Info(args ...goja.Value) {
+	c.log(logrus.InfoLevel, args...)
 }
 
-func (c console) Warn(msg goja.Value, args ...goja.Value) {
-	c.log(logrus.WarnLevel, msg, args...)
+func (c console) Warn(args ...goja.Value) {
+	c.log(logrus.WarnLevel, args...)
 }
 
-func (c console) Error(msg goja.Value, args ...goja.Value) {
-	c.log(logrus.ErrorLevel, msg, args...)
+func (c console) Error(args ...goja.Value) {
+	c.log(logrus.ErrorLevel, args...)
+}
+
+func (c console) valueString(v goja.Value) string {
+	exptype := v.ExportType()
+	if exptype == nil {
+		return v.String()
+	}
+
+	kind := exptype.Kind()
+	if kind != reflect.Map && kind != reflect.Slice {
+		return v.String()
+	}
+
+	b, err := json.Marshal(v)
+	if err != nil {
+		return v.String()
+	}
+	return string(b)
 }
diff --git a/js/console_test.go b/js/console_test.go
index 35e992f7d..55ccfbb03 100644
--- a/js/console_test.go
+++ b/js/console_test.go
@@ -33,6 +33,7 @@ import (
 	logtest "github.com/sirupsen/logrus/hooks/test"
 	"github.com/spf13/afero"
 	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
 	"gopkg.in/guregu/null.v3"
 
 	"go.k6.io/k6/js/common"
@@ -104,7 +105,69 @@ func extractLogger(fl logrus.FieldLogger) *logrus.Logger {
 	return nil
 }
 
-func TestConsole(t *testing.T) {
+func TestConsoleLog(t *testing.T) {
+	t.Parallel()
+
+	tests := []struct {
+		in       string
+		expected string
+	}{
+		{``, ``},
+		{`""`, ``},
+		{`undefined`, `undefined`},
+		{`null`, `null`},
+
+		{in: `"string"`, expected: "string"},
+		{in: `"string","a","b"`, expected: "string a b"},
+		{in: `"string",1,2`, expected: "string 1 2"},
+
+		{in: `["bar", 1, 2]`, expected: `["bar",1,2]`},
+		{in: `"bar", ["bar", 0x01, 2], 1, 2`, expected: `bar ["bar",1,2] 1 2`},
+
+		{in: `{}`, expected: "{}"},
+		{in: `{foo:"bar"}`, expected: `{"foo":"bar"}`},
+		{in: `["test1", 2]`, expected: `["test1",2]`},
+
+		// TODO: the ideal output for a circular object should be like `{a: [Circular]}`
+		{in: `function() {var a = {foo: {}}; a.foo = a; return a}()`, expected: "[object Object]"},
+	}
+
+	for i, tt := range tests {
+		tt := tt
+		t.Run(fmt.Sprintf("case%d", i), func(t *testing.T) {
+			t.Parallel()
+
+			r, err := getSimpleRunner(t, "/script.js", fmt.Sprintf(
+				`exports.default = function() { console.log(%s); }`, tt.in))
+			require.NoError(t, err)
+
+			samples := make(chan metrics.SampleContainer, 100)
+			initVU, err := r.newVU(1, 1, samples)
+			assert.NoError(t, err)
+
+			ctx, cancel := context.WithCancel(context.Background())
+			defer cancel()
+			vu := initVU.Activate(&lib.VUActivationParams{RunContext: ctx})
+
+			logger := extractLogger(vu.(*ActiveVU).Console.logger)
+
+			logger.Out = ioutil.Discard
+			logger.Level = logrus.DebugLevel
+			hook := logtest.NewLocal(logger)
+
+			err = vu.RunOnce()
+			assert.NoError(t, err)
+
+			entry := hook.LastEntry()
+
+			require.NotNil(t, entry, "nothing logged")
+			assert.Equal(t, tt.expected, entry.Message)
+			assert.Equal(t, logrus.Fields{"source": "console"}, entry.Data)
+		})
+	}
+}
+
+func TestConsoleLevels(t *testing.T) {
 	t.Parallel()
 	levels := map[string]logrus.Level{
 		"log":   logrus.InfoLevel,
@@ -113,21 +176,20 @@ func TestConsole(t *testing.T) {
 		"warn":  logrus.WarnLevel,
 		"error": logrus.ErrorLevel,
 	}
-	argsets := map[string]struct {
-		Message string
-		Data    logrus.Fields
+	argsets := []struct {
+		in  string
+		exp string
 	}{
-		`"string"`:         {Message: "string", Data: logrus.Fields{"source": "console"}},
-		`"string","a","b"`: {Message: "string a b", Data: logrus.Fields{"source": "console"}},
-		`"string",1,2`:     {Message: "string 1 2", Data: logrus.Fields{"source": "console"}},
-		`{}`:               {Message: "[object Object]", Data: logrus.Fields{"source": "console"}},
+		{in: `"string"`, exp: "string"},
+		{in: `{}`, exp: "{}"},
+		{in: `{foo:"bar"}`, exp: `{"foo":"bar"}`},
 	}
 	for name, level := range levels {
 		name, level := name, level
 		t.Run(name, func(t *testing.T) {
 			t.Parallel()
-			for args, result := range argsets {
-				args, result := args, result
+			for _, tt := range argsets {
+				args, result := tt.in, tt.exp
 				t.Run(args, func(t *testing.T) {
 					t.Parallel()
 					r, err := getSimpleRunner(t, "/script.js", fmt.Sprintf(
@@ -154,16 +216,11 @@ func TestConsole(t *testing.T) {
 					assert.NoError(t, err)
 
 					entry := hook.LastEntry()
-					if assert.NotNil(t, entry, "nothing logged") {
-						assert.Equal(t, level, entry.Level)
-						assert.Equal(t, result.Message, entry.Message)
-
-						data := result.Data
-						if data == nil {
-							data = make(logrus.Fields)
-						}
-						assert.Equal(t, data, entry.Data)
-					}
+					require.NotNil(t, entry, "nothing logged")
+
+					assert.Equal(t, level, entry.Level)
+					assert.Equal(t, result, entry.Message)
+					assert.Equal(t, logrus.Fields{"source": "console"}, entry.Data)
 				})
 			}
 		})
@@ -187,7 +244,7 @@ func TestFileConsole(t *testing.T) {
 			`"string"`:         {Message: "string", Data: logrus.Fields{}},
 			`"string","a","b"`: {Message: "string a b", Data: logrus.Fields{}},
 			`"string",1,2`:     {Message: "string 1 2", Data: logrus.Fields{}},
-			`{}`:               {Message: "[object Object]", Data: logrus.Fields{}},
+			`{}`:               {Message: "{}", Data: logrus.Fields{}},
 		}
 		preExisting = map[string]bool{
 			"log exists":        false,
