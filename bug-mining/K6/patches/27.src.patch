diff --git a/js/init.go b/js/init.go
index e88c1b1f7..a49062eff 100644
--- a/js/init.go
+++ b/js/init.go
@@ -25,13 +25,14 @@ import (
 	"fmt"
 	"github.com/loadimpact/k6/stats"
 	"github.com/robertkrimen/otto"
-	"io/ioutil"
+	"github.com/spf13/afero"
 	"path/filepath"
 	"strings"
 )
 
 type InitAPI struct {
-	r *Runtime
+	r  *Runtime
+	fs afero.Fs
 
 	fileCache map[string]string
 }
@@ -68,7 +69,7 @@ func (i *InitAPI) Require(name string) otto.Value {
 		return exports
 	}
 
-	exports, err := i.r.loadFile(name + ".js")
+	exports, err := i.r.loadFile(name+".js", i.fs)
 	if err != nil {
 		throw(i.r.VM, err)
 	}
@@ -89,7 +90,7 @@ func (i *InitAPI) Open(name string) string {
 		return data
 	}
 
-	data, err := ioutil.ReadFile(path)
+	data, err := afero.ReadFile(i.fs, path)
 	if err != nil {
 		throw(i.r.VM, err)
 	}
diff --git a/js/runtime.go b/js/runtime.go
index c63eee913..412224329 100644
--- a/js/runtime.go
+++ b/js/runtime.go
@@ -29,7 +29,7 @@ import (
 	"github.com/loadimpact/k6/lib"
 	"github.com/loadimpact/k6/stats"
 	"github.com/robertkrimen/otto"
-	"io/ioutil"
+	"github.com/spf13/afero"
 	"os"
 	"path/filepath"
 )
@@ -87,8 +87,8 @@ func New() (*Runtime, error) {
 	return rt, nil
 }
 
-func (r *Runtime) Load(src *lib.SourceData) (otto.Value, error) {
-	if err := r.VM.Set("__initapi__", &InitAPI{r: r}); err != nil {
+func (r *Runtime) Load(src *lib.SourceData, fs afero.Fs) (otto.Value, error) {
+	if err := r.VM.Set("__initapi__", &InitAPI{r: r, fs: fs}); err != nil {
 		return otto.UndefinedValue(), err
 	}
 	exp, err := r.loadSource(src)
@@ -145,7 +145,7 @@ func (r *Runtime) loadSource(src *lib.SourceData) (otto.Value, error) {
 	return exports, nil
 }
 
-func (r *Runtime) loadFile(filename string) (otto.Value, error) {
+func (r *Runtime) loadFile(filename string, fs afero.Fs) (otto.Value, error) {
 	path, err := filepath.Abs(filename)
 	if err != nil {
 		return otto.UndefinedValue(), err
@@ -156,7 +156,7 @@ func (r *Runtime) loadFile(filename string) (otto.Value, error) {
 		return exports, nil
 	}
 
-	data, err := ioutil.ReadFile(path)
+	data, err := afero.ReadFile(fs, path)
 	if err != nil {
 		return otto.UndefinedValue(), err
 	}
diff --git a/js/util_test.go b/js/util_test.go
index 00067984f..72f0029d1 100644
--- a/js/util_test.go
+++ b/js/util_test.go
@@ -24,6 +24,7 @@ import (
 	"context"
 	"errors"
 	"github.com/robertkrimen/otto"
+	"github.com/spf13/afero"
 	"github.com/stretchr/testify/assert"
 	"testing"
 )
@@ -34,7 +35,7 @@ func newSnippetRunner(src string) (*Runner, error) {
 		return nil, err
 	}
 
-	_ = rt.VM.Set("__initapi__", &InitAPI{r: rt})
+	_ = rt.VM.Set("__initapi__", &InitAPI{r: rt, fs: afero.NewOsFs()})
 	exp, err := rt.load("__snippet__", []byte(src))
 	_ = rt.VM.Set("__initapi__", nil)
 	if err != nil {
diff --git a/run.go b/run.go
index aa5d1c447..f899975e7 100644
--- a/run.go
+++ b/run.go
@@ -35,8 +35,10 @@ import (
 	"github.com/loadimpact/k6/stats/influxdb"
 	"github.com/loadimpact/k6/stats/json"
 	"github.com/loadimpact/k6/ui"
+	"github.com/spf13/afero"
 	"gopkg.in/guregu/null.v3"
 	"gopkg.in/urfave/cli.v1"
+	"io"
 	"io/ioutil"
 	"net"
 	"net/url"
@@ -165,10 +167,10 @@ func guessType(data []byte) string {
 	return TypeJS
 }
 
-func getSrcData(filename string) (*lib.SourceData, error) {
-	reader := os.Stdin
+func getSrcData(filename string, fs afero.Fs) (*lib.SourceData, error) {
+	reader := io.Reader(os.Stdin)
 	if filename != "-" {
-		f, err := os.Open(filename)
+		f, err := fs.Open(filename)
 		if err != nil {
 			// If the file doesn't exist, but it looks like a URL, try using it as one.
 			if os.IsNotExist(err) && urlRegex.MatchString(filename) {
@@ -180,6 +182,7 @@ func getSrcData(filename string) (*lib.SourceData, error) {
 
 			return nil, err
 		}
+		defer func() { _ = f.Close() }()
 		reader = f
 	}
 
@@ -194,10 +197,10 @@ func getSrcData(filename string) (*lib.SourceData, error) {
 	}, nil
 }
 
-func makeRunner(runnerType string, src *lib.SourceData) (lib.Runner, error) {
+func makeRunner(runnerType string, src *lib.SourceData, fs afero.Fs) (lib.Runner, error) {
 	switch runnerType {
 	case TypeAuto:
-		return makeRunner(guessType(src.Data), src)
+		return makeRunner(guessType(src.Data), src, fs)
 	case TypeURL:
 		u, err := url.Parse(strings.TrimSpace(string(src.Data)))
 		if err != nil || u.Scheme == "" {
@@ -213,7 +216,7 @@ func makeRunner(runnerType string, src *lib.SourceData) (lib.Runner, error) {
 		if err != nil {
 			return nil, err
 		}
-		exports, err := rt.Load(src)
+		exports, err := rt.Load(src, fs)
 		if err != nil {
 			return nil, err
 		}
@@ -246,7 +249,7 @@ func makeCollector(s string, opts lib.Options) (lib.Collector, error) {
 	case "influxdb":
 		return influxdb.New(p, opts)
 	case "json":
-		return json.New(p, opts)
+		return json.New(p, afero.NewOsFs(), opts)
 	default:
 		return nil, errors.New("Unknown output type: " + t)
 	}
@@ -287,7 +290,8 @@ func actionRun(cc *cli.Context) error {
 
 	// Make the Runner, extract script-defined options.
 	arg := args[0]
-	src, err := getSrcData(arg)
+	fs := afero.NewOsFs()
+	src, err := getSrcData(arg, fs)
 	if err != nil {
 		log.WithError(err).Error("Failed to parse input data")
 		return err
@@ -296,7 +300,7 @@ func actionRun(cc *cli.Context) error {
 	if runnerType == TypeAuto {
 		runnerType = guessType(src.Data)
 	}
-	runner, err := makeRunner(runnerType, src)
+	runner, err := makeRunner(runnerType, src, fs)
 	if err != nil {
 		log.WithError(err).Error("Couldn't create a runner")
 		return err
@@ -305,7 +309,7 @@ func actionRun(cc *cli.Context) error {
 
 	// Read config files.
 	for _, filename := range cc.StringSlice("config") {
-		data, err := ioutil.ReadFile(filename)
+		data, err := afero.ReadFile(fs, filename)
 		if err != nil {
 			return cli.NewExitError(err.Error(), 1)
 		}
@@ -616,7 +620,8 @@ func actionInspect(cc *cli.Context) error {
 	}
 	arg := args[0]
 
-	src, err := getSrcData(arg)
+	fs := afero.NewOsFs()
+	src, err := getSrcData(arg, fs)
 	if err != nil {
 		return err
 	}
@@ -634,14 +639,14 @@ func actionInspect(cc *cli.Context) error {
 			return cli.NewExitError(err.Error(), 1)
 		}
 
-		if _, err := r.Load(src); err != nil {
+		if _, err := r.Load(src, fs); err != nil {
 			return cli.NewExitError(err.Error(), 1)
 		}
 		opts = opts.Apply(r.Options)
 	}
 
 	for _, filename := range cc.StringSlice("config") {
-		data, err := ioutil.ReadFile(filename)
+		data, err := afero.ReadFile(fs, filename)
 		if err != nil {
 			return cli.NewExitError(err.Error(), 1)
 		}
diff --git a/stats/json/collector.go b/stats/json/collector.go
index 8861349c5..df23872bb 100644
--- a/stats/json/collector.go
+++ b/stats/json/collector.go
@@ -26,8 +26,8 @@ import (
 	log "github.com/Sirupsen/logrus"
 	"github.com/loadimpact/k6/lib"
 	"github.com/loadimpact/k6/stats"
+	"github.com/spf13/afero"
 	"io"
-	"os"
 )
 
 type Collector struct {
@@ -45,8 +45,8 @@ func (c *Collector) HasSeenMetric(str string) bool {
 	return false
 }
 
-func New(fname string, opts lib.Options) (*Collector, error) {
-	logfile, err := os.Create(fname)
+func New(fname string, fs afero.Fs, opts lib.Options) (*Collector, error) {
+	logfile, err := fs.Create(fname)
 	if err != nil {
 		return nil, err
 	}
diff --git a/stats/json/collector_test.go b/stats/json/collector_test.go
index b543d8b12..714dbd570 100644
--- a/stats/json/collector_test.go
+++ b/stats/json/collector_test.go
@@ -22,6 +22,7 @@ package json
 
 import (
 	"github.com/loadimpact/k6/lib"
+	"github.com/spf13/afero"
 	"github.com/stretchr/testify/assert"
 	"os"
 	"testing"
@@ -29,17 +30,16 @@ import (
 
 func TestNew(t *testing.T) {
 	testdata := map[string]bool{
-		"/nonexistent/badplacetolog.log":   false,
-		os.TempDir() + "/okplacetolog.log": true,
-		"./okplacetolog.log":               true,
-		"okplacetolog.log":                 true,
+		"/nonexistent/badplacetolog.log": false,
+		"./okplacetolog.log":             true,
+		"okplacetolog.log":               true,
 	}
 
 	for path, succ := range testdata {
 		t.Run("path="+path, func(t *testing.T) {
 			defer func() { _ = os.Remove(path) }()
 
-			collector, err := New(path, lib.Options{})
+			collector, err := New(path, afero.NewOsFs(), lib.Options{})
 			if succ {
 				assert.NoError(t, err)
 				assert.NotNil(t, collector)
