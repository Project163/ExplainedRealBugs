diff --git a/js/bundle.go b/js/bundle.go
index 030c726e7..7b212dc2e 100644
--- a/js/bundle.go
+++ b/js/bundle.go
@@ -23,6 +23,7 @@ package js
 import (
 	"context"
 	"encoding/json"
+	"os"
 
 	"github.com/dop251/goja"
 	"github.com/loadimpact/k6/js/common"
@@ -54,7 +55,7 @@ type BundleInstance struct {
 	Default goja.Callable
 }
 
-// Creates a new bundle from a source file and a filesystem.
+// NewBundle creates a new bundle from a source file and a filesystem.
 func NewBundle(src *lib.SourceData, fs afero.Fs, rtOpts lib.RuntimeOptions) (*Bundle, error) {
 	compiler, err := compiler.New()
 	if err != nil {
@@ -130,6 +131,7 @@ func NewBundle(src *lib.SourceData, fs afero.Fs, rtOpts lib.RuntimeOptions) (*Bu
 	return &bundle, nil
 }
 
+// NewBundleFromArchive creates a new bundle from an lib.Archive.
 func NewBundleFromArchive(arc *lib.Archive, rtOpts lib.RuntimeOptions) (*Bundle, error) {
 	compiler, err := compiler.New()
 	if err != nil {
@@ -140,20 +142,11 @@ func NewBundleFromArchive(arc *lib.Archive, rtOpts lib.RuntimeOptions) (*Bundle,
 		return nil, errors.Errorf("expected bundle type 'js', got '%s'", arc.Type)
 	}
 
-	pgm, _, err := compiler.Compile(string(arc.Data), arc.Filename, "", "", true)
+	initctx := NewInitContext(goja.New(), compiler, new(context.Context), arc.FS, arc.Pwd)
+	pgm, err := initctx.compileImport(string(arc.Data), arc.Filename)
 	if err != nil {
 		return nil, err
 	}
-
-	initctx := NewInitContext(goja.New(), compiler, new(context.Context), nil, arc.Pwd)
-	for filename, data := range arc.Scripts {
-		src := string(data)
-		pgm, err := initctx.compileImport(src, filename)
-		if err != nil {
-			return nil, err
-		}
-		initctx.programs[filename] = programWithSource{pgm, src}
-	}
 	initctx.files = arc.Files
 
 	env := arc.Env
@@ -175,9 +168,10 @@ func NewBundleFromArchive(arc *lib.Archive, rtOpts lib.RuntimeOptions) (*Bundle,
 	}, nil
 }
 
-func (b *Bundle) MakeArchive() *lib.Archive {
+func (b *Bundle) makeArchive() *lib.Archive {
 	arc := &lib.Archive{
 		Type:     "js",
+		FS:       afero.NewMemMapFs(),
 		Options:  b.Options,
 		Filename: b.Filename,
 		Data:     []byte(b.Source),
@@ -192,6 +186,10 @@ func (b *Bundle) MakeArchive() *lib.Archive {
 	arc.Scripts = make(map[string][]byte, len(b.BaseInitContext.programs))
 	for name, pgm := range b.BaseInitContext.programs {
 		arc.Scripts[name] = []byte(pgm.src)
+		err := afero.WriteFile(arc.FS, name, []byte(pgm.src), os.ModePerm)
+		if err != nil {
+			return nil
+		}
 	}
 	arc.Files = b.BaseInitContext.files
 
diff --git a/js/bundle_test.go b/js/bundle_test.go
index ac2a2c9dc..26f940ba3 100644
--- a/js/bundle_test.go
+++ b/js/bundle_test.go
@@ -376,7 +376,7 @@ func TestNewBundleFromArchive(t *testing.T) {
 	}
 	assert.Equal(t, "hi!", v.Export())
 
-	arc := b.MakeArchive()
+	arc := b.makeArchive()
 	assert.Equal(t, "js", arc.Type)
 	assert.Equal(t, lib.Options{VUs: null.IntFrom(12345)}, arc.Options)
 	assert.Equal(t, "/path/to/script.js", arc.Filename)
@@ -456,7 +456,7 @@ func TestBundleEnv(t *testing.T) {
 		return
 	}
 
-	b2, err := NewBundleFromArchive(b1.MakeArchive(), lib.RuntimeOptions{})
+	b2, err := NewBundleFromArchive(b1.makeArchive(), lib.RuntimeOptions{})
 	if !assert.NoError(t, err) {
 		return
 	}
diff --git a/js/initcontext.go b/js/initcontext.go
index 5eaac4b0c..0b0a5816e 100644
--- a/js/initcontext.go
+++ b/js/initcontext.go
@@ -74,8 +74,9 @@ func newBoundInitContext(base *InitContext, ctxPtr *context.Context, rt *goja.Ru
 		runtime: rt,
 		ctxPtr:  ctxPtr,
 
-		fs:  nil,
-		pwd: base.pwd,
+		fs:       base.fs,
+		pwd:      base.pwd,
+		compiler: base.compiler,
 
 		programs: base.programs,
 		files:    base.files,
diff --git a/js/runner.go b/js/runner.go
index b803f09c5..2d87c2d87 100644
--- a/js/runner.go
+++ b/js/runner.go
@@ -99,7 +99,7 @@ func NewFromBundle(b *Bundle) (*Runner, error) {
 }
 
 func (r *Runner) MakeArchive() *lib.Archive {
-	return r.Bundle.MakeArchive()
+	return r.Bundle.makeArchive()
 }
 
 func (r *Runner) NewVU(samplesOut chan<- stats.SampleContainer) (lib.VU, error) {
diff --git a/js/runner_test.go b/js/runner_test.go
index 4916bbfe1..16b236b6f 100644
--- a/js/runner_test.go
+++ b/js/runner_test.go
@@ -21,6 +21,7 @@
 package js
 
 import (
+	"bytes"
 	"context"
 	"crypto/tls"
 	"crypto/x509"
@@ -29,6 +30,7 @@ import (
 	stdlog "log"
 	"net"
 	"net/http"
+	"os"
 	"testing"
 	"time"
 
@@ -201,7 +203,8 @@ func TestOptionsPropagationToScript(t *testing.T) {
 	require.NoError(t, err)
 	require.Equal(t, expScriptOptions, r1.GetOptions())
 
-	r2, err := NewFromArchive(r1.MakeArchive(), lib.RuntimeOptions{Env: map[string]string{"expectedSetupTimeout": "3s"}})
+	r2, err := NewFromArchive(r1.MakeArchive(), lib.RuntimeOptions{Env: map[string]string{"expectedSetupTimeout": "1s"}})
+
 	require.NoError(t, err)
 	require.Equal(t, expScriptOptions, r2.GetOptions())
 
@@ -1346,3 +1349,83 @@ func TestInitContextForbidden(t *testing.T) {
 		})
 	}
 }
+
+func TestArchiveRunningIntegraty(t *testing.T) {
+	tb := testutils.NewHTTPMultiBin(t)
+	defer tb.Cleanup()
+
+	fs := afero.NewMemMapFs()
+	require.NoError(t, afero.WriteFile(fs, "/home/somebody/test.json", []byte(`42`), os.ModePerm))
+	r1, err := New(&lib.SourceData{
+		Filename: "/script.js",
+		Data: []byte(tb.Replacer.Replace(`
+			let fput = open("/home/somebody/test.json");
+			export let options = { setupTimeout: "10s", teardownTimeout: "10s" };
+			export function setup() {
+				return JSON.parse(fput);
+			}
+			export default function(data) {
+				if (data != 42) {
+					throw new Error("incorrect answer " + data);
+				}
+			}
+		`)),
+	}, fs, lib.RuntimeOptions{})
+	require.NoError(t, err)
+
+	buf := bytes.NewBuffer(nil)
+	require.NoError(t, r1.MakeArchive().Write(buf))
+
+	arc, err := lib.ReadArchive(buf)
+	require.NoError(t, err)
+	r2, err := NewFromArchive(arc, lib.RuntimeOptions{})
+	require.NoError(t, err)
+
+	runners := map[string]*Runner{"Source": r1, "Archive": r2}
+	for name, r := range runners {
+		t.Run(name, func(t *testing.T) {
+			ch := make(chan stats.SampleContainer, 100)
+			err = r.Setup(context.Background(), ch)
+			require.NoError(t, err)
+			vu, err := r.NewVU(ch)
+			require.NoError(t, err)
+			err = vu.RunOnce(context.Background())
+			require.NoError(t, err)
+		})
+	}
+}
+
+func TestArchiveNotPanicing(t *testing.T) {
+	tb := testutils.NewHTTPMultiBin(t)
+	defer tb.Cleanup()
+
+	fs := afero.NewMemMapFs()
+	require.NoError(t, afero.WriteFile(fs, "/non/existent", []byte(`42`), os.ModePerm))
+	r1, err := New(&lib.SourceData{
+		Filename: "/script.js",
+		Data: []byte(tb.Replacer.Replace(`
+			let fput = open("/non/existent");
+			export default function(data) {
+			}
+		`)),
+	}, fs, lib.RuntimeOptions{})
+	require.NoError(t, err)
+
+	arc := r1.MakeArchive()
+	arc.Files = make(map[string][]byte)
+	r2, err := NewFromArchive(arc, lib.RuntimeOptions{})
+	require.NoError(t, err)
+
+	runners := map[string]*Runner{"Source": r1, "Archive": r2}
+	for name, r := range runners {
+		t.Run(name, func(t *testing.T) {
+			ch := make(chan stats.SampleContainer, 100)
+			_, err := r.NewVU(ch)
+			if name == "Source" {
+				require.NoError(t, err)
+			} else {
+				require.Error(t, err)
+			}
+		})
+	}
+}
diff --git a/lib/archive.go b/lib/archive.go
index 6b0398357..fdb8d20b4 100644
--- a/lib/archive.go
+++ b/lib/archive.go
@@ -33,6 +33,8 @@ import (
 	"sort"
 	"strings"
 	"time"
+
+	"github.com/spf13/afero"
 )
 
 var volumeRE = regexp.MustCompile(`^([a-zA-Z]):(.*)`)
@@ -49,6 +51,18 @@ func NormalizeAndAnonymizePath(path string) string {
 	return homeDirRE.ReplaceAllString(p, `$1/$2/nobody`)
 }
 
+type normalizedFS struct {
+	afero.Fs
+}
+
+func (m *normalizedFS) Open(name string) (afero.File, error) {
+	return m.Fs.Open(NormalizeAndAnonymizePath(name))
+}
+
+func (m *normalizedFS) OpenFile(name string, flag int, mode os.FileMode) (afero.File, error) {
+	return m.Fs.OpenFile(NormalizeAndAnonymizePath(name), flag, mode)
+}
+
 // An Archive is a rollup of all resources and options needed to reproduce a test identically elsewhere.
 type Archive struct {
 	// The runner to use, eg. "js".
@@ -68,6 +82,8 @@ type Archive struct {
 	Scripts map[string][]byte `json:"-"` // included scripts
 	Files   map[string][]byte `json:"-"` // non-script resources
 
+	FS afero.Fs `json:"-"`
+
 	// Environment variables
 	Env map[string]string `json:"env"`
 }
@@ -78,6 +94,7 @@ func ReadArchive(in io.Reader) (*Archive, error) {
 	arc := &Archive{
 		Scripts: make(map[string][]byte),
 		Files:   make(map[string][]byte),
+		FS:      &normalizedFS{Fs: afero.NewMemMapFs()},
 	}
 
 	for {
@@ -133,6 +150,11 @@ func ReadArchive(in io.Reader) (*Archive, error) {
 		}
 
 		dst[name] = data
+
+		err = afero.WriteFile(arc.FS, name, data, os.ModePerm)
+		if err != nil {
+			return nil, err
+		}
 	}
 
 	return arc, nil
diff --git a/lib/archive_test.go b/lib/archive_test.go
index 21005a6e3..a09601f7a 100644
--- a/lib/archive_test.go
+++ b/lib/archive_test.go
@@ -78,6 +78,7 @@ func TestArchiveReadWrite(t *testing.T) {
 		assert.NoError(t, arc1.Write(buf))
 
 		arc2, err := ReadArchive(buf)
+		arc2.FS = nil
 		assert.NoError(t, err)
 		assert.Equal(t, arc1, arc2)
 	})
@@ -135,6 +136,7 @@ func TestArchiveReadWrite(t *testing.T) {
 			assert.NoError(t, arc1.Write(buf))
 
 			arc2, err := ReadArchive(buf)
+			arc2.FS = nil
 			assert.NoError(t, err)
 			assert.Equal(t, arc1Anon, arc2)
 		}
