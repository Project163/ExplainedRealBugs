diff --git a/js/modules/k6/crypto/crypto.go b/js/modules/k6/crypto/crypto.go
index d77c9f5df..822a0dc02 100644
--- a/js/modules/k6/crypto/crypto.go
+++ b/js/modules/k6/crypto/crypto.go
@@ -22,6 +22,7 @@ package crypto
 
 import (
 	"context"
+	"crypto/hmac"
 	"crypto/md5"
 	"crypto/sha1"
 	"crypto/sha256"
@@ -151,3 +152,38 @@ func (hasher *Hasher) Digest(outputEncoding string) string {
 
 	return ""
 }
+
+func (c Crypto) CreateHmac(ctx context.Context, algorithm string, key string) *Hasher {
+	hasher := Hasher{}
+	hasher.ctx = ctx
+	keyBuffer := []byte(key)
+
+	switch algorithm {
+	case "md4":
+		hasher.hash = hmac.New(md4.New, keyBuffer)
+	case "md5":
+		hasher.hash = hmac.New(md5.New, keyBuffer)
+	case "sha1":
+		hasher.hash = hmac.New(sha1.New, keyBuffer)
+	case "sha256":
+		hasher.hash = hmac.New(sha256.New, keyBuffer)
+	case "sha384":
+		hasher.hash = hmac.New(sha512.New384, keyBuffer)
+	case "sha512_224":
+		hasher.hash = hmac.New(sha512.New512_224, keyBuffer)
+	case "sha512_256":
+		hasher.hash = hmac.New(sha512.New512_256, keyBuffer)
+	case "sha512":
+		hasher.hash = hmac.New(sha512.New, keyBuffer)
+	case "ripemd160":
+		hasher.hash = hmac.New(ripemd160.New, keyBuffer)
+	}
+
+	return &hasher
+}
+
+func (c *Crypto) Hmac(ctx context.Context, algorithm string, key string, input string, outputEncoding string) string {
+	hasher := c.CreateHmac(ctx, algorithm, key)
+	hasher.Update(input)
+	return hasher.Digest(outputEncoding)
+}
diff --git a/js/modules/k6/crypto/crypto_test.go b/js/modules/k6/crypto/crypto_test.go
index bcc7c0883..eb89c641e 100644
--- a/js/modules/k6/crypto/crypto_test.go
+++ b/js/modules/k6/crypto/crypto_test.go
@@ -252,3 +252,48 @@ func TestOutputEncoding(t *testing.T) {
 		assert.EqualError(t, err, "GoError: Invalid output encoding: someInvalidEncoding")
 	})
 }
+
+func TestHMac(t *testing.T) {
+	if testing.Short() {
+		return
+	}
+
+	rt := goja.New()
+	rt.SetFieldNameMapper(common.FieldNameMapper{})
+
+	root, _ := lib.NewGroup("", nil)
+	state := &common.State{Group: root}
+
+	ctx := context.Background()
+	ctx = common.WithState(ctx, state)
+	ctx = common.WithRuntime(ctx, rt)
+
+	rt.Set("crypto", common.Bind(rt, &Crypto{}, &ctx))
+
+	t.Run("Valid", func(t *testing.T) {
+		_, err := common.RunString(rt, `
+		const correctHex = "7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e";
+
+		let hasher = crypto.createHmac("sha256", "a secret");
+		hasher.update("some data to hash");
+
+		const resultHex = hasher.digest("hex");
+		if (resultHex !== correctHex) {
+			throw new Error("Hex encoding mismatch: " + resultHex);
+		}`)
+
+		assert.NoError(t, err)
+	})
+
+	t.Run("Wrapper", func(t *testing.T) {
+		_, err := common.RunString(rt, `
+		const correctHex = "7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e";
+
+		let resultHex = crypto.hmac("sha256", "a secret", "some data to hash", "hex");
+		if (resultHex !== correctHex) {
+			throw new Error("Hex encoding mismatch: " + resultHex);
+		}`)
+
+		assert.NoError(t, err)
+	})
+}
