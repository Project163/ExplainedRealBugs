diff --git a/js/runner.go b/js/runner.go
index c9faa7e67..2ee07eb63 100644
--- a/js/runner.go
+++ b/js/runner.go
@@ -10,6 +10,7 @@ import (
 	"net"
 	"net/http"
 	"net/http/cookiejar"
+	"reflect"
 	"strconv"
 	"strings"
 	"sync"
@@ -557,9 +558,32 @@ func (r *Runner) runPart(
 		// otherwise we have timeouted
 		return v, newTimeoutError(name, r.getTimeoutFor(name))
 	}
+
 	return v, err
 }
 
+//nolint:gochecknoglobals
+var gojaPromiseType = reflect.TypeOf((*goja.Promise)(nil))
+
+// unPromisify gets the result of v if it is a promise, otherwise returns v
+func unPromisify(v goja.Value) goja.Value {
+	if !isNullish(v) {
+		if v.ExportType() == gojaPromiseType {
+			p, ok := v.Export().(*goja.Promise)
+			if !ok {
+				panic("Something that was promise did not export to a promise; this shouldn't happen")
+			}
+			return p.Result()
+		}
+	}
+
+	return v
+}
+
+func isNullish(v goja.Value) bool {
+	return v == nil || goja.IsUndefined(v) || goja.IsNull(v)
+}
+
 // getTimeoutFor returns the timeout duration for given special script function.
 func (r *Runner) getTimeoutFor(stage string) time.Duration {
 	d := time.Duration(0)
@@ -826,6 +850,8 @@ func (u *VU) runFn(
 		startTime, endTime, isFullIteration,
 		isDefault, u.state.Tags.GetCurrentValues(), u.Runner.preInitState.BuiltinMetrics)
 
+	v = unPromisify(v)
+
 	return v, isFullIteration, endTime.Sub(startTime), err
 }
 
diff --git a/js/runner_test.go b/js/runner_test.go
index 622f0e61d..0efd2da32 100644
--- a/js/runner_test.go
+++ b/js/runner_test.go
@@ -542,6 +542,26 @@ func TestSetupDataNoReturn(t *testing.T) {
 	};`)
 }
 
+func TestSetupDataPromise(t *testing.T) {
+	t.Parallel()
+	testSetupDataHelper(t, `
+	exports.options = { setupTimeout: "1s", teardownTimeout: "1s" };
+	exports.setup = async function() {
+        return await Promise.resolve({"data": "correct"})
+    }
+	exports.default = function(data) {
+		if (data.data !== "correct") {
+			throw new Error("default: wrong data: " + JSON.stringify(data))
+		}
+	};
+
+	exports.teardown = function(data) {
+		if (data.data !== "correct") {
+			throw new Error("teardown: wrong data: " + JSON.stringify(data))
+		}
+	};`)
+}
+
 func TestRunnerIntegrationImports(t *testing.T) {
 	t.Parallel()
 	t.Run("Modules", func(t *testing.T) {
diff --git a/js/summary_test.go b/js/summary_test.go
index f362cc49b..7e26579b3 100644
--- a/js/summary_test.go
+++ b/js/summary_test.go
@@ -619,6 +619,29 @@ func TestRawHandleSummaryDataWithSetupData(t *testing.T) {
 	assert.JSONEq(t, expectedHandleSummaryDataWithSetup, string(dataWithSetup))
 }
 
+func TestRawHandleSummaryPromise(t *testing.T) {
+	t.Parallel()
+	runner, err := getSimpleRunner(
+		t, "/script.js",
+		`
+		exports.options = {summaryTrendStats: ["avg", "min", "med", "max", "p(90)", "p(95)", "p(99)", "count"]};
+		exports.default = function() { /* we don't run this, metrics are mocked */ };
+		exports.handleSummary = async function(data) {
+            return await Promise.resolve({'dataWithSetup.json': JSON.stringify(data)});
+		};
+		`,
+	)
+	require.NoError(t, err)
+	runner.SetSetupData([]byte("5"))
+
+	summary := createTestSummary(t)
+	result, err := runner.HandleSummary(context.Background(), summary)
+	require.NoError(t, err)
+	dataWithSetup, err := ioutil.ReadAll(result["dataWithSetup.json"])
+	require.NoError(t, err)
+	assert.JSONEq(t, expectedHandleSummaryDataWithSetup, string(dataWithSetup))
+}
+
 func TestWrongSummaryHandlerExportTypes(t *testing.T) {
 	t.Parallel()
 	testCases := []string{"{}", `"foo"`, "null", "undefined", "123"}
