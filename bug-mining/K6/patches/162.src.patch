diff --git a/js/modules/k6/data/data.go b/js/modules/k6/data/data.go
index 2e43ab2bf..3b8ac3c7b 100644
--- a/js/modules/k6/data/data.go
+++ b/js/modules/k6/data/data.go
@@ -22,6 +22,7 @@ package data
 
 import (
 	"context"
+	"strconv"
 
 	"github.com/dop251/goja"
 	"github.com/loadimpact/k6/js/common"
@@ -62,7 +63,7 @@ func (d *data) XSharedArray(ctx context.Context, name string, call goja.Callable
 		return nil, errors.New("wrong type of shared object")
 	}
 
-	return array.wrap(&ctx, common.GetRuntime(ctx)), nil
+	return array.wrap(common.GetRuntime(ctx)), nil
 }
 
 func getShareArrayFromCall(rt *goja.Runtime, call goja.Callable) sharedArray {
@@ -76,20 +77,15 @@ func getShareArrayFromCall(rt *goja.Runtime, call goja.Callable) sharedArray {
 	}
 	arr := make([]string, obj.Get("length").ToInteger())
 
-	// We specifically use JSON.stringify here as we need to use JSON.parse on the way out
-	// it also has the benefit of needing only one loop and being more JS then using golang's json
-	cal, err := rt.RunString(`(function(input, output) {
-		for (var i = 0; i < input.length; i++) {
-			output[i] = JSON.stringify(input[i])
+	stringify, _ := goja.AssertFunction(rt.GlobalObject().Get("JSON").ToObject(rt).Get("stringify"))
+	var val goja.Value
+	for i := range arr {
+		val, err = stringify(goja.Undefined(), obj.Get(strconv.Itoa(i)))
+		if err != nil {
+			panic(err)
 		}
-	})`)
-	if err != nil {
-		common.Throw(rt, err)
-	}
-	newCall, _ := goja.AssertFunction(cal)
-	_, err = newCall(goja.Undefined(), gojaValue, rt.ToValue(arr))
-	if err != nil {
-		common.Throw(rt, err)
+		arr[i] = val.String()
 	}
+
 	return sharedArray{arr: arr}
 }
diff --git a/js/modules/k6/data/share.go b/js/modules/k6/data/share.go
index de0b25bd7..ad51daf80 100644
--- a/js/modules/k6/data/share.go
+++ b/js/modules/k6/data/share.go
@@ -21,8 +21,6 @@
 package data
 
 import (
-	"context"
-
 	"github.com/dop251/goja"
 	"github.com/loadimpact/k6/js/common"
 )
@@ -33,103 +31,84 @@ type sharedArray struct {
 	arr []string
 }
 
-func (s sharedArray) wrap(ctxPtr *context.Context, rt *goja.Runtime) goja.Value {
-	cal, err := rt.RunString(arrayWrapperCode)
-	if err != nil {
-		common.Throw(rt, err)
-	}
-	call, _ := goja.AssertFunction(cal)
-	wrapped, err := call(goja.Undefined(), rt.ToValue(common.Bind(rt, s, ctxPtr)))
-	if err != nil {
-		common.Throw(rt, err)
-	}
+type wrappedSharedArray struct {
+	sharedArray
 
-	return wrapped
+	rt       *goja.Runtime
+	freeze   goja.Callable
+	isFrozen goja.Callable
+	parse    goja.Callable
 }
 
-func (s sharedArray) Get(index int) (interface{}, error) {
-	if index < 0 || index >= len(s.arr) {
-		return goja.Undefined(), nil
-	}
-
-	// we specifically use JSON.parse to get the json to an object inside as otherwise we won't be
-	// able to freeze it as goja doesn't let us unless it is a pure goja object and this is the
-	// easiest way to get one.
-	return s.arr[index], nil
+func (s sharedArray) wrap(rt *goja.Runtime) goja.Value {
+	freeze, _ := goja.AssertFunction(rt.GlobalObject().Get("Object").ToObject(rt).Get("freeze"))
+	isFrozen, _ := goja.AssertFunction(rt.GlobalObject().Get("Object").ToObject(rt).Get("isFrozen"))
+	parse, _ := goja.AssertFunction(rt.GlobalObject().Get("JSON").ToObject(rt).Get("parse"))
+	return rt.NewDynamicArray(wrappedSharedArray{
+		sharedArray: s,
+		rt:          rt,
+		freeze:      freeze,
+		isFrozen:    isFrozen,
+		parse:       parse,
+	})
 }
 
-func (s sharedArray) Length() int {
-	return len(s.arr)
+func (s wrappedSharedArray) Set(index int, val goja.Value) bool {
+	panic(s.rt.NewTypeError("SharedArray is immutable")) // this is specifically a type error
 }
 
-/* This implementation is commented as with it - it is harder to deepFreeze it with this implementation.
-type sharedArrayIterator struct {
-	a     *sharedArray
-	index int
+func (s wrappedSharedArray) SetLen(len int) bool {
+	panic(s.rt.NewTypeError("SharedArray is immutable")) // this is specifically a type error
 }
 
-func (sai *sharedArrayIterator) Next() (interface{}, error) {
-	if sai.index == len(sai.a.arr)-1 {
-		return map[string]bool{"done": true}, nil
+func (s wrappedSharedArray) Get(index int) goja.Value {
+	if index < 0 || index >= len(s.arr) {
+		return goja.Undefined()
 	}
-	sai.index++
-	var tmp interface{}
-	if err := json.Unmarshal(sai.a.arr[sai.index], &tmp); err != nil {
-		return goja.Undefined(), err
+	val, err := s.parse(goja.Undefined(), s.rt.ToValue(s.arr[index]))
+	if err != nil {
+		common.Throw(s.rt, err)
+	}
+	err = s.deepFreeze(s.rt, val)
+	if err != nil {
+		common.Throw(s.rt, err)
 	}
-	return map[string]interface{}{"value": tmp}, nil
-}
 
-func (s sharedArray) Iterator() *sharedArrayIterator {
-	return &sharedArrayIterator{a: &s, index: -1}
+	return val
 }
-*/
 
-const arrayWrapperCode = `(function(val) {
-	function deepFreeze(o) {
-		Object.freeze(o);
-		if (o === undefined) {
-			return o;
-		}
+func (s wrappedSharedArray) Len() int {
+	return len(s.arr)
+}
 
-		Object.getOwnPropertyNames(o).forEach(function (prop) {
-			if (o[prop] !== null
-				&& (typeof o[prop] === "object" || typeof o[prop] === "function")
-				&& !Object.isFrozen(o[prop])) {
-				deepFreeze(o[prop]);
-			}
-		});
+func (s wrappedSharedArray) deepFreeze(rt *goja.Runtime, val goja.Value) error {
+	if val != nil && goja.IsNull(val) {
+		return nil
+	}
 
-		return o;
-	};
+	_, err := s.freeze(goja.Undefined(), val)
+	if err != nil {
+		return err
+	}
 
-	var arrayHandler = {
-		get: function(target, property, receiver) {
-			switch (property){
-			case "length":
-				return target.length();
-			case Symbol.iterator:
-				return function(){
-					var index = 0;
-					return {
-						"next": function() {
-							if (index >= target.length()) {
-								return {done: true}
-							}
-							var result = {value: deepFreeze(JSON.parse(target.get(index)))};
-							index++;
-							return result;
-						}
-					}
-				}
+	o := val.ToObject(rt)
+	if o == nil {
+		return nil
+	}
+	for _, key := range o.Keys() {
+		prop := o.Get(key)
+		if prop != nil {
+			// isFrozen returns true for all non objects so it we don't need to check that
+			frozen, err := s.isFrozen(goja.Undefined(), prop)
+			if err != nil {
+				return err
 			}
-			var i = parseInt(property);
-			if (isNaN(i)) {
-				return undefined;
+			if !frozen.ToBoolean() { // prevent cycles
+				if err = s.deepFreeze(rt, prop); err != nil {
+					return err
+				}
 			}
-
-			return deepFreeze(JSON.parse(target.get(i)));
 		}
-	};
-	return new Proxy(val, arrayHandler);
-})`
+	}
+	return nil
+}
diff --git a/js/modules/k6/data/share_test.go b/js/modules/k6/data/share_test.go
index 86f127e51..0265b531d 100644
--- a/js/modules/k6/data/share_test.go
+++ b/js/modules/k6/data/share_test.go
@@ -126,13 +126,13 @@ func TestSharedArrayAnotherRuntimeExceptions(t *testing.T) {
 			code: `'use strict'; array[2].data2 = "bad2"`,
 			err:  "Cannot add property data2, object is not extensible",
 		},
-		"setting property on the proxy": {
+		"setting property on the shared array": {
 			code: `'use strict'; array.something = "something"`,
-			err:  "Host object field something cannot be made configurable",
+			err:  `Cannot set property "something" on a dynamic array`,
 		},
-		"setting index on the proxy": {
+		"setting index on the shared array": {
 			code: `'use strict'; array[2] = "something"`,
-			err:  "Host object field 2 cannot be made configurable",
+			err:  "SharedArray is immutable",
 		},
 	}
 
@@ -184,6 +184,16 @@ func TestSharedArrayAnotherRuntimeWorking(t *testing.T) {
 		}
 		i++;
 	}
+
+	i = 0;
+	array.forEach(function(v){
+		if (v.value !== "something"+i) {
+			throw new Error("bad v.value="+v.value+" for i="+i);
+		}
+		i++;
+	});
+
+
 	`)
 	require.NoError(t, err)
 }
