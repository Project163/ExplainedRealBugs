diff --git a/js/runner.go b/js/runner.go
index f6be2ce1c..a70b66088 100644
--- a/js/runner.go
+++ b/js/runner.go
@@ -109,9 +109,9 @@ func (r *Runner) newVU() (*VU, error) {
 		cipherSuites = *r.Bundle.Options.TLSCipherSuites
 	}
 
-	var tlsVersion lib.TLSVersion
+	var tlsVersions lib.TLSVersions
 	if r.Bundle.Options.TLSVersion != nil {
-		tlsVersion = *r.Bundle.Options.TLSVersion
+		tlsVersions = *r.Bundle.Options.TLSVersion
 	}
 
 	tlsAuth := r.Bundle.Options.TLSAuth
@@ -138,8 +138,8 @@ func (r *Runner) newVU() (*VU, error) {
 		TLSClientConfig: &tls.Config{
 			InsecureSkipVerify: r.Bundle.Options.InsecureSkipTLSVerify.Bool,
 			CipherSuites:       cipherSuites,
-			MinVersion:         uint16(tlsVersion.Min),
-			MaxVersion:         uint16(tlsVersion.Max),
+			MinVersion:         uint16(tlsVersions.Min),
+			MaxVersion:         uint16(tlsVersions.Max),
 			Certificates:       certs,
 			NameToCertificate:  nameToCert,
 			Renegotiation:      tls.RenegotiateFreelyAsClient,
diff --git a/lib/options.go b/lib/options.go
index 2f8ea08fd..826b5556c 100644
--- a/lib/options.go
+++ b/lib/options.go
@@ -23,60 +23,54 @@ package lib
 import (
 	"crypto/tls"
 	"encoding/json"
-	"errors"
 	"net"
 
 	"github.com/loadimpact/k6/stats"
+	"github.com/pkg/errors"
 	"gopkg.in/guregu/null.v3"
 )
 
-type TLSVersion struct {
-	Min int
-	Max int
+type TLSVersion int
+
+func (v TLSVersion) MarshalJSON() ([]byte, error) {
+	return []byte(`"` + SupportedTLSVersionsToString[v] + `"`), nil
 }
 
 func (v *TLSVersion) UnmarshalJSON(data []byte) error {
-	version := TLSVersion{}
-
-	// Version might be a string or an object with separate min & max fields
-	var fields struct {
-		Min string `json:"min"`
-		Max string `json:"max"`
+	var str string
+	if err := json.Unmarshal(data, &str); err != nil {
+		return err
 	}
-	if err := json.Unmarshal(data, &fields); err != nil {
-		switch err.(type) {
-		case *json.UnmarshalTypeError:
-			// Check if it's a type error and the user has passed a string
-			var version string
-			if otherErr := json.Unmarshal(data, &version); otherErr != nil {
-				switch otherErr.(type) {
-				case *json.UnmarshalTypeError:
-					return errors.New("Type error: the value of tlsVersion " +
-						"should be an object with min/max fields or a string")
-				}
-
-				// Some other error occurred
-				return otherErr
-			}
-			// It was a string, assign it to both min & max
-			fields.Min = version
-			fields.Max = version
-		default:
-			return err
-		}
+	if str == "" {
+		*v = 0
+		return nil
 	}
-
-	var ok bool
-	if version.Min, ok = SupportedTLSVersions[fields.Min]; !ok {
-		return errors.New("Unknown TLS version : " + fields.Min)
+	ver, ok := SupportedTLSVersions[str]
+	if !ok {
+		return errors.Errorf("unknown TLS version: %s", str)
 	}
+	*v = ver
+	return nil
+}
 
-	if version.Max, ok = SupportedTLSVersions[fields.Max]; !ok {
-		return errors.New("Unknown TLS version : " + fields.Max)
-	}
+type TLSVersionsFields struct {
+	Min TLSVersion `json:"min"`
+	Max TLSVersion `json:"max"`
+}
 
-	*v = version
+type TLSVersions TLSVersionsFields
 
+func (v *TLSVersions) UnmarshalJSON(data []byte) error {
+	var fields TLSVersionsFields
+	if err := json.Unmarshal(data, &fields); err != nil {
+		var ver TLSVersion
+		if err2 := json.Unmarshal(data, &ver); err2 != nil {
+			return err
+		}
+		fields.Min = ver
+		fields.Max = ver
+	}
+	*v = TLSVersions(fields)
 	return nil
 }
 
@@ -147,7 +141,7 @@ type Options struct {
 	BatchPerHost          null.Int         `json:"batchPerHost" envconfig:"batch_per_host"`
 	InsecureSkipTLSVerify null.Bool        `json:"insecureSkipTLSVerify" envconfig:"insecure_skip_tls_verify"`
 	TLSCipherSuites       *TLSCipherSuites `json:"tlsCipherSuites" envconfig:"tls_cipher_suites"`
-	TLSVersion            *TLSVersion      `json:"tlsVersion" envconfig:"tls_version"`
+	TLSVersion            *TLSVersions     `json:"tlsVersion" envconfig:"tls_version"`
 	TLSAuth               []*TLSAuth       `json:"tlsAuth" envconfig:"tlsauth"`
 	NoConnectionReuse     null.Bool        `json:"noConnectionReuse" envconfig:"no_connection_reuse"`
 	UserAgent             null.String      `json:"userAgent" envconfig:"user_agent"`
diff --git a/lib/options_test.go b/lib/options_test.go
index b8b514246..06bf8e185 100644
--- a/lib/options_test.go
+++ b/lib/options_test.go
@@ -34,7 +34,7 @@ import (
 	"gopkg.in/guregu/null.v3"
 )
 
-func TestOptionsApply(t *testing.T) {
+func TestOptions(t *testing.T) {
 	t.Run("Paused", func(t *testing.T) {
 		opts := Options{}.Apply(Options{Paused: null.BoolFrom(true)})
 		assert.True(t, opts.Paused.Valid)
@@ -88,12 +88,48 @@ func TestOptionsApply(t *testing.T) {
 		}
 	})
 	t.Run("TLSVersion", func(t *testing.T) {
-		version := TLSVersion{Min: tls.VersionSSL30, Max: tls.VersionTLS12}
-		opts := Options{}.Apply(Options{TLSVersion: &version})
+		versions := TLSVersions{Min: tls.VersionSSL30, Max: tls.VersionTLS12}
+		opts := Options{}.Apply(Options{TLSVersion: &versions})
 
 		assert.NotNil(t, opts.TLSVersion)
-		assert.Equal(t, opts.TLSVersion.Min, tls.VersionSSL30)
-		assert.Equal(t, opts.TLSVersion.Max, tls.VersionTLS12)
+		assert.Equal(t, opts.TLSVersion.Min, TLSVersion(tls.VersionSSL30))
+		assert.Equal(t, opts.TLSVersion.Max, TLSVersion(tls.VersionTLS12))
+
+		t.Run("JSON", func(t *testing.T) {
+			t.Run("Object", func(t *testing.T) {
+				var opts Options
+				jsonStr := `{"tlsVersion":{"min":"ssl3.0","max":"tls1.2"}}`
+				assert.NoError(t, json.Unmarshal([]byte(jsonStr), &opts))
+				assert.Equal(t, &TLSVersions{
+					Min: TLSVersion(tls.VersionSSL30),
+					Max: TLSVersion(tls.VersionTLS12),
+				}, opts.TLSVersion)
+
+				t.Run("Roundtrip", func(t *testing.T) {
+					data, err := json.Marshal(opts.TLSVersion)
+					assert.NoError(t, err)
+					assert.Equal(t, `{"min":"ssl3.0","max":"tls1.2"}`, string(data))
+					var vers2 TLSVersions
+					assert.NoError(t, json.Unmarshal(data, &vers2))
+					assert.Equal(t, &vers2, opts.TLSVersion)
+				})
+			})
+			t.Run("String", func(t *testing.T) {
+				var opts Options
+				jsonStr := `{"tlsVersion":"tls1.2"}`
+				assert.NoError(t, json.Unmarshal([]byte(jsonStr), &opts))
+				assert.Equal(t, &TLSVersions{
+					Min: TLSVersion(tls.VersionTLS12),
+					Max: TLSVersion(tls.VersionTLS12),
+				}, opts.TLSVersion)
+			})
+			t.Run("Blank", func(t *testing.T) {
+				var opts Options
+				jsonStr := `{"tlsVersion":""}`
+				assert.NoError(t, json.Unmarshal([]byte(jsonStr), &opts))
+				assert.Equal(t, &TLSVersions{}, opts.TLSVersion)
+			})
+		})
 	})
 	t.Run("TLSAuth", func(t *testing.T) {
 		tlsAuth := []*TLSAuth{
@@ -173,6 +209,14 @@ func TestOptionsApply(t *testing.T) {
 		opts := Options{}.Apply(Options{External: map[string]interface{}{"a": 1}})
 		assert.Equal(t, map[string]interface{}{"a": 1}, opts.External)
 	})
+
+	t.Run("JSON", func(t *testing.T) {
+		data, err := json.Marshal(Options{})
+		assert.NoError(t, err)
+		var opts Options
+		assert.NoError(t, json.Unmarshal(data, &opts))
+		assert.Equal(t, Options{}, opts)
+	})
 }
 
 func TestOptionsEnv(t *testing.T) {
diff --git a/lib/tlsconfig_go1_7.go b/lib/tlsconfig_go1_7.go
index 3c6bf432f..bd5c332df 100644
--- a/lib/tlsconfig_go1_7.go
+++ b/lib/tlsconfig_go1_7.go
@@ -26,13 +26,20 @@ import "crypto/tls"
 
 // From https://golang.org/pkg/crypto/tls/#pkg-constants
 
-var SupportedTLSVersions = map[string]int{
+var SupportedTLSVersions = map[string]TLSVersion{
 	"ssl3.0": tls.VersionSSL30,
 	"tls1.0": tls.VersionTLS10,
 	"tls1.1": tls.VersionTLS11,
 	"tls1.2": tls.VersionTLS12,
 }
 
+var SupportedTLSVersionsToString = map[TLSVersion]string{
+	tls.VersionSSL30: "ssl3.0",
+	tls.VersionTLS10: "tls1.0",
+	tls.VersionTLS11: "tls1.1",
+	tls.VersionTLS12: "tls1.2",
+}
+
 var SupportedTLSCipherSuites = map[string]uint16{
 	"TLS_RSA_WITH_RC4_128_SHA":                tls.TLS_RSA_WITH_RC4_128_SHA,
 	"TLS_RSA_WITH_3DES_EDE_CBC_SHA":           tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
diff --git a/lib/tlsconfig_go1_8.go b/lib/tlsconfig_go1_8.go
index 008a01bdd..a26f74a47 100644
--- a/lib/tlsconfig_go1_8.go
+++ b/lib/tlsconfig_go1_8.go
@@ -24,13 +24,20 @@ package lib
 
 import "crypto/tls"
 
-var SupportedTLSVersions = map[string]int{
+var SupportedTLSVersions = map[string]TLSVersion{
 	"ssl3.0": tls.VersionSSL30,
 	"tls1.0": tls.VersionTLS10,
 	"tls1.1": tls.VersionTLS11,
 	"tls1.2": tls.VersionTLS12,
 }
 
+var SupportedTLSVersionsToString = map[TLSVersion]string{
+	tls.VersionSSL30: "ssl3.0",
+	tls.VersionTLS10: "tls1.0",
+	tls.VersionTLS11: "tls1.1",
+	tls.VersionTLS12: "tls1.2",
+}
+
 var SupportedTLSCipherSuites = map[string]uint16{
 	"TLS_RSA_WITH_RC4_128_SHA":                tls.TLS_RSA_WITH_RC4_128_SHA,
 	"TLS_RSA_WITH_3DES_EDE_CBC_SHA":           tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
