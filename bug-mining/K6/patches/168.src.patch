diff --git a/go.mod b/go.mod
index eed170fd7..b301a8782 100644
--- a/go.mod
+++ b/go.mod
@@ -33,7 +33,7 @@ require (
 	github.com/gorilla/websocket v1.4.2
 	github.com/inconshreveable/mousetrap v1.0.0 // indirect
 	github.com/influxdata/influxdb1-client v0.0.0-20190402204710-8ff2fc3824fc
-	github.com/jhump/protoreflect v1.7.0
+	github.com/jhump/protoreflect v1.8.2
 	github.com/julienschmidt/httprouter v1.1.1-0.20180222160526-d18983907793
 	github.com/kardianos/osext v0.0.0-20170510131534-ae77be60afb1 // indirect
 	github.com/kelseyhightower/envconfig v1.4.0
@@ -77,7 +77,7 @@ require (
 	golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 // indirect
 	google.golang.org/genproto v0.0.0-20200903010400-9bfcb5116336 // indirect
 	google.golang.org/grpc v1.36.1
-	google.golang.org/protobuf v1.25.0
+	google.golang.org/protobuf v1.25.1-0.20200805231151-a709e31e5d12
 	gopkg.in/go-playground/assert.v1 v1.2.1 // indirect
 	gopkg.in/go-playground/validator.v8 v8.18.2 // indirect
 	gopkg.in/guregu/null.v2 v2.1.2 // indirect
diff --git a/go.sum b/go.sum
index c56606b59..b1ba2faa1 100644
--- a/go.sum
+++ b/go.sum
@@ -62,7 +62,6 @@ github.com/golang/gddo v0.0.0-20190419222130-af0f2af80721/go.mod h1:xEhNfoBDX1hz
 github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
 github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
 github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
-github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
 github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
 github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
 github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
@@ -95,8 +94,8 @@ github.com/inconshreveable/mousetrap v1.0.0 h1:Z8tu5sraLXCXIcARxBp/8cbvlwVa7Z1NH
 github.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=
 github.com/influxdata/influxdb1-client v0.0.0-20190402204710-8ff2fc3824fc h1:KpMgaYJRieDkHZJWY3LMafvtqS/U8xX6+lUN+OKpl/Y=
 github.com/influxdata/influxdb1-client v0.0.0-20190402204710-8ff2fc3824fc/go.mod h1:qj24IKcXYK6Iy9ceXlo3Tc+vtHo9lIhSX5JddghvEPo=
-github.com/jhump/protoreflect v1.7.0 h1:qJ7piXPrjP3mDrfHf5ATkxfLix8ANs226vpo0aACOn0=
-github.com/jhump/protoreflect v1.7.0/go.mod h1:RZkzh7Hi9J7qT/sPlWnJ/UwZqCJvciFxKDA0UCeltSM=
+github.com/jhump/protoreflect v1.8.2 h1:k2xE7wcUomeqwY0LDCYA16y4WWfyTcMx5mKhk0d4ua0=
+github.com/jhump/protoreflect v1.8.2/go.mod h1:7GcYQDdMU/O/BBrl/cX6PNHpXh6cenjd8pneu5yW7Tg=
 github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
 github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
 github.com/julienschmidt/httprouter v1.1.1-0.20180222160526-d18983907793 h1:C70cJzQWvJh+6Rw8q2Qngi8J8uc1BC6FqJneu0f2pr8=
@@ -192,11 +191,13 @@ github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyC
 github.com/valyala/fasttemplate v0.0.0-20170224212429-dcecefd839c4 h1:gKMu1Bf6QINDnvyZuTaACm9ofY+PRh+5vFz4oxBZeF8=
 github.com/valyala/fasttemplate v0.0.0-20170224212429-dcecefd839c4/go.mod h1:50wTf68f99/Zt14pr046Tgt3Lp2vLyFZKzbFXTOabXw=
 github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
+github.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
 github.com/zyedidia/highlight v0.0.0-20170330143449-201131ce5cf5 h1:Zs6mpwXvlqpF9zHl5XaN0p5V4J9XvP+WBuiuXyIgqvc=
 github.com/zyedidia/highlight v0.0.0-20170330143449-201131ce5cf5/go.mod h1:c1r+Ob9tUTPB0FKWO1+x+Hsc/zNa45WdGq7Y38Ybip0=
 golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
 golang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
 golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
+golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
 golang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897 h1:pLI5jrR7OSLijeIDcmRxNmw2api+jEfxLoykJVice/E=
 golang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
 golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
@@ -205,6 +206,7 @@ golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvx
 golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
 golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
 golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
+golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
 golang.org/x/net v0.0.0-20180218175443-cbe0f9307d01/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
@@ -215,6 +217,7 @@ golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn
 golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
 golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
 golang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
+golang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
 golang.org/x/net v0.0.0-20201209123823-ac852fbbde11 h1:lwlPPsmjDKK0J6eG6xDWd5XPehI0R024zxjDnw3esPA=
 golang.org/x/net v0.0.0-20201209123823-ac852fbbde11/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
 golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
@@ -222,6 +225,7 @@ golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJ
 golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
@@ -251,6 +255,7 @@ golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBn
 golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
 golang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
 golang.org/x/tools v0.0.0-20200522201501-cb1345f3a375/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
+golang.org/x/tools v0.0.0-20200717024301-6ddee64345a6/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
 golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
@@ -258,13 +263,11 @@ golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 h1:go1bK/D/BFZV2I8cIQd1N
 golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
 google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
-google.golang.org/genproto v0.0.0-20170818010345-ee236bd376b0/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
 google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
 google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
 google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
 google.golang.org/genproto v0.0.0-20200903010400-9bfcb5116336 h1:ZcAny/XH59BbzUOKydQpvIlklwibW3T9SvDE5cGhdzc=
 google.golang.org/genproto v0.0.0-20200903010400-9bfcb5116336/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
-google.golang.org/grpc v1.8.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=
 google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
 google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
 google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
@@ -280,8 +283,9 @@ google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2
 google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
 google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
 google.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=
-google.golang.org/protobuf v1.25.0 h1:Ejskq+SyPohKW+1uil0JJMtmHCgJPJ/qWTxr8qp+R4c=
 google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
+google.golang.org/protobuf v1.25.1-0.20200805231151-a709e31e5d12 h1:OwhZOOMuf7leLaSCuxtQ9FW7ui2L2L6UKOtKAUqovUQ=
+google.golang.org/protobuf v1.25.1-0.20200805231151-a709e31e5d12/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=
 gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
diff --git a/vendor/github.com/jhump/protoreflect/codec/encode_fields.go b/vendor/github.com/jhump/protoreflect/codec/encode_fields.go
index 539c3fc95..499aa9564 100644
--- a/vendor/github.com/jhump/protoreflect/codec/encode_fields.go
+++ b/vendor/github.com/jhump/protoreflect/codec/encode_fields.go
@@ -34,6 +34,7 @@ func (cb *Buffer) EncodeFieldValue(fd *desc.FieldDescriptor, val interface{}) er
 		valType := entryType.FindFieldByNumber(2)
 		var entryBuffer Buffer
 		if cb.IsDeterministic() {
+			entryBuffer.SetDeterministic(true)
 			keys := make([]interface{}, 0, len(mp))
 			for k := range mp {
 				keys = append(keys, k)
diff --git a/vendor/github.com/jhump/protoreflect/desc/descriptor.go b/vendor/github.com/jhump/protoreflect/desc/descriptor.go
index a6a091424..42f0f8eb1 100644
--- a/vendor/github.com/jhump/protoreflect/desc/descriptor.go
+++ b/vendor/github.com/jhump/protoreflect/desc/descriptor.go
@@ -995,8 +995,9 @@ func (fd *FieldDescriptor) IsRepeated() bool {
 }
 
 // IsProto3Optional returns true if this field has an explicit "optional" label
-// and is in a "proto3" syntax file. Such fields will be nested in synthetic
-// oneofs that contain only the single field.
+// and is in a "proto3" syntax file. Such fields, if they are normal fields (not
+// extensions), will be nested in synthetic oneofs that contain only the single
+// field.
 func (fd *FieldDescriptor) IsProto3Optional() bool {
 	return internal.GetProto3Optional(fd.proto)
 }
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast.go
index 6980e93d1..6a39e7547 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast.go
@@ -1,1127 +1,205 @@
 package protoparse
 
-import "fmt"
+import "github.com/jhump/protoreflect/desc/protoparse/ast"
 
-// This file defines all of the nodes in the proto AST.
+// SourcePos is the same as ast.SourcePos. This alias exists for
+// backwards compatibility (SourcePos used to be defined in this package.)
+type SourcePos = ast.SourcePos
 
-// SourcePos identifies a location in a proto source file.
-type SourcePos struct {
-	Filename  string
-	Line, Col int
-	Offset    int
-}
-
-func (pos SourcePos) String() string {
-	if pos.Line <= 0 || pos.Col <= 0 {
-		return pos.Filename
-	}
-	return fmt.Sprintf("%s:%d:%d", pos.Filename, pos.Line, pos.Col)
-}
-
-func unknownPos(filename string) *SourcePos {
-	return &SourcePos{Filename: filename}
-}
-
-// node is the interface implemented by all nodes in the AST
-type node interface {
-	start() *SourcePos
-	end() *SourcePos
-	leadingComments() []comment
-	trailingComments() []comment
-}
-
-type terminalNode interface {
-	node
-	popLeadingComment() comment
-	pushTrailingComment(comment)
-}
-
-var _ terminalNode = (*basicNode)(nil)
-var _ terminalNode = (*stringLiteralNode)(nil)
-var _ terminalNode = (*intLiteralNode)(nil)
-var _ terminalNode = (*floatLiteralNode)(nil)
-var _ terminalNode = (*identNode)(nil)
-
-type fileDecl interface {
-	node
-	getSyntax() node
-}
-
-var _ fileDecl = (*fileNode)(nil)
-var _ fileDecl = (*noSourceNode)(nil)
-
-type optionDecl interface {
-	node
-	getName() node
-	getValue() valueNode
-}
-
-var _ optionDecl = (*optionNode)(nil)
-var _ optionDecl = (*noSourceNode)(nil)
-
-type fieldDecl interface {
-	node
-	fieldLabel() node
-	fieldName() node
-	fieldType() node
-	fieldTag() node
-	fieldExtendee() node
-	getGroupKeyword() node
-}
-
-var _ fieldDecl = (*fieldNode)(nil)
-var _ fieldDecl = (*groupNode)(nil)
-var _ fieldDecl = (*mapFieldNode)(nil)
-var _ fieldDecl = (*syntheticMapField)(nil)
-var _ fieldDecl = (*noSourceNode)(nil)
-
-type rangeDecl interface {
-	node
-	rangeStart() node
-	rangeEnd() node
-}
-
-var _ rangeDecl = (*rangeNode)(nil)
-var _ rangeDecl = (*noSourceNode)(nil)
-
-type enumValueDecl interface {
-	node
-	getName() node
-	getNumber() node
-}
-
-var _ enumValueDecl = (*enumValueNode)(nil)
-var _ enumValueDecl = (*noSourceNode)(nil)
-
-type msgDecl interface {
-	node
-	messageName() node
-}
-
-var _ msgDecl = (*messageNode)(nil)
-var _ msgDecl = (*groupNode)(nil)
-var _ msgDecl = (*mapFieldNode)(nil)
-var _ msgDecl = (*noSourceNode)(nil)
-
-type methodDecl interface {
-	node
-	getInputType() node
-	getOutputType() node
-}
-
-var _ methodDecl = (*methodNode)(nil)
-var _ methodDecl = (*noSourceNode)(nil)
-
-type posRange struct {
-	start, end SourcePos
-}
-
-type basicNode struct {
-	posRange
-	leading  []comment
-	trailing []comment
-}
-
-func (n *basicNode) start() *SourcePos {
-	return &n.posRange.start
-}
-
-func (n *basicNode) end() *SourcePos {
-	return &n.posRange.end
-}
-
-func (n *basicNode) leadingComments() []comment {
-	return n.leading
-}
-
-func (n *basicNode) trailingComments() []comment {
-	return n.trailing
-}
-
-func (n *basicNode) popLeadingComment() comment {
-	c := n.leading[0]
-	n.leading = n.leading[1:]
-	return c
-}
-
-func (n *basicNode) pushTrailingComment(c comment) {
-	n.trailing = append(n.trailing, c)
-}
-
-type comment struct {
-	posRange
-	text string
-}
-
-type basicCompositeNode struct {
-	first node
-	last  node
-}
-
-func (n *basicCompositeNode) start() *SourcePos {
-	return n.first.start()
-}
-
-func (n *basicCompositeNode) end() *SourcePos {
-	return n.last.end()
-}
-
-func (n *basicCompositeNode) leadingComments() []comment {
-	return n.first.leadingComments()
-}
-
-func (n *basicCompositeNode) trailingComments() []comment {
-	return n.last.trailingComments()
-}
-
-func (n *basicCompositeNode) setRange(first, last node) {
-	n.first = first
-	n.last = last
-}
-
-type fileNode struct {
-	basicCompositeNode
-	syntax *syntaxNode
-	decls  []*fileElement
-
-	// This field is populated after parsing, to make it easier to find
-	// source locations by import name for constructing link errors.
-	imports []*importNode
-}
-
-func (n *fileNode) getSyntax() node {
-	return n.syntax
-}
-
-type fileElement struct {
-	// a discriminated union: only one field will be set
-	imp     *importNode
-	pkg     *packageNode
-	option  *optionNode
-	message *messageNode
-	enum    *enumNode
-	extend  *extendNode
-	service *serviceNode
-	empty   *basicNode
-}
-
-func (n *fileElement) start() *SourcePos {
-	return n.get().start()
-}
-
-func (n *fileElement) end() *SourcePos {
-	return n.get().end()
-}
-
-func (n *fileElement) leadingComments() []comment {
-	return n.get().leadingComments()
-}
-
-func (n *fileElement) trailingComments() []comment {
-	return n.get().trailingComments()
-}
-
-func (n *fileElement) get() node {
-	switch {
-	case n.imp != nil:
-		return n.imp
-	case n.pkg != nil:
-		return n.pkg
-	case n.option != nil:
-		return n.option
-	case n.message != nil:
-		return n.message
-	case n.enum != nil:
-		return n.enum
-	case n.extend != nil:
-		return n.extend
-	case n.service != nil:
-		return n.service
-	default:
-		return n.empty
-	}
-}
-
-type syntaxNode struct {
-	basicCompositeNode
-	syntax *compoundStringNode
-}
-
-type importNode struct {
-	basicCompositeNode
-	name   *compoundStringNode
-	public bool
-	weak   bool
-}
-
-type packageNode struct {
-	basicCompositeNode
-	name *compoundIdentNode
-}
-
-type identifier string
-
-type identNode struct {
-	basicNode
-	val string
-}
-
-func (n *identNode) value() interface{} {
-	return identifier(n.val)
-}
+// the types below are accumulator types: linked lists that are
+// constructed during parsing and then converted to slices of AST nodes
+// once the whole list has been parsed
 
-type compoundIdentNode struct {
-	basicCompositeNode
-	val string
+type compactOptionList struct {
+	option *ast.OptionNode
+	comma  *ast.RuneNode
+	next   *compactOptionList
 }
 
-func (n *compoundIdentNode) value() interface{} {
-	return identifier(n.val)
-}
-
-type compactOptionsNode struct {
-	basicCompositeNode
-	decls []*optionNode
-}
-
-func (n *compactOptionsNode) Elements() []*optionNode {
-	if n == nil {
-		return nil
+func (list *compactOptionList) toNodes() ([]*ast.OptionNode, []*ast.RuneNode) {
+	l := 0
+	for cur := list; cur != nil; cur = cur.next {
+		l++
 	}
-	return n.decls
-}
-
-type optionNode struct {
-	basicCompositeNode
-	name *optionNameNode
-	val  valueNode
-}
-
-func (n *optionNode) getName() node {
-	return n.name
-}
-
-func (n *optionNode) getValue() valueNode {
-	return n.val
-}
-
-type optionNameNode struct {
-	basicCompositeNode
-	parts []*optionNamePartNode
-}
-
-type optionNamePartNode struct {
-	basicCompositeNode
-	text        *compoundIdentNode
-	offset      int
-	length      int
-	isExtension bool
-	st, en      *SourcePos
-}
-
-func (n *optionNamePartNode) start() *SourcePos {
-	if n.isExtension {
-		return n.basicCompositeNode.start()
+	opts := make([]*ast.OptionNode, l)
+	commas := make([]*ast.RuneNode, l-1)
+	for cur, i := list, 0; cur != nil; cur, i = cur.next, i+1 {
+		opts[i] = cur.option
+		if cur.comma != nil {
+			commas[i] = cur.comma
+		}
 	}
-	return n.st
+	return opts, commas
 }
 
-func (n *optionNamePartNode) end() *SourcePos {
-	if n.isExtension {
-		return n.basicCompositeNode.end()
-	}
-	return n.en
+type stringList struct {
+	str  *ast.StringLiteralNode
+	next *stringList
 }
 
-func (n *optionNamePartNode) setRange(first, last node) {
-	n.basicCompositeNode.setRange(first, last)
-	if !n.isExtension {
-		st := *first.start()
-		st.Col += n.offset
-		n.st = &st
-		en := st
-		en.Col += n.length
-		n.en = &en
+func (list *stringList) toStringValueNode() ast.StringValueNode {
+	if list.next == nil {
+		// single name
+		return list.str
 	}
-}
-
-type valueNode interface {
-	node
-	value() interface{}
-}
-
-var _ valueNode = (*identNode)(nil)
-var _ valueNode = (*compoundIdentNode)(nil)
-var _ valueNode = (*stringLiteralNode)(nil)
-var _ valueNode = (*compoundStringNode)(nil)
-var _ valueNode = (*intLiteralNode)(nil)
-var _ valueNode = (*compoundIntNode)(nil)
-var _ valueNode = (*compoundUintNode)(nil)
-var _ valueNode = (*floatLiteralNode)(nil)
-var _ valueNode = (*compoundFloatNode)(nil)
-var _ valueNode = (*boolLiteralNode)(nil)
-var _ valueNode = (*sliceLiteralNode)(nil)
-var _ valueNode = (*aggregateLiteralNode)(nil)
-var _ valueNode = (*noSourceNode)(nil)
-
-type stringLiteralNode struct {
-	basicNode
-	val string
-}
 
-func (n *stringLiteralNode) value() interface{} {
-	return n.val
-}
-
-type compoundStringNode struct {
-	basicCompositeNode
-	val string
-}
-
-func (n *compoundStringNode) value() interface{} {
-	return n.val
-}
-
-type intLiteral interface {
-	asInt32(min, max int32) (int32, bool)
-	value() interface{}
-}
-
-type intLiteralNode struct {
-	basicNode
-	val uint64
-}
-
-var _ intLiteral = (*intLiteralNode)(nil)
-
-func (n *intLiteralNode) value() interface{} {
-	return n.val
-}
-
-func (n *intLiteralNode) asInt32(min, max int32) (int32, bool) {
-	if (min >= 0 && n.val < uint64(min)) || n.val > uint64(max) {
-		return 0, false
+	l := 0
+	for cur := list; cur != nil; cur = cur.next {
+		l++
 	}
-	return int32(n.val), true
-}
-
-type compoundUintNode struct {
-	basicCompositeNode
-	val uint64
-}
-
-var _ intLiteral = (*compoundUintNode)(nil)
-
-func (n *compoundUintNode) value() interface{} {
-	return n.val
-}
-
-func (n *compoundUintNode) asInt32(min, max int32) (int32, bool) {
-	if (min >= 0 && n.val < uint64(min)) || n.val > uint64(max) {
-		return 0, false
+	strs := make([]*ast.StringLiteralNode, l)
+	for cur, i := list, 0; cur != nil; cur, i = cur.next, i+1 {
+		strs[i] = cur.str
 	}
-	return int32(n.val), true
+	return ast.NewCompoundLiteralStringNode(strs...)
 }
 
-type compoundIntNode struct {
-	basicCompositeNode
-	val int64
-}
-
-var _ intLiteral = (*compoundIntNode)(nil)
-
-func (n *compoundIntNode) value() interface{} {
-	return n.val
+type nameList struct {
+	name  ast.StringValueNode
+	comma *ast.RuneNode
+	next  *nameList
 }
 
-func (n *compoundIntNode) asInt32(min, max int32) (int32, bool) {
-	if n.val < int64(min) || n.val > int64(max) {
-		return 0, false
+func (list *nameList) toNodes() ([]ast.StringValueNode, []*ast.RuneNode) {
+	l := 0
+	for cur := list; cur != nil; cur = cur.next {
+		l++
 	}
-	return int32(n.val), true
-}
-
-type floatLiteralNode struct {
-	basicNode
-	val float64
-}
-
-func (n *floatLiteralNode) value() interface{} {
-	return n.val
-}
-
-type compoundFloatNode struct {
-	basicCompositeNode
-	val float64
-}
-
-func (n *compoundFloatNode) value() interface{} {
-	return n.val
-}
-
-type boolLiteralNode struct {
-	*identNode
-	val bool
-}
-
-func (n *boolLiteralNode) value() interface{} {
-	return n.val
-}
-
-type sliceLiteralNode struct {
-	basicCompositeNode
-	elements []valueNode
-}
-
-func (n *sliceLiteralNode) value() interface{} {
-	return n.elements
-}
-
-type aggregateLiteralNode struct {
-	basicCompositeNode
-	elements []*aggregateEntryNode
-}
-
-func (n *aggregateLiteralNode) value() interface{} {
-	return n.elements
-}
-
-type aggregateEntryNode struct {
-	basicCompositeNode
-	name *aggregateNameNode
-	val  valueNode
-}
-
-type aggregateNameNode struct {
-	basicCompositeNode
-	name        *compoundIdentNode
-	isExtension bool
-}
-
-func (a *aggregateNameNode) value() string {
-	if a.isExtension {
-		return "[" + a.name.val + "]"
-	} else {
-		return a.name.val
+	names := make([]ast.StringValueNode, l)
+	commas := make([]*ast.RuneNode, l-1)
+	for cur, i := list, 0; cur != nil; cur, i = cur.next, i+1 {
+		names[i] = cur.name
+		if cur.comma != nil {
+			commas[i] = cur.comma
+		}
 	}
+	return names, commas
 }
 
-type fieldNode struct {
-	basicCompositeNode
-	label   fieldLabel
-	fldType *compoundIdentNode
-	name    *identNode
-	tag     *intLiteralNode
-	options *compactOptionsNode
-
-	// This field is populated after parsing, to allow lookup of extendee source
-	// locations when field extendees cannot be linked. (Otherwise, this is just
-	// stored as a string in the field descriptors defined inside the extend
-	// block).
-	extendee *extendNode
+type rangeList struct {
+	rng   *ast.RangeNode
+	comma *ast.RuneNode
+	next  *rangeList
 }
 
-func (n *fieldNode) fieldLabel() node {
-	// proto3 fields and fields inside one-ofs will not have a label and we need
-	// this check in order to return a nil node -- otherwise we'd return a
-	// non-nil node that has a nil pointer value in it :/
-	if n.label.identNode == nil {
-		return nil
+func (list *rangeList) toNodes() ([]*ast.RangeNode, []*ast.RuneNode) {
+	l := 0
+	for cur := list; cur != nil; cur = cur.next {
+		l++
 	}
-	return n.label.identNode
-}
-
-func (n *fieldNode) fieldName() node {
-	return n.name
-}
-
-func (n *fieldNode) fieldType() node {
-	return n.fldType
-}
-
-func (n *fieldNode) fieldTag() node {
-	return n.tag
-}
-
-func (n *fieldNode) fieldExtendee() node {
-	if n.extendee != nil {
-		return n.extendee.extendee
+	ranges := make([]*ast.RangeNode, l)
+	commas := make([]*ast.RuneNode, l-1)
+	for cur, i := list, 0; cur != nil; cur, i = cur.next, i+1 {
+		ranges[i] = cur.rng
+		if cur.comma != nil {
+			commas[i] = cur.comma
+		}
 	}
-	return nil
-}
-
-func (n *fieldNode) getGroupKeyword() node {
-	return nil
+	return ranges, commas
 }
 
-type fieldLabel struct {
-	*identNode
-	repeated bool
-	required bool
-}
-
-type groupNode struct {
-	basicCompositeNode
-	groupKeyword *identNode
-	label        fieldLabel
-	name         *identNode
-	tag          *intLiteralNode
-	decls        []*messageElement
-	options      *compactOptionsNode
-
-	// This field is populated after parsing, to allow lookup of extendee source
-	// locations when field extendees cannot be linked. (Otherwise, this is just
-	// stored as a string in the field descriptors defined inside the extend
-	// block).
-	extendee *extendNode
+type valueList struct {
+	val   ast.ValueNode
+	comma *ast.RuneNode
+	next  *valueList
 }
 
-func (n *groupNode) fieldLabel() node {
-	if n.label.identNode == nil {
-		// return nil interface to indicate absence, not a typed nil
-		return nil
+func (list *valueList) toNodes() ([]ast.ValueNode, []*ast.RuneNode) {
+	if list == nil {
+		return nil, nil
 	}
-	return n.label.identNode
-}
-
-func (n *groupNode) fieldName() node {
-	return n.name
-}
-
-func (n *groupNode) fieldType() node {
-	return n.groupKeyword
-}
-
-func (n *groupNode) fieldTag() node {
-	return n.tag
-}
-
-func (n *groupNode) fieldExtendee() node {
-	if n.extendee != nil {
-		return n.extendee.extendee
+	l := 0
+	for cur := list; cur != nil; cur = cur.next {
+		l++
 	}
-	return nil
-}
-
-func (n *groupNode) getGroupKeyword() node {
-	return n.groupKeyword
-}
-
-func (n *groupNode) messageName() node {
-	return n.name
-}
-
-type oneOfNode struct {
-	basicCompositeNode
-	name  *identNode
-	decls []*oneOfElement
-}
-
-type oneOfElement struct {
-	// a discriminated union: only one field will be set
-	option *optionNode
-	field  *fieldNode
-	group  *groupNode
-	empty  *basicNode
-}
-
-func (n *oneOfElement) start() *SourcePos {
-	return n.get().start()
-}
-
-func (n *oneOfElement) end() *SourcePos {
-	return n.get().end()
-}
-
-func (n *oneOfElement) leadingComments() []comment {
-	return n.get().leadingComments()
-}
-
-func (n *oneOfElement) trailingComments() []comment {
-	return n.get().trailingComments()
-}
-
-func (n *oneOfElement) get() node {
-	switch {
-	case n.option != nil:
-		return n.option
-	case n.field != nil:
-		return n.field
-	default:
-		return n.empty
+	vals := make([]ast.ValueNode, l)
+	commas := make([]*ast.RuneNode, l-1)
+	for cur, i := list, 0; cur != nil; cur, i = cur.next, i+1 {
+		vals[i] = cur.val
+		if cur.comma != nil {
+			commas[i] = cur.comma
+		}
 	}
+	return vals, commas
 }
 
-type mapTypeNode struct {
-	basicCompositeNode
-	mapKeyword *identNode
-	keyType    *identNode
-	valueType  *compoundIdentNode
-}
-
-type mapFieldNode struct {
-	basicCompositeNode
-	mapType *mapTypeNode
-	name    *identNode
-	tag     *intLiteralNode
-	options *compactOptionsNode
+type fieldRefList struct {
+	ref  *ast.FieldReferenceNode
+	dot  *ast.RuneNode
+	next *fieldRefList
 }
 
-func (n *mapFieldNode) fieldLabel() node {
-	return nil
-}
-
-func (n *mapFieldNode) fieldName() node {
-	return n.name
-}
-
-func (n *mapFieldNode) fieldType() node {
-	return n.mapType
-}
-
-func (n *mapFieldNode) fieldTag() node {
-	return n.tag
-}
-
-func (n *mapFieldNode) fieldExtendee() node {
-	return nil
-}
-
-func (n *mapFieldNode) getGroupKeyword() node {
-	return nil
-}
-
-func (n *mapFieldNode) messageName() node {
-	return n.name
-}
-
-func (n *mapFieldNode) keyField() *syntheticMapField {
-	k := n.mapType.keyType
-	t := &compoundIdentNode{val: k.val}
-	t.setRange(k, k)
-	return newSyntheticMapField(t, 1)
-}
-
-func (n *mapFieldNode) valueField() *syntheticMapField {
-	return newSyntheticMapField(n.mapType.valueType, 2)
-}
-
-func newSyntheticMapField(ident *compoundIdentNode, tagNum uint64) *syntheticMapField {
-	tag := &intLiteralNode{
-		basicNode: basicNode{
-			posRange: posRange{start: *ident.start(), end: *ident.end()},
-		},
-		val: tagNum,
+func (list *fieldRefList) toNodes() ([]*ast.FieldReferenceNode, []*ast.RuneNode) {
+	l := 0
+	for cur := list; cur != nil; cur = cur.next {
+		l++
 	}
-	return &syntheticMapField{ident: ident, tag: tag}
-}
-
-type syntheticMapField struct {
-	ident *compoundIdentNode
-	tag   *intLiteralNode
-}
-
-func (n *syntheticMapField) start() *SourcePos {
-	return n.ident.start()
-}
-
-func (n *syntheticMapField) end() *SourcePos {
-	return n.ident.end()
-}
-
-func (n *syntheticMapField) leadingComments() []comment {
-	return nil
-}
-
-func (n *syntheticMapField) trailingComments() []comment {
-	return nil
-}
-
-func (n *syntheticMapField) fieldLabel() node {
-	return n.ident
-}
-
-func (n *syntheticMapField) fieldName() node {
-	return n.ident
-}
-
-func (n *syntheticMapField) fieldType() node {
-	return n.ident
-}
-
-func (n *syntheticMapField) fieldTag() node {
-	return n.tag
-}
-
-func (n *syntheticMapField) fieldExtendee() node {
-	return nil
-}
-
-func (n *syntheticMapField) getGroupKeyword() node {
-	return nil
-}
-
-type extensionRangeNode struct {
-	basicCompositeNode
-	ranges  []*rangeNode
-	options *compactOptionsNode
-}
-
-type rangeNode struct {
-	basicCompositeNode
-	startNode, endNode node
-	endMax             bool
-}
-
-func (n *rangeNode) rangeStart() node {
-	return n.startNode
-}
-
-func (n *rangeNode) rangeEnd() node {
-	if n.endNode == nil {
-		return n.startNode
+	refs := make([]*ast.FieldReferenceNode, l)
+	dots := make([]*ast.RuneNode, l-1)
+	for cur, i := list, 0; cur != nil; cur, i = cur.next, i+1 {
+		refs[i] = cur.ref
+		if cur.dot != nil {
+			dots[i] = cur.dot
+		}
 	}
-	return n.endNode
-}
 
-func (n *rangeNode) startValue() interface{} {
-	return n.startNode.(intLiteral).value()
+	return refs, dots
 }
 
-func (n *rangeNode) startValueAsInt32(min, max int32) (int32, bool) {
-	return n.startNode.(intLiteral).asInt32(min, max)
+type identList struct {
+	ident *ast.IdentNode
+	dot   *ast.RuneNode
+	next  *identList
 }
 
-func (n *rangeNode) endValue() interface{} {
-	l, ok := n.endNode.(intLiteral)
-	if !ok {
-		return nil
+func (list *identList) toIdentValueNode(leadingDot *ast.RuneNode) ast.IdentValueNode {
+	if list.next == nil && leadingDot == nil {
+		// single name
+		return list.ident
 	}
-	return l.value()
-}
 
-func (n *rangeNode) endValueAsInt32(min, max int32) (int32, bool) {
-	if n.endMax {
-		return max, true
-	}
-	if n.endNode == nil {
-		return n.startValueAsInt32(min, max)
+	l := 0
+	for cur := list; cur != nil; cur = cur.next {
+		l++
 	}
-	return n.endNode.(intLiteral).asInt32(min, max)
-}
-
-type reservedNode struct {
-	basicCompositeNode
-	ranges []*rangeNode
-	names  []*compoundStringNode
-}
-
-type enumNode struct {
-	basicCompositeNode
-	name  *identNode
-	decls []*enumElement
-}
-
-type enumElement struct {
-	// a discriminated union: only one field will be set
-	option   *optionNode
-	value    *enumValueNode
-	reserved *reservedNode
-	empty    *basicNode
-}
-
-func (n *enumElement) start() *SourcePos {
-	return n.get().start()
-}
-
-func (n *enumElement) end() *SourcePos {
-	return n.get().end()
-}
-
-func (n *enumElement) leadingComments() []comment {
-	return n.get().leadingComments()
-}
-
-func (n *enumElement) trailingComments() []comment {
-	return n.get().trailingComments()
-}
-
-func (n *enumElement) get() node {
-	switch {
-	case n.option != nil:
-		return n.option
-	case n.value != nil:
-		return n.value
-	default:
-		return n.empty
+	idents := make([]*ast.IdentNode, l)
+	dots := make([]*ast.RuneNode, l-1)
+	for cur, i := list, 0; cur != nil; cur, i = cur.next, i+1 {
+		idents[i] = cur.ident
+		if cur.dot != nil {
+			dots[i] = cur.dot
+		}
 	}
-}
 
-type enumValueNode struct {
-	basicCompositeNode
-	name    *identNode
-	options *compactOptionsNode
-	number  *compoundIntNode
+	return ast.NewCompoundIdentNode(leadingDot, idents, dots)
 }
 
-func (n *enumValueNode) getName() node {
-	return n.name
+type messageFieldEntry struct {
+	field     *ast.MessageFieldNode
+	delimiter *ast.RuneNode
 }
 
-func (n *enumValueNode) getNumber() node {
-	return n.number
+type messageFieldList struct {
+	field *messageFieldEntry
+	next  *messageFieldList
 }
 
-type messageNode struct {
-	basicCompositeNode
-	name  *identNode
-	decls []*messageElement
-}
-
-func (n *messageNode) messageName() node {
-	return n.name
-}
-
-type messageElement struct {
-	// a discriminated union: only one field will be set
-	option         *optionNode
-	field          *fieldNode
-	mapField       *mapFieldNode
-	oneOf          *oneOfNode
-	group          *groupNode
-	nested         *messageNode
-	enum           *enumNode
-	extend         *extendNode
-	extensionRange *extensionRangeNode
-	reserved       *reservedNode
-	empty          *basicNode
-}
-
-func (n *messageElement) start() *SourcePos {
-	return n.get().start()
-}
-
-func (n *messageElement) end() *SourcePos {
-	return n.get().end()
-}
-
-func (n *messageElement) leadingComments() []comment {
-	return n.get().leadingComments()
-}
-
-func (n *messageElement) trailingComments() []comment {
-	return n.get().trailingComments()
-}
-
-func (n *messageElement) get() node {
-	switch {
-	case n.option != nil:
-		return n.option
-	case n.field != nil:
-		return n.field
-	case n.mapField != nil:
-		return n.mapField
-	case n.oneOf != nil:
-		return n.oneOf
-	case n.group != nil:
-		return n.group
-	case n.nested != nil:
-		return n.nested
-	case n.enum != nil:
-		return n.enum
-	case n.extend != nil:
-		return n.extend
-	case n.extensionRange != nil:
-		return n.extensionRange
-	case n.reserved != nil:
-		return n.reserved
-	default:
-		return n.empty
+func (list *messageFieldList) toNodes() ([]*ast.MessageFieldNode, []*ast.RuneNode) {
+	if list == nil {
+		return nil, nil
 	}
-}
-
-type extendNode struct {
-	basicCompositeNode
-	extendee *compoundIdentNode
-	decls    []*extendElement
-}
-
-type extendElement struct {
-	// a discriminated union: only one field will be set
-	field *fieldNode
-	group *groupNode
-	empty *basicNode
-}
-
-func (n *extendElement) start() *SourcePos {
-	return n.get().start()
-}
-
-func (n *extendElement) end() *SourcePos {
-	return n.get().end()
-}
-
-func (n *extendElement) leadingComments() []comment {
-	return n.get().leadingComments()
-}
-
-func (n *extendElement) trailingComments() []comment {
-	return n.get().trailingComments()
-}
-
-func (n *extendElement) get() node {
-	switch {
-	case n.field != nil:
-		return n.field
-	case n.group != nil:
-		return n.group
-	default:
-		return n.empty
+	l := 0
+	for cur := list; cur != nil; cur = cur.next {
+		l++
 	}
-}
-
-type serviceNode struct {
-	basicCompositeNode
-	name  *identNode
-	decls []*serviceElement
-}
-
-type serviceElement struct {
-	// a discriminated union: only one field will be set
-	option *optionNode
-	rpc    *methodNode
-	empty  *basicNode
-}
-
-func (n *serviceElement) start() *SourcePos {
-	return n.get().start()
-}
-
-func (n *serviceElement) end() *SourcePos {
-	return n.get().end()
-}
-
-func (n *serviceElement) leadingComments() []comment {
-	return n.get().leadingComments()
-}
-
-func (n *serviceElement) trailingComments() []comment {
-	return n.get().trailingComments()
-}
-
-func (n *serviceElement) get() node {
-	switch {
-	case n.option != nil:
-		return n.option
-	case n.rpc != nil:
-		return n.rpc
-	default:
-		return n.empty
+	fields := make([]*ast.MessageFieldNode, l)
+	delimiters := make([]*ast.RuneNode, l)
+	for cur, i := list, 0; cur != nil; cur, i = cur.next, i+1 {
+		fields[i] = cur.field.field
+		if cur.field.delimiter != nil {
+			delimiters[i] = cur.field.delimiter
+		}
 	}
-}
-
-type methodNode struct {
-	basicCompositeNode
-	name    *identNode
-	input   *rpcTypeNode
-	output  *rpcTypeNode
-	options []*optionNode
-}
-
-func (n *methodNode) getInputType() node {
-	return n.input.msgType
-}
-
-func (n *methodNode) getOutputType() node {
-	return n.output.msgType
-}
-
-type rpcTypeNode struct {
-	basicCompositeNode
-	msgType       *compoundIdentNode
-	streamKeyword node
-}
-
-type noSourceNode struct {
-	pos *SourcePos
-}
-
-func (n noSourceNode) start() *SourcePos {
-	return n.pos
-}
-
-func (n noSourceNode) end() *SourcePos {
-	return n.pos
-}
-
-func (n noSourceNode) leadingComments() []comment {
-	return nil
-}
-
-func (n noSourceNode) trailingComments() []comment {
-	return nil
-}
-
-func (n noSourceNode) getSyntax() node {
-	return n
-}
-
-func (n noSourceNode) getName() node {
-	return n
-}
-
-func (n noSourceNode) getValue() valueNode {
-	return n
-}
-
-func (n noSourceNode) fieldLabel() node {
-	return n
-}
-
-func (n noSourceNode) fieldName() node {
-	return n
-}
-
-func (n noSourceNode) fieldType() node {
-	return n
-}
-
-func (n noSourceNode) fieldTag() node {
-	return n
-}
-
-func (n noSourceNode) fieldExtendee() node {
-	return n
-}
-
-func (n noSourceNode) getGroupKeyword() node {
-	return n
-}
-
-func (n noSourceNode) rangeStart() node {
-	return n
-}
-
-func (n noSourceNode) rangeEnd() node {
-	return n
-}
-
-func (n noSourceNode) getNumber() node {
-	return n
-}
-
-func (n noSourceNode) messageName() node {
-	return n
-}
-
-func (n noSourceNode) getInputType() node {
-	return n
-}
-
-func (n noSourceNode) getOutputType() node {
-	return n
-}
 
-func (n noSourceNode) value() interface{} {
-	return nil
+	return fields, delimiters
 }
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/doc.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/doc.go
new file mode 100644
index 000000000..e8902000a
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/doc.go
@@ -0,0 +1,27 @@
+// Package ast defines types for modeling the AST (Abstract Syntax
+// Tree) for the protocol buffers source language.
+//
+// All nodes of the tree implement the Node interface. Leaf nodes in the
+// tree implement TerminalNode and all others implement CompositeNode.
+// The root of the tree for a proto source file is a *FileNode.
+//
+// Comments are not represented as nodes in the tree. Instead, they are
+// attached to all terminal nodes in the tree. So, when lexing, comments
+// are accumulated until the next non-comment token is found. The AST
+// model in this package thus provides access to all comments in the
+// file, regardless of location (unlike the SourceCodeInfo present in
+// descriptor protos, which are lossy). The comments associated with a
+// a non-leaf/non-token node (i.e. a CompositeNode) come from the first
+// and last nodes in its sub-tree.
+//
+// Creation of AST nodes should use the factory functions in this
+// package instead of struct literals. Some factory functions accept
+// optional arguments, which means the arguments can be nil. If nil
+// values are provided for other (non-optional) arguments, the resulting
+// node may be invalid and cause panics later in the program.
+//
+// This package defines numerous interfaces. However, user code should
+// not attempt to implement any of them. Most consumers of an AST will
+// not work correctly if they encounter concrete implementations other
+// than the ones defined in this package.
+package ast
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/enum.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/enum.go
new file mode 100644
index 000000000..769e056e8
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/enum.go
@@ -0,0 +1,154 @@
+package ast
+
+import "fmt"
+
+// EnumNode represents an enum declaration. Example:
+//
+//  enum Foo { BAR = 0; BAZ = 1 }
+type EnumNode struct {
+	compositeNode
+	Keyword    *KeywordNode
+	Name       *IdentNode
+	OpenBrace  *RuneNode
+	Decls      []EnumElement
+	CloseBrace *RuneNode
+}
+
+func (*EnumNode) fileElement() {}
+func (*EnumNode) msgElement()  {}
+
+// NewEnumNode creates a new *EnumNode. All arguments must be non-nil. While
+// it is technically allowed for decls to be nil or empty, the resulting node
+// will not be a valid enum, which must have at least one value.
+//  - keyword: The token corresponding to the "enum" keyword.
+//  - name: The token corresponding to the enum's name.
+//  - openBrace: The token corresponding to the "{" rune that starts the body.
+//  - decls: All declarations inside the enum body.
+//  - closeBrace: The token corresponding to the "}" rune that ends the body.
+func NewEnumNode(keyword *KeywordNode, name *IdentNode, openBrace *RuneNode, decls []EnumElement, closeBrace *RuneNode) *EnumNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if openBrace == nil {
+		panic("openBrace is nil")
+	}
+	if closeBrace == nil {
+		panic("closeBrace is nil")
+	}
+	children := make([]Node, 0, 4+len(decls))
+	children = append(children, keyword, name, openBrace)
+	for _, decl := range decls {
+		children = append(children, decl)
+	}
+	children = append(children, closeBrace)
+
+	for _, decl := range decls {
+		switch decl.(type) {
+		case *OptionNode, *EnumValueNode, *ReservedNode, *EmptyDeclNode:
+		default:
+			panic(fmt.Sprintf("invalid EnumElement type: %T", decl))
+		}
+	}
+
+	return &EnumNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:    keyword,
+		Name:       name,
+		OpenBrace:  openBrace,
+		CloseBrace: closeBrace,
+		Decls:      decls,
+	}
+}
+
+// EnumElement is an interface implemented by all AST nodes that can
+// appear in the body of an enum declaration.
+type EnumElement interface {
+	Node
+	enumElement()
+}
+
+var _ EnumElement = (*OptionNode)(nil)
+var _ EnumElement = (*EnumValueNode)(nil)
+var _ EnumElement = (*ReservedNode)(nil)
+var _ EnumElement = (*EmptyDeclNode)(nil)
+
+// EnumValueDeclNode is a placeholder interface for AST nodes that represent
+// enum values. This allows NoSourceNode to be used in place of *EnumValueNode
+// for some usages.
+type EnumValueDeclNode interface {
+	Node
+	GetName() Node
+	GetNumber() Node
+}
+
+var _ EnumValueDeclNode = (*EnumValueNode)(nil)
+var _ EnumValueDeclNode = NoSourceNode{}
+
+// EnumNode represents an enum declaration. Example:
+//
+//  UNSET = 0 [deprecated = true];
+type EnumValueNode struct {
+	compositeNode
+	Name      *IdentNode
+	Equals    *RuneNode
+	Number    IntValueNode
+	Options   *CompactOptionsNode
+	Semicolon *RuneNode
+}
+
+func (*EnumValueNode) enumElement() {}
+
+// NewEnumValueNode creates a new *EnumValueNode. All arguments must be non-nil
+// except opts which is only non-nil if the declaration included options.
+//  - name: The token corresponding to the enum value's name.
+//  - equals: The token corresponding to the '=' rune after the name.
+//  - number: The token corresponding to the enum value's number.
+//  - opts: Optional set of enum value options.
+//  - semicolon: The token corresponding to the ";" rune that ends the declaration.
+func NewEnumValueNode(name *IdentNode, equals *RuneNode, number IntValueNode, opts *CompactOptionsNode, semicolon *RuneNode) *EnumValueNode {
+	if name == nil {
+		panic("name is nil")
+	}
+	if equals == nil {
+		panic("equals is nil")
+	}
+	if number == nil {
+		panic("number is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	numChildren := 4
+	if opts != nil {
+		numChildren++
+	}
+	children := make([]Node, 0, numChildren)
+	children = append(children, name, equals, number)
+	if opts != nil {
+		children = append(children, opts)
+	}
+	children = append(children, semicolon)
+	return &EnumValueNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Name:      name,
+		Equals:    equals,
+		Number:    number,
+		Options:   opts,
+		Semicolon: semicolon,
+	}
+}
+
+func (e *EnumValueNode) GetName() Node {
+	return e.Name
+}
+
+func (e *EnumValueNode) GetNumber() Node {
+	return e.Number
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/field.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/field.go
new file mode 100644
index 000000000..b5183af8b
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/field.go
@@ -0,0 +1,608 @@
+package ast
+
+import "fmt"
+
+// FieldDeclNode is a node in the AST that defines a field. This includes
+// normal message fields as well as extensions. There are multiple types
+// of AST nodes that declare fields:
+//  - *FieldNode
+//  - *GroupNode
+//  - *MapFieldNode
+// This also allows NoSourceNode to be used in place of one of the above
+// for some usages.
+type FieldDeclNode interface {
+	Node
+	FieldLabel() Node
+	FieldName() Node
+	FieldType() Node
+	FieldTag() Node
+	FieldExtendee() Node
+	GetGroupKeyword() Node
+	GetOptions() *CompactOptionsNode
+}
+
+var _ FieldDeclNode = (*FieldNode)(nil)
+var _ FieldDeclNode = (*GroupNode)(nil)
+var _ FieldDeclNode = (*MapFieldNode)(nil)
+var _ FieldDeclNode = (*SyntheticMapField)(nil)
+var _ FieldDeclNode = NoSourceNode{}
+
+// FieldNode represents a normal field declaration (not groups or maps). It
+// can represent extension fields as well as non-extension fields (both inside
+// of messages and inside of one-ofs). Example:
+//
+//  optional string foo = 1;
+type FieldNode struct {
+	compositeNode
+	Label     FieldLabel
+	FldType   IdentValueNode
+	Name      *IdentNode
+	Equals    *RuneNode
+	Tag       *UintLiteralNode
+	Options   *CompactOptionsNode
+	Semicolon *RuneNode
+
+	// This is an up-link to the containing *ExtendNode for fields
+	// that are defined inside of "extend" blocks.
+	Extendee *ExtendNode
+}
+
+func (*FieldNode) msgElement()    {}
+func (*FieldNode) oneOfElement()  {}
+func (*FieldNode) extendElement() {}
+
+// NewFieldNode creates a new *FieldNode. The label and options arguments may be
+// nil but the others must be non-nil.
+//  - label: The token corresponding to the label keyword if present ("optional",
+//    "required", or "repeated").
+//  - fieldType: The token corresponding to the field's type.
+//  - name: The token corresponding to the field's name.
+//  - equals: The token corresponding to the '=' rune after the name.
+//  - tag: The token corresponding to the field's tag number.
+//  - opts: Optional set of field options.
+//  - semicolon: The token corresponding to the ";" rune that ends the declaration.
+func NewFieldNode(label *KeywordNode, fieldType IdentValueNode, name *IdentNode, equals *RuneNode, tag *UintLiteralNode, opts *CompactOptionsNode, semicolon *RuneNode) *FieldNode {
+	if fieldType == nil {
+		panic("fieldType is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if equals == nil {
+		panic("equals is nil")
+	}
+	if tag == nil {
+		panic("tag is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	numChildren := 5
+	if label != nil {
+		numChildren++
+	}
+	if opts != nil {
+		numChildren++
+	}
+	children := make([]Node, 0, numChildren)
+	if label != nil {
+		children = append(children, label)
+	}
+	children = append(children, fieldType, name, equals, tag)
+	if opts != nil {
+		children = append(children, opts)
+	}
+	children = append(children, semicolon)
+
+	return &FieldNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Label:     newFieldLabel(label),
+		FldType:   fieldType,
+		Name:      name,
+		Equals:    equals,
+		Tag:       tag,
+		Options:   opts,
+		Semicolon: semicolon,
+	}
+}
+
+func (n *FieldNode) FieldLabel() Node {
+	// proto3 fields and fields inside one-ofs will not have a label and we need
+	// this check in order to return a nil node -- otherwise we'd return a
+	// non-nil node that has a nil pointer value in it :/
+	if n.Label.KeywordNode == nil {
+		return nil
+	}
+	return n.Label.KeywordNode
+}
+
+func (n *FieldNode) FieldName() Node {
+	return n.Name
+}
+
+func (n *FieldNode) FieldType() Node {
+	return n.FldType
+}
+
+func (n *FieldNode) FieldTag() Node {
+	return n.Tag
+}
+
+func (n *FieldNode) FieldExtendee() Node {
+	if n.Extendee != nil {
+		return n.Extendee.Extendee
+	}
+	return nil
+}
+
+func (n *FieldNode) GetGroupKeyword() Node {
+	return nil
+}
+
+func (n *FieldNode) GetOptions() *CompactOptionsNode {
+	return n.Options
+}
+
+// FieldLabel represents the label of a field, which indicates its cardinality
+// (i.e. whether it is optional, required, or repeated).
+type FieldLabel struct {
+	*KeywordNode
+	Repeated bool
+	Required bool
+}
+
+func newFieldLabel(lbl *KeywordNode) FieldLabel {
+	repeated, required := false, false
+	if lbl != nil {
+		repeated = lbl.Val == "repeated"
+		required = lbl.Val == "required"
+	}
+	return FieldLabel{
+		KeywordNode: lbl,
+		Repeated:    repeated,
+		Required:    required,
+	}
+}
+
+// IsPresent returns true if a label keyword was present in the declaration
+// and false if it was absent.
+func (f *FieldLabel) IsPresent() bool {
+	return f.KeywordNode != nil
+}
+
+// GroupNode represents a group declaration, which doubles as a field and inline
+// message declaration. It can represent extension fields as well as
+// non-extension fields (both inside of messages and inside of one-ofs).
+// Example:
+//
+//  optional group Key = 4 {
+//    optional uint64 id = 1;
+//    optional string name = 2;
+//  }
+type GroupNode struct {
+	compositeNode
+	Label   FieldLabel
+	Keyword *KeywordNode
+	Name    *IdentNode
+	Equals  *RuneNode
+	Tag     *UintLiteralNode
+	Options *CompactOptionsNode
+	MessageBody
+
+	// This is an up-link to the containing *ExtendNode for groups
+	// that are defined inside of "extend" blocks.
+	Extendee *ExtendNode
+}
+
+func (*GroupNode) msgElement()    {}
+func (*GroupNode) oneOfElement()  {}
+func (*GroupNode) extendElement() {}
+
+// NewGroupNode creates a new *GroupNode. The label and options arguments may be
+// nil but the others must be non-nil.
+//  - label: The token corresponding to the label keyword if present ("optional",
+//    "required", or "repeated").
+//  - keyword: The token corresponding to the "group" keyword.
+//  - name: The token corresponding to the field's name.
+//  - equals: The token corresponding to the '=' rune after the name.
+//  - tag: The token corresponding to the field's tag number.
+//  - opts: Optional set of field options.
+//  - openBrace: The token corresponding to the "{" rune that starts the body.
+//  - decls: All declarations inside the group body.
+//  - closeBrace: The token corresponding to the "}" rune that ends the body.
+func NewGroupNode(label *KeywordNode, keyword *KeywordNode, name *IdentNode, equals *RuneNode, tag *UintLiteralNode, opts *CompactOptionsNode, openBrace *RuneNode, decls []MessageElement, closeBrace *RuneNode) *GroupNode {
+	if keyword == nil {
+		panic("fieldType is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if equals == nil {
+		panic("equals is nil")
+	}
+	if tag == nil {
+		panic("tag is nil")
+	}
+	if openBrace == nil {
+		panic("openBrace is nil")
+	}
+	if closeBrace == nil {
+		panic("closeBrace is nil")
+	}
+	numChildren := 6 + len(decls)
+	if label != nil {
+		numChildren++
+	}
+	if opts != nil {
+		numChildren++
+	}
+	children := make([]Node, 0, numChildren)
+	if label != nil {
+		children = append(children, label)
+	}
+	children = append(children, keyword, name, equals, tag)
+	if opts != nil {
+		children = append(children, opts)
+	}
+	children = append(children, openBrace)
+	for _, decl := range decls {
+		children = append(children, decl)
+	}
+	children = append(children, closeBrace)
+
+	ret := &GroupNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Label:   newFieldLabel(label),
+		Keyword: keyword,
+		Name:    name,
+		Equals:  equals,
+		Tag:     tag,
+		Options: opts,
+	}
+	populateMessageBody(&ret.MessageBody, openBrace, decls, closeBrace)
+	return ret
+}
+
+func (n *GroupNode) FieldLabel() Node {
+	if n.Label.KeywordNode == nil {
+		// return nil interface to indicate absence, not a typed nil
+		return nil
+	}
+	return n.Label.KeywordNode
+}
+
+func (n *GroupNode) FieldName() Node {
+	return n.Name
+}
+
+func (n *GroupNode) FieldType() Node {
+	return n.Keyword
+}
+
+func (n *GroupNode) FieldTag() Node {
+	return n.Tag
+}
+
+func (n *GroupNode) FieldExtendee() Node {
+	if n.Extendee != nil {
+		return n.Extendee.Extendee
+	}
+	return nil
+}
+
+func (n *GroupNode) GetGroupKeyword() Node {
+	return n.Keyword
+}
+
+func (n *GroupNode) GetOptions() *CompactOptionsNode {
+	return n.Options
+}
+
+func (n *GroupNode) MessageName() Node {
+	return n.Name
+}
+
+// OneOfNode represents a one-of declaration. Example:
+//
+//  oneof query {
+//    string by_name = 2;
+//    Type by_type = 3;
+//    Address by_address = 4;
+//    Labels by_label = 5;
+//  }
+type OneOfNode struct {
+	compositeNode
+	Keyword    *KeywordNode
+	Name       *IdentNode
+	OpenBrace  *RuneNode
+	Decls      []OneOfElement
+	CloseBrace *RuneNode
+}
+
+func (*OneOfNode) msgElement() {}
+
+// NewOneOfNode creates a new *OneOfNode. All arguments must be non-nil. While
+// it is technically allowed for decls to be nil or empty, the resulting node
+// will not be a valid oneof, which must have at least one field.
+//  - keyword: The token corresponding to the "oneof" keyword.
+//  - name: The token corresponding to the oneof's name.
+//  - openBrace: The token corresponding to the "{" rune that starts the body.
+//  - decls: All declarations inside the oneof body.
+//  - closeBrace: The token corresponding to the "}" rune that ends the body.
+func NewOneOfNode(keyword *KeywordNode, name *IdentNode, openBrace *RuneNode, decls []OneOfElement, closeBrace *RuneNode) *OneOfNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if openBrace == nil {
+		panic("openBrace is nil")
+	}
+	if closeBrace == nil {
+		panic("closeBrace is nil")
+	}
+	children := make([]Node, 0, 4+len(decls))
+	children = append(children, keyword, name, openBrace)
+	for _, decl := range decls {
+		children = append(children, decl)
+	}
+	children = append(children, closeBrace)
+
+	for _, decl := range decls {
+		switch decl := decl.(type) {
+		case *OptionNode, *FieldNode, *GroupNode, *EmptyDeclNode:
+		default:
+			panic(fmt.Sprintf("invalid OneOfElement type: %T", decl))
+		}
+	}
+
+	return &OneOfNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:    keyword,
+		Name:       name,
+		OpenBrace:  openBrace,
+		Decls:      decls,
+		CloseBrace: closeBrace,
+	}
+}
+
+// OneOfElement is an interface implemented by all AST nodes that can
+// appear in the body of a oneof declaration.
+type OneOfElement interface {
+	Node
+	oneOfElement()
+}
+
+var _ OneOfElement = (*OptionNode)(nil)
+var _ OneOfElement = (*FieldNode)(nil)
+var _ OneOfElement = (*GroupNode)(nil)
+var _ OneOfElement = (*EmptyDeclNode)(nil)
+
+// MapTypeNode represents the type declaration for a map field. It defines
+// both the key and value types for the map. Example:
+//
+//  map<string, Values>
+type MapTypeNode struct {
+	compositeNode
+	Keyword    *KeywordNode
+	OpenAngle  *RuneNode
+	KeyType    *IdentNode
+	Comma      *RuneNode
+	ValueType  IdentValueNode
+	CloseAngle *RuneNode
+}
+
+// NewMapTypeNode creates a new *MapTypeNode. All arguments must be non-nil.
+//  - keyword: The token corresponding to the "map" keyword.
+//  - openAngle: The token corresponding to the "<" rune after the keyword.
+//  - keyType: The token corresponding to the key type for the map.
+//  - comma: The token corresponding to the "," rune between key and value types.
+//  - valType: The token corresponding to the value type for the map.
+//  - closeAngle: The token corresponding to the ">" rune that ends the declaration.
+func NewMapTypeNode(keyword *KeywordNode, openAngle *RuneNode, keyType *IdentNode, comma *RuneNode, valType IdentValueNode, closeAngle *RuneNode) *MapTypeNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if openAngle == nil {
+		panic("openAngle is nil")
+	}
+	if keyType == nil {
+		panic("keyType is nil")
+	}
+	if comma == nil {
+		panic("comma is nil")
+	}
+	if valType == nil {
+		panic("valType is nil")
+	}
+	if closeAngle == nil {
+		panic("closeAngle is nil")
+	}
+	children := []Node{keyword, openAngle, keyType, comma, valType, closeAngle}
+	return &MapTypeNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:    keyword,
+		OpenAngle:  openAngle,
+		KeyType:    keyType,
+		Comma:      comma,
+		ValueType:  valType,
+		CloseAngle: closeAngle,
+	}
+}
+
+// MapFieldNode represents a map field declaration. Example:
+//
+//  map<string,string> replacements = 3 [deprecated = true];
+type MapFieldNode struct {
+	compositeNode
+	MapType   *MapTypeNode
+	Name      *IdentNode
+	Equals    *RuneNode
+	Tag       *UintLiteralNode
+	Options   *CompactOptionsNode
+	Semicolon *RuneNode
+}
+
+func (*MapFieldNode) msgElement() {}
+
+// NewMapFieldNode creates a new *MapFieldNode. All arguments must be non-nil
+// except opts, which may be nil.
+//  - mapType: The token corresponding to the map type.
+//  - name: The token corresponding to the field's name.
+//  - equals: The token corresponding to the '=' rune after the name.
+//  - tag: The token corresponding to the field's tag number.
+//  - opts: Optional set of field options.
+//  - semicolon: The token corresponding to the ";" rune that ends the declaration.
+func NewMapFieldNode(mapType *MapTypeNode, name *IdentNode, equals *RuneNode, tag *UintLiteralNode, opts *CompactOptionsNode, semicolon *RuneNode) *MapFieldNode {
+	if mapType == nil {
+		panic("mapType is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if equals == nil {
+		panic("equals is nil")
+	}
+	if tag == nil {
+		panic("tag is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	numChildren := 5
+	if opts != nil {
+		numChildren++
+	}
+	children := make([]Node, 0, numChildren)
+	children = append(children, mapType, name, equals, tag)
+	if opts != nil {
+		children = append(children, opts)
+	}
+	children = append(children, semicolon)
+
+	return &MapFieldNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		MapType:   mapType,
+		Name:      name,
+		Equals:    equals,
+		Tag:       tag,
+		Options:   opts,
+		Semicolon: semicolon,
+	}
+}
+
+func (n *MapFieldNode) FieldLabel() Node {
+	return nil
+}
+
+func (n *MapFieldNode) FieldName() Node {
+	return n.Name
+}
+
+func (n *MapFieldNode) FieldType() Node {
+	return n.MapType
+}
+
+func (n *MapFieldNode) FieldTag() Node {
+	return n.Tag
+}
+
+func (n *MapFieldNode) FieldExtendee() Node {
+	return nil
+}
+
+func (n *MapFieldNode) GetGroupKeyword() Node {
+	return nil
+}
+
+func (n *MapFieldNode) GetOptions() *CompactOptionsNode {
+	return n.Options
+}
+
+func (n *MapFieldNode) MessageName() Node {
+	return n.Name
+}
+
+func (n *MapFieldNode) KeyField() *SyntheticMapField {
+	return NewSyntheticMapField(n.MapType.KeyType, 1)
+}
+
+func (n *MapFieldNode) ValueField() *SyntheticMapField {
+	return NewSyntheticMapField(n.MapType.ValueType, 2)
+}
+
+// SyntheticMapField is not an actual node in the AST but a synthetic node
+// that implements FieldDeclNode. These are used to represent the implicit
+// field declarations of the "key" and "value" fields in a map entry.
+type SyntheticMapField struct {
+	Ident IdentValueNode
+	Tag   *UintLiteralNode
+}
+
+// NewSyntheticMapField creates a new *SyntheticMapField for the given
+// identifier (either a key or value type in a map declaration) and tag
+// number (1 for key, 2 for value).
+func NewSyntheticMapField(ident IdentValueNode, tagNum uint64) *SyntheticMapField {
+	tag := &UintLiteralNode{
+		terminalNode: terminalNode{
+			posRange: PosRange{Start: *ident.Start(), End: *ident.End()},
+		},
+		Val: tagNum,
+	}
+	return &SyntheticMapField{Ident: ident, Tag: tag}
+}
+
+func (n *SyntheticMapField) Start() *SourcePos {
+	return n.Ident.Start()
+}
+
+func (n *SyntheticMapField) End() *SourcePos {
+	return n.Ident.End()
+}
+
+func (n *SyntheticMapField) LeadingComments() []Comment {
+	return nil
+}
+
+func (n *SyntheticMapField) TrailingComments() []Comment {
+	return nil
+}
+
+func (n *SyntheticMapField) FieldLabel() Node {
+	return n.Ident
+}
+
+func (n *SyntheticMapField) FieldName() Node {
+	return n.Ident
+}
+
+func (n *SyntheticMapField) FieldType() Node {
+	return n.Ident
+}
+
+func (n *SyntheticMapField) FieldTag() Node {
+	return n.Tag
+}
+
+func (n *SyntheticMapField) FieldExtendee() Node {
+	return nil
+}
+
+func (n *SyntheticMapField) GetGroupKeyword() Node {
+	return nil
+}
+
+func (n *SyntheticMapField) GetOptions() *CompactOptionsNode {
+	return nil
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/file.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/file.go
new file mode 100644
index 000000000..ed151b1b2
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/file.go
@@ -0,0 +1,234 @@
+package ast
+
+import "fmt"
+
+// FileDeclNode is a placeholder interface for AST nodes that represent files.
+// This allows NoSourceNode to be used in place of *FileNode for some usages.
+type FileDeclNode interface {
+	Node
+	GetSyntax() Node
+}
+
+var _ FileDeclNode = (*FileNode)(nil)
+var _ FileDeclNode = NoSourceNode{}
+
+// FileNode is the root of the AST hierarchy. It represents an entire
+// protobuf source file.
+type FileNode struct {
+	compositeNode
+	Syntax *SyntaxNode // nil if file has no syntax declaration
+	Decls  []FileElement
+
+	// Any comments that follow the last token in the file.
+	FinalComments []Comment
+	// Any whitespace at the end of the file (after the last token or
+	// last comment in the file).
+	FinalWhitespace string
+}
+
+// NewFileElement creates a new *FileNode. The syntax parameter is optional. If it
+// is absent, it means the file had no syntax declaration.
+//
+// This function panics if the concrete type of any element of decls is not
+// from this package.
+func NewFileNode(syntax *SyntaxNode, decls []FileElement) *FileNode {
+	numChildren := len(decls)
+	if syntax != nil {
+		numChildren++
+	}
+	children := make([]Node, 0, numChildren)
+	if syntax != nil {
+		children = append(children, syntax)
+	}
+	for _, decl := range decls {
+		children = append(children, decl)
+	}
+
+	for _, decl := range decls {
+		switch decl := decl.(type) {
+		case *PackageNode, *ImportNode, *OptionNode, *MessageNode,
+			*EnumNode, *ExtendNode, *ServiceNode, *EmptyDeclNode:
+		default:
+			panic(fmt.Sprintf("invalid FileElement type: %T", decl))
+		}
+	}
+
+	return &FileNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Syntax: syntax,
+		Decls:  decls,
+	}
+}
+
+func NewEmptyFileNode(filename string) *FileNode {
+	return &FileNode{
+		compositeNode: compositeNode{
+			children: []Node{NewNoSourceNode(filename)},
+		},
+	}
+}
+
+func (f *FileNode) GetSyntax() Node {
+	return f.Syntax
+}
+
+// FileElement is an interface implemented by all AST nodes that are
+// allowed as top-level declarations in the file.
+type FileElement interface {
+	Node
+	fileElement()
+}
+
+var _ FileElement = (*ImportNode)(nil)
+var _ FileElement = (*PackageNode)(nil)
+var _ FileElement = (*OptionNode)(nil)
+var _ FileElement = (*MessageNode)(nil)
+var _ FileElement = (*EnumNode)(nil)
+var _ FileElement = (*ExtendNode)(nil)
+var _ FileElement = (*ServiceNode)(nil)
+var _ FileElement = (*EmptyDeclNode)(nil)
+
+// SyntaxNode represents a syntax declaration, which if present must be
+// the first non-comment content. Example:
+//
+//  syntax = "proto2";
+//
+// Files that don't have a syntax node are assumed to use proto2 syntax.
+type SyntaxNode struct {
+	compositeNode
+	Keyword   *KeywordNode
+	Equals    *RuneNode
+	Syntax    StringValueNode
+	Semicolon *RuneNode
+}
+
+// NewSyntaxNode creates a new *SyntaxNode. All four arguments must be non-nil:
+//  - keyword: The token corresponding to the "syntax" keyword.
+//  - equals: The token corresponding to the "=" rune.
+//  - syntax: The actual syntax value, e.g. "proto2" or "proto3".
+//  - semicolon: The token corresponding to the ";" rune that ends the declaration.
+func NewSyntaxNode(keyword *KeywordNode, equals *RuneNode, syntax StringValueNode, semicolon *RuneNode) *SyntaxNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if equals == nil {
+		panic("equals is nil")
+	}
+	if syntax == nil {
+		panic("syntax is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	children := []Node{keyword, equals, syntax, semicolon}
+	return &SyntaxNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:   keyword,
+		Equals:    equals,
+		Syntax:    syntax,
+		Semicolon: semicolon,
+	}
+}
+
+// ImportNode represents an import statement. Example:
+//
+//  import "google/protobuf/empty.proto";
+type ImportNode struct {
+	compositeNode
+	Keyword *KeywordNode
+	// Optional; if present indicates this is a public import
+	Public *KeywordNode
+	// Optional; if present indicates this is a weak import
+	Weak      *KeywordNode
+	Name      StringValueNode
+	Semicolon *RuneNode
+}
+
+// NewImportNode creates a new *ImportNode. The public and weak arguments are optional
+// and only one or the other (or neither) may be specified, not both. When public is
+// non-nil, it indicates the "public" keyword in the import statement and means this is
+// a public import. When weak is non-nil, it indicates the "weak" keyword in the import
+// statement and means this is a weak import. When both are nil, this is a normal import.
+// The other arguments must be non-nil:
+//  - keyword: The token corresponding to the "import" keyword.
+//  - public: The token corresponding to the optional "public" keyword.
+//  - weak: The token corresponding to the optional "weak" keyword.
+//  - name: The actual imported file name.
+//  - semicolon: The token corresponding to the ";" rune that ends the declaration.
+func NewImportNode(keyword *KeywordNode, public *KeywordNode, weak *KeywordNode, name StringValueNode, semicolon *RuneNode) *ImportNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	numChildren := 3
+	if public != nil || weak != nil {
+		numChildren++
+	}
+	children := make([]Node, 0, numChildren)
+	children = append(children, keyword)
+	if public != nil {
+		children = append(children, public)
+	} else if weak != nil {
+		children = append(children, weak)
+	}
+	children = append(children, name, semicolon)
+
+	return &ImportNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:   keyword,
+		Public:    public,
+		Weak:      weak,
+		Name:      name,
+		Semicolon: semicolon,
+	}
+}
+
+func (*ImportNode) fileElement() {}
+
+// PackageNode represents a package declaration. Example:
+//
+//  package foobar.com;
+type PackageNode struct {
+	compositeNode
+	Keyword   *KeywordNode
+	Name      IdentValueNode
+	Semicolon *RuneNode
+}
+
+func (*PackageNode) fileElement() {}
+
+// NewPackageNode creates a new *PackageNode. All three arguments must be non-nil:
+//  - keyword: The token corresponding to the "package" keyword.
+//  - name: The package name declared for the file.
+//  - semicolon: The token corresponding to the ";" rune that ends the declaration.
+func NewPackageNode(keyword *KeywordNode, name IdentValueNode, semicolon *RuneNode) *PackageNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	children := []Node{keyword, name, semicolon}
+	return &PackageNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:   keyword,
+		Name:      name,
+		Semicolon: semicolon,
+	}
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/identifiers.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/identifiers.go
new file mode 100644
index 000000000..aa62add5a
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/identifiers.go
@@ -0,0 +1,134 @@
+package ast
+
+import (
+	"fmt"
+	"strings"
+)
+
+// Identifier is a possibly-qualified name. This is used to distinguish
+// ValueNode values that are references/identifiers vs. those that are
+// string literals.
+type Identifier string
+
+// IdentValueNode is an AST node that represents an identifier.
+type IdentValueNode interface {
+	ValueNode
+	AsIdentifier() Identifier
+}
+
+var _ IdentValueNode = (*IdentNode)(nil)
+var _ IdentValueNode = (*CompoundIdentNode)(nil)
+
+// IdentNode represents a simple, unqualified identifier. These are used to name
+// elements declared in a protobuf file or to refer to elements. Example:
+//
+//  foobar
+type IdentNode struct {
+	terminalNode
+	Val string
+}
+
+// NewIdentNode creates a new *IdentNode. The given val is the identifier text.
+func NewIdentNode(val string, info TokenInfo) *IdentNode {
+	return &IdentNode{
+		terminalNode: info.asTerminalNode(),
+		Val:          val,
+	}
+}
+
+func (n *IdentNode) Value() interface{} {
+	return n.AsIdentifier()
+}
+
+func (n *IdentNode) AsIdentifier() Identifier {
+	return Identifier(n.Val)
+}
+
+// ToKeyword is used to convert identifiers to keywords. Since keywords are not
+// reserved in the protobuf language, they are initially lexed as identifiers
+// and then converted to keywords based on context.
+func (n *IdentNode) ToKeyword() *KeywordNode {
+	return (*KeywordNode)(n)
+}
+
+// CompoundIdentNode represents a qualified identifier. A qualified identifier
+// has at least one dot and possibly multiple identifier names (all separated by
+// dots). If the identifier has a leading dot, then it is a *fully* qualified
+// identifier. Example:
+//
+//  .com.foobar.Baz
+type CompoundIdentNode struct {
+	compositeNode
+	// Optional leading dot, indicating that the identifier is fully qualified.
+	LeadingDot *RuneNode
+	Components []*IdentNode
+	// Dots[0] is the dot after Components[0]. The length of Dots is always
+	// one less than the length of Components.
+	Dots []*RuneNode
+	// The text value of the identifier, with all components and dots
+	// concatenated.
+	Val string
+}
+
+// NewCompoundIdentNode creates a *CompoundIdentNode. The leadingDot may be nil.
+// The dots arg must have a length that is one less than the length of
+// components. The components arg must not be empty.
+func NewCompoundIdentNode(leadingDot *RuneNode, components []*IdentNode, dots []*RuneNode) *CompoundIdentNode {
+	if len(components) == 0 {
+		panic("must have at least one component")
+	}
+	if len(dots) != len(components)-1 {
+		panic(fmt.Sprintf("%d components requires %d dots, not %d", len(components), len(components)-1, len(dots)))
+	}
+	numChildren := len(components)*2 - 1
+	if leadingDot != nil {
+		numChildren++
+	}
+	children := make([]Node, 0, numChildren)
+	var b strings.Builder
+	if leadingDot != nil {
+		children = append(children, leadingDot)
+		b.WriteRune(leadingDot.Rune)
+	}
+	for i, comp := range components {
+		if i > 0 {
+			dot := dots[i-1]
+			children = append(children, dot)
+			b.WriteRune(dot.Rune)
+		}
+		children = append(children, comp)
+		b.WriteString(comp.Val)
+	}
+	return &CompoundIdentNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		LeadingDot: leadingDot,
+		Components: components,
+		Dots:       dots,
+		Val:        b.String(),
+	}
+}
+
+func (n *CompoundIdentNode) Value() interface{} {
+	return n.AsIdentifier()
+}
+
+func (n *CompoundIdentNode) AsIdentifier() Identifier {
+	return Identifier(n.Val)
+}
+
+// KeywordNode is an AST node that represents a keyword. Keywords are
+// like identifiers, but they have special meaning in particular contexts.
+// Example:
+//
+//  message
+type KeywordNode IdentNode
+
+// NewKeywordNode creates a new *KeywordNode. The given val is the keyword.
+func NewKeywordNode(val string, info TokenInfo) *KeywordNode {
+	return &KeywordNode{
+		terminalNode: info.asTerminalNode(),
+		Val:          val,
+	}
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/message.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/message.go
new file mode 100644
index 000000000..80651b66d
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/message.go
@@ -0,0 +1,198 @@
+package ast
+
+import "fmt"
+
+// MessageDeclNode is a node in the AST that defines a message type. This
+// includes normal message fields as well as implicit messages:
+//  - *MessageNode
+//  - *GroupNode (the group is a field and inline message type)
+//  - *MapFieldNode (map fields implicitly define a MapEntry message type)
+// This also allows NoSourceNode to be used in place of one of the above
+// for some usages.
+type MessageDeclNode interface {
+	Node
+	MessageName() Node
+}
+
+var _ MessageDeclNode = (*MessageNode)(nil)
+var _ MessageDeclNode = (*GroupNode)(nil)
+var _ MessageDeclNode = (*MapFieldNode)(nil)
+var _ MessageDeclNode = NoSourceNode{}
+
+// MessageNode represents a message declaration. Example:
+//
+//  message Foo {
+//    string name = 1;
+//    repeated string labels = 2;
+//    bytes extra = 3;
+//  }
+type MessageNode struct {
+	compositeNode
+	Keyword *KeywordNode
+	Name    *IdentNode
+	MessageBody
+}
+
+func (*MessageNode) fileElement() {}
+func (*MessageNode) msgElement()  {}
+
+// NewMessageNode creates a new *MessageNode. All arguments must be non-nil.
+//  - keyword: The token corresponding to the "message" keyword.
+//  - name: The token corresponding to the field's name.
+//  - openBrace: The token corresponding to the "{" rune that starts the body.
+//  - decls: All declarations inside the message body.
+//  - closeBrace: The token corresponding to the "}" rune that ends the body.
+func NewMessageNode(keyword *KeywordNode, name *IdentNode, openBrace *RuneNode, decls []MessageElement, closeBrace *RuneNode) *MessageNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if openBrace == nil {
+		panic("openBrace is nil")
+	}
+	if closeBrace == nil {
+		panic("closeBrace is nil")
+	}
+	children := make([]Node, 0, 4+len(decls))
+	children = append(children, keyword, name, openBrace)
+	for _, decl := range decls {
+		children = append(children, decl)
+	}
+	children = append(children, closeBrace)
+
+	ret := &MessageNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword: keyword,
+		Name:    name,
+	}
+	populateMessageBody(&ret.MessageBody, openBrace, decls, closeBrace)
+	return ret
+}
+
+func (n *MessageNode) MessageName() Node {
+	return n.Name
+}
+
+// MessageBody represents the body of a message. It is used by both
+// MessageNodes and GroupNodes.
+type MessageBody struct {
+	OpenBrace  *RuneNode
+	Decls      []MessageElement
+	CloseBrace *RuneNode
+}
+
+func populateMessageBody(m *MessageBody, openBrace *RuneNode, decls []MessageElement, closeBrace *RuneNode) {
+	m.OpenBrace = openBrace
+	m.Decls = decls
+	for _, decl := range decls {
+		switch decl.(type) {
+		case *OptionNode, *FieldNode, *MapFieldNode, *GroupNode, *OneOfNode,
+			*MessageNode, *EnumNode, *ExtendNode, *ExtensionRangeNode,
+			*ReservedNode, *EmptyDeclNode:
+		default:
+			panic(fmt.Sprintf("invalid MessageElement type: %T", decl))
+		}
+	}
+	m.CloseBrace = closeBrace
+}
+
+// MessageElement is an interface implemented by all AST nodes that can
+// appear in a message body.
+type MessageElement interface {
+	Node
+	msgElement()
+}
+
+var _ MessageElement = (*OptionNode)(nil)
+var _ MessageElement = (*FieldNode)(nil)
+var _ MessageElement = (*MapFieldNode)(nil)
+var _ MessageElement = (*OneOfNode)(nil)
+var _ MessageElement = (*GroupNode)(nil)
+var _ MessageElement = (*MessageNode)(nil)
+var _ MessageElement = (*EnumNode)(nil)
+var _ MessageElement = (*ExtendNode)(nil)
+var _ MessageElement = (*ExtensionRangeNode)(nil)
+var _ MessageElement = (*ReservedNode)(nil)
+var _ MessageElement = (*EmptyDeclNode)(nil)
+
+// ExtendNode represents a declaration of extension fields. Example:
+//
+//  extend google.protobuf.FieldOptions {
+//    bool redacted = 33333;
+//  }
+type ExtendNode struct {
+	compositeNode
+	Keyword    *KeywordNode
+	Extendee   IdentValueNode
+	OpenBrace  *RuneNode
+	Decls      []ExtendElement
+	CloseBrace *RuneNode
+}
+
+func (*ExtendNode) fileElement() {}
+func (*ExtendNode) msgElement()  {}
+
+// NewExtendNode creates a new *ExtendNode. All arguments must be non-nil.
+//  - keyword: The token corresponding to the "extend" keyword.
+//  - extendee: The token corresponding to the name of the extended message.
+//  - openBrace: The token corresponding to the "{" rune that starts the body.
+//  - decls: All declarations inside the message body.
+//  - closeBrace: The token corresponding to the "}" rune that ends the body.
+func NewExtendNode(keyword *KeywordNode, extendee IdentValueNode, openBrace *RuneNode, decls []ExtendElement, closeBrace *RuneNode) *ExtendNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if extendee == nil {
+		panic("extendee is nil")
+	}
+	if openBrace == nil {
+		panic("openBrace is nil")
+	}
+	if closeBrace == nil {
+		panic("closeBrace is nil")
+	}
+	children := make([]Node, 0, 4+len(decls))
+	children = append(children, keyword, extendee, openBrace)
+	for _, decl := range decls {
+		children = append(children, decl)
+	}
+	children = append(children, closeBrace)
+
+	ret := &ExtendNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:    keyword,
+		Extendee:   extendee,
+		OpenBrace:  openBrace,
+		Decls:      decls,
+		CloseBrace: closeBrace,
+	}
+	for _, decl := range decls {
+		switch decl := decl.(type) {
+		case *FieldNode:
+			decl.Extendee = ret
+		case *GroupNode:
+			decl.Extendee = ret
+		case *EmptyDeclNode:
+		default:
+			panic(fmt.Sprintf("invalid ExtendElement type: %T", decl))
+		}
+	}
+	return ret
+}
+
+// ExtendElement is an interface implemented by all AST nodes that can
+// appear in the body of an extends declaration.
+type ExtendElement interface {
+	Node
+	extendElement()
+}
+
+var _ ExtendElement = (*FieldNode)(nil)
+var _ ExtendElement = (*GroupNode)(nil)
+var _ ExtendElement = (*EmptyDeclNode)(nil)
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/no_source.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/no_source.go
new file mode 100644
index 000000000..44e02b101
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/no_source.go
@@ -0,0 +1,103 @@
+package ast
+
+// UnknownPos is a placeholder position when only the source file
+// name is known.
+func UnknownPos(filename string) *SourcePos {
+	return &SourcePos{Filename: filename}
+}
+
+// NoSourceNode is a placeholder AST node that implements numerous
+// interfaces in this package. It can be used to represent an AST
+// element for a file whose source is not available.
+type NoSourceNode struct {
+	pos *SourcePos
+}
+
+// NewNoSourceNode creates a new NoSourceNode for the given filename.
+func NewNoSourceNode(filename string) NoSourceNode {
+	return NoSourceNode{pos: UnknownPos(filename)}
+}
+
+func (n NoSourceNode) Start() *SourcePos {
+	return n.pos
+}
+
+func (n NoSourceNode) End() *SourcePos {
+	return n.pos
+}
+
+func (n NoSourceNode) LeadingComments() []Comment {
+	return nil
+}
+
+func (n NoSourceNode) TrailingComments() []Comment {
+	return nil
+}
+
+func (n NoSourceNode) GetSyntax() Node {
+	return n
+}
+
+func (n NoSourceNode) GetName() Node {
+	return n
+}
+
+func (n NoSourceNode) GetValue() ValueNode {
+	return n
+}
+
+func (n NoSourceNode) FieldLabel() Node {
+	return n
+}
+
+func (n NoSourceNode) FieldName() Node {
+	return n
+}
+
+func (n NoSourceNode) FieldType() Node {
+	return n
+}
+
+func (n NoSourceNode) FieldTag() Node {
+	return n
+}
+
+func (n NoSourceNode) FieldExtendee() Node {
+	return n
+}
+
+func (n NoSourceNode) GetGroupKeyword() Node {
+	return n
+}
+
+func (n NoSourceNode) GetOptions() *CompactOptionsNode {
+	return nil
+}
+
+func (n NoSourceNode) RangeStart() Node {
+	return n
+}
+
+func (n NoSourceNode) RangeEnd() Node {
+	return n
+}
+
+func (n NoSourceNode) GetNumber() Node {
+	return n
+}
+
+func (n NoSourceNode) MessageName() Node {
+	return n
+}
+
+func (n NoSourceNode) GetInputType() Node {
+	return n
+}
+
+func (n NoSourceNode) GetOutputType() Node {
+	return n
+}
+
+func (n NoSourceNode) Value() interface{} {
+	return nil
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/node.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/node.go
new file mode 100644
index 000000000..a2a8a3b2c
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/node.go
@@ -0,0 +1,200 @@
+package ast
+
+// Node is the interface implemented by all nodes in the AST. It
+// provides information about the span of this AST node in terms
+// of location in the source file. It also provides information
+// about all prior comments (attached as leading comments) and
+// optional subsequent comments (attached as trailing comments).
+type Node interface {
+	Start() *SourcePos
+	End() *SourcePos
+	LeadingComments() []Comment
+	TrailingComments() []Comment
+}
+
+// TerminalNode represents a leaf in the AST. These represent
+// the tokens/lexemes in the protobuf language. Comments and
+// whitespace are accumulated by the lexer and associated with
+// the following lexed token.
+type TerminalNode interface {
+	Node
+	// PopLeadingComment removes the first leading comment from this
+	// token and returns it. If the node has no leading comments then
+	// this method will panic.
+	PopLeadingComment() Comment
+	// PushTrailingComment appends the given comment to the token's
+	// trailing comments.
+	PushTrailingComment(Comment)
+	// LeadingWhitespace returns any whitespace between the prior comment
+	// (last leading comment), if any, or prior lexed token and this token.
+	LeadingWhitespace() string
+	// RawText returns the raw text of the token as read from the source.
+	RawText() string
+}
+
+var _ TerminalNode = (*StringLiteralNode)(nil)
+var _ TerminalNode = (*UintLiteralNode)(nil)
+var _ TerminalNode = (*FloatLiteralNode)(nil)
+var _ TerminalNode = (*IdentNode)(nil)
+var _ TerminalNode = (*BoolLiteralNode)(nil)
+var _ TerminalNode = (*SpecialFloatLiteralNode)(nil)
+var _ TerminalNode = (*KeywordNode)(nil)
+var _ TerminalNode = (*RuneNode)(nil)
+
+// TokenInfo represents state accumulated by the lexer to associated with a
+// token (aka terminal node).
+type TokenInfo struct {
+	// The location of the token in the source file.
+	PosRange
+	// The raw text of the token.
+	RawText string
+	// Any comments encountered preceding this token.
+	LeadingComments []Comment
+	// Any leading whitespace immediately preceding this token.
+	LeadingWhitespace string
+	// Any trailing comments following this token. This is usually
+	// empty as tokens are created by the lexer immediately and
+	// trailing comments are accounted for afterwards, added using
+	// the node's PushTrailingComment method.
+	TrailingComments []Comment
+}
+
+func (t *TokenInfo) asTerminalNode() terminalNode {
+	return terminalNode{
+		posRange:          t.PosRange,
+		leadingComments:   t.LeadingComments,
+		leadingWhitespace: t.LeadingWhitespace,
+		trailingComments:  t.TrailingComments,
+		raw:               t.RawText,
+	}
+}
+
+// CompositeNode represents any non-terminal node in the tree. These
+// are interior or root nodes and have child nodes.
+type CompositeNode interface {
+	Node
+	// All AST nodes that are immediate children of this one.
+	Children() []Node
+}
+
+// terminalNode contains book-keeping shared by all TerminalNode
+// implementations. It is embedded in all such node types in this
+// package. It provides the implementation of the TerminalNode
+// interface.
+type terminalNode struct {
+	posRange          PosRange
+	leadingComments   []Comment
+	leadingWhitespace string
+	trailingComments  []Comment
+	raw               string
+}
+
+func (n *terminalNode) Start() *SourcePos {
+	return &n.posRange.Start
+}
+
+func (n *terminalNode) End() *SourcePos {
+	return &n.posRange.End
+}
+
+func (n *terminalNode) LeadingComments() []Comment {
+	return n.leadingComments
+}
+
+func (n *terminalNode) TrailingComments() []Comment {
+	return n.trailingComments
+}
+
+func (n *terminalNode) PopLeadingComment() Comment {
+	c := n.leadingComments[0]
+	n.leadingComments = n.leadingComments[1:]
+	return c
+}
+
+func (n *terminalNode) PushTrailingComment(c Comment) {
+	n.trailingComments = append(n.trailingComments, c)
+}
+
+func (n *terminalNode) LeadingWhitespace() string {
+	return n.leadingWhitespace
+}
+
+func (n *terminalNode) RawText() string {
+	return n.raw
+}
+
+// compositeNode contains book-keeping shared by all CompositeNode
+// implementations. It is embedded in all such node types in this
+// package. It provides the implementation of the CompositeNode
+// interface.
+type compositeNode struct {
+	children []Node
+}
+
+func (n *compositeNode) Children() []Node {
+	return n.children
+}
+
+func (n *compositeNode) Start() *SourcePos {
+	return n.children[0].Start()
+}
+
+func (n *compositeNode) End() *SourcePos {
+	return n.children[len(n.children)-1].End()
+}
+
+func (n *compositeNode) LeadingComments() []Comment {
+	return n.children[0].LeadingComments()
+}
+
+func (n *compositeNode) TrailingComments() []Comment {
+	return n.children[len(n.children)-1].TrailingComments()
+}
+
+// RuneNode represents a single rune in protobuf source. Runes
+// are typically collected into tokens, but some runes stand on
+// their own, such as punctuation/symbols like commas, semicolons,
+// equals signs, open and close symbols (braces, brackets, angles,
+// and parentheses), and periods/dots.
+type RuneNode struct {
+	terminalNode
+	Rune rune
+}
+
+// NewRuneNode creates a new *RuneNode with the given properties.
+func NewRuneNode(r rune, info TokenInfo) *RuneNode {
+	return &RuneNode{
+		terminalNode: info.asTerminalNode(),
+		Rune:         r,
+	}
+}
+
+// EmptyDeclNode represents an empty declaration in protobuf source.
+// These amount to extra semicolons, with no actual content preceding
+// the semicolon.
+type EmptyDeclNode struct {
+	compositeNode
+	Semicolon *RuneNode
+}
+
+// NewEmptyDeclNode creates a new *EmptyDeclNode. The one argument must
+// be non-nil.
+func NewEmptyDeclNode(semicolon *RuneNode) *EmptyDeclNode {
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	return &EmptyDeclNode{
+		compositeNode: compositeNode{
+			children: []Node{semicolon},
+		},
+		Semicolon: semicolon,
+	}
+}
+
+func (e *EmptyDeclNode) fileElement()    {}
+func (e *EmptyDeclNode) msgElement()     {}
+func (e *EmptyDeclNode) extendElement()  {}
+func (e *EmptyDeclNode) oneOfElement()   {}
+func (e *EmptyDeclNode) enumElement()    {}
+func (e *EmptyDeclNode) serviceElement() {}
+func (e *EmptyDeclNode) methodElement()  {}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/options.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/options.go
new file mode 100644
index 000000000..9f4a74e69
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/options.go
@@ -0,0 +1,300 @@
+package ast
+
+import "fmt"
+
+// OptionDeclNode is a placeholder interface for AST nodes that represent
+// options. This allows NoSourceNode to be used in place of *OptionNode
+// for some usages.
+type OptionDeclNode interface {
+	Node
+	GetName() Node
+	GetValue() ValueNode
+}
+
+var _ OptionDeclNode = (*OptionNode)(nil)
+var _ OptionDeclNode = NoSourceNode{}
+
+// OptionNode represents the declaration of a single option for an element.
+// It is used both for normal option declarations (start with "option" keyword
+// and end with semicolon) and for compact options found in fields, enum values,
+// and extension ranges. Example:
+//
+//  option (custom.option) = "foo";
+type OptionNode struct {
+	compositeNode
+	Keyword   *KeywordNode // absent for compact options
+	Name      *OptionNameNode
+	Equals    *RuneNode
+	Val       ValueNode
+	Semicolon *RuneNode // absent for compact options
+}
+
+func (e *OptionNode) fileElement()    {}
+func (e *OptionNode) msgElement()     {}
+func (e *OptionNode) oneOfElement()   {}
+func (e *OptionNode) enumElement()    {}
+func (e *OptionNode) serviceElement() {}
+func (e *OptionNode) methodElement()  {}
+
+// NewOptionNode creates a new *OptionNode for a full option declaration (as
+// used in files, messages, oneofs, enums, services, and methods). All arguments
+// must be non-nil. (Also see NewCompactOptionNode.)
+//  - keyword: The token corresponding to the "option" keyword.
+//  - name: The token corresponding to the name of the option.
+//  - equals: The token corresponding to the "=" rune after the name.
+//  - val: The token corresponding to the option value.
+//  - semicolon: The token corresponding to the ";" rune that ends the declaration.
+func NewOptionNode(keyword *KeywordNode, name *OptionNameNode, equals *RuneNode, val ValueNode, semicolon *RuneNode) *OptionNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if equals == nil {
+		panic("equals is nil")
+	}
+	if val == nil {
+		panic("val is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	children := []Node{keyword, name, equals, val, semicolon}
+	return &OptionNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:   keyword,
+		Name:      name,
+		Equals:    equals,
+		Val:       val,
+		Semicolon: semicolon,
+	}
+}
+
+// NewCompactOptionNode creates a new *OptionNode for a full compact declaration
+// (as used in fields, enum values, and extension ranges). All arguments must be
+// non-nil.
+//  - name: The token corresponding to the name of the option.
+//  - equals: The token corresponding to the "=" rune after the name.
+//  - val: The token corresponding to the option value.
+func NewCompactOptionNode(name *OptionNameNode, equals *RuneNode, val ValueNode) *OptionNode {
+	if name == nil {
+		panic("name is nil")
+	}
+	if equals == nil {
+		panic("equals is nil")
+	}
+	if val == nil {
+		panic("val is nil")
+	}
+	children := []Node{name, equals, val}
+	return &OptionNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Name:   name,
+		Equals: equals,
+		Val:    val,
+	}
+}
+
+func (n *OptionNode) GetName() Node {
+	return n.Name
+}
+
+func (n *OptionNode) GetValue() ValueNode {
+	return n.Val
+}
+
+// OptionNameNode represents an option name or even a traversal through message
+// types to name a nested option field. Example:
+//
+//   (foo.bar).baz.(bob)
+type OptionNameNode struct {
+	compositeNode
+	Parts []*FieldReferenceNode
+	// Dots represent the separating '.' characters between name parts. The
+	// length of this slice must be exactly len(Parts)-1, each item in Parts
+	// having a corresponding item in this slice *except the last* (since a
+	// trailing dot is not allowed).
+	//
+	// These do *not* include dots that are inside of an extension name. For
+	// example: (foo.bar).baz.(bob) has three parts:
+	//    1. (foo.bar)  - an extension name
+	//    2. baz        - a regular field in foo.bar
+	//    3. (bob)      - an extension field in baz
+	// Note that the dot in foo.bar will thus not be present in Dots but is
+	// instead in Parts[0].
+	Dots []*RuneNode
+}
+
+// NewOptionNameNode creates a new *OptionNameNode. The dots arg must have a
+// length that is one less than the length of parts. The parts arg must not be
+// empty.
+func NewOptionNameNode(parts []*FieldReferenceNode, dots []*RuneNode) *OptionNameNode {
+	if len(parts) == 0 {
+		panic("must have at least one part")
+	}
+	if len(dots) != len(parts)-1 {
+		panic(fmt.Sprintf("%d parts requires %d dots, not %d", len(parts), len(parts)-1, len(dots)))
+	}
+	children := make([]Node, 0, len(parts)*2-1)
+	for i, part := range parts {
+		if part == nil {
+			panic(fmt.Sprintf("parts[%d] is nil", i))
+		}
+		if i > 0 {
+			if dots[i-1] == nil {
+				panic(fmt.Sprintf("dots[%d] is nil", i-1))
+			}
+			children = append(children, dots[i-1])
+		}
+		children = append(children, part)
+	}
+	return &OptionNameNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Parts: parts,
+		Dots:  dots,
+	}
+}
+
+// FieldReferenceNode is a reference to a field name. It can indicate a regular
+// field (simple unqualified name) or an extension field (possibly-qualified
+// name that is enclosed either in brackets or parentheses).
+//
+// This is used in options to indicate the names of custom options (which are
+// actually extensions), in which case the name is enclosed in parentheses "("
+// and ")". It is also used in message literals to set extension fields, in
+// which case the name is enclosed in square brackets "[" and "]".
+//
+// Example:
+//   (foo.bar)
+type FieldReferenceNode struct {
+	compositeNode
+	Open  *RuneNode // only present for extension names
+	Name  IdentValueNode
+	Close *RuneNode // only present for extension names
+}
+
+// NewFieldReferenceNode creates a new *FieldReferenceNode for a regular field.
+// The name arg must not be nil.
+func NewFieldReferenceNode(name *IdentNode) *FieldReferenceNode {
+	if name == nil {
+		panic("name is nil")
+	}
+	children := []Node{name}
+	return &FieldReferenceNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Name: name,
+	}
+}
+
+// NewExtensionFieldReferenceNode creates a new *FieldReferenceNode for an
+// extension field. All args must be non-nil. The openSym and closeSym runes
+// should be "(" and ")" or "[" and "]".
+func NewExtensionFieldReferenceNode(openSym *RuneNode, name IdentValueNode, closeSym *RuneNode) *FieldReferenceNode {
+	if name == nil {
+		panic("name is nil")
+	}
+	if openSym == nil {
+		panic("openSym is nil")
+	}
+	if closeSym == nil {
+		panic("closeSym is nil")
+	}
+	children := []Node{openSym, name, closeSym}
+	return &FieldReferenceNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Open:  openSym,
+		Name:  name,
+		Close: closeSym,
+	}
+}
+
+// IsExtension reports if this is an extension name or not (e.g. enclosed in
+// punctuation, such as parentheses or brackets).
+func (a *FieldReferenceNode) IsExtension() bool {
+	return a.Open != nil
+}
+
+func (a *FieldReferenceNode) Value() string {
+	if a.Open != nil {
+		return string(a.Open.Rune) + string(a.Name.AsIdentifier()) + string(a.Close.Rune)
+	} else {
+		return string(a.Name.AsIdentifier())
+	}
+}
+
+// CompactOptionsNode represents a compact options declaration, as used with
+// fields, enum values, and extension ranges. Example:
+//
+//  [deprecated = true, json_name = "foo_bar"]
+type CompactOptionsNode struct {
+	compositeNode
+	OpenBracket *RuneNode
+	Options     []*OptionNode
+	// Commas represent the separating ',' characters between options. The
+	// length of this slice must be exactly len(Options)-1, with each item
+	// in Options having a corresponding item in this slice *except the last*
+	// (since a trailing comma is not allowed).
+	Commas       []*RuneNode
+	CloseBracket *RuneNode
+}
+
+// NewCompactOptionsNode creates a *CompactOptionsNode. All args must be
+// non-nil. The commas arg must have a length that is one less than the
+// length of opts. The opts arg must not be empty.
+func NewCompactOptionsNode(openBracket *RuneNode, opts []*OptionNode, commas []*RuneNode, closeBracket *RuneNode) *CompactOptionsNode {
+	if openBracket == nil {
+		panic("openBracket is nil")
+	}
+	if closeBracket == nil {
+		panic("closeBracket is nil")
+	}
+	if len(opts) == 0 {
+		panic("must have at least one part")
+	}
+	if len(commas) != len(opts)-1 {
+		panic(fmt.Sprintf("%d opts requires %d commas, not %d", len(opts), len(opts)-1, len(commas)))
+	}
+	children := make([]Node, 0, len(opts)*2+1)
+	children = append(children, openBracket)
+	for i, opt := range opts {
+		if i > 0 {
+			if commas[i-1] == nil {
+				panic(fmt.Sprintf("commas[%d] is nil", i-1))
+			}
+			children = append(children, commas[i-1])
+		}
+		if opt == nil {
+			panic(fmt.Sprintf("opts[%d] is nil", i))
+		}
+		children = append(children, opt)
+	}
+	children = append(children, closeBracket)
+
+	return &CompactOptionsNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		OpenBracket:  openBracket,
+		Options:      opts,
+		Commas:       commas,
+		CloseBracket: closeBracket,
+	}
+}
+
+func (e *CompactOptionsNode) GetElements() []*OptionNode {
+	if e == nil {
+		return nil
+	}
+	return e.Options
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/print.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/print.go
new file mode 100644
index 000000000..271200c73
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/print.go
@@ -0,0 +1,86 @@
+package ast
+
+import "io"
+
+// Print prints the given AST node to the given output. This operation
+// basically walks the AST and, for each TerminalNode, prints the node's
+// leading comments, leading whitespace, the node's raw text, and then
+// any trailing comments. If the given node is a *FileNode, it will then
+// also print the file's FinalComments and FinalWhitespace.
+func Print(w io.Writer, node Node) error {
+	sw, ok := w.(stringWriter)
+	if !ok {
+		sw = &strWriter{w}
+	}
+	var err error
+	Walk(node, func(n Node) (bool, VisitFunc) {
+		if err != nil {
+			return false, nil
+		}
+		token, ok := n.(TerminalNode)
+		if !ok {
+			return true, nil
+		}
+
+		err = printComments(sw, token.LeadingComments())
+		if err != nil {
+			return false, nil
+		}
+
+		_, err = sw.WriteString(token.LeadingWhitespace())
+		if err != nil {
+			return false, nil
+		}
+
+		_, err = sw.WriteString(token.RawText())
+		if err != nil {
+			return false, nil
+		}
+
+		err = printComments(sw, token.TrailingComments())
+		return false, nil
+	})
+	if err != nil {
+		return err
+	}
+
+	if file, ok := node.(*FileNode); ok {
+		err = printComments(sw, file.FinalComments)
+		if err != nil {
+			return err
+		}
+		_, err = sw.WriteString(file.FinalWhitespace)
+		return err
+	}
+
+	return nil
+}
+
+func printComments(sw stringWriter, comments []Comment) error {
+	for _, comment := range comments {
+		if _, err := sw.WriteString(comment.LeadingWhitespace); err != nil {
+			return err
+		}
+		if _, err := sw.WriteString(comment.Text); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+// many io.Writer impls also provide a string-based method
+type stringWriter interface {
+	WriteString(s string) (n int, err error)
+}
+
+// adapter, in case the given writer does NOT provide a string-based method
+type strWriter struct {
+	io.Writer
+}
+
+func (s *strWriter) WriteString(str string) (int, error) {
+	if str == "" {
+		return 0, nil
+	}
+	return s.Write([]byte(str))
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/ranges.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/ranges.go
new file mode 100644
index 000000000..341676f33
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/ranges.go
@@ -0,0 +1,305 @@
+package ast
+
+import "fmt"
+
+// ExtensionRangeNode represents an extension range declaration in an extendable
+// message. Example:
+//
+//  extensions 100 to max;
+type ExtensionRangeNode struct {
+	compositeNode
+	Keyword *KeywordNode
+	Ranges  []*RangeNode
+	// Commas represent the separating ',' characters between ranges. The
+	// length of this slice must be exactly len(Ranges)-1, each item in Ranges
+	// having a corresponding item in this slice *except the last* (since a
+	// trailing comma is not allowed).
+	Commas    []*RuneNode
+	Options   *CompactOptionsNode
+	Semicolon *RuneNode
+}
+
+func (e *ExtensionRangeNode) msgElement() {}
+
+// NewExtensionRangeNode creates a new *ExtensionRangeNode. All args must be
+// non-nil except opts, which may be nil.
+//  - keyword: The token corresponding to the "extends" keyword.
+//  - ranges: One or more range expressions.
+//  - commas: Tokens that represent the "," runes that delimit the range expressions.
+//    The length of commas must be one less than the length of ranges.
+//  - opts: The node corresponding to options that apply to each of the ranges.
+//  - semicolon The token corresponding to the ";" rune that ends the declaration.
+func NewExtensionRangeNode(keyword *KeywordNode, ranges []*RangeNode, commas []*RuneNode, opts *CompactOptionsNode, semicolon *RuneNode) *ExtensionRangeNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	if len(ranges) == 0 {
+		panic("must have at least one range")
+	}
+	if len(commas) != len(ranges)-1 {
+		panic(fmt.Sprintf("%d ranges requires %d commas, not %d", len(ranges), len(ranges)-1, len(commas)))
+	}
+	numChildren := len(ranges)*2 + 1
+	if opts != nil {
+		numChildren++
+	}
+	children := make([]Node, 0, numChildren)
+	children = append(children, keyword)
+	for i, rng := range ranges {
+		if i > 0 {
+			if commas[i-1] == nil {
+				panic(fmt.Sprintf("commas[%d] is nil", i-1))
+			}
+			children = append(children, commas[i-1])
+		}
+		if rng == nil {
+			panic(fmt.Sprintf("ranges[%d] is nil", i))
+		}
+		children = append(children, rng)
+	}
+	if opts != nil {
+		children = append(children, opts)
+	}
+	children = append(children, semicolon)
+	return &ExtensionRangeNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:   keyword,
+		Ranges:    ranges,
+		Commas:    commas,
+		Options:   opts,
+		Semicolon: semicolon,
+	}
+}
+
+// RangeDeclNode is a placeholder interface for AST nodes that represent
+// numeric values. This allows NoSourceNode to be used in place of *RangeNode
+// for some usages.
+type RangeDeclNode interface {
+	Node
+	RangeStart() Node
+	RangeEnd() Node
+}
+
+var _ RangeDeclNode = (*RangeNode)(nil)
+var _ RangeDeclNode = NoSourceNode{}
+
+// RangeNode represents a range expression, used in both extension ranges and
+// reserved ranges. Example:
+//
+//  1000 to max
+type RangeNode struct {
+	compositeNode
+	StartVal IntValueNode
+	// if To is non-nil, then exactly one of EndVal or Max must also be non-nil
+	To *KeywordNode
+	// EndVal and Max are mutually exclusive
+	EndVal IntValueNode
+	Max    *KeywordNode
+}
+
+// NewRangeNode creates a new *RangeNode. The start argument must be non-nil.
+// The to argument represents the "to" keyword. If present (i.e. if it is non-nil),
+// then so must be exactly one of end or max. If max is non-nil, it indicates a
+// "100 to max" style range. But if end is non-nil, the end of the range is a
+// literal, such as "100 to 200".
+func NewRangeNode(start IntValueNode, to *KeywordNode, end IntValueNode, max *KeywordNode) *RangeNode {
+	if start == nil {
+		panic("start is nil")
+	}
+	numChildren := 1
+	if to != nil {
+		if end == nil && max == nil {
+			panic("to is not nil, but end and max both are")
+		}
+		if end != nil && max != nil {
+			panic("end and max cannot be both non-nil")
+		}
+		numChildren = 3
+	} else {
+		if end != nil {
+			panic("to is nil, but end is not")
+		}
+		if max != nil {
+			panic("to is nil, but max is not")
+		}
+	}
+	children := make([]Node, 0, numChildren)
+	children = append(children, start)
+	if to != nil {
+		children = append(children, to)
+		if end != nil {
+			children = append(children, end)
+		} else {
+			children = append(children, max)
+		}
+	}
+	return &RangeNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		StartVal: start,
+		To:       to,
+		EndVal:   end,
+		Max:      max,
+	}
+}
+
+func (n *RangeNode) RangeStart() Node {
+	return n.StartVal
+}
+
+func (n *RangeNode) RangeEnd() Node {
+	if n.Max != nil {
+		return n.Max
+	}
+	if n.EndVal != nil {
+		return n.EndVal
+	}
+	return n.StartVal
+}
+
+func (n *RangeNode) StartValue() interface{} {
+	return n.StartVal.Value()
+}
+
+func (n *RangeNode) StartValueAsInt32(min, max int32) (int32, bool) {
+	return AsInt32(n.StartVal, min, max)
+}
+
+func (n *RangeNode) EndValue() interface{} {
+	if n.EndVal == nil {
+		return nil
+	}
+	return n.EndVal.Value()
+}
+
+func (n *RangeNode) EndValueAsInt32(min, max int32) (int32, bool) {
+	if n.Max != nil {
+		return max, true
+	}
+	if n.EndVal == nil {
+		return n.StartValueAsInt32(min, max)
+	}
+	return AsInt32(n.EndVal, min, max)
+}
+
+// ReservedNode represents reserved declaration, whic can be used to reserve
+// either names or numbers. Examples:
+//
+//   reserved 1, 10-12, 15;
+//   reserved "foo", "bar", "baz";
+type ReservedNode struct {
+	compositeNode
+	Keyword *KeywordNode
+	// If non-empty, this node represents reserved ranges and Names will be empty.
+	Ranges []*RangeNode
+	// If non-empty, this node represents reserved names and Ranges will be empty.
+	Names []StringValueNode
+	// Commas represent the separating ',' characters between options. The
+	// length of this slice must be exactly len(Ranges)-1 or len(Names)-1, depending
+	// on whether this node represents reserved ranges or reserved names. Each item
+	// in Ranges or Names has a corresponding item in this slice *except the last*
+	// (since a trailing comma is not allowed).
+	Commas    []*RuneNode
+	Semicolon *RuneNode
+}
+
+func (*ReservedNode) msgElement()  {}
+func (*ReservedNode) enumElement() {}
+
+// NewReservedRangesNode creates a new *ReservedNode that represents reserved
+// numeric ranges. All args must be non-nil.
+//  - keyword: The token corresponding to the "reserved" keyword.
+//  - ranges: One or more range expressions.
+//  - commas: Tokens that represent the "," runes that delimit the range expressions.
+//    The length of commas must be one less than the length of ranges.
+//  - semicolon The token corresponding to the ";" rune that ends the declaration.
+func NewReservedRangesNode(keyword *KeywordNode, ranges []*RangeNode, commas []*RuneNode, semicolon *RuneNode) *ReservedNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	if len(ranges) == 0 {
+		panic("must have at least one range")
+	}
+	if len(commas) != len(ranges)-1 {
+		panic(fmt.Sprintf("%d ranges requires %d commas, not %d", len(ranges), len(ranges)-1, len(commas)))
+	}
+	children := make([]Node, 0, len(ranges)*2+1)
+	children = append(children, keyword)
+	for i, rng := range ranges {
+		if i > 0 {
+			if commas[i-1] == nil {
+				panic(fmt.Sprintf("commas[%d] is nil", i-1))
+			}
+			children = append(children, commas[i-1])
+		}
+		if rng == nil {
+			panic(fmt.Sprintf("ranges[%d] is nil", i))
+		}
+		children = append(children, rng)
+	}
+	children = append(children, semicolon)
+	return &ReservedNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:   keyword,
+		Ranges:    ranges,
+		Commas:    commas,
+		Semicolon: semicolon,
+	}
+}
+
+// NewReservedNamesNode creates a new *ReservedNode that represents reserved
+// names. All args must be non-nil.
+//  - keyword: The token corresponding to the "reserved" keyword.
+//  - names: One or more names.
+//  - commas: Tokens that represent the "," runes that delimit the names.
+//    The length of commas must be one less than the length of names.
+//  - semicolon The token corresponding to the ";" rune that ends the declaration.
+func NewReservedNamesNode(keyword *KeywordNode, names []StringValueNode, commas []*RuneNode, semicolon *RuneNode) *ReservedNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	if len(names) == 0 {
+		panic("must have at least one name")
+	}
+	if len(commas) != len(names)-1 {
+		panic(fmt.Sprintf("%d names requires %d commas, not %d", len(names), len(names)-1, len(commas)))
+	}
+	children := make([]Node, 0, len(names)*2+1)
+	children = append(children, keyword)
+	for i, name := range names {
+		if i > 0 {
+			if commas[i-1] == nil {
+				panic(fmt.Sprintf("commas[%d] is nil", i-1))
+			}
+			children = append(children, commas[i-1])
+		}
+		if name == nil {
+			panic(fmt.Sprintf("names[%d] is nil", i))
+		}
+		children = append(children, name)
+	}
+	children = append(children, semicolon)
+	return &ReservedNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:   keyword,
+		Names:     names,
+		Commas:    commas,
+		Semicolon: semicolon,
+	}
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/service.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/service.go
new file mode 100644
index 000000000..d8cfe8b5a
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/service.go
@@ -0,0 +1,273 @@
+package ast
+
+import "fmt"
+
+// ServiceNode represents a service declaration. Example:
+//
+//  service Foo {
+//    rpc Bar (Baz) returns (Bob);
+//    rpc Frobnitz (stream Parts) returns (Gyzmeaux);
+//  }
+type ServiceNode struct {
+	compositeNode
+	Keyword    *KeywordNode
+	Name       *IdentNode
+	OpenBrace  *RuneNode
+	Decls      []ServiceElement
+	CloseBrace *RuneNode
+}
+
+func (*ServiceNode) fileElement() {}
+
+// NewServiceNode creates a new *ServiceNode. All arguments must be non-nil.
+//  - keyword: The token corresponding to the "service" keyword.
+//  - name: The token corresponding to the service's name.
+//  - openBrace: The token corresponding to the "{" rune that starts the body.
+//  - decls: All declarations inside the service body.
+//  - closeBrace: The token corresponding to the "}" rune that ends the body.
+func NewServiceNode(keyword *KeywordNode, name *IdentNode, openBrace *RuneNode, decls []ServiceElement, closeBrace *RuneNode) *ServiceNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if openBrace == nil {
+		panic("openBrace is nil")
+	}
+	if closeBrace == nil {
+		panic("closeBrace is nil")
+	}
+	children := make([]Node, 0, 4+len(decls))
+	children = append(children, keyword, name, openBrace)
+	for _, decl := range decls {
+		children = append(children, decl)
+	}
+	children = append(children, closeBrace)
+
+	for _, decl := range decls {
+		switch decl := decl.(type) {
+		case *OptionNode, *RPCNode, *EmptyDeclNode:
+		default:
+			panic(fmt.Sprintf("invalid ServiceElement type: %T", decl))
+		}
+	}
+
+	return &ServiceNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:    keyword,
+		Name:       name,
+		OpenBrace:  openBrace,
+		Decls:      decls,
+		CloseBrace: closeBrace,
+	}
+}
+
+// ServiceElement is an interface implemented by all AST nodes that can
+// appear in the body of a service declaration.
+type ServiceElement interface {
+	Node
+	serviceElement()
+}
+
+var _ ServiceElement = (*OptionNode)(nil)
+var _ ServiceElement = (*RPCNode)(nil)
+var _ ServiceElement = (*EmptyDeclNode)(nil)
+
+// RPCDeclNode is a placeholder interface for AST nodes that represent RPC
+// declarations. This allows NoSourceNode to be used in place of *RPCNode
+// for some usages.
+type RPCDeclNode interface {
+	Node
+	GetInputType() Node
+	GetOutputType() Node
+}
+
+var _ RPCDeclNode = (*RPCNode)(nil)
+var _ RPCDeclNode = NoSourceNode{}
+
+// RPCNode represents an RPC declaration. Example:
+//
+//  rpc Foo (Bar) returns (Baz);
+type RPCNode struct {
+	compositeNode
+	Keyword    *KeywordNode
+	Name       *IdentNode
+	Input      *RPCTypeNode
+	Returns    *KeywordNode
+	Output     *RPCTypeNode
+	Semicolon  *RuneNode
+	OpenBrace  *RuneNode
+	Decls      []RPCElement
+	CloseBrace *RuneNode
+}
+
+func (n *RPCNode) serviceElement() {}
+
+// NewRPCNode creates a new *RPCNode with no body. All arguments must be non-nil.
+//  - keyword: The token corresponding to the "rpc" keyword.
+//  - name: The token corresponding to the RPC's name.
+//  - input: The token corresponding to the RPC input message type.
+//  - returns: The token corresponding to the "returns" keyword that precedes the output type.
+//  - output: The token corresponding to the RPC output message type.
+//  - semicolon: The token corresponding to the ";" rune that ends the declaration.
+func NewRPCNode(keyword *KeywordNode, name *IdentNode, input *RPCTypeNode, returns *KeywordNode, output *RPCTypeNode, semicolon *RuneNode) *RPCNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if input == nil {
+		panic("input is nil")
+	}
+	if returns == nil {
+		panic("returns is nil")
+	}
+	if output == nil {
+		panic("output is nil")
+	}
+	if semicolon == nil {
+		panic("semicolon is nil")
+	}
+	children := []Node{keyword, name, input, returns, output, semicolon}
+	return &RPCNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:   keyword,
+		Name:      name,
+		Input:     input,
+		Returns:   returns,
+		Output:    output,
+		Semicolon: semicolon,
+	}
+}
+
+// NewRPCNodeWithBody creates a new *RPCNode that includes a body (and possibly
+// options). All arguments must be non-nil.
+//  - keyword: The token corresponding to the "rpc" keyword.
+//  - name: The token corresponding to the RPC's name.
+//  - input: The token corresponding to the RPC input message type.
+//  - returns: The token corresponding to the "returns" keyword that precedes the output type.
+//  - output: The token corresponding to the RPC output message type.
+//  - openBrace: The token corresponding to the "{" rune that starts the body.
+//  - decls: All declarations inside the RPC body.
+//  - closeBrace: The token corresponding to the "}" rune that ends the body.
+func NewRPCNodeWithBody(keyword *KeywordNode, name *IdentNode, input *RPCTypeNode, returns *KeywordNode, output *RPCTypeNode, openBrace *RuneNode, decls []RPCElement, closeBrace *RuneNode) *RPCNode {
+	if keyword == nil {
+		panic("keyword is nil")
+	}
+	if name == nil {
+		panic("name is nil")
+	}
+	if input == nil {
+		panic("input is nil")
+	}
+	if returns == nil {
+		panic("returns is nil")
+	}
+	if output == nil {
+		panic("output is nil")
+	}
+	if openBrace == nil {
+		panic("openBrace is nil")
+	}
+	if closeBrace == nil {
+		panic("closeBrace is nil")
+	}
+	children := make([]Node, 0, 7+len(decls))
+	children = append(children, keyword, name, input, returns, output, openBrace)
+	for _, decl := range decls {
+		children = append(children, decl)
+	}
+	children = append(children, closeBrace)
+
+	for _, decl := range decls {
+		switch decl := decl.(type) {
+		case *OptionNode, *EmptyDeclNode:
+		default:
+			panic(fmt.Sprintf("invalid RPCElement type: %T", decl))
+		}
+	}
+
+	return &RPCNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Keyword:    keyword,
+		Name:       name,
+		Input:      input,
+		Returns:    returns,
+		Output:     output,
+		OpenBrace:  openBrace,
+		Decls:      decls,
+		CloseBrace: closeBrace,
+	}
+}
+
+func (n *RPCNode) GetInputType() Node {
+	return n.Input.MessageType
+}
+
+func (n *RPCNode) GetOutputType() Node {
+	return n.Output.MessageType
+}
+
+// RPCElement is an interface implemented by all AST nodes that can
+// appear in the body of an rpc declaration (aka method).
+type RPCElement interface {
+	Node
+	methodElement()
+}
+
+var _ RPCElement = (*OptionNode)(nil)
+var _ RPCElement = (*EmptyDeclNode)(nil)
+
+// RPCTypeNode represents the declaration of a request or response type for an
+// RPC. Example:
+//
+//  (stream foo.Bar)
+type RPCTypeNode struct {
+	compositeNode
+	OpenParen   *RuneNode
+	Stream      *KeywordNode
+	MessageType IdentValueNode
+	CloseParen  *RuneNode
+}
+
+// NewRPCTypeNode creates a new *RPCTypeNode. All arguments must be non-nil
+// except stream, which may be nil.
+//  - openParen: The token corresponding to the "(" rune that starts the declaration.
+//  - stream: The token corresponding to the "stream" keyword or nil if not present.
+//  - msgType: The token corresponding to the message type's name.
+//  - closeParen: The token corresponding to the ")" rune that ends the declaration.
+func NewRPCTypeNode(openParen *RuneNode, stream *KeywordNode, msgType IdentValueNode, closeParen *RuneNode) *RPCTypeNode {
+	if openParen == nil {
+		panic("openParen is nil")
+	}
+	if msgType == nil {
+		panic("msgType is nil")
+	}
+	if closeParen == nil {
+		panic("closeParen is nil")
+	}
+	var children []Node
+	if stream != nil {
+		children = []Node{openParen, stream, msgType, closeParen}
+	} else {
+		children = []Node{openParen, msgType, closeParen}
+	}
+
+	return &RPCTypeNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		OpenParen:   openParen,
+		Stream:      stream,
+		MessageType: msgType,
+		CloseParen:  closeParen,
+	}
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/source_pos.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/source_pos.go
new file mode 100644
index 000000000..7346a84c5
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/source_pos.go
@@ -0,0 +1,38 @@
+package ast
+
+import "fmt"
+
+// SourcePos identifies a location in a proto source file.
+type SourcePos struct {
+	Filename  string
+	Line, Col int
+	Offset    int
+}
+
+func (pos SourcePos) String() string {
+	if pos.Line <= 0 || pos.Col <= 0 {
+		return pos.Filename
+	}
+	return fmt.Sprintf("%s:%d:%d", pos.Filename, pos.Line, pos.Col)
+}
+
+// PosRange is a range of positions in a source file that indicates
+// the span of some region of source, such as a single token or
+// a sub-tree of the AST.
+type PosRange struct {
+	Start, End SourcePos
+}
+
+// Comment represents a single comment in a source file. It indicates
+// the position of the comment and its contents.
+type Comment struct {
+	// The location of the comment in the source file.
+	PosRange
+	// Any whitespace between the prior lexical element (either a token
+	// or other comment) and this comment.
+	LeadingWhitespace string
+	// The text of the comment, including any "//" or "/*" and "*/"
+	// symbols at the start and end. Single-line comments will include
+	// the trailing newline rune in Text.
+	Text string
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/values.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/values.go
new file mode 100644
index 000000000..b19ab47bc
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/values.go
@@ -0,0 +1,563 @@
+package ast
+
+import (
+	"fmt"
+	"math"
+	"strings"
+)
+
+// ValueNode is an AST node that represents a literal value.
+//
+// It also includes references (e.g. IdentifierValueNode), which can be
+// used as values in some contexts, such as describing the default value
+// for a field, which can refer to an enum value.
+//
+// This also allows NoSourceNode to be used in place of a real value node
+// for some usages.
+type ValueNode interface {
+	Node
+	// Value returns a Go representation of the value. For scalars, this
+	// will be a string, int64, uint64, float64, or bool. This could also
+	// be an Identifier (e.g. IdentValueNodes). It can also be a composite
+	// literal:
+	//   * For array literals, the type returned will be []ValueNode
+	//   * For message literals, the type returned will be []*MessageFieldNode
+	Value() interface{}
+}
+
+var _ ValueNode = (*IdentNode)(nil)
+var _ ValueNode = (*CompoundIdentNode)(nil)
+var _ ValueNode = (*StringLiteralNode)(nil)
+var _ ValueNode = (*CompoundStringLiteralNode)(nil)
+var _ ValueNode = (*UintLiteralNode)(nil)
+var _ ValueNode = (*PositiveUintLiteralNode)(nil)
+var _ ValueNode = (*NegativeIntLiteralNode)(nil)
+var _ ValueNode = (*FloatLiteralNode)(nil)
+var _ ValueNode = (*SpecialFloatLiteralNode)(nil)
+var _ ValueNode = (*SignedFloatLiteralNode)(nil)
+var _ ValueNode = (*BoolLiteralNode)(nil)
+var _ ValueNode = (*ArrayLiteralNode)(nil)
+var _ ValueNode = (*MessageLiteralNode)(nil)
+var _ ValueNode = NoSourceNode{}
+
+// StringValueNode is an AST node that represents a string literal.
+// Such a node can be a single literal (*StringLiteralNode) or a
+// concatenation of multiple literals (*CompoundStringLiteralNode).
+type StringValueNode interface {
+	ValueNode
+	AsString() string
+}
+
+var _ StringValueNode = (*StringLiteralNode)(nil)
+var _ StringValueNode = (*CompoundStringLiteralNode)(nil)
+
+// StringLiteralNode represents a simple string literal. Example:
+//
+//  "proto2"
+type StringLiteralNode struct {
+	terminalNode
+	// Val is the actual string value that the literal indicates.
+	Val string
+}
+
+// NewStringLiteralNode creates a new *StringLiteralNode with the given val.
+func NewStringLiteralNode(val string, info TokenInfo) *StringLiteralNode {
+	return &StringLiteralNode{
+		terminalNode: info.asTerminalNode(),
+		Val:          val,
+	}
+}
+
+func (n *StringLiteralNode) Value() interface{} {
+	return n.AsString()
+}
+
+func (n *StringLiteralNode) AsString() string {
+	return n.Val
+}
+
+// CompoundStringLiteralNode represents a compound string literal, which is
+// the concatenaton of adjacent string literals. Example:
+//
+//  "this "  "is"   " all one "   "string"
+type CompoundStringLiteralNode struct {
+	compositeNode
+	Val string
+}
+
+// NewCompoundLiteralStringNode creates a new *CompoundStringLiteralNode that
+// consists of the given string components. The components argument may not be
+// empty.
+func NewCompoundLiteralStringNode(components ...*StringLiteralNode) *CompoundStringLiteralNode {
+	if len(components) == 0 {
+		panic("must have at least one component")
+	}
+	children := make([]Node, len(components))
+	var b strings.Builder
+	for i, comp := range components {
+		children[i] = comp
+		b.WriteString(comp.Val)
+	}
+	return &CompoundStringLiteralNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Val: b.String(),
+	}
+}
+
+func (n *CompoundStringLiteralNode) Value() interface{} {
+	return n.AsString()
+}
+
+func (n *CompoundStringLiteralNode) AsString() string {
+	return n.Val
+}
+
+// IntValueNode is an AST node that represents an integer literal. If
+// an integer literal is too large for an int64 (or uint64 for
+// positive literals), it is represented instead by a FloatValueNode.
+type IntValueNode interface {
+	ValueNode
+	AsInt64() (int64, bool)
+	AsUint64() (uint64, bool)
+}
+
+// AsInt32 range checks the given int value and returns its value is
+// in the range or 0, false if it is outside the range.
+func AsInt32(n IntValueNode, min, max int32) (int32, bool) {
+	i, ok := n.AsInt64()
+	if !ok {
+		return 0, false
+	}
+	if i < int64(min) || i > int64(max) {
+		return 0, false
+	}
+	return int32(i), true
+}
+
+var _ IntValueNode = (*UintLiteralNode)(nil)
+var _ IntValueNode = (*PositiveUintLiteralNode)(nil)
+var _ IntValueNode = (*NegativeIntLiteralNode)(nil)
+
+// UintLiteralNode represents a simple integer literal with no sign character.
+type UintLiteralNode struct {
+	terminalNode
+	// Val is the numeric value indicated by the literal
+	Val uint64
+}
+
+// NewUintLiteralNode creates a new *UintLiteralNode with the given val.
+func NewUintLiteralNode(val uint64, info TokenInfo) *UintLiteralNode {
+	return &UintLiteralNode{
+		terminalNode: info.asTerminalNode(),
+		Val:          val,
+	}
+}
+
+func (n *UintLiteralNode) Value() interface{} {
+	return n.Val
+}
+
+func (n *UintLiteralNode) AsInt64() (int64, bool) {
+	if n.Val > math.MaxInt64 {
+		return 0, false
+	}
+	return int64(n.Val), true
+}
+
+func (n *UintLiteralNode) AsUint64() (uint64, bool) {
+	return n.Val, true
+}
+
+func (n *UintLiteralNode) AsFloat() float64 {
+	return float64(n.Val)
+}
+
+// PositiveUintLiteralNode represents an integer literal with a positive (+) sign.
+type PositiveUintLiteralNode struct {
+	compositeNode
+	Plus *RuneNode
+	Uint *UintLiteralNode
+	Val  uint64
+}
+
+// NewPositiveUintLiteralNode creates a new *PositiveUintLiteralNode. Both
+// arguments must be non-nil.
+func NewPositiveUintLiteralNode(sign *RuneNode, i *UintLiteralNode) *PositiveUintLiteralNode {
+	if sign == nil {
+		panic("sign is nil")
+	}
+	if i == nil {
+		panic("i is nil")
+	}
+	children := []Node{sign, i}
+	return &PositiveUintLiteralNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Plus: sign,
+		Uint: i,
+		Val:  i.Val,
+	}
+}
+
+func (n *PositiveUintLiteralNode) Value() interface{} {
+	return n.Val
+}
+
+func (n *PositiveUintLiteralNode) AsInt64() (int64, bool) {
+	if n.Val > math.MaxInt64 {
+		return 0, false
+	}
+	return int64(n.Val), true
+}
+
+func (n *PositiveUintLiteralNode) AsUint64() (uint64, bool) {
+	return n.Val, true
+}
+
+// NegativeIntLiteralNode represents an integer literal with a negative (-) sign.
+type NegativeIntLiteralNode struct {
+	compositeNode
+	Minus *RuneNode
+	Uint  *UintLiteralNode
+	Val   int64
+}
+
+// NewNegativeIntLiteralNode creates a new *NegativeIntLiteralNode. Both
+// arguments must be non-nil.
+func NewNegativeIntLiteralNode(sign *RuneNode, i *UintLiteralNode) *NegativeIntLiteralNode {
+	if sign == nil {
+		panic("sign is nil")
+	}
+	if i == nil {
+		panic("i is nil")
+	}
+	children := []Node{sign, i}
+	return &NegativeIntLiteralNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Minus: sign,
+		Uint:  i,
+		Val:   -int64(i.Val),
+	}
+}
+
+func (n *NegativeIntLiteralNode) Value() interface{} {
+	return n.Val
+}
+
+func (n *NegativeIntLiteralNode) AsInt64() (int64, bool) {
+	return n.Val, true
+}
+
+func (n *NegativeIntLiteralNode) AsUint64() (uint64, bool) {
+	if n.Val < 0 {
+		return 0, false
+	}
+	return uint64(n.Val), true
+}
+
+// FloatValueNode is an AST node that represents a numeric literal with
+// a floating point, in scientific notation, or too large to fit in an
+// int64 or uint64.
+type FloatValueNode interface {
+	ValueNode
+	AsFloat() float64
+}
+
+var _ FloatValueNode = (*FloatLiteralNode)(nil)
+var _ FloatValueNode = (*SpecialFloatLiteralNode)(nil)
+var _ FloatValueNode = (*UintLiteralNode)(nil)
+
+// FloatLiteralNode represents a floating point numeric literal.
+type FloatLiteralNode struct {
+	terminalNode
+	// Val is the numeric value indicated by the literal
+	Val float64
+}
+
+// NewFloatLiteralNode creates a new *FloatLiteralNode with the given val.
+func NewFloatLiteralNode(val float64, info TokenInfo) *FloatLiteralNode {
+	return &FloatLiteralNode{
+		terminalNode: info.asTerminalNode(),
+		Val:          val,
+	}
+}
+
+func (n *FloatLiteralNode) Value() interface{} {
+	return n.AsFloat()
+}
+
+func (n *FloatLiteralNode) AsFloat() float64 {
+	return n.Val
+}
+
+// SpecialFloatLiteralNode represents a special floating point numeric literal
+// for "inf" and "nan" values.
+type SpecialFloatLiteralNode struct {
+	*KeywordNode
+	Val float64
+}
+
+// NewSpecialFloatLiteralNode returns a new *SpecialFloatLiteralNode for the
+// given keyword, which must be "inf" or "nan".
+func NewSpecialFloatLiteralNode(name *KeywordNode) *SpecialFloatLiteralNode {
+	var f float64
+	if name.Val == "inf" {
+		f = math.Inf(1)
+	} else {
+		f = math.NaN()
+	}
+	return &SpecialFloatLiteralNode{
+		KeywordNode: name,
+		Val:         f,
+	}
+}
+
+func (n *SpecialFloatLiteralNode) Value() interface{} {
+	return n.AsFloat()
+}
+
+func (n *SpecialFloatLiteralNode) AsFloat() float64 {
+	return n.Val
+}
+
+// SignedFloatLiteralNode represents a signed floating point number.
+type SignedFloatLiteralNode struct {
+	compositeNode
+	Sign  *RuneNode
+	Float FloatValueNode
+	Val   float64
+}
+
+// NewSignedFloatLiteralNode creates a new *SignedFloatLiteralNode. Both
+// arguments must be non-nil.
+func NewSignedFloatLiteralNode(sign *RuneNode, f FloatValueNode) *SignedFloatLiteralNode {
+	if sign == nil {
+		panic("sign is nil")
+	}
+	if f == nil {
+		panic("f is nil")
+	}
+	children := []Node{sign, f}
+	val := f.AsFloat()
+	if sign.Rune == '-' {
+		val = -val
+	}
+	return &SignedFloatLiteralNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Sign:  sign,
+		Float: f,
+		Val:   val,
+	}
+}
+
+func (n *SignedFloatLiteralNode) Value() interface{} {
+	return n.Val
+}
+
+func (n *SignedFloatLiteralNode) AsFloat() float64 {
+	return n.Val
+}
+
+// BoolLiteralNode represents a boolean literal.
+type BoolLiteralNode struct {
+	*KeywordNode
+	Val bool
+}
+
+// NewBoolLiteralNode returns a new *BoolLiteralNode for the given keyword,
+// which must be "true" or "false".
+func NewBoolLiteralNode(name *KeywordNode) *BoolLiteralNode {
+	return &BoolLiteralNode{
+		KeywordNode: name,
+		Val:         name.Val == "true",
+	}
+}
+
+func (n *BoolLiteralNode) Value() interface{} {
+	return n.Val
+}
+
+// ArrayLiteralNode represents an array literal, which is only allowed inside of
+// a MessageLiteralNode, to indicate values for a repeated field. Example:
+//
+//  ["foo", "bar", "baz"]
+type ArrayLiteralNode struct {
+	compositeNode
+	OpenBracket *RuneNode
+	Elements    []ValueNode
+	// Commas represent the separating ',' characters between elements. The
+	// length of this slice must be exactly len(Elements)-1, with each item
+	// in Elements having a corresponding item in this slice *except the last*
+	// (since a trailing comma is not allowed).
+	Commas       []*RuneNode
+	CloseBracket *RuneNode
+}
+
+// NewArrayLiteralNode creates a new *ArrayLiteralNode. The openBracket and
+// closeBracket args must be non-nil and represent the "[" and "]" runes that
+// surround the array values. The given commas arg must have a length that is
+// one less than the length of the vals arg. However, vals may be empty, in
+// which case commas must also be empty.
+func NewArrayLiteralNode(openBracket *RuneNode, vals []ValueNode, commas []*RuneNode, closeBracket *RuneNode) *ArrayLiteralNode {
+	if openBracket == nil {
+		panic("openBracket is nil")
+	}
+	if closeBracket == nil {
+		panic("closeBracket is nil")
+	}
+	if len(vals) == 0 && len(commas) != 0 {
+		panic("vals is empty but commas is not")
+	}
+	if len(vals) > 0 && len(commas) != len(vals)-1 {
+		panic(fmt.Sprintf("%d vals requires %d commas, not %d", len(vals), len(vals)-1, len(commas)))
+	}
+	children := make([]Node, 0, len(vals)*2+1)
+	children = append(children, openBracket)
+	for i, val := range vals {
+		if i > 0 {
+			if commas[i-1] == nil {
+				panic(fmt.Sprintf("commas[%d] is nil", i-1))
+			}
+			children = append(children, commas[i-1])
+		}
+		if val == nil {
+			panic(fmt.Sprintf("vals[%d] is nil", i))
+		}
+		children = append(children, val)
+	}
+	children = append(children, closeBracket)
+
+	return &ArrayLiteralNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		OpenBracket:  openBracket,
+		Elements:     vals,
+		Commas:       commas,
+		CloseBracket: closeBracket,
+	}
+}
+
+func (n *ArrayLiteralNode) Value() interface{} {
+	return n.Elements
+}
+
+// MessageLiteralNode represents a message literal, which is compatible with the
+// protobuf text format and can be used for custom options with message types.
+// Example:
+//
+//   { foo:1 foo:2 foo:3 bar:<name:"abc" id:123> }
+type MessageLiteralNode struct {
+	compositeNode
+	Open     *RuneNode // should be '{' or '<'
+	Elements []*MessageFieldNode
+	// Separator characters between elements, which can be either ','
+	// or ';' if present. This slice must be exactly len(Elements) in
+	// length, with each item in Elements having one corresponding item
+	// in Seps. Separators in message literals are optional, so a given
+	// item in this slice may be nil to indicate absence of a separator.
+	Seps  []*RuneNode
+	Close *RuneNode // should be '}' or '>', depending on Open
+}
+
+// NewMessageLiteralNode creates a new *MessageLiteralNode. The openSym and
+// closeSym runes must not be nil and should be "{" and "}" or "<" and ">".
+//
+// Unlike separators (dots and commas) used for other AST nodes that represent
+// a list of elements, the seps arg must be the SAME length as vals, and it may
+// contain nil values to indicate absence of a separator (in fact, it could be
+// all nils).
+func NewMessageLiteralNode(openSym *RuneNode, vals []*MessageFieldNode, seps []*RuneNode, closeSym *RuneNode) *MessageLiteralNode {
+	if openSym == nil {
+		panic("openSym is nil")
+	}
+	if closeSym == nil {
+		panic("closeSym is nil")
+	}
+	if len(seps) != len(vals) {
+		panic(fmt.Sprintf("%d vals requires %d commas, not %d", len(vals), len(vals), len(seps)))
+	}
+	numChildren := len(vals) + 2
+	for _, sep := range seps {
+		if sep != nil {
+			numChildren++
+		}
+	}
+	children := make([]Node, 0, numChildren)
+	children = append(children, openSym)
+	for i, val := range vals {
+		if val == nil {
+			panic(fmt.Sprintf("vals[%d] is nil", i))
+		}
+		children = append(children, val)
+		if seps[i] != nil {
+			children = append(children, seps[i])
+		}
+	}
+	children = append(children, closeSym)
+
+	return &MessageLiteralNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Open:     openSym,
+		Elements: vals,
+		Seps:     seps,
+		Close:    closeSym,
+	}
+}
+
+func (n *MessageLiteralNode) Value() interface{} {
+	return n.Elements
+}
+
+// MessageFieldNode represents a single field (name and value) inside of a
+// message literal. Example:
+//
+//   foo:"bar"
+type MessageFieldNode struct {
+	compositeNode
+	Name *FieldReferenceNode
+	// Sep represents the ':' separator between the name and value. If
+	// the value is a message literal (and thus starts with '<' or '{'),
+	// then the separator is optional, and thus may be nil.
+	Sep *RuneNode
+	Val ValueNode
+}
+
+// NewMessageFieldNode creates a new *MessageFieldNode. All args except sep
+// must be non-nil.
+func NewMessageFieldNode(name *FieldReferenceNode, sep *RuneNode, val ValueNode) *MessageFieldNode {
+	if name == nil {
+		panic("name is nil")
+	}
+	if val == nil {
+		panic("val is nil")
+	}
+	numChildren := 2
+	if sep != nil {
+		numChildren++
+	}
+	children := make([]Node, 0, numChildren)
+	children = append(children, name)
+	if sep != nil {
+		children = append(children, sep)
+	}
+	children = append(children, val)
+
+	return &MessageFieldNode{
+		compositeNode: compositeNode{
+			children: children,
+		},
+		Name: name,
+		Sep:  sep,
+		Val:  val,
+	}
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/walk.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/walk.go
new file mode 100644
index 000000000..53301946b
--- /dev/null
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/ast/walk.go
@@ -0,0 +1,492 @@
+package ast
+
+// VisitFunc is used to examine a node in the AST when walking the tree.
+// It returns true or false as to whether or not the descendants of the
+// given node should be visited. If it returns true, the node's children
+// will be visisted; if false, they will not. When returning true, it
+// can also return a new VisitFunc to use for the children. If it returns
+// (true, nil), then the current function will be re-used when visiting
+// the children.
+//
+// See also the Visitor type.
+type VisitFunc func(Node) (bool, VisitFunc)
+
+// Walk conducts a walk of the AST rooted at the given root using the
+// given function. It performs a "pre-order traversal", visiting a
+// given AST node before it visits that node's descendants.
+func Walk(root Node, v VisitFunc) {
+	ok, next := v(root)
+	if !ok {
+		return
+	}
+	if next != nil {
+		v = next
+	}
+	if comp, ok := root.(CompositeNode); ok {
+		for _, child := range comp.Children() {
+			Walk(child, v)
+		}
+	}
+}
+
+// Visitor provides a technique for walking the AST that allows for
+// dynamic dispatch, where a particular function is invoked based on
+// the runtime type of the argument.
+//
+// It consists of a number of functions, each of which matches a
+// concrete Node type. It also includes functions for sub-interfaces
+// of Node and the Node interface itself, to be used as broader
+// "catch all" functions.
+//
+// To use a visitor, provide a function for the node types of
+// interest and pass visitor.Visit as the function to a Walk operation.
+// When a node is traversed, the corresponding function field of
+// the visitor is invoked, if not nil. If the function for a node's
+// concrete type is nil/absent but the function for an interface it
+// implements is present, that interface visit function will be used
+// instead. If no matching function is present, the traversal will
+// continue. If a matching function is present, it will be invoked
+// and its response determines how the traversal proceeds.
+//
+// Every visit function returns (bool, *Visitor). If the bool returned
+// is false, the visited node's descendants are skipped. Otherwise,
+// traversal will continue into the node's children. If the returned
+// visitor is nil, the current visitor will continue to be used. But
+// if a non-nil visitor is returned, it will be used to visit the
+// node's children.
+type Visitor struct {
+	// VisitFileNode is invoked when visiting a *FileNode in the AST.
+	VisitFileNode func(*FileNode) (bool, *Visitor)
+	// VisitSyntaxNode is invoked when visiting a *SyntaxNode in the AST.
+	VisitSyntaxNode func(*SyntaxNode) (bool, *Visitor)
+	// VisitPackageNode is invoked when visiting a *PackageNode in the AST.
+	VisitPackageNode func(*PackageNode) (bool, *Visitor)
+	// VisitImportNode is invoked when visiting an *ImportNode in the AST.
+	VisitImportNode func(*ImportNode) (bool, *Visitor)
+	// VisitOptionNode is invoked when visiting an *OptionNode in the AST.
+	VisitOptionNode func(*OptionNode) (bool, *Visitor)
+	// VisitOptionNameNode is invoked when visiting an *OptionNameNode in the AST.
+	VisitOptionNameNode func(*OptionNameNode) (bool, *Visitor)
+	// VisitFieldReferenceNode is invoked when visiting a *FieldReferenceNode in the AST.
+	VisitFieldReferenceNode func(*FieldReferenceNode) (bool, *Visitor)
+	// VisitCompactOptionsNode is invoked when visiting a *CompactOptionsNode in the AST.
+	VisitCompactOptionsNode func(*CompactOptionsNode) (bool, *Visitor)
+	// VisitMessageNode is invoked when visiting a *MessageNode in the AST.
+	VisitMessageNode func(*MessageNode) (bool, *Visitor)
+	// VisitExtendNode is invoked when visiting an *ExtendNode in the AST.
+	VisitExtendNode func(*ExtendNode) (bool, *Visitor)
+	// VisitExtensionRangeNode is invoked when visiting an *ExtensionRangeNode in the AST.
+	VisitExtensionRangeNode func(*ExtensionRangeNode) (bool, *Visitor)
+	// VisitReservedNode is invoked when visiting a *ReservedNode in the AST.
+	VisitReservedNode func(*ReservedNode) (bool, *Visitor)
+	// VisitRangeNode is invoked when visiting a *RangeNode in the AST.
+	VisitRangeNode func(*RangeNode) (bool, *Visitor)
+	// VisitFieldNode is invoked when visiting a *FieldNode in the AST.
+	VisitFieldNode func(*FieldNode) (bool, *Visitor)
+	// VisitGroupNode is invoked when visiting a *GroupNode in the AST.
+	VisitGroupNode func(*GroupNode) (bool, *Visitor)
+	// VisitMapFieldNode is invoked when visiting a *MapFieldNode in the AST.
+	VisitMapFieldNode func(*MapFieldNode) (bool, *Visitor)
+	// VisitMapTypeNode is invoked when visiting a *MapTypeNode in the AST.
+	VisitMapTypeNode func(*MapTypeNode) (bool, *Visitor)
+	// VisitOneOfNode is invoked when visiting a *OneOfNode in the AST.
+	VisitOneOfNode func(*OneOfNode) (bool, *Visitor)
+	// VisitEnumNode is invoked when visiting an *EnumNode in the AST.
+	VisitEnumNode func(*EnumNode) (bool, *Visitor)
+	// VisitEnumValueNode is invoked when visiting an *EnumValueNode in the AST.
+	VisitEnumValueNode func(*EnumValueNode) (bool, *Visitor)
+	// VisitServiceNode is invoked when visiting a *ServiceNode in the AST.
+	VisitServiceNode func(*ServiceNode) (bool, *Visitor)
+	// VisitRPCNode is invoked when visiting an *RPCNode in the AST.
+	VisitRPCNode func(*RPCNode) (bool, *Visitor)
+	// VisitRPCTypeNode is invoked when visiting an *RPCTypeNode in the AST.
+	VisitRPCTypeNode func(*RPCTypeNode) (bool, *Visitor)
+	// VisitIdentNode is invoked when visiting an *IdentNode in the AST.
+	VisitIdentNode func(*IdentNode) (bool, *Visitor)
+	// VisitCompoundIdentNode is invoked when visiting a *CompoundIdentNode in the AST.
+	VisitCompoundIdentNode func(*CompoundIdentNode) (bool, *Visitor)
+	// VisitStringLiteralNode is invoked when visiting a *StringLiteralNode in the AST.
+	VisitStringLiteralNode func(*StringLiteralNode) (bool, *Visitor)
+	// VisitCompoundStringLiteralNode is invoked when visiting a *CompoundStringLiteralNode in the AST.
+	VisitCompoundStringLiteralNode func(*CompoundStringLiteralNode) (bool, *Visitor)
+	// VisitUintLiteralNode is invoked when visiting a *UintLiteralNode in the AST.
+	VisitUintLiteralNode func(*UintLiteralNode) (bool, *Visitor)
+	// VisitPositiveUintLiteralNode is invoked when visiting a *PositiveUintLiteralNode in the AST.
+	VisitPositiveUintLiteralNode func(*PositiveUintLiteralNode) (bool, *Visitor)
+	// VisitNegativeIntLiteralNode is invoked when visiting a *NegativeIntLiteralNode in the AST.
+	VisitNegativeIntLiteralNode func(*NegativeIntLiteralNode) (bool, *Visitor)
+	// VisitFloatLiteralNode is invoked when visiting a *FloatLiteralNode in the AST.
+	VisitFloatLiteralNode func(*FloatLiteralNode) (bool, *Visitor)
+	// VisitSpecialFloatLiteralNode is invoked when visiting a *SpecialFloatLiteralNode in the AST.
+	VisitSpecialFloatLiteralNode func(*SpecialFloatLiteralNode) (bool, *Visitor)
+	// VisitSignedFloatLiteralNode is invoked when visiting a *SignedFloatLiteralNode in the AST.
+	VisitSignedFloatLiteralNode func(*SignedFloatLiteralNode) (bool, *Visitor)
+	// VisitBoolLiteralNode is invoked when visiting a *BoolLiteralNode in the AST.
+	VisitBoolLiteralNode func(*BoolLiteralNode) (bool, *Visitor)
+	// VisitArrayLiteralNode is invoked when visiting an *ArrayLiteralNode in the AST.
+	VisitArrayLiteralNode func(*ArrayLiteralNode) (bool, *Visitor)
+	// VisitMessageLiteralNode is invoked when visiting a *MessageLiteralNode in the AST.
+	VisitMessageLiteralNode func(*MessageLiteralNode) (bool, *Visitor)
+	// VisitMessageFieldNode is invoked when visiting a *MessageFieldNode in the AST.
+	VisitMessageFieldNode func(*MessageFieldNode) (bool, *Visitor)
+	// VisitKeywordNode is invoked when visiting a *KeywordNode in the AST.
+	VisitKeywordNode func(*KeywordNode) (bool, *Visitor)
+	// VisitRuneNode is invoked when visiting a *RuneNode in the AST.
+	VisitRuneNode func(*RuneNode) (bool, *Visitor)
+	// VisitEmptyDeclNode is invoked when visiting a *EmptyDeclNode in the AST.
+	VisitEmptyDeclNode func(*EmptyDeclNode) (bool, *Visitor)
+
+	// VisitFieldDeclNode is invoked when visiting a FieldDeclNode in the AST.
+	// This function is used when no concrete type function is provided. If
+	// both this and VisitMessageDeclNode are provided, and a node implements
+	// both (such as *GroupNode and *MapFieldNode), this function will be
+	// invoked and not the other.
+	VisitFieldDeclNode func(FieldDeclNode) (bool, *Visitor)
+	// VisitMessageDeclNode is invoked when visiting a MessageDeclNode in the AST.
+	// This function is used when no concrete type function is provided.
+	VisitMessageDeclNode func(MessageDeclNode) (bool, *Visitor)
+
+	// VisitIdentValueNode is invoked when visiting an IdentValueNode in the AST.
+	// This function is used when no concrete type function is provided.
+	VisitIdentValueNode func(IdentValueNode) (bool, *Visitor)
+	// VisitStringValueNode is invoked when visiting a StringValueNode in the AST.
+	// This function is used when no concrete type function is provided.
+	VisitStringValueNode func(StringValueNode) (bool, *Visitor)
+	// VisitIntValueNode is invoked when visiting an IntValueNode in the AST.
+	// This function is used when no concrete type function is provided. If
+	// both this and VisitFloatValueNode are provided, and a node implements
+	// both (such as *UintLiteralNode), this function will be invoked and
+	// not the other.
+	VisitIntValueNode func(IntValueNode) (bool, *Visitor)
+	// VisitFloatValueNode is invoked when visiting a FloatValueNode in the AST.
+	// This function is used when no concrete type function is provided.
+	VisitFloatValueNode func(FloatValueNode) (bool, *Visitor)
+	// VisitValueNode is invoked when visiting a ValueNode in the AST. This
+	// function is used when no concrete type function is provided and no
+	// more specific ValueNode function is provided that matches the node.
+	VisitValueNode func(ValueNode) (bool, *Visitor)
+
+	// VisitTerminalNode is invoked when visiting a TerminalNode in the AST.
+	// This function is used when no concrete type function is provided
+	// no more specific interface type function is provided.
+	VisitTerminalNode func(TerminalNode) (bool, *Visitor)
+	// VisitCompositeNode is invoked when visiting a CompositeNode in the AST.
+	// This function is used when no concrete type function is provided
+	// no more specific interface type function is provided.
+	VisitCompositeNode func(CompositeNode) (bool, *Visitor)
+	// VisitNode is invoked when visiting a Node in the AST. This
+	// function is only used when no other more specific function is
+	// provided.
+	VisitNode func(Node) (bool, *Visitor)
+}
+
+// Visit provides the Visitor's implementation of VisitFunc, to be
+// used with Walk operations.
+func (v *Visitor) Visit(n Node) (bool, VisitFunc) {
+	var ok, matched bool
+	var next *Visitor
+	switch n := n.(type) {
+	case *FileNode:
+		if v.VisitFileNode != nil {
+			matched = true
+			ok, next = v.VisitFileNode(n)
+		}
+	case *SyntaxNode:
+		if v.VisitSyntaxNode != nil {
+			matched = true
+			ok, next = v.VisitSyntaxNode(n)
+		}
+	case *PackageNode:
+		if v.VisitPackageNode != nil {
+			matched = true
+			ok, next = v.VisitPackageNode(n)
+		}
+	case *ImportNode:
+		if v.VisitImportNode != nil {
+			matched = true
+			ok, next = v.VisitImportNode(n)
+		}
+	case *OptionNode:
+		if v.VisitOptionNode != nil {
+			matched = true
+			ok, next = v.VisitOptionNode(n)
+		}
+	case *OptionNameNode:
+		if v.VisitOptionNameNode != nil {
+			matched = true
+			ok, next = v.VisitOptionNameNode(n)
+		}
+	case *FieldReferenceNode:
+		if v.VisitFieldReferenceNode != nil {
+			matched = true
+			ok, next = v.VisitFieldReferenceNode(n)
+		}
+	case *CompactOptionsNode:
+		if v.VisitCompactOptionsNode != nil {
+			matched = true
+			ok, next = v.VisitCompactOptionsNode(n)
+		}
+	case *MessageNode:
+		if v.VisitMessageNode != nil {
+			matched = true
+			ok, next = v.VisitMessageNode(n)
+		}
+	case *ExtendNode:
+		if v.VisitExtendNode != nil {
+			matched = true
+			ok, next = v.VisitExtendNode(n)
+		}
+	case *ExtensionRangeNode:
+		if v.VisitExtensionRangeNode != nil {
+			matched = true
+			ok, next = v.VisitExtensionRangeNode(n)
+		}
+	case *ReservedNode:
+		if v.VisitReservedNode != nil {
+			matched = true
+			ok, next = v.VisitReservedNode(n)
+		}
+	case *RangeNode:
+		if v.VisitRangeNode != nil {
+			matched = true
+			ok, next = v.VisitRangeNode(n)
+		}
+	case *FieldNode:
+		if v.VisitFieldNode != nil {
+			matched = true
+			ok, next = v.VisitFieldNode(n)
+		}
+	case *GroupNode:
+		if v.VisitGroupNode != nil {
+			matched = true
+			ok, next = v.VisitGroupNode(n)
+		}
+	case *MapFieldNode:
+		if v.VisitMapFieldNode != nil {
+			matched = true
+			ok, next = v.VisitMapFieldNode(n)
+		}
+	case *MapTypeNode:
+		if v.VisitMapTypeNode != nil {
+			matched = true
+			ok, next = v.VisitMapTypeNode(n)
+		}
+	case *OneOfNode:
+		if v.VisitOneOfNode != nil {
+			matched = true
+			ok, next = v.VisitOneOfNode(n)
+		}
+	case *EnumNode:
+		if v.VisitEnumNode != nil {
+			matched = true
+			ok, next = v.VisitEnumNode(n)
+		}
+	case *EnumValueNode:
+		if v.VisitEnumValueNode != nil {
+			matched = true
+			ok, next = v.VisitEnumValueNode(n)
+		}
+	case *ServiceNode:
+		if v.VisitServiceNode != nil {
+			matched = true
+			ok, next = v.VisitServiceNode(n)
+		}
+	case *RPCNode:
+		if v.VisitRPCNode != nil {
+			matched = true
+			ok, next = v.VisitRPCNode(n)
+		}
+	case *RPCTypeNode:
+		if v.VisitRPCTypeNode != nil {
+			matched = true
+			ok, next = v.VisitRPCTypeNode(n)
+		}
+	case *IdentNode:
+		if v.VisitIdentNode != nil {
+			matched = true
+			ok, next = v.VisitIdentNode(n)
+		}
+	case *CompoundIdentNode:
+		if v.VisitCompoundIdentNode != nil {
+			matched = true
+			ok, next = v.VisitCompoundIdentNode(n)
+		}
+	case *StringLiteralNode:
+		if v.VisitStringLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitStringLiteralNode(n)
+		}
+	case *CompoundStringLiteralNode:
+		if v.VisitCompoundStringLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitCompoundStringLiteralNode(n)
+		}
+	case *UintLiteralNode:
+		if v.VisitUintLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitUintLiteralNode(n)
+		}
+	case *PositiveUintLiteralNode:
+		if v.VisitPositiveUintLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitPositiveUintLiteralNode(n)
+		}
+	case *NegativeIntLiteralNode:
+		if v.VisitNegativeIntLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitNegativeIntLiteralNode(n)
+		}
+	case *FloatLiteralNode:
+		if v.VisitFloatLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitFloatLiteralNode(n)
+		}
+	case *SpecialFloatLiteralNode:
+		if v.VisitSpecialFloatLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitSpecialFloatLiteralNode(n)
+		}
+	case *SignedFloatLiteralNode:
+		if v.VisitSignedFloatLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitSignedFloatLiteralNode(n)
+		}
+	case *BoolLiteralNode:
+		if v.VisitBoolLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitBoolLiteralNode(n)
+		}
+	case *ArrayLiteralNode:
+		if v.VisitArrayLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitArrayLiteralNode(n)
+		}
+	case *MessageLiteralNode:
+		if v.VisitMessageLiteralNode != nil {
+			matched = true
+			ok, next = v.VisitMessageLiteralNode(n)
+		}
+	case *MessageFieldNode:
+		if v.VisitMessageFieldNode != nil {
+			matched = true
+			ok, next = v.VisitMessageFieldNode(n)
+		}
+	case *KeywordNode:
+		if v.VisitKeywordNode != nil {
+			matched = true
+			ok, next = v.VisitKeywordNode(n)
+		}
+	case *RuneNode:
+		if v.VisitRuneNode != nil {
+			matched = true
+			ok, next = v.VisitRuneNode(n)
+		}
+	case *EmptyDeclNode:
+		if v.VisitEmptyDeclNode != nil {
+			matched = true
+			ok, next = v.VisitEmptyDeclNode(n)
+		}
+	}
+
+	if !matched {
+		// Visitor provided no concrete type visit function, so
+		// check interface types. We do this in several passes
+		// to provide "priority" for matched interfaces for nodes
+		// that actually implement more than one interface.
+		//
+		// For example, StringLiteralNode implements both
+		// StringValueNode and ValueNode. Both cases could match
+		// so the first case is what would match. So if we want
+		// to test against either, they need to be in different
+		// switch statements.
+		switch n := n.(type) {
+		case FieldDeclNode:
+			if v.VisitFieldDeclNode != nil {
+				matched = true
+				ok, next = v.VisitFieldDeclNode(n)
+			}
+		case IdentValueNode:
+			if v.VisitIdentValueNode != nil {
+				matched = true
+				ok, next = v.VisitIdentValueNode(n)
+			}
+		case StringValueNode:
+			if v.VisitStringValueNode != nil {
+				matched = true
+				ok, next = v.VisitStringValueNode(n)
+			}
+		case IntValueNode:
+			if v.VisitIntValueNode != nil {
+				matched = true
+				ok, next = v.VisitIntValueNode(n)
+			}
+		}
+	}
+
+	if !matched {
+		// These two are excluded from the above switch so that
+		// if visitor provides both VisitIntValueNode and
+		// VisitFloatValueNode, we'll prefer VisitIntValueNode
+		// for *UintLiteralNode (which implements both). Similarly,
+		// that way we prefer VisitFieldDeclNode over
+		// VisitMessageDeclNode when visiting a *GroupNode.
+		switch n := n.(type) {
+		case FloatValueNode:
+			if v.VisitFloatValueNode != nil {
+				matched = true
+				ok, next = v.VisitFloatValueNode(n)
+			}
+		case MessageDeclNode:
+			if v.VisitMessageDeclNode != nil {
+				matched = true
+				ok, next = v.VisitMessageDeclNode(n)
+			}
+		}
+	}
+
+	if !matched {
+		switch n := n.(type) {
+		case ValueNode:
+			if v.VisitValueNode != nil {
+				matched = true
+				ok, next = v.VisitValueNode(n)
+			}
+		}
+	}
+
+	if !matched {
+		switch n := n.(type) {
+		case TerminalNode:
+			if v.VisitTerminalNode != nil {
+				matched = true
+				ok, next = v.VisitTerminalNode(n)
+			}
+		case CompositeNode:
+			if v.VisitCompositeNode != nil {
+				matched = true
+				ok, next = v.VisitCompositeNode(n)
+			}
+		}
+	}
+
+	if !matched {
+		// finally, fallback to most generic visit function
+		if v.VisitNode != nil {
+			matched = true
+			ok, next = v.VisitNode(n)
+		}
+	}
+
+	if !matched {
+		// keep descending with the current visitor
+		return true, nil
+	}
+
+	if !ok {
+		return false, nil
+	}
+	if next != nil {
+		return true, next.Visit
+	}
+	return true, v.Visit
+}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/descriptor_protos.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/descriptor_protos.go
index 08de8d57a..41134541d 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/descriptor_protos.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/descriptor_protos.go
@@ -10,69 +10,70 @@ import (
 	dpb "github.com/golang/protobuf/protoc-gen-go/descriptor"
 
 	"github.com/jhump/protoreflect/desc/internal"
+	"github.com/jhump/protoreflect/desc/protoparse/ast"
 )
 
-func (r *parseResult) createFileDescriptor(filename string, file *fileNode) {
+func (r *parseResult) createFileDescriptor(filename string, file *ast.FileNode) {
 	fd := &dpb.FileDescriptorProto{Name: proto.String(filename)}
 	r.fd = fd
 	r.putFileNode(fd, file)
 
 	isProto3 := false
-	if file.syntax != nil {
-		if file.syntax.syntax.val == "proto3" {
+	if file.Syntax != nil {
+		if file.Syntax.Syntax.AsString() == "proto3" {
 			isProto3 = true
-		} else if file.syntax.syntax.val != "proto2" {
-			if r.errs.handleErrorWithPos(file.syntax.syntax.start(), `syntax value must be "proto2" or "proto3"`) != nil {
+		} else if file.Syntax.Syntax.AsString() != "proto2" {
+			if r.errs.handleErrorWithPos(file.Syntax.Syntax.Start(), `syntax value must be "proto2" or "proto3"`) != nil {
 				return
 			}
 		}
 
 		// proto2 is the default, so no need to set unless proto3
 		if isProto3 {
-			fd.Syntax = proto.String(file.syntax.syntax.val)
+			fd.Syntax = proto.String(file.Syntax.Syntax.AsString())
 		}
 	} else {
-		r.errs.warn(file.start(), ErrNoSyntax)
+		r.errs.warn(file.Start(), ErrNoSyntax)
 	}
 
-	for _, decl := range file.decls {
+	for _, decl := range file.Decls {
 		if r.errs.err != nil {
 			return
 		}
-		if decl.enum != nil {
-			fd.EnumType = append(fd.EnumType, r.asEnumDescriptor(decl.enum))
-		} else if decl.extend != nil {
-			r.addExtensions(decl.extend, &fd.Extension, &fd.MessageType, isProto3)
-		} else if decl.imp != nil {
-			file.imports = append(file.imports, decl.imp)
+		switch decl := decl.(type) {
+		case *ast.EnumNode:
+			fd.EnumType = append(fd.EnumType, r.asEnumDescriptor(decl))
+		case *ast.ExtendNode:
+			r.addExtensions(decl, &fd.Extension, &fd.MessageType, isProto3)
+		case *ast.ImportNode:
 			index := len(fd.Dependency)
-			fd.Dependency = append(fd.Dependency, decl.imp.name.val)
-			if decl.imp.public {
+			fd.Dependency = append(fd.Dependency, decl.Name.AsString())
+			if decl.Public != nil {
 				fd.PublicDependency = append(fd.PublicDependency, int32(index))
-			} else if decl.imp.weak {
+			} else if decl.Weak != nil {
 				fd.WeakDependency = append(fd.WeakDependency, int32(index))
 			}
-		} else if decl.message != nil {
-			fd.MessageType = append(fd.MessageType, r.asMessageDescriptor(decl.message, isProto3))
-		} else if decl.option != nil {
+		case *ast.MessageNode:
+			fd.MessageType = append(fd.MessageType, r.asMessageDescriptor(decl, isProto3))
+		case *ast.OptionNode:
 			if fd.Options == nil {
 				fd.Options = &dpb.FileOptions{}
 			}
-			fd.Options.UninterpretedOption = append(fd.Options.UninterpretedOption, r.asUninterpretedOption(decl.option))
-		} else if decl.service != nil {
-			fd.Service = append(fd.Service, r.asServiceDescriptor(decl.service))
-		} else if decl.pkg != nil {
+			fd.Options.UninterpretedOption = append(fd.Options.UninterpretedOption, r.asUninterpretedOption(decl))
+		case *ast.ServiceNode:
+			fd.Service = append(fd.Service, r.asServiceDescriptor(decl))
+		case *ast.PackageNode:
 			if fd.Package != nil {
-				if r.errs.handleErrorWithPos(decl.pkg.start(), "files should have only one package declaration") != nil {
+				if r.errs.handleErrorWithPos(decl.Start(), "files should have only one package declaration") != nil {
 					return
 				}
 			}
-			fd.Package = proto.String(decl.pkg.name.val)
+			fd.Package = proto.String(string(decl.Name.AsIdentifier()))
 		}
 	}
 }
 
-func (r *parseResult) asUninterpretedOptions(nodes []*optionNode) []*dpb.UninterpretedOption {
+func (r *parseResult) asUninterpretedOptions(nodes []*ast.OptionNode) []*dpb.UninterpretedOption {
 	if len(nodes) == 0 {
 		return nil
 	}
@@ -83,11 +84,11 @@ func (r *parseResult) asUninterpretedOptions(nodes []*optionNode) []*dpb.Uninter
 	return opts
 }
 
-func (r *parseResult) asUninterpretedOption(node *optionNode) *dpb.UninterpretedOption {
-	opt := &dpb.UninterpretedOption{Name: r.asUninterpretedOptionName(node.name.parts)}
+func (r *parseResult) asUninterpretedOption(node *ast.OptionNode) *dpb.UninterpretedOption {
+	opt := &dpb.UninterpretedOption{Name: r.asUninterpretedOptionName(node.Name.Parts)}
 	r.putOptionNode(opt, node)
 
-	switch val := node.val.value().(type) {
+	switch val := node.Val.Value().(type) {
 	case bool:
 		if val {
 			opt.IdentifierValue = proto.String("true")
@@ -102,27 +103,24 @@ func (r *parseResult) asUninterpretedOption(node *optionNode) *dpb.Uninterpreted
 		opt.DoubleValue = proto.Float64(val)
 	case string:
 		opt.StringValue = []byte(val)
-	case identifier:
+	case ast.Identifier:
 		opt.IdentifierValue = proto.String(string(val))
-	case []*aggregateEntryNode:
+	case []*ast.MessageFieldNode:
 		var buf bytes.Buffer
 		aggToString(val, &buf)
 		aggStr := buf.String()
 		opt.AggregateValue = proto.String(aggStr)
+		//the grammar does not allow arrays here, so no case for []ast.ValueNode
 	}
 	return opt
 }
 
-func (r *parseResult) asUninterpretedOptionName(parts []*optionNamePartNode) []*dpb.UninterpretedOption_NamePart {
+func (r *parseResult) asUninterpretedOptionName(parts []*ast.FieldReferenceNode) []*dpb.UninterpretedOption_NamePart {
 	ret := make([]*dpb.UninterpretedOption_NamePart, len(parts))
 	for i, part := range parts {
-		txt := part.text.val
-		if !part.isExtension {
-			txt = part.text.val[part.offset : part.offset+part.length]
-		}
 		np := &dpb.UninterpretedOption_NamePart{
-			NamePart:    proto.String(txt),
-			IsExtension: proto.Bool(part.isExtension),
+			NamePart:    proto.String(string(part.Name.AsIdentifier())),
+			IsExtension: proto.Bool(part.IsExtension()),
 		}
 		r.putOptionNamePartNode(np, part)
 		ret[i] = np
@@ -130,54 +128,53 @@ func (r *parseResult) asUninterpretedOptionName(parts []*optionNamePartNode) []*
 	return ret
 }
 
-func (r *parseResult) addExtensions(ext *extendNode, flds *[]*dpb.FieldDescriptorProto, msgs *[]*dpb.DescriptorProto, isProto3 bool) {
-	extendee := ext.extendee.val
+func (r *parseResult) addExtensions(ext *ast.ExtendNode, flds *[]*dpb.FieldDescriptorProto, msgs *[]*dpb.DescriptorProto, isProto3 bool) {
+	extendee := string(ext.Extendee.AsIdentifier())
 	count := 0
-	for _, decl := range ext.decls {
-		if decl.field != nil {
+	for _, decl := range ext.Decls {
+		switch decl := decl.(type) {
+		case *ast.FieldNode:
 			count++
-			decl.field.extendee = ext
 			// use higher limit since we don't know yet whether extendee is messageset wire format
-			fd := r.asFieldDescriptor(decl.field, internal.MaxTag, isProto3)
+			fd := r.asFieldDescriptor(decl, internal.MaxTag, isProto3)
 			fd.Extendee = proto.String(extendee)
 			*flds = append(*flds, fd)
-		} else if decl.group != nil {
+		case *ast.GroupNode:
 			count++
-			decl.group.extendee = ext
 			// ditto: use higher limit right now
-			fd, md := r.asGroupDescriptors(decl.group, isProto3, internal.MaxTag)
+			fd, md := r.asGroupDescriptors(decl, isProto3, internal.MaxTag)
 			fd.Extendee = proto.String(extendee)
 			*flds = append(*flds, fd)
 			*msgs = append(*msgs, md)
 		}
 	}
 	if count == 0 {
-		_ = r.errs.handleErrorWithPos(ext.start(), "extend sections must define at least one extension")
+		_ = r.errs.handleErrorWithPos(ext.Start(), "extend sections must define at least one extension")
 	}
 }
 
-func asLabel(lbl *fieldLabel) *dpb.FieldDescriptorProto_Label {
-	if lbl.identNode == nil {
+func asLabel(lbl *ast.FieldLabel) *dpb.FieldDescriptorProto_Label {
+	if !lbl.IsPresent() {
 		return nil
 	}
 	switch {
-	case lbl.repeated:
+	case lbl.Repeated:
 		return dpb.FieldDescriptorProto_LABEL_REPEATED.Enum()
-	case lbl.required:
+	case lbl.Required:
 		return dpb.FieldDescriptorProto_LABEL_REQUIRED.Enum()
 	default:
 		return dpb.FieldDescriptorProto_LABEL_OPTIONAL.Enum()
 	}
 }
 
-func (r *parseResult) asFieldDescriptor(node *fieldNode, maxTag int32, isProto3 bool) *dpb.FieldDescriptorProto {
-	tag := node.tag.val
-	if err := checkTag(node.tag.start(), tag, maxTag); err != nil {
+func (r *parseResult) asFieldDescriptor(node *ast.FieldNode, maxTag int32, isProto3 bool) *dpb.FieldDescriptorProto {
+	tag := node.Tag.Val
+	if err := checkTag(node.Tag.Start(), tag, maxTag); err != nil {
 		_ = r.errs.handleError(err)
 	}
-	fd := newFieldDescriptor(node.name.val, node.fldType.val, int32(tag), asLabel(&node.label))
+	fd := newFieldDescriptor(node.Name.Val, string(node.FldType.AsIdentifier()), int32(tag), asLabel(&node.Label))
 	r.putFieldNode(fd, node)
-	if opts := node.options.Elements(); len(opts) > 0 {
+	if opts := node.Options.GetElements(); len(opts) > 0 {
 		fd.Options = &dpb.FieldOptions{UninterpretedOption: r.asUninterpretedOptions(opts)}
 	}
 	if isProto3 && fd.Label != nil && fd.GetLabel() == dpb.FieldDescriptorProto_LABEL_OPTIONAL {
@@ -223,49 +220,49 @@ func newFieldDescriptor(name string, fieldType string, tag int32, lbl *dpb.Field
 	return fd
 }
 
-func (r *parseResult) asGroupDescriptors(group *groupNode, isProto3 bool, maxTag int32) (*dpb.FieldDescriptorProto, *dpb.DescriptorProto) {
-	tag := group.tag.val
-	if err := checkTag(group.tag.start(), tag, maxTag); err != nil {
+func (r *parseResult) asGroupDescriptors(group *ast.GroupNode, isProto3 bool, maxTag int32) (*dpb.FieldDescriptorProto, *dpb.DescriptorProto) {
+	tag := group.Tag.Val
+	if err := checkTag(group.Tag.Start(), tag, maxTag); err != nil {
 		_ = r.errs.handleError(err)
 	}
-	if !unicode.IsUpper(rune(group.name.val[0])) {
-		_ = r.errs.handleErrorWithPos(group.name.start(), "group %s should have a name that starts with a capital letter", group.name.val)
+	if !unicode.IsUpper(rune(group.Name.Val[0])) {
+		_ = r.errs.handleErrorWithPos(group.Name.Start(), "group %s should have a name that starts with a capital letter", group.Name.Val)
 	}
-	fieldName := strings.ToLower(group.name.val)
+	fieldName := strings.ToLower(group.Name.Val)
 	fd := &dpb.FieldDescriptorProto{
 		Name:     proto.String(fieldName),
 		JsonName: proto.String(internal.JsonName(fieldName)),
 		Number:   proto.Int32(int32(tag)),
-		Label:    asLabel(&group.label),
+		Label:    asLabel(&group.Label),
 		Type:     dpb.FieldDescriptorProto_TYPE_GROUP.Enum(),
-		TypeName: proto.String(group.name.val),
+		TypeName: proto.String(group.Name.Val),
 	}
 	r.putFieldNode(fd, group)
-	if opts := group.options.Elements(); len(opts) > 0 {
+	if opts := group.Options.GetElements(); len(opts) > 0 {
 		fd.Options = &dpb.FieldOptions{UninterpretedOption: r.asUninterpretedOptions(opts)}
 	}
-	md := &dpb.DescriptorProto{Name: proto.String(group.name.val)}
+	md := &dpb.DescriptorProto{Name: proto.String(group.Name.Val)}
 	r.putMessageNode(md, group)
-	r.addMessageDecls(md, group.decls, isProto3)
+	r.addMessageBody(md, &group.MessageBody, isProto3)
 	return fd, md
 }
 
-func (r *parseResult) asMapDescriptors(mapField *mapFieldNode, isProto3 bool, maxTag int32) (*dpb.FieldDescriptorProto, *dpb.DescriptorProto) {
-	tag := mapField.tag.val
-	if err := checkTag(mapField.tag.start(), tag, maxTag); err != nil {
+func (r *parseResult) asMapDescriptors(mapField *ast.MapFieldNode, isProto3 bool, maxTag int32) (*dpb.FieldDescriptorProto, *dpb.DescriptorProto) {
+	tag := mapField.Tag.Val
+	if err := checkTag(mapField.Tag.Start(), tag, maxTag); err != nil {
 		_ = r.errs.handleError(err)
 	}
 	var lbl *dpb.FieldDescriptorProto_Label
 	if !isProto3 {
 		lbl = dpb.FieldDescriptorProto_LABEL_OPTIONAL.Enum()
 	}
-	keyFd := newFieldDescriptor("key", mapField.mapType.keyType.val, 1, lbl)
-	r.putFieldNode(keyFd, mapField.keyField())
-	valFd := newFieldDescriptor("value", mapField.mapType.valueType.val, 2, lbl)
-	r.putFieldNode(valFd, mapField.valueField())
-	entryName := internal.InitCap(internal.JsonName(mapField.name.val)) + "Entry"
-	fd := newFieldDescriptor(mapField.name.val, entryName, int32(tag), dpb.FieldDescriptorProto_LABEL_REPEATED.Enum())
-	if opts := mapField.options.Elements(); len(opts) > 0 {
+	keyFd := newFieldDescriptor("key", mapField.MapType.KeyType.Val, 1, lbl)
+	r.putFieldNode(keyFd, mapField.KeyField())
+	valFd := newFieldDescriptor("value", string(mapField.MapType.ValueType.AsIdentifier()), 2, lbl)
+	r.putFieldNode(valFd, mapField.ValueField())
+	entryName := internal.InitCap(internal.JsonName(mapField.Name.Val)) + "Entry"
+	fd := newFieldDescriptor(mapField.Name.Val, entryName, int32(tag), dpb.FieldDescriptorProto_LABEL_REPEATED.Enum())
+	if opts := mapField.Options.GetElements(); len(opts) > 0 {
 		fd.Options = &dpb.FieldOptions{UninterpretedOption: r.asUninterpretedOptions(opts)}
 	}
 	r.putFieldNode(fd, mapField)
@@ -278,10 +275,10 @@ func (r *parseResult) asMapDescriptors(mapField *mapFieldNode, isProto3 bool, ma
 	return fd, md
 }
 
-func (r *parseResult) asExtensionRanges(node *extensionRangeNode, maxTag int32) []*dpb.DescriptorProto_ExtensionRange {
-	opts := r.asUninterpretedOptions(node.options.Elements())
-	ers := make([]*dpb.DescriptorProto_ExtensionRange, len(node.ranges))
-	for i, rng := range node.ranges {
+func (r *parseResult) asExtensionRanges(node *ast.ExtensionRangeNode, maxTag int32) []*dpb.DescriptorProto_ExtensionRange {
+	opts := r.asUninterpretedOptions(node.Options.GetElements())
+	ers := make([]*dpb.DescriptorProto_ExtensionRange, len(node.Ranges))
+	for i, rng := range node.Ranges {
 		start, end := getRangeBounds(r, rng, 0, maxTag)
 		er := &dpb.DescriptorProto_ExtensionRange{
 			Start: proto.Int32(start),
@@ -296,58 +293,64 @@ func (r *parseResult) asExtensionRanges(node *extensionRangeNode, maxTag int32)
 	return ers
 }
 
-func (r *parseResult) asEnumValue(ev *enumValueNode) *dpb.EnumValueDescriptorProto {
-	num, ok := ev.number.asInt32(math.MinInt32, math.MaxInt32)
+func (r *parseResult) asEnumValue(ev *ast.EnumValueNode) *dpb.EnumValueDescriptorProto {
+	num, ok := ast.AsInt32(ev.Number, math.MinInt32, math.MaxInt32)
 	if !ok {
-		_ = r.errs.handleErrorWithPos(ev.number.start(), "value %d is out of range: should be between %d and %d", ev.number.value(), math.MinInt32, math.MaxInt32)
+		_ = r.errs.handleErrorWithPos(ev.Number.Start(), "value %d is out of range: should be between %d and %d", ev.Number.Value(), math.MinInt32, math.MaxInt32)
 	}
-	evd := &dpb.EnumValueDescriptorProto{Name: proto.String(ev.name.val), Number: proto.Int32(num)}
+	evd := &dpb.EnumValueDescriptorProto{Name: proto.String(ev.Name.Val), Number: proto.Int32(num)}
 	r.putEnumValueNode(evd, ev)
-	if opts := ev.options.Elements(); len(opts) > 0 {
+	if opts := ev.Options.GetElements(); len(opts) > 0 {
 		evd.Options = &dpb.EnumValueOptions{UninterpretedOption: r.asUninterpretedOptions(opts)}
 	}
 	return evd
 }
 
-func (r *parseResult) asMethodDescriptor(node *methodNode) *dpb.MethodDescriptorProto {
+func (r *parseResult) asMethodDescriptor(node *ast.RPCNode) *dpb.MethodDescriptorProto {
 	md := &dpb.MethodDescriptorProto{
-		Name:       proto.String(node.name.val),
-		InputType:  proto.String(node.input.msgType.val),
-		OutputType: proto.String(node.output.msgType.val),
+		Name:       proto.String(node.Name.Val),
+		InputType:  proto.String(string(node.Input.MessageType.AsIdentifier())),
+		OutputType: proto.String(string(node.Output.MessageType.AsIdentifier())),
 	}
 	r.putMethodNode(md, node)
-	if node.input.streamKeyword != nil {
+	if node.Input.Stream != nil {
 		md.ClientStreaming = proto.Bool(true)
 	}
-	if node.output.streamKeyword != nil {
+	if node.Output.Stream != nil {
 		md.ServerStreaming = proto.Bool(true)
 	}
 	// protoc always adds a MethodOptions if there are brackets
-	// We have a non-nil node.options if there are brackets
 	// We do the same to match protoc as closely as possible
 	// https://github.com/protocolbuffers/protobuf/blob/0c3f43a6190b77f1f68b7425d1b7e1a8257a8d0c/src/google/protobuf/compiler/parser.cc#L2152
-	if node.options != nil {
-		md.Options = &dpb.MethodOptions{UninterpretedOption: r.asUninterpretedOptions(node.options)}
+	if node.OpenBrace != nil {
+		md.Options = &dpb.MethodOptions{}
+		for _, decl := range node.Decls {
+			switch decl := decl.(type) {
+			case *ast.OptionNode:
+				md.Options.UninterpretedOption = append(md.Options.UninterpretedOption, r.asUninterpretedOption(decl))
+			}
+		}
 	}
 	return md
 }
 
-func (r *parseResult) asEnumDescriptor(en *enumNode) *dpb.EnumDescriptorProto {
-	ed := &dpb.EnumDescriptorProto{Name: proto.String(en.name.val)}
+func (r *parseResult) asEnumDescriptor(en *ast.EnumNode) *dpb.EnumDescriptorProto {
+	ed := &dpb.EnumDescriptorProto{Name: proto.String(en.Name.Val)}
 	r.putEnumNode(ed, en)
-	for _, decl := range en.decls {
-		if decl.option != nil {
+	for _, decl := range en.Decls {
+		switch decl := decl.(type) {
+		case *ast.OptionNode:
 			if ed.Options == nil {
 				ed.Options = &dpb.EnumOptions{}
 			}
-			ed.Options.UninterpretedOption = append(ed.Options.UninterpretedOption, r.asUninterpretedOption(decl.option))
-		} else if decl.value != nil {
-			ed.Value = append(ed.Value, r.asEnumValue(decl.value))
-		} else if decl.reserved != nil {
-			for _, n := range decl.reserved.names {
-				ed.ReservedName = append(ed.ReservedName, n.val)
+			ed.Options.UninterpretedOption = append(ed.Options.UninterpretedOption, r.asUninterpretedOption(decl))
+		case *ast.EnumValueNode:
+			ed.Value = append(ed.Value, r.asEnumValue(decl))
+		case *ast.ReservedNode:
+			for _, n := range decl.Names {
+				ed.ReservedName = append(ed.ReservedName, n.AsString())
 			}
-			for _, rng := range decl.reserved.ranges {
+			for _, rng := range decl.Ranges {
 				ed.ReservedRange = append(ed.ReservedRange, r.asEnumReservedRange(rng))
 			}
 		}
@@ -355,7 +358,7 @@ func (r *parseResult) asEnumDescriptor(en *enumNode) *dpb.EnumDescriptorProto {
 	return ed
 }
 
-func (r *parseResult) asEnumReservedRange(rng *rangeNode) *dpb.EnumDescriptorProto_EnumReservedRange {
+func (r *parseResult) asEnumReservedRange(rng *ast.RangeNode) *dpb.EnumDescriptorProto_EnumReservedRange {
 	start, end := getRangeBounds(r, rng, math.MinInt32, math.MaxInt32)
 	rr := &dpb.EnumDescriptorProto_EnumReservedRange{
 		Start: proto.Int32(start),
@@ -365,73 +368,76 @@ func (r *parseResult) asEnumReservedRange(rng *rangeNode) *dpb.EnumDescriptorPro
 	return rr
 }
 
-func (r *parseResult) asMessageDescriptor(node *messageNode, isProto3 bool) *dpb.DescriptorProto {
-	msgd := &dpb.DescriptorProto{Name: proto.String(node.name.val)}
+func (r *parseResult) asMessageDescriptor(node *ast.MessageNode, isProto3 bool) *dpb.DescriptorProto {
+	msgd := &dpb.DescriptorProto{Name: proto.String(node.Name.Val)}
 	r.putMessageNode(msgd, node)
-	r.addMessageDecls(msgd, node.decls, isProto3)
+	r.addMessageBody(msgd, &node.MessageBody, isProto3)
 	return msgd
 }
 
-func (r *parseResult) addMessageDecls(msgd *dpb.DescriptorProto, decls []*messageElement, isProto3 bool) {
+func (r *parseResult) addMessageBody(msgd *dpb.DescriptorProto, body *ast.MessageBody, isProto3 bool) {
 	// first process any options
-	for _, decl := range decls {
-		if decl.option != nil {
+	for _, decl := range body.Decls {
+		if opt, ok := decl.(*ast.OptionNode); ok {
 			if msgd.Options == nil {
 				msgd.Options = &dpb.MessageOptions{}
 			}
-			msgd.Options.UninterpretedOption = append(msgd.Options.UninterpretedOption, r.asUninterpretedOption(decl.option))
+			msgd.Options.UninterpretedOption = append(msgd.Options.UninterpretedOption, r.asUninterpretedOption(opt))
 		}
 	}
 
 	// now that we have options, we can see if this uses messageset wire format, which
 	// impacts how we validate tag numbers in any fields in the message
 	maxTag := int32(internal.MaxNormalTag)
-	if isMessageSet, err := isMessageSetWireFormat(r, "message "+msgd.GetName(), msgd); err != nil {
+	messageSetOpt, err := isMessageSetWireFormat(r, "message "+msgd.GetName(), msgd)
+	if err != nil {
 		return
-	} else if isMessageSet {
+	} else if messageSetOpt != nil {
 		maxTag = internal.MaxTag // higher limit for messageset wire format
 	}
 
 	rsvdNames := map[string]int{}
 
 	// now we can process the rest
-	for _, decl := range decls {
-		if decl.enum != nil {
-			msgd.EnumType = append(msgd.EnumType, r.asEnumDescriptor(decl.enum))
-		} else if decl.extend != nil {
-			r.addExtensions(decl.extend, &msgd.Extension, &msgd.NestedType, isProto3)
-		} else if decl.extensionRange != nil {
-			msgd.ExtensionRange = append(msgd.ExtensionRange, r.asExtensionRanges(decl.extensionRange, maxTag)...)
-		} else if decl.field != nil {
-			fd := r.asFieldDescriptor(decl.field, maxTag, isProto3)
+	for _, decl := range body.Decls {
+		switch decl := decl.(type) {
+		case *ast.EnumNode:
+			msgd.EnumType = append(msgd.EnumType, r.asEnumDescriptor(decl))
+		case *ast.ExtendNode:
+			r.addExtensions(decl, &msgd.Extension, &msgd.NestedType, isProto3)
+		case *ast.ExtensionRangeNode:
+			msgd.ExtensionRange = append(msgd.ExtensionRange, r.asExtensionRanges(decl, maxTag)...)
+		case *ast.FieldNode:
+			fd := r.asFieldDescriptor(decl, maxTag, isProto3)
 			msgd.Field = append(msgd.Field, fd)
-		} else if decl.mapField != nil {
-			fd, md := r.asMapDescriptors(decl.mapField, isProto3, maxTag)
+		case *ast.MapFieldNode:
+			fd, md := r.asMapDescriptors(decl, isProto3, maxTag)
 			msgd.Field = append(msgd.Field, fd)
 			msgd.NestedType = append(msgd.NestedType, md)
-		} else if decl.group != nil {
-			fd, md := r.asGroupDescriptors(decl.group, isProto3, maxTag)
+		case *ast.GroupNode:
+			fd, md := r.asGroupDescriptors(decl, isProto3, maxTag)
 			msgd.Field = append(msgd.Field, fd)
 			msgd.NestedType = append(msgd.NestedType, md)
-		} else if decl.oneOf != nil {
+		case *ast.OneOfNode:
 			oodIndex := len(msgd.OneofDecl)
-			ood := &dpb.OneofDescriptorProto{Name: proto.String(decl.oneOf.name.val)}
-			r.putOneOfNode(ood, decl.oneOf)
+			ood := &dpb.OneofDescriptorProto{Name: proto.String(decl.Name.Val)}
+			r.putOneOfNode(ood, decl)
 			msgd.OneofDecl = append(msgd.OneofDecl, ood)
 			ooFields := 0
-			for _, oodecl := range decl.oneOf.decls {
-				if oodecl.option != nil {
+			for _, oodecl := range decl.Decls {
+				switch oodecl := oodecl.(type) {
+				case *ast.OptionNode:
 					if ood.Options == nil {
 						ood.Options = &dpb.OneofOptions{}
 					}
-					ood.Options.UninterpretedOption = append(ood.Options.UninterpretedOption, r.asUninterpretedOption(oodecl.option))
-				} else if oodecl.field != nil {
-					fd := r.asFieldDescriptor(oodecl.field, maxTag, isProto3)
+					ood.Options.UninterpretedOption = append(ood.Options.UninterpretedOption, r.asUninterpretedOption(oodecl))
+				case *ast.FieldNode:
+					fd := r.asFieldDescriptor(oodecl, maxTag, isProto3)
 					fd.OneofIndex = proto.Int32(int32(oodIndex))
 					msgd.Field = append(msgd.Field, fd)
 					ooFields++
-				} else if oodecl.group != nil {
-					fd, md := r.asGroupDescriptors(oodecl.group, isProto3, maxTag)
+				case *ast.GroupNode:
+					fd, md := r.asGroupDescriptors(oodecl, isProto3, maxTag)
 					fd.OneofIndex = proto.Int32(int32(oodIndex))
 					msgd.Field = append(msgd.Field, fd)
 					msgd.NestedType = append(msgd.NestedType, md)
@@ -439,56 +445,67 @@ func (r *parseResult) addMessageDecls(msgd *dpb.DescriptorProto, decls []*messag
 				}
 			}
 			if ooFields == 0 {
-				_ = r.errs.handleErrorWithPos(decl.oneOf.start(), "oneof must contain at least one field")
+				_ = r.errs.handleErrorWithPos(decl.Start(), "oneof must contain at least one field")
 			}
-		} else if decl.nested != nil {
-			msgd.NestedType = append(msgd.NestedType, r.asMessageDescriptor(decl.nested, isProto3))
-		} else if decl.reserved != nil {
-			for _, n := range decl.reserved.names {
-				count := rsvdNames[n.val]
+		case *ast.MessageNode:
+			msgd.NestedType = append(msgd.NestedType, r.asMessageDescriptor(decl, isProto3))
+		case *ast.ReservedNode:
+			for _, n := range decl.Names {
+				count := rsvdNames[n.AsString()]
 				if count == 1 { // already seen
-					_ = r.errs.handleErrorWithPos(n.start(), "name %q is reserved multiple times", n.val)
+					_ = r.errs.handleErrorWithPos(n.Start(), "name %q is reserved multiple times", n.AsString())
 				}
-				rsvdNames[n.val] = count + 1
-				msgd.ReservedName = append(msgd.ReservedName, n.val)
+				rsvdNames[n.AsString()] = count + 1
+				msgd.ReservedName = append(msgd.ReservedName, n.AsString())
 			}
-			for _, rng := range decl.reserved.ranges {
+			for _, rng := range decl.Ranges {
 				msgd.ReservedRange = append(msgd.ReservedRange, r.asMessageReservedRange(rng, maxTag))
 			}
 		}
 	}
 
+	if messageSetOpt != nil {
+		if len(msgd.Field) > 0 {
+			node := r.getFieldNode(msgd.Field[0])
+			_ = r.errs.handleErrorWithPos(node.Start(), "messages with message-set wire format cannot contain non-extension fields")
+		}
+		if len(msgd.ExtensionRange) == 0 {
+			node := r.getOptionNode(messageSetOpt)
+			_ = r.errs.handleErrorWithPos(node.Start(), "messages with message-set wire format must contain at least one extension range")
+		}
+	}
+
 	// process any proto3_optional fields
 	if isProto3 {
 		internal.ProcessProto3OptionalFields(msgd)
 	}
 }
 
-func isMessageSetWireFormat(res *parseResult, scope string, md *dpb.DescriptorProto) (bool, error) {
+func isMessageSetWireFormat(res *parseResult, scope string, md *dpb.DescriptorProto) (*dpb.UninterpretedOption, error) {
 	uo := md.GetOptions().GetUninterpretedOption()
 	index, err := findOption(res, scope, uo, "message_set_wire_format")
 	if err != nil {
-		return false, err
+		return nil, err
 	}
 	if index == -1 {
-		// no such option, so default to false
-		return false, nil
+		// no such option
+		return nil, nil
 	}
 
 	opt := uo[index]
-	optNode := res.getOptionNode(opt)
 
 	switch opt.GetIdentifierValue() {
 	case "true":
-		return true, nil
+		return opt, nil
 	case "false":
-		return false, nil
+		return nil, nil
 	default:
-		return false, res.errs.handleErrorWithPos(optNode.getValue().start(), "%s: expecting bool value for message_set_wire_format option", scope)
+		optNode := res.getOptionNode(opt)
+		return nil, res.errs.handleErrorWithPos(optNode.GetValue().Start(), "%s: expecting bool value for message_set_wire_format option", scope)
 	}
 }
 
-func (r *parseResult) asMessageReservedRange(rng *rangeNode, maxTag int32) *dpb.DescriptorProto_ReservedRange {
+func (r *parseResult) asMessageReservedRange(rng *ast.RangeNode, maxTag int32) *dpb.DescriptorProto_ReservedRange {
 	start, end := getRangeBounds(r, rng, 0, maxTag)
 	rr := &dpb.DescriptorProto_ReservedRange{
 		Start: proto.Int32(start),
@@ -498,40 +515,41 @@ func (r *parseResult) asMessageReservedRange(rng *rangeNode, maxTag int32) *dpb.
 	return rr
 }
 
-func getRangeBounds(res *parseResult, rng *rangeNode, minVal, maxVal int32) (int32, int32) {
+func getRangeBounds(res *parseResult, rng *ast.RangeNode, minVal, maxVal int32) (int32, int32) {
 	checkOrder := true
-	start, ok := rng.startValueAsInt32(minVal, maxVal)
+	start, ok := rng.StartValueAsInt32(minVal, maxVal)
 	if !ok {
 		checkOrder = false
-		_ = res.errs.handleErrorWithPos(rng.startNode.start(), "range start %d is out of range: should be between %d and %d", rng.startValue(), minVal, maxVal)
+		_ = res.errs.handleErrorWithPos(rng.StartVal.Start(), "range start %d is out of range: should be between %d and %d", rng.StartValue(), minVal, maxVal)
 	}
 
-	end, ok := rng.endValueAsInt32(minVal, maxVal)
+	end, ok := rng.EndValueAsInt32(minVal, maxVal)
 	if !ok {
 		checkOrder = false
-		if rng.endNode != nil {
-			_ = res.errs.handleErrorWithPos(rng.endNode.start(), "range end %d is out of range: should be between %d and %d", rng.endValue(), minVal, maxVal)
+		if rng.EndVal != nil {
+			_ = res.errs.handleErrorWithPos(rng.EndVal.Start(), "range end %d is out of range: should be between %d and %d", rng.EndValue(), minVal, maxVal)
 		}
 	}
 
 	if checkOrder && start > end {
-		_ = res.errs.handleErrorWithPos(rng.rangeStart().start(), "range, %d to %d, is invalid: start must be <= end", start, end)
+		_ = res.errs.handleErrorWithPos(rng.RangeStart().Start(), "range, %d to %d, is invalid: start must be <= end", start, end)
 	}
 
 	return start, end
 }
 
-func (r *parseResult) asServiceDescriptor(svc *serviceNode) *dpb.ServiceDescriptorProto {
-	sd := &dpb.ServiceDescriptorProto{Name: proto.String(svc.name.val)}
+func (r *parseResult) asServiceDescriptor(svc *ast.ServiceNode) *dpb.ServiceDescriptorProto {
+	sd := &dpb.ServiceDescriptorProto{Name: proto.String(svc.Name.Val)}
 	r.putServiceNode(sd, svc)
-	for _, decl := range svc.decls {
-		if decl.option != nil {
+	for _, decl := range svc.Decls {
+		switch decl := decl.(type) {
+		case *ast.OptionNode:
 			if sd.Options == nil {
 				sd.Options = &dpb.ServiceOptions{}
 			}
-			sd.Options.UninterpretedOption = append(sd.Options.UninterpretedOption, r.asUninterpretedOption(decl.option))
-		} else if decl.rpc != nil {
-			sd.Method = append(sd.Method, r.asMethodDescriptor(decl.rpc))
+			sd.Options.UninterpretedOption = append(sd.Options.UninterpretedOption, r.asUninterpretedOption(decl))
+		case *ast.RPCNode:
+			sd.Method = append(sd.Method, r.asMethodDescriptor(decl))
 		}
 	}
 	return sd
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/errors.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/errors.go
index 79e2adc29..77ead4d06 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/errors.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/errors.go
@@ -16,6 +16,9 @@ var ErrInvalidSource = errors.New("parse failed: invalid proto source")
 // indicates the file that had no syntax statement.
 var ErrNoSyntax = errors.New("no syntax specified; defaulting to proto2 syntax")
 
+// ErrLookupImportAndProtoSet is the error returned if both LookupImport and LookupImportProto are set.
+var ErrLookupImportAndProtoSet = errors.New("both LookupImport and LookupImportProto set")
+
 // ErrorReporter is responsible for reporting the given error. If the reporter
 // returns a non-nil error, parsing/linking will abort with that error. If the
 // reporter returns nil, parsing will continue, allowing the parser to try to
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/lexer.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/lexer.go
index ce3d2f6d8..e8f2cd0af 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/lexer.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/lexer.go
@@ -9,10 +9,13 @@ import (
 	"strconv"
 	"strings"
 	"unicode/utf8"
+
+	"github.com/jhump/protoreflect/desc/protoparse/ast"
 )
 
 type runeReader struct {
 	rr     *bufio.Reader
+	marked []rune
 	unread []rune
 	err    error
 }
@@ -24,19 +27,40 @@ func (rr *runeReader) readRune() (r rune, size int, err error) {
 	if len(rr.unread) > 0 {
 		r := rr.unread[len(rr.unread)-1]
 		rr.unread = rr.unread[:len(rr.unread)-1]
+		if rr.marked != nil {
+			rr.marked = append(rr.marked, r)
+		}
 		return r, utf8.RuneLen(r), nil
 	}
 	r, sz, err := rr.rr.ReadRune()
 	if err != nil {
 		rr.err = err
+	} else if rr.marked != nil {
+		rr.marked = append(rr.marked, r)
 	}
 	return r, sz, err
 }
 
 func (rr *runeReader) unreadRune(r rune) {
+	if rr.marked != nil {
+		if rr.marked[len(rr.marked)-1] != r {
+			panic("unread rune is not the same as last marked rune!")
+		}
+		rr.marked = rr.marked[:len(rr.marked)-1]
+	}
 	rr.unread = append(rr.unread, r)
 }
 
+func (rr *runeReader) startMark(initial rune) {
+	rr.marked = []rune{initial}
+}
+
+func (rr *runeReader) endMark() string {
+	m := string(rr.marked)
+	rr.marked = rr.marked[:0]
+	return m
+}
+
 func lexError(l protoLexer, pos *SourcePos, err string) {
 	pl := l.(*protoLex)
 	_ = pl.errs.handleErrorWithPos(pos, err)
@@ -46,23 +70,35 @@ type protoLex struct {
 	filename string
 	input    *runeReader
 	errs     *errorHandler
-	res      *fileNode
+	res      *ast.FileNode
 
 	lineNo int
 	colNo  int
 	offset int
 
-	prevSym terminalNode
+	prevSym ast.TerminalNode
+	eof     ast.TerminalNode
 
 	prevLineNo int
 	prevColNo  int
 	prevOffset int
-	comments   []comment
+	comments   []ast.Comment
+	ws         []rune
 }
 
+var utf8Bom = []byte{0xEF, 0xBB, 0xBF}
+
 func newLexer(in io.Reader, filename string, errs *errorHandler) *protoLex {
+	br := bufio.NewReader(in)
+
+	// if file has UTF8 byte order marker preface, consume it
+	marker, err := br.Peek(3)
+	if err == nil && bytes.Equal(marker, utf8Bom) {
+		_, _ = br.Discard(3)
+	}
+
 	return &protoLex{
-		input:    &runeReader{rr: bufio.NewReader(in)},
+		input:    &runeReader{rr: br},
 		filename: filename,
 		errs:     errs,
 	}
@@ -150,7 +186,7 @@ func (l *protoLex) prev() *SourcePos {
 			Col:      1,
 		}
 	}
-	return l.prevSym.start()
+	return l.prevSym.Start()
 }
 
 func (l *protoLex) Lex(lval *protoSymType) int {
@@ -164,6 +200,8 @@ func (l *protoLex) Lex(lval *protoSymType) int {
 	l.prevColNo = l.colNo
 	l.prevOffset = l.offset
 	l.comments = nil
+	l.ws = nil
+	l.input.endMark() // reset, just in case
 
 	for {
 		c, n, err := l.input.readRune()
@@ -171,7 +209,8 @@ func (l *protoLex) Lex(lval *protoSymType) int {
 			// we're not actually returning a rune, but this will associate
 			// accumulated comments as a trailing comment on last symbol
 			// (if appropriate)
-			l.setRune(lval)
+			l.setRune(lval, 0)
+			l.eof = lval.b
 			return 0
 		} else if err != nil {
 			// we don't call setError because we don't want it wrapped
@@ -188,14 +227,16 @@ func (l *protoLex) Lex(lval *protoSymType) int {
 		l.offset += n
 		l.adjustPos(c)
 		if strings.ContainsRune("\n\r\t ", c) {
+			l.ws = append(l.ws, c)
 			continue
 		}
 
+		l.input.startMark(c)
 		if c == '.' {
 			// decimal literals could start with a dot
 			cn, _, err := l.input.readRune()
 			if err != nil {
-				l.setDot(lval)
+				l.setRune(lval, c)
 				return int(c)
 			}
 			if cn >= '0' && cn <= '9' {
@@ -211,7 +252,7 @@ func (l *protoLex) Lex(lval *protoSymType) int {
 				return _FLOAT_LIT
 			}
 			l.input.unreadRune(cn)
-			l.setDot(lval)
+			l.setRune(lval, c)
 			return int(c)
 		}
 
@@ -311,63 +352,77 @@ func (l *protoLex) Lex(lval *protoSymType) int {
 			// comment
 			cn, _, err := l.input.readRune()
 			if err != nil {
-				l.setRune(lval)
+				l.setRune(lval, '/')
 				return int(c)
 			}
 			if cn == '/' {
 				l.adjustPos(cn)
-				hitNewline, txt := l.skipToEndOfLineComment()
-				commentPos := l.posRange()
-				commentPos.end.Col++
+				hitNewline := l.skipToEndOfLineComment()
+				comment := l.newComment()
+				comment.PosRange.End.Col++
 				if hitNewline {
 					// we don't do this inside of skipToEndOfLineComment
 					// because we want to know the length of previous
 					// line for calculation above
 					l.adjustPos('\n')
 				}
-				l.comments = append(l.comments, comment{posRange: commentPos, text: txt})
+				l.comments = append(l.comments, comment)
 				continue
 			}
 			if cn == '*' {
 				l.adjustPos(cn)
-				if txt, ok := l.skipToEndOfBlockComment(); !ok {
+				if ok := l.skipToEndOfBlockComment(); !ok {
 					l.setError(lval, errors.New("block comment never terminates, unexpected EOF"))
 					return _ERROR
 				} else {
-					l.comments = append(l.comments, comment{posRange: l.posRange(), text: txt})
+					l.comments = append(l.comments, l.newComment())
 				}
 				continue
 			}
 			l.input.unreadRune(cn)
 		}
 
-		l.setRune(lval)
+		l.setRune(lval, c)
 		return int(c)
 	}
 }
 
-func (l *protoLex) posRange() posRange {
-	return posRange{
-		start: SourcePos{
+func (l *protoLex) posRange() ast.PosRange {
+	return ast.PosRange{
+		Start: SourcePos{
 			Filename: l.filename,
 			Offset:   l.prevOffset,
 			Line:     l.prevLineNo + 1,
 			Col:      l.prevColNo + 1,
 		},
-		end: l.cur(),
+		End: l.cur(),
+	}
+}
+
+func (l *protoLex) newComment() ast.Comment {
+	ws := string(l.ws)
+	l.ws = l.ws[:0]
+	return ast.Comment{
+		PosRange:          l.posRange(),
+		LeadingWhitespace: ws,
+		Text:              l.input.endMark(),
 	}
 }
 
-func (l *protoLex) newBasicNode() basicNode {
-	return basicNode{
-		posRange: l.posRange(),
-		leading:  l.comments,
+func (l *protoLex) newTokenInfo() ast.TokenInfo {
+	ws := string(l.ws)
+	l.ws = nil
+	return ast.TokenInfo{
+		PosRange:          l.posRange(),
+		LeadingComments:   l.comments,
+		LeadingWhitespace: ws,
+		RawText:           l.input.endMark(),
 	}
 }
 
-func (l *protoLex) setPrev(n terminalNode, isDot bool) {
-	nStart := n.start().Line
-	if _, ok := n.(*basicNode); ok {
+func (l *protoLex) setPrev(n ast.TerminalNode, isDot bool) {
+	nStart := n.Start().Line
+	if _, ok := n.(*ast.RuneNode); ok {
 		// This is really gross, but there are many cases where we don't want
 		// to attribute comments to punctuation (like commas, equals, semicolons)
 		// and would instead prefer to attribute comments to a more meaningful
@@ -382,33 +437,33 @@ func (l *protoLex) setPrev(n terminalNode, isDot bool) {
 			nStart += 2
 		}
 	}
-	if l.prevSym != nil && len(n.leadingComments()) > 0 && l.prevSym.end().Line < nStart {
+	if l.prevSym != nil && len(n.LeadingComments()) > 0 && l.prevSym.End().Line < nStart {
 		// we may need to re-attribute the first comment to
 		// instead be previous node's trailing comment
-		prevEnd := l.prevSym.end().Line
-		comments := n.leadingComments()
+		prevEnd := l.prevSym.End().Line
+		comments := n.LeadingComments()
 		c := comments[0]
-		commentStart := c.start.Line
+		commentStart := c.Start.Line
 		if commentStart == prevEnd {
 			// comment is on same line as previous symbol
-			n.popLeadingComment()
-			l.prevSym.pushTrailingComment(c)
+			n.PopLeadingComment()
+			l.prevSym.PushTrailingComment(c)
 		} else if commentStart == prevEnd+1 {
 			// comment is right after previous symbol; see if it is detached
 			// and if so re-attribute
-			singleLineStyle := strings.HasPrefix(c.text, "//")
-			line := c.end.Line
+			singleLineStyle := strings.HasPrefix(c.Text, "//")
+			line := c.End.Line
 			groupEnd := -1
 			for i := 1; i < len(comments); i++ {
 				c := comments[i]
 				newGroup := false
-				if !singleLineStyle || c.start.Line > line+1 {
+				if !singleLineStyle || c.Start.Line > line+1 {
 					// we've found a gap between comments, which means the
 					// previous comments were detached
 					newGroup = true
 				} else {
-					line = c.end.Line
-					singleLineStyle = strings.HasPrefix(comments[i].text, "//")
+					line = c.End.Line
+					singleLineStyle = strings.HasPrefix(comments[i].Text, "//")
 					if !singleLineStyle {
 						// we've found a switch from // comments to /*
 						// consider that a new group which means the
@@ -428,13 +483,13 @@ func (l *protoLex) setPrev(n terminalNode, isDot bool) {
 				// detached from current symbol
 				c1 := comments[0]
 				c2 := comments[len(comments)-1]
-				if c1.start.Line <= prevEnd+1 && c2.end.Line < nStart-1 {
+				if c1.Start.Line <= prevEnd+1 && c2.End.Line < nStart-1 {
 					groupEnd = len(comments)
 				}
 			}
 
 			for i := 0; i < groupEnd; i++ {
-				l.prevSym.pushTrailingComment(n.popLeadingComment())
+				l.prevSym.PushTrailingComment(n.PopLeadingComment())
 			}
 		}
 	}
@@ -443,35 +498,28 @@ func (l *protoLex) setPrev(n terminalNode, isDot bool) {
 }
 
 func (l *protoLex) setString(lval *protoSymType, val string) {
-	lval.s = &stringLiteralNode{basicNode: l.newBasicNode(), val: val}
+	lval.s = ast.NewStringLiteralNode(val, l.newTokenInfo())
 	l.setPrev(lval.s, false)
 }
 
 func (l *protoLex) setIdent(lval *protoSymType, val string) {
-	lval.id = &identNode{basicNode: l.newBasicNode(), val: val}
+	lval.id = ast.NewIdentNode(val, l.newTokenInfo())
 	l.setPrev(lval.id, false)
 }
 
 func (l *protoLex) setInt(lval *protoSymType, val uint64) {
-	lval.i = &intLiteralNode{basicNode: l.newBasicNode(), val: val}
+	lval.i = ast.NewUintLiteralNode(val, l.newTokenInfo())
 	l.setPrev(lval.i, false)
 }
 
 func (l *protoLex) setFloat(lval *protoSymType, val float64) {
-	lval.f = &floatLiteralNode{basicNode: l.newBasicNode(), val: val}
+	lval.f = ast.NewFloatLiteralNode(val, l.newTokenInfo())
 	l.setPrev(lval.f, false)
 }
 
-func (l *protoLex) setRune(lval *protoSymType) {
-	b := l.newBasicNode()
-	lval.b = &b
-	l.setPrev(lval.b, false)
-}
-
-func (l *protoLex) setDot(lval *protoSymType) {
-	b := l.newBasicNode()
-	lval.b = &b
-	l.setPrev(lval.b, true)
+func (l *protoLex) setRune(lval *protoSymType, val rune) {
+	lval.b = ast.NewRuneNode(val, l.newTokenInfo())
+	l.setPrev(lval.b, val == '.')
 }
 
 func (l *protoLex) setError(lval *protoSymType, err error) {
@@ -724,39 +772,34 @@ func (l *protoLex) readStringLiteral(quote rune) (string, error) {
 	return buf.String(), nil
 }
 
-func (l *protoLex) skipToEndOfLineComment() (bool, string) {
-	txt := []rune{'/', '/'}
+func (l *protoLex) skipToEndOfLineComment() bool {
 	for {
 		c, _, err := l.input.readRune()
 		if err != nil {
-			return false, string(txt)
+			return false
 		}
 		if c == '\n' {
-			return true, string(append(txt, '\n'))
+			return true
 		}
 		l.adjustPos(c)
-		txt = append(txt, c)
 	}
 }
 
-func (l *protoLex) skipToEndOfBlockComment() (string, bool) {
-	txt := []rune{'/', '*'}
+func (l *protoLex) skipToEndOfBlockComment() bool {
 	for {
 		c, _, err := l.input.readRune()
 		if err != nil {
-			return "", false
+			return false
 		}
 		l.adjustPos(c)
-		txt = append(txt, c)
 		if c == '*' {
 			c, _, err := l.input.readRune()
 			if err != nil {
-				return "", false
+				return false
 			}
 			if c == '/' {
 				l.adjustPos(c)
-				txt = append(txt, c)
-				return string(txt), true
+				return true
 			}
 			l.input.unreadRune(c)
 		}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/linker.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/linker.go
index 9d49e565b..872b42fa1 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/linker.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/linker.go
@@ -11,6 +11,7 @@ import (
 
 	"github.com/jhump/protoreflect/desc"
 	"github.com/jhump/protoreflect/desc/internal"
+	"github.com/jhump/protoreflect/desc/protoparse/ast"
 )
 
 type linker struct {
@@ -68,7 +69,7 @@ func (l *linker) linkFiles() (map[string]*desc.FileDescriptor, error) {
 		}
 		// we should now have any message_set_wire_format options parsed
 		// and can do further validation on tag ranges
-		if err := checkExtensionTagsInFile(fd, r); err != nil {
+		if err := checkExtensionsInFile(fd, r); err != nil {
 			return nil, err
 		}
 	}
@@ -141,7 +142,7 @@ func (l *linker) createDescriptorPool() error {
 					desc1, desc2 = desc2, desc1
 				}
 				node := l.files[file2].nodes[desc2]
-				if err := l.errs.handleErrorWithPos(node.start(), "duplicate symbol %s: already defined as %s in %q", k, descriptorType(desc1), file1); err != nil {
+				if err := l.errs.handleErrorWithPos(node.Start(), "duplicate symbol %s: already defined as %s in %q", k, descriptorType(desc1), file1); err != nil {
 					return err
 				}
 			}
@@ -217,7 +218,7 @@ func addServiceToPool(r *parseResult, pool map[string]proto.Message, errs *error
 func addToPool(r *parseResult, pool map[string]proto.Message, errs *errorHandler, fqn string, dsc proto.Message) error {
 	if d, ok := pool[fqn]; ok {
 		node := r.nodes[dsc]
-		if err := errs.handleErrorWithPos(node.start(), "duplicate symbol %s: already defined as %s", fqn, descriptorType(d)); err != nil {
+		if err := errs.handleErrorWithPos(node.Start(), "duplicate symbol %s: already defined as %s", fqn, descriptorType(d)); err != nil {
 			return err
 		}
 	}
@@ -362,12 +363,12 @@ func (l *linker) resolveFieldTypes(r *parseResult, fd *dpb.FileDescriptorProto,
 		elemType = "extension"
 		fqn, dsc, _ := l.resolve(fd, fld.GetExtendee(), isMessage, scopes)
 		if dsc == nil {
-			return l.errs.handleErrorWithPos(node.fieldExtendee().start(), "unknown extendee type %s", fld.GetExtendee())
+			return l.errs.handleErrorWithPos(node.FieldExtendee().Start(), "unknown extendee type %s", fld.GetExtendee())
 		}
 		extd, ok := dsc.(*dpb.DescriptorProto)
 		if !ok {
 			otherType := descriptorType(dsc)
-			return l.errs.handleErrorWithPos(node.fieldExtendee().start(), "extendee is invalid: %s is a %s, not a message", fqn, otherType)
+			return l.errs.handleErrorWithPos(node.FieldExtendee().Start(), "extendee is invalid: %s is a %s, not a message", fqn, otherType)
 		}
 		fld.Extendee = proto.String("." + fqn)
 		// make sure the tag number is in range
@@ -380,7 +381,7 @@ func (l *linker) resolveFieldTypes(r *parseResult, fd *dpb.FileDescriptorProto,
 			}
 		}
 		if !found {
-			if err := l.errs.handleErrorWithPos(node.fieldTag().start(), "%s: tag %d is not in valid range for extended type %s", scope, tag, fqn); err != nil {
+			if err := l.errs.handleErrorWithPos(node.FieldTag().Start(), "%s: tag %d is not in valid range for extended type %s", scope, tag, fqn); err != nil {
 				return err
 			}
 		} else {
@@ -391,7 +392,7 @@ func (l *linker) resolveFieldTypes(r *parseResult, fd *dpb.FileDescriptorProto,
 				l.extensions[fqn] = usedExtTags
 			}
 			if other := usedExtTags[fld.GetNumber()]; other != "" {
-				if err := l.errs.handleErrorWithPos(node.fieldTag().start(), "%s: duplicate extension: %s and %s are both using tag %d", scope, other, thisName, fld.GetNumber()); err != nil {
+				if err := l.errs.handleErrorWithPos(node.FieldTag().Start(), "%s: duplicate extension: %s and %s are both using tag %d", scope, other, thisName, fld.GetNumber()); err != nil {
 					return err
 				}
 			} else {
@@ -413,7 +414,7 @@ func (l *linker) resolveFieldTypes(r *parseResult, fd *dpb.FileDescriptorProto,
 
 	fqn, dsc, proto3 := l.resolve(fd, fld.GetTypeName(), isType, scopes)
 	if dsc == nil {
-		return l.errs.handleErrorWithPos(node.fieldType().start(), "%s: unknown type %s", scope, fld.GetTypeName())
+		return l.errs.handleErrorWithPos(node.FieldType().Start(), "%s: unknown type %s", scope, fld.GetTypeName())
 	}
 	switch dsc := dsc.(type) {
 	case *dpb.DescriptorProto:
@@ -425,14 +426,14 @@ func (l *linker) resolveFieldTypes(r *parseResult, fd *dpb.FileDescriptorProto,
 	case *dpb.EnumDescriptorProto:
 		if fld.GetExtendee() == "" && isProto3(fd) && !proto3 {
 			// fields in a proto3 message cannot refer to proto2 enums
-			return l.errs.handleErrorWithPos(node.fieldType().start(), "%s: cannot use proto2 enum %s in a proto3 message", scope, fld.GetTypeName())
+			return l.errs.handleErrorWithPos(node.FieldType().Start(), "%s: cannot use proto2 enum %s in a proto3 message", scope, fld.GetTypeName())
 		}
 		fld.TypeName = proto.String("." + fqn)
 		// the type was tentatively unset, but now we know it's actually an enum
 		fld.Type = dpb.FieldDescriptorProto_TYPE_ENUM.Enum()
 	default:
 		otherType := descriptorType(dsc)
-		return l.errs.handleErrorWithPos(node.fieldType().start(), "%s: invalid type: %s is a %s, not a message or enum", scope, fqn, otherType)
+		return l.errs.handleErrorWithPos(node.FieldType().Start(), "%s: invalid type: %s is a %s, not a message or enum", scope, fqn, otherType)
 	}
 	return nil
 }
@@ -455,12 +456,12 @@ func (l *linker) resolveServiceTypes(r *parseResult, fd *dpb.FileDescriptorProto
 		node := r.getMethodNode(mtd)
 		fqn, dsc, _ := l.resolve(fd, mtd.GetInputType(), isMessage, scopes)
 		if dsc == nil {
-			if err := l.errs.handleErrorWithPos(node.getInputType().start(), "%s: unknown request type %s", scope, mtd.GetInputType()); err != nil {
+			if err := l.errs.handleErrorWithPos(node.GetInputType().Start(), "%s: unknown request type %s", scope, mtd.GetInputType()); err != nil {
 				return err
 			}
 		} else if _, ok := dsc.(*dpb.DescriptorProto); !ok {
 			otherType := descriptorType(dsc)
-			if err := l.errs.handleErrorWithPos(node.getInputType().start(), "%s: invalid request type: %s is a %s, not a message", scope, fqn, otherType); err != nil {
+			if err := l.errs.handleErrorWithPos(node.GetInputType().Start(), "%s: invalid request type: %s is a %s, not a message", scope, fqn, otherType); err != nil {
 				return err
 			}
 		} else {
@@ -469,12 +470,12 @@ func (l *linker) resolveServiceTypes(r *parseResult, fd *dpb.FileDescriptorProto
 
 		fqn, dsc, _ = l.resolve(fd, mtd.GetOutputType(), isMessage, scopes)
 		if dsc == nil {
-			if err := l.errs.handleErrorWithPos(node.getOutputType().start(), "%s: unknown response type %s", scope, mtd.GetOutputType()); err != nil {
+			if err := l.errs.handleErrorWithPos(node.GetOutputType().Start(), "%s: unknown response type %s", scope, mtd.GetOutputType()); err != nil {
 				return err
 			}
 		} else if _, ok := dsc.(*dpb.DescriptorProto); !ok {
 			otherType := descriptorType(dsc)
-			if err := l.errs.handleErrorWithPos(node.getOutputType().start(), "%s: invalid response type: %s is a %s, not a message", scope, fqn, otherType); err != nil {
+			if err := l.errs.handleErrorWithPos(node.GetOutputType().Start(), "%s: invalid response type: %s is a %s, not a message", scope, fqn, otherType); err != nil {
 				return err
 			}
 		} else {
@@ -496,19 +497,19 @@ opts:
 				node := r.getOptionNamePartNode(nm)
 				fqn, dsc, _ := l.resolve(fd, nm.GetNamePart(), isField, scopes)
 				if dsc == nil {
-					if err := l.errs.handleErrorWithPos(node.start(), "%sunknown extension %s", scope, nm.GetNamePart()); err != nil {
+					if err := l.errs.handleErrorWithPos(node.Start(), "%sunknown extension %s", scope, nm.GetNamePart()); err != nil {
 						return err
 					}
 					continue opts
 				}
 				if ext, ok := dsc.(*dpb.FieldDescriptorProto); !ok {
 					otherType := descriptorType(dsc)
-					if err := l.errs.handleErrorWithPos(node.start(), "%sinvalid extension: %s is a %s, not an extension", scope, nm.GetNamePart(), otherType); err != nil {
+					if err := l.errs.handleErrorWithPos(node.Start(), "%sinvalid extension: %s is a %s, not an extension", scope, nm.GetNamePart(), otherType); err != nil {
 						return err
 					}
 					continue opts
 				} else if ext.GetExtendee() == "" {
-					if err := l.errs.handleErrorWithPos(node.start(), "%sinvalid extension: %s is a field but not an extension", scope, nm.GetNamePart()); err != nil {
+					if err := l.errs.handleErrorWithPos(node.Start(), "%sinvalid extension: %s is a field but not an extension", scope, nm.GetNamePart()); err != nil {
 						return err
 					}
 					continue opts
@@ -703,19 +704,21 @@ func (l *linker) linkFile(name string, rootImportLoc *SourcePos, seen []string,
 	if rootImportLoc == nil {
 		// try to find a source location for this "root" import
 		decl := r.getFileNode(r.fd)
-		fnode, ok := decl.(*fileNode)
+		fnode, ok := decl.(*ast.FileNode)
 		if ok {
-			for _, dep := range fnode.imports {
-				ldep, err := l.linkFile(dep.name.val, dep.name.start(), seen, linked)
-				if err != nil {
-					return nil, err
+			for _, decl := range fnode.Decls {
+				if dep, ok := decl.(*ast.ImportNode); ok {
+					ldep, err := l.linkFile(dep.Name.AsString(), dep.Name.Start(), seen, linked)
+					if err != nil {
+						return nil, err
+					}
+					deps = append(deps, ldep)
 				}
-				deps = append(deps, ldep)
 			}
 		} else {
 			// no AST? just use the descriptor
 			for _, dep := range r.fd.Dependency {
-				ldep, err := l.linkFile(dep, decl.start(), seen, linked)
+				ldep, err := l.linkFile(dep, decl.Start(), seen, linked)
 				if err != nil {
 					return nil, err
 				}
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/options.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/options.go
index 403deb993..23b06d875 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/options.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/options.go
@@ -10,6 +10,7 @@ import (
 
 	"github.com/jhump/protoreflect/desc"
 	"github.com/jhump/protoreflect/desc/internal"
+	"github.com/jhump/protoreflect/desc/protoparse/ast"
 	"github.com/jhump/protoreflect/dynamic"
 )
 
@@ -795,12 +796,12 @@ func interpretFieldOptions(r *parseResult, fld fldDescriptorish) error {
 			optNode := r.getOptionNode(opt)
 
 			// attribute source code info
-			if on, ok := optNode.(*optionNode); ok {
+			if on, ok := optNode.(*ast.OptionNode); ok {
 				r.interpretedOptions[on] = []int32{-1, internal.Field_jsonNameTag}
 			}
 			uo = removeOption(uo, index)
 			if opt.StringValue == nil {
-				if err := r.errs.handleErrorWithPos(optNode.getValue().start(), "%s: expecting string value for json_name option", scope); err != nil {
+				if err := r.errs.handleErrorWithPos(optNode.GetValue().Start(), "%s: expecting string value for json_name option", scope); err != nil {
 					return err
 				}
 			} else {
@@ -814,7 +815,7 @@ func interpretFieldOptions(r *parseResult, fld fldDescriptorish) error {
 		} else if index >= 0 {
 			// attribute source code info
 			optNode := r.getOptionNode(uo[index])
-			if on, ok := optNode.(*optionNode); ok {
+			if on, ok := optNode.(*ast.OptionNode); ok {
 				r.interpretedOptions[on] = []int32{-1, internal.Field_defaultTag}
 			}
 			uo = removeOption(uo, index)
@@ -841,14 +842,14 @@ func processDefaultOption(res *parseResult, scope string, fld fldDescriptorish,
 	optNode := res.getOptionNode(opt)
 	fdp := fld.AsFieldDescriptorProto()
 	if fdp.GetLabel() == dpb.FieldDescriptorProto_LABEL_REPEATED {
-		return -1, res.errs.handleErrorWithPos(optNode.getName().start(), "%s: default value cannot be set because field is repeated", scope)
+		return -1, res.errs.handleErrorWithPos(optNode.GetName().Start(), "%s: default value cannot be set because field is repeated", scope)
 	}
 	if fdp.GetType() == dpb.FieldDescriptorProto_TYPE_GROUP || fdp.GetType() == dpb.FieldDescriptorProto_TYPE_MESSAGE {
-		return -1, res.errs.handleErrorWithPos(optNode.getName().start(), "%s: default value cannot be set because field is a message", scope)
+		return -1, res.errs.handleErrorWithPos(optNode.GetName().Start(), "%s: default value cannot be set because field is a message", scope)
 	}
-	val := optNode.getValue()
-	if _, ok := val.(*aggregateLiteralNode); ok {
-		return -1, res.errs.handleErrorWithPos(val.start(), "%s: default value cannot be an aggregate", scope)
+	val := optNode.GetValue()
+	if _, ok := val.(*ast.MessageLiteralNode); ok {
+		return -1, res.errs.handleErrorWithPos(val.Start(), "%s: default value cannot be a message", scope)
 	}
 	mc := &messageContext{
 		res:         res,
@@ -936,7 +937,7 @@ func interpretOptions(res *parseResult, element descriptorish, opts proto.Messag
 			return uninterpreted, nil
 		}
 		node := res.nodes[element.AsProto()]
-		return nil, res.errs.handleError(ErrorWithSourcePos{Pos: node.start(), Underlying: err})
+		return nil, res.errs.handleError(ErrorWithSourcePos{Pos: node.Start(), Underlying: err})
 	}
 
 	mc := &messageContext{res: res, file: element.GetFile(), elementName: element.GetFullyQualifiedName(), elementType: descriptorType(element.AsProto())}
@@ -949,7 +950,7 @@ func interpretOptions(res *parseResult, element descriptorish, opts proto.Messag
 				continue
 			}
 			// uninterpreted_option might be found reflectively, but is not actually valid for use
-			if err := res.errs.handleErrorWithPos(node.getName().start(), "%vinvalid option 'uninterpreted_option'", mc); err != nil {
+			if err := res.errs.handleErrorWithPos(node.GetName().Start(), "%vinvalid option 'uninterpreted_option'", mc); err != nil {
 				return nil, err
 			}
 		}
@@ -962,7 +963,7 @@ func interpretOptions(res *parseResult, element descriptorish, opts proto.Messag
 			}
 			return nil, err
 		}
-		if optn, ok := node.(*optionNode); ok {
+		if optn, ok := node.(*ast.OptionNode); ok {
 			res.interpretedOptions[optn] = path
 		}
 	}
@@ -987,7 +988,7 @@ func interpretOptions(res *parseResult, element descriptorish, opts proto.Messag
 
 	if err := dm.ValidateRecursive(); err != nil {
 		node := res.nodes[element.AsProto()]
-		if err := res.errs.handleErrorWithPos(node.start(), "error in %s options: %v", descriptorType(element.AsProto()), err); err != nil {
+		if err := res.errs.handleErrorWithPos(node.Start(), "error in %s options: %v", descriptorType(element.AsProto()), err); err != nil {
 			return nil, err
 		}
 	}
@@ -995,7 +996,7 @@ func interpretOptions(res *parseResult, element descriptorish, opts proto.Messag
 	// nw try to convert into the passed in message and fail if not successful
 	if err := dm.ConvertToDeterministic(opts); err != nil {
 		node := res.nodes[element.AsProto()]
-		return nil, res.errs.handleError(ErrorWithSourcePos{Pos: node.start(), Underlying: err})
+		return nil, res.errs.handleError(ErrorWithSourcePos{Pos: node.Start(), Underlying: err})
 	}
 
 	return nil, nil
@@ -1012,19 +1013,19 @@ func interpretField(res *parseResult, mc *messageContext, element descriptorish,
 		}
 		fld = findExtension(element.GetFile(), extName, false, map[fileDescriptorish]struct{}{})
 		if fld == nil {
-			return nil, res.errs.handleErrorWithPos(node.start(),
+			return nil, res.errs.handleErrorWithPos(node.Start(),
 				"%vunrecognized extension %s of %s",
 				mc, extName, dm.GetMessageDescriptor().GetFullyQualifiedName())
 		}
 		if fld.GetOwner().GetFullyQualifiedName() != dm.GetMessageDescriptor().GetFullyQualifiedName() {
-			return nil, res.errs.handleErrorWithPos(node.start(),
+			return nil, res.errs.handleErrorWithPos(node.Start(),
 				"%vextension %s should extend %s but instead extends %s",
 				mc, extName, dm.GetMessageDescriptor().GetFullyQualifiedName(), fld.GetOwner().GetFullyQualifiedName())
 		}
 	} else {
 		fld = dm.GetMessageDescriptor().FindFieldByName(nm.GetNamePart())
 		if fld == nil {
-			return nil, res.errs.handleErrorWithPos(node.start(),
+			return nil, res.errs.handleErrorWithPos(node.Start(),
 				"%vfield %s of %s does not exist",
 				mc, nm.GetNamePart(), dm.GetMessageDescriptor().GetFullyQualifiedName())
 		}
@@ -1036,12 +1037,12 @@ func interpretField(res *parseResult, mc *messageContext, element descriptorish,
 		nextnm := opt.GetName()[nameIndex+1]
 		nextnode := res.getOptionNamePartNode(nextnm)
 		if fld.GetType() != dpb.FieldDescriptorProto_TYPE_MESSAGE {
-			return nil, res.errs.handleErrorWithPos(nextnode.start(),
+			return nil, res.errs.handleErrorWithPos(nextnode.Start(),
 				"%vcannot set field %s because %s is not a message",
 				mc, nextnm.GetNamePart(), nm.GetNamePart())
 		}
 		if fld.IsRepeated() {
-			return nil, res.errs.handleErrorWithPos(nextnode.start(),
+			return nil, res.errs.handleErrorWithPos(nextnode.Start(),
 				"%vcannot set field %s because %s is repeated (must use an aggregate)",
 				mc, nextnm.GetNamePart(), nm.GetNamePart())
 		}
@@ -1056,14 +1057,14 @@ func interpretField(res *parseResult, mc *messageContext, element descriptorish,
 			err = dm.TrySetField(fld, fdm)
 		}
 		if err != nil {
-			return nil, res.errs.handleError(ErrorWithSourcePos{Pos: node.start(), Underlying: err})
+			return nil, res.errs.handleError(ErrorWithSourcePos{Pos: node.Start(), Underlying: err})
 		}
 		// recurse to set next part of name
 		return interpretField(res, mc, element, fdm, opt, nameIndex+1, path)
 	}
 
 	optNode := res.getOptionNode(opt)
-	if err := setOptionField(res, mc, dm, fld, node, optNode.getValue()); err != nil {
+	if err := setOptionField(res, mc, dm, fld, node, optNode.GetValue()); err != nil {
 		return nil, res.errs.handleError(err)
 	}
 	if fld.IsRepeated() {
@@ -1105,12 +1106,12 @@ func findExtension(fd fileDescriptorish, name string, public bool, checked map[f
 	return nil
 }
 
-func setOptionField(res *parseResult, mc *messageContext, dm *dynamic.Message, fld *desc.FieldDescriptor, name node, val valueNode) error {
-	v := val.value()
-	if sl, ok := v.([]valueNode); ok {
+func setOptionField(res *parseResult, mc *messageContext, dm *dynamic.Message, fld *desc.FieldDescriptor, name ast.Node, val ast.ValueNode) error {
+	v := val.Value()
+	if sl, ok := v.([]ast.ValueNode); ok {
 		// handle slices a little differently than the others
 		if !fld.IsRepeated() {
-			return errorWithPos(val.start(), "%vvalue is an array but field is not repeated", mc)
+			return errorWithPos(val.Start(), "%vvalue is an array but field is not repeated", mc)
 		}
 		origPath := mc.optAggPath
 		defer func() {
@@ -1121,7 +1122,7 @@ func setOptionField(res *parseResult, mc *messageContext, dm *dynamic.Message, f
 			if v, err := fieldValue(res, mc, richFldDescriptorish{FieldDescriptor: fld}, item, false); err != nil {
 				return err
 			} else if err = dm.TryAddRepeatedField(fld, v); err != nil {
-				return errorWithPos(val.start(), "%verror setting value: %s", mc, err)
+				return errorWithPos(val.Start(), "%verror setting value: %s", mc, err)
 			}
 		}
 		return nil
@@ -1135,12 +1136,12 @@ func setOptionField(res *parseResult, mc *messageContext, dm *dynamic.Message, f
 		err = dm.TryAddRepeatedField(fld, v)
 	} else {
 		if dm.HasField(fld) {
-			return errorWithPos(name.start(), "%vnon-repeated option field %s already set", mc, fieldName(fld))
+			return errorWithPos(name.Start(), "%vnon-repeated option field %s already set", mc, fieldName(fld))
 		}
 		err = dm.TrySetField(fld, v)
 	}
 	if err != nil {
-		return errorWithPos(val.start(), "%verror setting value: %s", mc, err)
+		return errorWithPos(val.Start(), "%verror setting value: %s", mc, err)
 	}
 
 	return nil
@@ -1157,7 +1158,7 @@ func findOption(res *parseResult, scope string, opts []*dpb.UninterpretedOption,
 		}
 		if found >= 0 {
 			optNode := res.getOptionNode(opt)
-			return -1, res.errs.handleErrorWithPos(optNode.getName().start(), "%s: option %s cannot be defined more than once", scope, name)
+			return -1, res.errs.handleErrorWithPos(optNode.GetName().Start(), "%s: option %s cannot be defined more than once", scope, name)
 		}
 		found = i
 	}
@@ -1237,7 +1238,7 @@ func fieldName(fld *desc.FieldDescriptor) string {
 
 func valueKind(val interface{}) string {
 	switch val := val.(type) {
-	case identifier:
+	case ast.Identifier:
 		return "identifier"
 	case bool:
 		return "bool"
@@ -1252,22 +1253,24 @@ func valueKind(val interface{}) string {
 		return "double"
 	case string, []byte:
 		return "string"
-	case []*aggregateEntryNode:
+	case []*ast.MessageFieldNode:
 		return "message"
+	case []ast.ValueNode:
+		return "array"
 	default:
 		return fmt.Sprintf("%T", val)
 	}
 }
 
-func fieldValue(res *parseResult, mc *messageContext, fld fldDescriptorish, val valueNode, enumAsString bool) (interface{}, error) {
-	v := val.value()
+func fieldValue(res *parseResult, mc *messageContext, fld fldDescriptorish, val ast.ValueNode, enumAsString bool) (interface{}, error) {
+	v := val.Value()
 	t := fld.AsFieldDescriptorProto().GetType()
 	switch t {
 	case dpb.FieldDescriptorProto_TYPE_ENUM:
-		if id, ok := v.(identifier); ok {
+		if id, ok := v.(ast.Identifier); ok {
 			ev := fld.GetEnumType().FindValueByName(string(id))
 			if ev == nil {
-				return nil, errorWithPos(val.start(), "%venum %s has no value named %s", mc, fld.GetEnumType().GetFullyQualifiedName(), id)
+				return nil, errorWithPos(val.Start(), "%venum %s has no value named %s", mc, fld.GetEnumType().GetFullyQualifiedName(), id)
 			}
 			if enumAsString {
 				return ev.GetName(), nil
@@ -1275,9 +1278,9 @@ func fieldValue(res *parseResult, mc *messageContext, fld fldDescriptorish, val
 				return ev.GetNumber(), nil
 			}
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting enum, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting enum, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_MESSAGE, dpb.FieldDescriptorProto_TYPE_GROUP:
-		if aggs, ok := v.([]*aggregateEntryNode); ok {
+		if aggs, ok := v.([]*ast.MessageFieldNode); ok {
 			fmd := fld.GetMessageType()
 			fdm := dynamic.NewMessage(fmd)
 			origPath := mc.optAggPath
@@ -1286,13 +1289,13 @@ func fieldValue(res *parseResult, mc *messageContext, fld fldDescriptorish, val
 			}()
 			for _, a := range aggs {
 				if origPath == "" {
-					mc.optAggPath = a.name.value()
+					mc.optAggPath = a.Name.Value()
 				} else {
-					mc.optAggPath = origPath + "." + a.name.value()
+					mc.optAggPath = origPath + "." + a.Name.Value()
 				}
 				var ffld *desc.FieldDescriptor
-				if a.name.isExtension {
-					n := a.name.name.val
+				if a.Name.IsExtension() {
+					n := string(a.Name.Name.AsIdentifier())
 					ffld = findExtension(mc.file, n, false, map[fileDescriptorish]struct{}{})
 					if ffld == nil {
 						// may need to qualify with package name
@@ -1302,83 +1305,83 @@ func fieldValue(res *parseResult, mc *messageContext, fld fldDescriptorish, val
 						}
 					}
 				} else {
-					ffld = fmd.FindFieldByName(a.name.value())
+					ffld = fmd.FindFieldByName(a.Name.Value())
 				}
 				if ffld == nil {
-					return nil, errorWithPos(val.start(), "%vfield %s not found", mc, a.name.name.val)
+					return nil, errorWithPos(val.Start(), "%vfield %s not found", mc, string(a.Name.Name.AsIdentifier()))
 				}
-				if err := setOptionField(res, mc, fdm, ffld, a.name, a.val); err != nil {
+				if err := setOptionField(res, mc, fdm, ffld, a.Name, a.Val); err != nil {
 					return nil, err
 				}
 			}
 			return fdm, nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting message, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting message, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_BOOL:
 		if b, ok := v.(bool); ok {
 			return b, nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting bool, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting bool, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_BYTES:
 		if str, ok := v.(string); ok {
 			return []byte(str), nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting bytes, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting bytes, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_STRING:
 		if str, ok := v.(string); ok {
 			return str, nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting string, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting string, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_INT32, dpb.FieldDescriptorProto_TYPE_SINT32, dpb.FieldDescriptorProto_TYPE_SFIXED32:
 		if i, ok := v.(int64); ok {
 			if i > math.MaxInt32 || i < math.MinInt32 {
-				return nil, errorWithPos(val.start(), "%vvalue %d is out of range for int32", mc, i)
+				return nil, errorWithPos(val.Start(), "%vvalue %d is out of range for int32", mc, i)
 			}
 			return int32(i), nil
 		}
 		if ui, ok := v.(uint64); ok {
 			if ui > math.MaxInt32 {
-				return nil, errorWithPos(val.start(), "%vvalue %d is out of range for int32", mc, ui)
+				return nil, errorWithPos(val.Start(), "%vvalue %d is out of range for int32", mc, ui)
 			}
 			return int32(ui), nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting int32, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting int32, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_UINT32, dpb.FieldDescriptorProto_TYPE_FIXED32:
 		if i, ok := v.(int64); ok {
 			if i > math.MaxUint32 || i < 0 {
-				return nil, errorWithPos(val.start(), "%vvalue %d is out of range for uint32", mc, i)
+				return nil, errorWithPos(val.Start(), "%vvalue %d is out of range for uint32", mc, i)
 			}
 			return uint32(i), nil
 		}
 		if ui, ok := v.(uint64); ok {
 			if ui > math.MaxUint32 {
-				return nil, errorWithPos(val.start(), "%vvalue %d is out of range for uint32", mc, ui)
+				return nil, errorWithPos(val.Start(), "%vvalue %d is out of range for uint32", mc, ui)
 			}
 			return uint32(ui), nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting uint32, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting uint32, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_INT64, dpb.FieldDescriptorProto_TYPE_SINT64, dpb.FieldDescriptorProto_TYPE_SFIXED64:
 		if i, ok := v.(int64); ok {
 			return i, nil
 		}
 		if ui, ok := v.(uint64); ok {
 			if ui > math.MaxInt64 {
-				return nil, errorWithPos(val.start(), "%vvalue %d is out of range for int64", mc, ui)
+				return nil, errorWithPos(val.Start(), "%vvalue %d is out of range for int64", mc, ui)
 			}
 			return int64(ui), nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting int64, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting int64, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_UINT64, dpb.FieldDescriptorProto_TYPE_FIXED64:
 		if i, ok := v.(int64); ok {
 			if i < 0 {
-				return nil, errorWithPos(val.start(), "%vvalue %d is out of range for uint64", mc, i)
+				return nil, errorWithPos(val.Start(), "%vvalue %d is out of range for uint64", mc, i)
 			}
 			return uint64(i), nil
 		}
 		if ui, ok := v.(uint64); ok {
 			return ui, nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting uint64, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting uint64, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_DOUBLE:
 		if d, ok := v.(float64); ok {
 			return d, nil
@@ -1389,11 +1392,11 @@ func fieldValue(res *parseResult, mc *messageContext, fld fldDescriptorish, val
 		if u, ok := v.(uint64); ok {
 			return float64(u), nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting double, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting double, got %s", mc, valueKind(v))
 	case dpb.FieldDescriptorProto_TYPE_FLOAT:
 		if d, ok := v.(float64); ok {
 			if (d > math.MaxFloat32 || d < -math.MaxFloat32) && !math.IsInf(d, 1) && !math.IsInf(d, -1) && !math.IsNaN(d) {
-				return nil, errorWithPos(val.start(), "%vvalue %f is out of range for float", mc, d)
+				return nil, errorWithPos(val.Start(), "%vvalue %f is out of range for float", mc, d)
 			}
 			return float32(d), nil
 		}
@@ -1403,8 +1406,8 @@ func fieldValue(res *parseResult, mc *messageContext, fld fldDescriptorish, val
 		if u, ok := v.(uint64); ok {
 			return float32(u), nil
 		}
-		return nil, errorWithPos(val.start(), "%vexpecting float, got %s", mc, valueKind(v))
+		return nil, errorWithPos(val.Start(), "%vexpecting float, got %s", mc, valueKind(v))
 	default:
-		return nil, errorWithPos(val.start(), "%vunrecognized field type: %s", mc, t)
+		return nil, errorWithPos(val.Start(), "%vunrecognized field type: %s", mc, t)
 	}
 }
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/parser.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/parser.go
index 6025bd0da..bbfec8d1f 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/parser.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/parser.go
@@ -17,6 +17,7 @@ import (
 
 	"github.com/jhump/protoreflect/desc"
 	"github.com/jhump/protoreflect/desc/internal"
+	"github.com/jhump/protoreflect/desc/protoparse/ast"
 )
 
 //go:generate goyacc -o proto.y.go -p proto proto.y
@@ -118,6 +119,12 @@ type Parser struct {
 	// desc.LoadFileDescriptor.
 	LookupImport func(string) (*desc.FileDescriptor, error)
 
+	// LookupImportProto has the same functionality as LookupImport, however it returns
+	// a FileDescriptorProto instead of a FileDescriptor.
+	//
+	// It is an error to set both LookupImport and LookupImportProto.
+	LookupImportProto func(string) (*dpb.FileDescriptorProto, error)
+
 	// Used to create a reader for a given filename, when loading proto source
 	// file contents. If unset, os.Open is used. If ImportPaths is also empty
 	// then relative paths are will be relative to the process's current working
@@ -200,11 +207,20 @@ func (p Parser) ParseFiles(filenames ...string) ([]*desc.FileDescriptor, error)
 			return nil, ret
 		}
 	}
+	lookupImport, err := p.getLookupImport()
+	if err != nil {
+		return nil, err
+	}
 
 	protos := map[string]*parseResult{}
-	results := &parseResults{resultsByFilename: protos}
+	results := &parseResults{
+		resultsByFilename:      protos,
+		recursive:              true,
+		validate:               true,
+		createDescriptorProtos: true,
+	}
 	errs := newErrorHandler(p.ErrorReporter, p.WarningReporter)
-	parseProtoFiles(accessor, filenames, errs, true, true, results, p.LookupImport)
+	parseProtoFiles(accessor, filenames, errs, results, lookupImport)
 	if err := errs.getError(); err != nil {
 		return nil, err
 	}
@@ -248,19 +264,19 @@ func (p Parser) ParseFiles(filenames ...string) ([]*desc.FileDescriptor, error)
 //      scope in which the type reference appears. This goes for fields that
 //      have message and enum types. It also applies to methods and their
 //      references to request and response message types.
-//   3. Enum fields are not known. Until a field's type reference is resolved
-//      (during linking), it is not known whether the type refers to a message
-//      or an enum. So all fields with such type references have their Type set
-//      to TYPE_MESSAGE.
+//   3. Type references are not known. For non-scalar fields, until the type
+//      name is resolved (during linking), it is not known whether the type
+//      refers to a message or an enum. So all fields with such type references
+//      will not have their Type set, only the TypeName.
 //
 // This method will still validate the syntax of parsed files. If the parser's
 // ValidateUnlinkedFiles field is true, additional checks, beyond syntax will
 // also be performed.
 //
-// If the Parser has no ErrorReporter set and a syntax or link error occurs,
-// parsing will abort with the first such error encountered. If there is an
+// If the Parser has no ErrorReporter set and a syntax error occurs, parsing
+// will abort with the first such error encountered. If there is an
 // ErrorReporter configured and it returns non-nil, parsing will abort with the
-// error it returns. If syntax or link errors are encountered but the configured
+// error it returns. If syntax errors are encountered but the configured
 // ErrorReporter always returns nil, the parse fails with ErrInvalidSource.
 func (p Parser) ParseFilesButDoNotLink(filenames ...string) ([]*dpb.FileDescriptorProto, error) {
 	accessor := p.Accessor
@@ -269,10 +285,19 @@ func (p Parser) ParseFilesButDoNotLink(filenames ...string) ([]*dpb.FileDescript
 			return os.Open(name)
 		}
 	}
+	lookupImport, err := p.getLookupImport()
+	if err != nil {
+		return nil, err
+	}
 
 	protos := map[string]*parseResult{}
 	errs := newErrorHandler(p.ErrorReporter, p.WarningReporter)
-	parseProtoFiles(accessor, filenames, errs, false, p.ValidateUnlinkedFiles, &parseResults{resultsByFilename: protos}, p.LookupImport)
+	results := &parseResults{
+		resultsByFilename:      protos,
+		validate:               p.ValidateUnlinkedFiles,
+		createDescriptorProtos: true,
+	}
+	parseProtoFiles(accessor, filenames, errs, results, lookupImport)
 	if err := errs.getError(); err != nil {
 		return nil, err
 	}
@@ -301,6 +326,67 @@ func (p Parser) ParseFilesButDoNotLink(filenames ...string) ([]*dpb.FileDescript
 	return fds, nil
 }
 
+// ParseToAST parses the named files into ASTs, or Abstract Syntax Trees. This
+// is for consumers of proto files that don't care about compiling the files to
+// descriptors, but care deeply about a non-lossy structured representation of
+// the source (since descriptors are lossy). This includes formatting tools and
+// possibly linters, too.
+//
+// If the requested filenames include standard imports (such as
+// "google/protobuf/empty.proto") and no source is provided, the corresponding
+// AST in the returned slice will be nil. These standard imports are only
+// available for use as descriptors; no source is available unless it is
+// provided by the configured Accessor.
+//
+// If the Parser has no ErrorReporter set and a syntax error occurs, parsing
+// will abort with the first such error encountered. If there is an
+// ErrorReporter configured and it returns non-nil, parsing will abort with the
+// error it returns. If syntax errors are encountered but the configured
+// ErrorReporter always returns nil, the parse fails with ErrInvalidSource.
+func (p Parser) ParseToAST(filenames ...string) ([]*ast.FileNode, error) {
+	accessor := p.Accessor
+	if accessor == nil {
+		accessor = func(name string) (io.ReadCloser, error) {
+			return os.Open(name)
+		}
+	}
+	lookupImport, err := p.getLookupImport()
+	if err != nil {
+		return nil, err
+	}
+
+	protos := map[string]*parseResult{}
+	errs := newErrorHandler(p.ErrorReporter, p.WarningReporter)
+	parseProtoFiles(accessor, filenames, errs, &parseResults{resultsByFilename: protos}, lookupImport)
+	if err := errs.getError(); err != nil {
+		return nil, err
+	}
+	ret := make([]*ast.FileNode, 0, len(filenames))
+	for _, name := range filenames {
+		ret = append(ret, protos[name].root)
+	}
+	return ret, nil
+}
+
+func (p Parser) getLookupImport() (func(string) (*dpb.FileDescriptorProto, error), error) {
+	if p.LookupImport != nil && p.LookupImportProto != nil {
+		return nil, ErrLookupImportAndProtoSet
+	}
+	if p.LookupImportProto != nil {
+		return p.LookupImportProto, nil
+	}
+	if p.LookupImport != nil {
+		return func(path string) (*dpb.FileDescriptorProto, error) {
+			value, err := p.LookupImport(path)
+			if value != nil {
+				return value.AsFileDescriptorProto(), err
+			}
+			return nil, err
+		}, nil
+	}
+	return nil, nil
+}
+
 func fixupFilenames(protos map[string]*parseResult) map[string]*parseResult {
 	// In the event that the given filenames (keys in the supplied map) do not
 	// match the actual paths used in 'import' statements in the files, we try
@@ -409,21 +495,21 @@ func fixupFilenames(protos map[string]*parseResult) map[string]*parseResult {
 	return revisedProtos
 }
 
-func parseProtoFiles(acc FileAccessor, filenames []string, errs *errorHandler, recursive, validate bool, parsed *parseResults, lookupImport func(string) (*desc.FileDescriptor, error)) {
+func parseProtoFiles(acc FileAccessor, filenames []string, errs *errorHandler, parsed *parseResults, lookupImport func(string) (*dpb.FileDescriptorProto, error)) {
 	for _, name := range filenames {
-		parseProtoFile(acc, name, nil, errs, recursive, validate, parsed, lookupImport)
+		parseProtoFile(acc, name, nil, errs, parsed, lookupImport)
 		if errs.err != nil {
 			return
 		}
 	}
 }
 
-func parseProtoFile(acc FileAccessor, filename string, importLoc *SourcePos, errs *errorHandler, recursive, validate bool, parsed *parseResults, lookupImport func(string) (*desc.FileDescriptor, error)) {
-	if parsed.has(filename) {
+func parseProtoFile(acc FileAccessor, filename string, importLoc *SourcePos, errs *errorHandler, results *parseResults, lookupImport func(string) (*dpb.FileDescriptorProto, error)) {
+	if results.has(filename) {
 		return
 	}
 	if lookupImport == nil {
-		lookupImport = func(string) (*desc.FileDescriptor, error) {
+		lookupImport = func(string) (*dpb.FileDescriptorProto, error) {
 			return nil, errors.New("no import lookup function")
 		}
 	}
@@ -437,12 +523,12 @@ func parseProtoFile(acc FileAccessor, filename string, importLoc *SourcePos, err
 				// closing need not fail this operation
 				_ = in.Close()
 			}()
-			result = parseProto(filename, in, errs, validate)
+			result = parseProto(filename, in, errs, results.validate, results.createDescriptorProtos)
 		}()
 	} else if d, lookupErr := lookupImport(filename); lookupErr == nil {
 		// This is a user-provided descriptor, which is acting similarly to a
 		// well-known import.
-		result = &parseResult{fd: proto.Clone(d.AsFileDescriptorProto()).(*dpb.FileDescriptorProto)}
+		result = &parseResult{fd: proto.Clone(d).(*dpb.FileDescriptorProto)}
 	} else if d, ok := standardImports[filename]; ok {
 		// it's a well-known import
 		// (we clone it to make sure we're not sharing state with other
@@ -472,20 +558,20 @@ func parseProtoFile(acc FileAccessor, filename string, importLoc *SourcePos, err
 		return
 	}
 
-	parsed.add(filename, result)
+	results.add(filename, result)
 
 	if errs.err != nil {
 		return // abort
 	}
 
-	if recursive {
+	if results.recursive {
 		fd := result.fd
 		decl := result.getFileNode(fd)
-		fnode, ok := decl.(*fileNode)
+		fnode, ok := decl.(*ast.FileNode)
 		if !ok {
 			// no AST for this file? use imports in descriptor
 			for _, dep := range fd.Dependency {
-				parseProtoFile(acc, dep, decl.start(), errs, true, validate, parsed, lookupImport)
+				parseProtoFile(acc, dep, decl.Start(), errs, results, lookupImport)
 				if errs.getError() != nil {
 					return // abort
 				}
@@ -493,10 +579,12 @@ func parseProtoFile(acc FileAccessor, filename string, importLoc *SourcePos, err
 			return
 		}
 		// we have an AST; use it so we can report import location in errors
-		for _, dep := range fnode.imports {
-			parseProtoFile(acc, dep.name.val, dep.name.start(), errs, true, validate, parsed, lookupImport)
-			if errs.getError() != nil {
-				return // abort
+		for _, decl := range fnode.Decls {
+			if dep, ok := decl.(*ast.ImportNode); ok {
+				parseProtoFile(acc, dep.Name.AsString(), dep.Name.Start(), errs, results, lookupImport)
+				if errs.getError() != nil {
+					return // abort
+				}
 			}
 		}
 	}
@@ -505,6 +593,8 @@ func parseProtoFile(acc FileAccessor, filename string, importLoc *SourcePos, err
 type parseResults struct {
 	resultsByFilename map[string]*parseResult
 	filenames         []string
+
+	recursive, validate, createDescriptorProtos bool
 }
 
 func (r *parseResults) has(filename string) bool {
@@ -522,6 +612,8 @@ type parseResult struct {
 	// or validation
 	errs *errorHandler
 
+	// the root of the AST
+	root *ast.FileNode
 	// the parsed file descriptor
 	fd *dpb.FileDescriptorProto
 
@@ -532,141 +624,149 @@ type parseResult struct {
 
 	// a map of elements in the descriptor to nodes in the AST
 	// (for extracting position information when validating the descriptor)
-	nodes map[proto.Message]node
+	nodes map[proto.Message]ast.Node
 
 	// a map of uninterpreted option AST nodes to their relative path
 	// in the resulting options message
-	interpretedOptions map[*optionNode][]int32
+	interpretedOptions map[*ast.OptionNode][]int32
 }
 
-func (r *parseResult) getFileNode(f *dpb.FileDescriptorProto) fileDecl {
+func (r *parseResult) getFileNode(f *dpb.FileDescriptorProto) ast.FileDeclNode {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(f.GetName())}
+		return ast.NewNoSourceNode(f.GetName())
 	}
-	return r.nodes[f].(fileDecl)
+	return r.nodes[f].(ast.FileDeclNode)
 }
 
-func (r *parseResult) getOptionNode(o *dpb.UninterpretedOption) optionDecl {
+func (r *parseResult) getOptionNode(o *dpb.UninterpretedOption) ast.OptionDeclNode {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(r.fd.GetName())}
+		return ast.NewNoSourceNode(r.fd.GetName())
 	}
-	return r.nodes[o].(optionDecl)
+	return r.nodes[o].(ast.OptionDeclNode)
 }
 
-func (r *parseResult) getOptionNamePartNode(o *dpb.UninterpretedOption_NamePart) node {
+func (r *parseResult) getOptionNamePartNode(o *dpb.UninterpretedOption_NamePart) ast.Node {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(r.fd.GetName())}
+		return ast.NewNoSourceNode(r.fd.GetName())
 	}
 	return r.nodes[o]
 }
 
-func (r *parseResult) getFieldNode(f *dpb.FieldDescriptorProto) fieldDecl {
+func (r *parseResult) getFieldNode(f *dpb.FieldDescriptorProto) ast.FieldDeclNode {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(r.fd.GetName())}
+		return ast.NewNoSourceNode(r.fd.GetName())
 	}
-	return r.nodes[f].(fieldDecl)
+	return r.nodes[f].(ast.FieldDeclNode)
 }
 
-func (r *parseResult) getExtensionRangeNode(e *dpb.DescriptorProto_ExtensionRange) rangeDecl {
+func (r *parseResult) getExtensionRangeNode(e *dpb.DescriptorProto_ExtensionRange) ast.RangeDeclNode {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(r.fd.GetName())}
+		return ast.NewNoSourceNode(r.fd.GetName())
 	}
-	return r.nodes[e].(rangeDecl)
+	return r.nodes[e].(ast.RangeDeclNode)
 }
 
-func (r *parseResult) getMessageReservedRangeNode(rr *dpb.DescriptorProto_ReservedRange) rangeDecl {
+func (r *parseResult) getMessageReservedRangeNode(rr *dpb.DescriptorProto_ReservedRange) ast.RangeDeclNode {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(r.fd.GetName())}
+		return ast.NewNoSourceNode(r.fd.GetName())
 	}
-	return r.nodes[rr].(rangeDecl)
+	return r.nodes[rr].(ast.RangeDeclNode)
 }
 
-func (r *parseResult) getEnumNode(e *dpb.EnumDescriptorProto) node {
+func (r *parseResult) getEnumNode(e *dpb.EnumDescriptorProto) ast.Node {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(r.fd.GetName())}
+		return ast.NewNoSourceNode(r.fd.GetName())
 	}
 	return r.nodes[e]
 }
 
-func (r *parseResult) getEnumValueNode(e *dpb.EnumValueDescriptorProto) enumValueDecl {
+func (r *parseResult) getEnumValueNode(e *dpb.EnumValueDescriptorProto) ast.EnumValueDeclNode {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(r.fd.GetName())}
+		return ast.NewNoSourceNode(r.fd.GetName())
 	}
-	return r.nodes[e].(enumValueDecl)
+	return r.nodes[e].(ast.EnumValueDeclNode)
 }
 
-func (r *parseResult) getEnumReservedRangeNode(rr *dpb.EnumDescriptorProto_EnumReservedRange) rangeDecl {
+func (r *parseResult) getEnumReservedRangeNode(rr *dpb.EnumDescriptorProto_EnumReservedRange) ast.RangeDeclNode {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(r.fd.GetName())}
+		return ast.NewNoSourceNode(r.fd.GetName())
 	}
-	return r.nodes[rr].(rangeDecl)
+	return r.nodes[rr].(ast.RangeDeclNode)
 }
 
-func (r *parseResult) getMethodNode(m *dpb.MethodDescriptorProto) methodDecl {
+func (r *parseResult) getMethodNode(m *dpb.MethodDescriptorProto) ast.RPCDeclNode {
 	if r.nodes == nil {
-		return noSourceNode{pos: unknownPos(r.fd.GetName())}
+		return ast.NewNoSourceNode(r.fd.GetName())
 	}
-	return r.nodes[m].(methodDecl)
+	return r.nodes[m].(ast.RPCDeclNode)
 }
 
-func (r *parseResult) putFileNode(f *dpb.FileDescriptorProto, n *fileNode) {
+func (r *parseResult) putFileNode(f *dpb.FileDescriptorProto, n *ast.FileNode) {
 	r.nodes[f] = n
 }
 
-func (r *parseResult) putOptionNode(o *dpb.UninterpretedOption, n *optionNode) {
+func (r *parseResult) putOptionNode(o *dpb.UninterpretedOption, n *ast.OptionNode) {
 	r.nodes[o] = n
 }
 
-func (r *parseResult) putOptionNamePartNode(o *dpb.UninterpretedOption_NamePart, n *optionNamePartNode) {
+func (r *parseResult) putOptionNamePartNode(o *dpb.UninterpretedOption_NamePart, n *ast.FieldReferenceNode) {
 	r.nodes[o] = n
 }
 
-func (r *parseResult) putMessageNode(m *dpb.DescriptorProto, n msgDecl) {
+func (r *parseResult) putMessageNode(m *dpb.DescriptorProto, n ast.MessageDeclNode) {
 	r.nodes[m] = n
 }
 
-func (r *parseResult) putFieldNode(f *dpb.FieldDescriptorProto, n fieldDecl) {
+func (r *parseResult) putFieldNode(f *dpb.FieldDescriptorProto, n ast.FieldDeclNode) {
 	r.nodes[f] = n
 }
 
-func (r *parseResult) putOneOfNode(o *dpb.OneofDescriptorProto, n *oneOfNode) {
+func (r *parseResult) putOneOfNode(o *dpb.OneofDescriptorProto, n *ast.OneOfNode) {
 	r.nodes[o] = n
 }
 
-func (r *parseResult) putExtensionRangeNode(e *dpb.DescriptorProto_ExtensionRange, n *rangeNode) {
+func (r *parseResult) putExtensionRangeNode(e *dpb.DescriptorProto_ExtensionRange, n *ast.RangeNode) {
 	r.nodes[e] = n
 }
 
-func (r *parseResult) putMessageReservedRangeNode(rr *dpb.DescriptorProto_ReservedRange, n *rangeNode) {
+func (r *parseResult) putMessageReservedRangeNode(rr *dpb.DescriptorProto_ReservedRange, n *ast.RangeNode) {
 	r.nodes[rr] = n
 }
 
-func (r *parseResult) putEnumNode(e *dpb.EnumDescriptorProto, n *enumNode) {
+func (r *parseResult) putEnumNode(e *dpb.EnumDescriptorProto, n *ast.EnumNode) {
 	r.nodes[e] = n
 }
 
-func (r *parseResult) putEnumValueNode(e *dpb.EnumValueDescriptorProto, n *enumValueNode) {
+func (r *parseResult) putEnumValueNode(e *dpb.EnumValueDescriptorProto, n *ast.EnumValueNode) {
 	r.nodes[e] = n
 }
 
-func (r *parseResult) putEnumReservedRangeNode(rr *dpb.EnumDescriptorProto_EnumReservedRange, n *rangeNode) {
+func (r *parseResult) putEnumReservedRangeNode(rr *dpb.EnumDescriptorProto_EnumReservedRange, n *ast.RangeNode) {
 	r.nodes[rr] = n
 }
 
-func (r *parseResult) putServiceNode(s *dpb.ServiceDescriptorProto, n *serviceNode) {
+func (r *parseResult) putServiceNode(s *dpb.ServiceDescriptorProto, n *ast.ServiceNode) {
 	r.nodes[s] = n
 }
 
-func (r *parseResult) putMethodNode(m *dpb.MethodDescriptorProto, n *methodNode) {
+func (r *parseResult) putMethodNode(m *dpb.MethodDescriptorProto, n *ast.RPCNode) {
 	r.nodes[m] = n
 }
 
-func parseProto(filename string, r io.Reader, errs *errorHandler, validate bool) *parseResult {
+func parseProto(filename string, r io.Reader, errs *errorHandler, validate, createProtos bool) *parseResult {
 	beforeErrs := errs.errsReported
 	lx := newLexer(r, filename, errs)
 	protoParse(lx)
-
-	res := createParseResult(filename, lx.res, errs)
+	if lx.res == nil || len(lx.res.Children()) == 0 {
+		// nil AST means there was an error that prevented any parsing
+		// or the file was empty; synthesize empty non-nil AST
+		lx.res = ast.NewEmptyFileNode(filename)
+	}
+	if lx.eof != nil {
+		lx.res.FinalComments = lx.eof.LeadingComments()
+		lx.res.FinalWhitespace = lx.eof.LeadingWhitespace()
+	}
+	res := createParseResult(filename, lx.res, errs, createProtos)
 	if validate && errs.err == nil {
 		validateBasic(res, errs.errsReported > beforeErrs)
 	}
@@ -674,35 +774,19 @@ func parseProto(filename string, r io.Reader, errs *errorHandler, validate bool)
 	return res
 }
 
-func createParseResult(filename string, file *fileNode, errs *errorHandler) *parseResult {
+func createParseResult(filename string, file *ast.FileNode, errs *errorHandler, createProtos bool) *parseResult {
 	res := &parseResult{
 		errs:               errs,
-		nodes:              map[proto.Message]node{},
-		interpretedOptions: map[*optionNode][]int32{},
+		root:               file,
+		nodes:              map[proto.Message]ast.Node{},
+		interpretedOptions: map[*ast.OptionNode][]int32{},
 	}
-	if file == nil {
-		// nil AST means there was an error that prevented any parsing
-		// or the file was empty; synthesize empty non-nil AST
-		file = &fileNode{}
-		n := noSourceNode{pos: unknownPos(filename)}
-		file.setRange(&n, &n)
+	if createProtos {
+		res.createFileDescriptor(filename, file)
 	}
-	res.createFileDescriptor(filename, file)
 	return res
 }
 
-func toNameParts(ident *compoundIdentNode) []*optionNamePartNode {
-	parts := strings.Split(ident.val, ".")
-	ret := make([]*optionNamePartNode, len(parts))
-	offset := 0
-	for i, p := range parts {
-		ret[i] = &optionNamePartNode{text: ident, offset: offset, length: len(p)}
-		ret[i].setRange(ident, ident)
-		offset += len(p) + 1
-	}
-	return ret
-}
-
 func checkTag(pos *SourcePos, v uint64, maxTag int32) error {
 	if v < 1 {
 		return errorWithPos(pos, "tag number %d must be greater than zero", v)
@@ -714,59 +798,68 @@ func checkTag(pos *SourcePos, v uint64, maxTag int32) error {
 	return nil
 }
 
-func checkExtensionTagsInFile(fd *desc.FileDescriptor, res *parseResult) error {
+func checkExtensionsInFile(fd *desc.FileDescriptor, res *parseResult) error {
 	for _, fld := range fd.GetExtensions() {
-		if err := checkExtensionTag(fld, res); err != nil {
+		if err := checkExtension(fld, res); err != nil {
 			return err
 		}
 	}
 	for _, md := range fd.GetMessageTypes() {
-		if err := checkExtensionTagsInMessage(md, res); err != nil {
+		if err := checkExtensionsInMessage(md, res); err != nil {
 			return err
 		}
 	}
 	return nil
 }
 
-func checkExtensionTagsInMessage(md *desc.MessageDescriptor, res *parseResult) error {
+func checkExtensionsInMessage(md *desc.MessageDescriptor, res *parseResult) error {
 	for _, fld := range md.GetNestedExtensions() {
-		if err := checkExtensionTag(fld, res); err != nil {
+		if err := checkExtension(fld, res); err != nil {
 			return err
 		}
 	}
 	for _, nmd := range md.GetNestedMessageTypes() {
-		if err := checkExtensionTagsInMessage(nmd, res); err != nil {
+		if err := checkExtensionsInMessage(nmd, res); err != nil {
 			return err
 		}
 	}
 	return nil
 }
 
-func checkExtensionTag(fld *desc.FieldDescriptor, res *parseResult) error {
-	// NB: This is kind of gross that we don't enforce this in validateBasic(). But it would
-	// require doing some minimal linking there (to identify the extendee and locate its
-	// descriptor). To keep the code simpler, we just wait until things are fully linked.
-
-	// In validateBasic() we just made sure these were within bounds for any message. But
-	// now that things are linked, we can check if the extendee is messageset wire format
-	// and, if not, enforce tighter limit.
-	if !fld.GetOwner().GetMessageOptions().GetMessageSetWireFormat() && fld.GetNumber() > internal.MaxNormalTag {
-		pos := res.nodes[fld.AsFieldDescriptorProto()].(fieldDecl).fieldTag().start()
-		return errorWithPos(pos, "tag number %d is higher than max allowed tag number (%d)", fld.GetNumber(), internal.MaxNormalTag)
+func checkExtension(fld *desc.FieldDescriptor, res *parseResult) error {
+	// NB: It's a little gross that we don't enforce these in validateBasic().
+	// But requires some minimal linking to resolve the extendee, so we can
+	// interrogate its descriptor.
+	if fld.GetOwner().GetMessageOptions().GetMessageSetWireFormat() {
+		// Message set wire format requires that all extensions be messages
+		// themselves (no scalar extensions)
+		if fld.GetType() != dpb.FieldDescriptorProto_TYPE_MESSAGE {
+			pos := res.getFieldNode(fld.AsFieldDescriptorProto()).FieldType().Start()
+			return errorWithPos(pos, "messages with message-set wire format cannot contain scalar extensions, only messages")
+		}
+	} else {
+		// In validateBasic() we just made sure these were within bounds for any message. But
+		// now that things are linked, we can check if the extendee is messageset wire format
+		// and, if not, enforce tighter limit.
+		if fld.GetNumber() > internal.MaxNormalTag {
+			pos := res.getFieldNode(fld.AsFieldDescriptorProto()).FieldTag().Start()
+			return errorWithPos(pos, "tag number %d is higher than max allowed tag number (%d)", fld.GetNumber(), internal.MaxNormalTag)
+		}
 	}
+
 	return nil
 }
 
-func aggToString(agg []*aggregateEntryNode, buf *bytes.Buffer) {
+func aggToString(agg []*ast.MessageFieldNode, buf *bytes.Buffer) {
 	buf.WriteString("{")
 	for _, a := range agg {
 		buf.WriteString(" ")
-		buf.WriteString(a.name.value())
-		if v, ok := a.val.(*aggregateLiteralNode); ok {
-			aggToString(v.elements, buf)
+		buf.WriteString(a.Name.Value())
+		if v, ok := a.Val.(*ast.MessageLiteralNode); ok {
+			aggToString(v.Elements, buf)
 		} else {
 			buf.WriteString(": ")
-			elementToString(a.val.value(), buf)
+			elementToString(a.Val.Value(), buf)
 		}
 	}
 	buf.WriteString(" }")
@@ -774,7 +867,7 @@ func aggToString(agg []*aggregateEntryNode, buf *bytes.Buffer) {
 
 func elementToString(v interface{}, buf *bytes.Buffer) {
 	switch v := v.(type) {
-	case bool, int64, uint64, identifier:
+	case bool, int64, uint64, ast.Identifier:
 		_, _ = fmt.Fprintf(buf, "%v", v)
 	case float64:
 		if math.IsInf(v, 1) {
@@ -790,7 +883,7 @@ func elementToString(v interface{}, buf *bytes.Buffer) {
 		buf.WriteRune('"')
 		writeEscapedBytes(buf, []byte(v))
 		buf.WriteRune('"')
-	case []valueNode:
+	case []ast.ValueNode:
 		buf.WriteString(": [")
 		first := true
 		for _, e := range v {
@@ -799,10 +892,10 @@ func elementToString(v interface{}, buf *bytes.Buffer) {
 			} else {
 				buf.WriteString(", ")
 			}
-			elementToString(e.value(), buf)
+			elementToString(e.Value(), buf)
 		}
 		buf.WriteString("]")
-	case []*aggregateEntryNode:
+	case []*ast.MessageFieldNode:
 		aggToString(v, buf)
 	}
 }
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/proto.y b/vendor/github.com/jhump/protoreflect/desc/protoparse/proto.y
index b7320707b..63b32d9d6 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/proto.y
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/proto.y
@@ -4,8 +4,9 @@ package protoparse
 //lint:file-ignore SA4006 generated parser has unused values
 
 import (
-	"fmt"
 	"math"
+
+	"github.com/jhump/protoreflect/desc/protoparse/ast"
 )
 
 %}
@@ -13,47 +14,60 @@ import (
 // fields inside this union end up as the fields in a structure known
 // as ${PREFIX}SymType, of which a reference is passed to the lexer.
 %union{
-	file      *fileNode
-	fileDecls []*fileElement
-	syn       *syntaxNode
-	pkg       *packageNode
-	imprt     *importNode
-	msg       *messageNode
-	msgDecls  []*messageElement
-	fld       *fieldNode
-	mapFld    *mapFieldNode
-	mapType   *mapTypeNode
-	grp       *groupNode
-	oo        *oneOfNode
-	ooDecls   []*oneOfElement
-	ext       *extensionRangeNode
-	resvd     *reservedNode
-	en        *enumNode
-	enDecls   []*enumElement
-	env       *enumValueNode
-	extend    *extendNode
-	extDecls  []*extendElement
-	svc       *serviceNode
-	svcDecls  []*serviceElement
-	mtd       *methodNode
-	rpcType   *rpcTypeNode
-	opts      []*optionNode
-	optNm     []*optionNamePartNode
-	cmpctOpts *compactOptionsNode
-	rngs      []*rangeNode
-	names     []*compoundStringNode
-	cid       *compoundIdentNode
-	sl        []valueNode
-	agg       []*aggregateEntryNode
-	aggName   *aggregateNameNode
-	v         valueNode
-	il        *compoundIntNode
-	str       *compoundStringNode
-	s         *stringLiteralNode
-	i         *intLiteralNode
-	f         *floatLiteralNode
-	id        *identNode
-	b         *basicNode
+	file      *ast.FileNode
+	syn       *ast.SyntaxNode
+	fileDecl  ast.FileElement
+	fileDecls []ast.FileElement
+	pkg       *ast.PackageNode
+	imprt     *ast.ImportNode
+	msg       *ast.MessageNode
+	msgDecl   ast.MessageElement
+	msgDecls  []ast.MessageElement
+	fld       *ast.FieldNode
+	mapFld    *ast.MapFieldNode
+	mapType   *ast.MapTypeNode
+	grp       *ast.GroupNode
+	oo        *ast.OneOfNode
+	ooDecl    ast.OneOfElement
+	ooDecls   []ast.OneOfElement
+	ext       *ast.ExtensionRangeNode
+	resvd     *ast.ReservedNode
+	en        *ast.EnumNode
+	enDecl    ast.EnumElement
+	enDecls   []ast.EnumElement
+	env       *ast.EnumValueNode
+	extend    *ast.ExtendNode
+	extDecl   ast.ExtendElement
+	extDecls  []ast.ExtendElement
+	svc       *ast.ServiceNode
+	svcDecl   ast.ServiceElement
+	svcDecls  []ast.ServiceElement
+	mtd       *ast.RPCNode
+	rpcType   *ast.RPCTypeNode
+	rpcDecl   ast.RPCElement
+	rpcDecls  []ast.RPCElement
+	opt       *ast.OptionNode
+	opts      *compactOptionList
+	ref       *ast.FieldReferenceNode
+	optNms    *fieldRefList
+	cmpctOpts *ast.CompactOptionsNode
+	rng       *ast.RangeNode
+	rngs      *rangeList
+	names     *nameList
+	cid       *identList
+	tid       ast.IdentValueNode
+	sl        *valueList
+	msgField  *ast.MessageFieldNode
+	msgEntry  *messageFieldEntry
+	msgLit    *messageFieldList
+	v         ast.ValueNode
+	il        ast.IntValueNode
+	str       *stringList
+	s         *ast.StringLiteralNode
+	i         *ast.UintLiteralNode
+	f         *ast.FloatLiteralNode
+	id        *ast.IdentNode
+	b         *ast.RuneNode
 	err       error
 }
 
@@ -61,45 +75,58 @@ import (
 // really a field name in the above union struct
 %type <file>      file
 %type <syn>       syntax
-%type <fileDecls> fileDecl fileDecls
+%type <fileDecl>  fileDecl
+%type <fileDecls> fileDecls
 %type <imprt>     import
 %type <pkg>       package
-%type <opts>      option compactOption compactOptionDecls rpcOption rpcOptions
-%type <optNm>     optionName optionNameComponent
+%type <opt>       option compactOption
+%type <opts>      compactOptionDecls
+%type <rpcDecl>   rpcDecl
+%type <rpcDecls>  rpcDecls
+%type <ref>       optionNameComponent aggName
+%type <optNms>    optionName
 %type <cmpctOpts> compactOptions
 %type <v>         constant scalarConstant aggregate numLit
 %type <il>        intLit
-%type <id>        name keyType
-%type <cid>       ident typeIdent
-%type <aggName>   aggName
+%type <id>        name keyType msgElementName extElementName oneofElementName enumElementName
+%type <cid>       ident msgElementIdent extElementIdent oneofElementIdent
+%type <tid>       typeIdent msgElementTypeIdent extElementTypeIdent oneofElementTypeIdent
 %type <sl>        constantList
-%type <agg>       aggFields aggField aggFieldEntry
-%type <fld>       field oneofField
+%type <msgField>  aggFieldEntry
+%type <msgEntry>  aggField
+%type <msgLit>    aggFields
+%type <fld>       oneofField msgField extField
 %type <oo>        oneof
 %type <grp>       group oneofGroup
 %type <mapFld>    mapField
 %type <mapType>   mapType
 %type <msg>       message
-%type <msgDecls>  messageItem messageBody
-%type <ooDecls>   oneofItem oneofBody
+%type <msgDecl>   messageDecl
+%type <msgDecls>  messageDecls
+%type <ooDecl>    ooDecl
+%type <ooDecls>   ooDecls
 %type <names>     fieldNames
 %type <resvd>     msgReserved enumReserved reservedNames
-%type <rngs>      tagRange tagRanges enumRange enumRanges
+%type <rng>       tagRange enumRange
+%type <rngs>      tagRanges enumRanges
 %type <ext>       extensions
 %type <en>        enum
-%type <enDecls>   enumItem enumBody
-%type <env>       enumField
+%type <enDecl>    enumDecl
+%type <enDecls>   enumDecls
+%type <env>       enumValue
 %type <extend>    extend
-%type <extDecls>  extendItem extendBody
+%type <extDecl>   extendDecl
+%type <extDecls>  extendDecls
 %type <str>       stringLit
 %type <svc>       service
-%type <svcDecls>  serviceItem serviceBody
+%type <svcDecl>   serviceDecl
+%type <svcDecls>  serviceDecls
 %type <mtd>       rpc
 %type <rpcType>   rpcType
 
 // same for terminals
-%token <s> _STRING_LIT
-%token <i>  _INT_LIT
+%token <s>   _STRING_LIT
+%token <i>   _INT_LIT
 %token <f>   _FLOAT_LIT
 %token <id>  _NAME
 %token <id>  _SYNTAX _IMPORT _WEAK _PUBLIC _PACKAGE _OPTION _TRUE _FALSE _INF _NAN _REPEATED _OPTIONAL _REQUIRED
@@ -114,478 +141,525 @@ import (
 %%
 
 file : syntax {
-		$$ = &fileNode{syntax: $1}
-		$$.setRange($1, $1)
+		$$ = ast.NewFileNode($1, nil)
 		protolex.(*protoLex).res = $$
 	}
 	| fileDecls  {
-		$$ = &fileNode{decls: $1}
-		if len($1) > 0 {
-			$$.setRange($1[0], $1[len($1)-1])
-		}
+		$$ = ast.NewFileNode(nil, $1)
 		protolex.(*protoLex).res = $$
 	}
 	| syntax fileDecls {
-		$$ = &fileNode{syntax: $1, decls: $2}
-		var end node
-		if len($2) > 0 {
-			end = $2[len($2)-1]
-		} else {
-			end = $1
-		}
-		$$.setRange($1, end)
+		$$ = ast.NewFileNode($1, $2)
 		protolex.(*protoLex).res = $$
 	}
 	| {
 	}
 
 fileDecls : fileDecls fileDecl {
-		$$ = append($1, $2...)
+		if $2 != nil {
+			$$ = append($1, $2)
+		} else {
+			$$ = $1
+		}
+	}
+	| fileDecl {
+		if $1 != nil {
+			$$ = []ast.FileElement{$1}
+		} else {
+			$$ = nil
+		}
 	}
-	| fileDecl
 
 fileDecl : import {
-		$$ = []*fileElement{{imp: $1}}
+		$$ = $1
 	}
 	| package {
-		$$ = []*fileElement{{pkg: $1}}
+		$$ = $1
 	}
 	| option {
-		$$ = []*fileElement{{option: $1[0]}}
+		$$ = $1
 	}
 	| message {
-		$$ = []*fileElement{{message: $1}}
+		$$ = $1
 	}
 	| enum {
-		$$ = []*fileElement{{enum: $1}}
+		$$ = $1
 	}
 	| extend {
-		$$ = []*fileElement{{extend: $1}}
+		$$ = $1
 	}
 	| service {
-		$$ = []*fileElement{{service: $1}}
+		$$ = $1
 	}
 	| ';' {
-		$$ = []*fileElement{{empty: $1}}
+		$$ = ast.NewEmptyDeclNode($1)
 	}
 	| error ';' {
+		$$ = nil
 	}
 	| error {
+		$$ = nil
 	}
 
 syntax : _SYNTAX '=' stringLit ';' {
-		$$ = &syntaxNode{syntax: $3}
-		$$.setRange($1, $4)
+		$$ = ast.NewSyntaxNode($1.ToKeyword(), $2, $3.toStringValueNode(), $4)
 	}
 
 import : _IMPORT stringLit ';' {
-		$$ = &importNode{ name: $2 }
-		$$.setRange($1, $3)
+		$$ = ast.NewImportNode($1.ToKeyword(), nil, nil, $2.toStringValueNode(), $3)
 	}
 	| _IMPORT _WEAK stringLit ';' {
-		$$ = &importNode{ name: $3, weak: true }
-		$$.setRange($1, $4)
+		$$ = ast.NewImportNode($1.ToKeyword(), nil, $2.ToKeyword(), $3.toStringValueNode(), $4)
 	}
 	| _IMPORT _PUBLIC stringLit ';' {
-		$$ = &importNode{ name: $3, public: true }
-		$$.setRange($1, $4)
+		$$ = ast.NewImportNode($1.ToKeyword(), $2.ToKeyword(), nil, $3.toStringValueNode(), $4)
 	}
 
 package : _PACKAGE ident ';' {
-		$$ = &packageNode{name: $2}
-		$$.setRange($1, $3)
+		$$ = ast.NewPackageNode($1.ToKeyword(), $2.toIdentValueNode(nil), $3)
 	}
 
 ident : name {
-        $$ = &compoundIdentNode{val: $1.val}
-        $$.setRange($1, $1)
-    }
-	| ident '.' name {
-        $$ = &compoundIdentNode{val: $1.val + "." + $3.val}
-        $$.setRange($1, $3)
+		$$ = &identList{$1, nil, nil}
+	}
+	| name '.' ident {
+		$$ = &identList{$1, $2, $3}
 	}
 
-option : _OPTION optionName '=' constant ';' {
-		n := &optionNameNode{parts: $2}
-		n.setRange($2[0], $2[len($2)-1])
-		o := &optionNode{name: n, val: $4}
-		o.setRange($1, $5)
-		$$ = []*optionNode{o}
+// to mimic limitations of protoc recursive-descent parser,
+// we don't allowed message statement keywords as identifiers
+// (or oneof statement keywords [e.g. "option"] below)
+
+msgElementIdent : msgElementName {
+		$$ = &identList{$1, nil, nil}
+	}
+	| msgElementName '.' ident {
+		$$ = &identList{$1, $2, $3}
 	}
 
-optionName : optionNameComponent
-    |
-    optionName '.' optionNameComponent {
-		$$ = append($1, $3...)
+extElementIdent : extElementName {
+		$$ = &identList{$1, nil, nil}
+	}
+	| extElementName '.' ident {
+		$$ = &identList{$1, $2, $3}
 	}
 
+oneofElementIdent : oneofElementName {
+		$$ = &identList{$1, nil, nil}
+	}
+	| oneofElementName '.' ident {
+		$$ = &identList{$1, $2, $3}
+	}
+
+option : _OPTION optionName '=' constant ';' {
+		refs, dots := $2.toNodes()
+		optName := ast.NewOptionNameNode(refs, dots)
+		$$ = ast.NewOptionNode($1.ToKeyword(), optName, $3, $4, $5)
+	}
+
+optionName : optionNameComponent {
+		$$ = &fieldRefList{$1, nil, nil}
+	}
+	| optionNameComponent '.' optionName {
+		$$ = &fieldRefList{$1, $2, $3}
+	}
 
 optionNameComponent : name {
-        nm := &compoundIdentNode{val: $1.val}
-        nm.setRange($1, $1)
-		$$ = toNameParts(nm)
+		$$ = ast.NewFieldReferenceNode($1)
 	}
 	| '(' typeIdent ')' {
-		p := &optionNamePartNode{text: $2, isExtension: true}
-		p.setRange($1, $3)
-		$$ = []*optionNamePartNode{p}
+		$$ = ast.NewExtensionFieldReferenceNode($1, $2, $3)
 	}
 
 constant : scalarConstant
 	| aggregate
 
 scalarConstant : stringLit {
-		$$ = $1
+		$$ = $1.toStringValueNode()
 	}
 	| numLit
 	| name {
-		if $1.val == "true" {
-			$$ = &boolLiteralNode{identNode: $1, val: true}
-		} else if $1.val == "false" {
-			$$ = &boolLiteralNode{identNode: $1, val: false}
-		} else if $1.val == "inf" {
-			f := &compoundFloatNode{val: math.Inf(1)}
-			f.setRange($1, $1)
-			$$ = f
-		} else if $1.val == "nan" {
-			f := &compoundFloatNode{val: math.NaN()}
-			f.setRange($1, $1)
-			$$ = f
+		if $1.Val == "true" || $1.Val == "false" {
+			$$ = ast.NewBoolLiteralNode($1.ToKeyword())
+		} else if $1.Val == "inf" || $1.Val == "nan" {
+			$$ = ast.NewSpecialFloatLiteralNode($1.ToKeyword())
 		} else {
 			$$ = $1
 		}
 	}
 
 numLit : _FLOAT_LIT {
-        $$ = $1
-    }
+		$$ = $1
+	}
 	| '-' _FLOAT_LIT {
-		f := &compoundFloatNode{val: -$2.val}
-		f.setRange($1, $2)
-		$$ = f
+		$$ = ast.NewSignedFloatLiteralNode($1, $2)
 	}
 	| '+' _FLOAT_LIT {
-		f := &compoundFloatNode{val: $2.val}
-		f.setRange($1, $2)
-		$$ = f
+		$$ = ast.NewSignedFloatLiteralNode($1, $2)
 	}
 	| '+' _INF {
-		f := &compoundFloatNode{val: math.Inf(1)}
-		f.setRange($1, $2)
-		$$ = f
+		f := ast.NewSpecialFloatLiteralNode($2.ToKeyword())
+		$$ = ast.NewSignedFloatLiteralNode($1, f)
 	}
 	| '-' _INF {
-		f := &compoundFloatNode{val: math.Inf(-1)}
-		f.setRange($1, $2)
-		$$ = f
+		f := ast.NewSpecialFloatLiteralNode($2.ToKeyword())
+		$$ = ast.NewSignedFloatLiteralNode($1, f)
 	}
 	| _INT_LIT {
-        $$ = $1
-    }
-    | '+' _INT_LIT {
-          i := &compoundUintNode{val: $2.val}
-          i.setRange($1, $2)
-          $$ = i
-    }
-    | '-' _INT_LIT {
-        if $2.val > math.MaxInt64 + 1 {
-            // can't represent as int so treat as float literal
-            f := &compoundFloatNode{val: -float64($2.val)}
-            f.setRange($1, $2)
-            $$ = f
-        } else {
-            i := &compoundIntNode{val: -int64($2.val)}
-            i.setRange($1, $2)
-            $$ = i
-        }
-    }
+		$$ = $1
+	}
+	| '+' _INT_LIT {
+		$$ = ast.NewPositiveUintLiteralNode($1, $2)
+	}
+	| '-' _INT_LIT {
+		if $2.Val > math.MaxInt64 + 1 {
+			// can't represent as int so treat as float literal
+			$$ = ast.NewSignedFloatLiteralNode($1, $2)
+		} else {
+			$$ = ast.NewNegativeIntLiteralNode($1, $2)
+		}
+	}
 
 stringLit : _STRING_LIT {
-        $$ = &compoundStringNode{val: $1.val}
-        $$.setRange($1, $1)
-    }
-    | stringLit _STRING_LIT {
-        $$ = &compoundStringNode{val: $1.val + $2.val}
-        $$.setRange($1, $2)
-    }
+		$$ = &stringList{$1, nil}
+	}
+	| _STRING_LIT stringLit  {
+		$$ = &stringList{$1, $2}
+	}
 
 aggregate : '{' aggFields '}' {
-		a := &aggregateLiteralNode{elements: $2}
-		a.setRange($1, $3)
-		$$ = a
+		fields, delims := $2.toNodes()
+		$$ = ast.NewMessageLiteralNode($1, fields, delims, $3)
 	}
 
-aggFields : aggField
-	| aggFields aggField {
-		$$ = append($1, $2...)
+aggFields : aggField {
+		if $1 != nil {
+			$$ = &messageFieldList{$1, nil}
+		} else {
+			$$ = nil
+		}
+	}
+	| aggField aggFields {
+		if $1 != nil {
+			$$ = &messageFieldList{$1, $2}
+		} else {
+			$$ = $2
+		}
 	}
 	| {
 		$$ = nil
 	}
 
-aggField : aggFieldEntry
+aggField : aggFieldEntry {
+		if $1 != nil {
+			$$ = &messageFieldEntry{$1, nil}
+		} else {
+			$$ = nil
+		}
+	}
 	| aggFieldEntry ',' {
-		$$ = $1
+		if $1 != nil {
+			$$ = &messageFieldEntry{$1, $2}
+		} else {
+			$$ = nil
+		}
 	}
 	| aggFieldEntry ';' {
-		$$ = $1
+		if $1 != nil {
+			$$ = &messageFieldEntry{$1, $2}
+		} else {
+			$$ = nil
+		}
 	}
 	| error ',' {
+		$$ = nil
 	}
 	| error ';' {
+		$$ = nil
 	}
 	| error {
+		$$ = nil
 	}
 
 aggFieldEntry : aggName ':' scalarConstant {
-		a := &aggregateEntryNode{name: $1, val: $3}
-		a.setRange($1, $3)
-		$$ = []*aggregateEntryNode{a}
+		if $1 != nil {
+			$$ = ast.NewMessageFieldNode($1, $2, $3)
+		} else {
+			$$ = nil
+		}
 	}
 	| aggName ':' '[' ']' {
-		s := &sliceLiteralNode{}
-		s.setRange($3, $4)
-		a := &aggregateEntryNode{name: $1, val: s}
-		a.setRange($1, $4)
-		$$ = []*aggregateEntryNode{a}
+		if $1 != nil {
+			val := ast.NewArrayLiteralNode($3, nil, nil, $4)
+			$$ = ast.NewMessageFieldNode($1, $2, val)
+		} else {
+			$$ = nil
+		}
 	}
 	| aggName ':' '[' constantList ']' {
-		s := &sliceLiteralNode{elements: $4}
-		s.setRange($3, $5)
-		a := &aggregateEntryNode{name: $1, val: s}
-		a.setRange($1, $5)
-		$$ = []*aggregateEntryNode{a}
+		if $1 != nil {
+			vals, commas := $4.toNodes()
+			val := ast.NewArrayLiteralNode($3, vals, commas, $5)
+			$$ = ast.NewMessageFieldNode($1, $2, val)
+		} else {
+			$$ = nil
+		}
 	}
 	| aggName ':' '[' error ']' {
+		$$ = nil
 	}
 	| aggName ':' aggregate {
-		a := &aggregateEntryNode{name: $1, val: $3}
-		a.setRange($1, $3)
-		$$ = []*aggregateEntryNode{a}
+		if $1 != nil {
+			$$ = ast.NewMessageFieldNode($1, $2, $3)
+		} else {
+			$$ = nil
+		}
 	}
 	| aggName aggregate {
-		a := &aggregateEntryNode{name: $1, val: $2}
-		a.setRange($1, $2)
-		$$ = []*aggregateEntryNode{a}
+		if $1 != nil {
+			$$ = ast.NewMessageFieldNode($1, nil, $2)
+		} else {
+			$$ = nil
+		}
 	}
 	| aggName ':' '<' aggFields '>' {
-		s := &aggregateLiteralNode{elements: $4}
-		s.setRange($3, $5)
-		a := &aggregateEntryNode{name: $1, val: s}
-		a.setRange($1, $5)
-		$$ = []*aggregateEntryNode{a}
+		if $1 != nil {
+			fields, delims := $4.toNodes()
+			msg := ast.NewMessageLiteralNode($3, fields, delims, $5)
+			$$ = ast.NewMessageFieldNode($1, $2, msg)
+		} else {
+			$$ = nil
+		}
 	}
 	| aggName '<' aggFields '>' {
-		s := &aggregateLiteralNode{elements: $3}
-		s.setRange($2, $4)
-		a := &aggregateEntryNode{name: $1, val: s}
-		a.setRange($1, $4)
-		$$ = []*aggregateEntryNode{a}
+		if $1 != nil {
+			fields, delims := $3.toNodes()
+			msg := ast.NewMessageLiteralNode($2, fields, delims, $4)
+			$$ = ast.NewMessageFieldNode($1, nil, msg)
+		} else {
+			$$ = nil
+		}
 	}
 	| aggName ':' '<' error '>' {
+		$$ = nil
 	}
 	| aggName '<' error '>' {
+		$$ = nil
 	}
 
 aggName : name {
-        n := &compoundIdentNode{val: $1.val}
-        n.setRange($1, $1)
-		$$ = &aggregateNameNode{name: n}
-		$$.setRange($1, $1)
+		$$ = ast.NewFieldReferenceNode($1)
 	}
 	| '[' typeIdent ']' {
-		$$ = &aggregateNameNode{name: $2, isExtension: true}
-		$$.setRange($1, $3)
+		$$ = ast.NewExtensionFieldReferenceNode($1, $2, $3)
 	}
 	| '[' error ']' {
+		$$ = nil
 	}
 
 constantList : constant {
-		$$ = []valueNode{$1}
-	}
-	| constantList ',' constant {
-		$$ = append($1, $3)
+		$$ = &valueList{$1, nil, nil}
 	}
-	| constantList ';' constant {
-		$$ = append($1, $3)
+	| constant ',' constantList {
+		$$ = &valueList{$1, $2, $3}
 	}
 	| '<' aggFields '>' {
-		s := &aggregateLiteralNode{elements: $2}
-		s.setRange($1, $3)
-		$$ = []valueNode{s}
+		fields, delims := $2.toNodes()
+		msg := ast.NewMessageLiteralNode($1, fields, delims, $3)
+		$$ = &valueList{msg, nil, nil}
 	}
-	| constantList ','  '<' aggFields '>' {
-		s := &aggregateLiteralNode{elements: $4}
-		s.setRange($3, $5)
-		$$ = append($1, s)
-	}
-	| constantList ';'  '<' aggFields '>' {
-		s := &aggregateLiteralNode{elements: $4}
-		s.setRange($3, $5)
-		$$ = append($1, s)
+	| '<' aggFields '>' ',' constantList {
+		fields, delims := $2.toNodes()
+		msg := ast.NewMessageLiteralNode($1, fields, delims, $3)
+		$$ = &valueList{msg, $4, $5}
 	}
 	| '<' error '>' {
+		$$ = nil
 	}
-	| constantList ','  '<' error '>' {
+	| '<' error '>' ',' constantList {
+		$$ = $5
 	}
-	| constantList ';'  '<' error '>' {
+
+typeIdent : ident {
+		$$ = $1.toIdentValueNode(nil)
+	}
+	| '.' ident {
+		$$ = $2.toIdentValueNode($1)
 	}
 
-typeIdent : ident
-    | '.' ident {
-          $$ = &compoundIdentNode{val: "." + $2.val}
-          $$.setRange($1, $2)
-    }
+msgElementTypeIdent : msgElementIdent {
+		$$ = $1.toIdentValueNode(nil)
+	}
+	| '.' ident {
+		$$ = $2.toIdentValueNode($1)
+	}
+
+extElementTypeIdent : extElementIdent {
+		$$ = $1.toIdentValueNode(nil)
+	}
+	| '.' ident {
+		$$ = $2.toIdentValueNode($1)
+	}
 
-field : _REQUIRED typeIdent name '=' _INT_LIT ';' {
-		lbl := fieldLabel{identNode: $1, required: true}
-		$$ = &fieldNode{label: lbl, fldType: $2, name: $3, tag: $5}
-		$$.setRange($1, $6)
+oneofElementTypeIdent : oneofElementIdent {
+		$$ = $1.toIdentValueNode(nil)
+	}
+	| '.' ident {
+		$$ = $2.toIdentValueNode($1)
+	}
+
+msgField : _REQUIRED typeIdent name '=' _INT_LIT ';' {
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, nil, $6)
 	}
 	| _OPTIONAL typeIdent name '=' _INT_LIT ';' {
-		lbl := fieldLabel{identNode: $1}
-		$$ = &fieldNode{label: lbl, fldType: $2, name: $3, tag: $5}
-		$$.setRange($1, $6)
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, nil, $6)
 	}
 	| _REPEATED typeIdent name '=' _INT_LIT ';' {
-		lbl := fieldLabel{identNode: $1, repeated: true}
-		$$ = &fieldNode{label: lbl, fldType: $2, name: $3, tag: $5}
-		$$.setRange($1, $6)
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, nil, $6)
 	}
-	| typeIdent name '=' _INT_LIT ';' {
-		$$ = &fieldNode{fldType: $1, name: $2, tag: $4}
-		$$.setRange($1, $5)
+	| _REQUIRED typeIdent name '=' _INT_LIT compactOptions ';' {
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, $6, $7)
+	}
+	| _OPTIONAL typeIdent name '=' _INT_LIT compactOptions ';' {
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, $6, $7)
+	}
+	| _REPEATED typeIdent name '=' _INT_LIT compactOptions ';' {
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, $6, $7)
+	}
+	| msgElementTypeIdent name '=' _INT_LIT ';' {
+		$$ = ast.NewFieldNode(nil, $1, $2, $3, $4, nil, $5)
+	}
+	| msgElementTypeIdent name '=' _INT_LIT compactOptions ';' {
+		$$ = ast.NewFieldNode(nil, $1, $2, $3, $4, $5, $6)
+	}
+
+extField : _REQUIRED typeIdent name '=' _INT_LIT ';' {
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, nil, $6)
+	}
+	| _OPTIONAL typeIdent name '=' _INT_LIT ';' {
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, nil, $6)
+	}
+	| _REPEATED typeIdent name '=' _INT_LIT ';' {
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, nil, $6)
 	}
 	| _REQUIRED typeIdent name '=' _INT_LIT compactOptions ';' {
-		lbl := fieldLabel{identNode: $1, required: true}
-		$$ = &fieldNode{label: lbl, fldType: $2, name: $3, tag: $5, options: $6}
-		$$.setRange($1, $7)
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, $6, $7)
 	}
 	| _OPTIONAL typeIdent name '=' _INT_LIT compactOptions ';' {
-		lbl := fieldLabel{identNode: $1}
-		$$ = &fieldNode{label: lbl, fldType: $2, name: $3, tag: $5, options: $6}
-		$$.setRange($1, $7)
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, $6, $7)
 	}
 	| _REPEATED typeIdent name '=' _INT_LIT compactOptions ';' {
-		lbl := fieldLabel{identNode: $1, repeated: true}
-		$$ = &fieldNode{label: lbl, fldType: $2, name: $3, tag: $5, options: $6}
-		$$.setRange($1, $7)
+		$$ = ast.NewFieldNode($1.ToKeyword(), $2, $3, $4, $5, $6, $7)
+	}
+	| extElementTypeIdent name '=' _INT_LIT ';' {
+		$$ = ast.NewFieldNode(nil, $1, $2, $3, $4, nil, $5)
 	}
-	| typeIdent name '=' _INT_LIT compactOptions ';' {
-		$$ = &fieldNode{fldType: $1, name: $2, tag: $4, options: $5}
-		$$.setRange($1, $6)
+	| extElementTypeIdent name '=' _INT_LIT compactOptions ';' {
+		$$ = ast.NewFieldNode(nil, $1, $2, $3, $4, $5, $6)
 	}
 
 compactOptions: '[' compactOptionDecls ']' {
-        $$ = &compactOptionsNode{decls: $2}
-        $$.setRange($1, $3)
-    }
+		opts, commas := $2.toNodes()
+		$$ = ast.NewCompactOptionsNode($1, opts, commas, $3)
+	}
 
-compactOptionDecls : compactOptionDecls ',' compactOption {
-		$$ = append($1, $3...)
+compactOptionDecls : compactOption {
+		$$ = &compactOptionList{$1, nil, nil}
+	}
+	| compactOption ',' compactOptionDecls {
+		$$ = &compactOptionList{$1, $2, $3}
 	}
-	| compactOption
 
 compactOption: optionName '=' constant {
-		n := &optionNameNode{parts: $1}
-		n.setRange($1[0], $1[len($1)-1])
-		o := &optionNode{name: n, val: $3}
-		o.setRange($1[0], $3)
-		$$ = []*optionNode{o}
+		refs, dots := $1.toNodes()
+		optName := ast.NewOptionNameNode(refs, dots)
+		$$ = ast.NewCompactOptionNode(optName, $2, $3)
 	}
 
-group : _REQUIRED _GROUP name '=' _INT_LIT '{' messageBody '}' {
-		lbl := fieldLabel{identNode: $1, required: true}
-		$$ = &groupNode{groupKeyword: $2, label: lbl, name: $3, tag: $5, decls: $7}
-		$$.setRange($1, $8)
+group : _REQUIRED _GROUP name '=' _INT_LIT '{' messageDecls '}' {
+		$$ = ast.NewGroupNode($1.ToKeyword(), $2.ToKeyword(), $3, $4, $5, nil, $6, $7, $8)
 	}
-	| _OPTIONAL _GROUP name '=' _INT_LIT '{' messageBody '}' {
-		lbl := fieldLabel{identNode: $1}
-		$$ = &groupNode{groupKeyword: $2, label: lbl, name: $3, tag: $5, decls: $7}
-		$$.setRange($1, $8)
+	| _OPTIONAL _GROUP name '=' _INT_LIT '{' messageDecls '}' {
+		$$ = ast.NewGroupNode($1.ToKeyword(), $2.ToKeyword(), $3, $4, $5, nil, $6, $7, $8)
 	}
-	| _REPEATED _GROUP name '=' _INT_LIT '{' messageBody '}' {
-		lbl := fieldLabel{identNode: $1, repeated: true}
-		$$ = &groupNode{groupKeyword: $2, label: lbl, name: $3, tag: $5, decls: $7}
-		$$.setRange($1, $8)
+	| _REPEATED _GROUP name '=' _INT_LIT '{' messageDecls '}' {
+		$$ = ast.NewGroupNode($1.ToKeyword(), $2.ToKeyword(), $3, $4, $5, nil, $6, $7, $8)
 	}
-	| _REQUIRED _GROUP name '=' _INT_LIT compactOptions '{' messageBody '}' {
-		lbl := fieldLabel{identNode: $1, required: true}
-		$$ = &groupNode{groupKeyword: $2, label: lbl, name: $3, tag: $5, options: $6, decls: $8}
-		$$.setRange($1, $9)
+	| _REQUIRED _GROUP name '=' _INT_LIT compactOptions '{' messageDecls '}' {
+		$$ = ast.NewGroupNode($1.ToKeyword(), $2.ToKeyword(), $3, $4, $5, $6, $7, $8, $9)
 	}
-	| _OPTIONAL _GROUP name '=' _INT_LIT compactOptions '{' messageBody '}' {
-		lbl := fieldLabel{identNode: $1}
-		$$ = &groupNode{groupKeyword: $2, label: lbl, name: $3, tag: $5, options: $6, decls: $8}
-		$$.setRange($1, $9)
+	| _OPTIONAL _GROUP name '=' _INT_LIT compactOptions '{' messageDecls '}' {
+		$$ = ast.NewGroupNode($1.ToKeyword(), $2.ToKeyword(), $3, $4, $5, $6, $7, $8, $9)
 	}
-	| _REPEATED _GROUP name '=' _INT_LIT compactOptions '{' messageBody '}' {
-		lbl := fieldLabel{identNode: $1, repeated: true}
-		$$ = &groupNode{groupKeyword: $2, label: lbl, name: $3, tag: $5, options: $6, decls: $8}
-		$$.setRange($1, $9)
+	| _REPEATED _GROUP name '=' _INT_LIT compactOptions '{' messageDecls '}' {
+		$$ = ast.NewGroupNode($1.ToKeyword(), $2.ToKeyword(), $3, $4, $5, $6, $7, $8, $9)
 	}
 
-oneof : _ONEOF name '{' oneofBody '}' {
-		$$ = &oneOfNode{name: $2, decls: $4}
-		$$.setRange($1, $5)
+oneof : _ONEOF name '{' ooDecls '}' {
+		$$ = ast.NewOneOfNode($1.ToKeyword(), $2, $3, $4, $5)
 	}
 
-oneofBody : oneofBody oneofItem {
-		$$ = append($1, $2...)
+ooDecls : ooDecls ooDecl {
+		if $2 != nil {
+			$$ = append($1, $2)
+		} else {
+			$$ = $1
+		}
+	}
+	| ooDecl {
+		if $1 != nil {
+			$$ = []ast.OneOfElement{$1}
+		} else {
+			$$ = nil
+		}
 	}
-	| oneofItem
 	| {
 		$$ = nil
 	}
 
-oneofItem : option {
-		$$ = []*oneOfElement{{option: $1[0]}}
+ooDecl : option {
+		$$ = $1
 	}
 	| oneofField {
-		$$ = []*oneOfElement{{field: $1}}
+		$$ = $1
 	}
 	| oneofGroup {
-		$$ = []*oneOfElement{{group: $1}}
+		$$ = $1
 	}
 	| ';' {
-		$$ = []*oneOfElement{{empty: $1}}
+		$$ = ast.NewEmptyDeclNode($1)
 	}
 	| error ';' {
+		$$ = nil
 	}
 	| error {
+		$$ = nil
 	}
 
-oneofField : typeIdent name '=' _INT_LIT ';' {
-		$$ = &fieldNode{fldType: $1, name: $2, tag: $4}
-		$$.setRange($1, $5)
+oneofField : oneofElementTypeIdent name '=' _INT_LIT ';' {
+		$$ = ast.NewFieldNode(nil, $1, $2, $3, $4, nil, $5)
 	}
-	| typeIdent name '=' _INT_LIT compactOptions ';' {
-		$$ = &fieldNode{fldType: $1, name: $2, tag: $4, options: $5}
-		$$.setRange($1, $6)
+	| oneofElementTypeIdent name '=' _INT_LIT compactOptions ';' {
+		$$ = ast.NewFieldNode(nil, $1, $2, $3, $4, $5, $6)
 	}
 
-oneofGroup : _GROUP name '=' _INT_LIT '{' messageBody '}' {
-		$$ = &groupNode{groupKeyword: $1, name: $2, tag: $4, decls: $6}
-		$$.setRange($1, $7)
+oneofGroup : _GROUP name '=' _INT_LIT '{' messageDecls '}' {
+		$$ = ast.NewGroupNode(nil, $1.ToKeyword(), $2, $3, $4, nil, $5, $6, $7)
 	}
-	| _GROUP name '=' _INT_LIT compactOptions '{' messageBody '}' {
-		$$ = &groupNode{groupKeyword: $1, name: $2, tag: $4, options: $5, decls: $7}
-		$$.setRange($1, $8)
+	| _GROUP name '=' _INT_LIT compactOptions '{' messageDecls '}' {
+		$$ = ast.NewGroupNode(nil, $1.ToKeyword(), $2, $3, $4, $5, $6, $7, $8)
 	}
 
 mapField : mapType name '=' _INT_LIT ';' {
-		$$ = &mapFieldNode{mapType: $1, name: $2, tag: $4}
-		$$.setRange($1, $5)
+		$$ = ast.NewMapFieldNode($1, $2, $3, $4, nil, $5)
 	}
 	| mapType name '=' _INT_LIT compactOptions ';' {
-		$$ = &mapFieldNode{mapType: $1, name: $2, tag: $4, options: $5}
-		$$.setRange($1, $6)
+		$$ = ast.NewMapFieldNode($1, $2, $3, $4, $5, $6)
 	}
 
 mapType : _MAP '<' keyType ',' typeIdent '>' {
-        $$ = &mapTypeNode{mapKeyword: $1, keyType: $3, valueType: $5}
-        $$.setRange($1, $6)
-}
+		$$ = ast.NewMapTypeNode($1.ToKeyword(), $2, $3, $4, $5, $6)
+	}
 
 keyType : _INT32
 	| _INT64
@@ -601,220 +675,245 @@ keyType : _INT32
 	| _STRING
 
 extensions : _EXTENSIONS tagRanges ';' {
-		$$ = &extensionRangeNode{ranges: $2}
-		$$.setRange($1, $3)
+		ranges, commas := $2.toNodes()
+		$$ = ast.NewExtensionRangeNode($1.ToKeyword(), ranges, commas, nil, $3)
 	}
 	| _EXTENSIONS tagRanges compactOptions ';' {
-		$$ = &extensionRangeNode{ranges: $2, options: $3}
-		$$.setRange($1, $4)
+		ranges, commas := $2.toNodes()
+		$$ = ast.NewExtensionRangeNode($1.ToKeyword(), ranges, commas, $3, $4)
 	}
 
-tagRanges : tagRanges ',' tagRange {
-		$$ = append($1, $3...)
+tagRanges : tagRange {
+		$$ = &rangeList{$1, nil, nil}
+	}
+	| tagRange ',' tagRanges {
+		$$ = &rangeList{$1, $2, $3}
 	}
-	| tagRange
 
 tagRange : _INT_LIT {
-		r := &rangeNode{startNode: $1}
-		r.setRange($1, $1)
-		$$ = []*rangeNode{r}
+		$$ = ast.NewRangeNode($1, nil, nil, nil)
 	}
 	| _INT_LIT _TO _INT_LIT {
-		r := &rangeNode{startNode: $1, endNode: $3}
-		r.setRange($1, $3)
-		$$ = []*rangeNode{r}
+		$$ = ast.NewRangeNode($1, $2.ToKeyword(), $3, nil)
 	}
 	| _INT_LIT _TO _MAX {
-		r := &rangeNode{startNode: $1, endNode: $3, endMax: true}
-		r.setRange($1, $3)
-		$$ = []*rangeNode{r}
+		$$ = ast.NewRangeNode($1, $2.ToKeyword(), nil, $3.ToKeyword())
 	}
 
-enumRanges : enumRanges ',' enumRange {
-		$$ = append($1, $3...)
+enumRanges : enumRange {
+		$$ = &rangeList{$1, nil, nil}
+	}
+	| enumRange ',' enumRanges {
+		$$ = &rangeList{$1, $2, $3}
 	}
-	| enumRange
 
 enumRange : intLit {
-		r := &rangeNode{startNode: $1}
-		r.setRange($1, $1)
-		$$ = []*rangeNode{r}
+		$$ = ast.NewRangeNode($1, nil, nil, nil)
 	}
 	| intLit _TO intLit {
-		r := &rangeNode{startNode: $1, endNode: $3}
-		r.setRange($1, $3)
-		$$ = []*rangeNode{r}
+		$$ = ast.NewRangeNode($1, $2.ToKeyword(), $3, nil)
 	}
 	| intLit _TO _MAX {
-		r := &rangeNode{startNode: $1, endNode: $3, endMax: true}
-		r.setRange($1, $3)
-		$$ = []*rangeNode{r}
+		$$ = ast.NewRangeNode($1, $2.ToKeyword(), nil, $3.ToKeyword())
 	}
 
 intLit : _INT_LIT {
-		i := &compoundIntNode{val: int64($1.val)}
-		i.setRange($1, $1)
-		$$ = i
+		$$ = $1
 	}
 	| '-' _INT_LIT {
-		if $2.val > math.MaxInt64 + 1 {
-			lexError(protolex, $2.start(), fmt.Sprintf("numeric constant %d would underflow 64-bit signed int (allowed range is %d to %d)", $2.val, int64(math.MinInt64), int64(math.MaxInt64)))
-		}
-		i := &compoundIntNode{val: -int64($2.val)}
-		i.setRange($1, $2)
-		$$ = i
+		$$ = ast.NewNegativeIntLiteralNode($1, $2)
 	}
 
 msgReserved : _RESERVED tagRanges ';' {
-		$$ = &reservedNode{ranges: $2}
-		$$.setRange($1, $3)
+		ranges, commas := $2.toNodes()
+		$$ = ast.NewReservedRangesNode($1.ToKeyword(), ranges, commas, $3)
 	}
 	| reservedNames
 
 enumReserved : _RESERVED enumRanges ';' {
-		$$ = &reservedNode{ranges: $2}
-		$$.setRange($1, $3)
+		ranges, commas := $2.toNodes()
+		$$ = ast.NewReservedRangesNode($1.ToKeyword(), ranges, commas, $3)
 	}
 	| reservedNames
 
 reservedNames : _RESERVED fieldNames ';' {
-		$$ = &reservedNode{names: $2}
-		$$.setRange($1, $3)
+		names, commas := $2.toNodes()
+		$$ = ast.NewReservedNamesNode($1.ToKeyword(), names, commas, $3)
 	}
 
-fieldNames : fieldNames ',' stringLit {
-		$$ = append($1, $3)
+fieldNames : stringLit {
+		$$ = &nameList{$1.toStringValueNode(), nil, nil}
 	}
-	| stringLit {
-		$$ = []*compoundStringNode{$1}
+	| stringLit ',' fieldNames {
+		$$ = &nameList{$1.toStringValueNode(), $2, $3}
 	}
 
-enum : _ENUM name '{' enumBody '}' {
-		$$ = &enumNode{name: $2, decls: $4}
-		$$.setRange($1, $5)
+enum : _ENUM name '{' enumDecls '}' {
+		$$ = ast.NewEnumNode($1.ToKeyword(), $2, $3, $4, $5)
 	}
 
-enumBody : enumBody enumItem {
-		$$ = append($1, $2...)
+enumDecls : enumDecls enumDecl {
+		if $2 != nil {
+			$$ = append($1, $2)
+		} else {
+			$$ = $1
+		}
+	}
+	| enumDecl {
+		if $1 != nil {
+			$$ = []ast.EnumElement{$1}
+		} else {
+			$$ = nil
+		}
 	}
-	| enumItem
 	| {
 		$$ = nil
 	}
 
-enumItem : option {
-		$$ = []*enumElement{{option: $1[0]}}
+enumDecl : option {
+		$$ = $1
 	}
-	| enumField {
-		$$ = []*enumElement{{value: $1}}
+	| enumValue {
+		$$ = $1
 	}
 	| enumReserved {
-		$$ = []*enumElement{{reserved: $1}}
+		$$ = $1
 	}
 	| ';' {
-		$$ = []*enumElement{{empty: $1}}
+		$$ = ast.NewEmptyDeclNode($1)
 	}
 	| error ';' {
+		$$ = nil
 	}
 	| error {
+		$$ = nil
 	}
 
-enumField : name '=' intLit ';' {
-		$$ = &enumValueNode{name: $1, number: $3}
-		$$.setRange($1, $4)
+enumValue : enumElementName '=' intLit ';' {
+		$$ = ast.NewEnumValueNode($1, $2, $3, nil, $4)
 	}
-	|  name '=' intLit compactOptions ';' {
-		$$ = &enumValueNode{name: $1, number: $3, options: $4}
-		$$.setRange($1, $5)
+	|  enumElementName '=' intLit compactOptions ';' {
+		$$ = ast.NewEnumValueNode($1, $2, $3, $4, $5)
 	}
 
-message : _MESSAGE name '{' messageBody '}' {
-		$$ = &messageNode{name: $2, decls: $4}
-		$$.setRange($1, $5)
+message : _MESSAGE name '{' messageDecls '}' {
+		$$ = ast.NewMessageNode($1.ToKeyword(), $2, $3, $4, $5)
 	}
 
-messageBody : messageBody messageItem {
-		$$ = append($1, $2...)
+messageDecls : messageDecls messageDecl {
+		if $2 != nil {
+			$$ = append($1, $2)
+		} else {
+			$$ = $1
+		}
+	}
+	| messageDecl {
+		if $1 != nil {
+			$$ = []ast.MessageElement{$1}
+		} else {
+			$$ = nil
+		}
 	}
-	| messageItem
 	| {
 		$$ = nil
 	}
 
-messageItem : field {
-		$$ = []*messageElement{{field: $1}}
+messageDecl : msgField {
+		$$ = $1
 	}
 	| enum {
-		$$ = []*messageElement{{enum: $1}}
+		$$ = $1
 	}
 	| message {
-		$$ = []*messageElement{{nested: $1}}
+		$$ = $1
 	}
 	| extend {
-		$$ = []*messageElement{{extend: $1}}
+		$$ = $1
 	}
 	| extensions {
-		$$ = []*messageElement{{extensionRange: $1}}
+		$$ = $1
 	}
 	| group {
-		$$ = []*messageElement{{group: $1}}
+		$$ = $1
 	}
 	| option {
-		$$ = []*messageElement{{option: $1[0]}}
+		$$ = $1
 	}
 	| oneof {
-		$$ = []*messageElement{{oneOf: $1}}
+		$$ = $1
 	}
 	| mapField {
-		$$ = []*messageElement{{mapField: $1}}
+		$$ = $1
 	}
 	| msgReserved {
-		$$ = []*messageElement{{reserved: $1}}
+		$$ = $1
 	}
 	| ';' {
-		$$ = []*messageElement{{empty: $1}}
+		$$ = ast.NewEmptyDeclNode($1)
 	}
 	| error ';' {
+		$$ = nil
 	}
 	| error {
+		$$ = nil
 	}
 
-extend : _EXTEND typeIdent '{' extendBody '}' {
-		$$ = &extendNode{extendee: $2, decls: $4}
-		$$.setRange($1, $5)
+extend : _EXTEND typeIdent '{' extendDecls '}' {
+		$$ = ast.NewExtendNode($1.ToKeyword(), $2, $3, $4, $5)
 	}
 
-extendBody : extendBody extendItem {
-		$$ = append($1, $2...)
+extendDecls : extendDecls extendDecl {
+		if $2 != nil {
+			$$ = append($1, $2)
+		} else {
+			$$ = $1
+		}
+	}
+	| extendDecl {
+		if $1 != nil {
+			$$ = []ast.ExtendElement{$1}
+		} else {
+			$$ = nil
+		}
 	}
-	| extendItem
 	| {
 		$$ = nil
 	}
 
-extendItem : field {
-		$$ = []*extendElement{{field: $1}}
+extendDecl : extField {
+		$$ = $1
 	}
 	| group {
-		$$ = []*extendElement{{group: $1}}
+		$$ = $1
 	}
 	| ';' {
-		$$ = []*extendElement{{empty: $1}}
+		$$ = ast.NewEmptyDeclNode($1)
 	}
 	| error ';' {
+		$$ = nil
 	}
 	| error {
+		$$ = nil
 	}
 
-service : _SERVICE name '{' serviceBody '}' {
-		$$ = &serviceNode{name: $2, decls: $4}
-		$$.setRange($1, $5)
+service : _SERVICE name '{' serviceDecls '}' {
+		$$ = ast.NewServiceNode($1.ToKeyword(), $2, $3, $4, $5)
 	}
 
-serviceBody : serviceBody serviceItem {
-		$$ = append($1, $2...)
+serviceDecls : serviceDecls serviceDecl {
+		if $2 != nil {
+			$$ = append($1, $2)
+		} else {
+			$$ = $1
+		}
+	}
+	| serviceDecl {
+		if $1 != nil {
+			$$ = []ast.ServiceElement{$1}
+		} else {
+			$$ = nil
+		}
 	}
-	| serviceItem
 	| {
 		$$ = nil
 	}
@@ -822,57 +921,229 @@ serviceBody : serviceBody serviceItem {
 // NB: doc suggests support for "stream" declaration, separate from "rpc", but
 // it does not appear to be supported in protoc (doc is likely from grammar for
 // Google-internal version of protoc, with support for streaming stubby)
-serviceItem : option {
-		$$ = []*serviceElement{{option: $1[0]}}
+serviceDecl : option {
+		$$ = $1
 	}
 	| rpc {
-		$$ = []*serviceElement{{rpc: $1}}
+		$$ = $1
 	}
 	| ';' {
-		$$ = []*serviceElement{{empty: $1}}
+		$$ = ast.NewEmptyDeclNode($1)
 	}
 	| error ';' {
+		$$ = nil
 	}
 	| error {
+		$$ = nil
 	}
 
-rpc : _RPC name '(' rpcType ')' _RETURNS '(' rpcType ')' ';' {
-		$$ = &methodNode{name: $2, input: $4, output: $8}
-		$$.setRange($1, $10)
+rpc : _RPC name rpcType _RETURNS rpcType ';' {
+		$$ = ast.NewRPCNode($1.ToKeyword(), $2, $3, $4.ToKeyword(), $5, $6)
 	}
-	| _RPC name '(' rpcType ')' _RETURNS '(' rpcType ')' '{' rpcOptions '}' {
-		$$ = &methodNode{name: $2, input: $4, output: $8, options: $11}
-		$$.setRange($1, $12)
+	| _RPC name rpcType _RETURNS rpcType '{' rpcDecls '}' {
+		$$ = ast.NewRPCNodeWithBody($1.ToKeyword(), $2, $3, $4.ToKeyword(), $5, $6, $7, $8)
 	}
 
-rpcType : _STREAM typeIdent {
-		$$ = &rpcTypeNode{msgType: $2, streamKeyword: $1}
-		$$.setRange($1, $2)
+rpcType : '(' _STREAM typeIdent ')' {
+		$$ = ast.NewRPCTypeNode($1, $2.ToKeyword(), $3, $4)
 	}
-	| typeIdent {
-		$$ = &rpcTypeNode{msgType: $1}
-		$$.setRange($1, $1)
+	| '(' typeIdent ')' {
+		$$ = ast.NewRPCTypeNode($1, nil, $2, $3)
 	}
 
-rpcOptions : rpcOptions rpcOption {
-		$$ = append($1, $2...)
+rpcDecls : rpcDecls rpcDecl {
+		if $2 != nil {
+			$$ = append($1, $2)
+		} else {
+			$$ = $1
+		}
+	}
+	| rpcDecl {
+		if $1 != nil {
+			$$ = []ast.RPCElement{$1}
+		} else {
+			$$ = nil
+		}
 	}
-	| rpcOption
 	| {
-		$$ = []*optionNode{}
+		$$ = nil
 	}
 
-rpcOption : option {
+rpcDecl : option {
 		$$ = $1
 	}
 	| ';' {
-		$$ = []*optionNode{}
+		$$ = ast.NewEmptyDeclNode($1)
 	}
 	| error ';' {
+		$$ = nil
 	}
 	| error {
+		$$ = nil
 	}
 
+// excludes message, enum, oneof, extensions, reserved, extend,
+//   option, optional, required, and repeated
+msgElementName : _NAME
+	| _SYNTAX
+	| _IMPORT
+	| _WEAK
+	| _PUBLIC
+	| _PACKAGE
+	| _TRUE
+	| _FALSE
+	| _INF
+	| _NAN
+	| _DOUBLE
+	| _FLOAT
+	| _INT32
+	| _INT64
+	| _UINT32
+	| _UINT64
+	| _SINT32
+	| _SINT64
+	| _FIXED32
+	| _FIXED64
+	| _SFIXED32
+	| _SFIXED64
+	| _BOOL
+	| _STRING
+	| _BYTES
+	| _GROUP
+	| _MAP
+	| _TO
+	| _MAX
+	| _SERVICE
+	| _RPC
+	| _STREAM
+	| _RETURNS
+
+// excludes optional, required, and repeated
+extElementName : _NAME
+	| _SYNTAX
+	| _IMPORT
+	| _WEAK
+	| _PUBLIC
+	| _PACKAGE
+	| _OPTION
+	| _TRUE
+	| _FALSE
+	| _INF
+	| _NAN
+	| _DOUBLE
+	| _FLOAT
+	| _INT32
+	| _INT64
+	| _UINT32
+	| _UINT64
+	| _SINT32
+	| _SINT64
+	| _FIXED32
+	| _FIXED64
+	| _SFIXED32
+	| _SFIXED64
+	| _BOOL
+	| _STRING
+	| _BYTES
+	| _GROUP
+	| _ONEOF
+	| _MAP
+	| _EXTENSIONS
+	| _TO
+	| _MAX
+	| _RESERVED
+	| _ENUM
+	| _MESSAGE
+	| _EXTEND
+	| _SERVICE
+	| _RPC
+	| _STREAM
+	| _RETURNS
+
+// excludes reserved, option
+enumElementName : _NAME
+	| _SYNTAX
+	| _IMPORT
+	| _WEAK
+	| _PUBLIC
+	| _PACKAGE
+	| _TRUE
+	| _FALSE
+	| _INF
+	| _NAN
+	| _REPEATED
+	| _OPTIONAL
+	| _REQUIRED
+	| _DOUBLE
+	| _FLOAT
+	| _INT32
+	| _INT64
+	| _UINT32
+	| _UINT64
+	| _SINT32
+	| _SINT64
+	| _FIXED32
+	| _FIXED64
+	| _SFIXED32
+	| _SFIXED64
+	| _BOOL
+	| _STRING
+	| _BYTES
+	| _GROUP
+	| _ONEOF
+	| _MAP
+	| _EXTENSIONS
+	| _TO
+	| _MAX
+	| _ENUM
+	| _MESSAGE
+	| _EXTEND
+	| _SERVICE
+	| _RPC
+	| _STREAM
+	| _RETURNS
+
+// excludes option, optional, required, and repeated
+oneofElementName : _NAME
+	| _SYNTAX
+	| _IMPORT
+	| _WEAK
+	| _PUBLIC
+	| _PACKAGE
+	| _TRUE
+	| _FALSE
+	| _INF
+	| _NAN
+	| _DOUBLE
+	| _FLOAT
+	| _INT32
+	| _INT64
+	| _UINT32
+	| _UINT64
+	| _SINT32
+	| _SINT64
+	| _FIXED32
+	| _FIXED64
+	| _SFIXED32
+	| _SFIXED64
+	| _BOOL
+	| _STRING
+	| _BYTES
+	| _GROUP
+	| _ONEOF
+	| _MAP
+	| _EXTENSIONS
+	| _TO
+	| _MAX
+	| _RESERVED
+	| _ENUM
+	| _MESSAGE
+	| _EXTEND
+	| _SERVICE
+	| _RPC
+	| _STREAM
+	| _RETURNS
+
 name : _NAME
 	| _SYNTAX
 	| _IMPORT
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/proto.y.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/proto.y.go
index 1c91002a5..61d903865 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/proto.y.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/proto.y.go
@@ -10,54 +10,68 @@ import __yyfmt__ "fmt"
 //lint:file-ignore SA4006 generated parser has unused values
 
 import (
-	"fmt"
 	"math"
+
+	"github.com/jhump/protoreflect/desc/protoparse/ast"
 )
 
-//line proto.y:15
+//line proto.y:16
 type protoSymType struct {
 	yys       int
-	file      *fileNode
-	fileDecls []*fileElement
-	syn       *syntaxNode
-	pkg       *packageNode
-	imprt     *importNode
-	msg       *messageNode
-	msgDecls  []*messageElement
-	fld       *fieldNode
-	mapFld    *mapFieldNode
-	mapType   *mapTypeNode
-	grp       *groupNode
-	oo        *oneOfNode
-	ooDecls   []*oneOfElement
-	ext       *extensionRangeNode
-	resvd     *reservedNode
-	en        *enumNode
-	enDecls   []*enumElement
-	env       *enumValueNode
-	extend    *extendNode
-	extDecls  []*extendElement
-	svc       *serviceNode
-	svcDecls  []*serviceElement
-	mtd       *methodNode
-	rpcType   *rpcTypeNode
-	opts      []*optionNode
-	optNm     []*optionNamePartNode
-	cmpctOpts *compactOptionsNode
-	rngs      []*rangeNode
-	names     []*compoundStringNode
-	cid       *compoundIdentNode
-	sl        []valueNode
-	agg       []*aggregateEntryNode
-	aggName   *aggregateNameNode
-	v         valueNode
-	il        *compoundIntNode
-	str       *compoundStringNode
-	s         *stringLiteralNode
-	i         *intLiteralNode
-	f         *floatLiteralNode
-	id        *identNode
-	b         *basicNode
+	file      *ast.FileNode
+	syn       *ast.SyntaxNode
+	fileDecl  ast.FileElement
+	fileDecls []ast.FileElement
+	pkg       *ast.PackageNode
+	imprt     *ast.ImportNode
+	msg       *ast.MessageNode
+	msgDecl   ast.MessageElement
+	msgDecls  []ast.MessageElement
+	fld       *ast.FieldNode
+	mapFld    *ast.MapFieldNode
+	mapType   *ast.MapTypeNode
+	grp       *ast.GroupNode
+	oo        *ast.OneOfNode
+	ooDecl    ast.OneOfElement
+	ooDecls   []ast.OneOfElement
+	ext       *ast.ExtensionRangeNode
+	resvd     *ast.ReservedNode
+	en        *ast.EnumNode
+	enDecl    ast.EnumElement
+	enDecls   []ast.EnumElement
+	env       *ast.EnumValueNode
+	extend    *ast.ExtendNode
+	extDecl   ast.ExtendElement
+	extDecls  []ast.ExtendElement
+	svc       *ast.ServiceNode
+	svcDecl   ast.ServiceElement
+	svcDecls  []ast.ServiceElement
+	mtd       *ast.RPCNode
+	rpcType   *ast.RPCTypeNode
+	rpcDecl   ast.RPCElement
+	rpcDecls  []ast.RPCElement
+	opt       *ast.OptionNode
+	opts      *compactOptionList
+	ref       *ast.FieldReferenceNode
+	optNms    *fieldRefList
+	cmpctOpts *ast.CompactOptionsNode
+	rng       *ast.RangeNode
+	rngs      *rangeList
+	names     *nameList
+	cid       *identList
+	tid       ast.IdentValueNode
+	sl        *valueList
+	msgField  *ast.MessageFieldNode
+	msgEntry  *messageFieldEntry
+	msgLit    *messageFieldList
+	v         ast.ValueNode
+	il        ast.IntValueNode
+	str       *stringList
+	s         *ast.StringLiteralNode
+	i         *ast.UintLiteralNode
+	f         *ast.FloatLiteralNode
+	id        *ast.IdentNode
+	b         *ast.RuneNode
 	err       error
 }
 
@@ -189,13 +203,14 @@ var protoToknames = [...]string{
 	"'~'",
 	"'`'",
 }
+
 var protoStatenames = [...]string{}
 
 const protoEofCode = 1
 const protoErrCode = 2
 const protoInitialStackSize = 16
 
-//line proto.y:920
+//line proto.y:1191
 
 //line yacctab:1
 var protoExca = [...]int{
@@ -215,302 +230,252 @@ var protoExca = [...]int{
 	1, 3,
 	-2, 0,
 	-1, 95,
-	55, 161,
+	55, 178,
 	-2, 0,
 	-1, 96,
-	55, 149,
+	55, 166,
 	-2, 0,
 	-1, 97,
-	55, 178,
+	55, 195,
 	-2, 0,
 	-1, 99,
-	55, 187,
+	55, 204,
 	-2, 0,
 	-1, 110,
-	55, 47,
+	55, 53,
 	-2, 0,
-	-1, 225,
-	61, 47,
+	-1, 289,
+	55, 51,
+	61, 51,
 	-2, 0,
-	-1, 240,
-	55, 99,
+	-1, 352,
+	61, 53,
 	-2, 0,
-	-1, 267,
-	61, 47,
+	-1, 367,
+	55, 116,
 	-2, 0,
-	-1, 310,
-	61, 47,
+	-1, 401,
+	61, 53,
 	-2, 0,
-	-1, 347,
-	55, 161,
+	-1, 489,
+	61, 53,
 	-2, 0,
-	-1, 351,
-	55, 161,
-	-2, 0,
-	-1, 355,
-	55, 161,
+	-1, 533,
+	55, 178,
 	-2, 0,
-	-1, 366,
-	61, 47,
+	-1, 537,
+	55, 178,
 	-2, 0,
-	-1, 368,
-	61, 47,
+	-1, 541,
+	55, 178,
 	-2, 0,
-	-1, 373,
-	55, 161,
+	-1, 559,
+	55, 216,
 	-2, 0,
-	-1, 376,
-	55, 161,
+	-1, 566,
+	55, 178,
 	-2, 0,
-	-1, 379,
-	55, 161,
+	-1, 569,
+	55, 178,
 	-2, 0,
-	-1, 395,
-	55, 161,
+	-1, 572,
+	55, 178,
 	-2, 0,
-	-1, 407,
-	55, 161,
+	-1, 593,
+	55, 178,
 	-2, 0,
-	-1, 412,
-	55, 199,
+	-1, 605,
+	55, 178,
 	-2, 0,
 }
 
 const protoPrivate = 57344
 
-const protoLast = 2738
+const protoLast = 2321
 
 var protoAct = [...]int{
-
-	31, 125, 8, 415, 8, 8, 118, 303, 169, 104,
-	287, 236, 75, 282, 117, 207, 193, 134, 77, 79,
-	80, 106, 84, 206, 8, 105, 107, 124, 119, 156,
-	162, 143, 146, 192, 395, 76, 82, 324, 81, 170,
-	339, 340, 26, 393, 235, 323, 353, 238, 338, 355,
-	351, 85, 237, 30, 88, 89, 337, 349, 238, 238,
-	347, 238, 238, 238, 345, 331, 321, 298, 271, 270,
-	408, 208, 238, 238, 335, 116, 382, 297, 200, 238,
-	238, 238, 238, 29, 208, 208, 263, 363, 91, 407,
-	223, 110, 103, 109, 77, 222, 94, 152, 147, 225,
-	222, 163, 421, 221, 401, 222, 379, 302, 221, 399,
-	222, 174, 405, 221, 370, 90, 376, 377, 221, 344,
-	98, 373, 91, 222, 183, 158, 157, 240, 154, 115,
-	209, 221, 314, 87, 87, 191, 80, 79, 99, 97,
-	77, 195, 196, 209, 209, 260, 152, 147, 243, 185,
-	187, 189, 242, 259, 222, 81, 244, 220, 325, 92,
-	237, 166, 221, 163, 96, 219, 93, 93, 216, 199,
-	174, 411, 17, 412, 95, 87, 197, 154, 202, 87,
-	199, 102, 101, 158, 157, 211, 228, 229, 230, 231,
-	232, 233, 214, 226, 14, 224, 166, 418, 374, 371,
-	4, 15, 418, 362, 16, 17, 167, 17, 17, 218,
-	357, 165, 334, 17, 213, 328, 279, 215, 212, 203,
-	258, 184, 168, 100, 109, 25, 174, 86, 361, 360,
-	277, 276, 275, 274, 268, 19, 18, 20, 21, 77,
-	273, 167, 288, 284, 13, 266, 165, 417, 272, 264,
-	419, 283, 417, 241, 280, 234, 204, 24, 293, 364,
-	261, 239, 381, 5, 29, 194, 109, 23, 174, 174,
-	299, 296, 380, 181, 179, 309, 311, 301, 320, 285,
-	319, 305, 318, 300, 180, 29, 23, 317, 288, 316,
-	322, 27, 28, 315, 329, 330, 295, 327, 122, 11,
-	194, 11, 11, 14, 293, 178, 176, 332, 218, 278,
-	15, 174, 174, 16, 17, 333, 177, 262, 87, 341,
-	29, 11, 336, 164, 161, 77, 109, 346, 348, 350,
-	352, 354, 356, 3, 12, 359, 22, 283, 358, 109,
-	109, 155, 174, 148, 19, 18, 20, 21, 365, 367,
-	145, 218, 123, 13, 205, 120, 10, 149, 10, 10,
-	121, 9, 372, 9, 9, 128, 375, 174, 198, 174,
-	378, 286, 141, 127, 290, 383, 126, 385, 10, 183,
-	289, 218, 183, 9, 174, 183, 174, 171, 388, 307,
-	397, 390, 394, 396, 392, 183, 173, 183, 245, 183,
-	305, 108, 414, 281, 7, 6, 2, 1, 0, 0,
-	406, 0, 0, 183, 416, 0, 416, 183, 420, 0,
-	0, 0, 410, 218, 308, 218, 29, 114, 111, 32,
-	33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
-	43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
-	53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
-	63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
-	73, 74, 0, 0, 0, 0, 110, 0, 0, 0,
-	0, 0, 0, 0, 310, 113, 112, 0, 0, 0,
-	306, 29, 114, 111, 32, 33, 34, 35, 36, 37,
+	31, 118, 117, 125, 8, 396, 8, 8, 488, 81,
+	486, 414, 363, 288, 579, 421, 328, 107, 77, 79,
+	80, 82, 84, 326, 317, 311, 8, 106, 105, 124,
+	281, 228, 139, 26, 177, 593, 416, 591, 30, 525,
+	555, 553, 85, 551, 541, 87, 88, 89, 364, 539,
+	537, 535, 364, 531, 75, 364, 364, 364, 364, 533,
+	524, 519, 512, 364, 364, 500, 364, 473, 364, 362,
+	502, 405, 364, 560, 404, 329, 364, 364, 523, 397,
+	364, 329, 364, 349, 364, 29, 329, 116, 94, 350,
+	110, 348, 563, 109, 77, 320, 562, 584, 352, 349,
+	178, 104, 550, 282, 529, 98, 349, 348, 530, 492,
+	349, 293, 347, 103, 348, 493, 583, 477, 348, 302,
+	346, 526, 503, 472, 388, 371, 365, 230, 511, 185,
+	115, 339, 321, 93, 330, 310, 91, 314, 315, 344,
+	330, 304, 306, 308, 14, 330, 285, 582, 605, 572,
+	4, 15, 569, 566, 16, 17, 318, 17, 17, 558,
+	367, 559, 14, 319, 316, 285, 582, 99, 97, 15,
+	96, 95, 16, 17, 603, 597, 17, 17, 577, 576,
+	178, 575, 570, 567, 564, 19, 18, 20, 21, 557,
+	549, 286, 543, 515, 13, 507, 284, 581, 413, 340,
+	595, 387, 318, 19, 18, 20, 21, 370, 369, 185,
+	286, 323, 13, 342, 333, 284, 581, 324, 303, 287,
+	102, 101, 100, 90, 86, 25, 547, 546, 504, 480,
+	479, 478, 411, 410, 409, 408, 407, 337, 406, 394,
+	368, 361, 325, 334, 335, 336, 92, 24, 482, 418,
+	389, 366, 122, 11, 574, 11, 11, 230, 573, 332,
+	338, 373, 374, 375, 376, 377, 378, 379, 380, 381,
+	382, 383, 384, 120, 10, 11, 10, 10, 121, 9,
+	518, 9, 9, 517, 282, 419, 516, 343, 29, 5,
+	293, 300, 298, 23, 27, 28, 10, 29, 313, 499,
+	498, 9, 299, 345, 353, 355, 356, 357, 358, 359,
+	360, 341, 23, 297, 295, 497, 496, 495, 494, 481,
+	351, 470, 313, 412, 296, 390, 29, 3, 283, 280,
+	22, 12, 227, 179, 176, 391, 392, 393, 123, 327,
+	312, 180, 386, 385, 128, 420, 137, 127, 424, 126,
+	229, 109, 119, 293, 423, 289, 290, 427, 236, 134,
+	429, 395, 237, 140, 183, 77, 402, 431, 239, 143,
+	372, 422, 108, 292, 76, 578, 415, 7, 400, 398,
+	6, 2, 1, 0, 0, 0, 0, 0, 0, 318,
+	0, 417, 0, 0, 0, 0, 471, 0, 0, 474,
+	109, 0, 293, 0, 0, 0, 476, 484, 0, 0,
+	0, 0, 475, 0, 0, 490, 0, 0, 0, 0,
+	0, 0, 0, 0, 422, 501, 0, 0, 508, 509,
+	0, 0, 0, 0, 426, 0, 506, 0, 0, 432,
+	433, 434, 435, 436, 437, 17, 438, 439, 440, 441,
+	0, 0, 510, 442, 443, 444, 445, 446, 447, 448,
+	449, 450, 451, 452, 453, 454, 455, 456, 428, 457,
+	458, 459, 460, 461, 462, 463, 464, 465, 466, 467,
+	468, 469, 514, 513, 425, 0, 0, 505, 521, 0,
+	293, 430, 0, 522, 520, 0, 0, 0, 0, 0,
+	0, 0, 0, 527, 77, 109, 0, 532, 534, 536,
+	538, 540, 542, 545, 0, 544, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 109, 0, 552,
+	554, 556, 0, 548, 0, 0, 565, 561, 0, 0,
+	568, 0, 0, 0, 571, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 580, 0, 0, 0, 302, 0, 586,
+	302, 0, 588, 302, 0, 590, 0, 0, 0, 0,
+	0, 0, 580, 0, 109, 109, 592, 594, 302, 0,
+	302, 0, 302, 596, 598, 599, 604, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 302, 0, 607, 302,
+	487, 0, 29, 114, 111, 32, 33, 34, 35, 36,
+	37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
+	47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
+	57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
+	67, 68, 69, 70, 71, 72, 73, 74, 0, 0,
+	0, 0, 110, 0, 0, 0, 0, 0, 0, 0,
+	489, 113, 112, 0, 0, 0, 485, 29, 114, 111,
+	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
+	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
+	62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
+	72, 73, 74, 0, 0, 0, 0, 110, 0, 0,
+	0, 0, 0, 0, 0, 401, 113, 112, 0, 0,
+	399, 29, 114, 111, 32, 33, 34, 35, 36, 37,
 	38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
 	48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
 	58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
 	68, 69, 70, 71, 72, 73, 74, 0, 0, 0,
-	0, 110, 0, 0, 0, 0, 0, 0, 0, 267,
-	113, 112, 0, 0, 265, 29, 114, 111, 32, 33,
-	34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
-	44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
-	54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
-	64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
-	74, 0, 0, 0, 0, 110, 0, 0, 0, 0,
-	0, 0, 0, 368, 113, 112, 29, 114, 111, 32,
-	33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
-	43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
-	53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
-	63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
-	73, 74, 0, 0, 0, 0, 110, 0, 0, 0,
-	0, 0, 172, 0, 366, 113, 112, 32, 33, 34,
-	35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
-	45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
-	55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
-	65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 400, 0, 172, 0, 0, 0, 175, 32, 33,
-	34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
-	44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
-	54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
-	64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
-	74, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 398, 0, 172, 0, 0, 0, 175, 32,
-	33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
-	43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
-	53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
-	63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
-	73, 74, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 369, 0, 0, 0, 0, 0, 175,
-	29, 114, 111, 32, 33, 34, 35, 36, 37, 38,
-	39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
-	49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
-	59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
-	69, 70, 71, 72, 73, 74, 0, 0, 0, 0,
-	110, 0, 0, 0, 0, 0, 172, 0, 0, 113,
-	112, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-	41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
-	51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
-	61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
-	71, 72, 73, 74, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 343, 0, 172, 0, 0,
-	0, 175, 32, 33, 34, 35, 36, 37, 38, 39,
-	40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
-	50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
-	60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
-	70, 71, 72, 73, 74, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 313, 0, 172, 0,
-	0, 0, 175, 32, 33, 34, 35, 36, 37, 38,
+	0, 110, 0, 0, 0, 0, 0, 0, 0, 489,
+	113, 112, 29, 114, 111, 32, 33, 34, 35, 36,
+	37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
+	47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
+	57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
+	67, 68, 69, 70, 71, 72, 73, 74, 0, 0,
+	0, 0, 110, 0, 0, 0, 0, 0, 528, 0,
+	0, 113, 112, 32, 33, 34, 35, 36, 37, 38,
 	39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
 	49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
 	59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
 	69, 70, 71, 72, 73, 74, 0, 0, 0, 0,
-	0, 217, 0, 0, 0, 0, 0, 0, 0, 386,
-	0, 0, 0, 175, 32, 33, 34, 35, 36, 37,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 491,
+	0, 0, 0, 294, 32, 33, 34, 35, 36, 37,
 	38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
 	48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
 	58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
-	68, 69, 70, 71, 72, 73, 74, 246, 247, 248,
-	249, 250, 251, 252, 253, 254, 255, 256, 257, 0,
-	384, 0, 0, 0, 175, 32, 33, 34, 35, 36,
+	68, 69, 70, 71, 72, 73, 74, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	403, 0, 0, 0, 294, 32, 33, 34, 35, 36,
 	37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
 	47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
 	57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
 	67, 68, 69, 70, 71, 72, 73, 74, 0, 0,
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 342, 0, 0, 0, 175, 32, 33, 34, 35,
+	0, 291, 0, 0, 0, 294, 32, 33, 34, 35,
 	36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
 	46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
 	56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
 	66, 67, 68, 69, 70, 71, 72, 73, 74, 0,
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 312, 0, 0, 0, 175, 32, 33, 34,
+	0, 0, 0, 0, 0, 0, 294, 32, 33, 34,
 	35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
 	45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
 	55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
 	65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 269, 0, 0, 0, 175, 32, 33,
-	34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
-	44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
-	54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
-	64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
-	74, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 172, 0, 0, 0, 175, 32,
-	33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
-	43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
-	53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
-	63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
-	73, 74, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 175,
-	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
-	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
-	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
-	62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
-	72, 73, 74, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 130, 0, 0, 0, 78, 32,
-	33, 34, 35, 36, 37, 139, 39, 40, 41, 42,
-	133, 132, 131, 46, 47, 48, 49, 50, 51, 52,
-	53, 54, 55, 56, 57, 58, 59, 60, 61, 140,
-	144, 138, 65, 66, 142, 135, 136, 137, 71, 72,
-	73, 74, 0, 0, 129, 0, 0, 413, 130, 0,
-	0, 83, 0, 32, 33, 34, 35, 36, 37, 139,
-	39, 40, 41, 42, 133, 132, 131, 46, 47, 48,
-	49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
-	59, 60, 61, 140, 144, 138, 65, 66, 142, 135,
-	136, 137, 71, 72, 73, 74, 0, 0, 129, 0,
-	0, 409, 130, 0, 0, 83, 0, 32, 33, 34,
-	35, 36, 37, 139, 39, 40, 41, 42, 133, 132,
-	131, 46, 47, 48, 49, 50, 51, 52, 53, 54,
-	55, 56, 57, 58, 59, 60, 61, 140, 144, 138,
-	65, 66, 142, 135, 136, 137, 71, 72, 73, 74,
-	0, 0, 129, 0, 0, 404, 130, 0, 0, 83,
-	0, 32, 33, 34, 35, 36, 37, 139, 39, 40,
-	41, 42, 133, 132, 131, 46, 47, 48, 49, 50,
-	51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
-	61, 140, 144, 138, 65, 66, 142, 135, 136, 137,
-	71, 72, 73, 74, 0, 0, 129, 0, 0, 403,
-	130, 0, 0, 83, 0, 32, 33, 34, 35, 36,
-	37, 139, 39, 40, 41, 42, 133, 132, 131, 46,
-	47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
-	57, 58, 59, 60, 61, 140, 144, 138, 65, 66,
-	142, 135, 136, 137, 71, 72, 73, 74, 0, 0,
-	129, 0, 0, 402, 130, 0, 0, 83, 0, 32,
-	33, 34, 35, 36, 37, 139, 39, 40, 41, 42,
-	133, 132, 131, 46, 47, 48, 49, 50, 51, 52,
-	53, 54, 55, 56, 57, 58, 59, 60, 61, 140,
-	144, 138, 65, 66, 142, 135, 136, 137, 71, 72,
-	73, 74, 0, 0, 129, 0, 0, 391, 130, 0,
-	0, 83, 0, 32, 33, 34, 35, 36, 37, 139,
-	39, 40, 41, 42, 133, 132, 131, 46, 47, 48,
-	49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
-	59, 60, 61, 140, 144, 138, 65, 66, 142, 135,
-	136, 137, 71, 72, 73, 74, 0, 0, 129, 0,
-	0, 389, 130, 0, 0, 83, 0, 32, 33, 34,
-	35, 36, 37, 139, 39, 40, 41, 42, 133, 132,
-	131, 46, 47, 48, 49, 50, 51, 52, 53, 54,
-	55, 56, 57, 58, 59, 60, 61, 140, 144, 138,
-	65, 66, 142, 135, 136, 137, 71, 72, 73, 74,
-	0, 0, 129, 0, 0, 387, 292, 0, 0, 83,
-	0, 32, 33, 34, 35, 36, 37, 139, 39, 40,
-	41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
-	51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
-	294, 62, 63, 64, 65, 66, 67, 68, 69, 70,
-	71, 72, 73, 74, 0, 0, 291, 0, 0, 326,
-	160, 0, 0, 83, 0, 32, 33, 34, 35, 36,
-	37, 38, 39, 40, 41, 42, 133, 132, 131, 46,
-	47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
-	57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
-	67, 68, 69, 70, 71, 72, 73, 74, 0, 0,
-	159, 0, 0, 210, 130, 0, 0, 83, 0, 32,
-	33, 34, 35, 36, 37, 139, 39, 40, 41, 42,
-	133, 132, 131, 46, 47, 48, 49, 50, 51, 52,
-	53, 54, 55, 56, 57, 58, 59, 60, 61, 140,
-	144, 138, 65, 66, 142, 135, 136, 137, 71, 72,
-	73, 74, 0, 0, 129, 0, 0, 182, 130, 0,
-	0, 83, 0, 32, 33, 34, 35, 36, 37, 139,
-	39, 40, 41, 42, 133, 132, 131, 46, 47, 48,
-	49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
-	59, 60, 61, 140, 144, 138, 65, 66, 142, 135,
-	136, 137, 71, 72, 73, 74, 0, 0, 129, 0,
-	0, 292, 0, 0, 0, 83, 32, 33, 34, 35,
-	36, 37, 139, 39, 40, 41, 42, 43, 44, 45,
-	46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
-	56, 57, 58, 59, 60, 294, 62, 63, 64, 65,
-	66, 67, 68, 69, 70, 71, 72, 73, 74, 0,
-	0, 291, 0, 0, 160, 0, 0, 0, 83, 32,
-	33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
-	133, 132, 131, 46, 47, 48, 49, 50, 51, 52,
-	53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
-	63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
-	73, 74, 0, 0, 159, 0, 0, 227, 0, 0,
-	0, 83, 32, 33, 34, 35, 36, 37, 38, 39,
+	0, 130, 0, 0, 0, 78, 144, 145, 146, 147,
+	148, 149, 17, 150, 151, 152, 153, 133, 132, 131,
+	154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
+	164, 165, 166, 167, 168, 169, 136, 142, 135, 170,
+	171, 138, 19, 18, 20, 172, 173, 174, 175, 0,
+	0, 129, 0, 0, 608, 130, 0, 0, 141, 0,
+	144, 145, 146, 147, 148, 149, 17, 150, 151, 152,
+	153, 133, 132, 131, 154, 155, 156, 157, 158, 159,
+	160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
+	136, 142, 135, 170, 171, 138, 19, 18, 20, 172,
+	173, 174, 175, 0, 0, 129, 0, 0, 606, 130,
+	0, 0, 141, 0, 144, 145, 146, 147, 148, 149,
+	17, 150, 151, 152, 153, 133, 132, 131, 154, 155,
+	156, 157, 158, 159, 160, 161, 162, 163, 164, 165,
+	166, 167, 168, 169, 136, 142, 135, 170, 171, 138,
+	19, 18, 20, 172, 173, 174, 175, 0, 0, 129,
+	0, 0, 602, 130, 0, 0, 141, 0, 144, 145,
+	146, 147, 148, 149, 17, 150, 151, 152, 153, 133,
+	132, 131, 154, 155, 156, 157, 158, 159, 160, 161,
+	162, 163, 164, 165, 166, 167, 168, 169, 136, 142,
+	135, 170, 171, 138, 19, 18, 20, 172, 173, 174,
+	175, 0, 0, 129, 0, 0, 601, 130, 0, 0,
+	141, 0, 144, 145, 146, 147, 148, 149, 17, 150,
+	151, 152, 153, 133, 132, 131, 154, 155, 156, 157,
+	158, 159, 160, 161, 162, 163, 164, 165, 166, 167,
+	168, 169, 136, 142, 135, 170, 171, 138, 19, 18,
+	20, 172, 173, 174, 175, 0, 0, 129, 0, 0,
+	600, 130, 0, 0, 141, 0, 144, 145, 146, 147,
+	148, 149, 17, 150, 151, 152, 153, 133, 132, 131,
+	154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
+	164, 165, 166, 167, 168, 169, 136, 142, 135, 170,
+	171, 138, 19, 18, 20, 172, 173, 174, 175, 0,
+	0, 129, 0, 0, 589, 130, 0, 0, 141, 0,
+	144, 145, 146, 147, 148, 149, 17, 150, 151, 152,
+	153, 133, 132, 131, 154, 155, 156, 157, 158, 159,
+	160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
+	136, 142, 135, 170, 171, 138, 19, 18, 20, 172,
+	173, 174, 175, 0, 0, 129, 0, 0, 587, 130,
+	0, 0, 141, 0, 144, 145, 146, 147, 148, 149,
+	17, 150, 151, 152, 153, 133, 132, 131, 154, 155,
+	156, 157, 158, 159, 160, 161, 162, 163, 164, 165,
+	166, 167, 168, 169, 136, 142, 135, 170, 171, 138,
+	19, 18, 20, 172, 173, 174, 175, 0, 0, 129,
+	0, 0, 585, 232, 0, 0, 141, 0, 240, 241,
+	242, 243, 244, 245, 246, 247, 248, 249, 250, 235,
+	234, 233, 251, 252, 253, 254, 255, 256, 257, 258,
+	259, 260, 261, 262, 263, 264, 265, 266, 267, 268,
+	269, 270, 271, 272, 273, 274, 275, 276, 277, 278,
+	279, 0, 0, 231, 0, 0, 331, 130, 0, 0,
+	238, 0, 144, 145, 146, 147, 148, 149, 17, 150,
+	151, 152, 153, 133, 132, 131, 154, 155, 156, 157,
+	158, 159, 160, 161, 162, 163, 164, 165, 166, 167,
+	168, 169, 136, 142, 135, 170, 171, 138, 19, 18,
+	20, 172, 173, 174, 175, 0, 0, 129, 0, 0,
+	301, 130, 0, 0, 141, 0, 144, 145, 146, 147,
+	148, 149, 17, 150, 151, 152, 153, 133, 132, 131,
+	154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
+	164, 165, 166, 167, 168, 169, 136, 142, 135, 170,
+	171, 138, 19, 18, 20, 172, 173, 174, 175, 0,
+	0, 129, 0, 0, 232, 0, 0, 0, 141, 240,
+	241, 242, 243, 244, 245, 246, 247, 248, 249, 250,
+	235, 234, 233, 251, 252, 253, 254, 255, 256, 257,
+	258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
+	268, 269, 270, 271, 272, 273, 274, 275, 276, 277,
+	278, 279, 0, 0, 231, 0, 0, 354, 0, 0,
+	0, 238, 32, 33, 34, 35, 36, 37, 38, 39,
 	40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
 	50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
 	60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
@@ -519,250 +484,345 @@ var protoAct = [...]int{
 	37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
 	47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
 	57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
-	67, 68, 69, 70, 71, 72, 304, 74, 0, 0,
+	67, 68, 69, 70, 71, 72, 73, 74, 0, 0,
 	0, 0, 0, 0, 0, 0, 0, 83, 32, 33,
 	34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
 	44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
 	54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
-	64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
+	64, 65, 66, 67, 68, 69, 70, 71, 72, 483,
 	74, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 	83, 32, 33, 34, 35, 36, 37, 38, 39, 40,
 	41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
 	51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
-	190, 62, 63, 64, 65, 66, 67, 68, 69, 70,
+	309, 62, 63, 64, 65, 66, 67, 68, 69, 70,
 	71, 72, 73, 74, 0, 0, 0, 0, 0, 0,
 	0, 0, 0, 83, 32, 33, 34, 35, 36, 37,
 	38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
 	48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
-	58, 59, 60, 188, 62, 63, 64, 65, 66, 67,
+	58, 59, 60, 307, 62, 63, 64, 65, 66, 67,
 	68, 69, 70, 71, 72, 73, 74, 0, 0, 0,
 	0, 0, 0, 0, 0, 0, 83, 32, 33, 34,
 	35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
 	45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
-	55, 56, 57, 58, 59, 60, 186, 62, 63, 64,
+	55, 56, 57, 58, 59, 60, 305, 62, 63, 64,
 	65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
-	0, 0, 0, 0, 0, 151, 0, 0, 0, 83,
-	32, 33, 34, 35, 36, 37, 139, 39, 40, 41,
-	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
-	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
-	62, 63, 64, 65, 66, 153, 68, 69, 70, 71,
-	72, 73, 74, 0, 151, 150, 0, 0, 201, 32,
-	33, 34, 35, 36, 37, 139, 39, 40, 41, 42,
-	43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
-	53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
-	63, 64, 65, 66, 153, 68, 69, 70, 71, 72,
-	73, 74, 0, 0, 150, 32, 33, 34, 35, 36,
-	37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
-	47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
-	57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
-	67, 68, 69, 70, 71, 72, 73, 74,
+	0, 0, 0, 0, 0, 426, 0, 0, 0, 83,
+	432, 433, 434, 435, 436, 437, 17, 438, 439, 440,
+	441, 0, 0, 0, 442, 443, 444, 445, 446, 447,
+	448, 449, 450, 451, 452, 453, 454, 455, 456, 428,
+	457, 458, 459, 460, 461, 462, 463, 464, 465, 466,
+	467, 468, 469, 0, 0, 425, 0, 0, 182, 0,
+	0, 0, 430, 186, 187, 188, 189, 190, 191, 17,
+	192, 193, 194, 195, 196, 197, 198, 199, 200, 201,
+	202, 203, 204, 205, 206, 207, 208, 209, 210, 211,
+	212, 213, 214, 215, 216, 217, 218, 219, 184, 220,
+	221, 222, 223, 224, 225, 226, 0, 182, 181, 0,
+	0, 322, 186, 187, 188, 189, 190, 191, 17, 192,
+	193, 194, 195, 196, 197, 198, 199, 200, 201, 202,
+	203, 204, 205, 206, 207, 208, 209, 210, 211, 212,
+	213, 214, 215, 216, 217, 218, 219, 184, 220, 221,
+	222, 223, 224, 225, 226, 0, 0, 181, 32, 33,
+	34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
+	44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
+	54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
+	64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
+	74,
 }
-var protoPact = [...]int{
 
-	192, -1000, 301, 301, 206, -1000, -1000, -1000, -1000, -1000,
-	-1000, -1000, -1000, -1000, 173, 281, 2688, 1463, 2688, 2688,
-	2381, 2688, 301, -1000, 316, -1000, 175, 316, 316, -1000,
-	63, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+var protoPact = [...]int{
+	142, -1000, 160, 160, 196, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, 173, 284, 2271, 1100, 2271, 2271,
+	1858, 2271, 160, -1000, 322, -1000, 172, 322, 322, 322,
+	171, 77, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, 195, 74, -1000, 1858, 117,
+	116, 114, -1000, 2271, 113, 170, -1000, 169, 168, -1000,
+	-1000, 2271, 798, 1100, 21, 1699, 2225, 1752, -1000, 163,
+	-1000, -1000, -1000, -1000, 167, -1000, -1000, -1000, -1000, -1000,
+	1039, -1000, 308, 286, -1000, -1000, -1000, 1645, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	166, 2070, 2017, 1964, 2271, 317, 2271, 2271, 293, -1000,
+	-1000, 2271, 33, 73, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, 2176, -1000, -1000, -1000,
+	-1000, -1000, 165, 191, 81, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 1591, -1000, -1000,
+	-1000, -1000, 162, 2070, 2017, 1964, 2271, -1000, 2271, 72,
 	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
-	-1000, -1000, -1000, -1000, -1000, 108, -1000, -1000, 2381, 120,
-	110, 85, 29, 2688, 84, 171, -1000, -1000, 130, 129,
-	-1000, 2688, 856, 1463, 9, 2116, 2642, 2222, 29, 194,
-	-1000, -1000, -1000, -1000, 170, -1000, -1000, 314, -1000, -1000,
-	1402, -1000, 300, 268, -1000, -1000, -1000, 2062, -1000, -1000,
 	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
-	169, 2540, 2487, 2434, 2688, 2688, 2688, 2381, 295, 1463,
-	2688, 2688, 260, -1000, 16, 2593, -1000, -1000, -1000, -1000,
-	-1000, 167, 205, 79, -1000, 2008, -1000, -1000, -1000, -1000,
-	166, 159, -1000, -1000, -1000, -1000, 165, 2688, -1000, 1036,
-	-1000, 105, 102, 37, -1000, 2275, -1000, -1000, -1000, -1000,
-	-1000, -1000, -1000, -1000, -1000, 2688, 2688, 2688, 2688, 2688,
-	2688, 204, -8, -1000, 221, 73, 202, 100, 96, 314,
-	1124, -1000, -1000, -1000, 80, 93, -1000, 220, -1000, 312,
-	-1000, -1000, -1000, -1000, -1000, -1000, 21, -1000, -1000, -1000,
-	-1000, -1000, -1000, 487, -1000, 1341, 1, 0, 197, 189,
-	182, 181, 180, 179, 304, -1000, 164, 295, 1463, 238,
-	2169, 291, -1000, -1000, 316, 17, -1000, -1000, -1000, -1000,
-	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, 15, 80,
-	-1000, 66, -1000, 2328, -1000, 422, -1000, 1280, 975, 71,
-	-1000, -1000, 288, 284, 282, 277, 275, 273, 14, -1000,
-	-1000, -23, -1000, 107, -1000, -1000, 1954, -1000, -1000, -1000,
-	-1000, -1000, 163, 2688, 2688, 13, 314, 2381, -1000, 160,
-	-1000, -1000, -1000, 8, 2381, -1000, -1000, -12, -27, -1000,
-	1219, 914, 58, -1000, -1000, 12, 6, 5, -4, -6,
-	-5, -1000, 158, -1000, 1463, 856, -1000, -1000, -1000, 178,
-	177, -1000, 151, 26, -1000, 210, -1000, -1000, 612, 551,
-	-1000, 792, 53, -1000, -1000, -1000, 147, 2116, 67, -1000,
-	146, 2116, 62, -1000, 65, 2116, 52, -1000, -1000, -1000,
-	267, 257, -1000, -1000, 11, -1000, 1158, -1000, 1097, -1000,
-	-1000, -1000, 1900, 2116, -1000, 1846, 2116, -1000, 1792, 2116,
-	-9, -20, 2328, 731, 48, 670, 43, -1000, 1738, -1000,
-	1684, -1000, 1630, -1000, 60, 2116, 35, 4, -1000, -1000,
-	-1000, -1000, -1000, -1000, -1000, -1000, 1576, 2116, 119, -1000,
-	1522, -1000, 200, -1000, 195, -1000, -1000, -1000, 50, -1000,
-	-1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	144, -1000, -1000, -1000, -1000, 161, 2271, -1000, 84, 1039,
+	60, 58, 36, -1000, 1805, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, 2271, 2271, 2271, 2271, 2271, 2271,
+	190, 17, 66, 211, 106, 189, 156, 155, 65, -1000,
+	238, 2271, -1000, -1000, -1000, 70, 149, 64, 210, -1000,
+	320, -1000, -1000, -1000, 2271, 2271, 2271, 188, -1000, 2271,
+	-1000, -1000, -1000, 14, -1000, -1000, -1000, -1000, -1000, -1000,
+	673, -1000, 978, 6, 3, 187, 185, 184, 183, 182,
+	181, 318, -1000, 146, 1100, 317, 244, 2123, 316, -1000,
+	-1000, 322, 63, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, 15, -1000, 70, 76,
+	-1000, 180, 179, 178, 314, -1000, 199, 1911, -1000, 608,
+	-1000, 917, 48, 54, -1000, -1000, 313, 312, 311, 310,
+	295, 294, 13, -1000, 2, 62, 177, -1000, -1000, -1000,
+	432, -1000, -1000, -1000, -1000, -1000, 143, 2271, 2271, -1000,
+	2271, 69, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
+	10, -1000, 1858, -1000, 141, -1000, -1000, -1000, 281, 278,
+	275, 9, 14, 1858, 12, -1000, -8, -29, 61, 856,
+	43, 47, -1000, -1000, 1, 5, -1, -4, -3, -10,
+	-1000, 140, -1000, 1100, 798, -1000, -1000, -1000, 176, 175,
+	-1000, 2271, -1000, 138, 41, -1000, -9, -11, -12, -1000,
+	137, 107, 7, -1000, -1000, -1000, 737, 35, 31, -1000,
+	-1000, -1000, 132, 1699, 99, -1000, 131, 1699, 98, -1000,
+	130, 1699, 95, -1000, -1000, -1000, 253, 249, -1000, -1000,
+	-1000, -1000, 129, -1000, 127, -1000, 126, -1000, -1000, 164,
+	-1000, -1000, 56, 37, -1000, 1537, 1699, -1000, 1483, 1699,
+	-1000, 1429, 1699, -15, -19, -1000, -1000, -1000, 145, -1000,
+	-1000, -1000, 123, 737, 737, -1000, 1375, -1000, 1321, -1000,
+	1267, -1000, 122, 1699, 94, -1000, -1000, -1000, -1000, -1000,
+	-1000, -1000, -1000, -1000, 1213, 1699, -1000, 1159, -1000,
 }
-var protoPgo = [...]int{
 
-	0, 407, 406, 263, 333, 405, 404, 1, 13, 403,
-	3, 402, 12, 35, 11, 9, 25, 21, 401, 15,
-	0, 398, 36, 17, 396, 389, 8, 39, 387, 28,
-	380, 376, 27, 374, 373, 372, 360, 6, 14, 10,
-	371, 368, 365, 357, 31, 16, 33, 23, 354, 352,
-	355, 32, 350, 343, 298, 29, 341, 26, 334, 30,
-	324, 323, 7,
+var protoPgo = [...]int{
+	0, 382, 381, 289, 327, 380, 377, 3, 376, 11,
+	14, 375, 374, 373, 36, 12, 8, 28, 27, 372,
+	16, 0, 370, 369, 368, 367, 364, 21, 363, 362,
+	360, 9, 359, 358, 357, 10, 356, 355, 13, 354,
+	352, 350, 349, 29, 348, 347, 346, 278, 1, 2,
+	15, 345, 24, 344, 341, 32, 340, 339, 25, 23,
+	338, 273, 34, 334, 333, 252, 31, 332, 17, 331,
+	30, 329, 328, 5,
 }
-var protoR1 = [...]int{
 
+var protoR1 = [...]int{
 	0, 1, 1, 1, 1, 4, 4, 3, 3, 3,
 	3, 3, 3, 3, 3, 3, 3, 2, 5, 5,
-	5, 6, 22, 22, 7, 12, 12, 13, 13, 15,
-	15, 16, 16, 16, 18, 18, 18, 18, 18, 18,
-	18, 18, 57, 57, 17, 26, 26, 26, 27, 27,
-	27, 27, 27, 27, 28, 28, 28, 28, 28, 28,
-	28, 28, 28, 28, 24, 24, 24, 25, 25, 25,
-	25, 25, 25, 25, 25, 25, 23, 23, 29, 29,
-	29, 29, 29, 29, 29, 29, 14, 9, 9, 8,
-	32, 32, 32, 32, 32, 32, 31, 40, 40, 40,
-	39, 39, 39, 39, 39, 39, 30, 30, 33, 33,
-	34, 34, 35, 21, 21, 21, 21, 21, 21, 21,
-	21, 21, 21, 21, 21, 49, 49, 46, 46, 45,
-	45, 45, 48, 48, 47, 47, 47, 19, 19, 42,
-	42, 43, 43, 44, 41, 41, 50, 52, 52, 52,
-	51, 51, 51, 51, 51, 51, 53, 53, 36, 38,
-	38, 38, 37, 37, 37, 37, 37, 37, 37, 37,
-	37, 37, 37, 37, 37, 54, 56, 56, 56, 55,
-	55, 55, 55, 55, 58, 60, 60, 60, 59, 59,
-	59, 59, 59, 61, 61, 62, 62, 11, 11, 11,
-	10, 10, 10, 10, 20, 20, 20, 20, 20, 20,
-	20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-	20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-	20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-	20, 20, 20, 20, 20, 20, 20,
+	5, 6, 27, 27, 28, 28, 29, 29, 30, 30,
+	7, 14, 14, 12, 12, 16, 16, 17, 17, 17,
+	19, 19, 19, 19, 19, 19, 19, 19, 68, 68,
+	18, 38, 38, 38, 37, 37, 37, 37, 37, 37,
+	36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
+	13, 13, 13, 35, 35, 35, 35, 35, 35, 31,
+	31, 32, 32, 33, 33, 34, 34, 40, 40, 40,
+	40, 40, 40, 40, 40, 41, 41, 41, 41, 41,
+	41, 41, 41, 15, 9, 9, 8, 43, 43, 43,
+	43, 43, 43, 42, 51, 51, 51, 50, 50, 50,
+	50, 50, 50, 39, 39, 44, 44, 45, 45, 46,
+	22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
+	22, 22, 60, 60, 58, 58, 56, 56, 56, 59,
+	59, 57, 57, 57, 20, 20, 53, 53, 54, 54,
+	55, 52, 52, 61, 63, 63, 63, 62, 62, 62,
+	62, 62, 62, 64, 64, 47, 49, 49, 49, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 65, 67, 67, 67, 66, 66, 66, 66,
+	66, 69, 71, 71, 71, 70, 70, 70, 70, 70,
+	72, 72, 73, 73, 11, 11, 11, 10, 10, 10,
+	10, 23, 23, 23, 23, 23, 23, 23, 23, 23,
+	23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
+	23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
+	23, 23, 23, 23, 24, 24, 24, 24, 24, 24,
+	24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+	24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+	24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+	24, 24, 24, 24, 26, 26, 26, 26, 26, 26,
+	26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+	26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+	26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+	26, 26, 26, 26, 26, 25, 25, 25, 25, 25,
+	25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+	25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+	25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+	25, 25, 25, 25, 21, 21, 21, 21, 21, 21,
+	21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
+	21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
+	21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
+	21, 21, 21, 21, 21, 21, 21,
 }
-var protoR2 = [...]int{
 
+var protoR2 = [...]int{
 	0, 1, 1, 2, 0, 2, 1, 1, 1, 1,
 	1, 1, 1, 1, 1, 2, 1, 4, 3, 4,
-	4, 3, 1, 3, 5, 1, 3, 1, 3, 1,
-	1, 1, 1, 1, 1, 2, 2, 2, 2, 1,
-	2, 2, 1, 2, 3, 1, 2, 0, 1, 2,
-	2, 2, 2, 1, 3, 4, 5, 5, 3, 2,
-	5, 4, 5, 4, 1, 3, 3, 1, 3, 3,
-	3, 5, 5, 3, 5, 5, 1, 2, 6, 6,
-	6, 5, 7, 7, 7, 6, 3, 3, 1, 3,
-	8, 8, 8, 9, 9, 9, 5, 2, 1, 0,
-	1, 1, 1, 1, 2, 1, 5, 6, 7, 8,
-	5, 6, 6, 1, 1, 1, 1, 1, 1, 1,
-	1, 1, 1, 1, 1, 3, 4, 3, 1, 1,
-	3, 3, 3, 1, 1, 3, 3, 1, 2, 3,
-	1, 3, 1, 3, 3, 1, 5, 2, 1, 0,
-	1, 1, 1, 1, 2, 1, 4, 5, 5, 2,
-	1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
-	1, 1, 1, 2, 1, 5, 2, 1, 0, 1,
-	1, 1, 2, 1, 5, 2, 1, 0, 1, 1,
-	1, 2, 1, 10, 12, 2, 1, 2, 1, 0,
-	1, 1, 2, 1, 1, 1, 1, 1, 1, 1,
+	4, 3, 1, 3, 1, 3, 1, 3, 1, 3,
+	5, 1, 3, 1, 3, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 1, 2, 2, 1, 2,
+	3, 1, 2, 0, 1, 2, 2, 2, 2, 1,
+	3, 4, 5, 5, 3, 2, 5, 4, 5, 4,
+	1, 3, 3, 1, 3, 3, 5, 3, 5, 1,
+	2, 1, 2, 1, 2, 1, 2, 6, 6, 6,
+	7, 7, 7, 5, 6, 6, 6, 6, 7, 7,
+	7, 5, 6, 3, 1, 3, 3, 8, 8, 8,
+	9, 9, 9, 5, 2, 1, 0, 1, 1, 1,
+	1, 2, 1, 5, 6, 7, 8, 5, 6, 6,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 3, 4, 1, 3, 1, 3, 3, 1,
+	3, 1, 3, 3, 1, 2, 3, 1, 3, 1,
+	3, 1, 3, 5, 2, 1, 0, 1, 1, 1,
+	1, 2, 1, 4, 5, 5, 2, 1, 0, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	2, 1, 5, 2, 1, 0, 1, 1, 1, 2,
+	1, 5, 2, 1, 0, 1, 1, 1, 2, 1,
+	6, 8, 4, 3, 2, 1, 0, 1, 1, 2,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 	1, 1, 1, 1, 1, 1, 1,
 }
-var protoChk = [...]int{
 
-	-1000, -1, -2, -4, 8, -3, -5, -6, -7, -36,
-	-50, -54, -58, 52, 2, 9, 12, 13, 44, 43,
-	45, 46, -4, -3, 51, 52, -57, 10, 11, 4,
-	-22, -20, 7, 8, 9, 10, 11, 12, 13, 14,
+var protoChk = [...]int{
+	-1000, -1, -2, -4, 8, -3, -5, -6, -7, -47,
+	-61, -65, -69, 52, 2, 9, 12, 13, 44, 43,
+	45, 46, -4, -3, 51, 52, -68, 10, 11, 4,
+	-27, -21, 7, 8, 9, 10, 11, 12, 13, 14,
 	15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
 	25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
 	35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
-	45, 46, 47, 48, 49, -12, -13, -20, 65, -20,
-	-20, -23, -22, 59, -20, -57, 52, 4, -57, -57,
-	52, 59, 51, 59, -23, 54, 54, 54, -22, 54,
-	52, 52, 52, -20, -15, -16, -17, -57, -18, -20,
-	54, 6, 64, 63, 5, -13, 66, -38, -37, -29,
-	-50, -36, -54, -49, -32, -7, -31, -34, -42, 52,
-	2, 20, 19, 18, -23, 43, 44, 45, 39, 13,
-	37, -35, 42, -44, 38, -52, -51, -7, -53, -43,
-	52, 2, -20, 42, -44, -56, -55, -29, -32, 52,
-	2, -60, -59, -7, -61, 52, 2, 47, 52, -26,
-	-27, -28, 2, -24, -20, 67, 6, 16, 5, 6,
-	16, 5, 55, -37, 52, -23, 36, -23, 36, -23,
-	36, -20, -46, -45, 5, -20, -20, -46, -41, -57,
-	62, 55, -51, 52, 51, -48, -47, -19, 5, 64,
-	55, -55, 52, 55, -59, 52, -20, 55, -27, 60,
-	52, 60, 52, 53, -17, 62, -23, 2, -20, -20,
-	-20, -20, -20, -20, 51, 52, -14, 60, 67, 40,
-	54, 51, 52, 52, 60, -21, 23, 24, 25, 26,
-	27, 28, 29, 30, 31, 32, 33, 34, -19, 60,
-	52, 40, 5, 65, -16, 67, -17, 62, -26, 2,
-	68, 68, 51, 51, 51, 51, 51, 51, 5, 52,
-	-45, -9, -8, -12, 5, 41, -40, -39, -7, -30,
-	-33, 52, 2, -23, 36, 5, -57, 60, 52, -14,
-	-47, -19, 41, -62, 48, -23, 68, -25, 2, -15,
-	62, -26, 2, 61, 61, 5, 5, 5, 5, 5,
-	5, 52, -14, 68, 60, 51, 55, -39, 52, -20,
-	-20, 52, -14, -23, 52, 66, -23, 68, 60, 52,
-	68, -26, 2, 61, 61, 52, -14, 54, -14, 52,
-	-14, 54, -14, 52, -14, 54, -14, 52, -8, -15,
-	51, 51, 52, 61, 49, -15, 62, -15, 62, 61,
-	61, 52, -38, 54, 52, -38, 54, 52, -38, 54,
-	5, 5, 65, -26, 2, -26, 2, 55, -38, 55,
-	-38, 55, -38, 52, -14, 54, -14, -62, 61, 61,
-	61, 61, 55, 55, 55, 52, -38, 54, 66, 55,
-	-38, 52, 54, 55, -11, -10, -7, 52, 2, 55,
-	-10, 52,
+	45, 46, 47, 48, 49, -14, -12, -21, 65, -21,
+	-21, -31, -27, 59, -21, -68, 52, -68, -68, -68,
+	52, 59, 51, 59, -31, 54, 54, 54, -27, 54,
+	52, 52, 52, -27, -16, -17, -18, -68, -19, -21,
+	54, 6, 64, 63, 5, -14, 66, -49, -48, -40,
+	-61, -47, -65, -60, -43, -7, -42, -45, -53, 52,
+	2, 20, 19, 18, -32, 39, 37, -46, 42, -55,
+	-28, 59, 38, -23, 7, 8, 9, 10, 11, 12,
+	14, 15, 16, 17, 21, 22, 23, 24, 25, 26,
+	27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
+	40, 41, 46, 47, 48, 49, -63, -62, -7, -64,
+	-54, 52, 2, -26, 42, -55, 7, 8, 9, 10,
+	11, 12, 14, 15, 16, 17, 18, 19, 20, 21,
+	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+	43, 44, 45, 46, 47, 48, 49, -67, -66, -41,
+	-43, 52, 2, 20, 19, 18, -33, -29, 59, -24,
+	7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
+	17, 21, 22, 23, 24, 25, 26, 27, 28, 29,
+	30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
+	40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
+	-71, -70, -7, -72, 52, 2, 47, 52, -38, -37,
+	-36, 2, -13, -21, 67, 6, 16, 5, 6, 16,
+	5, 55, -48, 52, -31, 36, -31, 36, -31, 36,
+	-21, -58, -56, 5, -21, -21, -58, -52, -68, -27,
+	62, 59, 55, -62, 52, 51, -59, -57, -20, 5,
+	64, 55, -66, 52, -31, -31, -31, -21, -27, 59,
+	55, -70, 52, -21, 55, -38, 60, 52, 60, 52,
+	53, -18, 62, -31, 2, -21, -21, -21, -21, -21,
+	-21, 51, 52, -15, 67, 60, 40, 54, 51, 52,
+	52, 60, -22, 23, 24, 25, 26, 27, 28, 29,
+	30, 31, 32, 33, 34, -27, -20, 52, 60, 40,
+	5, -21, -21, -21, 51, -27, -73, 65, -17, 67,
+	-18, 62, -38, 2, 68, 68, 51, 51, 51, 51,
+	51, 51, 5, 52, -9, -8, -14, -58, 5, 41,
+	-51, -50, -7, -39, -44, 52, 2, -34, 36, -30,
+	59, -25, 7, 8, 9, 10, 11, 12, 14, 15,
+	16, 17, 21, 22, 23, 24, 25, 26, 27, 28,
+	29, 30, 31, 32, 33, 34, 35, 37, 38, 39,
+	40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
+	5, -52, 60, 52, -15, -59, -20, 41, 51, 51,
+	51, 5, 49, 48, -31, 68, -35, 2, -16, 62,
+	-38, 2, 61, 61, 5, 5, 5, 5, 5, 5,
+	52, -15, 68, 60, 51, 55, -50, 52, -21, -21,
+	-27, 59, 52, -15, -31, 52, 5, 5, 5, 52,
+	-15, -73, -31, 66, 68, 68, 60, -38, 2, 61,
+	61, 52, -15, 54, -15, 52, -15, 54, -15, 52,
+	-15, 54, -15, 52, -9, -16, 51, 51, -27, 52,
+	61, 52, -15, 52, -15, 52, -15, 52, 52, 54,
+	66, -35, 61, 61, 52, -49, 54, 52, -49, 54,
+	52, -49, 54, 5, 5, 52, 52, 52, -11, -10,
+	-7, 52, 2, 60, 60, 55, -49, 55, -49, 55,
+	-49, 52, -15, 54, -15, 55, -10, 52, -35, -35,
+	55, 55, 55, 52, -49, 54, 55, -49, 55,
 }
-var protoDef = [...]int{
 
+var protoDef = [...]int{
 	-2, -2, -2, -2, 0, 6, 7, 8, 9, 10,
 	11, 12, 13, 14, 16, 0, 0, 0, 0, 0,
-	0, 0, -2, 5, 0, 15, 0, 0, 0, 42,
-	0, 22, 204, 205, 206, 207, 208, 209, 210, 211,
-	212, 213, 214, 215, 216, 217, 218, 219, 220, 221,
-	222, 223, 224, 225, 226, 227, 228, 229, 230, 231,
-	232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
-	242, 243, 244, 245, 246, 0, 25, 27, 0, 0,
-	0, 0, 76, 0, 0, 0, 18, 43, 0, 0,
-	21, 0, 0, 0, 0, -2, -2, -2, 77, -2,
-	17, 19, 20, 23, 0, 29, 30, 31, 32, 33,
-	-2, 34, 0, 0, 39, 26, 28, 0, 160, 162,
-	163, 164, 165, 166, 167, 168, 169, 170, 171, 172,
-	174, 0, 0, 0, 0, 240, 241, 0, 236, 210,
-	234, 0, 239, 140, 235, 0, 148, 150, 151, 152,
-	153, 155, 0, 239, 142, 0, 177, 179, 180, 181,
-	183, 0, 186, 188, 189, 190, 192, 0, 24, 0,
-	45, 48, 53, 0, 64, 0, 35, 38, 41, 36,
-	37, 40, 158, 159, 173, 0, 233, 0, 233, 0,
-	233, 0, 0, 128, 129, 0, 0, 0, 0, 145,
-	0, 146, 147, 154, 0, 0, 133, 134, 137, 0,
-	175, 176, 182, 184, 185, 191, 0, 44, 46, 49,
-	50, 51, 52, 0, 59, -2, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 125, 0, 0, 0, 0,
-	-2, 0, 139, 143, 0, 0, 113, 114, 115, 116,
-	117, 118, 119, 120, 121, 122, 123, 124, 0, 0,
-	141, 0, 138, 0, 54, 0, 58, -2, 0, 53,
-	65, 66, 0, 0, 0, 0, 0, 0, 0, 126,
-	127, 0, 88, 0, 130, 131, 0, 98, 100, 101,
-	102, 103, 105, 0, 233, 0, 144, 0, 156, 0,
-	132, 135, 136, 0, 245, 196, 55, 0, 0, 67,
-	-2, 0, 53, 61, 63, 0, 0, 0, 0, 0,
-	0, 81, 0, 86, 0, 0, 96, 97, 104, 0,
-	0, 110, 0, 0, 157, 0, 195, 56, 0, 0,
-	57, 0, 53, 60, 62, 78, 0, -2, 0, 79,
-	0, -2, 0, 80, 0, -2, 0, 85, 87, 89,
-	0, 0, 111, 112, 0, 68, -2, 69, -2, 70,
-	73, 82, 0, -2, 83, 0, -2, 84, 0, -2,
-	0, 0, 0, 0, 53, 0, 53, 90, 0, 91,
-	0, 92, 0, 106, 0, -2, 0, 0, 71, 74,
-	72, 75, 93, 94, 95, 107, 0, -2, 0, 108,
-	0, 193, -2, 109, 0, 198, 200, 201, 203, 194,
-	197, 202,
+	0, 0, -2, 5, 0, 15, 0, 0, 0, 48,
+	0, 22, 374, 375, 376, 377, 378, 379, 380, 381,
+	382, 383, 384, 385, 386, 387, 388, 389, 390, 391,
+	392, 393, 394, 395, 396, 397, 398, 399, 400, 401,
+	402, 403, 404, 405, 406, 407, 408, 409, 410, 411,
+	412, 413, 414, 415, 416, 0, 31, 33, 0, 0,
+	0, 0, 79, 0, 0, 0, 18, 0, 0, 49,
+	21, 0, 0, 0, 0, -2, -2, -2, 80, -2,
+	17, 19, 20, 23, 0, 35, 36, 37, 38, 39,
+	-2, 40, 0, 0, 45, 32, 34, 0, 177, 179,
+	180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
+	191, 0, 0, 0, 0, 0, 0, 0, 0, 157,
+	81, 0, 247, 24, 221, 222, 223, 224, 225, 226,
+	227, 228, 229, 230, 231, 232, 233, 234, 235, 236,
+	237, 238, 239, 240, 241, 242, 243, 244, 245, 246,
+	248, 249, 250, 251, 252, 253, 0, 165, 167, 168,
+	169, 170, 172, 0, 0, 159, 294, 295, 296, 297,
+	298, 299, 300, 301, 302, 303, 304, 305, 306, 307,
+	308, 309, 310, 311, 312, 313, 314, 315, 316, 317,
+	318, 319, 320, 321, 322, 323, 324, 325, 326, 327,
+	328, 329, 330, 331, 332, 333, 334, 0, 194, 196,
+	197, 198, 200, 0, 0, 0, 0, 83, 0, 26,
+	254, 255, 256, 257, 258, 259, 260, 261, 262, 263,
+	264, 265, 266, 267, 268, 269, 270, 271, 272, 273,
+	274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
+	284, 285, 286, 287, 288, 289, 290, 291, 292, 293,
+	0, 203, 205, 206, 207, 209, 0, 30, 0, -2,
+	54, 59, 0, 70, 0, 41, 44, 47, 42, 43,
+	46, 175, 176, 190, 0, 403, 0, 403, 0, 403,
+	0, 0, 144, 146, 0, 0, 0, 0, 161, 82,
+	0, 0, 163, 164, 171, 0, 0, 149, 151, 154,
+	0, 192, 193, 199, 0, 0, 0, 0, 84, 0,
+	201, 202, 208, 0, 50, 52, 55, 56, 57, 58,
+	0, 65, -2, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 142, 0, 0, 0, 0, -2, 0, 156,
+	160, 0, 0, 130, 131, 132, 133, 134, 135, 136,
+	137, 138, 139, 140, 141, 25, 0, 158, 0, 0,
+	155, 0, 0, 0, 0, 27, 0, 0, 60, 0,
+	64, -2, 0, 59, 71, 72, 0, 0, 0, 0,
+	0, 0, 0, 143, 0, 104, 0, 145, 147, 148,
+	0, 115, 117, 118, 119, 120, 122, 0, 360, 85,
+	0, 28, 335, 336, 337, 338, 339, 340, 341, 342,
+	343, 344, 345, 346, 347, 348, 349, 350, 351, 352,
+	353, 354, 355, 356, 357, 358, 359, 361, 362, 363,
+	364, 365, 366, 367, 368, 369, 370, 371, 372, 373,
+	0, 162, 0, 173, 0, 150, 152, 153, 0, 0,
+	0, 0, 0, 415, 0, 61, 0, 0, 73, -2,
+	0, 59, 67, 69, 0, 0, 0, 0, 0, 0,
+	93, 0, 103, 0, 0, 113, 114, 121, 0, 0,
+	86, 0, 127, 0, 0, 174, 0, 0, 0, 101,
+	0, 0, 0, 213, 62, 63, 0, 0, 59, 66,
+	68, 87, 0, -2, 0, 88, 0, -2, 0, 89,
+	0, -2, 0, 94, 105, 106, 0, 0, 29, 128,
+	129, 95, 0, 96, 0, 97, 0, 102, 210, -2,
+	212, 74, 75, 77, 90, 0, -2, 91, 0, -2,
+	92, 0, -2, 0, 0, 98, 99, 100, 0, 215,
+	217, 218, 220, 0, 0, 107, 0, 108, 0, 109,
+	0, 123, 0, -2, 0, 211, 214, 219, 76, 78,
+	110, 111, 112, 124, 0, -2, 125, 0, 126,
 }
-var protoTok1 = [...]int{
 
+var protoTok1 = [...]int{
 	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
@@ -777,14 +837,15 @@ var protoTok1 = [...]int{
 	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 	3, 3, 3, 54, 3, 55, 77,
 }
-var protoTok2 = [...]int{
 
+var protoTok2 = [...]int{
 	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
 	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
 	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
 	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
 	42, 43, 44, 45, 46, 47, 48, 49, 50,
 }
+
 var protoTok3 = [...]int{
 	0,
 }
@@ -1128,1182 +1189,1362 @@ protodefault:
 
 	case 1:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:116
+//line proto.y:143
 		{
-			protoVAL.file = &fileNode{syntax: protoDollar[1].syn}
-			protoVAL.file.setRange(protoDollar[1].syn, protoDollar[1].syn)
+			protoVAL.file = ast.NewFileNode(protoDollar[1].syn, nil)
 			protolex.(*protoLex).res = protoVAL.file
 		}
 	case 2:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:121
+//line proto.y:147
 		{
-			protoVAL.file = &fileNode{decls: protoDollar[1].fileDecls}
-			if len(protoDollar[1].fileDecls) > 0 {
-				protoVAL.file.setRange(protoDollar[1].fileDecls[0], protoDollar[1].fileDecls[len(protoDollar[1].fileDecls)-1])
-			}
+			protoVAL.file = ast.NewFileNode(nil, protoDollar[1].fileDecls)
 			protolex.(*protoLex).res = protoVAL.file
 		}
 	case 3:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:128
+//line proto.y:151
 		{
-			protoVAL.file = &fileNode{syntax: protoDollar[1].syn, decls: protoDollar[2].fileDecls}
-			var end node
-			if len(protoDollar[2].fileDecls) > 0 {
-				end = protoDollar[2].fileDecls[len(protoDollar[2].fileDecls)-1]
-			} else {
-				end = protoDollar[1].syn
-			}
-			protoVAL.file.setRange(protoDollar[1].syn, end)
+			protoVAL.file = ast.NewFileNode(protoDollar[1].syn, protoDollar[2].fileDecls)
 			protolex.(*protoLex).res = protoVAL.file
 		}
 	case 4:
 		protoDollar = protoS[protopt-0 : protopt+1]
-//line proto.y:139
+//line proto.y:155
 		{
 		}
 	case 5:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:142
+//line proto.y:158
+		{
+			if protoDollar[2].fileDecl != nil {
+				protoVAL.fileDecls = append(protoDollar[1].fileDecls, protoDollar[2].fileDecl)
+			} else {
+				protoVAL.fileDecls = protoDollar[1].fileDecls
+			}
+		}
+	case 6:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:165
 		{
-			protoVAL.fileDecls = append(protoDollar[1].fileDecls, protoDollar[2].fileDecls...)
+			if protoDollar[1].fileDecl != nil {
+				protoVAL.fileDecls = []ast.FileElement{protoDollar[1].fileDecl}
+			} else {
+				protoVAL.fileDecls = nil
+			}
 		}
 	case 7:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:147
+//line proto.y:173
 		{
-			protoVAL.fileDecls = []*fileElement{{imp: protoDollar[1].imprt}}
+			protoVAL.fileDecl = protoDollar[1].imprt
 		}
 	case 8:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:150
+//line proto.y:176
 		{
-			protoVAL.fileDecls = []*fileElement{{pkg: protoDollar[1].pkg}}
+			protoVAL.fileDecl = protoDollar[1].pkg
 		}
 	case 9:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:153
+//line proto.y:179
 		{
-			protoVAL.fileDecls = []*fileElement{{option: protoDollar[1].opts[0]}}
+			protoVAL.fileDecl = protoDollar[1].opt
 		}
 	case 10:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:156
+//line proto.y:182
 		{
-			protoVAL.fileDecls = []*fileElement{{message: protoDollar[1].msg}}
+			protoVAL.fileDecl = protoDollar[1].msg
 		}
 	case 11:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:159
+//line proto.y:185
 		{
-			protoVAL.fileDecls = []*fileElement{{enum: protoDollar[1].en}}
+			protoVAL.fileDecl = protoDollar[1].en
 		}
 	case 12:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:162
+//line proto.y:188
 		{
-			protoVAL.fileDecls = []*fileElement{{extend: protoDollar[1].extend}}
+			protoVAL.fileDecl = protoDollar[1].extend
 		}
 	case 13:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:165
+//line proto.y:191
 		{
-			protoVAL.fileDecls = []*fileElement{{service: protoDollar[1].svc}}
+			protoVAL.fileDecl = protoDollar[1].svc
 		}
 	case 14:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:168
+//line proto.y:194
 		{
-			protoVAL.fileDecls = []*fileElement{{empty: protoDollar[1].b}}
+			protoVAL.fileDecl = ast.NewEmptyDeclNode(protoDollar[1].b)
 		}
 	case 15:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:171
+//line proto.y:197
 		{
+			protoVAL.fileDecl = nil
 		}
 	case 16:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:173
+//line proto.y:200
 		{
+			protoVAL.fileDecl = nil
 		}
 	case 17:
 		protoDollar = protoS[protopt-4 : protopt+1]
-//line proto.y:176
+//line proto.y:204
 		{
-			protoVAL.syn = &syntaxNode{syntax: protoDollar[3].str}
-			protoVAL.syn.setRange(protoDollar[1].id, protoDollar[4].b)
+			protoVAL.syn = ast.NewSyntaxNode(protoDollar[1].id.ToKeyword(), protoDollar[2].b, protoDollar[3].str.toStringValueNode(), protoDollar[4].b)
 		}
 	case 18:
 		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:181
+//line proto.y:208
 		{
-			protoVAL.imprt = &importNode{name: protoDollar[2].str}
-			protoVAL.imprt.setRange(protoDollar[1].id, protoDollar[3].b)
+			protoVAL.imprt = ast.NewImportNode(protoDollar[1].id.ToKeyword(), nil, nil, protoDollar[2].str.toStringValueNode(), protoDollar[3].b)
 		}
 	case 19:
 		protoDollar = protoS[protopt-4 : protopt+1]
-//line proto.y:185
+//line proto.y:211
 		{
-			protoVAL.imprt = &importNode{name: protoDollar[3].str, weak: true}
-			protoVAL.imprt.setRange(protoDollar[1].id, protoDollar[4].b)
+			protoVAL.imprt = ast.NewImportNode(protoDollar[1].id.ToKeyword(), nil, protoDollar[2].id.ToKeyword(), protoDollar[3].str.toStringValueNode(), protoDollar[4].b)
 		}
 	case 20:
 		protoDollar = protoS[protopt-4 : protopt+1]
-//line proto.y:189
+//line proto.y:214
 		{
-			protoVAL.imprt = &importNode{name: protoDollar[3].str, public: true}
-			protoVAL.imprt.setRange(protoDollar[1].id, protoDollar[4].b)
+			protoVAL.imprt = ast.NewImportNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id.ToKeyword(), nil, protoDollar[3].str.toStringValueNode(), protoDollar[4].b)
 		}
 	case 21:
 		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:194
+//line proto.y:218
 		{
-			protoVAL.pkg = &packageNode{name: protoDollar[2].cid}
-			protoVAL.pkg.setRange(protoDollar[1].id, protoDollar[3].b)
+			protoVAL.pkg = ast.NewPackageNode(protoDollar[1].id.ToKeyword(), protoDollar[2].cid.toIdentValueNode(nil), protoDollar[3].b)
 		}
 	case 22:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:199
+//line proto.y:222
 		{
-			protoVAL.cid = &compoundIdentNode{val: protoDollar[1].id.val}
-			protoVAL.cid.setRange(protoDollar[1].id, protoDollar[1].id)
+			protoVAL.cid = &identList{protoDollar[1].id, nil, nil}
 		}
 	case 23:
 		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:203
+//line proto.y:225
 		{
-			protoVAL.cid = &compoundIdentNode{val: protoDollar[1].cid.val + "." + protoDollar[3].id.val}
-			protoVAL.cid.setRange(protoDollar[1].cid, protoDollar[3].id)
+			protoVAL.cid = &identList{protoDollar[1].id, protoDollar[2].b, protoDollar[3].cid}
 		}
 	case 24:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:208
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:233
 		{
-			n := &optionNameNode{parts: protoDollar[2].optNm}
-			n.setRange(protoDollar[2].optNm[0], protoDollar[2].optNm[len(protoDollar[2].optNm)-1])
-			o := &optionNode{name: n, val: protoDollar[4].v}
-			o.setRange(protoDollar[1].id, protoDollar[5].b)
-			protoVAL.opts = []*optionNode{o}
+			protoVAL.cid = &identList{protoDollar[1].id, nil, nil}
 		}
-	case 26:
+	case 25:
 		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:218
+//line proto.y:236
 		{
-			protoVAL.optNm = append(protoDollar[1].optNm, protoDollar[3].optNm...)
+			protoVAL.cid = &identList{protoDollar[1].id, protoDollar[2].b, protoDollar[3].cid}
 		}
-	case 27:
+	case 26:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:223
+//line proto.y:240
 		{
-			nm := &compoundIdentNode{val: protoDollar[1].id.val}
-			nm.setRange(protoDollar[1].id, protoDollar[1].id)
-			protoVAL.optNm = toNameParts(nm)
+			protoVAL.cid = &identList{protoDollar[1].id, nil, nil}
 		}
-	case 28:
+	case 27:
 		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:228
+//line proto.y:243
 		{
-			p := &optionNamePartNode{text: protoDollar[2].cid, isExtension: true}
-			p.setRange(protoDollar[1].b, protoDollar[3].b)
-			protoVAL.optNm = []*optionNamePartNode{p}
+			protoVAL.cid = &identList{protoDollar[1].id, protoDollar[2].b, protoDollar[3].cid}
 		}
-	case 31:
+	case 28:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:237
+//line proto.y:247
 		{
-			protoVAL.v = protoDollar[1].str
+			protoVAL.cid = &identList{protoDollar[1].id, nil, nil}
 		}
-	case 33:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:241
-		{
-			if protoDollar[1].id.val == "true" {
-				protoVAL.v = &boolLiteralNode{identNode: protoDollar[1].id, val: true}
-			} else if protoDollar[1].id.val == "false" {
-				protoVAL.v = &boolLiteralNode{identNode: protoDollar[1].id, val: false}
-			} else if protoDollar[1].id.val == "inf" {
-				f := &compoundFloatNode{val: math.Inf(1)}
-				f.setRange(protoDollar[1].id, protoDollar[1].id)
-				protoVAL.v = f
-			} else if protoDollar[1].id.val == "nan" {
-				f := &compoundFloatNode{val: math.NaN()}
-				f.setRange(protoDollar[1].id, protoDollar[1].id)
-				protoVAL.v = f
-			} else {
-				protoVAL.v = protoDollar[1].id
-			}
+	case 29:
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:250
+		{
+			protoVAL.cid = &identList{protoDollar[1].id, protoDollar[2].b, protoDollar[3].cid}
 		}
-	case 34:
+	case 30:
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:254
+		{
+			refs, dots := protoDollar[2].optNms.toNodes()
+			optName := ast.NewOptionNameNode(refs, dots)
+			protoVAL.opt = ast.NewOptionNode(protoDollar[1].id.ToKeyword(), optName, protoDollar[3].b, protoDollar[4].v, protoDollar[5].b)
+		}
+	case 31:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:259
+//line proto.y:260
 		{
-			protoVAL.v = protoDollar[1].f
+			protoVAL.optNms = &fieldRefList{protoDollar[1].ref, nil, nil}
 		}
-	case 35:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:262
+	case 32:
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:263
 		{
-			f := &compoundFloatNode{val: -protoDollar[2].f.val}
-			f.setRange(protoDollar[1].b, protoDollar[2].f)
-			protoVAL.v = f
+			protoVAL.optNms = &fieldRefList{protoDollar[1].ref, protoDollar[2].b, protoDollar[3].optNms}
 		}
-	case 36:
-		protoDollar = protoS[protopt-2 : protopt+1]
+	case 33:
+		protoDollar = protoS[protopt-1 : protopt+1]
 //line proto.y:267
 		{
-			f := &compoundFloatNode{val: protoDollar[2].f.val}
-			f.setRange(protoDollar[1].b, protoDollar[2].f)
-			protoVAL.v = f
+			protoVAL.ref = ast.NewFieldReferenceNode(protoDollar[1].id)
 		}
-	case 37:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:272
+	case 34:
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:270
 		{
-			f := &compoundFloatNode{val: math.Inf(1)}
-			f.setRange(protoDollar[1].b, protoDollar[2].id)
-			protoVAL.v = f
+			protoVAL.ref = ast.NewExtensionFieldReferenceNode(protoDollar[1].b, protoDollar[2].tid, protoDollar[3].b)
 		}
-	case 38:
-		protoDollar = protoS[protopt-2 : protopt+1]
+	case 37:
+		protoDollar = protoS[protopt-1 : protopt+1]
 //line proto.y:277
 		{
-			f := &compoundFloatNode{val: math.Inf(-1)}
-			f.setRange(protoDollar[1].b, protoDollar[2].id)
-			protoVAL.v = f
+			protoVAL.v = protoDollar[1].str.toStringValueNode()
 		}
 	case 39:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:282
+//line proto.y:281
 		{
-			protoVAL.v = protoDollar[1].i
+			if protoDollar[1].id.Val == "true" || protoDollar[1].id.Val == "false" {
+				protoVAL.v = ast.NewBoolLiteralNode(protoDollar[1].id.ToKeyword())
+			} else if protoDollar[1].id.Val == "inf" || protoDollar[1].id.Val == "nan" {
+				protoVAL.v = ast.NewSpecialFloatLiteralNode(protoDollar[1].id.ToKeyword())
+			} else {
+				protoVAL.v = protoDollar[1].id
+			}
 		}
 	case 40:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:285
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:291
 		{
-			i := &compoundUintNode{val: protoDollar[2].i.val}
-			i.setRange(protoDollar[1].b, protoDollar[2].i)
-			protoVAL.v = i
+			protoVAL.v = protoDollar[1].f
 		}
 	case 41:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:290
+//line proto.y:294
 		{
-			if protoDollar[2].i.val > math.MaxInt64+1 {
-				// can't represent as int so treat as float literal
-				f := &compoundFloatNode{val: -float64(protoDollar[2].i.val)}
-				f.setRange(protoDollar[1].b, protoDollar[2].i)
-				protoVAL.v = f
-			} else {
-				i := &compoundIntNode{val: -int64(protoDollar[2].i.val)}
-				i.setRange(protoDollar[1].b, protoDollar[2].i)
-				protoVAL.v = i
-			}
+			protoVAL.v = ast.NewSignedFloatLiteralNode(protoDollar[1].b, protoDollar[2].f)
 		}
 	case 42:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:303
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:297
 		{
-			protoVAL.str = &compoundStringNode{val: protoDollar[1].s.val}
-			protoVAL.str.setRange(protoDollar[1].s, protoDollar[1].s)
+			protoVAL.v = ast.NewSignedFloatLiteralNode(protoDollar[1].b, protoDollar[2].f)
 		}
 	case 43:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:307
+//line proto.y:300
 		{
-			protoVAL.str = &compoundStringNode{val: protoDollar[1].str.val + protoDollar[2].s.val}
-			protoVAL.str.setRange(protoDollar[1].str, protoDollar[2].s)
+			f := ast.NewSpecialFloatLiteralNode(protoDollar[2].id.ToKeyword())
+			protoVAL.v = ast.NewSignedFloatLiteralNode(protoDollar[1].b, f)
 		}
 	case 44:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:312
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:304
+		{
+			f := ast.NewSpecialFloatLiteralNode(protoDollar[2].id.ToKeyword())
+			protoVAL.v = ast.NewSignedFloatLiteralNode(protoDollar[1].b, f)
+		}
+	case 45:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:308
 		{
-			a := &aggregateLiteralNode{elements: protoDollar[2].agg}
-			a.setRange(protoDollar[1].b, protoDollar[3].b)
-			protoVAL.v = a
+			protoVAL.v = protoDollar[1].i
 		}
 	case 46:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:319
+//line proto.y:311
 		{
-			protoVAL.agg = append(protoDollar[1].agg, protoDollar[2].agg...)
+			protoVAL.v = ast.NewPositiveUintLiteralNode(protoDollar[1].b, protoDollar[2].i)
 		}
 	case 47:
-		protoDollar = protoS[protopt-0 : protopt+1]
-//line proto.y:322
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:314
+		{
+			if protoDollar[2].i.Val > math.MaxInt64+1 {
+				// can't represent as int so treat as float literal
+				protoVAL.v = ast.NewSignedFloatLiteralNode(protoDollar[1].b, protoDollar[2].i)
+			} else {
+				protoVAL.v = ast.NewNegativeIntLiteralNode(protoDollar[1].b, protoDollar[2].i)
+			}
+		}
+	case 48:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:323
 		{
-			protoVAL.agg = nil
+			protoVAL.str = &stringList{protoDollar[1].s, nil}
 		}
 	case 49:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:327
+//line proto.y:326
 		{
-			protoVAL.agg = protoDollar[1].agg
+			protoVAL.str = &stringList{protoDollar[1].s, protoDollar[2].str}
 		}
 	case 50:
-		protoDollar = protoS[protopt-2 : protopt+1]
+		protoDollar = protoS[protopt-3 : protopt+1]
 //line proto.y:330
 		{
-			protoVAL.agg = protoDollar[1].agg
+			fields, delims := protoDollar[2].msgLit.toNodes()
+			protoVAL.v = ast.NewMessageLiteralNode(protoDollar[1].b, fields, delims, protoDollar[3].b)
 		}
 	case 51:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:333
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:335
 		{
+			if protoDollar[1].msgEntry != nil {
+				protoVAL.msgLit = &messageFieldList{protoDollar[1].msgEntry, nil}
+			} else {
+				protoVAL.msgLit = nil
+			}
 		}
 	case 52:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:335
+//line proto.y:342
 		{
+			if protoDollar[1].msgEntry != nil {
+				protoVAL.msgLit = &messageFieldList{protoDollar[1].msgEntry, protoDollar[2].msgLit}
+			} else {
+				protoVAL.msgLit = protoDollar[2].msgLit
+			}
 		}
 	case 53:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:337
+		protoDollar = protoS[protopt-0 : protopt+1]
+//line proto.y:349
 		{
+			protoVAL.msgLit = nil
 		}
 	case 54:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:340
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:353
 		{
-			a := &aggregateEntryNode{name: protoDollar[1].aggName, val: protoDollar[3].v}
-			a.setRange(protoDollar[1].aggName, protoDollar[3].v)
-			protoVAL.agg = []*aggregateEntryNode{a}
+			if protoDollar[1].msgField != nil {
+				protoVAL.msgEntry = &messageFieldEntry{protoDollar[1].msgField, nil}
+			} else {
+				protoVAL.msgEntry = nil
+			}
 		}
 	case 55:
-		protoDollar = protoS[protopt-4 : protopt+1]
-//line proto.y:345
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:360
 		{
-			s := &sliceLiteralNode{}
-			s.setRange(protoDollar[3].b, protoDollar[4].b)
-			a := &aggregateEntryNode{name: protoDollar[1].aggName, val: s}
-			a.setRange(protoDollar[1].aggName, protoDollar[4].b)
-			protoVAL.agg = []*aggregateEntryNode{a}
+			if protoDollar[1].msgField != nil {
+				protoVAL.msgEntry = &messageFieldEntry{protoDollar[1].msgField, protoDollar[2].b}
+			} else {
+				protoVAL.msgEntry = nil
+			}
 		}
 	case 56:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:352
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:367
 		{
-			s := &sliceLiteralNode{elements: protoDollar[4].sl}
-			s.setRange(protoDollar[3].b, protoDollar[5].b)
-			a := &aggregateEntryNode{name: protoDollar[1].aggName, val: s}
-			a.setRange(protoDollar[1].aggName, protoDollar[5].b)
-			protoVAL.agg = []*aggregateEntryNode{a}
+			if protoDollar[1].msgField != nil {
+				protoVAL.msgEntry = &messageFieldEntry{protoDollar[1].msgField, protoDollar[2].b}
+			} else {
+				protoVAL.msgEntry = nil
+			}
 		}
 	case 57:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:359
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:374
 		{
+			protoVAL.msgEntry = nil
 		}
 	case 58:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:361
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:377
 		{
-			a := &aggregateEntryNode{name: protoDollar[1].aggName, val: protoDollar[3].v}
-			a.setRange(protoDollar[1].aggName, protoDollar[3].v)
-			protoVAL.agg = []*aggregateEntryNode{a}
+			protoVAL.msgEntry = nil
 		}
 	case 59:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:366
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:380
 		{
-			a := &aggregateEntryNode{name: protoDollar[1].aggName, val: protoDollar[2].v}
-			a.setRange(protoDollar[1].aggName, protoDollar[2].v)
-			protoVAL.agg = []*aggregateEntryNode{a}
+			protoVAL.msgEntry = nil
 		}
 	case 60:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:371
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:384
 		{
-			s := &aggregateLiteralNode{elements: protoDollar[4].agg}
-			s.setRange(protoDollar[3].b, protoDollar[5].b)
-			a := &aggregateEntryNode{name: protoDollar[1].aggName, val: s}
-			a.setRange(protoDollar[1].aggName, protoDollar[5].b)
-			protoVAL.agg = []*aggregateEntryNode{a}
-		}
+			if protoDollar[1].ref != nil {
+				protoVAL.msgField = ast.NewMessageFieldNode(protoDollar[1].ref, protoDollar[2].b, protoDollar[3].v)
+			} else {
+				protoVAL.msgField = nil
+			}
+		}
 	case 61:
 		protoDollar = protoS[protopt-4 : protopt+1]
-//line proto.y:378
+//line proto.y:391
 		{
-			s := &aggregateLiteralNode{elements: protoDollar[3].agg}
-			s.setRange(protoDollar[2].b, protoDollar[4].b)
-			a := &aggregateEntryNode{name: protoDollar[1].aggName, val: s}
-			a.setRange(protoDollar[1].aggName, protoDollar[4].b)
-			protoVAL.agg = []*aggregateEntryNode{a}
+			if protoDollar[1].ref != nil {
+				val := ast.NewArrayLiteralNode(protoDollar[3].b, nil, nil, protoDollar[4].b)
+				protoVAL.msgField = ast.NewMessageFieldNode(protoDollar[1].ref, protoDollar[2].b, val)
+			} else {
+				protoVAL.msgField = nil
+			}
 		}
 	case 62:
 		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:385
+//line proto.y:399
 		{
+			if protoDollar[1].ref != nil {
+				vals, commas := protoDollar[4].sl.toNodes()
+				val := ast.NewArrayLiteralNode(protoDollar[3].b, vals, commas, protoDollar[5].b)
+				protoVAL.msgField = ast.NewMessageFieldNode(protoDollar[1].ref, protoDollar[2].b, val)
+			} else {
+				protoVAL.msgField = nil
+			}
 		}
 	case 63:
-		protoDollar = protoS[protopt-4 : protopt+1]
-//line proto.y:387
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:408
 		{
+			protoVAL.msgField = nil
 		}
 	case 64:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:390
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:411
 		{
-			n := &compoundIdentNode{val: protoDollar[1].id.val}
-			n.setRange(protoDollar[1].id, protoDollar[1].id)
-			protoVAL.aggName = &aggregateNameNode{name: n}
-			protoVAL.aggName.setRange(protoDollar[1].id, protoDollar[1].id)
+			if protoDollar[1].ref != nil {
+				protoVAL.msgField = ast.NewMessageFieldNode(protoDollar[1].ref, protoDollar[2].b, protoDollar[3].v)
+			} else {
+				protoVAL.msgField = nil
+			}
 		}
 	case 65:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:396
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:418
 		{
-			protoVAL.aggName = &aggregateNameNode{name: protoDollar[2].cid, isExtension: true}
-			protoVAL.aggName.setRange(protoDollar[1].b, protoDollar[3].b)
+			if protoDollar[1].ref != nil {
+				protoVAL.msgField = ast.NewMessageFieldNode(protoDollar[1].ref, nil, protoDollar[2].v)
+			} else {
+				protoVAL.msgField = nil
+			}
 		}
 	case 66:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:400
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:425
 		{
+			if protoDollar[1].ref != nil {
+				fields, delims := protoDollar[4].msgLit.toNodes()
+				msg := ast.NewMessageLiteralNode(protoDollar[3].b, fields, delims, protoDollar[5].b)
+				protoVAL.msgField = ast.NewMessageFieldNode(protoDollar[1].ref, protoDollar[2].b, msg)
+			} else {
+				protoVAL.msgField = nil
+			}
 		}
 	case 67:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:403
+		protoDollar = protoS[protopt-4 : protopt+1]
+//line proto.y:434
 		{
-			protoVAL.sl = []valueNode{protoDollar[1].v}
+			if protoDollar[1].ref != nil {
+				fields, delims := protoDollar[3].msgLit.toNodes()
+				msg := ast.NewMessageLiteralNode(protoDollar[2].b, fields, delims, protoDollar[4].b)
+				protoVAL.msgField = ast.NewMessageFieldNode(protoDollar[1].ref, nil, msg)
+			} else {
+				protoVAL.msgField = nil
+			}
 		}
 	case 68:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:406
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:443
 		{
-			protoVAL.sl = append(protoDollar[1].sl, protoDollar[3].v)
+			protoVAL.msgField = nil
 		}
 	case 69:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:409
+		protoDollar = protoS[protopt-4 : protopt+1]
+//line proto.y:446
 		{
-			protoVAL.sl = append(protoDollar[1].sl, protoDollar[3].v)
+			protoVAL.msgField = nil
 		}
 	case 70:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:412
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:450
 		{
-			s := &aggregateLiteralNode{elements: protoDollar[2].agg}
-			s.setRange(protoDollar[1].b, protoDollar[3].b)
-			protoVAL.sl = []valueNode{s}
+			protoVAL.ref = ast.NewFieldReferenceNode(protoDollar[1].id)
 		}
 	case 71:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:417
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:453
 		{
-			s := &aggregateLiteralNode{elements: protoDollar[4].agg}
-			s.setRange(protoDollar[3].b, protoDollar[5].b)
-			protoVAL.sl = append(protoDollar[1].sl, s)
+			protoVAL.ref = ast.NewExtensionFieldReferenceNode(protoDollar[1].b, protoDollar[2].tid, protoDollar[3].b)
 		}
 	case 72:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:422
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:456
 		{
-			s := &aggregateLiteralNode{elements: protoDollar[4].agg}
-			s.setRange(protoDollar[3].b, protoDollar[5].b)
-			protoVAL.sl = append(protoDollar[1].sl, s)
+			protoVAL.ref = nil
 		}
 	case 73:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:427
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:460
 		{
+			protoVAL.sl = &valueList{protoDollar[1].v, nil, nil}
 		}
 	case 74:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:429
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:463
 		{
+			protoVAL.sl = &valueList{protoDollar[1].v, protoDollar[2].b, protoDollar[3].sl}
 		}
 	case 75:
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:466
+		{
+			fields, delims := protoDollar[2].msgLit.toNodes()
+			msg := ast.NewMessageLiteralNode(protoDollar[1].b, fields, delims, protoDollar[3].b)
+			protoVAL.sl = &valueList{msg, nil, nil}
+		}
+	case 76:
 		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:431
+//line proto.y:471
 		{
+			fields, delims := protoDollar[2].msgLit.toNodes()
+			msg := ast.NewMessageLiteralNode(protoDollar[1].b, fields, delims, protoDollar[3].b)
+			protoVAL.sl = &valueList{msg, protoDollar[4].b, protoDollar[5].sl}
 		}
 	case 77:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:435
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:476
 		{
-			protoVAL.cid = &compoundIdentNode{val: "." + protoDollar[2].cid.val}
-			protoVAL.cid.setRange(protoDollar[1].b, protoDollar[2].cid)
+			protoVAL.sl = nil
 		}
 	case 78:
-		protoDollar = protoS[protopt-6 : protopt+1]
-//line proto.y:440
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:479
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id, required: true}
-			protoVAL.fld = &fieldNode{label: lbl, fldType: protoDollar[2].cid, name: protoDollar[3].id, tag: protoDollar[5].i}
-			protoVAL.fld.setRange(protoDollar[1].id, protoDollar[6].b)
+			protoVAL.sl = protoDollar[5].sl
 		}
 	case 79:
-		protoDollar = protoS[protopt-6 : protopt+1]
-//line proto.y:445
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:483
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id}
-			protoVAL.fld = &fieldNode{label: lbl, fldType: protoDollar[2].cid, name: protoDollar[3].id, tag: protoDollar[5].i}
-			protoVAL.fld.setRange(protoDollar[1].id, protoDollar[6].b)
+			protoVAL.tid = protoDollar[1].cid.toIdentValueNode(nil)
 		}
 	case 80:
-		protoDollar = protoS[protopt-6 : protopt+1]
-//line proto.y:450
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:486
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id, repeated: true}
-			protoVAL.fld = &fieldNode{label: lbl, fldType: protoDollar[2].cid, name: protoDollar[3].id, tag: protoDollar[5].i}
-			protoVAL.fld.setRange(protoDollar[1].id, protoDollar[6].b)
+			protoVAL.tid = protoDollar[2].cid.toIdentValueNode(protoDollar[1].b)
 		}
 	case 81:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:455
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:490
 		{
-			protoVAL.fld = &fieldNode{fldType: protoDollar[1].cid, name: protoDollar[2].id, tag: protoDollar[4].i}
-			protoVAL.fld.setRange(protoDollar[1].cid, protoDollar[5].b)
+			protoVAL.tid = protoDollar[1].cid.toIdentValueNode(nil)
 		}
 	case 82:
-		protoDollar = protoS[protopt-7 : protopt+1]
-//line proto.y:459
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:493
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id, required: true}
-			protoVAL.fld = &fieldNode{label: lbl, fldType: protoDollar[2].cid, name: protoDollar[3].id, tag: protoDollar[5].i, options: protoDollar[6].cmpctOpts}
-			protoVAL.fld.setRange(protoDollar[1].id, protoDollar[7].b)
+			protoVAL.tid = protoDollar[2].cid.toIdentValueNode(protoDollar[1].b)
 		}
 	case 83:
-		protoDollar = protoS[protopt-7 : protopt+1]
-//line proto.y:464
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:497
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id}
-			protoVAL.fld = &fieldNode{label: lbl, fldType: protoDollar[2].cid, name: protoDollar[3].id, tag: protoDollar[5].i, options: protoDollar[6].cmpctOpts}
-			protoVAL.fld.setRange(protoDollar[1].id, protoDollar[7].b)
+			protoVAL.tid = protoDollar[1].cid.toIdentValueNode(nil)
 		}
 	case 84:
-		protoDollar = protoS[protopt-7 : protopt+1]
-//line proto.y:469
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:500
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id, repeated: true}
-			protoVAL.fld = &fieldNode{label: lbl, fldType: protoDollar[2].cid, name: protoDollar[3].id, tag: protoDollar[5].i, options: protoDollar[6].cmpctOpts}
-			protoVAL.fld.setRange(protoDollar[1].id, protoDollar[7].b)
+			protoVAL.tid = protoDollar[2].cid.toIdentValueNode(protoDollar[1].b)
 		}
 	case 85:
-		protoDollar = protoS[protopt-6 : protopt+1]
-//line proto.y:474
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:504
 		{
-			protoVAL.fld = &fieldNode{fldType: protoDollar[1].cid, name: protoDollar[2].id, tag: protoDollar[4].i, options: protoDollar[5].cmpctOpts}
-			protoVAL.fld.setRange(protoDollar[1].cid, protoDollar[6].b)
+			protoVAL.tid = protoDollar[1].cid.toIdentValueNode(nil)
 		}
 	case 86:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:479
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:507
 		{
-			protoVAL.cmpctOpts = &compactOptionsNode{decls: protoDollar[2].opts}
-			protoVAL.cmpctOpts.setRange(protoDollar[1].b, protoDollar[3].b)
+			protoVAL.tid = protoDollar[2].cid.toIdentValueNode(protoDollar[1].b)
 		}
 	case 87:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:484
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:511
+		{
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, nil, protoDollar[6].b)
+		}
+	case 88:
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:514
 		{
-			protoVAL.opts = append(protoDollar[1].opts, protoDollar[3].opts...)
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, nil, protoDollar[6].b)
 		}
 	case 89:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:489
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:517
 		{
-			n := &optionNameNode{parts: protoDollar[1].optNm}
-			n.setRange(protoDollar[1].optNm[0], protoDollar[1].optNm[len(protoDollar[1].optNm)-1])
-			o := &optionNode{name: n, val: protoDollar[3].v}
-			o.setRange(protoDollar[1].optNm[0], protoDollar[3].v)
-			protoVAL.opts = []*optionNode{o}
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, nil, protoDollar[6].b)
 		}
 	case 90:
-		protoDollar = protoS[protopt-8 : protopt+1]
-//line proto.y:497
+		protoDollar = protoS[protopt-7 : protopt+1]
+//line proto.y:520
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id, required: true}
-			protoVAL.grp = &groupNode{groupKeyword: protoDollar[2].id, label: lbl, name: protoDollar[3].id, tag: protoDollar[5].i, decls: protoDollar[7].msgDecls}
-			protoVAL.grp.setRange(protoDollar[1].id, protoDollar[8].b)
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, protoDollar[6].cmpctOpts, protoDollar[7].b)
 		}
 	case 91:
-		protoDollar = protoS[protopt-8 : protopt+1]
-//line proto.y:502
+		protoDollar = protoS[protopt-7 : protopt+1]
+//line proto.y:523
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id}
-			protoVAL.grp = &groupNode{groupKeyword: protoDollar[2].id, label: lbl, name: protoDollar[3].id, tag: protoDollar[5].i, decls: protoDollar[7].msgDecls}
-			protoVAL.grp.setRange(protoDollar[1].id, protoDollar[8].b)
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, protoDollar[6].cmpctOpts, protoDollar[7].b)
 		}
 	case 92:
-		protoDollar = protoS[protopt-8 : protopt+1]
-//line proto.y:507
+		protoDollar = protoS[protopt-7 : protopt+1]
+//line proto.y:526
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id, repeated: true}
-			protoVAL.grp = &groupNode{groupKeyword: protoDollar[2].id, label: lbl, name: protoDollar[3].id, tag: protoDollar[5].i, decls: protoDollar[7].msgDecls}
-			protoVAL.grp.setRange(protoDollar[1].id, protoDollar[8].b)
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, protoDollar[6].cmpctOpts, protoDollar[7].b)
 		}
 	case 93:
-		protoDollar = protoS[protopt-9 : protopt+1]
-//line proto.y:512
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:529
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id, required: true}
-			protoVAL.grp = &groupNode{groupKeyword: protoDollar[2].id, label: lbl, name: protoDollar[3].id, tag: protoDollar[5].i, options: protoDollar[6].cmpctOpts, decls: protoDollar[8].msgDecls}
-			protoVAL.grp.setRange(protoDollar[1].id, protoDollar[9].b)
+			protoVAL.fld = ast.NewFieldNode(nil, protoDollar[1].tid, protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, nil, protoDollar[5].b)
 		}
 	case 94:
-		protoDollar = protoS[protopt-9 : protopt+1]
-//line proto.y:517
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:532
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id}
-			protoVAL.grp = &groupNode{groupKeyword: protoDollar[2].id, label: lbl, name: protoDollar[3].id, tag: protoDollar[5].i, options: protoDollar[6].cmpctOpts, decls: protoDollar[8].msgDecls}
-			protoVAL.grp.setRange(protoDollar[1].id, protoDollar[9].b)
+			protoVAL.fld = ast.NewFieldNode(nil, protoDollar[1].tid, protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, protoDollar[5].cmpctOpts, protoDollar[6].b)
 		}
 	case 95:
-		protoDollar = protoS[protopt-9 : protopt+1]
-//line proto.y:522
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:536
 		{
-			lbl := fieldLabel{identNode: protoDollar[1].id, repeated: true}
-			protoVAL.grp = &groupNode{groupKeyword: protoDollar[2].id, label: lbl, name: protoDollar[3].id, tag: protoDollar[5].i, options: protoDollar[6].cmpctOpts, decls: protoDollar[8].msgDecls}
-			protoVAL.grp.setRange(protoDollar[1].id, protoDollar[9].b)
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, nil, protoDollar[6].b)
 		}
 	case 96:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:528
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:539
 		{
-			protoVAL.oo = &oneOfNode{name: protoDollar[2].id, decls: protoDollar[4].ooDecls}
-			protoVAL.oo.setRange(protoDollar[1].id, protoDollar[5].b)
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, nil, protoDollar[6].b)
 		}
 	case 97:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:533
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:542
+		{
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, nil, protoDollar[6].b)
+		}
+	case 98:
+		protoDollar = protoS[protopt-7 : protopt+1]
+//line proto.y:545
 		{
-			protoVAL.ooDecls = append(protoDollar[1].ooDecls, protoDollar[2].ooDecls...)
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, protoDollar[6].cmpctOpts, protoDollar[7].b)
 		}
 	case 99:
-		protoDollar = protoS[protopt-0 : protopt+1]
-//line proto.y:537
+		protoDollar = protoS[protopt-7 : protopt+1]
+//line proto.y:548
 		{
-			protoVAL.ooDecls = nil
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, protoDollar[6].cmpctOpts, protoDollar[7].b)
 		}
 	case 100:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:541
+		protoDollar = protoS[protopt-7 : protopt+1]
+//line proto.y:551
 		{
-			protoVAL.ooDecls = []*oneOfElement{{option: protoDollar[1].opts[0]}}
+			protoVAL.fld = ast.NewFieldNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, protoDollar[6].cmpctOpts, protoDollar[7].b)
 		}
 	case 101:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:544
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:554
 		{
-			protoVAL.ooDecls = []*oneOfElement{{field: protoDollar[1].fld}}
+			protoVAL.fld = ast.NewFieldNode(nil, protoDollar[1].tid, protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, nil, protoDollar[5].b)
 		}
 	case 102:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:547
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:557
 		{
-			protoVAL.ooDecls = []*oneOfElement{{group: protoDollar[1].grp}}
+			protoVAL.fld = ast.NewFieldNode(nil, protoDollar[1].tid, protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, protoDollar[5].cmpctOpts, protoDollar[6].b)
 		}
 	case 103:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:550
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:561
 		{
-			protoVAL.ooDecls = []*oneOfElement{{empty: protoDollar[1].b}}
+			opts, commas := protoDollar[2].opts.toNodes()
+			protoVAL.cmpctOpts = ast.NewCompactOptionsNode(protoDollar[1].b, opts, commas, protoDollar[3].b)
 		}
 	case 104:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:553
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:566
 		{
+			protoVAL.opts = &compactOptionList{protoDollar[1].opt, nil, nil}
 		}
 	case 105:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:555
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:569
 		{
+			protoVAL.opts = &compactOptionList{protoDollar[1].opt, protoDollar[2].b, protoDollar[3].opts}
 		}
 	case 106:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:558
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:573
 		{
-			protoVAL.fld = &fieldNode{fldType: protoDollar[1].cid, name: protoDollar[2].id, tag: protoDollar[4].i}
-			protoVAL.fld.setRange(protoDollar[1].cid, protoDollar[5].b)
+			refs, dots := protoDollar[1].optNms.toNodes()
+			optName := ast.NewOptionNameNode(refs, dots)
+			protoVAL.opt = ast.NewCompactOptionNode(optName, protoDollar[2].b, protoDollar[3].v)
 		}
 	case 107:
-		protoDollar = protoS[protopt-6 : protopt+1]
-//line proto.y:562
+		protoDollar = protoS[protopt-8 : protopt+1]
+//line proto.y:579
 		{
-			protoVAL.fld = &fieldNode{fldType: protoDollar[1].cid, name: protoDollar[2].id, tag: protoDollar[4].i, options: protoDollar[5].cmpctOpts}
-			protoVAL.fld.setRange(protoDollar[1].cid, protoDollar[6].b)
+			protoVAL.grp = ast.NewGroupNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id.ToKeyword(), protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, nil, protoDollar[6].b, protoDollar[7].msgDecls, protoDollar[8].b)
 		}
 	case 108:
-		protoDollar = protoS[protopt-7 : protopt+1]
-//line proto.y:567
+		protoDollar = protoS[protopt-8 : protopt+1]
+//line proto.y:582
 		{
-			protoVAL.grp = &groupNode{groupKeyword: protoDollar[1].id, name: protoDollar[2].id, tag: protoDollar[4].i, decls: protoDollar[6].msgDecls}
-			protoVAL.grp.setRange(protoDollar[1].id, protoDollar[7].b)
+			protoVAL.grp = ast.NewGroupNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id.ToKeyword(), protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, nil, protoDollar[6].b, protoDollar[7].msgDecls, protoDollar[8].b)
 		}
 	case 109:
 		protoDollar = protoS[protopt-8 : protopt+1]
-//line proto.y:571
+//line proto.y:585
 		{
-			protoVAL.grp = &groupNode{groupKeyword: protoDollar[1].id, name: protoDollar[2].id, tag: protoDollar[4].i, options: protoDollar[5].cmpctOpts, decls: protoDollar[7].msgDecls}
-			protoVAL.grp.setRange(protoDollar[1].id, protoDollar[8].b)
+			protoVAL.grp = ast.NewGroupNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id.ToKeyword(), protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, nil, protoDollar[6].b, protoDollar[7].msgDecls, protoDollar[8].b)
 		}
 	case 110:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:576
+		protoDollar = protoS[protopt-9 : protopt+1]
+//line proto.y:588
 		{
-			protoVAL.mapFld = &mapFieldNode{mapType: protoDollar[1].mapType, name: protoDollar[2].id, tag: protoDollar[4].i}
-			protoVAL.mapFld.setRange(protoDollar[1].mapType, protoDollar[5].b)
+			protoVAL.grp = ast.NewGroupNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id.ToKeyword(), protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, protoDollar[6].cmpctOpts, protoDollar[7].b, protoDollar[8].msgDecls, protoDollar[9].b)
 		}
 	case 111:
-		protoDollar = protoS[protopt-6 : protopt+1]
-//line proto.y:580
+		protoDollar = protoS[protopt-9 : protopt+1]
+//line proto.y:591
 		{
-			protoVAL.mapFld = &mapFieldNode{mapType: protoDollar[1].mapType, name: protoDollar[2].id, tag: protoDollar[4].i, options: protoDollar[5].cmpctOpts}
-			protoVAL.mapFld.setRange(protoDollar[1].mapType, protoDollar[6].b)
+			protoVAL.grp = ast.NewGroupNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id.ToKeyword(), protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, protoDollar[6].cmpctOpts, protoDollar[7].b, protoDollar[8].msgDecls, protoDollar[9].b)
 		}
 	case 112:
-		protoDollar = protoS[protopt-6 : protopt+1]
-//line proto.y:585
+		protoDollar = protoS[protopt-9 : protopt+1]
+//line proto.y:594
 		{
-			protoVAL.mapType = &mapTypeNode{mapKeyword: protoDollar[1].id, keyType: protoDollar[3].id, valueType: protoDollar[5].cid}
-			protoVAL.mapType.setRange(protoDollar[1].id, protoDollar[6].b)
+			protoVAL.grp = ast.NewGroupNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id.ToKeyword(), protoDollar[3].id, protoDollar[4].b, protoDollar[5].i, protoDollar[6].cmpctOpts, protoDollar[7].b, protoDollar[8].msgDecls, protoDollar[9].b)
 		}
-	case 125:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:603
+	case 113:
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:598
 		{
-			protoVAL.ext = &extensionRangeNode{ranges: protoDollar[2].rngs}
-			protoVAL.ext.setRange(protoDollar[1].id, protoDollar[3].b)
+			protoVAL.oo = ast.NewOneOfNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id, protoDollar[3].b, protoDollar[4].ooDecls, protoDollar[5].b)
 		}
-	case 126:
-		protoDollar = protoS[protopt-4 : protopt+1]
-//line proto.y:607
+	case 114:
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:602
 		{
-			protoVAL.ext = &extensionRangeNode{ranges: protoDollar[2].rngs, options: protoDollar[3].cmpctOpts}
-			protoVAL.ext.setRange(protoDollar[1].id, protoDollar[4].b)
+			if protoDollar[2].ooDecl != nil {
+				protoVAL.ooDecls = append(protoDollar[1].ooDecls, protoDollar[2].ooDecl)
+			} else {
+				protoVAL.ooDecls = protoDollar[1].ooDecls
+			}
 		}
-	case 127:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:612
+	case 115:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:609
 		{
-			protoVAL.rngs = append(protoDollar[1].rngs, protoDollar[3].rngs...)
+			if protoDollar[1].ooDecl != nil {
+				protoVAL.ooDecls = []ast.OneOfElement{protoDollar[1].ooDecl}
+			} else {
+				protoVAL.ooDecls = nil
+			}
 		}
-	case 129:
+	case 116:
+		protoDollar = protoS[protopt-0 : protopt+1]
+//line proto.y:616
+		{
+			protoVAL.ooDecls = nil
+		}
+	case 117:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:617
+//line proto.y:620
 		{
-			r := &rangeNode{startNode: protoDollar[1].i}
-			r.setRange(protoDollar[1].i, protoDollar[1].i)
-			protoVAL.rngs = []*rangeNode{r}
+			protoVAL.ooDecl = protoDollar[1].opt
 		}
-	case 130:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:622
+	case 118:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:623
 		{
-			r := &rangeNode{startNode: protoDollar[1].i, endNode: protoDollar[3].i}
-			r.setRange(protoDollar[1].i, protoDollar[3].i)
-			protoVAL.rngs = []*rangeNode{r}
+			protoVAL.ooDecl = protoDollar[1].fld
 		}
-	case 131:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:627
+	case 119:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:626
 		{
-			r := &rangeNode{startNode: protoDollar[1].i, endNode: protoDollar[3].id, endMax: true}
-			r.setRange(protoDollar[1].i, protoDollar[3].id)
-			protoVAL.rngs = []*rangeNode{r}
+			protoVAL.ooDecl = protoDollar[1].grp
 		}
-	case 132:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:633
+	case 120:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:629
+		{
+			protoVAL.ooDecl = ast.NewEmptyDeclNode(protoDollar[1].b)
+		}
+	case 121:
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:632
 		{
-			protoVAL.rngs = append(protoDollar[1].rngs, protoDollar[3].rngs...)
+			protoVAL.ooDecl = nil
 		}
-	case 134:
+	case 122:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:638
+//line proto.y:635
 		{
-			r := &rangeNode{startNode: protoDollar[1].il}
-			r.setRange(protoDollar[1].il, protoDollar[1].il)
-			protoVAL.rngs = []*rangeNode{r}
+			protoVAL.ooDecl = nil
 		}
-	case 135:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:643
+	case 123:
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:639
 		{
-			r := &rangeNode{startNode: protoDollar[1].il, endNode: protoDollar[3].il}
-			r.setRange(protoDollar[1].il, protoDollar[3].il)
-			protoVAL.rngs = []*rangeNode{r}
+			protoVAL.fld = ast.NewFieldNode(nil, protoDollar[1].tid, protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, nil, protoDollar[5].b)
 		}
-	case 136:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:648
+	case 124:
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:642
 		{
-			r := &rangeNode{startNode: protoDollar[1].il, endNode: protoDollar[3].id, endMax: true}
-			r.setRange(protoDollar[1].il, protoDollar[3].id)
-			protoVAL.rngs = []*rangeNode{r}
+			protoVAL.fld = ast.NewFieldNode(nil, protoDollar[1].tid, protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, protoDollar[5].cmpctOpts, protoDollar[6].b)
 		}
-	case 137:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:654
+	case 125:
+		protoDollar = protoS[protopt-7 : protopt+1]
+//line proto.y:646
 		{
-			i := &compoundIntNode{val: int64(protoDollar[1].i.val)}
-			i.setRange(protoDollar[1].i, protoDollar[1].i)
-			protoVAL.il = i
+			protoVAL.grp = ast.NewGroupNode(nil, protoDollar[1].id.ToKeyword(), protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, nil, protoDollar[5].b, protoDollar[6].msgDecls, protoDollar[7].b)
 		}
-	case 138:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:659
+	case 126:
+		protoDollar = protoS[protopt-8 : protopt+1]
+//line proto.y:649
 		{
-			if protoDollar[2].i.val > math.MaxInt64+1 {
-				lexError(protolex, protoDollar[2].i.start(), fmt.Sprintf("numeric constant %d would underflow 64-bit signed int (allowed range is %d to %d)", protoDollar[2].i.val, int64(math.MinInt64), int64(math.MaxInt64)))
-			}
-			i := &compoundIntNode{val: -int64(protoDollar[2].i.val)}
-			i.setRange(protoDollar[1].b, protoDollar[2].i)
-			protoVAL.il = i
+			protoVAL.grp = ast.NewGroupNode(nil, protoDollar[1].id.ToKeyword(), protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, protoDollar[5].cmpctOpts, protoDollar[6].b, protoDollar[7].msgDecls, protoDollar[8].b)
 		}
-	case 139:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:668
+	case 127:
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:653
+		{
+			protoVAL.mapFld = ast.NewMapFieldNode(protoDollar[1].mapType, protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, nil, protoDollar[5].b)
+		}
+	case 128:
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:656
+		{
+			protoVAL.mapFld = ast.NewMapFieldNode(protoDollar[1].mapType, protoDollar[2].id, protoDollar[3].b, protoDollar[4].i, protoDollar[5].cmpctOpts, protoDollar[6].b)
+		}
+	case 129:
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:660
 		{
-			protoVAL.resvd = &reservedNode{ranges: protoDollar[2].rngs}
-			protoVAL.resvd.setRange(protoDollar[1].id, protoDollar[3].b)
+			protoVAL.mapType = ast.NewMapTypeNode(protoDollar[1].id.ToKeyword(), protoDollar[2].b, protoDollar[3].id, protoDollar[4].b, protoDollar[5].tid, protoDollar[6].b)
 		}
-	case 141:
+	case 142:
 		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:674
+//line proto.y:677
 		{
-			protoVAL.resvd = &reservedNode{ranges: protoDollar[2].rngs}
-			protoVAL.resvd.setRange(protoDollar[1].id, protoDollar[3].b)
+			ranges, commas := protoDollar[2].rngs.toNodes()
+			protoVAL.ext = ast.NewExtensionRangeNode(protoDollar[1].id.ToKeyword(), ranges, commas, nil, protoDollar[3].b)
 		}
 	case 143:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:680
+		protoDollar = protoS[protopt-4 : protopt+1]
+//line proto.y:681
 		{
-			protoVAL.resvd = &reservedNode{names: protoDollar[2].names}
-			protoVAL.resvd.setRange(protoDollar[1].id, protoDollar[3].b)
+			ranges, commas := protoDollar[2].rngs.toNodes()
+			protoVAL.ext = ast.NewExtensionRangeNode(protoDollar[1].id.ToKeyword(), ranges, commas, protoDollar[3].cmpctOpts, protoDollar[4].b)
 		}
 	case 144:
-		protoDollar = protoS[protopt-3 : protopt+1]
-//line proto.y:685
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:686
 		{
-			protoVAL.names = append(protoDollar[1].names, protoDollar[3].str)
+			protoVAL.rngs = &rangeList{protoDollar[1].rng, nil, nil}
 		}
 	case 145:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:688
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:689
 		{
-			protoVAL.names = []*compoundStringNode{protoDollar[1].str}
+			protoVAL.rngs = &rangeList{protoDollar[1].rng, protoDollar[2].b, protoDollar[3].rngs}
 		}
 	case 146:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:692
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:693
 		{
-			protoVAL.en = &enumNode{name: protoDollar[2].id, decls: protoDollar[4].enDecls}
-			protoVAL.en.setRange(protoDollar[1].id, protoDollar[5].b)
+			protoVAL.rng = ast.NewRangeNode(protoDollar[1].i, nil, nil, nil)
 		}
 	case 147:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:697
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:696
+		{
+			protoVAL.rng = ast.NewRangeNode(protoDollar[1].i, protoDollar[2].id.ToKeyword(), protoDollar[3].i, nil)
+		}
+	case 148:
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:699
 		{
-			protoVAL.enDecls = append(protoDollar[1].enDecls, protoDollar[2].enDecls...)
+			protoVAL.rng = ast.NewRangeNode(protoDollar[1].i, protoDollar[2].id.ToKeyword(), nil, protoDollar[3].id.ToKeyword())
 		}
 	case 149:
-		protoDollar = protoS[protopt-0 : protopt+1]
-//line proto.y:701
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:703
 		{
-			protoVAL.enDecls = nil
+			protoVAL.rngs = &rangeList{protoDollar[1].rng, nil, nil}
 		}
 	case 150:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:705
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:706
 		{
-			protoVAL.enDecls = []*enumElement{{option: protoDollar[1].opts[0]}}
+			protoVAL.rngs = &rangeList{protoDollar[1].rng, protoDollar[2].b, protoDollar[3].rngs}
 		}
 	case 151:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:708
+//line proto.y:710
 		{
-			protoVAL.enDecls = []*enumElement{{value: protoDollar[1].env}}
+			protoVAL.rng = ast.NewRangeNode(protoDollar[1].il, nil, nil, nil)
 		}
 	case 152:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:711
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:713
 		{
-			protoVAL.enDecls = []*enumElement{{reserved: protoDollar[1].resvd}}
+			protoVAL.rng = ast.NewRangeNode(protoDollar[1].il, protoDollar[2].id.ToKeyword(), protoDollar[3].il, nil)
 		}
 	case 153:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:714
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:716
 		{
-			protoVAL.enDecls = []*enumElement{{empty: protoDollar[1].b}}
+			protoVAL.rng = ast.NewRangeNode(protoDollar[1].il, protoDollar[2].id.ToKeyword(), nil, protoDollar[3].id.ToKeyword())
 		}
 	case 154:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:717
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:720
 		{
+			protoVAL.il = protoDollar[1].i
 		}
 	case 155:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:719
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:723
 		{
+			protoVAL.il = ast.NewNegativeIntLiteralNode(protoDollar[1].b, protoDollar[2].i)
 		}
 	case 156:
-		protoDollar = protoS[protopt-4 : protopt+1]
-//line proto.y:722
-		{
-			protoVAL.env = &enumValueNode{name: protoDollar[1].id, number: protoDollar[3].il}
-			protoVAL.env.setRange(protoDollar[1].id, protoDollar[4].b)
-		}
-	case 157:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:726
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:727
 		{
-			protoVAL.env = &enumValueNode{name: protoDollar[1].id, number: protoDollar[3].il, options: protoDollar[4].cmpctOpts}
-			protoVAL.env.setRange(protoDollar[1].id, protoDollar[5].b)
+			ranges, commas := protoDollar[2].rngs.toNodes()
+			protoVAL.resvd = ast.NewReservedRangesNode(protoDollar[1].id.ToKeyword(), ranges, commas, protoDollar[3].b)
 		}
 	case 158:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:731
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:733
 		{
-			protoVAL.msg = &messageNode{name: protoDollar[2].id, decls: protoDollar[4].msgDecls}
-			protoVAL.msg.setRange(protoDollar[1].id, protoDollar[5].b)
+			ranges, commas := protoDollar[2].rngs.toNodes()
+			protoVAL.resvd = ast.NewReservedRangesNode(protoDollar[1].id.ToKeyword(), ranges, commas, protoDollar[3].b)
 		}
-	case 159:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:736
+	case 160:
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:739
 		{
-			protoVAL.msgDecls = append(protoDollar[1].msgDecls, protoDollar[2].msgDecls...)
+			names, commas := protoDollar[2].names.toNodes()
+			protoVAL.resvd = ast.NewReservedNamesNode(protoDollar[1].id.ToKeyword(), names, commas, protoDollar[3].b)
 		}
 	case 161:
-		protoDollar = protoS[protopt-0 : protopt+1]
-//line proto.y:740
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:744
 		{
-			protoVAL.msgDecls = nil
+			protoVAL.names = &nameList{protoDollar[1].str.toStringValueNode(), nil, nil}
 		}
 	case 162:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:744
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:747
 		{
-			protoVAL.msgDecls = []*messageElement{{field: protoDollar[1].fld}}
+			protoVAL.names = &nameList{protoDollar[1].str.toStringValueNode(), protoDollar[2].b, protoDollar[3].names}
 		}
 	case 163:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:747
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:751
 		{
-			protoVAL.msgDecls = []*messageElement{{enum: protoDollar[1].en}}
+			protoVAL.en = ast.NewEnumNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id, protoDollar[3].b, protoDollar[4].enDecls, protoDollar[5].b)
 		}
 	case 164:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:750
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:755
 		{
-			protoVAL.msgDecls = []*messageElement{{nested: protoDollar[1].msg}}
+			if protoDollar[2].enDecl != nil {
+				protoVAL.enDecls = append(protoDollar[1].enDecls, protoDollar[2].enDecl)
+			} else {
+				protoVAL.enDecls = protoDollar[1].enDecls
+			}
 		}
 	case 165:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:753
+//line proto.y:762
 		{
-			protoVAL.msgDecls = []*messageElement{{extend: protoDollar[1].extend}}
+			if protoDollar[1].enDecl != nil {
+				protoVAL.enDecls = []ast.EnumElement{protoDollar[1].enDecl}
+			} else {
+				protoVAL.enDecls = nil
+			}
 		}
 	case 166:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:756
+		protoDollar = protoS[protopt-0 : protopt+1]
+//line proto.y:769
 		{
-			protoVAL.msgDecls = []*messageElement{{extensionRange: protoDollar[1].ext}}
+			protoVAL.enDecls = nil
 		}
 	case 167:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:759
+//line proto.y:773
 		{
-			protoVAL.msgDecls = []*messageElement{{group: protoDollar[1].grp}}
+			protoVAL.enDecl = protoDollar[1].opt
 		}
 	case 168:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:762
+//line proto.y:776
 		{
-			protoVAL.msgDecls = []*messageElement{{option: protoDollar[1].opts[0]}}
+			protoVAL.enDecl = protoDollar[1].env
 		}
 	case 169:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:765
+//line proto.y:779
 		{
-			protoVAL.msgDecls = []*messageElement{{oneOf: protoDollar[1].oo}}
+			protoVAL.enDecl = protoDollar[1].resvd
 		}
 	case 170:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:768
+//line proto.y:782
 		{
-			protoVAL.msgDecls = []*messageElement{{mapField: protoDollar[1].mapFld}}
+			protoVAL.enDecl = ast.NewEmptyDeclNode(protoDollar[1].b)
 		}
 	case 171:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:771
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:785
 		{
-			protoVAL.msgDecls = []*messageElement{{reserved: protoDollar[1].resvd}}
+			protoVAL.enDecl = nil
 		}
 	case 172:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:774
+//line proto.y:788
 		{
-			protoVAL.msgDecls = []*messageElement{{empty: protoDollar[1].b}}
+			protoVAL.enDecl = nil
 		}
 	case 173:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:777
+		protoDollar = protoS[protopt-4 : protopt+1]
+//line proto.y:792
 		{
+			protoVAL.env = ast.NewEnumValueNode(protoDollar[1].id, protoDollar[2].b, protoDollar[3].il, nil, protoDollar[4].b)
 		}
 	case 174:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:779
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:795
 		{
+			protoVAL.env = ast.NewEnumValueNode(protoDollar[1].id, protoDollar[2].b, protoDollar[3].il, protoDollar[4].cmpctOpts, protoDollar[5].b)
 		}
 	case 175:
 		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:782
+//line proto.y:799
 		{
-			protoVAL.extend = &extendNode{extendee: protoDollar[2].cid, decls: protoDollar[4].extDecls}
-			protoVAL.extend.setRange(protoDollar[1].id, protoDollar[5].b)
+			protoVAL.msg = ast.NewMessageNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id, protoDollar[3].b, protoDollar[4].msgDecls, protoDollar[5].b)
 		}
 	case 176:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:787
+//line proto.y:803
 		{
-			protoVAL.extDecls = append(protoDollar[1].extDecls, protoDollar[2].extDecls...)
+			if protoDollar[2].msgDecl != nil {
+				protoVAL.msgDecls = append(protoDollar[1].msgDecls, protoDollar[2].msgDecl)
+			} else {
+				protoVAL.msgDecls = protoDollar[1].msgDecls
+			}
+		}
+	case 177:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:810
+		{
+			if protoDollar[1].msgDecl != nil {
+				protoVAL.msgDecls = []ast.MessageElement{protoDollar[1].msgDecl}
+			} else {
+				protoVAL.msgDecls = nil
+			}
 		}
 	case 178:
 		protoDollar = protoS[protopt-0 : protopt+1]
-//line proto.y:791
+//line proto.y:817
 		{
-			protoVAL.extDecls = nil
+			protoVAL.msgDecls = nil
 		}
 	case 179:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:795
+//line proto.y:821
 		{
-			protoVAL.extDecls = []*extendElement{{field: protoDollar[1].fld}}
+			protoVAL.msgDecl = protoDollar[1].fld
 		}
 	case 180:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:798
+//line proto.y:824
 		{
-			protoVAL.extDecls = []*extendElement{{group: protoDollar[1].grp}}
+			protoVAL.msgDecl = protoDollar[1].en
 		}
 	case 181:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:801
+//line proto.y:827
 		{
-			protoVAL.extDecls = []*extendElement{{empty: protoDollar[1].b}}
+			protoVAL.msgDecl = protoDollar[1].msg
 		}
 	case 182:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:804
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:830
 		{
+			protoVAL.msgDecl = protoDollar[1].extend
 		}
 	case 183:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:806
+//line proto.y:833
 		{
+			protoVAL.msgDecl = protoDollar[1].ext
 		}
 	case 184:
-		protoDollar = protoS[protopt-5 : protopt+1]
-//line proto.y:809
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:836
 		{
-			protoVAL.svc = &serviceNode{name: protoDollar[2].id, decls: protoDollar[4].svcDecls}
-			protoVAL.svc.setRange(protoDollar[1].id, protoDollar[5].b)
+			protoVAL.msgDecl = protoDollar[1].grp
 		}
 	case 185:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:814
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:839
+		{
+			protoVAL.msgDecl = protoDollar[1].opt
+		}
+	case 186:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:842
 		{
-			protoVAL.svcDecls = append(protoDollar[1].svcDecls, protoDollar[2].svcDecls...)
+			protoVAL.msgDecl = protoDollar[1].oo
 		}
 	case 187:
-		protoDollar = protoS[protopt-0 : protopt+1]
-//line proto.y:818
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:845
 		{
-			protoVAL.svcDecls = nil
+			protoVAL.msgDecl = protoDollar[1].mapFld
 		}
 	case 188:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:825
+//line proto.y:848
 		{
-			protoVAL.svcDecls = []*serviceElement{{option: protoDollar[1].opts[0]}}
+			protoVAL.msgDecl = protoDollar[1].resvd
 		}
 	case 189:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:828
+//line proto.y:851
 		{
-			protoVAL.svcDecls = []*serviceElement{{rpc: protoDollar[1].mtd}}
+			protoVAL.msgDecl = ast.NewEmptyDeclNode(protoDollar[1].b)
 		}
 	case 190:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:831
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:854
 		{
-			protoVAL.svcDecls = []*serviceElement{{empty: protoDollar[1].b}}
+			protoVAL.msgDecl = nil
 		}
 	case 191:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:834
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:857
 		{
+			protoVAL.msgDecl = nil
 		}
 	case 192:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:836
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:861
 		{
+			protoVAL.extend = ast.NewExtendNode(protoDollar[1].id.ToKeyword(), protoDollar[2].tid, protoDollar[3].b, protoDollar[4].extDecls, protoDollar[5].b)
 		}
 	case 193:
-		protoDollar = protoS[protopt-10 : protopt+1]
-//line proto.y:839
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:865
 		{
-			protoVAL.mtd = &methodNode{name: protoDollar[2].id, input: protoDollar[4].rpcType, output: protoDollar[8].rpcType}
-			protoVAL.mtd.setRange(protoDollar[1].id, protoDollar[10].b)
+			if protoDollar[2].extDecl != nil {
+				protoVAL.extDecls = append(protoDollar[1].extDecls, protoDollar[2].extDecl)
+			} else {
+				protoVAL.extDecls = protoDollar[1].extDecls
+			}
 		}
 	case 194:
-		protoDollar = protoS[protopt-12 : protopt+1]
-//line proto.y:843
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:872
 		{
-			protoVAL.mtd = &methodNode{name: protoDollar[2].id, input: protoDollar[4].rpcType, output: protoDollar[8].rpcType, options: protoDollar[11].opts}
-			protoVAL.mtd.setRange(protoDollar[1].id, protoDollar[12].b)
+			if protoDollar[1].extDecl != nil {
+				protoVAL.extDecls = []ast.ExtendElement{protoDollar[1].extDecl}
+			} else {
+				protoVAL.extDecls = nil
+			}
 		}
 	case 195:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:848
+		protoDollar = protoS[protopt-0 : protopt+1]
+//line proto.y:879
 		{
-			protoVAL.rpcType = &rpcTypeNode{msgType: protoDollar[2].cid, streamKeyword: protoDollar[1].id}
-			protoVAL.rpcType.setRange(protoDollar[1].id, protoDollar[2].cid)
+			protoVAL.extDecls = nil
 		}
 	case 196:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:852
+//line proto.y:883
 		{
-			protoVAL.rpcType = &rpcTypeNode{msgType: protoDollar[1].cid}
-			protoVAL.rpcType.setRange(protoDollar[1].cid, protoDollar[1].cid)
+			protoVAL.extDecl = protoDollar[1].fld
 		}
 	case 197:
-		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:857
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:886
 		{
-			protoVAL.opts = append(protoDollar[1].opts, protoDollar[2].opts...)
+			protoVAL.extDecl = protoDollar[1].grp
+		}
+	case 198:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:889
+		{
+			protoVAL.extDecl = ast.NewEmptyDeclNode(protoDollar[1].b)
 		}
 	case 199:
-		protoDollar = protoS[protopt-0 : protopt+1]
-//line proto.y:861
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:892
 		{
-			protoVAL.opts = []*optionNode{}
+			protoVAL.extDecl = nil
 		}
 	case 200:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:865
+//line proto.y:895
 		{
-			protoVAL.opts = protoDollar[1].opts
+			protoVAL.extDecl = nil
 		}
 	case 201:
-		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:868
+		protoDollar = protoS[protopt-5 : protopt+1]
+//line proto.y:899
 		{
-			protoVAL.opts = []*optionNode{}
+			protoVAL.svc = ast.NewServiceNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id, protoDollar[3].b, protoDollar[4].svcDecls, protoDollar[5].b)
 		}
 	case 202:
 		protoDollar = protoS[protopt-2 : protopt+1]
-//line proto.y:871
+//line proto.y:903
 		{
+			if protoDollar[2].svcDecl != nil {
+				protoVAL.svcDecls = append(protoDollar[1].svcDecls, protoDollar[2].svcDecl)
+			} else {
+				protoVAL.svcDecls = protoDollar[1].svcDecls
+			}
 		}
 	case 203:
 		protoDollar = protoS[protopt-1 : protopt+1]
-//line proto.y:873
+//line proto.y:910
+		{
+			if protoDollar[1].svcDecl != nil {
+				protoVAL.svcDecls = []ast.ServiceElement{protoDollar[1].svcDecl}
+			} else {
+				protoVAL.svcDecls = nil
+			}
+		}
+	case 204:
+		protoDollar = protoS[protopt-0 : protopt+1]
+//line proto.y:917
+		{
+			protoVAL.svcDecls = nil
+		}
+	case 205:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:924
+		{
+			protoVAL.svcDecl = protoDollar[1].opt
+		}
+	case 206:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:927
+		{
+			protoVAL.svcDecl = protoDollar[1].mtd
+		}
+	case 207:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:930
+		{
+			protoVAL.svcDecl = ast.NewEmptyDeclNode(protoDollar[1].b)
+		}
+	case 208:
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:933
+		{
+			protoVAL.svcDecl = nil
+		}
+	case 209:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:936
+		{
+			protoVAL.svcDecl = nil
+		}
+	case 210:
+		protoDollar = protoS[protopt-6 : protopt+1]
+//line proto.y:940
+		{
+			protoVAL.mtd = ast.NewRPCNode(protoDollar[1].id.ToKeyword(), protoDollar[2].id, protoDollar[3].rpcType, protoDollar[4].id.ToKeyword(), protoDollar[5].rpcType, protoDollar[6].b)
+		}
+	case 211:
+		protoDollar = protoS[protopt-8 : protopt+1]
+//line proto.y:943
+		{
+			protoVAL.mtd = ast.NewRPCNodeWithBody(protoDollar[1].id.ToKeyword(), protoDollar[2].id, protoDollar[3].rpcType, protoDollar[4].id.ToKeyword(), protoDollar[5].rpcType, protoDollar[6].b, protoDollar[7].rpcDecls, protoDollar[8].b)
+		}
+	case 212:
+		protoDollar = protoS[protopt-4 : protopt+1]
+//line proto.y:947
+		{
+			protoVAL.rpcType = ast.NewRPCTypeNode(protoDollar[1].b, protoDollar[2].id.ToKeyword(), protoDollar[3].tid, protoDollar[4].b)
+		}
+	case 213:
+		protoDollar = protoS[protopt-3 : protopt+1]
+//line proto.y:950
+		{
+			protoVAL.rpcType = ast.NewRPCTypeNode(protoDollar[1].b, nil, protoDollar[2].tid, protoDollar[3].b)
+		}
+	case 214:
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:954
+		{
+			if protoDollar[2].rpcDecl != nil {
+				protoVAL.rpcDecls = append(protoDollar[1].rpcDecls, protoDollar[2].rpcDecl)
+			} else {
+				protoVAL.rpcDecls = protoDollar[1].rpcDecls
+			}
+		}
+	case 215:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:961
+		{
+			if protoDollar[1].rpcDecl != nil {
+				protoVAL.rpcDecls = []ast.RPCElement{protoDollar[1].rpcDecl}
+			} else {
+				protoVAL.rpcDecls = nil
+			}
+		}
+	case 216:
+		protoDollar = protoS[protopt-0 : protopt+1]
+//line proto.y:968
+		{
+			protoVAL.rpcDecls = nil
+		}
+	case 217:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:972
+		{
+			protoVAL.rpcDecl = protoDollar[1].opt
+		}
+	case 218:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:975
+		{
+			protoVAL.rpcDecl = ast.NewEmptyDeclNode(protoDollar[1].b)
+		}
+	case 219:
+		protoDollar = protoS[protopt-2 : protopt+1]
+//line proto.y:978
+		{
+			protoVAL.rpcDecl = nil
+		}
+	case 220:
+		protoDollar = protoS[protopt-1 : protopt+1]
+//line proto.y:981
 		{
+			protoVAL.rpcDecl = nil
 		}
 	}
 	goto protostack /* stack new state and value */
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/source_code_info.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/source_code_info.go
index d5cc04710..2104c59a1 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/source_code_info.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/source_code_info.go
@@ -8,6 +8,7 @@ import (
 	dpb "github.com/golang/protobuf/protoc-gen-go/descriptor"
 
 	"github.com/jhump/protoreflect/desc/internal"
+	"github.com/jhump/protoreflect/desc/protoparse/ast"
 )
 
 func (r *parseResult) generateSourceCodeInfo() *dpb.SourceCodeInfo {
@@ -17,37 +18,37 @@ func (r *parseResult) generateSourceCodeInfo() *dpb.SourceCodeInfo {
 		return nil
 	}
 
-	sci := sourceCodeInfo{commentsUsed: map[*comment]struct{}{}}
+	sci := sourceCodeInfo{commentsUsed: map[*ast.Comment]struct{}{}}
 	path := make([]int32, 0, 10)
 
-	fn := r.getFileNode(r.fd).(*fileNode)
+	fn := r.getFileNode(r.fd).(*ast.FileNode)
 	sci.newLocWithoutComments(fn, nil)
 
-	if fn.syntax != nil {
-		sci.newLoc(fn.syntax, append(path, internal.File_syntaxTag))
+	if fn.Syntax != nil {
+		sci.newLoc(fn.Syntax, append(path, internal.File_syntaxTag))
 	}
 
 	var depIndex, optIndex, msgIndex, enumIndex, extendIndex, svcIndex int32
 
-	for _, child := range fn.decls {
-		switch {
-		case child.imp != nil:
-			sci.newLoc(child.imp, append(path, internal.File_dependencyTag, int32(depIndex)))
+	for _, child := range fn.Decls {
+		switch child := child.(type) {
+		case *ast.ImportNode:
+			sci.newLoc(child, append(path, internal.File_dependencyTag, int32(depIndex)))
 			depIndex++
-		case child.pkg != nil:
-			sci.newLoc(child.pkg, append(path, internal.File_packageTag))
-		case child.option != nil:
-			r.generateSourceCodeInfoForOption(&sci, child.option, false, &optIndex, append(path, internal.File_optionsTag))
-		case child.message != nil:
-			r.generateSourceCodeInfoForMessage(&sci, child.message, nil, append(path, internal.File_messagesTag, msgIndex))
+		case *ast.PackageNode:
+			sci.newLoc(child, append(path, internal.File_packageTag))
+		case *ast.OptionNode:
+			r.generateSourceCodeInfoForOption(&sci, child, false, &optIndex, append(path, internal.File_optionsTag))
+		case *ast.MessageNode:
+			r.generateSourceCodeInfoForMessage(&sci, child, nil, append(path, internal.File_messagesTag, msgIndex))
 			msgIndex++
-		case child.enum != nil:
-			r.generateSourceCodeInfoForEnum(&sci, child.enum, append(path, internal.File_enumsTag, enumIndex))
+		case *ast.EnumNode:
+			r.generateSourceCodeInfoForEnum(&sci, child, append(path, internal.File_enumsTag, enumIndex))
 			enumIndex++
-		case child.extend != nil:
-			r.generateSourceCodeInfoForExtensions(&sci, child.extend, &extendIndex, &msgIndex, append(path, internal.File_extensionsTag), append(dup(path), internal.File_messagesTag))
-		case child.service != nil:
-			r.generateSourceCodeInfoForService(&sci, child.service, append(path, internal.File_servicesTag, svcIndex))
+		case *ast.ExtendNode:
+			r.generateSourceCodeInfoForExtensions(&sci, child, &extendIndex, &msgIndex, append(path, internal.File_extensionsTag), append(dup(path), internal.File_messagesTag))
+		case *ast.ServiceNode:
+			r.generateSourceCodeInfoForService(&sci, child, append(path, internal.File_servicesTag, svcIndex))
 			svcIndex++
 		}
 	}
@@ -55,7 +56,7 @@ func (r *parseResult) generateSourceCodeInfo() *dpb.SourceCodeInfo {
 	return &dpb.SourceCodeInfo{Location: sci.locs}
 }
 
-func (r *parseResult) generateSourceCodeInfoForOption(sci *sourceCodeInfo, n *optionNode, compact bool, uninterpIndex *int32, path []int32) {
+func (r *parseResult) generateSourceCodeInfoForOption(sci *sourceCodeInfo, n *ast.OptionNode, compact bool, uninterpIndex *int32, path []int32) {
 	if !compact {
 		sci.newLocWithoutComments(n, path)
 	}
@@ -79,95 +80,96 @@ func (r *parseResult) generateSourceCodeInfoForOption(sci *sourceCodeInfo, n *op
 	*uninterpIndex++
 	sci.newLoc(n, optPath)
 	var valTag int32
-	switch n.val.(type) {
-	case *compoundIdentNode:
+	switch n.Val.(type) {
+	case ast.IdentValueNode:
 		valTag = internal.Uninterpreted_identTag
-	case *intLiteralNode:
-		valTag = internal.Uninterpreted_posIntTag
-	case *compoundIntNode:
+	case *ast.NegativeIntLiteralNode:
 		valTag = internal.Uninterpreted_negIntTag
-	case *compoundFloatNode:
+	case ast.IntValueNode:
+		valTag = internal.Uninterpreted_posIntTag
+	case ast.FloatValueNode:
 		valTag = internal.Uninterpreted_doubleTag
-	case *compoundStringNode:
+	case ast.StringValueNode:
 		valTag = internal.Uninterpreted_stringTag
-	case *aggregateLiteralNode:
+	case *ast.MessageLiteralNode:
 		valTag = internal.Uninterpreted_aggregateTag
 	}
 	if valTag != 0 {
-		sci.newLoc(n.val, append(optPath, valTag))
+		sci.newLoc(n.Val, append(optPath, valTag))
 	}
-	for j, nn := range n.name.parts {
+	for j, nn := range n.Name.Parts {
 		optNmPath := append(optPath, internal.Uninterpreted_nameTag, int32(j))
 		sci.newLoc(nn, optNmPath)
-		sci.newLoc(nn.text, append(optNmPath, internal.UninterpretedName_nameTag))
+		sci.newLoc(nn.Name, append(optNmPath, internal.UninterpretedName_nameTag))
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForMessage(sci *sourceCodeInfo, n msgDecl, fieldPath []int32, path []int32) {
+func (r *parseResult) generateSourceCodeInfoForMessage(sci *sourceCodeInfo, n ast.MessageDeclNode, fieldPath []int32, path []int32) {
 	sci.newLoc(n, path)
 
-	var decls []*messageElement
+	var decls []ast.MessageElement
 	switch n := n.(type) {
-	case *messageNode:
-		decls = n.decls
-	case *groupNode:
-		decls = n.decls
-	case *mapFieldNode:
+	case *ast.MessageNode:
+		decls = n.Decls
+	case *ast.GroupNode:
+		decls = n.Decls
+	case *ast.MapFieldNode:
 		// map entry so nothing else to do
 		return
 	}
 
-	sci.newLoc(n.messageName(), append(path, internal.Message_nameTag))
+	sci.newLoc(n.MessageName(), append(path, internal.Message_nameTag))
 	// matching protoc, which emits the corresponding field type name (for group fields)
 	// right after the source location for the group message name
 	if fieldPath != nil {
-		sci.newLoc(n.messageName(), append(fieldPath, internal.Field_typeNameTag))
+		sci.newLoc(n.MessageName(), append(fieldPath, internal.Field_typeNameTag))
 	}
 
 	var optIndex, fieldIndex, oneOfIndex, extendIndex, nestedMsgIndex int32
 	var nestedEnumIndex, extRangeIndex, reservedRangeIndex, reservedNameIndex int32
 	for _, child := range decls {
-		switch {
-		case child.option != nil:
-			r.generateSourceCodeInfoForOption(sci, child.option, false, &optIndex, append(path, internal.Message_optionsTag))
-		case child.field != nil:
-			r.generateSourceCodeInfoForField(sci, child.field, append(path, internal.Message_fieldsTag, fieldIndex))
+		switch child := child.(type) {
+		case *ast.OptionNode:
+			r.generateSourceCodeInfoForOption(sci, child, false, &optIndex, append(path, internal.Message_optionsTag))
+		case *ast.FieldNode:
+			r.generateSourceCodeInfoForField(sci, child, append(path, internal.Message_fieldsTag, fieldIndex))
 			fieldIndex++
-		case child.group != nil:
+		case *ast.GroupNode:
 			fldPath := append(path, internal.Message_fieldsTag, fieldIndex)
-			r.generateSourceCodeInfoForField(sci, child.group, fldPath)
+			r.generateSourceCodeInfoForField(sci, child, fldPath)
 			fieldIndex++
-			r.generateSourceCodeInfoForMessage(sci, child.group, fldPath, append(dup(path), internal.Message_nestedMessagesTag, nestedMsgIndex))
+			r.generateSourceCodeInfoForMessage(sci, child, fldPath, append(dup(path), internal.Message_nestedMessagesTag, nestedMsgIndex))
 			nestedMsgIndex++
-		case child.mapField != nil:
-			r.generateSourceCodeInfoForField(sci, child.mapField, append(path, internal.Message_fieldsTag, fieldIndex))
+		case *ast.MapFieldNode:
+			r.generateSourceCodeInfoForField(sci, child, append(path, internal.Message_fieldsTag, fieldIndex))
 			fieldIndex++
-		case child.oneOf != nil:
-			r.generateSourceCodeInfoForOneOf(sci, child.oneOf, &fieldIndex, &nestedMsgIndex, append(path, internal.Message_fieldsTag), append(dup(path), internal.Message_nestedMessagesTag), append(dup(path), internal.Message_oneOfsTag, oneOfIndex))
+			nestedMsgIndex++
+		case *ast.OneOfNode:
+			r.generateSourceCodeInfoForOneOf(sci, child, &fieldIndex, &nestedMsgIndex, append(path, internal.Message_fieldsTag), append(dup(path), internal.Message_nestedMessagesTag), append(dup(path), internal.Message_oneOfsTag, oneOfIndex))
 			oneOfIndex++
-		case child.nested != nil:
-			r.generateSourceCodeInfoForMessage(sci, child.nested, nil, append(path, internal.Message_nestedMessagesTag, nestedMsgIndex))
+		case *ast.MessageNode:
+			r.generateSourceCodeInfoForMessage(sci, child, nil, append(path, internal.Message_nestedMessagesTag, nestedMsgIndex))
 			nestedMsgIndex++
-		case child.enum != nil:
-			r.generateSourceCodeInfoForEnum(sci, child.enum, append(path, internal.Message_enumsTag, nestedEnumIndex))
+		case *ast.EnumNode:
+			r.generateSourceCodeInfoForEnum(sci, child, append(path, internal.Message_enumsTag, nestedEnumIndex))
 			nestedEnumIndex++
-		case child.extend != nil:
-			r.generateSourceCodeInfoForExtensions(sci, child.extend, &extendIndex, &nestedMsgIndex, append(path, internal.Message_extensionsTag), append(dup(path), internal.Message_nestedMessagesTag))
-		case child.extensionRange != nil:
-			r.generateSourceCodeInfoForExtensionRanges(sci, child.extensionRange, &extRangeIndex, append(path, internal.Message_extensionRangeTag))
-		case child.reserved != nil:
-			if len(child.reserved.names) > 0 {
+		case *ast.ExtendNode:
+			r.generateSourceCodeInfoForExtensions(sci, child, &extendIndex, &nestedMsgIndex, append(path, internal.Message_extensionsTag), append(dup(path), internal.Message_nestedMessagesTag))
+		case *ast.ExtensionRangeNode:
+			r.generateSourceCodeInfoForExtensionRanges(sci, child, &extRangeIndex, append(path, internal.Message_extensionRangeTag))
+		case *ast.ReservedNode:
+			if len(child.Names) > 0 {
 				resPath := append(path, internal.Message_reservedNameTag)
-				sci.newLoc(child.reserved, resPath)
-				for _, rn := range child.reserved.names {
+				sci.newLoc(child, resPath)
+				for _, rn := range child.Names {
 					sci.newLoc(rn, append(resPath, reservedNameIndex))
 					reservedNameIndex++
 				}
 			}
-			if len(child.reserved.ranges) > 0 {
+			if len(child.Ranges) > 0 {
 				resPath := append(path, internal.Message_reservedRangeTag)
-				sci.newLoc(child.reserved, resPath)
-				for _, rr := range child.reserved.ranges {
+				sci.newLoc(child, resPath)
+				for _, rr := range child.Ranges {
 					r.generateSourceCodeInfoForReservedRange(sci, rr, append(resPath, reservedRangeIndex))
 					reservedRangeIndex++
 				}
@@ -176,31 +178,31 @@ func (r *parseResult) generateSourceCodeInfoForMessage(sci *sourceCodeInfo, n ms
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForEnum(sci *sourceCodeInfo, n *enumNode, path []int32) {
+func (r *parseResult) generateSourceCodeInfoForEnum(sci *sourceCodeInfo, n *ast.EnumNode, path []int32) {
 	sci.newLoc(n, path)
-	sci.newLoc(n.name, append(path, internal.Enum_nameTag))
+	sci.newLoc(n.Name, append(path, internal.Enum_nameTag))
 
 	var optIndex, valIndex, reservedNameIndex, reservedRangeIndex int32
-	for _, child := range n.decls {
-		switch {
-		case child.option != nil:
-			r.generateSourceCodeInfoForOption(sci, child.option, false, &optIndex, append(path, internal.Enum_optionsTag))
-		case child.value != nil:
-			r.generateSourceCodeInfoForEnumValue(sci, child.value, append(path, internal.Enum_valuesTag, valIndex))
+	for _, child := range n.Decls {
+		switch child := child.(type) {
+		case *ast.OptionNode:
+			r.generateSourceCodeInfoForOption(sci, child, false, &optIndex, append(path, internal.Enum_optionsTag))
+		case *ast.EnumValueNode:
+			r.generateSourceCodeInfoForEnumValue(sci, child, append(path, internal.Enum_valuesTag, valIndex))
 			valIndex++
-		case child.reserved != nil:
-			if len(child.reserved.names) > 0 {
+		case *ast.ReservedNode:
+			if len(child.Names) > 0 {
 				resPath := append(path, internal.Enum_reservedNameTag)
-				sci.newLoc(child.reserved, resPath)
-				for _, rn := range child.reserved.names {
+				sci.newLoc(child, resPath)
+				for _, rn := range child.Names {
 					sci.newLoc(rn, append(resPath, reservedNameIndex))
 					reservedNameIndex++
 				}
 			}
-			if len(child.reserved.ranges) > 0 {
+			if len(child.Ranges) > 0 {
 				resPath := append(path, internal.Enum_reservedRangeTag)
-				sci.newLoc(child.reserved, resPath)
-				for _, rr := range child.reserved.ranges {
+				sci.newLoc(child, resPath)
+				for _, rr := range child.Ranges {
 					r.generateSourceCodeInfoForReservedRange(sci, rr, append(resPath, reservedRangeIndex))
 					reservedRangeIndex++
 				}
@@ -209,113 +211,99 @@ func (r *parseResult) generateSourceCodeInfoForEnum(sci *sourceCodeInfo, n *enum
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForEnumValue(sci *sourceCodeInfo, n *enumValueNode, path []int32) {
+func (r *parseResult) generateSourceCodeInfoForEnumValue(sci *sourceCodeInfo, n *ast.EnumValueNode, path []int32) {
 	sci.newLoc(n, path)
-	sci.newLoc(n.name, append(path, internal.EnumVal_nameTag))
-	sci.newLoc(n.getNumber(), append(path, internal.EnumVal_numberTag))
+	sci.newLoc(n.Name, append(path, internal.EnumVal_nameTag))
+	sci.newLoc(n.Number, append(path, internal.EnumVal_numberTag))
 
 	// enum value options
-	if n.options != nil {
+	if n.Options != nil {
 		optsPath := append(path, internal.EnumVal_optionsTag)
-		sci.newLoc(n.options, optsPath)
+		sci.newLoc(n.Options, optsPath)
 		var optIndex int32
-		for _, opt := range n.options.decls {
+		for _, opt := range n.Options.GetElements() {
 			r.generateSourceCodeInfoForOption(sci, opt, true, &optIndex, optsPath)
 		}
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForReservedRange(sci *sourceCodeInfo, n *rangeNode, path []int32) {
+func (r *parseResult) generateSourceCodeInfoForReservedRange(sci *sourceCodeInfo, n *ast.RangeNode, path []int32) {
 	sci.newLoc(n, path)
-	sci.newLoc(n.startNode, append(path, internal.ReservedRange_startTag))
-	if n.endNode != nil {
-		sci.newLoc(n.endNode, append(path, internal.ReservedRange_endTag))
+	sci.newLoc(n.StartVal, append(path, internal.ReservedRange_startTag))
+	if n.EndVal != nil {
+		sci.newLoc(n.EndVal, append(path, internal.ReservedRange_endTag))
+	} else if n.Max != nil {
+		sci.newLoc(n.Max, append(path, internal.ReservedRange_endTag))
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForExtensions(sci *sourceCodeInfo, n *extendNode, extendIndex, msgIndex *int32, extendPath, msgPath []int32) {
+func (r *parseResult) generateSourceCodeInfoForExtensions(sci *sourceCodeInfo, n *ast.ExtendNode, extendIndex, msgIndex *int32, extendPath, msgPath []int32) {
 	sci.newLoc(n, extendPath)
-	for _, decl := range n.decls {
-		switch {
-		case decl.field != nil:
-			r.generateSourceCodeInfoForField(sci, decl.field, append(extendPath, *extendIndex))
+	for _, decl := range n.Decls {
+		switch decl := decl.(type) {
+		case *ast.FieldNode:
+			r.generateSourceCodeInfoForField(sci, decl, append(extendPath, *extendIndex))
 			*extendIndex++
-		case decl.group != nil:
+		case *ast.GroupNode:
 			fldPath := append(extendPath, *extendIndex)
-			r.generateSourceCodeInfoForField(sci, decl.group, fldPath)
+			r.generateSourceCodeInfoForField(sci, decl, fldPath)
 			*extendIndex++
-			r.generateSourceCodeInfoForMessage(sci, decl.group, fldPath, append(msgPath, *msgIndex))
+			r.generateSourceCodeInfoForMessage(sci, decl, fldPath, append(msgPath, *msgIndex))
 			*msgIndex++
 		}
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForOneOf(sci *sourceCodeInfo, n *oneOfNode, fieldIndex, nestedMsgIndex *int32, fieldPath, nestedMsgPath, oneOfPath []int32) {
+func (r *parseResult) generateSourceCodeInfoForOneOf(sci *sourceCodeInfo, n *ast.OneOfNode, fieldIndex, nestedMsgIndex *int32, fieldPath, nestedMsgPath, oneOfPath []int32) {
 	sci.newLoc(n, oneOfPath)
-	sci.newLoc(n.name, append(oneOfPath, internal.OneOf_nameTag))
+	sci.newLoc(n.Name, append(oneOfPath, internal.OneOf_nameTag))
 
 	var optIndex int32
-	for _, child := range n.decls {
-		switch {
-		case child.option != nil:
-			r.generateSourceCodeInfoForOption(sci, child.option, false, &optIndex, append(oneOfPath, internal.OneOf_optionsTag))
-		case child.field != nil:
-			r.generateSourceCodeInfoForField(sci, child.field, append(fieldPath, *fieldIndex))
+	for _, child := range n.Decls {
+		switch child := child.(type) {
+		case *ast.OptionNode:
+			r.generateSourceCodeInfoForOption(sci, child, false, &optIndex, append(oneOfPath, internal.OneOf_optionsTag))
+		case *ast.FieldNode:
+			r.generateSourceCodeInfoForField(sci, child, append(fieldPath, *fieldIndex))
 			*fieldIndex++
-		case child.group != nil:
+		case *ast.GroupNode:
 			fldPath := append(fieldPath, *fieldIndex)
-			r.generateSourceCodeInfoForField(sci, child.group, fldPath)
+			r.generateSourceCodeInfoForField(sci, child, fldPath)
 			*fieldIndex++
-			r.generateSourceCodeInfoForMessage(sci, child.group, fldPath, append(nestedMsgPath, *nestedMsgIndex))
+			r.generateSourceCodeInfoForMessage(sci, child, fldPath, append(nestedMsgPath, *nestedMsgIndex))
 			*nestedMsgIndex++
 		}
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForField(sci *sourceCodeInfo, n fieldDecl, path []int32) {
-	isGroup := false
-	var opts *compactOptionsNode
-	var extendee *extendNode
+func (r *parseResult) generateSourceCodeInfoForField(sci *sourceCodeInfo, n ast.FieldDeclNode, path []int32) {
 	var fieldType string
-	switch n := n.(type) {
-	case *fieldNode:
-		opts = n.options
-		extendee = n.extendee
-		fieldType = n.fldType.val
-	case *mapFieldNode:
-		opts = n.options
-	case *groupNode:
-		isGroup = true
-		extendee = n.extendee
-	case *syntheticMapField:
-		// shouldn't get here since we don't recurse into fields from a mapNode
-		// in generateSourceCodeInfoForMessage... but just in case
-		return
+	if f, ok := n.(*ast.FieldNode); ok {
+		fieldType = string(f.FldType.AsIdentifier())
 	}
 
-	if isGroup {
+	if n.GetGroupKeyword() != nil {
 		// comments will appear on group message
 		sci.newLocWithoutComments(n, path)
-		if extendee != nil {
-			sci.newLoc(extendee.extendee, append(path, internal.Field_extendeeTag))
+		if n.FieldExtendee() != nil {
+			sci.newLoc(n.FieldExtendee(), append(path, internal.Field_extendeeTag))
 		}
-		if n.fieldLabel() != nil {
+		if n.FieldLabel() != nil {
 			// no comments here either (label is first token for group, so we want
 			// to leave the comments to be associated with the group message instead)
-			sci.newLocWithoutComments(n.fieldLabel(), append(path, internal.Field_labelTag))
+			sci.newLocWithoutComments(n.FieldLabel(), append(path, internal.Field_labelTag))
 		}
-		sci.newLoc(n.fieldType(), append(path, internal.Field_typeTag))
+		sci.newLoc(n.FieldType(), append(path, internal.Field_typeTag))
 		// let the name comments be attributed to the group name
-		sci.newLocWithoutComments(n.fieldName(), append(path, internal.Field_nameTag))
+		sci.newLocWithoutComments(n.FieldName(), append(path, internal.Field_nameTag))
 	} else {
 		sci.newLoc(n, path)
-		if extendee != nil {
-			sci.newLoc(extendee.extendee, append(path, internal.Field_extendeeTag))
+		if n.FieldExtendee() != nil {
+			sci.newLoc(n.FieldExtendee(), append(path, internal.Field_extendeeTag))
 		}
-		if n.fieldLabel() != nil {
-			sci.newLoc(n.fieldLabel(), append(path, internal.Field_labelTag))
+		if n.FieldLabel() != nil {
+			sci.newLoc(n.FieldLabel(), append(path, internal.Field_labelTag))
 		}
-		n.fieldType()
 		var tag int32
 		if _, isScalar := fieldTypes[fieldType]; isScalar {
 			tag = internal.Field_typeTag
@@ -324,93 +312,97 @@ func (r *parseResult) generateSourceCodeInfoForField(sci *sourceCodeInfo, n fiel
 			// to the type name field
 			tag = internal.Field_typeNameTag
 		}
-		sci.newLoc(n.fieldType(), append(path, tag))
-		sci.newLoc(n.fieldName(), append(path, internal.Field_nameTag))
+		sci.newLoc(n.FieldType(), append(path, tag))
+		sci.newLoc(n.FieldName(), append(path, internal.Field_nameTag))
 	}
-	sci.newLoc(n.fieldTag(), append(path, internal.Field_numberTag))
+	sci.newLoc(n.FieldTag(), append(path, internal.Field_numberTag))
 
-	if opts != nil {
+	if n.GetOptions() != nil {
 		optsPath := append(path, internal.Field_optionsTag)
-		sci.newLoc(opts, optsPath)
+		sci.newLoc(n.GetOptions(), optsPath)
 		var optIndex int32
-		for _, opt := range opts.decls {
+		for _, opt := range n.GetOptions().GetElements() {
 			r.generateSourceCodeInfoForOption(sci, opt, true, &optIndex, optsPath)
 		}
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForExtensionRanges(sci *sourceCodeInfo, n *extensionRangeNode, extRangeIndex *int32, path []int32) {
+func (r *parseResult) generateSourceCodeInfoForExtensionRanges(sci *sourceCodeInfo, n *ast.ExtensionRangeNode, extRangeIndex *int32, path []int32) {
 	sci.newLoc(n, path)
-	for _, child := range n.ranges {
+	for _, child := range n.Ranges {
 		path := append(path, *extRangeIndex)
 		*extRangeIndex++
 		sci.newLoc(child, path)
-		sci.newLoc(child.startNode, append(path, internal.ExtensionRange_startTag))
-		if child.endNode != nil {
-			sci.newLoc(child.endNode, append(path, internal.ExtensionRange_endTag))
+		sci.newLoc(child.StartVal, append(path, internal.ExtensionRange_startTag))
+		if child.EndVal != nil {
+			sci.newLoc(child.EndVal, append(path, internal.ExtensionRange_endTag))
+		} else if child.Max != nil {
+			sci.newLoc(child.Max, append(path, internal.ExtensionRange_endTag))
 		}
-		if n.options != nil {
+		if n.Options != nil {
 			optsPath := append(path, internal.ExtensionRange_optionsTag)
-			sci.newLoc(n.options, optsPath)
+			sci.newLoc(n.Options, optsPath)
 			var optIndex int32
-			for _, opt := range n.options.decls {
+			for _, opt := range n.Options.GetElements() {
 				r.generateSourceCodeInfoForOption(sci, opt, true, &optIndex, optsPath)
 			}
 		}
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForService(sci *sourceCodeInfo, n *serviceNode, path []int32) {
+func (r *parseResult) generateSourceCodeInfoForService(sci *sourceCodeInfo, n *ast.ServiceNode, path []int32) {
 	sci.newLoc(n, path)
-	sci.newLoc(n.name, append(path, internal.Service_nameTag))
+	sci.newLoc(n.Name, append(path, internal.Service_nameTag))
 	var optIndex, rpcIndex int32
-	for _, child := range n.decls {
-		switch {
-		case child.option != nil:
-			r.generateSourceCodeInfoForOption(sci, child.option, false, &optIndex, append(path, internal.Service_optionsTag))
-		case child.rpc != nil:
-			r.generateSourceCodeInfoForMethod(sci, child.rpc, append(path, internal.Service_methodsTag, rpcIndex))
+	for _, child := range n.Decls {
+		switch child := child.(type) {
+		case *ast.OptionNode:
+			r.generateSourceCodeInfoForOption(sci, child, false, &optIndex, append(path, internal.Service_optionsTag))
+		case *ast.RPCNode:
+			r.generateSourceCodeInfoForMethod(sci, child, append(path, internal.Service_methodsTag, rpcIndex))
 			rpcIndex++
 		}
 	}
 }
 
-func (r *parseResult) generateSourceCodeInfoForMethod(sci *sourceCodeInfo, n *methodNode, path []int32) {
+func (r *parseResult) generateSourceCodeInfoForMethod(sci *sourceCodeInfo, n *ast.RPCNode, path []int32) {
 	sci.newLoc(n, path)
-	sci.newLoc(n.name, append(path, internal.Method_nameTag))
-	if n.input.streamKeyword != nil {
-		sci.newLoc(n.input.streamKeyword, append(path, internal.Method_inputStreamTag))
+	sci.newLoc(n.Name, append(path, internal.Method_nameTag))
+	if n.Input.Stream != nil {
+		sci.newLoc(n.Input.Stream, append(path, internal.Method_inputStreamTag))
 	}
-	sci.newLoc(n.input.msgType, append(path, internal.Method_inputTag))
-	if n.output.streamKeyword != nil {
-		sci.newLoc(n.output.streamKeyword, append(path, internal.Method_outputStreamTag))
+	sci.newLoc(n.Input.MessageType, append(path, internal.Method_inputTag))
+	if n.Output.Stream != nil {
+		sci.newLoc(n.Output.Stream, append(path, internal.Method_outputStreamTag))
 	}
-	sci.newLoc(n.output.msgType, append(path, internal.Method_outputTag))
+	sci.newLoc(n.Output.MessageType, append(path, internal.Method_outputTag))
 
 	optsPath := append(path, internal.Method_optionsTag)
 	var optIndex int32
-	for _, opt := range n.options {
-		r.generateSourceCodeInfoForOption(sci, opt, false, &optIndex, optsPath)
+	for _, decl := range n.Decls {
+		if opt, ok := decl.(*ast.OptionNode); ok {
+			r.generateSourceCodeInfoForOption(sci, opt, false, &optIndex, optsPath)
+		}
 	}
 }
 
 type sourceCodeInfo struct {
 	locs         []*dpb.SourceCodeInfo_Location
-	commentsUsed map[*comment]struct{}
+	commentsUsed map[*ast.Comment]struct{}
 }
 
-func (sci *sourceCodeInfo) newLocWithoutComments(n node, path []int32) {
+func (sci *sourceCodeInfo) newLocWithoutComments(n ast.Node, path []int32) {
 	dup := make([]int32, len(path))
 	copy(dup, path)
 	sci.locs = append(sci.locs, &dpb.SourceCodeInfo_Location{
 		Path: dup,
-		Span: makeSpan(n.start(), n.end()),
+		Span: makeSpan(n.Start(), n.End()),
 	})
 }
 
-func (sci *sourceCodeInfo) newLoc(n node, path []int32) {
-	leadingComments := n.leadingComments()
-	trailingComments := n.trailingComments()
+func (sci *sourceCodeInfo) newLoc(n ast.Node, path []int32) {
+	leadingComments := n.LeadingComments()
+	trailingComments := n.TrailingComments()
 	if sci.commentUsed(leadingComments) {
 		leadingComments = nil
 	}
@@ -423,7 +415,7 @@ func (sci *sourceCodeInfo) newLoc(n node, path []int32) {
 		trail = proto.String(str)
 	}
 	var lead *string
-	if len(leadingComments) > 0 && leadingComments[len(leadingComments)-1].end.Line >= n.start().Line-1 {
+	if len(leadingComments) > 0 && leadingComments[len(leadingComments)-1].End.Line >= n.Start().Line-1 {
 		lead = proto.String(detached[len(detached)-1])
 		detached = detached[:len(detached)-1]
 	}
@@ -434,7 +426,7 @@ func (sci *sourceCodeInfo) newLoc(n node, path []int32) {
 		LeadingComments:         lead,
 		TrailingComments:        trail,
 		Path:                    dup,
-		Span:                    makeSpan(n.start(), n.end()),
+		Span:                    makeSpan(n.Start(), n.End()),
 	})
 }
 
@@ -445,7 +437,7 @@ func makeSpan(start, end *SourcePos) []int32 {
 	return []int32{int32(start.Line) - 1, int32(start.Col) - 1, int32(end.Line) - 1, int32(end.Col) - 1}
 }
 
-func (sci *sourceCodeInfo) commentUsed(c []comment) bool {
+func (sci *sourceCodeInfo) commentUsed(c []ast.Comment) bool {
 	if len(c) == 0 {
 		return false
 	}
@@ -457,27 +449,27 @@ func (sci *sourceCodeInfo) commentUsed(c []comment) bool {
 	return false
 }
 
-func groupComments(comments []comment) []string {
+func groupComments(comments []ast.Comment) []string {
 	if len(comments) == 0 {
 		return nil
 	}
 
 	var groups []string
-	singleLineStyle := comments[0].text[:2] == "//"
-	line := comments[0].end.Line
+	singleLineStyle := comments[0].Text[:2] == "//"
+	line := comments[0].End.Line
 	start := 0
 	for i := 1; i < len(comments); i++ {
 		c := comments[i]
 		prevSingleLine := singleLineStyle
-		singleLineStyle = strings.HasPrefix(comments[i].text, "//")
-		if !singleLineStyle || prevSingleLine != singleLineStyle || c.start.Line > line+1 {
+		singleLineStyle = strings.HasPrefix(comments[i].Text, "//")
+		if !singleLineStyle || prevSingleLine != singleLineStyle || c.Start.Line > line+1 {
 			// new group!
 			if str, ok := combineComments(comments[start:i]); ok {
 				groups = append(groups, str)
 			}
 			start = i
 		}
-		line = c.end.Line
+		line = c.End.Line
 	}
 	// don't forget last group
 	if str, ok := combineComments(comments[start:]); ok {
@@ -486,16 +478,16 @@ func groupComments(comments []comment) []string {
 	return groups
 }
 
-func combineComments(comments []comment) (string, bool) {
+func combineComments(comments []ast.Comment) (string, bool) {
 	if len(comments) == 0 {
 		return "", false
 	}
 	var buf bytes.Buffer
 	for _, c := range comments {
-		if c.text[:2] == "//" {
-			buf.WriteString(c.text[2:])
+		if c.Text[:2] == "//" {
+			buf.WriteString(c.Text[2:])
 		} else {
-			lines := strings.Split(c.text[2:len(c.text)-2], "\n")
+			lines := strings.Split(c.Text[2:len(c.Text)-2], "\n")
 			first := true
 			for _, l := range lines {
 				if first {
diff --git a/vendor/github.com/jhump/protoreflect/desc/protoparse/validate.go b/vendor/github.com/jhump/protoreflect/desc/protoparse/validate.go
index 70d9a51e5..353af6b26 100644
--- a/vendor/github.com/jhump/protoreflect/desc/protoparse/validate.go
+++ b/vendor/github.com/jhump/protoreflect/desc/protoparse/validate.go
@@ -5,8 +5,9 @@ import (
 	"sort"
 
 	"github.com/golang/protobuf/proto"
-
 	dpb "github.com/golang/protobuf/protoc-gen-go/descriptor"
+
+	"github.com/jhump/protoreflect/desc/protoparse/ast"
 )
 
 func validateBasic(res *parseResult, containsErrors bool) {
@@ -60,7 +61,7 @@ func validateMessage(res *parseResult, isProto3 bool, prefix string, md *dpb.Des
 
 	if isProto3 && len(md.ExtensionRange) > 0 {
 		n := res.getExtensionRangeNode(md.ExtensionRange[0])
-		if err := res.errs.handleErrorWithPos(n.start(), "%s: extension ranges are not allowed in proto3", scope); err != nil {
+		if err := res.errs.handleErrorWithPos(n.Start(), "%s: extension ranges are not allowed in proto3", scope); err != nil {
 			return err
 		}
 	}
@@ -75,7 +76,7 @@ func validateMessage(res *parseResult, isProto3 bool, prefix string, md *dpb.Des
 		if opt.IdentifierValue != nil {
 			if opt.GetIdentifierValue() == "true" {
 				valid = true
-				if err := res.errs.handleErrorWithPos(optn.getValue().start(), "%s: map_entry option should not be set explicitly; use map type instead", scope); err != nil {
+				if err := res.errs.handleErrorWithPos(optn.GetValue().Start(), "%s: map_entry option should not be set explicitly; use map type instead", scope); err != nil {
 					return err
 				}
 			} else if opt.GetIdentifierValue() == "false" {
@@ -84,7 +85,7 @@ func validateMessage(res *parseResult, isProto3 bool, prefix string, md *dpb.Des
 			}
 		}
 		if !valid {
-			if err := res.errs.handleErrorWithPos(optn.getValue().start(), "%s: expecting bool value for map_entry option", scope); err != nil {
+			if err := res.errs.handleErrorWithPos(optn.GetValue().Start(), "%s: expecting bool value for map_entry option", scope); err != nil {
 				return err
 			}
 		}
@@ -100,7 +101,7 @@ func validateMessage(res *parseResult, isProto3 bool, prefix string, md *dpb.Des
 	sort.Sort(rsvd)
 	for i := 1; i < len(rsvd); i++ {
 		if rsvd[i].start < rsvd[i-1].end {
-			if err := res.errs.handleErrorWithPos(rsvd[i].node.start(), "%s: reserved ranges overlap: %d to %d and %d to %d", scope, rsvd[i-1].start, rsvd[i-1].end-1, rsvd[i].start, rsvd[i].end-1); err != nil {
+			if err := res.errs.handleErrorWithPos(rsvd[i].node.Start(), "%s: reserved ranges overlap: %d to %d and %d to %d", scope, rsvd[i-1].start, rsvd[i-1].end-1, rsvd[i].start, rsvd[i].end-1); err != nil {
 				return err
 			}
 		}
@@ -115,7 +116,7 @@ func validateMessage(res *parseResult, isProto3 bool, prefix string, md *dpb.Des
 	sort.Sort(exts)
 	for i := 1; i < len(exts); i++ {
 		if exts[i].start < exts[i-1].end {
-			if err := res.errs.handleErrorWithPos(exts[i].node.start(), "%s: extension ranges overlap: %d to %d and %d to %d", scope, exts[i-1].start, exts[i-1].end-1, exts[i].start, exts[i].end-1); err != nil {
+			if err := res.errs.handleErrorWithPos(exts[i].node.Start(), "%s: extension ranges overlap: %d to %d and %d to %d", scope, exts[i-1].start, exts[i-1].end-1, exts[i].start, exts[i].end-1); err != nil {
 				return err
 			}
 		}
@@ -129,9 +130,9 @@ func validateMessage(res *parseResult, isProto3 bool, prefix string, md *dpb.Des
 
 			var pos *SourcePos
 			if rsvd[i].start >= exts[j].start && rsvd[i].start < exts[j].end {
-				pos = rsvd[i].node.start()
+				pos = rsvd[i].node.Start()
 			} else {
-				pos = exts[j].node.start()
+				pos = exts[j].node.Start()
 			}
 			// ranges overlap
 			if err := res.errs.handleErrorWithPos(pos, "%s: extension range %d to %d overlaps reserved range %d to %d", scope, exts[j].start, exts[j].end-1, rsvd[i].start, rsvd[i].end-1); err != nil {
@@ -155,12 +156,12 @@ func validateMessage(res *parseResult, isProto3 bool, prefix string, md *dpb.Des
 	for _, fld := range md.Field {
 		fn := res.getFieldNode(fld)
 		if _, ok := rsvdNames[fld.GetName()]; ok {
-			if err := res.errs.handleErrorWithPos(fn.fieldName().start(), "%s: field %s is using a reserved name", scope, fld.GetName()); err != nil {
+			if err := res.errs.handleErrorWithPos(fn.FieldName().Start(), "%s: field %s is using a reserved name", scope, fld.GetName()); err != nil {
 				return err
 			}
 		}
 		if existing := fieldTags[fld.GetNumber()]; existing != "" {
-			if err := res.errs.handleErrorWithPos(fn.fieldTag().start(), "%s: fields %s and %s both have the same tag %d", scope, existing, fld.GetName(), fld.GetNumber()); err != nil {
+			if err := res.errs.handleErrorWithPos(fn.FieldTag().Start(), "%s: fields %s and %s both have the same tag %d", scope, existing, fld.GetName(), fld.GetNumber()); err != nil {
 				return err
 			}
 		}
@@ -168,14 +169,14 @@ func validateMessage(res *parseResult, isProto3 bool, prefix string, md *dpb.Des
 		// check reserved ranges
 		r := sort.Search(len(rsvd), func(index int) bool { return rsvd[index].end > fld.GetNumber() })
 		if r < len(rsvd) && rsvd[r].start <= fld.GetNumber() {
-			if err := res.errs.handleErrorWithPos(fn.fieldTag().start(), "%s: field %s is using tag %d which is in reserved range %d to %d", scope, fld.GetName(), fld.GetNumber(), rsvd[r].start, rsvd[r].end-1); err != nil {
+			if err := res.errs.handleErrorWithPos(fn.FieldTag().Start(), "%s: field %s is using tag %d which is in reserved range %d to %d", scope, fld.GetName(), fld.GetNumber(), rsvd[r].start, rsvd[r].end-1); err != nil {
 				return err
 			}
 		}
 		// and check extension ranges
 		e := sort.Search(len(exts), func(index int) bool { return exts[index].end > fld.GetNumber() })
 		if e < len(exts) && exts[e].start <= fld.GetNumber() {
-			if err := res.errs.handleErrorWithPos(fn.fieldTag().start(), "%s: field %s is using tag %d which is in extension range %d to %d", scope, fld.GetName(), fld.GetNumber(), exts[e].start, exts[e].end-1); err != nil {
+			if err := res.errs.handleErrorWithPos(fn.FieldTag().Start(), "%s: field %s is using tag %d which is in extension range %d to %d", scope, fld.GetName(), fld.GetNumber(), exts[e].start, exts[e].end-1); err != nil {
 				return err
 			}
 		}
@@ -193,28 +194,29 @@ func validateEnum(res *parseResult, isProto3 bool, prefix string, ed *dpb.EnumDe
 		// case the value would be absent from the descriptor. In such a case, this error
 		// would be confusing and incorrect, so we just skip this check.
 		enNode := res.getEnumNode(ed)
-		if err := res.errs.handleErrorWithPos(enNode.start(), "%s: enums must define at least one value", scope); err != nil {
+		if err := res.errs.handleErrorWithPos(enNode.Start(), "%s: enums must define at least one value", scope); err != nil {
 			return err
 		}
 	}
 
 	allowAlias := false
+	var allowAliasOpt *dpb.UninterpretedOption
 	if index, err := findOption(res, scope, ed.Options.GetUninterpretedOption(), "allow_alias"); err != nil {
 		return err
 	} else if index >= 0 {
-		opt := ed.Options.UninterpretedOption[index]
+		allowAliasOpt = ed.Options.UninterpretedOption[index]
 		valid := false
-		if opt.IdentifierValue != nil {
-			if opt.GetIdentifierValue() == "true" {
+		if allowAliasOpt.IdentifierValue != nil {
+			if allowAliasOpt.GetIdentifierValue() == "true" {
 				allowAlias = true
 				valid = true
-			} else if opt.GetIdentifierValue() == "false" {
+			} else if allowAliasOpt.GetIdentifierValue() == "false" {
 				valid = true
 			}
 		}
 		if !valid {
-			optNode := res.getOptionNode(opt)
-			if err := res.errs.handleErrorWithPos(optNode.getValue().start(), "%s: expecting bool value for allow_alias option", scope); err != nil {
+			optNode := res.getOptionNode(allowAliasOpt)
+			if err := res.errs.handleErrorWithPos(optNode.GetValue().Start(), "%s: expecting bool value for allow_alias option", scope); err != nil {
 				return err
 			}
 		}
@@ -222,22 +224,32 @@ func validateEnum(res *parseResult, isProto3 bool, prefix string, ed *dpb.EnumDe
 
 	if isProto3 && len(ed.Value) > 0 && ed.Value[0].GetNumber() != 0 {
 		evNode := res.getEnumValueNode(ed.Value[0])
-		if err := res.errs.handleErrorWithPos(evNode.getNumber().start(), "%s: proto3 requires that first value in enum have numeric value of 0", scope); err != nil {
+		if err := res.errs.handleErrorWithPos(evNode.GetNumber().Start(), "%s: proto3 requires that first value in enum have numeric value of 0", scope); err != nil {
 			return err
 		}
 	}
 
-	if !allowAlias {
-		// make sure all value numbers are distinct
-		vals := map[int32]string{}
-		for _, evd := range ed.Value {
-			if existing := vals[evd.GetNumber()]; existing != "" {
+	// check for aliases
+	vals := map[int32]string{}
+	hasAlias := false
+	for _, evd := range ed.Value {
+		existing := vals[evd.GetNumber()]
+		if existing != "" {
+			if allowAlias {
+				hasAlias = true
+			} else {
 				evNode := res.getEnumValueNode(evd)
-				if err := res.errs.handleErrorWithPos(evNode.getNumber().start(), "%s: values %s and %s both have the same numeric value %d; use allow_alias option if intentional", scope, existing, evd.GetName(), evd.GetNumber()); err != nil {
+				if err := res.errs.handleErrorWithPos(evNode.GetNumber().Start(), "%s: values %s and %s both have the same numeric value %d; use allow_alias option if intentional", scope, existing, evd.GetName(), evd.GetNumber()); err != nil {
 					return err
 				}
 			}
-			vals[evd.GetNumber()] = evd.GetName()
+		}
+		vals[evd.GetNumber()] = evd.GetName()
+	}
+	if allowAlias && !hasAlias {
+		optNode := res.getOptionNode(allowAliasOpt)
+		if err := res.errs.handleErrorWithPos(optNode.GetValue().Start(), "%s: allow_alias is true but no values are aliases", scope); err != nil {
+			return err
 		}
 	}
 
@@ -250,7 +262,7 @@ func validateEnum(res *parseResult, isProto3 bool, prefix string, ed *dpb.EnumDe
 	sort.Sort(rsvd)
 	for i := 1; i < len(rsvd); i++ {
 		if rsvd[i].start <= rsvd[i-1].end {
-			if err := res.errs.handleErrorWithPos(rsvd[i].node.start(), "%s: reserved ranges overlap: %d to %d and %d to %d", scope, rsvd[i-1].start, rsvd[i-1].end, rsvd[i].start, rsvd[i].end); err != nil {
+			if err := res.errs.handleErrorWithPos(rsvd[i].node.Start(), "%s: reserved ranges overlap: %d to %d and %d to %d", scope, rsvd[i-1].start, rsvd[i-1].end, rsvd[i].start, rsvd[i].end); err != nil {
 				return err
 			}
 		}
@@ -265,14 +277,14 @@ func validateEnum(res *parseResult, isProto3 bool, prefix string, ed *dpb.EnumDe
 	for _, ev := range ed.Value {
 		evn := res.getEnumValueNode(ev)
 		if _, ok := rsvdNames[ev.GetName()]; ok {
-			if err := res.errs.handleErrorWithPos(evn.getName().start(), "%s: value %s is using a reserved name", scope, ev.GetName()); err != nil {
+			if err := res.errs.handleErrorWithPos(evn.GetName().Start(), "%s: value %s is using a reserved name", scope, ev.GetName()); err != nil {
 				return err
 			}
 		}
 		// check reserved ranges
 		r := sort.Search(len(rsvd), func(index int) bool { return rsvd[index].end >= ev.GetNumber() })
 		if r < len(rsvd) && rsvd[r].start <= ev.GetNumber() {
-			if err := res.errs.handleErrorWithPos(evn.getNumber().start(), "%s: value %s is using number %d which is in reserved range %d to %d", scope, ev.GetName(), ev.GetNumber(), rsvd[r].start, rsvd[r].end); err != nil {
+			if err := res.errs.handleErrorWithPos(evn.GetNumber().Start(), "%s: value %s is using number %d which is in reserved range %d to %d", scope, ev.GetName(), ev.GetNumber(), rsvd[r].start, rsvd[r].end); err != nil {
 				return err
 			}
 		}
@@ -287,16 +299,11 @@ func validateField(res *parseResult, isProto3 bool, prefix string, fld *dpb.Fiel
 	node := res.getFieldNode(fld)
 	if isProto3 {
 		if fld.GetType() == dpb.FieldDescriptorProto_TYPE_GROUP {
-			n := node.(*groupNode)
-			if err := res.errs.handleErrorWithPos(n.groupKeyword.start(), "%s: groups are not allowed in proto3", scope); err != nil {
+			if err := res.errs.handleErrorWithPos(node.GetGroupKeyword().Start(), "%s: groups are not allowed in proto3", scope); err != nil {
 				return err
 			}
 		} else if fld.Label != nil && fld.GetLabel() == dpb.FieldDescriptorProto_LABEL_REQUIRED {
-			if err := res.errs.handleErrorWithPos(node.fieldLabel().start(), "%s: label 'required' is not allowed in proto3", scope); err != nil {
-				return err
-			}
-		} else if fld.Extendee != nil && fld.Label != nil && fld.GetLabel() == dpb.FieldDescriptorProto_LABEL_OPTIONAL {
-			if err := res.errs.handleErrorWithPos(node.fieldLabel().start(), "%s: label 'optional' is not allowed on extensions in proto3", scope); err != nil {
+			if err := res.errs.handleErrorWithPos(node.FieldLabel().Start(), "%s: label 'required' is not allowed in proto3", scope); err != nil {
 				return err
 			}
 		}
@@ -304,18 +311,18 @@ func validateField(res *parseResult, isProto3 bool, prefix string, fld *dpb.Fiel
 			return err
 		} else if index >= 0 {
 			optNode := res.getOptionNode(fld.Options.GetUninterpretedOption()[index])
-			if err := res.errs.handleErrorWithPos(optNode.getName().start(), "%s: default values are not allowed in proto3", scope); err != nil {
+			if err := res.errs.handleErrorWithPos(optNode.GetName().Start(), "%s: default values are not allowed in proto3", scope); err != nil {
 				return err
 			}
 		}
 	} else {
 		if fld.Label == nil && fld.OneofIndex == nil {
-			if err := res.errs.handleErrorWithPos(node.fieldName().start(), "%s: field has no label; proto2 requires explicit 'optional' label", scope); err != nil {
+			if err := res.errs.handleErrorWithPos(node.FieldName().Start(), "%s: field has no label; proto2 requires explicit 'optional' label", scope); err != nil {
 				return err
 			}
 		}
 		if fld.GetExtendee() != "" && fld.Label != nil && fld.GetLabel() == dpb.FieldDescriptorProto_LABEL_REQUIRED {
-			if err := res.errs.handleErrorWithPos(node.fieldLabel().start(), "%s: extension fields cannot be 'required'", scope); err != nil {
+			if err := res.errs.handleErrorWithPos(node.FieldLabel().Start(), "%s: extension fields cannot be 'required'", scope); err != nil {
 				return err
 			}
 		}
@@ -332,7 +339,7 @@ func validateField(res *parseResult, isProto3 bool, prefix string, fld *dpb.Fiel
 type tagRange struct {
 	start int32
 	end   int32
-	node  rangeDecl
+	node  ast.RangeDeclNode
 }
 
 type tagRanges []tagRange
diff --git a/vendor/github.com/jhump/protoreflect/dynamic/dynamic_message.go b/vendor/github.com/jhump/protoreflect/dynamic/dynamic_message.go
index 513971e7f..de13b923c 100644
--- a/vendor/github.com/jhump/protoreflect/dynamic/dynamic_message.go
+++ b/vendor/github.com/jhump/protoreflect/dynamic/dynamic_message.go
@@ -2529,17 +2529,14 @@ func (m *Message) mergeFrom(pm proto.Message) error {
 
 	// extension fields
 	rexts, _ := proto.ExtensionDescs(pm)
-	var unknownExtensions []byte
 	for _, ed := range rexts {
 		v, _ := proto.GetExtension(pm, ed)
 		if v == nil {
 			continue
 		}
 		if ed.ExtensionType == nil {
-			extBytes, _ := v.([]byte)
-			if len(extBytes) > 0 {
-				unknownExtensions = append(unknownExtensions, extBytes...)
-			}
+			// unrecognized extension: we'll handle that below when we
+			// handle other unrecognized fields
 			continue
 		}
 		fd := m.er.FindExtension(m.md.GetFullyQualifiedName(), ed.Field)
@@ -2569,13 +2566,6 @@ func (m *Message) mergeFrom(pm proto.Message) error {
 		_ = m.UnmarshalMerge(data)
 	}
 
-	// lastly, also extract any unknown extensions the message may have (unknown extensions
-	// are stored with other extensions, not in the XXX_unrecognized field, so we have to do
-	// more than just the step above...)
-	if len(unknownExtensions) > 0 {
-		// pulling in unknown fields is best-effort, so we just ignore errors
-		_ = m.UnmarshalMerge(unknownExtensions)
-	}
 	return nil
 }
 
@@ -2627,12 +2617,15 @@ func (m *Message) validateRecursive(prefix string) error {
 			var dm *Message
 			if d, ok := pm.(*Message); ok {
 				dm = d
-			} else {
+			} else if pm != nil {
 				dm = m.mf.NewDynamicMessage(md)
 				if err := dm.ConvertFrom(pm); err != nil {
 					return nil
 				}
 			}
+			if dm == nil {
+				return nil
+			}
 			if err := dm.validateRecursive(chprefix); err != nil {
 				return err
 			}
diff --git a/vendor/google.golang.org/protobuf/encoding/protojson/decode.go b/vendor/google.golang.org/protobuf/encoding/protojson/decode.go
index 9bf4e8c17..e6953ad66 100644
--- a/vendor/google.golang.org/protobuf/encoding/protojson/decode.go
+++ b/vendor/google.golang.org/protobuf/encoding/protojson/decode.go
@@ -124,15 +124,6 @@ func (d decoder) unmarshalMessage(m pref.Message, skipTypeURL bool) error {
 		return d.unexpectedTokenError(tok)
 	}
 
-	if err := d.unmarshalFields(m, skipTypeURL); err != nil {
-		return err
-	}
-
-	return nil
-}
-
-// unmarshalFields unmarshals the fields into the given protoreflect.Message.
-func (d decoder) unmarshalFields(m pref.Message, skipTypeURL bool) error {
 	messageDesc := m.Descriptor()
 	if !flags.ProtoLegacy && messageset.IsMessageSet(messageDesc) {
 		return errors.New("no support for proto1 MessageSets")
@@ -170,7 +161,7 @@ func (d decoder) unmarshalFields(m pref.Message, skipTypeURL bool) error {
 		if strings.HasPrefix(name, "[") && strings.HasSuffix(name, "]") {
 			// Only extension names are in [name] format.
 			extName := pref.FullName(name[1 : len(name)-1])
-			extType, err := d.findExtension(extName)
+			extType, err := d.opts.Resolver.FindExtensionByName(extName)
 			if err != nil && err != protoregistry.NotFound {
 				return d.newError(tok.Pos(), "unable to resolve %s: %v", tok.RawString(), err)
 			}
@@ -184,17 +175,7 @@ func (d decoder) unmarshalFields(m pref.Message, skipTypeURL bool) error {
 			// The name can either be the JSON name or the proto field name.
 			fd = fieldDescs.ByJSONName(name)
 			if fd == nil {
-				fd = fieldDescs.ByName(pref.Name(name))
-				if fd == nil {
-					// The proto name of a group field is in all lowercase,
-					// while the textual field name is the group message name.
-					gd := fieldDescs.ByName(pref.Name(strings.ToLower(name)))
-					if gd != nil && gd.Kind() == pref.GroupKind && gd.Message().Name() == pref.Name(name) {
-						fd = gd
-					}
-				} else if fd.Kind() == pref.GroupKind && fd.Message().Name() != pref.Name(name) {
-					fd = nil // reset since field name is actually the message name
-				}
+				fd = fieldDescs.ByTextName(name)
 			}
 		}
 		if flags.ProtoLegacy {
@@ -257,15 +238,6 @@ func (d decoder) unmarshalFields(m pref.Message, skipTypeURL bool) error {
 	}
 }
 
-// findExtension returns protoreflect.ExtensionType from the resolver if found.
-func (d decoder) findExtension(xtName pref.FullName) (pref.ExtensionType, error) {
-	xt, err := d.opts.Resolver.FindExtensionByName(xtName)
-	if err == nil {
-		return xt, nil
-	}
-	return messageset.FindMessageSetExtension(d.opts.Resolver, xtName)
-}
-
 func isKnownValue(fd pref.FieldDescriptor) bool {
 	md := fd.Message()
 	return md != nil && md.FullName() == genid.Value_message_fullname
diff --git a/vendor/google.golang.org/protobuf/encoding/protojson/encode.go b/vendor/google.golang.org/protobuf/encoding/protojson/encode.go
index 7d6193300..ba971f078 100644
--- a/vendor/google.golang.org/protobuf/encoding/protojson/encode.go
+++ b/vendor/google.golang.org/protobuf/encoding/protojson/encode.go
@@ -7,15 +7,17 @@ package protojson
 import (
 	"encoding/base64"
 	"fmt"
-	"sort"
 
 	"google.golang.org/protobuf/internal/encoding/json"
 	"google.golang.org/protobuf/internal/encoding/messageset"
 	"google.golang.org/protobuf/internal/errors"
+	"google.golang.org/protobuf/internal/filedesc"
 	"google.golang.org/protobuf/internal/flags"
 	"google.golang.org/protobuf/internal/genid"
+	"google.golang.org/protobuf/internal/order"
 	"google.golang.org/protobuf/internal/pragma"
 	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/reflect/protoreflect"
 	pref "google.golang.org/protobuf/reflect/protoreflect"
 	"google.golang.org/protobuf/reflect/protoregistry"
 )
@@ -131,7 +133,7 @@ func (o MarshalOptions) marshal(m proto.Message) ([]byte, error) {
 	}
 
 	enc := encoder{internalEnc, o}
-	if err := enc.marshalMessage(m.ProtoReflect()); err != nil {
+	if err := enc.marshalMessage(m.ProtoReflect(), ""); err != nil {
 		return nil, err
 	}
 	if o.AllowPartial {
@@ -145,76 +147,94 @@ type encoder struct {
 	opts MarshalOptions
 }
 
-// marshalMessage marshals the given protoreflect.Message.
-func (e encoder) marshalMessage(m pref.Message) error {
-	if marshal := wellKnownTypeMarshaler(m.Descriptor().FullName()); marshal != nil {
-		return marshal(e, m)
-	}
+// typeFieldDesc is a synthetic field descriptor used for the "@type" field.
+var typeFieldDesc = func() protoreflect.FieldDescriptor {
+	var fd filedesc.Field
+	fd.L0.FullName = "@type"
+	fd.L0.Index = -1
+	fd.L1.Cardinality = protoreflect.Optional
+	fd.L1.Kind = protoreflect.StringKind
+	return &fd
+}()
+
+// typeURLFieldRanger wraps a protoreflect.Message and modifies its Range method
+// to additionally iterate over a synthetic field for the type URL.
+type typeURLFieldRanger struct {
+	order.FieldRanger
+	typeURL string
+}
 
-	e.StartObject()
-	defer e.EndObject()
-	if err := e.marshalFields(m); err != nil {
-		return err
+func (m typeURLFieldRanger) Range(f func(pref.FieldDescriptor, pref.Value) bool) {
+	if !f(typeFieldDesc, pref.ValueOfString(m.typeURL)) {
+		return
 	}
+	m.FieldRanger.Range(f)
+}
 
-	return nil
+// unpopulatedFieldRanger wraps a protoreflect.Message and modifies its Range
+// method to additionally iterate over unpopulated fields.
+type unpopulatedFieldRanger struct{ pref.Message }
+
+func (m unpopulatedFieldRanger) Range(f func(pref.FieldDescriptor, pref.Value) bool) {
+	fds := m.Descriptor().Fields()
+	for i := 0; i < fds.Len(); i++ {
+		fd := fds.Get(i)
+		if m.Has(fd) || fd.ContainingOneof() != nil {
+			continue // ignore populated fields and fields within a oneofs
+		}
+
+		v := m.Get(fd)
+		isProto2Scalar := fd.Syntax() == pref.Proto2 && fd.Default().IsValid()
+		isSingularMessage := fd.Cardinality() != pref.Repeated && fd.Message() != nil
+		if isProto2Scalar || isSingularMessage {
+			v = pref.Value{} // use invalid value to emit null
+		}
+		if !f(fd, v) {
+			return
+		}
+	}
+	m.Message.Range(f)
 }
 
-// marshalFields marshals the fields in the given protoreflect.Message.
-func (e encoder) marshalFields(m pref.Message) error {
-	messageDesc := m.Descriptor()
-	if !flags.ProtoLegacy && messageset.IsMessageSet(messageDesc) {
+// marshalMessage marshals the fields in the given protoreflect.Message.
+// If the typeURL is non-empty, then a synthetic "@type" field is injected
+// containing the URL as the value.
+func (e encoder) marshalMessage(m pref.Message, typeURL string) error {
+	if !flags.ProtoLegacy && messageset.IsMessageSet(m.Descriptor()) {
 		return errors.New("no support for proto1 MessageSets")
 	}
 
-	// Marshal out known fields.
-	fieldDescs := messageDesc.Fields()
-	for i := 0; i < fieldDescs.Len(); {
-		fd := fieldDescs.Get(i)
-		if od := fd.ContainingOneof(); od != nil {
-			fd = m.WhichOneof(od)
-			i += od.Fields().Len()
-			if fd == nil {
-				continue // unpopulated oneofs are not affected by EmitUnpopulated
-			}
-		} else {
-			i++
-		}
+	if marshal := wellKnownTypeMarshaler(m.Descriptor().FullName()); marshal != nil {
+		return marshal(e, m)
+	}
 
-		val := m.Get(fd)
-		if !m.Has(fd) {
-			if !e.opts.EmitUnpopulated {
-				continue
-			}
-			isProto2Scalar := fd.Syntax() == pref.Proto2 && fd.Default().IsValid()
-			isSingularMessage := fd.Cardinality() != pref.Repeated && fd.Message() != nil
-			if isProto2Scalar || isSingularMessage {
-				// Use invalid value to emit null.
-				val = pref.Value{}
-			}
-		}
+	e.StartObject()
+	defer e.EndObject()
 
+	var fields order.FieldRanger = m
+	if e.opts.EmitUnpopulated {
+		fields = unpopulatedFieldRanger{m}
+	}
+	if typeURL != "" {
+		fields = typeURLFieldRanger{fields, typeURL}
+	}
+
+	var err error
+	order.RangeFields(fields, order.IndexNameFieldOrder, func(fd pref.FieldDescriptor, v pref.Value) bool {
 		name := fd.JSONName()
 		if e.opts.UseProtoNames {
-			name = string(fd.Name())
-			// Use type name for group field name.
-			if fd.Kind() == pref.GroupKind {
-				name = string(fd.Message().Name())
-			}
+			name = fd.TextName()
 		}
-		if err := e.WriteName(name); err != nil {
-			return err
+
+		if err = e.WriteName(name); err != nil {
+			return false
 		}
-		if err := e.marshalValue(val, fd); err != nil {
-			return err
+		if err = e.marshalValue(v, fd); err != nil {
+			return false
 		}
-	}
-
-	// Marshal out extensions.
-	if err := e.marshalExtensions(m); err != nil {
-		return err
-	}
-	return nil
+		return true
+	})
+	return err
 }
 
 // marshalValue marshals the given protoreflect.Value.
@@ -281,7 +301,7 @@ func (e encoder) marshalSingular(val pref.Value, fd pref.FieldDescriptor) error
 		}
 
 	case pref.MessageKind, pref.GroupKind:
-		if err := e.marshalMessage(val.Message()); err != nil {
+		if err := e.marshalMessage(val.Message(), ""); err != nil {
 			return err
 		}
 
@@ -305,98 +325,20 @@ func (e encoder) marshalList(list pref.List, fd pref.FieldDescriptor) error {
 	return nil
 }
 
-type mapEntry struct {
-	key   pref.MapKey
-	value pref.Value
-}
-
 // marshalMap marshals given protoreflect.Map.
 func (e encoder) marshalMap(mmap pref.Map, fd pref.FieldDescriptor) error {
 	e.StartObject()
 	defer e.EndObject()
 
-	// Get a sorted list based on keyType first.
-	entries := make([]mapEntry, 0, mmap.Len())
-	mmap.Range(func(key pref.MapKey, val pref.Value) bool {
-		entries = append(entries, mapEntry{key: key, value: val})
-		return true
-	})
-	sortMap(fd.MapKey().Kind(), entries)
-
-	// Write out sorted list.
-	for _, entry := range entries {
-		if err := e.WriteName(entry.key.String()); err != nil {
-			return err
-		}
-		if err := e.marshalSingular(entry.value, fd.MapValue()); err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-// sortMap orders list based on value of key field for deterministic ordering.
-func sortMap(keyKind pref.Kind, values []mapEntry) {
-	sort.Slice(values, func(i, j int) bool {
-		switch keyKind {
-		case pref.Int32Kind, pref.Sint32Kind, pref.Sfixed32Kind,
-			pref.Int64Kind, pref.Sint64Kind, pref.Sfixed64Kind:
-			return values[i].key.Int() < values[j].key.Int()
-
-		case pref.Uint32Kind, pref.Fixed32Kind,
-			pref.Uint64Kind, pref.Fixed64Kind:
-			return values[i].key.Uint() < values[j].key.Uint()
+	var err error
+	order.RangeEntries(mmap, order.GenericKeyOrder, func(k pref.MapKey, v pref.Value) bool {
+		if err = e.WriteName(k.String()); err != nil {
+			return false
 		}
-		return values[i].key.String() < values[j].key.String()
-	})
-}
-
-// marshalExtensions marshals extension fields.
-func (e encoder) marshalExtensions(m pref.Message) error {
-	type entry struct {
-		key   string
-		value pref.Value
-		desc  pref.FieldDescriptor
-	}
-
-	// Get a sorted list based on field key first.
-	var entries []entry
-	m.Range(func(fd pref.FieldDescriptor, v pref.Value) bool {
-		if !fd.IsExtension() {
-			return true
+		if err = e.marshalSingular(v, fd.MapValue()); err != nil {
+			return false
 		}
-
-		// For MessageSet extensions, the name used is the parent message.
-		name := fd.FullName()
-		if messageset.IsMessageSetExtension(fd) {
-			name = name.Parent()
-		}
-
-		// Use [name] format for JSON field name.
-		entries = append(entries, entry{
-			key:   string(name),
-			value: v,
-			desc:  fd,
-		})
 		return true
 	})
-
-	// Sort extensions lexicographically.
-	sort.Slice(entries, func(i, j int) bool {
-		return entries[i].key < entries[j].key
-	})
-
-	// Write out sorted list.
-	for _, entry := range entries {
-		// JSON field name is the proto field name enclosed in [], similar to
-		// textproto. This is consistent with Go v1 lib. C++ lib v3.7.0 does not
-		// marshal out extension fields.
-		if err := e.WriteName("[" + entry.key + "]"); err != nil {
-			return err
-		}
-		if err := e.marshalValue(entry.value, entry.desc); err != nil {
-			return err
-		}
-	}
-	return nil
+	return err
 }
diff --git a/vendor/google.golang.org/protobuf/encoding/protojson/well_known_types.go b/vendor/google.golang.org/protobuf/encoding/protojson/well_known_types.go
index def7377c7..73b038eba 100644
--- a/vendor/google.golang.org/protobuf/encoding/protojson/well_known_types.go
+++ b/vendor/google.golang.org/protobuf/encoding/protojson/well_known_types.go
@@ -106,13 +106,11 @@ func (e encoder) marshalAny(m pref.Message) error {
 	fdType := fds.ByNumber(genid.Any_TypeUrl_field_number)
 	fdValue := fds.ByNumber(genid.Any_Value_field_number)
 
-	// Start writing the JSON object.
-	e.StartObject()
-	defer e.EndObject()
-
 	if !m.Has(fdType) {
 		if !m.Has(fdValue) {
 			// If message is empty, marshal out empty JSON object.
+			e.StartObject()
+			e.EndObject()
 			return nil
 		} else {
 			// Return error if type_url field is not set, but value is set.
@@ -123,14 +121,8 @@ func (e encoder) marshalAny(m pref.Message) error {
 	typeVal := m.Get(fdType)
 	valueVal := m.Get(fdValue)
 
-	// Marshal out @type field.
-	typeURL := typeVal.String()
-	e.WriteName("@type")
-	if err := e.WriteString(typeURL); err != nil {
-		return err
-	}
-
 	// Resolve the type in order to unmarshal value field.
+	typeURL := typeVal.String()
 	emt, err := e.opts.Resolver.FindMessageByURL(typeURL)
 	if err != nil {
 		return errors.New("%s: unable to resolve %q: %v", genid.Any_message_fullname, typeURL, err)
@@ -149,12 +141,21 @@ func (e encoder) marshalAny(m pref.Message) error {
 	// with corresponding custom JSON encoding of the embedded message as a
 	// field.
 	if marshal := wellKnownTypeMarshaler(emt.Descriptor().FullName()); marshal != nil {
+		e.StartObject()
+		defer e.EndObject()
+
+		// Marshal out @type field.
+		e.WriteName("@type")
+		if err := e.WriteString(typeURL); err != nil {
+			return err
+		}
+
 		e.WriteName("value")
 		return marshal(e, em)
 	}
 
 	// Else, marshal out the embedded message's fields in this Any object.
-	if err := e.marshalFields(em); err != nil {
+	if err := e.marshalMessage(em, typeURL); err != nil {
 		return err
 	}
 
diff --git a/vendor/google.golang.org/protobuf/encoding/prototext/decode.go b/vendor/google.golang.org/protobuf/encoding/prototext/decode.go
index cab95a427..e2bbf7c60 100644
--- a/vendor/google.golang.org/protobuf/encoding/prototext/decode.go
+++ b/vendor/google.golang.org/protobuf/encoding/prototext/decode.go
@@ -6,7 +6,6 @@ package prototext
 
 import (
 	"fmt"
-	"strings"
 	"unicode/utf8"
 
 	"google.golang.org/protobuf/internal/encoding/messageset"
@@ -158,21 +157,11 @@ func (d decoder) unmarshalMessage(m pref.Message, checkDelims bool) error {
 		switch tok.NameKind() {
 		case text.IdentName:
 			name = pref.Name(tok.IdentName())
-			fd = fieldDescs.ByName(name)
-			if fd == nil {
-				// The proto name of a group field is in all lowercase,
-				// while the textproto field name is the group message name.
-				gd := fieldDescs.ByName(pref.Name(strings.ToLower(string(name))))
-				if gd != nil && gd.Kind() == pref.GroupKind && gd.Message().Name() == name {
-					fd = gd
-				}
-			} else if fd.Kind() == pref.GroupKind && fd.Message().Name() != name {
-				fd = nil // reset since field name is actually the message name
-			}
+			fd = fieldDescs.ByTextName(string(name))
 
 		case text.TypeName:
 			// Handle extensions only. This code path is not for Any.
-			xt, xtErr = d.findExtension(pref.FullName(tok.TypeName()))
+			xt, xtErr = d.opts.Resolver.FindExtensionByName(pref.FullName(tok.TypeName()))
 
 		case text.FieldNumber:
 			isFieldNumberName = true
@@ -269,15 +258,6 @@ func (d decoder) unmarshalMessage(m pref.Message, checkDelims bool) error {
 	return nil
 }
 
-// findExtension returns protoreflect.ExtensionType from the Resolver if found.
-func (d decoder) findExtension(xtName pref.FullName) (pref.ExtensionType, error) {
-	xt, err := d.opts.Resolver.FindExtensionByName(xtName)
-	if err == nil {
-		return xt, nil
-	}
-	return messageset.FindMessageSetExtension(d.opts.Resolver, xtName)
-}
-
 // unmarshalSingular unmarshals a non-repeated field value specified by the
 // given FieldDescriptor.
 func (d decoder) unmarshalSingular(fd pref.FieldDescriptor, m pref.Message) error {
diff --git a/vendor/google.golang.org/protobuf/encoding/prototext/encode.go b/vendor/google.golang.org/protobuf/encoding/prototext/encode.go
index 0877d71c5..8d5304dc5 100644
--- a/vendor/google.golang.org/protobuf/encoding/prototext/encode.go
+++ b/vendor/google.golang.org/protobuf/encoding/prototext/encode.go
@@ -6,7 +6,6 @@ package prototext
 
 import (
 	"fmt"
-	"sort"
 	"strconv"
 	"unicode/utf8"
 
@@ -16,10 +15,11 @@ import (
 	"google.golang.org/protobuf/internal/errors"
 	"google.golang.org/protobuf/internal/flags"
 	"google.golang.org/protobuf/internal/genid"
-	"google.golang.org/protobuf/internal/mapsort"
+	"google.golang.org/protobuf/internal/order"
 	"google.golang.org/protobuf/internal/pragma"
 	"google.golang.org/protobuf/internal/strs"
 	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/reflect/protoreflect"
 	pref "google.golang.org/protobuf/reflect/protoreflect"
 	"google.golang.org/protobuf/reflect/protoregistry"
 )
@@ -169,35 +169,15 @@ func (e encoder) marshalMessage(m pref.Message, inclDelims bool) error {
 		// If unable to expand, continue on to marshal Any as a regular message.
 	}
 
-	// Marshal known fields.
-	fieldDescs := messageDesc.Fields()
-	size := fieldDescs.Len()
-	for i := 0; i < size; {
-		fd := fieldDescs.Get(i)
-		if od := fd.ContainingOneof(); od != nil {
-			fd = m.WhichOneof(od)
-			i += od.Fields().Len()
-		} else {
-			i++
-		}
-
-		if fd == nil || !m.Has(fd) {
-			continue
-		}
-
-		name := fd.Name()
-		// Use type name for group field name.
-		if fd.Kind() == pref.GroupKind {
-			name = fd.Message().Name()
-		}
-		val := m.Get(fd)
-		if err := e.marshalField(string(name), val, fd); err != nil {
-			return err
+	// Marshal fields.
+	var err error
+	order.RangeFields(m, order.IndexNameFieldOrder, func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
+		if err = e.marshalField(fd.TextName(), v, fd); err != nil {
+			return false
 		}
-	}
-
-	// Marshal extensions.
-	if err := e.marshalExtensions(m); err != nil {
+		return true
+	})
+	if err != nil {
 		return err
 	}
 
@@ -290,7 +270,7 @@ func (e encoder) marshalList(name string, list pref.List, fd pref.FieldDescripto
 // marshalMap marshals the given protoreflect.Map as multiple name-value fields.
 func (e encoder) marshalMap(name string, mmap pref.Map, fd pref.FieldDescriptor) error {
 	var err error
-	mapsort.Range(mmap, fd.MapKey().Kind(), func(key pref.MapKey, val pref.Value) bool {
+	order.RangeEntries(mmap, order.GenericKeyOrder, func(key pref.MapKey, val pref.Value) bool {
 		e.WriteName(name)
 		e.StartMessage()
 		defer e.EndMessage()
@@ -311,48 +291,6 @@ func (e encoder) marshalMap(name string, mmap pref.Map, fd pref.FieldDescriptor)
 	return err
 }
 
-// marshalExtensions marshals extension fields.
-func (e encoder) marshalExtensions(m pref.Message) error {
-	type entry struct {
-		key   string
-		value pref.Value
-		desc  pref.FieldDescriptor
-	}
-
-	// Get a sorted list based on field key first.
-	var entries []entry
-	m.Range(func(fd pref.FieldDescriptor, v pref.Value) bool {
-		if !fd.IsExtension() {
-			return true
-		}
-		// For MessageSet extensions, the name used is the parent message.
-		name := fd.FullName()
-		if messageset.IsMessageSetExtension(fd) {
-			name = name.Parent()
-		}
-		entries = append(entries, entry{
-			key:   string(name),
-			value: v,
-			desc:  fd,
-		})
-		return true
-	})
-	// Sort extensions lexicographically.
-	sort.Slice(entries, func(i, j int) bool {
-		return entries[i].key < entries[j].key
-	})
-
-	// Write out sorted list.
-	for _, entry := range entries {
-		// Extension field name is the proto field name enclosed in [].
-		name := "[" + entry.key + "]"
-		if err := e.marshalField(name, entry.value, entry.desc); err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
 // marshalUnknown parses the given []byte and marshals fields out.
 // This function assumes proper encoding in the given []byte.
 func (e encoder) marshalUnknown(b []byte) {
diff --git a/vendor/google.golang.org/protobuf/internal/detrand/rand.go b/vendor/google.golang.org/protobuf/internal/detrand/rand.go
index a904dd1f9..49c8676d4 100644
--- a/vendor/google.golang.org/protobuf/internal/detrand/rand.go
+++ b/vendor/google.golang.org/protobuf/internal/detrand/rand.go
@@ -26,6 +26,14 @@ func Bool() bool {
 	return randSeed%2 == 1
 }
 
+// Intn returns a deterministically random integer between 0 and n-1, inclusive.
+func Intn(n int) int {
+	if n <= 0 {
+		panic("must be positive")
+	}
+	return int(randSeed % uint64(n))
+}
+
 // randSeed is a best-effort at an approximate hash of the Go binary.
 var randSeed = binaryHash()
 
diff --git a/vendor/google.golang.org/protobuf/internal/encoding/messageset/messageset.go b/vendor/google.golang.org/protobuf/internal/encoding/messageset/messageset.go
index b1eeea507..453a81a56 100644
--- a/vendor/google.golang.org/protobuf/internal/encoding/messageset/messageset.go
+++ b/vendor/google.golang.org/protobuf/internal/encoding/messageset/messageset.go
@@ -11,7 +11,6 @@ import (
 	"google.golang.org/protobuf/encoding/protowire"
 	"google.golang.org/protobuf/internal/errors"
 	pref "google.golang.org/protobuf/reflect/protoreflect"
-	preg "google.golang.org/protobuf/reflect/protoregistry"
 )
 
 // The MessageSet wire format is equivalent to a message defiend as follows,
@@ -48,33 +47,17 @@ func IsMessageSet(md pref.MessageDescriptor) bool {
 	return ok && xmd.IsMessageSet()
 }
 
-// IsMessageSetExtension reports this field extends a MessageSet.
+// IsMessageSetExtension reports this field properly extends a MessageSet.
 func IsMessageSetExtension(fd pref.FieldDescriptor) bool {
-	if fd.Name() != ExtensionName {
+	switch {
+	case fd.Name() != ExtensionName:
 		return false
-	}
-	if fd.FullName().Parent() != fd.Message().FullName() {
+	case !IsMessageSet(fd.ContainingMessage()):
+		return false
+	case fd.FullName().Parent() != fd.Message().FullName():
 		return false
 	}
-	return IsMessageSet(fd.ContainingMessage())
-}
-
-// FindMessageSetExtension locates a MessageSet extension field by name.
-// In text and JSON formats, the extension name used is the message itself.
-// The extension field name is derived by appending ExtensionName.
-func FindMessageSetExtension(r preg.ExtensionTypeResolver, s pref.FullName) (pref.ExtensionType, error) {
-	name := s.Append(ExtensionName)
-	xt, err := r.FindExtensionByName(name)
-	if err != nil {
-		if err == preg.NotFound {
-			return nil, err
-		}
-		return nil, errors.Wrap(err, "%q", name)
-	}
-	if !IsMessageSetExtension(xt.TypeDescriptor()) {
-		return nil, preg.NotFound
-	}
-	return xt, nil
+	return true
 }
 
 // SizeField returns the size of a MessageSet item field containing an extension
diff --git a/vendor/google.golang.org/protobuf/internal/encoding/tag/tag.go b/vendor/google.golang.org/protobuf/internal/encoding/tag/tag.go
index 16c02d7b6..38f1931c6 100644
--- a/vendor/google.golang.org/protobuf/internal/encoding/tag/tag.go
+++ b/vendor/google.golang.org/protobuf/internal/encoding/tag/tag.go
@@ -104,7 +104,7 @@ func Unmarshal(tag string, goType reflect.Type, evs pref.EnumValueDescriptors) p
 		case strings.HasPrefix(s, "json="):
 			jsonName := s[len("json="):]
 			if jsonName != strs.JSONCamelCase(string(f.L0.FullName.Name())) {
-				f.L1.JSONName.Init(jsonName)
+				f.L1.StringName.InitJSON(jsonName)
 			}
 		case s == "packed":
 			f.L1.HasPacked = true
diff --git a/vendor/google.golang.org/protobuf/internal/fieldsort/fieldsort.go b/vendor/google.golang.org/protobuf/internal/fieldsort/fieldsort.go
deleted file mode 100644
index 517c4e2a0..000000000
--- a/vendor/google.golang.org/protobuf/internal/fieldsort/fieldsort.go
+++ /dev/null
@@ -1,40 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package fieldsort defines an ordering of fields.
-//
-// The ordering defined by this package matches the historic behavior of the proto
-// package, placing extensions first and oneofs last.
-//
-// There is no guarantee about stability of the wire encoding, and users should not
-// depend on the order defined in this package as it is subject to change without
-// notice.
-package fieldsort
-
-import (
-	"google.golang.org/protobuf/reflect/protoreflect"
-)
-
-// Less returns true if field a comes before field j in ordered wire marshal output.
-func Less(a, b protoreflect.FieldDescriptor) bool {
-	ea := a.IsExtension()
-	eb := b.IsExtension()
-	oa := a.ContainingOneof()
-	ob := b.ContainingOneof()
-	switch {
-	case ea != eb:
-		return ea
-	case oa != nil && ob != nil:
-		if oa == ob {
-			return a.Number() < b.Number()
-		}
-		return oa.Index() < ob.Index()
-	case oa != nil && !oa.IsSynthetic():
-		return false
-	case ob != nil && !ob.IsSynthetic():
-		return true
-	default:
-		return a.Number() < b.Number()
-	}
-}
diff --git a/vendor/google.golang.org/protobuf/internal/filedesc/build.go b/vendor/google.golang.org/protobuf/internal/filedesc/build.go
index d02d770c9..b293b6947 100644
--- a/vendor/google.golang.org/protobuf/internal/filedesc/build.go
+++ b/vendor/google.golang.org/protobuf/internal/filedesc/build.go
@@ -3,6 +3,9 @@
 // license that can be found in the LICENSE file.
 
 // Package filedesc provides functionality for constructing descriptors.
+//
+// The types in this package implement interfaces in the protoreflect package
+// related to protobuf descripriptors.
 package filedesc
 
 import (
diff --git a/vendor/google.golang.org/protobuf/internal/filedesc/desc.go b/vendor/google.golang.org/protobuf/internal/filedesc/desc.go
index 9385126fb..12f65f378 100644
--- a/vendor/google.golang.org/protobuf/internal/filedesc/desc.go
+++ b/vendor/google.golang.org/protobuf/internal/filedesc/desc.go
@@ -13,6 +13,7 @@ import (
 	"google.golang.org/protobuf/internal/descfmt"
 	"google.golang.org/protobuf/internal/descopts"
 	"google.golang.org/protobuf/internal/encoding/defval"
+	"google.golang.org/protobuf/internal/encoding/messageset"
 	"google.golang.org/protobuf/internal/genid"
 	"google.golang.org/protobuf/internal/pragma"
 	"google.golang.org/protobuf/internal/strs"
@@ -207,7 +208,7 @@ type (
 		Number           pref.FieldNumber
 		Cardinality      pref.Cardinality // must be consistent with Message.RequiredNumbers
 		Kind             pref.Kind
-		JSONName         jsonName
+		StringName       stringName
 		IsProto3Optional bool // promoted from google.protobuf.FieldDescriptorProto
 		IsWeak           bool // promoted from google.protobuf.FieldOptions
 		HasPacked        bool // promoted from google.protobuf.FieldOptions
@@ -277,8 +278,9 @@ func (fd *Field) Options() pref.ProtoMessage {
 func (fd *Field) Number() pref.FieldNumber      { return fd.L1.Number }
 func (fd *Field) Cardinality() pref.Cardinality { return fd.L1.Cardinality }
 func (fd *Field) Kind() pref.Kind               { return fd.L1.Kind }
-func (fd *Field) HasJSONName() bool             { return fd.L1.JSONName.has }
-func (fd *Field) JSONName() string              { return fd.L1.JSONName.get(fd) }
+func (fd *Field) HasJSONName() bool             { return fd.L1.StringName.hasJSON }
+func (fd *Field) JSONName() string              { return fd.L1.StringName.getJSON(fd) }
+func (fd *Field) TextName() string              { return fd.L1.StringName.getText(fd) }
 func (fd *Field) HasPresence() bool {
 	return fd.L1.Cardinality != pref.Repeated && (fd.L0.ParentFile.L1.Syntax == pref.Proto2 || fd.L1.Message != nil || fd.L1.ContainingOneof != nil)
 }
@@ -373,7 +375,7 @@ type (
 	}
 	ExtensionL2 struct {
 		Options          func() pref.ProtoMessage
-		JSONName         jsonName
+		StringName       stringName
 		IsProto3Optional bool // promoted from google.protobuf.FieldDescriptorProto
 		IsPacked         bool // promoted from google.protobuf.FieldOptions
 		Default          defaultValue
@@ -391,8 +393,9 @@ func (xd *Extension) Options() pref.ProtoMessage {
 func (xd *Extension) Number() pref.FieldNumber      { return xd.L1.Number }
 func (xd *Extension) Cardinality() pref.Cardinality { return xd.L1.Cardinality }
 func (xd *Extension) Kind() pref.Kind               { return xd.L1.Kind }
-func (xd *Extension) HasJSONName() bool             { return xd.lazyInit().JSONName.has }
-func (xd *Extension) JSONName() string              { return xd.lazyInit().JSONName.get(xd) }
+func (xd *Extension) HasJSONName() bool             { return xd.lazyInit().StringName.hasJSON }
+func (xd *Extension) JSONName() string              { return xd.lazyInit().StringName.getJSON(xd) }
+func (xd *Extension) TextName() string              { return xd.lazyInit().StringName.getText(xd) }
 func (xd *Extension) HasPresence() bool             { return xd.L1.Cardinality != pref.Repeated }
 func (xd *Extension) HasOptionalKeyword() bool {
 	return (xd.L0.ParentFile.L1.Syntax == pref.Proto2 && xd.L1.Cardinality == pref.Optional) || xd.lazyInit().IsProto3Optional
@@ -506,27 +509,50 @@ func (d *Base) Syntax() pref.Syntax                 { return d.L0.ParentFile.Syn
 func (d *Base) IsPlaceholder() bool                 { return false }
 func (d *Base) ProtoInternal(pragma.DoNotImplement) {}
 
-type jsonName struct {
-	has  bool
-	once sync.Once
-	name string
+type stringName struct {
+	hasJSON  bool
+	once     sync.Once
+	nameJSON string
+	nameText string
 }
 
-// Init initializes the name. It is exported for use by other internal packages.
-func (js *jsonName) Init(s string) {
-	js.has = true
-	js.name = s
+// InitJSON initializes the name. It is exported for use by other internal packages.
+func (s *stringName) InitJSON(name string) {
+	s.hasJSON = true
+	s.nameJSON = name
 }
 
-func (js *jsonName) get(fd pref.FieldDescriptor) string {
-	if !js.has {
-		js.once.Do(func() {
-			js.name = strs.JSONCamelCase(string(fd.Name()))
-		})
-	}
-	return js.name
+func (s *stringName) lazyInit(fd pref.FieldDescriptor) *stringName {
+	s.once.Do(func() {
+		if fd.IsExtension() {
+			// For extensions, JSON and text are formatted the same way.
+			var name string
+			if messageset.IsMessageSetExtension(fd) {
+				name = string("[" + fd.FullName().Parent() + "]")
+			} else {
+				name = string("[" + fd.FullName() + "]")
+			}
+			s.nameJSON = name
+			s.nameText = name
+		} else {
+			// Format the JSON name.
+			if !s.hasJSON {
+				s.nameJSON = strs.JSONCamelCase(string(fd.Name()))
+			}
+
+			// Format the text name.
+			s.nameText = string(fd.Name())
+			if fd.Kind() == pref.GroupKind {
+				s.nameText = string(fd.Message().Name())
+			}
+		}
+	})
+	return s
 }
 
+func (s *stringName) getJSON(fd pref.FieldDescriptor) string { return s.lazyInit(fd).nameJSON }
+func (s *stringName) getText(fd pref.FieldDescriptor) string { return s.lazyInit(fd).nameText }
+
 func DefaultValue(v pref.Value, ev pref.EnumValueDescriptor) defaultValue {
 	dv := defaultValue{has: v.IsValid(), val: v, enum: ev}
 	if b, ok := v.Interface().([]byte); ok {
diff --git a/vendor/google.golang.org/protobuf/internal/filedesc/desc_lazy.go b/vendor/google.golang.org/protobuf/internal/filedesc/desc_lazy.go
index e672233e7..198451e3e 100644
--- a/vendor/google.golang.org/protobuf/internal/filedesc/desc_lazy.go
+++ b/vendor/google.golang.org/protobuf/internal/filedesc/desc_lazy.go
@@ -451,7 +451,7 @@ func (fd *Field) unmarshalFull(b []byte, sb *strs.Builder, pf *File, pd pref.Des
 			case genid.FieldDescriptorProto_Name_field_number:
 				fd.L0.FullName = appendFullName(sb, pd.FullName(), v)
 			case genid.FieldDescriptorProto_JsonName_field_number:
-				fd.L1.JSONName.Init(sb.MakeString(v))
+				fd.L1.StringName.InitJSON(sb.MakeString(v))
 			case genid.FieldDescriptorProto_DefaultValue_field_number:
 				fd.L1.Default.val = pref.ValueOfBytes(v) // temporarily store as bytes; later resolved in resolveMessages
 			case genid.FieldDescriptorProto_TypeName_field_number:
@@ -551,7 +551,7 @@ func (xd *Extension) unmarshalFull(b []byte, sb *strs.Builder) {
 			b = b[m:]
 			switch num {
 			case genid.FieldDescriptorProto_JsonName_field_number:
-				xd.L2.JSONName.Init(sb.MakeString(v))
+				xd.L2.StringName.InitJSON(sb.MakeString(v))
 			case genid.FieldDescriptorProto_DefaultValue_field_number:
 				xd.L2.Default.val = pref.ValueOfBytes(v) // temporarily store as bytes; later resolved in resolveExtensions
 			case genid.FieldDescriptorProto_TypeName_field_number:
diff --git a/vendor/google.golang.org/protobuf/internal/filedesc/desc_list.go b/vendor/google.golang.org/protobuf/internal/filedesc/desc_list.go
index c876cd34d..aa294fff9 100644
--- a/vendor/google.golang.org/protobuf/internal/filedesc/desc_list.go
+++ b/vendor/google.golang.org/protobuf/internal/filedesc/desc_list.go
@@ -6,9 +6,12 @@ package filedesc
 
 import (
 	"fmt"
+	"math"
 	"sort"
 	"sync"
 
+	"google.golang.org/protobuf/internal/genid"
+
 	"google.golang.org/protobuf/encoding/protowire"
 	"google.golang.org/protobuf/internal/descfmt"
 	"google.golang.org/protobuf/internal/errors"
@@ -245,6 +248,7 @@ type OneofFields struct {
 	once   sync.Once
 	byName map[pref.Name]pref.FieldDescriptor        // protected by once
 	byJSON map[string]pref.FieldDescriptor           // protected by once
+	byText map[string]pref.FieldDescriptor           // protected by once
 	byNum  map[pref.FieldNumber]pref.FieldDescriptor // protected by once
 }
 
@@ -252,6 +256,7 @@ func (p *OneofFields) Len() int                                         { return
 func (p *OneofFields) Get(i int) pref.FieldDescriptor                   { return p.List[i] }
 func (p *OneofFields) ByName(s pref.Name) pref.FieldDescriptor          { return p.lazyInit().byName[s] }
 func (p *OneofFields) ByJSONName(s string) pref.FieldDescriptor         { return p.lazyInit().byJSON[s] }
+func (p *OneofFields) ByTextName(s string) pref.FieldDescriptor         { return p.lazyInit().byText[s] }
 func (p *OneofFields) ByNumber(n pref.FieldNumber) pref.FieldDescriptor { return p.lazyInit().byNum[n] }
 func (p *OneofFields) Format(s fmt.State, r rune)                       { descfmt.FormatList(s, r, p) }
 func (p *OneofFields) ProtoInternal(pragma.DoNotImplement)              {}
@@ -261,11 +266,13 @@ func (p *OneofFields) lazyInit() *OneofFields {
 		if len(p.List) > 0 {
 			p.byName = make(map[pref.Name]pref.FieldDescriptor, len(p.List))
 			p.byJSON = make(map[string]pref.FieldDescriptor, len(p.List))
+			p.byText = make(map[string]pref.FieldDescriptor, len(p.List))
 			p.byNum = make(map[pref.FieldNumber]pref.FieldDescriptor, len(p.List))
 			for _, f := range p.List {
 				// Field names and numbers are guaranteed to be unique.
 				p.byName[f.Name()] = f
 				p.byJSON[f.JSONName()] = f
+				p.byText[f.TextName()] = f
 				p.byNum[f.Number()] = f
 			}
 		}
@@ -274,9 +281,170 @@ func (p *OneofFields) lazyInit() *OneofFields {
 }
 
 type SourceLocations struct {
+	// List is a list of SourceLocations.
+	// The SourceLocation.Next field does not need to be populated
+	// as it will be lazily populated upon first need.
 	List []pref.SourceLocation
+
+	// File is the parent file descriptor that these locations are relative to.
+	// If non-nil, ByDescriptor verifies that the provided descriptor
+	// is a child of this file descriptor.
+	File pref.FileDescriptor
+
+	once   sync.Once
+	byPath map[pathKey]int
+}
+
+func (p *SourceLocations) Len() int                      { return len(p.List) }
+func (p *SourceLocations) Get(i int) pref.SourceLocation { return p.lazyInit().List[i] }
+func (p *SourceLocations) byKey(k pathKey) pref.SourceLocation {
+	if i, ok := p.lazyInit().byPath[k]; ok {
+		return p.List[i]
+	}
+	return pref.SourceLocation{}
+}
+func (p *SourceLocations) ByPath(path pref.SourcePath) pref.SourceLocation {
+	return p.byKey(newPathKey(path))
+}
+func (p *SourceLocations) ByDescriptor(desc pref.Descriptor) pref.SourceLocation {
+	if p.File != nil && desc != nil && p.File != desc.ParentFile() {
+		return pref.SourceLocation{} // mismatching parent files
+	}
+	var pathArr [16]int32
+	path := pathArr[:0]
+	for {
+		switch desc.(type) {
+		case pref.FileDescriptor:
+			// Reverse the path since it was constructed in reverse.
+			for i, j := 0, len(path)-1; i < j; i, j = i+1, j-1 {
+				path[i], path[j] = path[j], path[i]
+			}
+			return p.byKey(newPathKey(path))
+		case pref.MessageDescriptor:
+			path = append(path, int32(desc.Index()))
+			desc = desc.Parent()
+			switch desc.(type) {
+			case pref.FileDescriptor:
+				path = append(path, int32(genid.FileDescriptorProto_MessageType_field_number))
+			case pref.MessageDescriptor:
+				path = append(path, int32(genid.DescriptorProto_NestedType_field_number))
+			default:
+				return pref.SourceLocation{}
+			}
+		case pref.FieldDescriptor:
+			isExtension := desc.(pref.FieldDescriptor).IsExtension()
+			path = append(path, int32(desc.Index()))
+			desc = desc.Parent()
+			if isExtension {
+				switch desc.(type) {
+				case pref.FileDescriptor:
+					path = append(path, int32(genid.FileDescriptorProto_Extension_field_number))
+				case pref.MessageDescriptor:
+					path = append(path, int32(genid.DescriptorProto_Extension_field_number))
+				default:
+					return pref.SourceLocation{}
+				}
+			} else {
+				switch desc.(type) {
+				case pref.MessageDescriptor:
+					path = append(path, int32(genid.DescriptorProto_Field_field_number))
+				default:
+					return pref.SourceLocation{}
+				}
+			}
+		case pref.OneofDescriptor:
+			path = append(path, int32(desc.Index()))
+			desc = desc.Parent()
+			switch desc.(type) {
+			case pref.MessageDescriptor:
+				path = append(path, int32(genid.DescriptorProto_OneofDecl_field_number))
+			default:
+				return pref.SourceLocation{}
+			}
+		case pref.EnumDescriptor:
+			path = append(path, int32(desc.Index()))
+			desc = desc.Parent()
+			switch desc.(type) {
+			case pref.FileDescriptor:
+				path = append(path, int32(genid.FileDescriptorProto_EnumType_field_number))
+			case pref.MessageDescriptor:
+				path = append(path, int32(genid.DescriptorProto_EnumType_field_number))
+			default:
+				return pref.SourceLocation{}
+			}
+		case pref.EnumValueDescriptor:
+			path = append(path, int32(desc.Index()))
+			desc = desc.Parent()
+			switch desc.(type) {
+			case pref.EnumDescriptor:
+				path = append(path, int32(genid.EnumDescriptorProto_Value_field_number))
+			default:
+				return pref.SourceLocation{}
+			}
+		case pref.ServiceDescriptor:
+			path = append(path, int32(desc.Index()))
+			desc = desc.Parent()
+			switch desc.(type) {
+			case pref.FileDescriptor:
+				path = append(path, int32(genid.FileDescriptorProto_Service_field_number))
+			default:
+				return pref.SourceLocation{}
+			}
+		case pref.MethodDescriptor:
+			path = append(path, int32(desc.Index()))
+			desc = desc.Parent()
+			switch desc.(type) {
+			case pref.ServiceDescriptor:
+				path = append(path, int32(genid.ServiceDescriptorProto_Method_field_number))
+			default:
+				return pref.SourceLocation{}
+			}
+		default:
+			return pref.SourceLocation{}
+		}
+	}
 }
+func (p *SourceLocations) lazyInit() *SourceLocations {
+	p.once.Do(func() {
+		if len(p.List) > 0 {
+			// Collect all the indexes for a given path.
+			pathIdxs := make(map[pathKey][]int, len(p.List))
+			for i, l := range p.List {
+				k := newPathKey(l.Path)
+				pathIdxs[k] = append(pathIdxs[k], i)
+			}
 
-func (p *SourceLocations) Len() int                            { return len(p.List) }
-func (p *SourceLocations) Get(i int) pref.SourceLocation       { return p.List[i] }
+			// Update the next index for all locations.
+			p.byPath = make(map[pathKey]int, len(p.List))
+			for k, idxs := range pathIdxs {
+				for i := 0; i < len(idxs)-1; i++ {
+					p.List[idxs[i]].Next = idxs[i+1]
+				}
+				p.List[idxs[len(idxs)-1]].Next = 0
+				p.byPath[k] = idxs[0] // record the first location for this path
+			}
+		}
+	})
+	return p
+}
 func (p *SourceLocations) ProtoInternal(pragma.DoNotImplement) {}
+
+// pathKey is a comparable representation of protoreflect.SourcePath.
+type pathKey struct {
+	arr [16]uint8 // first n-1 path segments; last element is the length
+	str string    // used if the path does not fit in arr
+}
+
+func newPathKey(p pref.SourcePath) (k pathKey) {
+	if len(p) < len(k.arr) {
+		for i, ps := range p {
+			if ps < 0 || math.MaxUint8 <= ps {
+				return pathKey{str: p.String()}
+			}
+			k.arr[i] = uint8(ps)
+		}
+		k.arr[len(k.arr)-1] = uint8(len(p))
+		return k
+	}
+	return pathKey{str: p.String()}
+}
diff --git a/vendor/google.golang.org/protobuf/internal/filedesc/desc_list_gen.go b/vendor/google.golang.org/protobuf/internal/filedesc/desc_list_gen.go
index 6a8825e80..30db19fdc 100644
--- a/vendor/google.golang.org/protobuf/internal/filedesc/desc_list_gen.go
+++ b/vendor/google.golang.org/protobuf/internal/filedesc/desc_list_gen.go
@@ -142,6 +142,7 @@ type Fields struct {
 	once   sync.Once
 	byName map[protoreflect.Name]*Field        // protected by once
 	byJSON map[string]*Field                   // protected by once
+	byText map[string]*Field                   // protected by once
 	byNum  map[protoreflect.FieldNumber]*Field // protected by once
 }
 
@@ -163,6 +164,12 @@ func (p *Fields) ByJSONName(s string) protoreflect.FieldDescriptor {
 	}
 	return nil
 }
+func (p *Fields) ByTextName(s string) protoreflect.FieldDescriptor {
+	if d := p.lazyInit().byText[s]; d != nil {
+		return d
+	}
+	return nil
+}
 func (p *Fields) ByNumber(n protoreflect.FieldNumber) protoreflect.FieldDescriptor {
 	if d := p.lazyInit().byNum[n]; d != nil {
 		return d
@@ -178,6 +185,7 @@ func (p *Fields) lazyInit() *Fields {
 		if len(p.List) > 0 {
 			p.byName = make(map[protoreflect.Name]*Field, len(p.List))
 			p.byJSON = make(map[string]*Field, len(p.List))
+			p.byText = make(map[string]*Field, len(p.List))
 			p.byNum = make(map[protoreflect.FieldNumber]*Field, len(p.List))
 			for i := range p.List {
 				d := &p.List[i]
@@ -187,6 +195,9 @@ func (p *Fields) lazyInit() *Fields {
 				if _, ok := p.byJSON[d.JSONName()]; !ok {
 					p.byJSON[d.JSONName()] = d
 				}
+				if _, ok := p.byText[d.TextName()]; !ok {
+					p.byText[d.TextName()] = d
+				}
 				if _, ok := p.byNum[d.Number()]; !ok {
 					p.byNum[d.Number()] = d
 				}
diff --git a/vendor/google.golang.org/protobuf/internal/impl/api_export.go b/vendor/google.golang.org/protobuf/internal/impl/api_export.go
index b5974528d..abee5f30e 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/api_export.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/api_export.go
@@ -167,7 +167,7 @@ func (Export) MessageTypeOf(m message) pref.MessageType {
 	if mv := (Export{}).protoMessageV2Of(m); mv != nil {
 		return mv.ProtoReflect().Type()
 	}
-	return legacyLoadMessageInfo(reflect.TypeOf(m), "")
+	return legacyLoadMessageType(reflect.TypeOf(m), "")
 }
 
 // MessageStringOf returns the message value as a string,
diff --git a/vendor/google.golang.org/protobuf/internal/impl/codec_field.go b/vendor/google.golang.org/protobuf/internal/impl/codec_field.go
index c00744d38..cb4b482d1 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/codec_field.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/codec_field.go
@@ -10,6 +10,7 @@ import (
 	"sync"
 
 	"google.golang.org/protobuf/encoding/protowire"
+	"google.golang.org/protobuf/internal/errors"
 	"google.golang.org/protobuf/proto"
 	pref "google.golang.org/protobuf/reflect/protoreflect"
 	preg "google.golang.org/protobuf/reflect/protoregistry"
@@ -20,6 +21,7 @@ type errInvalidUTF8 struct{}
 
 func (errInvalidUTF8) Error() string     { return "string field contains invalid UTF-8" }
 func (errInvalidUTF8) InvalidUTF8() bool { return true }
+func (errInvalidUTF8) Unwrap() error     { return errors.Error }
 
 // initOneofFieldCoders initializes the fast-path functions for the fields in a oneof.
 //
@@ -242,7 +244,7 @@ func consumeMessageInfo(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	if p.Elem().IsNil() {
 		p.SetPointer(pointerOfValue(reflect.New(f.mi.GoReflectType.Elem())))
@@ -276,7 +278,7 @@ func consumeMessage(b []byte, m proto.Message, wtyp protowire.Type, opts unmarsh
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	o, err := opts.Options().UnmarshalState(piface.UnmarshalInput{
 		Buf:     v,
@@ -420,7 +422,7 @@ func consumeGroup(b []byte, m proto.Message, num protowire.Number, wtyp protowir
 	}
 	b, n := protowire.ConsumeGroup(num, b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	o, err := opts.Options().UnmarshalState(piface.UnmarshalInput{
 		Buf:     b,
@@ -494,7 +496,7 @@ func consumeMessageSliceInfo(b []byte, p pointer, wtyp protowire.Type, f *coderF
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	m := reflect.New(f.mi.GoReflectType.Elem()).Interface()
 	mp := pointerOfIface(m)
@@ -550,7 +552,7 @@ func consumeMessageSlice(b []byte, p pointer, goType reflect.Type, wtyp protowir
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	mp := reflect.New(goType.Elem())
 	o, err := opts.Options().UnmarshalState(piface.UnmarshalInput{
@@ -613,7 +615,7 @@ func consumeMessageSliceValue(b []byte, listv pref.Value, _ protowire.Number, wt
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return pref.Value{}, out, protowire.ParseError(n)
+		return pref.Value{}, out, errDecode
 	}
 	m := list.NewElement()
 	o, err := opts.Options().UnmarshalState(piface.UnmarshalInput{
@@ -681,7 +683,7 @@ func consumeGroupSliceValue(b []byte, listv pref.Value, num protowire.Number, wt
 	}
 	b, n := protowire.ConsumeGroup(num, b)
 	if n < 0 {
-		return pref.Value{}, out, protowire.ParseError(n)
+		return pref.Value{}, out, errDecode
 	}
 	m := list.NewElement()
 	o, err := opts.Options().UnmarshalState(piface.UnmarshalInput{
@@ -767,7 +769,7 @@ func consumeGroupSlice(b []byte, p pointer, num protowire.Number, wtyp protowire
 	}
 	b, n := protowire.ConsumeGroup(num, b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	mp := reflect.New(goType.Elem())
 	o, err := opts.Options().UnmarshalState(piface.UnmarshalInput{
diff --git a/vendor/google.golang.org/protobuf/internal/impl/codec_gen.go b/vendor/google.golang.org/protobuf/internal/impl/codec_gen.go
index ff198d0a1..98aaf2d67 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/codec_gen.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/codec_gen.go
@@ -45,7 +45,7 @@ func consumeBool(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo, _
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Bool() = protowire.DecodeBool(v)
 	out.n = n
@@ -121,7 +121,7 @@ func consumeBoolPtr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo,
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.BoolPtr()
 	if *vp == nil {
@@ -165,7 +165,7 @@ func consumeBoolSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -180,7 +180,7 @@ func consumeBoolSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, protowire.DecodeBool(v))
 			b = b[n:]
@@ -204,7 +204,7 @@ func consumeBoolSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, protowire.DecodeBool(v))
 	out.n = n
@@ -285,7 +285,7 @@ func consumeBoolValue(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp p
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfBool(protowire.DecodeBool(v)), out, nil
@@ -325,7 +325,7 @@ func consumeBoolSliceValue(b []byte, listv protoreflect.Value, _ protowire.Numbe
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -340,7 +340,7 @@ func consumeBoolSliceValue(b []byte, listv protoreflect.Value, _ protowire.Numbe
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfBool(protowire.DecodeBool(v)))
 			b = b[n:]
@@ -363,7 +363,7 @@ func consumeBoolSliceValue(b []byte, listv protoreflect.Value, _ protowire.Numbe
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfBool(protowire.DecodeBool(v)))
 	out.n = n
@@ -449,7 +449,7 @@ func consumeEnumValue(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp p
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfEnum(protoreflect.EnumNumber(v)), out, nil
@@ -489,7 +489,7 @@ func consumeEnumSliceValue(b []byte, listv protoreflect.Value, _ protowire.Numbe
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -504,7 +504,7 @@ func consumeEnumSliceValue(b []byte, listv protoreflect.Value, _ protowire.Numbe
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfEnum(protoreflect.EnumNumber(v)))
 			b = b[n:]
@@ -527,7 +527,7 @@ func consumeEnumSliceValue(b []byte, listv protoreflect.Value, _ protowire.Numbe
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfEnum(protoreflect.EnumNumber(v)))
 	out.n = n
@@ -615,7 +615,7 @@ func consumeInt32(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo, _
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Int32() = int32(v)
 	out.n = n
@@ -691,7 +691,7 @@ func consumeInt32Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Int32Ptr()
 	if *vp == nil {
@@ -735,7 +735,7 @@ func consumeInt32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -750,7 +750,7 @@ func consumeInt32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, int32(v))
 			b = b[n:]
@@ -774,7 +774,7 @@ func consumeInt32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, int32(v))
 	out.n = n
@@ -855,7 +855,7 @@ func consumeInt32Value(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfInt32(int32(v)), out, nil
@@ -895,7 +895,7 @@ func consumeInt32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Numb
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -910,7 +910,7 @@ func consumeInt32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Numb
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfInt32(int32(v)))
 			b = b[n:]
@@ -933,7 +933,7 @@ func consumeInt32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Numb
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfInt32(int32(v)))
 	out.n = n
@@ -1021,7 +1021,7 @@ func consumeSint32(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo,
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Int32() = int32(protowire.DecodeZigZag(v & math.MaxUint32))
 	out.n = n
@@ -1097,7 +1097,7 @@ func consumeSint32Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Int32Ptr()
 	if *vp == nil {
@@ -1141,7 +1141,7 @@ func consumeSint32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -1156,7 +1156,7 @@ func consumeSint32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, int32(protowire.DecodeZigZag(v&math.MaxUint32)))
 			b = b[n:]
@@ -1180,7 +1180,7 @@ func consumeSint32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, int32(protowire.DecodeZigZag(v&math.MaxUint32)))
 	out.n = n
@@ -1261,7 +1261,7 @@ func consumeSint32Value(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfInt32(int32(protowire.DecodeZigZag(v & math.MaxUint32))), out, nil
@@ -1301,7 +1301,7 @@ func consumeSint32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -1316,7 +1316,7 @@ func consumeSint32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfInt32(int32(protowire.DecodeZigZag(v & math.MaxUint32))))
 			b = b[n:]
@@ -1339,7 +1339,7 @@ func consumeSint32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfInt32(int32(protowire.DecodeZigZag(v & math.MaxUint32))))
 	out.n = n
@@ -1427,7 +1427,7 @@ func consumeUint32(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo,
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Uint32() = uint32(v)
 	out.n = n
@@ -1503,7 +1503,7 @@ func consumeUint32Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Uint32Ptr()
 	if *vp == nil {
@@ -1547,7 +1547,7 @@ func consumeUint32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -1562,7 +1562,7 @@ func consumeUint32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, uint32(v))
 			b = b[n:]
@@ -1586,7 +1586,7 @@ func consumeUint32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, uint32(v))
 	out.n = n
@@ -1667,7 +1667,7 @@ func consumeUint32Value(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfUint32(uint32(v)), out, nil
@@ -1707,7 +1707,7 @@ func consumeUint32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -1722,7 +1722,7 @@ func consumeUint32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfUint32(uint32(v)))
 			b = b[n:]
@@ -1745,7 +1745,7 @@ func consumeUint32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfUint32(uint32(v)))
 	out.n = n
@@ -1833,7 +1833,7 @@ func consumeInt64(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo, _
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Int64() = int64(v)
 	out.n = n
@@ -1909,7 +1909,7 @@ func consumeInt64Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Int64Ptr()
 	if *vp == nil {
@@ -1953,7 +1953,7 @@ func consumeInt64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -1968,7 +1968,7 @@ func consumeInt64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, int64(v))
 			b = b[n:]
@@ -1992,7 +1992,7 @@ func consumeInt64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, int64(v))
 	out.n = n
@@ -2073,7 +2073,7 @@ func consumeInt64Value(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfInt64(int64(v)), out, nil
@@ -2113,7 +2113,7 @@ func consumeInt64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Numb
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -2128,7 +2128,7 @@ func consumeInt64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Numb
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfInt64(int64(v)))
 			b = b[n:]
@@ -2151,7 +2151,7 @@ func consumeInt64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Numb
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfInt64(int64(v)))
 	out.n = n
@@ -2239,7 +2239,7 @@ func consumeSint64(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo,
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Int64() = protowire.DecodeZigZag(v)
 	out.n = n
@@ -2315,7 +2315,7 @@ func consumeSint64Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Int64Ptr()
 	if *vp == nil {
@@ -2359,7 +2359,7 @@ func consumeSint64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -2374,7 +2374,7 @@ func consumeSint64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, protowire.DecodeZigZag(v))
 			b = b[n:]
@@ -2398,7 +2398,7 @@ func consumeSint64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, protowire.DecodeZigZag(v))
 	out.n = n
@@ -2479,7 +2479,7 @@ func consumeSint64Value(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfInt64(protowire.DecodeZigZag(v)), out, nil
@@ -2519,7 +2519,7 @@ func consumeSint64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -2534,7 +2534,7 @@ func consumeSint64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfInt64(protowire.DecodeZigZag(v)))
 			b = b[n:]
@@ -2557,7 +2557,7 @@ func consumeSint64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfInt64(protowire.DecodeZigZag(v)))
 	out.n = n
@@ -2645,7 +2645,7 @@ func consumeUint64(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo,
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Uint64() = v
 	out.n = n
@@ -2721,7 +2721,7 @@ func consumeUint64Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Uint64Ptr()
 	if *vp == nil {
@@ -2765,7 +2765,7 @@ func consumeUint64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -2780,7 +2780,7 @@ func consumeUint64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, v)
 			b = b[n:]
@@ -2804,7 +2804,7 @@ func consumeUint64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, v)
 	out.n = n
@@ -2885,7 +2885,7 @@ func consumeUint64Value(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfUint64(v), out, nil
@@ -2925,7 +2925,7 @@ func consumeUint64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			var v uint64
@@ -2940,7 +2940,7 @@ func consumeUint64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 				v, n = protowire.ConsumeVarint(b)
 			}
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfUint64(v))
 			b = b[n:]
@@ -2963,7 +2963,7 @@ func consumeUint64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 		v, n = protowire.ConsumeVarint(b)
 	}
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfUint64(v))
 	out.n = n
@@ -3041,7 +3041,7 @@ func consumeSfixed32(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Int32() = int32(v)
 	out.n = n
@@ -3106,7 +3106,7 @@ func consumeSfixed32Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Int32Ptr()
 	if *vp == nil {
@@ -3148,12 +3148,12 @@ func consumeSfixed32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFiel
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed32(b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, int32(v))
 			b = b[n:]
@@ -3167,7 +3167,7 @@ func consumeSfixed32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFiel
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, int32(v))
 	out.n = n
@@ -3232,7 +3232,7 @@ func consumeSfixed32Value(b []byte, _ protoreflect.Value, _ protowire.Number, wt
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfInt32(int32(v)), out, nil
@@ -3269,12 +3269,12 @@ func consumeSfixed32SliceValue(b []byte, listv protoreflect.Value, _ protowire.N
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed32(b)
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfInt32(int32(v)))
 			b = b[n:]
@@ -3287,7 +3287,7 @@ func consumeSfixed32SliceValue(b []byte, listv protoreflect.Value, _ protowire.N
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfInt32(int32(v)))
 	out.n = n
@@ -3357,7 +3357,7 @@ func consumeFixed32(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo,
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Uint32() = v
 	out.n = n
@@ -3422,7 +3422,7 @@ func consumeFixed32Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Uint32Ptr()
 	if *vp == nil {
@@ -3464,12 +3464,12 @@ func consumeFixed32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderField
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed32(b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, v)
 			b = b[n:]
@@ -3483,7 +3483,7 @@ func consumeFixed32Slice(b []byte, p pointer, wtyp protowire.Type, f *coderField
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, v)
 	out.n = n
@@ -3548,7 +3548,7 @@ func consumeFixed32Value(b []byte, _ protoreflect.Value, _ protowire.Number, wty
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfUint32(uint32(v)), out, nil
@@ -3585,12 +3585,12 @@ func consumeFixed32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Nu
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed32(b)
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfUint32(uint32(v)))
 			b = b[n:]
@@ -3603,7 +3603,7 @@ func consumeFixed32SliceValue(b []byte, listv protoreflect.Value, _ protowire.Nu
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfUint32(uint32(v)))
 	out.n = n
@@ -3673,7 +3673,7 @@ func consumeFloat(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo, _
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Float32() = math.Float32frombits(v)
 	out.n = n
@@ -3738,7 +3738,7 @@ func consumeFloatPtr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Float32Ptr()
 	if *vp == nil {
@@ -3780,12 +3780,12 @@ func consumeFloatSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed32(b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, math.Float32frombits(v))
 			b = b[n:]
@@ -3799,7 +3799,7 @@ func consumeFloatSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, math.Float32frombits(v))
 	out.n = n
@@ -3864,7 +3864,7 @@ func consumeFloatValue(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfFloat32(math.Float32frombits(uint32(v))), out, nil
@@ -3901,12 +3901,12 @@ func consumeFloatSliceValue(b []byte, listv protoreflect.Value, _ protowire.Numb
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed32(b)
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfFloat32(math.Float32frombits(uint32(v))))
 			b = b[n:]
@@ -3919,7 +3919,7 @@ func consumeFloatSliceValue(b []byte, listv protoreflect.Value, _ protowire.Numb
 	}
 	v, n := protowire.ConsumeFixed32(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfFloat32(math.Float32frombits(uint32(v))))
 	out.n = n
@@ -3989,7 +3989,7 @@ func consumeSfixed64(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Int64() = int64(v)
 	out.n = n
@@ -4054,7 +4054,7 @@ func consumeSfixed64Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Int64Ptr()
 	if *vp == nil {
@@ -4096,12 +4096,12 @@ func consumeSfixed64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFiel
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed64(b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, int64(v))
 			b = b[n:]
@@ -4115,7 +4115,7 @@ func consumeSfixed64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderFiel
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, int64(v))
 	out.n = n
@@ -4180,7 +4180,7 @@ func consumeSfixed64Value(b []byte, _ protoreflect.Value, _ protowire.Number, wt
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfInt64(int64(v)), out, nil
@@ -4217,12 +4217,12 @@ func consumeSfixed64SliceValue(b []byte, listv protoreflect.Value, _ protowire.N
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed64(b)
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfInt64(int64(v)))
 			b = b[n:]
@@ -4235,7 +4235,7 @@ func consumeSfixed64SliceValue(b []byte, listv protoreflect.Value, _ protowire.N
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfInt64(int64(v)))
 	out.n = n
@@ -4305,7 +4305,7 @@ func consumeFixed64(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo,
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Uint64() = v
 	out.n = n
@@ -4370,7 +4370,7 @@ func consumeFixed64Ptr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Uint64Ptr()
 	if *vp == nil {
@@ -4412,12 +4412,12 @@ func consumeFixed64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderField
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed64(b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, v)
 			b = b[n:]
@@ -4431,7 +4431,7 @@ func consumeFixed64Slice(b []byte, p pointer, wtyp protowire.Type, f *coderField
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, v)
 	out.n = n
@@ -4496,7 +4496,7 @@ func consumeFixed64Value(b []byte, _ protoreflect.Value, _ protowire.Number, wty
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfUint64(v), out, nil
@@ -4533,12 +4533,12 @@ func consumeFixed64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Nu
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed64(b)
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfUint64(v))
 			b = b[n:]
@@ -4551,7 +4551,7 @@ func consumeFixed64SliceValue(b []byte, listv protoreflect.Value, _ protowire.Nu
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfUint64(v))
 	out.n = n
@@ -4621,7 +4621,7 @@ func consumeDouble(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo,
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Float64() = math.Float64frombits(v)
 	out.n = n
@@ -4686,7 +4686,7 @@ func consumeDoublePtr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.Float64Ptr()
 	if *vp == nil {
@@ -4728,12 +4728,12 @@ func consumeDoubleSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 		s := *sp
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed64(b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			s = append(s, math.Float64frombits(v))
 			b = b[n:]
@@ -4747,7 +4747,7 @@ func consumeDoubleSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, math.Float64frombits(v))
 	out.n = n
@@ -4812,7 +4812,7 @@ func consumeDoubleValue(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfFloat64(math.Float64frombits(v)), out, nil
@@ -4849,12 +4849,12 @@ func consumeDoubleSliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return protoreflect.Value{}, out, protowire.ParseError(n)
+			return protoreflect.Value{}, out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeFixed64(b)
 			if n < 0 {
-				return protoreflect.Value{}, out, protowire.ParseError(n)
+				return protoreflect.Value{}, out, errDecode
 			}
 			list.Append(protoreflect.ValueOfFloat64(math.Float64frombits(v)))
 			b = b[n:]
@@ -4867,7 +4867,7 @@ func consumeDoubleSliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 	}
 	v, n := protowire.ConsumeFixed64(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfFloat64(math.Float64frombits(v)))
 	out.n = n
@@ -4937,7 +4937,7 @@ func consumeString(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo,
 	}
 	v, n := protowire.ConsumeString(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.String() = v
 	out.n = n
@@ -4969,7 +4969,7 @@ func consumeStringValidateUTF8(b []byte, p pointer, wtyp protowire.Type, f *code
 	}
 	v, n := protowire.ConsumeString(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	if !utf8.ValidString(v) {
 		return out, errInvalidUTF8{}
@@ -5060,7 +5060,7 @@ func consumeStringPtr(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 	}
 	v, n := protowire.ConsumeString(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	vp := p.StringPtr()
 	if *vp == nil {
@@ -5097,7 +5097,7 @@ func consumeStringPtrValidateUTF8(b []byte, p pointer, wtyp protowire.Type, f *c
 	}
 	v, n := protowire.ConsumeString(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	if !utf8.ValidString(v) {
 		return out, errInvalidUTF8{}
@@ -5145,7 +5145,7 @@ func consumeStringSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 	}
 	v, n := protowire.ConsumeString(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, v)
 	out.n = n
@@ -5180,7 +5180,7 @@ func consumeStringSliceValidateUTF8(b []byte, p pointer, wtyp protowire.Type, f
 	}
 	v, n := protowire.ConsumeString(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	if !utf8.ValidString(v) {
 		return out, errInvalidUTF8{}
@@ -5216,7 +5216,7 @@ func consumeStringValue(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 	}
 	v, n := protowire.ConsumeString(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfString(string(v)), out, nil
@@ -5246,7 +5246,7 @@ func consumeStringValueValidateUTF8(b []byte, _ protoreflect.Value, _ protowire.
 	}
 	v, n := protowire.ConsumeString(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	if !utf8.ValidString(v) {
 		return protoreflect.Value{}, out, errInvalidUTF8{}
@@ -5291,7 +5291,7 @@ func consumeStringSliceValue(b []byte, listv protoreflect.Value, _ protowire.Num
 	}
 	v, n := protowire.ConsumeString(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfString(string(v)))
 	out.n = n
@@ -5326,7 +5326,7 @@ func consumeBytes(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo, _
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Bytes() = append(emptyBuf[:], v...)
 	out.n = n
@@ -5358,7 +5358,7 @@ func consumeBytesValidateUTF8(b []byte, p pointer, wtyp protowire.Type, f *coder
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	if !utf8.Valid(v) {
 		return out, errInvalidUTF8{}
@@ -5405,7 +5405,7 @@ func consumeBytesNoZero(b []byte, p pointer, wtyp protowire.Type, f *coderFieldI
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*p.Bytes() = append(([]byte)(nil), v...)
 	out.n = n
@@ -5441,7 +5441,7 @@ func consumeBytesNoZeroValidateUTF8(b []byte, p pointer, wtyp protowire.Type, f
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	if !utf8.Valid(v) {
 		return out, errInvalidUTF8{}
@@ -5485,7 +5485,7 @@ func consumeBytesSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldIn
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	*sp = append(*sp, append(emptyBuf[:], v...))
 	out.n = n
@@ -5520,7 +5520,7 @@ func consumeBytesSliceValidateUTF8(b []byte, p pointer, wtyp protowire.Type, f *
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	if !utf8.Valid(v) {
 		return out, errInvalidUTF8{}
@@ -5556,7 +5556,7 @@ func consumeBytesValue(b []byte, _ protoreflect.Value, _ protowire.Number, wtyp
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	out.n = n
 	return protoreflect.ValueOfBytes(append(emptyBuf[:], v...)), out, nil
@@ -5598,7 +5598,7 @@ func consumeBytesSliceValue(b []byte, listv protoreflect.Value, _ protowire.Numb
 	}
 	v, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return protoreflect.Value{}, out, protowire.ParseError(n)
+		return protoreflect.Value{}, out, errDecode
 	}
 	list.Append(protoreflect.ValueOfBytes(append(emptyBuf[:], v...)))
 	out.n = n
diff --git a/vendor/google.golang.org/protobuf/internal/impl/codec_map.go b/vendor/google.golang.org/protobuf/internal/impl/codec_map.go
index 44885a761..c1245fef4 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/codec_map.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/codec_map.go
@@ -5,7 +5,6 @@
 package impl
 
 import (
-	"errors"
 	"reflect"
 	"sort"
 
@@ -118,7 +117,7 @@ func consumeMap(b []byte, mapv reflect.Value, wtyp protowire.Type, mapi *mapInfo
 	}
 	b, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	var (
 		key = mapi.keyZero
@@ -127,10 +126,10 @@ func consumeMap(b []byte, mapv reflect.Value, wtyp protowire.Type, mapi *mapInfo
 	for len(b) > 0 {
 		num, wtyp, n := protowire.ConsumeTag(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		if num > protowire.MaxValidNumber {
-			return out, errors.New("invalid field number")
+			return out, errDecode
 		}
 		b = b[n:]
 		err := errUnknown
@@ -157,7 +156,7 @@ func consumeMap(b []byte, mapv reflect.Value, wtyp protowire.Type, mapi *mapInfo
 		if err == errUnknown {
 			n = protowire.ConsumeFieldValue(num, wtyp, b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 		} else if err != nil {
 			return out, err
@@ -175,7 +174,7 @@ func consumeMapOfMessage(b []byte, mapv reflect.Value, wtyp protowire.Type, mapi
 	}
 	b, n := protowire.ConsumeBytes(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	var (
 		key = mapi.keyZero
@@ -184,10 +183,10 @@ func consumeMapOfMessage(b []byte, mapv reflect.Value, wtyp protowire.Type, mapi
 	for len(b) > 0 {
 		num, wtyp, n := protowire.ConsumeTag(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		if num > protowire.MaxValidNumber {
-			return out, errors.New("invalid field number")
+			return out, errDecode
 		}
 		b = b[n:]
 		err := errUnknown
@@ -208,7 +207,7 @@ func consumeMapOfMessage(b []byte, mapv reflect.Value, wtyp protowire.Type, mapi
 			var v []byte
 			v, n = protowire.ConsumeBytes(b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			var o unmarshalOutput
 			o, err = f.mi.unmarshalPointer(v, pointerOfValue(val), 0, opts)
@@ -221,7 +220,7 @@ func consumeMapOfMessage(b []byte, mapv reflect.Value, wtyp protowire.Type, mapi
 		if err == errUnknown {
 			n = protowire.ConsumeFieldValue(num, wtyp, b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 		} else if err != nil {
 			return out, err
diff --git a/vendor/google.golang.org/protobuf/internal/impl/codec_message.go b/vendor/google.golang.org/protobuf/internal/impl/codec_message.go
index 0e176d565..e10864274 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/codec_message.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/codec_message.go
@@ -11,7 +11,7 @@ import (
 
 	"google.golang.org/protobuf/encoding/protowire"
 	"google.golang.org/protobuf/internal/encoding/messageset"
-	"google.golang.org/protobuf/internal/fieldsort"
+	"google.golang.org/protobuf/internal/order"
 	pref "google.golang.org/protobuf/reflect/protoreflect"
 	piface "google.golang.org/protobuf/runtime/protoiface"
 )
@@ -27,6 +27,7 @@ type coderMessageInfo struct {
 	coderFields        map[protowire.Number]*coderFieldInfo
 	sizecacheOffset    offset
 	unknownOffset      offset
+	unknownPtrKind     bool
 	extensionOffset    offset
 	needsInitCheck     bool
 	isMessageSet       bool
@@ -47,9 +48,20 @@ type coderFieldInfo struct {
 }
 
 func (mi *MessageInfo) makeCoderMethods(t reflect.Type, si structInfo) {
-	mi.sizecacheOffset = si.sizecacheOffset
-	mi.unknownOffset = si.unknownOffset
-	mi.extensionOffset = si.extensionOffset
+	mi.sizecacheOffset = invalidOffset
+	mi.unknownOffset = invalidOffset
+	mi.extensionOffset = invalidOffset
+
+	if si.sizecacheOffset.IsValid() && si.sizecacheType == sizecacheType {
+		mi.sizecacheOffset = si.sizecacheOffset
+	}
+	if si.unknownOffset.IsValid() && (si.unknownType == unknownFieldsAType || si.unknownType == unknownFieldsBType) {
+		mi.unknownOffset = si.unknownOffset
+		mi.unknownPtrKind = si.unknownType.Kind() == reflect.Ptr
+	}
+	if si.extensionOffset.IsValid() && si.extensionType == extensionFieldsType {
+		mi.extensionOffset = si.extensionOffset
+	}
 
 	mi.coderFields = make(map[protowire.Number]*coderFieldInfo)
 	fields := mi.Desc.Fields()
@@ -136,7 +148,7 @@ func (mi *MessageInfo) makeCoderMethods(t reflect.Type, si structInfo) {
 		sort.Slice(mi.orderedCoderFields, func(i, j int) bool {
 			fi := fields.ByNumber(mi.orderedCoderFields[i].num)
 			fj := fields.ByNumber(mi.orderedCoderFields[j].num)
-			return fieldsort.Less(fi, fj)
+			return order.LegacyFieldOrder(fi, fj)
 		})
 	}
 
@@ -157,3 +169,28 @@ func (mi *MessageInfo) makeCoderMethods(t reflect.Type, si structInfo) {
 		mi.methods.Merge = mi.merge
 	}
 }
+
+// getUnknownBytes returns a *[]byte for the unknown fields.
+// It is the caller's responsibility to check whether the pointer is nil.
+// This function is specially designed to be inlineable.
+func (mi *MessageInfo) getUnknownBytes(p pointer) *[]byte {
+	if mi.unknownPtrKind {
+		return *p.Apply(mi.unknownOffset).BytesPtr()
+	} else {
+		return p.Apply(mi.unknownOffset).Bytes()
+	}
+}
+
+// mutableUnknownBytes returns a *[]byte for the unknown fields.
+// The returned pointer is guaranteed to not be nil.
+func (mi *MessageInfo) mutableUnknownBytes(p pointer) *[]byte {
+	if mi.unknownPtrKind {
+		bp := p.Apply(mi.unknownOffset).BytesPtr()
+		if *bp == nil {
+			*bp = new([]byte)
+		}
+		return *bp
+	} else {
+		return p.Apply(mi.unknownOffset).Bytes()
+	}
+}
diff --git a/vendor/google.golang.org/protobuf/internal/impl/codec_messageset.go b/vendor/google.golang.org/protobuf/internal/impl/codec_messageset.go
index cfb68e12f..b7a23faf1 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/codec_messageset.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/codec_messageset.go
@@ -29,8 +29,9 @@ func sizeMessageSet(mi *MessageInfo, p pointer, opts marshalOptions) (size int)
 		size += xi.funcs.size(x.Value(), protowire.SizeTag(messageset.FieldMessage), opts)
 	}
 
-	unknown := *p.Apply(mi.unknownOffset).Bytes()
-	size += messageset.SizeUnknown(unknown)
+	if u := mi.getUnknownBytes(p); u != nil {
+		size += messageset.SizeUnknown(*u)
+	}
 
 	return size
 }
@@ -69,10 +70,12 @@ func marshalMessageSet(mi *MessageInfo, b []byte, p pointer, opts marshalOptions
 		}
 	}
 
-	unknown := *p.Apply(mi.unknownOffset).Bytes()
-	b, err := messageset.AppendUnknown(b, unknown)
-	if err != nil {
-		return b, err
+	if u := mi.getUnknownBytes(p); u != nil {
+		var err error
+		b, err = messageset.AppendUnknown(b, *u)
+		if err != nil {
+			return b, err
+		}
 	}
 
 	return b, nil
@@ -100,13 +103,13 @@ func unmarshalMessageSet(mi *MessageInfo, b []byte, p pointer, opts unmarshalOpt
 		*ep = make(map[int32]ExtensionField)
 	}
 	ext := *ep
-	unknown := p.Apply(mi.unknownOffset).Bytes()
 	initialized := true
 	err = messageset.Unmarshal(b, true, func(num protowire.Number, v []byte) error {
 		o, err := mi.unmarshalExtension(v, num, protowire.BytesType, ext, opts)
 		if err == errUnknown {
-			*unknown = protowire.AppendTag(*unknown, num, protowire.BytesType)
-			*unknown = append(*unknown, v...)
+			u := mi.mutableUnknownBytes(p)
+			*u = protowire.AppendTag(*u, num, protowire.BytesType)
+			*u = append(*u, v...)
 			return nil
 		}
 		if !o.initialized {
diff --git a/vendor/google.golang.org/protobuf/internal/impl/codec_reflect.go b/vendor/google.golang.org/protobuf/internal/impl/codec_reflect.go
index 86f7dc3c9..90705e3ae 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/codec_reflect.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/codec_reflect.go
@@ -30,7 +30,7 @@ func consumeEnum(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo, _
 	}
 	v, n := protowire.ConsumeVarint(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	p.v.Elem().SetInt(int64(v))
 	out.n = n
@@ -130,12 +130,12 @@ func consumeEnumSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 	if wtyp == protowire.BytesType {
 		b, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return out, protowire.ParseError(n)
+			return out, errDecode
 		}
 		for len(b) > 0 {
 			v, n := protowire.ConsumeVarint(b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			rv := reflect.New(s.Type().Elem()).Elem()
 			rv.SetInt(int64(v))
@@ -150,7 +150,7 @@ func consumeEnumSlice(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInf
 	}
 	v, n := protowire.ConsumeVarint(b)
 	if n < 0 {
-		return out, protowire.ParseError(n)
+		return out, errDecode
 	}
 	rv := reflect.New(s.Type().Elem()).Elem()
 	rv.SetInt(int64(v))
diff --git a/vendor/google.golang.org/protobuf/internal/impl/decode.go b/vendor/google.golang.org/protobuf/internal/impl/decode.go
index 85ba1d3b3..949dc49a6 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/decode.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/decode.go
@@ -17,6 +17,8 @@ import (
 	piface "google.golang.org/protobuf/runtime/protoiface"
 )
 
+var errDecode = errors.New("cannot parse invalid wire-format data")
+
 type unmarshalOptions struct {
 	flags    protoiface.UnmarshalInputFlags
 	resolver interface {
@@ -100,13 +102,13 @@ func (mi *MessageInfo) unmarshalPointer(b []byte, p pointer, groupTag protowire.
 			var n int
 			tag, n = protowire.ConsumeVarint(b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			b = b[n:]
 		}
 		var num protowire.Number
 		if n := tag >> 3; n < uint64(protowire.MinValidNumber) || n > uint64(protowire.MaxValidNumber) {
-			return out, errors.New("invalid field number")
+			return out, errDecode
 		} else {
 			num = protowire.Number(n)
 		}
@@ -114,7 +116,7 @@ func (mi *MessageInfo) unmarshalPointer(b []byte, p pointer, groupTag protowire.
 
 		if wtyp == protowire.EndGroupType {
 			if num != groupTag {
-				return out, errors.New("mismatching end group marker")
+				return out, errDecode
 			}
 			groupTag = 0
 			break
@@ -170,10 +172,10 @@ func (mi *MessageInfo) unmarshalPointer(b []byte, p pointer, groupTag protowire.
 			}
 			n = protowire.ConsumeFieldValue(num, wtyp, b)
 			if n < 0 {
-				return out, protowire.ParseError(n)
+				return out, errDecode
 			}
 			if !opts.DiscardUnknown() && mi.unknownOffset.IsValid() {
-				u := p.Apply(mi.unknownOffset).Bytes()
+				u := mi.mutableUnknownBytes(p)
 				*u = protowire.AppendTag(*u, num, wtyp)
 				*u = append(*u, b[:n]...)
 			}
@@ -181,7 +183,7 @@ func (mi *MessageInfo) unmarshalPointer(b []byte, p pointer, groupTag protowire.
 		b = b[n:]
 	}
 	if groupTag != 0 {
-		return out, errors.New("missing end group marker")
+		return out, errDecode
 	}
 	if mi.numRequiredFields > 0 && bits.OnesCount64(requiredMask) != int(mi.numRequiredFields) {
 		initialized = false
@@ -221,7 +223,7 @@ func (mi *MessageInfo) unmarshalExtension(b []byte, num protowire.Number, wtyp p
 					return out, nil
 				}
 			case ValidationInvalid:
-				return out, errors.New("invalid wire format")
+				return out, errDecode
 			case ValidationUnknown:
 			}
 		}
diff --git a/vendor/google.golang.org/protobuf/internal/impl/encode.go b/vendor/google.golang.org/protobuf/internal/impl/encode.go
index 8c8a794c6..845c67d6e 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/encode.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/encode.go
@@ -79,8 +79,9 @@ func (mi *MessageInfo) sizePointerSlow(p pointer, opts marshalOptions) (size int
 		size += f.funcs.size(fptr, f, opts)
 	}
 	if mi.unknownOffset.IsValid() {
-		u := *p.Apply(mi.unknownOffset).Bytes()
-		size += len(u)
+		if u := mi.getUnknownBytes(p); u != nil {
+			size += len(*u)
+		}
 	}
 	if mi.sizecacheOffset.IsValid() {
 		if size > math.MaxInt32 {
@@ -141,8 +142,9 @@ func (mi *MessageInfo) marshalAppendPointer(b []byte, p pointer, opts marshalOpt
 		}
 	}
 	if mi.unknownOffset.IsValid() && !mi.isMessageSet {
-		u := *p.Apply(mi.unknownOffset).Bytes()
-		b = append(b, u...)
+		if u := mi.getUnknownBytes(p); u != nil {
+			b = append(b, (*u)...)
+		}
 	}
 	return b, nil
 }
diff --git a/vendor/google.golang.org/protobuf/internal/impl/legacy_export.go b/vendor/google.golang.org/protobuf/internal/impl/legacy_export.go
index c3d741c2f..e3fb0b578 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/legacy_export.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/legacy_export.go
@@ -30,7 +30,7 @@ func (Export) LegacyMessageTypeOf(m piface.MessageV1, name pref.FullName) pref.M
 	if mv := (Export{}).protoMessageV2Of(m); mv != nil {
 		return mv.ProtoReflect().Type()
 	}
-	return legacyLoadMessageInfo(reflect.TypeOf(m), name)
+	return legacyLoadMessageType(reflect.TypeOf(m), name)
 }
 
 // UnmarshalJSONEnum unmarshals an enum from a JSON-encoded input.
diff --git a/vendor/google.golang.org/protobuf/internal/impl/legacy_extension.go b/vendor/google.golang.org/protobuf/internal/impl/legacy_extension.go
index 61757ce50..49e723161 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/legacy_extension.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/legacy_extension.go
@@ -154,7 +154,8 @@ func (x placeholderExtension) Number() pref.FieldNumber                   { retu
 func (x placeholderExtension) Cardinality() pref.Cardinality              { return 0 }
 func (x placeholderExtension) Kind() pref.Kind                            { return 0 }
 func (x placeholderExtension) HasJSONName() bool                          { return false }
-func (x placeholderExtension) JSONName() string                           { return "" }
+func (x placeholderExtension) JSONName() string                           { return "[" + string(x.name) + "]" }
+func (x placeholderExtension) TextName() string                           { return "[" + string(x.name) + "]" }
 func (x placeholderExtension) HasPresence() bool                          { return false }
 func (x placeholderExtension) HasOptionalKeyword() bool                   { return false }
 func (x placeholderExtension) IsExtension() bool                          { return true }
diff --git a/vendor/google.golang.org/protobuf/internal/impl/legacy_message.go b/vendor/google.golang.org/protobuf/internal/impl/legacy_message.go
index 06c68e117..b1d66c5c5 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/legacy_message.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/legacy_message.go
@@ -32,6 +32,16 @@ func legacyWrapMessage(v reflect.Value) pref.Message {
 	return mt.MessageOf(v.Interface())
 }
 
+// legacyLoadMessageType dynamically loads a protoreflect.Type for t,
+// where t must be not implement the v2 API already.
+// The provided name is used if it cannot be determined from the message.
+func legacyLoadMessageType(t reflect.Type, name pref.FullName) protoreflect.MessageType {
+	if t.Kind() != reflect.Ptr || t.Elem().Kind() != reflect.Struct {
+		return aberrantMessageType{t}
+	}
+	return legacyLoadMessageInfo(t, name)
+}
+
 var legacyMessageTypeCache sync.Map // map[reflect.Type]*MessageInfo
 
 // legacyLoadMessageInfo dynamically loads a *MessageInfo for t,
@@ -370,7 +380,7 @@ type legacyMerger interface {
 	Merge(protoiface.MessageV1)
 }
 
-var legacyProtoMethods = &piface.Methods{
+var aberrantProtoMethods = &piface.Methods{
 	Marshal:   legacyMarshal,
 	Unmarshal: legacyUnmarshal,
 	Merge:     legacyMerge,
@@ -495,7 +505,7 @@ func (m aberrantMessage) IsValid() bool {
 	return true
 }
 func (m aberrantMessage) ProtoMethods() *piface.Methods {
-	return legacyProtoMethods
+	return aberrantProtoMethods
 }
 func (m aberrantMessage) protoUnwrap() interface{} {
 	return m.v.Interface()
diff --git a/vendor/google.golang.org/protobuf/internal/impl/merge.go b/vendor/google.golang.org/protobuf/internal/impl/merge.go
index cdc4267df..c65bbc044 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/merge.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/merge.go
@@ -77,9 +77,9 @@ func (mi *MessageInfo) mergePointer(dst, src pointer, opts mergeOptions) {
 		}
 	}
 	if mi.unknownOffset.IsValid() {
-		du := dst.Apply(mi.unknownOffset).Bytes()
-		su := src.Apply(mi.unknownOffset).Bytes()
-		if len(*su) > 0 {
+		su := mi.getUnknownBytes(src)
+		if su != nil && len(*su) > 0 {
+			du := mi.mutableUnknownBytes(dst)
 			*du = append(*du, *su...)
 		}
 	}
diff --git a/vendor/google.golang.org/protobuf/internal/impl/message.go b/vendor/google.golang.org/protobuf/internal/impl/message.go
index c026a9818..a104e28e8 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/message.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/message.go
@@ -15,6 +15,7 @@ import (
 	"google.golang.org/protobuf/internal/genid"
 	"google.golang.org/protobuf/reflect/protoreflect"
 	pref "google.golang.org/protobuf/reflect/protoreflect"
+	preg "google.golang.org/protobuf/reflect/protoregistry"
 )
 
 // MessageInfo provides protobuf related functionality for a given Go type
@@ -109,22 +110,29 @@ func (mi *MessageInfo) getPointer(m pref.Message) (p pointer, ok bool) {
 type (
 	SizeCache       = int32
 	WeakFields      = map[int32]protoreflect.ProtoMessage
-	UnknownFields   = []byte
+	UnknownFields   = unknownFieldsA // TODO: switch to unknownFieldsB
+	unknownFieldsA  = []byte
+	unknownFieldsB  = *[]byte
 	ExtensionFields = map[int32]ExtensionField
 )
 
 var (
 	sizecacheType       = reflect.TypeOf(SizeCache(0))
 	weakFieldsType      = reflect.TypeOf(WeakFields(nil))
-	unknownFieldsType   = reflect.TypeOf(UnknownFields(nil))
+	unknownFieldsAType  = reflect.TypeOf(unknownFieldsA(nil))
+	unknownFieldsBType  = reflect.TypeOf(unknownFieldsB(nil))
 	extensionFieldsType = reflect.TypeOf(ExtensionFields(nil))
 )
 
 type structInfo struct {
 	sizecacheOffset offset
+	sizecacheType   reflect.Type
 	weakOffset      offset
+	weakType        reflect.Type
 	unknownOffset   offset
+	unknownType     reflect.Type
 	extensionOffset offset
+	extensionType   reflect.Type
 
 	fieldsByNumber        map[pref.FieldNumber]reflect.StructField
 	oneofsByName          map[pref.Name]reflect.StructField
@@ -151,18 +159,22 @@ fieldLoop:
 		case genid.SizeCache_goname, genid.SizeCacheA_goname:
 			if f.Type == sizecacheType {
 				si.sizecacheOffset = offsetOf(f, mi.Exporter)
+				si.sizecacheType = f.Type
 			}
 		case genid.WeakFields_goname, genid.WeakFieldsA_goname:
 			if f.Type == weakFieldsType {
 				si.weakOffset = offsetOf(f, mi.Exporter)
+				si.weakType = f.Type
 			}
 		case genid.UnknownFields_goname, genid.UnknownFieldsA_goname:
-			if f.Type == unknownFieldsType {
+			if f.Type == unknownFieldsAType || f.Type == unknownFieldsBType {
 				si.unknownOffset = offsetOf(f, mi.Exporter)
+				si.unknownType = f.Type
 			}
 		case genid.ExtensionFields_goname, genid.ExtensionFieldsA_goname, genid.ExtensionFieldsB_goname:
 			if f.Type == extensionFieldsType {
 				si.extensionOffset = offsetOf(f, mi.Exporter)
+				si.extensionType = f.Type
 			}
 		default:
 			for _, s := range strings.Split(f.Tag.Get("protobuf"), ",") {
@@ -212,4 +224,53 @@ func (mi *MessageInfo) New() protoreflect.Message {
 func (mi *MessageInfo) Zero() protoreflect.Message {
 	return mi.MessageOf(reflect.Zero(mi.GoReflectType).Interface())
 }
-func (mi *MessageInfo) Descriptor() protoreflect.MessageDescriptor { return mi.Desc }
+func (mi *MessageInfo) Descriptor() protoreflect.MessageDescriptor {
+	return mi.Desc
+}
+func (mi *MessageInfo) Enum(i int) protoreflect.EnumType {
+	mi.init()
+	fd := mi.Desc.Fields().Get(i)
+	return Export{}.EnumTypeOf(mi.fieldTypes[fd.Number()])
+}
+func (mi *MessageInfo) Message(i int) protoreflect.MessageType {
+	mi.init()
+	fd := mi.Desc.Fields().Get(i)
+	switch {
+	case fd.IsWeak():
+		mt, _ := preg.GlobalTypes.FindMessageByName(fd.Message().FullName())
+		return mt
+	case fd.IsMap():
+		return mapEntryType{fd.Message(), mi.fieldTypes[fd.Number()]}
+	default:
+		return Export{}.MessageTypeOf(mi.fieldTypes[fd.Number()])
+	}
+}
+
+type mapEntryType struct {
+	desc    protoreflect.MessageDescriptor
+	valType interface{} // zero value of enum or message type
+}
+
+func (mt mapEntryType) New() protoreflect.Message {
+	return nil
+}
+func (mt mapEntryType) Zero() protoreflect.Message {
+	return nil
+}
+func (mt mapEntryType) Descriptor() protoreflect.MessageDescriptor {
+	return mt.desc
+}
+func (mt mapEntryType) Enum(i int) protoreflect.EnumType {
+	fd := mt.desc.Fields().Get(i)
+	if fd.Enum() == nil {
+		return nil
+	}
+	return Export{}.EnumTypeOf(mt.valType)
+}
+func (mt mapEntryType) Message(i int) protoreflect.MessageType {
+	fd := mt.desc.Fields().Get(i)
+	if fd.Message() == nil {
+		return nil
+	}
+	return Export{}.MessageTypeOf(mt.valType)
+}
diff --git a/vendor/google.golang.org/protobuf/internal/impl/message_reflect.go b/vendor/google.golang.org/protobuf/internal/impl/message_reflect.go
index 0f4b8db76..0c6f106ae 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/message_reflect.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/message_reflect.go
@@ -8,6 +8,7 @@ import (
 	"fmt"
 	"reflect"
 
+	"google.golang.org/protobuf/internal/detrand"
 	"google.golang.org/protobuf/internal/pragma"
 	pref "google.golang.org/protobuf/reflect/protoreflect"
 )
@@ -16,6 +17,11 @@ type reflectMessageInfo struct {
 	fields map[pref.FieldNumber]*fieldInfo
 	oneofs map[pref.Name]*oneofInfo
 
+	// fieldTypes contains the zero value of an enum or message field.
+	// For lists, it contains the element type.
+	// For maps, it contains the entry value type.
+	fieldTypes map[pref.FieldNumber]interface{}
+
 	// denseFields is a subset of fields where:
 	//	0 < fieldDesc.Number() < len(denseFields)
 	// It provides faster access to the fieldInfo, but may be incomplete.
@@ -36,6 +42,7 @@ func (mi *MessageInfo) makeReflectFuncs(t reflect.Type, si structInfo) {
 	mi.makeKnownFieldsFunc(si)
 	mi.makeUnknownFieldsFunc(t, si)
 	mi.makeExtensionFieldsFunc(t, si)
+	mi.makeFieldTypes(si)
 }
 
 // makeKnownFieldsFunc generates functions for operations that can be performed
@@ -61,7 +68,7 @@ func (mi *MessageInfo) makeKnownFieldsFunc(si structInfo) {
 			fi = fieldInfoForList(fd, fs, mi.Exporter)
 		case fd.IsWeak():
 			fi = fieldInfoForWeakMessage(fd, si.weakOffset)
-		case fd.Kind() == pref.MessageKind || fd.Kind() == pref.GroupKind:
+		case fd.Message() != nil:
 			fi = fieldInfoForMessage(fd, fs, mi.Exporter)
 		default:
 			fi = fieldInfoForScalar(fd, fs, mi.Exporter)
@@ -92,27 +99,53 @@ func (mi *MessageInfo) makeKnownFieldsFunc(si structInfo) {
 			i++
 		}
 	}
+
+	// Introduce instability to iteration order, but keep it deterministic.
+	if len(mi.rangeInfos) > 1 && detrand.Bool() {
+		i := detrand.Intn(len(mi.rangeInfos) - 1)
+		mi.rangeInfos[i], mi.rangeInfos[i+1] = mi.rangeInfos[i+1], mi.rangeInfos[i]
+	}
 }
 
 func (mi *MessageInfo) makeUnknownFieldsFunc(t reflect.Type, si structInfo) {
-	mi.getUnknown = func(pointer) pref.RawFields { return nil }
-	mi.setUnknown = func(pointer, pref.RawFields) { return }
-	if si.unknownOffset.IsValid() {
+	switch {
+	case si.unknownOffset.IsValid() && si.unknownType == unknownFieldsAType:
+		// Handle as []byte.
 		mi.getUnknown = func(p pointer) pref.RawFields {
 			if p.IsNil() {
 				return nil
 			}
-			rv := p.Apply(si.unknownOffset).AsValueOf(unknownFieldsType)
-			return pref.RawFields(*rv.Interface().(*[]byte))
+			return *p.Apply(mi.unknownOffset).Bytes()
 		}
 		mi.setUnknown = func(p pointer, b pref.RawFields) {
 			if p.IsNil() {
 				panic("invalid SetUnknown on nil Message")
 			}
-			rv := p.Apply(si.unknownOffset).AsValueOf(unknownFieldsType)
-			*rv.Interface().(*[]byte) = []byte(b)
+			*p.Apply(mi.unknownOffset).Bytes() = b
 		}
-	} else {
+	case si.unknownOffset.IsValid() && si.unknownType == unknownFieldsBType:
+		// Handle as *[]byte.
+		mi.getUnknown = func(p pointer) pref.RawFields {
+			if p.IsNil() {
+				return nil
+			}
+			bp := p.Apply(mi.unknownOffset).BytesPtr()
+			if *bp == nil {
+				return nil
+			}
+			return **bp
+		}
+		mi.setUnknown = func(p pointer, b pref.RawFields) {
+			if p.IsNil() {
+				panic("invalid SetUnknown on nil Message")
+			}
+			bp := p.Apply(mi.unknownOffset).BytesPtr()
+			if *bp == nil {
+				*bp = new([]byte)
+			}
+			**bp = b
+		}
+	default:
 		mi.getUnknown = func(pointer) pref.RawFields {
 			return nil
 		}
@@ -139,6 +172,45 @@ func (mi *MessageInfo) makeExtensionFieldsFunc(t reflect.Type, si structInfo) {
 		}
 	}
 }
+func (mi *MessageInfo) makeFieldTypes(si structInfo) {
+	md := mi.Desc
+	fds := md.Fields()
+	for i := 0; i < fds.Len(); i++ {
+		var ft reflect.Type
+		fd := fds.Get(i)
+		fs := si.fieldsByNumber[fd.Number()]
+		switch {
+		case fd.ContainingOneof() != nil && !fd.ContainingOneof().IsSynthetic():
+			if fd.Enum() != nil || fd.Message() != nil {
+				ft = si.oneofWrappersByNumber[fd.Number()].Field(0).Type
+			}
+		case fd.IsMap():
+			if fd.MapValue().Enum() != nil || fd.MapValue().Message() != nil {
+				ft = fs.Type.Elem()
+			}
+		case fd.IsList():
+			if fd.Enum() != nil || fd.Message() != nil {
+				ft = fs.Type.Elem()
+			}
+		case fd.Enum() != nil:
+			ft = fs.Type
+			if fd.HasPresence() {
+				ft = ft.Elem()
+			}
+		case fd.Message() != nil:
+			ft = fs.Type
+			if fd.IsWeak() {
+				ft = nil
+			}
+		}
+		if ft != nil {
+			if mi.fieldTypes == nil {
+				mi.fieldTypes = make(map[pref.FieldNumber]interface{})
+			}
+			mi.fieldTypes[fd.Number()] = reflect.Zero(ft).Interface()
+		}
+	}
+}
 
 type extensionMap map[int32]ExtensionField
 
@@ -306,7 +378,6 @@ var (
 // pointer to a named Go struct. If the provided type has a ProtoReflect method,
 // it must be implemented by calling this method.
 func (mi *MessageInfo) MessageOf(m interface{}) pref.Message {
-	// TODO: Switch the input to be an opaque Pointer.
 	if reflect.TypeOf(m) != mi.GoReflectType {
 		panic(fmt.Sprintf("type mismatch: got %T, want %v", m, mi.GoReflectType))
 	}
diff --git a/vendor/google.golang.org/protobuf/internal/impl/pointer_reflect.go b/vendor/google.golang.org/protobuf/internal/impl/pointer_reflect.go
index 67b4ede67..9e3ed821e 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/pointer_reflect.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/pointer_reflect.go
@@ -121,6 +121,7 @@ func (p pointer) String() *string          { return p.v.Interface().(*string) }
 func (p pointer) StringPtr() **string      { return p.v.Interface().(**string) }
 func (p pointer) StringSlice() *[]string   { return p.v.Interface().(*[]string) }
 func (p pointer) Bytes() *[]byte           { return p.v.Interface().(*[]byte) }
+func (p pointer) BytesPtr() **[]byte       { return p.v.Interface().(**[]byte) }
 func (p pointer) BytesSlice() *[][]byte    { return p.v.Interface().(*[][]byte) }
 func (p pointer) WeakFields() *weakFields  { return (*weakFields)(p.v.Interface().(*WeakFields)) }
 func (p pointer) Extensions() *map[int32]ExtensionField {
diff --git a/vendor/google.golang.org/protobuf/internal/impl/pointer_unsafe.go b/vendor/google.golang.org/protobuf/internal/impl/pointer_unsafe.go
index 088aa85d4..9ecf23a85 100644
--- a/vendor/google.golang.org/protobuf/internal/impl/pointer_unsafe.go
+++ b/vendor/google.golang.org/protobuf/internal/impl/pointer_unsafe.go
@@ -109,6 +109,7 @@ func (p pointer) String() *string                       { return (*string)(p.p)
 func (p pointer) StringPtr() **string                   { return (**string)(p.p) }
 func (p pointer) StringSlice() *[]string                { return (*[]string)(p.p) }
 func (p pointer) Bytes() *[]byte                        { return (*[]byte)(p.p) }
+func (p pointer) BytesPtr() **[]byte                    { return (**[]byte)(p.p) }
 func (p pointer) BytesSlice() *[][]byte                 { return (*[][]byte)(p.p) }
 func (p pointer) WeakFields() *weakFields               { return (*weakFields)(p.p) }
 func (p pointer) Extensions() *map[int32]ExtensionField { return (*map[int32]ExtensionField)(p.p) }
diff --git a/vendor/google.golang.org/protobuf/internal/mapsort/mapsort.go b/vendor/google.golang.org/protobuf/internal/mapsort/mapsort.go
deleted file mode 100644
index a3de1cf32..000000000
--- a/vendor/google.golang.org/protobuf/internal/mapsort/mapsort.go
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package mapsort provides sorted access to maps.
-package mapsort
-
-import (
-	"sort"
-
-	"google.golang.org/protobuf/reflect/protoreflect"
-)
-
-// Range iterates over every map entry in sorted key order,
-// calling f for each key and value encountered.
-func Range(mapv protoreflect.Map, keyKind protoreflect.Kind, f func(protoreflect.MapKey, protoreflect.Value) bool) {
-	var keys []protoreflect.MapKey
-	mapv.Range(func(key protoreflect.MapKey, _ protoreflect.Value) bool {
-		keys = append(keys, key)
-		return true
-	})
-	sort.Slice(keys, func(i, j int) bool {
-		switch keyKind {
-		case protoreflect.BoolKind:
-			return !keys[i].Bool() && keys[j].Bool()
-		case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
-			protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
-			return keys[i].Int() < keys[j].Int()
-		case protoreflect.Uint32Kind, protoreflect.Fixed32Kind,
-			protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
-			return keys[i].Uint() < keys[j].Uint()
-		case protoreflect.StringKind:
-			return keys[i].String() < keys[j].String()
-		default:
-			panic("invalid kind: " + keyKind.String())
-		}
-	})
-	for _, key := range keys {
-		if !f(key, mapv.Get(key)) {
-			break
-		}
-	}
-}
diff --git a/vendor/google.golang.org/protobuf/internal/order/order.go b/vendor/google.golang.org/protobuf/internal/order/order.go
new file mode 100644
index 000000000..2a24953f6
--- /dev/null
+++ b/vendor/google.golang.org/protobuf/internal/order/order.go
@@ -0,0 +1,89 @@
+// Copyright 2020 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package order
+
+import (
+	pref "google.golang.org/protobuf/reflect/protoreflect"
+)
+
+// FieldOrder specifies the ordering to visit message fields.
+// It is a function that reports whether x is ordered before y.
+type FieldOrder func(x, y pref.FieldDescriptor) bool
+
+var (
+	// AnyFieldOrder specifies no specific field ordering.
+	AnyFieldOrder FieldOrder = nil
+
+	// LegacyFieldOrder sorts fields in the same ordering as emitted by
+	// wire serialization in the github.com/golang/protobuf implementation.
+	LegacyFieldOrder FieldOrder = func(x, y pref.FieldDescriptor) bool {
+		ox, oy := x.ContainingOneof(), y.ContainingOneof()
+		inOneof := func(od pref.OneofDescriptor) bool {
+			return od != nil && !od.IsSynthetic()
+		}
+
+		// Extension fields sort before non-extension fields.
+		if x.IsExtension() != y.IsExtension() {
+			return x.IsExtension() && !y.IsExtension()
+		}
+		// Fields not within a oneof sort before those within a oneof.
+		if inOneof(ox) != inOneof(oy) {
+			return !inOneof(ox) && inOneof(oy)
+		}
+		// Fields in disjoint oneof sets are sorted by declaration index.
+		if ox != nil && oy != nil && ox != oy {
+			return ox.Index() < oy.Index()
+		}
+		// Fields sorted by field number.
+		return x.Number() < y.Number()
+	}
+
+	// NumberFieldOrder sorts fields by their field number.
+	NumberFieldOrder FieldOrder = func(x, y pref.FieldDescriptor) bool {
+		return x.Number() < y.Number()
+	}
+
+	// IndexNameFieldOrder sorts non-extension fields before extension fields.
+	// Non-extensions are sorted according to their declaration index.
+	// Extensions are sorted according to their full name.
+	IndexNameFieldOrder FieldOrder = func(x, y pref.FieldDescriptor) bool {
+		// Non-extension fields sort before extension fields.
+		if x.IsExtension() != y.IsExtension() {
+			return !x.IsExtension() && y.IsExtension()
+		}
+		// Extensions sorted by fullname.
+		if x.IsExtension() && y.IsExtension() {
+			return x.FullName() < y.FullName()
+		}
+		// Non-extensions sorted by declaration index.
+		return x.Index() < y.Index()
+	}
+)
+
+// KeyOrder specifies the ordering to visit map entries.
+// It is a function that reports whether x is ordered before y.
+type KeyOrder func(x, y pref.MapKey) bool
+
+var (
+	// AnyKeyOrder specifies no specific key ordering.
+	AnyKeyOrder KeyOrder = nil
+
+	// GenericKeyOrder sorts false before true, numeric keys in ascending order,
+	// and strings in lexicographical ordering according to UTF-8 codepoints.
+	GenericKeyOrder KeyOrder = func(x, y pref.MapKey) bool {
+		switch x.Interface().(type) {
+		case bool:
+			return !x.Bool() && y.Bool()
+		case int32, int64:
+			return x.Int() < y.Int()
+		case uint32, uint64:
+			return x.Uint() < y.Uint()
+		case string:
+			return x.String() < y.String()
+		default:
+			panic("invalid map key type")
+		}
+	}
+)
diff --git a/vendor/google.golang.org/protobuf/internal/order/range.go b/vendor/google.golang.org/protobuf/internal/order/range.go
new file mode 100644
index 000000000..c8090e0c5
--- /dev/null
+++ b/vendor/google.golang.org/protobuf/internal/order/range.go
@@ -0,0 +1,115 @@
+// Copyright 2020 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package order provides ordered access to messages and maps.
+package order
+
+import (
+	"sort"
+	"sync"
+
+	pref "google.golang.org/protobuf/reflect/protoreflect"
+)
+
+type messageField struct {
+	fd pref.FieldDescriptor
+	v  pref.Value
+}
+
+var messageFieldPool = sync.Pool{
+	New: func() interface{} { return new([]messageField) },
+}
+
+type (
+	// FieldRnger is an interface for visiting all fields in a message.
+	// The protoreflect.Message type implements this interface.
+	FieldRanger interface{ Range(VisitField) }
+	// VisitField is called everytime a message field is visited.
+	VisitField = func(pref.FieldDescriptor, pref.Value) bool
+)
+
+// RangeFields iterates over the fields of fs according to the specified order.
+func RangeFields(fs FieldRanger, less FieldOrder, fn VisitField) {
+	if less == nil {
+		fs.Range(fn)
+		return
+	}
+
+	// Obtain a pre-allocated scratch buffer.
+	p := messageFieldPool.Get().(*[]messageField)
+	fields := (*p)[:0]
+	defer func() {
+		if cap(fields) < 1024 {
+			*p = fields
+			messageFieldPool.Put(p)
+		}
+	}()
+
+	// Collect all fields in the message and sort them.
+	fs.Range(func(fd pref.FieldDescriptor, v pref.Value) bool {
+		fields = append(fields, messageField{fd, v})
+		return true
+	})
+	sort.Slice(fields, func(i, j int) bool {
+		return less(fields[i].fd, fields[j].fd)
+	})
+
+	// Visit the fields in the specified ordering.
+	for _, f := range fields {
+		if !fn(f.fd, f.v) {
+			return
+		}
+	}
+}
+
+type mapEntry struct {
+	k pref.MapKey
+	v pref.Value
+}
+
+var mapEntryPool = sync.Pool{
+	New: func() interface{} { return new([]mapEntry) },
+}
+
+type (
+	// EntryRanger is an interface for visiting all fields in a message.
+	// The protoreflect.Map type implements this interface.
+	EntryRanger interface{ Range(VisitEntry) }
+	// VisitEntry is called everytime a map entry is visited.
+	VisitEntry = func(pref.MapKey, pref.Value) bool
+)
+
+// RangeEntries iterates over the entries of es according to the specified order.
+func RangeEntries(es EntryRanger, less KeyOrder, fn VisitEntry) {
+	if less == nil {
+		es.Range(fn)
+		return
+	}
+
+	// Obtain a pre-allocated scratch buffer.
+	p := mapEntryPool.Get().(*[]mapEntry)
+	entries := (*p)[:0]
+	defer func() {
+		if cap(entries) < 1024 {
+			*p = entries
+			mapEntryPool.Put(p)
+		}
+	}()
+
+	// Collect all entries in the map and sort them.
+	es.Range(func(k pref.MapKey, v pref.Value) bool {
+		entries = append(entries, mapEntry{k, v})
+		return true
+	})
+	sort.Slice(entries, func(i, j int) bool {
+		return less(entries[i].k, entries[j].k)
+	})
+
+	// Visit the entries in the specified ordering.
+	for _, e := range entries {
+		if !fn(e.k, e.v) {
+			return
+		}
+	}
+}
diff --git a/vendor/google.golang.org/protobuf/internal/version/version.go b/vendor/google.golang.org/protobuf/internal/version/version.go
index 72cf770b4..72b24ee5e 100644
--- a/vendor/google.golang.org/protobuf/internal/version/version.go
+++ b/vendor/google.golang.org/protobuf/internal/version/version.go
@@ -54,7 +54,7 @@ const (
 	Major      = 1
 	Minor      = 25
 	Patch      = 0
-	PreRelease = ""
+	PreRelease = "devel"
 )
 
 // String formats the version string for this module in semver format.
diff --git a/vendor/google.golang.org/protobuf/proto/decode.go b/vendor/google.golang.org/protobuf/proto/decode.go
index 42fc5195e..a0efaa038 100644
--- a/vendor/google.golang.org/protobuf/proto/decode.go
+++ b/vendor/google.golang.org/protobuf/proto/decode.go
@@ -116,10 +116,10 @@ func (o UnmarshalOptions) unmarshalMessageSlow(b []byte, m protoreflect.Message)
 		// Parse the tag (field number and wire type).
 		num, wtyp, tagLen := protowire.ConsumeTag(b)
 		if tagLen < 0 {
-			return protowire.ParseError(tagLen)
+			return errDecode
 		}
 		if num > protowire.MaxValidNumber {
-			return errors.New("invalid field number")
+			return errDecode
 		}
 
 		// Find the field descriptor for this field number.
@@ -159,7 +159,7 @@ func (o UnmarshalOptions) unmarshalMessageSlow(b []byte, m protoreflect.Message)
 			}
 			valLen = protowire.ConsumeFieldValue(num, wtyp, b[tagLen:])
 			if valLen < 0 {
-				return protowire.ParseError(valLen)
+				return errDecode
 			}
 			if !o.DiscardUnknown {
 				m.SetUnknown(append(m.GetUnknown(), b[:tagLen+valLen]...))
@@ -194,7 +194,7 @@ func (o UnmarshalOptions) unmarshalMap(b []byte, wtyp protowire.Type, mapv proto
 	}
 	b, n = protowire.ConsumeBytes(b)
 	if n < 0 {
-		return 0, protowire.ParseError(n)
+		return 0, errDecode
 	}
 	var (
 		keyField = fd.MapKey()
@@ -213,10 +213,10 @@ func (o UnmarshalOptions) unmarshalMap(b []byte, wtyp protowire.Type, mapv proto
 	for len(b) > 0 {
 		num, wtyp, n := protowire.ConsumeTag(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		if num > protowire.MaxValidNumber {
-			return 0, errors.New("invalid field number")
+			return 0, errDecode
 		}
 		b = b[n:]
 		err = errUnknown
@@ -246,7 +246,7 @@ func (o UnmarshalOptions) unmarshalMap(b []byte, wtyp protowire.Type, mapv proto
 		if err == errUnknown {
 			n = protowire.ConsumeFieldValue(num, wtyp, b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 		} else if err != nil {
 			return 0, err
@@ -272,3 +272,5 @@ func (o UnmarshalOptions) unmarshalMap(b []byte, wtyp protowire.Type, mapv proto
 // to the unknown field set of a message. It is never returned from an exported
 // function.
 var errUnknown = errors.New("BUG: internal error (unknown)")
+
+var errDecode = errors.New("cannot parse invalid wire-format data")
diff --git a/vendor/google.golang.org/protobuf/proto/decode_gen.go b/vendor/google.golang.org/protobuf/proto/decode_gen.go
index d6dc904dc..301eeb20f 100644
--- a/vendor/google.golang.org/protobuf/proto/decode_gen.go
+++ b/vendor/google.golang.org/protobuf/proto/decode_gen.go
@@ -27,7 +27,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfBool(protowire.DecodeBool(v)), n, nil
 	case protoreflect.EnumKind:
@@ -36,7 +36,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfEnum(protoreflect.EnumNumber(v)), n, nil
 	case protoreflect.Int32Kind:
@@ -45,7 +45,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfInt32(int32(v)), n, nil
 	case protoreflect.Sint32Kind:
@@ -54,7 +54,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfInt32(int32(protowire.DecodeZigZag(v & math.MaxUint32))), n, nil
 	case protoreflect.Uint32Kind:
@@ -63,7 +63,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfUint32(uint32(v)), n, nil
 	case protoreflect.Int64Kind:
@@ -72,7 +72,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfInt64(int64(v)), n, nil
 	case protoreflect.Sint64Kind:
@@ -81,7 +81,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfInt64(protowire.DecodeZigZag(v)), n, nil
 	case protoreflect.Uint64Kind:
@@ -90,7 +90,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfUint64(v), n, nil
 	case protoreflect.Sfixed32Kind:
@@ -99,7 +99,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeFixed32(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfInt32(int32(v)), n, nil
 	case protoreflect.Fixed32Kind:
@@ -108,7 +108,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeFixed32(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfUint32(uint32(v)), n, nil
 	case protoreflect.FloatKind:
@@ -117,7 +117,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeFixed32(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfFloat32(math.Float32frombits(uint32(v))), n, nil
 	case protoreflect.Sfixed64Kind:
@@ -126,7 +126,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeFixed64(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfInt64(int64(v)), n, nil
 	case protoreflect.Fixed64Kind:
@@ -135,7 +135,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeFixed64(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfUint64(v), n, nil
 	case protoreflect.DoubleKind:
@@ -144,7 +144,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeFixed64(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfFloat64(math.Float64frombits(v)), n, nil
 	case protoreflect.StringKind:
@@ -153,7 +153,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		if strs.EnforceUTF8(fd) && !utf8.Valid(v) {
 			return protoreflect.Value{}, 0, errors.InvalidUTF8(string(fd.FullName()))
@@ -165,7 +165,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfBytes(append(emptyBuf[:], v...)), n, nil
 	case protoreflect.MessageKind:
@@ -174,7 +174,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfBytes(v), n, nil
 	case protoreflect.GroupKind:
@@ -183,7 +183,7 @@ func (o UnmarshalOptions) unmarshalScalar(b []byte, wtyp protowire.Type, fd prot
 		}
 		v, n := protowire.ConsumeGroup(fd.Number(), b)
 		if n < 0 {
-			return val, 0, protowire.ParseError(n)
+			return val, 0, errDecode
 		}
 		return protoreflect.ValueOfBytes(v), n, nil
 	default:
@@ -197,12 +197,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeVarint(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfBool(protowire.DecodeBool(v)))
@@ -214,7 +214,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfBool(protowire.DecodeBool(v)))
 		return n, nil
@@ -222,12 +222,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeVarint(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfEnum(protoreflect.EnumNumber(v)))
@@ -239,7 +239,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfEnum(protoreflect.EnumNumber(v)))
 		return n, nil
@@ -247,12 +247,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeVarint(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfInt32(int32(v)))
@@ -264,7 +264,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfInt32(int32(v)))
 		return n, nil
@@ -272,12 +272,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeVarint(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfInt32(int32(protowire.DecodeZigZag(v & math.MaxUint32))))
@@ -289,7 +289,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfInt32(int32(protowire.DecodeZigZag(v & math.MaxUint32))))
 		return n, nil
@@ -297,12 +297,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeVarint(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfUint32(uint32(v)))
@@ -314,7 +314,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfUint32(uint32(v)))
 		return n, nil
@@ -322,12 +322,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeVarint(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfInt64(int64(v)))
@@ -339,7 +339,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfInt64(int64(v)))
 		return n, nil
@@ -347,12 +347,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeVarint(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfInt64(protowire.DecodeZigZag(v)))
@@ -364,7 +364,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfInt64(protowire.DecodeZigZag(v)))
 		return n, nil
@@ -372,12 +372,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeVarint(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfUint64(v))
@@ -389,7 +389,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeVarint(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfUint64(v))
 		return n, nil
@@ -397,12 +397,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeFixed32(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfInt32(int32(v)))
@@ -414,7 +414,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeFixed32(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfInt32(int32(v)))
 		return n, nil
@@ -422,12 +422,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeFixed32(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfUint32(uint32(v)))
@@ -439,7 +439,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeFixed32(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfUint32(uint32(v)))
 		return n, nil
@@ -447,12 +447,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeFixed32(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfFloat32(math.Float32frombits(uint32(v))))
@@ -464,7 +464,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeFixed32(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfFloat32(math.Float32frombits(uint32(v))))
 		return n, nil
@@ -472,12 +472,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeFixed64(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfInt64(int64(v)))
@@ -489,7 +489,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeFixed64(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfInt64(int64(v)))
 		return n, nil
@@ -497,12 +497,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeFixed64(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfUint64(v))
@@ -514,7 +514,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeFixed64(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfUint64(v))
 		return n, nil
@@ -522,12 +522,12 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		if wtyp == protowire.BytesType {
 			buf, n := protowire.ConsumeBytes(b)
 			if n < 0 {
-				return 0, protowire.ParseError(n)
+				return 0, errDecode
 			}
 			for len(buf) > 0 {
 				v, n := protowire.ConsumeFixed64(buf)
 				if n < 0 {
-					return 0, protowire.ParseError(n)
+					return 0, errDecode
 				}
 				buf = buf[n:]
 				list.Append(protoreflect.ValueOfFloat64(math.Float64frombits(v)))
@@ -539,7 +539,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeFixed64(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfFloat64(math.Float64frombits(v)))
 		return n, nil
@@ -549,7 +549,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		if strs.EnforceUTF8(fd) && !utf8.Valid(v) {
 			return 0, errors.InvalidUTF8(string(fd.FullName()))
@@ -562,7 +562,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		list.Append(protoreflect.ValueOfBytes(append(emptyBuf[:], v...)))
 		return n, nil
@@ -572,7 +572,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeBytes(b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		m := list.NewElement()
 		if err := o.unmarshalMessage(v, m.Message()); err != nil {
@@ -586,7 +586,7 @@ func (o UnmarshalOptions) unmarshalList(b []byte, wtyp protowire.Type, list prot
 		}
 		v, n := protowire.ConsumeGroup(fd.Number(), b)
 		if n < 0 {
-			return 0, protowire.ParseError(n)
+			return 0, errDecode
 		}
 		m := list.NewElement()
 		if err := o.unmarshalMessage(v, m.Message()); err != nil {
diff --git a/vendor/google.golang.org/protobuf/proto/encode.go b/vendor/google.golang.org/protobuf/proto/encode.go
index 7b47a1180..d18239c23 100644
--- a/vendor/google.golang.org/protobuf/proto/encode.go
+++ b/vendor/google.golang.org/protobuf/proto/encode.go
@@ -5,12 +5,9 @@
 package proto
 
 import (
-	"sort"
-
 	"google.golang.org/protobuf/encoding/protowire"
 	"google.golang.org/protobuf/internal/encoding/messageset"
-	"google.golang.org/protobuf/internal/fieldsort"
-	"google.golang.org/protobuf/internal/mapsort"
+	"google.golang.org/protobuf/internal/order"
 	"google.golang.org/protobuf/internal/pragma"
 	"google.golang.org/protobuf/reflect/protoreflect"
 	"google.golang.org/protobuf/runtime/protoiface"
@@ -211,14 +208,15 @@ func (o MarshalOptions) marshalMessageSlow(b []byte, m protoreflect.Message) ([]
 	if messageset.IsMessageSet(m.Descriptor()) {
 		return o.marshalMessageSet(b, m)
 	}
-	// There are many choices for what order we visit fields in. The default one here
-	// is chosen for reasonable efficiency and simplicity given the protoreflect API.
-	// It is not deterministic, since Message.Range does not return fields in any
-	// defined order.
-	//
-	// When using deterministic serialization, we sort the known fields.
+	fieldOrder := order.AnyFieldOrder
+	if o.Deterministic {
+		// TODO: This should use a more natural ordering like NumberFieldOrder,
+		// but doing so breaks golden tests that make invalid assumption about
+		// output stability of this implementation.
+		fieldOrder = order.LegacyFieldOrder
+	}
 	var err error
-	o.rangeFields(m, func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
+	order.RangeFields(m, fieldOrder, func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
 		b, err = o.marshalField(b, fd, v)
 		return err == nil
 	})
@@ -229,27 +227,6 @@ func (o MarshalOptions) marshalMessageSlow(b []byte, m protoreflect.Message) ([]
 	return b, nil
 }
 
-// rangeFields visits fields in a defined order when deterministic serialization is enabled.
-func (o MarshalOptions) rangeFields(m protoreflect.Message, f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
-	if !o.Deterministic {
-		m.Range(f)
-		return
-	}
-	var fds []protoreflect.FieldDescriptor
-	m.Range(func(fd protoreflect.FieldDescriptor, _ protoreflect.Value) bool {
-		fds = append(fds, fd)
-		return true
-	})
-	sort.Slice(fds, func(a, b int) bool {
-		return fieldsort.Less(fds[a], fds[b])
-	})
-	for _, fd := range fds {
-		if !f(fd, m.Get(fd)) {
-			break
-		}
-	}
-}
-
 func (o MarshalOptions) marshalField(b []byte, fd protoreflect.FieldDescriptor, value protoreflect.Value) ([]byte, error) {
 	switch {
 	case fd.IsList():
@@ -292,8 +269,12 @@ func (o MarshalOptions) marshalList(b []byte, fd protoreflect.FieldDescriptor, l
 func (o MarshalOptions) marshalMap(b []byte, fd protoreflect.FieldDescriptor, mapv protoreflect.Map) ([]byte, error) {
 	keyf := fd.MapKey()
 	valf := fd.MapValue()
+	keyOrder := order.AnyKeyOrder
+	if o.Deterministic {
+		keyOrder = order.GenericKeyOrder
+	}
 	var err error
-	o.rangeMap(mapv, keyf.Kind(), func(key protoreflect.MapKey, value protoreflect.Value) bool {
+	order.RangeEntries(mapv, keyOrder, func(key protoreflect.MapKey, value protoreflect.Value) bool {
 		b = protowire.AppendTag(b, fd.Number(), protowire.BytesType)
 		var pos int
 		b, pos = appendSpeculativeLength(b)
@@ -312,14 +293,6 @@ func (o MarshalOptions) marshalMap(b []byte, fd protoreflect.FieldDescriptor, ma
 	return b, err
 }
 
-func (o MarshalOptions) rangeMap(mapv protoreflect.Map, kind protoreflect.Kind, f func(protoreflect.MapKey, protoreflect.Value) bool) {
-	if !o.Deterministic {
-		mapv.Range(f)
-		return
-	}
-	mapsort.Range(mapv, kind, f)
-}
-
 // When encoding length-prefixed fields, we speculatively set aside some number of bytes
 // for the length, encode the data, and then encode the length (shifting the data if necessary
 // to make room).
diff --git a/vendor/google.golang.org/protobuf/proto/messageset.go b/vendor/google.golang.org/protobuf/proto/messageset.go
index 1d692c3a8..312d5d45c 100644
--- a/vendor/google.golang.org/protobuf/proto/messageset.go
+++ b/vendor/google.golang.org/protobuf/proto/messageset.go
@@ -9,6 +9,7 @@ import (
 	"google.golang.org/protobuf/internal/encoding/messageset"
 	"google.golang.org/protobuf/internal/errors"
 	"google.golang.org/protobuf/internal/flags"
+	"google.golang.org/protobuf/internal/order"
 	"google.golang.org/protobuf/reflect/protoreflect"
 	"google.golang.org/protobuf/reflect/protoregistry"
 )
@@ -28,8 +29,12 @@ func (o MarshalOptions) marshalMessageSet(b []byte, m protoreflect.Message) ([]b
 	if !flags.ProtoLegacy {
 		return b, errors.New("no support for message_set_wire_format")
 	}
+	fieldOrder := order.AnyFieldOrder
+	if o.Deterministic {
+		fieldOrder = order.NumberFieldOrder
+	}
 	var err error
-	o.rangeFields(m, func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
+	order.RangeFields(m, fieldOrder, func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
 		b, err = o.marshalMessageSetField(b, fd, v)
 		return err == nil
 	})
diff --git a/vendor/google.golang.org/protobuf/proto/proto.go b/vendor/google.golang.org/protobuf/proto/proto.go
index ca14b09c3..1f0d183b1 100644
--- a/vendor/google.golang.org/protobuf/proto/proto.go
+++ b/vendor/google.golang.org/protobuf/proto/proto.go
@@ -32,3 +32,12 @@ var Error error
 func init() {
 	Error = errors.Error
 }
+
+// MessageName returns the full name of m.
+// If m is nil, it returns an empty string.
+func MessageName(m Message) protoreflect.FullName {
+	if m == nil {
+		return ""
+	}
+	return m.ProtoReflect().Descriptor().FullName()
+}
diff --git a/vendor/google.golang.org/protobuf/reflect/protodesc/desc.go b/vendor/google.golang.org/protobuf/reflect/protodesc/desc.go
index 37f254d4c..e4dfb1205 100644
--- a/vendor/google.golang.org/protobuf/reflect/protodesc/desc.go
+++ b/vendor/google.golang.org/protobuf/reflect/protodesc/desc.go
@@ -144,6 +144,7 @@ func (o FileOptions) New(fd *descriptorpb.FileDescriptorProto, r Resolver) (prot
 	}
 
 	// Handle source locations.
+	f.L2.Locations.File = f
 	for _, loc := range fd.GetSourceCodeInfo().GetLocation() {
 		var l protoreflect.SourceLocation
 		// TODO: Validate that the path points to an actual declaration?
diff --git a/vendor/google.golang.org/protobuf/reflect/protodesc/desc_init.go b/vendor/google.golang.org/protobuf/reflect/protodesc/desc_init.go
index 673a230e7..37efda1af 100644
--- a/vendor/google.golang.org/protobuf/reflect/protodesc/desc_init.go
+++ b/vendor/google.golang.org/protobuf/reflect/protodesc/desc_init.go
@@ -135,7 +135,7 @@ func (r descsByName) initFieldsFromDescriptorProto(fds []*descriptorpb.FieldDesc
 			f.L1.Kind = protoreflect.Kind(fd.GetType())
 		}
 		if fd.JsonName != nil {
-			f.L1.JSONName.Init(fd.GetJsonName())
+			f.L1.StringName.InitJSON(fd.GetJsonName())
 		}
 	}
 	return fs, nil
@@ -175,7 +175,7 @@ func (r descsByName) initExtensionDeclarations(xds []*descriptorpb.FieldDescript
 			x.L1.Kind = protoreflect.Kind(xd.GetType())
 		}
 		if xd.JsonName != nil {
-			x.L2.JSONName.Init(xd.GetJsonName())
+			x.L2.StringName.InitJSON(xd.GetJsonName())
 		}
 	}
 	return xs, nil
diff --git a/vendor/google.golang.org/protobuf/reflect/protodesc/desc_validate.go b/vendor/google.golang.org/protobuf/reflect/protodesc/desc_validate.go
index 2d5fa9936..9af1d5648 100644
--- a/vendor/google.golang.org/protobuf/reflect/protodesc/desc_validate.go
+++ b/vendor/google.golang.org/protobuf/reflect/protodesc/desc_validate.go
@@ -239,6 +239,9 @@ func validateExtensionDeclarations(xs []filedesc.Extension, xds []*descriptorpb.
 			return errors.New("extension field %q has an invalid cardinality: %d", x.FullName(), x.Cardinality())
 		}
 		if xd.JsonName != nil {
+			// A bug in older versions of protoc would always populate the
+			// "json_name" option for extensions when it is meaningless.
+			// When it did so, it would always use the camel-cased field name.
 			if xd.GetJsonName() != strs.JSONCamelCase(string(x.Name())) {
 				return errors.New("extension field %q may not have an explicitly set JSON name: %q", x.FullName(), xd.GetJsonName())
 			}
diff --git a/vendor/google.golang.org/protobuf/reflect/protodesc/proto.go b/vendor/google.golang.org/protobuf/reflect/protodesc/proto.go
index 00d35e02e..a1b7c5058 100644
--- a/vendor/google.golang.org/protobuf/reflect/protodesc/proto.go
+++ b/vendor/google.golang.org/protobuf/reflect/protodesc/proto.go
@@ -9,6 +9,7 @@ import (
 	"strings"
 
 	"google.golang.org/protobuf/internal/encoding/defval"
+	"google.golang.org/protobuf/internal/strs"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/reflect/protoreflect"
 
@@ -138,7 +139,14 @@ func ToFieldDescriptorProto(field protoreflect.FieldDescriptor) *descriptorpb.Fi
 		p.TypeName = fullNameOf(field.Message())
 	}
 	if field.HasJSONName() {
-		p.JsonName = proto.String(field.JSONName())
+		// A bug in older versions of protoc would always populate the
+		// "json_name" option for extensions when it is meaningless.
+		// When it did so, it would always use the camel-cased field name.
+		if field.IsExtension() {
+			p.JsonName = proto.String(strs.JSONCamelCase(string(field.Name())))
+		} else {
+			p.JsonName = proto.String(field.JSONName())
+		}
 	}
 	if field.Syntax() == protoreflect.Proto3 && field.HasOptionalKeyword() {
 		p.Proto3Optional = proto.Bool(true)
diff --git a/vendor/google.golang.org/protobuf/reflect/protoreflect/source.go b/vendor/google.golang.org/protobuf/reflect/protoreflect/source.go
index 32ea3d98c..121ba3a07 100644
--- a/vendor/google.golang.org/protobuf/reflect/protoreflect/source.go
+++ b/vendor/google.golang.org/protobuf/reflect/protoreflect/source.go
@@ -4,6 +4,10 @@
 
 package protoreflect
 
+import (
+	"strconv"
+)
+
 // SourceLocations is a list of source locations.
 type SourceLocations interface {
 	// Len reports the number of source locations in the proto file.
@@ -11,9 +15,20 @@ type SourceLocations interface {
 	// Get returns the ith SourceLocation. It panics if out of bounds.
 	Get(int) SourceLocation
 
-	doNotImplement
+	// ByPath returns the SourceLocation for the given path,
+	// returning the first location if multiple exist for the same path.
+	// If multiple locations exist for the same path,
+	// then SourceLocation.Next index can be used to identify the
+	// index of the next SourceLocation.
+	// If no location exists for this path, it returns the zero value.
+	ByPath(path SourcePath) SourceLocation
 
-	// TODO: Add ByPath and ByDescriptor helper methods.
+	// ByDescriptor returns the SourceLocation for the given descriptor,
+	// returning the first location if multiple exist for the same path.
+	// If no location exists for this descriptor, it returns the zero value.
+	ByDescriptor(desc Descriptor) SourceLocation
+
+	doNotImplement
 }
 
 // SourceLocation describes a source location and
@@ -39,6 +54,10 @@ type SourceLocation struct {
 	LeadingComments string
 	// TrailingComments is the trailing attached comment for the declaration.
 	TrailingComments string
+
+	// Next is an index into SourceLocations for the next source location that
+	// has the same Path. It is zero if there is no next location.
+	Next int
 }
 
 // SourcePath identifies part of a file descriptor for a source location.
@@ -48,5 +67,62 @@ type SourceLocation struct {
 // See google.protobuf.SourceCodeInfo.Location.path.
 type SourcePath []int32
 
-// TODO: Add SourcePath.String method to pretty-print the path. For example:
-//	".message_type[6].nested_type[15].field[3]"
+// Equal reports whether p1 equals p2.
+func (p1 SourcePath) Equal(p2 SourcePath) bool {
+	if len(p1) != len(p2) {
+		return false
+	}
+	for i := range p1 {
+		if p1[i] != p2[i] {
+			return false
+		}
+	}
+	return true
+}
+
+// String formats the path in a humanly readable manner.
+// The output is guaranteed to be deterministic,
+// making it suitable for use as a key into a Go map.
+// It is not guaranteed to be stable as the exact output could change
+// in a future version of this module.
+//
+// Example output:
+//	.message_type[6].nested_type[15].field[3]
+func (p SourcePath) String() string {
+	b := p.appendFileDescriptorProto(nil)
+	for _, i := range p {
+		b = append(b, '.')
+		b = strconv.AppendInt(b, int64(i), 10)
+	}
+	return string(b)
+}
+
+type appendFunc func(*SourcePath, []byte) []byte
+
+func (p *SourcePath) appendSingularField(b []byte, name string, f appendFunc) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	b = append(b, '.')
+	b = append(b, name...)
+	*p = (*p)[1:]
+	if f != nil {
+		b = f(p, b)
+	}
+	return b
+}
+
+func (p *SourcePath) appendRepeatedField(b []byte, name string, f appendFunc) []byte {
+	b = p.appendSingularField(b, name, nil)
+	if len(*p) == 0 || (*p)[0] < 0 {
+		return b
+	}
+	b = append(b, '[')
+	b = strconv.AppendUint(b, uint64((*p)[0]), 10)
+	b = append(b, ']')
+	*p = (*p)[1:]
+	if f != nil {
+		b = f(p, b)
+	}
+	return b
+}
diff --git a/vendor/google.golang.org/protobuf/reflect/protoreflect/source_gen.go b/vendor/google.golang.org/protobuf/reflect/protoreflect/source_gen.go
new file mode 100644
index 000000000..b03c1223c
--- /dev/null
+++ b/vendor/google.golang.org/protobuf/reflect/protoreflect/source_gen.go
@@ -0,0 +1,461 @@
+// Copyright 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Code generated by generate-protos. DO NOT EDIT.
+
+package protoreflect
+
+func (p *SourcePath) appendFileDescriptorProto(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "name", nil)
+	case 2:
+		b = p.appendSingularField(b, "package", nil)
+	case 3:
+		b = p.appendRepeatedField(b, "dependency", nil)
+	case 10:
+		b = p.appendRepeatedField(b, "public_dependency", nil)
+	case 11:
+		b = p.appendRepeatedField(b, "weak_dependency", nil)
+	case 4:
+		b = p.appendRepeatedField(b, "message_type", (*SourcePath).appendDescriptorProto)
+	case 5:
+		b = p.appendRepeatedField(b, "enum_type", (*SourcePath).appendEnumDescriptorProto)
+	case 6:
+		b = p.appendRepeatedField(b, "service", (*SourcePath).appendServiceDescriptorProto)
+	case 7:
+		b = p.appendRepeatedField(b, "extension", (*SourcePath).appendFieldDescriptorProto)
+	case 8:
+		b = p.appendSingularField(b, "options", (*SourcePath).appendFileOptions)
+	case 9:
+		b = p.appendSingularField(b, "source_code_info", (*SourcePath).appendSourceCodeInfo)
+	case 12:
+		b = p.appendSingularField(b, "syntax", nil)
+	}
+	return b
+}
+
+func (p *SourcePath) appendDescriptorProto(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "name", nil)
+	case 2:
+		b = p.appendRepeatedField(b, "field", (*SourcePath).appendFieldDescriptorProto)
+	case 6:
+		b = p.appendRepeatedField(b, "extension", (*SourcePath).appendFieldDescriptorProto)
+	case 3:
+		b = p.appendRepeatedField(b, "nested_type", (*SourcePath).appendDescriptorProto)
+	case 4:
+		b = p.appendRepeatedField(b, "enum_type", (*SourcePath).appendEnumDescriptorProto)
+	case 5:
+		b = p.appendRepeatedField(b, "extension_range", (*SourcePath).appendDescriptorProto_ExtensionRange)
+	case 8:
+		b = p.appendRepeatedField(b, "oneof_decl", (*SourcePath).appendOneofDescriptorProto)
+	case 7:
+		b = p.appendSingularField(b, "options", (*SourcePath).appendMessageOptions)
+	case 9:
+		b = p.appendRepeatedField(b, "reserved_range", (*SourcePath).appendDescriptorProto_ReservedRange)
+	case 10:
+		b = p.appendRepeatedField(b, "reserved_name", nil)
+	}
+	return b
+}
+
+func (p *SourcePath) appendEnumDescriptorProto(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "name", nil)
+	case 2:
+		b = p.appendRepeatedField(b, "value", (*SourcePath).appendEnumValueDescriptorProto)
+	case 3:
+		b = p.appendSingularField(b, "options", (*SourcePath).appendEnumOptions)
+	case 4:
+		b = p.appendRepeatedField(b, "reserved_range", (*SourcePath).appendEnumDescriptorProto_EnumReservedRange)
+	case 5:
+		b = p.appendRepeatedField(b, "reserved_name", nil)
+	}
+	return b
+}
+
+func (p *SourcePath) appendServiceDescriptorProto(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "name", nil)
+	case 2:
+		b = p.appendRepeatedField(b, "method", (*SourcePath).appendMethodDescriptorProto)
+	case 3:
+		b = p.appendSingularField(b, "options", (*SourcePath).appendServiceOptions)
+	}
+	return b
+}
+
+func (p *SourcePath) appendFieldDescriptorProto(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "name", nil)
+	case 3:
+		b = p.appendSingularField(b, "number", nil)
+	case 4:
+		b = p.appendSingularField(b, "label", nil)
+	case 5:
+		b = p.appendSingularField(b, "type", nil)
+	case 6:
+		b = p.appendSingularField(b, "type_name", nil)
+	case 2:
+		b = p.appendSingularField(b, "extendee", nil)
+	case 7:
+		b = p.appendSingularField(b, "default_value", nil)
+	case 9:
+		b = p.appendSingularField(b, "oneof_index", nil)
+	case 10:
+		b = p.appendSingularField(b, "json_name", nil)
+	case 8:
+		b = p.appendSingularField(b, "options", (*SourcePath).appendFieldOptions)
+	case 17:
+		b = p.appendSingularField(b, "proto3_optional", nil)
+	}
+	return b
+}
+
+func (p *SourcePath) appendFileOptions(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "java_package", nil)
+	case 8:
+		b = p.appendSingularField(b, "java_outer_classname", nil)
+	case 10:
+		b = p.appendSingularField(b, "java_multiple_files", nil)
+	case 20:
+		b = p.appendSingularField(b, "java_generate_equals_and_hash", nil)
+	case 27:
+		b = p.appendSingularField(b, "java_string_check_utf8", nil)
+	case 9:
+		b = p.appendSingularField(b, "optimize_for", nil)
+	case 11:
+		b = p.appendSingularField(b, "go_package", nil)
+	case 16:
+		b = p.appendSingularField(b, "cc_generic_services", nil)
+	case 17:
+		b = p.appendSingularField(b, "java_generic_services", nil)
+	case 18:
+		b = p.appendSingularField(b, "py_generic_services", nil)
+	case 42:
+		b = p.appendSingularField(b, "php_generic_services", nil)
+	case 23:
+		b = p.appendSingularField(b, "deprecated", nil)
+	case 31:
+		b = p.appendSingularField(b, "cc_enable_arenas", nil)
+	case 36:
+		b = p.appendSingularField(b, "objc_class_prefix", nil)
+	case 37:
+		b = p.appendSingularField(b, "csharp_namespace", nil)
+	case 39:
+		b = p.appendSingularField(b, "swift_prefix", nil)
+	case 40:
+		b = p.appendSingularField(b, "php_class_prefix", nil)
+	case 41:
+		b = p.appendSingularField(b, "php_namespace", nil)
+	case 44:
+		b = p.appendSingularField(b, "php_metadata_namespace", nil)
+	case 45:
+		b = p.appendSingularField(b, "ruby_package", nil)
+	case 999:
+		b = p.appendRepeatedField(b, "uninterpreted_option", (*SourcePath).appendUninterpretedOption)
+	}
+	return b
+}
+
+func (p *SourcePath) appendSourceCodeInfo(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendRepeatedField(b, "location", (*SourcePath).appendSourceCodeInfo_Location)
+	}
+	return b
+}
+
+func (p *SourcePath) appendDescriptorProto_ExtensionRange(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "start", nil)
+	case 2:
+		b = p.appendSingularField(b, "end", nil)
+	case 3:
+		b = p.appendSingularField(b, "options", (*SourcePath).appendExtensionRangeOptions)
+	}
+	return b
+}
+
+func (p *SourcePath) appendOneofDescriptorProto(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "name", nil)
+	case 2:
+		b = p.appendSingularField(b, "options", (*SourcePath).appendOneofOptions)
+	}
+	return b
+}
+
+func (p *SourcePath) appendMessageOptions(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "message_set_wire_format", nil)
+	case 2:
+		b = p.appendSingularField(b, "no_standard_descriptor_accessor", nil)
+	case 3:
+		b = p.appendSingularField(b, "deprecated", nil)
+	case 7:
+		b = p.appendSingularField(b, "map_entry", nil)
+	case 999:
+		b = p.appendRepeatedField(b, "uninterpreted_option", (*SourcePath).appendUninterpretedOption)
+	}
+	return b
+}
+
+func (p *SourcePath) appendDescriptorProto_ReservedRange(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "start", nil)
+	case 2:
+		b = p.appendSingularField(b, "end", nil)
+	}
+	return b
+}
+
+func (p *SourcePath) appendEnumValueDescriptorProto(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "name", nil)
+	case 2:
+		b = p.appendSingularField(b, "number", nil)
+	case 3:
+		b = p.appendSingularField(b, "options", (*SourcePath).appendEnumValueOptions)
+	}
+	return b
+}
+
+func (p *SourcePath) appendEnumOptions(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 2:
+		b = p.appendSingularField(b, "allow_alias", nil)
+	case 3:
+		b = p.appendSingularField(b, "deprecated", nil)
+	case 999:
+		b = p.appendRepeatedField(b, "uninterpreted_option", (*SourcePath).appendUninterpretedOption)
+	}
+	return b
+}
+
+func (p *SourcePath) appendEnumDescriptorProto_EnumReservedRange(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "start", nil)
+	case 2:
+		b = p.appendSingularField(b, "end", nil)
+	}
+	return b
+}
+
+func (p *SourcePath) appendMethodDescriptorProto(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "name", nil)
+	case 2:
+		b = p.appendSingularField(b, "input_type", nil)
+	case 3:
+		b = p.appendSingularField(b, "output_type", nil)
+	case 4:
+		b = p.appendSingularField(b, "options", (*SourcePath).appendMethodOptions)
+	case 5:
+		b = p.appendSingularField(b, "client_streaming", nil)
+	case 6:
+		b = p.appendSingularField(b, "server_streaming", nil)
+	}
+	return b
+}
+
+func (p *SourcePath) appendServiceOptions(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 33:
+		b = p.appendSingularField(b, "deprecated", nil)
+	case 999:
+		b = p.appendRepeatedField(b, "uninterpreted_option", (*SourcePath).appendUninterpretedOption)
+	}
+	return b
+}
+
+func (p *SourcePath) appendFieldOptions(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "ctype", nil)
+	case 2:
+		b = p.appendSingularField(b, "packed", nil)
+	case 6:
+		b = p.appendSingularField(b, "jstype", nil)
+	case 5:
+		b = p.appendSingularField(b, "lazy", nil)
+	case 3:
+		b = p.appendSingularField(b, "deprecated", nil)
+	case 10:
+		b = p.appendSingularField(b, "weak", nil)
+	case 999:
+		b = p.appendRepeatedField(b, "uninterpreted_option", (*SourcePath).appendUninterpretedOption)
+	}
+	return b
+}
+
+func (p *SourcePath) appendUninterpretedOption(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 2:
+		b = p.appendRepeatedField(b, "name", (*SourcePath).appendUninterpretedOption_NamePart)
+	case 3:
+		b = p.appendSingularField(b, "identifier_value", nil)
+	case 4:
+		b = p.appendSingularField(b, "positive_int_value", nil)
+	case 5:
+		b = p.appendSingularField(b, "negative_int_value", nil)
+	case 6:
+		b = p.appendSingularField(b, "double_value", nil)
+	case 7:
+		b = p.appendSingularField(b, "string_value", nil)
+	case 8:
+		b = p.appendSingularField(b, "aggregate_value", nil)
+	}
+	return b
+}
+
+func (p *SourcePath) appendSourceCodeInfo_Location(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendRepeatedField(b, "path", nil)
+	case 2:
+		b = p.appendRepeatedField(b, "span", nil)
+	case 3:
+		b = p.appendSingularField(b, "leading_comments", nil)
+	case 4:
+		b = p.appendSingularField(b, "trailing_comments", nil)
+	case 6:
+		b = p.appendRepeatedField(b, "leading_detached_comments", nil)
+	}
+	return b
+}
+
+func (p *SourcePath) appendExtensionRangeOptions(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 999:
+		b = p.appendRepeatedField(b, "uninterpreted_option", (*SourcePath).appendUninterpretedOption)
+	}
+	return b
+}
+
+func (p *SourcePath) appendOneofOptions(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 999:
+		b = p.appendRepeatedField(b, "uninterpreted_option", (*SourcePath).appendUninterpretedOption)
+	}
+	return b
+}
+
+func (p *SourcePath) appendEnumValueOptions(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "deprecated", nil)
+	case 999:
+		b = p.appendRepeatedField(b, "uninterpreted_option", (*SourcePath).appendUninterpretedOption)
+	}
+	return b
+}
+
+func (p *SourcePath) appendMethodOptions(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 33:
+		b = p.appendSingularField(b, "deprecated", nil)
+	case 34:
+		b = p.appendSingularField(b, "idempotency_level", nil)
+	case 999:
+		b = p.appendRepeatedField(b, "uninterpreted_option", (*SourcePath).appendUninterpretedOption)
+	}
+	return b
+}
+
+func (p *SourcePath) appendUninterpretedOption_NamePart(b []byte) []byte {
+	if len(*p) == 0 {
+		return b
+	}
+	switch (*p)[0] {
+	case 1:
+		b = p.appendSingularField(b, "name_part", nil)
+	case 2:
+		b = p.appendSingularField(b, "is_extension", nil)
+	}
+	return b
+}
diff --git a/vendor/google.golang.org/protobuf/reflect/protoreflect/type.go b/vendor/google.golang.org/protobuf/reflect/protoreflect/type.go
index 5be14a725..8e53c44a9 100644
--- a/vendor/google.golang.org/protobuf/reflect/protoreflect/type.go
+++ b/vendor/google.golang.org/protobuf/reflect/protoreflect/type.go
@@ -232,11 +232,15 @@ type MessageDescriptor interface {
 type isMessageDescriptor interface{ ProtoType(MessageDescriptor) }
 
 // MessageType encapsulates a MessageDescriptor with a concrete Go implementation.
+// It is recommended that implementations of this interface also implement the
+// MessageFieldTypes interface.
 type MessageType interface {
 	// New returns a newly allocated empty message.
+	// It may return nil for synthetic messages representing a map entry.
 	New() Message
 
 	// Zero returns an empty, read-only message.
+	// It may return nil for synthetic messages representing a map entry.
 	Zero() Message
 
 	// Descriptor returns the message descriptor.
@@ -245,6 +249,26 @@ type MessageType interface {
 	Descriptor() MessageDescriptor
 }
 
+// MessageFieldTypes extends a MessageType by providing type information
+// regarding enums and messages referenced by the message fields.
+type MessageFieldTypes interface {
+	MessageType
+
+	// Enum returns the EnumType for the ith field in Descriptor.Fields.
+	// It returns nil if the ith field is not an enum kind.
+	// It panics if out of bounds.
+	//
+	// Invariant: mt.Enum(i).Descriptor() == mt.Descriptor().Fields(i).Enum()
+	Enum(i int) EnumType
+
+	// Message returns the MessageType for the ith field in Descriptor.Fields.
+	// It returns nil if the ith field is not a message or group kind.
+	// It panics if out of bounds.
+	//
+	// Invariant: mt.Message(i).Descriptor() == mt.Descriptor().Fields(i).Message()
+	Message(i int) MessageType
+}
+
 // MessageDescriptors is a list of message declarations.
 type MessageDescriptors interface {
 	// Len reports the number of messages.
@@ -279,8 +303,15 @@ type FieldDescriptor interface {
 
 	// JSONName reports the name used for JSON serialization.
 	// It is usually the camel-cased form of the field name.
+	// Extension fields are represented by the full name surrounded by brackets.
 	JSONName() string
 
+	// TextName reports the name used for text serialization.
+	// It is usually the name of the field, except that groups use the name
+	// of the inlined message, and extension fields are represented by the
+	// full name surrounded by brackets.
+	TextName() string
+
 	// HasPresence reports whether the field distinguishes between unpopulated
 	// and default values.
 	HasPresence() bool
@@ -371,6 +402,9 @@ type FieldDescriptors interface {
 	// ByJSONName returns the FieldDescriptor for a field with s as the JSON name.
 	// It returns nil if not found.
 	ByJSONName(s string) FieldDescriptor
+	// ByTextName returns the FieldDescriptor for a field with s as the text name.
+	// It returns nil if not found.
+	ByTextName(s string) FieldDescriptor
 	// ByNumber returns the FieldDescriptor for a field numbered n.
 	// It returns nil if not found.
 	ByNumber(n FieldNumber) FieldDescriptor
diff --git a/vendor/google.golang.org/protobuf/reflect/protoregistry/registry.go b/vendor/google.golang.org/protobuf/reflect/protoregistry/registry.go
index 5e5f96716..be261053c 100644
--- a/vendor/google.golang.org/protobuf/reflect/protoregistry/registry.go
+++ b/vendor/google.golang.org/protobuf/reflect/protoregistry/registry.go
@@ -21,7 +21,9 @@ import (
 	"strings"
 	"sync"
 
+	"google.golang.org/protobuf/internal/encoding/messageset"
 	"google.golang.org/protobuf/internal/errors"
+	"google.golang.org/protobuf/internal/flags"
 	"google.golang.org/protobuf/reflect/protoreflect"
 )
 
@@ -560,13 +562,25 @@ func (r *Types) FindEnumByName(enum protoreflect.FullName) (protoreflect.EnumTyp
 	return nil, NotFound
 }
 
-// FindMessageByName looks up a message by its full name.
-// E.g., "google.protobuf.Any"
+// FindMessageByName looks up a message by its full name,
+// e.g. "google.protobuf.Any".
 //
-// This return (nil, NotFound) if not found.
+// This returns (nil, NotFound) if not found.
 func (r *Types) FindMessageByName(message protoreflect.FullName) (protoreflect.MessageType, error) {
-	// The full name by itself is a valid URL.
-	return r.FindMessageByURL(string(message))
+	if r == nil {
+		return nil, NotFound
+	}
+	if r == GlobalTypes {
+		globalMutex.RLock()
+		defer globalMutex.RUnlock()
+	}
+	if v := r.typesByName[message]; v != nil {
+		if mt, _ := v.(protoreflect.MessageType); mt != nil {
+			return mt, nil
+		}
+		return nil, errors.New("found wrong type: got %v, want message", typeName(v))
+	}
+	return nil, NotFound
 }
 
 // FindMessageByURL looks up a message by a URL identifier.
@@ -574,6 +588,8 @@ func (r *Types) FindMessageByName(message protoreflect.FullName) (protoreflect.M
 //
 // This returns (nil, NotFound) if not found.
 func (r *Types) FindMessageByURL(url string) (protoreflect.MessageType, error) {
+	// This function is similar to FindMessageByName but
+	// truncates anything before and including '/' in the URL.
 	if r == nil {
 		return nil, NotFound
 	}
@@ -613,6 +629,26 @@ func (r *Types) FindExtensionByName(field protoreflect.FullName) (protoreflect.E
 		if xt, _ := v.(protoreflect.ExtensionType); xt != nil {
 			return xt, nil
 		}
+
+		// MessageSet extensions are special in that the name of the extension
+		// is the name of the message type used to extend the MessageSet.
+		// This naming scheme is used by text and JSON serialization.
+		//
+		// This feature is protected by the ProtoLegacy flag since MessageSets
+		// are a proto1 feature that is long deprecated.
+		if flags.ProtoLegacy {
+			if _, ok := v.(protoreflect.MessageType); ok {
+				field := field.Append(messageset.ExtensionName)
+				if v := r.typesByName[field]; v != nil {
+					if xt, _ := v.(protoreflect.ExtensionType); xt != nil {
+						if messageset.IsMessageSetExtension(xt.TypeDescriptor()) {
+							return xt, nil
+						}
+					}
+				}
+			}
+		}
+
 		return nil, errors.New("found wrong type: got %v, want extension", typeName(v))
 	}
 	return nil, NotFound
diff --git a/vendor/google.golang.org/protobuf/types/dynamicpb/dynamic.go b/vendor/google.golang.org/protobuf/types/dynamicpb/dynamic.go
index 7db6e5598..900b9d287 100644
--- a/vendor/google.golang.org/protobuf/types/dynamicpb/dynamic.go
+++ b/vendor/google.golang.org/protobuf/types/dynamicpb/dynamic.go
@@ -369,6 +369,18 @@ func NewMessageType(desc pref.MessageDescriptor) pref.MessageType {
 func (mt messageType) New() pref.Message                  { return NewMessage(mt.desc) }
 func (mt messageType) Zero() pref.Message                 { return &Message{typ: messageType{mt.desc}} }
 func (mt messageType) Descriptor() pref.MessageDescriptor { return mt.desc }
+func (mt messageType) Enum(i int) pref.EnumType {
+	if ed := mt.desc.Fields().Get(i).Enum(); ed != nil {
+		return NewEnumType(ed)
+	}
+	return nil
+}
+func (mt messageType) Message(i int) pref.MessageType {
+	if md := mt.desc.Fields().Get(i).Message(); md != nil {
+		return NewMessageType(md)
+	}
+	return nil
+}
 
 type emptyList struct {
 	desc pref.FieldDescriptor
diff --git a/vendor/google.golang.org/protobuf/types/known/fieldmaskpb/field_mask.pb.go b/vendor/google.golang.org/protobuf/types/known/fieldmaskpb/field_mask.pb.go
index 6a8d872c0..a852befef 100644
--- a/vendor/google.golang.org/protobuf/types/known/fieldmaskpb/field_mask.pb.go
+++ b/vendor/google.golang.org/protobuf/types/known/fieldmaskpb/field_mask.pb.go
@@ -393,9 +393,12 @@ func numValidPaths(m proto.Message, paths []string) int {
 
 			// Identify the next message to search within.
 			md = fd.Message() // may be nil
-			if fd.IsMap() {
-				md = fd.MapValue().Message() // may be nil
+
+			// Repeated fields are only allowed at the last postion.
+			if fd.IsList() || fd.IsMap() {
+				md = nil
 			}
+
 			return true
 		}) {
 			return i
diff --git a/vendor/modules.txt b/vendor/modules.txt
index 38c09743b..35f450757 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -115,12 +115,13 @@ github.com/inconshreveable/mousetrap
 github.com/influxdata/influxdb1-client/models
 github.com/influxdata/influxdb1-client/pkg/escape
 github.com/influxdata/influxdb1-client/v2
-# github.com/jhump/protoreflect v1.7.0
+# github.com/jhump/protoreflect v1.8.2
 ## explicit
 github.com/jhump/protoreflect/codec
 github.com/jhump/protoreflect/desc
 github.com/jhump/protoreflect/desc/internal
 github.com/jhump/protoreflect/desc/protoparse
+github.com/jhump/protoreflect/desc/protoparse/ast
 github.com/jhump/protoreflect/dynamic
 github.com/jhump/protoreflect/internal
 github.com/jhump/protoreflect/internal/codec
@@ -345,7 +346,7 @@ google.golang.org/grpc/stats
 google.golang.org/grpc/status
 google.golang.org/grpc/tap
 google.golang.org/grpc/test/grpc_testing
-# google.golang.org/protobuf v1.25.0
+# google.golang.org/protobuf v1.25.1-0.20200805231151-a709e31e5d12
 ## explicit
 google.golang.org/protobuf/encoding/protojson
 google.golang.org/protobuf/encoding/prototext
@@ -359,13 +360,12 @@ google.golang.org/protobuf/internal/encoding/messageset
 google.golang.org/protobuf/internal/encoding/tag
 google.golang.org/protobuf/internal/encoding/text
 google.golang.org/protobuf/internal/errors
-google.golang.org/protobuf/internal/fieldsort
 google.golang.org/protobuf/internal/filedesc
 google.golang.org/protobuf/internal/filetype
 google.golang.org/protobuf/internal/flags
 google.golang.org/protobuf/internal/genid
 google.golang.org/protobuf/internal/impl
-google.golang.org/protobuf/internal/mapsort
+google.golang.org/protobuf/internal/order
 google.golang.org/protobuf/internal/pragma
 google.golang.org/protobuf/internal/set
 google.golang.org/protobuf/internal/strs
