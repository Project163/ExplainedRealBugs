diff --git a/lib/executor/constant_arrival_rate.go b/lib/executor/constant_arrival_rate.go
index 73337e0e6..c97cdfcf9 100644
--- a/lib/executor/constant_arrival_rate.go
+++ b/lib/executor/constant_arrival_rate.go
@@ -230,7 +230,12 @@ func (car ConstantArrivalRate) Run(parentCtx context.Context, out chan<- metrics
 	activeVUsWg := &sync.WaitGroup{}
 
 	returnedVUs := make(chan struct{})
+	waitOnProgressChannel := make(chan struct{})
 	startTime, maxDurationCtx, regDurationCtx, cancel := getDurationContexts(parentCtx, duration, gracefulStop)
+	defer func() {
+		cancel()
+		<-waitOnProgressChannel
+	}()
 
 	vusPool := newActiveVUPool()
 	defer func() {
@@ -266,8 +271,6 @@ func (car ConstantArrivalRate) Run(parentCtx context.Context, out chan<- metrics
 		return math.Min(1, float64(spent)/float64(duration)), right
 	}
 	car.progress.Modify(pb.WithProgress(progressFn))
-	go trackProgress(parentCtx, maxDurationCtx, regDurationCtx, &car, progressFn)
-
 	maxDurationCtx = lib.WithScenarioState(maxDurationCtx, &lib.ScenarioState{
 		Name:       car.config.Name,
 		Executor:   car.config.Type,
@@ -275,6 +278,11 @@ func (car ConstantArrivalRate) Run(parentCtx context.Context, out chan<- metrics
 		ProgressFn: progressFn,
 	})
 
+	go func() {
+		trackProgress(parentCtx, maxDurationCtx, regDurationCtx, &car, progressFn)
+		close(waitOnProgressChannel)
+	}()
+
 	returnVU := func(u lib.InitializedVU) {
 		car.executionState.ReturnVU(u, true)
 		activeVUsWg.Done()
diff --git a/lib/executor/constant_vus.go b/lib/executor/constant_vus.go
index 84a40c9aa..1a3e5636f 100644
--- a/lib/executor/constant_vus.go
+++ b/lib/executor/constant_vus.go
@@ -147,8 +147,12 @@ func (clv ConstantVUs) Run(parentCtx context.Context, out chan<- metrics.SampleC
 	duration := clv.config.Duration.TimeDuration()
 	gracefulStop := clv.config.GetGracefulStop()
 
+	waitOnProgressChannel := make(chan struct{})
 	startTime, maxDurationCtx, regDurationCtx, cancel := getDurationContexts(parentCtx, duration, gracefulStop)
-	defer cancel()
+	defer func() {
+		cancel()
+		<-waitOnProgressChannel
+	}()
 
 	// Make sure the log and the progress bar have accurate information
 	clv.logger.WithFields(
@@ -167,7 +171,17 @@ func (clv ConstantVUs) Run(parentCtx context.Context, out chan<- metrics.SampleC
 		return float64(spent) / float64(duration), right
 	}
 	clv.progress.Modify(pb.WithProgress(progressFn))
-	go trackProgress(parentCtx, maxDurationCtx, regDurationCtx, clv, progressFn)
+	maxDurationCtx = lib.WithScenarioState(maxDurationCtx, &lib.ScenarioState{
+		Name:       clv.config.Name,
+		Executor:   clv.config.Type,
+		StartTime:  startTime,
+		ProgressFn: progressFn,
+	})
+
+	go func() {
+		trackProgress(parentCtx, maxDurationCtx, regDurationCtx, clv, progressFn)
+		close(waitOnProgressChannel)
+	}()
 
 	// Actually schedule the VUs and iterations...
 	activeVUs := &sync.WaitGroup{}
@@ -176,13 +190,6 @@ func (clv ConstantVUs) Run(parentCtx context.Context, out chan<- metrics.SampleC
 	regDurationDone := regDurationCtx.Done()
 	runIteration := getIterationRunner(clv.executionState, clv.logger)
 
-	maxDurationCtx = lib.WithScenarioState(maxDurationCtx, &lib.ScenarioState{
-		Name:       clv.config.Name,
-		Executor:   clv.config.Type,
-		StartTime:  startTime,
-		ProgressFn: progressFn,
-	})
-
 	returnVU := func(u lib.InitializedVU) {
 		clv.executionState.ReturnVU(u, true)
 		activeVUs.Done()
diff --git a/lib/executor/externally_controlled.go b/lib/executor/externally_controlled.go
index 1e9ed0e58..8b531ccdf 100644
--- a/lib/executor/externally_controlled.go
+++ b/lib/executor/externally_controlled.go
@@ -509,7 +509,11 @@ func (mex *ExternallyControlled) Run(parentCtx context.Context, out chan<- metri
 	mex.configLock.RUnlock()
 
 	ctx, cancel := context.WithCancel(parentCtx)
-	defer cancel()
+	waitOnProgressChannel := make(chan struct{})
+	defer func() {
+		cancel()
+		<-waitOnProgressChannel
+	}()
 
 	duration := currentControlConfig.Duration.TimeDuration()
 	if duration > 0 { // Only keep track of duration if it's not infinite
@@ -548,7 +552,10 @@ func (mex *ExternallyControlled) Run(parentCtx context.Context, out chan<- metri
 	}
 
 	mex.progress.Modify(pb.WithProgress(runState.progressFn)) // Keep track of the progress
-	go trackProgress(parentCtx, ctx, ctx, mex, runState.progressFn)
+	go func() {
+		trackProgress(parentCtx, ctx, ctx, mex, runState.progressFn)
+		close(waitOnProgressChannel)
+	}()
 
 	err = runState.handleConfigChange( // Start by setting MaxVUs to the starting MaxVUs
 		ExternallyControlledConfigParams{MaxVUs: mex.config.MaxVUs}, currentControlConfig,
diff --git a/lib/executor/per_vu_iterations.go b/lib/executor/per_vu_iterations.go
index fd38a22a8..870958c83 100644
--- a/lib/executor/per_vu_iterations.go
+++ b/lib/executor/per_vu_iterations.go
@@ -157,8 +157,12 @@ func (pvi PerVUIterations) Run(parentCtx context.Context, out chan<- metrics.Sam
 	duration := pvi.config.MaxDuration.TimeDuration()
 	gracefulStop := pvi.config.GetGracefulStop()
 
+	waitOnProgressChannel := make(chan struct{})
 	startTime, maxDurationCtx, regDurationCtx, cancel := getDurationContexts(parentCtx, duration, gracefulStop)
-	defer cancel()
+	defer func() {
+		cancel()
+		<-waitOnProgressChannel
+	}()
 
 	// Make sure the log and the progress bar have accurate information
 	pvi.logger.WithFields(logrus.Fields{
@@ -188,7 +192,17 @@ func (pvi PerVUIterations) Run(parentCtx context.Context, out chan<- metrics.Sam
 		return float64(currentDoneIters) / float64(totalIters), right
 	}
 	pvi.progress.Modify(pb.WithProgress(progressFn))
-	go trackProgress(parentCtx, maxDurationCtx, regDurationCtx, pvi, progressFn)
+
+	maxDurationCtx = lib.WithScenarioState(maxDurationCtx, &lib.ScenarioState{
+		Name:       pvi.config.Name,
+		Executor:   pvi.config.Type,
+		StartTime:  startTime,
+		ProgressFn: progressFn,
+	})
+	go func() {
+		trackProgress(parentCtx, maxDurationCtx, regDurationCtx, pvi, progressFn)
+		close(waitOnProgressChannel)
+	}()
 
 	handleVUsWG := &sync.WaitGroup{}
 	defer handleVUsWG.Wait()
@@ -199,13 +213,6 @@ func (pvi PerVUIterations) Run(parentCtx context.Context, out chan<- metrics.Sam
 	regDurationDone := regDurationCtx.Done()
 	runIteration := getIterationRunner(pvi.executionState, pvi.logger)
 
-	maxDurationCtx = lib.WithScenarioState(maxDurationCtx, &lib.ScenarioState{
-		Name:       pvi.config.Name,
-		Executor:   pvi.config.Type,
-		StartTime:  startTime,
-		ProgressFn: progressFn,
-	})
-
 	returnVU := func(u lib.InitializedVU) {
 		pvi.executionState.ReturnVU(u, true)
 		activeVUs.Done()
diff --git a/lib/executor/ramping_arrival_rate.go b/lib/executor/ramping_arrival_rate.go
index 1ab1f585e..e8fcec476 100644
--- a/lib/executor/ramping_arrival_rate.go
+++ b/lib/executor/ramping_arrival_rate.go
@@ -342,6 +342,7 @@ func (varr RampingArrivalRate) Run(parentCtx context.Context, out chan<- metrics
 	activeVUsWg := &sync.WaitGroup{}
 
 	returnedVUs := make(chan struct{})
+	waitOnProgressChannel := make(chan struct{})
 	startTime, maxDurationCtx, regDurationCtx, cancel := getDurationContexts(parentCtx, duration, gracefulStop)
 
 	vusPool := newActiveVUPool()
@@ -354,6 +355,7 @@ func (varr RampingArrivalRate) Run(parentCtx context.Context, out chan<- metrics
 		vusPool.Close()
 		cancel()
 		activeVUsWg.Wait()
+		<-waitOnProgressChannel
 	}()
 
 	activeVUsCount := uint64(0)
@@ -388,14 +390,16 @@ func (varr RampingArrivalRate) Run(parentCtx context.Context, out chan<- metrics
 	}
 
 	varr.progress.Modify(pb.WithProgress(progressFn))
-	go trackProgress(parentCtx, maxDurationCtx, regDurationCtx, &varr, progressFn)
-
 	maxDurationCtx = lib.WithScenarioState(maxDurationCtx, &lib.ScenarioState{
 		Name:       varr.config.Name,
 		Executor:   varr.config.Type,
 		StartTime:  startTime,
 		ProgressFn: progressFn,
 	})
+	go func() {
+		trackProgress(parentCtx, maxDurationCtx, regDurationCtx, &varr, progressFn)
+		close(waitOnProgressChannel)
+	}()
 
 	returnVU := func(u lib.InitializedVU) {
 		varr.executionState.ReturnVU(u, true)
diff --git a/lib/executor/ramping_vus.go b/lib/executor/ramping_vus.go
index 2c235a269..4e1bb0cd7 100644
--- a/lib/executor/ramping_vus.go
+++ b/lib/executor/ramping_vus.go
@@ -515,10 +515,14 @@ func (vlv *RampingVUs) Run(ctx context.Context, _ chan<- metrics.SampleContainer
 	if !isFinal {
 		return fmt.Errorf("%s expected graceful end offset at %s to be final", vlv.config.GetName(), maxDuration)
 	}
+	waitOnProgressChannel := make(chan struct{})
 	startTime, maxDurationCtx, regularDurationCtx, cancel := getDurationContexts(
 		ctx, regularDuration, maxDuration-regularDuration,
 	)
-	defer cancel()
+	defer func() {
+		cancel()
+		<-waitOnProgressChannel
+	}()
 
 	maxVUs := lib.GetMaxPlannedVUs(vlv.gracefulSteps)
 
@@ -547,8 +551,10 @@ func (vlv *RampingVUs) Run(ctx context.Context, _ chan<- metrics.SampleContainer
 		ProgressFn: progressFn,
 	})
 	vlv.progress.Modify(pb.WithProgress(progressFn))
-	go trackProgress(ctx, maxDurationCtx, regularDurationCtx, vlv, progressFn)
-
+	go func() {
+		trackProgress(ctx, maxDurationCtx, regularDurationCtx, vlv, progressFn)
+		close(waitOnProgressChannel)
+	}()
 	defer runState.wg.Wait()
 	// this will populate stopped VUs and run runLoopsIfPossible on each VU
 	// handle in a new goroutine
diff --git a/lib/executor/shared_iterations.go b/lib/executor/shared_iterations.go
index 31e17e598..3e7e08e4f 100644
--- a/lib/executor/shared_iterations.go
+++ b/lib/executor/shared_iterations.go
@@ -189,8 +189,12 @@ func (si SharedIterations) Run(parentCtx context.Context, out chan<- metrics.Sam
 	duration := si.config.MaxDuration.TimeDuration()
 	gracefulStop := si.config.GetGracefulStop()
 
+	waitOnProgressChannel := make(chan struct{})
 	startTime, maxDurationCtx, regDurationCtx, cancel := getDurationContexts(parentCtx, duration, gracefulStop)
-	defer cancel()
+	defer func() {
+		cancel()
+		<-waitOnProgressChannel
+	}()
 
 	// Make sure the log and the progress bar have accurate information
 	si.logger.WithFields(logrus.Fields{
@@ -214,7 +218,16 @@ func (si SharedIterations) Run(parentCtx context.Context, out chan<- metrics.Sam
 		return float64(currentDoneIters) / float64(totalIters), right
 	}
 	si.progress.Modify(pb.WithProgress(progressFn))
-	go trackProgress(parentCtx, maxDurationCtx, regDurationCtx, &si, progressFn)
+	maxDurationCtx = lib.WithScenarioState(maxDurationCtx, &lib.ScenarioState{
+		Name:       si.config.Name,
+		Executor:   si.config.Type,
+		StartTime:  startTime,
+		ProgressFn: progressFn,
+	})
+	go func() {
+		trackProgress(parentCtx, maxDurationCtx, regDurationCtx, &si, progressFn)
+		close(waitOnProgressChannel)
+	}()
 
 	var attemptedIters uint64
 
@@ -234,13 +247,6 @@ func (si SharedIterations) Run(parentCtx context.Context, out chan<- metrics.Sam
 	regDurationDone := regDurationCtx.Done()
 	runIteration := getIterationRunner(si.executionState, si.logger)
 
-	maxDurationCtx = lib.WithScenarioState(maxDurationCtx, &lib.ScenarioState{
-		Name:       si.config.Name,
-		Executor:   si.config.Type,
-		StartTime:  startTime,
-		ProgressFn: progressFn,
-	})
-
 	returnVU := func(u lib.InitializedVU) {
 		si.executionState.ReturnVU(u, true)
 		activeVUs.Done()
