diff --git a/core/engine_test.go b/core/engine_test.go
index 102404d36..a74d26b1c 100644
--- a/core/engine_test.go
+++ b/core/engine_test.go
@@ -298,8 +298,9 @@ func TestEngineRun(t *testing.T) {
 			samples = append(samples, stats.Sample{Metric: testMetric, Time: time.Now(), Value: 2})
 			return samples, err
 		}), lib.Options{
-			VUs:    null.IntFrom(1),
-			VUsMax: null.IntFrom(1),
+			VUs:        null.IntFrom(1),
+			VUsMax:     null.IntFrom(1),
+			Iterations: null.IntFrom(1),
 		})
 		if !assert.NoError(t, err) {
 			return
diff --git a/core/local/local.go b/core/local/local.go
index 0c4b61bcb..526e55c72 100644
--- a/core/local/local.go
+++ b/core/local/local.go
@@ -43,14 +43,17 @@ type vuHandle struct {
 	cancel context.CancelFunc
 }
 
-func (h *vuHandle) run(logger *log.Logger, flow <-chan struct{}, out chan<- []stats.Sample) {
+func (h *vuHandle) run(logger *log.Logger, flow <-chan int64, out chan<- []stats.Sample) {
 	h.RLock()
 	ctx := h.ctx
 	h.RUnlock()
 
 	for {
 		select {
-		case <-flow:
+		case _, ok := <-flow:
+			if !ok {
+				return
+			}
 		case <-ctx.Done():
 			return
 		}
@@ -104,7 +107,7 @@ type Executor struct {
 	out chan<- []stats.Sample
 
 	// Flow control for VUs; iterations are run only after reading from this channel.
-	flow chan struct{}
+	flow chan int64
 }
 
 func New(r lib.Runner) *Executor {
@@ -122,7 +125,7 @@ func (e *Executor) Run(parent context.Context, out chan<- []stats.Sample) error
 
 	ctx, cancel := context.WithCancel(parent)
 	vuOut := make(chan []stats.Sample)
-	vuFlow := make(chan struct{})
+	vuFlow := make(chan int64)
 
 	e.lock.Lock()
 	e.ctx = ctx
@@ -156,12 +159,16 @@ func (e *Executor) Run(parent context.Context, out chan<- []stats.Sample) error
 						samples = append(samples, s)
 					}
 				}
+			case <-wait:
+			}
+			select {
 			case <-wait:
 				close(vuOut)
 				if out != nil && len(samples) > 0 {
 					out <- samples
 				}
 				return
+			default:
 			}
 		}
 	}()
@@ -197,14 +204,14 @@ func (e *Executor) Run(parent context.Context, out chan<- []stats.Sample) error
 		// conditionally select on a channel either...so, we cheat: swap out the flow channel for a
 		// nil channel (writing to nil always blocks) if we don't wanna write an iteration.
 		flow := vuFlow
-		if end := atomic.LoadInt64(&e.endIters); end >= 0 {
-			if partials := atomic.LoadInt64(&e.partIters); partials >= end {
-				flow = nil
-			}
+		end := atomic.LoadInt64(&e.endIters)
+		partials := atomic.LoadInt64(&e.partIters)
+		if end >= 0 && partials >= end {
+			flow = nil
 		}
 
 		select {
-		case flow <- struct{}{}:
+		case flow <- partials:
 			// Start an iteration if there's a VU waiting. See also: the big comment block above.
 			atomic.AddInt64(&e.partIters, 1)
 		case t := <-ticker.C:
