diff --git a/js/modules/k6/ws/ws.go b/js/modules/k6/ws/ws.go
index 8bfe5d475..8ae4dc9b2 100644
--- a/js/modules/k6/ws/ws.go
+++ b/js/modules/k6/ws/ws.go
@@ -273,6 +273,21 @@ func (mi *WS) Connect(url string, args ...goja.Value) (*HTTPResponse, error) {
 		Time: start,
 	})
 
+	defer func() {
+		end := time.Now()
+		sessionDuration := metrics.D(end.Sub(start))
+
+		metrics.PushIfNotDone(ctx, state.Samples, metrics.Sample{
+			TimeSeries: metrics.TimeSeries{
+				Metric: socket.builtinMetrics.WSSessionDuration,
+				Tags:   socket.tagsAndMeta.Tags,
+			},
+			Time:     start,
+			Metadata: socket.tagsAndMeta.Metadata,
+			Value:    sessionDuration,
+		})
+	}()
+
 	if connErr != nil {
 		// Pass the error to the user script before exiting immediately
 		socket.handleEvent("error", rt.ToValue(connErr))
@@ -287,6 +302,8 @@ func (mi *WS) Connect(url string, args ...goja.Value) (*HTTPResponse, error) {
 		}, nil
 	}
 
+	defer socket.Close()
+
 	// Run the user-provided set up function
 	if _, err := setupFn(goja.Undefined(), rt.ToValue(&socket)); err != nil {
 		_ = socket.closeConnection(websocket.CloseGoingAway)
@@ -298,8 +315,6 @@ func (mi *WS) Connect(url string, args ...goja.Value) (*HTTPResponse, error) {
 	}
 	wsResponse.URL = url
 
-	defer func() { _ = conn.Close() }()
-
 	// The connection is now open, emit the event
 	socket.handleEvent("open")
 
@@ -323,23 +338,6 @@ func (mi *WS) Connect(url string, args ...goja.Value) (*HTTPResponse, error) {
 	// Wraps a couple of channels around conn.ReadMessage
 	go socket.readPump(readDataChan, readErrChan, readCloseChan)
 
-	// we do it here as below we can panic, which translates to an exception in js code
-	defer func() {
-		socket.Close() // just in case
-		end := time.Now()
-		sessionDuration := metrics.D(end.Sub(start))
-
-		metrics.PushIfNotDone(ctx, state.Samples, metrics.Sample{
-			TimeSeries: metrics.TimeSeries{
-				Metric: socket.builtinMetrics.WSSessionDuration,
-				Tags:   socket.tagsAndMeta.Tags,
-			},
-			Time:     start,
-			Metadata: socket.tagsAndMeta.Metadata,
-			Value:    sessionDuration,
-		})
-	}()
-
 	// This is the main control loop. All JS code (including error handlers)
 	// should only be executed by this thread to avoid race conditions
 	for {
diff --git a/js/modules/k6/ws/ws_test.go b/js/modules/k6/ws/ws_test.go
index e259790a5..2bb8cff0f 100644
--- a/js/modules/k6/ws/ws_test.go
+++ b/js/modules/k6/ws/ws_test.go
@@ -275,9 +275,7 @@ func TestSessionBadTimeout(t *testing.T) {
 		});
 		`))
 	require.ErrorContains(t, err, "setTimeout requires a >0 timeout parameter, received 0.00 ")
-	// TODO SessionDuration is not emitted if the "open" handler returns an error - which is what happens here
-	// see https://github.com/grafana/k6/issues/2734
-	// assertSessionMetricsEmitted(t, metrics.GetBufferedSamples(test.samples), "", sr("WSBIN_URL/ws-echo"), statusProtocolSwitch, "")
+	assertSessionMetricsEmitted(t, metrics.GetBufferedSamples(test.samples), "", sr("WSBIN_URL/ws-echo"), statusProtocolSwitch, "")
 }
 
 func TestSessionPing(t *testing.T) {
