diff --git a/api/browser.go b/api/browser.go
index c0b8cd0ea..fa71d2a19 100644
--- a/api/browser.go
+++ b/api/browser.go
@@ -29,6 +29,7 @@ type Browser interface {
 	IsConnected() bool
 	NewContext(opts goja.Value) BrowserContext
 	NewPage(opts goja.Value) Page
+	On(string) *goja.Promise
 	UserAgent() string
 	Version() string
 }
diff --git a/common/browser.go b/common/browser.go
index 0c2c942ce..c96be1e73 100644
--- a/common/browser.go
+++ b/common/browser.go
@@ -33,6 +33,7 @@ import (
 	"github.com/chromedp/cdproto/target"
 	"github.com/dop251/goja"
 	"github.com/gorilla/websocket"
+	k6modules "go.k6.io/k6/js/modules"
 
 	"github.com/grafana/xk6-browser/api"
 )
@@ -78,6 +79,8 @@ type Browser struct {
 	sessionIDtoTargetIDMu sync.RWMutex
 	sessionIDtoTargetID   map[target.SessionID]target.ID
 
+	vu k6modules.VU
+
 	logger *Logger
 }
 
@@ -102,6 +105,7 @@ func newBrowser(ctx context.Context, cancelFn context.CancelFunc, browserProc *B
 		contexts:            make(map[cdp.BrowserContextID]*BrowserContext),
 		pages:               make(map[target.ID]*Page),
 		sessionIDtoTargetID: make(map[target.SessionID]target.ID),
+		vu:                  GetVU(ctx),
 		logger:              logger,
 	}
 }
@@ -173,6 +177,7 @@ func (b *Browser) initEvents() error {
 					b.logger.Debugf("Browser:initEvents:EventConnectionClose", "")
 					b.browserProc.didLoseConnection()
 					b.cancelFn()
+					return
 				}
 			}
 		}
@@ -448,6 +453,35 @@ func (b *Browser) NewPage(opts goja.Value) api.Page {
 	return browserCtx.NewPage()
 }
 
+// On returns a Promise that is resolved when the browser process is disconnected.
+// The only accepted event value is "disconnected".
+func (b *Browser) On(event string) *goja.Promise {
+	if event != EventBrowserDisconnected {
+		k6Throw(b.ctx, "unknown browser event: %q, must be %q", event, EventBrowserDisconnected)
+	}
+
+	rt := b.vu.Runtime()
+	cb := b.vu.RegisterCallback()
+	p, resolve, reject := rt.NewPromise()
+
+	go func() {
+		select {
+		case <-b.browserProc.lostConnection:
+			cb(func() error {
+				resolve(true)
+				return nil
+			})
+		case <-b.ctx.Done():
+			cb(func() error {
+				reject(fmt.Errorf("browser.on promise rejected: %w", b.ctx.Err()))
+				return nil
+			})
+		}
+	}()
+
+	return p
+}
+
 // UserAgent returns the controlled browser's user agent string.
 func (b *Browser) UserAgent() string {
 	action := cdpbrowser.GetVersion()
diff --git a/examples/browser_on.js b/examples/browser_on.js
new file mode 100644
index 000000000..2b06bc98c
--- /dev/null
+++ b/examples/browser_on.js
@@ -0,0 +1,39 @@
+import launcher from 'k6/x/browser';
+import { check, sleep } from 'k6';
+
+export default function() {
+  const browser = launcher.launch('chromium', {
+    headless: __ENV.XK6_HEADLESS ? true : false,
+  });
+
+  check(browser, {
+    'should be connected after launch': browser.isConnected(),
+  });
+
+  const handlerCalled = Symbol();
+
+  let p = browser.on('disconnected')
+    // The promise resolve/success handler
+    .then((val) => {
+      check(browser, {
+        'should be disconnected on event': !browser.isConnected(),
+      });
+      return handlerCalled;
+    // The promise reject/failure handler
+    }, (val) => {
+      console.error(`promise rejected: ${val}`);
+    });
+
+  p.then((val) => {
+    check(val, {
+      'the browser.on success handler should be called': val === handlerCalled,
+    });
+  });
+
+  check(browser, {
+    'should be connected before ending iteration': browser.isConnected(),
+  });
+
+  // Disconnect from the browser instance.
+  browser.close();
+}
