diff --git a/js/runner.go b/js/runner.go
index a6e5702f3..a19e626de 100644
--- a/js/runner.go
+++ b/js/runner.go
@@ -113,6 +113,20 @@ func (r *Runner) newVU() (*VU, error) {
 		tlsVersion = *r.Bundle.Options.TLSVersion
 	}
 
+	tlsAuth := r.Bundle.Options.TLSAuth
+	certs := make([]tls.Certificate, len(tlsAuth))
+	nameToCert := make(map[string]*tls.Certificate)
+	for i, auth := range tlsAuth {
+		for _, name := range auth.Domains {
+			cert, err := auth.Certificate()
+			if err != nil {
+				return nil, err
+			}
+			certs[i] = *cert
+			nameToCert[name] = &certs[i]
+		}
+	}
+
 	dialer := &netext.Dialer{Dialer: r.BaseDialer, Resolver: r.Resolver}
 	transport := &http.Transport{
 		Proxy: http.ProxyFromEnvironment,
@@ -121,6 +135,8 @@ func (r *Runner) newVU() (*VU, error) {
 			CipherSuites:       cipherSuites,
 			MinVersion:         uint16(tlsVersion.Min),
 			MaxVersion:         uint16(tlsVersion.Max),
+			Certificates:       certs,
+			NameToCertificate:  nameToCert,
 		},
 		DialContext: dialer.DialContext,
 	}
diff --git a/js/runner_test.go b/js/runner_test.go
index cfdf537a2..07d4478ed 100644
--- a/js/runner_test.go
+++ b/js/runner_test.go
@@ -23,7 +23,11 @@ package js
 import (
 	"context"
 	"crypto/tls"
+	"crypto/x509"
 	"fmt"
+	"io/ioutil"
+	stdlog "log"
+	"net/http"
 	"testing"
 
 	"github.com/loadimpact/k6/js/common"
@@ -593,3 +597,146 @@ func TestVUIntegrationVUID(t *testing.T) {
 		})
 	}
 }
+
+func TestVUIntegrationClientCerts(t *testing.T) {
+	clientCAPool := x509.NewCertPool()
+	assert.True(t, clientCAPool.AppendCertsFromPEM(
+		[]byte("-----BEGIN CERTIFICATE-----\n"+
+			"MIIBYzCCAQqgAwIBAgIUMYw1pqZ1XhXdFG0S2ITXhfHBsWgwCgYIKoZIzj0EAwIw\n"+
+			"EDEOMAwGA1UEAxMFTXkgQ0EwHhcNMTcwODE1MTYxODAwWhcNMjIwODE0MTYxODAw\n"+
+			"WjAQMQ4wDAYDVQQDEwVNeSBDQTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFWO\n"+
+			"fg4dgL8cdvjoSWDQFLBJxlbQFlZfOSyUR277a4g91BD07KWX+9ny+Q8WuUODog06\n"+
+			"xH1g8fc6zuaejllfzM6jQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTAD\n"+
+			"AQH/MB0GA1UdDgQWBBTeoSFylGCmyqj1X4sWez1r6hkhjDAKBggqhkjOPQQDAgNH\n"+
+			"ADBEAiAfuKi6u/BVXenCkgnU2sfXsYjel6rACuXEcx01yaaWuQIgXAtjrDisdlf4\n"+
+			"0ZdoIoYjNhDAXUtnyRBt+V6+rIklv/8=\n"+
+			"-----END CERTIFICATE-----"),
+	))
+	serverCert, err := tls.X509KeyPair(
+		[]byte("-----BEGIN CERTIFICATE-----\n"+
+			"MIIBxjCCAW2gAwIBAgIUICcYHG1bI28NZm676wHlMPxL+CEwCgYIKoZIzj0EAwIw\n"+
+			"EDEOMAwGA1UEAxMFTXkgQ0EwHhcNMTcwODE3MTQwNjAwWhcNMTgwODE3MTQwNjAw\n"+
+			"WjAZMRcwFQYDVQQDEw4xMjcuMC4wLjE6Njk2OTBZMBMGByqGSM49AgEGCCqGSM49\n"+
+			"AwEHA0IABCdD1IqowucJ5oUjGYCZZnXvgi7EMD4jD1osbOkzOFFnHSLRvdm6fcJu\n"+
+			"vPUcl4g8zUs466sC0AVUNpk21XbA/QajgZswgZgwDgYDVR0PAQH/BAQDAgWgMB0G\n"+
+			"A1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAAMB0GA1Ud\n"+
+			"DgQWBBTeAc8HY3sgGIV+fu/lY0OKr2Ho0jAfBgNVHSMEGDAWgBTeoSFylGCmyqj1\n"+
+			"X4sWez1r6hkhjDAZBgNVHREEEjAQgg4xMjcuMC4wLjE6Njk2OTAKBggqhkjOPQQD\n"+
+			"AgNHADBEAiAt3gC5FGQfSJXQ5DloXAOeJDFnKIL7d6xhftgPS5O08QIgRuAyysB8\n"+
+			"5JXHvvze5DMN/clHYptos9idVFc+weUZAUQ=\n"+
+			"-----END CERTIFICATE-----\n"+
+			"-----BEGIN CERTIFICATE-----\n"+
+			"MIIBYzCCAQqgAwIBAgIUMYw1pqZ1XhXdFG0S2ITXhfHBsWgwCgYIKoZIzj0EAwIw\n"+
+			"EDEOMAwGA1UEAxMFTXkgQ0EwHhcNMTcwODE1MTYxODAwWhcNMjIwODE0MTYxODAw\n"+
+			"WjAQMQ4wDAYDVQQDEwVNeSBDQTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFWO\n"+
+			"fg4dgL8cdvjoSWDQFLBJxlbQFlZfOSyUR277a4g91BD07KWX+9ny+Q8WuUODog06\n"+
+			"xH1g8fc6zuaejllfzM6jQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTAD\n"+
+			"AQH/MB0GA1UdDgQWBBTeoSFylGCmyqj1X4sWez1r6hkhjDAKBggqhkjOPQQDAgNH\n"+
+			"ADBEAiAfuKi6u/BVXenCkgnU2sfXsYjel6rACuXEcx01yaaWuQIgXAtjrDisdlf4\n"+
+			"0ZdoIoYjNhDAXUtnyRBt+V6+rIklv/8=\n"+
+			"-----END CERTIFICATE-----"),
+		[]byte("-----BEGIN EC PRIVATE KEY-----\n"+
+			"MHcCAQEEIKYptA4VtQ8UOKL+d1wkhl+51aPpvO+ppY62nLF9Z1w5oAoGCCqGSM49\n"+
+			"AwEHoUQDQgAEJ0PUiqjC5wnmhSMZgJlmde+CLsQwPiMPWixs6TM4UWcdItG92bp9\n"+
+			"wm689RyXiDzNSzjrqwLQBVQ2mTbVdsD9Bg==\n"+
+			"-----END EC PRIVATE KEY-----"),
+	)
+	if !assert.NoError(t, err) {
+		return
+	}
+
+	listener, err := tls.Listen("tcp", "127.0.0.1:0", &tls.Config{
+		Certificates: []tls.Certificate{serverCert},
+		ClientAuth:   tls.RequireAndVerifyClientCert,
+		ClientCAs:    clientCAPool,
+	})
+	if !assert.NoError(t, err) {
+		return
+	}
+	defer func() { _ = listener.Close() }()
+	srv := &http.Server{
+		Handler: http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
+			_, _ = fmt.Fprintf(w, "ok")
+		}),
+		ErrorLog: stdlog.New(ioutil.Discard, "", 0),
+	}
+	go func() { _ = srv.Serve(listener) }()
+
+	r1, err := New(&lib.SourceData{
+		Filename: "/script.js",
+		Data: []byte(fmt.Sprintf(`
+			import http from "k6/http";
+			export default function() { http.get("https://%s")}
+		`, listener.Addr().String())),
+	}, afero.NewMemMapFs())
+	if !assert.NoError(t, err) {
+		return
+	}
+	r1.ApplyOptions(lib.Options{
+		Throw: null.BoolFrom(true),
+		InsecureSkipTLSVerify: null.BoolFrom(true),
+	})
+
+	t.Run("Unauthenticated", func(t *testing.T) {
+		r2, err := NewFromArchive(r1.MakeArchive())
+		if !assert.NoError(t, err) {
+			return
+		}
+
+		runners := map[string]*Runner{"Source": r1, "Archive": r2}
+		for name, r := range runners {
+			t.Run(name, func(t *testing.T) {
+				r.Logger, _ = logtest.NewNullLogger()
+				vu, err := r.NewVU()
+				if assert.NoError(t, err) {
+					_, err := vu.RunOnce(context.Background())
+					assert.EqualError(t, err, fmt.Sprintf("GoError: Get https://%s: remote error: tls: bad certificate", listener.Addr().String()))
+				}
+			})
+		}
+	})
+
+	r1.ApplyOptions(lib.Options{
+		TLSAuth: []*lib.TLSAuth{
+			{
+				TLSAuthFields: lib.TLSAuthFields{
+					Domains: []string{"127.0.0.1"},
+					Cert: "-----BEGIN CERTIFICATE-----\n" +
+						"MIIBoTCCAUigAwIBAgIUd6XedDxP+rGo+kq0APqHElGZzs4wCgYIKoZIzj0EAwIw\n" +
+						"EDEOMAwGA1UEAxMFTXkgQ0EwHhcNMTcwODE3MTUwNjAwWhcNMTgwODE3MTUwNjAw\n" +
+						"WjARMQ8wDQYDVQQDEwZjbGllbnQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATL\n" +
+						"mi/a1RVvk05FyrYmartbo/9cW+53DrQLW1twurII2q5ZfimdMX05A32uB3Ycoy/J\n" +
+						"x+w7Ifyd/YRw0zEc3NHQo38wfTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYI\n" +
+						"KwYBBQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFN2SR/TD\n" +
+						"yNW5DQWxZSkoXHQWsLY+MB8GA1UdIwQYMBaAFN6hIXKUYKbKqPVfixZ7PWvqGSGM\n" +
+						"MAoGCCqGSM49BAMCA0cAMEQCICtETmyOmupmg4w3tw59VYJyOBqRTxg6SK+rOQmq\n" +
+						"kE1VAiAUvsflDfmWBZ8EMPu46OhX6RX6MbvJ9NNvRco2G5ek1w==\n" +
+						"-----END CERTIFICATE-----",
+					Key: "-----BEGIN EC PRIVATE KEY-----\n" +
+						"MHcCAQEEIOrnhT05alCeQEX66HgnSHah/m5LazjJHLDawYRnhUtZoAoGCCqGSM49\n" +
+						"AwEHoUQDQgAEy5ov2tUVb5NORcq2Jmq7W6P/XFvudw60C1tbcLqyCNquWX4pnTF9\n" +
+						"OQN9rgd2HKMvycfsOyH8nf2EcNMxHNzR0A==\n" +
+						"-----END EC PRIVATE KEY-----",
+				},
+			},
+		},
+	})
+
+	t.Run("Authenticated", func(t *testing.T) {
+		r2, err := NewFromArchive(r1.MakeArchive())
+		if !assert.NoError(t, err) {
+			return
+		}
+
+		runners := map[string]*Runner{"Source": r1, "Archive": r2}
+		for name, r := range runners {
+			t.Run(name, func(t *testing.T) {
+				vu, err := r.NewVU()
+				if assert.NoError(t, err) {
+					_, err := vu.RunOnce(context.Background())
+					assert.NoError(t, err)
+				}
+			})
+		}
+	})
+}
diff --git a/lib/options.go b/lib/options.go
index e2451f1d5..cb56775d9 100644
--- a/lib/options.go
+++ b/lib/options.go
@@ -21,6 +21,7 @@
 package lib
 
 import (
+	"crypto/tls"
 	"encoding/json"
 	"errors"
 
@@ -100,6 +101,38 @@ func (s *TLSCipherSuites) UnmarshalJSON(data []byte) error {
 	return nil
 }
 
+type TLSAuthFields struct {
+	Cert    string   `json:"cert"`
+	Key     string   `json:"key"`
+	Domains []string `json:"domains"`
+}
+
+type TLSAuth struct {
+	TLSAuthFields
+	certificate *tls.Certificate
+}
+
+func (c *TLSAuth) UnmarshalJSON(data []byte) error {
+	if err := json.Unmarshal(data, &c.TLSAuthFields); err != nil {
+		return err
+	}
+	if _, err := c.Certificate(); err != nil {
+		return err
+	}
+	return nil
+}
+
+func (c *TLSAuth) Certificate() (*tls.Certificate, error) {
+	if c.certificate == nil {
+		cert, err := tls.X509KeyPair([]byte(c.Cert), []byte(c.Key))
+		if err != nil {
+			return nil, err
+		}
+		c.certificate = &cert
+	}
+	return c.certificate, nil
+}
+
 type Options struct {
 	Paused     null.Bool    `json:"paused"`
 	VUs        null.Int     `json:"vus"`
@@ -115,6 +148,7 @@ type Options struct {
 	InsecureSkipTLSVerify null.Bool        `json:"insecureSkipTLSVerify"`
 	TLSCipherSuites       *TLSCipherSuites `json:"tlsCipherSuites"`
 	TLSVersion            *TLSVersion      `json:"tlsVersion"`
+	TLSAuth               []*TLSAuth       `json:"tlsAuth"`
 	NoConnectionReuse     null.Bool        `json:"noConnectionReuse"`
 	UserAgent             null.String      `json:"userAgent"`
 	Throw                 null.Bool        `json:"throw"`
@@ -162,6 +196,9 @@ func (o Options) Apply(opts Options) Options {
 	if opts.TLSVersion != nil {
 		o.TLSVersion = opts.TLSVersion
 	}
+	if opts.TLSAuth != nil {
+		o.TLSAuth = opts.TLSAuth
+	}
 	if opts.NoConnectionReuse.Valid {
 		o.NoConnectionReuse = opts.NoConnectionReuse
 	}
diff --git a/lib/options_test.go b/lib/options_test.go
index 3118b13ac..6736f79b6 100644
--- a/lib/options_test.go
+++ b/lib/options_test.go
@@ -22,6 +22,7 @@ package lib
 
 import (
 	"crypto/tls"
+	"encoding/json"
 	"testing"
 	"time"
 
@@ -96,6 +97,66 @@ func TestOptionsApply(t *testing.T) {
 		assert.Equal(t, opts.TLSVersion.Min, tls.VersionSSL30)
 		assert.Equal(t, opts.TLSVersion.Max, tls.VersionTLS12)
 	})
+	t.Run("TLSAuth", func(t *testing.T) {
+		tlsAuth := []*TLSAuth{
+			{TLSAuthFields{
+				Domains: []string{"example.com", "*.example.com"},
+				Cert: "-----BEGIN CERTIFICATE-----\n" +
+					"MIIBoTCCAUegAwIBAgIUQl0J1Gkd6U2NIMwMDnpfH8c1myEwCgYIKoZIzj0EAwIw\n" +
+					"EDEOMAwGA1UEAxMFTXkgQ0EwHhcNMTcwODE1MTYxODAwWhcNMTgwODE1MTYxODAw\n" +
+					"WjAQMQ4wDAYDVQQDEwV1c2VyMTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABLaf\n" +
+					"xEOmBHkzbqd9/0VZX/39qO2yQq2Gz5faRdvy38kuLMCV+9HYrfMx6GYCZzTUIq6h\n" +
+					"8QXOrlgYTixuUVfhJNWjfzB9MA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggr\n" +
+					"BgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQUxmQiq5K3\n" +
+					"KUnVME945Byt3Ysvkh8wHwYDVR0jBBgwFoAU3qEhcpRgpsqo9V+LFns9a+oZIYww\n" +
+					"CgYIKoZIzj0EAwIDSAAwRQIgSGxnJ+/cLUNTzt7fhr/mjJn7ShsTW33dAdfLM7H2\n" +
+					"z/gCIQDyVf8DePtxlkMBScTxZmIlMQdNc6+6VGZQ4QscruVLmg==\n" +
+					"-----END CERTIFICATE-----",
+				Key: "-----BEGIN EC PRIVATE KEY-----\n" +
+					"MHcCAQEEIAfJeoc+XgcqmYV0b4owmofx0LXwPRqOPXMO+PUKxZSgoAoGCCqGSM49\n" +
+					"AwEHoUQDQgAEtp/EQ6YEeTNup33/RVlf/f2o7bJCrYbPl9pF2/LfyS4swJX70dit\n" +
+					"8zHoZgJnNNQirqHxBc6uWBhOLG5RV+Ek1Q==\n" +
+					"-----END EC PRIVATE KEY-----",
+			}, nil},
+			{TLSAuthFields{
+				Domains: []string{"sub.example.com"},
+				Cert: "-----BEGIN CERTIFICATE-----\n" +
+					"MIIBojCCAUegAwIBAgIUWMpVQhmGoLUDd2x6XQYoOOV6C9AwCgYIKoZIzj0EAwIw\n" +
+					"EDEOMAwGA1UEAxMFTXkgQ0EwHhcNMTcwODE1MTYxODAwWhcNMTgwODE1MTYxODAw\n" +
+					"WjAQMQ4wDAYDVQQDEwV1c2VyMTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABBfF\n" +
+					"85gu8fDbNGNlsrtnO+4HvuiP4IXA041jjGczD5kUQ8aihS7hg81tSrLNd1jgxkkv\n" +
+					"Po+3TQjzniysiunG3iKjfzB9MA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggr\n" +
+					"BgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQUU0JfPCQb\n" +
+					"2YpQZV4j1yiRXBa7J64wHwYDVR0jBBgwFoAU3qEhcpRgpsqo9V+LFns9a+oZIYww\n" +
+					"CgYIKoZIzj0EAwIDSQAwRgIhANYDaM18sXAdkjybHccH8xTbBWUNpOYvoHhrGW32\n" +
+					"Ov9JAiEA7QKGpm07tQl8p+t7UsOgZu132dHNZUtfgp1bjWfcapU=\n" +
+					"-----END CERTIFICATE-----",
+				Key: "-----BEGIN EC PRIVATE KEY-----\n" +
+					"MHcCAQEEINVilD5qOBkSy+AYfd41X0QPB5N3Z6OzgoBj8FZmSJOFoAoGCCqGSM49\n" +
+					"AwEHoUQDQgAEF8XzmC7x8Ns0Y2Wyu2c77ge+6I/ghcDTjWOMZzMPmRRDxqKFLuGD\n" +
+					"zW1Kss13WODGSS8+j7dNCPOeLKyK6cbeIg==\n" +
+					"-----END EC PRIVATE KEY-----",
+			}, nil},
+		}
+		opts := Options{}.Apply(Options{TLSAuth: tlsAuth})
+		assert.Equal(t, tlsAuth, opts.TLSAuth)
+
+		t.Run("Roundtrip", func(t *testing.T) {
+			optsData, err := json.Marshal(opts)
+			assert.NoError(t, err)
+
+			var opts2 Options
+			assert.NoError(t, json.Unmarshal(optsData, &opts2))
+			if assert.Len(t, opts2.TLSAuth, len(opts.TLSAuth)) {
+				for i := 0; i < len(opts2.TLSAuth); i++ {
+					assert.Equal(t, opts.TLSAuth[i].TLSAuthFields, opts2.TLSAuth[i].TLSAuthFields)
+					cert, err := opts2.TLSAuth[i].Certificate()
+					assert.NoError(t, err)
+					assert.NotNil(t, cert)
+				}
+			}
+		})
+	})
 	t.Run("NoConnectionReuse", func(t *testing.T) {
 		opts := Options{}.Apply(Options{NoConnectionReuse: null.BoolFrom(true)})
 		assert.True(t, opts.NoConnectionReuse.Valid)
