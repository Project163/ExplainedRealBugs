diff --git a/js/runner.go b/js/runner.go
index 9dc70ba1e..75d256dad 100644
--- a/js/runner.go
+++ b/js/runner.go
@@ -36,6 +36,7 @@ import (
 	log "github.com/sirupsen/logrus"
 	"github.com/spf13/afero"
 	"github.com/viki-org/dnscache"
+	"golang.org/x/net/http2"
 )
 
 type Runner struct {
@@ -111,23 +112,25 @@ func (r *Runner) newVU() (*VU, error) {
 		tlsVersion = *r.Bundle.Options.TLSVersion
 	}
 
-	// Make a VU, apply the VU context.
 	dialer := &netext.Dialer{Dialer: r.BaseDialer, Resolver: r.Resolver}
+	transport := &http.Transport{
+		Proxy: http.ProxyFromEnvironment,
+		TLSClientConfig: &tls.Config{
+			InsecureSkipVerify: r.Bundle.Options.InsecureSkipTLSVerify.Bool,
+			CipherSuites:       cipherSuites,
+			MinVersion:         uint16(tlsVersion.Min),
+			MaxVersion:         uint16(tlsVersion.Max),
+		},
+		DialContext: dialer.DialContext,
+	}
+	_ = http2.ConfigureTransport(transport)
+
 	vu := &VU{
 		BundleInstance: *bi,
 		Runner:         r,
-		HTTPTransport: &http.Transport{
-			Proxy: http.ProxyFromEnvironment,
-			TLSClientConfig: &tls.Config{
-				InsecureSkipVerify: r.Bundle.Options.InsecureSkipTLSVerify.Bool,
-				CipherSuites:       cipherSuites,
-				MinVersion:         uint16(tlsVersion.Min),
-				MaxVersion:         uint16(tlsVersion.Max),
-			},
-			DialContext: dialer.DialContext,
-		},
-		Dialer:  dialer,
-		Console: NewConsole(),
+		HTTPTransport:  transport,
+		Dialer:         dialer,
+		Console:        NewConsole(),
 	}
 	vu.Runtime.Set("console", common.Bind(vu.Runtime, vu.Console, vu.Context))
 
diff --git a/js/runner_test.go b/js/runner_test.go
index d17948a92..35446e22a 100644
--- a/js/runner_test.go
+++ b/js/runner_test.go
@@ -468,3 +468,47 @@ func TestVUIntegrationTLSConfig(t *testing.T) {
 		})
 	}
 }
+
+func TestVUIntegrationHTTP2(t *testing.T) {
+	r1, err := New(&lib.SourceData{
+		Filename: "/script.js",
+		Data: []byte(`
+			import http from "k6/http";
+			export default function() {
+				let res = http.request("GET", "https://http2.akamai.com/demo");
+				if (res.status != 200) { throw new Error("wrong status: " + res.status) }
+				if (res.proto != "HTTP/2.0") { throw new Error("wrong proto: " + res.proto) }
+			}
+		`),
+	}, afero.NewMemMapFs())
+	if !assert.NoError(t, err) {
+		return
+	}
+	r1.ApplyOptions(lib.Options{Throw: null.BoolFrom(true)})
+
+	r2, err := NewFromArchive(r1.MakeArchive())
+	if !assert.NoError(t, err) {
+		return
+	}
+
+	runners := map[string]*Runner{"Source": r1, "Archive": r2}
+	for name, r := range runners {
+		t.Run(name, func(t *testing.T) {
+			vu, err := r.NewVU()
+			if !assert.NoError(t, err) {
+				return
+			}
+			samples, err := vu.RunOnce(context.Background())
+			assert.NoError(t, err)
+
+			protoFound := false
+			for _, sample := range samples {
+				if proto := sample.Tags["proto"]; proto != "" {
+					protoFound = true
+					assert.Equal(t, "HTTP/2.0", proto)
+				}
+			}
+			assert.True(t, protoFound)
+		})
+	}
+}
