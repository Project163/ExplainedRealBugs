diff --git a/samples/base64.js b/samples/base64.js
index c65c0a0ae..56ffc7507 100644
--- a/samples/base64.js
+++ b/samples/base64.js
@@ -7,7 +7,7 @@ export default function() {
     let enc = "aGVsbG8gd29ybGQ=";
     check(null, {
         "is std encoding correct": () => encoding.b64encode(str) === enc,
-        "is std decoding correct": () => encoding.b64decode(enc) === str
+        "is std decoding correct": () => encoding.b64decode(enc, null, "s") === str
     });
 
     // Standard base64 encoding/decoding without '=' padding
@@ -15,7 +15,7 @@ export default function() {
     enc = "aGVsbG8gd29ybGQ";
     check(null, {
         "is rawstd encoding correct": () => encoding.b64encode(str, 'rawstd') === enc,
-        "is rawstd decoding correct": () => encoding.b64decode(enc, 'rawstd') === str
+        "is rawstd decoding correct": () => encoding.b64decode(enc, 'rawstd', "s") === str
     });
 
     // URL-safe base64 encoding/decoding with '=' padding
@@ -23,7 +23,7 @@ export default function() {
     enc = "5bCP6aO85by-Li4=";
     check(null, {
         "is url encoding correct": () => encoding.b64encode(str, 'url') === enc,
-        "is url decoding correct": () => encoding.b64decode(enc, 'url') === str
+        "is url decoding correct": () => encoding.b64decode(enc, 'url', "s") === str
     });
 
     // URL-safe base64 encoding/decoding without '=' padding
@@ -31,6 +31,6 @@ export default function() {
     enc = "5bCP6aO85by-Li4";
     check(null, {
         "is rawurl encoding correct": () => encoding.b64encode(str, 'rawurl') === enc,
-        "is rawurl decoding correct": () => encoding.b64decode(enc, 'rawurl') === str
+        "is rawurl decoding correct": () => encoding.b64decode(enc, 'rawurl', "s") === str
     });
 };
diff --git a/samples/jwt.js b/samples/jwt.js
index dfd6c18ba..62ee2b17c 100644
--- a/samples/jwt.js
+++ b/samples/jwt.js
@@ -20,15 +20,15 @@ function sign(data, hashAlg, secret) {
 function encode(payload, secret, algorithm) {
     algorithm = algorithm || "HS256";
     let header = encoding.b64encode(JSON.stringify({ typ: "JWT", alg: algorithm }), "rawurl");
-    payload = encoding.b64encode(JSON.stringify(payload), "rawurl");
+    payload = encoding.b64encode(JSON.stringify(payload), "rawurl", "s");
     let sig = sign(header + "." + payload, algToHash[algorithm], secret);
     return [header, payload, sig].join(".");
 }
 
 function decode(token, secret, algorithm) {
     let parts = token.split('.');
-    let header = JSON.parse(encoding.b64decode(parts[0], "rawurl"));
-    let payload = JSON.parse(encoding.b64decode(parts[1], "rawurl"));
+    let header = JSON.parse(encoding.b64decode(parts[0], "rawurl", "s"));
+    let payload = JSON.parse(encoding.b64decode(parts[1], "rawurl", "s"));
     algorithm = algorithm || algToHash[header.alg];
     if (sign(parts[0] + "." + parts[1], algorithm, secret) != parts[2]) {
         throw Error("JWT signature verification failed");
diff --git a/samples/tlsconfig.js b/samples/tlsconfig.js
index 275456369..7cbdc833b 100644
--- a/samples/tlsconfig.js
+++ b/samples/tlsconfig.js
@@ -7,7 +7,7 @@ export let options = {
         "TLS_RSA_WITH_AES_128_GCM_SHA256",
     ],
     tlsVersion: {
-        min: "ssl3.0",
+        min: "tls1.0",
         max: "tls1.2"
     }
 };
