diff --git a/js/common/init_error.go b/js/common/init_error.go
new file mode 100644
index 000000000..8cfd53b64
--- /dev/null
+++ b/js/common/init_error.go
@@ -0,0 +1,17 @@
+package common
+
+// InitContextError is an error that happened during the a test init context
+type InitContextError string
+
+// NewInitContextError returns a new InitContextError with the provided message
+func NewInitContextError(msg string) InitContextError {
+	return (InitContextError)(msg)
+}
+
+func (i InitContextError) Error() string {
+	return (string)(i)
+}
+
+func (i InitContextError) String() string {
+	return (string)(i)
+}
diff --git a/js/modules/k6/http/http.go b/js/modules/k6/http/http.go
index 06c80cc10..8ea1e8272 100644
--- a/js/modules/k6/http/http.go
+++ b/js/modules/k6/http/http.go
@@ -43,6 +43,9 @@ const (
 	HTTP_METHOD_OPTIONS = "OPTIONS"
 )
 
+// ErrJarForbiddenInInitContext is used when a cookie jar was made in the init context
+var ErrJarForbiddenInInitContext = common.NewInitContextError("Making cookie jars in the init context is not supported")
+
 type HTTPCookie struct {
 	Name, Value, Domain, Path string
 	HttpOnly, Secure          bool
@@ -104,9 +107,12 @@ func (*HTTP) XCookieJar(ctx *context.Context) *HTTPCookieJar {
 	return newCookieJar(ctx)
 }
 
-func (*HTTP) CookieJar(ctx context.Context) *HTTPCookieJar {
+func (*HTTP) CookieJar(ctx context.Context) (*HTTPCookieJar, error) {
 	state := common.GetState(ctx)
-	return &HTTPCookieJar{state.CookieJar, &ctx}
+	if state == nil {
+		return nil, ErrJarForbiddenInInitContext
+	}
+	return &HTTPCookieJar{state.CookieJar, &ctx}, nil
 }
 
 func (*HTTP) mergeCookies(req *http.Request, jar *cookiejar.Jar, reqCookies map[string]*HTTPRequestCookie) map[string][]*HTTPRequestCookie {
diff --git a/js/modules/k6/http/http_request.go b/js/modules/k6/http/http_request.go
index ab7039013..6b0e5e08f 100644
--- a/js/modules/k6/http/http_request.go
+++ b/js/modules/k6/http/http_request.go
@@ -50,6 +50,12 @@ import (
 	null "gopkg.in/guregu/null.v3"
 )
 
+// ErrHTTPForbiddenInInitContext is used when a http requests was made in the init context
+var ErrHTTPForbiddenInInitContext = common.NewInitContextError("Making http requests in the init context is not supported")
+
+// ErrBatchForbiddenInInitContext is used when batch was made in the init context
+var ErrBatchForbiddenInInitContext = common.NewInitContextError("Using batch in the init context is not supported")
+
 type HTTPRequest struct {
 	Method  string                          `json:"method"`
 	URL     string                          `json:"url"`
@@ -156,6 +162,9 @@ type parsedHTTPRequest struct {
 func (h *HTTP) parseRequest(ctx context.Context, method string, reqURL URL, body interface{}, params goja.Value) (*parsedHTTPRequest, error) {
 	rt := common.GetRuntime(ctx)
 	state := common.GetState(ctx)
+	if state == nil {
+		return nil, ErrHTTPForbiddenInInitContext
+	}
 
 	result := &parsedHTTPRequest{
 		url: &reqURL,
@@ -622,6 +631,9 @@ func (h *HTTP) request(ctx context.Context, preq *parsedHTTPRequest) (*HTTPRespo
 func (h *HTTP) Batch(ctx context.Context, reqsV goja.Value) (goja.Value, error) {
 	rt := common.GetRuntime(ctx)
 	state := common.GetState(ctx)
+	if state == nil {
+		return nil, ErrBatchForbiddenInInitContext
+	}
 
 	// Return values; retval must be guarded by the mutex.
 	var mutex sync.Mutex
diff --git a/js/modules/k6/k6.go b/js/modules/k6/k6.go
index 6c7992849..fba6bcd82 100644
--- a/js/modules/k6/k6.go
+++ b/js/modules/k6/k6.go
@@ -36,6 +36,12 @@ import (
 
 type K6 struct{}
 
+// ErrGroupInInitContext is returned when group() are using in the init context
+var ErrGroupInInitContext = common.NewInitContextError("Using group() in the init context is not supported")
+
+// ErrCheckInInitContext is returned when check() are using in the init context
+var ErrCheckInInitContext = common.NewInitContextError("Using check() in the init context is not supported")
+
 func New() *K6 {
 	return &K6{}
 }
@@ -62,6 +68,9 @@ func (*K6) RandomSeed(ctx context.Context, seed int64) {
 
 func (*K6) Group(ctx context.Context, name string, fn goja.Callable) (goja.Value, error) {
 	state := common.GetState(ctx)
+	if state == nil {
+		return nil, ErrGroupInInitContext
+	}
 
 	g, err := state.Group.Group(name)
 	if err != nil {
@@ -99,6 +108,9 @@ func (*K6) Group(ctx context.Context, name string, fn goja.Callable) (goja.Value
 
 func (*K6) Check(ctx context.Context, arg0, checks goja.Value, extras ...goja.Value) (bool, error) {
 	state := common.GetState(ctx)
+	if state == nil {
+		return false, ErrCheckInInitContext
+	}
 	rt := common.GetRuntime(ctx)
 	t := time.Now()
 
diff --git a/js/modules/k6/metrics/metrics.go b/js/modules/k6/metrics/metrics.go
index f1ce625d6..fb6b24da6 100644
--- a/js/modules/k6/metrics/metrics.go
+++ b/js/modules/k6/metrics/metrics.go
@@ -34,6 +34,9 @@ type Metric struct {
 	metric *stats.Metric
 }
 
+// ErrMetricsAddInInitContext is error returned when adding to metric is done in the init context
+var ErrMetricsAddInInitContext = common.NewInitContextError("Adding to metrics in the init context is not supported")
+
 func newMetric(ctxPtr *context.Context, name string, t stats.MetricType, isTime []bool) (interface{}, error) {
 	if common.GetState(*ctxPtr) != nil {
 		return nil, errors.New("Metrics must be declared in the init context")
@@ -48,8 +51,11 @@ func newMetric(ctxPtr *context.Context, name string, t stats.MetricType, isTime
 	return common.Bind(rt, Metric{stats.New(name, t, valueType)}, ctxPtr), nil
 }
 
-func (m Metric) Add(ctx context.Context, v goja.Value, addTags ...map[string]string) {
+func (m Metric) Add(ctx context.Context, v goja.Value, addTags ...map[string]string) (bool, error) {
 	state := common.GetState(ctx)
+	if state == nil {
+		return false, ErrMetricsAddInInitContext
+	}
 
 	tags := state.Options.RunTags.CloneTags()
 	if state.Options.SystemTags["group"] {
@@ -68,6 +74,7 @@ func (m Metric) Add(ctx context.Context, v goja.Value, addTags ...map[string]str
 	}
 
 	stats.PushIfNotCancelled(ctx, state.Samples, stats.Sample{Time: time.Now(), Metric: m.metric, Value: vfloat, Tags: stats.IntoSampleTags(&tags)})
+	return true, nil
 }
 
 type Metrics struct{}
diff --git a/js/modules/k6/ws/ws.go b/js/modules/k6/ws/ws.go
index 52178d7ab..5295b4d34 100644
--- a/js/modules/k6/ws/ws.go
+++ b/js/modules/k6/ws/ws.go
@@ -39,6 +39,9 @@ import (
 	"github.com/loadimpact/k6/stats"
 )
 
+// ErrWSInInitContext is returned when websockets are using in the init context
+var ErrWSInInitContext = common.NewInitContextError("Using websockets in the init context is not supported")
+
 type WS struct{}
 
 type pingDelta struct {
@@ -79,6 +82,9 @@ func New() *WS {
 func (*WS) Connect(ctx context.Context, url string, args ...goja.Value) (*WSHTTPResponse, error) {
 	rt := common.GetRuntime(ctx)
 	state := common.GetState(ctx)
+	if state == nil {
+		return nil, ErrWSInInitContext
+	}
 
 	// The params argument is optional
 	var callableV, paramsV goja.Value
diff --git a/js/runner_test.go b/js/runner_test.go
index 99fb7c098..ec2951098 100644
--- a/js/runner_test.go
+++ b/js/runner_test.go
@@ -35,6 +35,10 @@ import (
 	"github.com/loadimpact/k6/core"
 	"github.com/loadimpact/k6/core/local"
 	"github.com/loadimpact/k6/js/common"
+	"github.com/loadimpact/k6/js/modules/k6"
+	k6http "github.com/loadimpact/k6/js/modules/k6/http"
+	k6metrics "github.com/loadimpact/k6/js/modules/k6/metrics"
+	"github.com/loadimpact/k6/js/modules/k6/ws"
 	"github.com/loadimpact/k6/lib"
 	"github.com/loadimpact/k6/lib/metrics"
 	"github.com/loadimpact/k6/lib/testutils"
@@ -1218,3 +1222,105 @@ func TestVUIntegrationClientCerts(t *testing.T) {
 		}
 	})
 }
+
+func TestHTTPRequestInInitContext(t *testing.T) {
+	tb := testutils.NewHTTPMultiBin(t)
+	defer tb.Cleanup()
+
+	_, err := New(&lib.SourceData{
+		Filename: "/script.js",
+		Data: []byte(tb.Replacer.Replace(`
+					import { check, fail } from "k6";
+					import http from "k6/http";
+					let res = http.get("HTTPBIN_URL/");
+					export default function() {
+						console.log(test);ci
+					}
+				`)),
+	}, afero.NewMemMapFs(), lib.RuntimeOptions{})
+	if assert.Error(t, err) {
+		assert.Equal(
+			t,
+			"GoError: "+k6http.ErrHTTPForbiddenInInitContext.Error(),
+			err.Error())
+	}
+}
+
+func TestInitContextForbidden(t *testing.T) {
+	var table = [...][3]string{
+		{
+			"http.request",
+			`import http from "k6/http";
+			 let res = http.get("HTTPBIN_URL");
+			 export default function() { console.log("p"); }`,
+			k6http.ErrHTTPForbiddenInInitContext.Error(),
+		},
+		{
+			"http.batch",
+			`import http from "k6/http";
+			 let res = http.batch("HTTPBIN_URL/something", "HTTPBIN_URL/else");
+			 export default function() { console.log("p"); }`,
+			k6http.ErrBatchForbiddenInInitContext.Error(),
+		},
+		{
+			"http.cookieJar",
+			`import http from "k6/http";
+			 let jar = http.cookieJar();
+			 export default function() { console.log("p"); }`,
+			k6http.ErrJarForbiddenInInitContext.Error(),
+		},
+		{
+			"check",
+			`import { check } from "k6";
+			 check("test", {'is test': (test) => test == "test"})
+			 export default function() { console.log("p"); }`,
+			k6.ErrCheckInInitContext.Error(),
+		},
+		{
+			"group",
+			`import { group } from "k6";
+			 group("group1", function () { console.log("group1");})
+			 export default function() { console.log("p"); }`,
+			k6.ErrGroupInInitContext.Error(),
+		},
+		{
+			"ws",
+			`import ws from "k6/ws";
+			 var url = "ws://echo.websocket.org";
+			 var params = { "tags": { "my_tag": "hello" } };
+			 var response = ws.connect(url, params, function (socket) {
+			   socket.on('open', function open() {
+					console.log('connected');
+			   })
+		   });
+
+			 export default function() { console.log("p"); }`,
+			ws.ErrWSInInitContext.Error(),
+		},
+		{
+			"metric",
+			`import { Counter } from "k6/metrics";
+			 let counter = Counter("myCounter");
+			 counter.add(1);
+			 export default function() { console.log("p"); }`,
+			k6metrics.ErrMetricsAddInInitContext.Error(),
+		},
+	}
+	tb := testutils.NewHTTPMultiBin(t)
+	defer tb.Cleanup()
+
+	for _, test := range table {
+		t.Run(test[0], func(t *testing.T) {
+			_, err := New(&lib.SourceData{
+				Filename: "/script.js",
+				Data:     []byte(tb.Replacer.Replace(test[1])),
+			}, afero.NewMemMapFs(), lib.RuntimeOptions{})
+			if assert.Error(t, err) {
+				assert.Equal(
+					t,
+					"GoError: "+test[2],
+					err.Error())
+			}
+		})
+	}
+}
diff --git a/release notes/upcoming.md b/release notes/upcoming.md
index f3daae76d..20b18f889 100644
--- a/release notes/upcoming.md	
+++ b/release notes/upcoming.md	
@@ -116,3 +116,6 @@ Thanks to @AndriiChuzhynov for implementing this! (#766)
 * Setup data: Distinguish between `undefined` (when there is no `setup()` function or when it doesn't return anything) and `null` (when `setup()` explicitly returns `null`) values for the setup `data` that's passed to the default function and `teardown()` (#799)
 * Setup data: Prevent data races by having each VU have its own independent copy of the setup data (#799)
 * HAR converter: Support HAR files that don't have a `pages` array (#806)
+* UX: Instead of panicing on some operations in the init context we not return an error that the given
+  action is not supported(#811). This includes: making http requests(batched or not), websockets,
+  adding to metrics, making checks and groups or initializing cookie jars.
