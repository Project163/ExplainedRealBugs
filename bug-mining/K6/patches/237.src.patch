diff --git a/js/initcontext.go b/js/initcontext.go
index 8b8083ea2..68792c670 100644
--- a/js/initcontext.go
+++ b/js/initcontext.go
@@ -45,8 +45,9 @@ type InitContext struct {
 	pwd         *url.URL
 
 	// Cache of loaded programs and files.
-	programs     map[string]programWithSource
-	exportsCache map[string]goja.Value
+	programs map[string]programWithSource
+	// merge this and the above
+	k6ModulesCache map[string]goja.Value
 
 	compatibilityMode lib.CompatibilityMode
 
@@ -68,7 +69,7 @@ func NewInitContext(
 		compatibilityMode: compatMode,
 		logger:            logger,
 		moduleRegistry:    getJSModules(),
-		exportsCache:      make(map[string]goja.Value),
+		k6ModulesCache:    make(map[string]goja.Value),
 		moduleVUImpl: &moduleVUImpl{
 			// TODO: pass a real context as we did for https://github.com/grafana/k6/pull/2800,
 			// also see https://github.com/grafana/k6/issues/2804
@@ -96,7 +97,7 @@ func newBoundInitContext(base *InitContext, vuImpl *moduleVUImpl) *InitContext {
 
 		programs:          programs,
 		compatibilityMode: base.compatibilityMode,
-		exportsCache:      make(map[string]goja.Value),
+		k6ModulesCache:    make(map[string]goja.Value),
 		logger:            base.logger,
 		moduleRegistry:    base.moduleRegistry,
 		moduleVUImpl:      vuImpl,
@@ -105,13 +106,13 @@ func newBoundInitContext(base *InitContext, vuImpl *moduleVUImpl) *InitContext {
 
 // Require is called when a module/file needs to be loaded by a script
 func (i *InitContext) Require(arg string) (export goja.Value) {
-	var ok bool
-	if export, ok = i.exportsCache[arg]; ok {
-		return export
-	}
-	defer func() { i.exportsCache[arg] = export }()
 	switch {
 	case arg == "k6", strings.HasPrefix(arg, "k6/"):
+		var ok bool
+		if export, ok = i.k6ModulesCache[arg]; ok {
+			return export
+		}
+		defer func() { i.k6ModulesCache[arg] = export }()
 		// Builtin or external modules ("k6", "k6/*", or "k6/x/*") are handled
 		// specially, as they don't exist on the filesystem. This intentionally
 		// shadows attempts to name your own modules this.
diff --git a/js/initcontext_test.go b/js/initcontext_test.go
index 00ef84ec3..688b21238 100644
--- a/js/initcontext_test.go
+++ b/js/initcontext_test.go
@@ -708,3 +708,26 @@ func TestImportModificationsAreConsistentBetweenFiles(t *testing.T) {
 	_, err = b.Instantiate(context.Background(), 0)
 	require.NoError(t, err)
 }
+
+func TestCacheAbsolutePathsNotRelative(t *testing.T) {
+	t.Parallel()
+	fs := afero.NewMemMapFs()
+	require.NoError(t, afero.WriteFile(fs, "/a/interesting.js", []byte(`export default "a.interesting"`), 0o644))
+	require.NoError(t, afero.WriteFile(fs, "/a/import.js", []byte(`export { default as default} from "./interesting.js"`), 0o644))
+
+	require.NoError(t, afero.WriteFile(fs, "/b/interesting.js", []byte(`export default "b.interesting"`), 0o644))
+	require.NoError(t, afero.WriteFile(fs, "/b/import.js", []byte(`export { default as default} from "./interesting.js"`), 0o644))
+
+	b, err := getSimpleBundle(t, "/script.js", `
+    import a from "/a/import.js"
+    import b from "/b/import.js"
+    if (a != "a.interesting") { throw `+"`"+`'a' has wrong value "${a}" should be "a.interesting"`+"`"+`}
+
+    if (b != "b.interesting") { throw `+"`"+`'b' has wrong value "${b}" should be "b.interesting"`+"`"+`}
+    export default () => { throw "this shouldn't be ran" }
+`, fs)
+	require.NoError(t, err, "bundle error")
+
+	_, err = b.Instantiate(context.Background(), 0)
+	require.NoError(t, err)
+}
