diff --git a/js/runner.go b/js/runner.go
index 370ebf177..1be3c84be 100644
--- a/js/runner.go
+++ b/js/runner.go
@@ -48,9 +48,6 @@ import (
 	"github.com/loadimpact/k6/stats"
 )
 
-//nolint:gochecknoglobals
-var errInterrupt = errors.New("context cancelled")
-
 // Ensure Runner implements the lib.Runner interface
 var _ lib.Runner = &Runner{}
 
@@ -404,7 +401,7 @@ func (r *Runner) runPart(ctx context.Context, out chan<- stats.SampleContainer,
 	defer cancel()
 	go func() {
 		<-ctx.Done()
-		vu.Runtime.Interrupt(errInterrupt)
+		vu.Runtime.Interrupt(context.Canceled)
 	}()
 	*vu.Context = ctx
 
@@ -422,8 +419,8 @@ func (r *Runner) runPart(ctx context.Context, out chan<- stats.SampleContainer,
 
 	// deadline is reached so we have timeouted but this might've not been registered correctly
 	if deadline, ok := ctx.Deadline(); ok && time.Now().After(deadline) {
-		// we could have an error that is not errInterrupt in which case we should return it instead
-		if err, ok := err.(*goja.InterruptedError); ok && v != nil && err.Value() != errInterrupt {
+		// we could have an error that is not context.Canceled in which case we should return it instead
+		if err, ok := err.(*goja.InterruptedError); ok && v != nil && err.Value() != context.Canceled {
 			// TODO: silence this error?
 			return v, err
 		}
@@ -535,7 +532,7 @@ func (u *VU) Activate(params *lib.VUActivationParams) lib.ActiveVU {
 		// Wait for the run context to be over
 		<-params.RunContext.Done()
 		// Interrupt the JS runtime
-		u.Runtime.Interrupt(errInterrupt)
+		u.Runtime.Interrupt(context.Canceled)
 		// Wait for the VU to stop running, if it was, and prevent it from
 		// running again for this activation
 		avu.busy <- struct{}{}
@@ -583,7 +580,7 @@ func (u *ActiveVU) RunOnce() error {
 	// Call the exported function.
 	_, isFullIteration, totalTime, err := u.runFn(u.RunContext, true, fn, u.setupData)
 
-	// If MinIterationDuration is specified and the iteration wasn't cancelled
+	// If MinIterationDuration is specified and the iteration wasn't canceled
 	// and was less than it, sleep for the remainder
 	if isFullIteration && u.Runner.Bundle.Options.MinIterationDuration.Valid {
 		durationDiff := time.Duration(u.Runner.Bundle.Options.MinIterationDuration.Duration) - totalTime
diff --git a/js/runner_test.go b/js/runner_test.go
index 00a46631f..30287f0dc 100644
--- a/js/runner_test.go
+++ b/js/runner_test.go
@@ -578,7 +578,7 @@ func TestVURunInterrupt(t *testing.T) {
 			activeVU := vu.Activate(&lib.VUActivationParams{RunContext: ctx})
 			err = activeVU.RunOnce()
 			assert.Error(t, err)
-			assert.Contains(t, err.Error(), "context cancelled")
+			assert.Contains(t, err.Error(), "context canceled")
 		})
 	}
 }
@@ -624,7 +624,7 @@ func TestVURunInterruptDoesntPanic(t *testing.T) {
 					close(ch)
 					vuErr := vu.RunOnce()
 					assert.Error(t, vuErr)
-					assert.Contains(t, vuErr.Error(), "context cancelled")
+					assert.Contains(t, vuErr.Error(), "context canceled")
 				}()
 				<-ch
 				time.Sleep(time.Millisecond * 1) // NOTE: increase this in case of problems ;)
