diff --git a/lib/old_archive_test.go b/lib/old_archive_test.go
index ad700968f..16f539d84 100644
--- a/lib/old_archive_test.go
+++ b/lib/old_archive_test.go
@@ -62,10 +62,8 @@ func TestOldArchive(t *testing.T) {
 	t.Parallel()
 	testCases := map[string]string{
 		// map of filename to data for each main file tested
-		"github.com/k6io/k6/samples/example.js": `github file`,
-		"cdnjs.com/libraries/Faker":             `faker file`,
-		"C:/something/path2":                    `windows script`,
-		"/absolulte/path2":                      `unix script`,
+		"C:/something/path2": `windows script`,
+		"/absolulte/path2":   `unix script`,
 	}
 	for filename, data := range testCases {
 		filename, data := filename, data
@@ -74,20 +72,16 @@ func TestOldArchive(t *testing.T) {
 			metadata := `{"filename": "` + filename + `", "options": {}}`
 			fs := makeMemMapFs(t, map[string][]byte{
 				// files
-				"/files/github.com/k6io/k6/samples/example.js": []byte(`github file`),
-				"/files/cdnjs.com/libraries/Faker":             []byte(`faker file`),
-				"/files/example.com/path/to.js":                []byte(`example.com file`),
-				"/files/_/C/something/path":                    []byte(`windows file`),
-				"/files/_/absolulte/path":                      []byte(`unix file`),
+				"/files/example.com/path/to.js": []byte(`example.com file`),
+				"/files/_/C/something/path":     []byte(`windows file`),
+				"/files/_/absolulte/path":       []byte(`unix file`),
 
 				// scripts
-				"/scripts/github.com/k6io/k6/samples/example.js2": []byte(`github script`),
-				"/scripts/cdnjs.com/libraries/Faker2":             []byte(`faker script`),
-				"/scripts/example.com/path/too.js":                []byte(`example.com script`),
-				"/scripts/_/C/something/path2":                    []byte(`windows script`),
-				"/scripts/_/absolulte/path2":                      []byte(`unix script`),
-				"/data":                                           []byte(data),
-				"/metadata.json":                                  []byte(metadata),
+				"/scripts/example.com/path/too.js": []byte(`example.com script`),
+				"/scripts/_/C/something/path2":     []byte(`windows script`),
+				"/scripts/_/absolulte/path2":       []byte(`unix script`),
+				"/data":                            []byte(data),
+				"/metadata.json":                   []byte(metadata),
 			})
 
 			buf, err := dumpMemMapFsToBuf(fs)
@@ -101,12 +95,8 @@ func TestOldArchive(t *testing.T) {
 					"/absolulte/path2":    []byte(`unix script`),
 				}),
 				"https": makeMemMapFs(t, map[string][]byte{
-					"/example.com/path/to.js":                 []byte(`example.com file`),
-					"/example.com/path/too.js":                []byte(`example.com script`),
-					"/github.com/k6io/k6/samples/example.js":  []byte(`github file`),
-					"/cdnjs.com/libraries/Faker":              []byte(`faker file`),
-					"/github.com/k6io/k6/samples/example.js2": []byte(`github script`),
-					"/cdnjs.com/libraries/Faker2":             []byte(`faker script`),
+					"/example.com/path/to.js":  []byte(`example.com file`),
+					"/example.com/path/too.js": []byte(`example.com script`),
 				}),
 			}
 
@@ -146,16 +136,14 @@ func TestFilenamePwdResolve(t *testing.T) {
 			expectedPwdURL:      &url.URL{Scheme: "file", Path: "/home/nobody"},
 		},
 		{
-			Filename:            "github.com/k6io/k6/samples/http2.js",
-			Pwd:                 "github.com/k6io/k6/samples",
-			expectedFilenameURL: &url.URL{Opaque: "github.com/k6io/k6/samples/http2.js"},
-			expectedPwdURL:      &url.URL{Opaque: "github.com/k6io/k6/samples"},
+			Filename:      "github.com/k6io/k6/samples/http2.js",
+			Pwd:           "github.com/k6io/k6/samples",
+			expectedError: "are no longer supported",
 		},
 		{
-			Filename:            "cdnjs.com/libraries/Faker",
-			Pwd:                 "/home/nobody",
-			expectedFilenameURL: &url.URL{Opaque: "cdnjs.com/libraries/Faker"},
-			expectedPwdURL:      &url.URL{Scheme: "file", Path: "/home/nobody"},
+			Filename:      "cdnjs.com/libraries/Faker",
+			Pwd:           "/home/nobody",
+			expectedError: "are no longer supported",
 		},
 		{
 			Filename:            "https://example.com/something/dot.js",
diff --git a/loader/cdnjs.go b/loader/cdnjs.go
deleted file mode 100644
index f58719c7a..000000000
--- a/loader/cdnjs.go
+++ /dev/null
@@ -1,74 +0,0 @@
-package loader
-
-import (
-	"encoding/json"
-	"fmt"
-
-	"github.com/sirupsen/logrus"
-)
-
-type cdnjsEnvelope struct {
-	Name     string `json:"name"`
-	Filename string `json:"filename"`
-	Version  string `json:"version"`
-	Assets   []struct {
-		Version string   `json:"version"`
-		Files   []string `json:"files"`
-	}
-}
-
-func cdnjs(logger logrus.FieldLogger, path string, parts []string) (string, error) {
-	name := parts[0]
-	version := parts[1]
-	filename := parts[2]
-
-	data, err := fetch(logger, "https://api.cdnjs.com/libraries/"+name)
-	if err != nil {
-		return "", err
-	}
-	var envelope cdnjsEnvelope
-	if err := json.Unmarshal(data, &envelope); err != nil {
-		return "", err
-	}
-
-	// CDNJS doesn't actually send 404s, nonexistent libs' data is just *empty*.
-	if envelope.Name == "" {
-		return "", fmt.Errorf("cdnjs: no such library: %s", name)
-	}
-
-	// If no version is specified, use the default/latest one.
-	if version == "" {
-		version = envelope.Version
-	}
-
-	// If no filename is specified, use the default one, but make sure it actually exists in the
-	// chosen version (it may have changed name over the years). If not, the first listed file
-	// that does exist in that version is a pretty safe guess.
-	if filename == "" {
-		filename = envelope.Filename
-
-		backupFilename := filename
-		filenameExistsInVersion := false
-		for _, ver := range envelope.Assets {
-			if ver.Version != version {
-				continue
-			}
-			if len(ver.Files) == 0 {
-				return "",
-					fmt.Errorf("cdnjs: no files for version %s of %s, this is a problem with the library or cdnjs not k6",
-						version, path)
-			}
-			backupFilename = ver.Files[0]
-			for _, file := range ver.Files {
-				if file == filename {
-					filenameExistsInVersion = true
-				}
-			}
-		}
-		if !filenameExistsInVersion {
-			filename = backupFilename
-		}
-	}
-
-	return "https://cdnjs.cloudflare.com/ajax/libs/" + name + "/" + version + "/" + filename, nil
-}
diff --git a/loader/cdnjs_test.go b/loader/cdnjs_test.go
deleted file mode 100644
index 0a0fc50e4..000000000
--- a/loader/cdnjs_test.go
+++ /dev/null
@@ -1,107 +0,0 @@
-package loader
-
-import (
-	"net/url"
-	"testing"
-
-	"github.com/sirupsen/logrus"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"go.k6.io/k6/lib/fsext"
-	"go.k6.io/k6/lib/testutils"
-)
-
-func TestCDNJS(t *testing.T) {
-	t.Skip("skipped to avoid inconsistent API responses")
-	t.Parallel()
-
-	paths := map[string]struct {
-		parts []string
-		src   string
-	}{
-		"cdnjs.com/libraries/Faker": {
-			[]string{"Faker", "", ""},
-			`^https://cdnjs.cloudflare.com/ajax/libs/Faker/[\d\.]+/faker.min.js$`,
-		},
-		"cdnjs.com/libraries/Faker/faker.js": {
-			[]string{"Faker", "", "faker.js"},
-			`^https://cdnjs.cloudflare.com/ajax/libs/Faker/[\d\.]+/faker.js$`,
-		},
-		"cdnjs.com/libraries/Faker/locales/en_AU/faker.en_AU.min.js": {
-			[]string{"Faker", "", "locales/en_AU/faker.en_AU.min.js"},
-			`^https://cdnjs.cloudflare.com/ajax/libs/Faker/[\d\.]+/locales/en_AU/faker.en_AU.min.js$`,
-		},
-		"cdnjs.com/libraries/Faker/3.1.0": {
-			[]string{"Faker", "3.1.0", ""},
-			`^https://cdnjs.cloudflare.com/ajax/libs/Faker/3.1.0/faker.min.js$`,
-		},
-		"cdnjs.com/libraries/Faker/3.1.0/faker.js": {
-			[]string{"Faker", "3.1.0", "faker.js"},
-			`^https://cdnjs.cloudflare.com/ajax/libs/Faker/3.1.0/faker.js$`,
-		},
-		"cdnjs.com/libraries/Faker/3.1.0/locales/en_AU/faker.en_AU.min.js": {
-			[]string{"Faker", "3.1.0", "locales/en_AU/faker.en_AU.min.js"},
-			`^https://cdnjs.cloudflare.com/ajax/libs/Faker/3.1.0/locales/en_AU/faker.en_AU.min.js$`,
-		},
-		"cdnjs.com/libraries/Faker/0.7.2": {
-			[]string{"Faker", "0.7.2", ""},
-			`^https://cdnjs.cloudflare.com/ajax/libs/Faker/0.7.2/MinFaker.js$`,
-		},
-	}
-
-	root := &url.URL{Scheme: "https", Host: "example.com", Path: "/something/"}
-	logger := logrus.New()
-	logger.SetOutput(testutils.NewTestOutput(t))
-	for path, expected := range paths {
-		path, expected := path, expected
-		t.Run(path, func(t *testing.T) {
-			t.Parallel()
-			name, loader, parts := pickLoader(path)
-			assert.Equal(t, "cdnjs", name)
-			assert.Equal(t, expected.parts, parts)
-
-			src, err := loader(logger, path, parts)
-			require.NoError(t, err)
-			assert.Regexp(t, expected.src, src)
-
-			resolvedURL, err := Resolve(root, path)
-			require.NoError(t, err)
-			require.Empty(t, resolvedURL.Scheme)
-			require.Equal(t, path, resolvedURL.Opaque)
-
-			data, err := Load(logger, map[string]fsext.Fs{"https": fsext.NewMemMapFs()}, resolvedURL, path)
-			require.NoError(t, err)
-			assert.Equal(t, resolvedURL, data.URL)
-			assert.NotEmpty(t, data.Data)
-		})
-	}
-
-	t.Run("cdnjs.com/libraries/nonexistent", func(t *testing.T) {
-		t.Parallel()
-		path := "cdnjs.com/libraries/nonexistent"
-		name, loader, parts := pickLoader(path)
-		assert.Equal(t, "cdnjs", name)
-		assert.Equal(t, []string{"nonexistent", "", ""}, parts)
-		_, err := loader(logger, path, parts)
-		assert.EqualError(t, err, "cdnjs: no such library: nonexistent")
-	})
-
-	t.Run("cdnjs.com/libraries/Faker/3.1.0/nonexistent.js", func(t *testing.T) {
-		t.Parallel()
-		path := "cdnjs.com/libraries/Faker/3.1.0/nonexistent.js"
-		name, loader, parts := pickLoader(path)
-		assert.Equal(t, "cdnjs", name)
-		assert.Equal(t, []string{"Faker", "3.1.0", "nonexistent.js"}, parts)
-		src, err := loader(logger, path, parts)
-		require.NoError(t, err)
-		assert.Equal(t, "https://cdnjs.cloudflare.com/ajax/libs/Faker/3.1.0/nonexistent.js", src)
-
-		pathURL, err := url.Parse(src)
-		require.NoError(t, err)
-
-		_, err = Load(logger, map[string]fsext.Fs{"https": fsext.NewMemMapFs()}, pathURL, path)
-		require.Error(t, err)
-		assert.Contains(t, err.Error(), "not found: https://cdnjs.cloudflare.com/ajax/libs/Faker/3.1.0/nonexistent.js")
-	})
-}
diff --git a/loader/github.go b/loader/github.go
deleted file mode 100644
index 028d8c773..000000000
--- a/loader/github.go
+++ /dev/null
@@ -1,10 +0,0 @@
-package loader
-
-import "github.com/sirupsen/logrus"
-
-func github(_ logrus.FieldLogger, _ string, parts []string) (string, error) {
-	username := parts[0]
-	repo := parts[1]
-	filepath := parts[2]
-	return "https://raw.githubusercontent.com/" + username + "/" + repo + "/master/" + filepath, nil
-}
diff --git a/loader/github_test.go b/loader/github_test.go
deleted file mode 100644
index a420c6c9a..000000000
--- a/loader/github_test.go
+++ /dev/null
@@ -1,74 +0,0 @@
-package loader
-
-import (
-	"net/url"
-	"testing"
-
-	"github.com/sirupsen/logrus"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"go.k6.io/k6/lib/fsext"
-	"go.k6.io/k6/lib/testutils"
-)
-
-func TestGithub(t *testing.T) {
-	t.Parallel()
-	logger := logrus.New()
-	logger.SetOutput(testutils.NewTestOutput(t))
-	path := "github.com/github/gitignore/Go.gitignore"
-	expectedEndSrc := "https://raw.githubusercontent.com/github/gitignore/master/Go.gitignore"
-	name, loader, parts := pickLoader(path)
-	assert.Equal(t, "github", name)
-	assert.Equal(t, []string{"github", "gitignore", "Go.gitignore"}, parts)
-	src, err := loader(logger, path, parts)
-	assert.NoError(t, err)
-	assert.Equal(t, expectedEndSrc, src)
-
-	root := &url.URL{Scheme: "https", Host: "example.com", Path: "/something/"}
-	resolvedURL, err := Resolve(root, path)
-	require.NoError(t, err)
-	require.Empty(t, resolvedURL.Scheme)
-	require.Equal(t, path, resolvedURL.Opaque)
-	t.Run("not cached", func(t *testing.T) {
-		t.Parallel()
-		data, err := Load(logger, map[string]fsext.Fs{"https": fsext.NewMemMapFs()}, resolvedURL, path)
-		require.NoError(t, err)
-		assert.Equal(t, data.URL, resolvedURL)
-		assert.Equal(t, path, data.URL.String())
-		assert.NotEmpty(t, data.Data)
-	})
-
-	t.Run("cached", func(t *testing.T) {
-		t.Parallel()
-		fs := fsext.NewMemMapFs()
-		testData := []byte("test data")
-
-		err := fsext.WriteFile(fs, "/github.com/github/gitignore/Go.gitignore", testData, 0o644)
-		require.NoError(t, err)
-
-		data, err := Load(logger, map[string]fsext.Fs{"https": fs}, resolvedURL, path)
-		require.NoError(t, err)
-		assert.Equal(t, path, data.URL.String())
-		assert.Equal(t, data.Data, testData)
-	})
-
-	t.Run("relative", func(t *testing.T) {
-		t.Parallel()
-		tests := map[string]string{
-			"./something.else":  "github.com/github/gitignore/something.else",
-			"../something.else": "github.com/github/something.else",
-			"/something.else":   "github.com/something.else",
-		}
-		for relative, expected := range tests {
-			relativeURL, err := Resolve(Dir(resolvedURL), relative)
-			require.NoError(t, err)
-			assert.Equal(t, expected, relativeURL.String())
-		}
-	})
-
-	t.Run("dir", func(t *testing.T) {
-		t.Parallel()
-		require.Equal(t, &url.URL{Opaque: "github.com/github/gitignore"}, Dir(resolvedURL))
-	})
-}
diff --git a/loader/loader.go b/loader/loader.go
index 7e2c862fa..368f79b29 100644
--- a/loader/loader.go
+++ b/loader/loader.go
@@ -11,7 +11,6 @@ import (
 	"net/url"
 	"path"
 	"path/filepath"
-	"regexp"
 	"strings"
 	"time"
 
@@ -26,21 +25,6 @@ type SourceData struct {
 	PWD  *url.URL
 }
 
-type loaderFunc func(logger logrus.FieldLogger, path string, parts []string) (string, error)
-
-//nolint:gochecknoglobals
-var (
-	loaders = []struct {
-		name string
-		fn   loaderFunc
-		expr *regexp.Regexp
-	}{
-		{"cdnjs", cdnjs, regexp.MustCompile(`^cdnjs\.com/libraries/([^/]+)(?:/([(\d\.)]+-?[^/]*))?(?:/(.*))?$`)},
-		{"github", github, regexp.MustCompile(`^github\.com/([^/]+)/([^/]+)/(.*)$`)},
-	}
-	errNoLoaderMatched = errors.New("no loader matched")
-)
-
 const (
 	httpsSchemeCouldntBeLoadedMsg = `The moduleSpecifier "%s" couldn't be retrieved from` +
 		` the resolved url "%s". Error : "%s"`
@@ -85,13 +69,15 @@ func Resolve(pwd *url.URL, moduleSpecifier string) (*url.URL, error) {
 		}
 		return u, err
 	}
-	_, loader, _ := pickLoader(moduleSpecifier)
-	if loader != nil {
-		// here we only care if a loader is pickable, if it is and later there is an error in the loading
-		// from it we don't want to try another resolve
-		return &url.URL{Opaque: moduleSpecifier}, nil
-	}
 
+	if strings.HasPrefix(moduleSpecifier, "cdnjs.com") {
+		return nil, fmt.Errorf("cdnjs.com 'special' urls are no longer supported - please use real ones. " +
+			"You can get yours by going to cdnjs and copy-pasting the full url to the actual JavaScript file")
+	}
+	if strings.HasPrefix(moduleSpecifier, "github.com") {
+		return nil, fmt.Errorf("github.com 'special' urls are no longer supported - please use real ones. " +
+			"You can get yours by going to github and copy-pasting the full url to the actual raw JavaScript file")
+	}
 	return nil, unresolvableURLError(moduleSpecifier)
 }
 
@@ -127,9 +113,6 @@ func resolveFilePath(pwd *url.URL, moduleSpecifier string) (*url.URL, error) {
 
 // Dir returns the directory for the path.
 func Dir(old *url.URL) *url.URL {
-	if old.Opaque != "" { // loader
-		return &url.URL{Opaque: path.Join(old.Opaque, "../")}
-	}
 	return old.ResolveReference(&url.URL{Path: "./"})
 }
 
@@ -147,8 +130,6 @@ func Load(
 
 	var pathOnFs string
 	switch {
-	case moduleSpecifier.Opaque != "": // This is loader
-		pathOnFs = filepath.Join(fsext.FilePathSeparator, moduleSpecifier.Opaque)
 	case moduleSpecifier.Scheme == "":
 		pathOnFs = path.Clean(moduleSpecifier.String())
 	default:
@@ -171,10 +152,6 @@ func Load(
 	data, err := fsext.ReadFile(filesystems[scheme], pathOnFs)
 
 	if err == nil {
-		if moduleSpecifier.Opaque != "" {
-			loaderName, _, _ := pickLoader(moduleSpecifier.Opaque)
-			logger.Warnf(magicURLsDeprecationWarning, originalModuleSpecifier, loaderName)
-		}
 		return &SourceData{URL: moduleSpecifier, Data: data}, nil
 	}
 	if !errors.Is(err, fs.ErrNotExist) {
@@ -187,13 +164,6 @@ func Load(
 
 	finalModuleSpecifierURL := moduleSpecifier
 
-	if moduleSpecifier.Opaque != "" { // This is a loader
-		finalModuleSpecifierURL, err = resolveUsingLoaders(logger, moduleSpecifier.Opaque)
-		if err != nil {
-			return nil, err
-		}
-	}
-
 	var result *SourceData
 	result, err = loadRemoteURL(logger, finalModuleSpecifierURL)
 	if err != nil {
@@ -208,26 +178,6 @@ func Load(
 	return result, nil
 }
 
-const (
-	magicURLsDeprecationWarning = "Specifier %q resolved to use a non-conventional %[2]q loader. " +
-		"The used %[2]q loader is deprecated and will be removed in k6 v0.53.0."
-	magicURLsDeprecationWarningExtended = magicURLsDeprecationWarning + " Please use the real URL %q instead."
-)
-
-func resolveUsingLoaders(logger logrus.FieldLogger, name string) (*url.URL, error) {
-	loaderName, loader, loaderArgs := pickLoader(name)
-	if loader != nil {
-		urlString, err := loader(logger, name, loaderArgs)
-		if err != nil {
-			return nil, err
-		}
-		logger.Warnf(magicURLsDeprecationWarningExtended, name, loaderName, urlString)
-		return url.Parse(urlString)
-	}
-
-	return nil, errNoLoaderMatched
-}
-
 func loadRemoteURL(logger logrus.FieldLogger, u *url.URL) (*SourceData, error) {
 	oldQuery := u.RawQuery
 	if u.RawQuery != "" {
@@ -253,16 +203,6 @@ func loadRemoteURL(logger logrus.FieldLogger, u *url.URL) (*SourceData, error) {
 	return &SourceData{URL: u, Data: data}, nil
 }
 
-func pickLoader(path string) (string, loaderFunc, []string) {
-	for _, loader := range loaders {
-		matches := loader.expr.FindAllStringSubmatch(path, -1)
-		if len(matches) > 0 {
-			return loader.name, loader.fn, matches[0][1:]
-		}
-	}
-	return "", nil, nil
-}
-
 func fetch(logger logrus.FieldLogger, u string) ([]byte, error) {
 	logger.WithField("url", u).Debug("Fetching source...")
 	startTime := time.Now()
