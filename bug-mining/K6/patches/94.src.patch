diff --git a/js/modules/k6/crypto/crypto.go b/js/modules/k6/crypto/crypto.go
index d3c77ea7c..354ea16f9 100644
--- a/js/modules/k6/crypto/crypto.go
+++ b/js/modules/k6/crypto/crypto.go
@@ -63,55 +63,55 @@ func (*Crypto) RandomBytes(ctx context.Context, size int) []byte {
 	return bytes
 }
 
-func (c *Crypto) Md4(ctx context.Context, input []byte, outputEncoding string) string {
+func (c *Crypto) Md4(ctx context.Context, input []byte, outputEncoding string) interface{} {
 	hasher := c.CreateHash(ctx, "md4")
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
 }
 
-func (c *Crypto) Md5(ctx context.Context, input []byte, outputEncoding string) string {
+func (c *Crypto) Md5(ctx context.Context, input []byte, outputEncoding string) interface{} {
 	hasher := c.CreateHash(ctx, "md5")
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
 }
 
-func (c *Crypto) Sha1(ctx context.Context, input []byte, outputEncoding string) string {
+func (c *Crypto) Sha1(ctx context.Context, input []byte, outputEncoding string) interface{} {
 	hasher := c.CreateHash(ctx, "sha1")
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
 }
 
-func (c *Crypto) Sha256(ctx context.Context, input []byte, outputEncoding string) string {
+func (c *Crypto) Sha256(ctx context.Context, input []byte, outputEncoding string) interface{} {
 	hasher := c.CreateHash(ctx, "sha256")
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
 }
 
-func (c *Crypto) Sha384(ctx context.Context, input []byte, outputEncoding string) string {
+func (c *Crypto) Sha384(ctx context.Context, input []byte, outputEncoding string) interface{} {
 	hasher := c.CreateHash(ctx, "sha384")
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
 }
 
-func (c *Crypto) Sha512(ctx context.Context, input []byte, outputEncoding string) string {
+func (c *Crypto) Sha512(ctx context.Context, input []byte, outputEncoding string) interface{} {
 	hasher := c.CreateHash(ctx, "sha512")
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
 }
 
-func (c *Crypto) Sha512_224(ctx context.Context, input []byte, outputEncoding string) string {
+func (c *Crypto) Sha512_224(ctx context.Context, input []byte, outputEncoding string) interface{} {
 	hasher := c.CreateHash(ctx, "sha512_224")
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
 }
 
-func (c *Crypto) Sha512_256(ctx context.Context, input []byte, outputEncoding string) string {
+func (c *Crypto) Sha512_256(ctx context.Context, input []byte, outputEncoding string) interface{} {
 	hasher := c.CreateHash(ctx, "sha512_256")
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
 }
 
-func (c *Crypto) Ripemd160(ctx context.Context, input []byte, outputEncoding string) string {
+func (c *Crypto) Ripemd160(ctx context.Context, input []byte, outputEncoding string) interface{} {
 	hasher := c.CreateHash(ctx, "ripemd160")
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
@@ -152,7 +152,7 @@ func (hasher *Hasher) Update(input []byte) {
 	}
 }
 
-func (hasher *Hasher) Digest(outputEncoding string) string {
+func (hasher *Hasher) Digest(outputEncoding string) interface{} {
 	sum := hasher.hash.Sum(nil)
 
 	switch outputEncoding {
@@ -168,6 +168,9 @@ func (hasher *Hasher) Digest(outputEncoding string) string {
 	case "hex":
 		return hex.EncodeToString(sum)
 
+	case "binary":
+		return sum
+
 	default:
 		err := errors.New("Invalid output encoding: " + outputEncoding)
 		common.Throw(common.GetRuntime(hasher.ctx), err)
@@ -176,30 +179,34 @@ func (hasher *Hasher) Digest(outputEncoding string) string {
 	return ""
 }
 
-func (c Crypto) CreateHMAC(ctx context.Context, algorithm string, key string) *Hasher {
+// HexEncode returns a string with the hex representation of the provided byte array
+func (c Crypto) HexEncode(_ context.Context, data []byte) string {
+	return hex.EncodeToString(data)
+}
+
+func (c Crypto) CreateHMAC(ctx context.Context, algorithm string, key []byte) *Hasher {
 	hasher := Hasher{}
 	hasher.ctx = ctx
-	keyBuffer := []byte(key)
 
 	switch algorithm {
 	case "md4":
-		hasher.hash = hmac.New(md4.New, keyBuffer)
+		hasher.hash = hmac.New(md4.New, key)
 	case "md5":
-		hasher.hash = hmac.New(md5.New, keyBuffer)
+		hasher.hash = hmac.New(md5.New, key)
 	case "sha1":
-		hasher.hash = hmac.New(sha1.New, keyBuffer)
+		hasher.hash = hmac.New(sha1.New, key)
 	case "sha256":
-		hasher.hash = hmac.New(sha256.New, keyBuffer)
+		hasher.hash = hmac.New(sha256.New, key)
 	case "sha384":
-		hasher.hash = hmac.New(sha512.New384, keyBuffer)
+		hasher.hash = hmac.New(sha512.New384, key)
 	case "sha512_224":
-		hasher.hash = hmac.New(sha512.New512_224, keyBuffer)
+		hasher.hash = hmac.New(sha512.New512_224, key)
 	case "sha512_256":
-		hasher.hash = hmac.New(sha512.New512_256, keyBuffer)
+		hasher.hash = hmac.New(sha512.New512_256, key)
 	case "sha512":
-		hasher.hash = hmac.New(sha512.New, keyBuffer)
+		hasher.hash = hmac.New(sha512.New, key)
 	case "ripemd160":
-		hasher.hash = hmac.New(ripemd160.New, keyBuffer)
+		hasher.hash = hmac.New(ripemd160.New, key)
 	default:
 		err := errors.New("Invalid algorithm: " + algorithm)
 		common.Throw(common.GetRuntime(hasher.ctx), err)
@@ -208,7 +215,9 @@ func (c Crypto) CreateHMAC(ctx context.Context, algorithm string, key string) *H
 	return &hasher
 }
 
-func (c *Crypto) Hmac(ctx context.Context, algorithm string, key string, input []byte, outputEncoding string) string {
+func (c *Crypto) Hmac(
+	ctx context.Context, algorithm string, key []byte, input []byte, outputEncoding string,
+) interface{} {
 	hasher := c.CreateHMAC(ctx, algorithm, key)
 	hasher.Update(input)
 	return hasher.Digest(outputEncoding)
diff --git a/js/modules/k6/crypto/crypto_test.go b/js/modules/k6/crypto/crypto_test.go
index eb1b33497..c6098aeef 100644
--- a/js/modules/k6/crypto/crypto_test.go
+++ b/js/modules/k6/crypto/crypto_test.go
@@ -263,6 +263,7 @@ func TestOutputEncoding(t *testing.T) {
 		const correctBase64 = "XrY7u+Ae7tCTyyK7j1rNww==";
 		const correctBase64URL = "XrY7u-Ae7tCTyyK7j1rNww=="
 		const correctBase64RawURL = "XrY7u-Ae7tCTyyK7j1rNww";
+		const correctBinary = [94,182,59,187,224,30,238,208,147,203,34,187,143,90,205,195];
 
 		let hasher = crypto.createHash("md5");
 		hasher.update("hello world");
@@ -286,6 +287,23 @@ func TestOutputEncoding(t *testing.T) {
 		if (resultBase64RawURL !== correctBase64RawURL) {
 			throw new Error("Base64 raw URL encoding mismatch: " + resultBase64RawURL);
 		}
+
+		// https://stackoverflow.com/a/16436975/5427244
+		function arraysEqual(a, b) {
+		  if (a === b) return true;
+		  if (a == null || b == null) return false;
+		  if (a.length != b.length) return false;
+
+		  for (var i = 0; i < a.length; ++i) {
+			if (a[i] !== b[i]) return false;
+		  }
+		  return true;
+		}
+
+		const resultBinary = hasher.digest("binary");
+		if (!arraysEqual(resultBinary,  correctBinary)) {
+			throw new Error("Binary encoding mismatch: " + JSON.stringify(resultBinary));
+		}
 		`)
 
 		assert.NoError(t, err)
@@ -389,3 +407,53 @@ func TestHMac(t *testing.T) {
 		})
 	}
 }
+
+func TestAWSv4(t *testing.T) {
+	// example values from https://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html
+	rt := goja.New()
+	rt.SetFieldNameMapper(common.FieldNameMapper{})
+	ctx := context.Background()
+	ctx = common.WithRuntime(ctx, rt)
+	rt.Set("crypto", common.Bind(rt, New(), &ctx))
+
+	_, err := common.RunString(rt, `
+		let HexEncode = crypto.hexEncode;
+		let HmacSHA256 = function(data, key) {
+			return crypto.hmac("sha256",key, data, "binary");
+		};
+
+		let expectedKDate    = '969fbb94feb542b71ede6f87fe4d5fa29c789342b0f407474670f0c2489e0a0d'
+		let expectedKRegion  = '69daa0209cd9c5ff5c8ced464a696fd4252e981430b10e3d3fd8e2f197d7a70c'
+		let expectedKService = 'f72cfd46f26bc4643f06a11eabb6c0ba18780c19a8da0c31ace671265e3c87fa'
+		let expectedKSigning = 'f4780e2d9f65fa895f9c67b32ce1baf0b0d8a43505a000a1a9e090d414db404d'
+
+		let key = 'wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY';
+		let dateStamp = '20120215';
+		let regionName = 'us-east-1';
+		let serviceName = 'iam';
+
+		let kDate = HmacSHA256(dateStamp, "AWS4" + key);
+		let kRegion = HmacSHA256(regionName, kDate);
+		let kService = HmacSHA256(serviceName, kRegion);
+		let kSigning = HmacSHA256("aws4_request", kService);
+
+
+		let hexKDate = HexEncode(kDate);
+		if (expectedKDate != hexKDate) {
+			throw new Error("Wrong kDate: expected '" + expectedKDate + "' got '" + hexKDate + "'");
+		}
+		let hexKRegion = HexEncode(kRegion);
+		if (expectedKRegion != hexKRegion) {
+			throw new Error("Wrong kRegion: expected '" + expectedKRegion + "' got '" + hexKRegion + "'");
+		}
+		let hexKService = HexEncode(kService);
+		if (expectedKService != hexKService) {
+			throw new Error("Wrong kService: expected '" + expectedKService + "' got '" + hexKService + "'");
+		}
+		let hexKSigning = HexEncode(kSigning);
+		if (expectedKSigning != hexKSigning) {
+			throw new Error("Wrong kSigning: expected '" + expectedKSigning + "' got '" + hexKSigning + "'");
+		}
+		`)
+	assert.NoError(t, err)
+}
