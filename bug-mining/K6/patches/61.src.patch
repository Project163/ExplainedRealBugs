diff --git a/core/local/local.go b/core/local/local.go
index fc7a608df..e130475a0 100644
--- a/core/local/local.go
+++ b/core/local/local.go
@@ -63,10 +63,14 @@ func (h *vuHandle) run(logger *log.Logger, flow <-chan int64, out chan<- []stats
 		if h.vu != nil {
 			s, err := h.vu.RunOnce(ctx)
 			if err != nil {
-				if s, ok := err.(fmt.Stringer); ok {
-					logger.Error(s.String())
-				} else {
-					logger.Error(err.Error())
+				select {
+				case <-ctx.Done():
+				default:
+					if s, ok := err.(fmt.Stringer); ok {
+						logger.Error(s.String())
+					} else {
+						logger.Error(err.Error())
+					}
 				}
 			}
 			samples = s
diff --git a/core/local/local_test.go b/core/local/local_test.go
index c04bdf996..c7ac3eca1 100644
--- a/core/local/local_test.go
+++ b/core/local/local_test.go
@@ -29,6 +29,7 @@ import (
 	"github.com/loadimpact/k6/lib"
 	"github.com/loadimpact/k6/lib/metrics"
 	"github.com/loadimpact/k6/stats"
+	"github.com/pkg/errors"
 	logtest "github.com/sirupsen/logrus/hooks/test"
 	"github.com/stretchr/testify/assert"
 	null "gopkg.in/guregu/null.v3"
@@ -98,6 +99,48 @@ func TestExecutorEndTime(t *testing.T) {
 	startTime := time.Now()
 	assert.NoError(t, e.Run(context.Background(), nil))
 	assert.True(t, time.Now().After(startTime.Add(1*time.Second)), "test did not take 1s")
+
+	t.Run("Runtime Errors", func(t *testing.T) {
+		e := New(lib.RunnerFunc(func(ctx context.Context) ([]stats.Sample, error) {
+			return nil, errors.New("hi")
+		}))
+		assert.NoError(t, e.SetVUsMax(10))
+		assert.NoError(t, e.SetVUs(10))
+		e.SetEndTime(lib.NullDurationFrom(100 * time.Millisecond))
+		assert.Equal(t, lib.NullDurationFrom(100*time.Millisecond), e.GetEndTime())
+
+		l, hook := logtest.NewNullLogger()
+		e.SetLogger(l)
+
+		startTime := time.Now()
+		assert.NoError(t, e.Run(context.Background(), nil))
+		assert.True(t, time.Now().After(startTime.Add(100*time.Millisecond)), "test did not take 100ms")
+
+		assert.NotEmpty(t, hook.Entries)
+		for _, e := range hook.Entries {
+			assert.Equal(t, "hi", e.Message)
+		}
+	})
+
+	t.Run("End Errors", func(t *testing.T) {
+		e := New(lib.RunnerFunc(func(ctx context.Context) ([]stats.Sample, error) {
+			<-ctx.Done()
+			return nil, errors.New("hi")
+		}))
+		assert.NoError(t, e.SetVUsMax(10))
+		assert.NoError(t, e.SetVUs(10))
+		e.SetEndTime(lib.NullDurationFrom(100 * time.Millisecond))
+		assert.Equal(t, lib.NullDurationFrom(100*time.Millisecond), e.GetEndTime())
+
+		l, hook := logtest.NewNullLogger()
+		e.SetLogger(l)
+
+		startTime := time.Now()
+		assert.NoError(t, e.Run(context.Background(), nil))
+		assert.True(t, time.Now().After(startTime.Add(100*time.Millisecond)), "test did not take 100ms")
+
+		assert.Empty(t, hook.Entries)
+	})
 }
 
 func TestExecutorEndIterations(t *testing.T) {
