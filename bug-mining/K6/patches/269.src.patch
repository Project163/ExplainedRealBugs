diff --git a/internal/js/bundle_test.go b/internal/js/bundle_test.go
index bc3f564b8..04c50e9ea 100644
--- a/internal/js/bundle_test.go
+++ b/internal/js/bundle_test.go
@@ -640,6 +640,11 @@ func TestOpen(t *testing.T) {
 			openPath: "/path/to/file.txt",
 			pwd:      "/path",
 		},
+		{
+			name:     "file scheme",
+			openPath: "file:///path/to/file.txt",
+			pwd:      "/path",
+		},
 		{
 			name:     "file is dir",
 			openPath: "/path/to/",
@@ -687,6 +692,10 @@ func TestOpen(t *testing.T) {
 			filePath := filepath.Join(prefix, "/path/to/file.txt")
 			require.NoError(t, fs.MkdirAll(filepath.Join(prefix, "/path/to"), 0o755))
 			require.NoError(t, fsext.WriteFile(fs, filePath, []byte(`hi`), 0o644))
+			fs = fsext.NewChangePathFs(fs, func(name string) (string, error) {
+				// Drop the prefix effectively building something like https://pkg.go.dev/os#DirFS
+				return filepath.Join(prefix, name), nil
+			})
 			if isWindows {
 				fs = fsext.NewTrimFilePathSeparatorFs(fs)
 			}
@@ -705,14 +714,11 @@ func TestOpen(t *testing.T) {
 
 				testFunc := func(t *testing.T) {
 					t.Parallel()
-					fs, prefix, cleanUp := fsInit()
+					fs, _, cleanUp := fsInit()
 					defer cleanUp()
 					fs = fsext.NewReadOnlyFs(fs)
 					openPath := tCase.openPath
 					// if fullpath prepend prefix
-					if openPath != "" && (openPath[0] == '/' || openPath[0] == '\\') {
-						openPath = filepath.Join(prefix, openPath)
-					}
 					if isWindows {
 						openPath = strings.ReplaceAll(openPath, `\`, `\\`)
 					}
@@ -724,7 +730,7 @@ func TestOpen(t *testing.T) {
 						export let file = open("` + openPath + `");
 						export default function() { return file };`
 
-					sourceBundle, err := getSimpleBundle(t, filepath.ToSlash(filepath.Join(prefix, pwd, "script.js")), data, fs)
+					sourceBundle, err := getSimpleBundle(t, filepath.ToSlash(filepath.Join(pwd, "script.js")), data, fs)
 					if tCase.isError {
 						require.Error(t, err)
 						return
diff --git a/internal/js/initcontext.go b/internal/js/initcontext.go
index b4997b3d9..8fcb9f626 100644
--- a/internal/js/initcontext.go
+++ b/internal/js/initcontext.go
@@ -4,6 +4,7 @@ import (
 	"errors"
 	"fmt"
 	"net/url"
+	"strings"
 
 	"github.com/grafana/sobek"
 	"github.com/sirupsen/logrus"
@@ -19,6 +20,8 @@ const cantBeUsedOutsideInitContextMsg = `the "%s" function is only available in
 // contents of a file. If the second argument is "b" it returns an ArrayBuffer
 // instance, otherwise a string representation.
 func openImpl(rt *sobek.Runtime, fs fsext.Fs, basePWD *url.URL, filename string, args ...string) (sobek.Value, error) {
+	// Strip file scheme if available as we should support only this scheme
+	filename = strings.TrimPrefix(filename, "file://")
 	data, err := readFile(fs, fsext.Abs(basePWD.Path, filename))
 	if err != nil {
 		return nil, err
diff --git a/internal/js/modules/k6/experimental/fs/module.go b/internal/js/modules/k6/experimental/fs/module.go
index 9045d8210..34aee8adc 100644
--- a/internal/js/modules/k6/experimental/fs/module.go
+++ b/internal/js/modules/k6/experimental/fs/module.go
@@ -9,6 +9,7 @@ import (
 	"fmt"
 	"io"
 	"reflect"
+	"strings"
 
 	"go.k6.io/k6/lib/fsext"
 
@@ -102,6 +103,8 @@ func (mi *ModuleInstance) Open(path sobek.Value) *sobek.Promise {
 
 func (mi *ModuleInstance) openImpl(path string) (*File, error) {
 	initEnv := mi.vu.InitEnv()
+	// Strip file scheme if available as we should support only this scheme
+	path = strings.TrimPrefix(path, "file://")
 
 	// We resolve the path relative to the entrypoint script, as opposed to
 	// the current working directory (the k6 command is called from).
diff --git a/internal/js/modules/k6/experimental/fs/module_test.go b/internal/js/modules/k6/experimental/fs/module_test.go
index fddd59c64..4302b8e69 100644
--- a/internal/js/modules/k6/experimental/fs/module_test.go
+++ b/internal/js/modules/k6/experimental/fs/module_test.go
@@ -33,6 +33,11 @@ func TestOpen(t *testing.T) {
 				openPath: fsext.FilePathSeparator + testFileName,
 				wantPath: fsext.FilePathSeparator + testFileName,
 			},
+			{
+				name:     "open file absolute path",
+				openPath: "file://" + fsext.FilePathSeparator + testFileName,
+				wantPath: fsext.FilePathSeparator + testFileName,
+			},
 			{
 				name:     "open relative path",
 				openPath: filepath.Join(".", fsext.FilePathSeparator, testFileName),
diff --git a/internal/js/modules/k6/grpc/client.go b/internal/js/modules/k6/grpc/client.go
index 20b507829..b04c7d36e 100644
--- a/internal/js/modules/k6/grpc/client.go
+++ b/internal/js/modules/k6/grpc/client.go
@@ -54,6 +54,11 @@ func (c *Client) Load(importPaths []string, filenames ...string) ([]MethodInfo,
 		importPaths = append(importPaths, initEnv.CWD.Path)
 	}
 
+	for i, s := range importPaths {
+		// Clean file scheme as it is the only supported scheme and the following APIs do not support them
+		importPaths[i] = strings.TrimPrefix(s, "file://")
+	}
+
 	parser := protoparse.Parser{
 		ImportPaths:      importPaths,
 		InferImportPaths: false,
diff --git a/internal/js/modules/k6/grpc/client_test.go b/internal/js/modules/k6/grpc/client_test.go
index e9dd8c864..358bfc1cf 100644
--- a/internal/js/modules/k6/grpc/client_test.go
+++ b/internal/js/modules/k6/grpc/client_test.go
@@ -1374,7 +1374,6 @@ func TestClientLoadProto(t *testing.T) {
 	ts := newTestState(t)
 
 	tt := testcase{
-		name: "LoadNestedTypesProto",
 		initString: codeBlock{
 			code: `
 			var client = new grpc.Client();
@@ -1402,6 +1401,40 @@ func TestClientLoadProto(t *testing.T) {
 	}
 }
 
+func TestClientLoadProtoAbsoluteRootWithFile(t *testing.T) {
+	t.Parallel()
+
+	ts := newTestState(t)
+	rootPath := ts.VU.InitEnvField.CWD.JoinPath("../..").String()
+
+	tt := testcase{
+		initString: codeBlock{
+			code: `
+			var client = new grpc.Client();
+			client.load(["` + rootPath + `"], "../../lib/testutils/httpmultibin/nested_types/nested_types.proto");`,
+		},
+	}
+
+	val, err := ts.Run(tt.initString.code)
+	assertResponse(t, tt.initString, err, val, ts)
+
+	expectedTypes := []string{
+		"grpc.testdata.nested.types.Outer",
+		"grpc.testdata.nested.types.Outer.MiddleAA",
+		"grpc.testdata.nested.types.Outer.MiddleAA.Inner",
+		"grpc.testdata.nested.types.Outer.MiddleBB",
+		"grpc.testdata.nested.types.Outer.MiddleBB.Inner",
+		"grpc.testdata.nested.types.MeldOuter",
+	}
+
+	for _, expected := range expectedTypes {
+		found, err := protoregistry.GlobalTypes.FindMessageByName(protoreflect.FullName(expected))
+
+		assert.NotNil(t, found, "Expected to find the message type %s, but an error occurred", expected)
+		assert.Nil(t, err, "It was not expected that there would be an error, but it got: %v", err)
+	}
+}
+
 func TestClientConnectionReflectMetadata(t *testing.T) {
 	t.Parallel()
 
diff --git a/internal/js/modules/k6/grpc/teststate_test.go b/internal/js/modules/k6/grpc/teststate_test.go
index 830eef515..d81373786 100644
--- a/internal/js/modules/k6/grpc/teststate_test.go
+++ b/internal/js/modules/k6/grpc/teststate_test.go
@@ -4,6 +4,7 @@ import (
 	"io"
 	"net/url"
 	"os"
+	"path/filepath"
 	"runtime"
 	"sync"
 	"testing"
@@ -108,7 +109,7 @@ func newTestState(t *testing.T) testState {
 	if isWindows {
 		fs = fsext.NewTrimFilePathSeparatorFs(fs)
 	}
-	testRuntime.VU.InitEnvField.CWD = &url.URL{Path: cwd}
+	testRuntime.VU.InitEnvField.CWD = &url.URL{Scheme: "file", Path: filepath.ToSlash(cwd)}
 	testRuntime.VU.InitEnvField.FileSystems = map[string]fsext.Fs{"file": fs}
 
 	logger := logrus.New()
