diff --git a/cmd/run.go b/cmd/run.go
index aafeeaab0..69162bca2 100644
--- a/cmd/run.go
+++ b/cmd/run.go
@@ -237,17 +237,16 @@ a commandline interface for interacting with it.`,
 		{
 			out := "-"
 			link := ""
-			if engine.Collectors != nil {
-				for idx, collector := range engine.Collectors {
-					if out != "-" {
-						out = out + "; " + conf.Out[idx]
-					} else {
-						out = conf.Out[idx]
-					}
 
-					if l := collector.Link(); l != "" {
-						link = link + " (" + l + ")"
-					}
+			for idx, collector := range engine.Collectors {
+				if out != "-" {
+					out = out + "; " + conf.Out[idx]
+				} else {
+					out = conf.Out[idx]
+				}
+
+				if l := collector.Link(); l != "" {
+					link = link + " (" + l + ")"
 				}
 			}
 
diff --git a/core/engine.go b/core/engine.go
index 96344b662..5189a30c2 100644
--- a/core/engine.go
+++ b/core/engine.go
@@ -110,10 +110,6 @@ func NewEngine(ex lib.Executor, o lib.Options) (*Engine, error) {
 }
 
 func (e *Engine) setRunStatus(status lib.RunStatus) {
-	if len(e.Collectors) == 0 {
-		return
-	}
-
 	for _, c := range e.Collectors {
 		c.SetRunStatus(status)
 	}
@@ -146,14 +142,13 @@ func (e *Engine) Run(ctx context.Context) error {
 
 	collectorwg := sync.WaitGroup{}
 	collectorctx, collectorcancel := context.WithCancel(context.Background())
-	if len(e.Collectors) > 0 {
-		for _, collector := range e.Collectors {
-			collectorwg.Add(1)
-			go func(collector lib.Collector) {
-				collector.Run(collectorctx)
-				collectorwg.Done()
-			}(collector)
-		}
+
+	for _, collector := range e.Collectors {
+		collectorwg.Add(1)
+		go func(collector lib.Collector) {
+			collector.Run(collectorctx)
+			collectorwg.Done()
+		}(collector)
 	}
 
 	subctx, subcancel := context.WithCancel(context.Background())
@@ -205,9 +200,8 @@ func (e *Engine) Run(ctx context.Context) error {
 		for sc := range e.Samples {
 			sampleContainers = append(sampleContainers, sc)
 		}
-		if len(sampleContainers) > 0 {
-			e.processSamples(sampleContainers)
-		}
+
+		e.processSamples(sampleContainers)
 
 		// Emit final metrics.
 		e.emitMetrics()
@@ -382,8 +376,8 @@ func (e *Engine) processSamplesForMetrics(sampleCointainers []stats.SampleContai
 	}
 }
 
-func (e *Engine) processSamples(sampleCointainers []stats.SampleContainer) {
-	if len(sampleCointainers) == 0 {
+func (e *Engine) processSamples(sampleContainers []stats.SampleContainer) {
+	if len(sampleContainers) == 0 {
 		return
 	}
 
@@ -393,12 +387,10 @@ func (e *Engine) processSamples(sampleCointainers []stats.SampleContainer) {
 
 	// TODO: run this and the below code in goroutines?
 	if !(e.NoSummary && e.NoThresholds) {
-		e.processSamplesForMetrics(sampleCointainers)
+		e.processSamplesForMetrics(sampleContainers)
 	}
 
-	if len(e.Collectors) > 0 {
-		for _, collector := range e.Collectors {
-			collector.Collect(sampleCointainers)
-		}
+	for _, collector := range e.Collectors {
+		collector.Collect(sampleContainers)
 	}
 }
diff --git a/stats/cloud/collector.go b/stats/cloud/collector.go
index de0f799e0..f112c2180 100644
--- a/stats/cloud/collector.go
+++ b/stats/cloud/collector.go
@@ -253,6 +253,12 @@ func (c *Collector) Run(ctx context.Context) {
 // Collect receives a set of samples. This method is never called concurrently, and only while
 // the context for Run() is valid, but should defer as much work as possible to Run().
 func (c *Collector) Collect(sampleContainers []stats.SampleContainer) {
+	select {
+	case <-c.stopSendingMetricsCh:
+		return
+	default:
+	}
+
 	if c.referenceID == "" {
 		return
 	}
diff --git a/stats/cloud/collector_test.go b/stats/cloud/collector_test.go
index 5c4dddb56..a9af6c16c 100644
--- a/stats/cloud/collector_test.go
+++ b/stats/cloud/collector_test.go
@@ -459,6 +459,18 @@ func TestCloudCollectorStopSendingMetric(t *testing.T) {
 	_, ok := <-collector.stopSendingMetricsCh
 	require.False(t, ok)
 	require.Equal(t, max, count)
+
+	nBufferSamples := len(collector.bufferSamples)
+	nBufferHTTPTrails := len(collector.bufferHTTPTrails)
+	collector.Collect([]stats.SampleContainer{stats.Sample{
+		Time:   now,
+		Metric: metrics.VUs,
+		Tags:   stats.NewSampleTags(tags.CloneTags()),
+		Value:  1.0,
+	}})
+	if nBufferSamples != len(collector.bufferSamples) || nBufferHTTPTrails != len(collector.bufferHTTPTrails) {
+		t.Errorf("Collector still collects data after stop sending metrics")
+	}
 }
 
 func TestCloudCollectorAggregationPeriodZeroNoBlock(t *testing.T) {
