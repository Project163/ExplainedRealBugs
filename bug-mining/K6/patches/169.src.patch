diff --git a/js/bundle.go b/js/bundle.go
index d4460de39..6ec7cf0f6 100644
--- a/js/bundle.go
+++ b/js/bundle.go
@@ -21,6 +21,7 @@
 package js
 
 import (
+	"bytes"
 	"context"
 	"encoding/json"
 	"net/url"
@@ -99,7 +100,7 @@ func NewBundle(
 		return nil, err
 	}
 
-	err = bundle.getExports(rt, true)
+	err = bundle.getExports(logger, rt, true)
 	if err != nil {
 		return nil, err
 	}
@@ -159,7 +160,7 @@ func NewBundleFromArchive(logger logrus.FieldLogger, arc *lib.Archive, rtOpts li
 
 	// Grab exported objects, but avoid overwriting options, which would
 	// be initialized from the metadata.json at this point.
-	err = bundle.getExports(rt, false)
+	err = bundle.getExports(logger, rt, false)
 	if err != nil {
 		return nil, err
 	}
@@ -189,7 +190,7 @@ func (b *Bundle) makeArchive() *lib.Archive {
 }
 
 // getExports validates and extracts exported objects
-func (b *Bundle) getExports(rt *goja.Runtime, options bool) error {
+func (b *Bundle) getExports(logger logrus.FieldLogger, rt *goja.Runtime, options bool) error {
 	exportsV := rt.Get("exports")
 	if goja.IsNull(exportsV) || goja.IsUndefined(exportsV) {
 		return errors.New("exports must be an object")
@@ -211,8 +212,13 @@ func (b *Bundle) getExports(rt *goja.Runtime, options bool) error {
 			if err != nil {
 				return err
 			}
-			if err := json.Unmarshal(data, &b.Options); err != nil {
-				return err
+			dec := json.NewDecoder(bytes.NewReader(data))
+			dec.DisallowUnknownFields()
+			if err := dec.Decode(&b.Options); err != nil {
+				if uerr := json.Unmarshal(data, &b.Options); uerr != nil {
+					return uerr
+				}
+				logger.WithError(err).Warn("There were unknown fields in the options exported in the script")
 			}
 		case consts.SetupFn:
 			return errors.New("exported 'setup' must be a function")
diff --git a/js/bundle_test.go b/js/bundle_test.go
index c8723b379..93c565f6b 100644
--- a/js/bundle_test.go
+++ b/js/bundle_test.go
@@ -33,6 +33,7 @@ import (
 	"time"
 
 	"github.com/dop251/goja"
+	"github.com/sirupsen/logrus"
 	"github.com/spf13/afero"
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
@@ -50,8 +51,9 @@ const isWindows = runtime.GOOS == "windows"
 
 func getSimpleBundle(tb testing.TB, filename, data string, opts ...interface{}) (*Bundle, error) {
 	var (
-		fs     = afero.NewMemMapFs()
-		rtOpts = lib.RuntimeOptions{}
+		fs                        = afero.NewMemMapFs()
+		rtOpts                    = lib.RuntimeOptions{}
+		logger logrus.FieldLogger = testutils.NewLogger(tb)
 	)
 	for _, o := range opts {
 		switch opt := o.(type) {
@@ -59,10 +61,12 @@ func getSimpleBundle(tb testing.TB, filename, data string, opts ...interface{})
 			fs = opt
 		case lib.RuntimeOptions:
 			rtOpts = opt
+		case logrus.FieldLogger:
+			logger = opt
 		}
 	}
 	return NewBundle(
-		testutils.NewLogger(tb),
+		logger,
 		&loader.SourceData{
 			URL:  &url.URL{Path: filename, Scheme: "file"},
 			Data: []byte(data),
@@ -419,6 +423,31 @@ func TestNewBundle(t *testing.T) {
 				}
 			}
 		})
+
+		t.Run("Unknown field", func(t *testing.T) {
+			logger := logrus.New()
+			logger.SetLevel(logrus.InfoLevel)
+			logger.Out = ioutil.Discard
+			hook := testutils.SimpleLogrusHook{
+				HookedLevels: []logrus.Level{logrus.WarnLevel, logrus.InfoLevel, logrus.ErrorLevel, logrus.FatalLevel, logrus.PanicLevel},
+			}
+			logger.AddHook(&hook)
+
+			_, err := getSimpleBundle(t, "/script.js", `
+				export let options = {
+					something: {
+						http_req_duration: ["avg<100"],
+					},
+				};
+				export default function() {};
+			`, logger)
+			require.NoError(t, err)
+			entries := hook.Drain()
+			require.Len(t, entries, 1)
+			assert.Equal(t, logrus.WarnLevel, entries[0].Level)
+			require.Contains(t, entries[0].Message, "There were unknown fields")
+			require.Contains(t, entries[0].Data["error"].(error).Error(), "unknown field \"something\"")
+		})
 	})
 }
 
