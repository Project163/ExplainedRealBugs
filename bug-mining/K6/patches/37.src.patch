diff --git a/lib/engine.go b/lib/engine.go
index 4abd5f233..8b2ee07f4 100644
--- a/lib/engine.go
+++ b/lib/engine.go
@@ -55,39 +55,6 @@ type vuEntry struct {
 	lock       sync.Mutex
 }
 
-type submetric struct {
-	Name       string
-	Conditions map[string]string
-	Metric     *stats.Metric
-}
-
-func parseSubmetric(name string) (string, map[string]string) {
-	halves := strings.SplitN(strings.TrimSuffix(name, "}"), "{", 2)
-	if len(halves) != 2 {
-		return halves[0], nil
-	}
-
-	kvs := strings.Split(halves[1], ",")
-	conditions := make(map[string]string, len(kvs))
-	for _, kv := range kvs {
-		if kv == "" {
-			continue
-		}
-
-		parts := strings.SplitN(kv, ":", 2)
-
-		key := strings.TrimSpace(strings.Trim(parts[0], `"'`))
-		if len(parts) != 2 {
-			conditions[key] = ""
-			continue
-		}
-
-		value := strings.TrimSpace(strings.Trim(parts[1], `"'`))
-		conditions[key] = value
-	}
-	return halves[0], conditions
-}
-
 // The Engine is the beating heart of K6.
 type Engine struct {
 	Runner    Runner
@@ -101,8 +68,7 @@ type Engine struct {
 
 	// Assigned to metrics upon first received sample.
 	thresholds map[string]stats.Thresholds
-	// Submetrics, mapped from parent metric names.
-	submetrics map[string][]*submetric
+	submetrics map[string][]stats.Submetric
 
 	// Stage tracking.
 	atTime          time.Duration
@@ -170,17 +136,14 @@ func NewEngine(r Runner, o Options) (*Engine, error) {
 	}
 	if o.Thresholds != nil {
 		e.thresholds = o.Thresholds
-		e.submetrics = make(map[string][]*submetric)
+		e.submetrics = make(map[string][]stats.Submetric)
 		for name := range e.thresholds {
 			if !strings.Contains(name, "{") {
 				continue
 			}
 
-			parent, conds := parseSubmetric(name)
-			e.submetrics[parent] = append(e.submetrics[parent], &submetric{
-				Name:       name,
-				Conditions: conds,
-			})
+			parent, sm := stats.NewSubmetric(name)
+			e.submetrics[parent] = append(e.submetrics[parent], sm)
 		}
 	}
 
@@ -760,13 +723,14 @@ func (e *Engine) processSamples(samples ...stats.Sample) {
 		if !ok {
 			m = sample.Metric
 			m.Thresholds = e.thresholds[m.Name]
+			m.Submetrics = e.submetrics[m.Name]
 			e.Metrics[m.Name] = m
 		}
 		m.Sink.Add(sample)
 
-		for _, sm := range e.submetrics[sample.Metric.Name] {
+		for _, sm := range m.Submetrics {
 			passing := true
-			for k, v := range sm.Conditions {
+			for k, v := range sm.Tags {
 				if sample.Tags[k] != v {
 					passing = false
 					break
diff --git a/lib/engine_test.go b/lib/engine_test.go
index 1cedd9c5a..d7ff55b0b 100644
--- a/lib/engine_test.go
+++ b/lib/engine_test.go
@@ -77,34 +77,6 @@ func assertActiveVUs(t *testing.T, e *Engine, active, dead int) {
 	assert.Equal(t, dead, numDead, "wrong number of dead vus")
 }
 
-func Test_parseSubmetric(t *testing.T) {
-	testdata := map[string]struct {
-		parent string
-		conds  map[string]string
-	}{
-		"my_metric":                 {"my_metric", nil},
-		"my_metric{}":               {"my_metric", map[string]string{}},
-		"my_metric{a}":              {"my_metric", map[string]string{"a": ""}},
-		"my_metric{a:1}":            {"my_metric", map[string]string{"a": "1"}},
-		"my_metric{ a : 1 }":        {"my_metric", map[string]string{"a": "1"}},
-		"my_metric{a,b}":            {"my_metric", map[string]string{"a": "", "b": ""}},
-		"my_metric{a:1,b:2}":        {"my_metric", map[string]string{"a": "1", "b": "2"}},
-		"my_metric{ a : 1, b : 2 }": {"my_metric", map[string]string{"a": "1", "b": "2"}},
-	}
-
-	for name, data := range testdata {
-		t.Run(name, func(t *testing.T) {
-			parent, conds := parseSubmetric(name)
-			assert.Equal(t, data.parent, parent)
-			if data.conds != nil {
-				assert.EqualValues(t, data.conds, conds)
-			} else {
-				assert.Nil(t, conds)
-			}
-		})
-	}
-}
-
 func TestNewEngine(t *testing.T) {
 	_, err, _ := newTestEngine(nil, Options{})
 	assert.NoError(t, err)
@@ -921,7 +893,6 @@ func TestEngine_processSamples(t *testing.T) {
 
 		assert.IsType(t, &stats.GaugeSink{}, e.Metrics["my_metric"].Sink)
 	})
-
 	t.Run("submetric", func(t *testing.T) {
 		ths, err := stats.NewThresholds([]string{`1+1==2`})
 		assert.NoError(t, err)
@@ -936,7 +907,7 @@ func TestEngine_processSamples(t *testing.T) {
 		sms := e.submetrics["my_metric"]
 		assert.Len(t, sms, 1)
 		assert.Equal(t, "my_metric{a:1}", sms[0].Name)
-		assert.EqualValues(t, map[string]string{"a": "1"}, sms[0].Conditions)
+		assert.EqualValues(t, map[string]string{"a": "1"}, sms[0].Tags)
 
 		e.processSamples(
 			stats.Sample{Metric: metric, Value: 1.25, Tags: map[string]string{"a": "1"}},
diff --git a/stats/stats.go b/stats/stats.go
index 09e3c26b9..896d33918 100644
--- a/stats/stats.go
+++ b/stats/stats.go
@@ -25,6 +25,8 @@ import (
 	"strconv"
 	"time"
 
+	"strings"
+
 	"github.com/dustin/go-humanize"
 	"gopkg.in/guregu/null.v3"
 )
@@ -169,12 +171,13 @@ type Sample struct {
 
 // A Metric defines the shape of a set of data.
 type Metric struct {
-	Name       string     `json:"-"`
-	Type       MetricType `json:"type"`
-	Contains   ValueType  `json:"contains"`
-	Tainted    null.Bool  `json:"tainted"`
-	Sink       Sink       `json:"sink"`
-	Thresholds Thresholds `json:"thresholds"`
+	Name       string      `json:"-"`
+	Type       MetricType  `json:"type"`
+	Contains   ValueType   `json:"contains"`
+	Tainted    null.Bool   `json:"tainted"`
+	Sink       Sink        `json:"sink"`
+	Thresholds Thresholds  `json:"thresholds"`
+	Submetrics []Submetric `json:"submetrics"`
 }
 
 func New(name string, typ MetricType, t ...ValueType) *Metric {
@@ -224,3 +227,37 @@ func (m Metric) HumanizeValue(v float64) string {
 		}
 	}
 }
+
+// A Submetric represents a filtered dataset based on a parent metric.
+type Submetric struct {
+	Name   string            `json:"name"`
+	Tags   map[string]string `json:"tags"`
+	Metric *Metric           `json:"metric"`
+}
+
+// Creates a submetric from a name.
+func NewSubmetric(name string) (parentName string, sm Submetric) {
+	parts := strings.SplitN(strings.TrimSuffix(name, "}"), "{", 2)
+	if len(parts) == 1 {
+		return parts[0], Submetric{Name: name}
+	}
+
+	kvs := strings.Split(parts[1], ",")
+	tags := make(map[string]string, len(kvs))
+	for _, kv := range kvs {
+		if kv == "" {
+			continue
+		}
+		parts := strings.SplitN(kv, ":", 2)
+
+		key := strings.TrimSpace(strings.Trim(parts[0], `"'`))
+		if len(parts) != 2 {
+			tags[key] = ""
+			continue
+		}
+
+		value := strings.TrimSpace(strings.Trim(parts[1], `"'`))
+		tags[key] = value
+	}
+	return parts[0], Submetric{Name: name, Tags: tags}
+}
diff --git a/stats/stats_test.go b/stats/stats_test.go
index fc0ffee74..ad475549a 100644
--- a/stats/stats_test.go
+++ b/stats/stats_test.go
@@ -144,3 +144,31 @@ func TestNew(t *testing.T) {
 		})
 	}
 }
+
+func TestNewSubmetric(t *testing.T) {
+	testdata := map[string]struct {
+		parent string
+		tags   map[string]string
+	}{
+		"my_metric":                 {"my_metric", nil},
+		"my_metric{}":               {"my_metric", map[string]string{}},
+		"my_metric{a}":              {"my_metric", map[string]string{"a": ""}},
+		"my_metric{a:1}":            {"my_metric", map[string]string{"a": "1"}},
+		"my_metric{ a : 1 }":        {"my_metric", map[string]string{"a": "1"}},
+		"my_metric{a,b}":            {"my_metric", map[string]string{"a": "", "b": ""}},
+		"my_metric{a:1,b:2}":        {"my_metric", map[string]string{"a": "1", "b": "2"}},
+		"my_metric{ a : 1, b : 2 }": {"my_metric", map[string]string{"a": "1", "b": "2"}},
+	}
+
+	for name, data := range testdata {
+		t.Run(name, func(t *testing.T) {
+			parent, sm := NewSubmetric(name)
+			assert.Equal(t, data.parent, parent)
+			if data.tags != nil {
+				assert.EqualValues(t, data.tags, sm.Tags)
+			} else {
+				assert.Nil(t, sm.Tags)
+			}
+		})
+	}
+}
