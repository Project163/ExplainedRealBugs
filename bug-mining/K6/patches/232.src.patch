diff --git a/cmd/test_load.go b/cmd/test_load.go
index 8ad2d5a00..510a27cec 100644
--- a/cmd/test_load.go
+++ b/cmd/test_load.go
@@ -3,12 +3,14 @@ package cmd
 import (
 	"archive/tar"
 	"bytes"
+	"crypto/x509"
 	"fmt"
 	"io"
 	"os"
 	"path/filepath"
 	"sync"
 
+	"github.com/sirupsen/logrus"
 	"github.com/spf13/afero"
 	"github.com/spf13/cobra"
 	"github.com/spf13/pflag"
@@ -240,6 +242,13 @@ func loadAndConfigureTest(
 	return test.consolidateDeriveAndValidateConfig(gs, cmd, cliConfigGetter)
 }
 
+// loadSystemCertPool attempts to load system certificates.
+func loadSystemCertPool(logger *logrus.Logger) {
+	if _, err := x509.SystemCertPool(); err != nil {
+		logger.WithError(err).Warning("Unable to load system cert pool")
+	}
+}
+
 func (lct *loadedAndConfiguredTest) buildTestRunState(
 	configToReinject lib.Options,
 ) (*lib.TestRunState, error) {
@@ -248,6 +257,10 @@ func (lct *loadedAndConfiguredTest) buildTestRunState(
 		return nil, err
 	}
 
+	// it pre-loads system certificates to avoid doing it on the first TLS request.
+	// This is done async to avoid blocking the rest of the loading process as it will not stop if it fails.
+	go loadSystemCertPool(lct.preInitState.Logger)
+
 	return &lib.TestRunState{
 		TestPreInitState: lct.preInitState,
 		Runner:           lct.initRunner,
diff --git a/cmd/tls_integration_test.go b/cmd/tls_integration_test.go
new file mode 100644
index 000000000..e504942de
--- /dev/null
+++ b/cmd/tls_integration_test.go
@@ -0,0 +1,74 @@
+package cmd
+
+// TODO: convert this into the integration tests, once https://github.com/grafana/k6/issues/2459 will be done
+
+import (
+	"bytes"
+	"encoding/json"
+	"testing"
+
+	"github.com/spf13/afero"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	"go.k6.io/k6/lib/testutils/httpmultibin"
+)
+
+type metric struct {
+	Avg float64 `json:"avg"`
+	Min float64 `json:"min"`
+	P95 float64 `json:"p(95)"`
+}
+
+type summaryMetrics struct {
+	HTTPReqTLSHandshaking metric `json:"http_req_tls_handshaking"`
+}
+
+type summaryMetricsWrapper struct {
+	Metrics summaryMetrics `json:"metrics"`
+}
+
+func TestTLSLoadSystemCertificates(t *testing.T) {
+	t.Parallel()
+
+	summaryFilename := "summary.json"
+
+	tb := httpmultibin.NewHTTPMultiBin(t)
+	testState := newGlobalTestState(t)
+	testState.args = []string{"k6", "run", "--no-connection-reuse", "--summary-export", summaryFilename, "-i", "2", "-"}
+	testState.stdIn = bytes.NewReader([]byte(tb.Replacer.Replace(`
+		import http from "k6/http"
+		export const options = {
+		hosts: {
+			"HTTPSBIN_DOMAIN": "HTTPSBIN_IP",
+		},
+		insecureSkipTLSVerify: true,
+		}
+
+		export default () => {
+		http.get("HTTPSBIN_URL/get");
+		}
+  `)))
+	newRootCommand(testState.globalState).execute()
+
+	content, err := afero.ReadFile(testState.fs, summaryFilename)
+	require.NoError(t, err)
+
+	var summaryMetricsWrapperContent summaryMetricsWrapper
+	err = json.Unmarshal(content, &summaryMetricsWrapperContent)
+	require.NoError(t, err)
+
+	delta := 10.0
+	assert.InDelta(
+		t,
+		summaryMetricsWrapperContent.Metrics.HTTPReqTLSHandshaking.Min,
+		summaryMetricsWrapperContent.Metrics.HTTPReqTLSHandshaking.Avg,
+		delta,
+	)
+
+	assert.InDelta(
+		t,
+		summaryMetricsWrapperContent.Metrics.HTTPReqTLSHandshaking.Min,
+		summaryMetricsWrapperContent.Metrics.HTTPReqTLSHandshaking.P95,
+		delta,
+	)
+}
