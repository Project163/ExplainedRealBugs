diff --git a/core/local/local.go b/core/local/local.go
index da3c0e127..0c4b61bcb 100644
--- a/core/local/local.go
+++ b/core/local/local.go
@@ -82,6 +82,7 @@ type Executor struct {
 	vusLock   sync.RWMutex
 	numVUs    int64
 	numVUsMax int64
+	nextVUID  int64
 
 	iters     int64 // Completed iterations
 	partIters int64 // Partial, incomplete iterations
@@ -165,7 +166,9 @@ func (e *Executor) Run(parent context.Context, out chan<- []stats.Sample) error
 		}
 	}()
 
-	e.scale(ctx, lib.Max(0, atomic.LoadInt64(&e.numVUs)))
+	if err := e.scale(ctx, lib.Max(0, atomic.LoadInt64(&e.numVUs))); err != nil {
+		return err
+	}
 
 	ticker := time.NewTicker(1 * time.Millisecond)
 	defer ticker.Stop()
@@ -239,7 +242,7 @@ func (e *Executor) Run(parent context.Context, out chan<- []stats.Sample) error
 	}
 }
 
-func (e *Executor) scale(ctx context.Context, num int64) {
+func (e *Executor) scale(ctx context.Context, num int64) error {
 	e.vusLock.Lock()
 	defer e.vusLock.Unlock()
 
@@ -262,6 +265,12 @@ func (e *Executor) scale(ctx context.Context, num int64) {
 				handle.cancel = cancel
 				handle.Unlock()
 
+				if handle.vu != nil {
+					if err := handle.vu.Reconfigure(atomic.AddInt64(&e.nextVUID, 1)); err != nil {
+						return err
+					}
+				}
+
 				e.wg.Add(1)
 				go func() {
 					handle.run(e.Logger, flow, out)
@@ -277,6 +286,7 @@ func (e *Executor) scale(ctx context.Context, num int64) {
 	}
 
 	atomic.StoreInt64(&e.numVUs, num)
+	return nil
 }
 
 func (e *Executor) IsRunning() bool {
@@ -371,7 +381,9 @@ func (e *Executor) SetVUs(num int64) error {
 	}
 
 	if ctx := e.ctx; ctx != nil {
-		e.scale(ctx, num)
+		if err := e.scale(ctx, num); err != nil {
+			return err
+		}
 	} else {
 		atomic.StoreInt64(&e.numVUs, num)
 	}
diff --git a/core/local/local_test.go b/core/local/local_test.go
index f10c28fcb..fe5bb6736 100644
--- a/core/local/local_test.go
+++ b/core/local/local_test.go
@@ -161,7 +161,9 @@ func TestExecutorSetVUs(t *testing.T) {
 			num := 0
 			for i, handle := range e.vus {
 				num++
-				assert.NotNil(t, handle.vu, "vu %d lacks impl", i)
+				if assert.NotNil(t, handle.vu, "vu %d lacks impl", i) {
+					assert.Equal(t, int64(0), handle.vu.(*lib.RunnerFuncVU).ID)
+				}
 				assert.Nil(t, handle.ctx, "vu %d has ctx", i)
 				assert.Nil(t, handle.cancel, "vu %d has cancel", i)
 			}
@@ -175,9 +177,11 @@ func TestExecutorSetVUs(t *testing.T) {
 			for i, handle := range e.vus {
 				if i < 50 {
 					assert.NotNil(t, handle.cancel, "vu %d lacks cancel", i)
+					assert.Equal(t, int64(i+1), handle.vu.(*lib.RunnerFuncVU).ID)
 					num++
 				} else {
 					assert.Nil(t, handle.cancel, "vu %d has cancel", i)
+					assert.Equal(t, int64(0), handle.vu.(*lib.RunnerFuncVU).ID)
 				}
 			}
 			assert.Equal(t, 50, num)
@@ -189,6 +193,7 @@ func TestExecutorSetVUs(t *testing.T) {
 			num := 0
 			for i, handle := range e.vus {
 				assert.NotNil(t, handle.cancel, "vu %d lacks cancel", i)
+				assert.Equal(t, int64(i+1), handle.vu.(*lib.RunnerFuncVU).ID)
 				num++
 			}
 			assert.Equal(t, 100, num)
@@ -206,9 +211,25 @@ func TestExecutorSetVUs(t *testing.T) {
 					} else {
 						assert.Nil(t, handle.cancel, "vu %d has cancel", i)
 					}
+					assert.Equal(t, int64(i+1), handle.vu.(*lib.RunnerFuncVU).ID)
 				}
 				assert.Equal(t, 50, num)
 			}
+
+			t.Run("Raise", func(t *testing.T) {
+				assert.NoError(t, e.SetVUs(100))
+				assert.Equal(t, int64(100), e.GetVUs())
+				if assert.Len(t, e.vus, 100) {
+					for i, handle := range e.vus {
+						assert.NotNil(t, handle.cancel, "vu %d lacks cancel", i)
+						if i < 50 {
+							assert.Equal(t, int64(i+1), handle.vu.(*lib.RunnerFuncVU).ID)
+						} else {
+							assert.Equal(t, int64(50+i+1), handle.vu.(*lib.RunnerFuncVU).ID)
+						}
+					}
+				}
+			})
 		})
 	})
 }
diff --git a/js/runner_test.go b/js/runner_test.go
index d48d40cb1..cfdf537a2 100644
--- a/js/runner_test.go
+++ b/js/runner_test.go
@@ -560,3 +560,36 @@ func TestVUIntegrationCookies(t *testing.T) {
 		})
 	}
 }
+
+func TestVUIntegrationVUID(t *testing.T) {
+	r1, err := New(&lib.SourceData{
+		Filename: "/script.js",
+		Data: []byte(`
+			export default function() {
+				if (__VU != 1234) { throw new Error("wrong __VU: " + __VU); }
+			}`,
+		),
+	}, afero.NewMemMapFs())
+	if !assert.NoError(t, err) {
+		return
+	}
+	r1.ApplyOptions(lib.Options{Throw: null.BoolFrom(true)})
+
+	r2, err := NewFromArchive(r1.MakeArchive())
+	if !assert.NoError(t, err) {
+		return
+	}
+
+	runners := map[string]*Runner{"Source": r1, "Archive": r2}
+	for name, r := range runners {
+		t.Run(name, func(t *testing.T) {
+			vu, err := r.NewVU()
+			if !assert.NoError(t, err) {
+				return
+			}
+			assert.NoError(t, vu.Reconfigure(1234))
+			_, err = vu.RunOnce(context.Background())
+			assert.NoError(t, err)
+		})
+	}
+}
