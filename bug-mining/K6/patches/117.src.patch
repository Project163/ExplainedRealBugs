diff --git a/core/engine_test.go b/core/engine_test.go
index 327c69d7f..dbb37bbc9 100644
--- a/core/engine_test.go
+++ b/core/engine_test.go
@@ -502,6 +502,7 @@ func getMetricCount(collector *dummy.Collector, name string) (result uint) {
 
 const expectedHeaderMaxLength = 500
 
+// FIXME: This test is too brittle, consider simplifying.
 func TestSentReceivedMetrics(t *testing.T) {
 	t.Parallel()
 	tb := httpmultibin.NewHTTPMultiBin(t)
@@ -532,10 +533,14 @@ func TestSentReceivedMetrics(t *testing.T) {
 					file: http.file(data, "test.txt")
 				});
 			}`), 1, 1000, 100},
+		// NOTE(imiric): This needs to keep testing against /ws-echo-invalid because
+		// this test is highly sensitive to metric data, and slightly differing
+		// WS server implementations might introduce flakiness.
+		// See https://github.com/loadimpact/k6/pull/1149
 		{tr(`import ws from "k6/ws";
 			let data = "0123456789".repeat(100);
 			export default function() {
-				ws.connect("WSBIN_URL/ws-echo", null, function (socket) {
+				ws.connect("WSBIN_URL/ws-echo-invalid", null, function (socket) {
 					socket.on('open', function open() {
 						socket.send(data);
 					});
diff --git a/js/modules/k6/ws/ws.go b/js/modules/k6/ws/ws.go
index 96146ca04..e5d0a9282 100644
--- a/js/modules/k6/ws/ws.go
+++ b/js/modules/k6/ws/ws.go
@@ -223,6 +223,13 @@ func (*WS) Connect(ctx context.Context, url string, args ...goja.Value) (*WSHTTP
 	// The connection is now open, emit the event
 	socket.handleEvent("open")
 
+	// Make the default close handler a noop to avoid duplicate closes,
+	// since we use custom closing logic to call user's event
+	// handlers and for cleanup. See closeConnection.
+	// closeConnection is not set directly as a handler here to
+	// avoid race conditions when calling the Goja runtime.
+	conn.SetCloseHandler(func(code int, text string) error { return nil })
+
 	// Pass ping/pong events through the main control loop
 	pingChan := make(chan string)
 	pongChan := make(chan string)
@@ -262,9 +269,8 @@ func (*WS) Connect(ctx context.Context, url string, args ...goja.Value) (*WSHTTP
 		case readErr := <-readErrChan:
 			socket.handleEvent("error", rt.ToValue(readErr))
 
-		case readClose := <-readCloseChan:
-			// handle server close
-			socket.handleEvent("close", rt.ToValue(readClose))
+		case code := <-readCloseChan:
+			_ = socket.closeConnection(code)
 
 		case scheduledFn := <-socket.scheduled:
 			if _, err := scheduledFn(goja.Undefined()); err != nil {
@@ -425,7 +431,8 @@ func (s *Socket) Close(args ...goja.Value) {
 	_ = s.closeConnection(code)
 }
 
-// Attempts to close the websocket gracefully
+// closeConnection cleanly closes the WebSocket connection.
+// Returns an error if sending the close control frame fails.
 func (s *Socket) closeConnection(code int) error {
 	var err error
 
@@ -437,15 +444,16 @@ func (s *Socket) closeConnection(code int) error {
 			time.Now().Add(writeWait),
 		)
 		if err != nil {
-			// Just call the handler, we'll try to close the connection anyway
+			// Call the user-defined error handler
 			s.handleEvent("error", rt.ToValue(err))
 		}
 
-		// trigger `close` event when the client closes the connection
+		// Call the user-defined close handler
 		s.handleEvent("close", rt.ToValue(code))
+
 		_ = s.conn.Close()
 
-		// Stops the main control loop
+		// Stop the main control loop
 		close(s.done)
 	})
 
@@ -454,21 +462,19 @@ func (s *Socket) closeConnection(code int) error {
 
 // Wraps conn.ReadMessage in a channel
 func readPump(conn *websocket.Conn, readChan chan []byte, errorChan chan error, closeChan chan int) {
-	defer func() { _ = conn.Close() }()
-
 	for {
 		_, message, err := conn.ReadMessage()
 		if err != nil {
-
-			if websocket.IsCloseError(err, websocket.CloseNormalClosure) {
-				closeChan <- err.(*websocket.CloseError).Code
-			} else if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {
-				// Emit the error if it is not CloseNormalClosure
-				// and the error is not  originated from closing the socket ourselves with `CloseGoingAway`
+			if websocket.IsUnexpectedCloseError(
+				err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {
+				// Report an unexpected closure
 				errorChan <- err
 			}
-
-			//CloseGoingAway errors are ignored
+			code := websocket.CloseGoingAway
+			if e, ok := err.(*websocket.CloseError); ok {
+				code = e.Code
+			}
+			closeChan <- code
 			return
 		}
 
diff --git a/js/modules/k6/ws/ws_test.go b/js/modules/k6/ws/ws_test.go
index 731fdf1d8..f0090a831 100644
--- a/js/modules/k6/ws/ws_test.go
+++ b/js/modules/k6/ws/ws_test.go
@@ -22,10 +22,15 @@ package ws
 import (
 	"context"
 	"crypto/tls"
+	"fmt"
+	"net/http"
+	"net/http/httptest"
 	"strconv"
 	"testing"
+	"time"
 
 	"github.com/dop251/goja"
+	"github.com/gorilla/websocket"
 	"github.com/loadimpact/k6/js/common"
 	"github.com/loadimpact/k6/lib"
 	"github.com/loadimpact/k6/lib/metrics"
@@ -264,7 +269,7 @@ func TestSession(t *testing.T) {
 	assertSessionMetricsEmitted(t, samplesBuf, "", sr("WSBIN_URL/ws-echo"), 101, "")
 	assertMetricEmitted(t, metrics.WSPing, samplesBuf, sr("WSBIN_URL/ws-echo"))
 
-	t.Run("close", func(t *testing.T) {
+	t.Run("client_close", func(t *testing.T) {
 		_, err := common.RunString(rt, sr(`
 		let closed = false;
 		let res = ws.connect("WSBIN_URL/ws-echo", function(socket){
@@ -280,6 +285,36 @@ func TestSession(t *testing.T) {
 		assert.NoError(t, err)
 	})
 	assertSessionMetricsEmitted(t, stats.GetBufferedSamples(samples), "", sr("WSBIN_URL/ws-echo"), 101, "")
+
+	serverCloseTests := []struct {
+		name     string
+		endpoint string
+	}{
+		{"server_close_ok", "/ws-echo"},
+		// Ensure we correctly handle invalid WS server
+		// implementations that close the connection prematurely
+		// without sending a close control frame first.
+		{"server_close_invalid", "/ws-close-invalid"},
+	}
+
+	for _, tc := range serverCloseTests {
+		tc := tc
+		t.Run(tc.name, func(t *testing.T) {
+			_, err := common.RunString(rt, sr(fmt.Sprintf(`
+			let closed = false;
+			let res = ws.connect("WSBIN_URL%s", function(socket){
+				socket.on("open", function() {
+					socket.send("test");
+				})
+				socket.on("close", function() {
+					closed = true;
+				})
+			});
+			if (!closed) { throw new Error ("close event not fired"); }
+			`, tc.endpoint)))
+			assert.NoError(t, err)
+		})
+	}
 }
 
 func TestErrors(t *testing.T) {
@@ -332,7 +367,7 @@ func TestErrors(t *testing.T) {
 
 	t.Run("error_in_setup", func(t *testing.T) {
 		_, err := common.RunString(rt, sr(`
-		let res = ws.connect("WSBIN_URL/ws-echo", function(socket){
+		let res = ws.connect("WSBIN_URL/ws-echo-invalid", function(socket){
 			throw new Error("error in setup");
 		});
 		`))
@@ -342,7 +377,7 @@ func TestErrors(t *testing.T) {
 	t.Run("send_after_close", func(t *testing.T) {
 		_, err := common.RunString(rt, sr(`
 		let hasError = false;
-		let res = ws.connect("WSBIN_URL/ws-echo", function(socket){
+		let res = ws.connect("WSBIN_URL/ws-echo-invalid", function(socket){
 			socket.on("open", function() {
 				socket.close();
 				socket.send("test");
@@ -357,7 +392,7 @@ func TestErrors(t *testing.T) {
 		}
 		`))
 		assert.NoError(t, err)
-		assertSessionMetricsEmitted(t, stats.GetBufferedSamples(samples), "", sr("WSBIN_URL/ws-echo"), 101, "")
+		assertSessionMetricsEmitted(t, stats.GetBufferedSamples(samples), "", sr("WSBIN_URL/ws-echo-invalid"), 101, "")
 	})
 
 	t.Run("error on close", func(t *testing.T) {
@@ -514,3 +549,56 @@ func TestTLSConfig(t *testing.T) {
 	})
 	assertSessionMetricsEmitted(t, stats.GetBufferedSamples(samples), "", sr("WSSBIN_URL/ws-close"), 101, "")
 }
+
+func TestReadPump(t *testing.T) {
+	var closeCode int
+	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		conn, err := (&websocket.Upgrader{}).Upgrade(w, r, w.Header())
+		assert.NoError(t, err)
+		closeMsg := websocket.FormatCloseMessage(closeCode, "")
+		_ = conn.WriteControl(websocket.CloseMessage, closeMsg, time.Now().Add(time.Second))
+	}))
+	defer srv.Close()
+
+	closeCodes := []int{websocket.CloseNormalClosure, websocket.CloseGoingAway, websocket.CloseInternalServerErr}
+
+	numAsserts := 0
+	srvURL := "ws://" + srv.Listener.Addr().String()
+
+	// Ensure readPump returns the response close code sent by the server
+	for _, code := range closeCodes {
+		code := code
+		t.Run(strconv.Itoa(code), func(t *testing.T) {
+			closeCode = code
+			conn, resp, err := websocket.DefaultDialer.Dial(srvURL, nil)
+			assert.NoError(t, err)
+			defer func() {
+				_ = resp.Body.Close()
+				_ = conn.Close()
+			}()
+
+			msgChan := make(chan []byte)
+			errChan := make(chan error)
+			closeChan := make(chan int)
+			go readPump(conn, msgChan, errChan, closeChan)
+
+		readChans:
+			for {
+				select {
+				case responseCode := <-closeChan:
+					assert.Equal(t, code, responseCode)
+					numAsserts++
+					break readChans
+				case <-errChan:
+					continue
+				case <-time.After(time.Second):
+					t.Errorf("Read timed out")
+					break readChans
+				}
+			}
+		})
+	}
+
+	// Ensure all close code asserts passed
+	assert.Equal(t, numAsserts, len(closeCodes))
+}
diff --git a/lib/testutils/httpmultibin/httpmultibin.go b/lib/testutils/httpmultibin/httpmultibin.go
index 3228eac95..c1aa1218c 100644
--- a/lib/testutils/httpmultibin/httpmultibin.go
+++ b/lib/testutils/httpmultibin/httpmultibin.go
@@ -100,32 +100,42 @@ type jsonBody struct {
 	Compression string      `json:"compression"`
 }
 
-func websocketEchoHandler(w http.ResponseWriter, req *http.Request) {
-	conn, err := (&websocket.Upgrader{}).Upgrade(w, req, w.Header())
-	if err != nil {
-		return
-	}
-
-	mt, message, err := conn.ReadMessage()
-	if err != nil {
-		return
-	}
-	err = conn.WriteMessage(mt, message)
-	if err != nil {
-		return
-	}
-	err = conn.Close()
-	if err != nil {
-		return
-	}
-}
-
-func websocketCloserHandler(w http.ResponseWriter, req *http.Request) {
-	conn, err := (&websocket.Upgrader{}).Upgrade(w, req, w.Header())
-	if err != nil {
-		return
-	}
-	_ = conn.Close()
+func getWebsocketHandler(echo bool, closePrematurely bool) http.Handler {
+	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
+		conn, err := (&websocket.Upgrader{}).Upgrade(w, req, w.Header())
+		if err != nil {
+			return
+		}
+		if echo {
+			messageType, r, e := conn.NextReader()
+			if e != nil {
+				return
+			}
+			var wc io.WriteCloser
+			wc, err = conn.NextWriter(messageType)
+			if err != nil {
+				return
+			}
+			if _, err = io.Copy(wc, r); err != nil {
+				return
+			}
+			if err = wc.Close(); err != nil {
+				return
+			}
+		}
+		// closePrematurely=true mimics an invalid WS server that doesn't
+		// send a close control frame before closing the connection.
+		if !closePrematurely {
+			closeMsg := websocket.FormatCloseMessage(websocket.CloseNormalClosure, "")
+			_ = conn.WriteControl(websocket.CloseMessage, closeMsg, time.Now().Add(time.Second))
+			// Wait for response control frame
+			<-time.After(time.Second)
+		}
+		err = conn.Close()
+		if err != nil {
+			return
+		}
+	})
 }
 
 func writeJSON(w io.Writer, v interface{}) error {
@@ -193,8 +203,10 @@ func NewHTTPMultiBin(t testing.TB) *HTTPMultiBin {
 	// Create a http.ServeMux and set the httpbin handler as the default
 	mux := http.NewServeMux()
 	mux.Handle("/brotli", getEncodedHandler(t, httpext.CompressionTypeBr))
-	mux.HandleFunc("/ws-echo", websocketEchoHandler)
-	mux.HandleFunc("/ws-close", websocketCloserHandler)
+	mux.Handle("/ws-echo", getWebsocketHandler(true, false))
+	mux.Handle("/ws-echo-invalid", getWebsocketHandler(true, true))
+	mux.Handle("/ws-close", getWebsocketHandler(false, false))
+	mux.Handle("/ws-close-invalid", getWebsocketHandler(false, true))
 	mux.Handle("/zstd", getEncodedHandler(t, httpext.CompressionTypeZstd))
 	mux.Handle("/zstd-br", getZstdBrHandler(t))
 	mux.Handle("/", httpbin.New().Handler())
