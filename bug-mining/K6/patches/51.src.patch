diff --git a/js/bundle_test.go b/js/bundle_test.go
index f5150ab0f..4f20cdcd5 100644
--- a/js/bundle_test.go
+++ b/js/bundle_test.go
@@ -489,7 +489,7 @@ func TestNewBundleFromArchive(t *testing.T) {
 	assert.Equal(t, "\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.file = exports.options = undefined;exports.default =\n\n\n\nfunction () {return (0, _exclaim2.default)(file);};var _exclaim = require(\"./exclaim.js\");var _exclaim2 = _interopRequireDefault(_exclaim);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}var options = exports.options = { vus: 12345 };var file = exports.file = open(\"./file.txt\");;", string(arc.Data))
 	assert.Equal(t, "/path/to", arc.Pwd)
 	assert.Len(t, arc.Scripts, 1)
-	assert.Equal(t, "\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = function (s) {return s + \"!\";};;", string(arc.Scripts["/path/to/exclaim.js"]))
+	assert.Equal(t, "(function(){\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = function (s) {return s + \"!\";};;})()", string(arc.Scripts["/path/to/exclaim.js"]))
 	assert.Len(t, arc.Files, 1)
 	assert.Equal(t, `hi`, string(arc.Files["/path/to/file.txt"]))
 
diff --git a/js/initcontext.go b/js/initcontext.go
index 36d307114..2cf5855bf 100644
--- a/js/initcontext.go
+++ b/js/initcontext.go
@@ -135,6 +135,7 @@ func (i *InitContext) requireFile(name string) (goja.Value, error) {
 			return goja.Undefined(), err
 		}
 		src, _, err := compiler.Transform(string(data.Data), data.Filename)
+		src = "(function(){" + src + "})()"
 		if err != nil {
 			return goja.Undefined(), err
 		}
@@ -146,9 +147,6 @@ func (i *InitContext) requireFile(name string) (goja.Value, error) {
 		i.programs[filename] = pgm
 	}
 
-	// Execute the program to populate exports. You may notice that this theoretically allows an
-	// imported file to access or overwrite globals defined outside of it. Please don't do anything
-	// stupid with this, consider *any* use of it undefined behavior >_>;;
 	if _, err := i.runtime.RunProgram(pgm.pgm); err != nil {
 		return goja.Undefined(), err
 	}
diff --git a/js/initcontext_test.go b/js/initcontext_test.go
index 205009d3a..84034ac0f 100644
--- a/js/initcontext_test.go
+++ b/js/initcontext_test.go
@@ -129,7 +129,7 @@ func TestInitContextRequire(t *testing.T) {
 				Filename: "/script.js",
 				Data:     []byte(`import "/file.js"; export default function() {}`),
 			}, fs)
-			assert.EqualError(t, err, "Error: aaaa at /file.js:1:20(3)")
+			assert.EqualError(t, err, "Error: aaaa at /file.js:1:32(4)")
 		})
 
 		imports := map[string]struct {
@@ -211,6 +211,34 @@ func TestInitContextRequire(t *testing.T) {
 				}
 			})
 		}
+
+		t.Run("Isolation", func(t *testing.T) {
+			fs := afero.NewMemMapFs()
+			assert.NoError(t, afero.WriteFile(fs, "/a.js", []byte(`const myvar = "a";`), 0644))
+			assert.NoError(t, afero.WriteFile(fs, "/b.js", []byte(`const myvar = "b";`), 0644))
+			b, err := NewBundle(&lib.SourceData{
+				Filename: "/script.js",
+				Data: []byte(`
+				import "./a.js";
+				import "./b.js";
+				export default function() {
+					if (typeof myvar != "undefined") {
+						throw new Error("myvar is set in global scope");
+					}
+				};
+				`),
+			}, fs)
+			if !assert.NoError(t, err) {
+				return
+			}
+
+			bi, err := b.Instantiate()
+			if !assert.NoError(t, err) {
+				return
+			}
+			_, err = bi.Default(goja.Undefined())
+			assert.NoError(t, err)
+		})
 	})
 }
 
