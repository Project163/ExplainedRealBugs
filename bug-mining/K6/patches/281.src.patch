diff --git a/internal/js/tc55/timers/timers.go b/internal/js/tc55/timers/timers.go
index f4432d8c2..b4797d25a 100644
--- a/internal/js/tc55/timers/timers.go
+++ b/internal/js/tc55/timers/timers.go
@@ -10,6 +10,7 @@ import (
 	"github.com/sirupsen/logrus"
 
 	"github.com/grafana/sobek"
+
 	"go.k6.io/k6/js/common"
 	"go.k6.io/k6/js/modules"
 )
@@ -91,6 +92,13 @@ func (e *timers) clearTimeout(id uint64) {
 	}
 	delete(e.timers, id)
 
+	first := e.queue.first()
+	if first != nil && first.id == id && e.queue.length() > 1 {
+		// if this is the first in queue we need to reset the first timer
+		// but only if there are more tasks in the queue
+		// and we need to do it after we remove this one, so we are deferring it
+		defer e.setupTaskTimeout()
+	}
 	e.queue.remove(id)
 	e.freeEventLoopIfPossible()
 }
diff --git a/internal/js/tc55/timers/timers_test.go b/internal/js/tc55/timers/timers_test.go
index 0b279d9fc..9a3676985 100644
--- a/internal/js/tc55/timers/timers_test.go
+++ b/internal/js/tc55/timers/timers_test.go
@@ -196,3 +196,24 @@ func TestSetTimeoutContextCancel(t *testing.T) {
 		require.Empty(t, log)
 	}
 }
+
+func TestClearFirstTimeoutWhenMultiple(t *testing.T) {
+	t.Parallel()
+
+	runtime := newRuntime(t)
+	rt := runtime.VU.Runtime()
+	var log []time.Time
+
+	start := time.Now()
+	require.NoError(t, rt.Set("time", func() { log = append(log, time.Now()) }))
+	_, err := runtime.RunOnEventLoop(`
+		setTimeout(() => {
+		   time();
+		}, 1000);
+		const cancelTimeout = setTimeout(() => {}, 200);
+		clearTimeout(cancelTimeout);
+	`)
+	require.NoError(t, err)
+	require.Len(t, log, 1)
+	require.Greater(t, log[0].Sub(start), time.Second)
+}
