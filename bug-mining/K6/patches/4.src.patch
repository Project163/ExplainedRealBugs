diff --git a/lib/engine.go b/lib/engine.go
index 56831d59f..a8c3019e7 100644
--- a/lib/engine.go
+++ b/lib/engine.go
@@ -26,6 +26,7 @@ import (
 	log "github.com/Sirupsen/logrus"
 	"github.com/loadimpact/k6/stats"
 	"github.com/pkg/errors"
+	"strings"
 	"sync"
 	"sync/atomic"
 	"time"
@@ -57,6 +58,39 @@ type vuEntry struct {
 	lock    sync.Mutex
 }
 
+type submetric struct {
+	Name       string
+	Conditions map[string]string
+	Sink       stats.Sink
+}
+
+func parseSubmetric(name string) (string, map[string]string) {
+	halves := strings.SplitN(strings.TrimSuffix(name, "}"), "{", 2)
+	if len(halves) != 2 {
+		return halves[0], nil
+	}
+
+	kvs := strings.Split(halves[1], ",")
+	conditions := make(map[string]string, len(kvs))
+	for _, kv := range kvs {
+		if kv == "" {
+			continue
+		}
+
+		parts := strings.SplitN(kv, ":", 2)
+
+		key := strings.TrimSpace(strings.Trim(parts[0], `"'`))
+		if len(parts) != 2 {
+			conditions[key] = ""
+			continue
+		}
+
+		value := strings.TrimSpace(strings.Trim(parts[1], `"'`))
+		conditions[key] = value
+	}
+	return halves[0], conditions
+}
+
 // The Engine is the beating heart of K6.
 type Engine struct {
 	Runner    Runner
@@ -69,6 +103,9 @@ type Engine struct {
 	Metrics     map[*stats.Metric]stats.Sink
 	MetricsLock sync.Mutex
 
+	// Submetrics, mapped from parent metric names.
+	submetrics map[string][]*submetric
+
 	// Stage tracking.
 	atTime          time.Duration
 	atStage         int
@@ -134,6 +171,19 @@ func NewEngine(r Runner, o Options) (*Engine, error) {
 
 	if o.Thresholds != nil {
 		e.Thresholds = o.Thresholds
+		e.submetrics = make(map[string][]*submetric)
+
+		for name := range e.Thresholds {
+			if !strings.Contains(name, "{") {
+				continue
+			}
+
+			parent, conds := parseSubmetric(name)
+			e.submetrics[parent] = append(e.submetrics[parent], &submetric{
+				Name:       name,
+				Conditions: conds,
+			})
+		}
 	}
 
 	return e, nil
@@ -578,6 +628,30 @@ func (e *Engine) processThresholds() {
 			e.thresholdsTainted = true
 		}
 	}
+
+	for _, sms := range e.submetrics {
+		for _, sm := range sms {
+			if sm.Sink == nil {
+				continue
+			}
+
+			ts, ok := e.Thresholds[sm.Name]
+			if !ok {
+				continue
+			}
+
+			e.Logger.WithField("m", sm.Name).Debug("running thresholds")
+			succ, err := ts.Run(sm.Sink)
+			if err != nil {
+				e.Logger.WithField("m", sm.Name).WithError(err).Error("Threshold error")
+				continue
+			}
+			if !succ {
+				e.Logger.WithField("m", sm.Name).Debug("Thresholds failed")
+				e.thresholdsTainted = true
+			}
+		}
+	}
 }
 
 func (e *Engine) runCollection(ctx context.Context) {
@@ -611,6 +685,8 @@ func (e *Engine) collect() []stats.Sample {
 
 func (e *Engine) processSamples(samples ...stats.Sample) {
 	e.MetricsLock.Lock()
+	defer e.MetricsLock.Unlock()
+
 	for _, sample := range samples {
 		sink := e.Metrics[sample.Metric]
 		if sink == nil {
@@ -618,9 +694,27 @@ func (e *Engine) processSamples(samples ...stats.Sample) {
 			e.Metrics[sample.Metric] = sink
 		}
 		sink.Add(sample)
+
+		for _, sm := range e.submetrics[sample.Metric.Name] {
+			passing := true
+			for k, v := range sm.Conditions {
+				if sample.Tags[k] != v {
+					passing = false
+					break
+				}
+			}
+			if !passing {
+				continue
+			}
+
+			if sm.Sink == nil {
+				sm.Sink = sample.Metric.NewSink()
+			}
+			sm.Sink.Add(sample)
+		}
 	}
+
 	if e.Collector != nil {
 		e.Collector.Collect(samples)
 	}
-	e.MetricsLock.Unlock()
 }
diff --git a/lib/engine_test.go b/lib/engine_test.go
index 66101a5f3..82dc7a466 100644
--- a/lib/engine_test.go
+++ b/lib/engine_test.go
@@ -76,6 +76,34 @@ func assertActiveVUs(t *testing.T, e *Engine, active, dead int) {
 	assert.Equal(t, dead, numDead, "wrong number of dead vus")
 }
 
+func Test_parseSubmetric(t *testing.T) {
+	testdata := map[string]struct {
+		parent string
+		conds  map[string]string
+	}{
+		"my_metric":                 {"my_metric", nil},
+		"my_metric{}":               {"my_metric", map[string]string{}},
+		"my_metric{a}":              {"my_metric", map[string]string{"a": ""}},
+		"my_metric{a:1}":            {"my_metric", map[string]string{"a": "1"}},
+		"my_metric{ a : 1 }":        {"my_metric", map[string]string{"a": "1"}},
+		"my_metric{a,b}":            {"my_metric", map[string]string{"a": "", "b": ""}},
+		"my_metric{a:1,b:2}":        {"my_metric", map[string]string{"a": "1", "b": "2"}},
+		"my_metric{ a : 1, b : 2 }": {"my_metric", map[string]string{"a": "1", "b": "2"}},
+	}
+
+	for name, data := range testdata {
+		t.Run(name, func(t *testing.T) {
+			parent, conds := parseSubmetric(name)
+			assert.Equal(t, data.parent, parent)
+			if data.conds != nil {
+				assert.EqualValues(t, data.conds, conds)
+			} else {
+				assert.Nil(t, conds)
+			}
+		})
+	}
+}
+
 func TestNewEngine(t *testing.T) {
 	_, err, _ := newTestEngine(nil, Options{})
 	assert.NoError(t, err)
@@ -152,6 +180,26 @@ func TestNewEngineOptions(t *testing.T) {
 			assert.True(t, e.IsPaused())
 		})
 	})
+	t.Run("thresholds", func(t *testing.T) {
+		e, err, _ := newTestEngine(nil, Options{
+			Thresholds: map[string]Thresholds{
+				"my_metric": Thresholds{},
+			},
+		})
+		assert.NoError(t, err)
+		assert.Contains(t, e.Thresholds, "my_metric")
+
+		t.Run("submetrics", func(t *testing.T) {
+			e, err, _ := newTestEngine(nil, Options{
+				Thresholds: map[string]Thresholds{
+					"my_metric{tag:value}": Thresholds{},
+				},
+			})
+			assert.NoError(t, err)
+			assert.Contains(t, e.Thresholds, "my_metric{tag:value}")
+			assert.Contains(t, e.submetrics, "my_metric")
+		})
+	})
 }
 
 func TestEngineRun(t *testing.T) {
@@ -667,3 +715,82 @@ func TestEngineCollector(t *testing.T) {
 	assert.True(t, numSamples > 0, "no samples")
 	assert.True(t, numSamples > len(c.Samples)-(len(c.Samples)/10), "more than 10%% of samples omitted")
 }
+
+func TestEngine_processSamples(t *testing.T) {
+	metric := stats.New("my_metric", stats.Gauge)
+
+	t.Run("metric", func(t *testing.T) {
+		e, err, _ := newTestEngine(nil, Options{})
+		assert.NoError(t, err)
+
+		e.processSamples(
+			stats.Sample{Metric: metric, Value: 1.25, Tags: map[string]string{"a": "1"}},
+		)
+
+		assert.IsType(t, &stats.GaugeSink{}, e.Metrics[metric])
+	})
+
+	t.Run("submetric", func(t *testing.T) {
+		ths, err := NewThresholds([]string{`1+1==2`})
+		assert.NoError(t, err)
+
+		e, err, _ := newTestEngine(nil, Options{
+			Thresholds: map[string]Thresholds{
+				"my_metric{a:1}": ths,
+			},
+		})
+		assert.NoError(t, err)
+
+		sms := e.submetrics["my_metric"]
+		assert.Len(t, sms, 1)
+		assert.Equal(t, "my_metric{a:1}", sms[0].Name)
+		assert.EqualValues(t, map[string]string{"a": "1"}, sms[0].Conditions)
+
+		e.processSamples(
+			stats.Sample{Metric: metric, Value: 1.25, Tags: map[string]string{"a": "1"}},
+		)
+
+		assert.IsType(t, &stats.GaugeSink{}, e.Metrics[metric])
+
+		sms = e.submetrics["my_metric"]
+		assert.IsType(t, &stats.GaugeSink{}, sms[0].Sink)
+	})
+}
+
+func TestEngine_processThresholds(t *testing.T) {
+	metric := stats.New("my_metric", stats.Gauge)
+
+	testdata := map[string]struct {
+		pass bool
+		ths  map[string][]string
+	}{
+		"passing": {true, map[string][]string{"my_metric": {"1+1==2"}}},
+		"failing": {false, map[string][]string{"my_metric": {"1+1==3"}}},
+
+		"submetric,match,passing":   {true, map[string][]string{"my_metric{a:1}": {"1+1==2"}}},
+		"submetric,match,failing":   {false, map[string][]string{"my_metric{a:1}": {"1+1==3"}}},
+		"submetric,nomatch,passing": {true, map[string][]string{"my_metric{a:2}": {"1+1==2"}}},
+		"submetric,nomatch,failing": {true, map[string][]string{"my_metric{a:2}": {"1+1==3"}}},
+	}
+
+	for name, data := range testdata {
+		t.Run(name, func(t *testing.T) {
+			thresholds := make(map[string]Thresholds, len(data.ths))
+			for m, srcs := range data.ths {
+				ths, err := NewThresholds(srcs)
+				assert.NoError(t, err)
+				thresholds[m] = ths
+			}
+
+			e, err, _ := newTestEngine(nil, Options{Thresholds: thresholds})
+			assert.NoError(t, err)
+
+			e.processSamples(
+				stats.Sample{Metric: metric, Value: 1.25, Tags: map[string]string{"a": "1"}},
+			)
+			e.processThresholds()
+
+			assert.Equal(t, data.pass, !e.IsTainted())
+		})
+	}
+}
