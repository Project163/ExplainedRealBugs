diff --git a/lib/engine.go b/lib/engine.go
index 681ea36ac..ea976a27a 100644
--- a/lib/engine.go
+++ b/lib/engine.go
@@ -39,6 +39,9 @@ const (
 	CollectRate     = 10 * time.Millisecond
 	ThresholdsRate  = 2 * time.Second
 	ShutdownTimeout = 10 * time.Second
+
+	BackoffAmount = 50 * time.Millisecond
+	BackoffMax    = 10 * time.Second
 )
 
 type vuEntry struct {
@@ -501,6 +504,8 @@ func (e *Engine) runVU(ctx context.Context, vu *vuEntry) {
 	// Sleep until the engine starts running.
 	<-e.vuStop
 
+	backoffCounter := 0
+	backoff := time.Duration(0)
 	for {
 		// Exit if the VU has run all its intended iterations.
 		if maxIterations > 0 && vu.Iterations >= maxIterations {
@@ -519,19 +524,31 @@ func (e *Engine) runVU(ctx context.Context, vu *vuEntry) {
 		default:
 		}
 
-		e.runVUOnce(ctx, vu)
+		if !e.runVUOnce(ctx, vu) {
+			backoffCounter++
+			backoff += BackoffAmount * time.Duration(backoffCounter)
+			if backoff > BackoffMax {
+				backoff = BackoffMax
+			}
+			select {
+			case <-time.After(backoff):
+			case <-ctx.Done():
+			}
+		} else {
+			backoff = 0
+		}
 		vu.Iterations++
 	}
 }
 
-func (e *Engine) runVUOnce(ctx context.Context, vu *vuEntry) {
+func (e *Engine) runVUOnce(ctx context.Context, vu *vuEntry) bool {
 	samples, err := vu.VU.RunOnce(ctx)
 
 	// Expired VUs usually have request cancellation errors, and thus skewed metrics and
 	// unhelpful "request cancelled" errors. Don't process those.
 	select {
 	case <-ctx.Done():
-		return
+		return true
 	default:
 	}
 
@@ -558,7 +575,9 @@ func (e *Engine) runVUOnce(ctx context.Context, vu *vuEntry) {
 	atomic.AddInt64(&e.numIterations, 1)
 	if err != nil {
 		atomic.AddInt64(&e.numErrors, 1)
+		return false
 	}
+	return true
 }
 
 func (e *Engine) runMetricsEmission(ctx context.Context) {
