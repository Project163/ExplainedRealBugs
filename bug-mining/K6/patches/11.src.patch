diff --git a/js/api.go b/js/api.go
index bd958d676..1f7ca9419 100644
--- a/js/api.go
+++ b/js/api.go
@@ -22,6 +22,8 @@ package js
 
 import (
 	log "github.com/Sirupsen/logrus"
+	"github.com/loadimpact/k6/lib"
+	"github.com/loadimpact/k6/stats"
 	"github.com/robertkrimen/otto"
 	"strconv"
 	"sync/atomic"
@@ -102,9 +104,12 @@ func (a JSAPI) DoCheck(call otto.FunctionCall) otto.Value {
 		return otto.UndefinedValue()
 	}
 
+	t := time.Now()
+	samples := make([]stats.Sample, len(call.ArgumentList)-1)
+
 	success := true
 	arg0 := call.Argument(0)
-	for _, v := range call.ArgumentList[1:] {
+	for i, v := range call.ArgumentList[1:] {
 		obj := v.Object()
 		if obj == nil {
 			panic(call.Otto.MakeTypeError("checks must be objects"))
@@ -124,15 +129,31 @@ func (a JSAPI) DoCheck(call otto.FunctionCall) otto.Value {
 			if err != nil {
 				throw(call.Otto, err)
 			}
+
+			sampleValue := 1.0
 			if result {
 				atomic.AddInt64(&(check.Passes), 1)
 			} else {
 				atomic.AddInt64(&(check.Fails), 1)
 				success = false
+				sampleValue = 0.0
+			}
+
+			samples[i] = stats.Sample{
+				Time:   t,
+				Metric: lib.MetricChecks,
+				Tags: map[string]string{
+					"group_id": check.Group.ID,
+					"check_id": check.ID,
+					"path":     check.Path, // Included for human readability.
+				},
+				Value: sampleValue,
 			}
 		}
 	}
 
+	a.vu.Samples = append(a.vu.Samples, samples...)
+
 	if !success {
 		a.vu.Taint = true
 		return otto.FalseValue()
diff --git a/lib/engine.go b/lib/engine.go
index e352afd17..5cb7d3288 100644
--- a/lib/engine.go
+++ b/lib/engine.go
@@ -45,6 +45,8 @@ var (
 	MetricVUsMax     = stats.New("vus_max", stats.Gauge)
 	MetricIterations = stats.New("iterations", stats.Gauge)
 	MetricTaints     = stats.New("taints", stats.Gauge)
+
+	MetricChecks = stats.New("checks", stats.Rate)
 )
 
 // Special error used to signal that a VU wants a taint, without logging an error.
diff --git a/lib/models.go b/lib/models.go
index 23e11c655..14ecc54f7 100644
--- a/lib/models.go
+++ b/lib/models.go
@@ -134,5 +134,10 @@ func NewCheck(name string, group *Group) (*Check, error) {
 	hash := md5.Sum([]byte(path))
 	id := hex.EncodeToString(hash[:])
 
-	return &Check{ID: id, Path: path, Name: name, Group: group}, nil
+	return &Check{
+		ID:    id,
+		Path:  path,
+		Group: group,
+		Name:  name,
+	}, nil
 }
