diff --git a/js/modules/k6/http/request_test.go b/js/modules/k6/http/request_test.go
index aa8648918..a77fc022b 100644
--- a/js/modules/k6/http/request_test.go
+++ b/js/modules/k6/http/request_test.go
@@ -276,13 +276,13 @@ func TestRequestAndBatch(t *testing.T) {
 			`))
 			endTime := time.Now()
 			require.Error(t, err)
-			assert.Contains(t, err.Error(), "Client.Timeout exceeded while awaiting headers")
+			assert.Contains(t, err.Error(), "context deadline exceeded")
 			assert.WithinDuration(t, startTime.Add(1*time.Second), endTime, 2*time.Second)
 
 			logEntry := hook.LastEntry()
 			if assert.NotNil(t, logEntry) {
 				assert.Equal(t, logrus.WarnLevel, logEntry.Level)
-				assert.Contains(t, logEntry.Data["error"].(error).Error(), "Client.Timeout exceeded while awaiting headers")
+				assert.Contains(t, logEntry.Data["error"].(error).Error(), "context deadline exceeded")
 				assert.Equal(t, "Request Failed", logEntry.Message)
 			}
 		})
diff --git a/lib/netext/httpext/request.go b/lib/netext/httpext/request.go
index bf4462ee9..72acd5450 100644
--- a/lib/netext/httpext/request.go
+++ b/lib/netext/httpext/request.go
@@ -264,7 +264,7 @@ func MakeRequest(ctx context.Context, preq *ParsedHTTPRequest) (*Response, error
 		}
 	}
 
-	tracerTransport := newTransport(state, tags)
+	tracerTransport := newTransport(ctx, state, tags)
 	var transport http.RoundTripper = tracerTransport
 
 	if state.Options.HTTPDebug.String != "" {
diff --git a/lib/netext/httpext/transport.go b/lib/netext/httpext/transport.go
index b73c37851..3950454eb 100644
--- a/lib/netext/httpext/transport.go
+++ b/lib/netext/httpext/transport.go
@@ -33,9 +33,10 @@ import (
 	"github.com/loadimpact/k6/stats"
 )
 
-// transport is an implemenation of http.RoundTripper that will measure and emit
+// transport is an implementation of http.RoundTripper that will measure and emit
 // different metrics for each roundtrip
 type transport struct {
+	ctx   context.Context
 	state *lib.State
 	tags  map[string]string
 
@@ -72,10 +73,12 @@ var _ http.RoundTripper = &transport{}
 // requests made through it and annotates and emits the recorded metric samples
 // through the state.Samples channel.
 func newTransport(
+	ctx context.Context,
 	state *lib.State,
 	tags map[string]string,
 ) *transport {
 	return &transport{
+		ctx:             ctx,
 		state:           state,
 		tags:            tags,
 		lastRequestLock: new(sync.Mutex),
@@ -147,7 +150,7 @@ func (t *transport) measureAndEmitMetrics(unfReq *unfinishedRequest) *finishedRe
 	}
 
 	trail.SaveSamples(stats.IntoSampleTags(&tags))
-	stats.PushIfNotDone(unfReq.ctx, t.state.Samples, trail)
+	stats.PushIfNotDone(t.ctx, t.state.Samples, trail)
 
 	return result
 }
