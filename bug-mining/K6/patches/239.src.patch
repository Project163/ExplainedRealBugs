diff --git a/js/modules/k6/k6.go b/js/modules/k6/k6.go
index e7a0b95c8..348935729 100644
--- a/js/modules/k6/k6.go
+++ b/js/modules/k6/k6.go
@@ -212,6 +212,11 @@ func (mi *K6) Check(arg0, checks goja.Value, extras ...goja.Value) (bool, error)
 				exc = err
 			}
 		}
+		booleanVal := val.ToBoolean()
+		if !booleanVal {
+			// A single failure makes the return value false.
+			succ = false
+		}
 
 		// Emit! (But only if we have a valid context.)
 		select {
@@ -226,20 +231,18 @@ func (mi *K6) Check(arg0, checks goja.Value, extras ...goja.Value) (bool, error)
 				Metadata: commonTagsAndMeta.Metadata,
 				Value:    0,
 			}
-			if val.ToBoolean() {
+			if booleanVal {
 				atomic.AddInt64(&check.Passes, 1)
 				sample.Value = 1
 			} else {
 				atomic.AddInt64(&check.Fails, 1)
-
-				// A single failure makes the return value false.
-				succ = false
 			}
+
 			metrics.PushIfNotDone(ctx, state.Samples, sample)
 		}
 
 		if exc != nil {
-			return succ, exc
+			return false, exc
 		}
 	}
 
diff --git a/js/modules/k6/k6_test.go b/js/modules/k6/k6_test.go
index 81cd71d1a..3128826eb 100644
--- a/js/modules/k6/k6_test.go
+++ b/js/modules/k6/k6_test.go
@@ -323,6 +323,30 @@ func TestCheckArray(t *testing.T) {
 	}
 }
 
+func TestCheckContextDone(t *testing.T) {
+	t.Parallel()
+	t.Run("true", func(t *testing.T) {
+		t.Parallel()
+		tc := testCaseRuntime(t)
+
+		tc.testRuntime.CancelContext()
+		err := tc.run(`globalThis.result = k6.check(null, {"name": ()=>{ return true }})`)
+		assert.NoError(t, err)
+		assert.Len(t, metrics.GetBufferedSamples(tc.samples), 0)
+		assert.True(t, tc.testRuntime.VU.Runtime().Get("result").ToBoolean())
+	})
+	t.Run("false", func(t *testing.T) {
+		t.Parallel()
+		tc := testCaseRuntime(t)
+
+		tc.testRuntime.CancelContext()
+		err := tc.run(`globalThis.result = k6.check(null, {"name": ()=>{ return false }})`)
+		assert.NoError(t, err)
+		assert.Len(t, metrics.GetBufferedSamples(tc.samples), 0)
+		assert.False(t, tc.testRuntime.VU.Runtime().Get("result").ToBoolean())
+	})
+}
+
 func TestCheckLiteral(t *testing.T) {
 	t.Parallel()
 	rt, samples, _ := checkTestRuntime(t)
@@ -501,3 +525,43 @@ func TestCheckTags(t *testing.T) {
 		}, sample.Tags.Map())
 	}
 }
+
+type testCase struct {
+	samples     chan metrics.SampleContainer
+	testRuntime *modulestest.Runtime
+}
+
+func testCaseRuntime(t testing.TB) *testCase {
+	testRuntime := modulestest.NewRuntime(t)
+	m, ok := New().NewModuleInstance(testRuntime.VU).(*K6)
+	require.True(t, ok)
+	require.NoError(t, testRuntime.VU.RuntimeField.Set("k6", m.Exports().Named))
+
+	registry := metrics.NewRegistry()
+	root, err := lib.NewGroup("", nil)
+	assert.NoError(t, err)
+	samples := make(chan metrics.SampleContainer, 1000)
+	state := &lib.State{
+		Group: root,
+		Options: lib.Options{
+			SystemTags: &metrics.DefaultSystemTagSet,
+		},
+		Samples:        samples,
+		Tags:           lib.NewVUStateTags(registry.RootTagSet().WithTagsFromMap(map[string]string{"group": root.Path})),
+		BuiltinMetrics: metrics.RegisterBuiltinMetrics(registry),
+	}
+	testRuntime.MoveToVUContext(state)
+
+	return &testCase{
+		samples:     samples,
+		testRuntime: testRuntime,
+	}
+}
+
+func (t *testCase) run(script string) error {
+	defer t.testRuntime.EventLoop.WaitOnRegistered()
+	return t.testRuntime.EventLoop.Start(func() (err error) {
+		_, err = t.testRuntime.VU.Runtime().RunString(script)
+		return err
+	})
+}
