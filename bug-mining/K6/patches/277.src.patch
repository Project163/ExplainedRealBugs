diff --git a/internal/js/modules/k6/grpc/client.go b/internal/js/modules/k6/grpc/client.go
index 8a8efbce6..c4bd7d043 100644
--- a/internal/js/modules/k6/grpc/client.go
+++ b/internal/js/modules/k6/grpc/client.go
@@ -8,6 +8,8 @@ import (
 	"errors"
 	"fmt"
 	"io"
+	"math"
+	"reflect"
 	"strings"
 	"time"
 
@@ -369,7 +371,16 @@ func (c *Client) buildInvokeRequest(
 	if req == nil {
 		return grpcReq, errors.New("request cannot be nil")
 	}
-	b, err := req.ToObject(c.vu.Runtime()).MarshalJSON()
+
+	object := req.ToObject(c.vu.Runtime())
+
+	var stack []*sobek.Object
+	normalized, err := normalizeNumberStrings(object, c.vu.Runtime(), stack)
+	if err != nil {
+		return grpcReq, fmt.Errorf("unable to normalize number strings: %w", err)
+	}
+
+	b, err := normalized.ToObject(c.vu.Runtime()).MarshalJSON()
 	if err != nil {
 		return grpcReq, fmt.Errorf("unable to serialise request object: %w", err)
 	}
@@ -387,6 +398,72 @@ func (c *Client) buildInvokeRequest(
 	}, nil
 }
 
+// normalizeNumberStrings recursively traverses a sobek.Value. It creates a deep copy of any
+// objects or arrays, and converts special float values (NaN, Infinity) to their
+// string representations for proper JSON serialization.
+func normalizeNumberStrings(v sobek.Value, runtime *sobek.Runtime, stack []*sobek.Object) (sobek.Value, error) {
+	// If v is a primitive (not an object or array), handle it directly.
+	if v == nil || sobek.IsNull(v) || sobek.IsUndefined(v) {
+		return v, nil
+	}
+
+	// Handle special float values.
+	if v.ExportType().Kind() == reflect.Float64 {
+		f := v.ToFloat()
+		switch {
+		case math.IsNaN(f):
+			return runtime.ToValue("NaN"), nil
+		case math.IsInf(f, 1):
+			return runtime.ToValue("Infinity"), nil
+		case math.IsInf(f, -1):
+			return runtime.ToValue("-Infinity"), nil
+		}
+
+		return v, nil
+	}
+
+	obj := v.ToObject(runtime)
+
+	// If it's not a real object (e.g., a string, bool, or regular number primitive),
+	// after checking for special floats, we can just return it.
+	// We use obj.ClassName() to distinguish real objects from primitive wrappers.
+	className := obj.ClassName()
+	if className != "Object" && className != "Array" {
+		return v, nil
+	}
+
+	// Similar to what's done when marshaling into JSON,
+	// detect and prevent infinite recursion due to circular object references.
+	for _, vis := range stack {
+		if obj.SameAs(vis) {
+			return nil, errors.New("cyclic reference to an object found")
+		}
+	}
+	stack = append(stack, obj)
+
+	// It's a real object or array, so we need to deep-copy and normalize it.
+	var newObj *sobek.Object
+	if className == "Array" {
+		newObj = runtime.NewArray()
+	} else {
+		newObj = runtime.NewObject()
+	}
+
+	for _, key := range obj.Keys() {
+		val := obj.Get(key)
+		normalizedVal, err := normalizeNumberStrings(val, runtime, stack)
+		if err != nil {
+			return nil, err
+		}
+
+		if err := newObj.Set(key, normalizedVal); err != nil {
+			return nil, err
+		}
+	}
+
+	return newObj, nil
+}
+
 // Close will close the client gRPC connection
 func (c *Client) Close() error {
 	if c.conn == nil {
diff --git a/internal/js/modules/k6/grpc/client_test.go b/internal/js/modules/k6/grpc/client_test.go
index 2088743ac..b6f54479a 100644
--- a/internal/js/modules/k6/grpc/client_test.go
+++ b/internal/js/modules/k6/grpc/client_test.go
@@ -7,6 +7,7 @@ import (
 	"crypto/x509"
 	"encoding/pem"
 	"fmt"
+	"math"
 	"strings"
 	"testing"
 
@@ -1128,6 +1129,74 @@ func TestClient(t *testing.T) {
 			`,
 			},
 		},
+		{
+			name: "WrappersSpecialNumberValues",
+			initString: codeBlock{
+				code: `
+				var client = new grpc.Client();
+				client.load([], "../../../../lib/testutils/httpmultibin/grpc_wrappers_testing/test.proto");`,
+			},
+			setup: func(tb *httpmultibin.HTTPMultiBin) {
+				srv := grpc_wrappers_testing.Register(tb.ServerGRPC)
+
+				srv.TestDoubleImplementation = func(_ context.Context, in *wrappers.DoubleValue) (*wrappers.DoubleValue, error) {
+					if math.IsNaN(in.Value) {
+						return &wrappers.DoubleValue{Value: math.NaN()}, nil
+					}
+					if math.IsInf(in.Value, -1) {
+						return &wrappers.DoubleValue{Value: math.Inf(-1)}, nil
+					}
+					if math.IsInf(in.Value, 1) {
+						return &wrappers.DoubleValue{Value: math.Inf(1)}, nil
+					}
+					return &wrappers.DoubleValue{Value: in.Value}, nil
+				}
+			},
+			vuString: codeBlock{
+				code: `
+				client.connect("GRPCBIN_ADDR");
+
+				let respNaN = client.invoke("grpc.wrappers.testing.Service/TestDouble", NaN);
+				if (respNaN.message !== "NaN") {
+					throw new Error("expected to get 'NaN', but got a " + respString.message)
+				}
+
+				let respInfinity = client.invoke("grpc.wrappers.testing.Service/TestDouble", Infinity);
+				if (respInfinity.message !== "Infinity") {
+					throw new Error("expected to get 'Infinity', but got a " + respString.message)
+				}
+
+				let respNegativeInfinity = client.invoke("grpc.wrappers.testing.Service/TestDouble", -Infinity);
+				if (respNegativeInfinity.message !== "-Infinity") {
+					throw new Error("expected to get '-Infinity', but got a " + respString.message)
+				}
+			`,
+			},
+		},
+		{
+			name: "ObjectCyclicReference",
+			initString: codeBlock{
+				code: `
+				var client = new grpc.Client();
+				client.load([], "../../../../lib/testutils/httpmultibin/grpc_wrappers_testing/test.proto");`,
+			},
+			setup: func(tb *httpmultibin.HTTPMultiBin) {
+				reflection.Register(tb.ServerGRPC)
+			},
+			vuString: codeBlock{
+				code: `
+				client.connect("GRPCBIN_ADDR");
+
+				let obj1 = {};
+				let obj2 = {};
+				obj1.a = obj2;
+				obj2.b = obj1;
+
+				let respNaN = client.invoke("grpc.wrappers.testing.Service/TestDouble", obj1);
+				`,
+				err: "cyclic reference to an object found",
+			},
+		},
 		{
 			name: "HealthCheckServing",
 			setup: func(hb *httpmultibin.HTTPMultiBin) {
