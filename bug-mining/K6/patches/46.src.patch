diff --git a/js/modules/k6/http/http.go b/js/modules/k6/http/http.go
index 0f6742175..82d1b86d1 100644
--- a/js/modules/k6/http/http.go
+++ b/js/modules/k6/http/http.go
@@ -35,6 +35,7 @@ import (
 	"sync"
 	"time"
 
+	log "github.com/Sirupsen/logrus"
 	"github.com/dop251/goja"
 	"github.com/loadimpact/k6/js/common"
 	"github.com/loadimpact/k6/js/modules/k6/html"
@@ -57,6 +58,7 @@ type HTTPResponse struct {
 	Headers    map[string]string
 	Body       string
 	Timings    HTTPResponseTimings
+	Error      string
 
 	cachedJSON goja.Value
 }
@@ -123,6 +125,7 @@ func (*HTTP) Request(ctx context.Context, method, url string, args ...goja.Value
 		"group":  state.Group.Path,
 	}
 	timeout := 60 * time.Second
+	throw := state.Options.Throw.Bool
 
 	if len(args) > 1 {
 		paramsV := args[1]
@@ -156,11 +159,17 @@ func (*HTTP) Request(ctx context.Context, method, url string, args ...goja.Value
 					}
 				case "timeout":
 					timeout = time.Duration(params.Get(k).ToFloat() * float64(time.Millisecond))
+				case "throw":
+					throw = params.Get(k).ToBoolean()
 				}
 			}
 		}
 	}
 
+	resp := &HTTPResponse{
+		ctx: ctx,
+		URL: url,
+	}
 	client := http.Client{
 		Transport: state.HTTPTransport,
 		Timeout:   timeout,
@@ -172,48 +181,53 @@ func (*HTTP) Request(ctx context.Context, method, url string, args ...goja.Value
 			return nil
 		},
 	}
+
 	tracer := netext.Tracer{}
-	res, err := client.Do(req.WithContext(netext.WithTracer(ctx, &tracer)))
-	if err != nil {
-		state.Samples = append(state.Samples, tracer.Done().Samples(tags)...)
-		return nil, err
+	res, resErr := client.Do(req.WithContext(netext.WithTracer(ctx, &tracer)))
+	if res != nil {
+		body, _ := ioutil.ReadAll(res.Body)
+		_ = res.Body.Close()
+		resp.Body = string(body)
+	}
+	trail := tracer.Done()
+	if trail.ConnRemoteAddr != nil {
+		remoteHost, remotePortStr, _ := net.SplitHostPort(trail.ConnRemoteAddr.String())
+		remotePort, _ := strconv.Atoi(remotePortStr)
+		resp.RemoteIP = remoteHost
+		resp.RemotePort = remotePort
+	}
+	resp.Timings = HTTPResponseTimings{
+		Duration:   stats.D(trail.Duration),
+		Blocked:    stats.D(trail.Blocked),
+		Connecting: stats.D(trail.Connecting),
+		Sending:    stats.D(trail.Sending),
+		Waiting:    stats.D(trail.Waiting),
+		Receiving:  stats.D(trail.Receiving),
 	}
 
-	body, err := ioutil.ReadAll(res.Body)
-	if err != nil {
-		state.Samples = append(state.Samples, tracer.Done().Samples(tags)...)
-		return nil, err
+	if resErr != nil {
+		resp.Error = resErr.Error()
+		tags["error"] = resp.Error
+	} else {
+		resp.URL = res.Request.URL.String()
+		resp.Status = res.StatusCode
+		tags["url"] = resp.URL
+		tags["status"] = strconv.Itoa(resp.Status)
+
+		resp.Headers = make(map[string]string, len(res.Header))
+		for k, vs := range res.Header {
+			resp.Headers[k] = strings.Join(vs, ", ")
+		}
 	}
-	_ = res.Body.Close()
-	trail := tracer.Done()
 
-	tags["status"] = strconv.Itoa(res.StatusCode)
 	state.Samples = append(state.Samples, trail.Samples(tags)...)
-
-	headers := make(map[string]string, len(res.Header))
-	for k, vs := range res.Header {
-		headers[k] = strings.Join(vs, ", ")
+	if resErr != nil {
+		log.WithField("error", resErr).Warn("Request Failed")
+		if throw {
+			return nil, resErr
+		}
 	}
-	remoteHost, remotePortStr, _ := net.SplitHostPort(trail.ConnRemoteAddr.String())
-	remotePort, _ := strconv.Atoi(remotePortStr)
-	return &HTTPResponse{
-		ctx: ctx,
-
-		RemoteIP:   remoteHost,
-		RemotePort: remotePort,
-		URL:        res.Request.URL.String(),
-		Status:     res.StatusCode,
-		Headers:    headers,
-		Body:       string(body),
-		Timings: HTTPResponseTimings{
-			Duration:   stats.D(trail.Duration),
-			Blocked:    stats.D(trail.Blocked),
-			Connecting: stats.D(trail.Connecting),
-			Sending:    stats.D(trail.Sending),
-			Waiting:    stats.D(trail.Waiting),
-			Receiving:  stats.D(trail.Receiving),
-		},
-	}, nil
+	return resp, nil
 }
 
 func (http *HTTP) Get(ctx context.Context, url string, args ...goja.Value) (*HTTPResponse, error) {
diff --git a/js/modules/k6/http/http_test.go b/js/modules/k6/http/http_test.go
index 9671a53e8..f3b29d156 100644
--- a/js/modules/k6/http/http_test.go
+++ b/js/modules/k6/http/http_test.go
@@ -30,8 +30,8 @@ import (
 	"testing"
 	"time"
 
-	null "gopkg.in/guregu/null.v3"
-
+	log "github.com/Sirupsen/logrus"
+	logtest "github.com/Sirupsen/logrus/hooks/test"
 	"github.com/dop251/goja"
 	"github.com/loadimpact/k6/js/common"
 	"github.com/loadimpact/k6/lib"
@@ -39,6 +39,7 @@ import (
 	"github.com/loadimpact/k6/lib/netext"
 	"github.com/loadimpact/k6/stats"
 	"github.com/stretchr/testify/assert"
+	null "gopkg.in/guregu/null.v3"
 )
 
 func assertRequestMetricsEmitted(t *testing.T, samples []stats.Sample, method, url string, status int, group string) {
@@ -88,6 +89,7 @@ func TestRequest(t *testing.T) {
 		Options: lib.Options{
 			MaxRedirects: null.IntFrom(10),
 			UserAgent:    null.StringFrom("TestUserAgent"),
+			Throw:        null.BoolFrom(true),
 		},
 		Group: root,
 		HTTPTransport: &http.Transport{
@@ -110,8 +112,18 @@ func TestRequest(t *testing.T) {
 			assert.NoError(t, err)
 		})
 		t.Run("10", func(t *testing.T) {
+			hook := logtest.NewGlobal()
+			defer hook.Reset()
+
 			_, err := common.RunString(rt, `http.get("https://httpbin.org/redirect/10")`)
 			assert.EqualError(t, err, "GoError: Get /get: stopped after 10 redirects")
+
+			logEntry := hook.LastEntry()
+			if assert.NotNil(t, logEntry) {
+				assert.Equal(t, log.WarnLevel, logEntry.Level)
+				assert.EqualError(t, logEntry.Data["error"].(error), "Get /get: stopped after 10 redirects")
+				assert.Equal(t, "Request Failed", logEntry.Message)
+			}
 		})
 	})
 	t.Run("Timeout", func(t *testing.T) {
@@ -124,6 +136,9 @@ func TestRequest(t *testing.T) {
 			assert.NoError(t, err)
 		})
 		t.Run("10s", func(t *testing.T) {
+			hook := logtest.NewGlobal()
+			defer hook.Reset()
+
 			startTime := time.Now()
 			_, err := common.RunString(rt, `
 				http.get("https://httpbin.org/delay/10", {
@@ -133,6 +148,13 @@ func TestRequest(t *testing.T) {
 			endTime := time.Now()
 			assert.EqualError(t, err, "GoError: Get https://httpbin.org/delay/10: net/http: request canceled (Client.Timeout exceeded while awaiting headers)")
 			assert.WithinDuration(t, startTime.Add(1*time.Second), endTime, 1*time.Second)
+
+			logEntry := hook.LastEntry()
+			if assert.NotNil(t, logEntry) {
+				assert.Equal(t, log.WarnLevel, logEntry.Level)
+				assert.EqualError(t, logEntry.Data["error"].(error), "Get https://httpbin.org/delay/10: net/http: request canceled (Client.Timeout exceeded while awaiting headers)")
+				assert.Equal(t, "Request Failed", logEntry.Message)
+			}
 		})
 	})
 	t.Run("UserAgent", func(t *testing.T) {
@@ -216,8 +238,36 @@ func TestRequest(t *testing.T) {
 		})
 	})
 	t.Run("Invalid", func(t *testing.T) {
+		hook := logtest.NewGlobal()
+		defer hook.Reset()
+
 		_, err := common.RunString(rt, `http.request("", "");`)
 		assert.EqualError(t, err, "GoError: Get : unsupported protocol scheme \"\"")
+
+		logEntry := hook.LastEntry()
+		if assert.NotNil(t, logEntry) {
+			assert.Equal(t, log.WarnLevel, logEntry.Level)
+			assert.EqualError(t, logEntry.Data["error"].(error), "Get : unsupported protocol scheme \"\"")
+			assert.Equal(t, "Request Failed", logEntry.Message)
+		}
+
+		t.Run("throw=false", func(t *testing.T) {
+			hook := logtest.NewGlobal()
+			defer hook.Reset()
+
+			_, err := common.RunString(rt, `
+				let res = http.request("", "", { throw: false });
+				throw new Error(res.error);
+			`)
+			assert.EqualError(t, err, "GoError: Get : unsupported protocol scheme \"\"")
+
+			logEntry := hook.LastEntry()
+			if assert.NotNil(t, logEntry) {
+				assert.Equal(t, log.WarnLevel, logEntry.Level)
+				assert.EqualError(t, logEntry.Data["error"].(error), "Get : unsupported protocol scheme \"\"")
+				assert.Equal(t, "Request Failed", logEntry.Message)
+			}
+		})
 	})
 	t.Run("Unroutable", func(t *testing.T) {
 		_, err := common.RunString(rt, `http.request("GET", "http://sdafsgdhfjg/");`)
diff --git a/lib/options.go b/lib/options.go
index 0bebccbbf..617947d38 100644
--- a/lib/options.go
+++ b/lib/options.go
@@ -61,6 +61,7 @@ type Options struct {
 	InsecureSkipTLSVerify null.Bool   `json:"insecureSkipTLSVerify"`
 	NoConnectionReuse     null.Bool   `json:"noConnectionReuse"`
 	UserAgent             null.String `json:"userAgent"`
+	Throw                 null.Bool   `json:"throw"`
 
 	Thresholds map[string]stats.Thresholds `json:"thresholds"`
 
@@ -122,5 +123,7 @@ func (o Options) SetAllValid(valid bool) Options {
 	o.MaxRedirects.Valid = valid
 	o.InsecureSkipTLSVerify.Valid = valid
 	o.NoConnectionReuse.Valid = valid
+	o.UserAgent.Valid = valid
+	o.Throw.Valid = valid
 	return o
 }
diff --git a/run.go b/run.go
index 0116c3f96..ac7eafff4 100644
--- a/run.go
+++ b/run.go
@@ -120,6 +120,10 @@ var commandRun = cli.Command{
 			Name:  "no-connection-reuse",
 			Usage: "don't reuse connections between VU iterations",
 		},
+		cli.BoolFlag{
+			Name:  "throw, t",
+			Usage: "throw errors on failed requests",
+		},
 		cli.StringFlag{
 			Name:   "out, o",
 			Usage:  "output metrics to an external data store (format: type=uri)",
@@ -270,6 +274,7 @@ func actionRun(cc *cli.Context) error {
 		MaxRedirects:          cliInt64(cc, "max-redirects"),
 		InsecureSkipTLSVerify: cliBool(cc, "insecure-skip-tls-verify"),
 		NoConnectionReuse:     cliBool(cc, "no-connection-reuse"),
+		Throw:                 cliBool(cc, "throw"),
 		NoUsageReport:         cliBool(cc, "no-usage-report"),
 	}
 	for _, s := range cc.StringSlice("stage") {
