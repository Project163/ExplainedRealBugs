diff --git a/common/browser.go b/common/browser.go
index b4de007e8..b4b3d1841 100644
--- a/common/browser.go
+++ b/common/browser.go
@@ -421,6 +421,19 @@ func (b *Browser) Close() {
 
 	atomic.CompareAndSwapInt64(&b.state, b.state, BrowserStateClosed)
 
+	// Signal to the connection and the process that we're gracefully closing.
+	// We ignore any IO errors reading from the WS connection, because the below
+	// CDP Browser.close command ends the connection unexpectedly, which causes
+	// `websocket.ReadMessage()` to return `close 1006 (abnormal closure):
+	// unexpected EOF`.
+	b.conn.IgnoreIOErrors()
+	b.browserProc.GracefulClose()
+
+	// Send the Browser.close CDP command, which triggers the browser process to
+	// exit. The WS connection will also be closed if this succeeds, so we don't
+	// need to do it ourselves here, but note that we *don't* receive a Close
+	// control frame from Chrom{e,ium} as per the RFC[1].
+	// [1]: https://www.rfc-editor.org/rfc/rfc6455#section-1.4
 	action := cdpbrowser.Close()
 	if err := action.Do(cdp.WithExecutor(b.ctx, b.conn)); err != nil {
 		if _, ok := err.(*websocket.CloseError); !ok {
@@ -428,10 +441,9 @@ func (b *Browser) Close() {
 		}
 	}
 
-	// terminate the browser process early on, then tell the CDP
-	// afterwards. this will take a little bit of time, and CDP
-	// will stop emitting events.
-	b.browserProc.GracefulClose()
+	// Close all sessions and try to cleanly close the WS connection, but
+	// we'll disregard any errors in the case the connection has already
+	// been closed by the browser.
 	b.conn.Close()
 
 	// Wait for all outstanding events (e.g. Target.detachedFromTarget) to be
diff --git a/common/connection.go b/common/connection.go
index 2078ac85f..cccde07b3 100644
--- a/common/connection.go
+++ b/common/connection.go
@@ -25,7 +25,6 @@ import (
 	"crypto/tls"
 	"errors"
 	"fmt"
-	"net"
 	"net/http"
 	"sync"
 	"sync/atomic"
@@ -57,6 +56,7 @@ type executorEmitter interface {
 type connection interface {
 	executorEmitter
 	Close(...goja.Value)
+	IgnoreIOErrors()
 	getSession(target.SessionID) *Session
 }
 
@@ -130,6 +130,7 @@ type Connection struct {
 	closeCh      chan int
 	errorCh      chan error
 	done         chan struct{}
+	closing      chan struct{}
 	shutdownOnce sync.Once
 	msgID        int64
 
@@ -168,6 +169,7 @@ func NewConnection(ctx context.Context, wsURL string, logger *log.Logger) (*Conn
 		closeCh:          make(chan int),
 		errorCh:          make(chan error),
 		done:             make(chan struct{}),
+		closing:          make(chan struct{}),
 		msgID:            0,
 		sessions:         make(map[target.SessionID]*Session),
 	}
@@ -186,17 +188,11 @@ func (c *Connection) close(code int) error {
 	var err error
 	c.shutdownOnce.Do(func() {
 		defer func() {
-			_ = c.conn.Close()
-
 			// Stop the main control loop
 			close(c.done)
+			_ = c.conn.Close()
 		}()
 
-		err = c.conn.WriteControl(websocket.CloseMessage,
-			websocket.FormatCloseMessage(code, ""),
-			time.Now().Add(10*time.Second),
-		)
-
 		c.sessionsMu.Lock()
 		for _, s := range c.sessions {
 			s.close()
@@ -204,6 +200,19 @@ func (c *Connection) close(code int) error {
 		}
 		c.sessionsMu.Unlock()
 
+		err = c.conn.WriteControl(websocket.CloseMessage,
+			websocket.FormatCloseMessage(code, ""),
+			time.Now().Add(time.Second),
+		)
+
+		// According to the WS RFC[1], we might want to wait for a response
+		// Control frame back from the browser here (possibly for the above
+		// timeout duration), but Chrom{e,ium} never sends one, even when
+		// the browser process exits normally after the Browser.close CDP
+		// command. So we don't bother waiting, since it would just needlessly
+		// delay the k6 iteration.
+		// [1]: https://www.rfc-editor.org/rfc/rfc6455#section-1.4
+
 		c.emit(EventConnectionClose, nil)
 	})
 
@@ -238,15 +247,21 @@ func (c *Connection) createSession(info *target.Info) (*Session, error) {
 }
 
 func (c *Connection) handleIOError(err error) {
-	c.logger.Errorf("cdp", "communicating with browser: %v", err)
+	// It's either a normal closure initiated by the browser, or we stopped the
+	// connection. In either case, disregard the error.
+	if closing := c.isClosing(); websocket.IsCloseError(
+		err, websocket.CloseNormalClosure, websocket.CloseGoingAway,
+	) || closing {
+		c.logger.Debugf("cdp", "received IO error: %v, connection is closing: %v", err, closing)
+		return
+	}
 
-	if websocket.IsUnexpectedCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {
-		// Report an unexpected closure
-		select {
-		case c.errorCh <- err:
-		case <-c.done:
-			return
-		}
+	// Report an unexpected closure
+	c.logger.Errorf("cdp", "communicating with browser: %v", err)
+	select {
+	case c.errorCh <- err:
+	case <-c.done:
+		return
 	}
 	var (
 		cerr *websocket.CloseError
@@ -288,10 +303,7 @@ func (c *Connection) recvLoop() {
 	for {
 		_, buf, err := c.conn.ReadMessage()
 		if err != nil {
-			if !errors.Is(err, net.ErrClosed) {
-				c.logger.Debugf("Connection:recvLoop", "wsURL:%q ioErr:%v", c.wsURL, err)
-				c.handleIOError(err)
-			}
+			c.handleIOError(err)
 			return
 		}
 
@@ -547,3 +559,19 @@ func (c *Connection) Execute(ctx context.Context, method string, params easyjson
 	}
 	return c.send(c.ctx, msg, ch, res)
 }
+
+// IgnoreIOErrors signals that the connection will soon be closed, so that any
+// received IO errors can be disregarded.
+func (c *Connection) IgnoreIOErrors() {
+	close(c.closing)
+}
+
+func (c *Connection) isClosing() (s bool) {
+	select {
+	case <-c.closing:
+		s = true
+	default:
+	}
+
+	return
+}
