diff --git a/api/v1/group.go b/api/v1/group.go
index 5f585fc0a..8b43d29a2 100644
--- a/api/v1/group.go
+++ b/api/v1/group.go
@@ -24,11 +24,11 @@ import (
 	"github.com/loadimpact/k6/lib"
 	"github.com/manyminds/api2go/jsonapi"
 	"github.com/pkg/errors"
-	"strconv"
 )
 
 type Check struct {
-	ID     int64  `json:"id"`
+	ID     string `json:"id"`
+	Path   string `json:"path"`
 	Name   string `json:"name"`
 	Passes int64  `json:"passes"`
 	Fails  int64  `json:"fails"`
@@ -37,6 +37,7 @@ type Check struct {
 func NewCheck(c *lib.Check) Check {
 	return Check{
 		ID:     c.ID,
+		Path:   c.Path,
 		Name:   c.Name,
 		Passes: c.Passes,
 		Fails:  c.Fails,
@@ -44,19 +45,21 @@ func NewCheck(c *lib.Check) Check {
 }
 
 type Group struct {
-	ID     int64   `json:"-"`
+	ID     string  `json:"-"`
+	Path   string  `json:"path"`
 	Name   string  `json:"name"`
 	Checks []Check `json:"checks"`
 
 	Parent   *Group   `json:"-"`
-	ParentID int64    `json:"-"`
+	ParentID string   `json:"-"`
 	Groups   []*Group `json:"-"`
-	GroupIDs []int64  `json:"-"`
+	GroupIDs []string `json:"-"`
 }
 
 func NewGroup(g *lib.Group, parent *Group) *Group {
 	group := &Group{
 		ID:   g.ID,
+		Path: g.Path,
 		Name: g.Name,
 	}
 
@@ -80,15 +83,11 @@ func NewGroup(g *lib.Group, parent *Group) *Group {
 }
 
 func (g Group) GetID() string {
-	return strconv.FormatInt(g.ID, 10)
+	return g.ID
 }
 
 func (g *Group) SetID(v string) error {
-	id, err := strconv.ParseInt(v, 10, 64)
-	if err != nil {
-		return err
-	}
-	g.ID = id
+	g.ID = v
 	return nil
 }
 
@@ -128,17 +127,9 @@ func (g Group) GetReferencedIDs() []jsonapi.ReferenceID {
 	return refs
 }
 
-func (g *Group) SetToManyReferenceIDs(name string, IDs []string) error {
+func (g *Group) SetToManyReferenceIDs(name string, ids []string) error {
 	switch name {
 	case "groups":
-		ids := make([]int64, len(IDs))
-		for i, ID := range IDs {
-			id, err := strconv.ParseInt(ID, 10, 64)
-			if err != nil {
-				return err
-			}
-			ids[i] = id
-		}
 		g.Groups = nil
 		g.GroupIDs = ids
 		return nil
@@ -147,13 +138,9 @@ func (g *Group) SetToManyReferenceIDs(name string, IDs []string) error {
 	}
 }
 
-func (g *Group) SetToOneReferenceID(name, ID string) error {
+func (g *Group) SetToOneReferenceID(name, id string) error {
 	switch name {
 	case "parent":
-		id, err := strconv.ParseInt(ID, 10, 64)
-		if err != nil {
-			return err
-		}
 		g.Parent = nil
 		g.ParentID = id
 		return nil
diff --git a/api/v1/group_routes.go b/api/v1/group_routes.go
index f13c885c1..477084304 100644
--- a/api/v1/group_routes.go
+++ b/api/v1/group_routes.go
@@ -25,7 +25,6 @@ import (
 	"github.com/loadimpact/k6/api/common"
 	"github.com/manyminds/api2go/jsonapi"
 	"net/http"
-	"strconv"
 )
 
 func HandleGetGroups(rw http.ResponseWriter, r *http.Request, p httprouter.Params) {
@@ -43,11 +42,7 @@ func HandleGetGroups(rw http.ResponseWriter, r *http.Request, p httprouter.Param
 }
 
 func HandleGetGroup(rw http.ResponseWriter, r *http.Request, p httprouter.Params) {
-	id, err := strconv.ParseInt(p.ByName("id"), 10, 64)
-	if err != nil {
-		apiError(rw, "Invalid ID", err.Error(), http.StatusBadRequest)
-		return
-	}
+	id := p.ByName("id")
 
 	engine := common.GetEngine(r.Context())
 
diff --git a/js/api.go b/js/api.go
index 79ff12d48..bd958d676 100644
--- a/js/api.go
+++ b/js/api.go
@@ -74,7 +74,10 @@ func (a JSAPI) Log(level int, msg string, args []otto.Value) {
 
 func (a JSAPI) DoGroup(call otto.FunctionCall) otto.Value {
 	name := call.Argument(0).String()
-	group, _ := a.vu.group.Group(name, &(a.vu.runner.groupIDCounter))
+	group, err := a.vu.group.Group(name)
+	if err != nil {
+		throw(call.Otto, err)
+	}
 	a.vu.group = group
 	defer func() { a.vu.group = group.Parent }()
 
@@ -117,7 +120,10 @@ func (a JSAPI) DoCheck(call otto.FunctionCall) otto.Value {
 				throw(call.Otto, err)
 			}
 
-			check, _ := a.vu.group.Check(name, &(a.vu.runner.checkIDCounter))
+			check, err := a.vu.group.Check(name)
+			if err != nil {
+				throw(call.Otto, err)
+			}
 			if result {
 				atomic.AddInt64(&(check.Passes), 1)
 			} else {
diff --git a/js/api_http.go b/js/api_http.go
index bec8a9e61..53486beec 100644
--- a/js/api_http.go
+++ b/js/api_http.go
@@ -21,7 +21,6 @@
 package js
 
 import (
-	// "github.com/robertkrimen/otto"
 	"encoding/json"
 	"github.com/loadimpact/k6/lib"
 	"github.com/loadimpact/k6/stats"
@@ -92,7 +91,7 @@ func (a JSAPI) HTTPRequest(method, url, body string, paramData string) map[strin
 		"method":   method,
 		"url":      url,
 		"status":   strconv.Itoa(res.StatusCode),
-		"group_id": strconv.FormatInt(a.vu.group.ID, 10),
+		"group_id": a.vu.group.ID,
 	}
 	for key, value := range params.Tags {
 		tags[key] = value
diff --git a/js/runner.go b/js/runner.go
index e6a2cf487..7bc96215a 100644
--- a/js/runner.go
+++ b/js/runner.go
@@ -45,9 +45,6 @@ type Runner struct {
 	Options      lib.Options
 
 	HTTPTransport *http.Transport
-
-	groupIDCounter int64
-	checkIDCounter int64
 }
 
 func NewRunner(runtime *Runtime, exports otto.Value) (*Runner, error) {
@@ -69,9 +66,15 @@ func NewRunner(runtime *Runtime, exports otto.Value) (*Runner, error) {
 		return nil, err
 	}
 
+	defaultGroup, err := lib.NewGroup("", nil)
+	if err != nil {
+		return nil, err
+	}
+
 	r := &Runner{
-		Runtime: runtime,
-		Options: runtime.Options,
+		Runtime:      runtime,
+		DefaultGroup: defaultGroup,
+		Options:      runtime.Options,
 		HTTPTransport: &http.Transport{
 			Proxy: http.ProxyFromEnvironment,
 			DialContext: (&net.Dialer{
@@ -83,7 +86,6 @@ func NewRunner(runtime *Runtime, exports otto.Value) (*Runner, error) {
 			MaxIdleConnsPerHost: math.MaxInt32,
 		},
 	}
-	r.DefaultGroup = lib.NewGroup("", nil, nil)
 
 	return r, nil
 }
diff --git a/lib/models.go b/lib/models.go
index 19df567b6..23e11c655 100644
--- a/lib/models.go
+++ b/lib/models.go
@@ -21,19 +21,27 @@
 package lib
 
 import (
+	"crypto/md5"
+	"encoding/hex"
+	"github.com/pkg/errors"
 	"gopkg.in/guregu/null.v3"
+	"strings"
 	"sync"
-	"sync/atomic"
 	"time"
 )
 
+const groupSeparator = "::"
+
+var ErrNameContainsGroupSeparator = errors.Errorf("group and check names may not contain '%s'", groupSeparator)
+
 type Stage struct {
 	Duration time.Duration `json:"duration"`
 	Target   null.Int      `json:"target"`
 }
 
 type Group struct {
-	ID     int64             `json:"id"`
+	ID     string            `json:"id"`
+	Path   string            `json:"path"`
 	Name   string            `json:"name"`
 	Parent *Group            `json:"parent"`
 	Groups map[string]*Group `json:"groups"`
@@ -43,53 +51,73 @@ type Group struct {
 	checkMutex sync.Mutex
 }
 
-func NewGroup(name string, parent *Group, idCounter *int64) *Group {
-	var id int64
-	if idCounter != nil {
-		id = atomic.AddInt64(idCounter, 1)
+func NewGroup(name string, parent *Group) (*Group, error) {
+	if strings.Contains(name, groupSeparator) {
+		return nil, ErrNameContainsGroupSeparator
 	}
 
+	path := name
+	if parent != nil {
+		path = parent.Path + groupSeparator + path
+	}
+
+	hash := md5.Sum([]byte(path))
+	id := hex.EncodeToString(hash[:])
+
 	return &Group{
 		ID:     id,
+		Path:   path,
 		Name:   name,
 		Parent: parent,
 		Groups: make(map[string]*Group),
 		Checks: make(map[string]*Check),
-	}
+	}, nil
 }
 
-func (g *Group) Group(name string, idCounter *int64) (*Group, bool) {
+func (g *Group) Group(name string) (*Group, error) {
 	snapshot := g.Groups
 	group, ok := snapshot[name]
 	if !ok {
 		g.groupMutex.Lock()
-		group, ok = g.Groups[name]
+		defer g.groupMutex.Unlock()
+
+		group, ok := g.Groups[name]
 		if !ok {
-			group = NewGroup(name, g, idCounter)
+			group, err := NewGroup(name, g)
+			if err != nil {
+				return nil, err
+			}
 			g.Groups[name] = group
+			return group, nil
 		}
-		g.groupMutex.Unlock()
+		return group, nil
 	}
-	return group, ok
+	return group, nil
 }
 
-func (g *Group) Check(name string, idCounter *int64) (*Check, bool) {
+func (g *Group) Check(name string) (*Check, error) {
 	snapshot := g.Checks
 	check, ok := snapshot[name]
 	if !ok {
 		g.checkMutex.Lock()
-		check, ok = g.Checks[name]
+		defer g.checkMutex.Unlock()
+		check, ok := g.Checks[name]
 		if !ok {
-			check = NewCheck(name, g, idCounter)
+			check, err := NewCheck(name, g)
+			if err != nil {
+				return nil, err
+			}
 			g.Checks[name] = check
+			return check, nil
 		}
-		g.checkMutex.Unlock()
+		return check, nil
 	}
-	return check, ok
+	return check, nil
 }
 
 type Check struct {
-	ID    int64  `json:"id"`
+	ID    string `json:"id"`
+	Path  string `json:"path"`
 	Group *Group `json:"group"`
 	Name  string `json:"name"`
 
@@ -97,10 +125,14 @@ type Check struct {
 	Fails  int64 `json:"fails"`
 }
 
-func NewCheck(name string, group *Group, idCounter *int64) *Check {
-	var id int64
-	if idCounter != nil {
-		id = atomic.AddInt64(idCounter, 1)
+func NewCheck(name string, group *Group) (*Check, error) {
+	if strings.Contains(name, groupSeparator) {
+		return nil, ErrNameContainsGroupSeparator
 	}
-	return &Check{ID: id, Name: name, Group: group}
+
+	path := group.Path + groupSeparator + name
+	hash := md5.Sum([]byte(path))
+	id := hex.EncodeToString(hash[:])
+
+	return &Check{ID: id, Path: path, Name: name, Group: group}, nil
 }
