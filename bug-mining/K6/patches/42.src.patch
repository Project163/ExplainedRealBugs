diff --git a/js/runner_test.go b/js/runner_test.go
index 696eeaa2c..7a551499c 100644
--- a/js/runner_test.go
+++ b/js/runner_test.go
@@ -95,21 +95,59 @@ func TestRunnerOptions(t *testing.T) {
 }
 
 func TestRunnerIntegrationImports(t *testing.T) {
-	modules := []string{
-		"k6",
-		"k6/http",
-		"k6/metrics",
-		"k6/html",
-	}
-	for _, mod := range modules {
-		t.Run(mod, func(t *testing.T) {
-			_, err := New(&lib.SourceData{
-				Filename: "/script.js",
-				Data:     []byte(fmt.Sprintf(`import "%s"; export default function() {}`, mod)),
-			}, afero.NewMemMapFs())
-			assert.NoError(t, err)
-		})
-	}
+	t.Run("Modules", func(t *testing.T) {
+		modules := []string{
+			"k6",
+			"k6/http",
+			"k6/metrics",
+			"k6/html",
+		}
+		for _, mod := range modules {
+			t.Run(mod, func(t *testing.T) {
+				_, err := New(&lib.SourceData{
+					Filename: "/script.js",
+					Data:     []byte(fmt.Sprintf(`import "%s"; export default function() {}`, mod)),
+				}, afero.NewMemMapFs())
+				assert.NoError(t, err)
+			})
+		}
+	})
+
+	t.Run("Files", func(t *testing.T) {
+		fs := afero.NewMemMapFs()
+		assert.NoError(t, fs.MkdirAll("/path/to", 0755))
+		assert.NoError(t, afero.WriteFile(fs, "/path/to/lib.js", []byte(`export default "hi!";`), 0644))
+
+		testdata := map[string]struct{ filename, path string }{
+			"Absolute":       {"/path/script.js", "/path/to/lib.js"},
+			"Relative":       {"/path/script.js", "./to/lib.js"},
+			"Adjacent":       {"/path/to/script.js", "./lib.js"},
+			"STDIN-Absolute": {"-", "/path/to/lib.js"},
+			"STDIN-Relative": {"-", "./path/to/lib.js"},
+		}
+		for name, data := range testdata {
+			t.Run(name, func(t *testing.T) {
+				r, err := New(&lib.SourceData{
+					Filename: data.filename,
+					Data: []byte(fmt.Sprintf(`
+					import hi from "%s";
+					export default function() {
+						if (hi != "hi!") { throw new Error("incorrect value"); }
+					}`, data.path)),
+				}, fs)
+				if !assert.NoError(t, err) {
+					return
+				}
+
+				vu, err := r.NewVU()
+				if !assert.NoError(t, err) {
+					return
+				}
+				_, err = vu.RunOnce(context.Background())
+				assert.NoError(t, err)
+			})
+		}
+	})
 }
 
 func TestVURunContext(t *testing.T) {
diff --git a/loader/loader.go b/loader/loader.go
index edcd0f68b..333821257 100644
--- a/loader/loader.go
+++ b/loader/loader.go
@@ -59,6 +59,8 @@ func Dir(name string) string {
 }
 
 func Load(fs afero.Fs, pwd, name string) (*lib.SourceData, error) {
+	log.WithFields(log.Fields{"pwd": pwd, "name": name}).Debug("Loading...")
+
 	// We just need to make sure `import ""` doesn't crash the loader.
 	if name == "" {
 		return nil, errors.New("local or remote path required")
@@ -76,6 +78,7 @@ func Load(fs afero.Fs, pwd, name string) (*lib.SourceData, error) {
 
 	// If the file starts with ".", resolve it as a relative path.
 	name = Resolve(pwd, name)
+	log.WithField("name", name).Debug("Resolved...")
 
 	// If the resolved path starts with a "/", it's a local file.
 	if name[0] == '/' {
diff --git a/run.go b/run.go
index e3c481ad2..5a144794c 100644
--- a/run.go
+++ b/run.go
@@ -24,6 +24,7 @@ import (
 	"context"
 	"errors"
 	"fmt"
+	"io"
 	"io/ioutil"
 	"net"
 	"net/url"
@@ -36,6 +37,8 @@ import (
 	"syscall"
 	"time"
 
+	"path"
+
 	log "github.com/Sirupsen/logrus"
 	"github.com/fatih/color"
 	"github.com/ghodss/yaml"
@@ -169,27 +172,27 @@ func guessType(data []byte) string {
 	return TypeJS
 }
 
-func getSrcData(filename string, fs afero.Fs) (*lib.SourceData, error) {
+func getSrcData(filename, pwd string, stdin io.Reader, fs afero.Fs) (*lib.SourceData, error) {
 	if filename == "-" {
-		data, err := ioutil.ReadAll(os.Stdin)
+		data, err := ioutil.ReadAll(stdin)
 		if err != nil {
 			return nil, err
 		}
 		return &lib.SourceData{Filename: "-", Data: data}, nil
 	}
 
-	if ok, _ := afero.Exists(fs, filename); ok {
-		data, err := afero.ReadFile(fs, filename)
+	abspath := filename
+	if !path.IsAbs(abspath) {
+		abspath = path.Join(pwd, abspath)
+	}
+	if ok, _ := afero.Exists(fs, abspath); ok {
+		data, err := afero.ReadFile(fs, abspath)
 		if err != nil {
 			return nil, err
 		}
-		return &lib.SourceData{Filename: filename, Data: data}, nil
+		return &lib.SourceData{Filename: abspath, Data: data}, nil
 	}
 
-	pwd, err := os.Getwd()
-	if err != nil {
-		pwd = "/"
-	}
 	return loader.Load(fs, pwd, filename)
 }
 
@@ -247,6 +250,11 @@ func actionRun(cc *cli.Context) error {
 		return cli.NewExitError("Wrong number of arguments!", 1)
 	}
 
+	pwd, err := os.Getwd()
+	if err != nil {
+		pwd = "/"
+	}
+
 	// Collect CLI arguments, most (not all) relating to options.
 	addr := cc.GlobalString("address")
 	out := cc.String("out")
@@ -275,7 +283,7 @@ func actionRun(cc *cli.Context) error {
 	// Make the Runner, extract script-defined options.
 	arg := args[0]
 	fs := afero.NewOsFs()
-	src, err := getSrcData(arg, fs)
+	src, err := getSrcData(arg, pwd, os.Stdin, fs)
 	if err != nil {
 		log.WithError(err).Error("Failed to parse input data")
 		return err
@@ -617,8 +625,13 @@ func actionInspect(cc *cli.Context) error {
 	}
 	arg := args[0]
 
+	pwd, err := os.Getwd()
+	if err != nil {
+		pwd = "/"
+	}
+
 	fs := afero.NewOsFs()
-	src, err := getSrcData(arg, fs)
+	src, err := getSrcData(arg, pwd, os.Stdin, fs)
 	if err != nil {
 		return err
 	}
diff --git a/run_test.go b/run_test.go
new file mode 100644
index 000000000..85f3ffaad
--- /dev/null
+++ b/run_test.go
@@ -0,0 +1,53 @@
+/*
+ *
+ * k6 - a next-generation load testing tool
+ * Copyright (C) 2016 Load Impact
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+package main
+
+import (
+	"testing"
+
+	"github.com/spf13/afero"
+	"github.com/stretchr/testify/assert"
+)
+
+func Test_getSrcData(t *testing.T) {
+	t.Run("Files", func(t *testing.T) {
+		fs := afero.NewMemMapFs()
+		assert.NoError(t, fs.MkdirAll("/path/to", 0755))
+		assert.NoError(t, afero.WriteFile(fs, "/path/to/file.js", []byte(`hi!`), 0644))
+
+		testdata := map[string]struct{ filename, pwd string }{
+			"Absolute":        {"/path/to/file.js", "/path"},
+			"Relative":        {"./to/file.js", "/path"},
+			"Adjacent":        {"./file.js", "/path/to"},
+			"ImpliedRelative": {"to/file.js", "/path"},
+			"ImpliedAdjacent": {"file.js", "/path/to"},
+		}
+		for name, data := range testdata {
+			t.Run(name, func(t *testing.T) {
+				src, err := getSrcData(data.filename, data.pwd, nil, fs)
+				if assert.NoError(t, err) {
+					assert.Equal(t, "/path/to/file.js", src.Filename)
+					assert.Equal(t, "hi!", string(src.Data))
+				}
+			})
+		}
+	})
+}
