diff --git a/go.mod b/go.mod
index 744629c9f..a03298914 100644
--- a/go.mod
+++ b/go.mod
@@ -14,7 +14,7 @@ require (
 	github.com/andybalholm/cascadia v1.0.0 // indirect
 	github.com/daaku/go.zipexe v0.0.0-20150329023125-a5fe2436ffcb // indirect
 	github.com/dlclark/regexp2 v1.4.1-0.20201013204808-346446b5b182 // indirect
-	github.com/dop251/goja v0.0.0-20201020185350-bf18fe8c88fa
+	github.com/dop251/goja v0.0.0-20201022115936-e21ccf39bfce
 	github.com/dustin/go-humanize v0.0.0-20171111073723-bb3d318650d4
 	github.com/eapache/go-resiliency v1.1.0 // indirect
 	github.com/eapache/go-xerial-snappy v0.0.0-20160609142408-bb955e01b934 // indirect
diff --git a/go.sum b/go.sum
index 122e92b81..f2bdeb7ec 100644
--- a/go.sum
+++ b/go.sum
@@ -27,8 +27,8 @@ github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8
 github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/dlclark/regexp2 v1.4.1-0.20201013204808-346446b5b182 h1:P/IEt6bRdU/7F+i9VvzOgtLVg9MWMe4UODEllD/nH3o=
 github.com/dlclark/regexp2 v1.4.1-0.20201013204808-346446b5b182/go.mod h1:2pZnwuY/m+8K6iRw6wQdMtk+rH5tNGR1i55kozfMjCc=
-github.com/dop251/goja v0.0.0-20201020185350-bf18fe8c88fa h1:e9zLs9j9rFcKtT6Ui4Wh9livUkqFQlfgmNM3DC2cDKo=
-github.com/dop251/goja v0.0.0-20201020185350-bf18fe8c88fa/go.mod h1:Mw6PkjjMXWbTj+nnj4s3QPXq1jaT0s5pC0iFD4+BOAA=
+github.com/dop251/goja v0.0.0-20201022115936-e21ccf39bfce h1:zOwsa3ulKs2V6SR3//1UyPpzlPmvhKCBSHq5ITp2Ugw=
+github.com/dop251/goja v0.0.0-20201022115936-e21ccf39bfce/go.mod h1:Mw6PkjjMXWbTj+nnj4s3QPXq1jaT0s5pC0iFD4+BOAA=
 github.com/dustin/go-humanize v0.0.0-20171111073723-bb3d318650d4 h1:qk/FSDDxo05wdJH28W+p5yivv7LuLYLRXPPD8KQCtZs=
 github.com/dustin/go-humanize v0.0.0-20171111073723-bb3d318650d4/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=
 github.com/eapache/go-resiliency v1.1.0 h1:1NtRmCAqadE2FN4ZcN6g90TP3uk8cg9rn9eNK2197aU=
diff --git a/vendor/github.com/dop251/goja/ast/node.go b/vendor/github.com/dop251/goja/ast/node.go
index 02460205a..a0d285594 100644
--- a/vendor/github.com/dop251/goja/ast/node.go
+++ b/vendor/github.com/dop251/goja/ast/node.go
@@ -135,7 +135,7 @@ type (
 	}
 
 	Property struct {
-		Key   unistring.String
+		Key   Expression
 		Kind  string
 		Value Expression
 	}
diff --git a/vendor/github.com/dop251/goja/compiler.go b/vendor/github.com/dop251/goja/compiler.go
index 0dd9d7598..9375ef4d2 100644
--- a/vendor/github.com/dop251/goja/compiler.go
+++ b/vendor/github.com/dop251/goja/compiler.go
@@ -462,3 +462,30 @@ func (c *compiler) checkIdentifierLName(name unistring.String, offset int) {
 		c.throwSyntaxError(offset, "Assignment to eval or arguments is not allowed in strict mode")
 	}
 }
+
+// Enter a 'dummy' compilation mode. Any code produced after this method is called will be discarded after
+// leaveFunc is called with no additional side effects. This is useful for compiling code inside a
+// constant falsy condition 'if' branch or a loop (i.e 'if (false) { ... } or while (false) { ... }).
+// Such code should not be included in the final compilation result as it's never called, but it must
+// still produce compilation errors if there are any.
+func (c *compiler) enterDummyMode() (leaveFunc func()) {
+	savedBlock, savedBlockStart, savedProgram := c.block, c.blockStart, c.p
+	if savedBlock != nil {
+		c.block = &block{
+			typ:   savedBlock.typ,
+			label: savedBlock.label,
+		}
+	}
+	c.p = &Program{}
+	c.newScope()
+	return func() {
+		c.block, c.blockStart, c.p = savedBlock, savedBlockStart, savedProgram
+		c.popScope()
+	}
+}
+
+func (c *compiler) compileStatementDummy(statement ast.Statement) {
+	leave := c.enterDummyMode()
+	c.compileStatement(statement, false)
+	leave()
+}
diff --git a/vendor/github.com/dop251/goja/compiler_expr.go b/vendor/github.com/dop251/goja/compiler_expr.go
index 479f05940..352aa144c 100644
--- a/vendor/github.com/dop251/goja/compiler_expr.go
+++ b/vendor/github.com/dop251/goja/compiler_expr.go
@@ -1377,18 +1377,24 @@ func (e *compiledObjectLiteral) emitGetter(putOnStack bool) {
 	e.addSrcMap()
 	e.c.emit(newObject)
 	for _, prop := range e.expr.Value {
+		keyExpr := e.c.compileExpression(prop.Key)
+		cl, ok := keyExpr.(*compiledLiteral)
+		if !ok {
+			e.c.throwSyntaxError(e.offset, "non-literal properties in object literal are not supported yet")
+		}
+		key := cl.val.string()
 		e.c.compileExpression(prop.Value).emitGetter(true)
 		switch prop.Kind {
 		case "value":
-			if prop.Key == __proto__ {
+			if key == __proto__ {
 				e.c.emit(setProto)
 			} else {
-				e.c.emit(setProp1(prop.Key))
+				e.c.emit(setProp1(key))
 			}
 		case "get":
-			e.c.emit(setPropGetter(prop.Key))
+			e.c.emit(setPropGetter(key))
 		case "set":
-			e.c.emit(setPropSetter(prop.Key))
+			e.c.emit(setPropSetter(key))
 		default:
 			panic(fmt.Errorf("Unknown property kind: %s", prop.Kind))
 		}
diff --git a/vendor/github.com/dop251/goja/compiler_stmt.go b/vendor/github.com/dop251/goja/compiler_stmt.go
index 1b7af7109..e2ca4887f 100644
--- a/vendor/github.com/dop251/goja/compiler_stmt.go
+++ b/vendor/github.com/dop251/goja/compiler_stmt.go
@@ -259,15 +259,12 @@ func (c *compiler) compileLabeledForStatement(v *ast.ForStatement, needResult bo
 				if r.ToBoolean() {
 					testConst = true
 				} else {
-					// TODO: Properly implement dummy compilation (no garbage in block, scope, etc..)
-					/*
-						p := c.p
-						c.p = &program{}
-						c.compileStatement(v.Body, false)
-						if v.Update != nil {
-							c.compileExpression(v.Update).emitGetter(false)
-						}
-						c.p = p*/
+					leave := c.enterDummyMode()
+					c.compileStatement(v.Body, false)
+					if v.Update != nil {
+						c.compileExpression(v.Update).emitGetter(false)
+					}
+					leave()
 					goto end
 				}
 			} else {
@@ -398,10 +395,7 @@ func (c *compiler) compileLabeledWhileStatement(v *ast.WhileStatement, needResul
 			if t.ToBoolean() {
 				testTrue = true
 			} else {
-				p := c.p
-				c.p = &Program{}
-				c.compileStatement(v.Body, false)
-				c.p = p
+				c.compileStatementDummy(v.Body)
 				goto end
 			}
 		} else {
@@ -605,11 +599,7 @@ func (c *compiler) compileIfStatement(v *ast.IfStatement, needResult bool) {
 				c.p = p
 			}
 		} else {
-			// TODO: Properly implement dummy compilation (no garbage in block, scope, etc..)
-			p := c.p
-			c.p = &Program{}
-			c.compileStatement(v.Consequent, false)
-			c.p = p
+			c.compileStatementDummy(v.Consequent)
 			if v.Alternate != nil {
 				c.compileStatement(v.Alternate, needResult)
 			} else {
diff --git a/vendor/github.com/dop251/goja/parser/expression.go b/vendor/github.com/dop251/goja/parser/expression.go
index afaf51218..295737960 100644
--- a/vendor/github.com/dop251/goja/parser/expression.go
+++ b/vendor/github.com/dop251/goja/parser/expression.go
@@ -189,27 +189,42 @@ func (self *_parser) parseVariableDeclarationList(var_ file.Idx) []ast.Expressio
 	return list
 }
 
-func (self *_parser) parseObjectPropertyKey() (string, unistring.String) {
+func (self *_parser) parseObjectPropertyKey() (string, ast.Expression) {
 	idx, tkn, literal, parsedLiteral := self.idx, self.token, self.literal, self.parsedLiteral
-	var value unistring.String
+	var value ast.Expression
 	self.next()
 	switch tkn {
 	case token.IDENTIFIER:
-		value = parsedLiteral
+		value = &ast.StringLiteral{
+			Idx:     idx,
+			Literal: literal,
+			Value:   unistring.String(literal),
+		}
 	case token.NUMBER:
-		var err error
-		_, err = parseNumberLiteral(literal)
+		num, err := parseNumberLiteral(literal)
 		if err != nil {
 			self.error(idx, err.Error())
 		} else {
-			value = unistring.String(literal)
+			value = &ast.NumberLiteral{
+				Idx:     idx,
+				Literal: literal,
+				Value:   num,
+			}
 		}
 	case token.STRING:
-		value = parsedLiteral
+		value = &ast.StringLiteral{
+			Idx:     idx,
+			Literal: literal,
+			Value:   parsedLiteral,
+		}
 	default:
 		// null, false, class, etc.
 		if isId(tkn) {
-			value = unistring.String(literal)
+			value = &ast.StringLiteral{
+				Idx:     idx,
+				Literal: literal,
+				Value:   unistring.String(literal),
+			}
 		}
 	}
 	return literal, value
diff --git a/vendor/modules.txt b/vendor/modules.txt
index d6596d6e3..887335c09 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -34,7 +34,7 @@ github.com/davecgh/go-spew/spew
 ## explicit
 github.com/dlclark/regexp2
 github.com/dlclark/regexp2/syntax
-# github.com/dop251/goja v0.0.0-20201020185350-bf18fe8c88fa
+# github.com/dop251/goja v0.0.0-20201022115936-e21ccf39bfce
 ## explicit
 github.com/dop251/goja
 github.com/dop251/goja/ast
