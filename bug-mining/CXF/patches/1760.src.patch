diff --git a/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/FrontendClientAdapter.java b/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/FrontendClientAdapter.java
new file mode 100644
index 0000000000..754711d011
--- /dev/null
+++ b/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/FrontendClientAdapter.java
@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jaxrs.client;
+
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executor;
+
+import javax.xml.namespace.QName;
+
+import org.apache.cxf.Bus;
+import org.apache.cxf.endpoint.ClientCallback;
+import org.apache.cxf.endpoint.ConduitSelector;
+import org.apache.cxf.endpoint.Endpoint;
+import org.apache.cxf.interceptor.Interceptor;
+import org.apache.cxf.message.Exchange;
+import org.apache.cxf.message.Message;
+import org.apache.cxf.service.model.BindingOperationInfo;
+import org.apache.cxf.transport.Conduit;
+
+/**
+ * The adapter between JAX-RS and CXF Frontend Client, can be used in cases
+ * when org.apache.cxf.endpoint.Client is expected by the runtime, example when
+ * bus level features have to applied to a given JAX-RS client instance, etc  
+ */
+class FrontendClientAdapter implements org.apache.cxf.endpoint.Client {
+    private ClientConfiguration config;
+    
+    FrontendClientAdapter(ClientConfiguration config) {
+        this.config = config;
+    }
+    
+    @Override
+    public List<Interceptor<? extends Message>> getInInterceptors() {
+        return config.getInInterceptors();
+    }
+
+    @Override
+    public List<Interceptor<? extends Message>> getOutInterceptors() {
+        return config.getOutInterceptors();
+    }
+
+    @Override
+    public List<Interceptor<? extends Message>> getInFaultInterceptors() {
+        return config.getInFaultInterceptors();
+    }
+
+    @Override
+    public List<Interceptor<? extends Message>> getOutFaultInterceptors() {
+        return config.getOutFaultInterceptors();
+    }
+
+    @Override
+    public Conduit getConduit() {
+        return config.getConduit();
+    }
+
+    @Override
+    public ConduitSelector getConduitSelector() {
+        return config.getConduitSelector();
+    }
+
+    @Override
+    public void setConduitSelector(ConduitSelector selector) {
+        config.setConduitSelector(selector);
+    }
+
+    @Override
+    public Bus getBus() {
+        return config.getBus();
+    }
+    
+    @Override
+    public Endpoint getEndpoint() {
+        throw new UnsupportedOperationException();
+    }
+    
+    @Override
+    public void destroy() {
+        throw new UnsupportedOperationException();
+    }
+    
+    @Override
+    public void onMessage(Message message) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Object[] invoke(String operationName, Object... params) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Object[] invoke(QName operationName, Object... params) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Object[] invokeWrapped(String operationName, Object... params) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Object[] invokeWrapped(QName operationName, Object... params) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Object[] invoke(BindingOperationInfo oi, Object... params) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Object[] invoke(BindingOperationInfo oi, Object[] params, Map<String, Object> context)
+        throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Object[] invoke(BindingOperationInfo oi, Object[] params, Map<String, Object> context,
+                           Exchange exchange) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void invoke(ClientCallback callback, String operationName, Object... params) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void invoke(ClientCallback callback, QName operationName, Object... params) throws Exception {
+        throw new UnsupportedOperationException();
+        
+    }
+
+    @Override
+    public void invokeWrapped(ClientCallback callback, String operationName, Object... params)
+        throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void invokeWrapped(ClientCallback callback, QName operationName, Object... params)
+        throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void invoke(ClientCallback callback, BindingOperationInfo oi, Object... params) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void invoke(ClientCallback callback, BindingOperationInfo oi, Object[] params,
+                       Map<String, Object> context) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void invoke(ClientCallback callback, BindingOperationInfo oi, Object[] params, Exchange exchange)
+        throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void invoke(ClientCallback callback, BindingOperationInfo oi, Object[] params,
+                       Map<String, Object> context, Exchange exchange) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Map<String, Object> getRequestContext() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Map<String, Object> getResponseContext() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setThreadLocalRequestContext(boolean b) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isThreadLocalRequestContext() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setExecutor(Executor executor) {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactoryBean.java b/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactoryBean.java
index c5ba648684..b18438cdc9 100644
--- a/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactoryBean.java
+++ b/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactoryBean.java
@@ -28,6 +28,7 @@ import javax.ws.rs.core.MultivaluedMap;
 import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.common.util.ProxyHelper;
 import org.apache.cxf.configuration.security.AuthorizationPolicy;
+import org.apache.cxf.endpoint.ClientLifeCycleManager;
 import org.apache.cxf.endpoint.ConduitSelector;
 import org.apache.cxf.endpoint.Endpoint;
 import org.apache.cxf.endpoint.UpfrontConduitSelector;
@@ -209,6 +210,7 @@ public class JAXRSClientFactoryBean extends AbstractJAXRSFactoryBean {
                 : new WebClient(actualState);
             initClient(client, ep, actualState == null);
     
+            notifyLifecycleManager(client);
             this.getServiceFactory().sendEvent(FactoryBeanListener.Event.CLIENT_CREATED, client, ep);
             
             return client;
@@ -218,7 +220,12 @@ public class JAXRSClientFactoryBean extends AbstractJAXRSFactoryBean {
         }
     }
 
-    
+    private void notifyLifecycleManager(Object client) {
+        ClientLifeCycleManager mgr = bus.getExtension(ClientLifeCycleManager.class);
+        if (null != mgr) {
+            mgr.clientCreated(new FrontendClientAdapter(WebClient.getConfig(client)));
+        }
+    }    
     
     private ClientState getActualState() {
         if (threadSafe) {
@@ -311,7 +318,9 @@ public class JAXRSClientFactoryBean extends AbstractJAXRSFactoryBean {
                                                                 InvocationHandlerAware.class}, 
                                      proxyImpl);
             }
+            notifyLifecycleManager(actualClient);
             this.getServiceFactory().sendEvent(FactoryBeanListener.Event.CLIENT_CREATED, actualClient, ep);
+            
             return actualClient;
         } catch (IllegalArgumentException ex) {
             String message = ex.getLocalizedMessage();
diff --git a/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/WebClient.java b/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/WebClient.java
index 579bc3c6ca..1ea945a897 100644
--- a/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/WebClient.java
+++ b/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/WebClient.java
@@ -236,13 +236,13 @@ public class WebClient extends AbstractClient {
     }
     
     /**
-     * Converts proxy to Client
-     * @param proxy the proxy
-     * @return proxy as a Client 
+     * Converts object to Client
+     * @param object the object
+     * @return Client object converted to Client 
      */
-    public static Client client(Object proxy) {
-        if (proxy instanceof Client) {
-            return (Client)proxy;
+    public static Client client(Object object) {
+        if (object instanceof Client) {
+            return (Client)object;
         }
         return null;
     }
