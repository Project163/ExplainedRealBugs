diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
index e9e8b5c490..084ccb996c 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
@@ -574,6 +574,38 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
                 && !getWSAddressingFeature(message).isAddressingRequired()) {
                 assertAddressing(message);
             }
+            //CXF-3060 :If wsa policy is not enforced, AddressingProperties map is null and
+            // AddressingFeature.isRequired, requestor checks inbound message and throw exception
+            if (null == theMaps
+                && !ContextUtils.isOutbound(message) 
+                && ContextUtils.isRequestor(message)
+                && getWSAddressingFeature(message) != null
+                && getWSAddressingFeature(message).isAddressingRequired()) {
+                boolean missingWsaHeader = false;
+                AssertionInfoMap aim = message.get(AssertionInfoMap.class);
+                if (aim == null || aim.size() == 0) {
+                    missingWsaHeader = true;
+                }
+                if (aim != null && aim.size() > 0) {
+                    missingWsaHeader = true;
+                    QName[] types = new QName[] {
+                        MetadataConstants.ADDRESSING_ASSERTION_QNAME,
+                        MetadataConstants.USING_ADDRESSING_2004_QNAME,
+                        MetadataConstants.USING_ADDRESSING_2005_QNAME,
+                        MetadataConstants.USING_ADDRESSING_2006_QNAME
+                    };
+                    for (QName type : types) {
+                        if (aim.containsKey(type) && aim.get(type).size() > 0) {
+                            missingWsaHeader = false;
+                        }
+                    }
+                }
+                if (missingWsaHeader) {
+                    String reason = BUNDLE.getString("MISSING_ACTION_MESSAGE");
+                    throw new SoapFault(reason, new QName(Names.WSA_NAMESPACE_NAME,
+                                                          Names.HEADER_REQUIRED_NAME));
+                }
+            }
         }
         return continueProcessing;
     }
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_disable/WSADisableTest.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_disable/WSADisableTest.java
index f6202ffc63..6c6354d23f 100644
--- a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_disable/WSADisableTest.java
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_disable/WSADisableTest.java
@@ -117,6 +117,25 @@ public class WSADisableTest extends AbstractWSATestBase {
             //expected
         }
     }
+    
+    //CXF-3060
+    @Test
+    public void testDisableServerEnableClientRequired() throws Exception {
+        AddNumbersPortType port = getService().getAddNumbersPort(new AddressingFeature(true, true));
+
+        ((BindingProvider)port).getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
+                                                        "http://localhost:" + PORT + "/jaxws/add");
+        try {
+            port.addNumbers(1, 2);
+            fail("Expected missing WSA header exception");
+        } catch (Exception e) {
+            String expected = "A required header representing a Message Addressing"
+                              + " Property is not present";
+            assertTrue("Caught unexpected exception : " + e.getMessage(),
+                       e.getMessage().indexOf(expected) > -1);
+        }
+    }
+    
 
     private AddNumbersService getService() {
         URL wsdl = getClass().getResource("/wsdl_systest_wsspec/add_numbers.wsdl");
