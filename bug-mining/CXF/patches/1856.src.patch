diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/context/WrappedAttachments.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/context/WrappedAttachments.java
new file mode 100644
index 0000000000..37e46e7b91
--- /dev/null
+++ b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/context/WrappedAttachments.java
@@ -0,0 +1,200 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.jaxws.context;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+import javax.activation.DataHandler;
+
+import org.apache.cxf.attachment.AttachmentImpl;
+import org.apache.cxf.message.Attachment;
+
+/**
+ * This is a package local attachments wrapper class to treat the jaxws attachments
+ * as CXF's attachments.
+ */
+class WrappedAttachments implements Set<Attachment> {
+    private Map<String, DataHandler> attachments;
+    private Map<String, Attachment> cache;
+        
+    public WrappedAttachments(Map<String, DataHandler> attachments) {
+        this.attachments = attachments;
+        this.cache = new HashMap<String, Attachment>();
+    }
+        
+    public int size() {
+        return attachments.size();
+    }
+
+    public boolean isEmpty() {
+        return attachments.isEmpty();
+    }
+
+    public boolean contains(Object o) {
+        if (o instanceof Attachment) {
+            return attachments.containsKey(((Attachment) o).getId());
+        }
+        return false;
+    }
+
+    public Iterator<Attachment> iterator() {
+        return new WrappedAttachmentsIterator(attachments.entrySet().iterator());
+    }
+
+    public Object[] toArray() {
+        Object[] obj = new Object[attachments.size()];
+        int i = 0;
+        for (Map.Entry<String, DataHandler> entry : attachments.entrySet()) {
+            Attachment o = cache.get(entry.getKey());
+            if (o == null) {
+                o = new AttachmentImpl(entry.getKey(), entry.getValue());
+                cache.put(entry.getKey(), o);
+            }
+            obj[i++] = o;
+        }
+        return obj;
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T> T[] toArray(T[] a) {
+        Object[] obj = toArray();
+        return (T[])Arrays.copyOf(obj, obj.length, a.getClass());
+    }
+
+    public boolean add(Attachment e) {
+        if (!attachments.containsKey(e.getId())) {
+            attachments.put(e.getId(), e.getDataHandler());
+            cache.put(e.getId(), e);
+            return true;
+        }
+        return false;
+    }
+
+    public boolean remove(Object o) {
+        if (o instanceof Attachment) {
+            cache.remove(((Attachment) o).getId());
+            return attachments.remove(((Attachment) o).getId()) != null; 
+        }
+        return false;
+    }
+
+    public boolean containsAll(Collection<?> c) {
+        boolean b = true;
+        for (Iterator<?> it = c.iterator(); it.hasNext();) {
+            Object o = it.next();
+            if (!(o instanceof Attachment) && attachments.containsKey(((Attachment) o).getId())) {
+                b = false;
+                break;
+            }
+        }
+        return b;
+    }
+
+    public boolean addAll(Collection<? extends Attachment> c) {
+        boolean b = false;
+        for (Iterator<? extends Attachment> it = c.iterator(); it.hasNext();) {
+            Attachment o = it.next();
+            if (!attachments.containsKey(o.getId())) {
+                b = true;
+                attachments.put(o.getId(), o.getDataHandler());
+                cache.put(o.getId(), o);
+            }
+        }
+        return b;
+    }
+
+    public boolean retainAll(Collection<?> c) {
+        boolean b = false;
+        Set<String> ids = new HashSet<String>();
+        for (Iterator<?> it = c.iterator(); it.hasNext();) {
+            Object o = it.next();
+            if (o instanceof Attachment) {
+                ids.add(((Attachment)o).getId());
+            }
+        }
+        
+        for (Iterator<String> it = attachments.keySet().iterator(); it.hasNext();) {
+            String k = it.next();
+            if (!ids.contains(k)) {
+                b = true;
+                it.remove();
+                cache.remove(k);
+            }
+        }
+        return b;
+    }
+
+    public boolean removeAll(Collection<?> c) {
+        boolean b = false;
+        for (Iterator<?> it = c.iterator(); it.hasNext();) {
+            Object o = it.next();
+            if (o instanceof Attachment && attachments.containsKey(((Attachment) o).getId())) {
+                b = true;
+                attachments.remove(((Attachment) o).getId());
+                cache.remove(((Attachment) o).getId());
+            }
+        }
+        return b;
+    }
+
+    public void clear() {
+        attachments.clear();
+        cache.clear();
+    }
+
+    Map<String, DataHandler> getAttachments() {
+        return attachments;
+    }
+    
+    class WrappedAttachmentsIterator implements Iterator<Attachment> {
+        private Iterator<Map.Entry<String, DataHandler>> iterator;
+        private String key;
+        
+        public WrappedAttachmentsIterator(Iterator<Map.Entry<String, DataHandler>> iterator) { 
+            this.iterator = iterator;
+        }
+            
+        public boolean hasNext() {
+            return iterator.hasNext();
+        }
+
+        public Attachment next() {
+            Map.Entry<String, DataHandler> e = iterator.next();
+            key = e.getKey();
+            Attachment o = cache.get(key);
+            if (o == null) {
+                o = new AttachmentImpl(key, e.getValue());
+                cache.put(key, o);
+            }
+            return o;
+        }
+
+        public void remove() {
+            iterator.remove();
+            cache.remove(key);
+        }
+    }
+}
diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/context/WrappedMessageContext.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/context/WrappedMessageContext.java
index e1892dce03..c61e1bbc6e 100644
--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/context/WrappedMessageContext.java
+++ b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/context/WrappedMessageContext.java
@@ -358,11 +358,15 @@ public class WrappedMessageContext implements MessageContext {
             return null;
         }
         Collection<Attachment> attachments = CastUtils.cast((Collection<?>)mc.get(Message.ATTACHMENTS));
-        Map<String, DataHandler> dataHandlers = 
-            AttachmentUtil.getDHMap(attachments);
-        mc.put(propertyName, 
-               dataHandlers);
-        scopes.put(propertyName, Scope.APPLICATION);
+        Map<String, DataHandler> dataHandlers;
+        if (attachments instanceof WrappedAttachments) {
+            dataHandlers = ((WrappedAttachments) attachments).getAttachments();
+        } else {
+            dataHandlers = AttachmentUtil.getDHMap(attachments);
+            mc.put(propertyName, 
+                   dataHandlers);
+            scopes.put(propertyName, Scope.APPLICATION);
+        }
         return dataHandlers;
     }    
         
@@ -416,7 +420,6 @@ public class WrappedMessageContext implements MessageContext {
         Object ret = null;
         if ((MessageContext.HTTP_RESPONSE_HEADERS.equals(key)
             || MessageContext.HTTP_RESPONSE_CODE.equals(key)
-            || MessageContext.OUTBOUND_MESSAGE_ATTACHMENTS.equals(key)
             || MessageContext.HTTP_RESPONSE_CODE.equals(key))
             && !isResponse() && !isRequestor()) { 
             Message tmp = createResponseMessage();
@@ -447,6 +450,9 @@ public class WrappedMessageContext implements MessageContext {
             authPolicy.setPassword((String)value);
         } else if (MessageContext.HTTP_REQUEST_HEADERS.equals(key)) {
             ret = message.put(Message.PROTOCOL_HEADERS, value);
+        } else if (MessageContext.OUTBOUND_MESSAGE_ATTACHMENTS.equals(key)) {
+            Map<String, DataHandler> attachments = CastUtils.cast((Map<?, ?>)value);
+            ret = message.put(Message.ATTACHMENTS, new WrappedAttachments(attachments));
         } else if (SoapBindingConstants.SOAP_ACTION.equals(mappedKey)
             && !isRequestor() && exchange != null) {
             Message tmp = createResponseMessage();
diff --git a/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/context/WrappedMessageContextTest.java b/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/context/WrappedMessageContextTest.java
new file mode 100644
index 0000000000..674791d3c0
--- /dev/null
+++ b/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/context/WrappedMessageContextTest.java
@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.jaxws.context;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import javax.activation.DataHandler;
+import javax.mail.util.ByteArrayDataSource;
+import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.MessageContext.Scope;
+
+import org.apache.cxf.attachment.AttachmentImpl;
+import org.apache.cxf.helpers.CastUtils;
+import org.apache.cxf.message.Attachment;
+import org.apache.cxf.message.Message;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * 
+ */
+public class WrappedMessageContextTest extends Assert {
+    @Test
+    public void testPutAndGetJaxwsAttachments() throws Exception {
+        WrappedMessageContext context = 
+            new WrappedMessageContext(new HashMap<String, Object>(), null, Scope.APPLICATION);
+
+        DataHandler dh1 = new DataHandler(new ByteArrayDataSource("Hello world!".getBytes(), "text/plain"));
+        DataHandler dh2 = new DataHandler(new ByteArrayDataSource("Hola mundo!".getBytes(), "text/plain"));
+        DataHandler dh3 = new DataHandler(new ByteArrayDataSource("Bonjour tout le monde!".getBytes(), "text/plain"));
+        Map<String, DataHandler> jattachments = new HashMap<String, DataHandler>();
+        context.put(MessageContext.OUTBOUND_MESSAGE_ATTACHMENTS, jattachments);
+        
+        jattachments.put("attachment-1", dh1);                
+
+        Set<Attachment> cattachments = CastUtils.cast((Set<?>)context.get(Message.ATTACHMENTS));
+        assertNotNull(cattachments);
+        
+        assertEquals(1, cattachments.size());
+        
+        jattachments.put("attachment-2", dh2);
+        
+        assertEquals(2, cattachments.size());
+        
+        AttachmentImpl ca = new AttachmentImpl("attachment-3", dh3);
+        ca.setHeader("X-test", "true");
+        cattachments.add(ca); 
+
+        assertEquals(3, jattachments.size());
+        assertEquals(3, cattachments.size());
+        for (Attachment a : cattachments) {
+            if ("attachment-1".equals(a.getId())) {
+                assertEquals("Hello world!", a.getDataHandler().getContent());
+            } else if ("attachment-2".equals(a.getId())) {
+                assertEquals("Hola mundo!", a.getDataHandler().getContent());
+            } else if ("attachment-3".equals(a.getId())) {
+                assertEquals("Bonjour tout le monde!", a.getDataHandler().getContent());
+                assertEquals("true", a.getHeader("X-test"));
+            } else {
+                fail("unknown attachment");
+            }
+        }
+    }
+}
