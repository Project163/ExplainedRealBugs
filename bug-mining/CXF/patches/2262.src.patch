diff --git a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketConstants.java b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketConstants.java
index 64efc1d82f..ec78cb4cb7 100644
--- a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketConstants.java
+++ b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketConstants.java
@@ -23,8 +23,8 @@ package org.apache.cxf.transport.websocket;
  * 
  */
 public final class WebSocketConstants {
-    public static final String DEFAULT_REQUEST_ID_KEY = "requestId";
-    public static final String DEFAULT_RESPONSE_ID_KEY = "responseId";
+    public static final String DEFAULT_REQUEST_ID_KEY = "Request-Id";
+    public static final String DEFAULT_RESPONSE_ID_KEY = "Response-Id";
 
     private WebSocketConstants() {
     }
diff --git a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketVirtualServletRequest.java b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketVirtualServletRequest.java
index 9f7bc1a08e..fabe28c9c4 100644
--- a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketVirtualServletRequest.java
+++ b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketVirtualServletRequest.java
@@ -408,6 +408,10 @@ public class WebSocketVirtualServletRequest implements HttpServletRequest {
         LOG.log(Level.INFO, "getPathTranslated");
         String path = getPathInfo();
         String opathtrans = webSocketHolder.getPathTranslated();
+        // some container may choose not to return this value
+        if (opathtrans == null) {
+            return null;
+        }
         String opathinfo = webSocketHolder.getPathInfo();
         int pos = opathtrans.indexOf(opathinfo);
         //REVISIT may cache this value in requstHeaders?
diff --git a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketVirtualServletResponse.java b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketVirtualServletResponse.java
index 1594dab616..d1fa3b1ac1 100644
--- a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketVirtualServletResponse.java
+++ b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/WebSocketVirtualServletResponse.java
@@ -19,6 +19,7 @@
 
 package org.apache.cxf.transport.websocket;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Collection;
@@ -41,25 +42,17 @@ public class WebSocketVirtualServletResponse implements HttpServletResponse {
     private static final Logger LOG = LogUtils.getL7dLogger(WebSocketVirtualServletResponse.class);
     private WebSocketServletHolder webSocketHolder;
     private Map<String, String> responseHeaders;
-    private boolean flushed;
+    private ServletOutputStream outputStream;
 
     public WebSocketVirtualServletResponse(WebSocketServletHolder websocket) {
         this.webSocketHolder = websocket;
         this.responseHeaders = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
+        this.outputStream = createOutputStream();
     }
 
     @Override
     public void flushBuffer() throws IOException {
         LOG.log(Level.INFO, "flushBuffer()");
-        if (!flushed) {
-            //REVISIT this mechanism to determine if the headers have been flushed
-            if (responseHeaders.get(WebSocketUtils.FLUSHED_KEY) == null) {
-                byte[] data = WebSocketUtils.buildResponse(responseHeaders, null, 0, 0);
-                webSocketHolder.write(data, 0, data.length);
-                responseHeaders.put(WebSocketUtils.FLUSHED_KEY, "true");
-            }
-            flushed = true;
-        }
     }
 
     @Override
@@ -88,42 +81,7 @@ public class WebSocketVirtualServletResponse implements HttpServletResponse {
 
     @Override
     public ServletOutputStream getOutputStream() throws IOException {
-        return new ServletOutputStream() {
-
-            @Override
-            public void write(int b) throws IOException {
-                byte[] data = new byte[1];
-                data[0] = (byte)b;
-                write(data, 0, 1);
-            }
-
-            @Override
-            public void write(byte[] data) throws IOException {
-                write(data, 0, data.length);
-            }
-            
-            @Override
-            public void write(byte[] data, int offset, int length) throws IOException {
-                if (responseHeaders.get(WebSocketUtils.FLUSHED_KEY) == null) {
-                    data = WebSocketUtils.buildResponse(responseHeaders, data, offset, length);
-                    responseHeaders.put(WebSocketUtils.FLUSHED_KEY, "true");
-                } else {
-                    data = WebSocketUtils.buildResponse(data, offset, length);
-                }
-                webSocketHolder.write(data, 0, data.length);
-            }
-
-            @Override
-            public void close() throws IOException {
-                if (responseHeaders.get(WebSocketUtils.FLUSHED_KEY) == null) {
-                    byte[] data = WebSocketUtils.buildResponse(responseHeaders, null, 0, 0);
-                    webSocketHolder.write(data, 0, data.length);
-                    responseHeaders.put(WebSocketUtils.FLUSHED_KEY, "true");
-                }
-                super.close();
-            }
-            
-        };
+        return outputStream;
     }
 
     @Override
@@ -347,4 +305,59 @@ public class WebSocketVirtualServletResponse implements HttpServletResponse {
         responseHeaders.put(WebSocketUtils.SC_KEY, Integer.toString(sc));
         responseHeaders.put(WebSocketUtils.SM_KEY, sm);
     }
+
+    private ServletOutputStream createOutputStream() {
+        return new ServletOutputStream() {
+            //REVISIT
+            // This output buffering is needed as the server side websocket does
+            // not support the fragment transmission mode when sending back a large data.
+            // And this buffering is only used for the response for the initial service innovation.
+            // For the subsequently pushed data to the socket are sent back
+            // unbuffered as individual websocket messages.
+            // the things to consider :
+            // - provide a size limit if we are use this buffering
+            // - add a chunking mode in the cxf websocket's binding.
+            private InternalByteArrayOutputStream buffer = new InternalByteArrayOutputStream();
+
+            @Override
+            public void write(int b) throws IOException {
+                byte[] data = new byte[1];
+                data[0] = (byte)b;
+                write(data, 0, 1);
+            }
+
+            @Override
+            public void write(byte[] data) throws IOException {
+                write(data, 0, data.length);
+            }
+
+            @Override
+            public void write(byte[] data, int offset, int length) throws IOException {
+                if (responseHeaders.get(WebSocketUtils.FLUSHED_KEY) == null) {
+                    // buffer the data until it gets flushed
+                    buffer.write(data, offset, length);
+                } else {
+                    // unbuffered write to the socket
+                    data = WebSocketUtils.buildResponse(data, offset, length);
+                    webSocketHolder.write(data, 0, data.length);
+                }
+            }
+
+            @Override
+            public void close() throws IOException {
+                if (responseHeaders.get(WebSocketUtils.FLUSHED_KEY) == null) {
+                    byte[] data = WebSocketUtils.buildResponse(responseHeaders, buffer.getBytes(), 0, buffer.size());
+                    webSocketHolder.write(data, 0, data.length);
+                    responseHeaders.put(WebSocketUtils.FLUSHED_KEY, "true");
+                }
+                super.close();
+            }
+        };
+    }
+
+    private static class InternalByteArrayOutputStream extends ByteArrayOutputStream {
+        public byte[] getBytes() {
+            return buf;
+        }
+    }
 }
diff --git a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/ahc/AhcWebSocketConduit.java b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/ahc/AhcWebSocketConduit.java
index 5da490e3bc..4275d20fda 100644
--- a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/ahc/AhcWebSocketConduit.java
+++ b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/ahc/AhcWebSocketConduit.java
@@ -23,6 +23,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.MalformedURLException;
+import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.util.Collections;
 import java.util.HashMap;
@@ -298,7 +299,7 @@ public class AhcWebSocketConduit extends URLConnectionHTTPConduit {
                     }
                 }
                 if (response == null) {
-                    throw new IOException("timeout");
+                    throw new SocketTimeoutException("Read timed out while invoking " + entity.getUri());
                 }
             }
             return response;
diff --git a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/jetty/JettyWebSocket.java b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/jetty/JettyWebSocket.java
index 1685338ca5..00860950d1 100644
--- a/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/jetty/JettyWebSocket.java
+++ b/rt/transports/websocket/src/main/java/org/apache/cxf/transport/websocket/jetty/JettyWebSocket.java
@@ -202,6 +202,7 @@ class JettyWebSocket implements WebSocket.OnBinaryMessage, WebSocket.OnTextMessa
             properties.put("locale", request.getLocale());
             properties.put("locales", request.getLocales());
             properties.put("remoteHost", request.getRemoteHost());
+            properties.put("remotePort", request.getRemotePort());
             properties.put("remoteAddr", request.getRemoteAddr());
             properties.put("serverName", request.getServerName());
             properties.put("serverPort", request.getServerPort());
diff --git a/systests/jaxws/pom.xml b/systests/jaxws/pom.xml
index 82538f4338..825cfa5966 100644
--- a/systests/jaxws/pom.xml
+++ b/systests/jaxws/pom.xml
@@ -123,11 +123,22 @@
             <artifactId>cxf-rt-transports-http-jetty</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.cxf</groupId>
+            <artifactId>cxf-rt-transports-websocket</artifactId>
+            <version>${project.version}</version>
+        </dependency>
         <dependency>
             <groupId>org.apache.cxf</groupId>
             <artifactId>cxf-rt-features-clustering</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-websocket</artifactId>
+            <version>${cxf.jetty.version}</version>
+            <scope>test</scope>
+        </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-jdk14</artifactId>
@@ -220,6 +231,24 @@
             </exclusions>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>com.ning</groupId>
+            <artifactId>async-http-client</artifactId>
+            <version>${cxf.ahc.version}</version>
+            <scope>test</scope>
+            <exclusions>
+                <exclusion>
+                    <groupId>io.netty</groupId>
+                    <artifactId>netty</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty</artifactId>
+            <version>${cxf.netty3.version}</version>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
     <profiles>
         <profile>
diff --git a/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/websocket/ClientServerWebSocketTest.java b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/websocket/ClientServerWebSocketTest.java
new file mode 100644
index 0000000000..336fbe98f2
--- /dev/null
+++ b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/websocket/ClientServerWebSocketTest.java
@@ -0,0 +1,258 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.jaxws.websocket;
+
+import java.lang.reflect.UndeclaredThrowableException;
+import java.net.URL;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.logging.Logger;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.BindingProvider;
+
+import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.configuration.security.AuthorizationPolicy;
+import org.apache.cxf.endpoint.Client;
+import org.apache.cxf.frontend.ClientProxy;
+import org.apache.cxf.message.Message;
+import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
+import org.apache.cxf.transport.http.HTTPConduit;
+import org.apache.hello_world_soap_http.BadRecordLitFault;
+import org.apache.hello_world_soap_http.Greeter;
+import org.apache.hello_world_soap_http.NoSuchCodeLitFault;
+import org.apache.hello_world_soap_http.SOAPService;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class ClientServerWebSocketTest extends AbstractBusClientServerTestBase {
+    static final String PORT = allocatePort(Server.class);
+
+    static final Logger LOG = LogUtils.getLogger(ClientServerWebSocketTest.class);
+    private final QName serviceName = new QName("http://apache.org/hello_world_soap_http",
+                                                "SOAPService");    
+    private final QName portName = new QName("http://apache.org/hello_world_soap_http",
+                                             "SoapPort");
+    
+    @BeforeClass
+    public static void startServers() throws Exception {                    
+        // set up configuration to enable schema validation
+        assertTrue("server did not launch correctly", launchServer(Server.class, true));
+        createStaticBus();
+    }
+    
+    @Test
+    public void testBasicConnection() throws Exception {
+
+        SOAPService service = new SOAPService();
+
+        Greeter greeter = service.getPort(portName, Greeter.class);
+        updateGreeterAddress(greeter, PORT);
+
+        try {
+            String reply = greeter.greetMe("test");
+            assertNotNull("no response received from service", reply);
+            assertEquals("Hello test", reply);
+
+            reply = greeter.sayHi();
+            assertNotNull("no response received from service", reply);
+            assertEquals("Bonjour", reply);
+        } catch (UndeclaredThrowableException ex) {
+            throw (Exception)ex.getCause();
+        }
+        BindingProvider bp = (BindingProvider)greeter;
+        Map<String, Object> responseContext = bp.getResponseContext();
+        Integer responseCode = (Integer) responseContext.get(Message.RESPONSE_CODE);        
+        assertEquals(200, responseCode.intValue());
+    }
+    
+    @Test
+    public void testBasicConnection2() throws Exception {
+        URL wsdl = getClass().getResource("/wsdl/hello_world.wsdl");
+        assertNotNull(wsdl);
+        
+        SOAPService service = new SOAPService(wsdl, serviceName);
+        
+        //getPort only passing in SEI
+        Greeter greeter = service.getPort(Greeter.class);
+        updateGreeterAddress(greeter, PORT);
+        
+        String response1 = new String("Hello Milestone-");
+        String response2 = new String("Bonjour");
+        try {       
+            for (int idx = 0; idx < 5; idx++) {
+                String greeting = greeter.greetMe("Milestone-" + idx);
+                assertNotNull("no response received from service", greeting);
+                String exResponse = response1 + idx;
+                assertEquals(exResponse, greeting);
+                
+                String reply = greeter.sayHi();
+                assertNotNull("no response received from service", reply);
+                assertEquals(response2, reply);
+
+                greeter.greetMeOneWay("Milestone-" + idx);
+            }            
+        } catch (UndeclaredThrowableException ex) {
+            throw (Exception)ex.getCause();
+        }
+    } 
+
+    @Test
+    public void testTimeoutConfigutation() throws Exception {
+
+        SOAPService service = new SOAPService();
+
+        Greeter greeter = service.getPort(portName, Greeter.class);
+        updateGreeterAddress(greeter, PORT);
+
+        ((javax.xml.ws.BindingProvider)greeter).getRequestContext().put("javax.xml.ws.client.receiveTimeout",
+                                                                        "1");
+        try {
+            greeter.greetMe("test");
+            // remove fail() check to let this test pass in the powerful machine
+        } catch (Throwable ex) {
+            Object cause = null;
+            if (ex.getCause() != null) {
+                cause = ex.getCause();
+            }
+            assertTrue("Timeout cause is expected", cause instanceof java.net.SocketTimeoutException);
+        }
+    }    
+
+    @Test
+    public void testBasicConnectionAndOneway() throws Exception {
+        URL wsdl = getClass().getResource("/wsdl/hello_world.wsdl");
+        assertNotNull(wsdl);
+        
+        SOAPService service = new SOAPService(wsdl, serviceName);
+        
+        Greeter greeter = service.getPort(portName, Greeter.class);
+        updateGreeterAddress(greeter, PORT);
+        
+        String response1 = new String("Hello Milestone-");
+        String response2 = new String("Bonjour");
+        try {       
+            for (int idx = 0; idx < 1; idx++) {
+                String greeting = greeter.greetMe("Milestone-" + idx);
+                assertNotNull("no response received from service", greeting);
+                String exResponse = response1 + idx;
+                assertEquals(exResponse, greeting);
+                
+                String reply = greeter.sayHi();
+                assertNotNull("no response received from service", reply);
+                assertEquals(response2, reply);
+
+                greeter.greetMeOneWay("Milestone-" + idx);
+                
+                
+                
+            }            
+        } catch (UndeclaredThrowableException ex) {
+            throw (Exception)ex.getCause();
+        }
+    } 
+    
+    @Test
+    public void testFaults() throws Exception {
+        URL wsdl = getClass().getResource("/wsdl/hello_world.wsdl");
+        assertNotNull(wsdl);
+        
+        SOAPService service = new SOAPService(wsdl, serviceName);
+        ExecutorService ex = Executors.newFixedThreadPool(1);
+        service.setExecutor(ex);
+        assertNotNull(service);
+
+        String noSuchCodeFault = "NoSuchCodeLitFault";
+        String badRecordFault = "BadRecordLitFault";
+
+        Greeter greeter = service.getPort(portName, Greeter.class);
+        updateGreeterAddress(greeter, PORT);
+
+        for (int idx = 0; idx < 2; idx++) {
+            try {
+                greeter.testDocLitFault(noSuchCodeFault);
+                fail("Should have thrown NoSuchCodeLitFault exception");
+            } catch (NoSuchCodeLitFault nslf) {
+                assertNotNull(nslf.getFaultInfo());
+                assertNotNull(nslf.getFaultInfo().getCode());
+            } 
+            
+            try {
+                greeter.testDocLitFault(badRecordFault);
+                fail("Should have thrown BadRecordLitFault exception");
+            } catch (BadRecordLitFault brlf) {                
+                BindingProvider bp = (BindingProvider)greeter;
+                Map<String, Object> responseContext = bp.getResponseContext();
+                String contentType = (String) responseContext.get(Message.CONTENT_TYPE);
+                assertEquals("text/xml; charset=utf-8", contentType.toLowerCase());
+                Integer responseCode = (Integer) responseContext.get(Message.RESPONSE_CODE);
+                assertEquals(500, responseCode.intValue());                
+                assertNotNull(brlf.getFaultInfo());
+                assertEquals("BadRecordLitFault", brlf.getFaultInfo());
+            }
+                        
+        }
+
+    }
+
+    @Test
+    @org.junit.Ignore //TODO need to pass the principal of the original upgrade request to its subsequent service calls
+    public void testBasicAuth() throws Exception {
+        URL wsdl = getClass().getResource("/wsdl/hello_world.wsdl");
+        assertNotNull(wsdl);
+        
+        SOAPService service = new SOAPService(wsdl, serviceName);
+        Greeter greeter = service.getPort(portName, Greeter.class);
+        updateGreeterAddress(greeter, PORT);
+
+        try {
+            //try the jaxws way
+            BindingProvider bp = (BindingProvider)greeter;
+            bp.getRequestContext().put(BindingProvider.USERNAME_PROPERTY, "BJ");
+            bp.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY, "pswd");
+            String s = greeter.greetMe("secure");
+            assertEquals("Hello BJ", s);
+            bp.getRequestContext().remove(BindingProvider.USERNAME_PROPERTY);
+            bp.getRequestContext().remove(BindingProvider.PASSWORD_PROPERTY);
+            
+            //try setting on the conduit directly
+            Client client = ClientProxy.getClient(greeter);
+            HTTPConduit httpConduit = (HTTPConduit)client.getConduit();
+            AuthorizationPolicy policy = new AuthorizationPolicy();
+            policy.setUserName("BJ2");
+            policy.setPassword("pswd");
+            httpConduit.setAuthorization(policy);
+            
+            s = greeter.greetMe("secure");
+            assertEquals("Hello BJ2", s);
+        } catch (UndeclaredThrowableException ex) {
+            throw (Exception)ex.getCause();
+        }
+    }
+
+    private void updateGreeterAddress(Greeter greeter, String port) {
+        ((BindingProvider)greeter).getRequestContext()
+            .put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
+                 "ws://localhost:" + PORT + "/SoapContext/SoapPort");
+    }
+
+}
diff --git a/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/websocket/Server.java b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/websocket/Server.java
new file mode 100644
index 0000000000..6ffe044786
--- /dev/null
+++ b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/websocket/Server.java
@@ -0,0 +1,81 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.jaxws.websocket;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.jws.WebService;
+import javax.xml.ws.Endpoint;
+
+import org.apache.cxf.jaxws.EndpointImpl;
+import org.apache.cxf.testutil.common.AbstractBusTestServerBase;
+import org.apache.hello_world_soap_http.BaseGreeterImpl;
+import org.apache.hello_world_soap_http.GreeterImpl;
+
+public class Server extends AbstractBusTestServerBase {
+    static final String PORT = allocatePort(Server.class);
+    static final String BOGUS_REAL_PORT = allocatePort(Server.class, 2);
+
+    List<Endpoint> eps = new LinkedList<Endpoint>();
+
+    protected void run() {
+        Object implementor;
+        String address;
+
+        implementor = new GreeterImpl();
+        address = "ws://localhost:" + PORT + "/SoapContext/SoapPort";
+        Endpoint ep = Endpoint.publish(address, implementor);
+        eps.add(ep);
+
+        //publish port with soap12 binding
+        address = "ws://localhost:" + PORT + "/SoapContext/SoapPort";
+        EndpointImpl e = (EndpointImpl) Endpoint.create(javax.xml.ws.soap.SOAPBinding.SOAP12HTTP_BINDING, 
+                                                        new Greeter12Impl());
+        e.publish(address);
+        eps.add(e);
+    }
+    
+    public void tearDown() {
+        while (!eps.isEmpty()) {
+            Endpoint ep = eps.remove(0);
+            ep.stop();
+        }
+    }    
+    
+    @WebService(endpointInterface = "org.apache.hello_world_soap_http.Greeter",
+                targetNamespace = "http://apache.org/hello_world_soap_http")
+    public class Greeter12Impl extends BaseGreeterImpl {
+
+    }
+    
+
+    public static void main(String[] args) {
+        try {
+            Server s = new Server();
+            s.start();
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            System.exit(-1);
+        } finally {
+            System.out.println("done!");
+        }
+    }
+}
