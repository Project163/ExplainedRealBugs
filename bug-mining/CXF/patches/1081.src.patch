diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapPreProtocolOutInterceptor.java b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapPreProtocolOutInterceptor.java
index 202e512b46..d919be1daa 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapPreProtocolOutInterceptor.java
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapPreProtocolOutInterceptor.java
@@ -140,6 +140,11 @@ public class SoapPreProtocolOutInterceptor extends AbstractSoapInterceptor {
             if (boi == null) {
                 action = "\"\"";
             } else {
+                BindingOperationInfo dboi = 
+                    (BindingOperationInfo)boi.getProperty("dispatchToOperation");
+                if (null != dboi) {
+                    boi = dboi;
+                }
                 SoapOperationInfo soi = (SoapOperationInfo) boi.getExtensor(SoapOperationInfo.class);
                 action = soi == null ? "\"\"" : soi.getAction() == null ? "\"\"" : soi.getAction();
             }
diff --git a/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/interceptor/SoapPreProtocolOutInterceptorTest.java b/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/interceptor/SoapPreProtocolOutInterceptorTest.java
new file mode 100755
index 0000000000..32baaff262
--- /dev/null
+++ b/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/interceptor/SoapPreProtocolOutInterceptorTest.java
@@ -0,0 +1,137 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.binding.soap.interceptor;
+
+import java.lang.reflect.Method;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.namespace.QName;
+
+import junit.framework.Assert;
+
+import org.apache.cxf.binding.soap.SoapMessage;
+import org.apache.cxf.binding.soap.model.SoapOperationInfo;
+import org.apache.cxf.helpers.CastUtils;
+import org.apache.cxf.message.Exchange;
+import org.apache.cxf.message.ExchangeImpl;
+import org.apache.cxf.message.Message;
+import org.apache.cxf.message.MessageImpl;
+import org.apache.cxf.service.model.BindingOperationInfo;
+import org.apache.cxf.service.model.InterfaceInfo;
+import org.apache.cxf.service.model.MessageInfo.Type;
+import org.apache.cxf.service.model.OperationInfo;
+import org.apache.cxf.service.model.ServiceInfo;
+import org.easymock.classextension.EasyMock;
+import org.easymock.classextension.IMocksControl;
+
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * 
+ */
+public class SoapPreProtocolOutInterceptorTest extends Assert {
+    private IMocksControl control;
+    private SoapPreProtocolOutInterceptor interceptor;
+    
+    @Before
+    public void setUp() {
+        control = EasyMock.createNiceControl();
+        interceptor = new SoapPreProtocolOutInterceptor();
+    }
+
+    @Test
+    public void testRequestorOutboundSoapAction() throws Exception {
+        SoapMessage message = setUpMessage();
+        interceptor.handleMessage(message);
+        control.verify();
+
+        Map<String, List<String>> reqHeaders = CastUtils.cast((Map)message.get(Message.PROTOCOL_HEADERS));
+        assertNotNull(reqHeaders);
+        List<String> soapaction = reqHeaders.get("soapaction");
+        assertTrue(null != soapaction && soapaction.size() == 1);
+        assertEquals("\"http://foo/bar/SEI/opReq\"", soapaction.get(0));
+    }
+
+    @Test
+    public void testRequestorOutboundDispatchedSoapAction() throws Exception {
+        SoapMessage message = setUpMessage();
+        BindingOperationInfo dbop = setUpBindingOperationInfo("http://foo/bar/d",
+                                                              "opDReq",
+                                                              "opDResp",
+                                                              SEI.class.getMethod("op", new Class[0]));
+        SoapOperationInfo soi = new SoapOperationInfo();
+        soi.setAction("http://foo/bar/d/SEI/opDReq");
+        dbop.addExtensor(soi);
+
+        BindingOperationInfo bop = message.getExchange().get(BindingOperationInfo.class);
+        bop.setProperty("dispatchToOperation", dbop);
+
+        interceptor.handleMessage(message);
+        control.verify();
+
+        Map<String, List<String>> reqHeaders = CastUtils.cast((Map)message.get(Message.PROTOCOL_HEADERS));
+        assertNotNull(reqHeaders);
+        List<String> soapaction = reqHeaders.get("soapaction");
+        assertTrue(null != soapaction && soapaction.size() == 1);
+        assertEquals("\"http://foo/bar/d/SEI/opDReq\"", soapaction.get(0));
+    }
+
+    private SoapMessage setUpMessage() throws Exception {
+        
+        SoapMessage message = new SoapMessage(new MessageImpl());
+        Exchange exchange = new ExchangeImpl();
+        BindingOperationInfo bop = setUpBindingOperationInfo("http://foo/bar",
+                                                             "opReq",
+                                                             "opResp",
+                                                             SEI.class.getMethod("op", new Class[0]));
+        SoapOperationInfo sop = new SoapOperationInfo();
+        sop.setAction("http://foo/bar/SEI/opReq");
+        bop.addExtensor(sop);
+        exchange.put(BindingOperationInfo.class, bop);
+        message.setExchange(exchange);
+        message.put(Message.REQUESTOR_ROLE, Boolean.TRUE);
+        
+        control.replay();
+        return message;
+    }
+    
+    private BindingOperationInfo setUpBindingOperationInfo(String nsuri, 
+                                                           String opreq,
+                                                           String opresp,
+                                                           Method method) {
+        ServiceInfo si = new ServiceInfo();
+        InterfaceInfo iinf = new InterfaceInfo(si, 
+                                               new QName(nsuri, method.getDeclaringClass().getSimpleName()));
+        OperationInfo opInfo = iinf.addOperation(new QName(nsuri, method.getName()));
+        opInfo.setProperty(Method.class.getName(), method);
+        opInfo.setInput(opreq, opInfo.createMessage(new QName(nsuri, opreq), Type.INPUT));
+        opInfo.setOutput(opresp, opInfo.createMessage(new QName(nsuri, opresp), Type.INPUT));
+        
+        BindingOperationInfo bindingOpInfo = new BindingOperationInfo(null, opInfo);
+        
+        return bindingOpInfo;
+    }
+
+    private interface SEI {
+        String op();
+    }
+}
diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/DispatchImpl.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/DispatchImpl.java
index 965bc84357..421b6daafc 100644
--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/DispatchImpl.java
+++ b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/DispatchImpl.java
@@ -304,7 +304,8 @@ public class DispatchImpl<T> implements Dispatch<T>, BindingProvider {
                 getRequestContext().put("unwrap.jaxb.element", unwrapProperty);
             }
             QName opName = (QName)getRequestContext().get(MessageContext.WSDL_OPERATION);
-                       
+            boolean findDispatchOp = Boolean.TRUE.equals(getRequestContext().get("find.dispatch.operation"));
+            
             if (opName == null) {
                 opName = isOneWay ? INVOKE_ONEWAY_QNAME : INVOKE_QNAME;
             } else {
@@ -315,28 +316,31 @@ public class DispatchImpl<T> implements Dispatch<T>, BindingProvider {
                 }
             }
             
-            //CXF-2836 : find the operation for the dispatched object 
-            boolean wsaEnabled = false;
-            // the feature list to be searched is the endpoint and the bus's lists
-            List<AbstractFeature> endpointFeatures 
-                = ((JaxWsClientEndpointImpl)client.getEndpoint()).getFeatures();
-            List<AbstractFeature> allFeatures;
-            if (client.getBus().getFeatures() != null) {
-                allFeatures = new ArrayList<AbstractFeature>(endpointFeatures.size() 
-                    + client.getBus().getFeatures().size());
-                allFeatures.addAll(endpointFeatures);
-                allFeatures.addAll(client.getBus().getFeatures());
-            } else {
-                allFeatures = endpointFeatures;
-            }
-            for (AbstractFeature feature : allFeatures) {
-                if (feature instanceof WSAddressingFeature) {
-                    wsaEnabled = true; 
+            //CXF-2836 : find the operation for the dispatched object
+            // if findDispatchOp is already true, skip the addressing feature lookup.
+            // if the addressing feature is enabled, set findDispatchOp to true
+            if (!findDispatchOp) {
+                // the feature list to be searched is the endpoint and the bus's lists
+                List<AbstractFeature> endpointFeatures 
+                    = ((JaxWsClientEndpointImpl)client.getEndpoint()).getFeatures();
+                List<AbstractFeature> allFeatures;
+                if (client.getBus().getFeatures() != null) {
+                    allFeatures = new ArrayList<AbstractFeature>(endpointFeatures.size() 
+                        + client.getBus().getFeatures().size());
+                    allFeatures.addAll(endpointFeatures);
+                    allFeatures.addAll(client.getBus().getFeatures());
+                } else {
+                    allFeatures = endpointFeatures;
+                }
+                for (AbstractFeature feature : allFeatures) {
+                    if (feature instanceof WSAddressingFeature) {
+                        findDispatchOp = true; 
+                    }
                 }
             }
             Map<String, QName> payloadOPMap = 
                 createPayloadEleOpNameMap(client.getEndpoint().getBinding().getBindingInfo());
-            if (wsaEnabled && !payloadOPMap.isEmpty()) {
+            if (findDispatchOp && !payloadOPMap.isEmpty()) {
                 String payloadElementName = null;              
                 if (obj instanceof javax.xml.transform.Source) {
                     try {
@@ -360,10 +364,15 @@ public class DispatchImpl<T> implements Dispatch<T>, BindingProvider {
 
                 if (payloadElementName != null) {
                     QName dispatchedOpName = payloadOPMap.get(payloadElementName);
-                    BindingOperationInfo bop = client.getEndpoint().getBinding().getBindingInfo()
-                        .getOperation(opName);
-                    if (bop != null) {
-                        bop.setProperty("dispatchToOperation", dispatchedOpName);
+                    if (null != dispatchedOpName) {
+                        BindingOperationInfo bop = client.getEndpoint().getBinding().getBindingInfo()
+                          .getOperation(opName);
+                        BindingOperationInfo dbop = client.getEndpoint().getBinding().getBindingInfo()
+                          .getOperation(dispatchedOpName);
+                        if (bop != null) {
+                            // set the actual binding operation object to this dispatch operation
+                            bop.setProperty("dispatchToOperation", dbop);
+                        }
                     }
                 }
             } 
diff --git a/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/dispatch/DispatchTest.java b/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/dispatch/DispatchTest.java
index c32721ba78..83be5c9158 100644
--- a/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/dispatch/DispatchTest.java
+++ b/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/dispatch/DispatchTest.java
@@ -34,8 +34,11 @@ import javax.xml.ws.soap.SOAPFaultException;
 import org.w3c.dom.Document;
 
 import org.apache.cxf.Bus;
+import org.apache.cxf.binding.soap.SoapMessage;
+import org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;
 import org.apache.cxf.bus.spring.SpringBusFactory;
 import org.apache.cxf.helpers.DOMUtils;
+import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.interceptor.Interceptor;
 import org.apache.cxf.interceptor.LoggingInInterceptor;
 import org.apache.cxf.jaxws.AbstractJaxWsTest;
@@ -43,6 +46,8 @@ import org.apache.cxf.jaxws.DispatchImpl;
 import org.apache.cxf.jaxws.MessageReplayObserver;
 import org.apache.cxf.jaxws.ServiceImpl;
 import org.apache.cxf.message.Message;
+import org.apache.cxf.phase.Phase;
+import org.apache.cxf.service.model.BindingOperationInfo;
 import org.apache.cxf.service.model.EndpointInfo;
 import org.apache.cxf.transport.Destination;
 import org.apache.hello_world_soap_http.SOAPService;
@@ -98,7 +103,7 @@ public class DispatchTest extends AbstractJaxWsTest {
 
         d.setMessageObserver(new MessageReplayObserver("/org/apache/cxf/jaxws/sayHiResponse.xml"));
 
-        Document doc = DOMUtils.readXml(getResourceAsStream("/org/apache/cxf/jaxws/sayHi.xml"));
+        Document doc = DOMUtils.readXml(getResourceAsStream("/org/apache/cxf/jaxws/sayHi2.xml"));
         DOMSource source = new DOMSource(doc);
         Source res = disp.invoke(source);
         assertNotNull(res);
@@ -163,5 +168,46 @@ public class DispatchTest extends AbstractJaxWsTest {
         }
         assertTrue("The LoggingInInterceptor is not configured to dispatch client", exists);
     }
+
+    @Test
+    public void testFindOperationWithSource() throws Exception {
+        ServiceImpl service = 
+            new ServiceImpl(getBus(), getClass().getResource("/wsdl/hello_world.wsdl"), serviceName, null);
+
+        Dispatch<Source> disp = service.createDispatch(portName, Source.class, Service.Mode.MESSAGE);
+        disp.getRequestContext().put(Dispatch.ENDPOINT_ADDRESS_PROPERTY, address);
+        disp.getRequestContext().put("find.dispatch.operation", Boolean.TRUE);
+        
+        d.setMessageObserver(new MessageReplayObserver("/org/apache/cxf/jaxws/sayHiResponse.xml"));
+
+        BindingOperationVerifier bov = new BindingOperationVerifier();
+        ((DispatchImpl)disp).getClient().getOutInterceptors().add(bov);
+
+        Document doc = DOMUtils.readXml(getResourceAsStream("/org/apache/cxf/jaxws/sayHi2.xml"));
+        DOMSource source = new DOMSource(doc);
+        Source res = disp.invoke(source);
+        assertNotNull(res);
+
+        BindingOperationInfo boi = bov.getBindingOperationInfo();
+        assertNotNull(boi);
+        BindingOperationInfo dboi = (BindingOperationInfo)boi.getProperty("dispatchToOperation");
+        assertNotNull(dboi);
+
+        assertEquals(new QName("http://apache.org/hello_world_soap_http", "sayHi"), dboi.getName());
+    }
     
+    private static class BindingOperationVerifier extends AbstractSoapInterceptor {
+        BindingOperationInfo boi;
+        public BindingOperationVerifier() {
+            super(Phase.POST_LOGICAL);
+        }
+        
+        public void handleMessage(SoapMessage message) throws Fault {
+            boi = message.getExchange().getBindingOperationInfo();
+        }
+        
+        public BindingOperationInfo getBindingOperationInfo() {
+            return boi;
+        }
+    }
 }
diff --git a/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/sayHi2.xml b/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/sayHi2.xml
new file mode 100644
index 0000000000..bff2345832
--- /dev/null
+++ b/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/sayHi2.xml
@@ -0,0 +1,26 @@
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+ 
+  http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
+	<soap:Body>
+		<ns2:sayHi xmlns:ns2="http://apache.org/hello_world_soap_http/types">
+			<arg0>hola</arg0>
+		</ns2:sayHi>
+	</soap:Body>
+
+</soap:Envelope>
\ No newline at end of file
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
index 924515d537..5c5abfbd21 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
@@ -778,21 +778,12 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
             op = ((UnwrappedOperationInfo)op).getWrappedOperation();
         }
         //CXF-2836:To correct the wsa:action header value for dispatch client
-        if (bop.getProperty("dispatchToOperation") != null) {
+        BindingOperationInfo dbop = (BindingOperationInfo)bop.getProperty("dispatchToOperation");
+        if (null != dbop) {
             //modifies the bop and bp to the value of dispatch client really invokes, 
             //This helps corrct the wsa:action header value
-            QName opName = (QName)bop.getProperty("dispatchToOperation");
-            OperationInfo dispatchOP = bop.getBinding().getService().getInterface().getOperation(opName);
-            BindingOperationInfo dispachBop = null;
-            for (BindingOperationInfo binfo : bop.getBinding().getOperations()) {
-                if (binfo.getOperationInfo().getName().toString().equals(opName.toString())) {
-                    dispachBop = binfo;
-                }
-            }
-            if (dispachBop != null && dispatchOP != null) {
-                bop = dispachBop;
-                op = dispatchOP;
-            }
+            bop = dbop;
+            op = dbop.getOperationInfo();
         }
         
         String actionUri = null;
diff --git a/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/MAPAggregatorTest.java b/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/MAPAggregatorTest.java
index 8bb26d53fc..858acd7aae 100644
--- a/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/MAPAggregatorTest.java
+++ b/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/MAPAggregatorTest.java
@@ -439,7 +439,31 @@ public class MAPAggregatorTest extends Assert {
         assertSame(replyTo, props.getReplyTo());
     }
 
+    @Test
+    public void testGetActionUriForNormalOp() throws Exception {
+        Message message = setUpMessage(true, true, false, true, true);
+        String action = aggregator.getActionUri(message, false);
+        control.verify();
+        assertEquals("http://foo/bar/SEI/opRequest", action);
+    }
     
+    @Test
+    public void testGetActionUriForDispatchOp() throws Exception {
+        Message message = setUpMessage(true, true, false, true, true);
+        BindingOperationInfo dbop = setUpBindingOperationInfo("http://foo/bar/d",
+                                                              "opDRequest",
+                                                              "opDResponse",
+                                                              "opDFault", 
+                                                              DSEI.class.getMethod("op", new Class[0]));
+
+        BindingOperationInfo bop = message.getExchange().get(BindingOperationInfo.class);
+        bop.setProperty("dispatchToOperation", dbop);
+
+        String action = aggregator.getActionUri(message, false);
+        control.verify();
+        assertEquals("http://foo/bar/d/DSEI/opDRequest", action);
+    }
+
     private Message setUpMessage(boolean requestor, 
                                  boolean outbound,
                                  boolean oneway) 
@@ -583,17 +607,17 @@ public class MAPAggregatorTest extends Assert {
         List<ExtensibilityElement> endpointExts =
             new ArrayList<ExtensibilityElement>();
         endpointInfo.getExtensors(EasyMock.eq(ExtensibilityElement.class));
-        EasyMock.expectLastCall().andReturn(endpointExts);
+        EasyMock.expectLastCall().andReturn(endpointExts).anyTimes();
         BindingInfo bindingInfo = control.createMock(BindingInfo.class);
         endpointInfo.getBinding();
         EasyMock.expectLastCall().andReturn(bindingInfo).anyTimes();
         bindingInfo.getExtensors(EasyMock.eq(ExtensibilityElement.class));
-        EasyMock.expectLastCall().andReturn(Collections.EMPTY_LIST);
+        EasyMock.expectLastCall().andReturn(Collections.EMPTY_LIST).anyTimes();
         ServiceInfo serviceInfo = control.createMock(ServiceInfo.class);
         endpointInfo.getService();
-        EasyMock.expectLastCall().andReturn(serviceInfo).times(2);
+        EasyMock.expectLastCall().andReturn(serviceInfo).anyTimes();
         serviceInfo.getExtensors(EasyMock.eq(ExtensibilityElement.class));
-        EasyMock.expectLastCall().andReturn(Collections.EMPTY_LIST);
+        EasyMock.expectLastCall().andReturn(Collections.EMPTY_LIST).anyTimes();
         ExtensibilityElement ext = 
             control.createMock(ExtensibilityElement.class);
         if (usingAddressing) {
@@ -601,7 +625,7 @@ public class MAPAggregatorTest extends Assert {
                 ? Names.WSAW_USING_ADDRESSING_QNAME 
                 : new QName(SOAP_NAMESPACE, "encodingStyle");
             ext.getElementType();
-            EasyMock.expectLastCall().andReturn(elementType);
+            EasyMock.expectLastCall().andReturn(elementType).anyTimes();
             endpointExts.add(ext);
         }
     }
@@ -786,19 +810,10 @@ public class MAPAggregatorTest extends Assert {
     
     private void setUpMethod(Message message, Exchange exchange, Method method) {
         setUpMessageExchange(message, exchange);
-        ServiceInfo si = new ServiceInfo();
-        InterfaceInfo iinf = new InterfaceInfo(si, new QName("http://foo/bar", "SEI"));
-        OperationInfo opInfo = iinf.addOperation(new QName("http://foo/bar", method.getName()));
-        opInfo.setProperty(Method.class.getName(), method);
-        opInfo.setInput("opRequest",
-                        opInfo.createMessage(new QName("http://foo/bar", "opRequest"), Type.INPUT));
-        opInfo.setOutput("opResponse",
-                         opInfo.createMessage(new QName("http://foo/bar", "opResponse"), Type.INPUT));
-        FaultInfo finfo = opInfo.addFault(new QName("http://foo/bar", "opFault"),
-                new QName("http://foo/bar", "opFault"));
-        finfo.addMessagePart("fault");
-        
-        BindingOperationInfo bindingOpInfo = new TestBindingOperationInfo(opInfo);
+        BindingOperationInfo bindingOpInfo = setUpBindingOperationInfo("http://foo/bar",
+                                                                       "opRequest",
+                                                                       "opResponse",
+                                                                       "opFault", method);
         setUpExchangeGet(exchange, BindingOperationInfo.class, bindingOpInfo);
         // Usual fun with EasyMock not always working as expected
         //BindingOperationInfo bindingOpInfo =
@@ -810,6 +825,25 @@ public class MAPAggregatorTest extends Assert {
         //EasyMock.expectLastCall().andReturn(method);
     }
     
+    private BindingOperationInfo setUpBindingOperationInfo(String nsuri, 
+                                                           String opreq,
+                                                           String opresp,
+                                                           String opfault, Method method) {
+        ServiceInfo si = new ServiceInfo();
+        InterfaceInfo iinf = new InterfaceInfo(si, 
+                                               new QName(nsuri, method.getDeclaringClass().getSimpleName()));
+        OperationInfo opInfo = iinf.addOperation(new QName(nsuri, method.getName()));
+        opInfo.setProperty(Method.class.getName(), method);
+        opInfo.setInput(opreq, opInfo.createMessage(new QName(nsuri, opreq), Type.INPUT));
+        opInfo.setOutput(opresp, opInfo.createMessage(new QName(nsuri, opresp), Type.INPUT));
+        FaultInfo finfo = opInfo.addFault(new QName(nsuri, opfault), new QName(nsuri, opfault));
+        finfo.addMessagePart("fault");
+        
+        BindingOperationInfo bindingOpInfo = new TestBindingOperationInfo(opInfo);
+        
+        return bindingOpInfo;
+    }
+    
     private Message getMessage() {
         //return control.createMock(Message.class);
         return new MessageImpl();
@@ -938,6 +972,12 @@ public class MAPAggregatorTest extends Assert {
         @ResponseWrapper(targetNamespace = "http://foo/bar", className = "SEI", localName = "opResponse")
         String op();
     }
+
+    private interface DSEI {
+        @RequestWrapper(targetNamespace = "http://foo/bar/d", className = "DSEI", localName = "opDRequest")
+        @ResponseWrapper(targetNamespace = "http://foo/bar/d", className = "DSEI", localName = "opDResponse")
+        String op();
+    }
     
     private static class TestBindingMessageInfo extends BindingMessageInfo {
     }
