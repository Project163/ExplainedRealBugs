diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/handler/soap/SOAPHandlerFaultOutInterceptor.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/handler/soap/SOAPHandlerFaultOutInterceptor.java
index 60f12ca35f..7681693602 100644
--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/handler/soap/SOAPHandlerFaultOutInterceptor.java
+++ b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/handler/soap/SOAPHandlerFaultOutInterceptor.java
@@ -36,6 +36,7 @@ import javax.xml.ws.soap.SOAPFaultException;
 
 import org.w3c.dom.Node;
 
+import org.apache.cxf.binding.soap.HeaderUtil;
 import org.apache.cxf.binding.soap.SoapFault;
 import org.apache.cxf.binding.soap.SoapMessage;
 import org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;
@@ -96,6 +97,8 @@ public class SOAPHandlerFaultOutInterceptor extends
             return;
         }
 
+        checkUnderstoodHeaders(message);
+
         if (getInvoker(message).isOutbound()) {
             //The SOAPMessage might be set from the outchain, in this case, 
             //we need to clean it up and create a new SOAPMessage dedicated to fault.
@@ -107,6 +110,18 @@ public class SOAPHandlerFaultOutInterceptor extends
         } 
     }
     
+    private void checkUnderstoodHeaders(SoapMessage soapMessage) {
+        Set<QName> paramHeaders = HeaderUtil.getHeaderQNameInOperationParam(soapMessage);
+        if (soapMessage.getHeaders().isEmpty() && paramHeaders.isEmpty()) {
+            //the TCK expects the getHeaders method to always be
+            //called.   If there aren't any headers in the message,
+            //THe MustUnderstandInterceptor quickly returns without
+            //trying to calculate the understood headers.   Thus,
+            //we need to call it here.
+            getUnderstoodHeaders();
+        }
+    }
+
     private void handleMessageInternal(SoapMessage message) {
         MessageContext context = createProtocolMessageContext(message);
         HandlerChainInvoker invoker = getInvoker(message);
diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/handler/soap/SOAPHandlerInterceptor.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/handler/soap/SOAPHandlerInterceptor.java
index aab45aa1fc..0a1bc91b1f 100644
--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/handler/soap/SOAPHandlerInterceptor.java
+++ b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/handler/soap/SOAPHandlerInterceptor.java
@@ -43,6 +43,7 @@ import javax.xml.ws.handler.MessageContext;
 import javax.xml.ws.handler.soap.SOAPHandler;
 import javax.xml.ws.handler.soap.SOAPMessageContext;
 
+import org.apache.cxf.binding.soap.HeaderUtil;
 import org.apache.cxf.binding.soap.SoapMessage;
 import org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;
 import org.apache.cxf.binding.soap.interceptor.MustUnderstandInterceptor;
@@ -114,6 +115,8 @@ public class SOAPHandlerInterceptor extends
             return;
         }
 
+        checkUnderstoodHeaders(message);
+
         if (getInvoker(message).isOutbound()) {
             if (!chainAlreadyContainsSAAJ(message)) {
                 SAAJ_OUT.handleMessage(message);
@@ -143,6 +146,18 @@ public class SOAPHandlerInterceptor extends
         }
     }
 
+    private void checkUnderstoodHeaders(SoapMessage soapMessage) {
+        Set<QName> paramHeaders = HeaderUtil.getHeaderQNameInOperationParam(soapMessage);
+        if (soapMessage.getHeaders().isEmpty() && paramHeaders.isEmpty()) {
+            //the TCK expects the getHeaders method to always be
+            //called.   If there aren't any headers in the message,
+            //THe MustUnderstandInterceptor quickly returns without
+            //trying to calculate the understood headers.   Thus,
+            //we need to call it here.
+            getUnderstoodHeaders();
+        }
+    }
+
     private boolean handleMessageInternal(SoapMessage message) {
         
         MessageContext context = createProtocolMessageContext(message);
