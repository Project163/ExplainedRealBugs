diff --git a/rt/core/src/main/java/org/apache/cxf/interceptor/OneWayProcessorInterceptor.java b/rt/core/src/main/java/org/apache/cxf/interceptor/OneWayProcessorInterceptor.java
index cddbdd7bc1..6b4c98c14b 100644
--- a/rt/core/src/main/java/org/apache/cxf/interceptor/OneWayProcessorInterceptor.java
+++ b/rt/core/src/main/java/org/apache/cxf/interceptor/OneWayProcessorInterceptor.java
@@ -76,7 +76,7 @@ public class OneWayProcessorInterceptor extends AbstractPhaseInterceptor<Message
                 //need to suck in all the data from the input stream as
                 //the transport might discard any data on the stream when this 
                 //thread unwinds or when the empty response is sent back
-                DelegatingInputStream in = message.get(DelegatingInputStream.class);
+                DelegatingInputStream in = message.getContent(DelegatingInputStream.class);
                 if (in != null) {
                     in.cacheInput();
                 }
@@ -102,12 +102,13 @@ public class OneWayProcessorInterceptor extends AbstractPhaseInterceptor<Message
             if (Boolean.FALSE.equals(o)) {
                 chain.pause();
                 try {
-                    synchronized (chain) {
+                    final Object lock = new Object();
+                    synchronized (lock) {
                         message.getExchange().get(Bus.class).getExtension(WorkQueueManager.class)
                             .getAutomaticWorkQueue().execute(new Runnable() {
                                 public void run() {
-                                    synchronized (chain) {
-                                        chain.notifyAll();
+                                    synchronized (lock) {
+                                        lock.notifyAll();
                                     }
                                     chain.resume();
                                 }
@@ -115,7 +116,7 @@ public class OneWayProcessorInterceptor extends AbstractPhaseInterceptor<Message
                         //wait a few milliseconds for the background thread to start processing
                         //Mostly just to make an attempt at keeping the ordering of the 
                         //messages coming in from a client.  Not guaranteed though.
-                        chain.wait(20);
+                        lock.wait(20);
                     }
                 } catch (RejectedExecutionException e) {
                     //the executor queue is full, so run the task in the caller thread
diff --git a/rt/core/src/main/java/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.java b/rt/core/src/main/java/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.java
index aab1c12a94..0552e63b51 100644
--- a/rt/core/src/main/java/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.java
+++ b/rt/core/src/main/java/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.java
@@ -19,6 +19,8 @@
 
 package org.apache.cxf.workqueue;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.concurrent.DelayQueue;
@@ -30,6 +32,7 @@ import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
@@ -52,6 +55,9 @@ public class AutomaticWorkQueueImpl extends ThreadPoolExecutor implements Automa
     
     WorkQueueManagerImpl manager;
     String name = "default";
+    final int corePoolSize;
+    final int maxPoolSize;
+    final ReentrantLock mainLock;
 
     public AutomaticWorkQueueImpl() {
         this(DEFAULT_MAX_QUEUE_SIZE);
@@ -125,6 +131,19 @@ public class AutomaticWorkQueueImpl extends ThreadPoolExecutor implements Automa
         // start the watch dog thread
         watchDog.setDaemon(true);
         watchDog.start();
+        
+        corePoolSize = this.getCorePoolSize();
+        maxPoolSize = this.getMaximumPoolSize(); 
+        
+        ReentrantLock l = null;
+        try {
+            Field f = ThreadPoolExecutor.class.getDeclaredField("mainLock");
+            f.setAccessible(true);
+            l = (ReentrantLock)f.get(this);
+        } catch (Throwable t) {
+            l = new ReentrantLock();
+        }
+        mainLock = l;
     }
     private static ThreadFactory createThreadFactory(final String name) {
         ThreadGroup group;
@@ -337,7 +356,33 @@ public class AutomaticWorkQueueImpl extends ThreadPoolExecutor implements Automa
                 }
             }
         };
+        //The ThreadPoolExecutor in the JDK doesn't expand the number
+        //of threads until the queue is full.   However, we would 
+        //prefer the number of threads to expand immediately and 
+        //only uses the queue if we've reached the maximum number 
+        //of threads.   Thus, we'll set the core size to the max,
+        //add the runnable, and set back.  That will cause the
+        //threads to be created as needed.
         super.execute(r);
+        if (!getQueue().isEmpty() && this.getPoolSize() < maxPoolSize) {
+            mainLock.lock();
+            try {
+                int ps = this.getPoolSize();
+                int sz = getQueue().size();
+                int sz2 = this.getActiveCount();
+                
+                if ((sz + sz2) > ps) {
+                    Method m = ThreadPoolExecutor.class.getDeclaredMethod("addIfUnderMaximumPoolSize",
+                                                                          Runnable.class);
+                    m.setAccessible(true);
+                    m.invoke(this, new Object[1]);
+                }
+            } catch (Exception ex) {
+                //ignore
+            } finally {
+                mainLock.unlock();
+            }
+        }
     }
     
     // WorkQueue interface
diff --git a/rt/core/src/test/java/org/apache/cxf/workqueue/AutomaticWorkQueueTest.java b/rt/core/src/test/java/org/apache/cxf/workqueue/AutomaticWorkQueueTest.java
index 9a3aad9737..69cadd4455 100644
--- a/rt/core/src/test/java/org/apache/cxf/workqueue/AutomaticWorkQueueTest.java
+++ b/rt/core/src/test/java/org/apache/cxf/workqueue/AutomaticWorkQueueTest.java
@@ -281,7 +281,7 @@ public class AutomaticWorkQueueTest extends Assert {
 
         // Give threads a chance to dequeue (5sec max)
         int i = 0;
-        while (workqueue.getPoolSize() != 10 && i++ < 50) {
+        while (workqueue.getPoolSize() > 10 && i++ < 50) {
             try {
                 Thread.sleep(100);
             } catch (InterruptedException ie) {
@@ -300,7 +300,7 @@ public class AutomaticWorkQueueTest extends Assert {
     }
 
     @Test
-    public void testThreadPoolShrinkUnbounded() {
+    public void testThreadPoolShrinkUnbounded() throws Exception {
         workqueue = new AutomaticWorkQueueImpl(UNBOUNDED_MAX_QUEUE_SIZE, INITIAL_SIZE,
                                                UNBOUNDED_HIGH_WATER_MARK,
                                                DEFAULT_LOW_WATER_MARK, 100L);
@@ -311,18 +311,15 @@ public class AutomaticWorkQueueTest extends Assert {
         // Give threads a chance to dequeue (5sec max)
         int i = 0;
         int last = workqueue.getPoolSize();
-        while (workqueue.getPoolSize() != DEFAULT_LOW_WATER_MARK && i++ < 50) {
+        while (workqueue.getPoolSize() > DEFAULT_LOW_WATER_MARK && i++ < 50) {
             if (last != workqueue.getPoolSize()) {
                 last = workqueue.getPoolSize();
                 i = 0;
             }
-            try {
-                Thread.sleep(100);
-            } catch (InterruptedException ie) {
-                // ignore
-            }
+            Thread.sleep(100);
         }
-        assertTrue("threads_total()", workqueue.getPoolSize() <= DEFAULT_LOW_WATER_MARK);
+        int sz = workqueue.getPoolSize();
+        assertTrue("threads_total(): " + sz, workqueue.getPoolSize() <= DEFAULT_LOW_WATER_MARK);
     }
 
     @Test    
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
index d157fee774..ec82ccafef 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
@@ -434,7 +434,7 @@ public final class ContextUtils {
                         //need to suck in all the data from the input stream as
                         //the transport might discard any data on the stream when this 
                         //thread unwinds or when the empty response is sent back
-                        DelegatingInputStream in = inMessage.get(DelegatingInputStream.class);
+                        DelegatingInputStream in = inMessage.getContent(DelegatingInputStream.class);
                         if (in != null) {
                             in.cacheInput();
                         }
