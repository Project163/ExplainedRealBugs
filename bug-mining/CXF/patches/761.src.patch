diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/MustUnderstandInterceptor.java b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/MustUnderstandInterceptor.java
index 8a16e85b41..c5bccc386e 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/MustUnderstandInterceptor.java
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/MustUnderstandInterceptor.java
@@ -43,15 +43,18 @@ import org.apache.cxf.headers.Header;
 import org.apache.cxf.helpers.CastUtils;
 import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.interceptor.Interceptor;
+import org.apache.cxf.interceptor.OneWayProcessorInterceptor;
 import org.apache.cxf.phase.Phase;
 
 public class MustUnderstandInterceptor extends AbstractSoapInterceptor {
-
+    public static final String FAULT = "MustUnderstand.Fault";
 
     private static final Logger LOG = LogUtils.getL7dLogger(MustUnderstandInterceptor.class);
 
     private static final ResourceBundle BUNDLE = LOG.getResourceBundle();
-
+    
+    private MustUnderstandEndingInterceptor ending = new MustUnderstandEndingInterceptor();
+        
     public MustUnderstandInterceptor() {
         super(Phase.PRE_PROTOCOL);
     }
@@ -80,12 +83,18 @@ public class MustUnderstandInterceptor extends AbstractSoapInterceptor {
         checkUnderstand(mustUnderstandHeaders, mustUnderstandQNames, notUnderstandHeaders);
         
         if (!notUnderstandHeaders.isEmpty()) {
-            throw new SoapFault(new Message("MUST_UNDERSTAND", BUNDLE, notUnderstandHeaders),
-                            soapVersion.getMustUnderstand());
+            SoapFault soapFault = new SoapFault(new Message("MUST_UNDERSTAND", BUNDLE, notUnderstandHeaders),
+                                                soapVersion.getMustUnderstand());
+            if (!isRequestor(soapMessage)) {
+                soapMessage.put(MustUnderstandInterceptor.FAULT, soapFault);
+            } else {
+                throw soapFault;
+            }
         }
         if (!ultimateReceiverHeaders.isEmpty() && !isRequestor(soapMessage)) {
             checkUltimateReceiverHeaders(ultimateReceiverHeaders, mustUnderstandQNames, soapMessage);
         }
+        soapMessage.getInterceptorChain().add(ending);
     }
 
     private void checkUltimateReceiverHeaders(Set<Header> ultimateReceiverHeaders,
@@ -126,8 +135,11 @@ public class MustUnderstandInterceptor extends AbstractSoapInterceptor {
                 }
             }
             if (!notFound.isEmpty()) {
-                throw new SoapFault(new Message("MUST_UNDERSTAND", BUNDLE, notFound),
-                                soapMessage.getVersion().getMustUnderstand());
+                // Defer throwing soap fault exception in SOAPHeaderInterceptor once the isOneway can
+                // be detected
+                SoapFault soapFault = new SoapFault(new Message("MUST_UNDERSTAND", BUNDLE, notFound),
+                                                    soapMessage.getVersion().getMustUnderstand());
+                soapMessage.put(MustUnderstandInterceptor.FAULT, soapFault);
             }
         }
     }
@@ -230,4 +242,25 @@ public class MustUnderstandInterceptor extends AbstractSoapInterceptor {
         }
 
     }
+    
+    public class MustUnderstandEndingInterceptor extends AbstractSoapInterceptor {
+        public MustUnderstandEndingInterceptor() {
+            super(Phase.PRE_LOGICAL);
+            addAfter(OneWayProcessorInterceptor.class.getName());
+        }
+
+        public MustUnderstandEndingInterceptor(String phase) {
+            super(phase);
+        }
+
+        @Override
+        public void handleMessage(SoapMessage message) throws Fault {
+            // throws soapFault after the response code 202 is set in OneWayProcessorInterceptor
+            if (message.get(MustUnderstandInterceptor.FAULT) != null) {
+                SoapFault soapFault = (SoapFault)message.get(MustUnderstandInterceptor.FAULT);
+                throw soapFault;
+            }
+        }
+    }
+
 }
diff --git a/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/MustUnderstandInterceptorTest.java b/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/MustUnderstandInterceptorTest.java
index 4d3f1eb490..09a09cbac8 100644
--- a/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/MustUnderstandInterceptorTest.java
+++ b/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/MustUnderstandInterceptorTest.java
@@ -99,7 +99,7 @@ public class MustUnderstandInterceptorTest extends TestBase {
         assertEquals("DummaySoapInterceptor getUnderstood has been called!", true, dsi
             .isCalledGetUnderstood());
 
-        SoapFault ie = (SoapFault)soapMessage.getContent(Exception.class);
+        SoapFault ie = (SoapFault)soapMessage.get(MustUnderstandInterceptor.FAULT);
         if (ie == null) {
             fail("InBound Exception Missing! Exception should be Can't understands QNames: " + PASSENGER);
         } else {
diff --git a/systests/jaxws/src/test/java/org/apache/cxf/systest/handlers/HandlerInvocationTest.java b/systests/jaxws/src/test/java/org/apache/cxf/systest/handlers/HandlerInvocationTest.java
index e3ccaa886a..17f87d6446 100644
--- a/systests/jaxws/src/test/java/org/apache/cxf/systest/handlers/HandlerInvocationTest.java
+++ b/systests/jaxws/src/test/java/org/apache/cxf/systest/handlers/HandlerInvocationTest.java
@@ -1186,6 +1186,20 @@ public class HandlerInvocationTest extends AbstractBusClientServerTestBase {
             assertEquals(expected, iter.next());
         }
     }
+    
+    @Test
+    public void testMustUnderstandSoapFaultOneWay() {
+        TestMustUnderstandHandler<SOAPMessageContext> handler = 
+            new TestMustUnderstandHandler<SOAPMessageContext>();
+        addHandlersToChain((BindingProvider)handlerTest, handler);
+        try {
+            handlerTest.pingOneWay();
+        } catch (Exception e) {
+            fail("Catch unexpected exception: soap faule message " 
+                 + "should not be returned for one way operation");
+        }
+
+    }
 
     void addHandlersToChain(BindingProvider bp, Handler... handlers) {
         List<Handler> handlerChain = bp.getBinding().getHandlerChain();
diff --git a/systests/jaxws/src/test/java/org/apache/cxf/systest/handlers/TestMustUnderstandHandler.java b/systests/jaxws/src/test/java/org/apache/cxf/systest/handlers/TestMustUnderstandHandler.java
new file mode 100644
index 0000000000..7d9a9a8ab9
--- /dev/null
+++ b/systests/jaxws/src/test/java/org/apache/cxf/systest/handlers/TestMustUnderstandHandler.java
@@ -0,0 +1,97 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.handlers;
+
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+import javax.xml.soap.Name;
+import javax.xml.soap.SOAPEnvelope;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPFactory;
+import javax.xml.soap.SOAPHeader;
+import javax.xml.soap.SOAPHeaderElement;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.soap.SOAPPart;
+import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.soap.SOAPHandler;
+import javax.xml.ws.handler.soap.SOAPMessageContext;
+
+public class TestMustUnderstandHandler<T extends SOAPMessageContext> extends TestHandlerBase implements
+    SOAPHandler<T> {
+
+    public TestMustUnderstandHandler() {
+        super(true);
+    }
+
+    public boolean handleMessage(SOAPMessageContext ctx) {
+
+        boolean continueProcessing = true;
+
+        try {
+            Object b = ctx.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
+            boolean outbound = (Boolean)b;
+            SOAPMessage msg = ctx.getMessage();
+            if (isServerSideHandler()) {
+                if (outbound) {
+                    QName qname = new QName("http://cxf.apache.org/mu", "MU");
+                    SOAPPart soapPart = msg.getSOAPPart();
+                    SOAPEnvelope envelope = soapPart.getEnvelope();
+                    SOAPHeader header = envelope.getHeader();
+                    if (header == null) {
+                        header = envelope.addHeader();
+                    }
+
+                    SOAPHeaderElement headerElement = header.addHeaderElement(qname);
+
+                    // QName soapMustUnderstand = new QName("http://schemas.xmlsoap.org/soap/envelope/",
+                    // "mustUnderstand");
+                    Name name = SOAPFactory.newInstance()
+                        .createName("mustUnderstand", "soap", "http://schemas.xmlsoap.org/soap/envelope/");
+                    headerElement.addAttribute(name, "1");
+                } else {
+                    getHandlerInfoList(ctx).add(getHandlerId());
+                }
+            }
+        } catch (SOAPException e) {
+            e.printStackTrace();
+        }
+        return continueProcessing;
+    }
+
+    @Override
+    public String getHandlerId() {
+        return "TestMustUnderstandHandler";
+    }
+
+    @Override
+    public Set<QName> getHeaders() {
+        return null;
+    }
+
+    @Override
+    public void close(MessageContext messagecontext) {
+    }
+
+    @Override
+    public boolean handleFault(T messagecontext) {
+        return true;
+    }
+
+}
