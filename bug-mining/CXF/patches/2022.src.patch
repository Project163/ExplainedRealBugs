diff --git a/rt/features/clustering/src/main/java/org/apache/cxf/clustering/FailoverTargetSelector.java b/rt/features/clustering/src/main/java/org/apache/cxf/clustering/FailoverTargetSelector.java
index 7fdd06937c..3938831a63 100644
--- a/rt/features/clustering/src/main/java/org/apache/cxf/clustering/FailoverTargetSelector.java
+++ b/rt/features/clustering/src/main/java/org/apache/cxf/clustering/FailoverTargetSelector.java
@@ -26,6 +26,7 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 
 import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.common.util.PropertyUtils;
 import org.apache.cxf.endpoint.AbstractConduitSelector;
 import org.apache.cxf.endpoint.Client;
 import org.apache.cxf.endpoint.Endpoint;
@@ -51,7 +52,7 @@ public class FailoverTargetSelector extends AbstractConduitSelector {
     protected ConcurrentHashMap<InvocationKey, InvocationContext> inProgress 
         = new ConcurrentHashMap<InvocationKey, InvocationContext>();;
     protected FailoverStrategy failoverStrategy;
-    
+    private boolean supportNotAvailableErrorsOnly;
     /**
      * Normal constructor.
      */
@@ -78,6 +79,8 @@ public class FailoverTargetSelector extends AbstractConduitSelector {
             return;
         }
         Exchange exchange = message.getExchange();
+        setupExchangeExceptionProperties(exchange);
+        
         InvocationKey key = new InvocationKey(exchange);
         if (!inProgress.containsKey(key)) {
             Endpoint endpoint = exchange.get(Endpoint.class);
@@ -95,6 +98,10 @@ public class FailoverTargetSelector extends AbstractConduitSelector {
         }
     }
 
+    protected void setupExchangeExceptionProperties(Exchange ex) {
+        ex.remove("org.apache.cxf.transport.no_io_exceptions");
+    }
+    
     /**
      * Called when a Conduit is actually required.
      * 
@@ -121,7 +128,7 @@ public class FailoverTargetSelector extends AbstractConduitSelector {
             invocation = inProgress.get(key);
         }
         boolean failover = false;
-        if (requiresFailover(exchange)) {
+        if (invocation != null && requiresFailover(exchange)) {
             Conduit old = (Conduit)exchange.getOutMessage().remove(Conduit.class.getName());
             
             Endpoint failoverTarget = getFailoverTarget(exchange, invocation);
@@ -242,6 +249,12 @@ public class FailoverTargetSelector extends AbstractConduitSelector {
                             "CHECK_FAILURE_IN_TRANSPORT",
                             new Object[] {ex, failover});
         }
+        if (failover 
+            && isSupportNotAvailableErrorsOnly()
+            && exchange.get(Message.RESPONSE_CODE) != null
+            && !PropertyUtils.isTrue(exchange.get("org.apache.cxf.transport.service_not_available"))) { 
+            failover = false;
+        }
         return failover;
     }
     
@@ -342,6 +355,14 @@ public class FailoverTargetSelector extends AbstractConduitSelector {
         return false;
     }
             
+    public boolean isSupportNotAvailableErrorsOnly() {
+        return supportNotAvailableErrorsOnly;
+    }
+
+    public void setSupportNotAvailableErrorsOnly(boolean support) {
+        this.supportNotAvailableErrorsOnly = support;
+    }
+
     /**
      * Used to wrap an Exchange for usage as a Map key. The raw Exchange
      * is not a suitable key type, as the hashCode is computed from its
diff --git a/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/AbstractClient.java b/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/AbstractClient.java
index 716a1b20a8..6c6fab67cb 100644
--- a/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/AbstractClient.java
+++ b/rt/rs/client/src/main/java/org/apache/cxf/jaxrs/client/AbstractClient.java
@@ -944,7 +944,7 @@ public abstract class AbstractClient implements Client {
         exchange.put(Bus.class, cfg.getBus());
         exchange.put(MessageObserver.class, new ClientMessageObserver(cfg));
         exchange.put(Endpoint.class, cfg.getConduitSelector().getEndpoint());
-        exchange.put("org.apache.cxf.http.no_io_exceptions", true);
+        exchange.put("org.apache.cxf.transport.no_io_exceptions", true);
         //REVISIT - when response handling is actually put onto the in chain, this will likely not be needed
         exchange.put(StaxInEndingInterceptor.STAX_IN_NOCLOSE, Boolean.TRUE);
         m.setExchange(exchange);
diff --git a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java
index d225e6dcc1..0af1fa6fcd 100644
--- a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java
+++ b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java
@@ -1551,8 +1551,13 @@ public abstract class HTTPConduit
             // This property should be set in case the exceptions should not be handled here
             // For example jax rs uses this
             boolean noExceptions = MessageUtils.isTrue(outMessage.getContextualProperty(
-                "org.apache.cxf.http.no_io_exceptions"));
+                "org.apache.cxf.transport.no_io_exceptions"));
+            
             if (responseCode >= 400 && responseCode != 500 && !noExceptions) {
+                
+                if (responseCode == 404 || responseCode == 503) {
+                    exchange.put("org.apache.cxf.transport.service_not_available", true);
+                }
                 throw new HTTPException(responseCode, getResponseMessage(), url.toURL());
             }
 
diff --git a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSSoapBookTest.java b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSSoapBookTest.java
index 9a0155e4bf..48e6fde0f5 100644
--- a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSSoapBookTest.java
+++ b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSSoapBookTest.java
@@ -911,7 +911,7 @@ public class JAXRSSoapBookTest extends AbstractBusClientServerTestBase {
         features.add(testFeature);
         bean.setFeatures(features);
         BookStoreJaxrsJaxws proxy = (BookStoreJaxrsJaxws)bean.create();
-        WebClient.getConfig(proxy).getRequestContext().put("org.apache.cxf.http.no_io_exceptions", false);
+        WebClient.getConfig(proxy).getRequestContext().put("org.apache.cxf.transport.no_io_exceptions", false);
         try {
             //321 is special case - causes error code of 525
             proxy.getBook(new Long(param));
diff --git a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/failover/FailoverTest.java b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/failover/FailoverTest.java
index bc07abf7b5..d283ef205a 100644
--- a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/failover/FailoverTest.java
+++ b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/failover/FailoverTest.java
@@ -110,6 +110,26 @@ public class FailoverTest extends AbstractBusClientServerTestBase {
         strategyTestWebClient(Server.ADDRESS1, feature, Server.ADDRESS2, null, false, false);
     }
     
+    @Test
+    public void testSequentialStrategyWith404() throws Exception {
+        FailoverFeature feature = getFeature(false, false, Server.ADDRESS3);
+        feature.getTargetSelector().setSupportNotAvailableErrorsOnly(true);
+        strategyTestWebClient(Server.ADDRESS2 + "/new", feature, Server.ADDRESS3, null, false, false);
+    }
+    
+    @Test
+    public void testSequentialStrategyWith406() throws Exception {
+        FailoverFeature feature = getFeature(false, false, Server.ADDRESS3);
+        strategyTestWebClientHttpError(Server.ADDRESS2, feature, Server.ADDRESS3, false);
+    }
+    
+    @Test
+    public void testSequentialStrategyWith406NoFailover() throws Exception {
+        FailoverFeature feature = getFeature(false, false, Server.ADDRESS3);
+        feature.getTargetSelector().setSupportNotAvailableErrorsOnly(true);
+        strategyTestWebClientHttpError(Server.ADDRESS2, feature, Server.ADDRESS3, true);
+    }
+    
     @Test
     public void testRandomStrategyWebClient() throws Exception {
         FailoverFeature feature = 
@@ -341,6 +361,23 @@ public class FailoverTest extends AbstractBusClientServerTestBase {
                      expectRandom,
                      randomized);
     }
+    
+    protected void strategyTestWebClientHttpError(String currentReplica,
+                                 FailoverFeature feature,
+                                 String newReplica,
+                                 boolean notAvailableOnly) throws Exception {
+        WebClient bookStore = getWebClient(currentReplica, feature);
+        verifyStrategy(bookStore, SequentialStrategy.class);
+        bookStore.path("bookstore/webappexceptionXML");
+        Response r = bookStore.get();
+        assertEquals(406, r.getStatus());
+        String currEndpoint = getCurrentEndpointAddress(bookStore);
+        if (notAvailableOnly) {
+            assertTrue(currEndpoint.equals(currentReplica));
+        } else {
+            assertTrue(currEndpoint.equals(newReplica));
+        }
+    }
 
     
     protected String getCurrentEndpointAddress(Object client) {
