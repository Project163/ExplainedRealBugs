diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java
index 9342b673ed..d7f65ab385 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java
@@ -152,31 +152,27 @@ public class JAXRSInvoker extends AbstractInvoker {
         final Message inMessage = exchange.getInMessage();
         final ServerProviderFactory providerFactory = ServerProviderFactory.getInstance(inMessage);
 
-        boolean wasSuspended = exchange.remove(REQUEST_WAS_SUSPENDED) != null;
-        
-        if (!wasSuspended) {
-            
-            final boolean contextsAvailable = cri.contextsAvailable();
-            final boolean paramsAvailable = cri.paramsAvailable();
-            if (contextsAvailable || paramsAvailable) {
-                Object realResourceObject = ClassHelper.getRealObject(resourceObject);
-                if (paramsAvailable) {
-                    JAXRSUtils.injectParameters(ori, realResourceObject, inMessage);
-                }
-                if (contextsAvailable) {
-                    InjectionUtils.injectContexts(realResourceObject, cri, inMessage);
-                }
+        final boolean contextsAvailable = cri.contextsAvailable();
+        final boolean paramsAvailable = cri.paramsAvailable();
+        if (contextsAvailable || paramsAvailable) {
+            Object realResourceObject = ClassHelper.getRealObject(resourceObject);
+            if (paramsAvailable) {
+                JAXRSUtils.injectParameters(ori, realResourceObject, inMessage);
             }
-            if (cri.isRoot()) {
-                ProviderInfo<Application> appProvider = providerFactory.getApplicationProvider();
-                if (appProvider != null) {
-                    InjectionUtils.injectContexts(appProvider.getProvider(),
-                                                  appProvider,
-                                                  inMessage);
-                }
+            if (contextsAvailable) {
+                InjectionUtils.injectContexts(realResourceObject, cri, inMessage);
+            }
+        }
+        if (cri.isRoot()) {
+            ProviderInfo<Application> appProvider = providerFactory.getApplicationProvider();
+            if (appProvider != null) {
+                InjectionUtils.injectContexts(appProvider.getProvider(),
+                                              appProvider,
+                                              inMessage);
             }
         }
         
+        
 
         Method methodToInvoke = InjectionUtils.checkProxy(
             cri.getMethodDispatcher().getMethod(ori), resourceObject);
diff --git a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookCxfContinuationServer.java b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookCxfContinuationServer.java
new file mode 100644
index 0000000000..937cab7cfd
--- /dev/null
+++ b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookCxfContinuationServer.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.jaxrs;
+
+import org.apache.cxf.jaxrs.JAXRSServerFactoryBean;
+import org.apache.cxf.jaxrs.lifecycle.SingletonResourceProvider;
+import org.apache.cxf.testutil.common.AbstractBusTestServerBase;
+    
+public class BookCxfContinuationServer extends AbstractBusTestServerBase {
+    public static final String PORT = allocatePort(BookCxfContinuationServer.class);
+
+    protected void run() {
+        JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();
+        sf.setResourceClasses(BookCxfContinuationStore.class);
+        sf.setResourceProvider(BookCxfContinuationStore.class,
+                               new SingletonResourceProvider(new BookCxfContinuationStore()));
+        sf.setAddress("http://localhost:" + PORT + "/");
+
+        sf.create();        
+    }
+
+    public static void main(String[] args) {
+        try {
+            BookCxfContinuationServer s = new BookCxfContinuationServer();
+            s.start();
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            System.exit(-1);
+        } finally {
+            System.out.println("done!");
+        }
+    }
+}
diff --git a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookCxfContinuationStore.java b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookCxfContinuationStore.java
new file mode 100644
index 0000000000..7679f0c699
--- /dev/null
+++ b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookCxfContinuationStore.java
@@ -0,0 +1,156 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.jaxrs;
+
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.core.Context;
+
+import org.apache.cxf.continuations.Continuation;
+import org.apache.cxf.continuations.ContinuationProvider;
+import org.apache.cxf.jaxrs.ext.MessageContext;
+
+@Path("/bookstore")
+public class BookCxfContinuationStore {
+
+    private Map<String, String> books = new HashMap<String, String>();
+    private Map<String, Continuation> suspended = 
+        new HashMap<String, Continuation>();
+    private Executor executor = new ThreadPoolExecutor(5, 5, 0, TimeUnit.SECONDS,
+                                        new ArrayBlockingQueue<Runnable>(10));
+    
+    @Context
+    private MessageContext context;
+    
+    public BookCxfContinuationStore() {
+        init();
+    }
+    
+    @GET
+    @Path("/books/{id}")
+    public String getBookDescription(@PathParam("id") String id) {
+        
+        return handleContinuationRequest(id);
+        
+    }
+    
+    @Path("/books/subresources/")
+    public BookCxfContinuationStore getBookStore() {
+        
+        return this;
+        
+    }
+    
+    @GET
+    @Path("{id}")
+    public String handleContinuationRequest(@PathParam("id") String id) {
+        Continuation continuation = getContinuation(id);
+        if (continuation == null) {
+            throw new RuntimeException("Failed to get continuation");
+        }
+        synchronized (continuation) {
+            if (continuation.isNew()) {
+                continuation.setObject(id);
+                suspendInvocation(id, continuation);
+            } else {
+                String savedId = continuation.getObject().toString();
+                if (!savedId.equals(id)) {
+                    throw new RuntimeException("SavedId is wrong");
+                }
+                return books.get(savedId);
+            }
+        }
+        // unreachable
+        return null;
+    }
+    
+    private void resumeRequest(final String name) {
+        
+        Continuation suspendedCont = null;
+        synchronized (suspended) {
+            suspendedCont = suspended.get(name);
+        }
+        
+        if (suspendedCont != null) {
+            synchronized (suspendedCont) {
+                suspendedCont.resume();
+            }
+        }
+    }
+    
+    private void suspendInvocation(final String name, Continuation cont) {
+        
+        //System.out.println("Suspending invocation for " + name);
+        
+        try {
+            cont.suspend(500000);    
+        } finally {
+            synchronized (suspended) {
+                suspended.put(name, cont);
+            }
+            executor.execute(new Runnable() {
+                public void run() {
+                    try {
+                        Thread.sleep(2000);
+                    } catch (InterruptedException ex) {
+                        // ignore
+                    }       
+                    resumeRequest(name);
+                }
+            });
+        }
+    }
+    
+    private Continuation getContinuation(String name) {
+        
+        //System.out.println("Getting continuation for " + name);
+        ContinuationProvider provider = 
+            (ContinuationProvider)context.get(ContinuationProvider.class.getName());
+        provider.getClass();
+        synchronized (suspended) {
+            Continuation suspendedCont = suspended.remove(name);
+            if (suspendedCont != null) {
+                return suspendedCont;
+            }
+        }
+        
+        return provider.getContinuation();
+    }
+    
+    private void init() {
+        books.put("1", "CXF in Action1");
+        books.put("2", "CXF in Action2");
+        books.put("3", "CXF in Action3");
+        books.put("4", "CXF in Action4");
+        books.put("5", "CXF in Action5");
+    }
+     
+}
+
+
diff --git a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSCxfContinuationsTest.java b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSCxfContinuationsTest.java
new file mode 100644
index 0000000000..a2bf33ffff
--- /dev/null
+++ b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSCxfContinuationsTest.java
@@ -0,0 +1,127 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.jaxrs;
+
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.methods.GetMethod;
+import org.apache.cxf.jaxrs.model.AbstractResourceInfo;
+import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Ignore;
+import org.junit.Test;
+
+
+public class JAXRSCxfContinuationsTest extends AbstractBusClientServerTestBase {
+    public static final String PORT = BookCxfContinuationServer.PORT;
+
+    @BeforeClass
+    public static void startServers() throws Exception {
+        AbstractResourceInfo.clearAllMaps();
+        createStaticBus();
+        assertTrue("server did not launch correctly",
+                   launchServer(BookCxfContinuationServer.class));
+    }
+    
+    @Test
+    public void testContinuation() throws Exception {
+        
+        doTestContinuation("books");
+    }
+    
+    @Test
+    public void testContinuationSubresource() throws Exception {
+        
+        doTestContinuation("books/subresources");
+    }
+    
+    private void doTestContinuation(String pathSegment) throws Exception {
+        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS,
+                                                             new ArrayBlockingQueue<Runnable>(10));
+        CountDownLatch startSignal = new CountDownLatch(1);
+        CountDownLatch doneSignal = new CountDownLatch(1);
+        
+        executor.execute(new BookWorker("http://localhost:" + PORT + "/bookstore/" + pathSegment + "/1", 
+                                        "1", 
+                                        "CXF in Action1", startSignal, doneSignal));
+        startSignal.countDown();
+        doneSignal.await(60, TimeUnit.SECONDS);
+        executor.shutdownNow();
+        assertEquals("Not all invocations have completed", 0, doneSignal.getCount());
+    }
+    
+    private void checkBook(String address, String id, String expected) throws Exception {
+        GetMethod get = new GetMethod(address);
+        HttpClient httpclient = new HttpClient();
+        
+        try {
+            int result = httpclient.executeMethod(get);
+            assertEquals(200, result);
+            assertEquals("Book description for id " + id + " is wrong",
+                         expected, get.getResponseBodyAsString());
+        } finally {
+            // Release current connection to the connection pool once you are done
+            get.releaseConnection();
+        }
+    }
+    
+    @Ignore
+    private class BookWorker implements Runnable {
+
+        private String address;
+        private String id;
+        private String expected;
+        private CountDownLatch startSignal;
+        private CountDownLatch doneSignal;
+        public BookWorker(String address,
+                          String id,
+                          String expected,
+                           CountDownLatch startSignal,
+                           CountDownLatch doneSignal) {
+            this.address = address;
+            this.id = id;
+            this.expected = expected;
+            this.startSignal = startSignal;
+            this.doneSignal = doneSignal;
+        }
+        
+        public void run() {
+            
+            try {
+                startSignal.await();
+                checkBook(address, id, expected);
+                doneSignal.countDown();
+            } catch (InterruptedException ex) {
+                // ignore
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                Assert.fail("Book thread failed for : " + id);
+            } 
+            
+        }
+        
+    }
+}
