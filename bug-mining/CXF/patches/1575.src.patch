diff --git a/tools/corba/src/main/java/org/apache/cxf/tools/corba/processors/idl/ScopedNameVisitor.java b/tools/corba/src/main/java/org/apache/cxf/tools/corba/processors/idl/ScopedNameVisitor.java
index 5e855da5c5..aec3ff8a03 100644
--- a/tools/corba/src/main/java/org/apache/cxf/tools/corba/processors/idl/ScopedNameVisitor.java
+++ b/tools/corba/src/main/java/org/apache/cxf/tools/corba/processors/idl/ScopedNameVisitor.java
@@ -55,16 +55,27 @@ public class ScopedNameVisitor extends VisitorBase {
     public void setExceptionMode(boolean value) {
         exceptionMode = value;
     }
-    
     public static boolean accept(Scope scope,
                                  Definition defn,
                                  XmlSchema schemaRef,
                                  AST node,                                 
                                  WSDLASTVisitor wsdlVisitor) {
+        return accept(scope, defn, schemaRef, node, wsdlVisitor, false);
+    }    
+    
+    // when accepting a "name" (for example, name of a field in a struct), we may need
+    // to relax the strict checking for forward decls and schema types to not count for 
+    // exact parent scope names
+    public static boolean accept(Scope scope,
+                                 Definition defn,
+                                 XmlSchema schemaRef,
+                                 AST node,                                 
+                                 WSDLASTVisitor wsdlVisitor,
+                                 boolean asName) {
         boolean result = false;
         if (PrimitiveTypesVisitor.accept(node)) {
             result = true; 
-        } else if (isforwardDeclared(scope, node, wsdlVisitor)) {
+        } else if (isforwardDeclared(scope, node, wsdlVisitor, asName)) {
             result = true;          
         } else if (ObjectReferenceVisitor.accept(scope,
                                                  schemaRef,
@@ -72,7 +83,7 @@ public class ScopedNameVisitor extends VisitorBase {
                                                  node,
                                                  wsdlVisitor)) {
             result = true;
-        } else if (findSchemaType(scope, defn, schemaRef, node, wsdlVisitor, null)) {
+        } else if (findSchemaType(scope, defn, schemaRef, node, wsdlVisitor, null, asName)) {
             result = true;
         }
         return result;
@@ -154,6 +165,9 @@ public class ScopedNameVisitor extends VisitorBase {
     }
          
     protected static boolean isforwardDeclared(Scope scope, AST node, WSDLASTVisitor wsdlVisitor) {
+        return isforwardDeclared(scope, node, wsdlVisitor, false);
+    }
+    protected static boolean isforwardDeclared(Scope scope, AST node, WSDLASTVisitor wsdlVisitor, boolean b) {
         boolean isForward = false;
         Scope currentScope = scope;
 
@@ -172,6 +186,9 @@ public class ScopedNameVisitor extends VisitorBase {
                 if (scopedNames.getScope(scopedName) != null) {
                     isForward = true;
                 }
+                if (b && currentScope.equals(new Scope(currentScope.getParent(), node))) {
+                    break;
+                }
                 currentScope = currentScope.getParent();
             }
         }
@@ -255,13 +272,21 @@ public class ScopedNameVisitor extends VisitorBase {
         return result;
     }
     
-    
     protected static boolean findSchemaType(Scope scope,
                                             Definition defn,
                                             XmlSchema schemaRef,
                                             AST node,
                                             WSDLASTVisitor wsdlVisitor,
                                             VisitorTypeHolder holder) {
+        return findSchemaType(scope, defn, schemaRef, node, wsdlVisitor, holder, false);
+    }    
+    protected static boolean findSchemaType(Scope scope,
+                                            Definition defn,
+                                            XmlSchema schemaRef,
+                                            AST node,
+                                            WSDLASTVisitor wsdlVisitor,
+                                            VisitorTypeHolder holder,
+                                            boolean checkExact) {
                                                 
         boolean result = false;
         Scope currentScope = scope;        
@@ -289,6 +314,10 @@ public class ScopedNameVisitor extends VisitorBase {
                                                             node, wsdlVisitor, holder);
                     
                 }
+                if (checkExact && currentScope.equals(new Scope(currentScope.getParent(), node))) {
+                    return false;
+                }
+
                 currentScope = currentScope.getParent();
             }
         }
diff --git a/tools/corba/src/main/java/org/apache/cxf/tools/corba/processors/idl/StructVisitor.java b/tools/corba/src/main/java/org/apache/cxf/tools/corba/processors/idl/StructVisitor.java
index e57bd93a43..c112f5a388 100644
--- a/tools/corba/src/main/java/org/apache/cxf/tools/corba/processors/idl/StructVisitor.java
+++ b/tools/corba/src/main/java/org/apache/cxf/tools/corba/processors/idl/StructVisitor.java
@@ -138,7 +138,7 @@ public class StructVisitor extends VisitorBase {
             // (hence the ScopedNameVisitor.accept() call).
             while (memberNode != null
                    && memberNode.getType() == IDLTokenTypes.IDENT
-                   && !ScopedNameVisitor.accept(structScope, definition, schema, memberNode, wsdlVisitor)) {
+                   && !ScopedNameVisitor.accept(structScope, definition, schema, memberNode, wsdlVisitor, true)) {
 
                 XmlSchemaType memberSchemaType = schemaType;
                 CorbaTypeImpl memberCorbaType = corbaType;
diff --git a/tools/corba/src/test/java/org/apache/cxf/tools/corba/IDLToWSDLTest.java b/tools/corba/src/test/java/org/apache/cxf/tools/corba/IDLToWSDLTest.java
index 8de67af500..59fbd643d0 100644
--- a/tools/corba/src/test/java/org/apache/cxf/tools/corba/IDLToWSDLTest.java
+++ b/tools/corba/src/test/java/org/apache/cxf/tools/corba/IDLToWSDLTest.java
@@ -422,4 +422,17 @@ public class IDLToWSDLTest extends ToolTestBase {
         }
         fail("Did not find foo element");
     }
+    public void testCXF3329() throws Exception {
+        File input = new File(getClass().getResource("/idl/CXF3329.idl").toURI());
+        String[] args = new String[] {
+            "-o", output.toString(),
+            input.toString()
+        };
+        IDLToWSDL.run(args);
+        File fs = new File(output, "CXF3329.wsdl");
+        assertTrue(fs.getName() + " was not created.", fs.exists());
+        Document doc = StaxUtils.read(new FileInputStream(fs));
+        String s = StaxUtils.toString(doc.getDocumentElement());
+        assertTrue(s.contains("name=\"myStruct\""));
+    }
 }
diff --git a/tools/corba/src/test/resources/idl/CXF3329.idl b/tools/corba/src/test/resources/idl/CXF3329.idl
new file mode 100644
index 0000000000..cff5766a21
--- /dev/null
+++ b/tools/corba/src/test/resources/idl/CXF3329.idl
@@ -0,0 +1,9 @@
+module myModule
+{
+	struct myStruct
+	{
+		long myStruct;
+		long otherField;
+		sequence<myStruct> parent;
+	};
+};
\ No newline at end of file
