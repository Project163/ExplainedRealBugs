diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RetransmissionInterceptor.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RetransmissionInterceptor.java
index bc4fcad11d..9a501416d8 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RetransmissionInterceptor.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RetransmissionInterceptor.java
@@ -21,13 +21,15 @@ package org.apache.cxf.ws.rm;
 
 import java.io.OutputStream;
 
-import org.apache.cxf.interceptor.AttachmentOutInterceptor;
+//import org.apache.cxf.interceptor.AttachmentOutInterceptor;
 import org.apache.cxf.interceptor.Fault;
-import org.apache.cxf.interceptor.StaxOutInterceptor;
+import org.apache.cxf.interceptor.MessageSenderInterceptor;
+//import org.apache.cxf.interceptor.StaxOutInterceptor;
 import org.apache.cxf.io.WriteOnCloseOutputStream;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.phase.AbstractPhaseInterceptor;
 import org.apache.cxf.phase.Phase;
+import org.apache.cxf.transport.common.gzip.GZIPOutInterceptor;
 
 /**
  * 
@@ -37,9 +39,12 @@ public class RetransmissionInterceptor extends AbstractPhaseInterceptor<Message>
     RMManager manager;
 
     public RetransmissionInterceptor() {
-        super(Phase.PRE_STREAM);
-        addBefore(StaxOutInterceptor.class.getName());
-        addBefore(AttachmentOutInterceptor.class.getName());
+        super(Phase.PREPARE_SEND);
+        addAfter(MessageSenderInterceptor.class.getName());
+        addBefore(GZIPOutInterceptor.class.getName());
+//        super(Phase.PRE_STREAM);
+//        addBefore(StaxOutInterceptor.class.getName());
+//        addBefore(AttachmentOutInterceptor.class.getName());
     }
     
     public RMManager getManager() {
diff --git a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/MessageLossSimulator.java b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/MessageLossSimulator.java
index dbc8344c1f..dbf27b91e5 100644
--- a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/MessageLossSimulator.java
+++ b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/MessageLossSimulator.java
@@ -43,14 +43,31 @@ import org.apache.cxf.ws.rm.RMContextUtils;
  * 
  */
 public class MessageLossSimulator extends AbstractPhaseInterceptor<Message> {
-
     private static final Logger LOG = LogUtils.getLogger(MessageLossSimulator.class);
-    private int appMessageCount; 
-    
+    private int appMessageCount;
+    private boolean throwsException;
+    private int mode;
+
     public MessageLossSimulator() {
         super(Phase.PREPARE_SEND);
         addBefore(MessageSenderInterceptor.class.getName());
     }
+    
+    public boolean isThrowsException() {
+        return throwsException;
+    }
+
+    public void setThrowsException(boolean throwsException) {
+        this.throwsException = throwsException;
+    }
+
+    public int getMode() {
+        return mode;
+    }
+
+    public void setMode(int mode) {
+        this.mode = mode;
+    }
 
     public void handleMessage(Message message) throws Fault {
         AddressingProperties maps = RMContextUtils.retrieveMAPs(message, false, true);
@@ -64,10 +81,18 @@ public class MessageLossSimulator extends AbstractPhaseInterceptor<Message> {
         if (MessageUtils.isPartialResponse(message)) {
             return;
         }
-        synchronized (this) {
-            appMessageCount++;
-            if (0 != (appMessageCount % 2)) {
-                return;
+        if (mode == 1) {
+            // never lose
+            return;
+        } else if (mode == -1) {
+            // always lose
+        } else { 
+            // alternatively lose
+            synchronized (this) {
+                appMessageCount++;
+                if (0 != (appMessageCount % 2)) {
+                    return;
+                }
             }
         }
         
@@ -89,6 +114,9 @@ public class MessageLossSimulator extends AbstractPhaseInterceptor<Message> {
             public void handleMessage(Message message) throws Fault {
                 try {
                     message.getContent(OutputStream.class).close();
+                    if (throwsException) {
+                        throw new IOException("simulated transmission exception");
+                    }
                 } catch (IOException e) {
                     throw new Fault(e);
                 }
diff --git a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/RetransmissionGZIPTest.java b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/RetransmissionGZIPTest.java
new file mode 100755
index 0000000000..402e6e6f23
--- /dev/null
+++ b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/RetransmissionGZIPTest.java
@@ -0,0 +1,147 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.ws.rm;
+
+import java.util.logging.Logger;
+
+import javax.xml.ws.Endpoint;
+
+import org.apache.cxf.Bus;
+import org.apache.cxf.BusFactory;
+import org.apache.cxf.bus.spring.SpringBusFactory;
+import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.greeter_control.Greeter;
+import org.apache.cxf.greeter_control.GreeterService;
+import org.apache.cxf.interceptor.LoggingInInterceptor;
+import org.apache.cxf.interceptor.LoggingOutInterceptor;
+import org.apache.cxf.systest.ws.util.ConnectionHelper;
+import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
+import org.apache.cxf.testutil.common.AbstractBusTestServerBase;
+import org.apache.cxf.ws.rm.RMManager;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ * Tests the gzip feature does not interfere with the ws-rm retransmission.
+ * Note that the current retransmission logic isn't optimal (in some sense, wrong)
+ * and stores the wire-message and retransmits this wire-message directly. This  
+ * approach is not practical when ws-security is enabled and each message needs to be
+ * timestamped and signed. Therefore, the current retransmission logic needs to be
+ * changed one day.
+ *  
+ * Independently of this fix, this test verifies the gzip feature does not interfere
+ * with retransmission.
+ */
+public class RetransmissionGZIPTest extends AbstractBusClientServerTestBase {
+    public static final String PORT = allocatePort(Server.class);
+    public static final String DECOUPLE_PORT = allocatePort("decoupled.port");
+
+    private static final Logger LOG = LogUtils.getLogger(RetransmissionQueueTest.class);
+    private Bus bus;
+
+    public static class Server extends AbstractBusTestServerBase {
+      
+        protected void run()  {            
+            SpringBusFactory bf = new SpringBusFactory();
+            Bus bus = bf.createBus("/org/apache/cxf/systest/ws/rm/gzip-enabled.xml");
+            BusFactory.setDefaultBus(bus);
+            LoggingInInterceptor in = new LoggingInInterceptor();
+            bus.getInInterceptors().add(in);
+            bus.getInFaultInterceptors().add(in);
+            LoggingOutInterceptor out = new LoggingOutInterceptor();
+            bus.getOutInterceptors().add(out);
+            bus.getOutFaultInterceptors().add(out);
+            
+            GreeterImpl implementor = new GreeterImpl();
+            String address = "http://localhost:" + PORT + "/SoapContext/GreeterPort";
+            
+            Endpoint ep = Endpoint.create(implementor);
+            ep.publish(address);
+
+            LOG.info("Published greeter endpoint.");
+        }
+ 
+        public static void main(String[] args) {
+            try { 
+                Server s = new Server(); 
+                s.start();
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                System.exit(-1);
+            } finally { 
+                System.out.println("done!");
+            }
+        }
+    }
+    
+    @BeforeClass
+    public static void startServers() throws Exception {
+        assertTrue("server did not launch correctly", 
+                   launchServer(Server.class, true));
+    }
+            
+    @Test
+    public void testDecoupleFaultHandling() throws Exception {
+        SpringBusFactory bf = new SpringBusFactory();
+        bus = bf.createBus("/org/apache/cxf/systest/ws/rm/gzip-enabled.xml");
+        BusFactory.setDefaultBus(bus);
+        LoggingInInterceptor in = new LoggingInInterceptor();
+        bus.getInInterceptors().add(in);
+        bus.getInFaultInterceptors().add(in);
+        LoggingOutInterceptor out = new LoggingOutInterceptor();
+        bus.getOutInterceptors().add(out);
+        bus.getExtension(RMManager.class).getRMAssertion().getBaseRetransmissionInterval()
+            .setMilliseconds(new Long(4000));
+
+        // an interceptor to simulate a transmission error
+        MessageLossSimulator loser = new MessageLossSimulator();
+        bus.getOutInterceptors().add(loser);
+        
+        bus.getOutFaultInterceptors().add(out);
+        
+        GreeterService gs = new GreeterService();
+        final Greeter greeter = gs.getGreeterPort();
+        updateAddressPort(greeter, PORT);
+        LOG.fine("Created greeter client.");
+       
+        ConnectionHelper.setKeepAliveConnection(greeter, true);
+        loser.setMode(-1);
+        loser.setThrowsException(true);
+        
+        try {
+            greeter.greetMeOneWay("oneway");            
+        } catch (Exception e) {
+            fail("fault thrown after queued for retransmission");
+        }
+        Thread.sleep(2000);
+        
+        RMManager manager = bus.getExtension(RMManager.class);
+        boolean empty = manager.getRetransmissionQueue().isEmpty();
+        assertFalse("RetransmissionQueue is empty", empty);
+        
+        loser.setMode(1);
+
+        Thread.sleep(6000);
+         
+        empty = manager.getRetransmissionQueue().isEmpty();
+        assertTrue("RetransmissionQueue not cleared", empty);
+    }
+
+}
diff --git a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/RetransmissionQueueTest.java b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/RetransmissionQueueTest.java
index ee70f07e2d..ec07ae649c 100644
--- a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/RetransmissionQueueTest.java
+++ b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/RetransmissionQueueTest.java
@@ -18,7 +18,6 @@
  */
 package org.apache.cxf.systest.ws.rm;
 
-import java.io.IOException;
 import java.util.logging.Logger;
 
 import javax.xml.ws.Endpoint;
@@ -29,18 +28,11 @@ import org.apache.cxf.bus.spring.SpringBusFactory;
 import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.greeter_control.Greeter;
 import org.apache.cxf.greeter_control.GreeterService;
-import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.interceptor.LoggingInInterceptor;
 import org.apache.cxf.interceptor.LoggingOutInterceptor;
-import org.apache.cxf.message.Message;
-import org.apache.cxf.phase.AbstractPhaseInterceptor;
-import org.apache.cxf.phase.Phase;
 import org.apache.cxf.systest.ws.util.ConnectionHelper;
 import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
 import org.apache.cxf.testutil.common.AbstractBusTestServerBase;
-import org.apache.cxf.ws.addressing.AddressingProperties;
-import org.apache.cxf.ws.rm.RM10Constants;
-import org.apache.cxf.ws.rm.RMContextUtils;
 import org.apache.cxf.ws.rm.RMManager;
 
 import org.junit.BeforeClass;
@@ -95,7 +87,7 @@ public class RetransmissionQueueTest extends AbstractBusClientServerTestBase {
     @BeforeClass
     public static void startServers() throws Exception {
         assertTrue("server did not launch correctly", 
-                   launchServer(Server.class));
+                   launchServer(Server.class, true));
     }
             
     @Test
@@ -108,9 +100,12 @@ public class RetransmissionQueueTest extends AbstractBusClientServerTestBase {
         bus.getInFaultInterceptors().add(in);
         LoggingOutInterceptor out = new LoggingOutInterceptor();
         bus.getOutInterceptors().add(out);
+        bus.getExtension(RMManager.class).getRMAssertion().getBaseRetransmissionInterval()
+            .setMilliseconds(new Long(4000));
+
         // an interceptor to simulate a transmission error
-        TransmissionErrorSimulator tes = new TransmissionErrorSimulator();
-        bus.getOutInterceptors().add(tes);
+        MessageLossSimulator loser = new MessageLossSimulator();
+        bus.getOutInterceptors().add(loser);
         
         bus.getOutFaultInterceptors().add(out);
         
@@ -120,73 +115,26 @@ public class RetransmissionQueueTest extends AbstractBusClientServerTestBase {
         LOG.fine("Created greeter client.");
        
         ConnectionHelper.setKeepAliveConnection(greeter, true);
+        loser.setMode(-1);
+        loser.setThrowsException(true);
         
         try {
             greeter.greetMeOneWay("oneway");            
         } catch (Exception e) {
             fail("fault thrown after queued for retransmission");
         }
-        
-        tes.setWorking(true);
-
-        long wait = 3000;
-        while (wait > 0) {
-            long start = System.currentTimeMillis();
-            try {
-                Thread.sleep(wait);
-            } catch (InterruptedException ex) {
-                // ignore
-            }
-            wait -= System.currentTimeMillis() - start;
-        }
+        Thread.sleep(2000);
         
         RMManager manager = bus.getExtension(RMManager.class);
         boolean empty = manager.getRetransmissionQueue().isEmpty();
+        assertFalse("RetransmissionQueue is empty", empty);
         
-        assertTrue("RetransmissionQueue not cleared", empty);
-    }
-
-    
-    static class TransmissionErrorSimulator extends AbstractPhaseInterceptor<Message> {
-        private boolean working;
-        
-        /**
-         * @param phase
-         */
-        public TransmissionErrorSimulator() {
-            super(Phase.WRITE);
-        }
-
-        /* (non-Javadoc)
-         * @see org.apache.cxf.interceptor.Interceptor#handleMessage(org.apache.cxf.message.Message)
-         */
-        public void handleMessage(Message message) throws Fault {
-            // let the create sequence message to succeed so that a valid sequence is created
-            AddressingProperties maps =
-                RMContextUtils.retrieveMAPs(message, false, true);
-            if (maps != null 
-                && maps.getAction() != null
-                && RM10Constants.CREATE_SEQUENCE_ACTION.equals(maps.getAction().getValue())) {
-                // spare the message
-            } else if (!working) {
-                // triggers a simulated error
-                throw new Fault(new IOException("simulated transmission error"));
-            }
-        }
+        loser.setMode(1);
 
-        /**
-         * @return the working
-         */
-        public boolean isWorking() {
-            return working;
-        }
-
-        /**
-         * @param working the working to set
-         */
-        public void setWorking(boolean working) {
-            this.working = working;
-        }
+        Thread.sleep(6000);
+         
+        empty = manager.getRetransmissionQueue().isEmpty();
+        assertTrue("RetransmissionQueue not cleared", empty);
     }
 
 }
diff --git a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/gzip-enabled.xml b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/gzip-enabled.xml
new file mode 100644
index 0000000000..2e5e74b3e9
--- /dev/null
+++ b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/gzip-enabled.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+ 
+  http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+<beans xmlns="http://www.springframework.org/schema/beans"
+       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+       xmlns:cxf="http://cxf.apache.org/core"
+       xmlns:wsa="http://cxf.apache.org/ws/addressing"
+       xmlns:http="http://cxf.apache.org/transports/http/configuration"
+       xmlns:wsrm-policy="http://schemas.xmlsoap.org/ws/2005/02/rm/policy"
+       xmlns:wsrm-mgr="http://cxf.apache.org/ws/rm/manager"
+       xsi:schemaLocation="
+       http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd
+       http://cxf.apache.org/transports/http/configuration http://cxf.apache.org/schemas/configuration/http-conf.xsd
+       http://schemas.xmlsoap.org/ws/2005/02/rm/policy http://schemas.xmlsoap.org/ws/2005/02/rm/wsrm-policy.xsd
+       http://cxf.apache.org/ws/rm/manager http://cxf.apache.org/schemas/configuration/wsrm-manager.xsd
+       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
+ 
+    <bean id="GZIPFeature" class="org.apache.cxf.transport.common.gzip.GZIPFeature">
+        <property name="threshold" value="1"/>
+    </bean>     
+
+    <cxf:bus>
+        <cxf:features>
+            <cxf:logging/>
+            <wsa:addressing/>
+            <wsrm-mgr:reliableMessaging>
+                <wsrm-policy:RMAssertion>
+                    <wsrm-policy:BaseRetransmissionInterval Milliseconds="4000"/>           
+                    <wsrm-policy:AcknowledgementInterval Milliseconds="0"/>          
+                </wsrm-policy:RMAssertion>
+                <wsrm-mgr:deliveryAssurance>
+                    <wsrm-mgr:AtMostOnce />
+                </wsrm-mgr:deliveryAssurance>
+                <wsrm-mgr:destinationPolicy >
+                    <wsrm-mgr:acksPolicy intraMessageThreshold="0" />
+                </wsrm-mgr:destinationPolicy>
+            </wsrm-mgr:reliableMessaging>
+            <ref bean="GZIPFeature"/>
+        </cxf:features>
+    </cxf:bus>
+
+</beans>
\ No newline at end of file
diff --git a/testutils/src/main/java/org/apache/cxf/testutil/recorders/OutMessageRecorder.java b/testutils/src/main/java/org/apache/cxf/testutil/recorders/OutMessageRecorder.java
index a1e3f061da..40b1739b8a 100644
--- a/testutils/src/main/java/org/apache/cxf/testutil/recorders/OutMessageRecorder.java
+++ b/testutils/src/main/java/org/apache/cxf/testutil/recorders/OutMessageRecorder.java
@@ -27,7 +27,7 @@ import java.util.logging.Logger;
 
 import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.interceptor.Fault;
-import org.apache.cxf.interceptor.StaxOutInterceptor;
+import org.apache.cxf.interceptor.MessageSenderInterceptor;
 import org.apache.cxf.io.CachedOutputStream;
 import org.apache.cxf.io.CachedOutputStreamCallback;
 import org.apache.cxf.io.WriteOnCloseOutputStream;
@@ -45,10 +45,10 @@ public class OutMessageRecorder extends AbstractPhaseInterceptor<Message> {
     private List<byte[]> outbound;
 
     public OutMessageRecorder() {
-        super(Phase.PRE_STREAM);
+        super(Phase.PREPARE_SEND);
         outbound = new CopyOnWriteArrayList<byte[]>();
+        addAfter(MessageSenderInterceptor.class.getName());
         addAfter("org.apache.cxf.ws.rm.RetransmissionInterceptor");
-        addBefore(StaxOutInterceptor.class.getName());
     }
     
     public void handleMessage(Message message) throws Fault {
