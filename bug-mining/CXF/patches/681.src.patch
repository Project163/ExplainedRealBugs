diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/SecurityContextImpl.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/SecurityContextImpl.java
index 32e0d0436b..a0e5cc3f2a 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/SecurityContextImpl.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/SecurityContextImpl.java
@@ -25,6 +25,7 @@ import java.util.List;
 import javax.ws.rs.core.SecurityContext;
 
 import org.apache.cxf.configuration.security.AuthorizationPolicy;
+import org.apache.cxf.jaxrs.utils.HttpUtils;
 import org.apache.cxf.message.Message;
 
 public class SecurityContextImpl implements SecurityContext {
@@ -52,8 +53,7 @@ public class SecurityContextImpl implements SecurityContext {
 
     
     public boolean isSecure() {
-        String value = m.getExchange().getDestination().getAddress()
-            .getAddress().getValue();
+        String value = HttpUtils.getEndpointAddress(m);
         return value.startsWith("https://");
     }
 
diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/utils/HttpUtils.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/utils/HttpUtils.java
index 2e8b47ddad..0ba4c1fa9f 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/utils/HttpUtils.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/utils/HttpUtils.java
@@ -48,6 +48,7 @@ import org.apache.cxf.jaxrs.impl.HttpHeadersImpl;
 import org.apache.cxf.jaxrs.impl.PathSegmentImpl;
 import org.apache.cxf.jaxrs.model.ParameterType;
 import org.apache.cxf.message.Message;
+import org.apache.cxf.service.model.EndpointInfo;
 import org.apache.cxf.transport.Destination;
 import org.apache.cxf.transport.http.AbstractHTTPDestination;
 
@@ -207,7 +208,11 @@ public final class HttpUtils {
         Destination d = m.getExchange().getDestination();
         if (d != null) {
             if (d instanceof AbstractHTTPDestination) {
-                address = ((AbstractHTTPDestination)d).getEndpointInfo().getAddress();
+                EndpointInfo ei = ((AbstractHTTPDestination)d).getEndpointInfo();
+                HttpServletRequest request = (HttpServletRequest)m.get(AbstractHTTPDestination.HTTP_REQUEST); 
+                Object property = request != null 
+                    ? request.getAttribute("org.apache.cxf.transport.endpoint.address") : null;
+                address = property != null ? property.toString() : ei.getAddress();
             } else {
                 address = d.getAddress().getAddress().getValue();
             }
diff --git a/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/AbstractCXFServlet.java b/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/AbstractCXFServlet.java
index 4aa28aada8..3d1e7f6b5c 100644
--- a/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/AbstractCXFServlet.java
+++ b/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/AbstractCXFServlet.java
@@ -46,6 +46,8 @@ public abstract class AbstractCXFServlet extends AbstractHTTPServlet {
     protected ServletTransportFactory servletTransportFactory;
     protected ServletController controller;
     
+    private boolean disableAddressUpdates;
+        
     public static Logger getLogger() {
         return LogUtils.getL7dLogger(AbstractCXFServlet.class);
     }
@@ -56,6 +58,10 @@ public abstract class AbstractCXFServlet extends AbstractHTTPServlet {
                                   servletConfig,
                                   this.getServletContext(), 
                                   bus);
+    
+        if (servletConfig.getInitParameter("disable-address-updates") == null) {
+            newController.setDisableAddressUpdates(disableAddressUpdates);
+        }
         
         return newController;
     }
@@ -145,4 +151,10 @@ public abstract class AbstractCXFServlet extends AbstractHTTPServlet {
         }
     }
 
+    // this makes it a bit easier to disable the address 
+    // updates when creating servlets programmatically
+    public void setDisableAddressUpdates(boolean disableAddressUpdates) {
+        this.disableAddressUpdates = disableAddressUpdates;
+    }
+    
 }
diff --git a/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/ServletController.java b/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/ServletController.java
index 9e24d9f875..dfda8eb964 100644
--- a/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/ServletController.java
+++ b/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/ServletController.java
@@ -79,9 +79,7 @@ public class ServletController extends AbstractServletController {
     }
     
     protected synchronized void updateDests(HttpServletRequest request) {
-        if (disableAddressUpdates) {
-            return;
-        }
+        
         String base = forcedBaseAddress == null ? getBaseURL(request) : forcedBaseAddress;
                 
         if (base.equals(lastBase)) {
@@ -99,12 +97,19 @@ public class ServletController extends AbstractServletController {
             if (ad != null 
                 && (ad.equals(path)
                 || ad.equals(lastBase + path))) {
-                d2.getEndpointInfo().setAddress(base + path);
-                if (d2.getEndpointInfo().getExtensor(AddressType.class) != null) {
-                    d2.getEndpointInfo().getExtensor(AddressType.class).setLocation(base + path);
+                if (disableAddressUpdates) {
+                    request.setAttribute("org.apache.cxf.transport.endpoint.address", base + path);
+                } else {
+                    d2.getEndpointInfo().setAddress(base + path);
+                    if (d2.getEndpointInfo().getExtensor(AddressType.class) != null) {
+                        d2.getEndpointInfo().getExtensor(AddressType.class).setLocation(base + path);
+                    }
                 }
             }
         }
+        if (disableAddressUpdates) {
+            return;
+        }
         lastBase = base;
     }
 
diff --git a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSOverlappingDestinationsTest.java b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSOverlappingDestinationsTest.java
new file mode 100644
index 0000000000..52d03b607c
--- /dev/null
+++ b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSOverlappingDestinationsTest.java
@@ -0,0 +1,180 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.jaxrs;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.QueryParam;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.UriInfo;
+
+import org.apache.cxf.jaxrs.client.WebClient;
+import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
+
+import org.junit.BeforeClass;
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class JAXRSOverlappingDestinationsTest extends AbstractBusClientServerTestBase {
+    public static final String PORT = SpringServer.PORT;
+
+    @BeforeClass
+    public static void startServers() throws Exception {
+        assertTrue("server did not launch correctly", 
+                   launchServer(SpringServer.class, true));
+    }
+    
+    @Test
+    public void testAbsolutePathOne() throws Exception {
+        
+        WebClient wc = WebClient.create("http://localhost:" + PORT + "/one/bookstore/request");
+        String path = wc.accept("text/plain").get(String.class);
+        assertEquals("Absolute RequestURI is wrong", wc.getBaseURI().toString(), path);
+    }
+    
+    @Test
+    public void testAbsolutePathTwo() throws Exception {
+        
+        WebClient wc = WebClient.create("http://localhost:" + PORT + "/two/bookstore/request");
+        String path = wc.accept("text/plain").get(String.class);
+        assertEquals("Absolute RequestURI is wrong", wc.getBaseURI().toString(), path);
+    }
+    
+    @Test
+    public void testAbsolutePathOneAndTwo() throws Exception {
+        
+        final String requestURI = "http://localhost:" + PORT + "/one/bookstore/request?delay";
+        
+        Callable<String> callable = new Callable<String>() {
+            public String call() {
+                WebClient wc = WebClient.create(requestURI);
+                return wc.accept("text/plain").get(String.class);
+                    
+            }
+        };
+        FutureTask<String> task = new FutureTask<String>(callable);
+        ExecutorService executor = Executors.newFixedThreadPool(1);
+        executor.execute(task);
+        Thread.sleep(1000);
+        
+        Runnable runnable = new Runnable() {
+            public void run() {
+                try {
+                    testAbsolutePathTwo();
+                } catch (Exception ex) {
+                    throw new RuntimeException("Concurrent testAbsolutePathTwo failed");
+                }
+            }
+        };
+        new Thread(runnable).start();
+        Thread.sleep(2000);
+        
+        String path = task.get();
+        assertEquals("Absolute RequestURI is wrong", requestURI, path);
+        
+        
+    }
+    
+    @Test
+    public void testAbsolutePathOneAndTwoWithLock() throws Exception {
+        
+        WebClient.create("http://localhost:" + PORT + "/one/bookstore/lock").accept("text/plain").get();
+        
+        final String requestURI = "http://localhost:" + PORT + "/one/bookstore/uris";
+        
+        Callable<String> callable = new Callable<String>() {
+            public String call() {
+                WebClient wc = WebClient.create(requestURI);
+                return wc.accept("text/plain").get(String.class);
+                
+            }
+        };
+        FutureTask<String> task = new FutureTask<String>(callable);
+        ExecutorService executor = Executors.newFixedThreadPool(1);
+        executor.execute(task);
+        Thread.sleep(3000);
+        
+        WebClient wc2 = WebClient.create("http://localhost:" + PORT + "/two/bookstore/unlock");
+        wc2.accept("text/plain").get();
+        
+        String path = task.get();
+        assertEquals("Absolute RequestURI is wrong", requestURI, path);
+    }
+    
+    @Ignore
+    public static class SpringServer extends AbstractSpringServer {
+        public static final String PORT = AbstractSpringServer.PORT;
+        
+        public SpringServer() {
+            super("/jaxrs_many_destinations");
+        }
+    }
+    
+    @Path("/bookstore")
+    public static class Resource {
+
+        private volatile boolean locked;
+        
+        @GET
+        @Produces("text/plain")
+        @Path("request")
+        public String getRequestPath(@Context UriInfo ui, @QueryParam("delay") String delay) 
+            throws Exception {
+            if (delay != null) {
+                Thread.sleep(5000);
+            }
+            return ui.getRequestUri().toString();
+        }
+        
+        
+        @GET
+        @Path("/uris")
+        @Produces("text/plain")
+        public String getUris(@Context UriInfo uriInfo) {
+            String baseUriOnEntry = uriInfo.getRequestUri().toString();
+            try {
+                while (locked) { Thread.sleep(1000); }
+            } catch (InterruptedException x) {
+                // ignore
+            }
+            String baseUriOnExit = uriInfo.getRequestUri().toString();
+            if (!baseUriOnEntry.equals(baseUriOnExit)) {
+                throw new RuntimeException();
+            }
+            return baseUriOnExit;
+        }
+
+        @GET
+        @Path("/lock")
+        @Produces("text/plain")
+        public String lock() { locked = true; return "locked"; }
+
+        @GET
+        @Path("/unlock")
+        @Produces("text/plain")
+        public String unlock() { locked = false; return "unlocked"; }
+    }
+}
diff --git a/systests/jaxrs/src/test/resources/jaxrs_many_destinations/WEB-INF/beans.xml b/systests/jaxrs/src/test/resources/jaxrs_many_destinations/WEB-INF/beans.xml
new file mode 100644
index 0000000000..80b023701a
--- /dev/null
+++ b/systests/jaxrs/src/test/resources/jaxrs_many_destinations/WEB-INF/beans.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+  
+  http://www.apache.org/licenses/LICENSE-2.0
+  
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+<!-- START SNIPPET: beans -->
+<!--beans xmlns="http://www.springframework.org/schema/beans"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xmlns:simple="http://cxf.apache.org/simple"
+  xsi:schemaLocation="
+  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
+  http://cxf.apache.org/simple http://cxf.apache.org/schemas/simple.xsd"-->
+<beans xmlns="http://www.springframework.org/schema/beans"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xmlns:util="http://www.springframework.org/schema/util"
+  xmlns:jaxrs="http://cxf.apache.org/jaxrs"
+  xmlns:cxf="http://cxf.apache.org/core"
+  xsi:schemaLocation="
+http://www.springframework.org/schema/beans 
+http://www.springframework.org/schema/beans/spring-beans.xsd
+http://www.springframework.org/schema/util 
+http://www.springframework.org/schema/util/spring-util-2.0.xsd
+http://cxf.apache.org/jaxrs
+http://cxf.apache.org/schemas/jaxrs.xsd
+http://cxf.apache.org/core
+http://cxf.apache.org/schemas/core.xsd">
+
+  <import resource="classpath:META-INF/cxf/cxf.xml" />
+  <import resource="classpath:META-INF/cxf/cxf-extension-jaxrs-binding.xml" />
+  <import resource="classpath:META-INF/cxf/cxf-servlet.xml" />
+
+  <bean class="org.apache.cxf.systest.jaxrs.JAXRSOverlappingDestinationsTest.Resource" 
+        id="serviceBean"/>
+  
+  <jaxrs:server address="/">
+    <jaxrs:serviceBeans>
+      <ref bean="serviceBean" />
+    </jaxrs:serviceBeans>		   
+  </jaxrs:server>
+
+</beans>
+<!-- END SNIPPET: beans -->
diff --git a/systests/jaxrs/src/test/resources/jaxrs_many_destinations/WEB-INF/web.xml b/systests/jaxrs/src/test/resources/jaxrs_many_destinations/WEB-INF/web.xml
new file mode 100644
index 0000000000..013079904f
--- /dev/null
+++ b/systests/jaxrs/src/test/resources/jaxrs_many_destinations/WEB-INF/web.xml
@@ -0,0 +1,74 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<!DOCTYPE web-app
+    PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
+    "http://java.sun.com/dtd/web-app_2_3.dtd">
+
+<!--
+	Licensed to the Apache Software Foundation (ASF) under one
+	or more contributor license agreements. See the NOTICE file
+	distributed with this work for additional information
+	regarding copyright ownership. The ASF licenses this file
+	to you under the Apache License, Version 2.0 (the
+	"License"); you may not use this file except in compliance
+	with the License. You may obtain a copy of the License at
+	
+	http://www.apache.org/licenses/LICENSE-2.0
+	
+	Unless required by applicable law or agreed to in writing,
+	software distributed under the License is distributed on an
+	"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+	KIND, either express or implied. See the License for the
+	specific language governing permissions and limitations
+	under the License.
+-->
+<!-- START SNIPPET: webxml -->
+<web-app>
+	<context-param>
+		<param-name>contextConfigLocation</param-name>
+		<param-value>WEB-INF/beans.xml</param-value>
+	</context-param>
+
+	<listener>
+		<listener-class>
+			org.springframework.web.context.ContextLoaderListener
+		</listener-class>
+	</listener>
+
+	<servlet>
+		<servlet-name>CXFServletOne</servlet-name>
+		<display-name>CXF Servlet1</display-name>
+		<servlet-class>
+			org.apache.cxf.transport.servlet.CXFServlet
+		</servlet-class>
+		<init-param>
+		      <param-name>disable-address-updates</param-name>
+		      <param-value>true</param-value>    
+		</init-param>
+		<load-on-startup>1</load-on-startup>
+	</servlet>
+
+    <servlet>
+		<servlet-name>CXFServletTwo</servlet-name>
+		<display-name>CXF Servlet2</display-name>
+		<servlet-class>
+			org.apache.cxf.transport.servlet.CXFServlet
+		</servlet-class>
+		<init-param>
+		      <param-name>disable-address-updates</param-name>
+		      <param-value>true</param-value>    
+		</init-param>
+		<load-on-startup>1</load-on-startup>
+	</servlet>
+
+	<servlet-mapping>
+		<servlet-name>CXFServletOne</servlet-name>
+		<url-pattern>/one/*</url-pattern>
+	</servlet-mapping>
+	
+	<servlet-mapping>
+		<servlet-name>CXFServletTwo</servlet-name>
+		<url-pattern>/two/*</url-pattern>
+	</servlet-mapping>
+</web-app>
+<!-- END SNIPPET: webxml -->
\ No newline at end of file
