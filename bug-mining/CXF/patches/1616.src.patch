diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/token/provider/SamlCallbackHandler.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/token/provider/SamlCallbackHandler.java
index ebf62ffedf..21be476987 100644
--- a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/token/provider/SamlCallbackHandler.java
+++ b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/token/provider/SamlCallbackHandler.java
@@ -19,6 +19,7 @@
 package org.apache.cxf.sts.token.provider;
 
 import java.io.IOException;
+import java.util.Collections;
 import java.util.List;
 
 import javax.security.auth.callback.Callback;
@@ -112,11 +113,13 @@ public class SamlCallbackHandler implements CallbackHandler {
                 // Set the token Type.
                 TokenRequirements tokenRequirements = tokenParameters.getTokenRequirements();
                 String tokenType = tokenRequirements.getTokenType();
+                boolean saml1 = false;
                 if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)
                     || WSConstants.SAML2_NS.equals(tokenType)) {
                     callback.setSamlVersion(SAMLVersion.VERSION_20);
                 } else {
                     callback.setSamlVersion(SAMLVersion.VERSION_11);
+                    saml1 = true;
                     setSubjectOnBeans();
                 }
                 
@@ -129,14 +132,26 @@ public class SamlCallbackHandler implements CallbackHandler {
                 }
 
                 // Set the statements
+                boolean statementAdded = false;
                 if (attributeBeans != null && !attributeBeans.isEmpty()) {
                     callback.setAttributeStatementData(attributeBeans);
+                    statementAdded = true;
                 }
                 if (authBeans != null && !authBeans.isEmpty()) {
                     callback.setAuthenticationStatementData(authBeans);
+                    statementAdded = true;
                 }
                 if (authDecisionBeans != null && !authDecisionBeans.isEmpty()) {
                     callback.setAuthDecisionStatementData(authDecisionBeans);
+                    statementAdded = true;
+                }
+                
+                // If SAML 1.1 we *must* add a Statement
+                if (saml1 && !statementAdded) {
+                    AttributeStatementBean defaultStatement = 
+                        new DefaultAttributeStatementProvider().getStatement(tokenParameters);
+                    defaultStatement.setSubject(subjectBean);
+                    callback.setAttributeStatementData(Collections.singletonList(defaultStatement));
                 }
                 
                 // Set the conditions
diff --git a/services/sts/sts-core/src/test/java/org/apache/cxf/sts/token/validator/SAMLTokenValidatorTest.java b/services/sts/sts-core/src/test/java/org/apache/cxf/sts/token/validator/SAMLTokenValidatorTest.java
index 6cecb4c48b..9e14ccdd60 100644
--- a/services/sts/sts-core/src/test/java/org/apache/cxf/sts/token/validator/SAMLTokenValidatorTest.java
+++ b/services/sts/sts-core/src/test/java/org/apache/cxf/sts/token/validator/SAMLTokenValidatorTest.java
@@ -21,6 +21,7 @@ package org.apache.cxf.sts.token.validator;
 import java.io.IOException;
 import java.security.Principal;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Date;
 import java.util.List;
 import java.util.Properties;
@@ -38,6 +39,7 @@ import org.apache.cxf.message.MessageImpl;
 import org.apache.cxf.sts.STSConstants;
 import org.apache.cxf.sts.StaticSTSProperties;
 import org.apache.cxf.sts.cache.DefaultInMemoryTokenStore;
+import org.apache.cxf.sts.claims.ClaimsAttributeStatementProvider;
 import org.apache.cxf.sts.common.PasswordCallbackHandler;
 import org.apache.cxf.sts.request.KeyRequirements;
 import org.apache.cxf.sts.request.Lifetime;
@@ -45,6 +47,7 @@ import org.apache.cxf.sts.request.ReceivedToken;
 import org.apache.cxf.sts.request.ReceivedToken.STATE;
 import org.apache.cxf.sts.request.TokenRequirements;
 import org.apache.cxf.sts.service.EncryptionProperties;
+import org.apache.cxf.sts.token.provider.AttributeStatementProvider;
 import org.apache.cxf.sts.token.provider.DefaultConditionsProvider;
 import org.apache.cxf.sts.token.provider.SAMLTokenProvider;
 import org.apache.cxf.sts.token.provider.TokenProvider;
@@ -139,6 +142,41 @@ public class SAMLTokenValidatorTest extends org.junit.Assert {
         assertTrue(principal != null && principal.getName() != null);
     }
     
+    /**
+     * Test a SAML 1.1 Assertion that is configured with the ClaimsAttributeStatementProvider,
+     * but does not contain any claims. In older versions of the STS, this generated an invalid
+     * SAML Assertion.
+     */
+    @org.junit.Test
+    public void testSAML1AssertionWithClaims() throws Exception {
+        TokenValidator samlTokenValidator = new SAMLTokenValidator();
+        TokenValidatorParameters validatorParameters = createValidatorParameters();
+        validatorParameters.setTokenStore(null);
+        TokenRequirements tokenRequirements = validatorParameters.getTokenRequirements();
+        
+        // Create a ValidateTarget consisting of a SAML Assertion
+        Crypto crypto = CryptoFactory.getInstance(getEncryptionProperties());
+        CallbackHandler callbackHandler = new PasswordCallbackHandler();
+        Element samlToken = 
+            createSAMLAssertionWithClaimsProvider(
+                WSConstants.WSS_SAML_TOKEN_TYPE, crypto, "mystskey", callbackHandler
+            );
+        Document doc = samlToken.getOwnerDocument();
+        samlToken = (Element)doc.appendChild(samlToken);
+        
+        ReceivedToken validateTarget = new ReceivedToken(samlToken);
+        tokenRequirements.setValidateTarget(validateTarget);
+        validatorParameters.setToken(validateTarget);
+        
+        assertTrue(samlTokenValidator.canHandleToken(validateTarget));
+        
+        TokenValidatorResponse validatorResponse = 
+            samlTokenValidator.validateToken(validatorParameters);
+        assertTrue(validatorResponse != null);
+        assertTrue(validatorResponse.getToken() != null);
+        assertTrue(validatorResponse.getToken().getState() == STATE.VALID);
+    }
+    
     /**
      * Test a SAML 1.1 Assertion with an invalid signature
      */
@@ -357,6 +395,23 @@ public class SAMLTokenValidatorTest extends org.junit.Assert {
         return providerResponse.getToken();
     }
     
+    private Element createSAMLAssertionWithClaimsProvider(
+        String tokenType, Crypto crypto, String signatureUsername, CallbackHandler callbackHandler
+    ) throws WSSecurityException {
+        SAMLTokenProvider samlTokenProvider = new SAMLTokenProvider();
+        AttributeStatementProvider statementProvider = new ClaimsAttributeStatementProvider();
+        samlTokenProvider.setAttributeStatementProviders(Collections.singletonList(statementProvider));
+        TokenProviderParameters providerParameters = 
+            createProviderParameters(
+                tokenType, STSConstants.BEARER_KEY_KEYTYPE, crypto, signatureUsername, callbackHandler
+            );
+        TokenProviderResponse providerResponse = samlTokenProvider.createToken(providerParameters);
+        assertTrue(providerResponse != null);
+        assertTrue(providerResponse.getToken() != null && providerResponse.getTokenId() != null);
+
+        return providerResponse.getToken();
+    }
+    
     private Element createSAMLAssertion(
             String tokenType, Crypto crypto, String signatureUsername,
             CallbackHandler callbackHandler, long ttlMs
