diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerListener.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerListener.java
deleted file mode 100644
index 7556cdd7fd..0000000000
--- a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerListener.java
+++ /dev/null
@@ -1,376 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.apache.cxf.sts.event;
-
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import javax.servlet.http.HttpServletRequest;
-
-import org.apache.cxf.common.logging.LogUtils;
-import org.apache.cxf.sts.claims.RequestClaim;
-import org.apache.cxf.sts.token.canceller.TokenCancellerParameters;
-import org.apache.cxf.sts.token.provider.TokenProviderParameters;
-import org.apache.cxf.sts.token.renewer.TokenRenewerParameters;
-import org.apache.cxf.sts.token.validator.TokenValidatorParameters;
-import org.apache.cxf.transport.http.AbstractHTTPDestination;
-
-public class LoggerListener implements STSEventListener {
-    
-    public enum KEYS {
-        TIME,
-        OPERATION,
-        WS_SEC_PRINCIPAL,
-        STATUS,
-        TOKENTYPE,
-        EXCEPTION,
-        REALM,
-        APPLIESTO,
-        CLAIMS_PRIMARY,
-        CLAIMS_SECONDARY,
-        DURATION,
-        ACTAS_PRINCIPAL,
-        ONBEHALFOF_PRINCIPAL,
-        VALIDATE_PRINCIPAL,
-        CANCEL_PRINCIPAL,
-        RENEW_PRINCIPAL,
-        REMOTE_HOST,
-        REMOTE_PORT,
-        URL,
-        STACKTRACE
-    };
-    
-    private static final Logger LOG = LogUtils.getL7dLogger(LoggerListener.class);
-    
-    private List<String> fieldOrder = new ArrayList<String>();
-    private boolean logStacktrace;
-    private boolean logFieldname;
-    private Level logLevel = Level.FINE;
-    private DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);
-    private StacktraceFormatter stacktraceFormatter = new StacktraceDefaultFormatter();
-    
-    
-
-    public LoggerListener() {
-        fieldOrder.add(KEYS.TIME.name());
-        fieldOrder.add(KEYS.STATUS.name());
-        fieldOrder.add(KEYS.DURATION.name());
-        fieldOrder.add(KEYS.REMOTE_HOST.name());
-        fieldOrder.add(KEYS.REMOTE_PORT.name());
-        fieldOrder.add(KEYS.OPERATION.name());
-        fieldOrder.add(KEYS.URL.name());
-        fieldOrder.add(KEYS.REALM.name());
-        fieldOrder.add(KEYS.WS_SEC_PRINCIPAL.name());
-        fieldOrder.add(KEYS.ONBEHALFOF_PRINCIPAL.name());
-        fieldOrder.add(KEYS.ACTAS_PRINCIPAL.name());
-        fieldOrder.add(KEYS.VALIDATE_PRINCIPAL.name());
-        fieldOrder.add(KEYS.CANCEL_PRINCIPAL.name());
-        fieldOrder.add(KEYS.RENEW_PRINCIPAL.name());
-        fieldOrder.add(KEYS.TOKENTYPE.name());
-        fieldOrder.add(KEYS.APPLIESTO.name());
-        fieldOrder.add(KEYS.CLAIMS_PRIMARY.name());
-        fieldOrder.add(KEYS.CLAIMS_SECONDARY.name());
-        fieldOrder.add(KEYS.EXCEPTION.name());
-        fieldOrder.add(KEYS.STACKTRACE.name());
-    }
-    
-    @Override
-    public void handleSTSEvent(AbstractSTSEvent event) {
-        
-        if (event instanceof TokenProviderParametersSupport) {
-            handleEvent((TokenProviderParametersSupport)event);
-        } else if (event instanceof TokenValidatorParametersSupport) {
-            handleEvent((TokenValidatorParametersSupport)event);
-        } else if (event instanceof TokenCancellerParametersSupport) {
-            handleEvent((TokenCancellerParametersSupport)event);
-        } else if (event instanceof TokenRenewerParametersSupport) {
-            handleEvent((TokenRenewerParametersSupport)event);            
-        } else {
-            LOG.warning("Unknown STS event: " + event.getClass());
-        }
-    }
-    
-   
-    public void handleEvent(TokenProviderParametersSupport event) {
-        try {
-            Map<String, String> map = new HashMap<String, String>();
-            AbstractSTSEvent baseEvent = (AbstractSTSEvent)event;
-            map.put(KEYS.TIME.name(), this.dateFormat.format(new Date(baseEvent.getTimestamp())));
-            map.put(KEYS.OPERATION.name(), baseEvent.getOperation());
-            map.put(KEYS.DURATION.name(), String.valueOf(baseEvent.getDuration()) + "ms");
-            
-            TokenProviderParameters params = event.getTokenParameters();
-            try {
-                HttpServletRequest req = (HttpServletRequest)params.getWebServiceContext().
-                    getMessageContext().get(AbstractHTTPDestination.HTTP_REQUEST);
-                map.put(KEYS.REMOTE_HOST.name(), req.getRemoteHost());
-                map.put(KEYS.REMOTE_PORT.name(), String.valueOf(req.getRemotePort()));
-                map.put(KEYS.URL.name(), (String)params.getWebServiceContext().
-                        getMessageContext().get("org.apache.cxf.request.url"));
-            } catch (NullPointerException ex) {
-                map.put(KEYS.REMOTE_HOST.name(), "N.A.");
-                map.put(KEYS.REMOTE_PORT.name(), "N.A.");
-                map.put(KEYS.URL.name(), "N.A.");
-            }
-            
-            try {
-                map.put(KEYS.TOKENTYPE.name(), params.getTokenRequirements().getTokenType());
-            } catch (NullPointerException ex) {
-                map.put(KEYS.TOKENTYPE.name(), "N.A.");
-            }
-            
-            try {
-                if (params.getTokenRequirements().getOnBehalfOf() != null) {
-                    map.put(KEYS.ONBEHALFOF_PRINCIPAL.name(),
-                            params.getTokenRequirements().getOnBehalfOf().getPrincipal().getName());
-                }
-                if (params.getTokenRequirements().getActAs() != null) {
-                    map.put(KEYS.ACTAS_PRINCIPAL.name(),
-                            params.getTokenRequirements().getActAs().getPrincipal().getName());
-                }
-                if (params.getPrincipal() != null) {
-                    map.put(KEYS.WS_SEC_PRINCIPAL.name(), params.getPrincipal().getName());
-                }
-            } catch (NullPointerException ex) {
-                //Principal could be null
-            }
-            map.put(KEYS.REALM.name(), params.getRealm());
-            map.put(KEYS.APPLIESTO.name(), params.getAppliesToAddress());
-            
-            if (params.getRequestedPrimaryClaims() != null
-                    && fieldOrder.indexOf(KEYS.CLAIMS_PRIMARY.name()) != -1) {
-                List<String> claims = new ArrayList<String>();
-                for (RequestClaim claim : params.getRequestedPrimaryClaims()) {
-                    claims.add(claim.getClaimType().toString());
-                }
-                map.put(KEYS.CLAIMS_PRIMARY.name(), claims.toString());
-            }
-            if (params.getRequestedSecondaryClaims() != null
-                    && fieldOrder.indexOf(KEYS.CLAIMS_SECONDARY.name()) != -1) {
-                List<String> claims = new ArrayList<String>();
-                for (RequestClaim claim : params.getRequestedSecondaryClaims()) {
-                    claims.add(claim.getClaimType().toString());
-                }
-                map.put(KEYS.CLAIMS_SECONDARY.name(), claims.toString());
-            }
-            if (event instanceof AbstractSTSFailureEvent) {
-                map.put(KEYS.STATUS.name(), "FAILURE");
-                Exception ex = ((AbstractSTSFailureEvent)event).getException();
-                map.put(KEYS.EXCEPTION.name(), ex.getMessage());
-                if (this.isLogStacktrace() && stacktraceFormatter != null) {
-                    map.put(KEYS.STACKTRACE.name(), stacktraceFormatter.format(ex));
-                }
-            } else {
-                map.put(KEYS.STATUS.name(), "SUCCESS");
-            }
-            writeLog(map);
-        } catch (Throwable ex) {
-            LOG.log(Level.WARNING, "Failed to capture or write logging details", ex);
-        }
-    }
-    
-    public void handleEvent(TokenValidatorParametersSupport event) {
-        try {
-            Map<String, String> map = new HashMap<String, String>();
-            AbstractSTSEvent baseEvent = (AbstractSTSEvent)event;
-            map.put(KEYS.TIME.name(), this.dateFormat.format(new Date(baseEvent.getTimestamp())));
-            map.put(KEYS.OPERATION.name(), baseEvent.getOperation());
-            map.put(KEYS.DURATION.name(), String.valueOf(baseEvent.getDuration()) + "ms");
-            
-            TokenValidatorParameters params = event.getTokenParameters();
-            HttpServletRequest req = (HttpServletRequest)params.getWebServiceContext().
-                getMessageContext().get(AbstractHTTPDestination.HTTP_REQUEST);
-            map.put(KEYS.REMOTE_HOST.name(), req.getRemoteHost());
-            map.put(KEYS.REMOTE_PORT.name(), String.valueOf(req.getRemotePort()));
-            map.put(KEYS.URL.name(), (String)params.getWebServiceContext().
-                    getMessageContext().get("org.apache.cxf.request.url"));
-            map.put(KEYS.TOKENTYPE.name(), params.getTokenRequirements().getTokenType());
-            if (params.getTokenRequirements().getActAs() != null) {
-                map.put(KEYS.VALIDATE_PRINCIPAL.name(), 
-                        params.getTokenRequirements().getValidateTarget().getPrincipal().getName());
-            }
-            if (params.getPrincipal() != null) {
-                map.put(KEYS.WS_SEC_PRINCIPAL.name(), params.getPrincipal().getName());
-            }
-            map.put(KEYS.REALM.name(), params.getRealm());
-            //map.put(KEYS.APPLIESTO.name(), params.getAppliesToAddress());
-            if (event instanceof AbstractSTSFailureEvent) {
-                map.put(KEYS.STATUS.name(), "FAILURE");
-                Exception ex = ((AbstractSTSFailureEvent)event).getException();
-                map.put(KEYS.EXCEPTION.name(), ex.getMessage());
-                if (this.isLogStacktrace() && stacktraceFormatter != null) {
-                    map.put(KEYS.STACKTRACE.name(), stacktraceFormatter.format(ex));
-                }
-            } else {
-                map.put(KEYS.STATUS.name(), "SUCCESS");
-            }
-            writeLog(map);
-        } catch (Throwable ex) {
-            LOG.log(Level.WARNING, "Failed to capture or write logging details", ex);
-        }        
-    }
-    
-    public void handleEvent(TokenCancellerParametersSupport event) {
-        try {
-            Map<String, String> map = new HashMap<String, String>();
-            AbstractSTSEvent baseEvent = (AbstractSTSEvent)event;
-            map.put(KEYS.TIME.name(), this.dateFormat.format(new Date(baseEvent.getTimestamp())));
-            map.put(KEYS.OPERATION.name(), baseEvent.getOperation());
-            map.put(KEYS.DURATION.name(), String.valueOf(baseEvent.getDuration()) + "ms");
-            
-            TokenCancellerParameters params = event.getTokenParameters();
-            HttpServletRequest req = (HttpServletRequest)params.getWebServiceContext().
-                getMessageContext().get(AbstractHTTPDestination.HTTP_REQUEST);
-            map.put(KEYS.REMOTE_HOST.name(), req.getRemoteHost());
-            map.put(KEYS.REMOTE_PORT.name(), String.valueOf(req.getRemotePort()));
-            map.put(KEYS.URL.name(), (String)params.getWebServiceContext().
-                    getMessageContext().get("org.apache.cxf.request.url"));
-            map.put(KEYS.TOKENTYPE.name(), params.getTokenRequirements().getTokenType());
-            if (params.getTokenRequirements().getActAs() != null) {
-                map.put(KEYS.CANCEL_PRINCIPAL.name(), 
-                        params.getTokenRequirements().getCancelTarget().getPrincipal().getName());
-            }
-            if (params.getPrincipal() != null) {
-                map.put(KEYS.WS_SEC_PRINCIPAL.name(), params.getPrincipal().getName());
-            }
-            //map.put(KEYS.REALM.name(), params.getRealm());
-            //map.put(KEYS.APPLIESTO.name(), params.getAppliesToAddress());
-            if (event instanceof AbstractSTSFailureEvent) {
-                map.put(KEYS.STATUS.name(), "FAILURE");
-                Exception ex = ((AbstractSTSFailureEvent)event).getException();
-                map.put(KEYS.EXCEPTION.name(), ex.getMessage());
-                if (this.isLogStacktrace() && stacktraceFormatter != null) {
-                    map.put(KEYS.STACKTRACE.name(), stacktraceFormatter.format(ex));
-                }
-            } else {
-                map.put(KEYS.STATUS.name(), "SUCCESS");
-            }
-            writeLog(map);
-        } catch (Throwable ex) {
-            LOG.log(Level.WARNING, "Failed to capture or write logging details", ex);
-        }        
-    }
-    
-    public void handleEvent(TokenRenewerParametersSupport event) {
-        try {
-            Map<String, String> map = new HashMap<String, String>();
-            AbstractSTSEvent baseEvent = (AbstractSTSEvent)event;
-            map.put(KEYS.TIME.name(), this.dateFormat.format(new Date(baseEvent.getTimestamp())));
-            map.put(KEYS.OPERATION.name(), baseEvent.getOperation());
-            map.put(KEYS.DURATION.name(), String.valueOf(baseEvent.getDuration()) + "ms");
-            
-            TokenRenewerParameters params = event.getTokenParameters();
-            HttpServletRequest req = (HttpServletRequest)params.getWebServiceContext().
-                getMessageContext().get(AbstractHTTPDestination.HTTP_REQUEST);
-            map.put(KEYS.REMOTE_HOST.name(), req.getRemoteHost());
-            map.put(KEYS.REMOTE_PORT.name(), String.valueOf(req.getRemotePort()));
-            map.put(KEYS.URL.name(), (String)params.getWebServiceContext().
-                    getMessageContext().get("org.apache.cxf.request.url"));
-            map.put(KEYS.TOKENTYPE.name(), params.getTokenRequirements().getTokenType());
-            if (params.getTokenRequirements().getRenewTarget() != null) {
-                map.put(KEYS.RENEW_PRINCIPAL.name(), 
-                        params.getTokenRequirements().getRenewTarget().getPrincipal().getName());
-            }
-            if (params.getPrincipal() != null) {
-                map.put(KEYS.WS_SEC_PRINCIPAL.name(), params.getPrincipal().getName());
-            }
-            map.put(KEYS.REALM.name(), params.getRealm());
-            map.put(KEYS.APPLIESTO.name(), params.getAppliesToAddress());
-            if (event instanceof AbstractSTSFailureEvent) {
-                map.put(KEYS.STATUS.name(), "FAILURE");
-                Exception ex = ((AbstractSTSFailureEvent)event).getException();
-                map.put(KEYS.EXCEPTION.name(), ex.getMessage());
-                if (this.isLogStacktrace() && stacktraceFormatter != null) {
-                    map.put(KEYS.STACKTRACE.name(), stacktraceFormatter.format(ex));
-                }
-            } else {
-                map.put(KEYS.STATUS.name(), "SUCCESS");
-            }
-            writeLog(map);
-        } catch (Throwable ex) {
-            LOG.log(Level.WARNING, "Failed to capture or write logging details", ex);
-        }        
-    }
-    
-    protected void writeLog(Map<String, String> map) {
-        final StringBuilder builder = new StringBuilder();
-        for (String key : fieldOrder) {
-            if (this.logFieldname) {
-                builder.append(key).append("=").append(map.get(key)).append(";");
-            } else {
-                builder.append(map.get(key)).append(";");
-            }
-            
-        }
-        LOG.log(this.logLevel, builder.toString());
-    }
-
-    public List<String> getFieldOrder() {
-        return fieldOrder;
-    }
-
-    public void setFieldOrder(List<String> fieldOrder) {
-        this.fieldOrder = fieldOrder;
-    }
-
-    public boolean isLogStacktrace() {
-        return logStacktrace;
-    }
-
-    public void setLogStacktrace(boolean logStacktrace) {
-        this.logStacktrace = logStacktrace;
-    }
-
-    public boolean isLogFieldname() {
-        return logFieldname;
-    }
-
-    public void setLogFieldname(boolean logFieldname) {
-        this.logFieldname = logFieldname;
-    }
-    
-    public void setDateFormat(String format) {
-        this.dateFormat = new SimpleDateFormat(format);
-    }
-
-    public String getLogLevel() {
-        return logLevel.getName();
-    }
-
-    public void setLogLevel(String logLevel) {
-        this.logLevel = Level.parse(logLevel);
-    }
-    
-    public StacktraceFormatter getStacktraceFormatter() {
-        return stacktraceFormatter;
-    }
-
-    public void setStacktraceFormatter(StacktraceFormatter stacktraceFormatter) {
-        this.stacktraceFormatter = stacktraceFormatter;
-    }
-    
-}
diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerPatternLayoutLog4J.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerPatternLayoutLog4J.java
index 00686d5359..ee8b61b5b6 100644
--- a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerPatternLayoutLog4J.java
+++ b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerPatternLayoutLog4J.java
@@ -19,6 +19,7 @@
 
 package org.apache.cxf.sts.event;
 
+import org.apache.cxf.sts.event.map.MapEventLogger;
 import org.apache.log4j.PatternLayout;
 
 public class LoggerPatternLayoutLog4J extends PatternLayout {
@@ -34,7 +35,7 @@ public class LoggerPatternLayoutLog4J extends PatternLayout {
         if (this.header != null) {
             return this.header + System.getProperty("line.separator");
         }
-        LoggerListener ll = new LoggerListener();
+        MapEventLogger ll = new MapEventLogger();
         StringBuffer line = new StringBuffer();
         for (String item : ll.getFieldOrder()) {
             line.append(item).append(";");
diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerPatternLayoutLogback.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerPatternLayoutLogback.java
index b06c532059..2efe09b4cc 100644
--- a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerPatternLayoutLogback.java
+++ b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/LoggerPatternLayoutLogback.java
@@ -19,6 +19,8 @@
 
 package org.apache.cxf.sts.event;
 
+import org.apache.cxf.sts.event.map.MapEventLogger;
+
 import ch.qos.logback.classic.PatternLayout;
 
 public class LoggerPatternLayoutLogback extends PatternLayout {
@@ -30,7 +32,7 @@ public class LoggerPatternLayoutLogback extends PatternLayout {
         if (this.header != null) {
             return this.header + System.getProperty("line.separator");
         }
-        LoggerListener ll = new LoggerListener();
+        MapEventLogger ll = new MapEventLogger();
         StringBuffer line = new StringBuffer();
         for (String item : ll.getFieldOrder()) {
             line.append(item).append(";");
diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/EventMapper.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/EventMapper.java
new file mode 100644
index 0000000000..d29bb63ce5
--- /dev/null
+++ b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/EventMapper.java
@@ -0,0 +1,190 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.sts.event.map;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Logger;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.sts.claims.RequestClaim;
+import org.apache.cxf.sts.event.AbstractSTSEvent;
+import org.apache.cxf.sts.event.AbstractSTSFailureEvent;
+import org.apache.cxf.sts.event.STSEventListener;
+import org.apache.cxf.sts.event.TokenCancellerParametersSupport;
+import org.apache.cxf.sts.event.TokenProviderParametersSupport;
+import org.apache.cxf.sts.event.TokenRenewerParametersSupport;
+import org.apache.cxf.sts.event.TokenValidatorParametersSupport;
+import org.apache.cxf.sts.token.canceller.TokenCancellerParameters;
+import org.apache.cxf.sts.token.provider.TokenProviderParameters;
+import org.apache.cxf.sts.token.renewer.TokenRenewerParameters;
+import org.apache.cxf.sts.token.validator.TokenValidatorParameters;
+import org.apache.cxf.transport.http.AbstractHTTPDestination;
+
+public class EventMapper implements STSEventListener {
+    private static final Logger LOG = LogUtils.getL7dLogger(EventMapper.class);
+    private MapEventListener mapEventListener;
+
+    public EventMapper(MapEventListener mapEventListener) {
+        this.mapEventListener = mapEventListener;
+    }
+    
+    @Override
+    public void handleSTSEvent(AbstractSTSEvent event) {
+        Map<String, Object> map = new HashMap<String, Object>();
+        map.put(KEYS.TIME.name(), new Date(event.getTimestamp()));
+        map.put(KEYS.OPERATION.name(), event.getOperation());
+        map.put(KEYS.DURATION.name(), String.valueOf(event.getDuration()) + "ms");
+        
+        if (event instanceof AbstractSTSFailureEvent) {
+            map.put(KEYS.STATUS.name(), "FAILURE");
+            Exception ex = ((AbstractSTSFailureEvent) event).getException();
+            map.put(KEYS.EXCEPTION.name(), ex);
+        } else {
+            map.put(KEYS.STATUS.name(), "SUCCESS");
+        }
+        
+        if (event instanceof TokenProviderParametersSupport) {
+            handleEvent((TokenProviderParametersSupport)event, map);
+        } else if (event instanceof TokenValidatorParametersSupport) {
+            handleEvent((TokenValidatorParametersSupport)event, map);
+        } else if (event instanceof TokenCancellerParametersSupport) {
+            handleEvent((TokenCancellerParametersSupport)event, map);
+        } else if (event instanceof TokenRenewerParametersSupport) {
+            handleEvent((TokenRenewerParametersSupport)event, map);            
+        } else {
+            LOG.warning("Unknown STS event: " + event.getClass());
+        }
+        MapEvent mapEvent = new MapEvent("org/apache/cxf/sts", map);
+        mapEventListener.onEvent(mapEvent);
+    }
+    
+    protected void handleEvent(TokenProviderParametersSupport event, Map<String, Object> map) {
+        TokenProviderParameters params = event.getTokenParameters();
+        try {
+            HttpServletRequest req = (HttpServletRequest) params.getWebServiceContext().getMessageContext()
+                    .get(AbstractHTTPDestination.HTTP_REQUEST);
+            map.put(KEYS.REMOTE_HOST.name(), req.getRemoteHost());
+            map.put(KEYS.REMOTE_PORT.name(), String.valueOf(req.getRemotePort()));
+            map.put(KEYS.URL.name(),
+                    (String) params.getWebServiceContext().getMessageContext().get("org.apache.cxf.request.url"));
+        } catch (Exception ex) {
+            map.put(KEYS.REMOTE_HOST.name(), "N.A.");
+            map.put(KEYS.REMOTE_PORT.name(), "N.A.");
+            map.put(KEYS.URL.name(), "N.A.");
+        }
+
+        if (params.getTokenRequirements() != null) {
+            map.put(KEYS.TOKENTYPE.name(), params.getTokenRequirements().getTokenType());
+            if (params.getTokenRequirements().getOnBehalfOf() != null) {
+                map.put(KEYS.ONBEHALFOF_PRINCIPAL.name(), params.getTokenRequirements().getOnBehalfOf().getPrincipal()
+                        .getName());
+            }
+            if (params.getTokenRequirements().getActAs() != null) {
+                map.put(KEYS.ACTAS_PRINCIPAL.name(), params.getTokenRequirements().getActAs().getPrincipal().getName());
+            }
+        } else {
+            map.put(KEYS.TOKENTYPE.name(), "N.A.");
+        }
+        if (params.getPrincipal() != null) {
+            map.put(KEYS.WS_SEC_PRINCIPAL.name(), params.getPrincipal().getName());
+        }
+        map.put(KEYS.REALM.name(), params.getRealm());
+        map.put(KEYS.APPLIESTO.name(), params.getAppliesToAddress());
+
+        if (params.getRequestedPrimaryClaims() != null) {
+            List<String> claims = new ArrayList<String>();
+            for (RequestClaim claim : params.getRequestedPrimaryClaims()) {
+                claims.add(claim.getClaimType().toString());
+            }
+            map.put(KEYS.CLAIMS_PRIMARY.name(), claims.toString());
+        }
+        if (params.getRequestedSecondaryClaims() != null) {
+            List<String> claims = new ArrayList<String>();
+            for (RequestClaim claim : params.getRequestedSecondaryClaims()) {
+                claims.add(claim.getClaimType().toString());
+            }
+            map.put(KEYS.CLAIMS_SECONDARY.name(), claims.toString());
+        }
+    }
+    
+    protected void handleEvent(TokenValidatorParametersSupport event, Map<String, Object> map) {
+        TokenValidatorParameters params = event.getTokenParameters();
+        HttpServletRequest req = (HttpServletRequest) params.getWebServiceContext().getMessageContext()
+                .get(AbstractHTTPDestination.HTTP_REQUEST);
+        map.put(KEYS.REMOTE_HOST.name(), req.getRemoteHost());
+        map.put(KEYS.REMOTE_PORT.name(), String.valueOf(req.getRemotePort()));
+        map.put(KEYS.URL.name(),
+                (String) params.getWebServiceContext().getMessageContext().get("org.apache.cxf.request.url"));
+        map.put(KEYS.TOKENTYPE.name(), params.getTokenRequirements().getTokenType());
+        if (params.getTokenRequirements().getActAs() != null) {
+            map.put(KEYS.VALIDATE_PRINCIPAL.name(), params.getTokenRequirements().getValidateTarget().getPrincipal()
+                    .getName());
+        }
+        if (params.getPrincipal() != null) {
+            map.put(KEYS.WS_SEC_PRINCIPAL.name(), params.getPrincipal().getName());
+        }
+        map.put(KEYS.REALM.name(), params.getRealm());
+    }
+    
+    protected void handleEvent(TokenCancellerParametersSupport event, Map<String, Object> map) {
+        TokenCancellerParameters params = event.getTokenParameters();
+        HttpServletRequest req = (HttpServletRequest) params.getWebServiceContext().getMessageContext()
+                .get(AbstractHTTPDestination.HTTP_REQUEST);
+        map.put(KEYS.REMOTE_HOST.name(), req.getRemoteHost());
+        map.put(KEYS.REMOTE_PORT.name(), String.valueOf(req.getRemotePort()));
+        map.put(KEYS.URL.name(),
+                (String) params.getWebServiceContext().getMessageContext().get("org.apache.cxf.request.url"));
+        map.put(KEYS.TOKENTYPE.name(), params.getTokenRequirements().getTokenType());
+        if (params.getTokenRequirements().getActAs() != null) {
+            map.put(KEYS.CANCEL_PRINCIPAL.name(), params.getTokenRequirements().getCancelTarget().getPrincipal()
+                    .getName());
+        }
+        if (params.getPrincipal() != null) {
+            map.put(KEYS.WS_SEC_PRINCIPAL.name(), params.getPrincipal().getName());
+        }
+    }
+    
+    protected void handleEvent(TokenRenewerParametersSupport event, Map<String, Object> map) {
+        TokenRenewerParameters params = event.getTokenParameters();
+        HttpServletRequest req = (HttpServletRequest) params.getWebServiceContext().getMessageContext()
+                .get(AbstractHTTPDestination.HTTP_REQUEST);
+        map.put(KEYS.REMOTE_HOST.name(), req.getRemoteHost());
+        map.put(KEYS.REMOTE_PORT.name(), String.valueOf(req.getRemotePort()));
+        map.put(KEYS.URL.name(),
+                (String) params.getWebServiceContext().getMessageContext().get("org.apache.cxf.request.url"));
+        map.put(KEYS.TOKENTYPE.name(), params.getTokenRequirements().getTokenType());
+        if (params.getTokenRequirements().getRenewTarget() != null) {
+            map.put(KEYS.RENEW_PRINCIPAL.name(), params.getTokenRequirements().getRenewTarget().getPrincipal()
+                    .getName());
+        }
+        if (params.getPrincipal() != null) {
+            map.put(KEYS.WS_SEC_PRINCIPAL.name(), params.getPrincipal().getName());
+        }
+        map.put(KEYS.REALM.name(), params.getRealm());
+        map.put(KEYS.APPLIESTO.name(), params.getAppliesToAddress());
+    }
+
+}
diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/StacktraceDefaultFormatter.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/KEYS.java
similarity index 66%
rename from services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/StacktraceDefaultFormatter.java
rename to services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/KEYS.java
index cbb9add51f..edc26b7105 100644
--- a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/StacktraceDefaultFormatter.java
+++ b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/KEYS.java
@@ -16,22 +16,27 @@
  * specific language governing permissions and limitations
  * under the License.
  */
+package org.apache.cxf.sts.event.map;
 
-package org.apache.cxf.sts.event;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.io.Writer;
-
-public class StacktraceDefaultFormatter implements StacktraceFormatter {
-
-    @Override
-    public String format(Throwable t) {
-        final Writer result = new StringWriter();
-        t.printStackTrace(new PrintWriter(result));
-        return result.toString();
-    }
-
-}
-
-
+public enum KEYS {
+    TIME,
+    OPERATION,
+    WS_SEC_PRINCIPAL,
+    STATUS,
+    TOKENTYPE,
+    EXCEPTION,
+    REALM,
+    APPLIESTO,
+    CLAIMS_PRIMARY,
+    CLAIMS_SECONDARY,
+    DURATION,
+    ACTAS_PRINCIPAL,
+    ONBEHALFOF_PRINCIPAL,
+    VALIDATE_PRINCIPAL,
+    CANCEL_PRINCIPAL,
+    RENEW_PRINCIPAL,
+    REMOTE_HOST,
+    REMOTE_PORT,
+    URL,
+    STACKTRACE
+}
\ No newline at end of file
diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/StacktraceHtmlFormatter.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/MapEvent.java
similarity index 59%
rename from services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/StacktraceHtmlFormatter.java
rename to services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/MapEvent.java
index d883d4270a..f8162d49fb 100644
--- a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/StacktraceHtmlFormatter.java
+++ b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/MapEvent.java
@@ -16,25 +16,26 @@
  * specific language governing permissions and limitations
  * under the License.
  */
+package org.apache.cxf.sts.event.map;
 
-package org.apache.cxf.sts.event;
+import java.util.Map;
 
-public class StacktraceHtmlFormatter implements StacktraceFormatter {
-
-    public static final String NEW_LINE = "<br>";
+public class MapEvent {
+    private String topic;
+    private Map<String, ?> properties;
     
-    @Override
-    public String format(Throwable t) {
-        final StringBuilder result = new StringBuilder("<html>");
-        result.append(t.toString());
-        result.append(NEW_LINE);
+    public MapEvent(String topic, Map<String, ?> properties) {
+        super();
+        this.topic = topic;
+        this.properties = properties;
+    }
+
+    public String getTopic() {
+        return topic;
+    }
 
-        for (StackTraceElement element : t.getStackTrace()) {
-            result.append(element);
-            result.append(NEW_LINE);
-        }
-        result.append("</html>");
-        return result.toString();
+    public Map<String, ?> getProperties() {
+        return properties;
     }
 
 }
diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/StacktraceFormatter.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/MapEventListener.java
similarity index 88%
rename from services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/StacktraceFormatter.java
rename to services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/MapEventListener.java
index 6086e59ec9..1d24c263d2 100644
--- a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/StacktraceFormatter.java
+++ b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/MapEventListener.java
@@ -16,9 +16,8 @@
  * specific language governing permissions and limitations
  * under the License.
  */
+package org.apache.cxf.sts.event.map;
 
-package org.apache.cxf.sts.event;
-
-public interface StacktraceFormatter {
-    String format(Throwable t);
+public interface MapEventListener {
+    void onEvent(MapEvent event);
 }
diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/MapEventLogger.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/MapEventLogger.java
new file mode 100644
index 0000000000..b09b2c65e7
--- /dev/null
+++ b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/event/map/MapEventLogger.java
@@ -0,0 +1,126 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.sts.event.map;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.apache.cxf.common.logging.LogUtils;
+
+public class MapEventLogger implements MapEventListener {
+    private static final Logger LOG = LogUtils.getL7dLogger(MapEventLogger.class);
+    
+    private List<String> fieldOrder = new ArrayList<String>();
+    private boolean logStacktrace;
+    private boolean logFieldname;
+    private Level logLevel = Level.FINE;
+    private DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);
+
+    public MapEventLogger() {
+        fieldOrder.add(KEYS.TIME.name());
+        fieldOrder.add(KEYS.STATUS.name());
+        fieldOrder.add(KEYS.DURATION.name());
+        fieldOrder.add(KEYS.REMOTE_HOST.name());
+        fieldOrder.add(KEYS.REMOTE_PORT.name());
+        fieldOrder.add(KEYS.OPERATION.name());
+        fieldOrder.add(KEYS.URL.name());
+        fieldOrder.add(KEYS.REALM.name());
+        fieldOrder.add(KEYS.WS_SEC_PRINCIPAL.name());
+        fieldOrder.add(KEYS.ONBEHALFOF_PRINCIPAL.name());
+        fieldOrder.add(KEYS.ACTAS_PRINCIPAL.name());
+        fieldOrder.add(KEYS.VALIDATE_PRINCIPAL.name());
+        fieldOrder.add(KEYS.CANCEL_PRINCIPAL.name());
+        fieldOrder.add(KEYS.RENEW_PRINCIPAL.name());
+        fieldOrder.add(KEYS.TOKENTYPE.name());
+        fieldOrder.add(KEYS.APPLIESTO.name());
+        fieldOrder.add(KEYS.CLAIMS_PRIMARY.name());
+        fieldOrder.add(KEYS.CLAIMS_SECONDARY.name());
+        fieldOrder.add(KEYS.EXCEPTION.name());
+        fieldOrder.add(KEYS.STACKTRACE.name());
+    }
+
+    @Override
+    public void onEvent(MapEvent event) {
+        Map<String, ?> map = event.getProperties();
+        final StringBuilder builder = new StringBuilder();
+        for (String key : fieldOrder) {
+            if (this.logFieldname) {
+                builder.append(key).append("=").append(map.get(key)).append(";");
+            } else {
+                builder.append(format(map.get(key))).append(";");
+            }
+        }
+        Exception ex = (Exception) map.get(KEYS.EXCEPTION.name());
+        LOG.log(this.logLevel, builder.toString(), ex);
+    }
+
+    private String format(Object value) {
+        if (value instanceof String) {
+            return (String) value;
+        } else if (value instanceof Date) {
+            return dateFormat.format(value);
+        } else {
+            return value.toString();
+        }
+    }
+
+    public List<String> getFieldOrder() {
+        return fieldOrder;
+    }
+
+    public void setFieldOrder(List<String> fieldOrder) {
+        this.fieldOrder = fieldOrder;
+    }
+
+    public boolean isLogStacktrace() {
+        return logStacktrace;
+    }
+
+    public void setLogStacktrace(boolean logStacktrace) {
+        this.logStacktrace = logStacktrace;
+    }
+
+    public boolean isLogFieldname() {
+        return logFieldname;
+    }
+
+    public void setLogFieldname(boolean logFieldname) {
+        this.logFieldname = logFieldname;
+    }
+    
+    public void setDateFormat(String format) {
+        this.dateFormat = new SimpleDateFormat(format);
+    }
+
+    public String getLogLevel() {
+        return logLevel.getName();
+    }
+
+    public void setLogLevel(String logLevel) {
+        this.logLevel = Level.parse(logLevel);
+    }
+    
+}
