diff --git a/rt/core/src/main/java/org/apache/cxf/interceptor/AbstractFaultChainInitiatorObserver.java b/rt/core/src/main/java/org/apache/cxf/interceptor/AbstractFaultChainInitiatorObserver.java
index a222bc608c..a1b56c3e07 100644
--- a/rt/core/src/main/java/org/apache/cxf/interceptor/AbstractFaultChainInitiatorObserver.java
+++ b/rt/core/src/main/java/org/apache/cxf/interceptor/AbstractFaultChainInitiatorObserver.java
@@ -86,6 +86,11 @@ public abstract class AbstractFaultChainInitiatorObserver implements MessageObse
                 if (null != mode) {
                     faultMessage.put(FaultMode.class, mode);
                 }
+                //CXF-3981
+                if (message.get("javax.xml.ws.addressing.context.inbound") != null) {
+                    faultMessage.put("javax.xml.ws.addressing.context.inbound",
+                                     message.get("javax.xml.ws.addressing.context.inbound"));
+                }
                 exchange.setOutMessage(null);
                 exchange.setOutFaultMessage(faultMessage);
                 if (message.get(BindingFaultInfo.class) != null) {
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
index 5c5abfbd21..673cc1c262 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
@@ -464,10 +464,12 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
                         || (aicNonAnon2 != null && !aicNonAnon2.isEmpty());
                 
             if (hasAnonymous && hasNonAnon && !hasAnon) {
+                message.put(FaultMode.class, FaultMode.UNCHECKED_APPLICATION_FAULT);
                 throw new SoapFault("Found anonymous address but non-anonymous required",
                                     new QName(Names.WSA_NAMESPACE_NAME,
                                               "OnlyNonAnonymousAddressSupported"));
             } else if (!onlyAnonymous && !hasNonAnon && hasAnon) {
+                message.put(FaultMode.class, FaultMode.UNCHECKED_APPLICATION_FAULT);
                 throw new SoapFault("Found non-anonymous address but only anonymous supported",
                                     new QName(Names.WSA_NAMESPACE_NAME,
                                               "OnlyAnonymousAddressSupported"));
