diff --git a/rt/features/clustering/src/main/java/org/apache/cxf/clustering/AbstractStaticFailoverStrategy.java b/rt/features/clustering/src/main/java/org/apache/cxf/clustering/AbstractStaticFailoverStrategy.java
index 09755dd8f6..69002a3246 100644
--- a/rt/features/clustering/src/main/java/org/apache/cxf/clustering/AbstractStaticFailoverStrategy.java
+++ b/rt/features/clustering/src/main/java/org/apache/cxf/clustering/AbstractStaticFailoverStrategy.java
@@ -73,12 +73,14 @@ public abstract class AbstractStaticFailoverStrategy implements FailoverStrategy
      * Select one of the alternate addresses for a retried invocation.
      *
      * @param alternates a List of alternate addresses if available
-     * @return the selected address
+     * @return the selected address or {@code null} if no alternate address is available
      */
     public String selectAlternateAddress(List<String> alternates) {
         String selected = null;
         if (alternates != null && !alternates.isEmpty()) {
             selected = getNextAlternate(alternates);
+        }
+        if (selected != null) {
             Level level = getLogLevel();
             if (LOG.isLoggable(level)) {
                 LOG.log(level,
@@ -105,18 +107,20 @@ public abstract class AbstractStaticFailoverStrategy implements FailoverStrategy
      * Select one of the alternate endpoints for a retried invocation.
      *
      * @param alternates a List of alternate endpoints if available
-     * @return the selected endpoint
+     * @return the selected endpoint or {@code null} if no alternate endpoint is available
      */
     public Endpoint selectAlternateEndpoint(List<Endpoint> alternates) {
         Endpoint selected = null;
         if (alternates != null && !alternates.isEmpty()) {
             selected = getNextAlternate(alternates);
+        } 
+        if (selected != null) {
             Level level = getLogLevel();
             if (LOG.isLoggable(level)) {
                 LOG.log(level,
                         "FAILING_OVER_TO_ALTERNATE_ENDPOINT",
-                         new Object[] {selected.getEndpointInfo().getName(),
-                                       selected.getEndpointInfo().getAddress()});
+                        new Object[] {selected.getEndpointInfo().getName(),
+                                selected.getEndpointInfo().getAddress()});
             }
         } else {
             LOG.warning("NO_ALTERNATE_TARGETS_REMAIN");
diff --git a/rt/features/clustering/src/main/java/org/apache/cxf/clustering/RetryStrategy.java b/rt/features/clustering/src/main/java/org/apache/cxf/clustering/RetryStrategy.java
index 727bbdc025..e8e3ec235a 100644
--- a/rt/features/clustering/src/main/java/org/apache/cxf/clustering/RetryStrategy.java
+++ b/rt/features/clustering/src/main/java/org/apache/cxf/clustering/RetryStrategy.java
@@ -41,8 +41,13 @@ public class RetryStrategy extends SequentialStrategy {
         return getEndpoints(exchange, stillTheSameAddress());
     }
 
+    @Override
     protected <T> T getNextAlternate(List<T> alternates) {
-        return stillTheSameAddress() ? alternates.get(0) : alternates.remove(0);
+        // is the amount of retries for the first alternate already exceeded?
+        if (!stillTheSameAddress()) {
+            alternates.remove(0);
+        }
+        return alternates.isEmpty() ? null : alternates.get(0);
     }
 
     protected boolean stillTheSameAddress() {
diff --git a/rt/features/clustering/src/main/java/org/apache/cxf/clustering/SequentialStrategy.java b/rt/features/clustering/src/main/java/org/apache/cxf/clustering/SequentialStrategy.java
index 6ef077c276..4c2e685ac9 100644
--- a/rt/features/clustering/src/main/java/org/apache/cxf/clustering/SequentialStrategy.java
+++ b/rt/features/clustering/src/main/java/org/apache/cxf/clustering/SequentialStrategy.java
@@ -32,7 +32,7 @@ public class SequentialStrategy extends AbstractStaticFailoverStrategy {
      * Get next alternate endpoint.
      *
      * @param alternates non-empty List of alternate endpoints
-     * @return
+     * @return the next endpoint or {@code null} in case there are no more alternates
      */
     protected <T> T getNextAlternate(List<T> alternates) {
         return alternates.remove(0);
diff --git a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/failover/AbstractFailoverTest.java b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/failover/AbstractFailoverTest.java
index 164cef0697..9ee204f059 100644
--- a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/failover/AbstractFailoverTest.java
+++ b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/failover/AbstractFailoverTest.java
@@ -372,13 +372,15 @@ public abstract class AbstractFailoverTest extends AbstractBusClientServerTestBa
         protected <T> T getNextAlternate(List<T> alternates) {
             totalCount++;
             T next = super.getNextAlternate(alternates);
-            String address = (String)next;
-            Integer count = map.get(address);
-            if (count == null) {
-                count = 0;
+            if (next != null) {
+                String address = (String)next;
+                Integer count = map.get(address);
+                if (count == null) {
+                    count = 0;
+                }
+                count++;
+                map.put(address, count);
             }
-            count++;
-            map.put(address, count);
             return next;
         }
 
@@ -387,7 +389,7 @@ public abstract class AbstractFailoverTest extends AbstractBusClientServerTestBa
         }
 
         public int getAddressCount(String address) {
-            return map.get(address) - 1;
+            return map.get(address);
         }
     }
 }
