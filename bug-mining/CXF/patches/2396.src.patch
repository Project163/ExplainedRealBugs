diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/ProviderFactory.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/ProviderFactory.java
index e86f93b444..e38bdb4545 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/ProviderFactory.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/ProviderFactory.java
@@ -959,11 +959,11 @@ public abstract class ProviderFactory {
     protected static int compareClasses(Class<?> expectedCls, Object o1, Object o2) {
         Class<?> cl1 = ClassHelper.getRealClass(o1); 
         Class<?> cl2 = ClassHelper.getRealClass(o2);
-        
         Type[] types1 = getGenericInterfaces(cl1, expectedCls);
         Type[] types2 = getGenericInterfaces(cl2, expectedCls);
-        
-        if (types1.length == 0 && types2.length > 0) {
+        if (types1.length == 0 && types2.length == 0) {
+            return 0;
+        } else if (types1.length == 0 && types2.length > 0) {
             return 1;
         } else if (types1.length > 0 && types2.length == 0) {
             return -1;
@@ -989,9 +989,9 @@ public abstract class ProviderFactory {
             Type genericSuperType = cls.getGenericSuperclass();
             if (genericSuperType instanceof ParameterizedType) {       
                 Class<?> actualType = InjectionUtils.getActualType(genericSuperType);
-                if (expectedClass == actualType) {
+                if (actualType != null && actualType.isAssignableFrom(expectedClass)) {
                     return new Type[]{genericSuperType};
-                } else if (actualType != null && expectedClass.isAssignableFrom(actualType)) {
+                } else if (expectedClass.isAssignableFrom(actualType)) {
                     return new Type[]{};    
                 }
             }
diff --git a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/provider/ProviderFactoryTest.java b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/provider/ProviderFactoryTest.java
index b1428145da..1268538fdf 100644
--- a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/provider/ProviderFactoryTest.java
+++ b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/provider/ProviderFactoryTest.java
@@ -817,4 +817,80 @@ public class ProviderFactoryTest extends Assert {
             return Response.status(Status.BAD_REQUEST).entity(exception.getMessage()).build();
         }
     }
+    
+    @Test
+    public void testBadCustomExceptionMappersHierarchyWithGenerics() throws Exception {
+        ServerProviderFactory pf = ServerProviderFactory.getInstance();
+        BadExceptionMapperA badExceptionMapperA = new BadExceptionMapperA();
+        pf.registerUserProvider(badExceptionMapperA);
+        BadExceptionMapperB badExceptionMapperB = new BadExceptionMapperB();
+        pf.registerUserProvider(badExceptionMapperB);
+        Object mapperResponse1 = pf.createExceptionMapper(RuntimeExceptionA.class, new MessageImpl());
+        assertSame(badExceptionMapperA, mapperResponse1);
+        Object mapperResponse2 = pf.createExceptionMapper(RuntimeExceptionB.class, new MessageImpl());
+        assertSame(badExceptionMapperB, mapperResponse2);
+        Object mapperResponse3 = pf.createExceptionMapper(RuntimeExceptionAA.class, new MessageImpl());
+        assertSame(badExceptionMapperA, mapperResponse3);
+        Object mapperResponse4 = pf.createExceptionMapper(RuntimeExceptionBB.class, new MessageImpl());
+        assertSame(badExceptionMapperB, mapperResponse4);
+    }
+
+    @Test
+    public void testGoodExceptionMappersHierarchyWithGenerics() throws Exception {
+        ServerProviderFactory pf = ServerProviderFactory.getInstance();
+        GoodRuntimeExceptionAMapper runtimeExceptionAMapper = new GoodRuntimeExceptionAMapper();
+        pf.registerUserProvider(runtimeExceptionAMapper);
+        GoodRuntimeExceptionBMapper runtimeExceptionBMapper = new GoodRuntimeExceptionBMapper();
+        pf.registerUserProvider(runtimeExceptionBMapper);
+        Object mapperResponse1 = pf.createExceptionMapper(RuntimeExceptionA.class, new MessageImpl());
+        assertSame(runtimeExceptionAMapper, mapperResponse1);
+        Object mapperResponse2 = pf.createExceptionMapper(RuntimeExceptionB.class, new MessageImpl());
+        assertSame(runtimeExceptionBMapper, mapperResponse2);
+        Object mapperResponse3 = pf.createExceptionMapper(RuntimeExceptionAA.class, new MessageImpl());
+        assertSame(runtimeExceptionAMapper, mapperResponse3);
+        Object mapperResponse4 = pf.createExceptionMapper(RuntimeExceptionBB.class, new MessageImpl());
+        assertSame(runtimeExceptionBMapper, mapperResponse4);
+    }
+    private static class RuntimeExceptionA extends RuntimeException {
+        private static final long serialVersionUID = 1L;
+    }
+    private static class RuntimeExceptionAA extends RuntimeExceptionA {
+        private static final long serialVersionUID = 1L;
+    }
+    private static class RuntimeExceptionB extends RuntimeException {
+        private static final long serialVersionUID = 1L;
+    }
+    private static class RuntimeExceptionBB extends RuntimeExceptionB {
+        private static final long serialVersionUID = 1L;
+    }
+    private static class GoodRuntimeExceptionAMapper implements ExceptionMapper<RuntimeExceptionA> {
+
+        @Override
+        public Response toResponse(RuntimeExceptionA exception) {
+            return null;
+        }
+    }
+    private static class GoodRuntimeExceptionBMapper implements ExceptionMapper<RuntimeExceptionB> {
+
+        @Override
+        public Response toResponse(RuntimeExceptionB exception) {
+            return null;
+        }
+    }
+    public abstract static class BadParentExceptionMapper<T extends Throwable> implements ExceptionMapper<T> {
+    }
+    public static class BadExceptionMapperA extends BadParentExceptionMapper<RuntimeExceptionA> {
+
+        @Override
+        public Response toResponse(RuntimeExceptionA exception) {
+            return null;
+        }
+    }
+    public static class BadExceptionMapperB extends BadParentExceptionMapper<RuntimeExceptionB> {
+
+        @Override
+        public Response toResponse(RuntimeExceptionB exception) {
+            return null;
+        }
+    }
 }
