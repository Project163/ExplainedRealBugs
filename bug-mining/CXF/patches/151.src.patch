diff --git a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSConduit.java b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSConduit.java
index 6da522da4e..ff6d4ca24d 100644
--- a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSConduit.java
+++ b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSConduit.java
@@ -23,6 +23,7 @@ import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.logging.Level;
@@ -174,21 +175,26 @@ public class JMSConduit extends AbstractConduit implements JMSExchangeSender, Me
         Message inMessage = new MessageImpl();
         exchange.setInMessage(inMessage);
         LOG.log(Level.FINE, "client received reply: ", jmsMessage);
-        JMSUtils.populateIncomingContext(jmsMessage, inMessage, JMSConstants.JMS_CLIENT_RESPONSE_HEADERS);
-        byte[] response = JMSUtils.retrievePayload(jmsMessage);
-        LOG.log(Level.FINE, "The Response Message payload is : [" + response + "]");
-        inMessage.setContent(InputStream.class, new ByteArrayInputStream(response));
-
-        if (exchange.isSynchronous()) {
-            synchronized (exchange) {
-                exchange.put(CORRELATED, Boolean.TRUE);
-                exchange.notifyAll();
+        try {
+            JMSUtils.populateIncomingContext(jmsMessage, inMessage, JMSConstants.JMS_CLIENT_RESPONSE_HEADERS);
+        
+            byte[] response = JMSUtils.retrievePayload(jmsMessage, (String)inMessage.get(Message.ENCODING));
+            LOG.log(Level.FINE, "The Response Message payload is : [" + response + "]");
+            inMessage.setContent(InputStream.class, new ByteArrayInputStream(response));
+
+            if (exchange.isSynchronous()) {
+                synchronized (exchange) {
+                    exchange.put(CORRELATED, Boolean.TRUE);
+                    exchange.notifyAll();
+                }
             }
-        }
         
-        //REVISIT: put on a workqueue?
-        if (incomingObserver != null) {
-            incomingObserver.onMessage(exchange.getInMessage());
+            //REVISIT: put on a workqueue?
+            if (incomingObserver != null) {
+                incomingObserver.onMessage(exchange.getInMessage());
+            }
+        } catch (UnsupportedEncodingException ex) {
+            getLogger().log(Level.WARNING, "can't get the right encoding information " + ex);
         }
     }
 
diff --git a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSDestination.java b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSDestination.java
index 6547fbbdc2..6c2ac60153 100644
--- a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSDestination.java
+++ b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSDestination.java
@@ -23,6 +23,7 @@ import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
 import java.util.Calendar;
 import java.util.GregorianCalendar;
 import java.util.List;
@@ -158,14 +159,13 @@ public class JMSDestination extends AbstractMultiplexDestination implements Mess
     public void onMessage(javax.jms.Message message) {
         try {
             getLogger().log(Level.FINE, "server received request: ", message);
-
-            byte[] request = JMSUtils.retrievePayload(message);
+             // Build CXF message from JMS message
+            MessageImpl inMessage = new MessageImpl();            
+            JMSUtils.populateIncomingContext(message, inMessage, JMSConstants.JMS_SERVER_REQUEST_HEADERS);
+            
+            byte[] request = JMSUtils.retrievePayload(message, (String)inMessage.get(Message.ENCODING));
             getLogger().log(Level.FINE, "The Request Message is [ " + request + "]");
-
-            // Build CXF message from JMS message
-            MessageImpl inMessage = new MessageImpl();
             inMessage.setContent(InputStream.class, new ByteArrayInputStream(request));
-            JMSUtils.populateIncomingContext(message, inMessage, JMSConstants.JMS_SERVER_REQUEST_HEADERS);
             inMessage.put(JMSConstants.JMS_SERVER_RESPONSE_HEADERS, new JMSMessageHeadersType());
             inMessage.put(JMSConstants.JMS_REQUEST_MESSAGE, message);
             inMessage.setDestination(this);
@@ -174,6 +174,8 @@ public class JMSDestination extends AbstractMultiplexDestination implements Mess
 
             // handle the incoming message
             incomingObserver.onMessage(inMessage);
+        } catch (UnsupportedEncodingException ex) {
+            getLogger().log(Level.WARNING, "can't get the right encoding information. " + ex);
         } finally {
             BusFactory.setThreadDefaultBus(null);
         }
diff --git a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSUtils.java b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSUtils.java
index 1fd78687cc..e51daaf296 100644
--- a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSUtils.java
+++ b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSUtils.java
@@ -19,6 +19,7 @@
 
 package org.apache.cxf.transport.jms;
 
+import java.io.UnsupportedEncodingException;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
@@ -28,6 +29,7 @@ import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.logging.Level;
 import java.util.logging.Logger;
 
 import javax.jms.BytesMessage;
@@ -39,6 +41,7 @@ import javax.jms.Session;
 
 import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.helpers.CastUtils;
+import org.apache.cxf.helpers.HttpHeaderHelper;
 import org.springframework.jms.support.JmsUtils;
 import org.springframework.jms.support.converter.MessageConversionException;
 import org.springframework.jms.support.converter.SimpleMessageConverter102;
@@ -97,9 +100,12 @@ public final class JMSUtils {
      * Extract the payload of an incoming message.
      * 
      * @param message the incoming message
+     * @param encoding the message encoding
      * @return the message payload as byte[]
+     * @throws UnsupportedEncodingException 
      */
-    public static byte[] retrievePayload(Message message) {
+    public static byte[] retrievePayload(Message message, String encoding) 
+        throws UnsupportedEncodingException {
         Object converted;
         try {
             converted = new SimpleMessageConverter102().fromMessage(message);
@@ -109,7 +115,12 @@ public final class JMSUtils {
             throw JmsUtils.convertJmsAccessException(e);
         }
         if (converted instanceof String) {
-            return ((String)converted).getBytes(); // TODO encoding
+            if (encoding != null) {
+                return ((String)converted).getBytes(encoding); 
+            } else { 
+                // Using the UTF-8 encoding as default
+                return ((String)converted).getBytes("UTF-8");
+            }
         } else if (converted instanceof byte[]) {
             return (byte[])converted;
         } else {
@@ -118,7 +129,8 @@ public final class JMSUtils {
     }
 
     public static void populateIncomingContext(javax.jms.Message message,
-                                               org.apache.cxf.message.Message inMessage, String headerType) {
+                                               org.apache.cxf.message.Message inMessage, String headerType) 
+        throws UnsupportedEncodingException {
         try {
             JMSMessageHeadersType headers = null;
             headers = (JMSMessageHeadersType)inMessage.get(headerType);
@@ -150,13 +162,10 @@ public final class JMSUtils {
                 if (name.equals(org.apache.cxf.message.Message.CONTENT_TYPE)
                     || name.equals(JMSConstants.JMS_CONTENT_TYPE) && val != null) {
                     inMessage.put(org.apache.cxf.message.Message.CONTENT_TYPE, val);
+                    // set the message encoding
+                    inMessage.put(org.apache.cxf.message.Message.ENCODING, getEncoding(val));
                 }
-
-                protHeaders.put(name, Collections.singletonList(val));
-                if (name.equals(org.apache.cxf.message.Message.CONTENT_TYPE)
-                    || name.equals(JMSConstants.JMS_CONTENT_TYPE) && val != null) {
-                    inMessage.put(org.apache.cxf.message.Message.CONTENT_TYPE, val);
-                }
+                
             }
             inMessage.put(org.apache.cxf.message.Message.PROTOCOL_HEADERS, protHeaders);
         } catch (JMSException ex) {
@@ -164,6 +173,29 @@ public final class JMSUtils {
         }
     }
 
+    static String getEncoding(String ct) throws UnsupportedEncodingException {
+        String contentType = ct.toLowerCase();
+        String enc = null;
+        
+        String[] tokens = contentType.split(";");
+        for (String token : tokens) {
+            int index = token.indexOf("charset=");
+            if (index >= 0) {
+                enc = token.substring(index + 8);                
+            }            
+        }
+        
+        String normalizedEncoding = HttpHeaderHelper.mapCharset(enc);
+        if (normalizedEncoding == null) {
+            String m = new org.apache.cxf.common.i18n.Message("INVALID_ENCODING_MSG",
+                                                              LOG, enc).toString();
+            LOG.log(Level.WARNING, m);
+            throw new UnsupportedEncodingException(m);   
+        }
+        
+        return normalizedEncoding;
+    }
+
     protected static void addProtocolHeaders(Message message, Map<String, List<String>> headers)
         throws JMSException {
         if (headers == null) {
@@ -191,7 +223,18 @@ public final class JMSUtils {
     }
 
     public static void addContentTypeToProtocolHeader(org.apache.cxf.message.Message message) {
-        String contentType = (String)message.get(org.apache.cxf.message.Message.CONTENT_TYPE);
+        String contentType = (String)message.get(org.apache.cxf.message.Message.CONTENT_TYPE);        
+        String enc = (String) message.get(org.apache.cxf.message.Message.ENCODING);
+        // add the encoding information
+        if (null != contentType) {
+            if (enc != null && contentType.indexOf("charset=") == -1) {
+                contentType = contentType + "; charset=" + enc;
+            }
+        } else if (enc != null) {
+            contentType = "text/xml; charset=" + enc;
+        } else {
+            contentType = "text/xml";
+        }
 
         // Retrieve or create protocol headers
         Map<String, List<String>> headers = CastUtils.cast((Map<?, ?>)message
diff --git a/rt/transports/jms/src/test/java/org/apache/cxf/transport/jms/JMSDestinationTest.java b/rt/transports/jms/src/test/java/org/apache/cxf/transport/jms/JMSDestinationTest.java
index 4033050f39..35b08f963f 100644
--- a/rt/transports/jms/src/test/java/org/apache/cxf/transport/jms/JMSDestinationTest.java
+++ b/rt/transports/jms/src/test/java/org/apache/cxf/transport/jms/JMSDestinationTest.java
@@ -198,6 +198,7 @@ public class JMSDestinationTest extends AbstractJMSTester {
         header.setJMSPriority(1);
         header.setTimeToLive(1000);
         outMessage.put(JMSConstants.JMS_CLIENT_REQUEST_HEADERS, header);
+        outMessage.put(Message.ENCODING, "US-ASCII");
     }
 
     private void verifyReceivedMessage(Message inMessage) {
@@ -210,12 +211,16 @@ public class JMSDestinationTest extends AbstractJMSTester {
             ex.printStackTrace();
         }
         String reponse = IOUtils.newStringFromBytes(bytes);
-        assertEquals("The reponse date should be equals", reponse, "HelloWorld");
+        assertEquals("The reponse date should be equal", reponse, "HelloWorld");
     }
 
     private void verifyRequestResponseHeaders(Message inMessage, Message outMessage) {
         JMSMessageHeadersType outHeader = (JMSMessageHeadersType)outMessage
             .get(JMSConstants.JMS_CLIENT_REQUEST_HEADERS);
+        String inEncoding = (String) inMessage.get(Message.ENCODING);
+        String outEncoding = (String) outMessage.get(Message.ENCODING);
+        
+        assertEquals("The message encoding should be equal", inEncoding, outEncoding);
 
         JMSMessageHeadersType inHeader = (JMSMessageHeadersType)inMessage
             .get(JMSConstants.JMS_CLIENT_RESPONSE_HEADERS);
@@ -336,6 +341,8 @@ public class JMSDestinationTest extends AbstractJMSTester {
                     backConduit = destination.getBackChannel(m, null, null);
                     // wait for the message to be got from the conduit
                     Message replyMessage = new MessageImpl();
+                    // copy the message encoding
+                    replyMessage.put(Message.ENCODING, m.get(Message.ENCODING));
                     sendoutMessage(backConduit, replyMessage, true);
                 } catch (Exception e) {
                     throw new RuntimeException(e);
diff --git a/rt/transports/jms/src/test/java/org/apache/cxf/transport/jms/JMSUtilsTest.java b/rt/transports/jms/src/test/java/org/apache/cxf/transport/jms/JMSUtilsTest.java
index 7e87b181a5..9d96bb4272 100644
--- a/rt/transports/jms/src/test/java/org/apache/cxf/transport/jms/JMSUtilsTest.java
+++ b/rt/transports/jms/src/test/java/org/apache/cxf/transport/jms/JMSUtilsTest.java
@@ -19,6 +19,8 @@
 
 package org.apache.cxf.transport.jms;
 
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
 import java.util.Properties;
 
 import javax.naming.Context;
@@ -46,5 +48,22 @@ public class JMSUtilsTest extends Assert {
         assertTrue("Environment should not be empty", env.size() > 0);
         assertTrue("Environemnt should contain NamingBatchSize property", env.get(Context.BATCHSIZE) != null);
     }
+    
+    @Test
+    public void testGetEncoding() throws IOException {                
+        assertEquals("Get the wrong encoding", JMSUtils.getEncoding("text/xml; charset=utf-8"), "UTF-8");
+        assertEquals("Get the wrong encoding", JMSUtils.getEncoding("text/xml"), "UTF-8");
+        assertEquals("Get the wrong encoding", JMSUtils.getEncoding("text/xml; charset=GBK"), "GBK");
+        try {
+            JMSUtils.getEncoding("text/xml; charset=asci");
+            fail("Expect the exception here");
+        } catch (Exception ex) {
+            assertTrue("we should get the UnsupportedEncodingException here",
+                       ex instanceof UnsupportedEncodingException);
+        }
+        
+        
+        
+    }
 
 }
