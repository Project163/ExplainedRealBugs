diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java
index 423b562424..27ef1e366e 100644
--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java
+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java
@@ -34,13 +34,11 @@ import java.util.HashSet;
 import java.util.Set;
 
 import javax.xml.bind.annotation.XmlAccessType;
-import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlElement;
 import javax.xml.bind.annotation.XmlRootElement;
 import javax.xml.bind.annotation.XmlSeeAlso;
 import javax.xml.bind.annotation.XmlTransient;
 import javax.xml.bind.annotation.XmlType;
-import javax.xml.bind.annotation.adapters.XmlAdapter;
 import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
 import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
 
@@ -180,7 +178,7 @@ class JAXBContextInitializer extends ServiceModelVisitor {
         if (anns != null) {
             for (Annotation a : anns) {
                 if (XmlJavaTypeAdapter.class.isAssignableFrom(a.annotationType())) {
-                    Type t = getTypeFromXmlAdapter((XmlJavaTypeAdapter)a);
+                    Type t = Utils.getTypeFromXmlAdapter((XmlJavaTypeAdapter)a);
                     if (t != null) {
                         addType(t);
                     }
@@ -189,7 +187,7 @@ class JAXBContextInitializer extends ServiceModelVisitor {
         }
         XmlJavaTypeAdapter xjta = clazz.getAnnotation(XmlJavaTypeAdapter.class);
         if (xjta != null) {
-            Type t = getTypeFromXmlAdapter(xjta);
+            Type t = Utils.getTypeFromXmlAdapter(xjta);
             if (t != null) {
                 addType(t);
             }
@@ -201,7 +199,7 @@ class JAXBContextInitializer extends ServiceModelVisitor {
                     globalAdapters.add(a.type());
                 }
                 for (XmlJavaTypeAdapter a: adapt.value()) {
-                    Type t = getTypeFromXmlAdapter(a);
+                    Type t = Utils.getTypeFromXmlAdapter(a);
                     if (t != null) {
                         addType(t);
                     }
@@ -294,7 +292,7 @@ class JAXBContextInitializer extends ServiceModelVisitor {
                     //has an adapter.   We need to inspect the adapter and then
                     //return as the adapter will handle the superclass
                     //and interfaces and such
-                    Type t = getTypeFromXmlAdapter(xjta);
+                    Type t = Utils.getTypeFromXmlAdapter(xjta);
                     if (t != null) {
                         addType(t);
                     }
@@ -314,65 +312,6 @@ class JAXBContextInitializer extends ServiceModelVisitor {
         }
     }
     
-    static XmlJavaTypeAdapter getFieldXJTA(final Field f) {
-        XmlJavaTypeAdapter adapter = f.getAnnotation(XmlJavaTypeAdapter.class);
-        if (adapter == null) {
-            adapter = f.getType().getAnnotation(XmlJavaTypeAdapter.class);
-        }
-        if (adapter == null) {
-            XmlJavaTypeAdapters adapters = f.getDeclaringClass().getPackage().getAnnotation(XmlJavaTypeAdapters.class);
-            if (adapters != null) {
-                for (XmlJavaTypeAdapter candidate : adapters.value()) {
-                    if (candidate != null && candidate.type().equals(f.getType())) {
-                        adapter = candidate;
-                        break;
-                    }
-                }
-            }
-        }
-        return adapter;
-    }
-
-    static XmlJavaTypeAdapter getMethodXJTA(final Method m) {
-        XmlJavaTypeAdapter adapter = m.getAnnotation(XmlJavaTypeAdapter.class);
-        if (adapter == null) {
-            adapter = m.getReturnType().getAnnotation(XmlJavaTypeAdapter.class);
-        }
-        if (adapter == null) {
-            XmlJavaTypeAdapters adapters = m.getDeclaringClass().getPackage().getAnnotation(XmlJavaTypeAdapters.class);
-            if (adapters != null) {
-                for (XmlJavaTypeAdapter candidate : adapters.value()) {
-                    if (candidate != null && candidate.type().equals(m.getGenericReturnType())) {
-                        adapter = candidate;
-                        break;
-                    }
-                }
-            }
-        }
-        return adapter;
-    }
-
-    static Class<?> getTypeFromXmlAdapter(XmlJavaTypeAdapter xjta) {
-        if (xjta != null) {
-            Class<?> c2 = xjta.value();
-            Type sp = c2.getGenericSuperclass();
-            while (!XmlAdapter.class.equals(c2) && c2 != null) {
-                sp = c2.getGenericSuperclass();
-                c2 = c2.getSuperclass();
-            }
-            if (sp instanceof ParameterizedType) {
-                return (Class<?>)((ParameterizedType)sp).getActualTypeArguments()[0];
-            }
-        }
-        return null;
-    }
-
-    @SuppressWarnings("rawtypes") 
-    static XmlAdapter getXmlAdapter(XmlJavaTypeAdapter adapterAnnotation)
-        throws InstantiationException, IllegalAccessException {
-        return adapterAnnotation != null ? adapterAnnotation.value().newInstance() : null;
-    }
-
     private void walkReferences(Class<?> cls) {
         if (cls == null) {
             return;
@@ -387,11 +326,7 @@ class JAXBContextInitializer extends ServiceModelVisitor {
         //We'll grab the public field/method types and then add the ObjectFactory stuff
         //as well as look for jaxb.index files in those packages.
 
-        XmlAccessorType accessorType = cls.getAnnotation(XmlAccessorType.class);
-        if (accessorType == null && cls.getPackage() != null) {
-            accessorType = cls.getPackage().getAnnotation(XmlAccessorType.class);
-        }
-        XmlAccessType accessType = accessorType != null ? accessorType.value() : XmlAccessType.PUBLIC_MEMBER;
+        XmlAccessType accessType = Utils.getXmlAccessType(cls);
 
         if (accessType != XmlAccessType.PROPERTY) {   // only look for fields if we are instructed to
             //fields are accessible even if not public, must look at the declared fields
@@ -487,7 +422,7 @@ class JAXBContextInitializer extends ServiceModelVisitor {
      * @param annotations the array of annotations from the class member
      * @return true if JAXB annotations are present, false otherwise
      */
-    private static boolean checkJaxbAnnotation(Annotation[] annotations) {
+    static boolean checkJaxbAnnotation(Annotation[] annotations) {
         // must check if there are any jaxb annotations
         Package jaxbAnnotationsPackage = XmlElement.class.getPackage();
         for (Annotation annotation : annotations) {
diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBEncoderDecoder.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBEncoderDecoder.java
index da0439f90b..e32e26b08a 100644
--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBEncoderDecoder.java
+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBEncoderDecoder.java
@@ -45,17 +45,13 @@ import java.util.Set;
 import java.util.TreeMap;
 import java.util.logging.Logger;
 
-
 import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Marshaller;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.bind.annotation.XmlAccessType;
-import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
 import javax.xml.bind.annotation.adapters.HexBinaryAdapter;
-import javax.xml.bind.annotation.adapters.XmlAdapter;
-import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
 import javax.xml.bind.attachment.AttachmentMarshaller;
 import javax.xml.bind.attachment.AttachmentUnmarshaller;
 import javax.xml.namespace.NamespaceContext;
@@ -74,7 +70,6 @@ import org.w3c.dom.Attr;
 import org.w3c.dom.Element;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
-
 import org.apache.cxf.common.i18n.Message;
 import org.apache.cxf.common.jaxb.JAXBUtils;
 import org.apache.cxf.common.logging.LogUtils;
@@ -349,12 +344,7 @@ public final class JAXBEncoderDecoder {
         try {
             writer.writeStartElement("ns1", qn.getLocalPart(), qn.getNamespaceURI());
             Class<?> cls = part.getTypeClass();
-            XmlAccessorType accessorType = cls.getAnnotation(XmlAccessorType.class);
-            if (accessorType == null && cls.getPackage() != null) {
-                accessorType = cls.getPackage().getAnnotation(XmlAccessorType.class);
-            }
-            XmlAccessType accessType = accessorType != null
-                ? accessorType.value() : XmlAccessType.PUBLIC_MEMBER;
+            XmlAccessType accessType = Utils.getXmlAccessType(cls);
             String namespace = part.getElementQName().getNamespaceURI();
             
             SchemaInfo sch = part.getMessageInfo().getOperation().getInterface()
@@ -366,33 +356,29 @@ public final class JAXBEncoderDecoder {
             } else {
                 LOG.warning("Schema associated with " + namespace + " is null");
             }
-            for (Field f : ReflectionUtil.getDeclaredFields(cls)) {
-                if (JAXBContextInitializer.isFieldAccepted(f, accessType)) {
-                    XmlAttribute at = f.getAnnotation(XmlAttribute.class);
-                    if (at == null) {
-                        QName fname = new QName(namespace, f.getName());
-                        ReflectionUtil.setAccessible(f);
-                        if (JAXBSchemaInitializer.isArray(f.getGenericType())) {
-                            writeArrayObject(marshaller, writer, fname, f.get(elValue));
-                        } else {
-                            Object o = getFieldValue(f, elValue); 
-                            writeObject(marshaller, writer, newJAXBElement(fname, String.class, o));
-                        }
+            for (Field f : Utils.getFields(cls, accessType)) {
+                XmlAttribute at = f.getAnnotation(XmlAttribute.class);
+                if (at == null) {
+                    QName fname = new QName(namespace, f.getName());
+                    ReflectionUtil.setAccessible(f);
+                    if (JAXBSchemaInitializer.isArray(f.getGenericType())) {
+                        writeArrayObject(marshaller, writer, fname, f.get(elValue));
+                    } else {
+                        Object o = Utils.getFieldValue(f, elValue); 
+                        writeObject(marshaller, writer, newJAXBElement(fname, String.class, o));
                     }
                 }
             }
-            for (Method m : cls.getMethods()) {
-                if (JAXBContextInitializer.isMethodAccepted(m, accessType)) {
-                    int idx = m.getName().startsWith("get") ? 3 : 2;
-                    String name = m.getName().substring(idx);
-                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);
-                    QName mname = new QName(namespace, name);
-                    if (JAXBSchemaInitializer.isArray(m.getGenericReturnType())) {
-                        writeArrayObject(marshaller, writer, mname, m.invoke(elValue));
-                    } else {
-                        Object o = getMethodValue(m, elValue); 
-                        writeObject(marshaller, writer, newJAXBElement(mname, String.class, o));
-                    }
+            for (Method m : Utils.getGetters(cls, accessType)) {
+                int idx = m.getName().startsWith("get") ? 3 : 2;
+                String name = m.getName().substring(idx);
+                name = Character.toLowerCase(name.charAt(0)) + name.substring(1);
+                QName mname = new QName(namespace, name);
+                if (JAXBSchemaInitializer.isArray(m.getGenericReturnType())) {
+                    writeArrayObject(marshaller, writer, mname, m.invoke(elValue));
+                } else {
+                    Object o = Utils.getMethodValue(m, elValue); 
+                    writeObject(marshaller, writer, newJAXBElement(mname, String.class, o));
                 }
             }
 
@@ -404,7 +390,7 @@ public final class JAXBEncoderDecoder {
             StaxUtils.close(writer);
         }
     }
-
+    
     private static void writeArrayObject(Marshaller marshaller, 
                                          Object source,
                                          QName mname,
@@ -465,61 +451,44 @@ public final class JAXBEncoderDecoder {
                 obj = cons.newInstance(new Object[1]);
             }
 
-            XmlAccessorType accessorType = cls.getAnnotation(XmlAccessorType.class);
-            if (accessorType == null && cls.getPackage() != null) {
-                accessorType = cls.getPackage().getAnnotation(XmlAccessorType.class);
-            }
-            XmlAccessType accessType = accessorType != null
-                ? accessorType.value() : XmlAccessType.PUBLIC_MEMBER;
+            XmlAccessType accessType = Utils.getXmlAccessType(cls);
             reader.nextTag();
             while (reader.getEventType() == XMLStreamReader.START_ELEMENT) {
                 QName q = reader.getName();
-                try {
-                    Field f = ReflectionUtil.getDeclaredField(cls, q.getLocalPart());
-                    if (f == null) {
-                        f = cls.getField(q.getLocalPart());
-                    }
+                String fieldName = q.getLocalPart();
+                Field f = Utils.getField(cls, accessType, fieldName);
+                if (f != null) {
                     Type type = f.getGenericType();
-                    if (JAXBContextInitializer.isFieldAccepted(f, accessType)) {
-                        ReflectionUtil.setAccessible(f);
-                        if (JAXBSchemaInitializer.isArray(type)) {
-                            Class<?> compType = JAXBSchemaInitializer
-                                .getArrayComponentType(type);
-                            List<Object> ret = unmarshallArray(u, reader,
-                                                               q,
-                                                               compType,
-                                                               createList(type));
-                            Object o = ret;
-                            if (!isList(type)) {
-                                if (compType.isPrimitive()) {
-                                    o = java.lang.reflect.Array.newInstance(compType, ret.size());
-                                    for (int x = 0; x < ret.size(); x++) {
-                                        Array.set(o, x, ret.get(x));
-                                    }
-                                } else {
-                                    o = ret.toArray((Object[])Array.newInstance(compType, ret.size()));
+                    f.setAccessible(true);
+                    if (JAXBSchemaInitializer.isArray(type)) {
+                        Class<?> compType = JAXBSchemaInitializer.getArrayComponentType(type);
+                        List<Object> ret = unmarshallArray(u, reader, q, compType, createList(type));
+                        Object o = ret;
+                        if (!isList(type)) {
+                            if (compType.isPrimitive()) {
+                                o = java.lang.reflect.Array.newInstance(compType, ret.size());
+                                for (int x = 0; x < ret.size(); x++) {
+                                    Array.set(o, x, ret.get(x));
                                 }
+                            } else {
+                                o = ret.toArray((Object[]) Array.newInstance(compType, ret.size()));
                             }
-
-                            f.set(obj, o);
-                        } else {
-                            Object o = getElementValue(u.unmarshal(reader, getFieldType(f)));
-                            setFieldValue(f, obj, o);
                         }
+
+                        f.set(obj, o);
                     } else {
-                        throw new NoSuchFieldException("No accessible field " + q.getLocalPart());
+                        Object o = getElementValue(u.unmarshal(reader, Utils.getFieldType(f)));
+                        Utils.setFieldValue(f, obj, o);
                     }
-                } catch (NoSuchFieldException ex) {
+                } else {
                     String s = Character.toUpperCase(q.getLocalPart().charAt(0))
                                + q.getLocalPart().substring(1);
-                    Method m = null;
-                    try {
-                        m = cls.getMethod("get" + s);
-                    } catch (NoSuchMethodException mex) {
-                        m = cls.getMethod("is" + s);
+                    Method m = Utils.getMethod(cls, accessType, "get" + s);
+                    if (m == null) {
+                        m = Utils.getMethod(cls, accessType, "is" + s);
                     }
                     Type type = m.getGenericReturnType();
-                    Method m2 = cls.getMethod("set" + s, m.getReturnType());
+                    Method m2 = Utils.getMethod(cls, accessType, "set" + s, m.getReturnType());
                     if (JAXBSchemaInitializer.isArray(type)) {
                         Class<?> compType = JAXBSchemaInitializer
                             .getArrayComponentType(type);
@@ -541,8 +510,8 @@ public final class JAXBEncoderDecoder {
 
                         m2.invoke(obj, o);
                     } else {
-                        Object o = getElementValue(u.unmarshal(reader, getMethodReturnType(m)));
-                        setMethodValue(m, m2, obj, o);
+                        Object o = getElementValue(u.unmarshal(reader, Utils.getMethodReturnType(m)));
+                        Utils.setMethodValue(m, m2, obj, o);
                     }
                 }
             }
@@ -552,46 +521,6 @@ public final class JAXBEncoderDecoder {
         }
     }
 
-    private static Class<?> getFieldType(final Field f) {
-        XmlJavaTypeAdapter adapter = JAXBContextInitializer.getFieldXJTA(f);
-        Class<?> adapterType = JAXBContextInitializer.getTypeFromXmlAdapter(adapter);
-        return adapterType != null ? adapterType : f.getType();
-    }
-
-    private static Class<?> getMethodReturnType(final Method m) {
-        XmlJavaTypeAdapter adapter = JAXBContextInitializer.getMethodXJTA(m);
-        Class<?> adapterType = JAXBContextInitializer.getTypeFromXmlAdapter(adapter);
-        return adapterType != null ? adapterType : m.getReturnType(); 
-    }
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    private static Object getFieldValue(Field f, Object target) throws Exception {
-        XmlJavaTypeAdapter adapterAnnotation = JAXBContextInitializer.getFieldXJTA(f);
-        XmlAdapter adapter = JAXBContextInitializer.getXmlAdapter(adapterAnnotation);
-        return adapter != null ? adapter.marshal(f.get(target)) : f.get(target); 
-    }
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    private static Object getMethodValue(Method m, Object target) throws Exception {
-        XmlJavaTypeAdapter adapterAnnotation = JAXBContextInitializer.getMethodXJTA(m);
-        XmlAdapter adapter = JAXBContextInitializer.getXmlAdapter(adapterAnnotation);
-        return adapter != null ? adapter.marshal(m.invoke(target)) : m.invoke(target); 
-    }
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    private static void setFieldValue(Field f, Object target, Object value) throws Exception {
-        XmlJavaTypeAdapter xjta = JAXBContextInitializer.getFieldXJTA(f);
-        XmlAdapter adapter = JAXBContextInitializer.getXmlAdapter(xjta);
-        f.set(target, adapter != null ? adapter.unmarshal(value) : value);
-    }
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    private static void setMethodValue(Method getter, Method setter, Object target, Object value) throws Exception {
-        XmlJavaTypeAdapter xjta = JAXBContextInitializer.getMethodXJTA(getter);
-        XmlAdapter adapter = JAXBContextInitializer.getXmlAdapter(xjta);
-        setter.invoke(target, adapter != null ? adapter.unmarshal(value) : value);
-    }
-
     private static void writeObject(Marshaller u, Object source, Object mObj) throws Fault, JAXBException {
         if (source instanceof XMLStreamWriter) {
             u.marshal(mObj, (XMLStreamWriter)source);
diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBSchemaInitializer.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBSchemaInitializer.java
index 038ab64508..4fdd953d46 100644
--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBSchemaInitializer.java
+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBSchemaInitializer.java
@@ -32,7 +32,6 @@ import java.util.logging.Logger;
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.annotation.XmlAccessType;
-import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlList;
 import javax.xml.bind.annotation.XmlType;
 import javax.xml.bind.annotation.adapters.XmlAdapter;
@@ -516,35 +515,25 @@ class JAXBSchemaInitializer extends ServiceModelVisitor {
         XmlSchemaSequence seq = new XmlSchemaSequence();
         ct.setParticle(seq);
         String namespace = part.getElementQName().getNamespaceURI();
-
-        XmlAccessorType accessorType = cls.getAnnotation(XmlAccessorType.class);
-        if (accessorType == null && cls.getPackage() != null) {
-            accessorType = cls.getPackage().getAnnotation(XmlAccessorType.class);
-        }
-        XmlAccessType accessType = accessorType != null ? accessorType.value() : XmlAccessType.PUBLIC_MEMBER;
-
-
-        for (Field f : cls.getDeclaredFields()) {
-            if (JAXBContextInitializer.isFieldAccepted(f, accessType)) {
-                //map field
-                Type type = getFieldType(f);
-                JAXBBeanInfo beanInfo = getBeanInfo(type);
-                if (beanInfo != null) {
-                    addElement(schema, seq, beanInfo, new QName(namespace, f.getName()), isArray(type));
-                }
+        XmlAccessType accessType = Utils.getXmlAccessType(cls);
+
+        for (Field f : Utils.getFields(cls, accessType)) {
+            //map field
+            Type type = Utils.getFieldType(f);
+            JAXBBeanInfo beanInfo = getBeanInfo(type);
+            if (beanInfo != null) {
+                addElement(schema, seq, beanInfo, new QName(namespace, f.getName()), isArray(type));
             }
         }
-        for (Method m : cls.getMethods()) {
-            if (JAXBContextInitializer.isMethodAccepted(m, accessType)) {
-                //map method
-                Type type = getMethodReturnType(m);
-                JAXBBeanInfo beanInfo = getBeanInfo(type);
-                if (beanInfo != null) {
-                    int idx = m.getName().startsWith("get") ? 3 : 2;
-                    String name = m.getName().substring(idx);
-                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);
-                    addElement(schema, seq, beanInfo, new QName(namespace, name), isArray(type));
-                }
+        for (Method m : Utils.getGetters(cls, accessType)) {
+            //map method
+            Type type = Utils.getMethodReturnType(m);
+            JAXBBeanInfo beanInfo = getBeanInfo(type);
+            if (beanInfo != null) {
+                int idx = m.getName().startsWith("get") ? 3 : 2;
+                String name = m.getName().substring(idx);
+                name = Character.toLowerCase(name.charAt(0)) + name.substring(1);
+                addElement(schema, seq, beanInfo, new QName(namespace, name), isArray(type));
             }
         }
         // Create element in xsd:sequence for Exception.class
@@ -561,18 +550,6 @@ class JAXBSchemaInitializer extends ServiceModelVisitor {
         part.setProperty(JAXBDataBinding.class.getName() + ".CUSTOM_EXCEPTION", Boolean.TRUE);
     }
     
-    private static Type getFieldType(final Field f) {
-        XmlJavaTypeAdapter adapter = JAXBContextInitializer.getFieldXJTA(f);
-        Class<?> adapterType = JAXBContextInitializer.getTypeFromXmlAdapter(adapter);
-        return adapterType != null ? adapterType : f.getGenericType();
-    }
-
-    private static Type getMethodReturnType(final Method m) {
-        XmlJavaTypeAdapter adapter = JAXBContextInitializer.getMethodXJTA(m);
-        Class<?> adapterType = JAXBContextInitializer.getTypeFromXmlAdapter(adapter);
-        return adapterType != null ? adapterType : m.getGenericReturnType(); 
-    }
-
     static boolean isArray(Type cls) {
         if (cls instanceof Class) {
             return ((Class<?>)cls).isArray();
diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/Utils.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/Utils.java
new file mode 100644
index 0000000000..c28cfb3411
--- /dev/null
+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/Utils.java
@@ -0,0 +1,312 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.jaxb;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
+
+/**
+ * JAXB reflection utilities.
+ */
+final class Utils {
+    private Utils() {
+    }
+    
+    static XmlAccessType getXmlAccessType(Class<?> cls) {
+        XmlAccessorType accessorType = cls.getAnnotation(XmlAccessorType.class);
+        if (accessorType == null && cls.getPackage() != null) {
+            accessorType = cls.getPackage().getAnnotation(XmlAccessorType.class);
+        }
+        return accessorType != null
+            ? accessorType.value() : XmlAccessType.PUBLIC_MEMBER;
+    }
+
+    static Collection<Field> getFields(Class<?> cls, XmlAccessType accessType) {
+        if (cls.isAnnotationPresent(XmlTransient.class)) {
+            // When placed on a class, it indicates that the class shouldn't be mapped
+            // to XML by itself. Properties on such class will be mapped to XML along
+            // with its derived classes, as if the class is inlined.
+            return Collections.emptySet();
+        } else {
+            return getFieldsInternal(cls, accessType);
+        }
+    }
+
+    private static Collection<Field> getFieldsInternal(Class<?> cls, XmlAccessType accessType) {
+        Set<Field> fields = new HashSet<Field>();
+        Class<?> superClass = cls.getSuperclass();
+        if (superClass != null && superClass.isAnnotationPresent(XmlTransient.class)) {
+            // only if superClass is @XmlTransient annotated it will be processed recursively
+            fields.addAll(getFieldsInternal(superClass, accessType));
+        }
+        // process current class
+        for (Field field : cls.getDeclaredFields()) {
+            if (JAXBContextInitializer.isFieldAccepted(field, accessType)) {
+                fields.add(field);
+            }
+        }
+        return fields;
+    }
+
+    private static Collection<Method> getMethods(Class<?> cls, XmlAccessType accessType, boolean acceptSetters) {
+        if (cls.isAnnotationPresent(XmlTransient.class)) {
+            // When placed on a class, it indicates that the class shouldn't be mapped
+            // to XML by itself. Properties on such class will be mapped to XML along
+            // with its derived classes, as if the class is inlined.
+            return Collections.emptySet();
+        } else {
+            return getMethodsInternal(cls, accessType, acceptSetters);
+        }
+    }
+    
+    private static Collection<Method> getMethodsInternal(Class<?> cls, XmlAccessType accessType,
+            boolean acceptSetters) {
+        Set<Method> methods = new HashSet<Method>();
+        Class<?> superClass = cls.getSuperclass();
+        if (superClass != null && superClass.isAnnotationPresent(XmlTransient.class)) {
+            // only if superClass is @XmlTransient annotated it will be processed recursively
+            methods.addAll(getMethodsInternal(superClass, accessType, acceptSetters));
+        }
+        // process current class
+        for (Method method : cls.getDeclaredMethods()) {
+            if (isMethodAccepted(method, accessType, acceptSetters)) {
+                methods.add(method);
+            }
+        }
+        return methods;
+    }
+    
+    static Method getMethod(Class<?> cls, XmlAccessType accessType, String methodName,
+            Class<?>... paramTypes) {
+        for (Method m : getMethods(cls, accessType, true)) {
+            if (m.getName().equals(methodName) && Arrays.equals(m.getParameterTypes(), paramTypes)) {
+                return m;
+            }
+        }
+        return null;
+    }
+    
+    static Field getField(Class<?> cls, XmlAccessType accessType, String fieldName) {
+        for (final Field f : getFields(cls, accessType)) {
+            if (f.getName().equals(fieldName)) {
+                return f;
+            }
+        }
+        return null;
+    }
+    
+    static Collection<Method> getGetters(Class<?> cls, XmlAccessType accessType) {
+        return getMethods(cls, accessType, false);
+    }
+
+    static boolean isMethodAccepted(Method method, XmlAccessType accessType, boolean acceptSetters) {
+        // ignore bridge, static, @XmlTransient methods plus methods declared in Throwable
+        if (method.isBridge()
+                || Modifier.isStatic(method.getModifiers())
+                || method.isAnnotationPresent(XmlTransient.class)
+                || method.getDeclaringClass().equals(Throwable.class)) {
+            return false;
+        }
+        // Allow only public methods if PUBLIC_MEMBER access is requested
+        if (accessType == XmlAccessType.PUBLIC_MEMBER && !Modifier.isPublic(method.getModifiers())) { 
+            return false;
+        }
+        if (isGetter(method)) {
+            // does nothing
+        } else if (isSetter(method)) {
+            if (!acceptSetters) {
+                return false;
+            }
+        } else {
+            // we accept only getters and setters
+            return false;
+        }
+        // let JAXB annotations decide if NONE or FIELD access is requested
+        if (accessType == XmlAccessType.NONE || accessType == XmlAccessType.FIELD) {
+            return JAXBContextInitializer.checkJaxbAnnotation(method.getAnnotations());
+        }
+        // method accepted
+        return true;
+    }
+    
+    private static boolean isGetter(Method m) {
+        Class<?> declaringClass = m.getDeclaringClass();
+        if (m.getReturnType() != Void.class && m.getParameterTypes().length == 0) {
+            final int index = getterIndex(m.getName());
+            if (index != -1) {
+                String setterName = "set" + m.getName().substring(index);
+                Class<?> paramTypes = m.getReturnType();
+                Method setter = getDeclaredMethod(declaringClass, setterName, paramTypes);
+                if (setter != null && !setter.isAnnotationPresent(XmlTransient.class)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+    
+    private static boolean isSetter(Method m) {
+        Class<?> declaringClass = m.getDeclaringClass();
+        boolean isVoidReturnType = m.getReturnType() == Void.class || m.getReturnType() == Void.TYPE; 
+        if (isVoidReturnType && m.getParameterTypes().length == 1 && m.getName().startsWith("set")) {
+            String getterName = "get" + m.getName().substring(3);
+            Class<?> setterParamType = m.getParameterTypes()[0];
+            Method getter = getDeclaredMethod(declaringClass, getterName);
+            if (getter != null && getter.getReturnType().equals(setterParamType)
+                    && !getter.isAnnotationPresent(XmlTransient.class)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static int getterIndex(String methodName) {
+        if (methodName.startsWith("is")) {
+            return 2;
+        }
+        if (methodName.startsWith("get")) {
+            return 3;
+        }
+        return -1;
+    }
+
+    private static Method getDeclaredMethod(Class<?> cls, String methodName, Class<?>... paramTypes) {
+        try {
+            return cls.getDeclaredMethod(methodName, paramTypes);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    static Class<?> getFieldType(Field f) {
+        XmlJavaTypeAdapter adapter = getFieldXJTA(f);
+        Class<?> adapterType = getTypeFromXmlAdapter(adapter);
+        return adapterType != null ? adapterType : f.getType();
+    }
+
+    static Class<?> getMethodReturnType(Method m) {
+        XmlJavaTypeAdapter adapter = getMethodXJTA(m);
+        Class<?> adapterType = getTypeFromXmlAdapter(adapter);
+        return adapterType != null ? adapterType : m.getReturnType(); 
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    static Object getFieldValue(Field f, Object target) throws Exception {
+        XmlJavaTypeAdapter adapterAnnotation = getFieldXJTA(f);
+        XmlAdapter adapter = getXmlAdapter(adapterAnnotation);
+        return adapter != null ? adapter.marshal(f.get(target)) : f.get(target); 
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    static Object getMethodValue(Method m, Object target) throws Exception {
+        XmlJavaTypeAdapter adapterAnnotation = getMethodXJTA(m);
+        XmlAdapter adapter = getXmlAdapter(adapterAnnotation);
+        return adapter != null ? adapter.marshal(m.invoke(target)) : m.invoke(target); 
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    static void setFieldValue(Field f, Object target, Object value) throws Exception {
+        XmlJavaTypeAdapter xjta = getFieldXJTA(f);
+        XmlAdapter adapter = getXmlAdapter(xjta);
+        f.set(target, adapter != null ? adapter.unmarshal(value) : value);
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    static void setMethodValue(Method getter, Method setter, Object target, Object value) throws Exception {
+        XmlJavaTypeAdapter xjta = getMethodXJTA(getter);
+        XmlAdapter adapter = getXmlAdapter(xjta);
+        setter.invoke(target, adapter != null ? adapter.unmarshal(value) : value);
+    }
+
+    @SuppressWarnings("rawtypes") 
+    static XmlAdapter getXmlAdapter(XmlJavaTypeAdapter adapterAnnotation)
+        throws InstantiationException, IllegalAccessException {
+        return adapterAnnotation != null ? adapterAnnotation.value().newInstance() : null;
+    }
+
+    static XmlJavaTypeAdapter getFieldXJTA(final Field f) {
+        XmlJavaTypeAdapter adapter = f.getAnnotation(XmlJavaTypeAdapter.class);
+        if (adapter == null) {
+            adapter = f.getType().getAnnotation(XmlJavaTypeAdapter.class);
+        }
+        if (adapter == null) {
+            XmlJavaTypeAdapters adapters = f.getDeclaringClass().getPackage().getAnnotation(XmlJavaTypeAdapters.class);
+            if (adapters != null) {
+                for (XmlJavaTypeAdapter candidate : adapters.value()) {
+                    if (candidate != null && candidate.type().equals(f.getType())) {
+                        adapter = candidate;
+                        break;
+                    }
+                }
+            }
+        }
+        return adapter;
+    }
+
+    static XmlJavaTypeAdapter getMethodXJTA(final Method m) {
+        XmlJavaTypeAdapter adapter = m.getAnnotation(XmlJavaTypeAdapter.class);
+        if (adapter == null) {
+            adapter = m.getReturnType().getAnnotation(XmlJavaTypeAdapter.class);
+        }
+        if (adapter == null) {
+            XmlJavaTypeAdapters adapters = m.getDeclaringClass().getPackage().getAnnotation(XmlJavaTypeAdapters.class);
+            if (adapters != null) {
+                for (XmlJavaTypeAdapter candidate : adapters.value()) {
+                    if (candidate != null && candidate.type().equals(m.getGenericReturnType())) {
+                        adapter = candidate;
+                        break;
+                    }
+                }
+            }
+        }
+        return adapter;
+    }
+
+    static Class<?> getTypeFromXmlAdapter(XmlJavaTypeAdapter xjta) {
+        if (xjta != null) {
+            Class<?> c2 = xjta.value();
+            Type sp = c2.getGenericSuperclass();
+            while (!XmlAdapter.class.equals(c2) && c2 != null) {
+                sp = c2.getGenericSuperclass();
+                c2 = c2.getSuperclass();
+            }
+            if (sp instanceof ParameterizedType) {
+                return (Class<?>)((ParameterizedType)sp).getActualTypeArguments()[0];
+            }
+        }
+        return null;
+    }
+
+}
