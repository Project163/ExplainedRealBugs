diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
index 32a24f7c36..b7a4ab1a94 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
@@ -322,6 +322,18 @@ public final class ContextUtils {
                || Names.WSA_ANONYMOUS_ADDRESS.equals(ref.getAddress().getValue())
                || Names.WSA_NONE_ADDRESS.equals(ref.getAddress().getValue());
     }
+    
+    /**
+     * Helper method to determine if an EPR address is none.
+     *
+     * @param ref the EPR under test
+     * @return true if the address is generic
+     */
+    public static boolean isNoneAddress(EndpointReferenceType ref) {
+        return ref != null 
+               && ref.getAddress() != null
+               && Names.WSA_NONE_ADDRESS.equals(ref.getAddress().getValue());
+    }
 
     /**
      * Helper method to determine if an MAPs Action is empty (a null action
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
index 854d984ac2..7f772d9545 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
@@ -537,10 +537,16 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
                                                 message);
                 } 
                 if (!isOneway) {
-                    // ensure the inbound MAPs are available in both the full & fault
-                    // response messages (used to determine relatesTo etc.)
-                    ContextUtils.propogateReceivedMAPs(maps,
+                    // if ReplyTo address is none then 202 response status is expected
+                    // However returning a fault is more appropriate for request-response MEP
+                    if (ContextUtils.isNoneAddress(maps.getReplyTo())) {
+                        continueProcessing = false;
+                    } else {
+                        // ensure the inbound MAPs are available in both the full & fault
+                        // response messages (used to determine relatesTo etc.)
+                        ContextUtils.propogateReceivedMAPs(maps,
                                                        message.getExchange());
+                    }
                 }
             }
             if (continueProcessing) {
diff --git a/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/MAPAggregatorTest.java b/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/MAPAggregatorTest.java
index 03d257c03c..a8bd174454 100644
--- a/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/MAPAggregatorTest.java
+++ b/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/MAPAggregatorTest.java
@@ -33,16 +33,13 @@ import javax.xml.namespace.QName;
 import javax.xml.ws.RequestWrapper;
 import javax.xml.ws.ResponseWrapper;
 
-//import javax.xml.ws.RequestWrapper;
-//import javax.xml.ws.ResponseWrapper;
-
-
 import org.apache.cxf.Bus;
 import org.apache.cxf.binding.Binding;
 import org.apache.cxf.binding.soap.SoapFault;
 import org.apache.cxf.endpoint.Endpoint;
 import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.message.Exchange;
+import org.apache.cxf.message.ExchangeImpl;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.message.MessageImpl;
 import org.apache.cxf.phase.PhaseManager;
@@ -58,16 +55,17 @@ import org.apache.cxf.service.model.InterfaceInfo;
 import org.apache.cxf.service.model.MessageInfo.Type;
 import org.apache.cxf.service.model.OperationInfo;
 import org.apache.cxf.service.model.ServiceInfo;
+
 import org.apache.cxf.transport.Conduit;
 import org.apache.cxf.transport.Destination;
 import org.easymock.classextension.EasyMock;
 import org.easymock.classextension.IMocksControl;
+
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
-
 import static org.apache.cxf.binding.soap.Soap11.SOAP_NAMESPACE;
 import static org.apache.cxf.message.Message.REQUESTOR_ROLE;
 import static org.apache.cxf.ws.addressing.JAXWSAConstants.CLIENT_ADDRESSING_PROPERTIES;
@@ -319,6 +317,37 @@ public class MAPAggregatorTest extends Assert {
         control.verify();
         verifyMessage(message, true, false, false /*check*/);
     }
+    
+    @Test
+    public void testTwoWayRequestWithReplyToNone() throws Exception {
+        Message message = new MessageImpl();  
+        Exchange exchange = new ExchangeImpl();
+        message.setExchange(exchange);
+        setUpMessageProperty(message,
+                             REQUESTOR_ROLE,
+                             Boolean.FALSE);
+        AddressingPropertiesImpl maps = new AddressingPropertiesImpl();
+        EndpointReferenceType replyTo = new EndpointReferenceType();
+        replyTo.setAddress(ContextUtils.getAttributedURI(Names.WSA_NONE_ADDRESS));
+        maps.setReplyTo(replyTo);
+        AttributedURIType id = 
+            ContextUtils.getAttributedURI("urn:uuid:12345");
+        maps.setMessageID(id);
+        maps.setAction(ContextUtils.getAttributedURI(""));
+        setUpMessageProperty(message,
+                             SERVER_ADDRESSING_PROPERTIES_INBOUND,
+                             maps);
+        setUpMessageProperty(message,
+                             "org.apache.cxf.ws.addressing.map.fault.name",
+                             "NoneAddress");
+        
+        try {
+            aggregator.mediate(message, false);
+            fail("Two way request with ReplyTo address set to none must fail");
+        } catch (SoapFault ex) {
+            // expected
+        }
+    }
 
     
     private Message setUpMessage(boolean requestor, 
