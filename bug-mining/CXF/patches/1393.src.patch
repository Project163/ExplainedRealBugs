diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Soap11FaultOutInterceptor.java b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Soap11FaultOutInterceptor.java
index 325a0c15a3..fb589091f2 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Soap11FaultOutInterceptor.java
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Soap11FaultOutInterceptor.java
@@ -85,7 +85,12 @@ public class Soap11FaultOutInterceptor extends AbstractSoapInterceptor {
     
                 writer.writeStartElement("faultstring");
                 if (fault.getMessage() != null) {
-                    writer.writeCharacters(fault.getMessage());
+                    if (message.get("forced.faultstring") != null) {
+                        writer.writeCharacters((String)message.get("forced.faultstring"));
+                    } else {
+                        writer.writeCharacters(fault.getMessage());
+                    }
+                    
                 } else {
                     writer.writeCharacters("Fault occurred while processing.");
                 }
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/InternalContextUtils.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/InternalContextUtils.java
index 72b185001e..87d8553e94 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/InternalContextUtils.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/InternalContextUtils.java
@@ -45,6 +45,7 @@ import org.apache.cxf.io.DelegatingInputStream;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.message.MessageUtils;
+import org.apache.cxf.phase.PhaseInterceptorChain;
 import org.apache.cxf.service.model.BindingFaultInfo;
 import org.apache.cxf.service.model.BindingOperationInfo;
 import org.apache.cxf.service.model.EndpointInfo;
@@ -89,6 +90,7 @@ final class InternalContextUtils {
      * @param inMAPs the inbound MAPs
      * @param inMessage the current message
      */
+    //CHECKSTYLE:OFF  Max executable statement count limitation
     public static void rebaseResponse(EndpointReferenceType reference,
                                       AddressingProperties inMAPs,
                                       final Message inMessage) {
@@ -104,8 +106,6 @@ final class InternalContextUtils {
             // ensure the inbound MAPs are available in the partial response
             // message (used to determine relatesTo etc.)
             ContextUtils.propogateReceivedMAPs(inMAPs, partialResponse);
-            partialResponse.put(Message.PARTIAL_RESPONSE_MESSAGE, Boolean.TRUE);
-            partialResponse.put(Message.EMPTY_PARTIAL_RESPONSE_MESSAGE, Boolean.TRUE);
             Destination target = inMessage.getDestination();
             if (target == null) {
                 return;
@@ -118,8 +118,64 @@ final class InternalContextUtils {
                 Conduit backChannel = target.getBackChannel(inMessage,
                                                             partialResponse,
                                                             reference);
+                Exception exception = inMessage.getContent(Exception.class);
+                //Add this to handle two way faultTo
+                //TODO:Look at how to refactor 
+                if (backChannel != null && !inMessage.getExchange().isOneWay() 
+                    && ContextUtils.isFault(inMessage)) {
+                    // send the fault message to faultTo Endpoint
+                    exchange.setOutMessage(ContextUtils.createMessage(exchange));
+                    exchange.put(ConduitSelector.class, new NullConduitSelector());
+                    exchange.put("org.apache.cxf.http.no_io_exceptions", true);
+                    Destination destination = createDecoupledDestination(exchange, reference);
+                    exchange.setDestination(destination);
 
+                    if (ContextUtils.retrieveAsyncPostResponseDispatch(inMessage)) {
+                        DelegatingInputStream in = inMessage.getContent(DelegatingInputStream.class);
+                        if (in != null) {
+                            in.cacheInput();
+                        }
+                        inMessage.getInterceptorChain().reset();
+                        inMessage.getInterceptorChain().doIntercept(inMessage);
+
+                    }
+
+                    // send the partial response to requester
+                    partialResponse.put("forced.faultstring",
+                                        "The server sent HTTP status code :"
+                                            + inMessage.getExchange().get(Message.RESPONSE_CODE));
+                    partialResponse.setContent(Exception.class, exception);
+                    partialResponse.put(org.apache.cxf.message.Message.PROTOCOL_HEADERS,
+                                        inMessage.get(Message.PROTOCOL_HEADERS));
+                    partialResponse.put(org.apache.cxf.message.Message.ENCODING,
+                                        inMessage.get(Message.ENCODING));
+                    partialResponse.put(ContextUtils.ACTION, inMessage.get(ContextUtils.ACTION));
+                    partialResponse.put("javax.xml.ws.addressing.context.inbound",
+                                        inMessage.get("javax.xml.ws.addressing.context.inbound"));
+                    partialResponse.put("javax.xml.ws.addressing.context.outbound",
+                                        inMessage.get("javax.xml.ws.addressing.context.outbound"));
+                    exchange.setOutMessage(partialResponse);
+                    PhaseInterceptorChain newChian = ((PhaseInterceptorChain)inMessage.getInterceptorChain())
+                        .cloneChain();
+                    partialResponse.setInterceptorChain(newChian);
+                    exchange.setDestination(target);
+                    exchange.setOneWay(false);
+                    exchange.put(ConduitSelector.class,
+                                 new PreexistingConduitSelector(backChannel, exchange.get(Endpoint.class)));
+                    if (newChian != null && !newChian.doIntercept(partialResponse)
+                        && partialResponse.getContent(Exception.class) != null) {
+                        if (partialResponse.getContent(Exception.class) instanceof Fault) {
+                            throw (Fault)partialResponse.getContent(Exception.class);
+                        } else {
+                            throw new Fault(partialResponse.getContent(Exception.class));
+                        }
+                    }
+                    return;
+                }
+                
                 if (backChannel != null) {
+                    partialResponse.put(Message.PARTIAL_RESPONSE_MESSAGE, Boolean.TRUE);
+                    partialResponse.put(Message.EMPTY_PARTIAL_RESPONSE_MESSAGE, Boolean.TRUE);
                     boolean robust =
                         MessageUtils.isTrue(inMessage.getContextualProperty(Message.ROBUST_ONEWAY));
                     
@@ -214,12 +270,13 @@ final class InternalContextUtils {
                             }
                         }
                     }
-                }
+                } 
             } catch (Exception e) {
                 LOG.log(Level.WARNING, "SERVER_TRANSPORT_REBASE_FAILURE_MSG", e);
             }
         }
     }
+    //CHECKSTYLE:ON
 
     public static Destination createDecoupledDestination(
         Exchange exchange, final EndpointReferenceType reference) {
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/OneWayDecoupledFaultHandler.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/DecoupledFaultHandler.java
similarity index 94%
rename from rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/OneWayDecoupledFaultHandler.java
rename to rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/DecoupledFaultHandler.java
index 203c236637..6c81d418fd 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/OneWayDecoupledFaultHandler.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/DecoupledFaultHandler.java
@@ -41,11 +41,11 @@ import org.apache.cxf.ws.addressing.Names;
  * It can be installed using @InInterceptors and @OutInterceptors
  * annotations or explicitly added to the list of interceptors. 
  */
-public class OneWayDecoupledFaultHandler extends AbstractSoapInterceptor {
+public class DecoupledFaultHandler extends AbstractSoapInterceptor {
     
     public static final String WSA_ACTION = "http://schemas.xmlsoap.org/wsdl/soap/envelope/fault";
 
-    public OneWayDecoupledFaultHandler() {
+    public DecoupledFaultHandler() {
         super(Phase.PRE_PROTOCOL);
         addBefore(MAPCodec.class.getName());
     } 
@@ -58,8 +58,7 @@ public class OneWayDecoupledFaultHandler extends AbstractSoapInterceptor {
     // but at the moment PhaseInterceptorChain needs to be tricked that this is
     // a two way request for a fault chain be invoked
     public void handleFault(SoapMessage message) {
-        if (message.getExchange().isOneWay()
-            && !ContextUtils.isRequestor(message)) {
+        if (!ContextUtils.isRequestor(message)) {
             
             Exchange exchange = message.getExchange();
             Message inMessage = exchange.getInMessage();
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
index fde8aef00b..c2beefd50d 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
@@ -78,8 +78,8 @@ public class MAPCodec extends AbstractSoapInterceptor {
     private static final Logger LOG = LogUtils.getL7dLogger(MAPCodec.class);
     private static final String IS_REFERENCE_PARAM_ATTR_NAME = "IsReferenceParameter";
     private static final ResourceBundle BUNDLE = LOG.getResourceBundle();
-    private static final String ONE_WAY_DECOUPLED_FAULT_SUPPORT = 
-        "org.apache.cxf.ws.addressing.oneway.decoupled_fault_support";
+    private static final String DECOUPLED_FAULT_SUPPORT = 
+        "org.apache.cxf.ws.addressing.decoupled_fault_support";
     
     /**
      * REVISIT: map usage that the *same* interceptor instance 
@@ -151,10 +151,8 @@ public class MAPCodec extends AbstractSoapInterceptor {
                     }
                 }
             }
-        } else if (MessageUtils.getContextualBoolean(message, 
-                                                     ONE_WAY_DECOUPLED_FAULT_SUPPORT, 
-                                                     false)) {
-            new OneWayDecoupledFaultHandler().handleFault(message);
+        } else if (MessageUtils.getContextualBoolean(message, DECOUPLED_FAULT_SUPPORT, false)) {
+            new DecoupledFaultHandler().handleFault(message);
         }
     }
 
diff --git a/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/soap/OneWayDecoupledFaultHandlerTest.java b/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/soap/DecoupledFaultHandlerTest.java
similarity index 95%
rename from rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/soap/OneWayDecoupledFaultHandlerTest.java
rename to rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/soap/DecoupledFaultHandlerTest.java
index ddb0351b31..ee06ce60fa 100644
--- a/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/soap/OneWayDecoupledFaultHandlerTest.java
+++ b/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/soap/DecoupledFaultHandlerTest.java
@@ -35,11 +35,11 @@ import org.easymock.EasyMock;
 import org.junit.Assert;
 import org.junit.Test;
 
-public class OneWayDecoupledFaultHandlerTest extends Assert {
+public class DecoupledFaultHandlerTest extends Assert {
 
     @Test
     public void testOnewayFault() {
-        OneWayDecoupledFaultHandler handler = new OneWayDecoupledFaultHandler() {
+        DecoupledFaultHandler handler = new DecoupledFaultHandler() {
             protected Destination createDecoupledDestination(Exchange exchange, EndpointReferenceType epr) {
                 assertEquals("http://bar", epr.getAddress().getValue());
                 return EasyMock.createMock(Destination.class);
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/FaultToEndpointServer.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/FaultToEndpointServer.java
new file mode 100644
index 0000000000..2204545dcd
--- /dev/null
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/FaultToEndpointServer.java
@@ -0,0 +1,95 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.ws.addr_feature;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.xml.ws.Endpoint;
+
+import org.apache.cxf.BusFactory;
+import org.apache.cxf.jaxws.EndpointImpl;
+import org.apache.cxf.testutil.common.AbstractBusTestServerBase;
+import org.apache.cxf.ws.addressing.WSAddressingFeature;
+import org.apache.cxf.ws.addressing.soap.DecoupledFaultHandler;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+
+public class FaultToEndpointServer extends AbstractBusTestServerBase {
+    static final String FAULT_PORT = allocatePort(FaultToEndpointServer.class);
+    static final String PORT = allocatePort(FaultToEndpointServer.class, 1);
+    EndpointImpl ep;
+    private org.eclipse.jetty.server.Server faultToserver;
+    protected void run()  { 
+        faultToserver = new org.eclipse.jetty.server.Server(Integer.parseInt(FAULT_PORT));
+        faultToserver.setHandler(new HelloHandler());
+        try {
+            faultToserver.start();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        
+        setBus(BusFactory.getDefaultBus());
+        Object implementor = new AddNumberImpl();
+        String address = "http://localhost:" + PORT + "/jaxws/add";
+        //Endpoint.publish(address, implementor);
+
+        ep = (EndpointImpl) Endpoint.create(implementor);
+        ep.getInInterceptors().add(new DecoupledFaultHandler());
+        ep.getFeatures().add(new WSAddressingFeature());
+        ep.publish(address);     
+    }
+    
+    public void tearDown() throws Exception {
+        if (faultToserver != null) {
+            faultToserver.stop();
+            faultToserver.destroy();
+            faultToserver = null;
+        }
+        
+        ep.stop();
+        ep = null;        
+    }
+
+    public static void main(String[] args) {
+        try {
+            FaultToEndpointServer server = new FaultToEndpointServer();
+            server.start();
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            System.exit(-1);
+        } finally {
+            System.out.println("done!");
+        }
+    }
+    
+    class HelloHandler extends AbstractHandler {
+        public void handle(String target, Request baseRequest, HttpServletRequest request,
+                           HttpServletResponse response) throws IOException, ServletException {
+            response.setContentType("text/html;charset=utf-8");
+            response.setStatus(HttpServletResponse.SC_OK);
+            baseRequest.setHandled(true);
+            response.getWriter().println("Received");
+        }
+    }
+}   
+
+
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/Server.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/Server.java
index 974150b890..4282a5c2be 100644
--- a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/Server.java
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/Server.java
@@ -39,6 +39,7 @@ public class Server extends AbstractBusTestServerBase {
         ep.getFeatures().add(new WSAddressingFeature());
         ep.publish(address);
     }
+    
     public void tearDown() {
         ep.stop();
         ep = null;
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/WSAFaultToClientServerTest.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/WSAFaultToClientServerTest.java
new file mode 100644
index 0000000000..c1bd36bd0d
--- /dev/null
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/WSAFaultToClientServerTest.java
@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.ws.addr_feature;
+
+import java.io.ByteArrayOutputStream;
+import java.net.URL;
+import java.util.Map;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.soap.AddressingFeature;
+
+import org.apache.cxf.systest.ws.AbstractWSATestBase;
+import org.apache.cxf.ws.addressing.AddressingProperties;
+import org.apache.cxf.ws.addressing.AttributedURIType;
+import org.apache.cxf.ws.addressing.EndpointReferenceType;
+import org.apache.cxf.ws.addressing.JAXWSAConstants;
+import org.apache.cxf.ws.addressing.impl.AddressingPropertiesImpl;
+
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class WSAFaultToClientServerTest  extends AbstractWSATestBase {
+    private final QName serviceName = new QName("http://apache.org/cxf/systest/ws/addr_feature/",
+                                                "AddNumbersService");
+
+    @Before
+    public void setUp() throws Exception {
+        createBus();
+    }
+
+    @BeforeClass
+    public static void startServers() throws Exception {
+        assertTrue("FaultTo server did not launch correctly", launchServer(FaultToEndpointServer.class, true));
+    }
+
+    @Test
+    public void testJaxwsWsaFeature() throws Exception {
+        ByteArrayOutputStream input = setupInLogging();
+        AddNumbersPortType port = getPort();
+
+        EndpointReferenceType faultTo = new EndpointReferenceType();
+        AddressingProperties addrProperties = new AddressingPropertiesImpl();
+        AttributedURIType epr = new AttributedURIType();
+        epr.setValue("http://localhost:" + FaultToEndpointServer.FAULT_PORT);
+        faultTo.setAddress(epr);
+        addrProperties.setFaultTo(faultTo);
+        
+        BindingProvider provider = (BindingProvider) port;
+        Map<String, Object> requestContext = provider.getRequestContext();
+        requestContext.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, 
+                           "http://localhost:" + FaultToEndpointServer.PORT + "/jaxws/add");
+        requestContext.put(JAXWSAConstants.CLIENT_ADDRESSING_PROPERTIES, addrProperties);
+
+        try {
+            port.addNumbers(-1, -2);
+            fail("Exception is expected");
+        } catch (Exception e) {
+            //do nothing
+        }
+               
+        assertTrue("The response from faultTo endpoint is expected and actual response is " 
+                   + new String(input.toByteArray()) , 
+                   new String(input.toByteArray()).indexOf("The server sent HTTP status code :200") > -1);
+        assertTrue("WS addressing header is expected", 
+                   new String(input.toByteArray()).indexOf("http://www.w3.org/2005/08/addressing") > -1);       
+        assertTrue("Fault deatil is expected", 
+                   new String(input.toByteArray()).indexOf("Negative numbers cant be added") > -1);
+    }
+     
+    private AddNumbersPortType getPort() throws Exception {
+        URL wsdl = getClass().getResource("/wsdl_systest_wsspec/add_numbers.wsdl");
+        assertNotNull("WSDL is null", wsdl);
+
+        AddNumbersService service = new AddNumbersService(wsdl, serviceName);
+        assertNotNull("Service is null ", service);
+        AddNumbersPortType port = service.getAddNumbersPort(new AddressingFeature());
+        //updateAddressPort(port, PORT);
+        return port;
+    }
+}
