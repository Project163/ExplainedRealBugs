diff --git a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/ReferencingAuthenticator.java b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/ReferencingAuthenticator.java
index 2b633166e9..3ad9260a51 100644
--- a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/ReferencingAuthenticator.java
+++ b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/ReferencingAuthenticator.java
@@ -18,13 +18,18 @@
  */
 package org.apache.cxf.transport.http;
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.net.Authenticator;
+import java.net.InetAddress;
 import java.net.PasswordAuthentication;
+import java.net.URL;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
@@ -82,6 +87,33 @@ public class ReferencingAuthenticator extends Authenticator {
     }
 
     private void remove() {
+        try { 
+            // Try Authenticator.getDefault() first, JDK9+
+            final MethodHandle mt = MethodHandles
+               .lookup()
+               .findStatic(Authenticator.class, "getDefault", MethodType.methodType(Authenticator.class));
+            removeInternal((Authenticator)mt.invoke());
+        } catch (final NoSuchMethodException | IllegalAccessException ex) {
+            removeInternal();
+        } catch (Throwable e) {
+            //ignore
+        }
+    }
+    
+    private void removeInternal(final Authenticator def) {
+        try {
+            if (def == this) {
+                //this is at the root of any chain of authenticators
+                Authenticator.setDefault(wrapped);
+            } else {
+                removeFromChain(def);
+            }
+        } catch (Throwable t) {
+            //ignore
+        }
+    }
+    
+    private void removeInternal() {
         try {
             for (final Field f : Authenticator.class.getDeclaredFields()) {
                 if (f.getType().equals(Authenticator.class)) {
@@ -126,6 +158,42 @@ public class ReferencingAuthenticator extends Authenticator {
         if (a == null) {
             return null;
         }
+        
+        try {
+            // Try Authenticator.requestPasswordAuthentication() first, JDK9+
+            final MethodHandle mt = MethodHandles
+               .lookup()
+               .findStatic(Authenticator.class, "requestPasswordAuthentication", 
+                   MethodType.methodType(PasswordAuthentication.class, new Class<?>[] {
+                       Authenticator.class,
+                       String.class,
+                       InetAddress.class,
+                       int.class,
+                       String.class,
+                       String.class,
+                       String.class,
+                       URL.class,
+                       RequestorType.class
+                   }));
+    
+            return (PasswordAuthentication)mt.invoke(a, getRequestingHost(), getRequestingSite(), 
+                getRequestingPort(), getRequestingProtocol(), getRequestingPrompt(), getRequestingScheme(), 
+                    getRequestingURL(), getRequestorType());
+        } catch (final NoSuchMethodException | IllegalAccessException ex) {
+            return tryWithInternal(a);
+        } catch (final Throwable ex) {
+            if (ex instanceof Exception) {
+                throw (Exception)ex;
+            } else {
+                throw new Exception(ex);
+            }
+        }
+    }
+    
+    private PasswordAuthentication tryWithInternal(Authenticator a) throws Exception {
+        if (a == null) {
+            return null;
+        }
         Field[] fields = null;
         if (SKIPCHECK) {
             fields = Authenticator.class.getDeclaredFields();
