diff --git a/core/src/main/java/org/apache/cxf/interceptor/ServiceInvokerInterceptor.java b/core/src/main/java/org/apache/cxf/interceptor/ServiceInvokerInterceptor.java
index 9d23799894..81f773049e 100644
--- a/core/src/main/java/org/apache/cxf/interceptor/ServiceInvokerInterceptor.java
+++ b/core/src/main/java/org/apache/cxf/interceptor/ServiceInvokerInterceptor.java
@@ -24,7 +24,6 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.FutureTask;
 
-import org.apache.cxf.common.util.PropertyUtils;
 import org.apache.cxf.endpoint.Endpoint;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.Message;
@@ -32,6 +31,7 @@ import org.apache.cxf.message.MessageContentsList;
 import org.apache.cxf.message.MessageImpl;
 import org.apache.cxf.phase.AbstractPhaseInterceptor;
 import org.apache.cxf.phase.Phase;
+import org.apache.cxf.phase.PhaseInterceptorChain;
 import org.apache.cxf.service.Service;
 import org.apache.cxf.service.invoker.Invoker;
 
@@ -89,45 +89,51 @@ public class ServiceInvokerInterceptor extends AbstractPhaseInterceptor<Message>
         
         Executor executor = getExecutor(endpoint);
         Executor executor2 = exchange.get(Executor.class);
-        if (executor2 == executor || executor == null) {
+        if (executor2 == executor || executor == null
+            || !(message.getInterceptorChain() instanceof PhaseInterceptorChain)) {
             // already executing on the appropriate executor
             invocation.run();
         } else {
             exchange.put(Executor.class, executor);
-            FutureTask<Object> o = new FutureTask<Object>(invocation, null) {
+            // The current thread holds the lock on PhaseInterceptorChain.
+            // In order to avoid the executor threads deadlocking on any of
+            // synchronized PhaseInterceptorChain methods the current thread
+            // needs to release the chain lock and re-acquire it after the
+            // executor thread is done
+            
+            final PhaseInterceptorChain chain = (PhaseInterceptorChain)message.getInterceptorChain();
+            final FutureTask<Object> o = new FutureTask<Object>(invocation, null) {
                 @Override
                 protected void done() {
                     super.done();
-                    synchronized (this) {
-                        this.notifyAll();
+                    chain.releaseChain();
+                }
+                
+                @Override
+                public void run() {
+                    synchronized (chain) {
+                        super.run();
                     }
                 }
             };
-            synchronized (o) {
+            synchronized (chain) {
                 executor.execute(o);
-                if (!o.isDone()) {
-                    try {
-                        o.wait();
-                    } catch (InterruptedException e) {
-                        //IGNORE
-                    }
-                }
-                try {
-                    o.get();
-                } catch (InterruptedException e) {
-                    throw new Fault(e);
-                } catch (ExecutionException e) {
-                    if (e.getCause() instanceof RuntimeException) {
-                        throw (RuntimeException)e.getCause();
-                    } else {
-                        throw new Fault(e.getCause());
-                    }
-                } finally {
-                    if (PropertyUtils.isTrue(exchange.remove(Message.SUSPENDED_INVOCATION))) {    
-                        message.getInterceptorChain().suspend();
-                    }
+                // the task will already be done if the executor uses the current thread
+                // but the chain lock status still needs to be re-set
+                chain.releaseAndAcquireChain();
+            }
+            try {
+                o.get();
+            } catch (InterruptedException e) {
+                throw new Fault(e);
+            } catch (ExecutionException e) {
+                if (e.getCause() instanceof RuntimeException) {
+                    throw (RuntimeException)e.getCause();
+                } else {
+                    throw new Fault(e.getCause());
                 }
             }
+            
         }
     }
     
diff --git a/core/src/main/java/org/apache/cxf/message/Message.java b/core/src/main/java/org/apache/cxf/message/Message.java
index 40dd990232..2ad52aa06e 100644
--- a/core/src/main/java/org/apache/cxf/message/Message.java
+++ b/core/src/main/java/org/apache/cxf/message/Message.java
@@ -139,8 +139,6 @@ public interface Message extends StringMap {
     String WSDL_INTERFACE = "javax.xml.ws.wsdl.interface";
     String WSDL_OPERATION = "javax.xml.ws.wsdl.operation";
 
-    String SUSPENDED_INVOCATION = "org.apache.cxf.suspended.invocation";
-    
     /**
      * Some properties to allow adding interceptors to the chain
      * on a per-request basis.  All are a Collection<Interceptor> 
diff --git a/core/src/main/java/org/apache/cxf/phase/PhaseInterceptorChain.java b/core/src/main/java/org/apache/cxf/phase/PhaseInterceptorChain.java
index c403e97950..2f52655f0a 100644
--- a/core/src/main/java/org/apache/cxf/phase/PhaseInterceptorChain.java
+++ b/core/src/main/java/org/apache/cxf/phase/PhaseInterceptorChain.java
@@ -93,7 +93,7 @@ public class PhaseInterceptorChain implements InterceptorChain {
     // to avoid duplicate fault processing on nested calling of
     // doIntercept(), which will throw same fault multi-times
     private boolean faultOccurred;
-    
+    private boolean chainReleased;
     
     
     private PhaseInterceptorChain(PhaseInterceptorChain src) {
@@ -161,6 +161,22 @@ public class PhaseInterceptorChain implements InterceptorChain {
         return state;
     }
     
+    public synchronized void releaseAndAcquireChain() {
+        while (!chainReleased) {
+            try {
+                this.wait();
+            } catch (InterruptedException ex) {
+                // ignore
+            }
+        }
+        chainReleased = false;
+    }
+    
+    public synchronized void releaseChain() {
+        this.chainReleased = true;
+        this.notifyAll();
+    }
+    
     public PhaseInterceptorChain cloneChain() {
         return new PhaseInterceptorChain(this);
     }
diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java
index fa8805d5e4..4e33c83b52 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java
@@ -41,7 +41,6 @@ import org.apache.cxf.common.classloader.ClassLoaderUtils.ClassLoaderHolder;
 import org.apache.cxf.common.i18n.BundleUtils;
 import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.common.util.ClassHelper;
-import org.apache.cxf.common.util.PropertyUtils;
 import org.apache.cxf.helpers.CastUtils;
 import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.interceptor.InterceptorChain.State;
@@ -104,8 +103,7 @@ public class JAXRSInvoker extends AbstractInvoker {
             }
             return handleFault(ex, exchange.getInMessage());
         } finally {
-            boolean suspended = PropertyUtils.isTrue(exchange.get(Message.SUSPENDED_INVOCATION))
-                || exchange.getInMessage().getInterceptorChain().getState() == State.SUSPENDED;
+            boolean suspended = exchange.getInMessage().getInterceptorChain().getState() == State.SUSPENDED;
             if (exchange.isOneWay() || suspended) {
                 ServerProviderFactory.getInstance(exchange.getInMessage()).clearThreadLocalProxies();
             }
diff --git a/rt/transports/http-jetty/src/main/java/org/apache/cxf/transport/http_jetty/continuations/JettyContinuationWrapper.java b/rt/transports/http-jetty/src/main/java/org/apache/cxf/transport/http_jetty/continuations/JettyContinuationWrapper.java
index 9361fcceb4..b6d82aa09f 100644
--- a/rt/transports/http-jetty/src/main/java/org/apache/cxf/transport/http_jetty/continuations/JettyContinuationWrapper.java
+++ b/rt/transports/http-jetty/src/main/java/org/apache/cxf/transport/http_jetty/continuations/JettyContinuationWrapper.java
@@ -25,7 +25,6 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.cxf.continuations.Continuation;
 import org.apache.cxf.continuations.ContinuationCallback;
 import org.apache.cxf.message.Message;
-import org.apache.cxf.phase.PhaseInterceptorChain;
 import org.apache.cxf.transport.http.AbstractHTTPDestination;
 import org.eclipse.jetty.continuation.ContinuationListener;
 import org.eclipse.jetty.continuation.ContinuationSupport;
@@ -101,13 +100,8 @@ public class JettyContinuationWrapper implements Continuation, ContinuationListe
         }
         isNew = false;
         
-        if (PhaseInterceptorChain.getCurrentMessage() == null) {
-            // the current thread is different to the one which holds a lock on PhaseInterceptorChain 
-            message.getExchange().put(Message.SUSPENDED_INVOCATION, true);
-        } else {
-            // Need to get the right message which is handled in the interceptor chain
-            message.getExchange().getInMessage().getInterceptorChain().suspend();
-        }
+        message.getExchange().getInMessage().getInterceptorChain().suspend();
+        
         continuation.setTimeout(pendingTimeout);
         if (!isPending) {
             continuation.suspend();
diff --git a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/Servlet3ContinuationProvider.java b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/Servlet3ContinuationProvider.java
index 885ff0fd72..a9d2e231bc 100644
--- a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/Servlet3ContinuationProvider.java
+++ b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/Servlet3ContinuationProvider.java
@@ -31,7 +31,6 @@ import org.apache.cxf.continuations.Continuation;
 import org.apache.cxf.continuations.ContinuationCallback;
 import org.apache.cxf.continuations.ContinuationProvider;
 import org.apache.cxf.message.Message;
-import org.apache.cxf.phase.PhaseInterceptorChain;
 
 /**
  * 
@@ -100,13 +99,7 @@ public class Servlet3ContinuationProvider implements ContinuationProvider {
             isNew = false;
             
             context.setTimeout(timeout);
-            if (PhaseInterceptorChain.getCurrentMessage() == null) {
-                // the current thread is different to the one which holds a lock on PhaseInterceptorChain 
-                inMessage.getExchange().put(Message.SUSPENDED_INVOCATION, true);
-            } else {
-                // Need to get the right message which is handled in the interceptor chain
-                inMessage.getExchange().getInMessage().getInterceptorChain().suspend();
-            }
+            inMessage.getExchange().getInMessage().getInterceptorChain().suspend();
             
             return true;
         }
diff --git a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/continuations/JMSContinuation.java b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/continuations/JMSContinuation.java
index c2b033f22c..14a894e8c4 100644
--- a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/continuations/JMSContinuation.java
+++ b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/continuations/JMSContinuation.java
@@ -29,7 +29,6 @@ import org.apache.cxf.common.classloader.ClassLoaderUtils.ClassLoaderHolder;
 import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.continuations.Continuation;
 import org.apache.cxf.message.Message;
-import org.apache.cxf.phase.PhaseInterceptorChain;
 import org.apache.cxf.transport.MessageObserver;
 import org.apache.cxf.transport.jms.JMSConfiguration;
 import org.apache.cxf.workqueue.WorkQueue;
@@ -139,13 +138,8 @@ public class JMSContinuation implements Continuation {
         if (isPending) {
             return false;
         }
-        if (PhaseInterceptorChain.getCurrentMessage() == null) {
-            // the current thread is different to the one which holds a lock on PhaseInterceptorChain 
-            inMessage.getExchange().put(Message.SUSPENDED_INVOCATION, true);
-        } else {
-            // Need to get the right message which is handled in the interceptor chain
-            inMessage.getExchange().getInMessage().getInterceptorChain().suspend();
-        }
+        inMessage.getExchange().getInMessage().getInterceptorChain().suspend();
+        
         updateContinuations(false);
                 
         isNew = false;
