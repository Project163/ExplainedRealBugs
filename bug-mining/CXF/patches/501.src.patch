diff --git a/api/src/main/java/org/apache/cxf/io/DelegatingInputStream.java b/api/src/main/java/org/apache/cxf/io/DelegatingInputStream.java
new file mode 100644
index 0000000000..5de2572471
--- /dev/null
+++ b/api/src/main/java/org/apache/cxf/io/DelegatingInputStream.java
@@ -0,0 +1,67 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.io;
+
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.apache.cxf.helpers.IOUtils;
+
+public class DelegatingInputStream extends FilterInputStream {
+    private InputStream origIn;
+    
+    public DelegatingInputStream(InputStream is) {
+        super(is);
+        origIn = is;
+    }
+
+
+    public void setInputStream(InputStream inputStream) {
+        in = inputStream;
+    }
+    public InputStream getInputStream() {
+        return in;
+    }
+    
+
+    public void close() throws IOException {
+        super.close();
+        if (in != origIn) {
+            origIn.close();
+        }
+    }
+    
+    /**
+     * Read the entire original input stream and cache it.  Useful
+     * if switching threads or doing something where the original
+     * stream may not be valid by the time the next read() occurs
+     */
+    public void cacheInput() {
+        CachedOutputStream cache = new CachedOutputStream();
+        try {
+            IOUtils.copy(in, cache);
+            in = cache.getInputStream();
+        } catch (IOException e) {
+            //ignore
+        }
+    }
+    
+}
\ No newline at end of file
diff --git a/rt/core/src/main/java/org/apache/cxf/interceptor/OneWayProcessorInterceptor.java b/rt/core/src/main/java/org/apache/cxf/interceptor/OneWayProcessorInterceptor.java
index 7664e70f41..137c962e97 100644
--- a/rt/core/src/main/java/org/apache/cxf/interceptor/OneWayProcessorInterceptor.java
+++ b/rt/core/src/main/java/org/apache/cxf/interceptor/OneWayProcessorInterceptor.java
@@ -25,6 +25,7 @@ import java.util.concurrent.RejectedExecutionException;
 
 import org.apache.cxf.Bus;
 import org.apache.cxf.endpoint.Endpoint;
+import org.apache.cxf.io.DelegatingInputStream;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.message.MessageImpl;
@@ -59,6 +60,25 @@ public class OneWayProcessorInterceptor extends AbstractPhaseInterceptor<Message
             
             message.put(OneWayProcessorInterceptor.class, this);
             final InterceptorChain chain = message.getInterceptorChain();
+
+            Object o = message.getContextualProperty(USE_ORIGINAL_THREAD);
+            if (o == null) {
+                o = Boolean.FALSE;
+            } else if (o instanceof String) {
+                o = Boolean.valueOf((String)o);
+            }
+
+            
+            if (Boolean.FALSE.equals(o)) {
+                //need to suck in all the data from the input stream as
+                //the transport might discard any data on the stream when this 
+                //thread unwinds or when the empty response is sent back
+                DelegatingInputStream in = message.get(DelegatingInputStream.class);
+                if (in != null) {
+                    in.cacheInput();
+                }
+            }
+
             
             try {
                 Message partial = createMessage(message.getExchange());
@@ -71,12 +91,6 @@ public class OneWayProcessorInterceptor extends AbstractPhaseInterceptor<Message
                 //IGNORE
             }
             
-            Object o = message.getContextualProperty(USE_ORIGINAL_THREAD);
-            if (o == null) {
-                o = Boolean.FALSE;
-            } else if (o instanceof String) {
-                o = Boolean.valueOf((String)o);
-            }
             if (Boolean.FALSE.equals(o)) {
                 chain.pause();
                 try {
diff --git a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/AbstractHTTPDestination.java b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/AbstractHTTPDestination.java
index 3baabd8f6d..81db48330d 100644
--- a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/AbstractHTTPDestination.java
+++ b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/AbstractHTTPDestination.java
@@ -54,6 +54,7 @@ import org.apache.cxf.helpers.CastUtils;
 import org.apache.cxf.helpers.HttpHeaderHelper;
 import org.apache.cxf.interceptor.Interceptor;
 import org.apache.cxf.io.AbstractWrappedOutputStream;
+import org.apache.cxf.io.DelegatingInputStream;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.security.SecurityContext;
@@ -265,7 +266,9 @@ public abstract class AbstractHTTPDestination extends AbstractMultiplexDestinati
                                 final HttpServletRequest req, 
                                 final HttpServletResponse resp) throws IOException {
 
-        inMessage.setContent(InputStream.class, req.getInputStream());
+        DelegatingInputStream in = new DelegatingInputStream(req.getInputStream());
+        inMessage.setContent(DelegatingInputStream.class, in);
+        inMessage.setContent(InputStream.class, in);
         inMessage.put(HTTP_REQUEST, req);
         inMessage.put(HTTP_RESPONSE, resp);
         inMessage.put(HTTP_CONTEXT, context);
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
index 22c3fa6dae..9e2ebef3fa 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
@@ -41,6 +41,7 @@ import org.apache.cxf.endpoint.PreexistingConduitSelector;
 import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.interceptor.InterceptorChain;
 import org.apache.cxf.interceptor.OutgoingChainInterceptor;
+import org.apache.cxf.io.DelegatingInputStream;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.message.MessageImpl;
@@ -397,6 +398,14 @@ public final class ContextUtils {
                     }
                     
                     if (retrieveAsyncPostResponseDispatch(inMessage)) {
+                        //need to suck in all the data from the input stream as
+                        //the transport might discard any data on the stream when this 
+                        //thread unwinds or when the empty response is sent back
+                        DelegatingInputStream in = inMessage.get(DelegatingInputStream.class);
+                        if (in != null) {
+                            in.cacheInput();
+                        }
+                        
                         // async service invocation required *after* a response
                         // has been sent (i.e. to a oneway, or a partial response
                         // to a decoupled twoway)
