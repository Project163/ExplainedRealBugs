diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
index fbe7d2015b..2d5430ec80 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/ContextUtils.java
@@ -385,7 +385,9 @@ public final class ContextUtils {
                 exchange.setOutMessage(partialResponse);
                 Conduit backChannel = target.getBackChannel(inMessage,
                                                             partialResponse,
-                                                            reference);
+                                                            reference == null
+                                                            ? ContextUtils.getNoneEndpointReference()
+                                                            : reference);
 
                 if (backChannel != null) {
                     // set up interceptor chains and send message
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
index 9abb9bfa69..07edf6a4de 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
@@ -244,21 +244,23 @@ public class MAPCodec extends AbstractSoapInterceptor {
                                     hdr, 
                                     marshaller);
                 }
-                encodeAsExposed(maps,
-                                message,
-                                maps.getReplyTo(), 
-                                Names.WSA_REPLYTO_QNAME, 
-                                EndpointReferenceType.class,
-                                hdr,
-                                marshaller);
-                if (Names.WSA_REPLYTO_QNAME.equals(duplicate)) {
+                if (needsReplyTo(maps)) {
                     encodeAsExposed(maps,
-                                    message,
-                                    maps.getReplyTo(), 
-                                    Names.WSA_REPLYTO_QNAME, 
-                                    EndpointReferenceType.class,
-                                    hdr,
-                                    marshaller);
+                            message,
+                            maps.getReplyTo(), 
+                            Names.WSA_REPLYTO_QNAME, 
+                            EndpointReferenceType.class,
+                            hdr,
+                            marshaller);
+                    if (Names.WSA_REPLYTO_QNAME.equals(duplicate)) {
+                        encodeAsExposed(maps,
+                                        message,
+                                        maps.getReplyTo(), 
+                                        Names.WSA_REPLYTO_QNAME, 
+                                        EndpointReferenceType.class,
+                                        hdr,
+                                        marshaller);
+                    }
                 }
 
                 encodeAsExposed(maps,
@@ -293,11 +295,7 @@ public class MAPCodec extends AbstractSoapInterceptor {
                                     hdr, 
                                     marshaller);
                 }
-                if (maps.getFaultTo() != null
-                    && maps.getFaultTo().getAddress() != null
-                    && maps.getFaultTo().getAddress().getValue() != null
-                    && !maps.getFaultTo().getAddress().getValue()
-                        .equals(maps.getReplyTo().getAddress().getValue())) {
+                if (needsFaultTo(maps)) {
                     encodeAsExposed(maps,
                                     message,
                                     maps.getFaultTo(), 
@@ -337,6 +335,23 @@ public class MAPCodec extends AbstractSoapInterceptor {
         }
     }
 
+    private boolean needsReplyTo(AddressingProperties maps) {
+        return maps.getReplyTo() != null 
+            && maps.getReplyTo().getAddress() != null
+            && maps.getReplyTo().getAddress().getValue() != null
+            && !(VersionTransformer.Names200408.WSA_NAMESPACE_NAME.equals(maps.getNamespaceURI()) 
+                && maps.getReplyTo().getAddress().getValue()
+                .equals(ContextUtils.getNoneEndpointReference().getAddress().getValue()));
+    }
+
+    private boolean needsFaultTo(AddressingProperties maps) {
+        return maps.getFaultTo() != null
+            && maps.getFaultTo().getAddress() != null
+            && maps.getFaultTo().getAddress().getValue() != null
+            && !maps.getFaultTo().getAddress().getValue()
+                .equals(maps.getReplyTo().getAddress().getValue());
+    }
+
     private void encodeReferenceParameters(AddressingProperties maps, Element header, 
                                            Marshaller marshaller) throws JAXBException {
         EndpointReferenceType toEpr = maps.getToEndpointReference();
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addressing/HeaderVerifier.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addressing/HeaderVerifier.java
index 9c4894bdbc..9a0d73d634 100644
--- a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addressing/HeaderVerifier.java
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addressing/HeaderVerifier.java
@@ -129,7 +129,9 @@ public class HeaderVerifier extends AbstractSoapInterceptor {
                                       || outgoingPartialResponse;
             verificationCache.put(MAPTest.verifyHeaders(wsaHeaders, 
                                                         partialResponse,
-                                                        isRequestLeg(message)));
+                                                        isRequestLeg(message),
+                                                        !VersionTransformer.Names200408.WSA_NAMESPACE_NAME
+                                                        .equals(currentNamespaceURI)));
         } catch (SOAPException se) {
             verificationCache.put("SOAP header verification failed: " + se);
         }
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addressing/MAPTestBase.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addressing/MAPTestBase.java
index f565144a12..b74397d576 100644
--- a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addressing/MAPTestBase.java
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addressing/MAPTestBase.java
@@ -372,7 +372,8 @@ public abstract class MAPTestBase extends AbstractClientServerTestBase implement
      */
     protected static String verifyHeaders(List<String> wsaHeaders,
                                           boolean partial,
-                                          boolean requestLeg) {
+                                          boolean requestLeg,
+                                          boolean replyToRequired) {
         //System.out.println("verifying headers: " + wsaHeaders);
         String ret = null;
         if (!wsaHeaders.contains(Names.WSA_MESSAGEID_NAME)) {
@@ -382,8 +383,9 @@ public abstract class MAPTestBase extends AbstractClientServerTestBase implement
             ret = "expected To header";
         }
        
-        if (!(wsaHeaders.contains(Names.WSA_REPLYTO_NAME)
-              || wsaHeaders.contains(Names.WSA_RELATESTO_NAME))) {
+        if (replyToRequired 
+            && !(wsaHeaders.contains(Names.WSA_REPLYTO_NAME)
+                || wsaHeaders.contains(Names.WSA_RELATESTO_NAME))) {
             ret = "expected ReplyTo or RelatesTo header";
         }
         /*
