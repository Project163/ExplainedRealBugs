diff --git a/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPFeature.java b/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPFeature.java
index 9a50681987..bf0e69ce1b 100644
--- a/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPFeature.java
+++ b/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPFeature.java
@@ -57,15 +57,22 @@ public class GZIPFeature extends AbstractFeature {
      */
     int threshold = -1;
     
+    /**
+     * Force GZIP instead of negotiate
+     */
+    boolean force;
+    
+    
     @Override
     protected void initializeProvider(InterceptorProvider provider, Bus bus) {
         provider.getInInterceptors().add(IN);
-        if (threshold == -1) {
+        if (threshold == -1 && !force) {
             provider.getOutInterceptors().add(OUT);
             provider.getOutFaultInterceptors().add(OUT);
         } else {
             GZIPOutInterceptor out = new GZIPOutInterceptor();
             out.setThreshold(threshold);
+            out.setForce(force);
             remove(provider.getOutInterceptors());
             remove(provider.getOutFaultInterceptors());
             provider.getOutInterceptors().add(out);
@@ -89,5 +96,21 @@ public class GZIPFeature extends AbstractFeature {
     
     public int getThreshold() {
         return threshold;
-    }    
+    }
+    
+    
+    /**
+     * Set if GZIP is always used without negotiation 
+     * @param b
+     */
+    public void setForce(boolean b) {
+        force = b;
+    }
+    
+    /**
+     * Retrieve the value set with {@link #setForce(boolean)}.
+     */
+    public boolean getForce() {
+        return force;
+    }  
 }
diff --git a/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPInInterceptor.java b/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPInInterceptor.java
index 5f1c0c83ec..55ea7b5793 100644
--- a/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPInInterceptor.java
+++ b/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPInInterceptor.java
@@ -28,6 +28,7 @@ import java.util.zip.GZIPInputStream;
 
 import org.apache.cxf.common.i18n.BundleUtils;
 import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.endpoint.Endpoint;
 import org.apache.cxf.helpers.CastUtils;
 import org.apache.cxf.helpers.HttpHeaderHelper;
 import org.apache.cxf.interceptor.AttachmentInInterceptor;
@@ -91,6 +92,13 @@ public class GZIPInInterceptor extends AbstractPhaseInterceptor<Message> {
                             break;
                         }
                     }
+                    
+                    if (isRequestor(message)) {
+                        //record the fact that is worked so future requests will 
+                        //automatically be FI enabled
+                        Endpoint ep = message.getExchange().getEndpoint();
+                        ep.put(GZIPOutInterceptor.USE_GZIP_KEY, GZIPOutInterceptor.UseGzip.YES);
+                    }
                 } catch (IOException ex) {
                     throw new Fault(new org.apache.cxf.common.i18n.Message("COULD_NOT_UNZIP", BUNDLE), ex);
                 }
diff --git a/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPOutInterceptor.java b/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPOutInterceptor.java
index 2ba490f2a8..01a990ea21 100644
--- a/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPOutInterceptor.java
+++ b/rt/core/src/main/java/org/apache/cxf/transport/common/gzip/GZIPOutInterceptor.java
@@ -112,6 +112,7 @@ public class GZIPOutInterceptor extends AbstractPhaseInterceptor<Message> {
      * compressed.
      */
     private int threshold = 1024;
+    private boolean force;
 
     public GZIPOutInterceptor() {
         super(Phase.PREPARE_SEND);
@@ -169,9 +170,16 @@ public class GZIPOutInterceptor extends AbstractPhaseInterceptor<Message> {
      */
     private UseGzip gzipPermitted(Message message) throws Fault {
         UseGzip permitted = UseGzip.NO;
-        if (Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE))) {
+        if (isRequestor(message)) {
             LOG.fine("Requestor role, so gzip enabled");
-            permitted = UseGzip.YES;
+            Object o = message.getContextualProperty(USE_GZIP_KEY);
+            if (o instanceof UseGzip) {
+                permitted = (UseGzip)o;
+            } else if (o instanceof String) {
+                permitted = UseGzip.valueOf((String)o);
+            } else {
+                permitted = force ? UseGzip.YES : UseGzip.NO;
+            }
             message.put(GZIP_ENCODING_KEY, "gzip");
             addHeader(message, "Accept-Encoding", "gzip;q=1.0, identity; q=0.5, *;q=0"); 
         } else {
@@ -326,6 +334,9 @@ public class GZIPOutInterceptor extends AbstractPhaseInterceptor<Message> {
         } else {
             header.set(0, header.get(0) + "," + value);
         }
+    }
+    public void setForce(boolean force) {
+        this.force = force;
     }    
 
 }
diff --git a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSUtils.java b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSUtils.java
index 4475c34be3..52daf12056 100644
--- a/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSUtils.java
+++ b/rt/transports/jms/src/main/java/org/apache/cxf/transport/jms/JMSUtils.java
@@ -51,7 +51,6 @@ import org.apache.cxf.helpers.CastUtils;
 import org.apache.cxf.helpers.HttpHeaderHelper;
 import org.apache.cxf.message.MessageUtils;
 import org.apache.cxf.security.SecurityContext;
-import org.apache.cxf.transport.common.gzip.GZIPOutInterceptor;
 import org.apache.cxf.transport.jms.spec.JMSSpecConstants;
 import org.apache.cxf.transport.jms.uri.JMSEndpoint;
 import org.apache.cxf.transport.jms.uri.JMSEndpointParser;
@@ -450,7 +449,15 @@ public final class JMSUtils {
     }
     
     public static String getContentEncoding(org.apache.cxf.message.Message message) {
-        return (String)message.get(GZIPOutInterceptor.GZIP_ENCODING_KEY);
+        Map<String, List<String>> headers 
+            = CastUtils.cast((Map<?, ?>)message.get(org.apache.cxf.message.Message.PROTOCOL_HEADERS));
+        if (headers != null) {
+            List<String> l = headers.get("Content-Encoding");
+            if (l != null && !l.isEmpty()) {
+                return l.get(0);
+            }
+        }
+        return null;
     }
 
     public static Message buildJMSMessageFromCXFMessage(JMSConfiguration jmsConfig,
