diff --git a/common/common/src/main/java/org/apache/cxf/staxutils/DelegatingXMLStreamWriter.java b/common/common/src/main/java/org/apache/cxf/staxutils/DelegatingXMLStreamWriter.java
new file mode 100644
index 0000000000..8f20037b18
--- /dev/null
+++ b/common/common/src/main/java/org/apache/cxf/staxutils/DelegatingXMLStreamWriter.java
@@ -0,0 +1,167 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.staxutils;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+
+
+public class DelegatingXMLStreamWriter implements XMLStreamWriter {
+    XMLStreamWriter delegate;
+    
+    public DelegatingXMLStreamWriter(XMLStreamWriter del) {
+        delegate = del;
+    }
+    
+    public void close() throws XMLStreamException {
+        delegate.close();
+    }
+
+    public void flush() throws XMLStreamException {
+        delegate.flush();
+    }
+
+    public NamespaceContext getNamespaceContext() {
+        return delegate.getNamespaceContext();
+    }
+
+    
+    
+    
+    public String getPrefix(String uri) throws XMLStreamException {
+        return delegate.getPrefix(uri);
+    }
+
+    public Object getProperty(String name) throws IllegalArgumentException {
+        return delegate.getProperty(name);
+    }
+
+    public void setDefaultNamespace(String uri) throws XMLStreamException {
+        delegate.setDefaultNamespace(uri);
+    }
+
+    public void setNamespaceContext(NamespaceContext ctx) throws XMLStreamException {
+        delegate.setNamespaceContext(ctx);
+    }
+
+    public void setPrefix(String pfx, String uri) throws XMLStreamException {
+        delegate.setPrefix(pfx, uri);
+    }
+
+    public void writeAttribute(String prefix, String uri, 
+                               String local, String value) throws XMLStreamException {
+        delegate.writeAttribute(prefix, uri, local, value);
+    }
+
+    public void writeAttribute(String uri, String local, String value) throws XMLStreamException {
+        delegate.writeAttribute(uri, local, value);
+    }
+
+    public void writeAttribute(String local, String value) throws XMLStreamException {
+        delegate.writeAttribute(local, value);
+    }
+
+    public void writeCData(String cdata) throws XMLStreamException {
+        delegate.writeCData(cdata);
+    }
+
+    public void writeCharacters(char[] arg0, int arg1, int arg2) throws XMLStreamException {
+        delegate.writeCharacters(arg0, arg1, arg2);
+    }
+
+    public void writeCharacters(String text) throws XMLStreamException {
+        delegate.writeCharacters(text);
+    }
+
+    public void writeComment(String text) throws XMLStreamException {
+        delegate.writeComment(text);
+    }
+
+    public void writeDefaultNamespace(String uri) throws XMLStreamException {
+        delegate.writeDefaultNamespace(uri);
+    }
+
+    public void writeDTD(String dtd) throws XMLStreamException {
+        delegate.writeDTD(dtd);
+    }
+
+    public void writeEmptyElement(String prefix, String local, String uri) throws XMLStreamException {
+        delegate.writeEmptyElement(prefix, local, uri);
+    }
+
+    public void writeEmptyElement(String uri, String local) throws XMLStreamException {
+        delegate.writeEmptyElement(uri, local);
+    }
+
+    public void writeEmptyElement(String localName) throws XMLStreamException {
+        delegate.writeEmptyElement(localName);
+    }
+
+    public void writeEndDocument() throws XMLStreamException {
+        delegate.writeEndDocument();
+    }
+
+    public void writeEndElement() throws XMLStreamException {
+        delegate.writeEndElement();
+    }
+
+    public void writeEntityRef(String ent) throws XMLStreamException {
+        delegate.writeEntityRef(ent);
+    }
+
+    public void writeNamespace(String prefix, String uri) throws XMLStreamException {
+        delegate.writeNamespace(prefix, uri);
+    }
+
+    public void writeProcessingInstruction(String target, String data) throws XMLStreamException {
+        delegate.writeProcessingInstruction(target, data);
+    }
+
+    public void writeProcessingInstruction(String target) throws XMLStreamException {
+        delegate.writeProcessingInstruction(target);
+    }
+
+    public void writeStartDocument() throws XMLStreamException {
+        delegate.writeStartDocument();
+    }
+
+    public void writeStartDocument(String encoding, String ver) throws XMLStreamException {
+        delegate.writeStartDocument(encoding, ver);
+    }
+
+    public void writeStartDocument(String ver) throws XMLStreamException {
+        delegate.writeStartDocument(ver);
+    }
+
+    public void writeStartElement(String prefix, String local, String uri) throws XMLStreamException {
+        delegate.writeStartElement(prefix, local, uri);
+    }
+
+    public void writeStartElement(String uri, String local) throws XMLStreamException {
+        delegate.writeStartElement(uri, local);
+    }
+
+    public void writeStartElement(String local) throws XMLStreamException {
+        delegate.writeStartElement(local);
+    }
+
+
+}
diff --git a/distribution/bundle/all/pom.xml b/distribution/bundle/all/pom.xml
index 1524b421ff..382366d73e 100644
--- a/distribution/bundle/all/pom.xml
+++ b/distribution/bundle/all/pom.xml
@@ -261,7 +261,6 @@
                             antlr*;resolution:=optional,
                             com.ibm*;resolution:=optional,
                             com.sun*;resolution:=optional,
-                            javanet.staxutils*;resolution:=optional,
                             javax.jms*;resolution:=optional,
                             javax.ws.rs*;resolution:=optional,
                             repackage;resolution:=optional,
diff --git a/distribution/bundle/jaxrs/pom.xml b/distribution/bundle/jaxrs/pom.xml
index c0cf28a84f..24c9efccef 100644
--- a/distribution/bundle/jaxrs/pom.xml
+++ b/distribution/bundle/jaxrs/pom.xml
@@ -116,7 +116,6 @@
                             antlr*;resolution:=optional,
                             com.ibm*;resolution:=optional,
                             com.sun*;resolution:=optional,
-                            javanet.staxutils*;resolution:=optional,
                             javax.jms*;resolution:=optional,
                             javax.ws.rs*;resolution:=optional,
                             repackage;resolution:=optional,
diff --git a/distribution/bundle/minimal/pom.xml b/distribution/bundle/minimal/pom.xml
index 9280dc8605..9b97faa807 100644
--- a/distribution/bundle/minimal/pom.xml
+++ b/distribution/bundle/minimal/pom.xml
@@ -150,7 +150,6 @@
                             antlr*;resolution:=optional,
                             com.ibm*;resolution:=optional,
                             com.sun*;resolution:=optional,
-                            javanet.staxutils*;resolution:=optional,
                             javax.jms*;resolution:=optional,
                             javax.ws.rs*;resolution:=optional,
                             repackage;resolution:=optional,
diff --git a/parent/pom.xml b/parent/pom.xml
index 1d4047c957..c34b4e34b3 100644
--- a/parent/pom.xml
+++ b/parent/pom.xml
@@ -497,18 +497,6 @@
                     </exclusion>
                 </exclusions>
             </dependency>
-			<dependency>
-				<groupId>net.java.dev.stax-utils</groupId>
-				<artifactId>stax-utils</artifactId>
-				<version>20060502</version>
-				<exclusions>
-					<exclusion>
-						<groupId>com.bea.xml</groupId>
-						<artifactId>jsr173-ri</artifactId>
-					</exclusion>
-				</exclusions>
-			</dependency>
-
             <dependency>
                 <groupId>jaxen</groupId>
                 <artifactId>jaxen</artifactId>
diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/MustUnderstandInterceptor.java b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/MustUnderstandInterceptor.java
index 0a2bb94235..48495fb0f8 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/MustUnderstandInterceptor.java
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/MustUnderstandInterceptor.java
@@ -21,6 +21,7 @@ package org.apache.cxf.binding.soap.interceptor;
 
 import java.net.URI;
 import java.util.HashSet;
+import java.util.List;
 import java.util.ResourceBundle;
 import java.util.Set;
 import java.util.logging.Logger;
@@ -34,11 +35,15 @@ import org.apache.cxf.binding.soap.SoapMessage;
 import org.apache.cxf.binding.soap.SoapVersion;
 import org.apache.cxf.common.i18n.Message;
 import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.common.util.StringUtils;
 import org.apache.cxf.headers.Header;
+import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.interceptor.Interceptor;
 import org.apache.cxf.phase.Phase;
 
 public class MustUnderstandInterceptor extends AbstractSoapInterceptor {
+
+
     private static final Logger LOG = LogUtils.getL7dLogger(MustUnderstandInterceptor.class);
 
     private static final ResourceBundle BUNDLE = LOG.getResourceBundle();
@@ -54,22 +59,35 @@ public class MustUnderstandInterceptor extends AbstractSoapInterceptor {
         SoapVersion soapVersion = soapMessage.getVersion();              
         Set<Header> mustUnderstandHeaders = new HashSet<Header>();
         Set<URI> serviceRoles = new HashSet<URI>();
-        Set<QName> notUnderstandQNames = new HashSet<QName>();
+        Set<Header> notUnderstandHeaders = new HashSet<Header>();
+        Set<Header> ultimateReceiverHeaders = new HashSet<Header>();
         Set<QName> mustUnderstandQNames = new HashSet<QName>();
 
-        buildMustUnderstandHeaders(mustUnderstandHeaders, soapMessage, serviceRoles);
+        buildMustUnderstandHeaders(mustUnderstandHeaders, soapMessage,
+                                   serviceRoles, ultimateReceiverHeaders);
         initServiceSideInfo(mustUnderstandQNames, soapMessage, serviceRoles);
         
-        if (!checkUnderstand(mustUnderstandHeaders, mustUnderstandQNames, notUnderstandQNames)) {
+        if (!checkUnderstand(mustUnderstandHeaders, mustUnderstandQNames,
+                             notUnderstandHeaders)) {
             StringBuffer sb = new StringBuffer(300);
-            int pos = 0;
-            for (QName qname : notUnderstandQNames) {
-                pos = pos + qname.toString().length() + 2;
-                sb.append(qname.toString() + ", ");
+            boolean first = true;
+            for (Header head : notUnderstandHeaders) {
+                if (first) {
+                    first = false;
+                } else {
+                    sb.append(", ");
+                }
+                sb.append(head.getName().toString());
             }
-            sb.delete(pos - 2, pos);
-            throw new SoapFault(new Message("MUST_UNDERSTAND", BUNDLE, sb.toString()),
+            if (sb.length() > 0) {
+                throw new SoapFault(new Message("MUST_UNDERSTAND", BUNDLE, sb.toString()),
                                 soapVersion.getMustUnderstand());
+            }
+        }
+        if (!ultimateReceiverHeaders.isEmpty()) {
+            soapMessage.getInterceptorChain()
+                .add(new UltimateReceiverMustUnderstandInterceptor(ultimateReceiverHeaders,
+                                                                   mustUnderstandQNames));
         }
     }
 
@@ -98,15 +116,17 @@ public class MustUnderstandInterceptor extends AbstractSoapInterceptor {
 
     private void buildMustUnderstandHeaders(Set<Header> mustUnderstandHeaders,
                                             SoapMessage soapMessage,
-                                            Set<URI> serviceRoles) {
+                                            Set<URI> serviceRoles,
+                                            Set<Header> ultimateReceiverHeaders) {
         for (Header header : soapMessage.getHeaders()) {
             if (header instanceof SoapHeader && ((SoapHeader)header).isMustUnderstand()) {
                 String role = ((SoapHeader)header).getActor();
-                if (role != null) {
+                if (!StringUtils.isEmpty(role)) {
                     role = role.trim();
-                    if (role.equals(soapMessage.getVersion().getNextRole())
-                                    || role.equals(soapMessage.getVersion().getUltimateReceiverRole())) {
+                    if (role.equals(soapMessage.getVersion().getNextRole())) {
                         mustUnderstandHeaders.add(header);
+                    } else if (role.equals(soapMessage.getVersion().getUltimateReceiverRole())) {
+                        ultimateReceiverHeaders.add(header);                        
                     } else {
                         for (URI roleFromBinding : serviceRoles) {
                             if (role.equals(roleFromBinding.toString())) {
@@ -117,7 +137,7 @@ public class MustUnderstandInterceptor extends AbstractSoapInterceptor {
                 } else {
                     // if role omitted, the soap node is ultimate receiver,
                     // needs to understand
-                    mustUnderstandHeaders.add(header);
+                    ultimateReceiverHeaders.add(header);
                 }
             }
         }
@@ -125,17 +145,64 @@ public class MustUnderstandInterceptor extends AbstractSoapInterceptor {
 
     private boolean checkUnderstand(Set<Header> mustUnderstandHeaders,
                                     Set<QName> mustUnderstandQNames,
-                                    Set<QName> notUnderstandQNames) {
+                                    Set<Header> notUnderstandHeaders) {
 
         for (Header header : mustUnderstandHeaders) {
             QName qname = header.getName();
             if (!mustUnderstandQNames.contains(qname)) {
-                notUnderstandQNames.add(qname);
+                notUnderstandHeaders.add(header);
             }
         }
-        if (notUnderstandQNames.size() > 0) {
+        if (notUnderstandHeaders.size() > 0) {
             return false;
         }
         return true;
     }
+    
+    
+    
+    /**
+     * 
+     */
+    private class UltimateReceiverMustUnderstandInterceptor extends AbstractSoapInterceptor {
+        Set<Header> ultimateReceiverHeaders;
+        Set<QName> knownHeaders;
+        public UltimateReceiverMustUnderstandInterceptor(Set<Header> ult,
+                                                         Set<QName> knownHeaders) {
+            super(Phase.INVOKE);
+            this.knownHeaders = knownHeaders;
+            ultimateReceiverHeaders = ult;
+        }
+        public void handleMessage(SoapMessage soapMessage) throws Fault {
+            SoapVersion soapVersion = soapMessage.getVersion();
+            Set<Header> notFound = new HashSet<Header>();
+            List<Header> heads = soapMessage.getHeaders();
+            for (Header header : ultimateReceiverHeaders) {
+                if (heads.contains(header)
+                    && header.getDirection() == Header.Direction.DIRECTION_IN
+                    && !knownHeaders.contains(header.getName())) {
+                    notFound.add(header);
+                }
+            }
+            
+            
+            if (!notFound.isEmpty()) {
+                StringBuffer sb = new StringBuffer(300);
+                boolean first = true;
+                for (Header head : notFound) {
+                    if (first) {
+                        first = false;
+                    } else {
+                        sb.append(", ");
+                    }
+                    sb.append(head.getName().toString());
+                }
+                if (sb.length() > 0) {
+                    throw new SoapFault(new Message("MUST_UNDERSTAND", BUNDLE, sb.toString()),
+                                    soapVersion.getMustUnderstand());
+                }
+            }            
+        }
+
+    }
 }
diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/ReadHeadersInterceptor.java b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/ReadHeadersInterceptor.java
index ebdab665e6..5926aff3ec 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/ReadHeadersInterceptor.java
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/ReadHeadersInterceptor.java
@@ -43,6 +43,7 @@ import org.apache.cxf.binding.soap.SoapVersion;
 import org.apache.cxf.binding.soap.SoapVersionFactory;
 import org.apache.cxf.common.i18n.Message;
 import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.common.util.StringUtils;
 import org.apache.cxf.databinding.DataBinding;
 import org.apache.cxf.headers.HeaderManager;
 import org.apache.cxf.headers.HeaderProcessor;
@@ -160,8 +161,10 @@ public class ReadHeadersInterceptor extends AbstractSoapInterceptor {
                                                           soapVersion.getAttrNameMustUnderstand());
                             String act = hel.getAttributeNS(soapVersion.getNamespace(),
                                                             soapVersion.getAttrNameRole());
-                            
-                            shead.setActor(act);
+
+                            if (!StringUtils.isEmpty(act)) {
+                                shead.setActor(act);
+                            }
                             shead.setMustUnderstand(Boolean.valueOf(mu) || "1".equals(mu));
                             //mark header as inbound header.(for distinguishing between the  direction to 
                             //avoid piggybacking of headers from request->server->response.
diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapOutInterceptor.java b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapOutInterceptor.java
index da647d0602..b7ebe6c021 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapOutInterceptor.java
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapOutInterceptor.java
@@ -31,10 +31,12 @@ import org.w3c.dom.Element;
 
 import org.apache.cxf.Bus;
 import org.apache.cxf.binding.soap.SoapFault;
+import org.apache.cxf.binding.soap.SoapHeader;
 import org.apache.cxf.binding.soap.SoapMessage;
 import org.apache.cxf.binding.soap.SoapVersion;
 import org.apache.cxf.binding.soap.model.SoapHeaderInfo;
 import org.apache.cxf.common.i18n.BundleUtils;
+import org.apache.cxf.common.util.StringUtils;
 import org.apache.cxf.databinding.DataBinding;
 import org.apache.cxf.databinding.DataWriter;
 import org.apache.cxf.headers.Header;
@@ -52,6 +54,7 @@ import org.apache.cxf.service.model.BindingMessageInfo;
 import org.apache.cxf.service.model.BindingOperationInfo;
 import org.apache.cxf.service.model.MessagePartInfo;
 import org.apache.cxf.service.model.ServiceModelUtil;
+import org.apache.cxf.staxutils.DelegatingXMLStreamWriter;
 import org.apache.cxf.staxutils.StaxUtils;
 
 public class SoapOutInterceptor extends AbstractSoapInterceptor {
@@ -87,8 +90,8 @@ public class SoapOutInterceptor extends AbstractSoapInterceptor {
         message.getInterceptorChain().add(new SoapOutEndingInterceptor());
     }
     
-    private void writeSoapEnvelopeStart(SoapMessage message) {
-        SoapVersion soapVersion = message.getVersion();
+    private void writeSoapEnvelopeStart(final SoapMessage message) {
+        final SoapVersion soapVersion = message.getVersion();
         try {            
             XMLStreamWriter xtw = message.getContent(XMLStreamWriter.class);
             xtw.setPrefix(soapVersion.getPrefix(), soapVersion.getNamespace());
@@ -105,6 +108,11 @@ public class SoapOutInterceptor extends AbstractSoapInterceptor {
                                       soapVersion.getNamespace());   
                 List<Header> hdrList = message.getHeaders();
                 for (Header header : hdrList) {
+                    XMLStreamWriter writer = xtw;
+                    if (header instanceof SoapHeader) {
+                        SoapHeader soapHeader = (SoapHeader)header;
+                        writer = new SOAPHeaderWriter(xtw, soapHeader, soapVersion);
+                    }
                     DataBinding b = header.getDataBinding();
                     if (b == null) {
                         HeaderProcessor hp = bus.getExtension(HeaderManager.class)
@@ -114,11 +122,13 @@ public class SoapOutInterceptor extends AbstractSoapInterceptor {
                         }
                     }
                     if (b != null) {
+                        MessagePartInfo part = new MessagePartInfo(header.getName(), null);
+                        part.setConcreteName(header.getName());
                         b.createWriter(XMLStreamWriter.class)
-                            .write(header.getObject(), xtw);
+                            .write(header.getObject(), part, writer);
                     } else {
                         Element node = (Element)header.getObject();
-                        StaxUtils.copy(node, xtw);
+                        StaxUtils.copy(node, writer);
                     }
                 }
             }
@@ -245,6 +255,71 @@ public class SoapOutInterceptor extends AbstractSoapInterceptor {
                                     soapVersion.getSender());
             }
         }
-
-    }    
+    }
+    
+    public static class SOAPHeaderWriter extends DelegatingXMLStreamWriter {
+        final SoapHeader soapHeader;
+        final SoapVersion soapVersion;
+        boolean firstDone;
+        
+        public SOAPHeaderWriter(XMLStreamWriter writer,
+                                SoapHeader header,
+                                SoapVersion version) {
+            super(writer);
+            soapHeader = header;
+            soapVersion = version;
+        }
+        
+        public void writeAttribute(String prefix, String uri, String local, String value)
+            throws XMLStreamException {
+            if (soapVersion.getNamespace().equals(uri)
+                && (local.equals(soapVersion.getAttrNameMustUnderstand())
+                    || local.equals(soapVersion.getAttrNameRole()))) {
+                return;
+            }
+            super.writeAttribute(prefix, uri, local, value);
+        }
+        public void writeAttribute(String uri, String local, String value) throws XMLStreamException {
+            if (soapVersion.getNamespace().equals(uri)
+                && (local.equals(soapVersion.getAttrNameMustUnderstand())
+                    || local.equals(soapVersion.getAttrNameRole()))) {
+                return;
+            }
+            super.writeAttribute(uri, local, value);
+        }
+        
+        private void writeSoapAttributes() throws XMLStreamException {
+            if (!firstDone) {
+                firstDone = true;
+                if (!StringUtils.isEmpty(soapHeader.getActor())) {
+                    super.writeAttribute(soapVersion.getPrefix(),
+                                   soapVersion.getNamespace(),
+                                   soapVersion.getAttrNameRole(),
+                                   soapHeader.getActor());
+                }
+                if (soapHeader.isMustUnderstand()) {
+                    super.writeAttribute(soapVersion.getPrefix(),
+                                   soapVersion.getNamespace(),
+                                   soapVersion.getAttrNameMustUnderstand(),
+                                   "true");                                        
+                }
+            }
+        }
+        public void writeStartElement(String arg0, String arg1, String arg2)
+            throws XMLStreamException {
+            super.writeStartElement(arg0, arg1, arg2);
+            writeSoapAttributes();
+        }
+        public void writeStartElement(String arg0, String arg1)
+            throws XMLStreamException {
+            super.writeStartElement(arg0, arg1);
+            writeSoapAttributes();
+        }
+        public void writeStartElement(String arg0) throws XMLStreamException {
+            super.writeStartElement(arg0);
+            writeSoapAttributes();
+        }
+        
+        
+    };
 }
diff --git a/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/TestBase.java b/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/TestBase.java
index a1cf0f1850..b27e8474c3 100644
--- a/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/TestBase.java
+++ b/rt/bindings/soap/src/test/java/org/apache/cxf/binding/soap/TestBase.java
@@ -69,6 +69,7 @@ public class TestBase extends Assert {
         phases.add(phase2);
         phases.add(phase3);
         phases.add(phase4);
+        phases.add(new Phase(Phase.INVOKE, 5));
         chain = new PhaseInterceptorChain(phases);
 
         soapMessage = TestUtil.createEmptySoapMessage(Soap11.getInstance(), chain);
diff --git a/rt/databinding/aegis/pom.xml b/rt/databinding/aegis/pom.xml
index 534498712b..49514fad68 100644
--- a/rt/databinding/aegis/pom.xml
+++ b/rt/databinding/aegis/pom.xml
@@ -83,17 +83,6 @@
             <artifactId>jdom</artifactId>
             <version>${jdom.version}</version>
         </dependency>
-        <dependency>
-            <groupId>net.java.dev.stax-utils</groupId>
-            <artifactId>stax-utils</artifactId>
-            <version>20060502</version>
-            <exclusions>
-                <exclusion>
-                    <groupId>com.bea.xml</groupId>
-                    <artifactId>jsr173-ri</artifactId>
-                </exclusion>
-            </exclusions>
-        </dependency>
         <dependency>
             <groupId>jaxen</groupId>
             <artifactId>jaxen</artifactId>
diff --git a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/xml/SourceType.java b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/xml/SourceType.java
index 46f2922309..d44dab4c85 100644
--- a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/xml/SourceType.java
+++ b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/xml/SourceType.java
@@ -24,8 +24,6 @@ import javax.xml.stream.XMLStreamReader;
 import javax.xml.stream.XMLStreamWriter;
 import javax.xml.transform.Source;
 import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.transform.stream.StreamSource;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
@@ -34,8 +32,6 @@ import org.xml.sax.SAXException;
 import org.xml.sax.XMLReader;
 import org.xml.sax.helpers.XMLReaderFactory;
 
-import javanet.staxutils.ContentHandlerToXMLStreamWriter;
-
 import org.apache.cxf.aegis.Context;
 import org.apache.cxf.aegis.DatabindingException;
 import org.apache.cxf.aegis.type.Type;
@@ -101,24 +97,8 @@ public class SourceType extends Type {
             }
 
             StaxUtils.writeElement(element, writer, false);
-        } else if (object instanceof SAXSource) {
-            SAXSource source = (SAXSource)object;
-
-            try {
-                XMLReader xmlReader = source.getXMLReader();
-                if (xmlReader == null) {
-                    xmlReader = createXMLReader();
-                }
-
-                xmlReader.setContentHandler(new FilteringContentHandlerToXMLStreamWriter(writer));
-
-                xmlReader.parse(source.getInputSource());
-            } catch (Exception e) {
-                throw new DatabindingException("Could not send xml.", e);
-            }
-        } else if (object instanceof StreamSource) {
-            StreamSource ss = (StreamSource)object;
-            XMLStreamReader reader = StaxUtils.createXMLStreamReader(ss.getInputStream(), null);
+        } else {
+            XMLStreamReader reader = StaxUtils.createXMLStreamReader((Source)object);
             StaxUtils.copy(reader, writer);
         }
     }
@@ -136,17 +116,4 @@ public class SourceType extends Type {
         }
     }
 
-    class FilteringContentHandlerToXMLStreamWriter extends ContentHandlerToXMLStreamWriter {
-        public FilteringContentHandlerToXMLStreamWriter(XMLStreamWriter xmlStreamWriter) {
-            super(xmlStreamWriter);
-        }
-
-        @Override
-        public void startDocument() throws SAXException {
-        }
-
-        @Override
-        public void endDocument() throws SAXException {
-        }
-    }
 }
diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBEncoderDecoder.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBEncoderDecoder.java
index 3bf67daa61..685036313d 100644
--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBEncoderDecoder.java
+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBEncoderDecoder.java
@@ -158,6 +158,8 @@ public final class JAXBEncoderDecoder {
                            && part.getTypeQName().getLocalPart().equals("hexBinary")) {
                     mObj = new HexBinaryAdapter().marshal((byte[])mObj);
                     writeObject(marshaller, source, new JAXBElement(elName, String.class, mObj));
+                } else if (mObj instanceof JAXBElement) {
+                    writeObject(marshaller, source, mObj);
                 } else {
                     writeObject(marshaller, source, new JAXBElement(elName, cls, mObj));
                 }
diff --git a/rt/javascript/pom.xml b/rt/javascript/pom.xml
index 090dc001f3..4fe3dd902a 100755
--- a/rt/javascript/pom.xml
+++ b/rt/javascript/pom.xml
@@ -68,10 +68,6 @@
             <artifactId>jdom</artifactId>
             <version>${jdom.version}</version>
         </dependency>
-        <dependency>
-            <groupId>net.java.dev.stax-utils</groupId>
-            <artifactId>stax-utils</artifactId>
-        </dependency>
         <dependency>
             <groupId>jaxen</groupId>
             <artifactId>jaxen</artifactId>
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
index d8cac7e571..69aeec73a8 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
@@ -116,6 +116,13 @@ public class MAPCodec extends AbstractSoapInterceptor {
      * @param message the messsage message
      */
     public void handleFault(SoapMessage message) {
+        AddressingProperties maps = ContextUtils.retrieveMAPs(message, false, true, false);
+        if (ContextUtils.isRequestor(message) 
+            && !message.getExchange().isOneWay()
+            && maps != null) {
+            //fault occured trying to sent the message, remove it
+            uncorrelatedExchanges.remove(maps.getMessageID().getValue());
+        }
     }
 
     /**
diff --git a/systests/src/test/java/org/apache/cxf/systest/outofband/header/OOBHdrServiceImpl.java b/systests/src/test/java/org/apache/cxf/systest/outofband/header/OOBHdrServiceImpl.java
index b6ece83870..b86af63062 100644
--- a/systests/src/test/java/org/apache/cxf/systest/outofband/header/OOBHdrServiceImpl.java
+++ b/systests/src/test/java/org/apache/cxf/systest/outofband/header/OOBHdrServiceImpl.java
@@ -104,35 +104,36 @@ public class OOBHdrServiceImpl implements PutLastTradedPricePortType {
         MessageContext ctx = context == null ? null : context.getMessageContext();
         if (ctx.containsKey(Header.HEADER_LIST)) {
             List oobHdr = (List) ctx.get(Header.HEADER_LIST);
-            
-            if (oobHdr instanceof List) {
-                Iterator iter = oobHdr.iterator();
-                while (iter.hasNext()) {
-                    Object hdr = iter.next();
-                    if (hdr instanceof Header && ((Header) hdr).getObject() instanceof Node) {
-                        Header hdr1 = (Header) hdr;
-                        //System.out.println("Node conains : " + hdr1.getObject().toString());
-                        try {
-                            JAXBElement job = (JAXBElement) JAXBContext.newInstance(ObjectFactory.class)
-                                .createUnmarshaller()
-                                .unmarshal((Node) hdr1.getObject());
-                            OutofBandHeader ob = (OutofBandHeader) job.getValue();
-                            if ("testOobHeader".equals(ob.getName())
-                                && "testOobHeaderValue".equals(ob.getValue())
-                                && "testHdrAttribute".equals(ob.getHdrAttribute())) {
+            Iterator iter = oobHdr.iterator();
+            while (iter.hasNext()) {
+                Object hdr = iter.next();
+                if (hdr instanceof Header && ((Header) hdr).getObject() instanceof Node) {
+                    Header hdr1 = (Header) hdr;
+                    //System.out.println("Node conains : " + hdr1.getObject().toString());
+                    try {
+                        JAXBElement job = (JAXBElement) JAXBContext.newInstance(ObjectFactory.class)
+                            .createUnmarshaller()
+                            .unmarshal((Node) hdr1.getObject());
+                        OutofBandHeader ob = (OutofBandHeader) job.getValue();
+                        if ("testOobHeader".equals(ob.getName())
+                            && "testOobHeaderValue".equals(ob.getValue())) { 
+                            if ("testHdrAttribute".equals(ob.getHdrAttribute())) {
+                                success = true;
+                                iter.remove(); //mark it processed
+                            } else if ("dontProcess".equals(ob.getHdrAttribute())) {
+                                //we won't remove it so we won't let the runtime know
+                                //it's processed.   It SHOULD throw an exception 
+                                //saying the mustunderstand wasn't processed
                                 success = true;
-                            } else {
-                                throw new RuntimeException("test failed");
                             }
-                        } catch (JAXBException ex) {
-                            //
-                            ex.printStackTrace();
+                        } else {
+                            throw new RuntimeException("test failed");
                         }
+                    } catch (JAXBException ex) {
+                        //
+                        ex.printStackTrace();
                     }
                 }
-            } else {
-                throw new RuntimeException("Header should not be null"
-                                           + "and should be of type JAXBHeaderHolder");
             }
         } else {
             throw new RuntimeException("MessageContext is null or doesnot contain OOBHeaders");
diff --git a/systests/src/test/java/org/apache/cxf/systest/outofband/header/OOBHeaderTest.java b/systests/src/test/java/org/apache/cxf/systest/outofband/header/OOBHeaderTest.java
index 79fb96e372..6c676bc4e6 100644
--- a/systests/src/test/java/org/apache/cxf/systest/outofband/header/OOBHeaderTest.java
+++ b/systests/src/test/java/org/apache/cxf/systest/outofband/header/OOBHeaderTest.java
@@ -38,6 +38,7 @@ import org.w3c.dom.Node;
 
 import org.apache.cxf.BusFactory;
 
+import org.apache.cxf.binding.soap.SoapHeader;
 import org.apache.cxf.bus.spring.SpringBusFactory;
 import org.apache.cxf.headers.Header;
 import org.apache.cxf.jaxb.JAXBDataBinding;
@@ -78,7 +79,7 @@ public class OOBHeaderTest extends AbstractBusClientServerTestBase {
         assertTrue("server did not launch correctly", launchServer(Server.class, true));
     }
     
-    private void addOutOfBoundHeader(PutLastTradedPricePortType portType) {
+    private void addOutOfBoundHeader(PutLastTradedPricePortType portType, boolean invalid) {
         InvocationHandler handler  = Proxy.getInvocationHandler(portType);
         BindingProvider  bp = null;
 
@@ -90,14 +91,13 @@ public class OOBHeaderTest extends AbstractBusClientServerTestBase {
                 OutofBandHeader ob = new OutofBandHeader();
                 ob.setName("testOobHeader");
                 ob.setValue("testOobHeaderValue");
-                ob.setHdrAttribute("testHdrAttribute");
+                ob.setHdrAttribute(invalid ? "dontProcess" : "testHdrAttribute");
 
-                JAXBElement<OutofBandHeader> job = new JAXBElement<OutofBandHeader>(
-                        new QName(TEST_HDR_NS, TEST_HDR_REQUEST_ELEM), OutofBandHeader.class, null, ob);
-                Header hdr = new Header(
+                SoapHeader hdr = new SoapHeader(
                         new QName(TEST_HDR_NS, TEST_HDR_REQUEST_ELEM), 
-                        job, 
+                        ob, 
                         new JAXBDataBinding(ob.getClass()));
+                hdr.setMustUnderstand(true);
 
                 List<Header> holder = new ArrayList<Header>();
                 holder.add(hdr);
@@ -182,10 +182,16 @@ public class OOBHeaderTest extends AbstractBusClientServerTestBase {
         priceData.setTickerSymbol("CELTIX");
         Holder<TradePriceData> holder = new Holder<TradePriceData>(priceData);
         
-        addOutOfBoundHeader(putLastTradedPrice);
-        
+        addOutOfBoundHeader(putLastTradedPrice, false);
         putLastTradedPrice.sayHi(holder);
-        
         checkReturnedOOBHeader(putLastTradedPrice);
+        
+        addOutOfBoundHeader(putLastTradedPrice, true);
+        try {
+            putLastTradedPrice.sayHi(holder);
+            fail("mustUnderstand header should not have been processed");
+        } catch (Exception ex) {
+            assertTrue(ex.getMessage().contains("Can not understand"));
+        }
     }
 }
