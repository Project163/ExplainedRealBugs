diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/ConfigurableImpl.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/ConfigurableImpl.java
index 4abfed5824..fe2427a7b7 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/ConfigurableImpl.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/ConfigurableImpl.java
@@ -20,6 +20,7 @@
 package org.apache.cxf.jaxrs.impl;
 
 import java.util.Arrays;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -71,17 +72,40 @@ public class ConfigurableImpl<C extends Configurable<C>> implements Configurable
 
     static Class<?>[] getImplementedContracts(Object provider, Class<?>[] restrictedClasses) {
         Class<?> providerClass = provider instanceof Class<?> ? ((Class<?>)provider) : provider.getClass();
-        Set<Class<?>> interfaces = Arrays.stream(providerClass.getInterfaces()).collect(Collectors.toSet());
-        providerClass = providerClass.getSuperclass();
-        for (; providerClass != null && providerClass != Object.class; providerClass = providerClass.getSuperclass()) {
-            interfaces.addAll(Arrays.stream(providerClass.getInterfaces()).collect(Collectors.toSet()));
-        }
+
+        Set<Class<?>> interfaces = collectAllInterfaces(providerClass);
+
         List<Class<?>> implementedContracts = interfaces.stream()
             .filter(el -> Arrays.stream(restrictedClasses).noneMatch(el::equals))
             .collect(Collectors.toList());
+
         return implementedContracts.toArray(new Class<?>[]{});
     }
-    
+
+    private static Set<Class<?>> collectAllInterfaces(Class<?> providerClass) {
+        Set<Class<?>> interfaces = new HashSet<>();
+        do {
+            for (Class<?> anInterface : providerClass.getInterfaces()) {
+                collectInterfaces(interfaces, anInterface);
+            }
+            providerClass = providerClass.getSuperclass();
+        } while (providerClass != null && providerClass != Object.class);
+
+        return interfaces;
+    }
+
+    /**
+     * internal helper function to recursively collect Interfaces.
+     * This is needed since {@link Class#getInterfaces()} does only return directly implemented Interfaces,
+     * But not the ones derived from those classes.
+     */
+    private static void collectInterfaces(Set<Class<?>> interfaces, Class<?> anInterface) {
+        interfaces.add(anInterface);
+        for (Class<?> superInterface : anInterface.getInterfaces()) {
+            collectInterfaces(interfaces, superInterface);
+        }
+    }
+
     protected C getConfigurable() {
         return configurable;
     }
diff --git a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/ConfigurationImplTest.java b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/ConfigurationImplTest.java
index 0e43f05e3d..09938810dd 100644
--- a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/ConfigurationImplTest.java
+++ b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/ConfigurationImplTest.java
@@ -180,6 +180,24 @@ public class ConfigurationImplTest extends Assert {
         }
     }
 
+    public interface MyClientFilter extends ClientRequestFilter, ClientResponseFilter {
+        // reduced to just the intermediate layer. Could contain user code
+    }
+
+    public static class NestedInterfaceTestFilter implements MyClientFilter {
+
+        @Override
+        public void filter(ClientRequestContext requestContext) throws IOException {
+            // no-op
+        }
+
+        @Override
+        public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext)
+                throws IOException {
+            // no-op
+        }
+    }
+
     private Client createClientProxy() {
         return (Client) Proxy.newProxyInstance(this.getClass().getClassLoader(), 
             new Class<?>[]{Client.class},
@@ -215,6 +233,16 @@ public class ConfigurationImplTest extends Assert {
         assertFalse(contracts.containsKey(ContainerResponseFilter.class));
     }
 
+    @Test
+    public void testClientFilterWithNestedInterfacesIsAccepted() {
+        Configurable<Client> configurable = new ConfigurableImpl<>(createClientProxy(), RuntimeType.CLIENT);
+        Configuration config = configurable.getConfiguration();
+        configurable.register(NestedInterfaceTestFilter.class);
+        Map<Class<?>, Integer> contracts = config.getContracts(NestedInterfaceTestFilter.class);
+        assertTrue(contracts.containsKey(ClientRequestFilter.class));
+        assertTrue(contracts.containsKey(ClientResponseFilter.class));
+    }
+
     @Test
     public void testClientFilterContractsOnServerFeatureIsRejected() {
         FeatureContextImpl featureContext = new FeatureContextImpl();
