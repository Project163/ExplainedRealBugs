diff --git a/api/pom.xml b/api/pom.xml
index 9d6e5caca2..e18c0893b0 100644
--- a/api/pom.xml
+++ b/api/pom.xml
@@ -73,6 +73,10 @@
             <groupId>org.apache.geronimo.specs</groupId>
             <artifactId>geronimo-annotation_1.0_spec</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.geronimo.specs</groupId>
+            <artifactId>geronimo-j2ee-connector_1.5_spec</artifactId>
+        </dependency>
         <dependency>
             <groupId>org.codehaus.woodstox</groupId>
             <artifactId>wstx-asl</artifactId>
diff --git a/api/src/main/java/org/apache/cxf/jca/outbound/CXFConnection.java b/api/src/main/java/org/apache/cxf/jca/outbound/CXFConnection.java
new file mode 100644
index 0000000000..097dab862a
--- /dev/null
+++ b/api/src/main/java/org/apache/cxf/jca/outbound/CXFConnection.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jca.outbound;
+
+/**
+ * A CXFConnection is obtains from {@link CXFConnectionFactory}.  It provides
+ * access to a CXF web service for client to invoke.  The client should close
+ * the CxfConnection when the web service is no longer needed.
+ */
+
+public interface CXFConnection {
+    
+    /**
+     * Retrieves a service object to invoke.  The serviceInterface class must
+     * match the serviceClass in the CXFConnectionSpec that is used to
+     * obtain this CXFConnection.  Application can continue to use the service
+     * object after the the connection has been closed by calling {@link #close()}.
+     * 
+     * @param <T>
+     * @param serviceClass
+     * @return service object
+     * @throws Exception
+     */
+    <T> T getService(Class<T> serviceClass) throws Exception;
+    
+    /**
+     * Closes the connection handle. A caller should not use a closed connection.
+     * 
+     * @throws Exception if an error occurs during close.
+     */
+    void close() throws Exception;
+
+
+}
diff --git a/api/src/main/java/org/apache/cxf/jca/outbound/CXFConnectionFactory.java b/api/src/main/java/org/apache/cxf/jca/outbound/CXFConnectionFactory.java
new file mode 100644
index 0000000000..06064d706a
--- /dev/null
+++ b/api/src/main/java/org/apache/cxf/jca/outbound/CXFConnectionFactory.java
@@ -0,0 +1,48 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jca.outbound;
+
+import java.io.Serializable;
+
+import javax.resource.Referenceable;
+import javax.resource.ResourceException;
+
+
+/**
+ * Provides methods to create a {@link CXFConnection} object that provides access
+ * to a Web Service defined from the supplied specifications.  A CXFConnectionFactory 
+ * is returned from an environment naming context JNDI lookup by the Application 
+ * Server.
+ */
+public interface CXFConnectionFactory extends Serializable, Referenceable  {
+    
+    /**
+     * Creates a CXFConnection object which allows access to CXF web service based on 
+     * the CXFConnectionSpec object.  Required CXFConnectionSpec fields are wsdlURL, 
+     * serviceClass, endpointName, and serviceName.  Each connection returned by this 
+     * method MUST be closed by calling the {@link CXFConnection#close()} when it is no 
+     * longer needed.  
+     * 
+     * @param spec
+     * @return CXFConnection 
+     * @throws ResourceException
+     */
+    CXFConnection getConnection(CXFConnectionSpec spec) throws ResourceException;
+
+}
diff --git a/api/src/main/java/org/apache/cxf/jca/outbound/CXFConnectionSpec.java b/api/src/main/java/org/apache/cxf/jca/outbound/CXFConnectionSpec.java
new file mode 100644
index 0000000000..3c33ab0eaa
--- /dev/null
+++ b/api/src/main/java/org/apache/cxf/jca/outbound/CXFConnectionSpec.java
@@ -0,0 +1,193 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jca.outbound;
+
+import java.net.URL;
+
+import javax.resource.spi.ConnectionRequestInfo;
+import javax.xml.namespace.QName;
+
+import org.apache.commons.lang.ObjectUtils;
+
+/**
+ *
+ * The CXFConnectionSpec contains properties that needed for obtaining
+ * a {@link CXFConnection}.
+ */
+public class CXFConnectionSpec implements ConnectionRequestInfo {
+        
+    private Class<?> serviceClass;
+    private URL wsdlURL;
+    private URL busConfigURL;
+    private QName serviceName;
+    private QName endpointName;
+    private String address;
+    
+    /**
+     * @return the serviceClass
+     */
+    public Class<?> getServiceClass() {
+        return serviceClass;
+    }
+    /**
+     * @param serviceClass the serviceClass to set
+     */
+    public void setServiceClass(Class<?> serviceClass) {
+        this.serviceClass = serviceClass;
+    }
+    /**
+     * @return the wsdlURL
+     */
+    public URL getWsdlURL() {
+        return wsdlURL;
+    }
+    /**
+     * @param wsdlURL the wsdlURL to set
+     */
+    public void setWsdlURL(URL wsdlURL) {
+        this.wsdlURL = wsdlURL;
+    }
+    /**
+     * @return the busConfigURL
+     */
+    public URL getBusConfigURL() {
+        return busConfigURL;
+    }
+    /**
+     * @param busConfigURL the busConfigURL to set
+     */
+    public void setBusConfigURL(URL busConfigURL) {
+        this.busConfigURL = busConfigURL;
+    }
+    /**
+     * @return the serviceName
+     */
+    public QName getServiceName() {
+        return serviceName;
+    }
+    /**
+     * @param serviceName the serviceName to set
+     */
+    public void setServiceName(QName serviceName) {
+        this.serviceName = serviceName;
+    }
+    /**
+     * @return the endpointName
+     */
+    public QName getEndpointName() {
+        return endpointName;
+    }
+    /**
+     * @param endpointName the endpointName to set
+     */
+    public void setEndpointName(QName endpointName) {
+        this.endpointName = endpointName;
+    }
+    /**
+     * @return the address
+     */
+    public String getAddress() {
+        return address;
+    }
+    /**
+     * @param address the address to set
+     */
+    public void setAddress(String address) {
+        this.address = address;
+    }
+    
+    // Required by JCA Spec 
+    public boolean equals(Object other) {
+        if (!this.getClass().isAssignableFrom(other.getClass())) {
+            return false;
+        }
+        
+        CXFConnectionSpec that = (CXFConnectionSpec)other;
+        
+        if (!ObjectUtils.equals(that.getWsdlURL(), wsdlURL)) {
+            return false;
+        }
+        
+        if (!ObjectUtils.equals(that.getBusConfigURL(), busConfigURL)) {
+            return false;
+        }
+        
+        if (!ObjectUtils.equals(that.getServiceClass(), serviceClass)) {
+            return false;
+        }
+        
+        if (!ObjectUtils.equals(that.getServiceName(), serviceName)) {
+            return false;
+        }
+        
+        if (!ObjectUtils.equals(that.getEndpointName(), endpointName)) {
+            return false;
+        }
+        
+        if (!ObjectUtils.equals(that.getAddress(), address)) {
+            return false;
+        }
+ 
+        return true;
+    }
+
+    // Required by JCA Spec
+    public int hashCode() {
+        int retval = 0;
+        
+        if (wsdlURL != null) {
+            retval += wsdlURL.hashCode();
+        }
+        
+        if (busConfigURL != null) {
+            retval += busConfigURL.hashCode();
+        }
+        
+        if (serviceClass != null) {
+            retval += serviceClass.hashCode();
+        }
+        
+        if (serviceName != null) {
+            retval += serviceName.hashCode();
+        }
+        
+        if (endpointName != null) {
+            retval += endpointName.hashCode();
+        }
+        
+        if (address != null) {
+            retval += address.hashCode();
+        }
+        
+        return retval;
+    
+    }
+
+    public String toString() {
+        StringBuffer buf = new StringBuffer();
+        buf.append("serviceName=" + serviceName);
+        buf.append(",endpointName=" + endpointName);
+        buf.append(",wsdlURL=" + wsdlURL);
+        buf.append(",busConfigURL=" + busConfigURL);
+        buf.append(",serviceClass=" + serviceClass);
+        buf.append(",address=" + address);
+        return buf.toString();
+    }
+    
+}
diff --git a/distribution/src/main/release/samples/integration/jca/outbound.was61/README.txt b/distribution/src/main/release/samples/integration/jca/outbound.was61/README.txt
new file mode 100644
index 0000000000..2ea90a7950
--- /dev/null
+++ b/distribution/src/main/release/samples/integration/jca/outbound.was61/README.txt
@@ -0,0 +1,277 @@
+CXF OUTBOUND RESOURCE ADAPTER IBM WEBSPHERE 6.1 SAMPLE
+======================================================
+
+This sample demonstrates the new CXF outbound resource adapter.  Notice that
+it does not use the ra.xml file located in <CXF_HOME>/etc directory as does 
+the old outbound sample.  Instead, it uses the ra.xml file in the sample's 
+etc directory.  You may notice in ra.xml file that the new outbound connect-
+ion classes have a new package name: org.apache.cxf.jca.outbound.  The APIs 
+for new outbound resource adapter use that package name.  
+
+The src/demo/servlet/HelloWorldServlet.java source file illustrates how to 
+invoke the CXF outbound connector APIs.
+
+The RAR deployment descriptor used in this demo is only configured to enable
+outbound connection for clarity.  It is perfectly fine to configure inbound 
+and outbound connector in the same RAR file.
+
+The README.txt (this file) provides detailed instructions to run the sample 
+in IBM WebSphere 6.1.  However, the cxf.rar and helloworld.war files built 
+by this sample can be deployed to other application servers as well.  Please
+consult application server vendor's documentation for instructions to deploy 
+in other application server environment.
+
+In this sample, you will first build a resource adapter RAR file.  Next, you 
+will create a web application and compile a WAR file.  Upon receiving a 
+request, the web application will make outgoing calls to a CXF web service, 
+gather results, and send responses to the client.
+
+The web application is a Servlet that accepts a HTTP request.  It then looks 
+up a CXFConnectoryFactory from the application server's JNDI registry.  The 
+CXFConnectoryFactory is the entry point to gain access to CXF web service.   
+The application calls the getConnection() method and gets back a 
+CXFConnection.  With a CXFConnection, the application can get the web service
+client by calling the getService() method.  The application must close the 
+CXFConnection but the it can continue to use the web service client after the 
+connection has been closed.
+
+The sole parameter to CXFConnectoryFactory.getConnection() method is 
+CXFConnectionSpec.   The following fields of CXFConnectionSpec are required:
+
+serviceName  - the QName of the service
+endpointName - the QName of the endpoint (port name)
+wsdlURL      - the URL of the WSDL
+serviceClass - the service interface class
+
+The following fields of CXFConnectionSpec are optional:
+
+busConfigURL - the URL of the CXF bus configuration.  If this is provided, it
+               overrides the busConfigURL defined (if any) in the 
+               CXFConnectionFactory custom property. (see the next paragraph)
+address      - the transport address
+
+The CXF bus configuration can be configured in CXF resource adapter factory's
+custom property (busConfigURL).  More than one factory can be created for each
+resource adapter.  Each factory has a JNDI name and can have different custom
+property values.  The application can choose to (JNDI) lookup the factory (by
+different JNDI name) it needs and picks up the factory's custom property 
+values.  If busConfigURL in the CXFConnectionSpec is specified during the
+getConnection() call, the value in the CXFConnectionSpec takes precedence over
+the property value of the connection factory custom property.  If no
+busConfigURL value is set in neither CXFConnectionSpec nor connection factory, 
+default bus will be created.
+
+
+Prerequisite
+------------
+
+For IBM WebSphere 6.1, you need to copy <CXF_HOME>/lib/wsdl4j-1.6.2.jar to 
+<WAS_HOME>/AppServer/java/jre/lib/endorsed.  If the "endorsed" directory does
+not exist, create a new one.  You need to restart the WebSphere 6.1 server.
+
+If your environment already includes cxf-manifest.jar on the
+CLASSPATH, and the JDK and ant bin directories on the PATH
+it is not necessary to set the environment as described in
+the samples directory README.  If your environment is not
+properly configured, or if you are planning on using wsdl2java,
+javac, and java to build and run the samples, you must set the
+environment.
+
+
+Building and running the sample using Ant
+-----------------------------------------
+From the base directory of this sample (i.e., where this README file is
+located), the Ant build.xml file can be used to build and run the sample.
+ 
+
+Build the common Servlet base jar
+---------------------------------
+  (Unix)    % cd ../common
+            % ant
+            % cd ../outbound.was
+
+  (Windows) > cd ..\common
+            > ant
+            > cd ..\outbound.was
+
+Build CXF J2C RAR file 
+----------------------
+  (Unix)    % ant generate.rar
+  (Windows) > ant generate.rar
+
+The result RAR file is located in build/classes/lib/cxf.rar
+
+
+Launch the application server
+-----------------------------
+
+The sample requires an application server (IBM WebSphere 6.1).  Make sure 
+you have a running instance of an application server. 
+
+
+Enable Tracing CXF messages (Optional)
+--------------------------------------
+
+To see the full effect of this sample, you will need to enable trace log in
+your application server.
+
+Please consult your vendor documentation on setting tracing and log level.  
+Here are basic instructions to deploy the MDB in WebSphere 6.1.
+
+1. Logon to WebSphere Integrated Solution Console.  The default address is:
+
+   http://<hostname>:9060/ibm/console/login.do
+
+2. Navigate to tree menu: Servers -> Application Servers 
+
+3. On the Application servers page, click of the target server (e.g. server1).
+   We will refer the target server as "server1" thereafter.  Please subsitute
+   for a suitable server name in your environment.
+
+4. On the next page (Application servers -> server1 in the Configuration tab)
+   and under Troubleshooting, click on Logging and Tracing.
+
+5. On the Logging and Tracking page, click on Change Log Detail Levels.
+
+6. On the next page, click on the Runtime tab.
+
+7. On the next page, check the "Save runtime changes to configuration as well"
+   box.  Enter the following in the textbox and then click OK.
+
+   *=info: org.apache.cxf.*=finest
+
+The trace log is located in:
+
+   <WebSphere install>/AppServer/profiles/AppSrv01/logs/server/trace.log.
+
+Please remember to remove the "org.apache.cxf.*=finest" entry in a production
+environment.
+
+Deploy the CXF JCA Connector
+-----------------------------
+
+The CXF JCA Connector must be deployed to the application server before 
+running the sample.  The JCA Connector used in this sample has a unique
+deployment descriptor (ra.xml) to demonstrate the direct invocation of
+service implementation resides in the Message Driven Bean.  Therefore, the 
+JCA Connector in this sample cannot be used by other JCA samples.  Please
+make sure there is no other CXF JCA Connector deployed into the application
+server.
+
+Please consult your vendor documentation on Resource Adapter deployment. 
+Here are basic instructions to deploy the CXF JCA connector in WebSphere 6.1.
+
+1. Logon to WebSphere Integrated Solution Console.  The default address is:
+
+   http://<hostname>:9060/ibm/console/login.do
+
+2. Navigate to tree menu: Resources -> Resource adapters -> Resource adapters
+
+3. On the Resource adapters page, click the "Install RAR" button.
+
+4. On the Install RAR File page, select the "Local path" radio button if the
+   browser that you are running is on the same machine as the WebSphere server.
+   Otherwise, select the "Server path" radio button.  Specify or browse to the
+   path build/lib/cxf.rar file of this sample.  Then, click the "Next" button.
+
+5. On the next page, click the "OK" button to install the Resource Adapter.
+
+6. On the next page, click the "CXF JCA Connector" link to edit the Resource
+   Adatper.
+
+7. On the "Configuration" page, click the "J2C connection factories"
+   link.  
+
+8. On the next page, click the "New" button to create a new connection
+   factory.
+
+9. On the next page, enter "CXFConnectionFactory" in the Name textbox and click
+   the "OK" button.
+   
+   Notice that the JNDI name is optional.  If it is omitted, a JNDI name
+   is created for you as eis/<ConnectionFactory> where <ConnectionFactory>
+   is "CXFConnectionFactory" above.  Basically, you can name the factory
+   anything as long as your application knows the JNDI name to look it up.
+
+10. Finally, click the "Save" link to commit the configuration.
+
+
+Building the Web Application
+----------------------------
+
+Issue the command:
+
+  (Unix)    % ant
+  (Windows) > ant
+
+The output WAR file can be found in build/lib/helloworld.war.
+
+
+Deploying the Web Applicatin
+----------------------------
+
+Please consult your vendor documentation on WAR file deployment.  Here are 
+basic instructions to deploy the MDB in WebSphere 6.1.
+
+1. Logon to WebSphere Integrated Solution Console.  The default address is:
+
+   http://<hostname>:9060/ibm/console/login.do
+
+2. Navigate to tree menu: Applications -> Install new Applications
+
+3. On the "Preparing for the application installation" page, select the "Local 
+   path" radio button if the browser that you are running is on the same 
+   machine as the WebSphere server.  Otherwise, select the "Server path" radio
+   button.  Specify or browse to the path helloworld.war file in this sample.
+
+   Enter "helloworld" in the Context root textbox.  Then, click the "Next" 
+   button.
+
+4. Click the "Next" button on the "Step 1: Select installation options" page.
+
+5. Click the "Next" button on the "Step 2: Map modules to servers" page.
+
+6. On the "Step 3. Map resource references to resources" page, Enter the follow
+   in the "Target Resource JNDI Name" and then click Next.
+
+   eis/CXFConnectionFactory
+
+7. On the "Step 4. Map virtual hosts for Web modules" page, click Next.
+
+8. On the "Step 5. Summary" page, click Finish.
+
+9. Finally, click the "Save" link to commit the configuration.
+
+10. Navigate to tree menu: Applications -> Enterprise Applications
+
+11. Select the box next to "helloworld_war" and click the "Start" button at 
+    the top to start the application.
+
+
+Running the Demo
+----------------
+
+Start the server in samples/wsdl_first by running:
+
+    Change directory to ../../../wsdl_first
+    ant server
+
+Notice that the server will timeout and stop itself after a few minutes.
+
+Next, run the client:
+
+    ant client
+
+NOTE: the URL in demo.client.Client.jar needs to be adjusted for other app
+      server
+
+This will launch the client submitted a HTTP request to the Servlet hosted by
+the application server.  The Servlet obtained a CXFConnection.  And, from
+the connection, it obtained a web service client.  The Servlet invoked the
+The web server.  It gathered the result and replied to the client.
+
+The following output is observed from the client.
+
+client:
+     [java]  server return: Hi  CXF from an EJB
+
diff --git a/distribution/src/main/release/samples/integration/jca/outbound.was61/build.xml b/distribution/src/main/release/samples/integration/jca/outbound.was61/build.xml
new file mode 100644
index 0000000000..66a23ceb75
--- /dev/null
+++ b/distribution/src/main/release/samples/integration/jca/outbound.was61/build.xml
@@ -0,0 +1,154 @@
+<?xml version="1.0"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+ 
+  http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+
+<project name="JCA Outbound WAS 6.1 Sample" default="build" basedir=".">
+
+    <property environment="env"/>
+    <condition property="cxf.home" value="${env.CXF_HOME}">
+        <isset property="env.CXF_HOME"/>
+    </condition>
+
+    <fail message="this sample need to use CXF_HOME enviroment, please setup CXF_HOME in your environment" unless="cxf.home"/>
+
+    <property name="wsdl.dir" value="${basedir}/etc/wsdl"/>
+    <property name="wsdl.location" value="${wsdl.dir}/hello_world.wsdl"/>
+    <property name="war.name" value="helloworld.war"/>
+    <property name="j2ee.resources.dir" location="${basedir}/../common/resources"/>
+
+    <property environment="env"/>
+    <condition property="module.jar.dir" value="${env.CXF_HOME}/modules" else="${env.CXF_HOME}/lib">
+        <available file="${env.CXF_HOME}/modules" type="dir"/>
+    </condition>
+    <condition property="integration.jar.dir" value="${env.CXF_HOME}/modules/integration" else="${env.CXF_HOME}/lib">
+        <available file="${env.CXF_HOME}/modules/integration" type="dir"/>
+    </condition>
+    
+    <import file="../../../common_build.xml"/>
+ 
+    <path id="thirdParth.classpath">
+        <pathelement location="${basedir}/../common/common.jar"/>
+    </path>
+
+    <path id="other.classpath">
+        <pathelement location="${cxf.home}/lib/geronimo-servlet_2.5_spec-1.2-M1.jar"/>
+        <pathelement location="${cxf.home}/lib/geronimo-j2ee-connector_1.5_spec-2.0.0.jar"/>
+        <pathelement location="${basedir}/../common/common.jar"/>
+        <fileset dir="${integration.jar.dir}" >  
+             <include name="cxf-integration-jca-*.jar"/>
+        </fileset>
+    </path>
+    
+    <target name="init">
+        <mkdir dir="${build.classes.dir}"/>
+        <mkdir dir="${build.src.dir}"/> 
+        <mkdir dir="${build.classes.dir}/lib"/>
+    </target>
+
+
+    <target name="generate.rar" depends="init">
+        <copy file="${basedir}/etc/ra.xml" todir="${build.classes.dir}/cxf-rar/META-INF"/>
+
+        <copy todir="${build.classes.dir}/cxf-rar" failonerror="no">
+            <fileset dir="${cxf.home}/lib">
+                <include name="*.jar"/>
+                <exclude name="*manifest*.jar"/>
+                <exclude name="*-jbi-*.jar"/>
+            </fileset>
+            <fileset dir="${module.jar.dir}">
+                <include name="cxf*.jar"/>
+                <exclude name="*manifest*.jar"/>
+                <exclude name="*-jbi-*.jar"/>
+            </fileset>
+            <fileset dir="${integration.jar.dir}">
+                <include name="*-jca-*.jar"/>
+                <exclude name="*-jbi-*.jar"/>
+            </fileset>
+        </copy>
+        <jar destfile="${build.classes.dir}/lib/cxf.rar"
+         basedir="${build.classes.dir}/cxf-rar"/>
+    </target>
+  
+    <target name="j2ee.compile" depends="maybe.generate.code">
+        <javac destdir="${build.classes.dir}" debug="true">
+            <src path="${build.src.dir}"/>
+            <src path="${basedir}/src"/>
+            <classpath>
+                <path refid="cxf.classpath"/>
+                <path refid="other.classpath"/>
+            </classpath>
+        </javac>
+
+        <copy todir="${build.classes.dir}">
+            <fileset dir="${build.src.dir}" includes="**/*.xml" />
+            <fileset dir="${build.src.dir}" includes="**/*.wsdl" />
+        </copy>
+    </target>
+
+    <target name="build" description="compile the code" depends="init,j2ee.compile,build-war"/>
+
+    <target name="generate.code">
+        <echo level="info" message="Generating code using wsdl2java..."/>
+        <wsdl2java file="hello_world.wsdl"/>
+    </target>
+
+     <target name="clean">
+        <delete dir="${build.dir}"/>
+    </target>
+
+    <target name="build-war">
+        <copy file="${wsdl.location}" todir="${basedir}/src" />
+
+        <mkdir dir="./build/lib"/>
+        <mkdir dir="./build/classes/wsdl"/>
+        <mkdir dir="./build/classes/etc"/>
+        <copy file="${wsdl.location}" todir="${basedir}/build/classes/wsdl"/>
+        <copy file="${basedir}/etc/cxf_client.xml" todir="${basedir}/build/classes/etc"/>
+        <war destfile="build/lib/${war.name}" webxml="${basedir}/etc/web.xml">
+            <lib dir="../common/">
+                <include name="common.jar"/>
+            </lib>
+
+            <classes dir="${build.classes.dir}">
+                <include name="**/servlet/*.class"/>
+                <include name="**/hello_world_soap_http/*.class"/>
+                <include name="**/hello_world_soap_http/types/*.class"/>
+                <include name="**/*.wsdl"/>
+                <include name="**/cxf_client.xml"/>
+            </classes>
+
+            <zipfileset dir="${j2ee.resources.dir}/images" prefix="images">
+                <include name="*.gif" />
+            </zipfileset>
+
+            <zipfileset dir="${j2ee.resources.dir}">
+                <include name="*.css" />
+            </zipfileset>
+
+        </war>
+    </target>
+
+    <target name="client" description="run demo client" depends="build">
+        <property name="param" value=""/>
+        <cxfrun classname="demo.client.Client" param1="${op}"/>
+    </target>
+
+
+
+</project>
diff --git a/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/cxf_client.xml b/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/cxf_client.xml
new file mode 100644
index 0000000000..d9d21b034b
--- /dev/null
+++ b/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/cxf_client.xml
@@ -0,0 +1,29 @@
+<beans xmlns="http://www.springframework.org/schema/beans"
+      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+      xmlns:cxf="http://cxf.apache.org/core"
+      xsi:schemaLocation="
+      http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd
+      http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">
+
+    <!--
+        Licensed to the Apache Software Foundation (ASF) under one or
+        more contributor license agreements. See the NOTICE file
+        distributed with this work for additional information regarding
+        copyright ownership. The ASF licenses this file to you under the
+        Apache License, Version 2.0 (the "License"); you may not use
+        this file except in compliance with the License. You may obtain
+        a copy of the License at
+        http://www.apache.org/licenses/LICENSE-2.0 Unless required by
+        applicable law or agreed to in writing, software distributed
+        under the License is distributed on an "AS IS" BASIS, WITHOUT
+        WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+        See the License for the specific language governing permissions
+        and limitations under the License.
+    -->
+
+    <cxf:bus>
+        <cxf:features>
+            <cxf:logging/>
+        </cxf:features>
+    </cxf:bus> 
+</beans>
diff --git a/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/ra.xml b/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/ra.xml
new file mode 100644
index 0000000000..b8b82c5f30
--- /dev/null
+++ b/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/ra.xml
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+    <!--
+        Licensed to the Apache Software Foundation (ASF) under one or
+        more contributor license agreements. See the NOTICE file
+        distributed with this work for additional information regarding
+        copyright ownership. The ASF licenses this file to you under the
+        Apache License, Version 2.0 (the "License"); you may not use
+        this file except in compliance with the License. You may obtain
+        a copy of the License at
+        http://www.apache.org/licenses/LICENSE-2.0 Unless required by
+        applicable law or agreed to in writing, software distributed
+        under the License is distributed on an "AS IS" BASIS, WITHOUT
+        WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+        See the License for the specific language governing permissions
+        and limitations under the License.
+    -->
+<connector xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java/sun.com/xml/ns/j2ee/connector_1_5.xsd"
+    version="1.5">
+    <display-name>CXFConnector</display-name>
+    <vendor-name>Apache</vendor-name>
+    <eis-type>CXF</eis-type>
+    <resourceadapter-version>2.0</resourceadapter-version>
+    <license>
+        <license-required>false</license-required>
+    </license>
+    <resourceadapter>
+        <resourceadapter-class>
+            org.apache.cxf.jca.cxf.ResourceAdapterImpl
+        </resourceadapter-class>
+        <outbound-resourceadapter>
+            <connection-definition>
+                <managedconnectionfactory-class>
+                    org.apache.cxf.jca.outbound.ManagedConnectionFactoryImpl
+                </managedconnectionfactory-class>
+                <connectionfactory-interface>
+                    org.apache.cxf.jca.outbound.CXFConnectionFactory
+                </connectionfactory-interface>
+                <connectionfactory-impl-class>
+                    org.apache.cxf.jca.outbound.ConnectionFactoryImpl
+                </connectionfactory-impl-class>
+                <connection-interface>
+                    org.apache.cxf.jca.outbound.CXFConnection
+                </connection-interface>
+                <connection-impl-class>
+                    org.apache.cxf.jca.outbound.ManagedConnectionImpl
+                </connection-impl-class>
+            </connection-definition>
+            <transaction-support>NoTransaction
+            </transaction-support>
+            <authentication-mechanism>
+                <authentication-mechanism-type>BasicPassword
+                </authentication-mechanism-type>
+                <credential-interface>
+                    javax.resource.spi.security.PasswordCredential
+                </credential-interface>
+            </authentication-mechanism>
+            <reauthentication-support>false
+            </reauthentication-support>
+        </outbound-resourceadapter>
+    </resourceadapter>
+</connector>
diff --git a/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/web.xml b/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/web.xml
new file mode 100644
index 0000000000..6aea013427
--- /dev/null
+++ b/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/web.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+
+<!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd">
+
+<web-app>
+
+  <servlet>
+    <servlet-name>HelloWorldServlet</servlet-name>
+    <servlet-class>demo.servlet.HelloWorldServlet</servlet-class>
+  </servlet>
+  <servlet-mapping>
+    <servlet-name>HelloWorldServlet</servlet-name>
+    <url-pattern>*.do</url-pattern>
+  </servlet-mapping>
+ 
+  <resource-ref>
+    <res-ref-name>eis/CXFConnectionFactory</res-ref-name>
+    <res-type>org.apache.cxf.jca.outbound.CXFConnectionFactory</res-type>
+    <res-auth>Container</res-auth>
+  </resource-ref>
+
+</web-app>
diff --git a/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/wsdl/hello_world.wsdl b/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/wsdl/hello_world.wsdl
new file mode 100644
index 0000000000..15e629c0f1
--- /dev/null
+++ b/distribution/src/main/release/samples/integration/jca/outbound.was61/etc/wsdl/hello_world.wsdl
@@ -0,0 +1,181 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+ 
+  http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+<wsdl:definitions name="HelloWorld" targetNamespace="http://apache.org/hello_world_soap_http" 
+    xmlns="http://schemas.xmlsoap.org/wsdl/" 
+    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 
+    xmlns:tns="http://apache.org/hello_world_soap_http"
+    xmlns:x1="http://apache.org/hello_world_soap_http/types"
+    xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
+    xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+    <wsdl:types>
+        <schema targetNamespace="http://apache.org/hello_world_soap_http/types" 
+            xmlns="http://www.w3.org/2001/XMLSchema"
+	    xmlns:tns="http://apache.org/hello_world_soap_http/types"
+            elementFormDefault="qualified">
+	    <simpleType name="MyStringType">
+		<restriction base="string">
+		    <maxLength value="30" />
+		</restriction>
+	    </simpleType>
+
+            <element name="sayHi">
+                <complexType/>
+            </element>
+            <element name="sayHiResponse">
+                <complexType>
+                    <sequence>
+                        <element name="responseType" type="string"/>
+                    </sequence>
+                </complexType>
+            </element>
+            <element name="greetMe">
+                <complexType>
+                    <sequence>
+                        <element name="requestType" type="tns:MyStringType"/>
+                    </sequence>
+                </complexType>
+            </element>
+            <element name="greetMeResponse">
+                <complexType>
+                    <sequence>
+                        <element name="responseType" type="string"/>
+                    </sequence>
+                </complexType>
+            </element>
+            <element name="greetMeOneWay">
+                <complexType>
+                    <sequence>
+                        <element name="requestType" type="string"/>
+                    </sequence>
+                </complexType>
+            </element>
+            <element name="pingMe">
+                <complexType/>
+            </element>
+            <element name="pingMeResponse">
+                <complexType/>
+            </element>
+            <element name="faultDetail">
+                <complexType>
+                    <sequence>
+                        <element name="minor" type="short"/>
+                        <element name="major" type="short"/>
+                    </sequence>
+                </complexType>
+            </element>
+        </schema>
+    </wsdl:types>
+    <wsdl:message name="sayHiRequest">
+        <wsdl:part element="x1:sayHi" name="in"/>
+    </wsdl:message>
+    <wsdl:message name="sayHiResponse">
+        <wsdl:part element="x1:sayHiResponse" name="out"/>
+    </wsdl:message>
+    <wsdl:message name="greetMeRequest">
+        <wsdl:part element="x1:greetMe" name="in"/>
+    </wsdl:message>
+    <wsdl:message name="greetMeResponse">
+        <wsdl:part element="x1:greetMeResponse" name="out"/>
+    </wsdl:message>
+    <wsdl:message name="greetMeOneWayRequest">
+        <wsdl:part element="x1:greetMeOneWay" name="in"/>
+    </wsdl:message>
+    <wsdl:message name="pingMeRequest">
+        <wsdl:part name="in" element="x1:pingMe"/>
+    </wsdl:message>
+    <wsdl:message name="pingMeResponse">
+        <wsdl:part name="out" element="x1:pingMeResponse"/>
+    </wsdl:message>		
+    <wsdl:message name="pingMeFault">
+        <wsdl:part name="faultDetail" element="x1:faultDetail"/>
+    </wsdl:message>
+    
+    <wsdl:portType name="Greeter">
+        <wsdl:operation name="sayHi">
+            <wsdl:input message="tns:sayHiRequest" name="sayHiRequest"/>
+            <wsdl:output message="tns:sayHiResponse" name="sayHiResponse"/>
+        </wsdl:operation>
+        
+        <wsdl:operation name="greetMe">
+            <wsdl:input message="tns:greetMeRequest" name="greetMeRequest"/>
+            <wsdl:output message="tns:greetMeResponse" name="greetMeResponse"/>
+        </wsdl:operation>
+        
+        <wsdl:operation name="greetMeOneWay">
+            <wsdl:input message="tns:greetMeOneWayRequest" name="greetMeOneWayRequest"/>
+        </wsdl:operation>
+
+        <wsdl:operation name="pingMe">
+            <wsdl:input name="pingMeRequest" message="tns:pingMeRequest"/>
+            <wsdl:output name="pingMeResponse" message="tns:pingMeResponse"/>
+            <wsdl:fault name="pingMeFault" message="tns:pingMeFault"/>
+        </wsdl:operation> 
+    </wsdl:portType>
+    <wsdl:binding name="Greeter_SOAPBinding" type="tns:Greeter">
+        <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
+        
+        <wsdl:operation name="sayHi">
+            <soap:operation soapAction="" style="document"/>
+            <wsdl:input name="sayHiRequest">
+                <soap:body use="literal"/>
+            </wsdl:input>
+            <wsdl:output name="sayHiResponse">
+                <soap:body use="literal"/>
+            </wsdl:output>
+        </wsdl:operation>
+        
+        <wsdl:operation name="greetMe">
+            <soap:operation soapAction="" style="document"/>
+            <wsdl:input name="greetMeRequest">
+                <soap:body use="literal"/>
+            </wsdl:input>
+            <wsdl:output name="greetMeResponse">
+                <soap:body use="literal"/>
+            </wsdl:output>
+        </wsdl:operation>
+        
+        <wsdl:operation name="greetMeOneWay">
+            <soap:operation soapAction="" style="document"/>
+            <wsdl:input name="greetMeOneWayRequest">
+                <soap:body use="literal"/>
+            </wsdl:input>
+        </wsdl:operation>
+
+        <wsdl:operation name="pingMe">
+            <soap:operation style="document"/>
+            <wsdl:input>
+                <soap:body use="literal"/>
+            </wsdl:input>
+            <wsdl:output>
+                <soap:body use="literal"/>
+            </wsdl:output>
+            <wsdl:fault name="pingMeFault">
+                <soap:fault name="pingMeFault" use="literal"/>
+            </wsdl:fault>
+        </wsdl:operation>
+        
+    </wsdl:binding>
+    <wsdl:service name="SOAPService">
+        <wsdl:port binding="tns:Greeter_SOAPBinding" name="SoapPort">
+            <soap:address location="http://localhost:9000/SoapContext/SoapPort"/>
+        </wsdl:port>
+    </wsdl:service>
+</wsdl:definitions>
+
diff --git a/distribution/src/main/release/samples/integration/jca/outbound.was61/src/demo/client/Client.java b/distribution/src/main/release/samples/integration/jca/outbound.was61/src/demo/client/Client.java
new file mode 100644
index 0000000000..e8f012b0bc
--- /dev/null
+++ b/distribution/src/main/release/samples/integration/jca/outbound.was61/src/demo/client/Client.java
@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package demo.client;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+public class Client {
+
+    protected Client() {
+    }
+
+
+    public static void main(String[] args) throws Exception {
+
+        invokeServlet("sayHi", null);
+        invokeServlet("greetMe", "CXF");
+    }
+
+    public static void invokeServlet(String op, String user) throws Exception {
+        boolean isSayHi = true;
+        try {
+            if (!"sayHi".equals(op)) {
+                isSayHi = false;
+            }
+
+            /*
+             * Default port for JBoss is 8080
+             * URL url = new URL("http://localhost:8080/helloworld/*.do");
+             */
+            URL url = new URL("http://localhost:9080/helloworld/*.do");
+            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+
+            conn.setRequestMethod("POST");
+            conn.setDoOutput(true);
+                
+            BufferedWriter out =
+                    new BufferedWriter(new OutputStreamWriter(conn.getOutputStream()));
+                
+            out.write("Operation=" + op);
+            if (!isSayHi) {
+                out.write("&User=" + user);                
+            }
+            out.flush();
+            out.close();
+                
+            BufferedReader in =
+                new BufferedReader(new InputStreamReader(conn.getInputStream()));
+            
+            boolean correctReturn = false;
+            String response;
+            if (isSayHi) {
+                while ((response = in.readLine()) != null) {
+                    
+                    if (response.contains("Bonjour")) {
+                        System.out.println(" sayHi server return: Bonjour");
+                        correctReturn = true;
+                        break;
+                    }
+                }
+            } else {
+                while ((response = in.readLine()) != null) {
+                    if (response.contains("Hello CXF")) {
+                        System.out.println(" greetMe server return: Hello CXF");
+                        correctReturn = true;
+                        break;
+                    }
+                }
+            }
+
+            if (!correctReturn) {
+                System.out.println("Can't got correct return from server.");
+            }
+            
+            in.close();
+            
+        } catch (MalformedURLException ex) {
+            ex.printStackTrace();
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/distribution/src/main/release/samples/integration/jca/outbound.was61/src/demo/servlet/HelloWorldServlet.java b/distribution/src/main/release/samples/integration/jca/outbound.was61/src/demo/servlet/HelloWorldServlet.java
new file mode 100644
index 0000000000..38243b4fed
--- /dev/null
+++ b/distribution/src/main/release/samples/integration/jca/outbound.was61/src/demo/servlet/HelloWorldServlet.java
@@ -0,0 +1,148 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package demo.servlet;
+
+import java.io.PrintWriter;
+import java.util.Map;
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.naming.NamingException;
+import javax.resource.ResourceException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.xml.namespace.QName;
+import javax.xml.ws.BindingProvider;
+
+import org.apache.cxf.jca.outbound.CXFConnection;
+import org.apache.cxf.jca.outbound.CXFConnectionFactory;
+import org.apache.cxf.jca.outbound.CXFConnectionSpec;
+import org.apache.hello_world_soap_http.Greeter;
+
+public class HelloWorldServlet extends DemoServletBase {
+
+    private static final String EIS_JNDI_NAME = "java:comp/env/eis/CXFConnectionFactory";
+
+    private String operationName; 
+    private String userName; 
+
+    public HelloWorldServlet() {
+        super("J2EE Connector Hello World Demo");
+    }
+
+    public void doGet(HttpServletRequest req, HttpServletResponse resp) {
+        try { 
+            operationName = req.getParameter("Operation"); 
+            userName = req.getParameter("User"); 
+            super.doGet(req, resp);
+        } finally { 
+            operationName = null; 
+        } 
+    }
+
+
+    public void doPost(HttpServletRequest req, HttpServletResponse resp) {
+        doGet(req, resp);
+    }
+
+    /** 
+     * get a connection to the SOAP service
+     */ 
+    protected CXFConnection getServiceConnection() throws NamingException, ResourceException {
+
+
+        // retrieve the connection factory from JNDI 
+        //
+        Context ctx = new InitialContext();
+        CXFConnectionFactory factory = (CXFConnectionFactory)ctx.lookup(EIS_JNDI_NAME);
+
+        // create the connection 
+        //
+        CXFConnectionSpec spec = new CXFConnectionSpec();
+        spec.setWsdlURL(getClass().getResource("/wsdl/hello_world.wsdl"));
+        spec.setBusConfigURL(getClass().getResource("/etc/cxf_client.xml"));
+        spec.setServiceName(new QName("http://apache.org/hello_world_soap_http", "SOAPService"));
+        spec.setEndpointName(new QName("http://apache.org/hello_world_soap_http", "SoapPort"));
+        spec.setServiceClass(Greeter.class);
+        return factory.getConnection(spec);
+    }
+
+    protected void writeMainBody(PrintWriter writer) {
+        operationForm(writer);
+        writer.println("&nbsp;&nbsp;" + getResponseFromWebService());
+    }
+
+    protected void operationForm(PrintWriter writer) {
+
+        writer.println("<TABLE ALIGN=\"center\">");
+        writer.println("<FORM ACTION=\"./*.do\" METHOD=GET>");
+        writer.println("<TR><TD><b>Operation:</b><BR>");
+        writer.println("<TR><TD>");   
+        writer.println("<INPUT TYPE=RADIO NAME=\"Operation\" VALUE=\"sayHi\"" 
+            + ("sayHi".equals(operationName) ? " CHECKED " : "") +  "> sayHi<BR>");
+        writer.println("<TR><TD>");
+        writer.println("<INPUT TYPE=RADIO NAME=\"Operation\" VALUE=\"greetMe\""
+            + ("greetMe".equals(operationName) ? "  CHECKED " : "") + "> greetMe ");
+        writer.println("<INPUT TYPE=TEXT NAME=\"User\" VALUE=\""
+            + ("greetMe".equals(operationName) ? userName : "") + "\" SIZE=20><BR>");
+        writer.println("<TR><TD>");
+        writer.println("<INPUT TYPE=SUBMIT VALUE=\"Submit\"><BR></p>");
+        writer.println("</FORM>");
+        writer.println("</TABLE>");
+    }
+
+
+    String getResponseFromWebService() {
+
+        String responseFromWebService = "No message sent";
+
+        CXFConnection connection = null;
+        try {
+            connection = getServiceConnection();
+            Greeter greeter = connection.getService(Greeter.class);
+            
+            if (operationName != null) {
+                if ("sayHi".equals(operationName)) {
+                    responseFromWebService = greeter.sayHi();
+                } else if ("greetMe".equals(operationName)) {
+                    responseFromWebService = greeter.greetMe(userName);
+                }
+            }
+
+            Map<String, Object> requestContext = ((BindingProvider)greeter).getRequestContext(); 
+            System.out.println("requestContext = " + requestContext);
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            if (e.getCause() != null) { 
+                e.getCause().printStackTrace(); 
+            } 
+            responseFromWebService = e.toString();
+        } finally { 
+            try {
+                if (connection != null) {
+                    connection.close();
+                }
+            } catch (Exception e) {
+                // report error from close
+            }
+        } 
+        return responseFromWebService; 
+    }
+}
diff --git a/distribution/src/main/release/samples/integration/jca/outbound.was61/src/hello_world.wsdl b/distribution/src/main/release/samples/integration/jca/outbound.was61/src/hello_world.wsdl
new file mode 100644
index 0000000000..15e629c0f1
--- /dev/null
+++ b/distribution/src/main/release/samples/integration/jca/outbound.was61/src/hello_world.wsdl
@@ -0,0 +1,181 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+ 
+  http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+<wsdl:definitions name="HelloWorld" targetNamespace="http://apache.org/hello_world_soap_http" 
+    xmlns="http://schemas.xmlsoap.org/wsdl/" 
+    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 
+    xmlns:tns="http://apache.org/hello_world_soap_http"
+    xmlns:x1="http://apache.org/hello_world_soap_http/types"
+    xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
+    xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+    <wsdl:types>
+        <schema targetNamespace="http://apache.org/hello_world_soap_http/types" 
+            xmlns="http://www.w3.org/2001/XMLSchema"
+	    xmlns:tns="http://apache.org/hello_world_soap_http/types"
+            elementFormDefault="qualified">
+	    <simpleType name="MyStringType">
+		<restriction base="string">
+		    <maxLength value="30" />
+		</restriction>
+	    </simpleType>
+
+            <element name="sayHi">
+                <complexType/>
+            </element>
+            <element name="sayHiResponse">
+                <complexType>
+                    <sequence>
+                        <element name="responseType" type="string"/>
+                    </sequence>
+                </complexType>
+            </element>
+            <element name="greetMe">
+                <complexType>
+                    <sequence>
+                        <element name="requestType" type="tns:MyStringType"/>
+                    </sequence>
+                </complexType>
+            </element>
+            <element name="greetMeResponse">
+                <complexType>
+                    <sequence>
+                        <element name="responseType" type="string"/>
+                    </sequence>
+                </complexType>
+            </element>
+            <element name="greetMeOneWay">
+                <complexType>
+                    <sequence>
+                        <element name="requestType" type="string"/>
+                    </sequence>
+                </complexType>
+            </element>
+            <element name="pingMe">
+                <complexType/>
+            </element>
+            <element name="pingMeResponse">
+                <complexType/>
+            </element>
+            <element name="faultDetail">
+                <complexType>
+                    <sequence>
+                        <element name="minor" type="short"/>
+                        <element name="major" type="short"/>
+                    </sequence>
+                </complexType>
+            </element>
+        </schema>
+    </wsdl:types>
+    <wsdl:message name="sayHiRequest">
+        <wsdl:part element="x1:sayHi" name="in"/>
+    </wsdl:message>
+    <wsdl:message name="sayHiResponse">
+        <wsdl:part element="x1:sayHiResponse" name="out"/>
+    </wsdl:message>
+    <wsdl:message name="greetMeRequest">
+        <wsdl:part element="x1:greetMe" name="in"/>
+    </wsdl:message>
+    <wsdl:message name="greetMeResponse">
+        <wsdl:part element="x1:greetMeResponse" name="out"/>
+    </wsdl:message>
+    <wsdl:message name="greetMeOneWayRequest">
+        <wsdl:part element="x1:greetMeOneWay" name="in"/>
+    </wsdl:message>
+    <wsdl:message name="pingMeRequest">
+        <wsdl:part name="in" element="x1:pingMe"/>
+    </wsdl:message>
+    <wsdl:message name="pingMeResponse">
+        <wsdl:part name="out" element="x1:pingMeResponse"/>
+    </wsdl:message>		
+    <wsdl:message name="pingMeFault">
+        <wsdl:part name="faultDetail" element="x1:faultDetail"/>
+    </wsdl:message>
+    
+    <wsdl:portType name="Greeter">
+        <wsdl:operation name="sayHi">
+            <wsdl:input message="tns:sayHiRequest" name="sayHiRequest"/>
+            <wsdl:output message="tns:sayHiResponse" name="sayHiResponse"/>
+        </wsdl:operation>
+        
+        <wsdl:operation name="greetMe">
+            <wsdl:input message="tns:greetMeRequest" name="greetMeRequest"/>
+            <wsdl:output message="tns:greetMeResponse" name="greetMeResponse"/>
+        </wsdl:operation>
+        
+        <wsdl:operation name="greetMeOneWay">
+            <wsdl:input message="tns:greetMeOneWayRequest" name="greetMeOneWayRequest"/>
+        </wsdl:operation>
+
+        <wsdl:operation name="pingMe">
+            <wsdl:input name="pingMeRequest" message="tns:pingMeRequest"/>
+            <wsdl:output name="pingMeResponse" message="tns:pingMeResponse"/>
+            <wsdl:fault name="pingMeFault" message="tns:pingMeFault"/>
+        </wsdl:operation> 
+    </wsdl:portType>
+    <wsdl:binding name="Greeter_SOAPBinding" type="tns:Greeter">
+        <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
+        
+        <wsdl:operation name="sayHi">
+            <soap:operation soapAction="" style="document"/>
+            <wsdl:input name="sayHiRequest">
+                <soap:body use="literal"/>
+            </wsdl:input>
+            <wsdl:output name="sayHiResponse">
+                <soap:body use="literal"/>
+            </wsdl:output>
+        </wsdl:operation>
+        
+        <wsdl:operation name="greetMe">
+            <soap:operation soapAction="" style="document"/>
+            <wsdl:input name="greetMeRequest">
+                <soap:body use="literal"/>
+            </wsdl:input>
+            <wsdl:output name="greetMeResponse">
+                <soap:body use="literal"/>
+            </wsdl:output>
+        </wsdl:operation>
+        
+        <wsdl:operation name="greetMeOneWay">
+            <soap:operation soapAction="" style="document"/>
+            <wsdl:input name="greetMeOneWayRequest">
+                <soap:body use="literal"/>
+            </wsdl:input>
+        </wsdl:operation>
+
+        <wsdl:operation name="pingMe">
+            <soap:operation style="document"/>
+            <wsdl:input>
+                <soap:body use="literal"/>
+            </wsdl:input>
+            <wsdl:output>
+                <soap:body use="literal"/>
+            </wsdl:output>
+            <wsdl:fault name="pingMeFault">
+                <soap:fault name="pingMeFault" use="literal"/>
+            </wsdl:fault>
+        </wsdl:operation>
+        
+    </wsdl:binding>
+    <wsdl:service name="SOAPService">
+        <wsdl:port binding="tns:Greeter_SOAPBinding" name="SoapPort">
+            <soap:address location="http://localhost:9000/SoapContext/SoapPort"/>
+        </wsdl:port>
+    </wsdl:service>
+</wsdl:definitions>
+
diff --git a/integration/jca/pom.xml b/integration/jca/pom.xml
index ec8fe4f986..d2c8159714 100644
--- a/integration/jca/pom.xml
+++ b/integration/jca/pom.xml
@@ -111,12 +111,6 @@
             <scope>test</scope>
         </dependency>
 
-        <dependency>
-            <groupId>org.apache.geronimo.specs</groupId>
-            <artifactId>geronimo-j2ee-connector_1.5_spec</artifactId>
-            <scope>provided</scope>
-        </dependency>
-
         <dependency>
             <groupId>org.apache.geronimo.specs</groupId>
             <artifactId>geronimo-ejb_3.0_spec</artifactId>
diff --git a/integration/jca/src/main/java/org/apache/cxf/jca/outbound/CXFManagedConnectionMetaData.java b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/CXFManagedConnectionMetaData.java
new file mode 100644
index 0000000000..b0f6f390ba
--- /dev/null
+++ b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/CXFManagedConnectionMetaData.java
@@ -0,0 +1,60 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jca.outbound;
+
+import javax.resource.ResourceException;
+import javax.resource.spi.ManagedConnectionMetaData;
+
+/**
+ * CXF Managed Connection MetaData
+ */
+public class CXFManagedConnectionMetaData implements ManagedConnectionMetaData {
+
+    private String userName;
+
+    /**
+     * @param userName
+     */
+    public CXFManagedConnectionMetaData(String userName) {
+        this.userName = userName;
+    }
+
+
+    public String getEISProductName() throws ResourceException {
+        return "Apache CXF";
+    }
+
+ 
+    public String getEISProductVersion() throws ResourceException {
+        return "2.0";
+    }
+
+    /*
+     * Don't have a hard limit
+     */
+    public int getMaxConnections() throws ResourceException {
+        return -1;
+    }
+
+ 
+    public String getUserName() throws ResourceException {
+        return userName;
+    }
+
+}
diff --git a/integration/jca/src/main/java/org/apache/cxf/jca/outbound/ConnectionFactoryImpl.java b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/ConnectionFactoryImpl.java
new file mode 100644
index 0000000000..9e8c1c1d98
--- /dev/null
+++ b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/ConnectionFactoryImpl.java
@@ -0,0 +1,56 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jca.outbound;
+
+import javax.naming.NamingException;
+import javax.naming.Reference;
+import javax.resource.ResourceException;
+import javax.resource.spi.ConnectionManager;
+import javax.resource.spi.ManagedConnectionFactory;
+
+/**
+ * Implement ConnectionFactory that delegate allocation of connection
+ * to {@link ConnectionManager}.
+ */
+public class ConnectionFactoryImpl implements CXFConnectionFactory {
+
+    private static final long serialVersionUID = -9185852866781165233L;
+    private ManagedConnectionFactory mcf;
+    private ConnectionManager connectionManager;
+    private Reference reference;
+
+    public ConnectionFactoryImpl(ManagedConnectionFactory mcf,
+            ConnectionManager connectionManager) {
+        this.mcf = mcf;
+        this.connectionManager = connectionManager;
+    }
+
+    public void setReference(Reference reference) {
+        this.reference = reference; 
+    }
+
+    public Reference getReference() throws NamingException {
+        return reference;
+    }
+
+    public CXFConnection getConnection(CXFConnectionSpec spec) throws ResourceException {
+        return (CXFConnection) connectionManager.allocateConnection(mcf, spec);
+    }
+
+}
diff --git a/integration/jca/src/main/java/org/apache/cxf/jca/outbound/DefaultConnectionManager.java b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/DefaultConnectionManager.java
new file mode 100644
index 0000000000..c187da0234
--- /dev/null
+++ b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/DefaultConnectionManager.java
@@ -0,0 +1,85 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jca.outbound;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.resource.ResourceException;
+import javax.resource.spi.ConnectionEvent;
+import javax.resource.spi.ConnectionEventListener;
+import javax.resource.spi.ConnectionManager;
+import javax.resource.spi.ConnectionRequestInfo;
+import javax.resource.spi.ManagedConnection;
+import javax.resource.spi.ManagedConnectionFactory;
+
+import org.apache.cxf.common.logging.LogUtils;
+
+/**
+ * Default Connection Manager which does not support connection pool.  
+ * Connection will be destroyed upon closing by application.
+ */
+public class DefaultConnectionManager implements ConnectionManager, ConnectionEventListener {
+
+    private static final long serialVersionUID = -8931949400870739450L;
+    private static final Logger LOG = LogUtils.getL7dLogger(DefaultConnectionManager.class);
+
+
+    /* -------------------- ConnectionManager Methods ----------------------------
+     */
+    public Object allocateConnection(ManagedConnectionFactory mcf,
+            ConnectionRequestInfo cxRequestInfo) throws ResourceException {
+
+        if (LOG.isLoggable(Level.FINEST)) {
+            LOG.finest("allocateConnection cxRequestInfo = " + cxRequestInfo);
+        }
+
+        ManagedConnection mc = mcf.createManagedConnection(null, cxRequestInfo);
+        mc.addConnectionEventListener(this);
+        return mc.getConnection(null, cxRequestInfo);
+    }
+
+    /* -------------------- ConnectionEventListener Methods -----------------------
+     */
+    public void connectionClosed(ConnectionEvent event) {
+        try {
+            ((ManagedConnection)event.getSource()).destroy();
+        } catch (ResourceException e) {
+            LOG.log(Level.SEVERE, "Failed to destroy connection.", e);
+        }
+    }
+
+    public void connectionErrorOccurred(ConnectionEvent event) {
+        try {
+            ((ManagedConnection)event.getSource()).destroy();
+        } catch (ResourceException e) {
+            LOG.log(Level.SEVERE, "Failed to destroy connection.", e);
+        }
+    }
+
+    public void localTransactionCommitted(ConnectionEvent event) {
+    }
+
+    public void localTransactionRolledback(ConnectionEvent event) {
+    }
+
+    public void localTransactionStarted(ConnectionEvent event) {
+    }
+
+}
diff --git a/integration/jca/src/main/java/org/apache/cxf/jca/outbound/ManagedConnectionFactoryImpl.java b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/ManagedConnectionFactoryImpl.java
new file mode 100644
index 0000000000..1fafa8a46e
--- /dev/null
+++ b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/ManagedConnectionFactoryImpl.java
@@ -0,0 +1,199 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jca.outbound;
+
+import java.io.PrintWriter;
+
+import java.util.Iterator;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.resource.ResourceException;
+import javax.resource.spi.ConnectionManager;
+import javax.resource.spi.ConnectionRequestInfo;
+import javax.resource.spi.ManagedConnection;
+import javax.resource.spi.ManagedConnectionFactory;
+import javax.resource.spi.ResourceAdapter;
+import javax.resource.spi.ResourceAdapterAssociation;
+import javax.resource.spi.work.WorkManager;
+import javax.security.auth.Subject;
+
+import org.apache.commons.lang.ObjectUtils;
+import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.jca.core.logging.LoggerHelper;
+import org.apache.cxf.jca.cxf.ResourceAdapterImpl;
+
+public class ManagedConnectionFactoryImpl implements ManagedConnectionFactory, 
+    ResourceAdapterAssociation {
+
+    private static final long serialVersionUID = -5294527634981120642L;
+    private static final Logger LOG = LogUtils.getL7dLogger(ManagedConnectionFactoryImpl.class);
+    
+    private String busConfigURL;
+    private PrintWriter printWriter;
+    private ResourceAdapter resourceAdapter;
+    
+    private ConnectionManager defaultConnectionManager = 
+        new DefaultConnectionManager();
+
+    static {
+        // first use of log, default init if necessary
+        LoggerHelper.init();
+    }
+   
+    /* --------------------------------------------------------------------
+     *                           Bean Properties
+     */
+    public void setBusConfigURL(String busConfigURL) {
+        this.busConfigURL = busConfigURL;
+    }
+
+    public String getBusConfigURL() {
+        return busConfigURL;
+    }
+    
+  
+    /* --------------------------------------------------------------------
+     *                    ManagedConnectionFactory methods
+     */
+    public Object createConnectionFactory() throws ResourceException {
+        if (LOG.isLoggable(Level.FINER)) {
+            LOG.finer("Create connection factory for unmanaged connections");
+        }
+        return new ConnectionFactoryImpl(this, defaultConnectionManager);
+    }
+    
+    public Object createConnectionFactory(ConnectionManager connMgr) 
+        throws ResourceException {
+        if (LOG.isLoggable(Level.FINER)) {
+            LOG.finer("Create connection factory by app server connMgr " + connMgr);
+        }
+        return new ConnectionFactoryImpl(this, 
+                connMgr == null ? defaultConnectionManager : connMgr);
+    }
+
+    public ManagedConnection createManagedConnection(Subject subject, ConnectionRequestInfo connReqInfo) 
+        throws ResourceException {
+        if (LOG.isLoggable(Level.FINER)) {
+            LOG.finer("Create managed connection subject=" + subject + "connReqInfo="
+                    + connReqInfo);
+        }
+        return new ManagedConnectionImpl(this, connReqInfo, subject);
+    }
+    
+    // hashCode method is required by JCA 1.5 because on properties
+    public int hashCode() {
+        int retval = 0;
+
+        if (busConfigURL != null) {
+            retval += busConfigURL.hashCode();
+        }
+        
+        return retval;
+    }
+    
+    // equals method is required by JCA 1.5 because on properties
+    public boolean equals(Object o) {
+        if (!this.getClass().isAssignableFrom(o.getClass())) {
+            return false;
+        }
+        
+        ManagedConnectionFactoryImpl that = (ManagedConnectionFactoryImpl)o;
+       
+        if (!ObjectUtils.equals(that.getBusConfigURL(), busConfigURL)) {
+            return false;
+        }
+        
+        return true;
+    }
+    
+    public PrintWriter getLogWriter() throws ResourceException {
+        return printWriter;
+    }
+
+    public void setLogWriter(final PrintWriter aPrintWriter) throws ResourceException {
+        if (aPrintWriter == null) {
+            throw new IllegalArgumentException("NULL_LOG_WRITER");
+        }
+
+        printWriter = aPrintWriter;
+        LoggerHelper.initializeLoggingOnWriter(printWriter);
+    }
+    
+    @SuppressWarnings("unchecked")
+    public ManagedConnection matchManagedConnections(Set mcs, Subject subject, 
+            ConnectionRequestInfo reqInfo) throws ResourceException {
+
+        if (LOG.isLoggable(Level.FINER)) {
+            LOG.finer("match connections: set=" + mcs + ", subject=" + subject
+                    + " reqInfo=" + reqInfo);
+        }
+
+        // find the first managed connection that matches the bus and request info
+        Iterator iter = mcs.iterator();
+        while (iter.hasNext()) {
+            Object obj = iter.next();
+            if (!(obj instanceof ManagedConnectionImpl)) {
+                continue;
+            }
+            
+            ManagedConnectionImpl mc = (ManagedConnectionImpl)obj;
+             
+            if (!ObjectUtils.equals(busConfigURL,
+                    mc.getManagedConnectionFactoryImpl().getBusConfigURL())) {
+                continue;
+            }
+            
+            if (!ObjectUtils.equals(reqInfo, mc.getRequestInfo())) {
+                continue;
+            }
+            
+            if (LOG.isLoggable(Level.FINER)) {
+                LOG.finer("found matched connection " + mc);
+            }
+            return mc;
+        }
+        return null;
+    }
+    
+    /* --------------------------------------------------------------------
+     *                      ResourceAdapterAssociation methods
+     */
+    public ResourceAdapter getResourceAdapter() {
+        return resourceAdapter;
+    }
+
+    public void setResourceAdapter(ResourceAdapter ra) throws ResourceException {
+        resourceAdapter = ra;
+    }
+
+    /* --------------------------------------------------------------------
+     *                      public methods
+     */
+    public WorkManager getWorkManager() {
+        if (resourceAdapter instanceof ResourceAdapterImpl) {
+            return ((ResourceAdapterImpl)resourceAdapter).getBootstrapContext()
+                .getWorkManager();
+        } else {
+            return null;
+        }
+    }
+
+}
diff --git a/integration/jca/src/main/java/org/apache/cxf/jca/outbound/ManagedConnectionImpl.java b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/ManagedConnectionImpl.java
new file mode 100644
index 0000000000..44133b2c47
--- /dev/null
+++ b/integration/jca/src/main/java/org/apache/cxf/jca/outbound/ManagedConnectionImpl.java
@@ -0,0 +1,400 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jca.outbound;
+
+import java.io.PrintWriter;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.resource.NotSupportedException;
+import javax.resource.ResourceException;
+import javax.resource.spi.ConnectionEvent;
+import javax.resource.spi.ConnectionEventListener;
+import javax.resource.spi.ConnectionRequestInfo;
+import javax.resource.spi.LocalTransaction;
+import javax.resource.spi.ManagedConnection;
+import javax.resource.spi.ManagedConnectionMetaData;
+import javax.security.auth.Subject;
+import javax.transaction.xa.XAResource;
+import javax.xml.ws.BindingProvider;
+
+import org.apache.cxf.Bus;
+import org.apache.cxf.BusFactory;
+import org.apache.cxf.bus.spring.SpringBusFactory;
+import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.configuration.Configurer;
+import org.apache.cxf.frontend.ClientProxyFactoryBean;
+import org.apache.cxf.jaxws.EndpointUtils;
+import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;
+import org.apache.cxf.jca.core.logging.LoggerHelper;
+
+/**
+ * Represents a "physical" connection to EIS, which provides access to target
+ * web service.  ManagedConnectionImpl creates connection handles for
+ * applications to use the connection backed by this object.
+ */
+public class ManagedConnectionImpl implements ManagedConnection {
+    private static final Logger LOG = LogUtils.getL7dLogger(ManagedConnectionImpl.class);
+    
+    private Set<ConnectionEventListener> listeners = 
+        Collections.synchronizedSet(new HashSet<ConnectionEventListener>());
+    
+    private Map<Object, Subject> handles = 
+        Collections.synchronizedMap(new HashMap<Object, Subject>());
+    private PrintWriter printWriter;
+    
+    private ManagedConnectionFactoryImpl mcf;
+    private ConnectionRequestInfo connReqInfo;
+    private boolean isClosed;
+    private Bus bus;
+    private Object associatedHandle;
+    
+    public ManagedConnectionImpl(ManagedConnectionFactoryImpl mcf,
+            ConnectionRequestInfo connReqInfo, Subject subject) {
+        this.mcf = mcf;
+        this.connReqInfo = connReqInfo;
+    }
+
+    /* -------------------------------------------------------------------
+     * ManagedConnection Methods
+     */
+    
+    public void addConnectionEventListener(ConnectionEventListener listener) {
+        if (LOG.isLoggable(Level.FINER)) {
+            LOG.finer("add listener : " + listener);
+        }
+        listeners.add(listener);
+    }
+
+    public void associateConnection(Object connection) throws ResourceException {
+        if (LOG.isLoggable(Level.FINER)) {
+            LOG.finer("associate handle : " + connection);
+        }
+        associatedHandle = connection;
+        // nothing needs to be done as app gets a copy of client proxy
+    }
+
+    public void cleanup() throws ResourceException {
+        if (LOG.isLoggable(Level.FINER)) {
+            LOG.finer("cleanup");
+        }
+        handles.clear();
+        isClosed = false;
+    }
+
+    public void destroy() throws ResourceException {
+        if (LOG.isLoggable(Level.FINER)) {
+            LOG.finer("destroy");
+        }
+        handles.clear();
+        isClosed = false;
+        bus = null;
+        connReqInfo = null;
+    }
+
+    public Object getConnection(Subject subject,
+            ConnectionRequestInfo cxRequestInfo) throws ResourceException {
+        if (LOG.isLoggable(Level.FINER)) {
+            LOG.finer("get handle for subject=" + subject + " cxRequestInfo="
+                    + cxRequestInfo);
+        }
+        
+        if (isClosed) {
+            throw new ResourceException("connection has been closed");
+        }
+        
+        // check request info
+        if (!connReqInfo.equals(cxRequestInfo)) {
+            throw new ResourceException("connection request info: " + cxRequestInfo
+                    + " does not match " + connReqInfo);
+        }
+        
+        CXFConnectionSpec spec = (CXFConnectionSpec)cxRequestInfo;
+
+        Object handle = createConnectionHandle(spec);
+        handles.put(handle, subject);
+        associatedHandle = handle;
+        return handle;
+        
+    }
+
+    public LocalTransaction getLocalTransaction() throws ResourceException {
+        throw new NotSupportedException("LocalTransaction is not supported.");
+    }
+
+    public PrintWriter getLogWriter() throws ResourceException {
+        return printWriter;
+    }
+
+    public ManagedConnectionMetaData getMetaData() throws ResourceException {
+        return new CXFManagedConnectionMetaData(getUserName());
+    }
+
+    public XAResource getXAResource() throws ResourceException {
+        throw new NotSupportedException("XAResource is not supported.");
+    }
+
+    public void removeConnectionEventListener(ConnectionEventListener listener) {
+        listeners.remove(listener);
+    }
+
+    public void setLogWriter(PrintWriter out) throws ResourceException {
+        printWriter = out;
+
+        if (printWriter != null) {
+            LoggerHelper.initializeLoggingOnWriter(printWriter);
+        }
+    }
+    
+    /* -------------------------------------------------------------------
+     * Public Methods
+     */
+
+    public ConnectionRequestInfo getRequestInfo() {
+        return connReqInfo;
+    }
+    
+    public ManagedConnectionFactoryImpl getManagedConnectionFactoryImpl() {
+        return mcf;
+    }
+    
+    /* -------------------------------------------------------------------
+     * Private Methods
+     */
+    
+    private void sendEvent(final ConnectionEvent coEvent) {
+        synchronized (listeners) {
+            Iterator<ConnectionEventListener> iterator = listeners.iterator();
+            while (iterator.hasNext()) {
+                sendEventToListener(iterator.next(), coEvent);
+            }
+        }
+    }
+
+    private void sendEventToListener(ConnectionEventListener listener, 
+            ConnectionEvent coEvent) {
+        if (coEvent.getId() == ConnectionEvent.CONNECTION_CLOSED) {
+            listener.connectionClosed(coEvent);
+        }
+
+        if (coEvent.getId() == ConnectionEvent.LOCAL_TRANSACTION_COMMITTED) {
+            listener.localTransactionCommitted(coEvent);
+        }
+
+        if (coEvent.getId() == ConnectionEvent.LOCAL_TRANSACTION_ROLLEDBACK) {
+            listener.localTransactionRolledback(coEvent);
+        }
+
+        if (coEvent.getId() == ConnectionEvent.LOCAL_TRANSACTION_STARTED) {
+            listener.localTransactionStarted(coEvent);
+        }
+
+        if (coEvent.getId() == ConnectionEvent.CONNECTION_ERROR_OCCURRED) {
+            listener.connectionErrorOccurred(coEvent);
+        }
+        
+    }
+    
+    private String getUserName() {
+        if (associatedHandle != null) {
+            Subject subject = handles.get(associatedHandle);
+            if (subject != null) {
+                return subject.toString();
+            }
+        } 
+        return null;
+        
+    }
+
+    private Object createConnectionHandle(final CXFConnectionSpec spec) {
+                                
+        Class<?> interfaces[] = {CXFConnection.class, BindingProvider.class, 
+                spec.getServiceClass()};
+
+        return Proxy.newProxyInstance(spec.getServiceClass().getClassLoader(), 
+                interfaces, new ConnectionInvocationHandler(
+                        createClientProxy(spec), spec));
+    }
+    
+    private Object createClientProxy(final CXFConnectionSpec spec) {
+        
+        validateConnectionSpec(spec);
+        ClientProxyFactoryBean factory = null;
+
+        if (EndpointUtils.hasWebServiceAnnotation(spec.getServiceClass())) {
+            factory = new JaxWsProxyFactoryBean();
+        } else {
+            factory = new ClientProxyFactoryBean();
+        }
+              
+        factory.setBus(getBus(spec.getBusConfigURL()));
+        factory.setServiceClass(spec.getServiceClass());
+        factory.getServiceFactory().setEndpointName(spec.getEndpointName());
+        factory.getServiceFactory().setServiceName(spec.getServiceName());
+        factory.getServiceFactory().setWsdlURL(spec.getWsdlURL());
+
+        if (spec.getAddress() != null) {
+            factory.setAddress(spec.getAddress());
+        }
+        
+        configureObject(spec.getEndpointName().toString() + ".jaxws-client.proxyFactory", factory);
+
+        return factory.create();
+
+    }
+
+    private void validateConnectionSpec(CXFConnectionSpec spec) {
+        if (spec.getServiceClass() == null) {
+            throw new IllegalArgumentException("no serviceClass in connection spec");
+        }
+        
+        if (spec.getEndpointName() == null) {
+            throw new IllegalArgumentException("no endpointName in connection spec");
+        }
+        
+        if (spec.getServiceName() == null) {
+            throw new IllegalArgumentException("no serviceName in connection spec");
+        }
+        
+        if (spec.getWsdlURL() == null) {
+            throw new IllegalArgumentException("no wsdlURL in connection spec");
+        }
+    }
+
+    private void configureObject(String name, Object instance) {
+        Configurer configurer = bus.getExtension(Configurer.class);
+        if (null != configurer) {
+            configurer.configureBean(name, instance);
+        }
+    }
+    
+    private synchronized Bus getBus(URL busConfigLocation) {
+        if (bus == null) {
+            if (busConfigLocation != null) {
+                if (LOG.isLoggable(Level.FINE)) {
+                    LOG.fine("Create bus from location " + busConfigLocation);
+                }
+                bus = new SpringBusFactory().createBus(busConfigLocation);
+            } else if (mcf.getBusConfigURL() != null) {
+                
+                if (LOG.isLoggable(Level.FINE)) {
+                    LOG.fine("Create bus from URL " + mcf.getBusConfigURL());
+                }
+                
+                URL url = null;
+                try {
+                    url = new URL(mcf.getBusConfigURL());
+                } catch (MalformedURLException e) {
+                    LOG.warning("Malformed URL " + mcf.getBusConfigURL());
+                }
+
+                if (url != null) {
+                    bus = new SpringBusFactory().createBus(url);
+                }
+            } 
+            
+            if (bus == null) {
+                if (LOG.isLoggable(Level.FINE)) {
+                    LOG.fine("Create default bus");
+                }
+                bus = BusFactory.getDefaultBus();
+            }
+        }
+        return bus;
+    }
+
+    private class ConnectionInvocationHandler implements InvocationHandler {
+        private Object target;
+        private CXFConnectionSpec spec;
+        
+        ConnectionInvocationHandler(Object target, CXFConnectionSpec spec) {
+            this.target = target;
+            this.spec = spec;
+        }
+
+        public Object invoke(Object proxy, Method method, Object[] args)
+            throws Throwable {
+            
+            if (LOG.isLoggable(Level.FINEST)) {
+                LOG.finest("invoke connection spec:" + spec + " method=" + method);
+            }
+            
+            if ("hashCode".equals(method.getName()) || "equals".equals(method.getName())) {
+                return method.invoke(Proxy.getInvocationHandler(proxy), args);
+                
+            }
+            
+            if ("toString".equals(method.getName())) {
+                return "ManagedConnection: " + spec;
+            }
+            
+            if (!handles.containsKey(proxy)) {
+                throw new IllegalArgumentException("Stale connection");
+            }
+            
+            if ("getService".equals(method.getName())) {
+                return handleGetServiceMethod(proxy, method, args);
+            } else if ("close".equals(method.getName())) {
+                return handleCloseMethod(proxy, method, args);
+
+            } else {
+                throw new IllegalArgumentException("Unhandled method " + method);
+            }
+        }
+
+        private Object handleGetServiceMethod(Object proxy, Method method,
+                Object[] args) {
+
+            if (!spec.getServiceClass().equals(args[0])) {
+                throw new IllegalArgumentException("serviceClass " 
+                        + args[0] + " does not match " + spec.getServiceClass());
+            }                                      
+                                                                          
+            return target;
+        }
+        
+        private Object handleCloseMethod(Object proxy, Method method,
+                Object[] args) {
+            
+            handles.remove(proxy);
+            associatedHandle = null;
+            if (handles.isEmpty()) {
+                isClosed = true;
+                ConnectionEvent event = new ConnectionEvent(ManagedConnectionImpl.this,
+                        ConnectionEvent.CONNECTION_CLOSED);
+                event.setConnectionHandle(proxy);
+                sendEvent(event);
+            }
+            
+            return null;
+        }
+    }
+   
+}
