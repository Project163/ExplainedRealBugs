diff --git a/rt/transports/http-jetty/src/test/java/org/apache/cxf/transport/http_jetty/JettyHTTPDestinationTest.java b/rt/transports/http-jetty/src/test/java/org/apache/cxf/transport/http_jetty/JettyHTTPDestinationTest.java
index 571f2a91b0..de2e7d3cf6 100644
--- a/rt/transports/http-jetty/src/test/java/org/apache/cxf/transport/http_jetty/JettyHTTPDestinationTest.java
+++ b/rt/transports/http-jetty/src/test/java/org/apache/cxf/transport/http_jetty/JettyHTTPDestinationTest.java
@@ -410,9 +410,6 @@ public class JettyHTTPDestinationTest extends Assert {
         Conduit partialBackChannel =
             destination.getBackChannel(inMessage, partialResponse, replyTo);
         partialBackChannel.prepare(partialResponse);
-        assertEquals("unexpected response code",
-                     202,
-                     partialResponse.get(Message.RESPONSE_CODE));
         verifyBackChannelSend(partialBackChannel, partialResponse, 202);
 
         outMessage = setUpOutMessage();
diff --git a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/AbstractHTTPDestination.java b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/AbstractHTTPDestination.java
index 882fe99b7f..64698b3f44 100644
--- a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/AbstractHTTPDestination.java
+++ b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/AbstractHTTPDestination.java
@@ -180,9 +180,6 @@ public abstract class AbstractHTTPDestination
     }
     
     protected void updateResponseHeaders(Message message) {
-        if (MessageUtils.isPartialResponse(message)) {
-            message.put(Message.RESPONSE_CODE, HttpURLConnection.HTTP_ACCEPTED);
-        }
         Map<String, List<String>> responseHeaders =
             CastUtils.cast((Map)message.get(Message.PROTOCOL_HEADERS));
         if (responseHeaders == null) {
@@ -540,7 +537,7 @@ public abstract class AbstractHTTPDestination
                     }
                 }
                 response.setStatus(status);
-            } else if (oneWay) {
+            } else if (oneWay && !MessageUtils.isPartialResponse(outMessage)) {
                 response.setStatus(HttpURLConnection.HTTP_ACCEPTED);
             } else {
                 response.setStatus(HttpURLConnection.HTTP_OK);
@@ -548,7 +545,6 @@ public abstract class AbstractHTTPDestination
 
             copyResponseHeaders(outMessage, response);
 
-            
             if (oneWay && !MessageUtils.isPartialResponse(outMessage)) {
                 response.setContentLength(0);
                 response.flushBuffer();
@@ -598,9 +594,6 @@ public abstract class AbstractHTTPDestination
          * @param message the message to be sent.
          */
         public void prepare(Message message) throws IOException {
-            if (MessageUtils.isPartialResponse(message)) {
-                message.put(Message.RESPONSE_CODE, HttpURLConnection.HTTP_ACCEPTED);
-            }
             message.put(HTTP_RESPONSE, response);
             OutputStream os = message.getContent(OutputStream.class);
             if (os == null) {
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
index f2665ee0d2..e9e8b5c490 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
@@ -1000,6 +1000,7 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
             //inMessage.remove(AbstractHTTPDestination.HTTP_REQUEST);
             //inMessage.remove(AbstractHTTPDestination.HTTP_RESPONSE);
             inMessage.remove(Message.ASYNC_POST_RESPONSE_DISPATCH);
+            updateResponseCode(inMessage);
 
             //cache this inputstream since it's defer to use in case of async
             try {
@@ -1014,6 +1015,20 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
                 e.printStackTrace();
             }
         }
+        
+        private void updateResponseCode(Message message) {
+            Object o = message.get("HTTP.RESPONSE");
+            if (o != null) {
+                try {
+                    o.getClass().getMethod("setStatus", Integer.TYPE)
+                        .invoke(o, HttpURLConnection.HTTP_ACCEPTED);
+                } catch (Throwable t) {
+                    //ignore
+                }
+            }
+            
+        }
+        
     }
     
     /**
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RMSoapInterceptor.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RMSoapInterceptor.java
index 1429e17780..cc0aa80fa0 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RMSoapInterceptor.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RMSoapInterceptor.java
@@ -20,6 +20,7 @@
 package org.apache.cxf.ws.rm.soap;
 
 
+import java.net.HttpURLConnection;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
@@ -220,6 +221,10 @@ public class RMSoapInterceptor extends AbstractSoapInterceptor {
                 }
             }
             Node node = hdr.getFirstChild();
+            if (node != null && MessageUtils.isPartialResponse(message)) {
+                // make sure the response is returned as HTTP 200 and not 202
+                message.put(Message.RESPONSE_CODE, HttpURLConnection.HTTP_OK);
+            }
             while (node != null) {
                 Header holder = new Header(new QName(node.getNamespaceURI(), node.getLocalName()), node);
                 header.add(holder);
