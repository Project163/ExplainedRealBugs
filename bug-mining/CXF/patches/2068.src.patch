diff --git a/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/InterfaceProxy.java b/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/InterfaceProxy.java
new file mode 100644
index 0000000000..fbb1feaa28
--- /dev/null
+++ b/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/InterfaceProxy.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jaxrs.ext.search;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Map;
+
+public class InterfaceProxy implements InvocationHandler {
+
+    private Map<String, Object> map = new HashMap<String, Object>(); 
+
+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+        String methodName = method.getName();
+        if (methodName.length() <= 3) {
+            throw new UnsupportedOperationException();
+        }
+        String property = methodName.substring(3);
+        boolean isGetter = "get".equals(methodName.substring(0,  3));
+        if (isGetter) {
+            return map.get(property);
+        } else {
+            map.put(property, args[0]);
+            return null;
+        }
+    }
+
+}
diff --git a/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/fiql/FiqlParser.java b/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/fiql/FiqlParser.java
index 65e1e4f253..4ca6e976aa 100644
--- a/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/fiql/FiqlParser.java
+++ b/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/fiql/FiqlParser.java
@@ -18,6 +18,7 @@
  */
 package org.apache.cxf.jaxrs.ext.search.fiql;
 import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.util.ArrayList;
@@ -37,6 +38,7 @@ import org.apache.cxf.jaxrs.ext.search.AndSearchCondition;
 import org.apache.cxf.jaxrs.ext.search.Beanspector;
 import org.apache.cxf.jaxrs.ext.search.Beanspector.TypeInfo;
 import org.apache.cxf.jaxrs.ext.search.ConditionType;
+import org.apache.cxf.jaxrs.ext.search.InterfaceProxy;
 import org.apache.cxf.jaxrs.ext.search.OrSearchCondition;
 import org.apache.cxf.jaxrs.ext.search.PropertyNotFoundException;
 import org.apache.cxf.jaxrs.ext.search.SearchBean;
@@ -381,7 +383,12 @@ public class FiqlParser<T> implements SearchConditionParser<T> {
                 boolean lastTry = names.length == 2 
                     && (isPrimitive || returnType == Date.class || returnCollection);
                 
-                Object valueObject = lastTry && ownerBean != null ? ownerBean : actualType.newInstance();
+                Object valueObject = lastTry && ownerBean != null ? ownerBean 
+                    : actualType.isInterface() 
+                    ? Proxy.newProxyInstance(this.getClass().getClassLoader(), 
+                                             new Class[]{actualType}, 
+                                             new InterfaceProxy())
+                    : actualType.newInstance();
                 Object nextObject;
                 
                 if (lastTry) {
diff --git a/rt/rs/extensions/search/src/test/java/org/apache/cxf/jaxrs/ext/search/SearchContextImplTest.java b/rt/rs/extensions/search/src/test/java/org/apache/cxf/jaxrs/ext/search/SearchContextImplTest.java
index 2c54e9662f..cf8726703c 100644
--- a/rt/rs/extensions/search/src/test/java/org/apache/cxf/jaxrs/ext/search/SearchContextImplTest.java
+++ b/rt/rs/extensions/search/src/test/java/org/apache/cxf/jaxrs/ext/search/SearchContextImplTest.java
@@ -19,8 +19,10 @@
 package org.apache.cxf.jaxrs.ext.search;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
+import org.apache.cxf.jaxrs.ext.search.fiql.FiqlParser;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.message.MessageImpl;
 
@@ -238,4 +240,76 @@ public class SearchContextImplTest extends Assert {
         assertEquals(ConditionType.EQUALS, ps.getCondition());
         assertEquals(String.class, ps.getValueType());
     }
+    
+    @Test
+    public void testIsMetCompositeObject() throws Exception {
+        SearchCondition<TheBook> filter = 
+            new FiqlParser<TheBook>(TheBook.class,
+                null,                          
+                Collections.singletonMap("address", "address.street")).parse("address==Street1");
+        
+        TheBook b = new TheBook();
+        b.setAddress(new TheOwnerAddress("Street1"));
+        assertTrue(filter.isMet(b));
+        
+        b.setAddress(new TheOwnerAddress("Street2"));
+        assertFalse(filter.isMet(b));
+    }
+    @Test
+    public void testIsMetCompositeInterface() throws Exception {
+        SearchCondition<TheBook> filter = 
+            new FiqlParser<TheBook>(TheBook.class,
+                null,                          
+                Collections.singletonMap("address", "addressInterface.street"))
+                    .parse("address==Street1");
+        
+        TheBook b = new TheBook();
+        b.setAddress(new TheOwnerAddress("Street1"));
+        assertTrue(filter.isMet(b));
+        
+        b.setAddress(new TheOwnerAddress("Street2"));
+        assertFalse(filter.isMet(b));
+    }
+        
+    public static class TheBook {
+        private TheOwnerAddressInterface address;
+
+        public TheOwnerAddress getAddress() {
+            return (TheOwnerAddress)address;
+        }
+
+        public void setAddress(TheOwnerAddress a) {
+            this.address = a;
+        }
+        
+        public TheOwnerAddressInterface getAddressInterface() {
+            return address;
+        }
+
+        public void setAddressInterface(TheOwnerAddressInterface a) {
+            this.address = a;
+        }
+    }
+    public interface TheOwnerAddressInterface {
+        String getStreet();
+        void setStreet(String street);
+    }
+    public static class TheOwnerAddress implements TheOwnerAddressInterface {
+        private String street;
+
+        public TheOwnerAddress() {
+            
+        }
+        public TheOwnerAddress(String s) {
+            this.street = s;
+        }
+        
+        public String getStreet() {
+            return street;
+        }
+
+        public void setStreet(String street) {
+            this.street = street;
+        }
+    }
 }
diff --git a/rt/rs/extensions/search/src/test/java/org/apache/cxf/jaxrs/ext/search/jpa/JPATypedQueryVisitorTest.java b/rt/rs/extensions/search/src/test/java/org/apache/cxf/jaxrs/ext/search/jpa/JPATypedQueryVisitorTest.java
index ec8b7dfb9d..fc0cd38f92 100644
--- a/rt/rs/extensions/search/src/test/java/org/apache/cxf/jaxrs/ext/search/jpa/JPATypedQueryVisitorTest.java
+++ b/rt/rs/extensions/search/src/test/java/org/apache/cxf/jaxrs/ext/search/jpa/JPATypedQueryVisitorTest.java
@@ -336,21 +336,6 @@ public class JPATypedQueryVisitorTest extends Assert {
         assertEquals("Street1", book.getAddress().getStreet());
     }
     
-    @Test
-    public void testIsMet() throws Exception {
-        SearchCondition<Book> filter = 
-            new FiqlParser<Book>(Book.class,
-                null,                          
-                Collections.singletonMap("address", "address.street")).parse("address==Street1");
-        
-        Book b = new Book();
-        b.setAddress(new OwnerAddress("Street1"));
-        assertTrue(filter.isMet(b));
-        
-        b.setAddress(new OwnerAddress("Street2"));
-        assertFalse(filter.isMet(b));
-    }
-    
     @Test
     public void testEqualsAddressQuery2() throws Exception {
         List<Book> books = queryBooks("street==Street1",
