diff --git a/api/src/main/java/org/apache/cxf/service/model/AbstractMessageContainer.java b/api/src/main/java/org/apache/cxf/service/model/AbstractMessageContainer.java
index 169a6a2c40..deb735c976 100644
--- a/api/src/main/java/org/apache/cxf/service/model/AbstractMessageContainer.java
+++ b/api/src/main/java/org/apache/cxf/service/model/AbstractMessageContainer.java
@@ -33,6 +33,7 @@ public abstract class AbstractMessageContainer extends AbstractPropertiesHolder
     private OperationInfo operation;
     private Map<QName, MessagePartInfo> messageParts 
         = new LinkedHashMap<QName, MessagePartInfo>(4);
+    private List<MessagePartInfo> outOfBandParts;
     
     /**
      * Initializes a new instance of the <code>MessagePartContainer</code>.
@@ -102,6 +103,12 @@ public abstract class AbstractMessageContainer extends AbstractPropertiesHolder
             }
             i++;
         }
+        for (MessagePartInfo p : getOutOfBandParts()) {
+            if (part == p) {
+                return i;
+            }
+            i++;
+        }
         return -1;
     }
 
@@ -111,6 +118,11 @@ public abstract class AbstractMessageContainer extends AbstractPropertiesHolder
                 return p;
             }
         }
+        for (MessagePartInfo p : getOutOfBandParts()) {
+            if (p.getIndex() == i) {
+                return p;
+            }
+        }
         return null;
     }
 
@@ -141,6 +153,12 @@ public abstract class AbstractMessageContainer extends AbstractPropertiesHolder
                 }
             }
         }
+        for (MessagePartInfo mpi2 : getOutOfBandParts()) {
+            if (name.equals(mpi2.getName())
+                || name.equals(mpi2.getConcreteName())) {
+                return mpi2;
+            }
+        }
         return mpi;
     }
     
@@ -154,7 +172,7 @@ public abstract class AbstractMessageContainer extends AbstractPropertiesHolder
         if (n == -1) {
             return null;
         }
-        for (MessagePartInfo mpi : messageParts.values()) {
+        for (MessagePartInfo mpi : getMessageParts()) {
             if (n == 0) {
                 return mpi;
             }
@@ -163,17 +181,42 @@ public abstract class AbstractMessageContainer extends AbstractPropertiesHolder
         return null;
     }    
     
+    
+    public MessagePartInfo addOutOfBandMessagePart(QName name) {
+        if (name == null) {
+            throw new IllegalArgumentException("Invalid name [" + name + "]");
+        }
+
+        MessagePartInfo part = new MessagePartInfo(name, this);
+        if (outOfBandParts == null) {
+            outOfBandParts = new ArrayList<MessagePartInfo>(1);
+        }
+        part.setIndex(messageParts.size() + outOfBandParts.size());
+        outOfBandParts.add(part);
+        return part;
+    }
+
+    
+    
     /**
      * Returns all message parts for this message.
      *
      * @return all message parts.
      */
     public List<MessagePartInfo> getMessageParts() {
-        return Collections.unmodifiableList(new ArrayList<MessagePartInfo>(messageParts.values()));
+        List<MessagePartInfo> parts = new ArrayList<MessagePartInfo>(messageParts.values());
+        parts.addAll(getOutOfBandParts());
+        return Collections.unmodifiableList(parts);
+    }
+    public List<MessagePartInfo> getOutOfBandParts() {
+        if (outOfBandParts == null) {
+            return Collections.emptyList();
+        }
+        return Collections.unmodifiableList(outOfBandParts);
     }
     
     public int size() {
-        return messageParts.size();
+        return messageParts.size() + getOutOfBandParts().size();
     }
     
 
diff --git a/api/src/main/java/org/apache/cxf/service/model/MessagePartInfo.java b/api/src/main/java/org/apache/cxf/service/model/MessagePartInfo.java
index 0278380c3a..940a742464 100644
--- a/api/src/main/java/org/apache/cxf/service/model/MessagePartInfo.java
+++ b/api/src/main/java/org/apache/cxf/service/model/MessagePartInfo.java
@@ -41,6 +41,10 @@ public final class MessagePartInfo extends AbstractPropertiesHolder implements N
         mInfo = info;
         pname = n;
     }
+    
+    public void setMessageContainer(AbstractMessageContainer info) {
+        mInfo = info;
+    }
 
     /**
      * @return Returns the name.
diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/SoapBindingFactory.java b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/SoapBindingFactory.java
index cfc175d7aa..bacb238547 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/SoapBindingFactory.java
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/SoapBindingFactory.java
@@ -500,8 +500,13 @@ public class SoapBindingFactory extends AbstractBindingFactory {
             if (StringUtils.isEmpty(partNameFilter)
                 || part.getName().equals(partNameFilter)) {
             
-                MessagePartInfo pi = minfo.addMessagePart(new QName(minfo.getName().getNamespaceURI(), part
-                                                                    .getName()));
+                QName pqname = new QName(minfo.getName().getNamespaceURI(), part.getName());
+                MessagePartInfo pi = minfo.addOutOfBandMessagePart(pqname);
+                
+                if (!minfo.getName().equals(msg.getQName())) {
+                    pi.setMessageContainer(new MessageInfo(minfo.getOperation(), null, msg.getQName()));
+                }
+                
                 if (part.getTypeName() != null) {
                     pi.setTypeQName(part.getTypeName());
                     pi.setElement(false);
@@ -577,8 +582,19 @@ public class SoapBindingFactory extends AbstractBindingFactory {
             for (SoapHeader header : headers) {
                 SoapHeaderInfo headerInfo = new SoapHeaderInfo();
                 headerInfo.setUse(header.getUse());
-                MessagePartInfo part = msg.getMessagePart(new QName(msg.getName().getNamespaceURI(), header
-                                .getPart()));
+                MessagePartInfo part = msg.getMessagePart(new QName(msg.getName().getNamespaceURI(), 
+                                                                    header.getPart()));
+                if (part != null && header.getMessage() != null
+                    && !part.getMessageInfo().getName().equals(header.getMessage())) {
+                    part = null;
+                    //out of band, let's find it
+                    for (MessagePartInfo mpi : msg.getOutOfBandParts()) {
+                        if (mpi.getName().getLocalPart().equals(header.getPart())
+                            && mpi.getMessageInfo().getName().equals(header.getMessage())) {
+                            part = mpi;
+                        }
+                    }
+                }
                 if (part != null) {
                     headerInfo.setPart(part);
                     messageParts.remove(part);
@@ -609,54 +625,9 @@ public class SoapBindingFactory extends AbstractBindingFactory {
             List<MessagePartInfo> bodyParts = new ArrayList<MessagePartInfo>();
             for (Iterator itr = parts.iterator(); itr.hasNext();) {
                 Object part = itr.next();
-                String partName = null;
                 if (part instanceof MIMEPart) {
                     MIMEPart mpart = (MIMEPart) part;
-                    if (mpart.getExtensibilityElements().size() < 1) {
-                        throw new RuntimeException("MIMEPart should at least contain one element!");
-                    }
-                    for (Object content : mpart.getExtensibilityElements()) {
-                        if (content instanceof MIMEContent) {
-                            MIMEContent mc = (MIMEContent)content;
-                            partName = mc.getPart();
-
-                            if (attParts == null) {
-                                attParts = new LinkedList<MessagePartInfo>();
-                            }
-
-                            MessagePartInfo mpi =
-                                msg.getMessagePart(new QName(msg.getName().getNamespaceURI(),
-                                                             partName));
-                            mpi.setProperty(Message.CONTENT_TYPE, mc.getType());
-                            attParts.add(mpi);
-                            // Attachments shouldn't be part of the body message
-                            bmsg.getMessageParts().remove(mpi);
-                        } else if (SOAPBindingUtil.isSOAPBody(content)) {
-                            SoapBody sb = SOAPBindingUtil.getSoapBody(content);
-                            if (sb.getParts() != null && sb.getParts().size() == 1) {
-                                partName = (String) sb.getParts().get(0);
-                            }
-
-                            // We can have a list of empty part names here.
-                            if (partName != null) {
-                                addSoapBodyPart(msg, bodyParts, partName);
-                            }
-                        } else if (SOAPBindingUtil.isSOAPHeader(content)) {
-                            SoapHeader header = SOAPBindingUtil.getSoapHeader(content);
-
-                            SoapHeaderInfo headerInfo = new SoapHeaderInfo();
-                            headerInfo.setUse(header.getUse());
-                            MessagePartInfo mpi =
-                                msg.getMessagePart(new QName(msg.getName().getNamespaceURI(), header
-                                            .getPart()));
-                            if (mpi != null) {
-                                headerInfo.setPart(mpi);
-                                messageParts.remove(part);
-                                bmsg.getMessageParts().remove(mpi);
-                                bmsg.addExtensor(headerInfo);
-                            }
-                        }
-                    }
+                    attParts = handleMimePart(mpart, attParts, msg, bmsg, bodyParts, messageParts);
                 } else {
                     addSoapBodyPart(msg, bodyParts, (String)part);
                 }
@@ -669,6 +640,75 @@ public class SoapBindingFactory extends AbstractBindingFactory {
 
         bmsg.addExtensor(bodyInfo);
     }
+    
+    private List<MessagePartInfo> handleMimePart(MIMEPart mpart, 
+                                                 List<MessagePartInfo> attParts,
+                                                 MessageInfo msg,
+                                                 BindingMessageInfo bmsg,
+                                                 List<MessagePartInfo> bodyParts,
+                                                 List<MessagePartInfo> messageParts) {
+        if (mpart.getExtensibilityElements().size() < 1) {
+            throw new RuntimeException("MIMEPart should at least contain one element!");
+        }
+        String partName = null;
+        for (Object content : mpart.getExtensibilityElements()) {
+            if (content instanceof MIMEContent) {
+                MIMEContent mc = (MIMEContent)content;
+                partName = mc.getPart();
+
+                if (attParts == null) {
+                    attParts = new LinkedList<MessagePartInfo>();
+                }
+
+                MessagePartInfo mpi =
+                    msg.getMessagePart(new QName(msg.getName().getNamespaceURI(),
+                                                 partName));
+                mpi.setProperty(Message.CONTENT_TYPE, mc.getType());
+                attParts.add(mpi);
+                // Attachments shouldn't be part of the body message
+                bmsg.getMessageParts().remove(mpi);
+            } else if (SOAPBindingUtil.isSOAPBody(content)) {
+                SoapBody sb = SOAPBindingUtil.getSoapBody(content);
+                if (sb.getParts() != null && sb.getParts().size() == 1) {
+                    partName = (String) sb.getParts().get(0);
+                }
+
+                // We can have a list of empty part names here.
+                if (partName != null) {
+                    addSoapBodyPart(msg, bodyParts, partName);
+                }
+            } else if (SOAPBindingUtil.isSOAPHeader(content)) {
+                SoapHeader header = SOAPBindingUtil.getSoapHeader(content);
+
+                SoapHeaderInfo headerInfo = new SoapHeaderInfo();
+                headerInfo.setUse(header.getUse());
+                MessagePartInfo mpi =
+                    msg.getMessagePart(new QName(msg.getName().getNamespaceURI(), header
+                                .getPart()));
+                
+                if (mpi != null && header.getMessage() != null
+                    && !mpi.getMessageInfo().getName().equals(header.getMessage())) {
+                    mpi = null;
+                    //out of band, let's find it
+                    for (MessagePartInfo mpi2 : msg.getOutOfBandParts()) {
+                        if (mpi2.getName().getLocalPart().equals(header.getPart())
+                            && mpi2.getMessageInfo().getName().equals(header.getMessage())) {
+                            mpi = mpi2;
+                        }
+                    }
+                }
+
+                if (mpi != null) {
+                    headerInfo.setPart(mpi);
+                    messageParts.remove(mpart);
+                    bmsg.getMessageParts().remove(mpi);
+                    bmsg.addExtensor(headerInfo);
+                }
+            }
+        }
+        return attParts;
+    }
+    
     private void addSoapBodyPart(MessageInfo msg, List<MessagePartInfo> bodyParts, String partName) {
         MessagePartInfo mpi = msg.getMessagePart(new QName(msg.getName().getNamespaceURI(),
                                                            partName));
diff --git a/tools/wsdlto/test/src/test/resources/wsdl2java_wsdl/pizza_wrapped.wsdl b/tools/wsdlto/test/src/test/resources/wsdl2java_wsdl/pizza_wrapped.wsdl
index b77c97bbdc..dc209d9819 100644
--- a/tools/wsdlto/test/src/test/resources/wsdl2java_wsdl/pizza_wrapped.wsdl
+++ b/tools/wsdlto/test/src/test/resources/wsdl2java_wsdl/pizza_wrapped.wsdl
@@ -73,14 +73,14 @@ under the License.
     </wsdl:portType>
 
     <wsdl:message name="CallerIDHeader">
-      <wsdl:part name="callerID" element="types:CallerIDHeader"/>
+      <wsdl:part name="parameters" element="types:CallerIDHeader"/>
     </wsdl:message>
 
     <wsdl:message name="OrderPizzaRequest">
-      <wsdl:part name="body" element="types:OrderPizza"/>
+      <wsdl:part name="parameters" element="types:OrderPizza"/>
     </wsdl:message>
     <wsdl:message name="OrderPizzaResponse">
-      <wsdl:part name="body" element="types:OrderPizzaResponse"/>
+      <wsdl:part name="parameters" element="types:OrderPizzaResponse"/>
     </wsdl:message>
 
   <wsdl:binding name="PizzaPortBinding" type="tns:Pizza">
@@ -88,7 +88,7 @@ under the License.
     <wsdl:operation name="OrderPizza">
       <soap:operation soapAction=""/>
       <wsdl:input>
-        <soap:header message="tns:CallerIDHeader" part="callerID" use="literal" />
+        <soap:header message="tns:CallerIDHeader" part="parameters" use="literal" />
         <soap:body use="literal"/>
       </wsdl:input>
       <wsdl:output>
