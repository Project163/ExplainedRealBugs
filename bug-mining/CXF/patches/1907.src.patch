diff --git a/api/src/main/java/org/apache/cxf/endpoint/ClientImpl.java b/api/src/main/java/org/apache/cxf/endpoint/ClientImpl.java
index 7716a7dfac..4c3e617398 100644
--- a/api/src/main/java/org/apache/cxf/endpoint/ClientImpl.java
+++ b/api/src/main/java/org/apache/cxf/endpoint/ClientImpl.java
@@ -411,7 +411,7 @@ public class ClientImpl
         return doInvoke(null, oi, params, context, exchange);
     }
 
-    private Object[] doInvoke(ClientCallback callback,
+    private Object[] doInvoke(final ClientCallback callback,
                               BindingOperationInfo oi,
                               Object[] params,
                               Map<String, Object> context,
@@ -469,7 +469,31 @@ public class ClientImpl
 
             PhaseInterceptorChain chain = setupInterceptorChain(endpoint);
             message.setInterceptorChain(chain);
-            chain.setFaultObserver(outFaultObserver);
+            if (callback == null) {
+                chain.setFaultObserver(outFaultObserver);
+            } else {
+                // We need to wrap the outFaultObserver if the callback is not null
+                // calling the conduitSelector.complete to make sure the fail over feature works
+                chain.setFaultObserver(new MessageObserver() {
+                    public void onMessage(Message message) {
+                        Exception ex = message.getContent(Exception.class);
+                        if (ex != null) {
+                            getConduitSelector().complete(message.getExchange());
+                            if (message.getContent(Exception.class) == null) {
+                                // handle the right response
+                                List<Object> resList = null;
+                                Message inMsg = message.getExchange().getInMessage();
+                                Map<String, Object> ctx = responseContext.get(Thread.currentThread());
+                                resList = CastUtils.cast(inMsg.getContent(List.class));
+                                Object[] result = resList == null ? null : resList.toArray();
+                                callback.handleResponse(ctx, result);
+                                return;
+                            }
+                        }
+                        outFaultObserver.onMessage(message);
+                    }
+                });
+            }
             prepareConduitSelector(message);
 
             // add additional interceptors and such
diff --git a/systests/jaxws/pom.xml b/systests/jaxws/pom.xml
index bff951ed8d..245c12e349 100644
--- a/systests/jaxws/pom.xml
+++ b/systests/jaxws/pom.xml
@@ -135,6 +135,11 @@
             <artifactId>cxf-rt-transports-http-jetty</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.cxf</groupId>
+            <artifactId>cxf-rt-features-clustering</artifactId>
+            <version>${project.version}</version>
+        </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-jdk14</artifactId>
diff --git a/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/JaxwsAsyncFailOverTest.java b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/JaxwsAsyncFailOverTest.java
new file mode 100644
index 0000000000..572c26a8db
--- /dev/null
+++ b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/JaxwsAsyncFailOverTest.java
@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.jaxws;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.jws.WebService;
+import javax.xml.ws.Response;
+
+import org.apache.cxf.clustering.FailoverFeature;
+import org.apache.cxf.clustering.RandomStrategy;
+import org.apache.cxf.greeter_control.AbstractGreeterImpl;
+import org.apache.cxf.greeter_control.Greeter;
+import org.apache.cxf.greeter_control.types.GreetMeResponse;
+import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;
+import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
+import org.apache.cxf.testutil.common.AbstractBusTestServerBase;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class JaxwsAsyncFailOverTest  extends AbstractBusClientServerTestBase {
+    static final String PORT = allocatePort(ServerNoBodyParts.class, 1);
+    static final String PORT2 = allocatePort(ServerNoBodyParts.class, 2);
+
+    public static class Server extends AbstractBusTestServerBase {
+        
+        protected void run()  {            
+            GreeterImpl implementor = new GreeterImpl();
+            String address = "http://localhost:" + PORT + "/SoapContext/GreeterPort";
+            javax.xml.ws.Endpoint.publish(address, implementor);
+        }
+        
+
+        public static void main(String[] args) {
+            try { 
+                Server s = new Server(); 
+                s.start();
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                System.exit(-1);
+            } finally { 
+                System.out.println("done!");
+            }
+        }
+        
+        @WebService(serviceName = "BasicGreeterService",
+                    portName = "GreeterPort",
+                    endpointInterface = "org.apache.cxf.greeter_control.Greeter",
+                    targetNamespace = "http://cxf.apache.org/greeter_control",
+                    wsdlLocation = "testutils/greeter_control.wsdl")
+        public class GreeterImpl extends AbstractGreeterImpl {
+        }
+    }  
+ 
+
+    @BeforeClass
+    public static void startServers() throws Exception {
+        assertTrue("server did not launch correctly", launchServer(Server.class, true));
+    }
+         
+    @Test
+    public void testUseFailOverOnClient() throws Exception {
+        List<String> serviceList = new ArrayList<String>();
+        serviceList.add("http://localhost:" + PORT + "/SoapContext/GreeterPort");
+
+        RandomStrategy strategy = new RandomStrategy();
+        strategy.setAlternateAddresses(serviceList);
+
+        FailoverFeature ff = new FailoverFeature();
+        ff.setStrategy(strategy);
+        
+        // setup the feature by using JAXWS front-end API
+        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();
+        // set a fake address to kick off the failover feature
+        factory.setAddress("http://localhost:" + PORT2 + "/SoapContext/GreeterPort");
+        factory.getFeatures().add(ff);
+        factory.setServiceClass(Greeter.class);
+        Greeter proxy = factory.create(Greeter.class);
+        
+        Response<GreetMeResponse>  response = proxy.greetMeAsync("cxf");
+        int waitCount = 0;
+        while (!response.isDone() && waitCount < 15) {
+            Thread.sleep(1000);
+            waitCount++;
+        }
+        assertTrue("Response still not received.", response.isDone());
+        
+    }
+   
+}
