diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Messages.properties b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Messages.properties
index 9484fc1824..e2005170cb 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Messages.properties
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Messages.properties
@@ -21,6 +21,7 @@
 
 XML_STREAM_EXC=Error reading XMLStreamReader.
 XML_WRITE_EXC=Error writing to XMLStreamWriter.
+COULD_NOT_VALIDATE_SOAP_HEADER_CAUSED_BY=Could not validate soapheader caused by: {0}: {1}.
 MUST_UNDERSTAND=MustUnderstand headers: {0} are not understood.
 PARSER_EXC=Could not create DOM DocumentBuilder.
 NO_OPERATION=No such operation: {0}
@@ -29,4 +30,4 @@ INVALID_VERSION="{0}", the namespace on the "{1}" element, is not a valid SOAP v
 INVALID_11_VERSION=A SOAP 1.2 message is not valid when sent to a SOAP 1.1 only endpoint.
 NO_NAMESPACE=No namespace on "{0}" element.
 BP_2211_RPCLIT_CANNOT_BE_NULL=Cannot write part {0}. RPC/Literal parts cannot be null. (WS-I BP R2211)
-UNKNOWN_RPC_LIT_PART=Found element {0} but could not find matching RPC/Literal part
\ No newline at end of file
+UNKNOWN_RPC_LIT_PART=Found element {0} but could not find matching RPC/Literal part
diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapHeaderInterceptor.java b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapHeaderInterceptor.java
index 3eba80710d..a440381514 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapHeaderInterceptor.java
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/SoapHeaderInterceptor.java
@@ -19,17 +19,24 @@
 
 package org.apache.cxf.binding.soap.interceptor;
 
+import java.io.IOException;
 import java.util.List;
+import java.util.logging.Logger;
 
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.validation.Schema;
 
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 
+import org.xml.sax.SAXException;
+
 import org.apache.cxf.binding.soap.SoapMessage;
 import org.apache.cxf.binding.soap.SoapVersion;
 import org.apache.cxf.binding.soap.model.SoapHeaderInfo;
+import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.headers.Header;
 import org.apache.cxf.interceptor.AbstractInDatabindingInterceptor;
 import org.apache.cxf.interceptor.BareInInterceptor;
@@ -38,17 +45,23 @@ import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.message.MessageContentsList;
+import org.apache.cxf.message.MessageUtils;
 import org.apache.cxf.phase.Phase;
+import org.apache.cxf.service.Service;
 import org.apache.cxf.service.model.BindingMessageInfo;
 import org.apache.cxf.service.model.BindingOperationInfo;
 import org.apache.cxf.service.model.MessagePartInfo;
+import org.apache.cxf.service.model.ServiceModelUtil;
 import org.apache.cxf.staxutils.W3CDOMStreamReader;
+import org.apache.cxf.wsdl.EndpointReferenceUtils;
 
 /**
  * Perform databinding of the SOAP headers.
  */
 public class SoapHeaderInterceptor extends AbstractInDatabindingInterceptor {
 
+    private static final Logger LOG = LogUtils.getL7dLogger(SoapHeaderInterceptor.class);
+    
     public SoapHeaderInterceptor() {
         super(Phase.UNMARSHAL);
         addAfter(BareInInterceptor.class.getName());
@@ -89,8 +102,23 @@ public class SoapHeaderInterceptor extends AbstractInDatabindingInterceptor {
         }
         
         boolean supportsNode = this.supportsDataReader(message, Node.class);
+        Service service = ServiceModelUtil.getService(message.getExchange());
+        Schema schema = EndpointReferenceUtils.getSchema(service.getServiceInfos().get(0), message
+                                                         .getExchange().getBus());
         for (SoapHeaderInfo header : headers) {
             MessagePartInfo mpi = header.getPart();
+            try {
+                if (MessageUtils.getContextualBoolean(message,
+                                                 org.apache.cxf.message.Message.SCHEMA_VALIDATION_ENABLED,
+                                                 Boolean.FALSE)) {
+                    validateHeader(message, mpi, schema);
+                }
+            } catch (Fault f) {
+                if (!isRequestor(message)) {
+                    f.setFaultCode(Fault.FAULT_CODE_CLIENT);
+                }
+                throw f;
+            }
             if (mpi.getTypeClass() != null) {
 
                 Header param = findHeader(message, mpi);
@@ -135,6 +163,32 @@ public class SoapHeaderInterceptor extends AbstractInDatabindingInterceptor {
         }
     }
 
+    private void validateHeader(SoapMessage message, MessagePartInfo mpi, Schema schema) {
+        Header param = findHeader(message, mpi);
+        Element el = null;
+        if (param != null
+            && param.getDataBinding() == null) {
+            Node source = (Node)param.getObject();
+            if (source instanceof Element) {
+                el = (Element)source;
+            } else {
+                return;
+            }
+            if (schema != null) {
+                DOMSource ds = new DOMSource(el);
+                try {
+                    schema.newValidator().validate(ds);
+                } catch (SAXException e) {
+                    throw new Fault("COULD_NOT_VALIDATE_SOAP_HEADER_CAUSED_BY", LOG, e, e.getClass()
+                        .getCanonicalName(), e.getMessage());
+                } catch (IOException e) {
+                    throw new Fault("COULD_NOT_VALIDATE_SOAP_HEADER_CAUSED_BY", LOG, e, e.getClass()
+                        .getCanonicalName(), e.getMessage());
+                }
+            }
+        }
+    }
+
     private Header findHeader(SoapMessage message, MessagePartInfo mpi) {
         return message.getHeader(mpi.getConcreteName());
     }
