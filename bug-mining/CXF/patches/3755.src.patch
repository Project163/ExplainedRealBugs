diff --git a/rt/transports/http-hc/src/main/java/org/apache/cxf/transport/http/asyncclient/AsyncHTTPConduit.java b/rt/transports/http-hc/src/main/java/org/apache/cxf/transport/http/asyncclient/AsyncHTTPConduit.java
index 3cb93af102..edf8b8cfb9 100755
--- a/rt/transports/http-hc/src/main/java/org/apache/cxf/transport/http/asyncclient/AsyncHTTPConduit.java
+++ b/rt/transports/http-hc/src/main/java/org/apache/cxf/transport/http/asyncclient/AsyncHTTPConduit.java
@@ -420,7 +420,11 @@ public class AsyncHTTPConduit extends HttpClientHTTPConduit {
                     this.basicEntity.setContentLength(out.size());
                     wrappedStream = null;
                     handleHeadersTrustCaching();
-                    out.writeCacheTo(wrappedStream);
+                    // The wrappedStrem could be null for KNOWN_HTTP_VERBS_WITH_NO_CONTENT or empty
+                    // requests (org.apache.cxf.empty.request)
+                    if (wrappedStream != null) {
+                        out.writeCacheTo(wrappedStream);
+                    }
                 }
             }
             super.close();
diff --git a/rt/transports/http-hc/src/main/java/org/apache/cxf/transport/http/asyncclient/URLConnectionAsyncHTTPConduit.java b/rt/transports/http-hc/src/main/java/org/apache/cxf/transport/http/asyncclient/URLConnectionAsyncHTTPConduit.java
index e7b280811f..9ced688c5e 100755
--- a/rt/transports/http-hc/src/main/java/org/apache/cxf/transport/http/asyncclient/URLConnectionAsyncHTTPConduit.java
+++ b/rt/transports/http-hc/src/main/java/org/apache/cxf/transport/http/asyncclient/URLConnectionAsyncHTTPConduit.java
@@ -420,7 +420,11 @@ public class URLConnectionAsyncHTTPConduit extends URLConnectionHTTPConduit {
                     this.basicEntity.setContentLength(out.size());
                     wrappedStream = null;
                     handleHeadersTrustCaching();
-                    out.writeCacheTo(wrappedStream);
+                    // The wrappedStrem could be null for KNOWN_HTTP_VERBS_WITH_NO_CONTENT or empty
+                    // requests (org.apache.cxf.empty.request)
+                    if (wrappedStream != null) {
+                        out.writeCacheTo(wrappedStream);
+                    }
                 }
             }
             super.close();
diff --git a/rt/transports/http-hc5/src/main/java/org/apache/cxf/transport/http/asyncclient/hc5/AsyncHTTPConduit.java b/rt/transports/http-hc5/src/main/java/org/apache/cxf/transport/http/asyncclient/hc5/AsyncHTTPConduit.java
index 689341c4a5..8b27ffeea1 100644
--- a/rt/transports/http-hc5/src/main/java/org/apache/cxf/transport/http/asyncclient/hc5/AsyncHTTPConduit.java
+++ b/rt/transports/http-hc5/src/main/java/org/apache/cxf/transport/http/asyncclient/hc5/AsyncHTTPConduit.java
@@ -434,7 +434,11 @@ public class AsyncHTTPConduit extends HttpClientHTTPConduit {
                     this.basicEntity.setContentLength(out.size());
                     wrappedStream = null;
                     handleHeadersTrustCaching();
-                    out.writeCacheTo(wrappedStream);
+                    // The wrappedStrem could be null for KNOWN_HTTP_VERBS_WITH_NO_CONTENT or empty
+                    // requests (org.apache.cxf.empty.request)
+                    if (wrappedStream != null) {
+                        out.writeCacheTo(wrappedStream);
+                    }
                 }
             }
             super.close();
diff --git a/rt/transports/http-hc5/src/main/java/org/apache/cxf/transport/http/asyncclient/hc5/URLConnectionAsyncHTTPConduit.java b/rt/transports/http-hc5/src/main/java/org/apache/cxf/transport/http/asyncclient/hc5/URLConnectionAsyncHTTPConduit.java
index 81010856e5..6732f1e124 100644
--- a/rt/transports/http-hc5/src/main/java/org/apache/cxf/transport/http/asyncclient/hc5/URLConnectionAsyncHTTPConduit.java
+++ b/rt/transports/http-hc5/src/main/java/org/apache/cxf/transport/http/asyncclient/hc5/URLConnectionAsyncHTTPConduit.java
@@ -436,7 +436,11 @@ public class URLConnectionAsyncHTTPConduit extends URLConnectionHTTPConduit {
                     this.basicEntity.setContentLength(out.size());
                     wrappedStream = null;
                     handleHeadersTrustCaching();
-                    out.writeCacheTo(wrappedStream);
+                    // The wrappedStrem could be null for KNOWN_HTTP_VERBS_WITH_NO_CONTENT or empty
+                    // requests (org.apache.cxf.empty.request)
+                    if (wrappedStream != null) {
+                        out.writeCacheTo(wrappedStream);
+                    }
                 }
             }
             super.close();
diff --git a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookStore.java b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookStore.java
index f2319e7d8d..a28f720742 100644
--- a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookStore.java
+++ b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookStore.java
@@ -337,6 +337,14 @@ public class BookStore {
         return book;
     }
 
+    @GET
+    @Path("/getbody")
+    @Produces("application/xml")
+    @Consumes("application/xml")
+    public Book getBodyBook(Book book) {
+        return book;
+    }
+
     @POST
     @Path("/echoxmlbookquery")
     @Produces("application/xml")
diff --git a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSAsyncClientTest.java b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSAsyncClientTest.java
index 3d6c2bed29..f56a9ee2b3 100644
--- a/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSAsyncClientTest.java
+++ b/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSAsyncClientTest.java
@@ -165,6 +165,16 @@ public class JAXRSAsyncClientTest extends AbstractBusClientServerTestBase {
         wc.close();
     }
 
+    @Test
+    public void testGetWithBody() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/getbody";
+        WebClient wc = createWebClient(address).type("application/xml").accept("application/xml");
+        try (Response response = wc.invoke("GET", new Book("Get", 123L))) {
+            assertEquals(400, response.getStatus());
+        }
+        wc.close();
+    }
+
     @Test
     public void testRetrieveBookCustomMethodAsync() throws Exception {
         String address = "http://localhost:" + PORT + "/bookstore/retrieve";
diff --git a/systests/transport-hc5/src/test/java/org/apache/cxf/systest/hc5/jaxrs/BookStore.java b/systests/transport-hc5/src/test/java/org/apache/cxf/systest/hc5/jaxrs/BookStore.java
index 393fa723b2..abbd42acac 100644
--- a/systests/transport-hc5/src/test/java/org/apache/cxf/systest/hc5/jaxrs/BookStore.java
+++ b/systests/transport-hc5/src/test/java/org/apache/cxf/systest/hc5/jaxrs/BookStore.java
@@ -120,6 +120,14 @@ public class BookStore {
         return book;
     }
 
+    @GET
+    @Path("/getbody")
+    @Produces("application/xml")
+    @Consumes("application/xml")
+    public Book getBodyBook(Book book) {
+        return book;
+    }
+
     @GET
     @Path("setcookies")
     public Response setComplexCookies() {
diff --git a/systests/transport-hc5/src/test/java/org/apache/cxf/systest/hc5/jaxrs/JAXRSAsyncClientTest.java b/systests/transport-hc5/src/test/java/org/apache/cxf/systest/hc5/jaxrs/JAXRSAsyncClientTest.java
index 51230100c2..73e68082ca 100644
--- a/systests/transport-hc5/src/test/java/org/apache/cxf/systest/hc5/jaxrs/JAXRSAsyncClientTest.java
+++ b/systests/transport-hc5/src/test/java/org/apache/cxf/systest/hc5/jaxrs/JAXRSAsyncClientTest.java
@@ -143,6 +143,16 @@ public class JAXRSAsyncClientTest extends AbstractBusClientServerTestBase {
         wc.close();
     }
 
+    @Test
+    public void testGetWithBody() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/getbody";
+        WebClient wc = createWebClient(address).type("application/xml").accept("application/xml");
+        try (Response response = wc.invoke("GET", new Book("Get", 123L))) {
+            assertEquals(400, response.getStatus());
+        }
+        wc.close();
+    }
+
     @Test
     public void testRetrieveBookCustomMethodAsync() throws Exception {
         String address = "http://localhost:" + PORT + "/bookstore/retrieve";
diff --git a/systests/transports/pom.xml b/systests/transports/pom.xml
index 7a911f3d17..f3bc7397ff 100644
--- a/systests/transports/pom.xml
+++ b/systests/transports/pom.xml
@@ -397,6 +397,11 @@
             <version>${cxf.jetty.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.jakarta.rs</groupId>
+            <artifactId>jackson-jakarta-rs-json-provider</artifactId>
+            <scope>test</scope>
+        </dependency>
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
             <artifactId>jetty-security</artifactId>
diff --git a/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/Book.java b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/Book.java
new file mode 100644
index 0000000000..d2f17f8161
--- /dev/null
+++ b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/Book.java
@@ -0,0 +1,116 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.hc.jaxrs;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import com.fasterxml.jackson.annotation.JsonTypeInfo;
+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
+
+import jakarta.ws.rs.GET;
+import jakarta.ws.rs.PUT;
+import jakarta.ws.rs.Path;
+import jakarta.ws.rs.PathParam;
+import jakarta.ws.rs.Produces;
+import jakarta.xml.bind.annotation.XmlRootElement;
+
+@JsonTypeInfo(use = Id.CLASS, include = As.PROPERTY, property = "class")
+@XmlRootElement(name = "Book")
+public class Book {
+    private String name;
+    private long id;
+    private Map<Long, Chapter> chapters = new HashMap<>();
+
+    public Book() {
+        Chapter c1 = new Chapter();
+        c1.setId(1L);
+        c1.setTitle("chapter 1");
+        chapters.put(c1.getId(), c1);
+        Chapter c2 = new Chapter();
+        c2.setId(2L);
+        c2.setTitle("chapter 2");
+        chapters.put(c2.getId(), c2);
+    }
+
+    public Book(String name, long id) {
+        this.name = name;
+        this.id = id;
+    }
+
+    public void setName(String n) {
+        name = n;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setId(long i) {
+        id = i;
+    }
+    public long getId() {
+        return id;
+    }
+
+    @PUT
+    public void cloneState(Book book) {
+        id = book.getId();
+        name = book.getName();
+    }
+
+    @GET
+    public Book retrieveState() {
+        return this;
+    }
+
+    @GET
+    @Path("chapters/{chapterid}/")
+    @Produces("application/xml;charset=ISO-8859-1")
+    public Chapter getChapter(@PathParam("chapterid") long chapterid) {
+        return chapters.get(chapterid);
+    }
+
+    @GET
+    @Path("chapters/acceptencoding/{chapterid}/")
+    @Produces("application/xml")
+    public Chapter getChapterAcceptEncoding(@PathParam("chapterid") long chapterid) {
+        return chapters.get(chapterid);
+    }
+
+    @GET
+    @Path("chapters/badencoding/{chapterid}/")
+    @Produces("application/xml;charset=UTF-48")
+    public Chapter getChapterBadEncoding(@PathParam("chapterid") long chapterid) {
+        return chapters.get(chapterid);
+    }
+
+    @Path("chapters/sub/{chapterid}/")
+    public Chapter getSubChapter(@PathParam("chapterid") long chapterid) {
+        return chapters.get(chapterid);
+    }
+
+    @Path("chaptersobject/sub/{chapterid}/")
+    public Object getSubChapterObject(@PathParam("chapterid") long chapterid) {
+        return getSubChapter(chapterid);
+    }
+
+}
diff --git a/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/BookServerAsyncClient.java b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/BookServerAsyncClient.java
new file mode 100644
index 0000000000..2e7610166d
--- /dev/null
+++ b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/BookServerAsyncClient.java
@@ -0,0 +1,106 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.hc.jaxrs;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+import com.fasterxml.jackson.jakarta.rs.json.JacksonJsonProvider;
+
+import jakarta.ws.rs.Consumes;
+import jakarta.ws.rs.Produces;
+import jakarta.ws.rs.WebApplicationException;
+import jakarta.ws.rs.core.MediaType;
+import jakarta.ws.rs.core.MultivaluedMap;
+import jakarta.ws.rs.ext.MessageBodyReader;
+import jakarta.ws.rs.ext.MessageBodyWriter;
+import org.apache.cxf.Bus;
+import org.apache.cxf.endpoint.Server;
+import org.apache.cxf.helpers.IOUtils;
+import org.apache.cxf.jaxrs.JAXRSServerFactoryBean;
+import org.apache.cxf.jaxrs.lifecycle.SingletonResourceProvider;
+import org.apache.cxf.jaxrs.provider.StreamingResponseProvider;
+import org.apache.cxf.testutil.common.AbstractServerTestServerBase;
+
+public class BookServerAsyncClient extends AbstractServerTestServerBase {
+    public static final String PORT = allocatePort(BookServerAsyncClient.class);
+
+    @Override
+    protected Server createServer(Bus bus) throws Exception {
+        JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();
+        sf.setResourceClasses(BookStore.class);
+        sf.setResourceProvider(BookStore.class,
+                               new SingletonResourceProvider(new BookStore(), true));
+        sf.setAddress("http://localhost:" + PORT + "/");
+        sf.setProvider(new BooleanReaderWriter());
+        sf.setProvider(new JacksonJsonProvider());
+        sf.setProvider(new StreamingResponseProvider<Book>());
+        sf.getProperties(true).put("default.content.type", "*/*");
+        return sf.create();
+    }
+
+    public static void main(String[] args) throws Exception {
+        new BookServerAsyncClient().start();
+    }
+
+    @Consumes("text/boolean")
+    @Produces("text/boolean")
+    public static class BooleanReaderWriter implements
+        MessageBodyReader<Object>, MessageBodyWriter<Boolean> {
+
+        @Override
+        public boolean isReadable(Class<?> arg0, Type arg1, Annotation[] arg2, MediaType arg3) {
+            return true;
+        }
+
+        @Override
+        public Object readFrom(Class<Object> arg0, Type arg1, Annotation[] arg2, MediaType arg3,
+                             MultivaluedMap<String, String> arg4, InputStream is) throws IOException,
+            WebApplicationException {
+            return Boolean.valueOf(IOUtils.readStringFromStream(is));
+        }
+
+        @Override
+        public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations,
+                                   MediaType mediaType) {
+            return true;
+        }
+
+        @Override
+        public long getSize(Boolean t, Class<?> type, Type genericType, Annotation[] annotations,
+                            MediaType mediaType) {
+            return -1;
+        }
+
+        @Override
+        public void writeTo(Boolean t, Class<?> type, Type genericType, Annotation[] annotations,
+                            MediaType mediaType, MultivaluedMap<String, Object> httpHeaders,
+                            OutputStream os) throws IOException, WebApplicationException {
+            byte[] bytes = t.toString().getBytes("UTF-8");
+            os.write(bytes);
+
+        }
+
+
+    }
+}
diff --git a/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/BookStore.java b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/BookStore.java
new file mode 100644
index 0000000000..632c91e770
--- /dev/null
+++ b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/BookStore.java
@@ -0,0 +1,237 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.hc.jaxrs;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.HashMap;
+import java.util.Map;
+
+import jakarta.ws.rs.Consumes;
+import jakarta.ws.rs.DELETE;
+import jakarta.ws.rs.GET;
+import jakarta.ws.rs.MatrixParam;
+import jakarta.ws.rs.NotFoundException;
+import jakarta.ws.rs.POST;
+import jakarta.ws.rs.PUT;
+import jakarta.ws.rs.Path;
+import jakarta.ws.rs.PathParam;
+import jakarta.ws.rs.Produces;
+import jakarta.ws.rs.WebApplicationException;
+import jakarta.ws.rs.core.Context;
+import jakarta.ws.rs.core.MultivaluedMap;
+import jakarta.ws.rs.core.Response;
+import jakarta.ws.rs.core.Response.Status;
+import jakarta.ws.rs.core.StreamingOutput;
+import jakarta.ws.rs.core.UriInfo;
+import org.apache.cxf.annotations.GZIP;
+import org.apache.cxf.jaxrs.ext.MessageContext;
+import org.apache.cxf.jaxrs.ext.Oneway;
+import org.apache.cxf.jaxrs.ext.PATCH;
+import org.apache.cxf.jaxrs.ext.StreamingResponse;
+import org.apache.cxf.jaxrs.impl.MetadataMap;
+import org.apache.cxf.message.Message;
+import org.apache.cxf.phase.PhaseInterceptorChain;
+
+@Path("/bookstore")
+@GZIP(threshold = 1)
+public class BookStore {
+
+    private Map<Long, Book> books = new HashMap<>();
+    private long bookId = 123;
+
+    @Context
+    private UriInfo ui;
+    @Context
+    private MessageContext messageContext;
+
+    public BookStore() {
+        init();
+    }
+
+    @GET
+    @Path("/")
+    public Book getBookRoot() {
+        return new Book("root", 124L);
+    }
+    @PUT
+    @Path("/updatebook/{id}")
+    @Consumes("application/xml")
+    @Produces("application/xml")
+    public Book updateEchoBook(Book book) {
+        if (book.getId() != Long.parseLong(ui.getPathParameters().getFirst("id"))) {
+            throw new WebApplicationException(404);
+        }
+        return new Book("Updated " + book.getName(), book.getId());
+    }
+
+    @GET
+    @Path("/books/wildcard")
+    @Produces("text/*")
+    public String getBookTextWildcard() {
+        return "book";
+    }
+
+    @RETRIEVE
+    @Path("/retrieve")
+    @Produces("application/xml")
+    @Consumes("application/xml")
+    public Book retrieveBook(Book book) {
+        return book;
+    }
+
+    @PATCH
+    @Path("/patch")
+    @Produces("application/xml")
+    @Consumes("application/xml")
+    public Response patchBook(Book book) {
+        if ("Timeout".equals(book.getName())) {
+            try {
+                Thread.sleep(2000);
+            } catch (InterruptedException e) {
+            }
+            return Response.ok(book).build();
+        }
+        return Response.ok(book).build();
+    }
+
+    @DELETE
+    @Path("/deletebody")
+    @Produces("application/xml")
+    @Consumes("application/xml")
+    public Book deleteBodyBook(Book book) {
+        return book;
+    }
+
+    @GET
+    @Path("/getbody")
+    @Produces("application/xml")
+    @Consumes("application/xml")
+    public Book getBodyBook(Book book) {
+        return book;
+    }
+
+    @GET
+    @Path("setcookies")
+    public Response setComplexCookies() {
+        return Response.ok().header("Set-Cookie",
+                                    "bar.com.anoncart=107894933471602436; Domain=.bar.com;"
+                                    + " Expires=Thu, 01-Oct-2020 23:44:22 GMT; Path=/")
+                                    .build();
+    }
+
+    @GET
+    @Path("books/check/{id}")
+    @Produces("text/plain,text/boolean")
+    public boolean checkBook(@PathParam("id") Long id) {
+        return books.containsKey(id);
+    }
+
+    @GET
+    @Path("/books/statusFromStream")
+    @Produces("text/xml")
+    public Response statusFromStream() {
+        return Response.ok(new ResponseStreamingOutputImpl()).type("text/plain").build();
+    }
+
+    @SuppressWarnings("rawtypes")
+    @GET
+    @Path("/books/streamingresponse")
+    @Produces("text/xml")
+    public Response getBookStreamingResponse() {
+        return Response.ok(new StreamingResponse() {
+
+            @SuppressWarnings("unchecked")
+            @Override
+            public void writeTo(Writer writer) throws IOException {
+                writer.write(new Book("stream", 124L));
+            }
+
+        }).build();
+    }
+
+    @POST
+    @Path("/oneway")
+    @Oneway
+    public void onewayRequest() {
+        if (!PhaseInterceptorChain.getCurrentMessage().getExchange().isOneWay()) {
+            throw new WebApplicationException();
+        }
+    }
+    
+    @POST
+    @Path("/no-content")
+    public void noContent() {
+    }
+
+    @GET
+    @Path("/books/{bookId}/")
+    @Produces("application/xml")
+    public Book getBook(@PathParam("bookId") String id) {
+        return doGetBook(id);
+    }
+
+    @GET
+    @Path("/segment/matrix")
+    public Book getBookByMatrixParams(@MatrixParam("first") String s1,
+                                      @MatrixParam("second") String s2) throws Exception {
+
+        return doGetBook(s1 + s2);
+    }
+
+    public final String init() {
+        books.clear();
+        bookId = 123;
+
+        Book book = new Book();
+        book.setId(bookId);
+        book.setName("CXF in Action");
+        books.put(book.getId(), book);
+
+        return "OK";
+    }
+
+    private final class ResponseStreamingOutputImpl implements StreamingOutput {
+        public void write(OutputStream output) throws IOException, WebApplicationException {
+            if (!"text/plain".equals(BookStore.this.messageContext.get("Content-Type"))) {
+                throw new RuntimeException();
+            }
+            BookStore.this.messageContext.put(Message.RESPONSE_CODE, 503);
+            MultivaluedMap<String, String> headers = new MetadataMap<>();
+            headers.putSingle("Content-Type", "text/custom+plain");
+            headers.putSingle("CustomHeader", "CustomValue");
+            BookStore.this.messageContext.put(Message.PROTOCOL_HEADERS, headers);
+
+            output.write("Response is not available".getBytes());
+        }
+    }
+
+    private Book doGetBook(String id) {
+        Book book = books.get(Long.parseLong(id));
+        if (book != null) {
+            return book;
+        }
+        
+        throw new NotFoundException(Response
+            .status(Status.NOT_FOUND)
+            .entity("The book with ID '" + id + "' was not found")
+            .build());
+    }
+}
diff --git a/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/Chapter.java b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/Chapter.java
new file mode 100644
index 0000000000..9b9dcf2a26
--- /dev/null
+++ b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/Chapter.java
@@ -0,0 +1,106 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.hc.jaxrs;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import jakarta.ws.rs.GET;
+import jakarta.ws.rs.Path;
+import jakarta.ws.rs.PathParam;
+import jakarta.ws.rs.Produces;
+import jakarta.ws.rs.QueryParam;
+import jakarta.ws.rs.core.Context;
+import jakarta.ws.rs.core.UriInfo;
+import jakarta.xml.bind.annotation.XmlRootElement;
+
+
+@XmlRootElement(name = "Chapter")
+public class Chapter {
+    private String title;
+    private long id;
+
+    public Chapter() {
+    }
+
+    public void setTitle(String n) {
+        title = n;
+    }
+
+    public String getTitle() {
+        return title;
+    }
+
+    public void setId(long i) {
+        id = i;
+    }
+    public long getId() {
+        return id;
+    }
+
+    @GET
+    @Path("/recurse")
+    @Produces("application/xml")
+    public Chapter getItself() {
+        return this;
+    }
+
+    @Path("/recurse2")
+    public Chapter getItself2() {
+        return this;
+    }
+
+    @GET
+    @Produces("application/xml;charset=ISO-8859-1")
+    public Chapter get() {
+        return this;
+    }
+
+    @GET
+    @Path("/ids")
+    @Produces("application/xml;charset=ISO-8859-1")
+    public Chapter getWithBookId(@PathParam("bookId") int bookId,
+                                 @PathParam("chapterid") int chapterId) {
+        if (bookId != 123 || chapterId != 1) {
+            throw new RuntimeException();
+        }
+        return this;
+    }
+
+
+    @GET
+    @Path("/matched-resources")
+    @Produces("text/plain")
+    public String getMatchedResources(@Context UriInfo ui) {
+        List<String> list = new ArrayList<>();
+        for (Object obj : ui.getMatchedResources()) {
+            list.add(obj.toString());
+        }
+        return list.toString();
+    }
+
+    @GET
+    @Path("/matched!uris")
+    @Produces("text/plain")
+    public String getMatchedUris(@Context UriInfo ui,
+                                 @QueryParam("decode") String decode) {
+        return ui.getMatchedURIs(Boolean.parseBoolean(decode)).toString();
+    }
+}
diff --git a/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/JAXRSAsyncClientTest.java b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/JAXRSAsyncClientTest.java
new file mode 100644
index 0000000000..b6318cf9c6
--- /dev/null
+++ b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/JAXRSAsyncClientTest.java
@@ -0,0 +1,647 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.hc.jaxrs;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+import jakarta.annotation.Priority;
+import jakarta.ws.rs.Consumes;
+import jakarta.ws.rs.NotFoundException;
+import jakarta.ws.rs.ProcessingException;
+import jakarta.ws.rs.Produces;
+import jakarta.ws.rs.WebApplicationException;
+import jakarta.ws.rs.client.Client;
+import jakarta.ws.rs.client.ClientBuilder;
+import jakarta.ws.rs.client.ClientRequestContext;
+import jakarta.ws.rs.client.ClientResponseContext;
+import jakarta.ws.rs.client.ClientResponseFilter;
+import jakarta.ws.rs.client.Entity;
+import jakarta.ws.rs.client.Invocation;
+import jakarta.ws.rs.client.InvocationCallback;
+import jakarta.ws.rs.client.ResponseProcessingException;
+import jakarta.ws.rs.client.WebTarget;
+import jakarta.ws.rs.core.GenericType;
+import jakarta.ws.rs.core.MediaType;
+import jakarta.ws.rs.core.MultivaluedMap;
+import jakarta.ws.rs.core.Response;
+import jakarta.ws.rs.ext.MessageBodyReader;
+import jakarta.ws.rs.ext.MessageBodyWriter;
+import jakarta.xml.ws.Holder;
+import org.apache.cxf.jaxrs.client.ClientConfiguration;
+import org.apache.cxf.jaxrs.client.JAXRSClientFactory;
+import org.apache.cxf.jaxrs.client.WebClient;
+import org.apache.cxf.jaxrs.model.AbstractResourceInfo;
+import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
+import org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduit;
+import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.nullValue;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class JAXRSAsyncClientTest extends AbstractBusClientServerTestBase {
+    public static final String PORT = BookServerAsyncClient.PORT;
+
+    @BeforeClass
+    public static void startServers() throws Exception {
+        AbstractResourceInfo.clearAllMaps();
+        assertTrue("server did not launch correctly", launchServer(BookServerAsyncClient.class, true));
+        createStaticBus();
+    }
+
+    @Test
+    public void testRetrieveBookCustomMethodAsyncSync() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/retrieve";
+        WebClient wc = createWebClient(address).type("application/xml").accept("application/xml");
+        Book book = wc.invoke("RETRIEVE", new Book("Retrieve", 123L), Book.class);
+        assertEquals("Retrieve", book.getName());
+        wc.close();
+    }
+
+    @Test
+    public void testPatchBook() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/patch";
+        WebClient wc = createWebClient(address).type("application/xml");
+        Book book = wc.invoke("PATCH", new Book("Patch", 123L), Book.class);
+        assertEquals("Patch", book.getName());
+        wc.close();
+    }
+
+    @Test
+    public void testPatchBookTimeout() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/patch";
+        WebClient wc = WebClient.create(address).type("application/xml");
+        ClientConfiguration clientConfig = WebClient.getConfig(wc);
+        clientConfig.getRequestContext().put(AsyncHTTPConduit.USE_ASYNC, true);
+        HTTPClientPolicy clientPolicy = clientConfig.getHttpConduit().getClient();
+        clientPolicy.setReceiveTimeout(500);
+        clientPolicy.setConnectionTimeout(500);
+        try {
+            Book book = wc.invoke("PATCH", new Book("Timeout", 123L), Book.class);
+            fail("should throw an exception due to timeout, instead got " + book);
+        } catch (jakarta.ws.rs.ProcessingException e) {
+            //expected!!!
+        }
+    }
+
+    @Test
+    public void testPatchBookInputStream() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/patch";
+        WebClient wc = createWebClient(address).type("application/xml");
+        Book book = wc.invoke("PATCH",
+                              new ByteArrayInputStream(
+                                  "<Book><name>Patch</name><id>123</id></Book>".getBytes()),
+                              Book.class);
+        assertEquals("Patch", book.getName());
+        wc.close();
+    }
+
+    @Test
+    public void testDeleteWithBody() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/deletebody";
+        WebClient wc = createWebClient(address).type("application/xml").accept("application/xml");
+        Book book = wc.invoke("DELETE", new Book("Delete", 123L), Book.class);
+        assertEquals("Delete", book.getName());
+        wc.close();
+    }
+
+    @Test
+    public void testGetWithBody() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/getbody";
+        WebClient wc = createWebClient(address).type("application/xml").accept("application/xml");
+        try (Response response = wc.invoke("GET", new Book("Get", 123L))) {
+            assertEquals(400, response.getStatus());
+        }
+        wc.close();
+    }
+
+    @Test
+    public void testRetrieveBookCustomMethodAsync() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/retrieve";
+        WebClient wc = createWebClient(address).accept("application/xml");
+        Future<Book> book = wc.async().method("RETRIEVE", Entity.xml(new Book("Retrieve", 123L)),
+                                              Book.class);
+        assertEquals("Retrieve", book.get().getName());
+        wc.close();
+    }
+
+    @Test
+    public void testGetBookAsyncResponseNotFound() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/bookheaders/404";
+        WebClient wc = createWebClient(address);
+        Future<Response> future = wc.async().get(Response.class);
+        assertEquals(404, future.get().getStatus());
+        wc.close();
+    }
+
+    @Test
+    public void testGetBookAsyncUpdate() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/updatebook/124";
+        WebClient wc = createWebClient(address);
+        Future<Response> future = wc.async().put(Entity.xml(new Book("My CXF Book", 124)));
+        final Response response = future.get();
+        assertEquals(200, response.getStatus());
+        final Book book = response.readEntity(Book.class);
+        assertThat(book.getId(), equalTo(124L));
+        assertThat(book.getName(), equalTo("Updated My CXF Book"));
+        wc.close();
+    }
+
+    @Test
+    public void testGetBookAsync404() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/bookheaders/404";
+        WebClient wc = createWebClient(address);
+        Future<Book> future = wc.async().get(Book.class);
+        try {
+            future.get();
+            fail("Exception expected");
+        } catch (ExecutionException ex) {
+            assertTrue(ex.getCause() instanceof NotFoundException);
+        }
+        wc.close();
+    }
+
+    @Test
+    public void testNonExistentHostnameAsync() throws Exception {
+        String address = "http://168.168.168.168/bookstore";
+        List<Object> providers = new ArrayList<>();
+        providers.add(new TestResponseFilter());
+        WebClient wc = createWebClient(address, providers);
+        Future<Book> future = wc.async().get(Book.class);
+        try {
+            future.get();
+            fail("Exception expected");
+        } catch (ExecutionException ex) {
+            Throwable cause = ex.getCause();
+            assertTrue(cause instanceof ProcessingException);
+            assertTrue(ex.getCause().getCause() instanceof IOException);
+        } finally {
+            wc.close();
+        }
+    }
+    
+    @Test
+    public void testNonExistentHostnameGet() throws Exception {
+        String address = "http://168.168.168.168/bookstore";
+        Client c = ClientBuilder.newClient();
+        c.register(new TestResponseFilter());
+        WebTarget t1 = c.target(address);
+        Future<Response> future = t1.request().async().get();
+        try {
+            future.get();
+            fail("Exception expected");
+        } catch (ExecutionException ex) {
+            Throwable cause = ex.getCause();
+            assertTrue(cause instanceof ProcessingException);
+            assertTrue(ex.getCause().getCause() instanceof IOException);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test
+    public void testNonExistentHostnamePost() throws Exception {
+        Client client = ClientBuilder.newClient();
+        WebTarget target = client.target("http://168.168.168.168/");
+        Invocation.Builder builder = target.request();
+        Entity<String> entity = Entity.entity("entity", MediaType.WILDCARD_TYPE);
+        Invocation invocation = builder.buildPost(entity);
+        Future<String> future = invocation.submit(
+            new GenericType<String>() {
+            }
+        );
+
+        try {
+            future.get();
+        } catch (Exception ex) {
+            Throwable cause = ex.getCause();
+            assertTrue(cause instanceof ProcessingException);
+        }
+    }
+
+    @Test
+    public void testPostBookProcessingException() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/";
+        List<Object> providers = new ArrayList<>();
+        providers.add(new FaultyBookWriter());
+        WebClient wc = createWebClient(address, providers);
+
+        Future<Book> future = wc.async().post(Entity.xml(new Book()), Book.class);
+        try {
+            future.get();
+            fail("Exception expected");
+        } catch (ExecutionException ex) {
+            assertTrue(ex.getCause() instanceof ProcessingException);
+        }
+        wc.close();
+    }
+
+    @Test
+    public void testGetBookResponseProcessingException() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/books/123";
+        List<Object> providers = new ArrayList<>();
+        providers.add(new FaultyBookReader());
+        WebClient wc = createWebClient(address, providers);
+
+        Future<Book> future = wc.async().get(Book.class);
+        try {
+            future.get();
+            fail("Exception expected");
+        } catch (ExecutionException ex) {
+            assertTrue(ex.getCause() instanceof ResponseProcessingException);
+        }
+        wc.close();
+    }
+
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void testGenericInvocationCallback() throws Exception {
+        InvocationCallback<?> callback = createGenericInvocationCallback();
+        String address = "http://localhost:" + PORT + "/bookstore/books/check/123";
+        Client client = ClientBuilder
+            .newBuilder()
+            .register(new BookServerAsyncClient.BooleanReaderWriter())
+            .build();
+
+        client
+            .target(address)
+            .request()
+            .accept("text/boolean")
+            .async()
+            .get(callback)
+            .get();
+
+        assertTrue(((GenericInvocationCallback)callback).getResult().readEntity(Boolean.class));
+    }
+
+    @Test
+    public void testAsyncProxyPrimitiveResponse() throws Exception {
+        String address = "http://localhost:" + PORT;
+        final Holder<Boolean> holder = new Holder<>();
+        final InvocationCallback<Boolean> callback = new InvocationCallback<Boolean>() {
+            public void completed(Boolean response) {
+                holder.value = response;
+            }
+            public void failed(Throwable error) {
+            }
+        };
+
+        BookStore store = JAXRSClientFactory.create(address, BookStore.class);
+        WebClient.getConfig(store).getRequestContext().put(AsyncHTTPConduit.USE_ASYNC, true);
+        WebClient.getConfig(store).getRequestContext().put(InvocationCallback.class.getName(), callback);
+        
+        store.checkBook(123L);
+        Thread.sleep(3000);
+        assertTrue(holder.value);
+    }
+    
+    @Test
+    public void testAsyncProxyBookResponse() throws Exception {
+        String address = "http://localhost:" + PORT;
+        final Holder<Book> holder = new Holder<>();
+        final InvocationCallback<Book> callback = new InvocationCallback<Book>() {
+            public void completed(Book response) {
+                holder.value = response;
+            }
+            public void failed(Throwable error) {
+            }
+        };
+
+        BookStore store = JAXRSClientFactory.create(address, BookStore.class);
+        WebClient.getConfig(store).getRequestContext().put(AsyncHTTPConduit.USE_ASYNC, true);
+        WebClient.getConfig(store).getRequestContext().put(InvocationCallback.class.getName(), callback);
+        
+        Book book = store.getBookByMatrixParams("12", "3");
+        assertNull(book);
+        Thread.sleep(3000);
+        assertNotNull(holder.value);
+        assertEquals(123L, holder.value.getId());
+    }
+
+    @Test
+    public void testAsyncProxyMultipleCallbacks() throws Exception {
+        String address = "http://localhost:" + PORT;
+        final Holder<Book> bookHolder = new Holder<>();
+        final InvocationCallback<Book> bookCallback = new InvocationCallback<Book>() {
+            public void completed(Book response) {
+                bookHolder.value = response;
+            }
+            public void failed(Throwable error) {
+            }
+        };
+        final Holder<Boolean> booleanHolder = new Holder<>();
+        final InvocationCallback<Boolean> booleanCallback = new InvocationCallback<Boolean>() {
+            public void completed(Boolean response) {
+                booleanHolder.value = response;
+            }
+            public void failed(Throwable error) {
+            }
+        };
+        List<InvocationCallback<?>> callbacks = new ArrayList<>();
+        callbacks.add(bookCallback);
+        callbacks.add(booleanCallback);
+
+        BookStore store = JAXRSClientFactory.create(address, BookStore.class);
+        WebClient.getConfig(store).getRequestContext().put(InvocationCallback.class.getName(), callbacks);
+        WebClient.getConfig(store).getRequestContext().put(AsyncHTTPConduit.USE_ASYNC, true);
+
+        Book book = store.getBookByMatrixParams("12", "3");
+        assertNull(book);
+        Thread.sleep(3000);
+        assertNotNull(bookHolder.value);
+        assertEquals(123L, bookHolder.value.getId());
+
+        store.checkBook(123L);
+        Thread.sleep(3000);
+        assertTrue(booleanHolder.value);
+    }
+
+    @Test
+    public void testGetBookAsyncNotFoundCallback() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/bookheaders/404";
+        WebClient wc = createWebClient(address);
+        final Holder<Object> holder = new Holder<>();
+        InvocationCallback<Object> callback = createCallback(holder);
+        try {
+            wc.async().get(callback).get();
+            fail("Exception expected");
+        } catch (ExecutionException ex) {
+            assertTrue(ex.getCause() instanceof NotFoundException);
+            assertTrue(ex.getCause() == holder.value);
+        }
+        wc.close();
+    }
+
+    @Test
+    public void testClientResponseFilter() throws Exception {
+        final String address = "http://localhost:" + PORT + "/bookstore/books/wildcard";
+        try (Response response = ClientBuilder.newClient()
+             .register(AddHeaderClientResponseFilter.class)
+             .target(address)
+             .request("text/plain")
+             .async()
+             .get()
+             .get()) {
+            assertEquals(200, response.getStatus());
+            assertEquals("true", response.getHeaderString("X-Done"));
+        }
+    }
+
+    @Test
+    public void testExceptionWhenMultipleClientResponseFilters() {
+        final String address = "http://localhost:" + PORT + "/bookstore/books/wildcard";
+        try (Response response = ClientBuilder.newClient()
+             .register(AddHeaderClientResponseFilter.class)
+             .register(FaultyClientResponseFilter.class)
+             .target(address)
+             .request()
+             .async()
+             .put(null)
+             .get(10, TimeUnit.SECONDS)) {
+            fail("Should not be invoked");
+        } catch (ExecutionException ex) {
+            assertThat(ex.getCause(), is(instanceOf(ResponseProcessingException.class)));
+        } catch (Throwable ex) {
+            fail("Should be handled by ResponseProcessingException block");
+        }
+    }
+
+    @Test
+    public void testExceptionInClientResponseFilter() throws Exception {
+        final String address = "http://localhost:" + PORT + "/bookstore/books/wildcard";
+        try (Response response = ClientBuilder.newClient()
+             .register(FaultyClientResponseFilter.class)
+             .target(address)
+             .request("text/plain")
+             .async()
+             .get()
+             .get(10, TimeUnit.SECONDS)) {
+            fail("Should raise ResponseProcessingException");
+        } catch (ExecutionException ex) {
+            assertThat(ex.getCause(), is(instanceOf(ResponseProcessingException.class)));
+        } catch (Throwable ex) {
+            fail("Should be handled by ResponseProcessingException block");
+        }
+    }
+
+    @Test
+    public void testExceptionInClientResponseFilterWhenNotFound() throws Exception {
+        final String address = "http://localhost:" + PORT + "/bookstore/notFound";
+        try (Response response = ClientBuilder.newClient()
+             .register(FaultyClientResponseFilter.class)
+             .target(address)
+             .request("text/plain")
+             .async()
+             .put(null)
+             .get(10, TimeUnit.SECONDS)) {
+            fail("Should not be invoked");
+        } catch (ExecutionException ex) {
+            assertThat(ex.getCause(), is(instanceOf(ResponseProcessingException.class)));
+        } catch (Throwable ex) {
+            fail("Should be handled by ResponseProcessingException block");
+        }
+    }
+    
+    @Test
+    public void testNotFound() throws Exception {
+        final String address = "http://localhost:" + PORT + "/bookstore/notFound";
+        try (Response response = ClientBuilder.newClient()
+             .target(address)
+             .request("text/plain")
+             .async()
+             .put(null)
+             .get(10, TimeUnit.SECONDS)) {
+            assertThat(response.getStatus(), equalTo(404));
+        }
+    }
+
+    @Test
+    public void testStatusAngHeadersFromStream() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/books/statusFromStream";
+        WebClient wc = createWebClient(address).accept("text/xml");
+        Response r = wc.async().get().get();
+        assertEquals(503, r.getStatus());
+        assertEquals("text/custom+plain", r.getMediaType().toString());
+        assertEquals("CustomValue", r.getHeaderString("CustomHeader"));
+        assertEquals("Response is not available", r.readEntity(String.class));
+    }
+    
+    @Test
+    public void testBookAsStream() throws Exception {
+        String address = "http://localhost:" + PORT + "/bookstore/books/streamingresponse";
+        WebClient wc = createWebClient(address).accept("text/xml");
+        Response r = wc.async().get().get();
+        assertEquals(200, r.getStatus());
+        final Book book = r.readEntity(Book.class);
+        assertThat(book.getId(), equalTo(124L));
+        assertThat(book.getName(), equalTo("stream"));
+    }
+
+    @Test
+    public void testSetCookieWebClient() throws Exception {
+        final String address = "http://localhost:" + PORT + "/bookstore/setcookies";
+        WebClient client = createWebClient(address);
+        Response r = client.type("*/*").async().get().get();
+        assertEquals(200, r.getStatus());
+        List<Object> cookies = r.getMetadata().get("Set-Cookie");
+        assertNotNull(cookies);
+        assertEquals(1, cookies.size());
+    }
+    
+   
+    @Test
+    public void testBookNoContent() throws Exception {
+        final String address = "http://localhost:" + PORT + "/bookstore/no-content";
+        WebClient client = createWebClient(address);
+        Response r = client.type("*/*").async().post(null).get();
+        assertEquals(204, r.getStatus());
+        assertThat(r.readEntity(String.class), equalTo(""));
+    }
+
+    @Test
+    public void testBookOneway() throws Exception {
+        final String address = "http://localhost:" + PORT + "/bookstore/oneway";
+        WebClient client = createWebClient(address, new TestResponseFilter());
+        Response r = client.type("*/*").async().post(null).get();
+        assertEquals(202, r.getStatus());
+        assertThat(r.getEntity(), is(nullValue()));
+        assertThat(r.getHeaderString("X-Filter"), equalTo("true"));
+    }
+
+    private WebClient createWebClient(String address, Object ... providers) {
+        final WebClient wc = WebClient.create(address, Arrays.asList(providers));
+        WebClient.getConfig(wc).getRequestContext().put(AsyncHTTPConduit.USE_ASYNC, true);
+        return wc;
+    }
+
+    private InvocationCallback<Object> createCallback(final Holder<Object> holder) {
+        return new InvocationCallback<Object>() {
+            public void completed(Object response) {
+                holder.value = response;
+            }
+            public void failed(Throwable error) {
+                holder.value = error;
+            }
+        };
+    }
+
+    @Produces("application/xml")
+    private static final class FaultyBookWriter implements MessageBodyWriter<Book> {
+        @Override
+        public long getSize(Book arg0, Class<?> arg1, Type arg2, Annotation[] arg3, MediaType arg4) {
+            return 0;
+        }
+
+        @Override
+        public boolean isWriteable(Class<?> arg0, Type arg1, Annotation[] arg2, MediaType arg3) {
+            return true;
+        }
+
+        @Override
+        public void writeTo(Book arg0, Class<?> arg1, Type arg2, Annotation[] arg3, MediaType arg4,
+                MultivaluedMap<String, Object> arg5, OutputStream arg6) throws IOException, WebApplicationException {
+            throw new RuntimeException();
+        }
+    }
+
+    @Consumes("application/xml")
+    private static final class FaultyBookReader implements MessageBodyReader<Book> {
+        @Override
+        public boolean isReadable(Class<?> arg0, Type arg1, Annotation[] arg2, MediaType arg3) {
+            return true;
+        }
+
+        @Override
+        public Book readFrom(Class<Book> arg0, Type arg1, Annotation[] arg2, MediaType arg3,
+                MultivaluedMap<String, String> arg4, InputStream arg5) throws IOException, WebApplicationException {
+            throw new RuntimeException();
+        }
+    }
+
+    public static class TestResponseFilter implements ClientResponseFilter {
+        @Override
+        public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext)
+            throws IOException {
+            responseContext.getHeaders().add("X-Filter", "true");
+        }
+    }
+
+    private static final class GenericInvocationCallback<T> implements InvocationCallback<T> {
+        private Object result;
+
+        @Override
+        public void completed(final Object o) {
+            result = o;
+        }
+
+        @Override
+        public void failed(final Throwable throwable) {
+            // complete
+        }
+
+        public Response getResult() {
+            return (Response)result;
+        }
+    }
+    
+    @Priority(2)
+    public static class AddHeaderClientResponseFilter implements ClientResponseFilter {
+        @Override
+        public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext) 
+                throws IOException {
+            responseContext.getHeaders().add("X-Done", "true");
+        }
+    }
+
+    @Priority(1)
+    public static class FaultyClientResponseFilter implements ClientResponseFilter {
+        @Override
+        public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext) 
+                throws IOException {
+            throw new IOException("Exception from client response filter");
+        }
+    }
+    
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    private static <T> InvocationCallback<T> createGenericInvocationCallback() {
+        return new GenericInvocationCallback();
+    }
+}
diff --git a/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/RETRIEVE.java b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/RETRIEVE.java
new file mode 100644
index 0000000000..e9346cdc3f
--- /dev/null
+++ b/systests/transports/src/test/java/org/apache/cxf/systest/hc/jaxrs/RETRIEVE.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.hc.jaxrs;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import jakarta.ws.rs.HttpMethod;
+
+@Target({ElementType.METHOD })
+@Retention(RetentionPolicy.RUNTIME)
+@HttpMethod("RETRIEVE")
+public @interface RETRIEVE {
+
+}
