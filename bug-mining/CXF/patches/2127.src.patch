diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder.java
index 5c6202e1f7..b67c84869c 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder.java
@@ -24,7 +24,6 @@ import java.util.Collection;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Marshaller;
-import javax.xml.namespace.QName;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
@@ -129,7 +128,25 @@ public abstract class EncoderDecoder {
             return false;
         }
         
-        // get the SOAP:Header element
+        // add WSRM namespace declaration to header, instead of repeating in each individual child node
+        Element header = getSoapHeader(doc);
+        addNamespaceDecl(header);
+        
+        // build individual headers
+        Marshaller marshaller = getContext().createMarshaller();
+        marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
+        buildHeaders(seq, acks, reqs, rmps.isLastMessage(), header, marshaller);
+        return true;
+    }
+
+    /**
+     * Get the SOAP Header element from a message document.
+     * 
+     * @param doc
+     * @return header
+     * @throws JAXBException if not found
+     */
+    protected Element getSoapHeader(Document doc) throws JAXBException {
         NodeList nodes = doc.getDocumentElement().getChildNodes();
         Element header = null;
         for (int i = 0; i < nodes.getLength(); i++) {
@@ -142,15 +159,22 @@ public abstract class EncoderDecoder {
         if (header == null) {
             throw new JAXBException("No SOAP:Header element in message");
         }
-        
-        // add WSRM namespace declaration to header, instead of repeating in each individual child node
+        return header;
+    }
+    
+    /**
+     * Inserts a Header element containing a WS-RM Fault into a SOAP message.
+     * 
+     * @param sf
+     * @param qname constructed element name
+     * @param doc
+     */
+    public void insertHeaderFault(SequenceFault sf, Document doc) throws JAXBException {
+        Element header = getSoapHeader(doc);
         addNamespaceDecl(header);
-        
-        // build individual headers
         Marshaller marshaller = getContext().createMarshaller();
         marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
-        buildHeaders(seq, acks, reqs, rmps.isLastMessage(), header, marshaller);
-        return true;
+        buildHeaderFault(sf, header, marshaller);
     }
 
     /**
@@ -166,16 +190,17 @@ public abstract class EncoderDecoder {
      */
     protected abstract void buildHeaders(SequenceType seq, Collection<SequenceAcknowledgement> acks,
         Collection<AckRequestedType> reqs, boolean last, Element header, Marshaller marshaller) throws JAXBException;
-    
+
     /**
-     * Builds an element containing a WS-RM Fault. This adds the appropriate WS-RM namespace declaration to
-     * the element, and then adds the Fault as a child element.
+     * Build a header fault, using the correct protocol variation.
      * 
      * @param sf
-     * @param qname constructed element name
-     * @return element
+     * @param header
+     * @param marshaller
+     * @throws JAXBException
      */
-    public abstract Element buildHeaderFault(SequenceFault sf, QName qname) throws JAXBException;
+    protected abstract void buildHeaderFault(SequenceFault sf, Element header, Marshaller marshaller)
+        throws JAXBException;
     
     /**
      * Marshals a SequenceAcknowledgement to the appropriate external form.
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder10AImpl.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder10AImpl.java
index a073fdd406..6872206c7d 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder10AImpl.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder10AImpl.java
@@ -29,7 +29,6 @@ import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Marshaller;
 import javax.xml.bind.Unmarshaller;
-import javax.xml.namespace.QName;
 
 import org.w3c.dom.Attr;
 import org.w3c.dom.Document;
@@ -141,40 +140,30 @@ public final class EncoderDecoder10AImpl extends EncoderDecoder {
         }
     }
 
-    public Element buildHeaderFault(SequenceFault sf, QName qname) throws JAXBException {
-        
-        Document doc = DOMUtils.createDocument();
-        Element header = doc.createElementNS(qname.getNamespaceURI(), qname.getLocalPart());
-        // add WSRM namespace declaration to header, instead of
-        // repeating in each individual child node
-        
-        Attr attr = doc.createAttributeNS("http://www.w3.org/2000/xmlns/", 
-            "xmlns:" + RMConstants.NAMESPACE_PREFIX);
-        attr.setValue(RM10Constants.NAMESPACE_URI);
-        header.setAttributeNodeNS(attr);
-
-        Marshaller marshaller = getContext().createMarshaller();
-        marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
-        QName fqname = RM10Constants.SEQUENCE_FAULT_QNAME;
+    public void buildHeaderFault(SequenceFault sf, Element header, Marshaller marshaller) throws JAXBException {
         org.apache.cxf.ws.rm.v200502wsa15.SequenceFaultType flt =
             new org.apache.cxf.ws.rm.v200502wsa15.SequenceFaultType();
         flt.setFaultCode(sf.getFaultCode());
         Object detail = sf.getDetail();
+        Document doc = DOMUtils.createDocument();
         if (detail instanceof Element) {
             flt.getAny().add(detail);
         } else if (detail instanceof Identifier) {
             marshaller.marshal(VersionTransformer.convert200502wsa15((Identifier)detail), doc);
         } else if (detail instanceof SequenceAcknowledgement) {
-            marshaller.marshal(VersionTransformer.convert200502wsa15((SequenceAcknowledgement)detail),
-                doc);
+            marshaller.marshal(VersionTransformer.convert200502wsa15((SequenceAcknowledgement)detail), doc);
         }
         Element data = doc.getDocumentElement();
         if (data != null) {
             flt.getAny().add(data);
         }
-        marshaller.marshal(new JAXBElement<org.apache.cxf.ws.rm.v200502wsa15.SequenceFaultType>(fqname,
+        data = sf.getExtraDetail();
+        if (data != null) {
+            flt.getAny().add(data);
+        }
+        marshaller.marshal(new JAXBElement<org.apache.cxf.ws.rm.v200502wsa15.SequenceFaultType>(
+            RM10Constants.SEQUENCE_FAULT_QNAME,
             org.apache.cxf.ws.rm.v200502wsa15.SequenceFaultType.class, flt), header);
-        return header;
     }
 
     public Element encodeSequenceAcknowledgement(SequenceAcknowledgement ack) throws JAXBException {
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder10Impl.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder10Impl.java
index 42bf4c4563..538e1b4246 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder10Impl.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder10Impl.java
@@ -29,7 +29,6 @@ import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Marshaller;
 import javax.xml.bind.Unmarshaller;
-import javax.xml.namespace.QName;
 
 import org.w3c.dom.Attr;
 import org.w3c.dom.Document;
@@ -140,25 +139,11 @@ public final class EncoderDecoder10Impl extends EncoderDecoder {
         }
     }
 
-    public Element buildHeaderFault(SequenceFault sf, QName qname) throws JAXBException {
-        
-        Document doc = DOMUtils.createDocument();
-        Element header = doc.createElementNS(qname.getNamespaceURI(), qname.getLocalPart());
-        // add WSRM namespace declaration to header, instead of
-        // repeating in each individual child node
-        
-        Attr attr = doc.createAttributeNS("http://www.w3.org/2000/xmlns/", 
-            "xmlns:" + RMConstants.NAMESPACE_PREFIX);
-        attr.setValue(RM10Constants.NAMESPACE_URI);
-        header.setAttributeNodeNS(attr);
-
-        Marshaller marshaller = getContext().createMarshaller();
-        marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
-        QName fqname = RM10Constants.SEQUENCE_FAULT_QNAME;
-        org.apache.cxf.ws.rm.v200502.SequenceFaultType flt =
-            new org.apache.cxf.ws.rm.v200502.SequenceFaultType();
+    public void buildHeaderFault(SequenceFault sf, Element header, Marshaller marshaller) throws JAXBException {
+        org.apache.cxf.ws.rm.v200502.SequenceFaultType flt = new org.apache.cxf.ws.rm.v200502.SequenceFaultType();
         flt.setFaultCode(sf.getFaultCode());
         Object detail = sf.getDetail();
+        Document doc = DOMUtils.createDocument();
         if (detail instanceof Element) {
             flt.getAny().add(detail);
         } else if (detail instanceof Identifier) {
@@ -170,9 +155,13 @@ public final class EncoderDecoder10Impl extends EncoderDecoder {
         if (data != null) {
             flt.getAny().add(data);
         }
-        marshaller.marshal(new JAXBElement<org.apache.cxf.ws.rm.v200502.SequenceFaultType>(fqname,
+        data = sf.getExtraDetail();
+        if (data != null) {
+            flt.getAny().add(data);
+        }
+        marshaller.marshal(new JAXBElement<org.apache.cxf.ws.rm.v200502.SequenceFaultType>(
+            RM10Constants.SEQUENCE_FAULT_QNAME,
             org.apache.cxf.ws.rm.v200502.SequenceFaultType.class, flt), header);
-        return header;
     }
 
     public Element encodeSequenceAcknowledgement(SequenceAcknowledgement ack) throws JAXBException {
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder11Impl.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder11Impl.java
index b652b30c49..e1d516ecf1 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder11Impl.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/EncoderDecoder11Impl.java
@@ -29,7 +29,6 @@ import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Marshaller;
 import javax.xml.bind.Unmarshaller;
-import javax.xml.namespace.QName;
 
 import org.w3c.dom.Attr;
 import org.w3c.dom.Document;
@@ -137,20 +136,11 @@ public final class EncoderDecoder11Impl extends EncoderDecoder {
         element.setAttributeNodeNS(attr);
     }
 
-    public Element buildHeaderFault(SequenceFault sf, QName qname) throws JAXBException {
-        
-        Document doc = DOMUtils.createDocument();
-        Element header = doc.createElementNS(qname.getNamespaceURI(), qname.getLocalPart());
-        
-        // add WSRM namespace declaration to header, instead of repeating in each individual child node
-        addNamespaceDecl(header);
-
-        Marshaller marshaller = getContext().createMarshaller();
-        marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
-        QName fqname = RM11Constants.SEQUENCE_FAULT_QNAME;
+    public void buildHeaderFault(SequenceFault sf, Element header, Marshaller marshaller) throws JAXBException {
         SequenceFaultType flt = new SequenceFaultType();
         flt.setFaultCode(sf.getFaultCode());
         Object detail = sf.getDetail();
+        Document doc = DOMUtils.createDocument();
         if (detail instanceof Element) {
             flt.getAny().add(detail);
         } else if (detail instanceof Identifier) {
@@ -166,8 +156,8 @@ public final class EncoderDecoder11Impl extends EncoderDecoder {
         if (data != null) {
             flt.getDetail().getAny().add(data);
         }
-        marshaller.marshal(new JAXBElement<SequenceFaultType>(fqname, SequenceFaultType.class, flt), header);
-        return header;
+        marshaller.marshal(new JAXBElement<SequenceFaultType>(RM11Constants.SEQUENCE_FAULT_QNAME,
+            SequenceFaultType.class, flt), header);
     }
 
     public Element encodeSequenceAcknowledgement(SequenceAcknowledgement ack) throws JAXBException {
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/persistence/jdbc/RMTxStore.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/persistence/jdbc/RMTxStore.java
index 03241afe80..c298db27b4 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/persistence/jdbc/RMTxStore.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/persistence/jdbc/RMTxStore.java
@@ -155,7 +155,7 @@ public class RMTxStore implements RMStore {
     private static final String SELECT_MESSAGES_STMT_STR =
         "SELECT MSG_NO, SEND_TO, CONTENT FROM {0} WHERE SEQ_ID = ?";
     private static final String SELECT_ATTACHMENTS_STMT_STR =
-        "SELECT ATTACHMENT_NO, DATA FROM {0} WHERE SEQ_ID = ?, MSG_ID = ?";
+        "SELECT ATTACHMENT_NO, DATA FROM {0} WHERE SEQ_ID = ? AND MSG_NO = ?";
     private static final String ALTER_TABLE_STMT_STR =
         "ALTER TABLE {0} ADD {1} {2}";
     private static final String CREATE_INBOUND_MESSAGE_STMT_STR = 
@@ -1104,8 +1104,7 @@ public class RMTxStore implements RMStore {
     }
 
     
-    protected void cacheStatement(Connection con, String sql) 
-        throws SQLException {
+    protected void cacheStatement(Connection con, String sql) throws SQLException {
         PreparedStatement stmt = con.prepareStatement(sql);
         cachedStatements.put(sql, stmt);
         statementLocks.put(stmt, new ReentrantLock());
@@ -1137,6 +1136,12 @@ public class RMTxStore implements RMStore {
         cacheStatement(connection, DELETE_OUTBOUND_MESSAGE_STMT_STR);
         cacheStatement(connection, SELECT_INBOUND_MESSAGES_STMT_STR);
         cacheStatement(connection, SELECT_OUTBOUND_MESSAGES_STMT_STR);
+        cacheStatement(connection, CREATE_INBOUND_ATTACHMENT_STMT_STR);
+        cacheStatement(connection, CREATE_OUTBOUND_ATTACHMENT_STMT_STR);
+        cacheStatement(connection, DELETE_INBOUND_ATTACHMENTS_STMT_STR);
+        cacheStatement(connection, DELETE_OUTBOUND_ATTACHMENTS_STMT_STR);
+        cacheStatement(connection, SELECT_INBOUND_ATTACHMENTS_STMT_STR);
+        cacheStatement(connection, SELECT_OUTBOUND_ATTACHMENTS_STMT_STR);
     }
 
     public synchronized void init() {
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RMSoapOutInterceptor.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RMSoapOutInterceptor.java
index fade7a7c3c..d33930a8aa 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RMSoapOutInterceptor.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RMSoapOutInterceptor.java
@@ -21,7 +21,6 @@ package org.apache.cxf.ws.rm.soap;
 
 import java.net.HttpURLConnection;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -32,16 +31,10 @@ import javax.xml.namespace.QName;
 import javax.xml.soap.SOAPException;
 import javax.xml.soap.SOAPMessage;
 
-import org.w3c.dom.Attr;
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-
-import org.apache.cxf.binding.soap.Soap11;
 import org.apache.cxf.binding.soap.SoapFault;
 import org.apache.cxf.binding.soap.SoapMessage;
 import org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;
 import org.apache.cxf.common.logging.LogUtils;
-import org.apache.cxf.headers.Header;
 import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.message.MessageUtils;
@@ -50,7 +43,6 @@ import org.apache.cxf.ws.addressing.AddressingProperties;
 import org.apache.cxf.ws.rm.ProtocolVariation;
 import org.apache.cxf.ws.rm.RM10Constants;
 import org.apache.cxf.ws.rm.RM11Constants;
-import org.apache.cxf.ws.rm.RMConstants;
 import org.apache.cxf.ws.rm.RMContextUtils;
 import org.apache.cxf.ws.rm.RMOutInterceptor;
 import org.apache.cxf.ws.rm.RMProperties;
@@ -144,16 +136,9 @@ public class RMSoapOutInterceptor extends AbstractSoapInterceptor {
             if (added) {
                 try {
                     content.saveChanges();
-//                    ByteArrayOutputStream bos = new ByteArrayOutputStream();
-//                    content.writeTo(bos);
-//                    bos.close();
-//                    LOG.info("Message after headers added: " + bos.toString("UTF-8"));
                 } catch (SOAPException e) {
                     // TODO Auto-generated catch block
                     e.printStackTrace();
-//                } catch (IOException e) {
-//                    // TODO Auto-generated catch block
-//                    e.printStackTrace();
                 }
                 
             }
@@ -172,22 +157,13 @@ public class RMSoapOutInterceptor extends AbstractSoapInterceptor {
     public static void encodeFault(SoapMessage message, SequenceFault sf) {
         LOG.log(Level.FINE, "Encoding SequenceFault in SOAP header");
         try {
-            List<Header> headers = message.getHeaders();
             Message inmsg = message.getExchange().getInMessage();
             RMProperties rmps = RMContextUtils.retrieveRMProperties(inmsg, false);
             AddressingProperties maps = RMContextUtils.retrieveMAPs(inmsg, false, false);
             ProtocolVariation protocol = ProtocolVariation.findVariant(rmps.getNamespaceURI(),
                 maps.getNamespaceURI());
-            Element header = protocol.getCodec().buildHeaderFault(sf, Soap11.getInstance().getHeader());
-            Node node = header.getFirstChild();
-            if (node instanceof Element) {
-                Attr attr = header.getOwnerDocument().createAttributeNS("http://www.w3.org/2000/xmlns/",
-                    "xmlns:" + RMConstants.NAMESPACE_PREFIX);
-                attr.setValue(rmps.getNamespaceURI());
-                ((Element)node).setAttributeNodeNS(attr);
-            }
-            
-            headers.add(new Header(new QName(node.getNamespaceURI(), node.getLocalName()), node));
+            SOAPMessage content = message.getContent(SOAPMessage.class);
+            protocol.getCodec().insertHeaderFault(sf, content.getSOAPPart());
         } catch (JAXBException je) {
             LOG.log(Level.WARNING, "SOAP_HEADER_ENCODE_FAILURE_MSG", je);
         }        
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMManagerTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMManagerTest.java
index 5696b58f3d..ce091f2d54 100644
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMManagerTest.java
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMManagerTest.java
@@ -19,7 +19,6 @@
 
 package org.apache.cxf.ws.rm;
 
-import java.io.IOException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -37,7 +36,6 @@ import org.apache.cxf.bus.spring.SpringBusFactory;
 import org.apache.cxf.endpoint.Client;
 import org.apache.cxf.endpoint.Endpoint;
 import org.apache.cxf.endpoint.Server;
-import org.apache.cxf.io.CachedOutputStream;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.service.Service;
@@ -645,14 +643,6 @@ public class RMManagerTest extends Assert {
         if (null == conduit) {
             EasyMock.expect(m.getTo()).andReturn("toAddress");
         }
-        byte[] content = new byte[] {'x', '9'};
-        CachedOutputStream cos = new CachedOutputStream();
-        try {
-            cos.write(content);
-        } catch (IOException e) {
-            // ignore
-        }
-        EasyMock.expect(m.getCachedOutputStream()).andReturn(cos);
 
         if (mc != null) {
             queue.addUnacknowledged(EasyMock.capture(mc));
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMOutInterceptorTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMOutInterceptorTest.java
index 4d86dfaef3..74bda457a2 100644
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMOutInterceptorTest.java
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMOutInterceptorTest.java
@@ -20,22 +20,15 @@
 package org.apache.cxf.ws.rm;
 
 import java.lang.reflect.Method;
-import java.util.Iterator;
-import java.util.SortedSet;
-import java.util.TreeSet;
 
-import org.apache.cxf.interceptor.Interceptor;
 import org.apache.cxf.interceptor.InterceptorChain;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.FaultMode;
 import org.apache.cxf.message.Message;
-import org.apache.cxf.phase.Phase;
-import org.apache.cxf.phase.PhaseInterceptorChain;
 import org.apache.cxf.ws.addressing.AddressingProperties;
 import org.apache.cxf.ws.addressing.AttributedURIType;
 import org.apache.cxf.ws.addressing.EndpointReferenceType;
 import org.apache.cxf.ws.addressing.JAXWSAConstants;
-import org.apache.cxf.ws.addressing.MAPAggregator;
 import org.apache.cxf.ws.addressing.VersionTransformer.Names200408;
 import org.apache.cxf.ws.rm.v200702.Identifier;
 import org.easymock.EasyMock;
@@ -54,22 +47,6 @@ public class RMOutInterceptorTest extends Assert {
         control = EasyMock.createNiceControl();
     }
     
-    @Test
-    public void testOrdering() {
-        Phase p = new Phase(Phase.PRE_LOGICAL, 1);
-        SortedSet<Phase> phases = new TreeSet<Phase>();
-        phases.add(p);
-        PhaseInterceptorChain chain = 
-            new PhaseInterceptorChain(phases);
-        MAPAggregator map = new MAPAggregator();
-        RMOutInterceptor rmi = new RMOutInterceptor();        
-        chain.add(rmi);
-        chain.add(map);
-        Iterator<Interceptor<? extends Message>> it = chain.iterator();
-        assertSame("Unexpected order.", map, it.next());
-        assertSame("Unexpected order.", rmi, it.next());                      
-    } 
-    
     @Test 
     public void testHandleRuntimeFault() throws NoSuchMethodException, SequenceFault, RMException {
         Method[] mocked = new Method[] {                                                
@@ -134,11 +111,6 @@ public class RMOutInterceptorTest extends Assert {
             andReturn(rmpsOut).anyTimes();
         InterceptorChain chain = control.createMock(InterceptorChain.class);
         EasyMock.expect(message.getInterceptorChain()).andReturn(chain).anyTimes();
-        chain.add(EasyMock.isA(RetransmissionInterceptor.class));
-        EasyMock.expectLastCall();
-        RetransmissionQueue queue = control.createMock(RetransmissionQueue.class);
-        EasyMock.expect(manager.getRetransmissionQueue()).andReturn(queue).anyTimes();
-        queue.start();
         EasyMock.expectLastCall();
                 
         RMEndpoint rme = control.createMock(RMEndpoint.class);
@@ -169,8 +141,6 @@ public class RMOutInterceptorTest extends Assert {
         
         control.replay();
         interceptor.handle(message);
-        assertSame(sid, rmpsOut.getSequence().getIdentifier());        
-        assertEquals(new Long(10), rmpsOut.getSequence().getMessageNumber());
         control.verify();
     }
     
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/persistence/RMMessageTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/persistence/RMMessageTest.java
index c1317851a3..7279d1ea9b 100644
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/persistence/RMMessageTest.java
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/persistence/RMMessageTest.java
@@ -53,8 +53,7 @@ public class RMMessageTest extends Assert {
         RMMessage msg = new RMMessage();
         msg.setContent(new ByteArrayInputStream(DATA));
         
-        assertEquals(DATA.length, msg.getSize());
-        byte[] msgbytes = IOUtils.readBytesFromStream(msg.getInputStream());
+        byte[] msgbytes = IOUtils.readBytesFromStream(msg.getContent());
         
         assertArrayEquals(DATA, msgbytes);
     }
@@ -64,13 +63,10 @@ public class RMMessageTest extends Assert {
         RMMessage msg = new RMMessage();
         CachedOutputStream co = new CachedOutputStream();
         co.write(DATA);
-        msg.setContent(co);
+        msg.setContent(co.getInputStream());
         
-        assertEquals(DATA.length, msg.getSize());
-        byte[] msgbytes = IOUtils.readBytesFromStream(msg.getInputStream());
+        byte[] msgbytes = IOUtils.readBytesFromStream(msg.getContent());
         
         assertArrayEquals(DATA, msgbytes);
-
-        assertEquals(co, msg.getCachedOutputStream());
     }
 }
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/persistence/jdbc/RMTxStoreTestBase.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/persistence/jdbc/RMTxStoreTestBase.java
index 4db306f667..306e3b0935 100644
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/persistence/jdbc/RMTxStoreTestBase.java
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/persistence/jdbc/RMTxStoreTestBase.java
@@ -30,7 +30,6 @@ import java.util.Date;
 import java.util.List;
 
 import org.apache.cxf.helpers.IOUtils;
-import org.apache.cxf.io.CachedOutputStream;
 import org.apache.cxf.ws.addressing.EndpointReferenceType;
 import org.apache.cxf.ws.addressing.Names;
 import org.apache.cxf.ws.rm.DestinationSequence;
@@ -220,13 +219,13 @@ public abstract class RMTxStoreTestBase extends Assert {
         Identifier sid1 = new Identifier();
         sid1.setValue("sequence1");
         
-        EasyMock.expect(msg1.getMessageNumber()).andReturn(ONE); 
-        EasyMock.expect(msg2.getMessageNumber()).andReturn(ONE); 
+        EasyMock.expect(msg1.getMessageNumber()).andReturn(ONE).anyTimes(); 
+        EasyMock.expect(msg2.getMessageNumber()).andReturn(ONE).anyTimes(); 
         byte[] bytes = new byte[89];
-        EasyMock.expect(msg1.getInputStream()).andReturn(new ByteArrayInputStream(bytes));
-        EasyMock.expect(msg1.getSize()).andReturn((long)bytes.length);
-        EasyMock.expect(msg2.getInputStream()).andReturn(new ByteArrayInputStream(bytes));
-        EasyMock.expect(msg2.getSize()).andReturn((long)bytes.length);
+        EasyMock.expect(msg1.getContent()).andReturn(new ByteArrayInputStream(bytes)).anyTimes();
+        EasyMock.expect(msg2.getContent()).andReturn(new ByteArrayInputStream(bytes)).anyTimes();
+        EasyMock.expect(msg1.getAttachments()).andReturn(new ArrayList<InputStream>()).anyTimes();
+        EasyMock.expect(msg2.getAttachments()).andReturn(new ArrayList<InputStream>()).anyTimes();
         
         control.replay();
 
@@ -244,8 +243,7 @@ public abstract class RMTxStoreTestBase extends Assert {
         
         control.reset();
         EasyMock.expect(msg1.getMessageNumber()).andReturn(ONE); 
-        EasyMock.expect(msg1.getInputStream()).andReturn(new ByteArrayInputStream(bytes));
-        EasyMock.expect(msg1.getSize()).andReturn((long)bytes.length);
+        EasyMock.expect(msg1.getContent()).andReturn(new ByteArrayInputStream(bytes));
         
         control.replay();
         con = getConnection();
@@ -262,12 +260,12 @@ public abstract class RMTxStoreTestBase extends Assert {
         control.verify();
         
         control.reset();
-        EasyMock.expect(msg1.getMessageNumber()).andReturn(TEN);
-        EasyMock.expect(msg2.getMessageNumber()).andReturn(TEN); 
-        EasyMock.expect(msg1.getInputStream()).andReturn(new ByteArrayInputStream(bytes)); 
-        EasyMock.expect(msg1.getSize()).andReturn((long)bytes.length);
-        EasyMock.expect(msg2.getInputStream()).andReturn(new ByteArrayInputStream(bytes)); 
-        EasyMock.expect(msg2.getSize()).andReturn((long)bytes.length);
+        EasyMock.expect(msg1.getMessageNumber()).andReturn(TEN).anyTimes();
+        EasyMock.expect(msg2.getMessageNumber()).andReturn(TEN).anyTimes(); 
+        EasyMock.expect(msg1.getContent()).andReturn(new ByteArrayInputStream(bytes)).anyTimes(); 
+        EasyMock.expect(msg2.getContent()).andReturn(new ByteArrayInputStream(bytes)).anyTimes(); 
+        EasyMock.expect(msg1.getAttachments()).andReturn(new ArrayList<InputStream>()).anyTimes();
+        EasyMock.expect(msg2.getAttachments()).andReturn(new ArrayList<InputStream>()).anyTimes();
         
         control.replay();
         con = getConnection();
@@ -863,12 +861,11 @@ public abstract class RMTxStoreTestBase extends Assert {
     
     private RMMessage createRMMessage(Long mn, String to) throws IOException {
         RMMessage msg = control.createMock(RMMessage.class);
-        EasyMock.expect(msg.getMessageNumber()).andReturn(mn);
-        EasyMock.expect(msg.getTo()).andReturn(to);
+        EasyMock.expect(msg.getMessageNumber()).andReturn(mn).anyTimes();
+        EasyMock.expect(msg.getTo()).andReturn(to).anyTimes();
+        EasyMock.expect(msg.getAttachments()).andReturn(new ArrayList<InputStream>()).anyTimes();
         byte[] value = ("Message " + mn.longValue()).getBytes();
-        EasyMock.expect(msg.getInputStream()).andReturn(new ByteArrayInputStream(value));
-        EasyMock.expect(msg.getSize()).andReturn((long)value.length);
-        EasyMock.expect(msg.getCachedOutputStream()).andReturn(new CachedOutputStream()).anyTimes();
+        EasyMock.expect(msg.getContent()).andReturn(new ByteArrayInputStream(value)).anyTimes();
         return msg;
     }
 
@@ -932,7 +929,7 @@ public abstract class RMTxStoreTestBase extends Assert {
                 assertNull(msg.getTo());
             }
             try {
-                InputStream actual = msg.getInputStream();
+                InputStream actual = msg.getContent();
                 assertEquals(new String("Message " + mn), IOUtils.readStringFromStream(actual));
             } catch (IOException e) {
                 fail("failed to get the input stream");
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapInInterceptorTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapInInterceptorTest.java
new file mode 100644
index 0000000000..6e59e127a9
--- /dev/null
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapInInterceptorTest.java
@@ -0,0 +1,174 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.ws.rm.soap;
+
+import java.io.InputStream;
+import java.util.Collection;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+
+import org.apache.cxf.BusFactory;
+import org.apache.cxf.binding.soap.SoapMessage;
+import org.apache.cxf.binding.soap.interceptor.ReadHeadersInterceptor;
+import org.apache.cxf.binding.soap.interceptor.StartBodyInterceptor;
+import org.apache.cxf.message.Message;
+import org.apache.cxf.message.MessageImpl;
+import org.apache.cxf.ws.addressing.AddressingProperties;
+import org.apache.cxf.ws.rm.RM10Constants;
+import org.apache.cxf.ws.rm.RMContextUtils;
+import org.apache.cxf.ws.rm.RMProperties;
+import org.apache.cxf.ws.rm.v200702.AckRequestedType;
+import org.apache.cxf.ws.rm.v200702.SequenceAcknowledgement;
+import org.apache.cxf.ws.rm.v200702.SequenceAcknowledgement.AcknowledgementRange;
+import org.apache.cxf.ws.rm.v200702.SequenceType;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class RMSoapInInterceptorTest extends Assert {
+
+    private static final String SEQ_IDENTIFIER = "http://Business456.com/RM/ABC";
+    private static final Long ONE = new Long(1);
+    private static final Long MSG1_MESSAGE_NUMBER = ONE;
+    private static final Long MSG2_MESSAGE_NUMBER = new Long(2);
+
+    @Test
+    public void testGetUnderstoodHeaders() throws Exception {
+        RMSoapInInterceptor codec = new RMSoapInInterceptor();
+        Set<QName> headers = codec.getUnderstoodHeaders();
+        assertTrue("expected Sequence header", headers.contains(RM10Constants.SEQUENCE_QNAME));
+        assertTrue("expected SequenceAcknowledgment header", 
+                   headers.contains(RM10Constants.SEQUENCE_ACK_QNAME));
+        assertTrue("expected AckRequested header", 
+                   headers.contains(RM10Constants.ACK_REQUESTED_QNAME));
+    }
+    
+    @Test
+    public void testDecodeSequence() throws XMLStreamException {
+        SoapMessage message = setUpInboundMessage("resources/Message1.xml");
+        RMSoapInInterceptor codec = new RMSoapInInterceptor();
+        codec.handleMessage(message);
+        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
+        SequenceType st = rmps.getSequence();
+        assertNotNull(st);
+        assertEquals(st.getIdentifier().getValue(), SEQ_IDENTIFIER);
+        assertEquals(st.getMessageNumber(), MSG1_MESSAGE_NUMBER);
+        
+        assertNull(rmps.getAcks());
+        assertNull(rmps.getAcksRequested());
+
+    }
+
+    @Test
+    public void testDecodeAcknowledgements() throws XMLStreamException {
+        SoapMessage message = setUpInboundMessage("resources/Acknowledgment.xml");
+        RMSoapInInterceptor codec = new RMSoapInInterceptor();
+        codec.handleMessage(message);
+        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
+        Collection<SequenceAcknowledgement> acks = rmps.getAcks();
+        assertNotNull(acks);
+        assertEquals(1, acks.size());
+        SequenceAcknowledgement ack = acks.iterator().next();
+        assertNotNull(ack);
+        assertEquals(ack.getIdentifier().getValue(), SEQ_IDENTIFIER);
+        assertEquals(2, ack.getAcknowledgementRange().size());
+        AcknowledgementRange r1 = ack.getAcknowledgementRange().get(0);
+        AcknowledgementRange r2 = ack.getAcknowledgementRange().get(1);
+        verifyRange(r1, 1, 1);
+        verifyRange(r2, 3, 3);
+        assertNull(rmps.getSequence());
+        assertNull(rmps.getAcksRequested());
+    }
+
+    @Test
+    public void testDecodeAcknowledgements2() throws XMLStreamException {
+        SoapMessage message = setUpInboundMessage("resources/Acknowledgment2.xml");
+        RMSoapInInterceptor codec = new RMSoapInInterceptor();
+        codec.handleMessage(message);
+        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
+        Collection<SequenceAcknowledgement> acks = rmps.getAcks();
+        assertNotNull(acks);
+        assertEquals(1, acks.size());
+        SequenceAcknowledgement ack = acks.iterator().next();
+        assertNotNull(ack);
+        assertEquals(1, ack.getAcknowledgementRange().size());
+        AcknowledgementRange r1 = ack.getAcknowledgementRange().get(0);
+        verifyRange(r1, 1, 3);
+        assertNull(rmps.getSequence());
+        assertNull(rmps.getAcksRequested());
+    }
+
+    private void verifyRange(AcknowledgementRange r, int i, int j) {
+        assertNotNull(r);
+        if (i > 0) {
+            assertNotNull(r.getLower());
+            assertEquals(i, r.getLower().longValue());
+        }
+        if (j > 0) {
+            assertNotNull(r.getUpper());
+            assertEquals(j, r.getUpper().longValue());
+        }
+    }
+
+    @Test
+    public void testDecodeAcksRequested() throws XMLStreamException {
+        SoapMessage message = setUpInboundMessage("resources/Retransmission.xml");
+        RMSoapInInterceptor codec = new RMSoapInInterceptor();
+        codec.handleMessage(message);
+        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
+        Collection<AckRequestedType> requested = rmps.getAcksRequested();
+        assertNotNull(requested);
+        assertEquals(1, requested.size());
+        AckRequestedType ar = requested.iterator().next();
+        assertNotNull(ar);
+        assertEquals(ar.getIdentifier().getValue(), SEQ_IDENTIFIER);
+
+        SequenceType s = rmps.getSequence();
+        assertNotNull(s);
+        assertEquals(s.getIdentifier().getValue(), SEQ_IDENTIFIER);
+        assertEquals(s.getMessageNumber(), MSG2_MESSAGE_NUMBER);
+
+        assertNull(rmps.getAcks());
+    }
+    
+    private SoapMessage setUpInboundMessage(String resource) throws XMLStreamException {
+        Message message = new MessageImpl();
+        SoapMessage soapMessage = new SoapMessage(message);
+        RMProperties rmps = new RMProperties();
+        rmps.exposeAs(RM10Constants.NAMESPACE_URI);
+        RMContextUtils.storeRMProperties(soapMessage, rmps, false);
+        AddressingProperties maps = new AddressingProperties();
+        RMContextUtils.storeMAPs(maps, soapMessage, false, false);
+        message.put(Message.SCHEMA_VALIDATION_ENABLED, false);
+        InputStream is = RMSoapInInterceptorTest.class.getResourceAsStream(resource);
+        assertNotNull(is);
+        XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);
+        soapMessage.setContent(XMLStreamReader.class, reader);
+        ReadHeadersInterceptor rji = new ReadHeadersInterceptor(BusFactory.getDefaultBus());
+        rji.handleMessage(soapMessage); 
+        StartBodyInterceptor sbi = new StartBodyInterceptor();
+        sbi.handleMessage(soapMessage);
+        return soapMessage;
+    }
+}
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapInterceptorTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapInterceptorTest.java
deleted file mode 100644
index 5e26a72974..0000000000
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapInterceptorTest.java
+++ /dev/null
@@ -1,475 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.apache.cxf.ws.rm.soap;
-
-import java.io.InputStream;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-
-import org.w3c.dom.Element;
-
-import org.apache.cxf.BusFactory;
-import org.apache.cxf.binding.soap.SoapFault;
-import org.apache.cxf.binding.soap.SoapMessage;
-import org.apache.cxf.binding.soap.interceptor.ReadHeadersInterceptor;
-import org.apache.cxf.binding.soap.interceptor.StartBodyInterceptor;
-import org.apache.cxf.headers.Header;
-import org.apache.cxf.message.Exchange;
-import org.apache.cxf.message.ExchangeImpl;
-import org.apache.cxf.message.Message;
-import org.apache.cxf.message.MessageImpl;
-import org.apache.cxf.message.MessageUtils;
-import org.apache.cxf.ws.addressing.AddressingProperties;
-import org.apache.cxf.ws.addressing.Names;
-import org.apache.cxf.ws.rm.RM10Constants;
-import org.apache.cxf.ws.rm.RMConstants;
-import org.apache.cxf.ws.rm.RMContextUtils;
-import org.apache.cxf.ws.rm.RMProperties;
-import org.apache.cxf.ws.rm.SequenceFault;
-import org.apache.cxf.ws.rm.v200702.AckRequestedType;
-import org.apache.cxf.ws.rm.v200702.Identifier;
-import org.apache.cxf.ws.rm.v200702.ObjectFactory;
-import org.apache.cxf.ws.rm.v200702.SequenceAcknowledgement;
-import org.apache.cxf.ws.rm.v200702.SequenceAcknowledgement.AcknowledgementRange;
-import org.apache.cxf.ws.rm.v200702.SequenceType;
-import org.easymock.EasyMock;
-import org.easymock.IMocksControl;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-public class RMSoapInterceptorTest extends Assert {
-
-    private static final String SEQ_IDENTIFIER = "http://Business456.com/RM/ABC";
-    private static final Long ONE = new Long(1);
-    private static final Long TEN = new Long(10);
-    private static final Long MSG1_MESSAGE_NUMBER = ONE;
-    private static final Long MSG2_MESSAGE_NUMBER = new Long(2);
-
-    private IMocksControl control;
-    
-    private SequenceType s1;
-    private SequenceType s2;
-    private SequenceAcknowledgement ack1;
-    private SequenceAcknowledgement ack2;
-    private AckRequestedType ar1;
-    private AckRequestedType ar2;
-    
-    @Before
-    public void setUp() {
-        control = EasyMock.createNiceControl(); 
-    }
-
-    @Test
-    public void testGetUnderstoodHeaders() throws Exception {
-        RMSoapInterceptor codec = new RMSoapInterceptor();
-        Set<QName> headers = codec.getUnderstoodHeaders();
-        assertTrue("expected Sequence header", headers.contains(RM10Constants.SEQUENCE_QNAME));
-        assertTrue("expected SequenceAcknowledgment header", 
-                   headers.contains(RM10Constants.SEQUENCE_ACK_QNAME));
-        assertTrue("expected AckRequested header", 
-                   headers.contains(RM10Constants.ACK_REQUESTED_QNAME));
-    }
-    
-    @Test
-    public void testHandleMessage() throws NoSuchMethodException {
-        Method m = RMSoapInterceptor.class.getDeclaredMethod("mediate", 
-            new Class[] {SoapMessage.class});
-        RMSoapInterceptor codec = 
-            EasyMock.createMockBuilder(RMSoapInterceptor.class)
-                .addMockedMethod(m).createMock(control);
-        SoapMessage msg = control.createMock(SoapMessage.class);
-        codec.mediate(msg);
-        EasyMock.expectLastCall();
-        
-        control.replay();
-        codec.handleMessage(msg);
-        control.verify();
-    }
-    
-    @Test
-    public void testMediate() throws NoSuchMethodException, XMLStreamException {
-        Method m1 = RMSoapInterceptor.class.getDeclaredMethod("encode", 
-                                                             new Class[] {SoapMessage.class});
-        Method m2 = RMSoapInterceptor.class.getDeclaredMethod("decode", 
-                                                              new Class[] {SoapMessage.class});
-        RMSoapInterceptor codec =
-            EasyMock.createMockBuilder(RMSoapInterceptor.class)
-                .addMockedMethods(m1, m2).createMock(control);
-        
-        SoapMessage msg = control.createMock(SoapMessage.class);
-        Exchange exchange = control.createMock(Exchange.class);
-        EasyMock.expect(msg.getExchange()).andReturn(exchange);
-        EasyMock.expect(exchange.getOutMessage()).andReturn(msg);
-        codec.encode(msg);
-        EasyMock.expectLastCall();
-        
-        control.replay();
-        codec.mediate(msg);
-        control.verify();
-                
-        control.reset();
-        EasyMock.expect(msg.getExchange()).andReturn(null);
-        codec.decode(msg);
-        EasyMock.expectLastCall();
-        
-        control.replay();
-        codec.mediate(msg);
-        control.verify();
-        
-    }
-
-    @Test
-    public void testEncode() throws Exception {
-        RMSoapInterceptor codec = new RMSoapInterceptor();
-        setUpOutbound();
-        SoapMessage message = setupOutboundMessage();
-
-        // no RM headers
-   
-        codec.handleMessage(message);
-        verifyHeaders(message, new String[] {});
-
-        // one sequence header
-
-        message = setupOutboundMessage();        
-        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, true);     
-        rmps.setSequence(s1);
-        codec.encode(message);
-        verifyHeaders(message, new String[] {RMConstants.SEQUENCE_NAME});
-
-        // one acknowledgment header
-
-        message = setupOutboundMessage(); 
-        rmps = RMContextUtils.retrieveRMProperties(message, true);          
-        Collection<SequenceAcknowledgement> acks = new ArrayList<SequenceAcknowledgement>();
-        acks.add(ack1);
-        rmps.setAcks(acks);        
-        codec.encode(message);
-        verifyHeaders(message, new String[] {RMConstants.SEQUENCE_ACK_NAME});
-
-        // two acknowledgment headers
-
-        message = setupOutboundMessage();
-        rmps = RMContextUtils.retrieveRMProperties(message, true);        
-        acks.add(ack2);
-        rmps.setAcks(acks);
-        codec.encode(message);
-        verifyHeaders(message, new String[] {RMConstants.SEQUENCE_ACK_NAME, 
-                                             RMConstants.SEQUENCE_ACK_NAME});
-
-        // one ack requested header
-
-        message = setupOutboundMessage();
-        rmps = RMContextUtils.retrieveRMProperties(message, true);        
-        Collection<AckRequestedType> requested = new ArrayList<AckRequestedType>();
-        requested.add(ar1);
-        rmps.setAcksRequested(requested);
-        codec.encode(message);
-        verifyHeaders(message, new String[] {RMConstants.ACK_REQUESTED_NAME});
-
-        // two ack requested headers
-
-        message = setupOutboundMessage();
-        rmps = RMContextUtils.retrieveRMProperties(message, true);         
-        requested.add(ar2);
-        rmps.setAcksRequested(requested);
-        codec.encode(message);
-        verifyHeaders(message, new String[] {RMConstants.ACK_REQUESTED_NAME, 
-                                             RMConstants.ACK_REQUESTED_NAME});
-    }
-    
-    @Test
-    public void testEncodeFault() throws Exception {
-        RMSoapInterceptor codec = new RMSoapInterceptor();
-        setUpOutbound();
-        SoapMessage message = setupOutboundFaultMessage();
-
-        // no RM headers and no fault
-   
-        codec.encode(message);
-        verifyHeaders(message, new String[] {});
-
-        // fault is not a SoapFault
-
-        message = setupOutboundFaultMessage();
-        assertTrue(MessageUtils.isFault(message));
-        Exception ex = new RuntimeException("");
-        message.setContent(Exception.class, ex);      
-        codec.encode(message);
-        verifyHeaders(message, new String[] {});
-        
-        // fault is a SoapFault but does not have a SequenceFault cause
-
-        message = setupOutboundFaultMessage();
-        SoapFault f = new SoapFault("REASON", RM10Constants.UNKNOWN_SEQUENCE_FAULT_QNAME);
-        message.setContent(Exception.class, f);      
-        codec.encode(message);
-        verifyHeaders(message, new String[] {});
-
-        // fault is a SoapFault and has a SequenceFault cause
-        
-        message = setupOutboundFaultMessage();
-        SequenceFault sf = new SequenceFault("REASON");
-        sf.setFaultCode(RM10Constants.UNKNOWN_SEQUENCE_FAULT_QNAME);
-        Identifier sid = new Identifier();
-        sid.setValue("SID");
-        sf.setSender(true);
-        f.initCause(sf);
-        message.setContent(Exception.class, f);      
-        codec.encode(message);
-        verifyHeaders(message, new String[] {RMConstants.SEQUENCE_FAULT_NAME});
-
-    }
-
-    @Test
-    public void testDecodeSequence() throws XMLStreamException {
-        SoapMessage message = setUpInboundMessage("resources/Message1.xml");
-        RMSoapInterceptor codec = new RMSoapInterceptor();
-        codec.handleMessage(message);
-        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
-        SequenceType st = rmps.getSequence();
-        assertNotNull(st);
-        assertEquals(st.getIdentifier().getValue(), SEQ_IDENTIFIER);
-        assertEquals(st.getMessageNumber(), MSG1_MESSAGE_NUMBER);
-        
-        assertNull(rmps.getAcks());
-        assertNull(rmps.getAcksRequested());
-
-    }
-
-    @Test
-    public void testDecodeAcknowledgements() throws XMLStreamException {
-        SoapMessage message = setUpInboundMessage("resources/Acknowledgment.xml");
-        RMSoapInterceptor codec = new RMSoapInterceptor();
-        codec.handleMessage(message);
-        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
-        Collection<SequenceAcknowledgement> acks = rmps.getAcks();
-        assertNotNull(acks);
-        assertEquals(1, acks.size());
-        SequenceAcknowledgement ack = acks.iterator().next();
-        assertNotNull(ack);
-        assertEquals(ack.getIdentifier().getValue(), SEQ_IDENTIFIER);
-        assertEquals(2, ack.getAcknowledgementRange().size());
-        AcknowledgementRange r1 = ack.getAcknowledgementRange().get(0);
-        AcknowledgementRange r2 = ack.getAcknowledgementRange().get(1);
-        verifyRange(r1, 1, 1);
-        verifyRange(r2, 3, 3);
-        assertNull(rmps.getSequence());
-        assertNull(rmps.getAcksRequested());
-    }
-
-    @Test
-    public void testDecodeAcknowledgements2() throws XMLStreamException {
-        SoapMessage message = setUpInboundMessage("resources/Acknowledgment2.xml");
-        RMSoapInterceptor codec = new RMSoapInterceptor();
-        codec.handleMessage(message);
-        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
-        Collection<SequenceAcknowledgement> acks = rmps.getAcks();
-        assertNotNull(acks);
-        assertEquals(1, acks.size());
-        SequenceAcknowledgement ack = acks.iterator().next();
-        assertNotNull(ack);
-        assertEquals(1, ack.getAcknowledgementRange().size());
-        AcknowledgementRange r1 = ack.getAcknowledgementRange().get(0);
-        verifyRange(r1, 1, 3);
-        assertNull(rmps.getSequence());
-        assertNull(rmps.getAcksRequested());
-    }
-
-    private void verifyRange(AcknowledgementRange r, int i, int j) {
-        assertNotNull(r);
-        if (i > 0) {
-            assertNotNull(r.getLower());
-            assertEquals(i, r.getLower().longValue());
-        }
-        if (j > 0) {
-            assertNotNull(r.getUpper());
-            assertEquals(j, r.getUpper().longValue());
-        }
-    }
-
-    @Test
-    public void testDecodeAcksRequested() throws XMLStreamException {
-        SoapMessage message = setUpInboundMessage("resources/Retransmission.xml");
-        RMSoapInterceptor codec = new RMSoapInterceptor();
-        codec.handleMessage(message);
-        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
-        Collection<AckRequestedType> requested = rmps.getAcksRequested();
-        assertNotNull(requested);
-        assertEquals(1, requested.size());
-        AckRequestedType ar = requested.iterator().next();
-        assertNotNull(ar);
-        assertEquals(ar.getIdentifier().getValue(), SEQ_IDENTIFIER);
-
-        SequenceType s = rmps.getSequence();
-        assertNotNull(s);
-        assertEquals(s.getIdentifier().getValue(), SEQ_IDENTIFIER);
-        assertEquals(s.getMessageNumber(), MSG2_MESSAGE_NUMBER);
-
-        assertNull(rmps.getAcks());
-    }
-
-    private void setUpOutbound() {
-        ObjectFactory factory = new ObjectFactory();
-        s1 = factory.createSequenceType();
-        Identifier sid = factory.createIdentifier();
-        sid.setValue("sequence1");
-        s1.setIdentifier(sid);
-        s1.setMessageNumber(ONE);
-        s2 = factory.createSequenceType();
-        sid = factory.createIdentifier();
-        sid.setValue("sequence2");
-        s2.setIdentifier(sid);
-        s2.setMessageNumber(TEN);
-
-        ack1 = factory.createSequenceAcknowledgement();
-        SequenceAcknowledgement.AcknowledgementRange r = 
-            factory.createSequenceAcknowledgementAcknowledgementRange();
-        r.setLower(ONE);
-        r.setUpper(ONE);
-        ack1.getAcknowledgementRange().add(r);
-        ack1.setIdentifier(s1.getIdentifier());
-
-        ack2 = factory.createSequenceAcknowledgement();
-        r = factory.createSequenceAcknowledgementAcknowledgementRange();
-        r.setLower(ONE);
-        r.setUpper(TEN);
-        ack2.getAcknowledgementRange().add(r);
-        ack2.setIdentifier(s2.getIdentifier());
-
-        ar1 = factory.createAckRequestedType();
-        ar1.setIdentifier(s1.getIdentifier());
-
-        ar2 = factory.createAckRequestedType();
-        ar2.setIdentifier(s2.getIdentifier());
-    }
-
-    private SoapMessage setupOutboundMessage() throws Exception {
-        Exchange ex = new ExchangeImpl();        
-        Message message = new MessageImpl();
-        SoapMessage soapMessage = new SoapMessage(message);         
-        RMProperties rmps = new RMProperties();
-        rmps.exposeAs(RM10Constants.NAMESPACE_URI);
-        RMContextUtils.storeRMProperties(soapMessage, rmps, true);
-        AddressingProperties maps = new AddressingProperties();
-        RMContextUtils.storeMAPs(maps, soapMessage, true, false);
-        ex.setOutMessage(soapMessage);
-        soapMessage.setExchange(ex);        
-        return soapMessage;
-    }
-    
-    private SoapMessage setupOutboundFaultMessage() throws Exception {
-        Exchange ex = new ExchangeImpl();
-        Message message = new MessageImpl();
-        RMProperties rmps = new RMProperties();
-        rmps.exposeAs(RM10Constants.NAMESPACE_URI);
-        RMContextUtils.storeRMProperties(message, rmps, false);
-        AddressingProperties maps = new AddressingProperties();
-        RMContextUtils.storeMAPs(maps, message, false, false);
-        ex.setInMessage(message);
-        message = new MessageImpl();
-        SoapMessage soapMessage = new SoapMessage(message);         
-        ex.setOutFaultMessage(soapMessage);
-        soapMessage.setExchange(ex);        
-        return soapMessage;
-    }
-
-    private void verifyHeaders(SoapMessage message, String... names) {
-        List<Header> header = message.getHeaders();
-
-        // check all expected headers are present
-
-        for (String name : names) {
-            boolean found = false;
-            Iterator<Header> iter = header.iterator();
-            while (iter.hasNext()) {
-                Object obj = iter.next().getObject();
-                if (obj instanceof Element) {
-                    Element elem = (Element) obj;
-                    String namespace = elem.getNamespaceURI();
-                    String localName = elem.getLocalName();
-                    if (RM10Constants.NAMESPACE_URI.equals(namespace)
-                        && localName.equals(name)) {
-                        found = true;
-                        break;
-                    } else if (Names.WSA_NAMESPACE_NAME.equals(namespace)
-                        && localName.equals(name)) {
-                        found = true;
-                        break;
-                    }
-                }
-            }
-            assertTrue("Could not find header element " + name, found);
-        }
-
-        // no other headers should be present
-
-        Iterator<Header> iter1 = header.iterator();
-        while (iter1.hasNext()) {
-            Object obj = iter1.next().getObject();
-            if (obj instanceof Element) {
-                Element elem = (Element) obj;
-                String namespace = elem.getNamespaceURI();
-                String localName = elem.getLocalName();
-                assertTrue(RM10Constants.NAMESPACE_URI.equals(namespace) 
-                    || Names.WSA_NAMESPACE_NAME.equals(namespace));
-                boolean found = false;
-                for (String name : names) {
-                    if (localName.equals(name)) {
-                        found = true;
-                        break;
-                    }
-                }
-                assertTrue("Unexpected header element " + localName, found);
-            }
-        }
-    }
-    
-    private SoapMessage setUpInboundMessage(String resource) throws XMLStreamException {
-        Message message = new MessageImpl();
-        SoapMessage soapMessage = new SoapMessage(message);
-        RMProperties rmps = new RMProperties();
-        rmps.exposeAs(RM10Constants.NAMESPACE_URI);
-        RMContextUtils.storeRMProperties(soapMessage, rmps, false);
-        AddressingProperties maps = new AddressingProperties();
-        RMContextUtils.storeMAPs(maps, soapMessage, false, false);
-        message.put(Message.SCHEMA_VALIDATION_ENABLED, false);
-        InputStream is = RMSoapInterceptorTest.class.getResourceAsStream(resource);
-        assertNotNull(is);
-        XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);
-        soapMessage.setContent(XMLStreamReader.class, reader);
-        ReadHeadersInterceptor rji = new ReadHeadersInterceptor(BusFactory.getDefaultBus());
-        rji.handleMessage(soapMessage); 
-        StartBodyInterceptor sbi = new StartBodyInterceptor();
-        sbi.handleMessage(soapMessage);
-        return soapMessage;
-    }
-}
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapOutInterceptorTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapOutInterceptorTest.java
index 9d676cab28..176ec2d5fd 100644
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapOutInterceptorTest.java
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RMSoapOutInterceptorTest.java
@@ -19,27 +19,21 @@
 
 package org.apache.cxf.ws.rm.soap;
 
-import java.io.InputStream;
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Set;
 
 import javax.xml.namespace.QName;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
+import javax.xml.soap.MessageFactory;
+import javax.xml.soap.SOAPConstants;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPMessage;
 
 import org.w3c.dom.Element;
 
-import org.apache.cxf.BusFactory;
 import org.apache.cxf.binding.soap.SoapFault;
 import org.apache.cxf.binding.soap.SoapMessage;
-import org.apache.cxf.binding.soap.interceptor.ReadHeadersInterceptor;
-import org.apache.cxf.binding.soap.interceptor.StartBodyInterceptor;
-import org.apache.cxf.headers.Header;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.ExchangeImpl;
 import org.apache.cxf.message.Message;
@@ -56,24 +50,15 @@ import org.apache.cxf.ws.rm.v200702.AckRequestedType;
 import org.apache.cxf.ws.rm.v200702.Identifier;
 import org.apache.cxf.ws.rm.v200702.ObjectFactory;
 import org.apache.cxf.ws.rm.v200702.SequenceAcknowledgement;
-import org.apache.cxf.ws.rm.v200702.SequenceAcknowledgement.AcknowledgementRange;
 import org.apache.cxf.ws.rm.v200702.SequenceType;
-import org.easymock.EasyMock;
-import org.easymock.IMocksControl;
 
 import org.junit.Assert;
-import org.junit.Before;
 import org.junit.Test;
 
 public class RMSoapOutInterceptorTest extends Assert {
 
-    private static final String SEQ_IDENTIFIER = "http://Business456.com/RM/ABC";
     private static final Long ONE = new Long(1);
     private static final Long TEN = new Long(10);
-    private static final Long MSG1_MESSAGE_NUMBER = ONE;
-    private static final Long MSG2_MESSAGE_NUMBER = new Long(2);
-
-    private IMocksControl control;
     
     private SequenceType s1;
     private SequenceType s2;
@@ -81,11 +66,6 @@ public class RMSoapOutInterceptorTest extends Assert {
     private SequenceAcknowledgement ack2;
     private AckRequestedType ar1;
     private AckRequestedType ar2;
-    
-    @Before
-    public void setUp() {
-        control = EasyMock.createNiceControl(); 
-    }
 
     @Test
     public void testGetUnderstoodHeaders() throws Exception {
@@ -97,54 +77,6 @@ public class RMSoapOutInterceptorTest extends Assert {
         assertTrue("expected AckRequested header", 
                    headers.contains(RM10Constants.ACK_REQUESTED_QNAME));
     }
-    
-    @Test
-    public void testHandleMessage() throws NoSuchMethodException {
-        Method m = RMSoapOutInterceptor.class.getDeclaredMethod("mediate", 
-            new Class[] {SoapMessage.class});
-        RMSoapOutInterceptor codec = 
-            EasyMock.createMockBuilder(RMSoapOutInterceptor.class)
-                .addMockedMethod(m).createMock(control);
-        SoapMessage msg = control.createMock(SoapMessage.class);
-        codec.mediate(msg);
-        EasyMock.expectLastCall();
-        
-        control.replay();
-        codec.handleMessage(msg);
-        control.verify();
-    }
-    
-    @Test
-    public void testMediate() throws NoSuchMethodException, XMLStreamException {
-        Method m1 = RMSoapOutInterceptor.class.getDeclaredMethod("encode", 
-                                                             new Class[] {SoapMessage.class});
-        Method m2 = RMSoapOutInterceptor.class.getDeclaredMethod("decode", 
-                                                              new Class[] {SoapMessage.class});
-        RMSoapOutInterceptor codec =
-            EasyMock.createMockBuilder(RMSoapOutInterceptor.class)
-                .addMockedMethods(m1, m2).createMock(control);
-        
-        SoapMessage msg = control.createMock(SoapMessage.class);
-        Exchange exchange = control.createMock(Exchange.class);
-        EasyMock.expect(msg.getExchange()).andReturn(exchange);
-        EasyMock.expect(exchange.getOutMessage()).andReturn(msg);
-        codec.encode(msg);
-        EasyMock.expectLastCall();
-        
-        control.replay();
-        codec.mediate(msg);
-        control.verify();
-                
-        control.reset();
-        EasyMock.expect(msg.getExchange()).andReturn(null);
-        codec.decode(msg);
-        EasyMock.expectLastCall();
-        
-        control.replay();
-        codec.mediate(msg);
-        control.verify();
-        
-    }
 
     @Test
     public void testEncode() throws Exception {
@@ -249,94 +181,6 @@ public class RMSoapOutInterceptorTest extends Assert {
 
     }
 
-    @Test
-    public void testDecodeSequence() throws XMLStreamException {
-        SoapMessage message = setUpInboundMessage("resources/Message1.xml");
-        RMSoapOutInterceptor codec = new RMSoapOutInterceptor();
-        codec.handleMessage(message);
-        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
-        SequenceType st = rmps.getSequence();
-        assertNotNull(st);
-        assertEquals(st.getIdentifier().getValue(), SEQ_IDENTIFIER);
-        assertEquals(st.getMessageNumber(), MSG1_MESSAGE_NUMBER);
-        
-        assertNull(rmps.getAcks());
-        assertNull(rmps.getAcksRequested());
-
-    }
-
-    @Test
-    public void testDecodeAcknowledgements() throws XMLStreamException {
-        SoapMessage message = setUpInboundMessage("resources/Acknowledgment.xml");
-        RMSoapOutInterceptor codec = new RMSoapOutInterceptor();
-        codec.handleMessage(message);
-        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
-        Collection<SequenceAcknowledgement> acks = rmps.getAcks();
-        assertNotNull(acks);
-        assertEquals(1, acks.size());
-        SequenceAcknowledgement ack = acks.iterator().next();
-        assertNotNull(ack);
-        assertEquals(ack.getIdentifier().getValue(), SEQ_IDENTIFIER);
-        assertEquals(2, ack.getAcknowledgementRange().size());
-        AcknowledgementRange r1 = ack.getAcknowledgementRange().get(0);
-        AcknowledgementRange r2 = ack.getAcknowledgementRange().get(1);
-        verifyRange(r1, 1, 1);
-        verifyRange(r2, 3, 3);
-        assertNull(rmps.getSequence());
-        assertNull(rmps.getAcksRequested());
-    }
-
-    @Test
-    public void testDecodeAcknowledgements2() throws XMLStreamException {
-        SoapMessage message = setUpInboundMessage("resources/Acknowledgment2.xml");
-        RMSoapOutInterceptor codec = new RMSoapOutInterceptor();
-        codec.handleMessage(message);
-        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
-        Collection<SequenceAcknowledgement> acks = rmps.getAcks();
-        assertNotNull(acks);
-        assertEquals(1, acks.size());
-        SequenceAcknowledgement ack = acks.iterator().next();
-        assertNotNull(ack);
-        assertEquals(1, ack.getAcknowledgementRange().size());
-        AcknowledgementRange r1 = ack.getAcknowledgementRange().get(0);
-        verifyRange(r1, 1, 3);
-        assertNull(rmps.getSequence());
-        assertNull(rmps.getAcksRequested());
-    }
-
-    private void verifyRange(AcknowledgementRange r, int i, int j) {
-        assertNotNull(r);
-        if (i > 0) {
-            assertNotNull(r.getLower());
-            assertEquals(i, r.getLower().longValue());
-        }
-        if (j > 0) {
-            assertNotNull(r.getUpper());
-            assertEquals(j, r.getUpper().longValue());
-        }
-    }
-
-    @Test
-    public void testDecodeAcksRequested() throws XMLStreamException {
-        SoapMessage message = setUpInboundMessage("resources/Retransmission.xml");
-        RMSoapOutInterceptor codec = new RMSoapOutInterceptor();
-        codec.handleMessage(message);
-        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
-        Collection<AckRequestedType> requested = rmps.getAcksRequested();
-        assertNotNull(requested);
-        assertEquals(1, requested.size());
-        AckRequestedType ar = requested.iterator().next();
-        assertNotNull(ar);
-        assertEquals(ar.getIdentifier().getValue(), SEQ_IDENTIFIER);
-
-        SequenceType s = rmps.getSequence();
-        assertNotNull(s);
-        assertEquals(s.getIdentifier().getValue(), SEQ_IDENTIFIER);
-        assertEquals(s.getMessageNumber(), MSG2_MESSAGE_NUMBER);
-
-        assertNull(rmps.getAcks());
-    }
-
     private void setUpOutbound() {
         ObjectFactory factory = new ObjectFactory();
         s1 = factory.createSequenceType();
@@ -373,9 +217,9 @@ public class RMSoapOutInterceptorTest extends Assert {
     }
 
     private SoapMessage setupOutboundMessage() throws Exception {
-        Exchange ex = new ExchangeImpl();        
+        Exchange ex = new ExchangeImpl();
         Message message = new MessageImpl();
-        SoapMessage soapMessage = new SoapMessage(message);         
+        SoapMessage soapMessage = new SoapMessage(message);
         RMProperties rmps = new RMProperties();
         rmps.exposeAs(RM10Constants.NAMESPACE_URI);
         RMContextUtils.storeRMProperties(soapMessage, rmps, true);
@@ -383,6 +227,11 @@ public class RMSoapOutInterceptorTest extends Assert {
         RMContextUtils.storeMAPs(maps, soapMessage, true, false);
         ex.setOutMessage(soapMessage);
         soapMessage.setExchange(ex);        
+        MessageFactory factory = MessageFactory.newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
+        SOAPMessage soap = factory.createMessage();
+        QName bodyName = new QName("http://cxf.apache.org", "dummy", "d");
+        soap.getSOAPBody().addBodyElement(bodyName);
+        soapMessage.setContent(SOAPMessage.class, soap);
         return soapMessage;
     }
     
@@ -399,21 +248,24 @@ public class RMSoapOutInterceptorTest extends Assert {
         SoapMessage soapMessage = new SoapMessage(message);         
         ex.setOutFaultMessage(soapMessage);
         soapMessage.setExchange(ex);        
+        MessageFactory factory = MessageFactory.newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
+        SOAPMessage soap = factory.createMessage();
+        soap.getSOAPBody().addFault();
+        soapMessage.setContent(SOAPMessage.class, soap);
         return soapMessage;
     }
 
     private void verifyHeaders(SoapMessage message, String... names) {
-        List<Header> header = message.getHeaders();
+        SOAPMessage content = message.getContent(SOAPMessage.class);
 
         // check all expected headers are present
 
         for (String name : names) {
             boolean found = false;
-            Iterator<Header> iter = header.iterator();
-            while (iter.hasNext()) {
-                Object obj = iter.next().getObject();
-                if (obj instanceof Element) {
-                    Element elem = (Element) obj;
+            try {
+                Iterator<?> elems = content.getSOAPHeader().getChildElements();
+                while (elems.hasNext()) {
+                    Element elem = (Element)elems.next();
                     String namespace = elem.getNamespaceURI();
                     String localName = elem.getLocalName();
                     if (RM10Constants.NAMESPACE_URI.equals(namespace)
@@ -426,17 +278,15 @@ public class RMSoapOutInterceptorTest extends Assert {
                         break;
                     }
                 }
-            }
+            } catch (SOAPException e) { /* failure will result in not found */ }
             assertTrue("Could not find header element " + name, found);
         }
 
         // no other headers should be present
-
-        Iterator<Header> iter1 = header.iterator();
-        while (iter1.hasNext()) {
-            Object obj = iter1.next().getObject();
-            if (obj instanceof Element) {
-                Element elem = (Element) obj;
+        try {
+            Iterator<?> elems = content.getSOAPHeader().getChildElements();
+            while (elems.hasNext()) {
+                Element elem = (Element)elems.next();
                 String namespace = elem.getNamespaceURI();
                 String localName = elem.getLocalName();
                 assertTrue(RM10Constants.NAMESPACE_URI.equals(namespace) 
@@ -450,26 +300,6 @@ public class RMSoapOutInterceptorTest extends Assert {
                 }
                 assertTrue("Unexpected header element " + localName, found);
             }
-        }
-    }
-    
-    private SoapMessage setUpInboundMessage(String resource) throws XMLStreamException {
-        Message message = new MessageImpl();
-        SoapMessage soapMessage = new SoapMessage(message);
-        RMProperties rmps = new RMProperties();
-        rmps.exposeAs(RM10Constants.NAMESPACE_URI);
-        RMContextUtils.storeRMProperties(soapMessage, rmps, false);
-        AddressingProperties maps = new AddressingProperties();
-        RMContextUtils.storeMAPs(maps, soapMessage, false, false);
-        message.put(MessaRMSoapOutInterceptorTestENABLED, false);
-        InputStream is = RMSoapInterceptorTest.class.getResourceAsStream(resource);
-        assertNotNull(is);
-        XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);
-        soapMessage.setContent(XMLStreamReader.class, reader);
-        ReadHeadersInterceptor rji = new ReadHeadersInterceptor(BusFactory.getDefaultBus());
-        rji.handleMessage(soapMessage); 
-        StartBodyInterceptor sbi = new StartBodyInterceptor();
-        sbi.handleMessage(soapMessage);
-        return soapMessage;
+        } catch (SOAPException e) { /* failure would have been caught before */ }
     }
 }
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImplTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImplTest.java
index 6252e83d0d..44db41c6a2 100644
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImplTest.java
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImplTest.java
@@ -25,6 +25,7 @@ import java.util.Date;
 import java.util.List;
 import java.util.concurrent.Executor;
 
+import org.apache.cxf.binding.soap.SoapMessage;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.ws.rm.RMConfiguration;
 import org.apache.cxf.ws.rm.RMEndpoint;
@@ -101,7 +102,7 @@ public class RetransmissionQueueImplTest extends Assert {
     
     @Test
     public void testResendCandidateCtor() {
-        Message message = createMock(Message.class);
+        SoapMessage message = createMock(SoapMessage.class);
         setupMessagePolicies(message);
         control.replay();
         long now = System.currentTimeMillis();
@@ -117,7 +118,7 @@ public class RetransmissionQueueImplTest extends Assert {
     
     @Test
     public void testResendCandidateAttempted() {
-        Message message = createMock(Message.class);
+        SoapMessage message = createMock(SoapMessage.class);
         setupMessagePolicies(message);
         ready(true);
         long now = System.currentTimeMillis();
@@ -133,7 +134,7 @@ public class RetransmissionQueueImplTest extends Assert {
 
     @Test
     public void testResendCandidateMaxRetries() {
-        Message message = createMock(Message.class);
+        SoapMessage message = createMock(SoapMessage.class);
         setupMessagePolicies(message);
         setupRetryPolicy(message);
         
@@ -159,9 +160,9 @@ public class RetransmissionQueueImplTest extends Assert {
     
     @Test
     public void testCacheUnacknowledged() {
-        Message message1 = setUpMessage("sequence1");
-        Message message2 = setUpMessage("sequence2");
-        Message message3 = setUpMessage("sequence1");
+        SoapMessage message1 = setUpMessage("sequence1");
+        SoapMessage message2 = setUpMessage("sequence2");
+        SoapMessage message3 = setUpMessage("sequence1");
         
         setupMessagePolicies(message1);
         setupMessagePolicies(message2);
@@ -215,11 +216,9 @@ public class RetransmissionQueueImplTest extends Assert {
         List<RetransmissionQueueImpl.ResendCandidate> sequenceList =
             new ArrayList<RetransmissionQueueImpl.ResendCandidate>();
         queue.getUnacknowledged().put("sequence1", sequenceList);
-        Message message1 =
-            setUpMessage("sequence1", messageNumbers[0]);
+        SoapMessage message1 = setUpMessage("sequence1", messageNumbers[0]);
         setupMessagePolicies(message1);        
-        Message message2 =
-            setUpMessage("sequence1", messageNumbers[1]);
+        SoapMessage message2 = setUpMessage("sequence1", messageNumbers[1]);
         setupMessagePolicies(message2);
         ready(false);
         
@@ -244,11 +243,9 @@ public class RetransmissionQueueImplTest extends Assert {
         List<RetransmissionQueueImpl.ResendCandidate> sequenceList =
             new ArrayList<RetransmissionQueueImpl.ResendCandidate>();
         queue.getUnacknowledged().put("sequence1", sequenceList);
-        Message message1 =
-            setUpMessage("sequence1", messageNumbers[0]);
+        SoapMessage message1 = setUpMessage("sequence1", messageNumbers[0]);
         setupMessagePolicies(message1);        
-        Message message2 =
-            setUpMessage("sequence1", messageNumbers[1]);
+        SoapMessage message2 = setUpMessage("sequence1", messageNumbers[1]);
         setupMessagePolicies(message2);        
         ready(false);
         
@@ -273,11 +270,9 @@ public class RetransmissionQueueImplTest extends Assert {
         List<RetransmissionQueueImpl.ResendCandidate> sequenceList =
             new ArrayList<RetransmissionQueueImpl.ResendCandidate>();
         queue.getUnacknowledged().put("sequence1", sequenceList);
-        Message message1 =
-            setUpMessage("sequence1", messageNumbers[0]);
+        SoapMessage message1 = setUpMessage("sequence1", messageNumbers[0]);
         setupMessagePolicies(message1);
-        Message message2 =
-            setUpMessage("sequence1", messageNumbers[1]);
+        SoapMessage message2 = setUpMessage("sequence1", messageNumbers[1]);
         setupMessagePolicies(message2);
         ready(false);
 
@@ -308,11 +303,9 @@ public class RetransmissionQueueImplTest extends Assert {
             new ArrayList<RetransmissionQueueImpl.ResendCandidate>();
         
         queue.getUnacknowledged().put("sequence1", sequenceList);
-        Message message1 =
-            setUpMessage("sequence1", messageNumbers[0], false);
+        SoapMessage message1 = setUpMessage("sequence1", messageNumbers[0], false);
         setupMessagePolicies(message1);        
-        Message message2 =
-            setUpMessage("sequence1", messageNumbers[1], false);
+        SoapMessage message2 = setUpMessage("sequence1", messageNumbers[1], false);
         setupMessagePolicies(message2);
         ready(false);
         
@@ -344,19 +337,16 @@ public class RetransmissionQueueImplTest extends Assert {
         queue.start();
     }
     
-    private Message setUpMessage(String sid) {
+    private SoapMessage setUpMessage(String sid) {
         return setUpMessage(sid, null);
     }
 
-    private Message setUpMessage(String sid, Long messageNumber) {
+    private SoapMessage setUpMessage(String sid, Long messageNumber) {
         return setUpMessage(sid, messageNumber, true);
     }
 
-    private Message setUpMessage(String sid,
-                                        Long messageNumber,
-                                        boolean storeSequence) {
-        Message message =
-            createMock(Message.class);
+    private SoapMessage setUpMessage(String sid, Long messageNumber, boolean storeSequence) {
+        SoapMessage message = createMock(SoapMessage.class);
         if (storeSequence) {
             setUpSequenceType(message, sid, messageNumber);
         }
@@ -388,9 +378,7 @@ public class RetransmissionQueueImplTest extends Assert {
         }
     }
     
-    private SequenceType setUpSequenceType(Message message,
-                                           String sid,
-                                           Long messageNumber) {
+    private SequenceType setUpSequenceType(Message message, String sid, Long messageNumber) {
         RMProperties rmps = createMock(RMProperties.class);
         if (message != null) {
             message.get(RMMessageConstants.RM_PROPERTIES_OUTBOUND);
@@ -417,9 +405,7 @@ public class RetransmissionQueueImplTest extends Assert {
         return sequence;
     }
     
-    private SourceSequence setUpSequence(String sid, 
-                                   Long[] messageNumbers,
-                                   boolean[] isAcked) {
+    private SourceSequence setUpSequence(String sid,  Long[] messageNumbers, boolean[] isAcked) {
         SourceSequence sequence = createMock(SourceSequence.class);
         Identifier id = createMock(Identifier.class);
         sequence.getIdentifier();
@@ -467,7 +453,7 @@ public class RetransmissionQueueImplTest extends Assert {
         Message message;
         boolean includeAckRequested;
         
-        public void resend(Message ctx, boolean requestAcknowledge) {
+        public void resend(SoapMessage ctx, boolean requestAcknowledge) {
             message = ctx;
             includeAckRequested = requestAcknowledge;
         }
