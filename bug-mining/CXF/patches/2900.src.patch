diff --git a/core/src/main/java/org/apache/cxf/endpoint/ClientImpl.java b/core/src/main/java/org/apache/cxf/endpoint/ClientImpl.java
index 428f79454b..848d3bcabe 100644
--- a/core/src/main/java/org/apache/cxf/endpoint/ClientImpl.java
+++ b/core/src/main/java/org/apache/cxf/endpoint/ClientImpl.java
@@ -791,8 +791,11 @@ public class ClientImpl
                         if (resCtx != null) {
                             responseContext.put(Thread.currentThread(), resCtx);
                         }
-                        callback.handleException(resCtx, error);
-
+                        // remove callback so that it won't be invoked twice
+                        callback = message.getExchange().remove(ClientCallback.class);
+                        if (callback != null) {
+                            callback.handleException(resCtx, error);
+                        }
                     }
                 } else {
                     chain.doIntercept(message);
@@ -801,8 +804,13 @@ public class ClientImpl
             }
 
             callback = message.getExchange().get(ClientCallback.class);
+            if (callback == null || isPartialResponse(message)) {
+                return;
+            }
 
-            if (callback != null && !isPartialResponse(message)) {
+            // remove callback so that it won't be invoked twice
+            callback = message.getExchange().remove(ClientCallback.class);
+            if (callback != null) {
                 message.getExchange().setInMessage(message);
                 Map<String, Object> resCtx = CastUtils.cast((Map<?, ?>)message
                                                                 .getExchange()
diff --git a/core/src/main/java/org/apache/cxf/interceptor/ClientOutFaultObserver.java b/core/src/main/java/org/apache/cxf/interceptor/ClientOutFaultObserver.java
index 0c879c52af..f139da90a2 100644
--- a/core/src/main/java/org/apache/cxf/interceptor/ClientOutFaultObserver.java
+++ b/core/src/main/java/org/apache/cxf/interceptor/ClientOutFaultObserver.java
@@ -50,7 +50,8 @@ public class ClientOutFaultObserver extends AbstractFaultChainInitiatorObserver
             return;
         }
         Exception ex = m.getContent(Exception.class);
-        ClientCallback callback = m.getExchange().get(ClientCallback.class);
+        // remove callback so that it won't be invoked twice
+        ClientCallback callback = m.getExchange().remove(ClientCallback.class);
 
         if (callback != null) {
             Map<String, Object> resCtx = CastUtils.cast((Map<?, ?>) m.getExchange().getOutMessage().get(
diff --git a/core/src/main/java/org/apache/cxf/message/AbstractWrappedMessage.java b/core/src/main/java/org/apache/cxf/message/AbstractWrappedMessage.java
index 496b97bc67..094e4322da 100644
--- a/core/src/main/java/org/apache/cxf/message/AbstractWrappedMessage.java
+++ b/core/src/main/java/org/apache/cxf/message/AbstractWrappedMessage.java
@@ -157,6 +157,9 @@ public abstract class AbstractWrappedMessage implements Message {
     public <T> void put(Class<T> key, T value) {
         message.put(key, value);
     }
+    public <T> T remove(Class<T> key) {
+        return message.remove(key);
+    }
 
     public Object getContextualProperty(String key) {
         return message.getContextualProperty(key);
diff --git a/core/src/main/java/org/apache/cxf/message/ExchangeImpl.java b/core/src/main/java/org/apache/cxf/message/ExchangeImpl.java
index d2abd7a85e..4798827da8 100644
--- a/core/src/main/java/org/apache/cxf/message/ExchangeImpl.java
+++ b/core/src/main/java/org/apache/cxf/message/ExchangeImpl.java
@@ -159,6 +159,10 @@ public class ExchangeImpl extends ConcurrentHashMap<String, Object>  implements
         return super.put(key, value);
     }
 
+    public <T> T remove(Class<T> key) {
+        return key.cast(super.remove(key.getName()));
+    }
+
     private void setMessageContextProperty(Message m, String key, Object value) {
         if (m == null) {
             return;
diff --git a/core/src/main/java/org/apache/cxf/message/StringMap.java b/core/src/main/java/org/apache/cxf/message/StringMap.java
index 4d802b817f..87115fe01e 100644
--- a/core/src/main/java/org/apache/cxf/message/StringMap.java
+++ b/core/src/main/java/org/apache/cxf/message/StringMap.java
@@ -38,4 +38,11 @@ public interface StringMap extends Map<String, Object> {
      * @param value the value
      */
     <T> void put(Class<T> key, T value);
+
+    /**
+     * Convenience method for removing typed objects from the map.
+     * equivalent to:  (T)remove(key.getName());
+     * @param key the key
+     */
+    <T> T remove(Class<T> key);
 }
diff --git a/core/src/main/java/org/apache/cxf/message/StringMapImpl.java b/core/src/main/java/org/apache/cxf/message/StringMapImpl.java
index c1428e455c..f3acdc126b 100644
--- a/core/src/main/java/org/apache/cxf/message/StringMapImpl.java
+++ b/core/src/main/java/org/apache/cxf/message/StringMapImpl.java
@@ -46,4 +46,8 @@ public class StringMapImpl
     public <T> void put(Class<T> key, T value) {
         put(key.getName(), value);
     }
+
+    public <T> T remove(Class<T> key) {
+        return key.cast(remove(key.getName()));
+    }
 }
diff --git a/rt/transports/http-hc/src/test/java/org/apache/cxf/transport/http/asyncclient/AsyncHTTPConduitTest.java b/rt/transports/http-hc/src/test/java/org/apache/cxf/transport/http/asyncclient/AsyncHTTPConduitTest.java
index 3341e3eced..d4a25f6cce 100644
--- a/rt/transports/http-hc/src/test/java/org/apache/cxf/transport/http/asyncclient/AsyncHTTPConduitTest.java
+++ b/rt/transports/http-hc/src/test/java/org/apache/cxf/transport/http/asyncclient/AsyncHTTPConduitTest.java
@@ -23,6 +23,7 @@ import java.net.URL;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import javax.xml.ws.AsyncHandler;
 import javax.xml.ws.Endpoint;
@@ -197,6 +198,26 @@ public class AsyncHTTPConduitTest extends AbstractBusClientServerTestBase {
             }
         }).get();
     }
+
+    @Test
+    public void testCallAsyncCallbackInvokedOnlyOnce() throws Exception {
+        // This test is especially targeted for RHEL 6.8
+        updateAddressPort(g, PORT_INV);
+        int repeat = 100;
+        final AtomicInteger count = new AtomicInteger(0);
+        for (int i = 0; i < repeat; i++) {
+            try {
+                g.greetMeAsync(request, new AsyncHandler<GreetMeResponse>() {
+                    public void handleResponse(Response<GreetMeResponse> res) {
+                        count.incrementAndGet();
+                    }
+                }).get();
+            } catch (Exception e) {
+            }
+        }
+        Thread.sleep(1000);
+        assertEquals("Callback should be invoked only once per request", repeat, count.intValue());
+    }
         
     @Test
     @Ignore("peformance test")
diff --git a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java
index adebe09fd9..e5aa543a02 100644
--- a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java
+++ b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java
@@ -1626,12 +1626,13 @@ public abstract class HTTPConduit
                     if (isOneway(exchange) && responseCode > 300) {
                         throw new HTTPException(responseCode, getResponseMessage(), url.toURL());
                     }
-                    ClientCallback cc = exchange.get(ClientCallback.class);
-                    if (null != cc) {
-                        //REVISIT move the decoupled destination property name into api
-                        Endpoint ep = exchange.getEndpoint();
-                        if (null != ep && null != ep.getEndpointInfo() && null == ep.getEndpointInfo().
+                    //REVISIT move the decoupled destination property name into api
+                    Endpoint ep = exchange.getEndpoint();
+                    if (null != ep && null != ep.getEndpointInfo() && null == ep.getEndpointInfo().
                             getProperty("org.apache.cxf.ws.addressing.MAPAggregator.decoupledDestination")) {
+                        // remove callback so that it won't be invoked twice
+                        ClientCallback cc = exchange.remove(ClientCallback.class);
+                        if (null != cc) {
                             cc.handleResponse(null, null);
                         }
                     }
