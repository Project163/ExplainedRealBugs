diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/ConfigurableImpl.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/ConfigurableImpl.java
index d78d8c98f0..4abfed5824 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/ConfigurableImpl.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/ConfigurableImpl.java
@@ -22,9 +22,11 @@ package org.apache.cxf.jaxrs.impl;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.logging.Logger;
 import java.util.stream.Collectors;
 
+import javax.ws.rs.ConstrainedTo;
 import javax.ws.rs.Priorities;
 import javax.ws.rs.RuntimeType;
 import javax.ws.rs.client.ClientRequestFilter;
@@ -69,7 +71,12 @@ public class ConfigurableImpl<C extends Configurable<C>> implements Configurable
 
     static Class<?>[] getImplementedContracts(Object provider, Class<?>[] restrictedClasses) {
         Class<?> providerClass = provider instanceof Class<?> ? ((Class<?>)provider) : provider.getClass();
-        List<Class<?>> implementedContracts = Arrays.stream(providerClass.getInterfaces())
+        Set<Class<?>> interfaces = Arrays.stream(providerClass.getInterfaces()).collect(Collectors.toSet());
+        providerClass = providerClass.getSuperclass();
+        for (; providerClass != null && providerClass != Object.class; providerClass = providerClass.getSuperclass()) {
+            interfaces.addAll(Arrays.stream(providerClass.getInterfaces()).collect(Collectors.toSet()));
+        }
+        List<Class<?>> implementedContracts = interfaces.stream()
             .filter(el -> Arrays.stream(restrictedClasses).noneMatch(el::equals))
             .collect(Collectors.toList());
         return implementedContracts.toArray(new Class<?>[]{});
@@ -130,20 +137,23 @@ public class ConfigurableImpl<C extends Configurable<C>> implements Configurable
     public C register(Class<?> providerClass, Map<Class<?>, Integer> contracts) {
         return register(getInstantiator().create(providerClass), contracts);
     }
-    
+
     protected Instantiator getInstantiator() {
         return ConfigurationImpl::createProvider;
     }
 
     private C doRegister(Object provider, int bindingPriority, Class<?>... contracts) {
         if (contracts == null || contracts.length == 0) {
-            LOG.warning("Null or empty contracts specified for " + provider + "; ignoring.");
+            LOG.warning("Null, empty or invalid contracts specified for " + provider + "; ignoring.");
             return configurable;
         }
         return doRegister(provider, ConfigurationImpl.initContractsMap(bindingPriority, contracts));
     }
-    
+
     private C doRegister(Object provider, Map<Class<?>, Integer> contracts) {
+        if (!checkConstraints(provider)) {
+            return configurable;
+        }
         if (provider instanceof Feature) {
             Feature feature = (Feature)provider;
             boolean enabled = feature.configure(new FeatureContextImpl(this));
@@ -154,4 +164,33 @@ public class ConfigurableImpl<C extends Configurable<C>> implements Configurable
         config.register(provider, contracts);
         return configurable;
     }
+
+    private boolean checkConstraints(Object provider) {
+        Class<?> providerClass = provider.getClass();
+        ConstrainedTo providerConstraint = providerClass.getAnnotation(ConstrainedTo.class);
+        if (providerConstraint != null) {
+            RuntimeType currentRuntime = config.getRuntimeType();
+            RuntimeType providerRuntime = providerConstraint.value();
+            // need to check (1) whether the registration is occurring in the specified runtime type
+            // and (2) does the provider implement an invalid interface based on the constrained runtime type
+            if (!providerRuntime.equals(currentRuntime)) {
+                LOG.warning("Provider " + provider + " cannot be registered in this " + currentRuntime
+                            + " runtime because it is constrained to " + providerRuntime + " runtimes.");
+                return false;
+            }
+            
+            Class<?>[] restrictedInterfaces = RuntimeType.CLIENT.equals(providerRuntime) ? RESTRICTED_CLASSES_IN_CLIENT
+                                                                                         : RESTRICTED_CLASSES_IN_SERVER;
+            for (Class<?> restrictedContract : restrictedInterfaces) {
+                if (restrictedContract.isAssignableFrom(providerClass)) {
+                    RuntimeType opposite = RuntimeType.CLIENT.equals(providerRuntime) ? RuntimeType.SERVER
+                                                                                      : RuntimeType.CLIENT;
+                    LOG.warning("Provider " + providerClass.getName() + " is invalid - it is constrained to "
+                        + providerRuntime + " runtimes but implements a " + opposite + " interface ");
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
 }
diff --git a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/ConfigurationImplTest.java b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/ConfigurationImplTest.java
index 726c3e05d0..0e43f05e3d 100644
--- a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/ConfigurationImplTest.java
+++ b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/ConfigurationImplTest.java
@@ -30,6 +30,7 @@ import java.util.Map;
 import java.util.logging.Handler;
 import java.util.logging.LogRecord;
 
+import javax.ws.rs.ConstrainedTo;
 import javax.ws.rs.RuntimeType;
 import javax.ws.rs.client.Client;
 import javax.ws.rs.client.ClientRequestContext;
@@ -54,30 +55,62 @@ import org.junit.Test;
 public class ConfigurationImplTest extends Assert {
 
     @Test
-    public void testIsRegistered() {
+    public void testIsRegistered() throws Exception {
+//        ConfigurationImpl c = new ConfigurationImpl(RuntimeType.SERVER);
+//        ContainerResponseFilter filter = new ContainerResponseFilterImpl();
+//        assertTrue(c.register(filter,
+//                              Collections.<Class<?>, Integer>singletonMap(ContainerResponseFilter.class, 1000)));
+//        assertTrue(c.isRegistered(filter));
+//        assertFalse(c.isRegistered(new ContainerResponseFilterImpl()));
+//        assertTrue(c.isRegistered(ContainerResponseFilterImpl.class));
+//        assertFalse(c.isRegistered(ContainerResponseFilter.class));
+//        assertFalse(c.register(filter,
+//                               Collections.<Class<?>, Integer>singletonMap(ContainerResponseFilter.class, 1000)));
+//        assertFalse(c.register(ContainerResponseFilterImpl.class,
+//                               Collections.<Class<?>, Integer>singletonMap(ContainerResponseFilter.class, 1000)));
+        doTestIsFilterRegistered(new ContainerResponseFilterImpl(), ContainerResponseFilterImpl.class);
+    }
+    
+    @Test
+    public void testIsRegisteredSubClass() throws Exception {
+        doTestIsFilterRegistered(new ContainerResponseFilterSubClassImpl(), ContainerResponseFilterSubClassImpl.class);
+    }
+
+    private void doTestIsFilterRegistered(Object provider, Class<?> providerClass) throws Exception {
         ConfigurationImpl c = new ConfigurationImpl(RuntimeType.SERVER);
-        ContainerResponseFilter filter = new ContainerResponseFilterImpl();
-        assertTrue(c.register(filter,
+        assertTrue(c.register(provider,
                               Collections.<Class<?>, Integer>singletonMap(ContainerResponseFilter.class, 1000)));
-        assertTrue(c.isRegistered(filter));
-        assertFalse(c.isRegistered(new ContainerResponseFilterImpl()));
-        assertTrue(c.isRegistered(ContainerResponseFilterImpl.class));
+        assertTrue(c.isRegistered(provider));
+        assertFalse(c.isRegistered(providerClass.newInstance()));
+        assertTrue(c.isRegistered(providerClass));
         assertFalse(c.isRegistered(ContainerResponseFilter.class));
-        assertFalse(c.register(filter,
+        assertFalse(c.register(provider,
                                Collections.<Class<?>, Integer>singletonMap(ContainerResponseFilter.class, 1000)));
-        assertFalse(c.register(ContainerResponseFilterImpl.class,
+        assertFalse(c.register(providerClass,
                                Collections.<Class<?>, Integer>singletonMap(ContainerResponseFilter.class, 1000)));
     }
+
+    @ConstrainedTo(RuntimeType.SERVER)
     public static class ContainerResponseFilterImpl implements ContainerResponseFilter {
 
         @Override
         public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext)
             throws IOException {
-
         }
 
     }
 
+    public static class ContainerResponseFilterSubClassImpl extends ContainerResponseFilterImpl { }
+
+    @ConstrainedTo(RuntimeType.CLIENT)
+    public static class ClientResponseFilterImpl implements ClientResponseFilter {
+
+        @Override
+        public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext)
+            throws IOException {
+        }
+
+    }
     static class TestHandler extends Handler {
 
         List<String> messages = new ArrayList<>();
@@ -158,6 +191,18 @@ public class ConfigurationImplTest extends Assert {
                 } });
     }
 
+    @Test
+    public void testSubClassIsRegisteredOnConfigurable() {
+        FeatureContextImpl featureContext = new FeatureContextImpl();
+        Configurable<FeatureContext> configurable = new ConfigurableImpl<>(featureContext, RuntimeType.SERVER);
+        featureContext.setConfigurable(configurable);
+        featureContext.register(ContainerResponseFilterSubClassImpl.class);
+        Configuration config = configurable.getConfiguration();
+        Map<Class<?>, Integer> contracts = config.getContracts(ContainerResponseFilter.class);
+        assertEquals(1, contracts.size());
+        assertTrue(contracts.containsKey(ContainerResponseFilter.class));
+    }
+    
     @Test
     public void testServerFilterContractsOnClientIsRejected() {
         Configurable<Client> configurable = new ConfigurableImpl<Client>(createClientProxy(), RuntimeType.CLIENT);
@@ -244,4 +289,56 @@ public class ConfigurationImplTest extends Assert {
         assertEquals(5, config.getInstances().size());
         assertTrue(config.isEnabled(DisablableFeature.class));
     }
+
+    @ConstrainedTo(RuntimeType.SERVER)
+    public static class ClientFilterConstrainedToServer implements ClientRequestFilter {
+
+        /** {@inheritDoc}*/
+        @Override
+        public void filter(ClientRequestContext paramClientRequestContext) throws IOException {
+            // no-op
+        }
+        
+    }
+
+    @Test
+    public void testInvalidConstraintOnProvider() {
+        TestHandler handler = new TestHandler();
+        LogUtils.getL7dLogger(ConfigurableImpl.class).addHandler(handler);
+
+        Configurable<Client> configurable = new ConfigurableImpl<Client>(createClientProxy(), RuntimeType.CLIENT);
+        Configuration config = configurable.getConfiguration();
+
+        configurable.register(ClientFilterConstrainedToServer.class);
+
+        assertEquals(0, config.getInstances().size());
+
+        for (String message : handler.messages) {
+            if (message.startsWith("WARN") && message.contains("cannot be registered in ")) {
+                return; // success
+            }
+        }
+        fail("did not log expected message");
+    }
+
+    
+    @Test
+    public void testChecksConstrainedToAnnotationDuringRegistration() {
+        TestHandler handler = new TestHandler();
+        LogUtils.getL7dLogger(ConfigurableImpl.class).addHandler(handler);
+
+        Configurable<Client> configurable = new ConfigurableImpl<Client>(createClientProxy(), RuntimeType.CLIENT);
+        Configuration config = configurable.getConfiguration();
+
+        configurable.register(ContainerResponseFilterImpl.class);
+
+        assertEquals(0, config.getInstances().size());
+
+        for (String message : handler.messages) {
+            if (message.startsWith("WARN") && message.contains("Null, empty or invalid contracts specified")) {
+                return; // success
+            }
+        }
+        fail("did not log expected message");
+    }
 }
diff --git a/rt/rs/client/src/test/java/org/apache/cxf/jaxrs/client/spec/ClientImplTest.java b/rt/rs/client/src/test/java/org/apache/cxf/jaxrs/client/spec/ClientImplTest.java
index f45c2ea9e3..88cf9da8f5 100644
--- a/rt/rs/client/src/test/java/org/apache/cxf/jaxrs/client/spec/ClientImplTest.java
+++ b/rt/rs/client/src/test/java/org/apache/cxf/jaxrs/client/spec/ClientImplTest.java
@@ -164,7 +164,7 @@ public class ClientImplTest extends Assert {
         ClientBuilder.newClient().register(MyInterceptor.class, (Class<?>[]) null);
 
         for (String message : handler.messages) {
-            if (message.startsWith("WARN") && message.contains("Null or empty contracts")) {
+            if (message.startsWith("WARN") && message.contains("Null, empty or invalid contracts specified")) {
                 return; // success
             }
         }
@@ -181,7 +181,7 @@ public class ClientImplTest extends Assert {
         ClientBuilder.newClient().register(new MyInterceptor(), (Class<?>[]) null);
 
         for (String message : handler.messages) {
-            if (message.startsWith("WARN") && message.contains("Null or empty contracts")) {
+            if (message.startsWith("WARN") && message.contains("Null, empty or invalid contracts specified")) {
                 return; // success
             }
         }
