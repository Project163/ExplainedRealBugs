diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RetransmissionCallback.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RetransmissionCallback.java
index b00c4fc48c..b5ae9f25bf 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RetransmissionCallback.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RetransmissionCallback.java
@@ -48,7 +48,7 @@ public class RetransmissionCallback implements CachedOutputStreamCallback {
     }
     public void onClose(CachedOutputStream cos) {
    
-        //REVISIT - would be nice to keep the cache on disk intead of in-memory 
+        //REVISIT - would be nice to keep the cache on disk instead of in-memory 
         byte bytes[] = null;
         try {
             bytes = cos.getBytes();
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImpl.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImpl.java
index d497ffe2e1..36b4ec1517 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImpl.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImpl.java
@@ -23,6 +23,7 @@ import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.math.BigInteger;
+import java.net.ConnectException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -262,6 +263,10 @@ public class RetransmissionQueueImpl implements RetransmissionQueue {
         if (null != maps) {
             to = maps.getTo();
         }
+        if (RMUtils.getAddressingConstants().getAnonymousURI().equals(to.getValue())) {
+            LOG.log(Level.FINE, "Cannot resend to anonymous target");
+            return;
+        }
         if (null == to) {
             LOG.log(Level.SEVERE, "NO_ADDRESS_FOR_RESEND_MSG");
             return;
@@ -317,10 +322,11 @@ public class RetransmissionQueueImpl implements RetransmissionQueue {
             if (os instanceof CachedOutputStream) {
                 callbacks = ((CachedOutputStream)os).getCallbacks();
             }
-            
+            message.removeContent(OutputStream.class);
             c.prepare(message);
 
             os = message.getContent(OutputStream.class);
+            
             if (null != callbacks && callbacks.size() > 1) {
                 if (!(os instanceof CachedOutputStream)) {
                     os = RMUtils.createCachedStream(message, os);
@@ -349,6 +355,8 @@ public class RetransmissionQueueImpl implements RetransmissionQueue {
             IOUtils.copyAndCloseInput(bis, os);
             os.flush();
             os.close();
+        } catch (ConnectException ex) {
+            //ignore, we'll just resent again later
         } catch (IOException ex) {
             LOG.log(Level.SEVERE, "RESEND_FAILED_MSG", ex);
         }
@@ -359,6 +367,7 @@ public class RetransmissionQueueImpl implements RetransmissionQueue {
      */
     protected class ResendCandidate implements Runnable {
         private Message message;
+        private OutputStream out;
         private Date next;
         private TimerTask nextTask;
         private int resends;
@@ -373,6 +382,7 @@ public class RetransmissionQueueImpl implements RetransmissionQueue {
         protected ResendCandidate(Message m) {
             message = m;
             resends = 0;
+            out = m.getContent(OutputStream.class);
             RMAssertion rma = PolicyUtils.getRMAssertion(manager.getRMAssertion(), message);
             long baseRetransmissionInterval = 
                 rma.getBaseRetransmissionInterval().getMilliseconds().longValue();
@@ -380,6 +390,18 @@ public class RetransmissionQueueImpl implements RetransmissionQueue {
                 ? RetransmissionQueue.DEFAULT_EXPONENTIAL_BACKOFF : 1;
             next = new Date(System.currentTimeMillis() + baseRetransmissionInterval);
             nextInterval = baseRetransmissionInterval * backoff;
+            
+            
+            AddressingProperties maps = RMContextUtils.retrieveMAPs(message, false, true);
+            AttributedURIType to = null;
+            if (null != maps) {
+                to = maps.getTo();
+            }
+            if (to != null 
+                && RMUtils.getAddressingConstants().getAnonymousURI().equals(to.getValue())) {
+                LOG.log(Level.INFO, "Cannot resend to anonymous target.  Not scheduling a resend.");
+                return;
+            }
             if (null != manager.getTimer()) {
                 schedule();
             }
@@ -415,6 +437,7 @@ public class RetransmissionQueueImpl implements RetransmissionQueue {
                 // ensure ACK wasn't received while this task was enqueued
                 // on executor
                 if (isPending()) {
+                    message.setContent(OutputStream.class, out);
                     resender.resend(message, includeAckRequested);
                     includeAckRequested = false;
                 }
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/rm/SequenceTest.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/rm/SequenceTest.java
index 27d6f53e5e..096c3c8e96 100644
--- a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/rm/SequenceTest.java
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/rm/SequenceTest.java
@@ -188,7 +188,6 @@ public class SequenceTest extends AbstractBusClientServerTestBase {
     }
 
     // --- tests ---
-    
     @Test
     public void testOnewayAnonymousAcks() throws Exception {
         init("org/apache/cxf/systest/ws/rm/rminterceptors.xml");
@@ -642,16 +641,14 @@ public class SequenceTest extends AbstractBusClientServerTestBase {
 
     }
     
-    /**
-     * A maximum sequence length of 2 is configured for the client only (server allows 10).
-     * However, as we use the defaults regarding the including and acceptance
-     * for inbound sequence offers and correlate offered sequences that are
-     * included in a CreateSequence request and accepted with those that are
-     * created on behalf of such a request, the server also tries terminate its
-     * sequences. Note that as part of the sequence termination exchange a
-     * standalone sequence acknowledgment needs to be sent regardless of whether
-     * or nor acknowledgments are delivered steadily with every response.
-     */
+    // A maximum sequence length of 2 is configured for the client only (server allows 10).
+    // However, as we use the defaults regarding the including and acceptance
+    // for inbound sequence offers and correlate offered sequences that are
+    // included in a CreateSequence request and accepted with those that are
+    // created on behalf of such a request, the server also tries terminate its
+    // sequences. Note that as part of the sequence termination exchange a
+    // standalone sequence acknowledgment needs to be sent regardless of whether
+    // or nor acknowledgments are delivered steadily with every response.
     @Test
     public void testTwowayNonAnonymousMaximumSequenceLength2() throws Exception {
         init("org/apache/cxf/systest/ws/rm/seqlength10.xml", true);
@@ -1322,7 +1319,6 @@ public class SequenceTest extends AbstractBusClientServerTestBase {
         mf.verifyAcknowledgements(new boolean[] {false, true}, false);
         
     }    
-
     // --- test utilities ---
 
     private void init(String cfgResource) {
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/util/InMessageRecorder.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/util/InMessageRecorder.java
index 01bc9b9956..9a4dad7423 100644
--- a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/util/InMessageRecorder.java
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/util/InMessageRecorder.java
@@ -20,8 +20,8 @@ package org.apache.cxf.systest.ws.util;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
-import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
@@ -40,7 +40,7 @@ public class InMessageRecorder extends AbstractPhaseInterceptor<Message> {
 
     public InMessageRecorder() {
         super(Phase.RECEIVE);
-        inbound = new ArrayList<byte[]>();
+        inbound = new CopyOnWriteArrayList<byte[]>();
     }
 
     public void handleMessage(Message message) throws Fault {
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/util/OutMessageRecorder.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/util/OutMessageRecorder.java
index 890343df36..0ef7ff2d57 100644
--- a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/util/OutMessageRecorder.java
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/util/OutMessageRecorder.java
@@ -20,8 +20,8 @@
 package org.apache.cxf.systest.ws.util;
 
 import java.io.OutputStream;
-import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
@@ -48,12 +48,13 @@ public class OutMessageRecorder extends AbstractPhaseInterceptor<Message> {
 
     public OutMessageRecorder() {
         super(Phase.PRE_STREAM);
-        outbound = new ArrayList<byte[]>();
+        outbound = new CopyOnWriteArrayList<byte[]>();
         addAfter(RetransmissionInterceptor.class.getName());
         addBefore(StaxOutInterceptor.class.getName());
     }
     
     public void handleMessage(Message message) throws Fault {
+        
         OutputStream os = message.getContent(OutputStream.class);
         if (null == os) {
             return;
