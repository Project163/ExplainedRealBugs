diff --git a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/databinding/AegisDatabinding.java b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/databinding/AegisDatabinding.java
index 2050798ab4..360264309c 100644
--- a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/databinding/AegisDatabinding.java
+++ b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/databinding/AegisDatabinding.java
@@ -35,8 +35,8 @@ import org.w3c.dom.Node;
 
 import org.apache.cxf.aegis.AegisContext;
 import org.apache.cxf.aegis.DatabindingException;
-import org.apache.cxf.aegis.type.AbstractTypeCreator;
 import org.apache.cxf.aegis.type.Type;
+import org.apache.cxf.aegis.type.TypeClassInfo;
 import org.apache.cxf.aegis.type.TypeCreationOptions;
 import org.apache.cxf.aegis.type.TypeCreator;
 import org.apache.cxf.aegis.type.TypeMapping;
@@ -352,7 +352,11 @@ public class AegisDatabinding
                 }
             }
             
-            part.setProperty("nillable", Boolean.valueOf(type.isNillable()));
+            // The concept of type.isNillable is questionable: how are types nillable? 
+            // However, this if at least allow .aegis.xml files to get control.
+            if (part.getProperty("nillable") == null) {
+                part.setProperty("nillable", Boolean.valueOf(type.isNillable()));
+            }
             if (type.hasMinOccurs()) {
                 long miValue = type.getMinOccurs();
                 if (miValue != 0) {
@@ -554,11 +558,6 @@ public class AegisDatabinding
     private Type getParameterType(Service s, TypeMapping tm, MessagePartInfo param, int paramtype) {
         Type type = tm.getType(param.getTypeQName());
 
-        /*
-         * if (type == null && tm.isRegistered(param.getTypeClass())) { type =
-         * tm.getType(param.getTypeClass()); part2type.put(param, type); }
-         */
-
         int offset = 0;
         if (paramtype == OUT_PARAM) {
             offset = 1;
@@ -569,12 +568,18 @@ public class AegisDatabinding
             OperationInfo op = param.getMessageInfo().getOperation();
 
             Method m = getMethod(s, op);
-            AbstractTypeCreator.TypeClassInfo info;
+            TypeClassInfo info;
             if (paramtype != FAULT_PARAM && m != null) {
                 info = typeCreator.createClassInfo(m, param.getIndex() - offset);
             } else {
                 info = typeCreator.createBasicClassInfo(param.getTypeClass());
             }
+            Boolean nillable = info.getNillable();
+            /* Note that, for types from the mapping, the minOccurs, maxOccurs, and nillable
+             * from the 'info' will be ignored by createTypeForClass below. So we need
+             * to override.
+             */
+
             if (param.getMessageInfo().getOperation().isUnwrapped() && param.getTypeClass().isArray()) {
                 // The service factory expects arrays going into the wrapper to
                 // be
@@ -584,15 +589,32 @@ public class AegisDatabinding
                 // want the default.
                 param.setProperty("minOccurs", "1");
                 param.setProperty("maxOccurs", "1");
-                param.setProperty("nillable", Boolean.TRUE);
+                if (nillable == null) {
+                    nillable = Boolean.TRUE;
+                }
+                param.setProperty("nillable", nillable);
+            } else {
+                if (nillable != null) {
+                    param.setProperty("nillable", nillable);
+                }
+                /*
+                 * TypeClassInfo uses -1 to mean 'not specified'
+                 */
+                if (info.getMinOccurs() != -1) {
+                    param.setProperty("minOccurs", Long.toString(info.getMinOccurs()));
+                }
+                if (info.getMaxOccurs() != -1) {
+                    param.setProperty("maxOccurs", Long.toString(info.getMaxOccurs()));
+                }
             }
             if (info.getMappedName() != null) {
                 param.setConcreteName(info.getMappedName());
                 param.setName(info.getMappedName());
             }
             type = typeCreator.createTypeForClass(info);
-            // We have to register the type if we want minOccurs and such to
-            // work.
+            
+            //We have to register the type if we want minOccurs and such to
+            // work. (for custom types)
             if (info.nonDefaultAttributes()) {
                 tm.register(type);
             }
diff --git a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/AbstractTypeCreator.java b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/AbstractTypeCreator.java
index 02738f38f0..82f1c800c3 100644
--- a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/AbstractTypeCreator.java
+++ b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/AbstractTypeCreator.java
@@ -135,7 +135,8 @@ public abstract class AbstractTypeCreator implements TypeCreator {
             result = type;
         }
 
-        if (newType && !getConfiguration().isDefaultNillable()) {
+        if (newType
+            && !getConfiguration().isDefaultNillable()) {
             result.setNillable(false);
         }
 
@@ -337,11 +338,11 @@ public abstract class AbstractTypeCreator implements TypeCreator {
         if (info.nonDefaultAttributes()) {
             localName += "-";
             if (info.getMinOccurs() >= 0) {
-                localName += info.minOccurs;
+                localName += info.getMinOccurs();
             }
             localName += "-";
             if (info.getMaxOccurs() >= 0) {
-                localName += info.maxOccurs;
+                localName += info.getMaxOccurs();
             }
             if (info.isFlat()) {
                 localName += "Flat";
@@ -433,131 +434,4 @@ public abstract class AbstractTypeCreator implements TypeCreator {
     public void setConfiguration(TypeCreationOptions tpConfiguration) {
         this.typeConfiguration = tpConfiguration;
     }
-
-    /**
-     * Object to carry information for a type, such as that from an XML mapping file. 
-     */
-    public static class TypeClassInfo {
-        Class typeClass;
-
-        Object[] annotations;
-
-        Object genericType;
-
-        Object keyType;
-        Object valueType;
-        QName mappedName;
-        QName typeName;
-        Class type;
-        String description;
-        long minOccurs = -1;
-        long maxOccurs = -1;
-        boolean flat;
-        
-        public boolean nonDefaultAttributes() {
-            return minOccurs != -1 || maxOccurs != -1 || flat;
-        }
-
-        public String getDescription() {
-            return description;
-        }
-
-        public void setDescription(String description) {
-            this.description = description;
-        }
-
-        public Object[] getAnnotations() {
-            return annotations;
-        }
-
-        public void setAnnotations(Object[] annotations) {
-            this.annotations = annotations;
-        }
-
-        public Object getGenericType() {
-            return genericType;
-        }
-
-        public void setGenericType(Object genericType) {
-            this.genericType = genericType;
-        }
-
-        public Object getKeyType() {
-            return keyType;
-        }
-
-        public void setKeyType(Object keyType) {
-            this.keyType = keyType;
-        }
-
-        public Class getTypeClass() {
-            return typeClass;
-        }
-
-        public void setTypeClass(Class typeClass) {
-            this.typeClass = typeClass;
-        }
-
-        public QName getTypeName() {
-            return typeName;
-        }
-
-        public void setTypeName(QName name) {
-            this.typeName = name;
-        }
-
-        public Class getType() {
-            return type;
-        }
-
-        public void setType(Class type) {
-            this.type = type;
-        }
-
-        public QName getMappedName() {
-            return mappedName;
-        }
-
-        public void setMappedName(QName mappedName) {
-            this.mappedName = mappedName;
-        }
-
-        public long getMaxOccurs() {
-            return maxOccurs;
-        }
-
-        public void setMaxOccurs(long maxOccurs) {
-            this.maxOccurs = maxOccurs;
-        }
-
-        public long getMinOccurs() {
-            return minOccurs;
-        }
-
-        public void setMinOccurs(long minOccurs) {
-            this.minOccurs = minOccurs;
-        }
-
-        public boolean isFlat() {
-            return flat;
-        }
-
-        public void setFlat(boolean flat) {
-            this.flat = flat;
-        }
-
-        @Override
-        public String toString() {
-            return "TypeClassInfo " + getDescription();
-        }
-
-        public Object getValueType() {
-            return valueType;
-        }
-
-        public void setValueType(Object valueType) {
-            this.valueType = valueType;
-        }
-
-    }
 }
diff --git a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/DefaultTypeCreator.java b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/DefaultTypeCreator.java
index 0bdfc47a24..f54b2b9514 100644
--- a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/DefaultTypeCreator.java
+++ b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/DefaultTypeCreator.java
@@ -22,7 +22,6 @@ import java.beans.PropertyDescriptor;
 import java.lang.reflect.Method;
 
 import org.apache.cxf.aegis.DatabindingException;
-import org.apache.cxf.aegis.type.AbstractTypeCreator.TypeClassInfo;
 import org.apache.cxf.aegis.type.basic.BeanType;
 import org.apache.cxf.aegis.type.basic.BeanTypeInfo;
 
diff --git a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/TypeClassInfo.java b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/TypeClassInfo.java
new file mode 100644
index 0000000000..48f7e450f0
--- /dev/null
+++ b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/TypeClassInfo.java
@@ -0,0 +1,172 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.aegis.type;
+
+import javax.xml.namespace.QName;
+
+/**
+ * Object to carry information for a type, such as that from an XML mapping file.
+ * 
+ * Note that this class has a misleading name. It is used both for 
+ * type information that corresponds to a type, and also for parameters 
+ * of methods and elements of beans. When describing a top-level type,
+ * minOccurs and maxOccurs are not meaningful. Nillable is only used for
+ * parameters. It might be that the code could be deconfused by
+ * using the nillable property in here for the non-parameters cases
+ * that look at minOccurs and maxOccurs.
+ * 
+ * Historically, the code for dealing with nillable was very confused,
+ * and so the support here is a bit ginger, until someone figures out how
+ * to sort things out. Thus the three-valued support instead
+ * of a plain boolean.
+ */
+public class TypeClassInfo {
+    private Class typeClass;
+    private Object[] annotations;
+    // Object because it can be either a TypeClassInfo or a
+    // java.lang.reflect.Type
+    private Object genericType;
+    // ditto
+    private Object keyType;
+    // ditto
+    private Object valueType;
+    private QName mappedName;
+    private QName typeName;
+    private Class type;
+    private String description;
+    private long minOccurs = -1;
+    private long maxOccurs = -1;
+    // not yet implemented
+    private boolean flat;
+    private Boolean nillable;
+    
+    public boolean nonDefaultAttributes() {
+        return minOccurs != -1 || maxOccurs != -1 || flat;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    public Object[] getAnnotations() {
+        return annotations;
+    }
+
+    public void setAnnotations(Object[] annotations) {
+        this.annotations = annotations;
+    }
+
+    public Object getGenericType() {
+        return genericType;
+    }
+
+    public void setGenericType(Object genericType) {
+        this.genericType = genericType;
+    }
+
+    public Object getKeyType() {
+        return keyType;
+    }
+
+    public void setKeyType(Object keyType) {
+        this.keyType = keyType;
+    }
+
+    public Class getTypeClass() {
+        return typeClass;
+    }
+
+    public void setTypeClass(Class typeClass) {
+        this.typeClass = typeClass;
+    }
+
+    public QName getTypeName() {
+        return typeName;
+    }
+
+    public void setTypeName(QName name) {
+        this.typeName = name;
+    }
+
+    public Class getType() {
+        return type;
+    }
+
+    public void setType(Class type) {
+        this.type = type;
+    }
+
+    public QName getMappedName() {
+        return mappedName;
+    }
+
+    public void setMappedName(QName mappedName) {
+        this.mappedName = mappedName;
+    }
+
+    public long getMaxOccurs() {
+        return maxOccurs;
+    }
+
+    public void setMaxOccurs(long maxOccurs) {
+        this.maxOccurs = maxOccurs;
+    }
+
+    public long getMinOccurs() {
+        return minOccurs;
+    }
+
+    public void setMinOccurs(long minOccurs) {
+        this.minOccurs = minOccurs;
+    }
+
+    public boolean isFlat() {
+        return flat;
+    }
+
+    public void setFlat(boolean flat) {
+        this.flat = flat;
+    }
+
+    @Override
+    public String toString() {
+        return "TypeClassInfo " + getDescription();
+    }
+
+    public Object getValueType() {
+        return valueType;
+    }
+
+    public void setValueType(Object valueType) {
+        this.valueType = valueType;
+    }
+
+    public Boolean getNillable() {
+        return nillable;
+    }
+
+    public void setNillable(Boolean nillable) {
+        this.nillable = nillable;
+    }
+}
\ No newline at end of file
diff --git a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/TypeCreator.java b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/TypeCreator.java
index 4dc774fceb..943bc99688 100644
--- a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/TypeCreator.java
+++ b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/TypeCreator.java
@@ -24,7 +24,6 @@ import java.lang.reflect.Method;
 
 import javax.xml.namespace.QName;
 
-import org.apache.cxf.aegis.type.AbstractTypeCreator.TypeClassInfo;
 
 /**
  * @author <a href="mailto:dan@envoisolutions.com">Dan Diephouse</a>
diff --git a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/XMLTypeCreator.java b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/XMLTypeCreator.java
index e98f51195b..38abcceea0 100644
--- a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/XMLTypeCreator.java
+++ b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/XMLTypeCreator.java
@@ -471,6 +471,11 @@ public class XMLTypeCreator extends AbstractTypeCreator {
         if (flat != null) {
             info.setFlat(Boolean.valueOf(flat.toLowerCase()).booleanValue());
         }
+        
+        String nillable = DOMUtils.getAttributeValueEmptyNull(parameter, "nillable");
+        if (nillable != null) {
+            info.setNillable(Boolean.valueOf(nillable.toLowerCase()).booleanValue());
+        }
     }
 
     @Override
diff --git a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/java5/Java5TypeCreator.java b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/java5/Java5TypeCreator.java
index 3896d59dbc..855cab9e25 100644
--- a/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/java5/Java5TypeCreator.java
+++ b/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/java5/Java5TypeCreator.java
@@ -29,6 +29,7 @@ import javax.xml.namespace.QName;
 
 import org.apache.cxf.aegis.type.AbstractTypeCreator;
 import org.apache.cxf.aegis.type.Type;
+import org.apache.cxf.aegis.type.TypeClassInfo;
 import org.apache.cxf.aegis.type.basic.BeanType;
 import org.apache.cxf.aegis.util.NamespaceHelper;
 import org.apache.cxf.aegis.util.ServiceUtils;
diff --git a/rt/databinding/aegis/src/test/java/org/apache/cxf/aegis/services/NillableService.aegis.xml b/rt/databinding/aegis/src/test/java/org/apache/cxf/aegis/services/NillableService.aegis.xml
new file mode 100644
index 0000000000..35a7ac8d26
--- /dev/null
+++ b/rt/databinding/aegis/src/test/java/org/apache/cxf/aegis/services/NillableService.aegis.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+ 
+  http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+<mappings>
+    <mapping name="NillableService">
+        <method name="submitStringArray">
+            <parameter index="0" minOccurs='2' maxOccurs='50' nillable='false' />
+        </method>
+         <method name="takeNotNillableString">
+            <parameter index="0" minOccurs="1" nillable='false' />
+        </method>
+    </mapping>
+</mappings>
diff --git a/rt/databinding/aegis/src/test/java/org/apache/cxf/aegis/services/NillableService.java b/rt/databinding/aegis/src/test/java/org/apache/cxf/aegis/services/NillableService.java
new file mode 100644
index 0000000000..74842b8735
--- /dev/null
+++ b/rt/databinding/aegis/src/test/java/org/apache/cxf/aegis/services/NillableService.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.aegis.services;
+
+/**
+ * A minimal service for testing nillable annotations in Aegis XML.
+ */
+public class NillableService {
+    
+    public NillableService() {
+    }
+    
+    public boolean submitStringArray(String[] array) {
+        return true;
+    }
+    
+    public void takeNotNillableString(String string) {
+    }
+}
diff --git a/rt/databinding/aegis/src/test/java/org/apache/cxf/aegis/xmlconfig/NillableTest.java b/rt/databinding/aegis/src/test/java/org/apache/cxf/aegis/xmlconfig/NillableTest.java
new file mode 100644
index 0000000000..9b079a5c76
--- /dev/null
+++ b/rt/databinding/aegis/src/test/java/org/apache/cxf/aegis/xmlconfig/NillableTest.java
@@ -0,0 +1,66 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.aegis.xmlconfig;
+
+import javax.xml.namespace.QName;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import org.apache.cxf.aegis.AbstractAegisTest;
+import org.apache.cxf.aegis.services.NillableService;
+
+import org.junit.Before;
+import org.junit.Test;
+
+public class NillableTest extends AbstractAegisTest {
+
+    private Document arrayWsdlDoc;
+
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        createService(NillableService.class, new NillableService(), "Nillable", new QName("urn:nillable",
+                                                                                          "Nillable"));
+        arrayWsdlDoc = getWSDLDocument("Nillable");
+    }
+
+    @Test
+    public void testXmlConfigurationOfParameterTypeSchema() throws Exception {
+        NodeList typeList = assertValid(
+                                        "/wsdl:definitions/wsdl:types"
+                                            + "/xsd:schema[@targetNamespace='urn:nillable']"
+                                            + "/xsd:complexType[@name=\"submitStringArray\"]"
+                                            + "/xsd:sequence/xsd:element"
+                                            + "[@name='array']", arrayWsdlDoc);
+        Element typeElement = (Element)typeList.item(0);
+        String nillableValue = typeElement.getAttribute("nillable");
+        assertTrue(nillableValue == null || "".equals(nillableValue) || "false".equals("nillableValue"));
+
+        typeList = assertValid("/wsdl:definitions/wsdl:types"
+                               + "/xsd:schema[@targetNamespace='urn:nillable']"
+                               + "/xsd:complexType[@name=\"takeNotNillableString\"]"
+                               + "/xsd:sequence/xsd:element[@name='string']", arrayWsdlDoc);
+        typeElement = (Element)typeList.item(0);
+        nillableValue = typeElement.getAttribute("nillable");
+        assertTrue(nillableValue == null || "".equals(nillableValue) || "false".equals("nillableValue"));
+
+    }
+}
diff --git a/rt/frontend/simple/src/main/java/org/apache/cxf/service/factory/AbstractServiceConfiguration.java b/rt/frontend/simple/src/main/java/org/apache/cxf/service/factory/AbstractServiceConfiguration.java
index f6949e1ff8..6bb7fdc2f8 100644
--- a/rt/frontend/simple/src/main/java/org/apache/cxf/service/factory/AbstractServiceConfiguration.java
+++ b/rt/frontend/simple/src/main/java/org/apache/cxf/service/factory/AbstractServiceConfiguration.java
@@ -189,17 +189,34 @@ public abstract class AbstractServiceConfiguration {
         return null;
     }
     
+    /**
+     * If Aegis is at work, the XML can render a wrapper part non-nillable.
+     * @param mpi part
+     * @return nillability
+     */
     public Boolean isWrapperPartNillable(MessagePartInfo mpi) {
-        return null;
+        return (Boolean)mpi.getProperty("nillable");
     }
+    
     public Boolean isWrapperPartQualified(MessagePartInfo mpi) {
         return null;
     }
     public Long getWrapperPartMaxOccurs(MessagePartInfo mpi) {
-        //return Long.MAX_VALUE for unbounded
+        String miString = (String)mpi.getProperty("maxOccurs");
+        if (miString != null) {
+            if ("unbounded".equals(miString)) {
+                return Long.MAX_VALUE;
+            } else {
+                return Long.valueOf(miString, 10);
+            }
+        }
         return null;
     }
     public Long getWrapperPartMinOccurs(MessagePartInfo mpi) {
+        String miString = (String)mpi.getProperty("minOccurs");
+        if (miString != null) {
+            return Long.valueOf(miString, 10);
+        }
         return null;
     }
 }
