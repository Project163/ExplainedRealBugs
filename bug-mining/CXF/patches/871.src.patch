diff --git a/rt/core/src/main/java/org/apache/cxf/attachment/MimeBodyPartInputStream.java b/rt/core/src/main/java/org/apache/cxf/attachment/MimeBodyPartInputStream.java
index 6be717a7b7..f9eccbd54d 100644
--- a/rt/core/src/main/java/org/apache/cxf/attachment/MimeBodyPartInputStream.java
+++ b/rt/core/src/main/java/org/apache/cxf/attachment/MimeBodyPartInputStream.java
@@ -178,7 +178,7 @@ public class MimeBodyPartInputStream extends InputStream {
                 //boundary matched (may or may not be last mime boundary)
                 int processed = initialI - off;
                 if ((len - (i + 2)) > 0) {
-                    inStream.unread(buffer, i + 2, len - (i + 2));
+                    inStream.unread(buffer, i + 2, len - (i + 2) + off);
                 }
                 return processed;
             }
diff --git a/rt/core/src/test/java/org/apache/cxf/attachment/AttachmentDeserializerTest.java b/rt/core/src/test/java/org/apache/cxf/attachment/AttachmentDeserializerTest.java
index c76a582374..1dc060c41a 100644
--- a/rt/core/src/test/java/org/apache/cxf/attachment/AttachmentDeserializerTest.java
+++ b/rt/core/src/test/java/org/apache/cxf/attachment/AttachmentDeserializerTest.java
@@ -29,6 +29,7 @@ import java.util.Iterator;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import javax.activation.DataSource;
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
 
@@ -456,5 +457,42 @@ public class AttachmentDeserializerTest extends Assert {
         }
         return bout.toString();
     }
+    
+    @Test
+    public void testCXF3383() throws Exception {
+        String contentType = "multipart/related; type=\"application/xop+xml\";"
+            + " boundary=\"uuid:7a555f51-c9bb-4bd4-9929-706899e2f793\"; start=" 
+            + "\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\"";
+        
+        Message message = new MessageImpl();
+        message.put(Message.CONTENT_TYPE, contentType);
+        message.setContent(InputStream.class, getClass().getResourceAsStream("cxf3383.data"));
+        message.put(AttachmentDeserializer.ATTACHMENT_DIRECTORY, System
+                .getProperty("java.io.tmpdir"));
+        message.put(AttachmentDeserializer.ATTACHMENT_MEMORY_THRESHOLD, String
+                .valueOf(AttachmentDeserializer.THRESHOLD));
+
+
+        AttachmentDeserializer ad 
+            = new AttachmentDeserializer(message, 
+                                         Collections.singletonList("multipart/related"));
+        
+        ad.initializeAttachments();
+        
+        
+        for (int x = 1; x < 50; x++) {
+            String cid = "1882f79d-e20a-4b36-a222-7a75518cf395-" + x + "@cxf.apache.org";
+            DataSource ds = AttachmentUtil.getAttachmentDataSource(cid, message.getAttachments());
+            byte bts[] = new byte[1024];
+            
+            InputStream ins = ds.getInputStream();
+            int count = ins.read(bts, 0, bts.length);
+            int sz = ins.read(bts, count, bts.length - count);
+            while (sz != -1) {
+                sz = ins.read(bts, count, bts.length - count);
+            }
+            assertEquals(x + 1, count);
+        }
+    }
 
 }
\ No newline at end of file
diff --git a/rt/core/src/test/java/org/apache/cxf/attachment/cxf3383.data b/rt/core/src/test/java/org/apache/cxf/attachment/cxf3383.data
new file mode 100644
index 0000000000..5bd3d9c88c
Binary files /dev/null and b/rt/core/src/test/java/org/apache/cxf/attachment/cxf3383.data differ
diff --git a/systests/databinding/src/test/java/org/apache/cxf/systest/jaxb/HashMapAdapter.java b/systests/databinding/src/test/java/org/apache/cxf/systest/jaxb/HashMapAdapter.java
new file mode 100644
index 0000000000..0d48ef37b6
--- /dev/null
+++ b/systests/databinding/src/test/java/org/apache/cxf/systest/jaxb/HashMapAdapter.java
@@ -0,0 +1,103 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.jaxb;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.XmlValue;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+
+/**
+ * 
+ */
+public class HashMapAdapter extends XmlAdapter<HashMapAdapter.HashMapType, Map<String, byte[]>> {
+    
+    @XmlType()
+    @XmlAccessorType(XmlAccessType.FIELD)
+    public static class HashMapEntryType {
+        @XmlAttribute
+        private String key;
+        @XmlValue
+        private byte[] value;
+
+        public String getKey() {
+            return key;
+        }
+
+        public void setKey(String key) {
+            this.key = key;
+        }
+
+        public byte[] getValue() {
+            return value;
+        }
+
+        public void setValue(byte[] value) {
+            this.value = value;
+        }
+    }
+
+    public static class HashMapType {
+        private List<HashMapEntryType> entry = new ArrayList<HashMapEntryType>();
+
+        public List<HashMapEntryType> getEntry() {
+            return entry;
+        }
+
+        public void setEntry(List<HashMapEntryType> entry) {
+            this.entry = entry;
+        }
+    }
+    
+    public HashMapType marshal(Map<String, byte[]> arg0) throws Exception {
+        HashMapType myHashMapType = new HashMapType();
+        if (arg0 != null && arg0.size() > 0) {
+            for (Map.Entry<String, byte[]> entry : arg0.entrySet()) {
+                if (entry != null) {
+                    HashMapEntryType myHashEntryType = new HashMapEntryType();
+                    myHashEntryType.key = entry.getKey();
+                    myHashEntryType.value = entry.getValue();
+                    myHashMapType.entry.add(myHashEntryType);
+                }
+            }
+        }
+        return myHashMapType;
+    }
+
+    public Map<String, byte[]> unmarshal(HashMapType arg0) throws Exception {
+        Map<String, byte[]> hashMap = new HashMap<String, byte[]>();
+        if (arg0 != null && arg0.entry != null) {
+            for (HashMapEntryType myHashEntryType : arg0.entry) {
+                if (myHashEntryType.key != null) {
+                    hashMap.put(myHashEntryType.key, myHashEntryType.value);
+                }
+            }
+        }
+        return hashMap;
+    }
+
+}
diff --git a/systests/databinding/src/test/java/org/apache/cxf/systest/jaxb/MTOMTest.java b/systests/databinding/src/test/java/org/apache/cxf/systest/jaxb/MTOMTest.java
new file mode 100644
index 0000000000..75ad6e4703
--- /dev/null
+++ b/systests/databinding/src/test/java/org/apache/cxf/systest/jaxb/MTOMTest.java
@@ -0,0 +1,141 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.jaxb;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import javax.jws.WebService;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+import javax.xml.namespace.QName;
+import javax.xml.ws.Endpoint;
+import javax.xml.ws.Service;
+import javax.xml.ws.soap.MTOM;
+import javax.xml.ws.soap.SOAPBinding;
+
+import org.apache.cxf.annotations.Logging;
+import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
+import org.apache.cxf.testutil.common.AbstractBusTestServerBase;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ * 
+ */
+public class MTOMTest extends AbstractBusClientServerTestBase {
+    static final String PORT = allocatePort(MTOMTest.class);
+    static final String ADDRESS = "http://localhost:" + PORT + "/MTOM";
+
+    public static class ObjectWithHashMapData {
+        private String name;
+        private Map<String, byte[]> keyData = new LinkedHashMap<String, byte[]>();
+
+        public ObjectWithHashMapData() {
+        }
+        
+        @XmlJavaTypeAdapter(HashMapAdapter.class)
+        public Map<String, byte[]> getKeyData() {
+            return keyData;
+        }
+        
+        public void setKeyData(Map<String, byte[]> d) {
+            keyData = d;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+    }
+    
+    @Logging
+    @WebService
+    @MTOM(threshold = 1)
+    public static interface MTOMService {
+        ObjectWithHashMapData getHashMapData(int y);
+    }
+    @WebService
+    public static class MTOMServer implements MTOMService {
+        public ObjectWithHashMapData getHashMapData(int y) {
+            ObjectWithHashMapData ret = new ObjectWithHashMapData();
+            ret.setName("Test");
+            for (int x = 1; x < y; x++) {
+                ret.getKeyData().put(Integer.toHexString(x), generateByteData(x));
+            }
+            return ret;
+        }
+
+        private byte[] generateByteData(int x) {
+            byte bytes[] = new byte[x];
+            for (int y = 0; y < x; y++) {
+                int z = 'A' + y;
+                if (z > 'z') {
+                    z -= 'A';
+                }
+                bytes[y] = (byte)z;
+            }
+            return bytes;
+        }        
+    }
+    public static class Server extends AbstractBusTestServerBase {        
+
+        protected void run() {
+            Endpoint.publish(ADDRESS, new MTOMServer());
+        }
+        public static void main(String[] args) {
+            try {
+                Server s = new Server();
+                s.start();
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                System.exit(-1);
+            } finally {
+                System.out.println("done!");
+            }
+        }
+    }
+    @BeforeClass
+    public static void startServers() throws Exception {
+        assertTrue("server did not launch correctly", launchServer(Server.class, true));
+    }
+    
+    @Test
+    public void testMTOMInHashMap() throws Exception {
+        Service service = Service.create(new QName("http://foo", "bar"));
+        service.addPort(new QName("http://foo", "bar"), SOAPBinding.SOAP11HTTP_BINDING, 
+                        ADDRESS);
+        MTOMService port = service.getPort(new QName("http://foo", "bar"),
+                                           MTOMService.class);
+        
+        final int count = 99;
+        ObjectWithHashMapData data = port.getHashMapData(count);
+        for (int y = 1;  y < count; y++) {
+            byte bytes[] = data.getKeyData().get(Integer.toHexString(y));
+            if (bytes.length != y) {
+                System.out.println(new String(bytes));
+            }
+            assertEquals(y, bytes.length);
+        }
+    }
+}
