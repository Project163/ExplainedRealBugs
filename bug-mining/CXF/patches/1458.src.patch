diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/Messages.properties b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/Messages.properties
index 874fe0b36f..82661b5735 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/Messages.properties
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/Messages.properties
@@ -37,6 +37,7 @@ INVALID_ACK_EXC = The SequenceAcknowledgement violates the cumulative acknowledg
 MESSAGE_NR_ROLLOVER_EXC = The maximum value for wsrm:MessageNumber has been exceeded.
 SEQUENCE_CLOSED_EXC = The Sequence has been closed.
 WSRM_REQUIRED_EXC = WS-ReliableMessaging is required by this endpoint.
+WSA_REQUIRED_EXC = WS-Addressing is required by this endpoint.
 UNSUPPORTED_NAMESPACE = WS-Addressing namespace {0} is not supported with WS-ReliableMessaging namespace {1}.
 CREATE_SEQ_REFUSED = The create sequence request has been refused by the RM destination.
 CREATE_SEQ_ANON_TARGET = It is not possible to send a create sequence request to the anonymous address {0}
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMInInterceptor.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMInInterceptor.java
index ebdb620be7..eb5bc847f0 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMInInterceptor.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMInInterceptor.java
@@ -61,13 +61,23 @@ public class RMInInterceptor extends AbstractRMInterceptor<Message> {
     protected void handle(Message message) throws SequenceFault, RMException {
         LOG.entering(getClass().getName(), "handleMessage");
         
+        boolean isServer = RMContextUtils.isServerSide(message);
+        LOG.fine("isServerSide: " + isServer);
+
         RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);
         
         // message addressing properties may be null, e.g. in case of a runtime fault 
         // on the server side
         final AddressingProperties maps = ContextUtils.retrieveMAPs(message, false, false, false);
         if (null == maps) {
-            return;
+            if (isServer) {
+                org.apache.cxf.common.i18n.Message msg = new org.apache.cxf.common.i18n.Message(
+                    "WSA_REQUIRED_EXC", LOG);
+                LOG.log(Level.INFO, msg.toString());
+                throw new RMException(msg);                
+            } else {
+                return;
+            }
         }
 
         String action = null;
@@ -85,18 +95,23 @@ public class RMInInterceptor extends AbstractRMInterceptor<Message> {
             message.put(Message.REQUESTOR_ROLE, originalRequestor);
         }
 
-        String rmUri = getManager().getRMNamespace(message);
-        String addrUri = getManager().getAddressingNamespace(message);
+        // get the wsa and wsrm namespaces from the message 
+        String rmUri = rmps.getNamespaceURI();
+        String addrUri = maps.getNamespaceURI();
 
         ProtocolVariation protocol = ProtocolVariation.findVariant(rmUri, addrUri);
+        if (null == protocol) {
+            org.apache.cxf.common.i18n.Message msg = new org.apache.cxf.common.i18n.Message(
+                "WSRM_REQUIRED_EXC", LOG, rmUri, addrUri);
+            LOG.log(Level.INFO, msg.toString());
+            throw new RMException(msg);
+        }
         RMContextUtils.setProtocolVariation(message, protocol);
         
         // Destination destination = getManager().getDestination(message);
         // RMEndpoint rme = getManager().getReliableEndpoint(message);
         // Servant servant = new Servant(rme);
         
-        boolean isServer = RMContextUtils.isServerSide(message);
-        LOG.fine("isServerSide: " + isServer);
         boolean isApplicationMessage = !RMContextUtils.isRMProtocolMessage(action);
         LOG.fine("isApplicationMessage: " + isApplicationMessage);
         
@@ -172,7 +187,7 @@ public class RMInInterceptor extends AbstractRMInterceptor<Message> {
         if (robust) {
             // set this property to change the acknlowledging behavior
             message.put(RMMessageConstants.DELIVERING_ROBUST_ONEWAY, Boolean.TRUE);
-        } 
+        }
         destination.acknowledge(message);
     }
     
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMInInterceptorTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMInInterceptorTest.java
index 4284eb208d..3883ad89b0 100644
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMInInterceptorTest.java
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMInInterceptorTest.java
@@ -293,6 +293,7 @@ public class RMInInterceptorTest extends Assert {
         
         EasyMock.expect(message.get(Message.REQUESTOR_ROLE)).andReturn(!serverSide);
         AddressingPropertiesImpl maps = control.createMock(AddressingPropertiesImpl.class);
+        EasyMock.expect(maps.getNamespaceURI()).andReturn(Names200408.WSA_NAMESPACE_NAME).anyTimes();
         EasyMock.expect(message.get(JAXWSAConstants.SERVER_ADDRESSING_PROPERTIES_INBOUND)).andReturn(maps);
         
         AttributedURIType actionURI = control.createMock(AttributedURIType.class);
@@ -308,12 +309,15 @@ public class RMInInterceptorTest extends Assert {
         
         manager = control.createMock(RMManager.class);
         EasyMock.expect(manager.getRMNamespace(EasyMock.same(message)))
-            .andReturn(RM10Constants.NAMESPACE_URI);
+            .andReturn(RM10Constants.NAMESPACE_URI).anyTimes();
         EasyMock.expect(manager.getAddressingNamespace(EasyMock.same(message)))
-            .andReturn(Names200408.WSA_NAMESPACE_NAME);
+            .andReturn(Names200408.WSA_NAMESPACE_NAME).anyTimes();
         interceptor.setManager(manager);
         rme = control.createMock(RMEndpoint.class);
         EasyMock.expect(manager.getReliableEndpoint(message)).andReturn(rme);
+        
+        EasyMock.expect(rmps.getNamespaceURI()).andReturn(RM10Constants.NAMESPACE_URI).anyTimes();
+        
         return message;
     }
 }
\ No newline at end of file
diff --git a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/ProtocolVariationsTest.java b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/ProtocolVariationsTest.java
index 97f358edac..f7968debe0 100644
--- a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/ProtocolVariationsTest.java
+++ b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/ProtocolVariationsTest.java
@@ -19,6 +19,8 @@
 
 package org.apache.cxf.systest.ws.rm;
 
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.logging.Logger;
 
@@ -28,6 +30,7 @@ import javax.xml.ws.Endpoint;
 
 import org.apache.cxf.Bus;
 import org.apache.cxf.BusFactory;
+import org.apache.cxf.binding.soap.SoapFault;
 import org.apache.cxf.bus.spring.SpringBusFactory;
 import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.endpoint.Client;
@@ -36,6 +39,7 @@ import org.apache.cxf.greeter_control.Control;
 import org.apache.cxf.greeter_control.ControlService;
 import org.apache.cxf.greeter_control.Greeter;
 import org.apache.cxf.greeter_control.GreeterService;
+import org.apache.cxf.interceptor.transform.TransformOutInterceptor;
 import org.apache.cxf.jaxws.DispatchImpl;
 import org.apache.cxf.systest.ws.util.ConnectionHelper;
 import org.apache.cxf.systest.ws.util.MessageFlow;
@@ -192,18 +196,105 @@ public class ProtocolVariationsTest extends AbstractBusClientServerTestBase {
 
         try {
             greeter.greetMe("one");
-            fail("invalid namespace combination");
+            fail("invalid namespace combination accepted");
         } catch (Exception e) {
             assertTrue(e.getCause() instanceof RMException);
             // verify a partial error text match to exclude an unexpected exception
             // (see UNSUPPORTED_NAMESPACE in Messages.properties)
             final String text = Names200408.WSA_NAMESPACE_NAME + " is not supported";
             assertTrue(e.getCause().getMessage() != null 
-                       && e.getCause().getMessage().indexOf(text) > 0);
+                       && e.getCause().getMessage().indexOf(text) >= 0);
         }
         
     }
     
+    @Test
+    public void testInvalidRM11WSA200408OnReceive() throws Exception {
+        init("org/apache/cxf/systest/ws/rm/rminterceptors.xml", false);
+        
+        // WS-RM 1.0 using the WS-A 1.0 namespace
+        Client client = ClientProxy.getClient(greeter);
+        client.getRequestContext().put(RMManager.WSRM_VERSION_PROPERTY, RM10Constants.NAMESPACE_URI);
+        client.getRequestContext().put(RMManager.WSRM_WSA_VERSION_PROPERTY, Names200408.WSA_NAMESPACE_NAME);
+
+        // rewrite the outgoing message's WS-RM namespace to 1.1
+        TransformOutInterceptor trans = new TransformOutInterceptor();
+        Map<String, String> outElements = new HashMap<String, String>();
+        outElements.put("{" + RM10Constants.NAMESPACE_URI + "}*", "{" + RM11Constants.NAMESPACE_URI + "}*");
+        trans.setOutTransformElements(outElements);
+        
+        client.getOutInterceptors().add(trans);
+        try {
+            greeter.greetMe("one");
+            fail("invalid namespace combination accepted");
+        } catch (Exception e) {
+            assertTrue(e.getCause() instanceof SoapFault);
+            // verify a partial error text match to exclude an unexpected exception
+            // (see WSRM_REQUIRED_EXC in Messages.properties)
+            final String text = "WS-ReliableMessaging is required";
+            assertTrue(e.getCause().getMessage() != null 
+                       && e.getCause().getMessage().indexOf(text) >= 0);
+        }
+    }
+    
+    @Test
+    public void testInvalidWSAOnReceive() throws Exception {
+        init("org/apache/cxf/systest/ws/rm/rminterceptors.xml", false);
+        
+        // WS-RM 1.0 using the WS-A 1.0 namespace
+        Client client = ClientProxy.getClient(greeter);
+        client.getRequestContext().put(RMManager.WSRM_VERSION_PROPERTY, RM10Constants.NAMESPACE_URI);
+        client.getRequestContext().put(RMManager.WSRM_WSA_VERSION_PROPERTY, Names200408.WSA_NAMESPACE_NAME);
+
+        // rewrite the outgoing message's WS-A namespace to an invalid one
+        TransformOutInterceptor trans = new TransformOutInterceptor();
+        Map<String, String> outElements = new HashMap<String, String>();
+        outElements.put("{" + Names200408.WSA_NAMESPACE_NAME + "}*", "{http://cxf.apache.org/invalid}*");
+        trans.setOutTransformElements(outElements);
+        
+        client.getOutInterceptors().add(trans);
+        try {
+            greeter.greetMe("one");
+            fail("invalid wsa header accepted");
+        } catch (Exception e) {
+            assertTrue(e.getCause() instanceof SoapFault);
+            // verify a partial error text match to exclude an unexpected exception
+            // (see WSA_REQUIRED_EXC in Messages.properties)
+            final String text = "WS-Addressing is required";
+            assertTrue(e.getCause().getMessage() != null 
+                && e.getCause().getMessage().indexOf(text) >= 0);
+        }
+    }
+
+    @Test
+    public void testInvalidWRMOnReceive() throws Exception {
+        init("org/apache/cxf/systest/ws/rm/rminterceptors.xml", false);
+        
+        // WS-RM 1.0 using the WS-A 1.0 namespace
+        Client client = ClientProxy.getClient(greeter);
+        client.getRequestContext().put(RMManager.WSRM_VERSION_PROPERTY, RM10Constants.NAMESPACE_URI);
+        client.getRequestContext().put(RMManager.WSRM_WSA_VERSION_PROPERTY, Names200408.WSA_NAMESPACE_NAME);
+
+        // rewrite the outgoing message's WS-RM namespace to an invalid one
+        TransformOutInterceptor trans = new TransformOutInterceptor();
+        Map<String, String> outElements = new HashMap<String, String>();
+        outElements.put("{" + RM10Constants.NAMESPACE_URI + "}*", "{http://cxf.apache.org/invalid}*");
+        trans.setOutTransformElements(outElements);
+        
+        client.getOutInterceptors().add(trans);
+        try {
+            greeter.greetMe("one");
+            fail("invalid wsrm header");
+        } catch (Exception e) {
+            assertTrue(e.getCause() instanceof SoapFault);
+            // verify a partial error text match to exclude an unexpected exception
+            // (see WSRM_REQUIRED_EXC in Messages.properties)
+            final String text = "WS-ReliableMessaging is required";
+            assertTrue(e.getCause().getMessage() != null 
+                && e.getCause().getMessage().indexOf(text) >= 0);
+        }
+    }
+    
     @Test
     public void testDefaultDecoupled() throws Exception {
         init("org/apache/cxf/systest/ws/rm/rminterceptors.xml", true);
