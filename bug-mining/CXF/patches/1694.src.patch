diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriBuilderImpl.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriBuilderImpl.java
index c46cf9b22d..51c4f5ed68 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriBuilderImpl.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriBuilderImpl.java
@@ -88,7 +88,16 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
     }
     
     private URI doBuild(boolean fromEncoded, boolean encodePathSlash, Object... values) {
-        UriParts parts = doBuildUriParts(fromEncoded, encodePathSlash, values);
+        if (values == null) {
+            throw new IllegalArgumentException("Template parameter values are set to null");
+        }
+        for (int i = 0; i < values.length; i++) {
+            if (values[i] == null) {
+                throw new IllegalArgumentException("Template parameter value is set to null");
+            }
+        }
+        
+        UriParts parts = doBuildUriParts(fromEncoded, encodePathSlash, false, values);
         try {
             return buildURI(fromEncoded, parts.path, parts.query, parts.fragment);
         } catch (URISyntaxException ex) {
@@ -96,7 +105,8 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
         }
     }
     
-    private UriParts doBuildUriParts(boolean fromEncoded, boolean encodePathSlash, Object... values) {
+    private UriParts doBuildUriParts(boolean fromEncoded, boolean encodePathSlash, 
+                                     boolean allowUnresolved, Object... values) {
         
         Map<String, Object> alreadyResolvedTs = getResolvedTemplates(resolvedTemplates);
         Map<String, Object> alreadyResolvedTsPathEnc = getResolvedTemplates(resolvedTemplatesPathEnc);
@@ -105,37 +115,38 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
             + alreadyResolvedEncTs.size()
             + alreadyResolvedTsPathEnc.size();
         
-        String thePath = buildPath(fromEncoded);
+        String thePath = buildPath();
         URITemplate pathTempl = new URITemplate(thePath);
         thePath = substituteVarargs(pathTempl, alreadyResolvedTs, alreadyResolvedTsPathEnc, 
-                                    alreadyResolvedEncTs, values, 0, false, fromEncoded, encodePathSlash);
+                                    alreadyResolvedEncTs, values, 0, false, fromEncoded, 
+                                    allowUnresolved, encodePathSlash);
         int pathTemplateVarsSize = pathTempl.getVariables().size();
         
-        String theQuery = buildQuery(fromEncoded);
+        String theQuery = buildQuery();
         int queryTemplateVarsSize = 0;
         if (theQuery != null) {
             URITemplate queryTempl = new URITemplate(theQuery);
-            int lengthDiff = values.length + resolvedTsSize 
-                - alreadyResolvedTs.size() - alreadyResolvedTsPathEnc.size() - alreadyResolvedEncTs.size() 
-                - pathTemplateVarsSize; 
-            if (lengthDiff > 0) {
-                queryTemplateVarsSize = queryTempl.getVariables().size();
+            queryTemplateVarsSize = queryTempl.getVariables().size();
+            if (queryTemplateVarsSize > 0) {
+                int lengthDiff = values.length + resolvedTsSize 
+                    - alreadyResolvedTs.size() - alreadyResolvedTsPathEnc.size() - alreadyResolvedEncTs.size() 
+                    - pathTemplateVarsSize; 
                 theQuery = substituteVarargs(queryTempl, alreadyResolvedTs, alreadyResolvedTsPathEnc, 
                                              alreadyResolvedEncTs, values, values.length - lengthDiff, 
-                                             true, fromEncoded, false);
+                                             true, fromEncoded, allowUnresolved, false);
             }
         }
         
         String theFragment = fragment;
         if (theFragment != null) {
             URITemplate fragmentTempl = new URITemplate(theFragment);
-            int lengthDiff = values.length  + resolvedTsSize 
-                - alreadyResolvedTs.size() - alreadyResolvedTsPathEnc.size() - alreadyResolvedEncTs.size()
-                - pathTemplateVarsSize - queryTemplateVarsSize; 
-            if (lengthDiff > 0) {
+            if (fragmentTempl.getVariables().size() > 0) {
+                int lengthDiff = values.length  + resolvedTsSize 
+                    - alreadyResolvedTs.size() - alreadyResolvedTsPathEnc.size() - alreadyResolvedEncTs.size()
+                    - pathTemplateVarsSize - queryTemplateVarsSize; 
                 theFragment = substituteVarargs(fragmentTempl, alreadyResolvedTs, alreadyResolvedTsPathEnc, 
                                                 alreadyResolvedEncTs, values, values.length - lengthDiff, 
-                                                true, fromEncoded, false);
+                                                true, fromEncoded, allowUnresolved, false);
             }
         }
         
@@ -144,19 +155,17 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
     
     private URI buildURI(boolean fromEncoded, String thePath, String theQuery, String theFragment) 
         throws URISyntaxException {
-        if (fromEncoded) {
+        if (fromEncoded) { 
             return buildURIFromEncoded(thePath, theQuery, theFragment);
         } else if (!isSchemeOpaque()) {
             if ((scheme != null || host != null || userInfo != null)
                 && thePath.length() != 0 && !thePath.startsWith("/")) {
                 thePath = "/" + thePath;
             }
-            if (theQuery != null && HttpUtils.isPartiallyEncoded(theQuery)) {
-                try {
-                    return buildURIFromEncoded(thePath, theQuery, theFragment);
-                } catch (Exception ex) {
-                    // lets try the option below
-                }
+            try {
+                return buildURIFromEncoded(thePath, theQuery, theFragment);
+            } catch (Exception ex) {
+                // lets try the option below
             }
             URI uri = new URI(scheme, userInfo, host, port, 
                            thePath, theQuery, theFragment);
@@ -216,22 +225,6 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
     
     @Override
     public URI buildFromEncoded(Object... values) throws IllegalArgumentException, UriBuilderException {
-        // Problem: multi-arg URI c-tor always forces encoding, operation contract would be broken;
-        // use os single-arg URI c-tor requires unnecessary concatenate-parse roundtrip.
-        // While decoding back given values and passing as non-decoded to regular build() method
-        // is promising unfortunatley it causes the loss of encoded reserved values such as +,
-        // which might cause problems if consumers do rely on URLEncoder which would turn '+' into
-        // ' ' or would break the contract in when query parameters are expected to have %2B 
-        if (values == null) {
-            throw new IllegalArgumentException("Template parameter values are set to null");
-        }
-        for (int i = 0; i < values.length; i++) {
-            if (values[i] == null) {
-                throw new IllegalArgumentException("Template parameter value is set to null");
-            }
-            
-            values[i] = HttpUtils.encodePartiallyEncoded(values[i].toString(), false);
-        }
         return doBuild(true, false, values);
     }
 
@@ -249,11 +242,11 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
             Map<String, Object> alreadyResolvedTsPathEnc = getResolvedTemplates(resolvedTemplatesPathEnc);
             Map<String, Object> alreadyResolvedEncTs = getResolvedTemplates(resolvedEncodedTemplates);
                         
-            String thePath = buildPath(fromEncoded);
+            String thePath = buildPath();
             thePath = substituteMapped(thePath, map, alreadyResolvedTs, alreadyResolvedTsPathEnc, 
                                        alreadyResolvedEncTs, false, fromEncoded, encodePathSlash);
             
-            String theQuery = buildQuery(fromEncoded);
+            String theQuery = buildQuery();
             if (theQuery != null) {
                 theQuery = substituteMapped(theQuery, map, alreadyResolvedTs, alreadyResolvedTsPathEnc, 
                                             alreadyResolvedEncTs, true, fromEncoded, false);
@@ -277,13 +270,15 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
                                      int ind,
                                      boolean isQuery,
                                      boolean fromEncoded,
+                                     boolean allowUnresolved,
                                      boolean encodePathSlash) {
+        
    //CHECKSTYLE:ON     
         Map<String, String> varValueMap = new HashMap<String, String>();
         
         // vars in set are properly ordered due to linking in hash set
         Set<String> uniqueVars = new LinkedHashSet<String>(templ.getVariables());
-        if (values.length + alreadyResolvedTs.size() + alreadyResolvedTsEnc.size()
+        if (!allowUnresolved && values.length + alreadyResolvedTs.size() + alreadyResolvedTsEnc.size()
             + alreadyResolvedTsPathEnc.size() < uniqueVars.size()) {
             throw new IllegalArgumentException("Unresolved variables; only " + values.length
                                                + " value(s) given for " + uniqueVars.size()
@@ -301,21 +296,30 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
                 : isPathEncVar ? alreadyResolvedTsPathEnc : alreadyResolvedTs;
             Object oval = resolved.isEmpty() ? null : resolved.remove(var);
             if (oval == null) {
+                if (allowUnresolved) {
+                    continue;
+                }
                 oval = values[idx++];
-            } else if (fromEncoded) {
-                oval = HttpUtils.encodePartiallyEncoded(oval.toString(), isQuery);
-            }
+            } 
+            
             if (oval == null) {
                 throw new IllegalArgumentException("No object for " + var);
             }
             String value = oval.toString();
+            if (fromEncoded) {
+                value = HttpUtils.encodePartiallyEncoded(value, isQuery);
+            } else {
+                value = isQuery ? HttpUtils.queryEncode(value) : HttpUtils.pathEncode(value);
+            }
+            
             varValueMap.put(var, value);
             
             if (!isQuery && (isPathEncVar || encodePathSlash)) {
                 pathEncodeVars.add(var);
             }
+            
         }
-        return templ.substitute(varValueMap, pathEncodeVars);
+        return templ.substitute(varValueMap, pathEncodeVars, allowUnresolved);
     }
     
     //CHECKSTYLE:OFF
@@ -351,18 +355,21 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
             Object oval = resolved.isEmpty() ? null : resolved.remove(var);
             if (oval == null) {
                 oval = varValueMap.get(var);
-            } else if (fromEncoded) {
-                oval = HttpUtils.encodePartiallyEncoded(oval.toString(), isQuery);
-            }
+            }  
             if (oval == null) {
                 throw new IllegalArgumentException("No object for " + var);
             }
+            if (fromEncoded) {
+                oval = HttpUtils.encodePartiallyEncoded(oval.toString(), isQuery);
+            } else {
+                oval = isQuery ? HttpUtils.queryEncode(oval.toString()) : HttpUtils.pathEncode(oval.toString());
+            }
             theMap.put(var, oval);
             if (!isQuery && (isPathEncVar || encodePathSlash)) {
                 pathEncodeVars.add(var);
             }
         }
-        return templ.substitute(theMap, pathEncodeVars);
+        return templ.substitute(theMap, pathEncodeVars, false);
     }
 
     @Override
@@ -609,14 +616,14 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
         }
     }
     
-    private String buildPath(boolean fromEncoded) {
+    private String buildPath() {
         StringBuilder sb = new StringBuilder();
         Iterator<PathSegment> iter = paths.iterator();
         while (iter.hasNext()) {
             PathSegment ps = iter.next();
             String p = ps.getPath();
             if (p.length() != 0 || !iter.hasNext()) {
-                p = fromEncoded ? new URITemplate(p).encodeLiteralCharacters() : p;
+                p = new URITemplate(p).encodeLiteralCharacters(false);
                 if (sb.length() == 0 && leadingSlash) {
                     sb.append('/');
                 } else if (!p.startsWith("/") && sb.length() > 0) {
@@ -624,16 +631,16 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
                 }
                 sb.append(p);
                 if (iter.hasNext()) {
-                    buildMatrix(sb, ps.getMatrixParameters(), fromEncoded);
+                    buildMatrix(sb, ps.getMatrixParameters());
                 }
             }
         }
-        buildMatrix(sb, matrix, fromEncoded);
+        buildMatrix(sb, matrix);
         return sb.toString();
     }
 
-    private String buildQuery(boolean fromEncoded) {
-        return buildParams(query, '&', fromEncoded);
+    private String buildQuery() {
+        return buildParams(query, '&');
     }
 
     @Override
@@ -783,16 +790,18 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
      * @param fromEncoded if true then values will be decoded 
      * @return stringified params.
      */
-    private String buildParams(MultivaluedMap<String, String> map, char separator,
-                                      boolean fromEncoded) {
+    private String buildParams(MultivaluedMap<String, String> map, char separator) {
         boolean isQuery = separator == '&';
         StringBuilder b = new StringBuilder();
         for (Iterator<Map.Entry<String, List<String>>> it = map.entrySet().iterator(); it.hasNext();) {
             Map.Entry<String, List<String>> entry = it.next();
             for (Iterator<String> sit = entry.getValue().iterator(); sit.hasNext();) {
                 String val = sit.next();
-                if (fromEncoded  || (isQuery && !val.startsWith("{") && !val.endsWith("}"))) { 
+                boolean templateValue = val.startsWith("{") && val.endsWith("}");
+                if (!templateValue) { 
                     val = HttpUtils.encodePartiallyEncoded(val, isQuery);
+                } else {
+                    val = new URITemplate(val).encodeLiteralCharacters(isQuery);
                 }
                 b.append(entry.getKey());
                 if (val.length() != 0) {
@@ -812,18 +821,17 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
      * @param sb buffer to add the matrix part to, will get ';' added if map is not empty 
      * @param map matrix multivalued map
      */    
-    private void buildMatrix(StringBuilder sb, MultivaluedMap<String, String> map,
-                                    boolean fromEncoded) {
+    private void buildMatrix(StringBuilder sb, MultivaluedMap<String, String> map) {
         if (!map.isEmpty()) {
             sb.append(';');
-            sb.append(buildParams(map, ';', fromEncoded));
+            sb.append(buildParams(map, ';'));
         }
     }
     
     private PathSegment replacePathSegment(PathSegment ps) {
         StringBuilder sb = new StringBuilder();
         sb.append(ps.getPath());
-        buildMatrix(sb, matrix, false);
+        buildMatrix(sb, matrix);
         return new PathSegmentImpl(sb.toString());
     }
 
@@ -857,7 +865,7 @@ public class UriBuilderImpl extends UriBuilder implements Cloneable {
 
     @Override
     public String toTemplate() {
-        UriParts parts = doBuildUriParts(false, false);
+        UriParts parts = doBuildUriParts(false, false, true);
         return buildUriString(parts.path, parts.query, parts.fragment);
     }
     
diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriInfoImpl.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriInfoImpl.java
index a7eeb3f55a..fac9e2df29 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriInfoImpl.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriInfoImpl.java
@@ -190,7 +190,7 @@ public class UriInfoImpl implements UriInfo {
                 }
                 UriBuilder ub = UriBuilder.fromPath(sum.toString());
                 objects.addAll(invocation.getTemplateValues());
-                uris.add(0, ub.build(objects.toArray()).normalize().getPath());
+                uris.add(0, ub.build(objects.toArray()).normalize().getRawPath());
             }
             return uris;
         }
diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/model/URITemplate.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/model/URITemplate.java
index 989bc3b1bb..a31444f884 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/model/URITemplate.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/model/URITemplate.java
@@ -249,8 +249,8 @@ public final class URITemplate {
         return sb.toString();
     }
 
-    public String substitute(Map<String, ? extends Object> valuesMap) throws IllegalArgumentException {
-        return this.substitute(valuesMap, Collections.<String>emptySet());
+    String substitute(Map<String, ? extends Object> valuesMap) throws IllegalArgumentException {
+        return this.substitute(valuesMap, Collections.<String>emptySet(), false);
     }
     
     /**
@@ -266,7 +266,8 @@ public final class URITemplate {
      * @return template with bound variables.
      */
     public String substitute(Map<String, ? extends Object> valuesMap,
-                             Set<String> encodePathSlashVars) throws IllegalArgumentException {
+                             Set<String> encodePathSlashVars,
+                             boolean allowUnresolved) throws IllegalArgumentException {
         if (valuesMap == null) {
             throw new IllegalArgumentException("valuesMap is null");
         }
@@ -286,9 +287,11 @@ public final class URITemplate {
                         sval = sval.replaceAll("/", "%2F");
                     }
                     sb.append(sval);
+                } else if (allowUnresolved) {
+                    sb.append(chunk); 
                 } else {
                     throw new IllegalArgumentException("Template variable " + var.getName() 
-                        + " has no matching value"); 
+                                                       + " has no matching value"); 
                 }
             } else {
                 sb.append(chunk);
@@ -302,13 +305,13 @@ public final class URITemplate {
      * ex. "a {id} b" will be encoded to "a%20{id}%20b" 
      * @return encoded value
      */
-    public String encodeLiteralCharacters() {
+    public String encodeLiteralCharacters(boolean isQuery) {
         final float encodedRatio = 1.5f;
         StringBuilder sb = new StringBuilder((int)(encodedRatio * template.length()));
         for (UriChunk chunk : uriChunks) {
             String val = chunk.getValue();
             if (chunk instanceof Literal) {
-                sb.append(HttpUtils.encodePartiallyEncoded(val, false));
+                sb.append(HttpUtils.encodePartiallyEncoded(val, isQuery));
             } else { 
                 sb.append(val);
             }
diff --git a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/UriBuilderImplTest.java b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/UriBuilderImplTest.java
index f9221de050..a3233c9448 100644
--- a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/UriBuilderImplTest.java
+++ b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/UriBuilderImplTest.java
@@ -39,6 +39,76 @@ import org.junit.Test;
 
 public class UriBuilderImplTest extends Assert {
 
+    @Test
+    public void testBuildWithNonEncodedSubstitutionValue() {
+        URI uri;
+        uri = UriBuilder.fromPath("/{a}").build("{}");
+        assertEquals("/%7B%7D", uri.toString());        
+    }
+    
+    @Test
+    public void testBuildWithNonEncodedSubstitutionValue2() {
+        URI uri;
+        uri = UriBuilder.fromPath("/{a}").buildFromEncoded("{}");
+        assertEquals("/%7B%7D", uri.toString());        
+    }
+    
+    @Test
+    public void testBuildWithNonEncodedSubstitutionValue3() {
+        UriBuilder ub = UriBuilder.fromPath("/");
+        URI uri = ub.path("{a}").buildFromEncoded("%");
+        assertEquals("/%25", uri.toString());
+        uri = ub.path("{token}").buildFromEncoded("%", "{}");
+        assertEquals("/%25/%7B%7D", uri.toString());        
+    }
+    
+    @Test
+    public void testBuildWithNonEncodedSubstitutionValue4() {
+        UriBuilder ub = UriBuilder.fromPath("/");
+        URI uri = ub.path("{a}").build("%");
+        assertEquals("/%25", uri.toString());
+        uri = ub.path("{token}").build("%", "{}");
+        assertEquals("/%25/%7B%7D", uri.toString());        
+    }
+    
+    @Test
+    public void testBuildWithNonEncodedSubstitutionValue5() {
+        UriBuilder ub = UriBuilder.fromUri("/%25");
+        URI uri = ub.build();
+        assertEquals("/%25", uri.toString());
+        uri = ub.replacePath("/%/{token}").build("{}");
+        assertEquals("/%25/%7B%7D", uri.toString());        
+    }
+    
+    @Test
+    public void testBuildWithNonEncodedSubstitutionValue6() {
+        UriBuilder ub = UriBuilder.fromPath("/");
+        URI uri = ub.path("%").build();
+        assertEquals("/%25", uri.toString());
+        uri = ub.replacePath("/%/{token}").build("{}");
+        assertEquals("/%25/%7B%7D", uri.toString());        
+    }
+    
+    @Test
+    public void testBuildWithNonEncodedSubstitutionValue7() {
+        UriBuilder ub = UriBuilder.fromPath("/");
+        URI uri = ub.replaceQueryParam("a", "%").buildFromEncoded();
+        assertEquals("/?a=%25", uri.toString());
+        uri = ub.replaceQueryParam("a2", "{token}").buildFromEncoded("{}");
+        assertEquals("/?a=%25&a2=%7B%7D", uri.toString());
+    }
+    
+    @Test
+    public void testBuildWithNonEncodedSubstitutionValue8() {
+        UriBuilder ub = UriBuilder.fromPath("/");
+        URI uri = ub.replaceQueryParam("a", "%").build();
+        assertEquals("/?a=%25", uri.toString());
+        uri = ub.replaceQueryParam("a2", "{token}").build("{}");
+        assertEquals("/?a=%25&a2=%7B%7D", uri.toString());
+    }
+       
+    
+    
     @Test
     public void testResolveTemplate() {
         URI uri;
@@ -108,6 +178,11 @@ public class UriBuilderImplTest extends Assert {
         UriBuilder.fromPath("/index.jsp").queryParam("a", "{a}").queryParam("b", "{b}")
             .build("valueA");
     }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void testQueryParamWithMissingTemplateValues2() {
+        UriBuilder.fromPath("/index.jsp").queryParam("a", "{a}").build();
+    }
 
     @Test
     public void testPathAndQueryParamWithTemplateValues() {
@@ -1122,7 +1197,7 @@ public class UriBuilderImplTest extends Assert {
     
     @Test
     public void testNullScheme() {
-        String expected = "//localhost:8080";
+        String expected = "localhost:8080";
         URI uri = UriBuilder.fromUri("http://localhost:8080")
                             .scheme(null)
                             .build();
diff --git a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/model/URITemplateTest.java b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/model/URITemplateTest.java
index 9323b675eb..47bb62c648 100644
--- a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/model/URITemplateTest.java
+++ b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/model/URITemplateTest.java
@@ -698,13 +698,13 @@ public class URITemplateTest extends Assert {
     @Test
     public void testEncodeLiteralCharacters() {
         URITemplate ut = new URITemplate("a {id} b");
-        assertEquals("a%20{id}%20b", ut.encodeLiteralCharacters());
+        assertEquals("a%20{id}%20b", ut.encodeLiteralCharacters(false));
     }
 
     @Test
     public void testEncodeLiteralCharactersNotVariable() {
         URITemplate ut = new URITemplate("a {digit:[0-9]} b");
         //System.out.println(ut.encodeLiteralCharacters());
-        assertEquals("a%20{digit:[0-9]}%20b", ut.encodeLiteralCharacters());
+        assertEquals("a%20{digit:[0-9]}%20b", ut.encodeLiteralCharacters(false));
     }
 }
