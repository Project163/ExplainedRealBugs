diff --git a/api/src/main/java/org/apache/cxf/io/CachedOutputStream.java b/api/src/main/java/org/apache/cxf/io/CachedOutputStream.java
index 5ff716d430..116f2ef980 100644
--- a/api/src/main/java/org/apache/cxf/io/CachedOutputStream.java
+++ b/api/src/main/java/org/apache/cxf/io/CachedOutputStream.java
@@ -186,6 +186,10 @@ public class CachedOutputStream extends OutputStream {
      * @throws IOException
      */
     public void resetOut(OutputStream out, boolean copyOldContent) throws IOException {
+        if (out == null) {
+            out = new ByteArrayOutputStream();
+        }
+
         if (currentStream instanceof CachedOutputStream) {
             CachedOutputStream ac = (CachedOutputStream) currentStream;
             InputStream in = ac.getInputStream();
@@ -210,6 +214,7 @@ public class CachedOutputStream extends OutputStream {
                 if (copyOldContent) {
                     IOUtils.copyAndCloseInput(fin, out);
                 }
+                streamList.remove(currentStream);
                 tempFile.delete();
                 tempFile = null;
                 inmem = true;
diff --git a/rt/core/src/main/java/org/apache/cxf/interceptor/LoggingOutInterceptor.java b/rt/core/src/main/java/org/apache/cxf/interceptor/LoggingOutInterceptor.java
index 9d8a2df5f7..f6d8bc8a4c 100644
--- a/rt/core/src/main/java/org/apache/cxf/interceptor/LoggingOutInterceptor.java
+++ b/rt/core/src/main/java/org/apache/cxf/interceptor/LoggingOutInterceptor.java
@@ -74,16 +74,18 @@ public class LoggingOutInterceptor extends AbstractPhaseInterceptor {
             // Write the output while caching it for the log message
             final CacheAndWriteOutputStream newOut = new CacheAndWriteOutputStream(os);
             message.setContent(OutputStream.class, newOut);
-            newOut.registerCallback(new LoggingCallback(message));
+            newOut.registerCallback(new LoggingCallback(message, os));
         }
     }
 
     class LoggingCallback implements CachedOutputStreamCallback {
         
         private final Message message;
+        private final OutputStream origStream;
         
-        public LoggingCallback(final Message msg) {
+        public LoggingCallback(final Message msg, final OutputStream os) {
             this.message = msg;
+            this.origStream = os;
         }
 
         public void onFlush(CachedOutputStream cos) {  
@@ -128,6 +130,15 @@ public class LoggingOutInterceptor extends AbstractPhaseInterceptor {
             } else if (LOG.isLoggable(Level.INFO)) {
                 LOG.info(buffer.toString());
             }
+            try {
+                //empty out the cache
+                cos.lockOutputStream();
+                cos.resetOut(null, false);
+            } catch (Exception ex) {
+                //ignore
+            }
+            message.setContent(OutputStream.class, 
+                               origStream);
         }
     } 
 }
diff --git a/rt/core/src/main/java/org/apache/cxf/interceptor/StaxOutInterceptor.java b/rt/core/src/main/java/org/apache/cxf/interceptor/StaxOutInterceptor.java
index 907bd4ea05..eb4c280631 100644
--- a/rt/core/src/main/java/org/apache/cxf/interceptor/StaxOutInterceptor.java
+++ b/rt/core/src/main/java/org/apache/cxf/interceptor/StaxOutInterceptor.java
@@ -157,10 +157,12 @@ public class StaxOutInterceptor extends AbstractPhaseInterceptor<Message> {
                     xtw.writeEndDocument();
                     xtw.close();
                 }
+
                 OutputStream os = (OutputStream)message.get(OUTPUT_STREAM_HOLDER);
                 if (os != null) {
                     message.setContent(OutputStream.class, os);
                 }
+                message.removeContent(XMLStreamWriter.class);
             } catch (XMLStreamException e) {
                 throw new Fault(new org.apache.cxf.common.i18n.Message("STAX_WRITE_EXC", BUNDLE), e);
             }
diff --git a/rt/core/src/main/java/org/apache/cxf/io/CacheAndWriteOutputStream.java b/rt/core/src/main/java/org/apache/cxf/io/CacheAndWriteOutputStream.java
index c0935df3bb..3de57cd4da 100644
--- a/rt/core/src/main/java/org/apache/cxf/io/CacheAndWriteOutputStream.java
+++ b/rt/core/src/main/java/org/apache/cxf/io/CacheAndWriteOutputStream.java
@@ -47,6 +47,10 @@ public class CacheAndWriteOutputStream extends CachedOutputStream {
         flowThroughStream.close();
     }
     
+    public OutputStream getFlowThroughStream() {
+        return flowThroughStream;
+    }
+    
     
     @Override
     protected void onWrite() throws IOException {
diff --git a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java
index 44168bb8dc..0b57a50499 100644
--- a/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java
+++ b/rt/transports/http/src/main/java/org/apache/cxf/transport/http/HTTPConduit.java
@@ -1864,7 +1864,7 @@ public class HTTPConduit
             try {
                 handleResponse();
             } finally {
-                if (cachingForRetransmission) {
+                if (cachingForRetransmission && cachedStream != null) {
                     cachedStream.close();
                 }
             }
@@ -1974,6 +1974,14 @@ public class HTTPConduit
                     connection.getInputStream().close();
                     return;
                 }
+            } else {
+                //not going to be resending or anything, clear out the stuff in the out message
+                //to free memory
+                outMessage.removeContent(OutputStream.class);
+                if (cachingForRetransmission) {
+                    cachedStream.close();
+                }
+                cachedStream = null;
             }
             
             Message inMessage = new MessageImpl();
@@ -2026,6 +2034,7 @@ public class HTTPConduit
             }
             inMessage.setContent(InputStream.class, in);
             
+            
             incomingObserver.onMessage(inMessage);
         }
 
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
index 6fdf27e54a..7381621a17 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
@@ -63,6 +63,7 @@ import org.apache.cxf.ws.policy.AssertionInfoMap;
  * Properties for outgoing messages.
  */
 public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
+    public static final String USING_ADDRESSING = MAPAggregator.class.getName() + ".usingAddressing";
 
     private static final Logger LOG = 
         LogUtils.getL7dLogger(MAPAggregator.class);
@@ -77,11 +78,6 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
     protected final Map<String, String> messageIDs = 
         new ConcurrentHashMap<String, String>();
     
-    /**
-     * Whether the endpoint supports WS-Addressing.
-     */
-
-    private final Map<Endpoint, Boolean> usingAddressing = new ConcurrentHashMap<Endpoint, Boolean>();
     private boolean usingAddressingAdvisory = true;
     private boolean addressingRequired;
 
@@ -203,7 +199,7 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
         boolean ret = false;
         Endpoint endpoint = message.getExchange().get(Endpoint.class);
         if (null != endpoint) {
-            Boolean b = usingAddressing.get(endpoint);
+            Boolean b = (Boolean)endpoint.get(USING_ADDRESSING);
             if (null == b) {
                 EndpointInfo endpointInfo = endpoint.getEndpointInfo();
                 List<ExtensibilityElement> endpointExts = endpointInfo != null ? endpointInfo
@@ -217,7 +213,7 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
                 ret = hasUsingAddressing(endpointExts) || hasUsingAddressing(bindingExts)
                              || hasUsingAddressing(serviceExts);
                 b = ret ? Boolean.TRUE : Boolean.FALSE;
-                usingAddressing.put(endpoint, b);
+                endpoint.put(USING_ADDRESSING, b);
             } else {
                 ret = b.booleanValue();
             }
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
index 4e08ee529d..d8cac7e571 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
@@ -19,13 +19,12 @@
 
 package org.apache.cxf.ws.addressing.soap;
 
-import java.util.Collections;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
@@ -80,8 +79,8 @@ public class MAPCodec extends AbstractSoapInterceptor {
      * REVISIT: map usage that the *same* interceptor instance 
      * is used in all chains.
      */
-    protected final Map<String, Exchange> uncorrelatedExchanges =
-        Collections.synchronizedMap(new HashMap<String, Exchange>());
+    protected final Map<String, Exchange> uncorrelatedExchanges 
+        = new ConcurrentHashMap<String, Exchange>();
 
     private VersionTransformer transformer;
     private HeaderFactory headerFactory;
@@ -734,7 +733,18 @@ public class MAPCodec extends AbstractSoapInterceptor {
                 LOG.log(Level.WARNING, "CORRELATION_FAILURE_MSG");
                 message.getInterceptorChain().abort();
             }
+        } else if (maps == null && isRequestor(message)) {
+            Message m = message.getExchange().getOutMessage();
+            maps = ContextUtils.retrieveMAPs(m, false, true, false);
+            if (maps != null) {
+                Exchange ex = uncorrelatedExchanges.get(maps.getMessageID().getValue());
+                if (ex == message.getExchange()) {
+                    uncorrelatedExchanges.remove(maps.getMessageID().getValue());
+                    LOG.log(Level.WARNING, "RESPONSE_NOT_USING_WSADDRESSING");
+                }
+            }
         }
+        
     }
 
     /**
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/Messages.properties b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/Messages.properties
index 7d37849eb9..f25fdfd6a9 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/Messages.properties
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/Messages.properties
@@ -23,3 +23,4 @@ SOAP_HEADER_DECODE_FAILURE_MSG = WS-Addressing - decoding Message Addressing Pro
 UNSUPPORTED_VERSION_MSG = Unsupported WS-Addressing version {0}
 IGNORE_NON_ELEMENT_REF_PARAM_MSG = Ignoring reference parameter {0} because it is not a JAXBElement
 CORRELATION_FAILURE_MSG = Failed to correlate message, aborting dispatch.
+RESPONSE_NOT_USING_WSADDRESSING = Response message does not contain WS-Addressing properties.  Not correlating response.
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/WrappedEndpoint.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/WrappedEndpoint.java
index b77b9a6443..f73715b506 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/WrappedEndpoint.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/WrappedEndpoint.java
@@ -32,12 +32,14 @@ import org.apache.cxf.interceptor.Interceptor;
 import org.apache.cxf.service.Service;
 import org.apache.cxf.service.model.EndpointInfo;
 import org.apache.cxf.transport.MessageObserver;
+import org.apache.cxf.ws.addressing.MAPAggregator;
 
 public class WrappedEndpoint implements Endpoint {
 
     private Endpoint wrappedEndpoint;
     private EndpointInfo endpointInfo;
     private Service service;
+    private Boolean usingAddressing;
     
     WrappedEndpoint(Endpoint wrapped, EndpointInfo info, Service s) {
         wrappedEndpoint = wrapped;
@@ -118,6 +120,9 @@ public class WrappedEndpoint implements Endpoint {
     }
 
     public Object get(Object key) {
+        if (MAPAggregator.USING_ADDRESSING == key) {
+            return usingAddressing;
+        }
         return wrappedEndpoint.get(key);
     }
 
@@ -130,6 +135,10 @@ public class WrappedEndpoint implements Endpoint {
     }
 
     public Object put(String key, Object value) {
+        if (MAPAggregator.USING_ADDRESSING == key) {
+            usingAddressing = (Boolean)value;
+            return null;
+        }
         return wrappedEndpoint.put(key, value);
     }
 
