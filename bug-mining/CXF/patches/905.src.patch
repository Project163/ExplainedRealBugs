diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
index db8cf6bfed..6855ea93c4 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
@@ -1250,6 +1250,10 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
             valid = false;
         }
         
+        if (Names.INVALID_CARDINALITY_NAME.equals(ContextUtils.retrieveMAPFaultName(message))) {
+            valid = false;
+        }
+        
         return valid;
     }
 }
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/Names.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/Names.java
index bad224df97..7bca8f2813 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/Names.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/Names.java
@@ -171,6 +171,10 @@ public final class Names {
     public static final QName ONLY_NONANONYMOUS_ADDRESS_SUPPORTED_QNAME =
         new QName(WSA_NAMESPACE_NAME, ONLY_NONANONYMOUS_ADDRESS_SUPPORTED_NAME);
     
+    public static final String INVALID_CARDINALITY_NAME = "InvalidCardinality";
+    public static final QName INVALID_CARDINALITY_QNAME = new QName(WSA_NAMESPACE_NAME,
+                                                                    INVALID_CARDINALITY_NAME);
+           
     public static final String SOAP11HTTP_ADDRESSING_BINDING = 
         "http://schemas.xmlsoap.org/soap/envelope/?addressing=ms";
     public static final String SOAP12HTTP_ADDRESSING_BINDING = 
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
index 00d3cb8dc8..7dc93d9944 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
@@ -23,6 +23,7 @@ import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.ResourceBundle;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.logging.Level;
@@ -76,6 +77,7 @@ public class MAPCodec extends AbstractSoapInterceptor {
 
     private static final Logger LOG = LogUtils.getL7dLogger(MAPCodec.class);
     private static final String IS_REFERENCE_PARAM_ATTR_NAME = "IsReferenceParameter";
+    private static final ResourceBundle BUNDLE = LOG.getResourceBundle();
     private static final String ONE_WAY_DECOUPLED_FAULT_SUPPORT = 
         "org.apache.cxf.ws.addressing.oneway.decoupled_fault_support";
     
@@ -495,7 +497,7 @@ public class MAPCodec extends AbstractSoapInterceptor {
                 LOG.log(Level.FINE, "Inbound WS-Addressing headers");
                 Unmarshaller unmarshaller = null;
                 Set<Element> referenceParameterHeaders = null;
-
+                QName invalidCardinalityQName = null;
                 Iterator<Header> iter = header.iterator();
                 while (iter.hasNext()) {
                     Header hdr = iter.next();
@@ -518,12 +520,15 @@ public class MAPCodec extends AbstractSoapInterceptor {
                             }
                             String localName = headerElement.getLocalName();
                             if (Names.WSA_MESSAGEID_NAME.equals(localName)) {
+                                invalidCardinalityQName = maps.getMessageID() != null
+                                    ? Names.WSA_MESSAGEID_QNAME : null;
                                 maps.setMessageID(decodeAsNative(
                                                        headerURI,
                                                        AttributedURIType.class,
                                                        headerElement, 
                                                        unmarshaller));
                             } else if (Names.WSA_TO_NAME.equals(localName)) {
+                                invalidCardinalityQName = maps.getTo() != null ? Names.WSA_TO_QNAME : null;
                                 AttributedURIType addr = decodeAsNative(
                                                        headerURI,
                                                        AttributedURIType.class,
@@ -531,18 +536,26 @@ public class MAPCodec extends AbstractSoapInterceptor {
                                                        unmarshaller);
                                 maps.setTo(EndpointReferenceUtils.getEndpointReference(addr));
                             } else if (Names.WSA_FROM_NAME.equals(localName)) {
+                                invalidCardinalityQName = maps.getFrom() != null
+                                    ? Names.WSA_FROM_QNAME : null;
                                 maps.setFrom(decodeAsNative(
                                                        headerURI,
                                                        EndpointReferenceType.class,
                                                        headerElement, 
                                                        unmarshaller));
                             } else if (Names.WSA_REPLYTO_NAME.equals(localName)) {
+                                invalidCardinalityQName = maps.getReplyTo() != null
+                                                                   ? Names.WSA_REPLYTO_QNAME : null;
+
                                 maps.setReplyTo(decodeAsNative(
                                                        headerURI,
                                                        EndpointReferenceType.class,
                                                        headerElement, 
                                                        unmarshaller));
                             } else if (Names.WSA_FAULTTO_NAME.equals(localName)) {
+                                invalidCardinalityQName = maps.getFaultTo() != null
+                                    ? Names.WSA_FAULTTO_QNAME : null;
+
                                 maps.setFaultTo(decodeAsNative(
                                                        headerURI,
                                                        EndpointReferenceType.class,
@@ -555,6 +568,8 @@ public class MAPCodec extends AbstractSoapInterceptor {
                                                        headerElement, 
                                                        unmarshaller));
                             } else if (Names.WSA_ACTION_NAME.equals(localName)) {
+                                invalidCardinalityQName = maps.getAction() != null
+                                    ? Names.WSA_ACTION_QNAME : null;
                                 maps.setAction(decodeAsNative(
                                                        headerURI,
                                                        AttributedURIType.class,
@@ -576,13 +591,24 @@ public class MAPCodec extends AbstractSoapInterceptor {
                 if (null != referenceParameterHeaders && null != maps) {
                     decodeReferenceParameters(referenceParameterHeaders, maps, unmarshaller);
                 }
+                if (invalidCardinalityQName != null) {
+                    storeInvalidCardinalityFault(message, invalidCardinalityQName);
+                }
+
             }
         } catch (JAXBException je) {
             LOG.log(Level.WARNING, "SOAP_HEADER_DECODE_FAILURE_MSG", je); 
         }
         return maps;
     }
-    
+        
+    private void storeInvalidCardinalityFault(SoapMessage message, QName wsaHeaderName) {
+        LOG.log(Level.WARNING, "INVALID_CARDINALITY_MESSAGE", wsaHeaderName);
+        String reason = BUNDLE.getString("INVALID_ADDRESSING_PROPERTY_MESSAGE");
+        ContextUtils.storeMAPFaultName(Names.INVALID_CARDINALITY_NAME, message);
+        ContextUtils.storeMAPFaultReason(reason, message);
+    }
+        
     private void decodeReferenceParameters(Set<Element> referenceParameterHeaders, 
                                            AddressingPropertiesImpl maps, 
                                            Unmarshaller unmarshaller) 
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/Messages.properties b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/Messages.properties
index f25fdfd6a9..9a2327e43e 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/Messages.properties
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/Messages.properties
@@ -24,3 +24,5 @@ UNSUPPORTED_VERSION_MSG = Unsupported WS-Addressing version {0}
 IGNORE_NON_ELEMENT_REF_PARAM_MSG = Ignoring reference parameter {0} because it is not a JAXBElement
 CORRELATION_FAILURE_MSG = Failed to correlate message, aborting dispatch.
 RESPONSE_NOT_USING_WSADDRESSING = Response message does not contain WS-Addressing properties.  Not correlating response.
+INVALID_CARDINALITY_MESSAGE = Duplicate WS-Addressing header {0}
+INVALID_ADDRESSING_PROPERTY_MESSAGE = A header representing a Message Addressing Property is not valid and the message cannot be processed
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/WSAClientServerTest.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/WSAClientServerTest.java
index 9a921818c7..3b62c15bc3 100644
--- a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/WSAClientServerTest.java
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/WSAClientServerTest.java
@@ -19,11 +19,20 @@
 
 package org.apache.cxf.systest.ws.addr_feature;
 
+import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
 import java.net.URL;
 import javax.xml.namespace.QName;
+import javax.xml.soap.MessageFactory;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.Dispatch;
+import javax.xml.ws.Service;
 import javax.xml.ws.soap.AddressingFeature;
+import javax.xml.ws.soap.SOAPFaultException;
 
+import org.apache.cxf.helpers.IOUtils;
 import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;
 import org.apache.cxf.systest.ws.AbstractWSATestBase;
 import org.apache.cxf.ws.addressing.WSAddressingFeature;
@@ -101,7 +110,39 @@ public class WSAClientServerTest extends AbstractWSATestBase {
         assertTrue(output.toString().indexOf(expectedOut) != -1);
         assertTrue(input.toString().indexOf(expectedIn) != -1);
     }
+    
+    //CXF-3456
+    @Test
+    public void testDuplicateHeaders() throws Exception {
+        URL wsdl = getClass().getResource("/wsdl_systest_wsspec/add_numbers.wsdl");
+        assertNotNull("WSDL is null", wsdl);
 
+        AddNumbersService service = new AddNumbersService(wsdl, serviceName);
+        QName portName = new QName("http://apache.org/cxf/systest/ws/addr_feature/", "AddNumbersPort");
+        Dispatch<SOAPMessage> disp = service.createDispatch(portName, SOAPMessage.class,
+                                                            Service.Mode.MESSAGE,
+                                                            new AddressingFeature(false, false));
+        disp.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
+                                 "http://localhost:" + PORT + "/jaxws/add");
+        
+        InputStream msgIns = getClass().getResourceAsStream("./duplicate-wsa-header-msg.xml");
+        String msg = new String(IOUtils.readBytesFromStream(msgIns));
+        msg = msg.replaceAll("$PORT", PORT);
+        
+        ByteArrayInputStream bout = new ByteArrayInputStream(msg.getBytes());
+        
+        SOAPMessage soapReqMsg = MessageFactory.newInstance().createMessage(null, bout);
+        assertNotNull(soapReqMsg);
+        
+        try {
+            disp.invoke(soapReqMsg);
+            fail("SOAPFaultFxception is expected");
+        } catch (SOAPFaultException ex) {
+            assertTrue("WSA header exception is expected",
+                       ex.getMessage().indexOf("A header representing a Message Addressing") > -1);
+        }         
+    }
+    
     private AddNumbersPortType getPort() throws Exception {
         URL wsdl = getClass().getResource("/wsdl_systest_wsspec/add_numbers.wsdl");
         assertNotNull("WSDL is null", wsdl);
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/duplicate-wsa-header-msg.xml b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/duplicate-wsa-header-msg.xml
new file mode 100644
index 0000000000..fd7d5bc048
--- /dev/null
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/addr_feature/duplicate-wsa-header-msg.xml
@@ -0,0 +1,21 @@
+<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
+	<soap:Header>
+		<Action xmlns="http://www.w3.org/2005/08/addressing">http://apache.org/cxf/systest/ws/addr_feature/AddNumbersPortType/addNumbers
+		</Action>
+		<MessageID xmlns="http://www.w3.org/2005/08/addressing">urn:uuid:19cbc77a-a910-4f41-8bc4-ecb0e7af34ab
+		</MessageID>
+		<To xmlns="http://www.w3.org/2005/08/addressing">http://localhost:$PORT$/jaxws/add</To>
+		<ReplyTo xmlns="http://www.w3.org/2005/08/addressing">
+			<Address>http://www.w3.org/2005/08/addressing/anonymous</Address>
+		</ReplyTo>
+		<ReplyTo xmlns="http://www.w3.org/2005/08/addressing">
+			<Address>http://www.w3.org/2005/08/addressing/anonymous</Address>
+		</ReplyTo>
+	</soap:Header>
+	<soap:Body>
+		<addNumbers xmlns="http://apache.org/cxf/systest/ws/addr_feature/">
+			<number1>1</number1>
+			<number2>2</number2>
+		</addNumbers>
+	</soap:Body>
+</soap:Envelope>
\ No newline at end of file
