diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java
index da1ccf3e7b..a18c0e266c 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/JAXRSInvoker.java
@@ -40,6 +40,7 @@ import org.apache.cxf.jaxrs.impl.MetadataMap;
 import org.apache.cxf.jaxrs.interceptor.JAXRSInInterceptor;
 import org.apache.cxf.jaxrs.model.ClassResourceInfo;
 import org.apache.cxf.jaxrs.model.OperationResourceInfo;
+import org.apache.cxf.jaxrs.model.OperationResourceInfoStack;
 import org.apache.cxf.jaxrs.model.URITemplate;
 import org.apache.cxf.jaxrs.provider.ProviderFactory;
 import org.apache.cxf.jaxrs.utils.HttpUtils;
@@ -53,55 +54,56 @@ import org.apache.cxf.service.invoker.AbstractInvoker;
 public class JAXRSInvoker extends AbstractInvoker {
     private static final Logger LOG = LogUtils.getL7dLogger(JAXRSServiceFactoryBean.class);
     private static final ResourceBundle BUNDLE = BundleUtils.getBundle(JAXRSInvoker.class);
-    
+
     private List<Object> resourceObjects;
 
     public JAXRSInvoker() {
     }
-    
+
     public JAXRSInvoker(List<Object> resourceObjects) {
         this.resourceObjects = resourceObjects;
     }
     public Object invoke(Exchange exchange, Object request) {
         return invoke(exchange, request, resourceObjects);
-    }    
+    }
     @SuppressWarnings("unchecked")
     public Object invoke(Exchange exchange, Object request, List<Object> resources) {
-        
+
         Response response = exchange.get(Response.class);
         if (response != null) {
             // this means a blocking request filter provided a Response
             // or earlier exception has been converted to Response
-            
+
             //TODO: should we remove response from exchange ?
-            //      or should we rather ignore content list and have 
-            //      Response set here for all cases and extract it 
-            //      in the out interceptor instead of dealing with the contents list ?  
-            return new MessageContentsList(response);    
+            //      or should we rather ignore content list and have
+            //      Response set here for all cases and extract it
+            //      in the out interceptor instead of dealing with the contents list ?
+            return new MessageContentsList(response);
         }
-        
+
         OperationResourceInfo ori = exchange.get(OperationResourceInfo.class);
+        pushOntoStack(ori, exchange.getInMessage());
 
         ClassResourceInfo cri = ori.getClassResourceInfo();
         Object resourceObject = getServiceObject(exchange, resources);
-        
+
         Method methodToInvoke = InjectionUtils.checkProxy(
              cri.getMethodDispatcher().getMethod(ori), resourceObject);
-        
+
         if (cri.isRoot()) {
-            JAXRSUtils.handleSetters(ori, resourceObject, 
+            JAXRSUtils.handleSetters(ori, resourceObject,
                                      exchange.getInMessage());
-            
-            InjectionUtils.injectContextFields(resourceObject, 
-                                               ori.getClassResourceInfo(), 
+
+            InjectionUtils.injectContextFields(resourceObject,
+                                               ori.getClassResourceInfo(),
                                                exchange.getInMessage());
-            InjectionUtils.injectResourceFields(resourceObject, 
-                                            ori.getClassResourceInfo(), 
+            InjectionUtils.injectResourceFields(resourceObject,
+                                            ori.getClassResourceInfo(),
                                             exchange.getInMessage());
         }
 
         String baseAddress = HttpUtils.getOriginalAddress(exchange.getInMessage());
-        
+
         List<Object> params = null;
         if (request instanceof List) {
             params = CastUtils.cast((List<?>)request);
@@ -125,47 +127,47 @@ public class JAXRSInvoker extends AbstractInvoker {
             }
             return new MessageContentsList(excResponse);
         }
-        
+
         if (ori.isSubResourceLocator()) {
             try {
                 Message msg = exchange.getInMessage();
-                MultivaluedMap<String, String> values = new MetadataMap<String, String>();                 
+                MultivaluedMap<String, String> values = new MetadataMap<String, String>();
                 String subResourcePath = (String)msg.get(JAXRSInInterceptor.RELATIVE_PATH);
-                String httpMethod = (String)msg.get(Message.HTTP_REQUEST_METHOD); 
+                String httpMethod = (String)msg.get(Message.HTTP_REQUEST_METHOD);
                 String contentType = (String)msg.get(Message.CONTENT_TYPE);
                 if (contentType == null) {
                     contentType = "*/*";
                 }
-                List<MediaType> acceptContentType = 
+                List<MediaType> acceptContentType =
                     (List<MediaType>)msg.getExchange().get(Message.ACCEPT_CONTENT_TYPE);
-                
-                result = checkResultObject(result, subResourcePath); 
-                
+
+                result = checkResultObject(result, subResourcePath);
+
                 List<Object> newResourceObjects = new ArrayList<Object>();
                 newResourceObjects.add(result);
-            
+
                 ClassResourceInfo subCri = cri.getSubResource(
-                     methodToInvoke.getReturnType(), 
+                     methodToInvoke.getReturnType(),
                      ClassHelper.getRealClass(result));
                 if (subCri == null) {
-                    org.apache.cxf.common.i18n.Message errorM = 
-                        new org.apache.cxf.common.i18n.Message("NO_SUBRESOURCE_FOUND",  
-                                                               BUNDLE, 
+                    org.apache.cxf.common.i18n.Message errorM =
+                        new org.apache.cxf.common.i18n.Message("NO_SUBRESOURCE_FOUND",
+                                                               BUNDLE,
                                                                subResourcePath);
                     LOG.severe(errorM.toString());
                     throw new WebApplicationException(404);
                 }
-                
-                OperationResourceInfo subOri = JAXRSUtils.findTargetMethod(subCri, 
-                                                         subResourcePath, 
-                                                         httpMethod, 
-                                                         values, 
-                                                         contentType, 
+
+                OperationResourceInfo subOri = JAXRSUtils.findTargetMethod(subCri,
+                                                         subResourcePath,
+                                                         httpMethod,
+                                                         values,
+                                                         contentType,
                                                          acceptContentType);
-                
-                
+
+
                 exchange.put(OperationResourceInfo.class, subOri);
-                msg.put(JAXRSInInterceptor.RELATIVE_PATH, 
+                msg.put(JAXRSInInterceptor.RELATIVE_PATH,
                         values.getFirst(URITemplate.FINAL_MATCH_GROUP));
                 msg.put(URITemplate.TEMPLATE_PARAMETERS, values);
                 // work out request parameters for the sub-resouce class. Here we
@@ -174,26 +176,26 @@ public class JAXRSInvoker extends AbstractInvoker {
                 //have a parameter that read from entitybody.
                 List<Object> newParams = JAXRSUtils.processParameters(subOri, values, msg);
                 msg.setContent(List.class, newParams);
-                
+
                 return this.invoke(exchange, newParams, newResourceObjects);
             } catch (WebApplicationException ex) {
                 Response excResponse = JAXRSUtils.convertFaultToResponse(ex, baseAddress);
                 return new MessageContentsList(excResponse);
             }
         }
-        
+
         return result;
-    }    
-    
+    }
+
     public Object getServiceObject(Exchange exchange) {
         return getServiceObject(exchange, resourceObjects);
     }
     public Object getServiceObject(Exchange exchange, List<Object> resources) {
         Object serviceObject = null;
-        
+
         OperationResourceInfo ori = exchange.get(OperationResourceInfo.class);
         ClassResourceInfo cri = ori.getClassResourceInfo();
-        
+
         if (resources != null) {
             Class c  = cri.getResourceClass();
             for (Object resourceObject : resources) {
@@ -203,24 +205,24 @@ public class JAXRSInvoker extends AbstractInvoker {
                 }
             }
         }
-        
+
         if (serviceObject == null) {
             serviceObject = cri.getResourceProvider().getInstance();
         }
-        
+
         return serviceObject;
     }
-    
+
     private static Object checkResultObject(Object result, String subResourcePath) {
         if (result == null) {
-            org.apache.cxf.common.i18n.Message errorM = 
-                new org.apache.cxf.common.i18n.Message("NULL_SUBRESOURCE",  
-                                                       BUNDLE, 
+            org.apache.cxf.common.i18n.Message errorM =
+                new org.apache.cxf.common.i18n.Message("NULL_SUBRESOURCE",
+                                                       BUNDLE,
                                                        subResourcePath);
             LOG.severe(errorM.toString());
             throw new WebApplicationException(500);
         }
-        
+
         //the result becomes the object that will handle the request
         if (result instanceof MessageContentsList) {
             result = ((MessageContentsList)result).get(0);
@@ -229,7 +231,16 @@ public class JAXRSInvoker extends AbstractInvoker {
         } else if (result.getClass().isArray()) {
             result = ((Object[])result)[0];
         }
-        
+
         return result;
     }
+
+    private void pushOntoStack(OperationResourceInfo ori, Message msg) {
+        OperationResourceInfoStack stack = msg.get(OperationResourceInfoStack.class);
+        if (stack == null) {
+            stack = new OperationResourceInfoStack();
+            msg.put(OperationResourceInfoStack.class, stack);
+        }
+        stack.push(ori);
+    }
 }
diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriBuilderImpl.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriBuilderImpl.java
index 781cd608d5..71f019caa5 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriBuilderImpl.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriBuilderImpl.java
@@ -19,6 +19,7 @@
 
 package org.apache.cxf.jaxrs.impl;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -27,6 +28,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
+import javax.ws.rs.Path;
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.PathSegment;
 import javax.ws.rs.core.UriBuilder;
@@ -35,7 +37,7 @@ import javax.ws.rs.core.UriBuilderException;
 import org.apache.cxf.jaxrs.utils.JAXRSUtils;
 
 public class UriBuilderImpl extends UriBuilder {
-    
+
     private String scheme;
     private String userInfo;
     private int port;
@@ -43,38 +45,31 @@ public class UriBuilderImpl extends UriBuilder {
     private List<PathSegment> paths = new ArrayList<PathSegment>();
     private String fragment;
     private MultivaluedMap<String, String> query = new MetadataMap<String, String>();
-    
-       
+
     public UriBuilderImpl() {
     }
-    
+
     public UriBuilderImpl(URI uri) {
         setUriParts(uri);
     }
 
-    
     @Override
     public URI build(Object... values) throws IllegalArgumentException, UriBuilderException {
         try {
-            return new URI(scheme, 
-                           userInfo, 
-                           host, 
-                           port, 
-                           buildPath(), 
-                           buildQuery(), 
-                           fragment);
+            return new URI(scheme, userInfo, host, port, buildPath(), buildQuery(), fragment);
         } catch (URISyntaxException ex) {
             throw new UriBuilderException("URI can not be built", ex);
         }
     }
 
-//CHECKSTYLE:OFF
+    // CHECKSTYLE:OFF
     @Override
     public UriBuilder clone() {
         return new UriBuilderImpl(build());
     }
-//CHECKSTYLE:ON
-    
+
+    // CHECKSTYLE:ON
+
     @Override
     public UriBuilder fragment(String theFragment) throws IllegalArgumentException {
         this.fragment = theFragment;
@@ -87,16 +82,67 @@ public class UriBuilderImpl extends UriBuilder {
         return this;
     }
 
+    @SuppressWarnings("unchecked")
     @Override
     public UriBuilder path(Class resource) throws IllegalArgumentException {
-        // TODO Auto-generated method stub
-        return null;
+        if (resource == null) {
+            throw new IllegalArgumentException("resource is null");
+        }
+        Annotation ann = resource.getAnnotation(Path.class);
+        if (ann == null) {
+            throw new IllegalArgumentException("Class '" + resource.getCanonicalName()
+                                               + "' is not annotated with Path");
+        }
+        // path(String) decomposes multi-segment path when necessary
+        return path(((Path)ann).value());
     }
 
+    @SuppressWarnings("unchecked")
     @Override
     public UriBuilder path(Class resource, String method) throws IllegalArgumentException {
-        // TODO Auto-generated method stub
-        return null;
+        if (resource == null) {
+            throw new IllegalArgumentException("resource is null");
+        }
+        if (method == null) {
+            throw new IllegalArgumentException("method is null");
+        }
+        Annotation foundAnn = null;
+        for (Method meth : resource.getMethods()) {
+            if (meth.getName().equals(method)) {
+                Annotation ann = meth.getAnnotation(Path.class);
+                if (foundAnn != null && ann != null) {
+                    throw new IllegalArgumentException("Multiple Path annotations for '" + method
+                                                       + "' overloaded method");
+                }
+                foundAnn = ann;
+            }
+        }
+        if (foundAnn == null) {
+            throw new IllegalArgumentException("No Path annotation for '" + method + "' method");
+        }
+        // path(String) decomposes multi-segment path when necessary
+        return path(((Path)foundAnn).value());
+    }
+
+    @Override
+    public UriBuilder path(Method method) throws IllegalArgumentException {
+        if (method == null) {
+            throw new IllegalArgumentException("method is null");
+        }
+        Annotation ann = method.getAnnotation(Path.class);
+        if (ann == null) {
+            throw new IllegalArgumentException("Method '" + method.getClass().getCanonicalName() + "."
+                                               + method.getName() + "' is not annotated with Path");
+        }
+        // path(String) decomposes multi-segment path when necessary
+        return path(((Path)ann).value());
+    }
+
+    @Override
+    public UriBuilder path(String path) throws IllegalArgumentException {
+        List<PathSegment> segments = JAXRSUtils.getPathSegments(path, false);
+        paths.addAll(segments);
+        return this;
     }
 
     @Override
@@ -113,7 +159,19 @@ public class UriBuilderImpl extends UriBuilder {
 
     @Override
     public UriBuilder schemeSpecificPart(String ssp) throws IllegalArgumentException {
-        //schemeSpPart = ssp;
+        // scheme-specific part is whatever after ":" of URI
+        // see: http://en.wikipedia.org/wiki/URI_scheme
+        try {
+            URI uri = new URI("whatever://" + ssp);
+            port = uri.getPort();
+            host = uri.getHost();
+            paths = JAXRSUtils.getPathSegments(uri.getPath(), false);
+            fragment = uri.getFragment();
+            query = JAXRSUtils.getStructuredParams(uri.getQuery(), "&", true);
+            userInfo = uri.getUserInfo();
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Wrong syntax of scheme-specific part", e);
+        }
         return this;
     }
 
@@ -138,20 +196,20 @@ public class UriBuilderImpl extends UriBuilder {
         query = JAXRSUtils.getStructuredParams(uri.getQuery(), "&", true);
         userInfo = uri.getUserInfo();
     }
-    
+
     private String buildPath() {
         StringBuilder sb = new StringBuilder();
         for (PathSegment ps : paths) {
             String p = ps.getPath();
-            if (!p.startsWith("/")) {
-                sb.append('/');    
+            if (!p.startsWith("/") && (sb.length() == 0 || sb.charAt(sb.length() - 1) != '/')) {
+                sb.append('/');
             }
             sb.append(p);
         }
         return sb.toString();
-        
+
     }
-    
+
     private String buildQuery() {
         StringBuilder b = new StringBuilder();
         for (Iterator<Map.Entry<String, List<String>>> it = query.entrySet().iterator(); it.hasNext();) {
@@ -167,49 +225,30 @@ public class UriBuilderImpl extends UriBuilder {
     @Override
     public URI buildFromEncoded(Object... values) throws IllegalArgumentException, UriBuilderException {
         try {
-            return new URI(scheme, 
-                           userInfo, 
-                           host, 
-                           port, 
-                           buildPath(), 
-                           buildQuery(), 
-                           fragment);
+            return new URI(scheme, userInfo, host, port, buildPath(), buildQuery(), fragment);
         } catch (URISyntaxException ex) {
             throw new UriBuilderException("URI can not be built", ex);
         }
     }
 
     @Override
-    public URI buildFromEncodedMap(Map<String, ? extends Object> arg0) 
-        throws IllegalArgumentException, UriBuilderException {
+    public URI buildFromEncodedMap(Map<String, ? extends Object> arg0) throws IllegalArgumentException,
+        UriBuilderException {
         // TODO Auto-generated method stub
-        return null;
+        throw new UnsupportedOperationException("Not implemented :/");
     }
 
     @Override
-    public URI buildFromMap(Map<String, ? extends Object> arg0) 
-        throws IllegalArgumentException, UriBuilderException {
+    public URI buildFromMap(Map<String, ? extends Object> arg0) throws IllegalArgumentException,
+        UriBuilderException {
         // TODO Auto-generated method stub
-        return null;
+        throw new UnsupportedOperationException("Not implemented :/");
     }
 
     @Override
     public UriBuilder matrixParam(String name, Object... values) throws IllegalArgumentException {
         // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public UriBuilder path(String path) throws IllegalArgumentException {
-        List<PathSegment> segments = JAXRSUtils.getPathSegments(path, false);
-        paths.addAll(segments);
-        return this;
-    }
-
-    @Override
-    public UriBuilder path(Method method) throws IllegalArgumentException {
-        // TODO Auto-generated method stub
-        return null;
+        throw new UnsupportedOperationException("Not implemented :/");
     }
 
     @Override
@@ -225,38 +264,39 @@ public class UriBuilderImpl extends UriBuilder {
     @Override
     public UriBuilder replaceMatrix(String matrix) throws IllegalArgumentException {
         // TODO Auto-generated method stub
-        return null;
+        throw new UnsupportedOperationException("Not implemented :/");
     }
 
     @Override
     public UriBuilder replaceMatrixParam(String name, Object... values) throws IllegalArgumentException {
         // TODO Auto-generated method stub
-        return null;
+        throw new UnsupportedOperationException("Not implemented :/");
     }
 
     @Override
     public UriBuilder replacePath(String path) {
-        // TODO Auto-generated method stub
-        return null;
+        paths = JAXRSUtils.getPathSegments(path, false);
+        return this;
     }
 
     @Override
     public UriBuilder replaceQuery(String queryValue) throws IllegalArgumentException {
-        // TODO Auto-generated method stub
-        return null;
+        query = JAXRSUtils.getStructuredParams(queryValue, "&", true);
+        return this;
     }
 
     @Override
     public UriBuilder segment(String... segments) throws IllegalArgumentException {
-        // TODO Auto-generated method stub
-        return null;
+        for (String segment : segments) {
+            path(segment);
+        }
+        return this;
     }
 
     @Override
     public UriBuilder replaceQueryParam(String name, Object... values) throws IllegalArgumentException {
         // TODO Auto-generated method stub
-        return null;
+        throw new UnsupportedOperationException("Not implemented :/");
     }
-    
-    
+
 }
diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriInfoImpl.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriInfoImpl.java
index 0bda0b68a9..2f0c3abd3f 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriInfoImpl.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/impl/UriInfoImpl.java
@@ -20,29 +20,42 @@
 package org.apache.cxf.jaxrs.impl;
 
 import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.logging.Logger;
 
+import javax.ws.rs.Path;
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.PathSegment;
 import javax.ws.rs.core.UriBuilder;
 import javax.ws.rs.core.UriInfo;
 
+import org.apache.cxf.common.logging.LogUtils;
+import org.apache.cxf.jaxrs.model.OperationResourceInfo;
+import org.apache.cxf.jaxrs.model.OperationResourceInfoStack;
 import org.apache.cxf.jaxrs.model.URITemplate;
+import org.apache.cxf.jaxrs.utils.AnnotationUtils;
 import org.apache.cxf.jaxrs.utils.HttpUtils;
 import org.apache.cxf.jaxrs.utils.JAXRSUtils;
 import org.apache.cxf.message.Message;
 
 public class UriInfoImpl implements UriInfo {
+    private static final Logger LOG = LogUtils.getL7dLogger(UriInfoImpl.class);
 
-    private MultivaluedMap<String, String> templateParams; 
+    private MultivaluedMap<String, String> templateParams;
     private Message message;
-    
+    private OperationResourceInfoStack stack;
+
     public UriInfoImpl(Message m, MultivaluedMap<String, String> templateParams) {
         this.message = m;
         this.templateParams = templateParams;
+        if (m != null) {
+            this.stack = m.get(OperationResourceInfoStack.class);
+        }
     }
-    
+
     public URI getAbsolutePath() {
         String path = getAbsolutePathAsString();
         return URI.create(path);
@@ -66,7 +79,6 @@ public class UriInfoImpl implements UriInfo {
     }
 
     public String getPath(boolean decode) {
-        
         return doGetPath(decode, true);
     }
 
@@ -83,9 +95,7 @@ public class UriInfoImpl implements UriInfo {
     }
 
     public MultivaluedMap<String, String> getQueryParameters(boolean decode) {
-        return JAXRSUtils.getStructuredParams((String)message.get(Message.QUERY_STRING),
-                                              "&",
-                                              decode);
+        return JAXRSUtils.getStructuredParams((String)message.get(Message.QUERY_STRING), "&", decode);
     }
 
     public URI getRequestUri() {
@@ -111,33 +121,58 @@ public class UriInfoImpl implements UriInfo {
             if (entry.getKey().equals(URITemplate.FINAL_MATCH_GROUP)) {
                 continue;
             }
-            values.add(entry.getKey(), 
-                       decode ? JAXRSUtils.uriDecode(entry.getValue().get(0)) 
-                              : entry.getValue().get(0));
+            values.add(entry.getKey(), decode ? JAXRSUtils.uriDecode(entry.getValue().get(0)) : entry
+                .getValue().get(0));
         }
         return values;
     }
 
     public List<Object> getMatchedResources() {
-        // TODO Auto-generated method stub
-        return null;
+        if (stack != null) {
+            List<Object> resources = new ArrayList<Object>(stack.size());
+            for (OperationResourceInfo ori : stack) {
+                resources.add(ori.getClassResourceInfo().getResourceClass());
+            }
+            return resources;
+        }
+        LOG.fine("No resource stack information, returning empty list");
+        return Collections.emptyList();
     }
 
     public List<String> getMatchedURIs() {
-        // TODO Auto-generated method stub
-        return null;
+        return getMatchedURIs(true);
     }
 
     public List<String> getMatchedURIs(boolean decode) {
-        // TODO Auto-generated method stub
-        return null;
+        if (stack != null) {
+            List<String> uris = new ArrayList<String>(stack.size());
+            String sum = "";
+            for (OperationResourceInfo ori : stack) {
+                Path[] paths = {
+                    (Path)AnnotationUtils.getClassAnnotation(ori.getClassResourceInfo().getResourceClass(),
+                                                             Path.class),
+                    (Path)AnnotationUtils.getMethodAnnotation(ori.getAnnotatedMethod(), Path.class)
+                };
+                for (Path p : paths) {
+                    if (p != null) {
+                        String v = p.value();
+                        sum += "/" + (decode ? JAXRSUtils.uriDecode(v) : v);
+                    }
+                }
+                UriBuilder ub = UriBuilder.fromPath(sum);
+                uris.add(ub.build().normalize().getPath());
+            }
+            return uris;
+        }
+        LOG.fine("No resource stack information, returning empty list");
+        return Collections.emptyList();
     }
 
     private String doGetPath(boolean decode, boolean addSlash) {
         String path = HttpUtils.getPathToMatch(message, addSlash);
         return decode ? JAXRSUtils.uriDecode(path) : path;
     }
-    
+
     private String getAbsolutePathAsString() {
         String address = getBaseUri().toString();
         String path = doGetPath(true, false);
diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/model/OperationResourceInfoStack.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/model/OperationResourceInfoStack.java
new file mode 100644
index 0000000000..999f70597c
--- /dev/null
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/model/OperationResourceInfoStack.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jaxrs.model;
+
+import java.util.Stack;
+
+/**
+ * Stack of {@link OperationResourceInfo} representing resources path when JAX-RS invocation looks for target.
+ * Used to evaluate {@link UriInfo#getMatchedResources() UriInfo.getMatched*} methods when sub-locators are
+ * involved.
+ * <p>
+ * Stack elements are placed in order same as java stacktrace - root resource on bottom, recent resource on
+ * top.
+ */
+public class OperationResourceInfoStack extends Stack<OperationResourceInfo> {
+    private static final long serialVersionUID = 1L;
+}
diff --git a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/UriBuilderImplTest.java b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/UriBuilderImplTest.java
index e7dc42dccb..3f2b986d24 100644
--- a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/UriBuilderImplTest.java
+++ b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/impl/UriBuilderImplTest.java
@@ -19,33 +19,104 @@
 
 package org.apache.cxf.jaxrs.impl;
 
+import java.lang.reflect.Method;
 import java.net.URI;
 
+import org.apache.cxf.jaxrs.resources.Book;
+import org.apache.cxf.jaxrs.resources.BookStore;
+import org.apache.cxf.jaxrs.resources.UriBuilderWrongAnnotations;
+
 import org.junit.Assert;
 import org.junit.Test;
 
 public class UriBuilderImplTest extends Assert {
-    
+
     @Test
     public void testUri() throws Exception {
         URI uri = new URI("http://foo/bar/baz?query=1#fragment");
         URI newUri = new UriBuilderImpl().uri(uri).build();
         assertEquals("URI is not built correctly", newUri, uri);
     }
-    
-    
+
     @Test
     public void testAddPath() throws Exception {
         URI uri = new URI("http://foo/bar");
         URI newUri = new UriBuilderImpl().uri(uri).path("baz").build();
-        assertEquals("URI is not built correctly", newUri, 
-                     new URI("http://foo/bar/baz"));
+        assertEquals("URI is not built correctly", new URI("http://foo/bar/baz"), newUri);
         newUri = new UriBuilderImpl().uri(uri).path("baz").path("1").path("2").build();
-        assertEquals("URI is not built correctly", newUri, 
-                     new URI("http://foo/bar/baz/1/2"));
+        assertEquals("URI is not built correctly", new URI("http://foo/bar/baz/1/2"), newUri);
+    }
+
+    @Test
+    public void testAddPathSlashes() throws Exception {
+        URI uri = new URI("http://foo/");
+        URI newUri = new UriBuilderImpl().uri(uri).path("/bar").path("baz/").path("/blah/").build();
+        assertEquals("URI is not built correctly", new URI("http://foo/bar/baz/blah/"), newUri);
+    }
+
+    @Test
+    public void testAddPathClass() throws Exception {
+        URI uri = new URI("http://foo/");
+        URI newUri = new UriBuilderImpl().uri(uri).path(BookStore.class).path("bar").build();
+        assertEquals("URI is not built correctly", new URI("http://foo/bookstore/bar"), newUri);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddPathClassNull() throws Exception {
+        new UriBuilderImpl().path((Class)null).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddPathClassNoAnnotation() throws Exception {
+        new UriBuilderImpl().path(this.getClass()).build();
+    }
+
+    @Test
+    public void testAddPathClassMethod() throws Exception {
+        URI uri = new URI("http://foo/");
+        URI newUri = new UriBuilderImpl().uri(uri).path(BookStore.class, "updateBook").path("bar").build();
+        assertEquals("URI is not built correctly", new URI("http://foo/books/bar"), newUri);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddPathClassMethodNull1() throws Exception {
+        new UriBuilderImpl().path(null, "methName").build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddPathClassMethodNull2() throws Exception {
+        new UriBuilderImpl().path(BookStore.class, null).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddPathClassMethodTooMany() throws Exception {
+        new UriBuilderImpl().path(UriBuilderWrongAnnotations.class, "overloaded").build();
     }
-    
-    
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddPathClassMethodTooLess() throws Exception {
+        new UriBuilderImpl().path(BookStore.class, "nonexistingMethod").build();
+    }
+
+    @Test
+    public void testAddPathMethod() throws Exception {
+        Method meth = BookStore.class.getMethod("updateBook", Book.class);
+        URI uri = new URI("http://foo/");
+        URI newUri = new UriBuilderImpl().uri(uri).path(meth).path("bar").build();
+        assertEquals("URI is not built correctly", new URI("http://foo/books/bar"), newUri);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddPathMethodNull() throws Exception {
+        new UriBuilderImpl().path((Method)null).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddPathMethodNoAnnotation() throws Exception {
+        Method noAnnot = BookStore.class.getMethod("getBook", String.class);
+        new UriBuilderImpl().path(noAnnot).build();
+    }
+
     @Test
     public void testSchemeHostPortQueryFragment() throws Exception {
         URI uri;
@@ -54,11 +125,9 @@ public class UriBuilderImplTest extends Assert {
         } else {
             uri = new URI("http://foo:1234/bar?n1=v1&n2=v2#fragment");
         }
-        URI newUri = new UriBuilderImpl().scheme("http").host("foo")
-                     .port(1234).path("bar")
-                     .queryParam("n1", "v1").queryParam("n2", "v2")
-                     .fragment("fragment").build();
-        assertEquals("URI is not built correctly", newUri, uri);
+        URI newUri = new UriBuilderImpl().scheme("http").host("foo").port(1234).path("bar").queryParam("n1",
+                                                                                                       "v1")
+            .queryParam("n2", "v2").fragment("fragment").build();
+        assertEquals("URI is not built correctly", uri, newUri);
     }
-
 }
diff --git a/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/resources/UriBuilderWrongAnnotations.java b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/resources/UriBuilderWrongAnnotations.java
new file mode 100644
index 0000000000..6bcd2db96e
--- /dev/null
+++ b/rt/frontend/jaxrs/src/test/java/org/apache/cxf/jaxrs/resources/UriBuilderWrongAnnotations.java
@@ -0,0 +1,32 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.jaxrs.resources;
+
+import javax.ws.rs.Path;
+
+public class UriBuilderWrongAnnotations {
+
+    @Path("/foo")
+    public void overloaded(int x) {
+    }
+
+    @Path("/bar")
+    public void overloaded() {
+    }
+}
diff --git a/systests/src/test/java/org/apache/cxf/systest/jaxrs/Chapter.java b/systests/src/test/java/org/apache/cxf/systest/jaxrs/Chapter.java
index 92378c8890..c14026bde5 100644
--- a/systests/src/test/java/org/apache/cxf/systest/jaxrs/Chapter.java
+++ b/systests/src/test/java/org/apache/cxf/systest/jaxrs/Chapter.java
@@ -19,9 +19,15 @@
 
 package org.apache.cxf.systest.jaxrs;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
+import javax.ws.rs.QueryParam;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.UriInfo;
 import javax.xml.bind.annotation.XmlRootElement;
 
 
@@ -61,4 +67,23 @@ public class Chapter {
         return this;
     }
 
+    
+    @GET
+    @Path("/matched-resources")
+    @Produces("text/plain")
+    public String getMatchedResources(@Context UriInfo ui) {
+        List<String> list = new ArrayList<String>();
+        for (Object obj : ui.getMatchedResources()) {
+            list.add(obj.toString());
+        }
+        return list.toString();
+    }
+
+    @GET
+    @Path("/matched%21uris")
+    @Produces("text/plain")
+    public String getMatchedUris(@Context UriInfo ui, 
+                                 @QueryParam("decode") String decode) {
+        return ui.getMatchedURIs(Boolean.parseBoolean(decode)).toString();        
+    }
 }
diff --git a/systests/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerBookTest.java b/systests/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerBookTest.java
index 4cced6b60e..9186f69aad 100644
--- a/systests/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerBookTest.java
+++ b/systests/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerBookTest.java
@@ -684,6 +684,39 @@ public class JAXRSClientServerBookTest extends AbstractBusClientServerTestBase {
         }  
     }
     
+    @Test
+    public void testUriInfoMatchedResources() throws Exception {
+        getAndCompare("http://localhost:9080/bookstore/"
+                      + "booksubresource/123/chapters/sub/1/matched-resources", 
+                      "[class org.apache.cxf.systest.jaxrs.BookStore, " 
+                      + "class org.apache.cxf.systest.jaxrs.Book, "
+                      + "class org.apache.cxf.systest.jaxrs.Chapter]", 
+                      "text/plain", 200);
+    }
+
+    @Test
+    public void testUriInfoMatchedUrisDecode() throws Exception {
+        String expected = "[/bookstore/booksubresource/{bookId}/, "
+                          + "/bookstore/booksubresource/{bookId}/chapters/sub/{chapterid}/, "
+                          + "/bookstore/booksubresource/{bookId}/chapters/sub/{chapterid}/matched!uris]";
+        getAndCompare("http://localhost:9080/bookstore/"
+                      + "booksubresource/123/chapters/sub/1/matched%21uris?decode=true", 
+                      expected, 
+                      "text/plain", 200);
+    }
+
+    @Test
+    public void testUriInfoMatchedUrisNoDecode() throws Exception {
+        //note '%21' instead of '!'
+        String expected = "[/bookstore/booksubresource/{bookId}/, "
+            + "/bookstore/booksubresource/{bookId}/chapters/sub/{chapterid}/, "
+            + "/bookstore/booksubresource/{bookId}/chapters/sub/{chapterid}/matched%21uris]";
+        getAndCompare("http://localhost:9080/bookstore/"
+                      + "booksubresource/123/chapters/sub/1/matched%21uris?decode=false", 
+                      expected,
+                      "text/plain", 200);
+    }
+    
     private void getAndCompareAsStrings(String address, 
                                         String resourcePath,
                                         String acceptType,
