diff --git a/core/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java b/core/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
index 721ea601fd..425e9726b8 100644
--- a/core/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
+++ b/core/src/main/java/org/apache/cxf/ws/addressing/MAPAggregator.java
@@ -36,6 +36,7 @@ public class MAPAggregator extends AbstractPhaseInterceptor<Message> {
     public static final String DECOUPLED_DESTINATION = MAPAggregator.class.getName()
         + ".decoupledDestination";
     public static final String ACTION_VERIFIED = MAPAggregator.class.getName() + ".actionVerified";
+    public static final String ADDRESSING_NAMESPACE = MAPAggregator.class.getName() + ".addressingNamespace";
 
     public interface MAPAggregatorLoader {
         MAPAggregator createImplementation(MAPAggregator mag);
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/AddressingFeatureApplier.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/AddressingFeatureApplier.java
index 774d339871..c962d1afc1 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/AddressingFeatureApplier.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/AddressingFeatureApplier.java
@@ -33,7 +33,7 @@ import org.apache.cxf.ws.addressing.soap.MAPCodec;
 public class AddressingFeatureApplier implements WSAddressingFeature.WSAddressingFeatureApplier {
 
     public void initializeProvider(WSAddressingFeature feature, InterceptorProvider provider, Bus bus) {
-        MAPCodec mapCodec = new MAPCodec();
+        MAPCodec mapCodec = MAPCodec.getInstance(bus);
         MAPAggregatorImpl mapAggregator = new MAPAggregatorImpl();
 
         mapAggregator.setAllowDuplicates(feature.isAllowDuplicates());
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/MAPAggregatorImpl.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/MAPAggregatorImpl.java
index 4d7ad7e20a..deed6bf787 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/MAPAggregatorImpl.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/impl/MAPAggregatorImpl.java
@@ -1076,6 +1076,10 @@ public class MAPAggregatorImpl extends MAPAggregator {
     private void setupNamespace(AddressingProperties maps, Message message) {
         AssertionInfoMap aim = message.get(AssertionInfoMap.class);
         if (null == aim) {
+            String ns = (String)message.getContextualProperty(MAPAggregator.ADDRESSING_NAMESPACE);
+            if (ns != null) {
+                maps.exposeAs(ns);
+            }
             return;
         }
         Collection<AssertionInfo> aic = aim.getAssertionInfo(MetadataConstants.USING_ADDRESSING_2004_QNAME);
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/policy/AddressingPolicyInterceptorProvider.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/policy/AddressingPolicyInterceptorProvider.java
index 11d629fbab..a9a6d324ed 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/policy/AddressingPolicyInterceptorProvider.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/policy/AddressingPolicyInterceptorProvider.java
@@ -24,6 +24,7 @@ import java.util.Collection;
 
 import javax.xml.namespace.QName;
 
+import org.apache.cxf.Bus;
 import org.apache.cxf.ws.addressing.MAPAggregator;
 import org.apache.cxf.ws.addressing.impl.MAPAggregatorImpl;
 import org.apache.cxf.ws.addressing.soap.MAPCodec;
@@ -39,7 +40,6 @@ public class AddressingPolicyInterceptorProvider extends AbstractPolicyIntercept
     private static final long serialVersionUID = -1018053541795476992L;
     private static final Collection<QName> ASSERTION_TYPES;
     private static final MAPAggregator MAP_AGGREGATOR = new MAPAggregatorImpl();
-    private static final MAPCodec MAP_CODEC = new MAPCodec();
 
     static {
         Collection<QName> types = new ArrayList<>();
@@ -52,19 +52,22 @@ public class AddressingPolicyInterceptorProvider extends AbstractPolicyIntercept
         ASSERTION_TYPES = types;
     }
 
-    public AddressingPolicyInterceptorProvider() {
+    public AddressingPolicyInterceptorProvider(Bus b) {
         super(ASSERTION_TYPES);
+        
+        MAPCodec mapCodec = MAPCodec.getInstance(b);
+
         getInInterceptors().add(MAP_AGGREGATOR);
-        getInInterceptors().add(MAP_CODEC);
+        getInInterceptors().add(mapCodec);
 
         getOutInterceptors().add(MAP_AGGREGATOR);
-        getOutInterceptors().add(MAP_CODEC);
+        getOutInterceptors().add(mapCodec);
 
         getInFaultInterceptors().add(MAP_AGGREGATOR);
-        getInFaultInterceptors().add(MAP_CODEC);
+        getInFaultInterceptors().add(mapCodec);
 
         getOutFaultInterceptors().add(MAP_AGGREGATOR);
-        getOutFaultInterceptors().add(MAP_CODEC);
+        getOutFaultInterceptors().add(mapCodec);
     }
 
 }
diff --git a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
index 0b10aba733..d0d8410df9 100644
--- a/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
+++ b/rt/ws/addr/src/main/java/org/apache/cxf/ws/addressing/soap/MAPCodec.java
@@ -40,6 +40,7 @@ import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 
+import org.apache.cxf.Bus;
 import org.apache.cxf.binding.soap.SoapFault;
 import org.apache.cxf.binding.soap.SoapHeader;
 import org.apache.cxf.binding.soap.SoapMessage;
@@ -76,7 +77,8 @@ import org.apache.cxf.ws.addressing.VersionTransformer.Names200408;
  * Properties for {outgo|incom}ing messages.
  */
 public class MAPCodec extends AbstractSoapInterceptor {
-
+    public static final MAPCodec INSTANCE = new MAPCodec();
+    
     private static final Logger LOG = LogUtils.getL7dLogger(MAPCodec.class);
     private static final String IS_REFERENCE_PARAM_ATTR_NAME = "IsReferenceParameter";
     private static final ResourceBundle BUNDLE = LOG.getResourceBundle();
@@ -101,6 +103,22 @@ public class MAPCodec extends AbstractSoapInterceptor {
         transformer = new VersionTransformer(this);
     }
 
+    public static synchronized MAPCodec getInstance(Bus bus) {
+        MAPCodec mc = bus.getExtension(MAPCodec.class);
+        if (mc == null) {
+            return createMAPCodec(bus);
+        }
+        return mc;
+    }
+    private static synchronized MAPCodec createMAPCodec(Bus bus) {
+        MAPCodec mc = bus.getExtension(MAPCodec.class);
+        if (mc == null) {
+            bus.setExtension(new MAPCodec(), MAPCodec.class);
+            mc = bus.getExtension(MAPCodec.class);
+        }
+        return mc;
+    }
+    
     public Map<String, Exchange> getUncorrelatedExchanges() {
         return uncorrelatedExchanges;
     }
diff --git a/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/impl/MAPAggregatorTest.java b/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/impl/MAPAggregatorTest.java
index 07614dbaa4..df62735575 100644
--- a/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/impl/MAPAggregatorTest.java
+++ b/rt/ws/addr/src/test/java/org/apache/cxf/ws/addressing/impl/MAPAggregatorTest.java
@@ -625,11 +625,15 @@ public class MAPAggregatorTest extends Assert {
             srArgs.fault = args.fault;
             srArgs.noMessageId = args.noMessageId;
 
+            Endpoint endpoint = control.createMock(Endpoint.class);
+            exchange.getEndpoint();
+            EasyMock.expectLastCall().andReturn(endpoint).anyTimes();
+
             setUpResponder(message,
                            exchange,
-                           srArgs);
+                           srArgs, 
+                           endpoint);
 
-            Endpoint endpoint = control.createMock(Endpoint.class);
             endpoint.getOutInterceptors();
             EasyMock.expectLastCall().andReturn(new ArrayList<Interceptor<? extends Message>>()).anyTimes();
             Service serv = control.createMock(Service.class);
@@ -637,8 +641,6 @@ public class MAPAggregatorTest extends Assert {
             EasyMock.expectLastCall().andReturn(serv).anyTimes();
             serv.getOutInterceptors();
             EasyMock.expectLastCall().andReturn(new ArrayList<Interceptor<? extends Message>>()).anyTimes();
-            exchange.getEndpoint();
-            EasyMock.expectLastCall().andReturn(endpoint).anyTimes();
         }
         control.replay();
         return message;
@@ -729,7 +731,8 @@ public class MAPAggregatorTest extends Assert {
 
     private void setUpResponder(Message message,
                                 Exchange exchange,
-                                SetupResponderArgs args) throws Exception {
+                                SetupResponderArgs args,
+                                Endpoint endpoint) throws Exception {
 
         setUpMessageProperty(message,
                              REQUESTOR_ROLE,
@@ -763,7 +766,7 @@ public class MAPAggregatorTest extends Assert {
         if (!args.outbound) {
             setUpOneway(message, exchange, args.oneway);
             if (args.oneway || args.decoupled) {
-                setUpRebase(message, exchange);
+                setUpRebase(message, exchange, endpoint);
             }
         }
 
@@ -792,7 +795,7 @@ public class MAPAggregatorTest extends Assert {
                                  maps);
             if (args.fault) {
                 // REVISIT test double rebase does not occur
-                setUpRebase(message, exchange);
+                setUpRebase(message, exchange, endpoint);
             }
             expectedTo = args.decoupled
                          ? args.fault
@@ -814,14 +817,11 @@ public class MAPAggregatorTest extends Assert {
         }
     }
 
-    private void setUpRebase(Message message, Exchange exchange)
+    private void setUpRebase(Message message, Exchange exchange, Endpoint endpoint)
         throws Exception {
         setUpMessageProperty(message,
                              "org.apache.cxf.ws.addressing.partial.response.sent",
                              Boolean.FALSE);
-        Endpoint endpoint = control.createMock(Endpoint.class);
-        exchange.getEndpoint();
-        EasyMock.expectLastCall().andReturn(endpoint);
         Binding binding = control.createMock(Binding.class);
         endpoint.getBinding();
         EasyMock.expectLastCall().andReturn(binding).anyTimes();
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/Proxy.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/Proxy.java
index dd32b16a39..feb5a2f4e1 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/Proxy.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/Proxy.java
@@ -47,7 +47,9 @@ import org.apache.cxf.transport.Conduit;
 import org.apache.cxf.workqueue.SynchronousExecutor;
 import org.apache.cxf.ws.addressing.AttributedURIType;
 import org.apache.cxf.ws.addressing.EndpointReferenceType;
+import org.apache.cxf.ws.addressing.MAPAggregator;
 import org.apache.cxf.ws.addressing.RelatesToType;
+import org.apache.cxf.ws.addressing.WSAddressingFeature;
 import org.apache.cxf.ws.rm.manager.SourcePolicyType;
 import org.apache.cxf.ws.rm.v200702.CloseSequenceType;
 import org.apache.cxf.ws.rm.v200702.CreateSequenceResponseType;
@@ -359,7 +361,12 @@ public class Proxy {
             }
         };
         RMClient client = new RMClient(bus, endpoint, cs);
+        // WS-RM requires ws-addressing
+        WSAddressingFeature wsa = new WSAddressingFeature();
+        wsa.setAddressingRequired(true);
+        wsa.initialize(client, bus);
         Map<String, Object> context = client.getRequestContext();
+        context.put(MAPAggregator.ADDRESSING_NAMESPACE, protocol.getWSANamespace());
         context.put(RMManager.WSRM_VERSION_PROPERTY, protocol.getWSRMNamespace());
         context.put(RMManager.WSRM_WSA_VERSION_PROPERTY, protocol.getWSANamespace());
         return client;
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMCaptureOutInterceptor.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMCaptureOutInterceptor.java
index ab2d426a89..19f43d8b09 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMCaptureOutInterceptor.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMCaptureOutInterceptor.java
@@ -112,6 +112,8 @@ public class RMCaptureOutInterceptor extends AbstractRMInterceptor<Message>  {
         if (null != maps.getAction()) {
             action = maps.getAction().getValue();
         }
+        //make sure we use the appropriate namespace
+        maps.exposeAs(wsaNamespace);
 
         if (LOG.isLoggable(Level.FINE)) {
             LOG.fine("Action: " + action);
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMOutInterceptor.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMOutInterceptor.java
index d1d4c32066..57772e38be 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMOutInterceptor.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/RMOutInterceptor.java
@@ -76,6 +76,8 @@ public class RMOutInterceptor extends AbstractRMInterceptor<Message>  {
         if (null != maps.getAction()) {
             action = maps.getAction().getValue();
         }
+        //make sure we use the appropriate namespace
+        maps.exposeAs(wsaNamespace);
 
         if (LOG.isLoggable(Level.FINE)) {
             LOG.fine("Action: " + action);
diff --git a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImpl.java b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImpl.java
index 668fc61d7b..1a8ff69a75 100644
--- a/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImpl.java
+++ b/rt/ws/rm/src/main/java/org/apache/cxf/ws/rm/soap/RetransmissionQueueImpl.java
@@ -439,6 +439,7 @@ public class RetransmissionQueueImpl implements RetransmissionQueue {
             AttributedURIType to = null;
             if (null != maps) {
                 to = maps.getTo();
+                maps.exposeAs(cfg.getAddressingNamespace());
             }
             if (to != null  && RMUtils.getAddressingConstants().getAnonymousURI().equals(to.getValue())) {
                 LOG.log(Level.INFO, "Cannot resend to anonymous target.  Not scheduling a resend.");
@@ -796,7 +797,7 @@ public class RetransmissionQueueImpl implements RetransmissionQueue {
             }
 
             // set message addressing properties
-            AddressingProperties maps = new MAPCodec().unmarshalMAPs(message);
+            AddressingProperties maps = MAPCodec.getInstance(message.getExchange().getBus()).unmarshalMAPs(message);
             RMContextUtils.storeMAPs(maps, message, true, MessageUtils.isRequestor(message));
             AttributedURIType to = null;
             if (null != maps) {
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/ProxyTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/ProxyTest.java
index a43dc7d3bd..52f69b0837 100644
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/ProxyTest.java
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/ProxyTest.java
@@ -29,6 +29,7 @@ import org.apache.cxf.Bus;
 import org.apache.cxf.endpoint.Client;
 import org.apache.cxf.endpoint.ConduitSelector;
 import org.apache.cxf.endpoint.Endpoint;
+import org.apache.cxf.interceptor.InterceptorProvider;
 import org.apache.cxf.jaxb.DatatypeFactory;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.message.ExchangeImpl;
@@ -45,6 +46,8 @@ import org.apache.cxf.ws.addressing.AttributedURIType;
 import org.apache.cxf.ws.addressing.EndpointReferenceType;
 import org.apache.cxf.ws.addressing.Names;
 import org.apache.cxf.ws.addressing.RelatesToType;
+import org.apache.cxf.ws.addressing.WSAddressingFeature;
+import org.apache.cxf.ws.addressing.WSAddressingFeature.WSAddressingFeatureApplier;
 import org.apache.cxf.ws.rm.manager.SourcePolicyType;
 import org.apache.cxf.ws.rm.v200702.Identifier;
 import org.apache.cxf.ws.rm.v200702.OfferType;
@@ -290,6 +293,12 @@ public class ProxyTest extends Assert {
     public void testRMClientConstruction() {
         Proxy proxy = new Proxy(rme);
         Bus bus = control.createMock(Bus.class);
+        EasyMock.expect(bus.getExtension(WSAddressingFeatureApplier.class))
+            .andReturn(new WSAddressingFeatureApplier() {
+                @Override
+                public void initializeProvider(WSAddressingFeature feature, InterceptorProvider provider,
+                                               Bus bus) {
+                } }).anyTimes();
         Endpoint endpoint = control.createMock(Endpoint.class);
         Conduit conduit = control.createMock(Conduit.class);
         org.apache.cxf.ws.addressing.EndpointReferenceType address =
diff --git a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMManagerTest.java b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMManagerTest.java
index a566e6046a..1ee2effb02 100644
--- a/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMManagerTest.java
+++ b/rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMManagerTest.java
@@ -309,15 +309,18 @@ public class RMManagerTest extends Assert {
     public void testGetReliableEndpointExisting() throws NoSuchMethodException, RMException {
         Method m1 = RMManager.class.getDeclaredMethod("createReliableEndpoint",
             new Class[] {Endpoint.class});
-        manager = control.createMock(RMManager.class, new Method[] {m1});
+        Method m2 = RMManager.class.getDeclaredMethod("getEffectiveConfiguration",
+                                                      new Class[] {Message.class});
+        manager = control.createMock(RMManager.class, new Method[] {m1, m2});
         manager.setReliableEndpointsMap(new HashMap<Endpoint, RMEndpoint>());
         Message message = control.createMock(Message.class);
+        Exchange exchange = control.createMock(Exchange.class);
+        EasyMock.expect(message.getExchange()).andReturn(exchange).anyTimes();
+        
         RMConfiguration config = new RMConfiguration();
         config.setRMNamespace(RM10Constants.NAMESPACE_URI);
         config.setRM10AddressingNamespace(RM10Constants.NAMESPACE_URI);
         EasyMock.expect(manager.getEffectiveConfiguration(message)).andReturn(config).anyTimes();
-        Exchange exchange = control.createMock(Exchange.class);
-        EasyMock.expect(message.getExchange()).andReturn(exchange);
         Endpoint endpoint = control.createMock(Endpoint.class);
         EasyMock.expect(exchange.getEndpoint()).andReturn(endpoint);
         EndpointInfo ei = control.createMock(EndpointInfo.class);
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/clustering/FailoverAddressOverrideTest.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/clustering/FailoverAddressOverrideTest.java
index f61d4f2d5f..a350db677e 100644
--- a/systests/uncategorized/src/test/java/org/apache/cxf/systest/clustering/FailoverAddressOverrideTest.java
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/clustering/FailoverAddressOverrideTest.java
@@ -240,7 +240,7 @@ public class FailoverAddressOverrideTest extends AbstractBusClientServerTestBase
     protected void enableWSAForCurrentEndpoint() {
         Endpoint provider = ClientProxy.getClient(greeter).getEndpoint();
         mapAggregator = new MAPAggregator();
-        mapCodec = new MAPCodec();
+        mapCodec = MAPCodec.getInstance(ClientProxy.getClient(greeter).getBus());
         provider.getInInterceptors().add(mapAggregator);
         provider.getInInterceptors().add(mapCodec);
 
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/clustering/FailoverTest.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/clustering/FailoverTest.java
index af09d8f82c..87822ba99d 100644
--- a/systests/uncategorized/src/test/java/org/apache/cxf/systest/clustering/FailoverTest.java
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/clustering/FailoverTest.java
@@ -447,7 +447,7 @@ public class FailoverTest extends AbstractBusClientServerTestBase {
     protected void enableWSAForCurrentEndpoint() {
         Endpoint provider = ClientProxy.getClient(greeter).getEndpoint();
         mapAggregator = new MAPAggregator();
-        mapCodec = new MAPCodec();
+        mapCodec = MAPCodec.getInstance(ClientProxy.getClient(greeter).getBus());
         provider.getInInterceptors().add(mapAggregator);
         provider.getInInterceptors().add(mapCodec);
 
diff --git a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/ControlImpl.java b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/ControlImpl.java
index 7365067d01..45f78d5eca 100644
--- a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/ControlImpl.java
+++ b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/ControlImpl.java
@@ -40,8 +40,7 @@ import org.w3c.dom.Node;
 import org.apache.cxf.BusFactory;
 import org.apache.cxf.bus.spring.SpringBusFactory;
 import org.apache.cxf.common.logging.LogUtils;
-import org.apache.cxf.ext.logging.LoggingInInterceptor;
-import org.apache.cxf.ext.logging.LoggingOutInterceptor;
+import org.apache.cxf.ext.logging.LoggingFeature;
 import org.apache.cxf.helpers.XPathUtils;
 import org.apache.cxf.staxutils.StaxUtils;
 
@@ -69,11 +68,9 @@ public class ControlImpl  extends org.apache.cxf.greeter_control.ControlImpl {
         LOG.info("Initialised bus " + greeterBus + " with cfg file resource: " + cfgResource);
         LOG.fine("greeterBus inInterceptors: " + greeterBus.getInInterceptors());
 
-        LoggingInInterceptor logIn = new LoggingInInterceptor();
-        LoggingOutInterceptor logOut = new LoggingOutInterceptor();
-        greeterBus.getInInterceptors().add(logIn);
-        greeterBus.getOutInterceptors().add(logOut);
-        greeterBus.getOutFaultInterceptors().add(logOut);
+        LoggingFeature lf = new LoggingFeature();
+        lf.setPrettyLogging(true);
+        lf.initialize(greeterBus);
 
         if (cfgResource.indexOf("provider") == -1) {
             endpoint = Endpoint.publish(address, implementor);
diff --git a/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/WSRM12ServerCycleTest.java b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/WSRM12ServerCycleTest.java
new file mode 100644
index 0000000000..64e0b64140
--- /dev/null
+++ b/systests/ws-rm/src/test/java/org/apache/cxf/systest/ws/rm/WSRM12ServerCycleTest.java
@@ -0,0 +1,180 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.ws.rm;
+
+import java.io.Closeable;
+
+import javax.xml.ws.Endpoint;
+import javax.xml.ws.soap.AddressingFeature;
+
+import org.apache.cxf.Bus;
+import org.apache.cxf.BusFactory;
+import org.apache.cxf.bus.spring.SpringBusFactory;
+import org.apache.cxf.ext.logging.LoggingFeature;
+import org.apache.cxf.greeter_control.Control;
+import org.apache.cxf.greeter_control.ControlService;
+import org.apache.cxf.greeter_control.Greeter;
+import org.apache.cxf.greeter_control.GreeterService;
+import org.apache.cxf.systest.ws.util.ConnectionHelper;
+import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
+import org.apache.cxf.testutil.common.AbstractBusTestServerBase;
+import org.apache.cxf.ws.rm.RMManager;
+import org.apache.cxf.ws.rm.feature.RMFeature;
+import org.apache.cxf.ws.rm.manager.AcksPolicyType;
+import org.apache.cxf.ws.rm.manager.DestinationPolicyType;
+import org.apache.cxf.ws.rm.persistence.jdbc.RMTxStore;
+import org.apache.cxf.ws.rmp.v200502.RMAssertion;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+
+/**
+ * 
+ */
+public class WSRM12ServerCycleTest extends AbstractBusClientServerTestBase {
+    public static final String PORT = allocatePort(WSRM12ServerCycleTest.class);
+    private static final String CFG = "/org/apache/cxf/systest/ws/rm/persistent.xml";
+
+    private static final long DEFAULT_BASE_RETRANSMISSION_INTERVAL = 4000L;
+    private static final long DEFAULT_ACKNOWLEDGEMENT_INTERVAL = 2000L;
+
+    public static class Server extends AbstractBusTestServerBase {
+        String port;
+        String pfx;
+        Endpoint ep;
+        public Server(String args[]) {
+            port = args[0];
+            pfx = args[1];
+        }
+
+        protected void run()  {
+            SpringBusFactory factory = new SpringBusFactory();
+            Bus bus = factory.createBus();
+            BusFactory.setDefaultBus(bus);
+            setBus(bus);
+
+            //System.out.println("Created control bus " + bus);
+            ControlImpl implementor = new ControlImpl();
+            implementor.setDbName(pfx + "-server");
+            implementor.setAddress("http://localhost:" + port + "/SoapContext/GreeterPort");
+            GreeterImpl greeterImplementor = new GreeterImpl();
+            implementor.setImplementor(greeterImplementor);
+            ep = Endpoint.publish("http://localhost:" + port + "/SoapContext/ControlPort", implementor);
+            BusFactory.setDefaultBus(null);
+            BusFactory.setThreadDefaultBus(null);
+        }
+        public void tearDown() {
+            ep.stop();
+            ep = null;
+        }
+        public static void main(String args[]) {
+            new Server(args).start();
+        }
+    }
+
+
+    @BeforeClass
+    public static void setUpBeforeClass() throws Exception {
+        RMTxStore.deleteDatabaseFiles("cxf7392-recovery", true);
+        RMTxStore.deleteDatabaseFiles("cxf7392-greeter", true);
+        assertTrue("server did not launch correctly",
+                   launchServer(Server.class, null, new String[] {PORT, "cxf7392"}, true));
+
+    }
+    
+    private String getPrefix() { 
+        return "cxf7392";
+    }
+    
+    public static RMFeature wsrm() {
+        return wsrm(DEFAULT_BASE_RETRANSMISSION_INTERVAL, DEFAULT_ACKNOWLEDGEMENT_INTERVAL);
+    }
+
+    public static RMFeature wsrm(long brtxInterval, long ackInterval) {
+        RMAssertion.BaseRetransmissionInterval baseRetransmissionInterval 
+            = new RMAssertion.BaseRetransmissionInterval();
+        baseRetransmissionInterval.setMilliseconds(Long.valueOf(brtxInterval));
+        RMAssertion.AcknowledgementInterval acknowledgementInterval = new RMAssertion.AcknowledgementInterval();
+        acknowledgementInterval.setMilliseconds(Long.valueOf(ackInterval));
+
+        RMAssertion rmAssertion = new RMAssertion();
+        rmAssertion.setAcknowledgementInterval(acknowledgementInterval);
+        rmAssertion.setBaseRetransmissionInterval(baseRetransmissionInterval);
+
+        AcksPolicyType acksPolicy = new AcksPolicyType();
+        acksPolicy.setIntraMessageThreshold(0);
+        DestinationPolicyType destinationPolicy = new DestinationPolicyType();
+        destinationPolicy.setAcksPolicy(acksPolicy);
+
+        RMFeature feature = new RMFeature();
+        feature.setRMAssertion(rmAssertion);
+        feature.setDestinationPolicy(destinationPolicy);
+        //feature.setRMNamespace(RM11Constants.NAMESPACE_URI);
+
+        return feature;
+    }
+
+    
+
+    @Test
+    public void testCXF7392() throws Exception {
+        SpringBusFactory bf = new SpringBusFactory();
+        bus = bf.createBus();
+        BusFactory.setDefaultBus(bus);
+        ControlService cs = new ControlService();
+        Control control = cs.getControlPort();
+        ConnectionHelper.setKeepAliveConnection(control, false, true);
+        updateAddressPort(control, PORT);
+
+        Assert.assertTrue("Failed to start greeter", control.startGreeter(CFG));
+
+        System.setProperty("db.name", getPrefix() + "-recovery");
+        Bus greeterBus = new SpringBusFactory().createBus();
+        System.clearProperty("db.name");
+        BusFactory.setDefaultBus(greeterBus);
+
+        // avoid early client resends
+        greeterBus.getExtension(RMManager.class).getConfiguration()
+            .setBaseRetransmissionInterval(new Long(60000));
+        GreeterService gs = new GreeterService();
+        Greeter greeter = gs.getGreeterPort(new LoggingFeature(), new AddressingFeature(), wsrm());
+        updateAddressPort(greeter, PORT);
+
+        greeter.greetMe("one");
+        greeter.greetMe("two");
+        greeter.greetMe("three");
+
+
+        control.stopGreeter(CFG);
+        control.startGreeter(CFG);
+        
+        // this will cause an exception as the sequence is no longer valid
+        //greeter.greetMe("four");
+        
+
+        ((Closeable)greeter).close();
+        greeterBus.shutdown(true);
+        control.stopGreeter(CFG);
+        bus.shutdown(true);
+    }
+
+}
diff --git a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/policy/NestedAddressingPolicyTest.java b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/policy/NestedAddressingPolicyTest.java
index 1bacd366f3..9dd0603988 100644
--- a/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/policy/NestedAddressingPolicyTest.java
+++ b/systests/ws-specs/src/test/java/org/apache/cxf/systest/ws/policy/NestedAddressingPolicyTest.java
@@ -127,7 +127,7 @@ public class NestedAddressingPolicyTest extends AbstractBusClientServerTestBase
         updateAddressPort(greeter, PORT);
         LoggingInInterceptor in = new LoggingInInterceptor();
         LoggingOutInterceptor out = new LoggingOutInterceptor();
-        MAPCodec mapCodec = new MAPCodec();
+        MAPCodec mapCodec = MAPCodec.getInstance(bus);
         MAPAggregatorImpl mapAggregator = new MAPAggregatorImpl();
 
         bus.getInInterceptors().add(in);
