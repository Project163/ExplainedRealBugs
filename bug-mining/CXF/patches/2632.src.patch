diff --git a/core/src/main/java/org/apache/cxf/common/util/URIParserUtil.java b/core/src/main/java/org/apache/cxf/common/util/URIParserUtil.java
index 8372db0e13..8170709bbf 100644
--- a/core/src/main/java/org/apache/cxf/common/util/URIParserUtil.java
+++ b/core/src/main/java/org/apache/cxf/common/util/URIParserUtil.java
@@ -290,4 +290,78 @@ public final class URIParserUtil {
             return normalize(arg);
         }
     }
+    
+    public static String relativize(String base, String toBeRelativized) throws URISyntaxException {
+        if (base == null || toBeRelativized == null) {
+            return null;
+        }
+        return relativize(new URI(base), new URI(toBeRelativized));
+    }
+
+    /**
+     * This is a custom implementation for doing what URI.relativize(URI uri) should be
+     * doing but is not actually doing when URI roots do not fully match.
+     * See http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6226081
+     * 
+     * @param base              The base URI
+     * @param toBeRelativized   The URI to be realivized
+     * @return                  The string value of the URI you'd expect to get as result
+     *                          of calling baseURI.relativize(toBeRelativizedURI).
+     *                          null is returned if the parameters are null or are not
+     *                          both absolute or not absolute.
+     * @throws URISyntaxException
+     */
+    public static String relativize(URI baseURI, URI toBeRelativizedURI) throws URISyntaxException {
+        if (baseURI == null || toBeRelativizedURI == null) {
+            return null;
+        }
+        if (baseURI.isAbsolute() ^ toBeRelativizedURI.isAbsolute()) {
+            return null;
+        }
+        final String base = baseURI.getSchemeSpecificPart();
+        final String toBeRelativized = toBeRelativizedURI.getSchemeSpecificPart();
+        final int l1 = base.length();
+        final int l2 = toBeRelativized.length();
+        if (l1 == 0) {
+            return toBeRelativized;
+        }
+        int slashes = 0;
+        StringBuilder sb = new StringBuilder();
+        boolean differenceFound = false;
+        for (int i = 0; i < l1; i++) {
+            char c = base.charAt(i);
+            if (i < l2) {
+                if (!differenceFound && c == toBeRelativized.charAt(i)) {
+                    sb.append(c);
+                } else {
+                    differenceFound = true;
+                    if (c == '/') {
+                        slashes++;
+                    }
+                }
+            } else {
+                if (c == '/') {
+                    slashes++;
+                }
+            }
+        }
+        String rResolved = new URI(getRoot(sb.toString())).relativize(new URI(toBeRelativized)).toString();
+        StringBuilder relativizedPath = new StringBuilder();
+        for (int i = 0; i < slashes; i++) {
+            relativizedPath.append("../");
+        }
+        relativizedPath.append(rResolved);
+        return relativizedPath.toString();
+    }
+
+    private static String getRoot(String uri) {
+        int idx = uri.lastIndexOf('/');
+        if (idx == uri.length() - 1) {
+            return uri;
+        } else if (idx == -1) {
+            return "";
+        } else {
+            return uri.substring(0, idx + 1);
+        }
+    }
 }
diff --git a/core/src/test/java/org/apache/cxf/common/util/URIParserUtilsTest.java b/core/src/test/java/org/apache/cxf/common/util/URIParserUtilsTest.java
new file mode 100644
index 0000000000..2d92315023
--- /dev/null
+++ b/core/src/test/java/org/apache/cxf/common/util/URIParserUtilsTest.java
@@ -0,0 +1,54 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.common.util;
+
+import java.net.URISyntaxException;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+
+public class URIParserUtilsTest extends Assert {
+    
+    @Test
+    public void testRelativize() throws URISyntaxException {
+        assertNull(URIParserUtil.relativize(null, "foo"));
+        assertNull(URIParserUtil.relativize("foo", null));
+        assertEquals("", URIParserUtil.relativize("", ""));
+        assertEquals("", URIParserUtil.relativize("fds", ""));
+        assertEquals("../", URIParserUtil.relativize("fds/", ""));
+        assertEquals("fdsfs", URIParserUtil.relativize("", "fdsfs"));
+        assertEquals("fdsfs/a", URIParserUtil.relativize("", "fdsfs/a"));
+        assertEquals("../de", URIParserUtil.relativize("ab/cd", "de"));
+        assertEquals("../de/fe/gh", URIParserUtil.relativize("ab/cd", "de/fe/gh"));
+        assertEquals("../../../de/fe/gh", URIParserUtil.relativize("/abc/def/", "de/fe/gh"));
+        assertNull(URIParserUtil.relativize("file:/c:/abc/def/", "de/fe/gh")); // null as the URI obtained by
+                                                                               // the 2 strings are not both
+                                                                               // absolute or not absolute
+        assertEquals("pippo2.xsd", URIParserUtil.relativize("/abc/def/pippo1.xsd", "/abc/def/pippo2.xsd"));
+        assertEquals("../default/pippo2.xsd",
+                     URIParserUtil.relativize("/abc/def/pippo1.xsd", "/abc/default/pippo2.xsd"));
+        assertEquals("def/pippo2.xsd", URIParserUtil.relativize("/abc/def", "/abc/def/pippo2.xsd"));
+        assertEquals("hello_world_schema2.xsd",
+                     URIParserUtil.relativize("jar:file:/home/a.jar!/wsdl/others/",
+                                              "jar:file:/home/a.jar!/wsdl/others/hello_world_schema2.xsd"));
+    }
+
+}
diff --git a/rt/frontend/simple/src/main/java/org/apache/cxf/frontend/WSDLGetUtils.java b/rt/frontend/simple/src/main/java/org/apache/cxf/frontend/WSDLGetUtils.java
index 95d019781c..2579cf815b 100644
--- a/rt/frontend/simple/src/main/java/org/apache/cxf/frontend/WSDLGetUtils.java
+++ b/rt/frontend/simple/src/main/java/org/apache/cxf/frontend/WSDLGetUtils.java
@@ -59,7 +59,7 @@ import org.apache.cxf.catalog.OASISCatalogManager;
 import org.apache.cxf.catalog.OASISCatalogManagerHelper;
 import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.common.util.StringUtils;
-import org.apache.cxf.common.util.UrlUtils;
+import org.apache.cxf.common.util.URIParserUtil;
 import org.apache.cxf.helpers.CastUtils;
 import org.apache.cxf.helpers.DOMUtils;
 import org.apache.cxf.message.Message;
@@ -149,7 +149,7 @@ public class WSDLGetUtils {
             } else if (params.get("xsd") != null) {
                 String xsd = URLDecoder.decode(params.get("xsd"), "utf-8");
                 doc = readXSDDocument(bus, xsd, smp, base);
-                updateDoc(doc, base, mp, smp, message, xsd, null);
+                updateDoc(doc, base, mp, smp, message, xsd);
             }
         } catch (WSDLQueryException wex) {
             throw wex;
@@ -192,6 +192,7 @@ public class WSDLGetUtils {
         return null;
     }
 
+    @Deprecated
     protected void updateDoc(Document doc,
                              String base,
                              Map<String, Definition> mp,
@@ -199,6 +200,15 @@ public class WSDLGetUtils {
                              Message message,
                              String xsd,
                              String wsdl) {
+        updateDoc(doc, base, mp, smp, message, xsd != null ? xsd : wsdl);
+    }
+
+    protected void updateDoc(Document doc,
+                             String base,
+                             Map<String, Definition> mp,
+                             Map<String, SchemaReference> smp,
+                             Message message,
+                             String xsdWsdlPar) {
         Bus bus = message.getExchange().getBus();
         List<Element> elementList = null;
 
@@ -207,7 +217,7 @@ public class WSDLGetUtils {
                                                               "http://www.w3.org/2001/XMLSchema", "import");
             for (Element el : elementList) {
                 String sl = el.getAttribute("schemaLocation");
-                sl = mapUri(bus, base, smp, sl, xsd);
+                sl = mapUri(bus, base, smp, sl, xsdWsdlPar);
                 if (sl != null) {
                     el.setAttribute("schemaLocation", sl);
                 }
@@ -218,7 +228,7 @@ public class WSDLGetUtils {
                                                               "include");
             for (Element el : elementList) {
                 String sl = el.getAttribute("schemaLocation");
-                sl = mapUri(bus, base, smp, sl, xsd);
+                sl = mapUri(bus, base, smp, sl, xsdWsdlPar);
                 if (sl != null) {
                     el.setAttribute("schemaLocation", sl);
                 }
@@ -228,7 +238,7 @@ public class WSDLGetUtils {
                                                               "redefine");
             for (Element el : elementList) {
                 String sl = el.getAttribute("schemaLocation");
-                sl = mapUri(bus, base, smp, sl, xsd);
+                sl = mapUri(bus, base, smp, sl, xsdWsdlPar);
                 if (sl != null) {
                     el.setAttribute("schemaLocation", sl);
                 }
@@ -239,7 +249,7 @@ public class WSDLGetUtils {
             for (Element el : elementList) {
                 String sl = el.getAttribute("location");
                 try {
-                    sl = getLocationURI(sl, wsdl);
+                    sl = getLocationURI(sl, xsdWsdlPar);
                 } catch (URISyntaxException e) {
                     //ignore
                 }
@@ -402,8 +412,7 @@ public class WSDLGetUtils {
             for (ExtensibilityElement el
                 : CastUtils.cast(types.getExtensibilityElements(), ExtensibilityElement.class)) {
                 if (el instanceof Schema) {
-                    Schema see = (Schema)el;
-                    updateSchemaImports(bus, see, see.getDocumentBaseURI(), doneSchemas, base);
+                    updateSchemaImports(bus, (Schema)el, docBase, doneSchemas, base);
                 }
             }
         }
@@ -493,15 +502,17 @@ public class WSDLGetUtils {
                             } catch (MalformedURLException e) {
                                 if (doneSchemas.put(decodedStart, imp) == null) {
                                     putResolvedSchemaLocationIfRelative(doneSchemas, decodedStart, imp);
-                                    updateSchemaImports(bus, imp.getReferencedSchema(), docBase,
-                                                        doneSchemas, base);
+                                    updateSchemaImports(bus, imp.getReferencedSchema(), start, doneSchemas, base);
                                 }
                             }
                         } else {
                             if (doneSchemas.put(decodedStart, imp) == null) {
                                 doneSchemas.put(resolvedSchemaLocation, imp);
-                                doneSchemas.put(imp.getSchemaLocationURI(), imp);
-                                updateSchemaImports(bus, imp.getReferencedSchema(), docBase, doneSchemas, base);
+                                String p = getAndSaveRelativeSchemaLocationIfCatalogResolved(doneSchemas,
+                                                                                             resolvedSchemaLocation,
+                                                                                             schema,
+                                                                                             imp);
+                                updateSchemaImports(bus, imp.getReferencedSchema(), p, doneSchemas, base);
                             }
                         }
                     }
@@ -535,7 +546,7 @@ public class WSDLGetUtils {
                         } catch (MalformedURLException e) {
                             if (doneSchemas.put(decodedStart, included) == null) {
                                 putResolvedSchemaLocationIfRelative(doneSchemas, decodedStart, included);
-                                updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);
+                                updateSchemaImports(bus, included.getReferencedSchema(), start, doneSchemas, base);
                             }
                         }
                     }
@@ -543,7 +554,11 @@ public class WSDLGetUtils {
                     || !doneSchemas.containsKey(resolvedSchemaLocation)) {
                     doneSchemas.put(decodedStart, included);
                     doneSchemas.put(resolvedSchemaLocation, included);
-                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);
+                    String p = getAndSaveRelativeSchemaLocationIfCatalogResolved(doneSchemas,
+                                                                                 resolvedSchemaLocation,
+                                                                                 schema,
+                                                                                 included);
+                    updateSchemaImports(bus, included.getReferencedSchema(), p, doneSchemas, base);
                 }
             }
         }
@@ -573,7 +588,7 @@ public class WSDLGetUtils {
                         } catch (MalformedURLException e) {
                             if (doneSchemas.put(decodedStart, included) == null) {
                                 putResolvedSchemaLocationIfRelative(doneSchemas, decodedStart, included);
-                                updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);
+                                updateSchemaImports(bus, included.getReferencedSchema(), start, doneSchemas, base);
                             }
                         }
                     }
@@ -581,12 +596,60 @@ public class WSDLGetUtils {
                     || !doneSchemas.containsKey(resolvedSchemaLocation)) {
                     doneSchemas.put(decodedStart, included);
                     doneSchemas.put(resolvedSchemaLocation, included);
-                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);
+                    String p = getAndSaveRelativeSchemaLocationIfCatalogResolved(doneSchemas,
+                                                                                 resolvedSchemaLocation,
+                                                                                 schema,
+                                                                                 included);
+                    updateSchemaImports(bus, included.getReferencedSchema(), p, doneSchemas, base);
                 }
             }
         }
     }
 
+    /**
+     * When the imported schema location has been resolved through catalog, we need to:
+     * 1) get a valid relative location to use for recursion into the imported schema
+     * 2) add an entry to the doneSchemas map using such a valid relative location, as that's
+     *    what will be used later for import links
+     * 
+     * The valid relative location for the imported schema is computed by first obtaining the
+     * relative uri that maps the importing schema resolved location into the imported schema
+     * resolved location, then such value is resolved on top of the valid relative location
+     * that's saved in the doneSchemas map for the importing schema.
+     * 
+     * @param doneSchemas
+     * @param resolvedSchemaLocation
+     * @param currentSchema
+     * @param schemaReference
+     * @return
+     */
+    private String getAndSaveRelativeSchemaLocationIfCatalogResolved(Map<String, SchemaReference> doneSchemas,
+                                                                     String resolvedSchemaLocation,
+                                                                     Schema currentSchema,
+                                                                     SchemaReference schemaReference) {
+        String path = null;
+        for (Map.Entry<String, SchemaReference> entry : doneSchemas.entrySet()) {
+            Schema rs = entry.getValue().getReferencedSchema();
+            String k = entry.getKey();
+            String rsURI = rs.getDocumentBaseURI();
+            if (currentSchema.equals(rs) && !rsURI.equals(k)) {
+                try {
+                    String p = URIParserUtil.relativize(rsURI, resolvedSchemaLocation);
+                    if (p != null) {
+                        path = new URI(k).resolve(p).toString();
+                        break;
+                    }
+                } catch (URISyntaxException e) {
+                    // ignore
+                }
+            }
+        }
+        if (path != null) {
+            doneSchemas.put(path, schemaReference);
+        }
+        return path;
+    }
+
     /**
      * If given decodedStart is relative path, resolves a real location of given schema and puts it into schema map.
      *
@@ -610,13 +673,9 @@ public class WSDLGetUtils {
                                       SchemaReference imp,
                                       String docBase) {
         String schemaLocationURI = imp.getSchemaLocationURI();
-        if (docBase != null && imp.getReferencedSchema() != null) {
+        if (docBase != null && schemaLocationURI != null) {
             try {
-                String baseURI = URLDecoder.decode(UrlUtils.getStem(docBase), "utf-8");
-                String importURI = URLDecoder.decode(imp.getReferencedSchema().getDocumentBaseURI(), "utf-8");
-                if (importURI.contains(baseURI)) {
-                    schemaLocationURI = importURI.substring(baseURI.length() + 1);
-                }
+                schemaLocationURI = getLocationURI(schemaLocationURI, docBase);
             } catch (Exception e) {
                 //ignore
             }
@@ -671,7 +730,7 @@ public class WSDLGetUtils {
             doc = wsdlWriter.getDocument(def);
         }
 
-        updateDoc(doc, epurl, mp, smp, message, null, wsdl);
+        updateDoc(doc, epurl, mp, smp, message, wsdl);
         return doc;
     }
 
diff --git a/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/OASISCatalogTest.java b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/OASISCatalogTest.java
index 32455177fa..c82666876b 100644
--- a/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/OASISCatalogTest.java
+++ b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/OASISCatalogTest.java
@@ -82,7 +82,7 @@ public class OASISCatalogTest extends Assert {
         assertTrue(result, result.contains("xsd=http://apache.org/hello_world/types2/hello_world_schema2.xsd"));
 
         result = readUrl("http://localhost:" + PORT + "/SoapContext/SoapPort"
-                + "?wsdl=testutils/others/hello_world_messages_catalog.wsdl");
+                + "?wsdl=hello_world_messages_catalog.wsdl");
         assertTrue(result, result.contains("xsd=hello_world_schema.xsd"));
 
         ep.stop();
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/SayHiImpl2.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/SayHiImpl2.java
new file mode 100644
index 0000000000..b10fed6f25
--- /dev/null
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/SayHiImpl2.java
@@ -0,0 +1,64 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.schemaimport;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.jws.WebMethod;
+import javax.jws.WebParam;
+import javax.jws.WebResult;
+import javax.jws.WebService;
+import javax.xml.ws.RequestWrapper;
+import javax.xml.ws.ResponseWrapper;
+
+@WebService(targetNamespace = "http://apache.org/sayHi", name = "SayHi", 
+            wsdlLocation = "classpath:/wsdl_systest/e/sayHi.wsdl", 
+            endpointInterface = "org.apache.cxf.systest.schemaimport.SayHi")
+public class SayHiImpl2 implements SayHi {
+
+    @Override
+    @WebResult(name = "return", targetNamespace = "")
+    @RequestWrapper(localName = "sayHiArray", 
+                    targetNamespace = "http://apache.org/sayHi2", 
+                    className = "org.apache.sayhi2.SayHiArray")
+    @WebMethod
+    @ResponseWrapper(localName = "sayHiArrayResponse", 
+                     targetNamespace = "http://apache.org/sayHi2", 
+                     className = "org.apache.sayhi2.SayHiArrayResponse")
+    public List<String> sayHiArray(@WebParam(name = "arg0", targetNamespace = "") List<String> arg0) {
+        List<String> list = new ArrayList<String>();
+        list.add("Hi");
+        return list;
+    }
+
+    @Override
+    @WebResult(name = "return", targetNamespace = "http://apache.org/sayHi1")
+    @RequestWrapper(localName = "sayHi", 
+                    targetNamespace = "http://apache.org/sayHi1", 
+                    className = "org.apache.sayhi1.SayHi")
+    @WebMethod
+    @ResponseWrapper(localName = "sayHiResponse", 
+                     targetNamespace = "http://apache.org/sayHi1", 
+                     className = "org.apache.sayhi1.SayHiResponse")
+    public String sayHi(@WebParam(name = "arg0", targetNamespace = "http://apache.org/sayHi1") String arg0) {
+        return "Hi";
+    }
+
+}
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/SchemaImportTest.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/SchemaImportTest.java
index b73ff933d3..11da342f5d 100644
--- a/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/SchemaImportTest.java
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/SchemaImportTest.java
@@ -48,6 +48,20 @@ public class SchemaImportTest extends AbstractBusClientServerTestBase {
         }
     }
 
+    @Test
+    public void testImportSchema2() throws Exception {
+        String schemaURL = "http://localhost:" + PORT + "/schemaimport/sayHi2"
+                           + "?xsd=../sayhi/sayhi/sayhi-schema1.xsd";
+        URL url = new URL(schemaURL);
+        try (InputStream ins = url.openStream()) {
+            String output = IOUtils.toString(ins);
+            assertTrue(output.indexOf("sayHiArray") > -1);
+        } catch (Exception e) {
+            e.printStackTrace();
+            fail("Can not access the import schema");
+        }
+    }
+
     @Test
     public void testImportWsdl() throws Exception {
         String wsdlURL = "http://localhost:" + PORT + "/schemaimport/sayHi"  + "?wsdl=sayhi/sayhi/a.wsdl";
@@ -61,8 +75,21 @@ public class SchemaImportTest extends AbstractBusClientServerTestBase {
 
         }
     }
-    
-    
+
+    @Test
+    public void testImportWsdl2() throws Exception {
+        String wsdlURL = "http://localhost:" + PORT + "/schemaimport/sayHi2" + "?wsdl=../sayhi/sayhi/a.wsdl";
+        URL url = new URL(wsdlURL);
+        try (InputStream ins = url.openStream()) {
+            String output = IOUtils.toString(ins);
+            assertTrue(output.indexOf("sayHiArray") > -1);
+        } catch (Exception e) {
+            e.printStackTrace();
+            fail("Can not access the import wsdl");
+
+        }
+    }
+
     @Test
     public void testAnotherSchemaImportl() throws Exception {
         String schemaURL = "http://localhost:" + PORT + "/schemaimport/service"  + "?xsd=schema1.xsd";
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/Server.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/Server.java
index 7d0643d34e..30668c582f 100644
--- a/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/Server.java
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/schemaimport/Server.java
@@ -38,6 +38,9 @@ public class Server extends AbstractBusTestServerBase {
         Object implementor3 = new ServiceImpl();
         String address3 = "http://localhost:" + PORT + "/schemainclude/service";
         Endpoint.publish(address3, implementor3);
+        Object implementor4 = new SayHiImpl2();
+        String address4 = "http://localhost:" + PORT + "/schemaimport/sayHi2";
+        Endpoint.publish(address4, implementor4);
     }
 
     public static void main(String[] args) {
diff --git a/systests/uncategorized/src/test/resources/wsdl_systest/e/sayHi.wsdl b/systests/uncategorized/src/test/resources/wsdl_systest/e/sayHi.wsdl
new file mode 100644
index 0000000000..f6b50a3625
--- /dev/null
+++ b/systests/uncategorized/src/test/resources/wsdl_systest/e/sayHi.wsdl
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+ 
+  http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+<definitions xmlns:tns="http://apache.org/sayHi" xmlns:sayhi1="http://apache.org/sayHi1" xmlns:sayhi2="http://apache.org/sayHi2" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns="http://schemas.xmlsoap.org/wsdl/" targetNamespace="http://apache.org/sayHi" name="SayHiService">
+    <import namespace="http://apache.org/sayHi" location="../sayhi/a.wsdl"/>
+    <types>
+        <xsd:schema>
+            <xsd:import namespace="http://apache.org/sayHi1" schemaLocation="../sayhi/sayhi-schema1.xsd"/>
+        </xsd:schema>
+    </types>
+    <portType name="SayHi">
+        <operation name="sayHi">
+            <input message="tns:sayHi"/>
+            <output message="tns:sayHiResponse"/>
+        </operation>
+        <operation name="sayHiArray">
+            <input message="tns:sayHiArray"/>
+            <output message="tns:sayHiArrayResponse"/>
+        </operation>
+    </portType>    
+    <binding name="SayHiPortBinding" type="tns:SayHi">
+        <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/>
+        <operation name="sayHi">
+            <soap:operation soapAction=""/>
+            <input>
+                <soap:body use="literal"/>
+            </input>
+            <output>
+                <soap:body use="literal"/>
+            </output>
+        </operation>
+        <operation name="sayHiArray">
+            <soap:operation soapAction=""/>
+            <input>
+                <soap:body use="literal"/>
+            </input>
+            <output>
+                <soap:body use="literal"/>
+            </output>
+        </operation>
+    </binding>
+    <service name="SayHiService">
+        <port name="SayHiPort" binding="tns:SayHiPortBinding">
+            <soap:address location="http://localhost:9090/sayHi2"/>
+        </port>
+    </service>
+</definitions>
diff --git a/testutils/src/main/resources/wsdl/others/hello_world_bindings_catalog.wsdl b/testutils/src/main/resources/wsdl/others/hello_world_bindings_catalog.wsdl
index c6b58ff729..2ede002e81 100644
--- a/testutils/src/main/resources/wsdl/others/hello_world_bindings_catalog.wsdl
+++ b/testutils/src/main/resources/wsdl/others/hello_world_bindings_catalog.wsdl
@@ -18,7 +18,7 @@ specific language governing permissions and limitations
 under the License.
 -->
 <wsdl:definitions xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:x2="http://apache.org/hello_world" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="HelloWorld" targetNamespace="http://apache.org/hello_world/bindings">
-    <wsdl:import namespace="http://apache.org/hello_world" location="testutils/others/hello_world_wsdl_import_catalog.wsdl"/>
+    <wsdl:import namespace="http://apache.org/hello_world" location="hello_world_wsdl_import_catalog.wsdl"/>
     <wsdl:binding name="SOAPBinding" type="x2:Greeter">
         <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
         <wsdl:operation name="sayHi">
diff --git a/testutils/src/main/resources/wsdl/others/hello_world_services_catalog.wsdl b/testutils/src/main/resources/wsdl/others/hello_world_services_catalog.wsdl
index 0a0588ee22..fac32b24ca 100644
--- a/testutils/src/main/resources/wsdl/others/hello_world_services_catalog.wsdl
+++ b/testutils/src/main/resources/wsdl/others/hello_world_services_catalog.wsdl
@@ -18,7 +18,7 @@ specific language governing permissions and limitations
 under the License.
 -->
 <wsdl:definitions xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:tns="http://apache.org/hello_world/services" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:x1="http://apache.org/hello_world/bindings" xmlns:x2="http://apache.org/hello_world" name="HelloWorld" targetNamespace="http://apache.org/hello_world/services">
-    <wsdl:import namespace="http://apache.org/hello_world/bindings" location="testutils/others/hello_world_bindings_catalog.wsdl"/>
+    <wsdl:import namespace="http://apache.org/hello_world/bindings" location="hello_world_bindings_catalog.wsdl"/>
     <wsdl:service name="SOAPService">
         <wsdl:port name="SoapPort" binding="x1:SOAPBinding">
             <soap:address location="http://localhost:9000/SoapContext/SoapPort"/>
diff --git a/testutils/src/main/resources/wsdl/others/hello_world_wsdl_import_catalog.wsdl b/testutils/src/main/resources/wsdl/others/hello_world_wsdl_import_catalog.wsdl
index 636e46efe3..23a03c99d7 100644
--- a/testutils/src/main/resources/wsdl/others/hello_world_wsdl_import_catalog.wsdl
+++ b/testutils/src/main/resources/wsdl/others/hello_world_wsdl_import_catalog.wsdl
@@ -18,7 +18,7 @@
   under the License.
 -->
 <wsdl:definitions xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://apache.org/hello_world" xmlns:x1="http://apache.org/hello_world/messages" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="HelloWorldImport" targetNamespace="http://apache.org/hello_world">
-    <wsdl:import namespace="http://apache.org/hello_world/messages" location="testutils/others/hello_world_messages_catalog.wsdl"/>
+    <wsdl:import namespace="http://apache.org/hello_world/messages" location="hello_world_messages_catalog.wsdl"/>
     <wsdl:portType name="Greeter">
         <wsdl:operation name="sayHi">
             <wsdl:input message="x1:sayHiRequest"/>
