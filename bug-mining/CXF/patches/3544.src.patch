diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Messages.properties b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Messages.properties
index aea4a57c7e..8d5e174d3e 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Messages.properties
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/Messages.properties
@@ -25,6 +25,7 @@ COULD_NOT_VALIDATE_SOAP_HEADER_CAUSED_BY=Could not validate soapheader caused by
 MUST_UNDERSTAND=MustUnderstand headers: {0} are not understood.
 PARSER_EXC=Could not create DOM DocumentBuilder.
 NO_OPERATION=No such operation: {0}
+NO_SOAP_BODY=No soap body
 ATTACHMENT_IO=Attachment IO Exception: {0}
 INVALID_VERSION="{0}", the namespace on the "{1}" element, is not a valid SOAP version.
 INVALID_11_VERSION=A SOAP 1.2 message is not valid when sent to a SOAP 1.1 only endpoint.
@@ -34,4 +35,4 @@ NO_NAMESPACE=No namespace on "{0}" element. You must send a SOAP message.
 BP_2211_RPCLIT_CANNOT_BE_NULL=Cannot write part {0}. RPC/Literal parts cannot be null. (WS-I BP R2211)
 UNKNOWN_RPC_LIT_PART=Found element {0} but could not find matching RPC/Literal part
 SOAP_ACTION_MISMATCH=The given SOAPAction {0} does not match an operation.
-SOAP_ACTION_MISMATCH_OP=The given SOAPAction {0} does not match the received operation {1}.
\ No newline at end of file
+SOAP_ACTION_MISMATCH_OP=The given SOAPAction {0} does not match the received operation {1}.
diff --git a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/ReadHeadersInterceptor.java b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/ReadHeadersInterceptor.java
index 3426d880eb..3f96558faf 100644
--- a/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/ReadHeadersInterceptor.java
+++ b/rt/bindings/soap/src/main/java/org/apache/cxf/binding/soap/interceptor/ReadHeadersInterceptor.java
@@ -218,13 +218,20 @@ public class ReadHeadersInterceptor extends AbstractSoapInterceptor {
                     }
                 }
 
+                List<Element> soapBody = null; 
                 // Find header
                 if (doc != null) {
                     Element element = doc.getDocumentElement();
                     QName header = soapVersion.getHeader();
+                    QName body = soapVersion.getBody();
                     List<Element> elemList = DOMUtils.findAllElementsByTagNameNS(element,
                                                                                  header.getNamespaceURI(),
                                                                                  header.getLocalPart());
+                    soapBody = new ArrayList<Element>();      
+                    soapBody = DOMUtils.getChildrenWithName(element,
+                                                                                 body.getNamespaceURI(),
+                                                                                 body.getLocalPart());
+                    
                     for (Element elem : elemList) {
                         Element hel = DOMUtils.getFirstElement(elem);
                         while (hel != null) {
@@ -286,6 +293,11 @@ public class ReadHeadersInterceptor extends AbstractSoapInterceptor {
                 if (ServiceUtils.isSchemaValidationEnabled(SchemaValidationType.IN, message)) {
                     message.getInterceptorChain().add(new CheckClosingTagsInterceptor());
                 }
+                if (ServiceUtils.isSchemaValidationEnabled(SchemaValidationType.IN, message)
+                    && soapBody != null && soapBody.isEmpty()) {
+                    throw new SoapFault(new Message("NO_SOAP_BODY", LOG, "no soap body"),
+                                        soapVersion.getSender());
+                }
             }
         } catch (XMLStreamException e) {
             throw new SoapFault(new Message("XML_STREAM_EXC", LOG, e.getMessage()), e,
