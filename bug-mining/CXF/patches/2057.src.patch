diff --git a/core/src/main/java/org/apache/cxf/common/util/ReflectionUtil.java b/core/src/main/java/org/apache/cxf/common/util/ReflectionUtil.java
index 3d54418567..6b418954c1 100644
--- a/core/src/main/java/org/apache/cxf/common/util/ReflectionUtil.java
+++ b/core/src/main/java/org/apache/cxf/common/util/ReflectionUtil.java
@@ -123,8 +123,20 @@ public final class ReflectionUtil {
                     return null;
                 }
             }
-        });
-        
+        });      
+    }
+    
+    public static <T> Constructor<T>[] getDeclaredConstructors(final Class<T> cls) {
+        return AccessController.doPrivileged(new PrivilegedAction<Constructor<T>[]>() {
+            @SuppressWarnings("unchecked")
+            public Constructor<T>[] run() {
+                try {
+                    return (Constructor<T>[])cls.getDeclaredConstructors();
+                } catch (SecurityException e) {
+                    return null;
+                } 
+            }
+        });      
     }
     
     public static Method[] getDeclaredMethods(final Class<?> cls) {
diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java
index 4b7d5f05c5..826522496c 100644
--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java
+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java
@@ -21,6 +21,7 @@ package org.apache.cxf.jaxb;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Method;
@@ -31,6 +32,7 @@ import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
 
 import javax.xml.bind.annotation.XmlAccessType;
@@ -46,6 +48,10 @@ import javax.xml.namespace.QName;
 
 import org.apache.cxf.common.classloader.ClassLoaderUtils;
 import org.apache.cxf.common.jaxb.JAXBUtils;
+import org.apache.cxf.common.util.ASMHelper;
+import org.apache.cxf.common.util.ASMHelper.ClassWriter;
+import org.apache.cxf.common.util.ASMHelper.MethodVisitor;
+import org.apache.cxf.common.util.ASMHelper.Opcodes;
 import org.apache.cxf.common.util.ReflectionUtil;
 import org.apache.cxf.common.util.StringUtils;
 import org.apache.cxf.service.ServiceModelVisitor;
@@ -63,13 +69,16 @@ class JAXBContextInitializer extends ServiceModelVisitor {
     private Set<Class<?>> classes;
     private Collection<Object> typeReferences;
     private Set<Class<?>> globalAdapters = new HashSet<Class<?>>();
+    private Map<String, Object> unmarshallerProperties;
 
     public JAXBContextInitializer(ServiceInfo serviceInfo,
                                   Set<Class<?>> classes,
-                                  Collection<Object> typeReferences) {
+                                  Collection<Object> typeReferences, 
+                                  Map<String, Object> unmarshallerProperties) {
         super(serviceInfo);
         this.classes = classes;
         this.typeReferences = typeReferences;
+        this.unmarshallerProperties = unmarshallerProperties;
     }
 
     @Override
@@ -267,18 +276,24 @@ class JAXBContextInitializer extends ServiceModelVisitor {
     }
 
 
-    void addClass(Class<?> cls) {
-        if (Throwable.class.isAssignableFrom(cls)) {
-            if (!Throwable.class.equals(cls)
-                && !Exception.class.equals(cls)) {
-                walkReferences(cls);
+    void addClass(Class<?> claz) {
+        if (Throwable.class.isAssignableFrom(claz)) {
+            if (!Throwable.class.equals(claz)
+                && !Exception.class.equals(claz)) {
+                walkReferences(claz);
             }
             addClass(String.class);
-        } else if (cls.getName().startsWith("java.")
-            || cls.getName().startsWith("javax.")) {
+        } else if (claz.getName().startsWith("java.")
+            || claz.getName().startsWith("javax.")) {
             return;
         } else {
-            cls = JAXBUtils.getValidClass(cls);
+            Class<?> cls = JAXBUtils.getValidClass(claz);
+            if (cls == null && ReflectionUtil.getDeclaredConstructors(claz).length > 0) {
+                //there is no init(), but other constructors
+                Object factory = createFactory(claz, ReflectionUtil.getDeclaredConstructors(claz)[0]);
+                unmarshallerProperties.put("com.sun.xml.bind.ObjectFactory", factory);
+                cls = claz;
+            }
             if (null != cls) {
                 if (classes.contains(cls)) {
                     return;
@@ -315,7 +330,7 @@ class JAXBContextInitializer extends ServiceModelVisitor {
                 if (!cls.isInterface()) {
                     walkReferences(cls);
                 }
-            }
+            } 
         }
     }
     
@@ -502,4 +517,55 @@ class JAXBContextInitializer extends ServiceModelVisitor {
         return null;
     }
     
+    @SuppressWarnings("unused") 
+    private Object createFactory(Class<?> cls, Constructor<?> contructor) {       
+        String newClassName = cls.getName() + "Factory";
+        ASMHelper helper = new ASMHelper();
+        ClassWriter cw = helper.createClassWriter();
+        MethodVisitor mv;
+
+        cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER,
+                 ASMHelper.periodToSlashes(newClassName), null, "java/lang/Object", null);
+
+        cw.visitSource(cls.getSimpleName() + "Factory" + ".java", null);
+
+        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null);
+        mv.visitCode();
+        mv.visitVarInsn(Opcodes.ALOAD, 0);
+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
+        mv.visitInsn(Opcodes.RETURN);
+        mv.visitMaxs(1, 1);
+        mv.visitEnd();
+
+        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, "create" + cls.getSimpleName(),
+                            "()L" + ASMHelper.periodToSlashes(cls.getName()) + ";", null, null);
+        mv.visitCode();
+        String name = cls.getName().replace(".", "/");
+        mv.visitTypeInsn(Opcodes.NEW, name);
+        mv.visitInsn(Opcodes.DUP);
+        StringBuilder paraString = new StringBuilder("(");
+       
+        for (Class<?> paraClass : contructor.getParameterTypes()) {
+            mv.visitInsn(Opcodes.ACONST_NULL);
+            paraString.append("Ljava/lang/Object;");      
+        }
+        paraString.append(")V");
+
+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, name, "<init>", paraString.toString());
+
+        mv.visitInsn(Opcodes.ARETURN);
+        mv.visitMaxs(1, 1);
+        mv.visitEnd();
+
+        cw.visitEnd();
+        Class<?> factoryClass = helper.loadClass(newClassName, cls, cw.toByteArray());
+        try {
+            return factoryClass.newInstance();
+        } catch (Exception e) {
+           //ignore
+        } 
+        return null;
+    }
+    
+    
 }
\ No newline at end of file
diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBDataBinding.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBDataBinding.java
index 8b4ccae12c..067d8f0ac0 100644
--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBDataBinding.java
+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBDataBinding.java
@@ -304,9 +304,12 @@ public class JAXBDataBinding extends AbstractInterceptorProvidingDataBinding
 
 
         contextClasses = new LinkedHashSet<Class<?>>();
+        Map<String, Object> unmarshallerProps = new HashMap<String, Object>();
+        this.setUnmarshallerProperties(unmarshallerProps);
         for (ServiceInfo serviceInfo : service.getServiceInfos()) {
+            
             JAXBContextInitializer initializer
-                = new JAXBContextInitializer(serviceInfo, contextClasses, typeRefs);
+                = new JAXBContextInitializer(serviceInfo, contextClasses, typeRefs, this.getUnmarshallerProperties());
             initializer.walk();
             if (serviceInfo.getProperty("extra.class") != null) {
                 Set<Class<?>> exClasses = serviceInfo.getProperty("extra.class", Set.class);
diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBSchemaInitializer.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBSchemaInitializer.java
index bacb48af33..d64e096a17 100644
--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBSchemaInitializer.java
+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBSchemaInitializer.java
@@ -26,6 +26,7 @@ import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -546,9 +547,13 @@ class JAXBSchemaInitializer extends ServiceModelVisitor {
             if ((type == null) && (f.getGenericType() instanceof ParameterizedType)) {
                 type = f.getGenericType();
             }
-            JAXBBeanInfo beanInfo = getBeanInfo(type);
-            if (beanInfo != null) {
-                addElement(schema, seq, beanInfo, new QName(namespace, f.getName()), isArray(type));
+            if (generateGenericType(type)) {
+                buildGenericElements(schema, seq, f);
+            } else {
+                JAXBBeanInfo beanInfo = getBeanInfo(type);
+                if (beanInfo != null) {
+                    addElement(schema, seq, beanInfo, new QName(namespace, f.getName()), isArray(type));
+                }
             }
         }
         for (Method m : Utils.getGetters(cls, accessType)) {
@@ -560,12 +565,17 @@ class JAXBSchemaInitializer extends ServiceModelVisitor {
             if ((type == null) && (m.getGenericReturnType() instanceof ParameterizedType)) {
                 type = m.getGenericReturnType();
             }
-            JAXBBeanInfo beanInfo = getBeanInfo(type);
-            if (beanInfo != null) {
-                int idx = m.getName().startsWith("get") ? 3 : 2;
-                String name = m.getName().substring(idx);
-                name = Character.toLowerCase(name.charAt(0)) + name.substring(1);
-                addElement(schema, seq, beanInfo, new QName(namespace, name), isArray(type));
+            
+            if (generateGenericType(type)) {
+                buildGenericElements(schema, seq, m, type);
+            } else {
+                JAXBBeanInfo beanInfo = getBeanInfo(type);
+                if (beanInfo != null) {
+                    int idx = m.getName().startsWith("get") ? 3 : 2;
+                    String name = m.getName().substring(idx);
+                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);
+                    addElement(schema, seq, beanInfo, new QName(namespace, name), isArray(type));
+                }
             }
         }
         // Create element in xsd:sequence for Exception.class
@@ -597,6 +607,106 @@ class JAXBSchemaInitializer extends ServiceModelVisitor {
         part.setProperty(JAXBDataBinding.class.getName() + ".CUSTOM_EXCEPTION", Boolean.TRUE);
     }
     
+    private boolean generateGenericType(Type type) {
+        if (type instanceof ParameterizedType) {
+            ParameterizedType paramType = (ParameterizedType)type;
+            if (paramType.getActualTypeArguments().length > 1) {
+                return true;
+
+            }
+        }
+        return false;
+    }
+    
+    private void buildGenericElements(XmlSchema schema, XmlSchemaSequence seq, Field f) {
+        XmlSchemaComplexType generics = new XmlSchemaComplexType(schema, true);
+        Type type = f.getGenericType();
+        String rawType = ((ParameterizedType)type).getRawType().toString();
+        String typeName = StringUtils.uncapitalize(rawType.substring(rawType.lastIndexOf(".") + 1));
+        generics.setName(typeName);
+
+        Class<?> genericsClass = f.getType();
+        buildGenericSeq(schema, generics, genericsClass);   
+
+        String name = Character.toLowerCase(f.getName().charAt(0)) + f.getName().substring(1);
+        XmlSchemaElement newel = new XmlSchemaElement(schema, false);
+        newel.setName(name);
+        newel.setSchemaTypeName(generics.getQName());
+        newel.setMinOccurs(0);
+        if (!seq.getItems().contains(newel)) {
+            seq.getItems().add(newel);
+        }
+    }
+     
+    private void buildGenericElements(XmlSchema schema, XmlSchemaSequence seq, Method m, Type type) {       
+        String rawType = ((ParameterizedType)type).getRawType().toString();
+        String typeName = StringUtils.uncapitalize(rawType.substring(rawType.lastIndexOf(".") + 1));
+        
+        XmlSchemaComplexType generics = (XmlSchemaComplexType)schema.getTypeByName(typeName);        
+        if (generics == null) {
+            generics =  new XmlSchemaComplexType(schema, true);
+            generics.setName(typeName);
+        }
+        
+        Class<?> genericsClass = m.getReturnType();
+        buildGenericSeq(schema, generics, genericsClass);  
+          
+        int idx = m.getName().startsWith("get") ? 3 : 2;
+        String name = m.getName().substring(idx);
+        name = Character.toLowerCase(name.charAt(0)) + name.substring(1);
+        XmlSchemaElement newel = new XmlSchemaElement(schema, false);
+        newel.setName(name);
+        newel.setSchemaTypeName(generics.getQName());
+        newel.setMinOccurs(0);
+        if (!seq.getItems().contains(newel)) {
+            seq.getItems().add(newel);
+        }
+    }
+    
+    private void buildGenericSeq(XmlSchema schema, XmlSchemaComplexType generics, Class<?> genericsClass) {
+        XmlSchemaSequence genericsSeq = new XmlSchemaSequence();
+        generics.setParticle(genericsSeq);
+        XmlAccessType  accessType = Utils.getXmlAccessType(genericsClass);
+        
+        for (Field f : Utils.getFields(genericsClass, accessType)) {
+            if (f.getGenericType() instanceof TypeVariable) {               
+                String genericName = Character.toLowerCase(f.getName().charAt(0)) + f.getName().substring(1);
+                XmlSchemaElement genericEle = new XmlSchemaElement(schema, false);
+                genericEle.setName(genericName);
+                genericEle.setMinOccurs(0);
+                JAXBBeanInfo anyBean = getBeanInfo(context, f.getType()); 
+                Iterator<QName> itr = anyBean.getTypeNames().iterator();
+                if (!itr.hasNext()) {
+                    return;
+                }
+                QName typeName = itr.next();
+                genericEle.setSchemaTypeName(typeName);
+                genericsSeq.getItems().add(genericEle);
+            }
+        }
+               
+        for (Method genericMethod : Utils.getGetters(genericsClass, accessType)) {
+            if (genericMethod.getGenericReturnType() instanceof TypeVariable) {
+                int idx = genericMethod.getName().startsWith("get") ? 3 : 2;
+                String genericName = genericMethod.getName().substring(idx);
+                genericName = Character.toLowerCase(genericName.charAt(0)) + genericName.substring(1);
+                XmlSchemaElement genericEle = new XmlSchemaElement(schema, false);
+                genericEle.setName(genericName);
+                genericEle.setMinOccurs(0);
+                JAXBBeanInfo anyBean = getBeanInfo(context, genericMethod.getReturnType()); 
+                Iterator<QName> itr = anyBean.getTypeNames().iterator();
+                if (!itr.hasNext()) {
+                    return;
+                }
+                QName typeName = itr.next();
+                genericEle.setSchemaTypeName(typeName);
+                genericsSeq.getItems().add(genericEle);
+            }
+            
+        } 
+    }
+    
+    
     static boolean isArray(Type cls) {
         if (cls instanceof Class) {
             return ((Class<?>)cls).isArray();
diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/Utils.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/Utils.java
index 241b75ab2a..40de666954 100644
--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/Utils.java
+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/Utils.java
@@ -205,7 +205,8 @@ final class Utils {
 
     static Class<?> getFieldType(Field f) {
         XmlJavaTypeAdapter adapter = getFieldXJTA(f);
-        if (adapter == null && f.getGenericType() instanceof ParameterizedType) {
+        if (adapter == null && f.getGenericType() instanceof ParameterizedType
+            && ((ParameterizedType)f.getGenericType()).getActualTypeArguments().length == 1) {
             return null;
         }
         Class<?> adapterType = (Class<?>)getTypeFromXmlAdapter(adapter);
@@ -217,7 +218,8 @@ final class Utils {
         // if there is no adapter, yet we have a collection make sure
         // we return the Generic type; if there is an annotation let the
         // adapter handle what gets populated
-        if (adapter == null && m.getGenericReturnType() instanceof ParameterizedType) {
+        if (adapter == null && m.getGenericReturnType() instanceof ParameterizedType 
+            && ((ParameterizedType)m.getGenericReturnType()).getActualTypeArguments().length < 2) {
             return null;
         }
         Class<?> adapterType = (Class<?>)getTypeFromXmlAdapter(adapter);
diff --git a/rt/databinding/jaxb/src/test/java/org/apache/cxf/jaxb/JAXBDataBindingTest.java b/rt/databinding/jaxb/src/test/java/org/apache/cxf/jaxb/JAXBDataBindingTest.java
index 393f3cc58a..791525f4e5 100644
--- a/rt/databinding/jaxb/src/test/java/org/apache/cxf/jaxb/JAXBDataBindingTest.java
+++ b/rt/databinding/jaxb/src/test/java/org/apache/cxf/jaxb/JAXBDataBindingTest.java
@@ -227,7 +227,8 @@ public class JAXBDataBindingTest extends Assert {
     public void testResursiveType() throws Exception {
         Set<Class<?>> classes = new HashSet<Class<?>>();
         Collection<Object> typeReferences = new ArrayList<Object>();
-        JAXBContextInitializer init = new JAXBContextInitializer(null, classes, typeReferences);
+        Map<String, Object> props = new HashMap<String, Object>();
+        JAXBContextInitializer init = new JAXBContextInitializer(null, classes, typeReferences, props);
         init.addClass(Type2.class);
         assertEquals(2, classes.size());
     }
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericExceptionTest.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericExceptionTest.java
new file mode 100644
index 0000000000..512a04cc39
--- /dev/null
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericExceptionTest.java
@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.exception;
+
+import java.io.InputStream;
+import java.net.URL;
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.Service;
+import javax.xml.ws.soap.SOAPBinding;
+
+import org.apache.cxf.helpers.IOUtils;
+import org.apache.cxf.testutil.common.AbstractBusClientServerTestBase;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class GenericExceptionTest extends AbstractBusClientServerTestBase {
+    public static final String PORT = "9001";
+        //Server.PORT;
+    private final QName serviceName = new QName("http://cxf.apache.org/test/HelloService", "HelloService");
+
+    @BeforeClass
+    public static void startServers() throws Exception {
+        //assertTrue("server did not launch correctly", launchServer(Server.class));
+
+    }
+
+    @Test
+    public void testGenericException() throws Exception {
+        String address = "http://localhost:" + PORT + "/generic";
+        URL wsdlURL = new URL(address + "?wsdl");
+        //check wsdl element
+        InputStream ins = wsdlURL.openStream();
+        String wsdlContent = IOUtils.toString(ins).replaceAll("  ", " ");
+
+        int objIndex = wsdlContent
+            .indexOf("type=\"tns:objectWithGenerics\"/>");
+        int aIndex = wsdlContent.indexOf("name=\"a\" type=\"xs:anyType\"/>");
+        int bIndex = wsdlContent.indexOf("name=\"b\" type=\"xs:anyType\"/>");
+
+        assertTrue(objIndex > -1);
+        assertTrue(aIndex > -1);
+        assertTrue(bIndex > -1);
+        
+        
+        Service service = Service.create(wsdlURL, serviceName);
+        service.addPort(new QName("http://cxf.apache.org/test/HelloService", "HelloPort"),
+                        SOAPBinding.SOAP11HTTP_BINDING, address);
+        GenericsEcho port = service
+            .getPort(new QName("http://cxf.apache.org/test/HelloService", "HelloPort"), GenericsEcho.class);
+        try {
+            port.echo("test");
+            fail("Exception is expected");
+        } catch (GenericsException e) {
+            ObjectWithGenerics<Boolean, Integer> genericObj = e.getObj();
+            assertEquals(true, genericObj.getA());
+            assertEquals(100, genericObj.getB().intValue());
+        }
+
+    }
+
+}
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericsEcho.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericsEcho.java
new file mode 100644
index 0000000000..5e72bac5ef
--- /dev/null
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericsEcho.java
@@ -0,0 +1,29 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.exception;
+
+import javax.jws.WebService;
+
+import org.apache.cxf.annotations.Logging;
+
+@WebService(targetNamespace = "http://cxf.apache.org/test/HelloService", name = "HelloService")
+@Logging
+public interface GenericsEcho {
+    String echo(String request) throws GenericsException;
+}
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericsEchoImpl.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericsEchoImpl.java
new file mode 100644
index 0000000000..6d536f99b1
--- /dev/null
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericsEchoImpl.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.exception;
+
+import javax.jws.WebService;
+
+@WebService(serviceName = "HelloService", 
+            portName = "HelloPort", 
+            endpointInterface = "org.apache.cxf.systest.exception.GenericsEcho", 
+            targetNamespace = "http://cxf.apache.org/test/HelloService")
+public class GenericsEchoImpl {
+    public String echo(String request) throws GenericsException {
+        GenericsException exception = new GenericsException();
+        ObjectWithGenerics<Boolean, Integer> objs = 
+            new ObjectWithGenerics<Boolean, Integer>(Boolean.TRUE, new Integer(100));
+        exception.setObj(objs);
+        throw exception;
+    }
+
+}
\ No newline at end of file
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericsException.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericsException.java
new file mode 100644
index 0000000000..f0f8064f10
--- /dev/null
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/GenericsException.java
@@ -0,0 +1,34 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.exception;
+
+@javax.xml.ws.WebFault
+public class GenericsException extends Exception {
+    private static final long serialVersionUID = 1L;
+
+    private ObjectWithGenerics<Boolean, Integer> obj;
+
+    public ObjectWithGenerics<Boolean, Integer> getObj() {
+        return obj;
+    }
+
+    public void setObj(ObjectWithGenerics<Boolean, Integer> obj) {
+        this.obj = obj;
+    }
+}
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/ObjectWithGenerics.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/ObjectWithGenerics.java
new file mode 100644
index 0000000000..dc811bd987
--- /dev/null
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/ObjectWithGenerics.java
@@ -0,0 +1,47 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.systest.exception;
+
+public class ObjectWithGenerics<A, B> {
+
+    private A a;
+    private B b;
+    
+    
+    public ObjectWithGenerics(A aa, B bb) {
+        this.a = aa;
+        this.b = bb;
+    }
+
+    public A getA() {
+        return a;
+    }
+    
+    public void setA(A a) {
+        this.a = a;
+    }
+    
+    public B getB() {
+        return b;
+    }
+    
+    public void setB(B b) {
+        this.b = b;
+    }
+}
diff --git a/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/Server.java b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/Server.java
new file mode 100644
index 0000000000..89ee02a85c
--- /dev/null
+++ b/systests/uncategorized/src/test/java/org/apache/cxf/systest/exception/Server.java
@@ -0,0 +1,46 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.cxf.systest.exception;
+
+import javax.xml.ws.Endpoint;
+
+import org.apache.cxf.testutil.common.AbstractBusTestServerBase;
+
+public class Server extends AbstractBusTestServerBase {
+    public static final String PORT = allocatePort(Server.class);
+
+    protected void run()  {
+        Object implementor = new GenericsEchoImpl();
+        String address = "http://localhost:" + PORT + "/generic";
+        Endpoint.publish(address, implementor);
+    }
+
+    public static void main(String[] args) {
+        try {
+            Server s = new Server();
+            s.start();
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            System.exit(-1);
+        } finally {
+            System.out.println("done!");
+        }
+    }
+}
