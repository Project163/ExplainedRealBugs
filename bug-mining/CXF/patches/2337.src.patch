diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/BinaryDataProvider.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/BinaryDataProvider.java
index 8fd4becb4f..431f6fe0de 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/BinaryDataProvider.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/BinaryDataProvider.java
@@ -47,6 +47,7 @@ import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.helpers.FileUtils;
 import org.apache.cxf.helpers.IOUtils;
 import org.apache.cxf.jaxrs.impl.HttpHeadersImpl;
+import org.apache.cxf.jaxrs.utils.ExceptionUtils;
 import org.apache.cxf.message.Message;
 import org.apache.cxf.message.MessageUtils;
 import org.apache.cxf.phase.PhaseInterceptorChain;
@@ -70,36 +71,44 @@ public class BinaryDataProvider<T> extends AbstractConfigurableProvider
     public T readFrom(Class<T> clazz, Type genericType, Annotation[] annotations, MediaType type, 
                            MultivaluedMap<String, String> headers, InputStream is)
         throws IOException {
-        if (InputStream.class.isAssignableFrom(clazz)) {
-            return clazz.cast(is);
-        }
-        if (Reader.class.isAssignableFrom(clazz)) {
-            return clazz.cast(new InputStreamReader(is, getEncoding(type)));
-        }
-        if (byte[].class.isAssignableFrom(clazz)) {
-            String enc = getCharset(type);
-            if (enc == null) {
-                return clazz.cast(IOUtils.readBytesFromStream(is));
-            } else {
-                return clazz.cast(IOUtils.toString(is, enc).getBytes(enc));
+        try {
+            if (InputStream.class.isAssignableFrom(clazz)) {
+                return clazz.cast(is);
             }
-        }
-        if (File.class.isAssignableFrom(clazz)) {
-            LOG.warning("Reading data into File objects with the help of pre-packaged" 
-                + " providers is not recommended - use InputStream or custom File reader");
-            // create a temp file, delete on exit
-            File f = FileUtils.createTempFile("File" + UUID.randomUUID().toString(), 
-                                              "jaxrs",
-                                              null,
-                                              true);
-            FileOutputStream fos = new FileOutputStream(f);
-            IOUtils.copy(is, fos);
-            fos.close();
-            return clazz.cast(f);
+            if (Reader.class.isAssignableFrom(clazz)) {
+                return clazz.cast(new InputStreamReader(is, getEncoding(type)));
+            }
+            if (byte[].class.isAssignableFrom(clazz)) {
+                String enc = getCharset(type);
+                if (enc == null) {
+                    return clazz.cast(IOUtils.readBytesFromStream(is));
+                } else {
+                    return clazz.cast(IOUtils.toString(is, enc).getBytes(enc));
+                }
+            }
+            if (File.class.isAssignableFrom(clazz)) {
+                LOG.warning("Reading data into File objects with the help of pre-packaged" 
+                    + " providers is not recommended - use InputStream or custom File reader");
+                // create a temp file, delete on exit
+                File f = FileUtils.createTempFile("File" + UUID.randomUUID().toString(), 
+                                                  "jaxrs",
+                                                  null,
+                                                  true);
+                FileOutputStream fos = new FileOutputStream(f);
+                IOUtils.copy(is, fos);
+                fos.close();
+                return clazz.cast(f);
+            }
+        } catch (ClassCastException e) {
+            String msg = "Unsupported class: " + clazz.getName();
+            LOG.warning(msg);
+            throw ExceptionUtils.toInternalServerErrorException(null, null);
         }
         throw new IOException("Unrecognized class");
     }
 
+    
+    
     public long getSize(T t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mt) {
         // TODO: if it's a range request, then we should probably always return -1 and set 
         // Content-Length and Content-Range in handleRangeRequest
diff --git a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/SourceProvider.java b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/SourceProvider.java
index ab3a6e28bd..4ece76bbcc 100644
--- a/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/SourceProvider.java
+++ b/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/SourceProvider.java
@@ -24,6 +24,7 @@ import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import java.util.logging.Logger;
 
 import javax.ws.rs.Consumes;
 import javax.ws.rs.Produces;
@@ -43,6 +44,7 @@ import javax.xml.transform.stream.StreamSource;
 
 import org.w3c.dom.Document;
 
+import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.io.CachedOutputStream;
 import org.apache.cxf.jaxrs.ext.MessageContext;
 import org.apache.cxf.jaxrs.ext.xml.XMLSource;
@@ -62,6 +64,7 @@ public class SourceProvider<T> extends AbstractConfigurableProvider implements
     MessageBodyReader<T>, MessageBodyWriter<T> {
 
     private static final String PREFERRED_FORMAT = "source-preferred-format";
+    private static final Logger LOG = LogUtils.getL7dLogger(SourceProvider.class);
     @Context
     private MessageContext context;
     
@@ -88,41 +91,46 @@ public class SourceProvider<T> extends AbstractConfigurableProvider implements
                 theSource = SAXSource.class;
             }
         }
-        
-        if (DOMSource.class.isAssignableFrom(theSource) || Document.class.isAssignableFrom(theSource)) {
-            
-            boolean docRequired = Document.class.isAssignableFrom(theSource);
-            XMLStreamReader reader = getReader(is);
-            try {
-                Document doc = StaxUtils.read(reader);
-                return source.cast(docRequired ? doc : new DOMSource(doc));
-            } catch (DepthExceededStaxException e) {
-                throw ExceptionUtils.toWebApplicationException(null, JAXRSUtils.toResponse(413));
-            } catch (XMLStreamException e) {
-                if (e.getMessage() != null && e.getMessage().startsWith("Maximum Number")) {
-                    throw ExceptionUtils.toWebApplicationException(null, JAXRSUtils.toResponse(413));
-                } else {
-                    throw ExceptionUtils.toBadRequestException(e, null);
-                }
-            } catch (Exception e) {
-                IOException ioex = new IOException("Problem creating a Source object");
-                ioex.setStackTrace(e.getStackTrace());
-                throw ioex;
-            } finally {
+        try {
+            if (DOMSource.class.isAssignableFrom(theSource) || Document.class.isAssignableFrom(theSource)) {
+                
+                boolean docRequired = Document.class.isAssignableFrom(theSource);
+                XMLStreamReader reader = getReader(is);
                 try {
-                    reader.close();
+                    Document doc = StaxUtils.read(reader);
+                    return source.cast(docRequired ? doc : new DOMSource(doc));
+                } catch (DepthExceededStaxException e) {
+                    throw ExceptionUtils.toWebApplicationException(null, JAXRSUtils.toResponse(413));
                 } catch (XMLStreamException e) {
-                    //ignore
+                    if (e.getMessage() != null && e.getMessage().startsWith("Maximum Number")) {
+                        throw ExceptionUtils.toWebApplicationException(null, JAXRSUtils.toResponse(413));
+                    } else {
+                        throw ExceptionUtils.toBadRequestException(e, null);
+                    }
+                } catch (Exception e) {
+                    IOException ioex = new IOException("Problem creating a Source object");
+                    ioex.setStackTrace(e.getStackTrace());
+                    throw ioex;
+                } finally {
+                    try {
+                        reader.close();
+                    } catch (XMLStreamException e) {
+                        //ignore
+                    }
                 }
+            } else if (SAXSource.class.isAssignableFrom(theSource)
+                      || StaxSource.class.isAssignableFrom(theSource)) {
+                return source.cast(new StaxSource(getReader(is)));
+            } else if (StreamSource.class.isAssignableFrom(theSource)
+                       || Source.class.isAssignableFrom(theSource)) {
+                return source.cast(new StreamSource(getRealStream(is)));
+            } else if (XMLSource.class.isAssignableFrom(theSource)) {
+                return source.cast(new XMLSource(getRealStream(is)));
             }
-        } else if (SAXSource.class.isAssignableFrom(theSource)
-                  || StaxSource.class.isAssignableFrom(theSource)) {
-            return source.cast(new StaxSource(getReader(is)));
-        } else if (StreamSource.class.isAssignableFrom(theSource)
-                   || Source.class.isAssignableFrom(theSource)) {
-            return source.cast(new StreamSource(getRealStream(is)));
-        } else if (XMLSource.class.isAssignableFrom(theSource)) {
-            return source.cast(new XMLSource(getRealStream(is)));
+        } catch (ClassCastException e) {
+            String msg = "Unsupported class: " + source.getName();
+            LOG.warning(msg);
+            throw ExceptionUtils.toInternalServerErrorException(null, null);
         }
         
         throw new IOException("Unrecognized source");
