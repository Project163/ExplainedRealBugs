diff --git a/core/src/main/java/org/apache/cxf/common/util/Base64Utility.java b/core/src/main/java/org/apache/cxf/common/util/Base64Utility.java
index cefd45c171..c134fc836f 100644
--- a/core/src/main/java/org/apache/cxf/common/util/Base64Utility.java
+++ b/core/src/main/java/org/apache/cxf/common/util/Base64Utility.java
@@ -232,7 +232,7 @@ public final class Base64Utility {
         // If not a multiple of 3 octets then a final padded 4 char
         // slot is needed.
         //
-        if ((l - o) % 3 == 0) {
+        if (l % 3 == 0) {
             out = new char[l / 3 * 4];
         } else {
             out = new char[l / 3 * 4 + 4];
@@ -240,7 +240,7 @@ public final class Base64Utility {
 
         int rindex = o;
         int windex = 0;
-        int rest = l - o;
+        int rest = l;
 
         while (rest >= 3) {
             int i = ((id[rindex] & 0xff) << 16)
diff --git a/core/src/test/java/org/apache/cxf/common/util/Base64UtilityTest.java b/core/src/test/java/org/apache/cxf/common/util/Base64UtilityTest.java
index 86fe9a731f..fc6cff10d2 100644
--- a/core/src/test/java/org/apache/cxf/common/util/Base64UtilityTest.java
+++ b/core/src/test/java/org/apache/cxf/common/util/Base64UtilityTest.java
@@ -23,6 +23,7 @@ import java.io.ByteArrayOutputStream;
 import java.io.StringWriter;
 
 import org.apache.cxf.helpers.IOUtils;
+
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -39,6 +40,26 @@ public class Base64UtilityTest extends Assert {
         }
     }
     
+    @Test
+    public void testEncodeMulltipleChunks() throws Exception {
+        final String text = "The true sign of intelligence is not knowledge but imagination.";
+        byte[] bytes = text.getBytes("UTF-8");
+        // multiple of 3 octets
+        assertEquals(63, bytes.length);
+        String s1 = new String(Base64Utility.encodeChunk(bytes, 0, bytes.length));
+        
+        StringBuilder sb = new StringBuilder();
+        int off = 0;
+        for (; off + 21 < bytes.length; off += 21) {
+            sb.append(Base64Utility.encodeChunk(bytes, off, 21));
+        }
+        if (off < bytes.length) {
+            sb.append(Base64Utility.encodeChunk(bytes, off, bytes.length - off));
+        }
+        String s2 = sb.toString();
+        assertEquals(s1, s2);
+    }
+    
     @Test
     public void testEncodeDecodeChunk() throws Exception {
         byte bytes[] = new byte[100];
