<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 11:38:30 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CXF-2398] JMS Connections are not closed when JCA recycles CXF proxy</title>
                <link>https://issues.apache.org/jira/browse/CXF-2398</link>
                <project id="12310511" key="CXF">CXF</project>
                    <description>&lt;p&gt;When close() is called on JCA ConnectionHandler, there is no cleanup of the underlying client proxy and its transport. Specfically when the JCA outbound use case is using JMS, JMS connections are not being closed. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12433364">CXF-2398</key>
            <summary>JMS Connections are not closed when JCA recycles CXF proxy</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dkulp">Daniel Kulp</assignee>
                                    <reporter username="seumassoltysik">Seumas Soltysik</reporter>
                        <labels>
                    </labels>
                <created>Tue, 18 Aug 2009 18:50:48 +0000</created>
                <updated>Wed, 15 Jun 2016 19:39:09 +0000</updated>
                            <resolved>Mon, 28 Sep 2009 20:49:37 +0000</resolved>
                                    <version>2.1</version>
                                    <fixVersion>2.1.7</fixVersion>
                    <fixVersion>2.2.4</fixVersion>
                                    <component>Integration</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                                <comments>
                            <comment id="12744647" author="seumassoltysik" created="Tue, 18 Aug 2009 18:53:31 +0000"  >&lt;p&gt;Patch allows JCA to call Client.destroy() which in turn will close the underlying conduit. JMSConduit.close() is modified to ensure that connection is destroyed in the case where SingleConnectionFactory is being used.&lt;/p&gt;</comment>
                            <comment id="12745779" author="seumassoltysik" created="Fri, 21 Aug 2009 03:57:51 +0000"  >&lt;p&gt;Further testing and reading of the JCA spec indicate that destroying the client proxy when close is called on the ManagedConnection handle returned by ManagedConnection.getConnection() is not appropriate. Doing so causes the proxy to be destroyed more often than necessary. According to the spec, close() is called on the handle proxy created by ManagedConnection.getConnection() before the ManagedConnection is recycled for pooling. Destroying the client proxy at this point is premature. The client proxy itself should be considered the underlying resource and should only be destroyed when the ManagedConnection is itself destroyed. In addition, there is no need to create a client proxy each time getConnection() is called. Each ManagedConnection only requires a single client proxy which in turn can be wrapped by a Connection proxy each time getConnection() is called.&lt;/p&gt;</comment>
                            <comment id="12745780" author="seumassoltysik" created="Fri, 21 Aug 2009 04:00:25 +0000"  >&lt;p&gt;Patch to fix modify how client proxy is destroyed in ManagedConnection.&lt;/p&gt;</comment>
                            <comment id="12746074" author="wtam" created="Fri, 21 Aug 2009 16:46:57 +0000"  >&lt;p&gt;While the new patch &lt;a href=&quot;https://issues.apache.org/jira/browse/CXF-2398&quot; title=&quot;JMS Connections are not closed when JCA recycles CXF proxy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CXF-2398&quot;&gt;&lt;del&gt;CXF-2398&lt;/del&gt;&lt;/a&gt;.patch2 addresses the problem (of prematurely destroying clients) introduced &lt;a href=&quot;https://issues.apache.org/jira/browse/CXF-2398&quot; title=&quot;JMS Connections are not closed when JCA recycles CXF proxy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CXF-2398&quot;&gt;&lt;del&gt;CXF-2398&lt;/del&gt;&lt;/a&gt;.patch, the new patch also raises new issues/questions.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Creating more than one client proxy per ManagedConnectionImpl.getConnection(subject, spec) method call is needed if we are going to support Jee credential mapping.  Currently, the subject is only saved in the handles map for reporting the subject of the associated handle in metadata (the new patch will break this, btw)  but the subject could be used as credential to create a client proxy connection handle in the future.   FYI, If you look at ManagedConnectionFactoryImpl.matchManagedConnections(), it intentionally skips the subject as a matching criteria (so the application server would call ManagedConnectionImpl.getConnection(subject, spec) with different subjects).   I&apos;d  recommend not to change it.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think what prompted the change was the observation of too many proxies getting created.  It is a problem in the  ManagedConnectionImpl.getConnection(subject, spec) method that does not check the subject.  We should not create new proxy if there is one already created for a given subject.  We could so something like this in getConnection() to fix it.&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; handle = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (Map.Entry&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;, Subject&amp;gt; entry : handles.entrySet()) {
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (subject == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (entry.getValue() == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                    handle = entry.getKey();
                    &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
                }
            } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (subject.equals(entry.getValue())) {
                    handle = entry.getKey();
                    &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
                }
            }
        }
 
        &lt;span class=&quot;code-comment&quot;&gt;// only create a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; handle, &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; hande is &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
	&lt;li&gt;I think it is fine to have the ManagedConnectionImpl.destroy() to destroy client proxies.  What about the cleanup() method? The JCA spec 6.5.4.4 says we should invalidate all handles but at the same time it says cleanup() should not close physical pipe.  It does not fit well in our model because we invalidate handle by destroying client (thus, closing connection).    Right now, we are not invalidating handles.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;So, if you take my advice in the first bullet, we would move the closed handle from handles map to another collection (say, closedHandles) in handleCloseMethod().&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
handles.remove(proxy);
closedHandles.add(proxy);

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When destroying the proxies, we just need to make sure we destroy the closedHandles as well.&lt;/p&gt;


</comment>
                            <comment id="12746115" author="seumassoltysik" created="Fri, 21 Aug 2009 17:58:09 +0000"  >&lt;p&gt;I understand your comments regarding a proxy per subject. I would say leave it as is for now and open up a jira for the requirement to support the security issues you mentioned. However, I disagree with your statement regarding cleaning up the proxies in ManagedConnection.cleanup(). Per section 6.5.4.4 of the spec:&lt;br/&gt;
&quot;It invokes ManagedConnection.cleanup when it has to invalidate all&lt;br/&gt;
connection handles associated with this ManagedConnection instance and put the&lt;br/&gt;
ManagedConnection instance back in to the pool.&quot;&lt;br/&gt;
This means that if cleanup() were to destroy the proxies then they would be destroyed each time a ManagedConnection was recycled to the pool. Not very efficient. The spec talks about the need to hold onto underlying connection resources when a ManagedConnection is recycled. In our case, these resources are not so clear, but I would contend that the ClientProxy is essentially the closest thing to the kind of resources that the spec is talking about. Thus it makes sense to hold onto the proxy/proxies until the ManagedConnection is no longer needed and destroy() is called.&lt;/p&gt;</comment>
                            <comment id="12746125" author="wtam" created="Fri, 21 Aug 2009 18:19:55 +0000"  >&lt;p&gt;My point regarding the cleanup() is either way (destroy client or not). we are not 100% compliant with the spec because we either leave the handle as &quot;validate&quot; or we close the connection.  I agree with you that destroying the client in cleanup is not efficient (I have retrieved my opinion to invoke cleanup before your comment).  However, the current cleanup method needs update if we intent to preserve the clients.    (i.e. it should not clear the handles map).    That said, we can revisit the handles map when we look at the &quot;proxy per subject&quot; issue.&lt;/p&gt;</comment>
                            <comment id="12746134" author="wtam" created="Fri, 21 Aug 2009 18:35:59 +0000"  >&lt;p&gt;Regarding to proxy per subject issue.  Sounds like you are confident with the patch,   We can certainly revisit the proxy per subject issue.&lt;/p&gt;</comment>
                            <comment id="12746145" author="seumassoltysik" created="Fri, 21 Aug 2009 18:53:44 +0000"  >&lt;p&gt;Keep in mind that the following structure:&lt;br/&gt;
Handle proxy wraps Client proxy wraps Client&lt;/p&gt;

&lt;p&gt;As you stated from the spec: &quot;6.5.4.4 says we should invalidate all handles but at the same time it says cleanup() should not close physical pipe&quot;&lt;/p&gt;

&lt;p&gt;For our connector, i chose to treat the Client/ClientProxy as the pipe and the Handle proxy as the handle. The pipe(Client)  is not destroyed on cleanup() but the handles are released from the map and thus made invalid. So when cleanup is called, the client remains valid, but the handles are invalid. New handles are created when the ManagedConnection is re-used and getConnection() is called again.&lt;/p&gt;</comment>
                            <comment id="12746171" author="wtam" created="Fri, 21 Aug 2009 19:20:14 +0000"  >&lt;p&gt;OK.  I view it differently.  The problem with treating handle as you have described is:  if my application calls connection.close(), the application can still invoke target service without getting an exception until suddenly the application server calls destroy() on the ManagedConnection.   That&apos;s not good.&lt;/p&gt;

&lt;p&gt;In fact, the handle (i.e. the connection returned by CXFConnectionFactory) is not being invalidated after cleanup() is called, the application can still call connection.getService() AND invoke the service without problem.  That certainly does not comply to 6.5.4.4.  I guess it is a pre-existed issue.&lt;/p&gt;

</comment>
                            <comment id="12746178" author="seumassoltysik" created="Fri, 21 Aug 2009 19:32:25 +0000"  >&lt;p&gt;6.5.4.4&lt;br/&gt;
&quot;The container always drives the cleanup of a ManagedConnection instance. The&lt;br/&gt;
container keeps track of created connection handles in an implementation specific&lt;br/&gt;
mechanism. It invokes ManagedConnection.cleanup when it has to invalidate all&lt;br/&gt;
connection handles associated with this ManagedConnection instance and put the&lt;br/&gt;
ManagedConnection instance back in to the pool. This may be called after the end&lt;br/&gt;
of a connection sharing scope or when the last associated connection handle is closed&lt;br/&gt;
for a ManagedConnection instance.&quot;&lt;/p&gt;

&lt;p&gt;My reading of this is that it is up to the container to make sure that after close() is called, the handles will not longer be used. However, to be sure, when close() is called on the handle we could set a member variable to indicate that the handle has been closed and any further calls to invoke() on the proxy handler could throw an exception.&lt;/p&gt;</comment>
                            <comment id="12746211" author="wtam" created="Fri, 21 Aug 2009 20:43:16 +0000"  >&lt;p&gt;I don&apos;t think we are reading it any differently but It says this right in your quote:&lt;/p&gt;

&lt;p&gt;&quot;It (the container) invokes ManagedConnection.cleanup when it has to invalidate all&lt;br/&gt;
connection handles associated with this ManagedConnection instance ...&quot;&lt;/p&gt;

&lt;p&gt;It clearly mandates that it is JCA connector&apos;s responsibility to invalidate all the handles when ManagedConnection.cleanup().  You could invalidate individual handle in handleCloseMethod() upon connection.close() which is driven by the application but we are still required to invalidate all the handles in cleanup() which is driven by container/application server.&lt;/p&gt;

&lt;p&gt;The only question is what constitutes a &quot;handle&quot; and thus what should be invalidated.&lt;/p&gt;

&lt;p&gt;Your view: &lt;/p&gt;

&lt;p&gt;the target service proxy should NOT be invalidated when the associated handle is closed.&lt;/p&gt;

&lt;p&gt;My view: &lt;/p&gt;

&lt;p&gt;the target service proxy should be invalidated when the associated handle is closed.  &lt;/p&gt;

&lt;p&gt;When the application closes a connection, we should not allow the application to access any resource associated with the closed connection.  I think it makes the contract much more clear and intuitive.  Otherwise, how would you document how long the target service (client proxy) can remain usable after a connection has been closed?   &lt;/p&gt;

&lt;p&gt;I think the intention for your quotation is to point out that there is a window between the application calls connection.close() and the container calls ManagedConnection.cleanup().  True, but the window is tiny comparing with the window when ManagedConnection.destroy() is called.  We could add a member in the handle similar to your suggestion but it also blocks invocation made to the target service if the associated handle has been closed.  Then, there would be no window.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12979212">CXF-6940</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12416904" name="CXF-2398.patch" size="5568" author="seumassoltysik" created="Tue, 18 Aug 2009 18:53:31 +0000"/>
                            <attachment id="12417213" name="CXF-2398.patch2" size="5610" author="seumassoltysik" created="Fri, 21 Aug 2009 04:00:25 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>113822</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            16 years, 14 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0cv0f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>72968</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>