<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 12:41:03 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CXF-9146] MemoryLeak in HttpClientHTTPConduit when used with the ThreadLocalClientState</title>
                <link>https://issues.apache.org/jira/browse/CXF-9146</link>
                <project id="12310511" key="CXF">CXF</project>
                    <description>&lt;p&gt;&lt;font color=&quot;#000000&quot;&gt;Is defined as following:&lt;/font&gt;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;ThreadLocalClientState &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; ClientState {

       &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;, LocalClientState&amp;gt; state = Collections.synchronizedMap(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WeakHashMap&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;, LocalClientState&amp;gt;()); &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;... which does not make any sense to me, as is this is just ThreadLocal built at home, a class which as been in the JDK for a very long time.. A WeakHashMap of Threads might emulate ThreadLocal, &#160;but it can cause unexpected memory leaks, because the Weak-Keys are strongly held until the WeakHashMap is accessed for the next time.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Let&apos;s take this simple example:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; mb = 1024 * 1024;
&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; rt = &lt;span class=&quot;code-object&quot;&gt;Runtime&lt;/span&gt;.getRuntime();
&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; entries = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WeakHashMap&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[][]&amp;gt;();
&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; keys = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();

&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.gc();
&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;Memory before Memory Load: %s mb%n&quot;&lt;/span&gt;, (rt.totalMemory() - rt.freeMemory()) / mb);

IntStream.range(0, 100).mapToObj(i -&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Date(i + 1000)).forEach(key -&amp;gt; {
    keys.add(key);
    entries.put(key, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[1][10 * mb]);
});
&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.gc();
&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;Memory after Memory Load: %s mb%n&quot;&lt;/span&gt;, (rt.totalMemory() - rt.freeMemory()) / mb);

keys.clear();
&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.gc();
&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;Memory after Memory Keys clear: %s mb%n&quot;&lt;/span&gt;, (rt.totalMemory() - rt.freeMemory()) / mb);

&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;Map Size: %s%n&quot;&lt;/span&gt;, entries.size());
&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.gc();
&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;Memory after first Memory Map access: %s mb%n&quot;&lt;/span&gt;, (rt.totalMemory() - rt.freeMemory()) / mb);&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;This leads to the following output:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Memory before Memory Load: 13 mb
Memory after Memory Load: 1213 mb
Memory after Memory Keys clear: 1213 mb
Map Size: 0
Memory after first Memory Map access: 13 mb
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Please ignore my inaccurate measurements with System.gc() without using JMH, but when looking up the source for WeakHashMap then it becomes obvious that no cleanup is technically possible until the WeakHashMap is deferenced for the next time for a method of the Map interface. This is a scenario which should rarely happen in a production enviroment, but we have seen it at least once being the cause of an OutOfMemoryError wenn many threads in in parallel executed requests which returned very large Response objects in memory.&lt;/p&gt;

&lt;p&gt;Therefore, and especially when thinking of the future of virtual threads and scoped values, I would advise to the refactor the code so that it internally uses a simple Treadlocal from now on instead of the WeakHashMap.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13620543">CXF-9146</key>
            <summary>MemoryLeak in HttpClientHTTPConduit when used with the ThreadLocalClientState</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="cheesemaster">Eric</reporter>
                        <labels>
                    </labels>
                <created>Tue, 10 Jun 2025 12:14:40 +0000</created>
                <updated>Wed, 18 Jun 2025 19:32:16 +0000</updated>
                            <resolved>Wed, 18 Jun 2025 19:32:16 +0000</resolved>
                                    <version>4.1.2</version>
                    <version>4.0.8</version>
                    <version>3.6.7</version>
                                    <fixVersion>4.1.3</fixVersion>
                    <fixVersion>4.0.9</fixVersion>
                    <fixVersion>3.6.8</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="17959543" author="JIRAUSER293945" created="Tue, 10 Jun 2025 17:08:38 +0000"  >&lt;p&gt;After some further testing I have increased the priority of the ticket to MAJOR, since I have the feeling that there are some real problems with this class and the HttpClientConduit.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The following screenshots shows a cyclic reference with the new httpclientconduit: The conduit in the value holds through the PipedInputStream a strong reference to the thread which is the key in the WeakHashMap. That means the value references the key, which builds a cycly which will prevent garbage collection. All these problems would immediatly vanish with proper ThreadLocal usage.&lt;/p&gt;

&lt;p&gt;Note: the timetokeepstate is 0 in the surrounding ThreadLocalClientState, so no cleanupthread will ever start.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://issues.apache.org/jira/secure/attachment/13076931/13076931_image-2025-06-10-19-05-03-593.png&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="17959544" author="JIRAUSER293945" created="Tue, 10 Jun 2025 17:12:48 +0000"  >&lt;p&gt;Just for further clarification:&lt;/p&gt;

&lt;p&gt;I am pretty sure that there is a reason for the logic of the class, with the internal cleanup thread with the timetokeepstate feature, but I am not sure if this is really worth the trouble which could arise from memoryleaks like above, even if the cleanupthread might eventually solve them.&lt;/p&gt;

&lt;p&gt;Perhaps the best idea might be to create a switch where the internal implementation chooses weakhashmap if the timetokeepstate is &amp;gt; 0 and threadlocals if the timetokeepstate is 0?&lt;/p&gt;</comment>
                            <comment id="17959641" author="JIRAUSER293945" created="Wed, 11 Jun 2025 04:07:20 +0000"  >&lt;p&gt;Created a self-contained test to reproduce the Leak:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/13076944/13076944_CxfClientMemoryLeakTest.java&quot; title=&quot;CxfClientMemoryLeakTest.java attached to CXF-9146&quot;&gt;CxfClientMemoryLeakTest.java&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The Client is created both in a threadsafe and non-threadsafe way and reused in multiple threads sequentially (for non-threadsafe) and joined. There a multiple scenarios for threadsafe=true/false withBody=true/false, and if keepState with timeout is enabled. The error occurs&#160; when:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;threadsafe is true&lt;/li&gt;
	&lt;li&gt;a body of any length is sent (even a single &apos;a&apos;)&lt;/li&gt;
	&lt;li&gt;secondsToKeepState is zero&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In my view this is a perfectly valid and common scenario and the reason why I increase the priority of the ticket again, this time to CRITICAL.&lt;/p&gt;</comment>
                            <comment id="17963254" author="reta" created="Thu, 12 Jun 2025 00:54:54 +0000"  >&lt;p&gt;Thanks a lot for the comprehensive analysis &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cheesemaster&quot; class=&quot;user-hover&quot; rel=&quot;cheesemaster&quot;&gt;cheesemaster&lt;/a&gt; , I will take a closer look shortly (indeed, ThreadLocalClientState was created 15 years ago). I have lowered this ticket to major - there is absolutely nothing critical about it (no crashes, OOMs, data corruption, etc)&lt;/p&gt;</comment>
                            <comment id="17965489" author="JIRAUSER293945" created="Thu, 12 Jun 2025 07:50:46 +0000"  >&lt;p&gt;I think I have an idea how to fix this within ThreadLocalClientState without causing any obversable changes, I will come up with a pull request in the next days.&lt;/p&gt;</comment>
                            <comment id="17967288" author="JIRAUSER293945" created="Fri, 13 Jun 2025 07:23:31 +0000"  >&lt;p&gt;I have created a PullRequest to fix the issue:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/cxf/pull/2461&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/cxf/pull/2461&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17973483" author="JIRAUSER293945" created="Fri, 13 Jun 2025 12:33:39 +0000"  >&lt;p&gt;After experiencing Crashes in our production environments because of OutOfMemoryErrors caused by the MemoryLeaks by this issue&lt;b&gt;, I can attest that an upping this ticket to CRITICAL is still necessary in my opinion.&lt;/b&gt;&lt;b&gt;{&lt;/b&gt;}&lt;/p&gt;

&lt;p&gt;Also I have recently learned the hard way that the MemoryLeak in the ThreadLocalClientState ist only the &lt;b&gt;JAXRS-Side of the MemoryLeak&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;The same issue exists in &lt;font color=&quot;#000000&quot;&gt;org.apache.cxf.endpoint.&lt;/font&gt;ClientImpl&lt;/b&gt; which also hosts a WeakHashMap of Threads.&lt;/p&gt;

&lt;p&gt;I will see that I provide Fixes for these as well.&lt;/p&gt;</comment>
                            <comment id="17974149" author="JIRAUSER293945" created="Sat, 14 Jun 2025 08:55:06 +0000"  >&lt;p&gt;Sadly, the solution in the PullRequest does not work as expected: While it fixes the MemoryLeak with dead threads, it opens up a completely different memory leak when creating many short-lived instances from the same thread.&#160;&lt;/p&gt;

&lt;p&gt;This, and the fact that there are even more WeakHashMaps of Threads in the SOAP-Client convinces me that the fix should instead be within the HttpClientHTTPConduit by removing the PipedStreams as soon as they are closed.&lt;/p&gt;</comment>
                            <comment id="17975071" author="reta" created="Sat, 14 Jun 2025 12:04:34 +0000"  >&lt;p&gt;As alternative, could you please switch to URLConnection based HTTP conduit using contextual property &quot;force.urlconnection.http.conduit&quot; (see please &lt;a href=&quot;https://cxf.apache.org/docs/client-http-transport-including-ssl-support.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://cxf.apache.org/docs/client-http-transport-including-ssl-support.html&lt;/a&gt; for more details)?&lt;/p&gt;</comment>
                            <comment id="17975824" author="JIRAUSER293945" created="Sat, 14 Jun 2025 15:13:07 +0000"  >&lt;p&gt;That&apos;s not really an option we want to take any longer if it is possible to avoid it.&lt;/p&gt;

&lt;p&gt;We have a large stack of software and doing so would require us to add jvm Options to allow reflection an URLConnection again in order to support all Httpmethods, like PATCH, for example.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Instead I will see if I can eliminate the dangling reference to PipedOutputStream in the HttpClientWrappedInputStream above. This solves these bugs without touching other classes and seems to be the root of the problem.&lt;/p&gt;

&lt;p&gt;I guess all that is missing is the following line in HttpClientWrappedOutputStream::close:&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
wrappedOutputStream = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This removes the last reference to the PipedOutputStream and the GC can do its work in the acceptancetest above and remove the dead Thread and Context objects.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The best part ist that in this case I can write a custom HttpConduitFactory, register it in the Bus and overwrite the HttpClientHTTPConduit::createOutputStream with a custom close method to fix the bug in our application until the issue is fixed in CXF itself.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17978578" author="reta" created="Mon, 16 Jun 2025 02:20:49 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cheesemaster&quot; class=&quot;user-hover&quot; rel=&quot;cheesemaster&quot;&gt;cheesemaster&lt;/a&gt; could you demonstrate the typical usage of the webclient in your application(s)? the one &#160;&lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/13076944/13076944_CxfClientMemoryLeakTest.java&quot; title=&quot;CxfClientMemoryLeakTest.java attached to CXF-9146&quot;&gt;CxfClientMemoryLeakTest.java&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt; demonstrates is clearly not correct - the response is never closed but it should be. I suspect the leaks may be caused by improper API usage.&lt;/p&gt;</comment>
                            <comment id="17979288" author="JIRAUSER293945" created="Mon, 16 Jun 2025 17:23:08 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=reta&quot; class=&quot;user-hover&quot; rel=&quot;reta&quot;&gt;reta&lt;/a&gt; I do not think that I am using CXF in an improper or undocumented way. I am not closing the response since there is no response to close. I just create a JAXRS-Client by Proxy with CXF. All HTTP-Requests are performend internally through a dynamic proxy created by the cxf-jaxrs-client-API which handles both the Request and the Response. The example should be perfectly valid:&lt;/p&gt;

&lt;p&gt;1. A threadsafe Proxy-Client is created&lt;/p&gt;

&lt;p&gt;2. Many Requests are performend with the same, threadsafe client in multiple threads&lt;/p&gt;

&lt;p&gt;This corresponds to our pattern of creating a CXF client, registering it as a springbean and using it for the entire lifetime of the application, which should be a common usecase. This also explains the MemoryLeak: Since the client lives in the application scope, its ThreadLocalClientState is never garbage collected, so any MemoryLeak within its WeakHashMap with Thread keys will sum up over the lifetime of the application.&lt;/p&gt;

&lt;p&gt;Note that as by comment above I created a newer, MUCH simpler PR to try to clear the reference to the PipedOutputStream which prevents the garbage collection of dead threads: &lt;a href=&quot;https://github.com/apache/cxf/pull/2467/files&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/cxf/pull/2467/files&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Sorry for all of this infodump, I just want to help to solve this problem which made huge waves in our production environment. I have already fixed it the same way as in the PR by inheriting from HttpClientHTTPConduit by simply nulling the wrapped stream in an outer close block, and it&apos;s working fine.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="13076944" name="CxfClientMemoryLeakTest.java" size="3102" author="cheesemaster" created="Wed, 11 Jun 2025 04:07:15 +0000"/>
                            <attachment id="13076930" name="image-2025-06-10-19-04-43-021.png" size="178487" author="cheesemaster" created="Tue, 10 Jun 2025 17:04:43 +0000"/>
                            <attachment id="13076931" name="image-2025-06-10-19-05-03-593.png" size="173836" author="cheesemaster" created="Tue, 10 Jun 2025 17:05:03 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310060" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Estimated Complexity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10060"><![CDATA[Unknown]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            21 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z1w9o0:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>