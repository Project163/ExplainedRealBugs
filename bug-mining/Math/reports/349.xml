<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 20:23:25 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[MATH-867] CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound. </title>
                <link>https://issues.apache.org/jira/browse/MATH-867</link>
                <project id="12310485" key="MATH">Commons Math</project>
                    <description>&lt;p&gt;When fitting with bounds, the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound.  This is because it internally maps the fitted parameter range into the interval &lt;span class=&quot;error&quot;&gt;&amp;#91;0,1&amp;#93;&lt;/span&gt;.  The unit of least precision (ulp) between floating point numbers is much smaller near zero than near one.  Thus, fits have much better resolution near the lower bound (which is mapped to zero) than the upper bound (which is mapped to one).  I will attach a example program to demonstrate.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12608709">MATH-867</key>
            <summary>CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound. </summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="fhess">Frank Hess</reporter>
                        <labels>
                    </labels>
                <created>Fri, 21 Sep 2012 22:52:58 +0000</created>
                <updated>Mon, 4 Mar 2013 18:53:25 +0000</updated>
                            <resolved>Mon, 1 Oct 2012 16:09:26 +0000</resolved>
                                                    <fixVersion>3.1</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="13460915" author="fhess" created="Fri, 21 Sep 2012 23:00:47 +0000"  >&lt;p&gt;Attached a test program.&lt;/p&gt;</comment>
                            <comment id="13461300" author="erans" created="Sun, 23 Sep 2012 00:27:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;This is because it internally maps the fitted parameter range into the interval &lt;span class=&quot;error&quot;&gt;&amp;#91;0,1&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If this is indeed the reason, not much can be done short of modifying the algorithm. The implementation we have in CM was ported from the original code under the supervision of the original author. Maybe you should ask him this question.&lt;/p&gt;</comment>
                            <comment id="13461783" author="fhess" created="Mon, 24 Sep 2012 13:28:07 +0000"  >&lt;p&gt;I&apos;ve sent an email to the original author.  I&apos;ve copied what I wrote to him below for reference:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I was wondering if you have any input on this bug in the Apache Commons implementation of your algorithm:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-867&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/MATH-867&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It seems to be due to their attempt to follow your &quot;encoding of variables&quot; hint.  They map parameters on to the interval &lt;span class=&quot;error&quot;&gt;&amp;#91;0,1&amp;#93;&lt;/span&gt; when boundaries are provided, which can have a bad interaction with how floating point variable ULP are distributed.  Since your hint seems to suggest the main point of this encoding is just make the width of the intervals uniform, it seems to me they could just scale the boundaries onto a interval of unit width without offseting the interval to start at zero.  This would get rid of the mismatch in ULP distribution between the scaled interval and the original boundaries.&lt;/p&gt;&lt;/blockquote&gt;</comment>
                            <comment id="13461788" author="fhess" created="Mon, 24 Sep 2012 13:36:35 +0000"  >&lt;p&gt;I tried changing the FitnessFunction.encode/decode methods so they don&apos;t offset and that causes my test program to fit well near both bounds.  That is, I changed encode from:&lt;/p&gt;

&lt;p&gt;res&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; = (x&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; - boundaries&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;) / diff;&lt;/p&gt;

&lt;p&gt;to: &lt;/p&gt;

&lt;p&gt;res&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; = x&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; / diff;&lt;/p&gt;

&lt;p&gt;and changed decode from:&lt;/p&gt;

&lt;p&gt;res&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; = diff * x&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; + boundaries&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;;&lt;/p&gt;

&lt;p&gt;to:&lt;/p&gt;

&lt;p&gt;res&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; = diff * x&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;;&lt;/p&gt;
</comment>
                            <comment id="13461853" author="jolievie" created="Mon, 24 Sep 2012 15:18:30 +0000"  >&lt;p&gt;I don&apos;t see anything wrong with the new version (the original version better facilitates the display of the evolution of variables in a single picture). It seems also clear where the original version fails: taking the difference in the above computation leads to a loss of significant digits if x&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; and boundaries&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; largely differ, that is, if the solution is far away from the lower bound. &lt;/p&gt;

&lt;p&gt;However the use of boundaries for a range like &lt;span class=&quot;error&quot;&gt;&amp;#91;0, 5e16&amp;#93;&lt;/span&gt; seems not reasonable to me and it was not meant to be used like that. More specifically, I don&apos;t see a good reason to set an upper bound of 5e16, in particular when the initial point is 1. I would expect a reasonable initial point to lie roughly in the middle of the search interval. If the variable is supposed to be as large as 5e16, it is likely advisable to apply a non-linear transformation, e.g. to optimization its logarithm. More general, when searching in an interval of size 1e16 using double precision, one can, in principle, hardly expect to get a solution with a precision better than, say, 10 in which case one has identified the optimum with 15 digits of precision. &lt;/p&gt;
</comment>
                            <comment id="13461867" author="fhess" created="Mon, 24 Sep 2012 15:42:24 +0000"  >&lt;p&gt;If I&apos;m fitting a peak width, for example, I only want to fit positive widths.  So specifying a range with a bound on only one end like &lt;span class=&quot;error&quot;&gt;&amp;#91;0,+Infinity&amp;#93;&lt;/span&gt; would be natural.  Now the CMAESOptimizer doesn&apos;t accept infinite bounds, so the best I could do would be something like &lt;span class=&quot;error&quot;&gt;&amp;#91;0, VeryLargeValue&amp;#93;&lt;/span&gt;.  And I might reasonably use an initial peak width of 1.  My expectation as a user is that specifying this bound actually helps the optimizer.  Instead what happens is the entirely the opposite (well, actually it works fine when the lower bound is zero but would blow up if you were setting a finite upper bound instead of a finite lower bound).&lt;/p&gt;

&lt;p&gt;As a user the encoding of my fitted parameters to the interval 0 to 1 is entirely invisible and internal to the library.  So my expectation is the optimizer would give results with a precision matching the precision of the parameter being fitted (in the form I passed it in, not in some internal normalized form I know nothing about).&lt;/p&gt;</comment>
                            <comment id="13461878" author="fhess" created="Mon, 24 Sep 2012 16:09:05 +0000"  >&lt;p&gt;To elaborate on my previous point, the CMAESOptimizer also doesn&apos;t allow mixing of bounded and unbounded parameters.  So, if I only want to apply a bound to one parameter of a multi-parameter fit, then the best I can do is set the bounds of the &quot;unbounded&quot; parameters to be &lt;span class=&quot;error&quot;&gt;&amp;#91;-VeryLargeValue, +VeryLargeValue&amp;#93;&lt;/span&gt;.  This causes the fit precision around zero for the &quot;unbounded&quot; parameters to be much worse than when no bounds are specified at all.&lt;/p&gt;</comment>
                            <comment id="13461891" author="jolievie" created="Mon, 24 Sep 2012 16:26:36 +0000"  >&lt;p&gt;It seems important to point out that a parameter transformation or scaling and variable boundaries are two different things. That they are mixed in the code/interface I would indeed consider as a bug. Generally, the boundary handling can be done without any variable transformation and therefore does not need to effect precision. &lt;/p&gt;

&lt;p&gt;If we want positive variable values only, the code should IMHO support only applying a lower bound in some way. &lt;/p&gt;

&lt;p&gt;Maybe it is still important to mention: a relevant initial parameter to CMA-ES is an initial step-size (a standard deviation) possibly in each coordinate. You might think of this step-size as similar to the width of the initial simplex in Nelder&amp;amp;Mead. Choosing this step-size is equivalent to choosing a different &quot;diff&quot;-factor in the encoding as suggested above. &lt;/p&gt;</comment>
                            <comment id="13461957" author="fhess" created="Mon, 24 Sep 2012 18:06:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;It seems important to point out that a parameter transformation or scaling and variable boundaries are two different things. That they are mixed in the code/interface I would indeed consider as a bug. Generally, the boundary handling can be done without any variable transformation and therefore does not need to effect precision.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s good news, I think things would work a lot closer to my expectations if the boundary handling was done without a transformation.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If we want positive variable values only, the code should IMHO support only applying a lower bound in some way. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;AFAICT the variable transformation is the main reason CMAESOptimizer doesn&apos;t let you use infinite values as bounds.  So if the transformation is dropped, we can have infinity as a bound value, which gives support for only specifying a bound on one side, plus mixing bounded and unbounded parameters.&lt;/p&gt;</comment>
                            <comment id="13463628" author="erans" created="Wed, 26 Sep 2012 08:44:45 +0000"  >&lt;blockquote&gt;&lt;p&gt;That they are mixed in the code/interface I would indeed consider as a bug.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is this &quot;bug&quot; in the original code?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Generally, the boundary handling can be done without any variable transformation &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But isn&apos;t this variable transformation part of the original code? At least, that&apos;s how it looked like from my perspective since &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=docdwo&quot; class=&quot;user-hover&quot; rel=&quot;docdwo&quot;&gt;docdwo&lt;/a&gt; contributed the port while in contact with you.&lt;br/&gt;
Do you mean that the &quot;encode&quot; and &quot;decode&quot; steps can be simply dropped from the code without any ill side-effects?&lt;/p&gt;

&lt;p&gt;Another issue (&lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-868&quot; title=&quot;Default sigma for CMAESOptimizer is wrong when using bounds&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-868&quot;&gt;&lt;del&gt;MATH-868&lt;/del&gt;&lt;/a&gt;) also seems related to the default transformation.&lt;/p&gt;
</comment>
                            <comment id="13463721" author="jolievie" created="Wed, 26 Sep 2012 11:29:31 +0000"  >&lt;p&gt;the &quot;bug&quot; is not in the original code. In some CMA-ES codes, variable transformations are provided as an option (not in the one which was translated). This is however just meant as a convenience feature, as it could be equivalently implemented as part of the objective function (and should IMHO preferably viewed as such). This should IMHO be a general feature implemented in the optimization library, as the benefits of variable transformations are not tightly linked to any specific optimization method. &lt;/p&gt;

&lt;p&gt;It should be easily possible to drop the transformation in CMAESOptimizer, in which case 0 and 1 must be replaced by the lower and upper boundary values in some parts of the code. &lt;/p&gt;</comment>
                            <comment id="13463747" author="jolievie" created="Wed, 26 Sep 2012 12:24:55 +0000"  >&lt;p&gt;Why are variables transformations generally desirable? Because, for example, if a parameter x_i should only have positive values, the transformation x_i -&amp;gt; x_i^2 makes the objective function compatible to any unbounded optimizer. Or, for example, rescaling of variables (e.g. unit m in km etc) can change an ill-conditioned problem to a well-conditioned one. &lt;/p&gt;</comment>
                            <comment id="13465521" author="erans" created="Fri, 28 Sep 2012 11:14:03 +0000"  >&lt;p&gt;I&apos;ve tried Frank&apos;s proposal &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-867?focusedCommentId=13461788&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13461788&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;above&lt;/a&gt;; in the code, I only modified the &quot;encode&quot; and &quot;decode&quot; functions.&lt;br/&gt;
This made one unit test fail (&quot;testConstrainedRosen&quot;).&lt;br/&gt;
I think that the test is partly incorrect in the tolerance setting and in the selection of the starting point, but even with those changed, I get critically different behaviours due to the &quot;isActiveCMA&quot; flag.&lt;br/&gt;
If &quot;true&quot;, the solution is found with pretty good accuracy:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;sol=[1.0000000029406888, 1.0000000045238486, 0.9999999996025084, 0.9999999959542569, 0.9999999988066054, 0.9999999956724651, 1.0000000008220962, 1.0000000011037358, 1.0000000004144547, 0.9999999946437816, 0.9999999977923537, 1.0000000007816154, 1.0000000164552258]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But when set to &quot;false&quot;, the result is:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;sol=[0.997107074864516, 0.9942080214735094, 0.9884131718553784, 0.9768835748661846, 0.954143705394098, 0.910067297297918, 0.8275510138614142, 0.6833931486612853, 0.4636505565068948, 0.20554769008446425, 0.0, 0.009899135523990096, 0.0]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is this expected? If so, wouldn&apos;t it be safer to always set this flag to &quot;true&quot; (thus removing it as a user input)?&lt;br/&gt;
If unexpected, does it indicate that other things must be changed in addition to &quot;encode&quot;/&quot;decode&quot;?&lt;/p&gt;</comment>
                            <comment id="13465568" author="fhess" created="Fri, 28 Sep 2012 12:33:24 +0000"  >&lt;p&gt;I think you should also modify isFeasible() and initializeCMA().  isFeasible should use the bounds instead of the unit interval.  initializeCMA should initialize sigmaArray to to be equal to inputSigma if inputSigma is not null, or to 0.3 times the range (as long as the boundaries are not such that the range is calculated to be infinity).&lt;/p&gt;</comment>
                            <comment id="13465630" author="erans" created="Fri, 28 Sep 2012 14:16:17 +0000"  >&lt;p&gt;In revision 1391477, I&apos;ve added a unit test (&quot;testFitAccuracyDependsOnBoundary&quot;) based on your attached file. But it is disabled since it fails with the current implementation (as this was the reason for this report).&lt;/p&gt;

&lt;p&gt;I changed &quot;isFeasible()&quot; but it was not enough to make the &quot;testConstrainedRosen&quot; pass; modifying &quot;sigmaArray&quot; as per your last comment entails that the above unit test fails again, though it passed with all but the &quot;sigmaArray&quot; changes. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Could you please provide a patch against the latest revision, once you are sure that all unit test pass (also removing the &quot;@Ignore&quot; annotation on &quot;testFitAccuracyDependsOnBoundary&quot;)? Thanks.&lt;/p&gt;</comment>
                            <comment id="13465682" author="fhess" created="Fri, 28 Sep 2012 15:42:23 +0000"  >&lt;p&gt;Attached a patch.  It makes encode/decode identities and removes the restrictions on infinite ranges.  The test on fit resolution near upper/lower bounds fails.  I believe the reason is that defaulting sigma to 0.3 times the range causes the fitter to jump from the initial value (which is order of 1 away from the target) to some huge value on the order of 1e16 on the first step.  The fitter then has to work its way all the way back to the target.  It doesn&apos;t reach the target exactly due to one of the many stop conditions hard-coded into the generationLoop which decide that the fit is &quot;good enough&quot; and quit.  That should probably be entered as a different ticket though, in that there is no way to override the internal stop conditions and make the fitter try harder.  The ConvergenceChecker which can be passed into the optimizer only has the ability to terminate the optimizer earlier than it normally would quit, it doesn&apos;t suppress the other stop conditions which can&apos;t be directly controlled by the user.&lt;/p&gt;</comment>
                            <comment id="13465693" author="jolievie" created="Fri, 28 Sep 2012 15:51:35 +0000"  >&lt;blockquote&gt;
&lt;p&gt;But when set to &quot;false&quot;, the result is:&lt;br/&gt;
sol=&lt;span class=&quot;error&quot;&gt;&amp;#91;0.997107074864516, 0.9942080214735094, 0.9884131718553784, 0.9768835748661846, 0.954143705394098, 0.910067297297918, 0.8275510138614142, 0.6833931486612853, 0.4636505565068948, 0.20554769008446425, 0.0, 0.009899135523990096, 0.0&amp;#93;&lt;/span&gt;&lt;br/&gt;
Is this expected?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No! The code must pass this test with high probability. &lt;/p&gt;</comment>
                            <comment id="13465719" author="jolievie" created="Fri, 28 Sep 2012 16:38:26 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I believe the reason is that defaulting sigma to 0.3 times the range causes the fitter to jump from the initial value (which is order of 1 away from the target) to some huge value on the order of 1e16 on the first step.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Right. I suggest to make sigmaArray independent of the boundary values. Otherwise setting boundaries like &lt;span class=&quot;error&quot;&gt;&amp;#91;1e-15,1e15&amp;#93;&lt;/span&gt; still will most likely lead to an unexpected behavior: the user just does not want to exceed this value, while the algorithm interprets the interval as being reasonable values to be checked out. Still it makes perfectly sense to check consistency between the initial guess, sigmaArray and boundaries, in that, say, &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;fitfun.encode(guess)[i] - sigmaArray[i]/2. &amp;gt; fitfun.encode(boundaries[0])[i] 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;in case of a lower bound. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It doesn&apos;t reach the target exactly due to one of the many stop conditions hard-coded into the generationLoop which decide that the fit is &quot;good enough&quot; and quit. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;more specifically, stopTolX is defined relative to the initial value of sigmaArray. This specific problem should therefore go away if stopTolX is defined as an absolute value like 1e-11. I think absolute and relative definition of stopTolX are both justified. &lt;/p&gt;

&lt;p&gt;Generally, the patch becomes buggy, when encode and decode are changed/reused. In this case, where solutions are compared with boundaries, like &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(x[i] &amp;lt; boundaries[0][i])
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;the comparison must be done with encoded boundaries: &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;encLboundaries = fitfun.encode(boundaries[0]); 
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (x[i] &amp;lt; encLboundaries[i])
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13465988" author="erans" created="Fri, 28 Sep 2012 23:04:16 +0000"  >&lt;blockquote&gt;&lt;p&gt;Attached a patch. It makes encode/decode identities and removes the restrictions on infinite ranges.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry but it is not good: You are removing the fix to your other issue (&lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-865&quot; title=&quot;Wide bounds to CMAESOptimizer result in NaN parameters passed to fitness function&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-865&quot;&gt;&lt;del&gt;MATH-865&lt;/del&gt;&lt;/a&gt;). Even if it won&apos;t be necessary anymore when this issue is fixed, it cannot be reverted as part of this issue. Let&apos;s leave the possibility to have infinite bounds for later, and focus on making the code work with finite bounds.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The test on fit resolution near upper/lower bounds fails.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is what must be fixed by the patch, without any side-effects (i.e. other tests failing).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I believe the reason is that defaulting sigma to 0.3 times the range &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-868&quot; title=&quot;Default sigma for CMAESOptimizer is wrong when using bounds&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-868&quot;&gt;&lt;del&gt;MATH-868&lt;/del&gt;&lt;/a&gt;, I noted that this does not work, since using this value makes the &quot;testFitAccuracyDependsOnBoundary&quot; fail. From this I conclude, that if the doc for &quot;inputSigma&quot; is correct, then there is something else to be changed in the code, or that the doc must be changed to indicate that &quot;inputSigma&quot; is &quot;relative&quot;.&lt;/p&gt;

&lt;p&gt;Nikolaus seems to confirm the latter (IIUC):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;fitfun.encode(guess)[i] - sigmaArray[i]/2. &amp;gt; fitfun.encode(boundaries[0])[i]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13466199" author="jolievie" created="Sat, 29 Sep 2012 12:28:46 +0000"  >&lt;p&gt;I second to make encode/decode the identity to address the bug. I don&apos;t even see a different way to address it. Then, inputSigma/sigmaArray/insigma should become independent of the boundary values (which seems consistent with the doc, as long as encode/decode remains the identity). &lt;/p&gt;

&lt;p&gt;my previous snippet must read &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;guess[i] - sigmaArray[i]/2. &amp;gt; fitfun.encode(boundaries[0])[i]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;because we have&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] guess = fitfun.encode(getStartPoint());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;i.e. guess is an encoded initial guess. &lt;/p&gt;</comment>
                            <comment id="13466222" author="erans" created="Sat, 29 Sep 2012 13:05:35 +0000"  >&lt;p&gt;I don&apos;t understand. This is the documentation:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;/**
 * Individual sigma values - initial search volume. inputSigma determines
 * the initial coordinate wise standard deviations &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the search. Setting
 * SIGMA one third of the initial search region is appropriate.
 */
&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] inputSigma;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AFAIUC, this says that sigma is &lt;em&gt;not&lt;/em&gt; independent on the boundary values.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I second to make encode/decode the identity to address the bug.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I also don&apos;t understand this. Referring to the code of &quot;decode&quot;:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] decode(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] x) {
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (boundaries == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; x;
  }
  &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] res = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[x.length];
  &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; x.length; i++) {
    &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; diff = boundaries[1][i] - boundaries[0][i];
    &lt;span class=&quot;code-comment&quot;&gt;// res[i] = diff * x[i] + boundaries[0][i]; // XXX orig
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// res[i] = diff * x[i]; // XXX v1
&lt;/span&gt;    res[i] = x[i]; &lt;span class=&quot;code-comment&quot;&gt;// XXX v2
&lt;/span&gt;  }
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; res;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;This&lt;/em&gt; issue&apos;s bug is solved by normalizing the variables (line marked with &quot;XXX v1&quot; in the above snippet). The downside is that &quot;testConstrainedRosen&quot; fails.&lt;/p&gt;

&lt;p&gt;When &quot;decode&quot; is made the identity (line marked with &quot;XXX v2&quot;), &quot;testConstrainedRosen&quot; passes but &quot;testFitAccuracyDependsOnBoundary&quot; fails, as with the original code (line marked with &quot;XXX orig&quot;).&lt;/p&gt;

&lt;p&gt;Since in some previous comments, you indicated that boundaries do not necessarily need to be taken into account inside the CMAES algorithm, a possibility is to review the entire code, and remove all code related to boundaries.&lt;/p&gt;

&lt;p&gt;Would you (or Frank) be willing to do that? In the affirmative, a new issue must be created for that task.&lt;/p&gt;

&lt;p&gt;Then, the &quot;encode&quot;/&quot;decode&quot; functions will disappear (by design) and so will the issue about &quot;inputSigma&quot;.&lt;br/&gt;
Unit tests &quot;testConstrainedRosen&quot; and &quot;testFitAccuracyDependsOnBoundary&quot; will also be removed since the internal support form boundaries won&apos;t exist anymore.&lt;br/&gt;
All issues solved in one fell swoop! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13466238" author="jolievie" created="Sat, 29 Sep 2012 13:45:45 +0000"  >&lt;p&gt;This issue&apos;s bug is not solved by v1 alone. The way how to check the boundaries in isFeasible and the method repair must be adapted to the encode/decode function, otherwise a more severe bug has been introduced (even if it would pass all tests). I agree that v1, along with corrected boundary checks, can solve the issue. However v2 makes the remaining modifications simpler. &lt;/p&gt;

&lt;p&gt;Besides, the testConstrainedRosen must not fail, definitely not! &lt;/p&gt;</comment>
                            <comment id="13466239" author="jolievie" created="Sat, 29 Sep 2012 13:54:18 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Since in some previous comments, you indicated that boundaries do not necessarily need to be taken into account inside the CMAES algorithm, a possibility is to review the entire code, and remove all code related to boundaries.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I believe that this must be a misunderstanding. We do not need the transformation into &lt;span class=&quot;error&quot;&gt;&amp;#91;0,1&amp;#93;&lt;/span&gt; (or any other transformation for that matter) to take into account boundaries. But we need to possibly take into account the boundaries within CMAES, if the returned solution is supposed to be in the bounds. &lt;/p&gt;
</comment>
                            <comment id="13466240" author="jolievie" created="Sat, 29 Sep 2012 13:59:59 +0000"  >&lt;p&gt;regarding the documentation of inputSigma: I don&apos;t see in what sense the doc says that it depends on the bounds. The doc says how it should be set (but this is a bit blurry, to the extend of how &quot;initial search volume&quot; and &quot;initial search region&quot; are interpreted)&lt;/p&gt;</comment>
                            <comment id="13466243" author="erans" created="Sat, 29 Sep 2012 14:36:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;This issue&apos;s bug is not solved by v1 alone. The way how to check the boundaries in isFeasible and the method repair must be adapted to the encode/decode function, otherwise a more severe bug has been introduced (even if it would pass all tests).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This was assumed; I only copied the &quot;decode&quot; function here, but the rest was changed accordingly, and the result is as I described (and the same as obtained by Frank, see above).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;However v2 makes the remaining modifications simpler.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The problem is that we don&apos;t know what are &quot;the remaining modifications&quot;: we never got beyond to the point were both &quot;testFitAccuracyDependsOnBoundary&quot; and &quot;testConstrainedRosen&quot; pass.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But we need to possibly take into account the boundaries within CMAES, if the returned solution is supposed to be in the bounds.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There are two different things:&lt;br/&gt;
1. Does the existence of constraints modify the search procedure is some way (i.e. CMAES must &quot;know&quot; that it deals with boundaries)?&lt;br/&gt;
2. Alternately, is it possible to pass a modified objective function (in which the allowed range of the original objective function has been mapped to the &lt;span class=&quot;error&quot;&gt;&amp;#91;-inf, +inf&amp;#93;&lt;/span&gt; interval) and have CMAES behave the same (i.e. find the same solution)?&lt;/p&gt;

&lt;p&gt;In the second alternative, CM has adapter classes (e.g. &quot;MultivariateFunctionPenaltyAdapter&quot;) that handle the mapping (and re-implementing it within each optimizer is an unnecessary source of bugs).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;regarding the documentation of inputSigma: I don&apos;t see in what sense the doc says that it depends on the bounds.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Then what is &quot;initial search volume&quot;?&lt;br/&gt;
I interpret the doc as roughly saying &quot;0.3 times the range&quot;. Perhaps this is wrong, in which case it should be made clearer...&lt;br/&gt;
We noticed that very small or very large values for &quot;sigma&quot; did not work; so maybe we should say &quot;inputSigma must be of order 1&quot; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;</comment>
                            <comment id="13466246" author="jolievie" created="Sat, 29 Sep 2012 15:30:35 +0000"  >&lt;blockquote&gt;
&lt;p&gt;However v2 makes the remaining modifications simpler.&lt;br/&gt;
The problem is that we don&apos;t know what are &quot;the remaining modifications&quot;: &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I thought I knew... &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;we never got beyond to the point were both &quot;testFitAccuracyDependsOnBoundary&quot; and &quot;testConstrainedRosen&quot; pass.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;the former, because inputSigma was not adapted appropriately, the latter because the test against boundaries was not adapted appropriately. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There are two different things:&lt;br/&gt;
1. Does the existence of constraints modify the search procedure is some way (i.e. CMAES must &quot;know&quot; that it deals with boundaries)?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yes. Otherwise it will sample and evaluation points outside the boundaries. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2. Alternately, is it possible to pass a modified objective function (in which the allowed range of the original objective function has been mapped to the &lt;span class=&quot;error&quot;&gt;&amp;#91;-inf, +inf&amp;#93;&lt;/span&gt; interval) and have CMAES behave the same (i.e. find the same solution)?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;probably not the same, but possibly reasonably well, unless the boundary is mapped to (or close to) inf, which is likely to lead to unexpected results, if the optimum is on (or close to) the boundary. &lt;/p&gt;

&lt;p&gt;checking MultivariateFunctionPenaltyAdapter (which does not map the parameters, rather computes a penalty), the answer is likely to be no, if the optimal solution happens to be on (or very close to) the bound. The methods developed for CMA-ES should work much better in this case. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;regarding the documentation of inputSigma: I don&apos;t see in what sense the doc says that it depends on the bounds.&lt;br/&gt;
Then what is &quot;initial search volume&quot;?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;the volume/region where points are likely to be sampled in the beginning of the search. Points beyond, say, startpoint + 10*sigma are not likely to be sampled in the beginning. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I interpret the doc as roughly saying &quot;0.3 times the range&quot;. Perhaps this is wrong, in which case it should be made clearer...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I agree, it is not clear (I guess it was taken from another doc and slightly changed context). &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We noticed that very small or very large values for &quot;sigma&quot; did not work; so maybe we should say &quot;inputSigma must be of order 1&quot; .&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;no, it entirely depends on how far we expect the optimal solution to be from the start solution. Putting it differently: one could rescale parameters by a factor 1000 (say in one case it is km, in the other m), then one would need to rescale inputSigma accordingly (which would not be in the order of one). &lt;/p&gt;

&lt;p&gt;Codes I write typically don&apos;t accept a default value for inputSigma, basically for this reason. I agree however that a value of 1 might often turn out OK. &lt;/p&gt;
</comment>
                            <comment id="13466253" author="jolievie" created="Sat, 29 Sep 2012 15:56:21 +0000"  >&lt;p&gt;just another motivation: inputSigma is related to the uncertainty on getStartPoint(), as we cannot intrinsically know whether this is in the order of 1 or 1e-4 or 1e4 or 10e23. &lt;/p&gt;</comment>
                            <comment id="13466269" author="erans" created="Sat, 29 Sep 2012 17:13:09 +0000"  >&lt;p&gt;Revision 1391840 contains modified &quot;encode&quot; and &quot;decode&quot; functions. Both unit tests now pass (for &quot;testConstrainedRosen&quot; I had to move the initial guess closer to the solution).&lt;/p&gt;

&lt;p&gt;No change was required for &quot;inputSigma&quot;; I still do not understand why it works as is (cf. lines 588, 589). And I have no idea how to improve the documentation...&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;yes. Otherwise it will sample and evaluation points outside the boundaries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, because the modified objective function wouldn&apos;t have boundaries.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;probably not the same, but possibly reasonably well, unless the boundary is mapped to (or close to) inf, which is likely to lead to unexpected results, if the optimum is on (or close to) the boundary. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In such a case, I imagine that a &quot;penalty&quot; adapter would work better than a &quot;mapping&quot; adapter. Both are available.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The methods developed for CMA-ES should work much better in this case. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hence, unless someone wants to try it out, we&apos;ll of course trust you &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; and leave the internal boundary handling in place.&lt;/p&gt;</comment>
                            <comment id="13466297" author="jolievie" created="Sat, 29 Sep 2012 19:21:41 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Revision 1391840 contains modified &quot;encode&quot; and &quot;decode&quot; functions. Both unit tests now pass (for &quot;testConstrainedRosen&quot; I had to move the initial guess closer to the solution).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;if the test does not pass with initial point at 0.1, something is wrong (and it doesn&apos;t look like a good idea to change the test to make the code pass). &lt;/p&gt;

&lt;p&gt;I found at least one problem:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] repair(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] x) {
            &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] repaired = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[x.length];
            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; x.length; i++) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (x[i] &amp;lt; 0) {
                    repaired[i] = 0;
                } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (x[i] &amp;gt; 1.0) {
                    repaired[i] = 1.0;
                } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
                    repaired[i] = x[i];
                }
            }
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; repaired;
        }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;must read &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] repair(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] x) {
            &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] repaired = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[x.length];
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (boundaries == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; x.length; i++) {
                    repaired[i] = x[i];
                }
            } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {

                &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] bLoEnc = encode(boundaries[0]);
                &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[] bHiEnc = encode(boundaries[1]);

                &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; x.length; i++) {
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (x[i] &amp;lt; bLoEnc[i]) {
                        repaired[i] = bLoEnc[i];
                    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (x[i] &amp;gt; bHiEnc[i]) {
                        repaired[i] = bHiEnc[i];
                    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
                        repaired[i] = x[i];
                    }
                }
            }
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; repaired;
    }


&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I am not sure whether or not this is the reason why the test fails. &lt;/p&gt;</comment>
                            <comment id="13466308" author="jolievie" created="Sat, 29 Sep 2012 20:48:45 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Revision 1391840 contains modified &quot;encode&quot; and &quot;decode&quot; functions. Both unit tests now pass (for &quot;testConstrainedRosen&quot; I had to move the initial guess closer to the solution).&lt;br/&gt;
No change was required for &quot;inputSigma&quot;; I still do not understand why it works as is (cf. lines 588, 589). &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;to me it makes perfectly sense: luckily enough line 589 performs the same transformation on inputSigma as the encode function on getStartPoint() (maybe this should be mentioned in a comment?). As the transformation is linear, the situations before and after the transformations are mathematically equivalent (the bug came from loosing digits due to a subtraction, which is now omitted). As said before it would simplify the code if both transformations were omitted (but we could leave this to another issue). &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;And I have no idea how to improve the documentation...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I&apos;ll think about it. &lt;/p&gt;</comment>
                            <comment id="13466309" author="jolievie" created="Sat, 29 Sep 2012 20:55:10 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Hence, unless someone wants to try it out, we&apos;ll of course trust you  and leave the internal boundary handling in place.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I spent several hundreds of hours (really!) to investigate (and try to understand) this with the greatest care I was able to. That of course doesn&apos;t mean there could be still surprises out there...&lt;/p&gt;</comment>
                            <comment id="13466310" author="erans" created="Sat, 29 Sep 2012 21:00:30 +0000"  >&lt;p&gt;Thanks for looking into this. Unfortunately, a copy/paste of your version of &quot;repair&quot; (which I totally agree with) makes the tests fail again!&lt;/p&gt;

&lt;p&gt;And we can also worry that the tests pass with the wrong version...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;if the test does not pass with initial point at 0.1, something is wrong (and it doesn&apos;t look like a good idea to change the test to make the code pass).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I certainly agree. But since there was something wrong before in the code, one could also imagine that it was because of the problem that it passed before...&lt;/p&gt;</comment>
                            <comment id="13466313" author="erans" created="Sat, 29 Sep 2012 21:05:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;As said before it would simplify the code if both transformations were omitted (but we could leave this to another issue). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I would like to, but as I said, the identity transformation makes one of the tests fail.&lt;/p&gt;

&lt;p&gt;It must be because something else in the code assumes that the parameters have been restricted into the &lt;span class=&quot;error&quot;&gt;&amp;#91;0, 1&amp;#93;&lt;/span&gt; interval, which is not true anymore.&lt;/p&gt;

&lt;p&gt;I wonder whether the various matrices (around lines 380) are computed based on this assumption...&lt;/p&gt;</comment>
                            <comment id="13466317" author="jolievie" created="Sat, 29 Sep 2012 21:11:06 +0000"  >&lt;p&gt;I have corrected the repair: the last assignment &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;                    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
                        repaired[i] = x[i];
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;was missing (sorry). Now there is some chance that it might pass...&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I certainly agree. But since there was something wrong before in the code, one could also imagine that it was because of the problem that it passed before...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;that seems somehow irrelevant: it is an absolute statement about the algorithm, that an implementation of it must pass this test. It&apos;s not related to the question when and why it has already been past or not. &lt;/p&gt;

&lt;p&gt;otherwise, the code was, AFAICS, not wrong before unless with boundary values as large as 1e16 in absolute value. &lt;/p&gt;</comment>
                            <comment id="13466319" author="jolievie" created="Sat, 29 Sep 2012 21:21:29 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I would like to, but as I said, the identity transformation makes one of the tests fail.&lt;br/&gt;
It must be because something else in the code assumes that the parameters have been restricted into the &lt;span class=&quot;error&quot;&gt;&amp;#91;0, 1&amp;#93;&lt;/span&gt; interval, which is not true anymore.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The reason is IMHO line 589, which does need to be changed according to the change in encode/decode. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I wonder whether the various matrices (around lines 380) are computed based on this assumption...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I would not worry much, I am pretty sure they are not. &lt;/p&gt;</comment>
                            <comment id="13466323" author="erans" created="Sat, 29 Sep 2012 21:34:15 +0000"  >&lt;blockquote&gt;&lt;p&gt;to me it makes perfectly sense: luckily enough line 589 performs the same transformation on inputSigma as the encode function on getStartPoint() &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I may be missing something (and I can just make wild guesses since I have no clue about the CMAES algorithm) but I would be expecting that the code behaves the same way without boundaries as with boundaries that become arbitrarily large (i.e. when the &lt;span class=&quot;error&quot;&gt;&amp;#91;loBound, hiBound&amp;#93;&lt;/span&gt; interval becomes &lt;span class=&quot;error&quot;&gt;&amp;#91;-inf, +inf&amp;#93;&lt;/span&gt;).&lt;br/&gt;
The line that uses &quot;inputSigma&quot; does not behave that way since the &quot;range&quot; becomes arbitrarily large as the bounds grow although when there is no boundaries it is set 1.0.&lt;/p&gt;

&lt;p&gt;This is also shown by some unit tests which I&apos;ve just set up, by copying existing ones which minimized a function without constraint and specifying a very large allowed interval (e.g. &lt;span class=&quot;error&quot;&gt;&amp;#91;-1e20, 1e20&amp;#93;&lt;/span&gt;): those tests fail.&lt;br/&gt;
Intuitively, when the solution is far from the bounds (and the initial point also), whether there are bounds or not should not matter. But with the current implementation that&apos;s clearly not the case.&lt;/p&gt;</comment>
                            <comment id="13466327" author="erans" created="Sat, 29 Sep 2012 21:42:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;The reason is IMHO line 589, which does need to be changed according to the change in encode/decode. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That cannot be the end of the story; I&apos;ve just tried:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;remove the division by &quot;range&quot; on that line&lt;/li&gt;
	&lt;li&gt;&quot;encode&quot; and &quot;decode&quot; are the identity&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;And the two tests still fail.&lt;/p&gt;</comment>
                            <comment id="13466328" author="jolievie" created="Sat, 29 Sep 2012 21:42:42 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I may be missing something (and I can just make wild guesses since I have no clue about the CMAES algorithm) but I would be expecting that the code behaves the same way without boundaries as with boundaries that become arbitrarily large (i.e. when the &lt;span class=&quot;error&quot;&gt;&amp;#91;loBound, hiBound&amp;#93;&lt;/span&gt; interval becomes &lt;span class=&quot;error&quot;&gt;&amp;#91;-inf, +inf&amp;#93;&lt;/span&gt;).&lt;br/&gt;
The line that uses &quot;inputSigma&quot; does not behave that way since the &quot;range&quot; becomes arbitrarily large as the bounds grow although when there is no boundaries it is set 1.0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;as both, x and sigma are transformed in the same way it does not matter mathematically. If you choose boundaries as large as (close to) maxdouble, it will matter numerically. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is also shown by some unit tests which I&apos;ve just set up, by copying existing ones which minimized a function without constraint and specifying a very large allowed interval (e.g. &lt;span class=&quot;error&quot;&gt;&amp;#91;-1e20, 1e20&amp;#93;&lt;/span&gt;): those tests fail.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;did you correct the mistake in the repair method I proposed above? &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Intuitively, when the solution is far from the bounds (and the initial point also), whether there are bounds or not should not matter. But with the current implementation that&apos;s clearly not the case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I agree. I am confident we will be able to sort this out. &lt;/p&gt;</comment>
                            <comment id="13466331" author="jolievie" created="Sat, 29 Sep 2012 21:45:43 +0000"  >&lt;blockquote&gt;
&lt;p&gt;And the two tests still fail.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;did you correct the bug in the repair method that I proposed above? &lt;/p&gt;</comment>
                            <comment id="13466333" author="erans" created="Sat, 29 Sep 2012 21:47:49 +0000"  >&lt;blockquote&gt;&lt;p&gt;I have corrected the repair: the last assignment &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oops, I had missed that comment.&lt;br/&gt;
That&apos;s much better now. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13466344" author="erans" created="Sat, 29 Sep 2012 22:28:23 +0000"  >&lt;p&gt;Revision 1391908 contains the cleaned up code:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;All limitations concerning boundary specifications removed. This supersedes the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-865&quot; title=&quot;Wide bounds to CMAESOptimizer result in NaN parameters passed to fitness function&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-865&quot;&gt;&lt;del&gt;MATH-865&lt;/del&gt;&lt;/a&gt;.&lt;/li&gt;
	&lt;li&gt;Methods &quot;encode&quot; and &quot;decode&quot; removed.&lt;/li&gt;
	&lt;li&gt;&quot;sigmaArray&quot; is assigned the values from &quot;inputSigma&quot; (or 0.3 if &quot;inputSigma&quot; is null). This probably also solves &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-868&quot; title=&quot;Default sigma for CMAESOptimizer is wrong when using bounds&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-868&quot;&gt;&lt;del&gt;MATH-868&lt;/del&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Please test.&lt;/p&gt;</comment>
                            <comment id="13466345" author="erans" created="Sat, 29 Sep 2012 22:32:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;did you correct the bug in the repair method that I proposed above?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes. There was some unnecessary fiddling because of asynchronous updates of this page and the email notifications of those updates...&lt;/p&gt;</comment>
                            <comment id="13466811" author="fhess" created="Mon, 1 Oct 2012 14:01:32 +0000"  >&lt;p&gt;I looked at the commits, and ran the tests locally.  FWIW, everything looks fine to me now.&lt;/p&gt;</comment>
                            <comment id="13466900" author="erans" created="Mon, 1 Oct 2012 16:09:01 +0000"  >&lt;p&gt;Thanks; I&apos;ll thus set this issue as &quot;resolved&quot;.&lt;/p&gt;</comment>
                            <comment id="13467764" author="jolievie" created="Tue, 2 Oct 2012 14:46:50 +0000"  >&lt;blockquote&gt;
&lt;p&gt;And I have no idea how to improve the documentation...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Here are my suggestions: Replace (several times) &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;     * @param inputSigma Initial search volume; sigma of offspring objective variables.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;with &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;     * @param inputSigma Initial standard deviations to sample &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; points from startPoint
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    /**
     * Individual sigma values - initial search volume. inputSigma determines
     * the initial coordinate wise standard deviations &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the search. Setting
     * SIGMA one third of the initial search region is appropriate.
     */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    /**
     * Values in inputSigma define the initial coordinate-wise 
     * standard deviations &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; sampling &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; search points about 
     * startPoint. 
     * Setting inputSigma roughly to the predicted distance of 
     * startPoint to the actually desired optimum is appropriate. 
     * Small values &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; inputSigma induce the search to be more local
     * and very small values are more likely to find a local optimum 
     * close to startPoint. 
     * Extremely small values will however lead to early termination. 
     */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13468711" author="erans" created="Wed, 3 Oct 2012 18:10:25 +0000"  >&lt;p&gt;Thanks. The improved Javadoc is in revision 1393641.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12547005" name="MATH867_patch" size="8133" author="fhess" created="Fri, 28 Sep 2012 15:42:23 +0000"/>
                            <attachment id="12546110" name="Math867Test.java" size="1746" author="fhess" created="Fri, 21 Sep 2012 23:00:47 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>292266</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 7 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0rsxb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160330</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>