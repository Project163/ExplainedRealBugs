<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 20:22:47 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[MATH-705] DormandPrince853 integrator leads to revisiting of state events</title>
                <link>https://issues.apache.org/jira/browse/MATH-705</link>
                <project id="12310485" key="MATH">Commons Math</project>
                    <description>&lt;p&gt;See the attached ReappearingEventTest.java. It has two unit tests, which use either the DormandPrince853 or the GraggBulirschStoer integrator, on the same ODE problem. It is a problem starting at time 6.0, with 7 variables, and 1 state event. The state event was previously detected at time 6.0, which is why I start there now. I provide and end time of 10.0. Since I start at the state event, I expect to integrate all the way to the end (10.0). For the GraggBulirschStoer this is what happens (see attached ReappearingEventTest.out). For the DormandPrince853Integerator, it detects a state event and stops integration at 6.000000000000002.&lt;/p&gt;

&lt;p&gt;I think the problem becomes clear by looking at the output in ReappearingEventTest.out, in particular these lines:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;computeDerivatives: t=6.0                  y=[2.0                 , 2.0                 , 2.0                 , 4.0                 , 2.0                 , 7.0                 , 15.0                ]
(...)
g                 : t=6.0                  y=[1.9999999999999996  , 1.9999999999999996  , 1.9999999999999996  , 4.0                 , 1.9999999999999996  , 7.0                 , 14.999999999999998  ]
(...)
final result      : t=6.000000000000002    y=[2.0000000000000013  , 2.0000000000000013  , 2.0000000000000013  , 4.000000000000002   , 2.0000000000000013  , 7.000000000000002   , 15.0                ]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The initial value of the last variable in y, the one that the state event refers to, is 15.0. However, the first time it is given to the g function, the value is 14.999999999999998. This value is less than 15, and more importantly, it is a value from the past (as all functions are increasing), &lt;b&gt;before&lt;/b&gt; the state event. This makes that the state event re-appears immediately, and integration stops at 6.000000000000002 because of the detected state event.&lt;/p&gt;

&lt;p&gt;I find it puzzling that for the DormandPrince853Integerator the y array that is given to the first evaluation of the g function, has different values than the y array that is the input to the problem. For GraggBulirschStoer is can be seen that the y arrays have identical values.&lt;/p&gt;</description>
                <environment>&lt;p&gt;Commons Math trunk, Java 6, Linux&lt;/p&gt;</environment>
        <key id="12530878">MATH-705</key>
            <summary>DormandPrince853 integrator leads to revisiting of state events</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="luc">Luc Maisonobe</assignee>
                                    <reporter username="dhendriks">Dennis Hendriks</reporter>
                        <labels>
                    </labels>
                <created>Wed, 9 Nov 2011 13:29:25 +0000</created>
                <updated>Sat, 24 Mar 2012 16:16:54 +0000</updated>
                            <resolved>Sun, 27 Nov 2011 14:34:04 +0000</resolved>
                                    <version>3.0</version>
                                    <fixVersion>3.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                                                                <comments>
                            <comment id="13147039" author="dhendriks" created="Wed, 9 Nov 2011 13:31:35 +0000"  >&lt;p&gt;The Java unit tests that show the problem, and the console output they give, as described in the issue description.&lt;/p&gt;</comment>
                            <comment id="13147240" author="luc" created="Wed, 9 Nov 2011 19:57:08 +0000"  >&lt;p&gt;The reason for this strange behavior is that g function evaluations are based on the integrator-specific interpolator.&lt;/p&gt;

&lt;p&gt;Each integration method has its specific algorithm and preserve a rich internal data set. From this data set, it is possible to build an interpolator which is specific to the integrator and in fact share part of the data set (they reference the same arrays). So integrator and interpolator are tightly bound together.&lt;/p&gt;

&lt;p&gt;For embedded Runge-Kutta methods like Dormand-Prince 8(5,3), this data set corresponds to one state vector value and several state vector derivatives sampled throughout the step. When the step is accepted after error estimation, the state value is set to the value at end of step and the interpolator is called. So the equations of the interpolator are written in such a way interpolation is backward: we start from the end state and roll back to beginning of step. This explains why when we roll all the way back to step start, we may find a state that is not exactly the one we started from, due to both the integration order and interpolation order.&lt;/p&gt;

&lt;p&gt;For Gragg-Bulirsch-Stoer, the data set corresponds to one state vector value and derivatives at several orders, all taken at step middle point. When the step is accepted after error estimation, the interpolator is called before the state value is set to the value at end of step and. So the equations of the interpolator are written in such a way interpolation is forward: we start from the start state and go on towards end of step. This explains why when we go all the way to step end, we may find a state that is not exactly the one that will be used for next step, due to both the integration order and interpolation order.&lt;/p&gt;

&lt;p&gt;So one integrator type is more consistent at step start and has more error at step end, while the other integrator has a reversed behavior.&lt;/p&gt;

&lt;p&gt;In any case, the interpolation that is used (and in fact the integration data set it is based upon) are not error free. The error is related to step size.&lt;/p&gt;

&lt;p&gt;We could perhaps rewrite some interpolators by preserving both start state s(t&lt;span class=&quot;error&quot;&gt;&amp;#91;k&amp;#93;&lt;/span&gt;) and end state s(t&lt;span class=&quot;error&quot;&gt;&amp;#91;k+1&amp;#93;&lt;/span&gt;) and switching between two hal model as follows:&lt;br/&gt;
  i(t) = s(t&lt;span class=&quot;error&quot;&gt;&amp;#91;k&amp;#93;&lt;/span&gt;)   + forwardModel(t&lt;span class=&quot;error&quot;&gt;&amp;#91;k&amp;#93;&lt;/span&gt;, t)    if t &amp;lt;= (t&lt;span class=&quot;error&quot;&gt;&amp;#91;k&amp;#93;&lt;/span&gt; + t&lt;span class=&quot;error&quot;&gt;&amp;#91;k+1&amp;#93;&lt;/span&gt;)/2&lt;br/&gt;
and&lt;br/&gt;
  i(t) = s(t&lt;span class=&quot;error&quot;&gt;&amp;#91;k+1&amp;#93;&lt;/span&gt;) + backwardModel(t, t&lt;span class=&quot;error&quot;&gt;&amp;#91;k+1&amp;#93;&lt;/span&gt;) if t &amp;gt; (t&lt;span class=&quot;error&quot;&gt;&amp;#91;k&amp;#93;&lt;/span&gt; + t&lt;span class=&quot;error&quot;&gt;&amp;#91;k+1&amp;#93;&lt;/span&gt;)/2&lt;/p&gt;

&lt;p&gt;This would make interpolator more consistent with integrator at both step start and step end and perhaps reduce this problem. This would however not be perfect, as it will introduce a small error at junction point. I&apos;m not sure if it would be easy or not, we would have to review all interpolators and all integrators for that. All models are polynomial ones.&lt;/p&gt;

&lt;p&gt;Note that the problem should not appear for Adams methods (when they will be considered validated ...), because in this case, it is the interpolator that is built first and the integrator is in fact an application of the interpolator at step end! So interpolator and integrator are by definition always perfectly consistent with each other.&lt;/p&gt;

&lt;p&gt;What do you think ?&lt;/p&gt;

&lt;p&gt;Should we let this problem alone and consider we are in the grey zone of expected numerical inaccuracy due to integration/interpolation orders or should we attempt the two half-models trick ?&lt;/p&gt;</comment>
                            <comment id="13147712" author="dhendriks" created="Thu, 10 Nov 2011 14:31:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;Should we let this problem alone and consider we are in the grey zone of expected numerical inaccuracy due to integration/interpolation orders or should we attempt the two half-models trick?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I consider it important that events are properly detected, and are detected exactly once (if they occur exactly once). Therefore, in general, I think the half-models trick would be a good idea, as it is more important (to me) to have higher accuracy at the end points than in the middle. For me, the DormandPrince853Integrator is now practically useless.&lt;/p&gt;</comment>
                            <comment id="13153884" author="luc" created="Sun, 20 Nov 2011 21:44:21 +0000"  >&lt;p&gt;This issue should be fixed in subversion repository as of r1204270.&lt;/p&gt;

&lt;p&gt;Could you check it works for you ? If so, I will use the same trick for other Runge-Kutta type step interpolators.&lt;/p&gt;</comment>
                            <comment id="13154054" author="dhendriks" created="Mon, 21 Nov 2011 07:46:33 +0000"  >&lt;blockquote&gt;&lt;p&gt;This issue should be fixed in subversion repository as of r1204270. Could you check it works for you ? If so, I will use the same trick for other Runge-Kutta type step interpolators.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It seems to work perfectly. Thanks!&lt;/p&gt;</comment>
                            <comment id="13157908" author="luc" created="Sun, 27 Nov 2011 14:34:04 +0000"  >&lt;p&gt;Fixed in subversion repository as of r1206723.&lt;/p&gt;

&lt;p&gt;Applied same method to all Runge-Kutta based integrators.&lt;/p&gt;

&lt;p&gt;Thanks for the report.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12503077" name="ReappearingEventTest.java" size="2919" author="dhendriks" created="Wed, 9 Nov 2011 13:31:35 +0000"/>
                            <attachment id="12503078" name="ReappearingEventTest.out" size="20882" author="dhendriks" created="Wed, 9 Nov 2011 13:31:35 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>216616</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 51 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0aosn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>60290</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>