diff --git a/findbugs-exclude-filter.xml b/findbugs-exclude-filter.xml
index 86d0087f6..7a90945c5 100644
--- a/findbugs-exclude-filter.xml
+++ b/findbugs-exclude-filter.xml
@@ -81,9 +81,9 @@
   <!-- The following equality test is intentional and needed for semantic purposes -->
   <Match>
     <Or>
-      <Class name="org.apache.commons.math4.geometry.euclidean.oned.Vector1D" />
-      <Class name="org.apache.commons.math4.geometry.euclidean.twod.Vector2D" />
-      <Class name="org.apache.commons.math4.geometry.euclidean.threed.Vector3D" />
+      <Class name="org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D" />
+      <Class name="org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D" />
+      <Class name="org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D" />
     </Or>
     <Method name="equals" params="java.lang.Object" returns="boolean" />
     <Bug pattern="FE_FLOATING_POINT_EQUALITY" />
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Cartesian3D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Cartesian3D.java
index 85696f651..5dc04c508 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Cartesian3D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Cartesian3D.java
@@ -196,7 +196,7 @@ public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euc
 
     /** Get the abscissa of the vector.
      * @return abscissa of the vector
-     * @see #Vector3D(double, double, double)
+     * @see #Cartesian3D(double, double, double)
      */
     public double getX() {
         return x;
@@ -204,7 +204,7 @@ public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euc
 
     /** Get the ordinate of the vector.
      * @return ordinate of the vector
-     * @see #Vector3D(double, double, double)
+     * @see #Cartesian3D(double, double, double)
      */
     public double getY() {
         return y;
@@ -212,7 +212,7 @@ public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euc
 
     /** Get the height of the vector.
      * @return height of the vector
-     * @see #Vector3D(double, double, double)
+     * @see #Cartesian3D(double, double, double)
      */
     public double getZ() {
         return z;
@@ -220,7 +220,7 @@ public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euc
 
     /** Get the vector coordinates as a dimension 3 array.
      * @return vector coordinates
-     * @see #Vector3D(double[])
+     * @see #Cartesian3D(double[])
      */
     public double[] toArray() {
         return new double[] { x, y, z };
@@ -266,7 +266,7 @@ public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euc
 
     /** Get the azimuth of the vector.
      * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;
-     * @see #Vector3D(double, double)
+     * @see #Cartesian3D(double, double)
      */
     public double getAlpha() {
         return FastMath.atan2(y, x);
@@ -274,7 +274,7 @@ public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euc
 
     /** Get the elevation of the vector.
      * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2
-     * @see #Vector3D(double, double)
+     * @see #Cartesian3D(double, double)
      */
     public double getDelta() {
         return FastMath.asin(z / getNorm());
@@ -324,9 +324,9 @@ public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euc
      * following example shows how to build a frame having the k axis
      * aligned with the known vector u :
      * <pre><code>
-     *   Vector3D k = u.normalize();
-     *   Vector3D i = k.orthogonal();
-     *   Vector3D j = Vector3D.crossProduct(k, i);
+     *   Cartesian3D k = u.normalize();
+     *   Cartesian3D i = k.orthogonal();
+     *   Cartesian3D j = Cartesian3D.crossProduct(k, i);
      * </code></pre></p>
      * @return a new normalized vector orthogonal to the instance
      * @exception MathArithmeticException if the norm of the instance is null
@@ -423,8 +423,8 @@ public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euc
      *
      * @param other Object to test for equality to this
      * @return true if two 3D vector objects are equal, false if
-     *         object is null, not an instance of Vector3D, or
-     *         not equal to this Vector3D instance
+     *         object is null, not an instance of Cartesian3D, or
+     *         not equal to this Cartesian3D instance
      *
      */
     @Override
@@ -476,7 +476,7 @@ public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euc
 
     /** Compute the cross-product of the instance with another vector.
      * @param v other vector
-     * @return the cross product this ^ v as a new Vector3D
+     * @return the cross product this ^ v as a new Cartesian3D
      */
     public Cartesian3D crossProduct(final Vector<Euclidean3D> v) {
         final Cartesian3D v3 = (Cartesian3D) v;
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotation.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotation.java
index 6392e3f83..d3853c0c5 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotation.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotation.java
@@ -815,9 +815,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
         } else {
             if (order == RotationOrder.XYZ) {
 
-                // r (Vector3D.plusI) coordinates are :
+                // r (Cartesian3D.plusI) coordinates are :
                 //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)
-                // (-r) (Vector3D.plusK) coordinates are :
+                // (-r) (Cartesian3D.plusK) coordinates are :
                 // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)
                 // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_I);
@@ -831,9 +831,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.XZY) {
 
-                // r (Vector3D.plusI) coordinates are :
+                // r (Cartesian3D.plusI) coordinates are :
                 // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)
-                // (-r) (Vector3D.plusJ) coordinates are :
+                // (-r) (Cartesian3D.plusJ) coordinates are :
                 // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)
                 // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_I);
@@ -847,9 +847,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.YXZ) {
 
-                // r (Vector3D.plusJ) coordinates are :
+                // r (Cartesian3D.plusJ) coordinates are :
                 // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)
-                // (-r) (Vector3D.plusK) coordinates are :
+                // (-r) (Cartesian3D.plusK) coordinates are :
                 // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)
                 // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_J);
@@ -863,9 +863,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.YZX) {
 
-                // r (Vector3D.plusJ) coordinates are :
+                // r (Cartesian3D.plusJ) coordinates are :
                 // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)
-                // (-r) (Vector3D.plusI) coordinates are :
+                // (-r) (Cartesian3D.plusI) coordinates are :
                 // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)
                 // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_J);
@@ -879,9 +879,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.ZXY) {
 
-                // r (Vector3D.plusK) coordinates are :
+                // r (Cartesian3D.plusK) coordinates are :
                 //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)
-                // (-r) (Vector3D.plusJ) coordinates are :
+                // (-r) (Cartesian3D.plusJ) coordinates are :
                 // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)
                 // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_K);
@@ -895,9 +895,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.ZYX) {
 
-                // r (Vector3D.plusK) coordinates are :
+                // r (Cartesian3D.plusK) coordinates are :
                 //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)
-                // (-r) (Vector3D.plusI) coordinates are :
+                // (-r) (Cartesian3D.plusI) coordinates are :
                 // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)
                 // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_K);
@@ -911,9 +911,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.XYX) {
 
-                // r (Vector3D.plusI) coordinates are :
+                // r (Cartesian3D.plusI) coordinates are :
                 //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)
-                // (-r) (Vector3D.plusI) coordinates are :
+                // (-r) (Cartesian3D.plusI) coordinates are :
                 // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)
                 // and we can choose to have theta in the interval [0 ; PI]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_I);
@@ -927,9 +927,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.XZX) {
 
-                // r (Vector3D.plusI) coordinates are :
+                // r (Cartesian3D.plusI) coordinates are :
                 //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)
-                // (-r) (Vector3D.plusI) coordinates are :
+                // (-r) (Cartesian3D.plusI) coordinates are :
                 // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)
                 // and we can choose to have psi in the interval [0 ; PI]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_I);
@@ -943,9 +943,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.YXY) {
 
-                // r (Vector3D.plusJ) coordinates are :
+                // r (Cartesian3D.plusJ) coordinates are :
                 // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
-                // (-r) (Vector3D.plusJ) coordinates are :
+                // (-r) (Cartesian3D.plusJ) coordinates are :
                 //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
                 // and we can choose to have phi in the interval [0 ; PI]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_J);
@@ -959,9 +959,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.YZY) {
 
-                // r (Vector3D.plusJ) coordinates are :
+                // r (Cartesian3D.plusJ) coordinates are :
                 // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
-                // (-r) (Vector3D.plusJ) coordinates are :
+                // (-r) (Cartesian3D.plusJ) coordinates are :
                 //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
                 // and we can choose to have psi in the interval [0 ; PI]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_J);
@@ -975,9 +975,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else if (order == RotationOrder.ZXZ) {
 
-                // r (Vector3D.plusK) coordinates are :
+                // r (Cartesian3D.plusK) coordinates are :
                 // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
-                // (-r) (Vector3D.plusK) coordinates are :
+                // (-r) (Cartesian3D.plusK) coordinates are :
                 //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
                 // and we can choose to have phi in the interval [0 ; PI]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_K);
@@ -991,9 +991,9 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
 
             } else { // last possibility is ZYZ
 
-                // r (Vector3D.plusK) coordinates are :
+                // r (Cartesian3D.plusK) coordinates are :
                 // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
-                // (-r) (Vector3D.plusK) coordinates are :
+                // (-r) (Cartesian3D.plusK) coordinates are :
                 //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
                 // and we can choose to have theta in the interval [0 ; PI]
                 FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_K);
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3D.java
index ac3162286..6f93fddc5 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3D.java
@@ -535,9 +535,9 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * following example shows how to build a frame having the k axis
      * aligned with the known vector u :
      * <pre><code>
-     *   Vector3D k = u.normalize();
-     *   Vector3D i = k.orthogonal();
-     *   Vector3D j = Vector3D.crossProduct(k, i);
+     *   Cartesian3D k = u.normalize();
+     *   Cartesian3D i = k.orthogonal();
+     *   Cartesian3D j = Cartesian3D.crossProduct(k, i);
      * </code></pre></p>
      * @return a new normalized vector orthogonal to the instance
      * @exception MathArithmeticException if the norm of the instance is null
@@ -707,8 +707,8 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      *
      * @param other Object to test for equality to this
      * @return true if two 3D vector objects are equal, false if
-     *         object is null, not an instance of Vector3D, or
-     *         not equal to this Vector3D instance
+     *         object is null, not an instance of FieldVector3D, or
+     *         not equal to this FieldVector3D instance
      *
      */
     @Override
@@ -776,7 +776,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
 
     /** Compute the cross-product of the instance with another vector.
      * @param v other vector
-     * @return the cross product this ^ v as a new Vector3D
+     * @return the cross product this ^ v as a new FieldVector3D
      */
     public FieldVector3D<T> crossProduct(final FieldVector3D<T> v) {
         return new FieldVector3D<>(x.linearCombination(y, v.z, z.negate(), v.y),
@@ -786,7 +786,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
 
     /** Compute the cross-product of the instance with another vector.
      * @param v other vector
-     * @return the cross product this ^ v as a new Vector3D
+     * @return the cross product this ^ v as a new FieldVector3D
      */
     public FieldVector3D<T> crossProduct(final Cartesian3D v) {
         return new FieldVector3D<>(x.linearCombination(v.getZ(), y, -v.getY(), z),
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Rotation.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Rotation.java
index 63e701735..a14eb6f14 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Rotation.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Rotation.java
@@ -72,8 +72,8 @@ import org.apache.commons.math4.util.MathArrays;
  * class does not push the user towards one specific definition and hence does not
  * provide methods like <code>projectVectorIntoDestinationFrame</code> or
  * <code>computeTransformedDirection</code>. It provides simpler and more generic
- * methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link
- * #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>
+ * methods: {@link #applyTo(Cartesian3D) applyTo(Cartesian3D)} and {@link
+ * #applyInverseTo(Cartesian3D) applyInverseTo(Cartesian3D)}.</p>
  *
  * <p>Since a rotation is basically a vectorial operator, several rotations can be
  * composed together and the composite operation <code>r = r<sub>1</sub> o
@@ -153,13 +153,13 @@ public class Rotation implements Serializable {
   /** Build a rotation from an axis and an angle.
    * <p>
    * Calling this constructor is equivalent to call
-   * {@link #Rotation(Vector3D, double, RotationConvention)
+   * {@link #Rotation(Cartesian3D, double, RotationConvention)
    * new Rotation(axis, angle, RotationConvention.VECTOR_OPERATOR)}
    * </p>
    * @param axis axis around which to rotate
    * @param angle rotation angle.
    * @exception MathIllegalArgumentException if the axis norm is zero
-   * @deprecated as of 3.6, replaced with {@link #Rotation(Vector3D, double, RotationConvention)}
+   * @deprecated as of 3.6, replaced with {@link #Rotation(Cartesian3D, double, RotationConvention)}
    */
   @Deprecated
   public Rotation(Cartesian3D axis, double angle) throws MathIllegalArgumentException {
@@ -518,7 +518,7 @@ public class Rotation implements Serializable {
    * {@link #getAxis(RotationConvention) getAxis(RotationConvention.VECTOR_OPERATOR)}
    * </p>
    * @return normalized axis of the rotation
-   * @see #Rotation(Vector3D, double, RotationConvention)
+   * @see #Rotation(Cartesian3D, double, RotationConvention)
    * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}
    */
   @Deprecated
@@ -534,7 +534,7 @@ public class Rotation implements Serializable {
    * </p>
    * @param convention convention to use for the semantics of the angle
    * @return normalized axis of the rotation
-   * @see #Rotation(Vector3D, double, RotationConvention)
+   * @see #Rotation(Cartesian3D, double, RotationConvention)
    * @since 3.6
    */
   public Cartesian3D getAxis(final RotationConvention convention) {
@@ -554,7 +554,7 @@ public class Rotation implements Serializable {
 
   /** Get the angle of the rotation.
    * @return angle of the rotation (between 0 and &pi;)
-   * @see #Rotation(Vector3D, double)
+   * @see #Rotation(Cartesian3D, double)
    */
   public double getAngle() {
     if ((q0 < -0.1) || (q0 > 0.1)) {
@@ -628,9 +628,9 @@ public class Rotation implements Serializable {
       if (convention == RotationConvention.VECTOR_OPERATOR) {
           if (order == RotationOrder.XYZ) {
 
-              // r (Vector3D.plusK) coordinates are :
+              // r (Cartesian3D.plusK) coordinates are :
               //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
-              // (-r) (Vector3D.plusI) coordinates are :
+              // (-r) (Cartesian3D.plusI) coordinates are :
               // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
               // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
@@ -646,9 +646,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.XZY) {
 
-              // r (Vector3D.plusJ) coordinates are :
+              // r (Cartesian3D.plusJ) coordinates are :
               // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
-              // (-r) (Vector3D.plusI) coordinates are :
+              // (-r) (Cartesian3D.plusI) coordinates are :
               // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
               // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
@@ -664,9 +664,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.YXZ) {
 
-              // r (Vector3D.plusK) coordinates are :
+              // r (Cartesian3D.plusK) coordinates are :
               //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
-              // (-r) (Vector3D.plusJ) coordinates are :
+              // (-r) (Cartesian3D.plusJ) coordinates are :
               // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
               // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
@@ -682,9 +682,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.YZX) {
 
-              // r (Vector3D.plusI) coordinates are :
+              // r (Cartesian3D.plusI) coordinates are :
               // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
-              // (-r) (Vector3D.plusJ) coordinates are :
+              // (-r) (Cartesian3D.plusJ) coordinates are :
               // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
               // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
@@ -700,9 +700,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.ZXY) {
 
-              // r (Vector3D.plusJ) coordinates are :
+              // r (Cartesian3D.plusJ) coordinates are :
               // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
-              // (-r) (Vector3D.plusK) coordinates are :
+              // (-r) (Cartesian3D.plusK) coordinates are :
               // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
               // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
@@ -718,9 +718,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.ZYX) {
 
-              // r (Vector3D.plusI) coordinates are :
+              // r (Cartesian3D.plusI) coordinates are :
               //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
-              // (-r) (Vector3D.plusK) coordinates are :
+              // (-r) (Cartesian3D.plusK) coordinates are :
               // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
               // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
@@ -736,9 +736,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.XYX) {
 
-              // r (Vector3D.plusI) coordinates are :
+              // r (Cartesian3D.plusI) coordinates are :
               //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
-              // (-r) (Vector3D.plusI) coordinates are :
+              // (-r) (Cartesian3D.plusI) coordinates are :
               // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
               // and we can choose to have theta in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
@@ -754,9 +754,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.XZX) {
 
-              // r (Vector3D.plusI) coordinates are :
+              // r (Cartesian3D.plusI) coordinates are :
               //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
-              // (-r) (Vector3D.plusI) coordinates are :
+              // (-r) (Cartesian3D.plusI) coordinates are :
               // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
               // and we can choose to have psi in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
@@ -772,9 +772,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.YXY) {
 
-              // r (Vector3D.plusJ) coordinates are :
+              // r (Cartesian3D.plusJ) coordinates are :
               //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
-              // (-r) (Vector3D.plusJ) coordinates are :
+              // (-r) (Cartesian3D.plusJ) coordinates are :
               // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
               // and we can choose to have phi in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
@@ -790,9 +790,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.YZY) {
 
-              // r (Vector3D.plusJ) coordinates are :
+              // r (Cartesian3D.plusJ) coordinates are :
               //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
-              // (-r) (Vector3D.plusJ) coordinates are :
+              // (-r) (Cartesian3D.plusJ) coordinates are :
               // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
               // and we can choose to have psi in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
@@ -808,9 +808,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.ZXZ) {
 
-              // r (Vector3D.plusK) coordinates are :
+              // r (Cartesian3D.plusK) coordinates are :
               //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
-              // (-r) (Vector3D.plusK) coordinates are :
+              // (-r) (Cartesian3D.plusK) coordinates are :
               // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
               // and we can choose to have phi in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
@@ -826,9 +826,9 @@ public class Rotation implements Serializable {
 
           } else { // last possibility is ZYZ
 
-              // r (Vector3D.plusK) coordinates are :
+              // r (Cartesian3D.plusK) coordinates are :
               //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
-              // (-r) (Vector3D.plusK) coordinates are :
+              // (-r) (Cartesian3D.plusK) coordinates are :
               // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
               // and we can choose to have theta in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
@@ -846,9 +846,9 @@ public class Rotation implements Serializable {
       } else {
           if (order == RotationOrder.XYZ) {
 
-              // r (Vector3D.plusI) coordinates are :
+              // r (Cartesian3D.plusI) coordinates are :
               //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)
-              // (-r) (Vector3D.plusK) coordinates are :
+              // (-r) (Cartesian3D.plusK) coordinates are :
               // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)
               // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
@@ -864,9 +864,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.XZY) {
 
-              // r (Vector3D.plusI) coordinates are :
+              // r (Cartesian3D.plusI) coordinates are :
               // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)
-              // (-r) (Vector3D.plusJ) coordinates are :
+              // (-r) (Cartesian3D.plusJ) coordinates are :
               // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)
               // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
@@ -882,9 +882,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.YXZ) {
 
-              // r (Vector3D.plusJ) coordinates are :
+              // r (Cartesian3D.plusJ) coordinates are :
               // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)
-              // (-r) (Vector3D.plusK) coordinates are :
+              // (-r) (Cartesian3D.plusK) coordinates are :
               // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)
               // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
@@ -900,9 +900,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.YZX) {
 
-              // r (Vector3D.plusJ) coordinates are :
+              // r (Cartesian3D.plusJ) coordinates are :
               // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)
-              // (-r) (Vector3D.plusI) coordinates are :
+              // (-r) (Cartesian3D.plusI) coordinates are :
               // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)
               // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
@@ -918,9 +918,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.ZXY) {
 
-              // r (Vector3D.plusK) coordinates are :
+              // r (Cartesian3D.plusK) coordinates are :
               //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)
-              // (-r) (Vector3D.plusJ) coordinates are :
+              // (-r) (Cartesian3D.plusJ) coordinates are :
               // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)
               // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
@@ -936,9 +936,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.ZYX) {
 
-              // r (Vector3D.plusK) coordinates are :
+              // r (Cartesian3D.plusK) coordinates are :
               //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)
-              // (-r) (Vector3D.plusI) coordinates are :
+              // (-r) (Cartesian3D.plusI) coordinates are :
               // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)
               // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
@@ -954,9 +954,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.XYX) {
 
-              // r (Vector3D.plusI) coordinates are :
+              // r (Cartesian3D.plusI) coordinates are :
               //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)
-              // (-r) (Vector3D.plusI) coordinates are :
+              // (-r) (Cartesian3D.plusI) coordinates are :
               // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)
               // and we can choose to have theta in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
@@ -972,9 +972,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.XZX) {
 
-              // r (Vector3D.plusI) coordinates are :
+              // r (Cartesian3D.plusI) coordinates are :
               //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)
-              // (-r) (Vector3D.plusI) coordinates are :
+              // (-r) (Cartesian3D.plusI) coordinates are :
               // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)
               // and we can choose to have psi in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
@@ -990,9 +990,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.YXY) {
 
-              // r (Vector3D.plusJ) coordinates are :
+              // r (Cartesian3D.plusJ) coordinates are :
               // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
-              // (-r) (Vector3D.plusJ) coordinates are :
+              // (-r) (Cartesian3D.plusJ) coordinates are :
               //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
               // and we can choose to have phi in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
@@ -1008,9 +1008,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.YZY) {
 
-              // r (Vector3D.plusJ) coordinates are :
+              // r (Cartesian3D.plusJ) coordinates are :
               // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
-              // (-r) (Vector3D.plusJ) coordinates are :
+              // (-r) (Cartesian3D.plusJ) coordinates are :
               //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
               // and we can choose to have psi in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
@@ -1026,9 +1026,9 @@ public class Rotation implements Serializable {
 
           } else if (order == RotationOrder.ZXZ) {
 
-              // r (Vector3D.plusK) coordinates are :
+              // r (Cartesian3D.plusK) coordinates are :
               // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
-              // (-r) (Vector3D.plusK) coordinates are :
+              // (-r) (Cartesian3D.plusK) coordinates are :
               //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
               // and we can choose to have phi in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
@@ -1044,9 +1044,9 @@ public class Rotation implements Serializable {
 
           } else { // last possibility is ZYZ
 
-              // r (Vector3D.plusK) coordinates are :
+              // r (Cartesian3D.plusK) coordinates are :
               // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
-              // (-r) (Vector3D.plusK) coordinates are :
+              // (-r) (Cartesian3D.plusK) coordinates are :
               //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
               // and we can choose to have theta in the interval [0 ; PI]
               Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/RotationConvention.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/RotationConvention.java
index d9871c52c..0c4eb8095 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/RotationConvention.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/RotationConvention.java
@@ -31,10 +31,10 @@ public enum RotationConvention {
      * </p>
      * <p>
      * This means that if we define rotation r is a 90 degrees rotation around
-     * the Z axis, the image of vector {@link Vector3D#PLUS_I} would be
-     * {@link Vector3D#PLUS_J}, the image of vector {@link Vector3D#PLUS_J}
-     * would be {@link Vector3D#MINUS_I}, the image of vector {@link Vector3D#PLUS_K}
-     * would be {@link Vector3D#PLUS_K}, and the image of vector with coordinates (1, 2, 3)
+     * the Z axis, the image of vector {@link Cartesian3D#PLUS_I} would be
+     * {@link Cartesian3D#PLUS_J}, the image of vector {@link Cartesian3D#PLUS_J}
+     * would be {@link Cartesian3D#MINUS_I}, the image of vector {@link Cartesian3D#PLUS_K}
+     * would be {@link Cartesian3D#PLUS_K}, and the image of vector with coordinates (1, 2, 3)
      * would be vector (-2, 1, 3). This means that the vector rotates counterclockwise.
      * </p>
      * <p>
@@ -58,10 +58,10 @@ public enum RotationConvention {
      * </p>
      * <p>
      * This means that if we define rotation r is a 90 degrees rotation around
-     * the Z axis, the image of vector {@link Vector3D#PLUS_I} would be
-     * {@link Vector3D#MINUS_J}, the image of vector {@link Vector3D#PLUS_J}
-     * would be {@link Vector3D#PLUS_I}, the image of vector {@link Vector3D#PLUS_K}
-     * would be {@link Vector3D#PLUS_K}, and the image of vector with coordinates (1, 2, 3)
+     * the Z axis, the image of vector {@link Cartesian3D#PLUS_I} would be
+     * {@link Cartesian3D#MINUS_J}, the image of vector {@link Cartesian3D#PLUS_J}
+     * would be {@link Cartesian3D#PLUS_I}, the image of vector {@link Cartesian3D#PLUS_K}
+     * would be {@link Cartesian3D#PLUS_K}, and the image of vector with coordinates (1, 2, 3)
      * would be vector (2, -1, 3). This means that the coordinates of the vector rotates
      * clockwise, because they are expressed with respect to a destination frame that is rotated
      * counterclockwise.
diff --git a/src/main/java/org/apache/commons/math4/geometry/partitioning/Embedding.java b/src/main/java/org/apache/commons/math4/geometry/partitioning/Embedding.java
index d5f58baed..ae48f1112 100644
--- a/src/main/java/org/apache/commons/math4/geometry/partitioning/Embedding.java
+++ b/src/main/java/org/apache/commons/math4/geometry/partitioning/Embedding.java
@@ -27,7 +27,7 @@ import org.apache.commons.math4.geometry.Space;
  * of the dimensions differences. As an example, {@link
  * org.apache.commons.math4.geometry.euclidean.threed.Line Line} in 3D
  * implements Embedding<{@link
- * org.apache.commons.math4.geometry.euclidean.threed.Vector3D Vector3D}, {link
+ * org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D Cartesian3D}, {link
  * org.apache.commons.math4.geometry.euclidean.oned.Vector1D Vector1D}, i.e. it
  * maps directly dimensions 3 and 1.</p>
 
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Circle.java b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Circle.java
index ab8c2c58e..38059672c 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Circle.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Circle.java
@@ -147,7 +147,7 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
     }
 
     /** {@inheritDoc}
-     * @see #getPhase(Vector3D)
+     * @see #getPhase(Cartesian3D)
      */
     @Override
     public S1Point toSubSpace(final Point<Sphere2D> point) {
@@ -256,7 +256,7 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
     }
 
     /** {@inheritDoc}
-     * @see #getOffset(Vector3D)
+     * @see #getOffset(Cartesian3D)
      */
     @Override
     public double getOffset(final Point<Sphere2D> point) {
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSet.java b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSet.java
index 0f5d11540..83c693645 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSet.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSet.java
@@ -435,7 +435,7 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
      *   EnclosingBall<Sphere2D, S2Point> cap = complexShape.getEnclosingCap();
      *
      *   // check lots of points
-     *   for (Vector3D p : points) {
+     *   for (Cartesian3D p : points) {
      *
      *     final Location l;
      *     if (cap.contains(p)) {
diff --git a/src/site/design/threeD.puml b/src/site/design/threeD.puml
index 43175f632..de13ded5e 100644
--- a/src/site/design/threeD.puml
+++ b/src/site/design/threeD.puml
@@ -64,7 +64,7 @@
       package threed #DDDBD8 {
 
         class Euclidean3D
-        class Vector3D
+        class Cartesian3D
         class Line
         class SubLine
         class Plane
@@ -72,7 +72,7 @@
         class PolyhedronsSet
 
         Space            <|.. Euclidean3D
-        Vector_S_        <|.. Vector3D
+        Vector_S_        <|.. Cartesian3D
         Hyperplane_S_    <|.. Plane
         SubHyperplane_S_ <|.. SubPlane
         Region_S_        <|.. PolyhedronsSet
diff --git a/src/site/xdoc/userguide/geometry.xml b/src/site/xdoc/userguide/geometry.xml
index fc6c6352b..ab9c55131 100644
--- a/src/site/xdoc/userguide/geometry.xml
+++ b/src/site/xdoc/userguide/geometry.xml
@@ -78,8 +78,8 @@
         <p>
           <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/oned/Vector1D.html">
           Vector1D</a>, <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/twod/Vector2D.html">
-          Vector2D</a> and <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/threed/Vector3D.html">
-          Vector3D</a> provide simple vector types. One important feature is
+          Vector2D</a> and <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/threed/Cartesian3D.html">
+          Cartesian3D</a> provide simple vector types. One important feature is
           that instances of these classes are guaranteed
           to be immutable, this greatly simplifies modeling dynamical systems
           with changing states: once a vector has been computed, a reference to it
@@ -109,7 +109,7 @@
         <p>
           <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/threed/Rotation.html">
           Rotation</a> represents 3D rotations.
-          Rotation instances are also immutable objects, as Vector3D instances.
+          Rotation instances are also immutable objects, as Cartesian3D instances.
         </p>
         <p>
           Rotations can be represented by several different mathematical
@@ -174,8 +174,8 @@
           definition and hence does not provide methods like
           <code>projectVectorIntoDestinationFrame</code> or
           <code>computeTransformedDirection</code>. It provides simpler and more
-          generic methods: <code>applyTo(Vector3D)</code> and
-          <code>applyInverseTo(Vector3D)</code>.
+          generic methods: <code>applyTo(Cartesian3D)</code> and
+          <code>applyInverseTo(Cartesian3D)</code>.
         </p>
         <p>
           Since a rotation is basically a vectorial operator, several
@@ -303,7 +303,7 @@ PolygonsSet empty = new PolygonsSet(new BSPTree&lt;Euclidean2D&gt;(false), toler
          constructor is:
         </p>
         <source>
-PolyhedronsSet(List&lt;Vector3D&gt; vertices, List&lt;int[]&gt; facets, double tolerance);
+PolyhedronsSet(List&lt;Cartesian3D&gt; vertices, List&lt;int[]&gt; facets, double tolerance);
         </source>
         <p>
           The vertices list contains all the vertices of the polyhedrons, the facets list defines the facets,
