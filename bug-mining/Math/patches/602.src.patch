diff --git a/src/main/java/org/apache/commons/math4/geometry/Vector.java b/src/main/java/org/apache/commons/math4/geometry/Vector.java
index 93a66569c..fad858e8c 100644
--- a/src/main/java/org/apache/commons/math4/geometry/Vector.java
+++ b/src/main/java/org/apache/commons/math4/geometry/Vector.java
@@ -26,7 +26,12 @@ import org.apache.commons.math4.exception.MathArithmeticException;
  * @see Point
  * @since 3.0
  */
-public interface Vector<S extends Space> extends Point<S> {
+public interface Vector<S extends Space> {
+
+    /** Get the space to which the point belongs.
+     * @return containing space
+     */
+    Space getSpace();
 
     /** Get the null vector of the vectorial space or origin point of the affine space.
      * @return null vector of the vectorial space or origin point of the affine space
@@ -96,6 +101,12 @@ public interface Vector<S extends Space> extends Point<S> {
      */
     Vector<S> scalarMultiply(double a);
 
+    /**
+     * Returns true if any coordinate of this point is NaN; false otherwise
+     * @return  true if any coordinate of this point is NaN; false otherwise
+     */
+    boolean isNaN();
+
     /**
      * Returns true if any coordinate of this vector is infinite and none are NaN;
      * false otherwise
@@ -113,6 +124,12 @@ public interface Vector<S extends Space> extends Point<S> {
      */
     double distance1(Vector<S> v);
 
+    /** Compute the distance between the instance and another vector.
+     * @param v second vector
+     * @return the distance between the instance and v
+     */
+    double distance(Vector<S> v);
+
     /** Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.
      * <p>Calling this method is equivalent to calling:
      * <code>q.subtract(p).getNormInf()</code> except that no intermediate
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Coordinates1D.java
similarity index 73%
rename from src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1D.java
rename to src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Coordinates1D.java
index 2b64ff7b0..1f31594de 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Coordinates1D.java
@@ -26,30 +26,34 @@ import org.apache.commons.math4.geometry.Vector;
 import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.MathUtils;
 
-/** This class represents a 1D vector.
+/** This class represents a 1D point or a 1D vector.
+ * <p>An instance of Coordinates1D represents the point with the corresponding
+ * coordinates.</p>
+ * <p>An instance of Coordinates1D also represents the vector which begins at
+ * the origin and ends at the point corresponding to the coordinates.</p>
  * <p>Instances of this class are guaranteed to be immutable.</p>
- * @since 3.0
+ * @since 4.0
  */
-public class Vector1D implements Vector<Euclidean1D> {
+public class Coordinates1D implements Point<Euclidean1D>, Vector<Euclidean1D> {
 
     /** Origin (coordinates: 0). */
-    public static final Vector1D ZERO = new Vector1D(0.0);
+    public static final Coordinates1D ZERO = new Coordinates1D(0.0);
 
     /** Unit (coordinates: 1). */
-    public static final Vector1D ONE  = new Vector1D(1.0);
+    public static final Coordinates1D ONE  = new Coordinates1D(1.0);
 
     // CHECKSTYLE: stop ConstantName
     /** A vector with all coordinates set to NaN. */
-    public static final Vector1D NaN = new Vector1D(Double.NaN);
+    public static final Coordinates1D NaN = new Coordinates1D(Double.NaN);
     // CHECKSTYLE: resume ConstantName
 
     /** A vector with all coordinates set to positive infinity. */
-    public static final Vector1D POSITIVE_INFINITY =
-        new Vector1D(Double.POSITIVE_INFINITY);
+    public static final Coordinates1D POSITIVE_INFINITY =
+        new Coordinates1D(Double.POSITIVE_INFINITY);
 
     /** A vector with all coordinates set to negative infinity. */
-    public static final Vector1D NEGATIVE_INFINITY =
-        new Vector1D(Double.NEGATIVE_INFINITY);
+    public static final Coordinates1D NEGATIVE_INFINITY =
+        new Coordinates1D(Double.NEGATIVE_INFINITY);
 
     /** Serializable UID. */
     private static final long serialVersionUID = 7556674948671647925L;
@@ -62,7 +66,7 @@ public class Vector1D implements Vector<Euclidean1D> {
      * @param x abscissa
      * @see #getX()
      */
-    public Vector1D(double x) {
+    public Coordinates1D(double x) {
         this.x = x;
     }
 
@@ -72,7 +76,7 @@ public class Vector1D implements Vector<Euclidean1D> {
      * @param a scale factor
      * @param u base (unscaled) vector
      */
-    public Vector1D(double a, Vector1D u) {
+    public Coordinates1D(double a, Coordinates1D u) {
         this.x = a * u.x;
     }
 
@@ -84,7 +88,7 @@ public class Vector1D implements Vector<Euclidean1D> {
      * @param a2 second scale factor
      * @param u2 second base (unscaled) vector
      */
-    public Vector1D(double a1, Vector1D u1, double a2, Vector1D u2) {
+    public Coordinates1D(double a1, Coordinates1D u1, double a2, Coordinates1D u2) {
         this.x = a1 * u1.x + a2 * u2.x;
     }
 
@@ -98,8 +102,8 @@ public class Vector1D implements Vector<Euclidean1D> {
      * @param a3 third scale factor
      * @param u3 third base (unscaled) vector
      */
-    public Vector1D(double a1, Vector1D u1, double a2, Vector1D u2,
-                   double a3, Vector1D u3) {
+    public Coordinates1D(double a1, Coordinates1D u1, double a2, Coordinates1D u2,
+                   double a3, Coordinates1D u3) {
         this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;
     }
 
@@ -115,8 +119,8 @@ public class Vector1D implements Vector<Euclidean1D> {
      * @param a4 fourth scale factor
      * @param u4 fourth base (unscaled) vector
      */
-    public Vector1D(double a1, Vector1D u1, double a2, Vector1D u2,
-                   double a3, Vector1D u3, double a4, Vector1D u4) {
+    public Coordinates1D(double a1, Coordinates1D u1, double a2, Coordinates1D u2,
+                   double a3, Coordinates1D u3, double a4, Coordinates1D u4) {
         this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;
     }
 
@@ -136,7 +140,7 @@ public class Vector1D implements Vector<Euclidean1D> {
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D getZero() {
+    public Coordinates1D getZero() {
         return ZERO;
     }
 
@@ -166,35 +170,35 @@ public class Vector1D implements Vector<Euclidean1D> {
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D add(Vector<Euclidean1D> v) {
-        Vector1D v1 = (Vector1D) v;
-        return new Vector1D(x + v1.getX());
+    public Coordinates1D add(Vector<Euclidean1D> v) {
+        Coordinates1D v1 = (Coordinates1D) v;
+        return new Coordinates1D(x + v1.getX());
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D add(double factor, Vector<Euclidean1D> v) {
-        Vector1D v1 = (Vector1D) v;
-        return new Vector1D(x + factor * v1.getX());
+    public Coordinates1D add(double factor, Vector<Euclidean1D> v) {
+        Coordinates1D v1 = (Coordinates1D) v;
+        return new Coordinates1D(x + factor * v1.getX());
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D subtract(Vector<Euclidean1D> p) {
-        Vector1D p3 = (Vector1D) p;
-        return new Vector1D(x - p3.x);
+    public Coordinates1D subtract(Vector<Euclidean1D> p) {
+        Coordinates1D p3 = (Coordinates1D) p;
+        return new Coordinates1D(x - p3.x);
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D subtract(double factor, Vector<Euclidean1D> v) {
-        Vector1D v1 = (Vector1D) v;
-        return new Vector1D(x - factor * v1.getX());
+    public Coordinates1D subtract(double factor, Vector<Euclidean1D> v) {
+        Coordinates1D v1 = (Coordinates1D) v;
+        return new Coordinates1D(x - factor * v1.getX());
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D normalize() throws MathArithmeticException {
+    public Coordinates1D normalize() throws MathArithmeticException {
         double s = getNorm();
         if (s == 0) {
             throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);
@@ -203,14 +207,14 @@ public class Vector1D implements Vector<Euclidean1D> {
     }
     /** {@inheritDoc} */
     @Override
-    public Vector1D negate() {
-        return new Vector1D(-x);
+    public Coordinates1D negate() {
+        return new Coordinates1D(-x);
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D scalarMultiply(double a) {
-        return new Vector1D(a * x);
+    public Coordinates1D scalarMultiply(double a) {
+        return new Coordinates1D(a * x);
     }
 
     /** {@inheritDoc} */
@@ -228,7 +232,7 @@ public class Vector1D implements Vector<Euclidean1D> {
     /** {@inheritDoc} */
     @Override
     public double distance1(Vector<Euclidean1D> p) {
-        Vector1D p3 = (Vector1D) p;
+        Coordinates1D p3 = (Coordinates1D) p;
         final double dx = FastMath.abs(p3.x - x);
         return dx;
     }
@@ -236,15 +240,28 @@ public class Vector1D implements Vector<Euclidean1D> {
     /** {@inheritDoc} */
     @Override
     public double distance(Point<Euclidean1D> p) {
-        Vector1D p3 = (Vector1D) p;
-        final double dx = p3.x - x;
+        return distance((Coordinates1D) p);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public double distance(Vector<Euclidean1D> v) {
+        return distance((Coordinates1D) v);
+    }
+
+    /** Compute the distance between the instance and other coordinates.
+     * @param c other coordinates
+     * @return the distance between the instance and c
+     */
+    public double distance(Coordinates1D c) {
+        final double dx = c.x - x;
         return FastMath.abs(dx);
     }
 
     /** {@inheritDoc} */
     @Override
     public double distanceInf(Vector<Euclidean1D> p) {
-        Vector1D p3 = (Vector1D) p;
+        Coordinates1D p3 = (Coordinates1D) p;
         final double dx = FastMath.abs(p3.x - x);
         return dx;
     }
@@ -252,7 +269,7 @@ public class Vector1D implements Vector<Euclidean1D> {
     /** {@inheritDoc} */
     @Override
     public double distanceSq(Vector<Euclidean1D> p) {
-        Vector1D p3 = (Vector1D) p;
+        Coordinates1D p3 = (Coordinates1D) p;
         final double dx = p3.x - x;
         return dx * dx;
     }
@@ -260,7 +277,7 @@ public class Vector1D implements Vector<Euclidean1D> {
     /** {@inheritDoc} */
     @Override
     public double dotProduct(final Vector<Euclidean1D> v) {
-        final Vector1D v1 = (Vector1D) v;
+        final Coordinates1D v1 = (Coordinates1D) v;
         return x * v1.x;
     }
 
@@ -272,7 +289,7 @@ public class Vector1D implements Vector<Euclidean1D> {
      * @param p2 second vector
      * @return the distance between p1 and p2 according to the L<sub>2</sub> norm
      */
-    public static double distance(Vector1D p1, Vector1D p2) {
+    public static double distance(Coordinates1D p1, Coordinates1D p2) {
         return p1.distance(p2);
     }
 
@@ -284,7 +301,7 @@ public class Vector1D implements Vector<Euclidean1D> {
      * @param p2 second vector
      * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm
      */
-    public static double distanceInf(Vector1D p1, Vector1D p2) {
+    public static double distanceInf(Coordinates1D p1, Coordinates1D p2) {
         return p1.distanceInf(p2);
     }
 
@@ -296,7 +313,7 @@ public class Vector1D implements Vector<Euclidean1D> {
      * @param p2 second vector
      * @return the square of the distance between p1 and p2
      */
-    public static double distanceSq(Vector1D p1, Vector1D p2) {
+    public static double distanceSq(Coordinates1D p1, Coordinates1D p2) {
         return p1.distanceSq(p2);
     }
 
@@ -326,8 +343,8 @@ public class Vector1D implements Vector<Euclidean1D> {
             return true;
         }
 
-        if (other instanceof Vector1D) {
-            final Vector1D rhs = (Vector1D)other;
+        if (other instanceof Coordinates1D) {
+            final Coordinates1D rhs = (Coordinates1D)other;
             if (rhs.isNaN()) {
                 return this.isNaN();
             }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/IntervalsSet.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/IntervalsSet.java
index 1b58cd997..78c50c1ea 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/IntervalsSet.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/IntervalsSet.java
@@ -112,14 +112,14 @@ public class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> imple
             }
             // the tree must be open on the negative infinity side
             final SubHyperplane<Euclidean1D> upperCut =
-                new OrientedPoint(new Vector1D(upper), true, tolerance).wholeHyperplane();
+                new OrientedPoint(new Coordinates1D(upper), true, tolerance).wholeHyperplane();
             return new BSPTree<>(upperCut,
                                new BSPTree<Euclidean1D>(Boolean.FALSE),
                                new BSPTree<Euclidean1D>(Boolean.TRUE),
                                null);
         }
         final SubHyperplane<Euclidean1D> lowerCut =
-            new OrientedPoint(new Vector1D(lower), false, tolerance).wholeHyperplane();
+            new OrientedPoint(new Coordinates1D(lower), false, tolerance).wholeHyperplane();
         if (Double.isInfinite(upper) && (upper > 0)) {
             // the tree must be open on the positive infinity side
             return new BSPTree<>(lowerCut,
@@ -130,7 +130,7 @@ public class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> imple
 
         // the tree must be bounded on the two sides
         final SubHyperplane<Euclidean1D> upperCut =
-            new OrientedPoint(new Vector1D(upper), true, tolerance).wholeHyperplane();
+            new OrientedPoint(new Coordinates1D(upper), true, tolerance).wholeHyperplane();
         return new BSPTree<>(lowerCut,
                                         new BSPTree<Euclidean1D>(Boolean.FALSE),
                                         new BSPTree<>(upperCut,
@@ -151,7 +151,7 @@ public class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> imple
     @Override
     protected void computeGeometricalProperties() {
         if (getTree(false).getCut() == null) {
-            setBarycenter((Point<Euclidean1D>) Vector1D.NaN);
+            setBarycenter((Point<Euclidean1D>) Coordinates1D.NaN);
             setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);
         } else {
             double size = 0.0;
@@ -162,9 +162,9 @@ public class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> imple
             }
             setSize(size);
             if (Double.isInfinite(size)) {
-                setBarycenter((Point<Euclidean1D>) Vector1D.NaN);
+                setBarycenter((Point<Euclidean1D>) Coordinates1D.NaN);
             } else if (size >= Precision.SAFE_MIN) {
-                setBarycenter((Point<Euclidean1D>) new Vector1D(sum / size));
+                setBarycenter((Point<Euclidean1D>) new Coordinates1D(sum / size));
             } else {
                 setBarycenter((Point<Euclidean1D>) ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());
             }
@@ -212,7 +212,7 @@ public class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> imple
     public BoundaryProjection<Euclidean1D> projectToBoundary(final Point<Euclidean1D> point) {
 
         // get position of test point
-        final double x = ((Vector1D) point).getX();
+        final double x = ((Coordinates1D) point).getX();
 
         double previous = Double.NEGATIVE_INFINITY;
         for (final double[] a : this) {
@@ -249,8 +249,8 @@ public class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> imple
      * @param x abscissa of the point
      * @return a new point for finite abscissa, null otherwise
      */
-    private Vector1D finiteOrNullPoint(final double x) {
-        return Double.isInfinite(x) ? null : new Vector1D(x);
+    private Coordinates1D finiteOrNullPoint(final double x) {
+        return Double.isInfinite(x) ? null : new Coordinates1D(x);
     }
 
     /** Build an ordered list of intervals representing the instance.
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/OrientedPoint.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/OrientedPoint.java
index 93af5b843..2f719a2ad 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/OrientedPoint.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/OrientedPoint.java
@@ -29,7 +29,7 @@ import org.apache.commons.math4.geometry.partitioning.Hyperplane;
 public class OrientedPoint implements Hyperplane<Euclidean1D> {
 
     /** Vector location. */
-    private final Vector1D location;
+    private final Coordinates1D location;
 
     /** Orientation. */
     private boolean direct;
@@ -44,7 +44,7 @@ public class OrientedPoint implements Hyperplane<Euclidean1D> {
      * @param tolerance tolerance below which points are considered to belong to the hyperplane
      * @since 3.3
      */
-    public OrientedPoint(final Vector1D location, final boolean direct, final double tolerance) {
+    public OrientedPoint(final Coordinates1D location, final boolean direct, final double tolerance) {
         this.location  = location;
         this.direct    = direct;
         this.tolerance = tolerance;
@@ -71,7 +71,7 @@ public class OrientedPoint implements Hyperplane<Euclidean1D> {
     /** {@inheritDoc} */
     @Override
     public double getOffset(final Point<Euclidean1D> point) {
-        final double delta = ((Vector1D) point).getX() - location.getX();
+        final double delta = ((Coordinates1D) point).getX() - location.getX();
         return direct ? delta : -delta;
     }
 
@@ -125,7 +125,7 @@ public class OrientedPoint implements Hyperplane<Euclidean1D> {
     /** Get the hyperplane location on the real line.
      * @return the hyperplane location
      */
-    public Vector1D getLocation() {
+    public Coordinates1D getLocation() {
         return location;
     }
 
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DFormat.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DFormat.java
index d3c4bd82d..4b40bb35b 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DFormat.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DFormat.java
@@ -105,31 +105,31 @@ public class Vector1DFormat extends VectorFormat<Euclidean1D> {
     @Override
     public StringBuffer format(final Vector<Euclidean1D> vector, final StringBuffer toAppendTo,
                                final FieldPosition pos) {
-        final Vector1D p1 = (Vector1D) vector;
+        final Coordinates1D p1 = (Coordinates1D) vector;
         return format(toAppendTo, pos, p1.getX());
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D parse(final String source) throws MathParseException {
+    public Coordinates1D parse(final String source) throws MathParseException {
         ParsePosition parsePosition = new ParsePosition(0);
-        Vector1D result = parse(source, parsePosition);
+        Coordinates1D result = parse(source, parsePosition);
         if (parsePosition.getIndex() == 0) {
             throw new MathParseException(source,
                                          parsePosition.getErrorIndex(),
-                                         Vector1D.class);
+                                         Coordinates1D.class);
         }
         return result;
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D parse(final String source, final ParsePosition pos) {
+    public Coordinates1D parse(final String source, final ParsePosition pos) {
         final double[] coordinates = parseCoordinates(1, source, pos);
         if (coordinates == null) {
             return null;
         }
-        return new Vector1D(coordinates[0]);
+        return new Coordinates1D(coordinates[0]);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Coordinates3D.java
similarity index 77%
rename from src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3D.java
rename to src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Coordinates3D.java
index 7e43245b0..ee2376cd8 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Coordinates3D.java
@@ -31,45 +31,49 @@ import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
- * This class implements vectors in a three-dimensional space.
+ * This class represents points or vectors in a three-dimensional space.
+ * <p>An instance of Coordinates3D represents the point with the corresponding
+ * coordinates.</p>
+ * <p>An instance of Coordinates3D also represents the vector which begins at
+ * the origin and ends at the point corresponding to the coordinates.</p>
  * <p>Instance of this class are guaranteed to be immutable.</p>
- * @since 1.2
+ * @since 4.0
  */
-public class Vector3D implements Serializable, Vector<Euclidean3D> {
+public class Coordinates3D implements Serializable, Point<Euclidean3D>, Vector<Euclidean3D> {
 
     /** Null vector (coordinates: 0, 0, 0). */
-    public static final Vector3D ZERO   = new Vector3D(0, 0, 0);
+    public static final Coordinates3D ZERO   = new Coordinates3D(0, 0, 0);
 
     /** First canonical vector (coordinates: 1, 0, 0). */
-    public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);
+    public static final Coordinates3D PLUS_I = new Coordinates3D(1, 0, 0);
 
     /** Opposite of the first canonical vector (coordinates: -1, 0, 0). */
-    public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);
+    public static final Coordinates3D MINUS_I = new Coordinates3D(-1, 0, 0);
 
     /** Second canonical vector (coordinates: 0, 1, 0). */
-    public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);
+    public static final Coordinates3D PLUS_J = new Coordinates3D(0, 1, 0);
 
     /** Opposite of the second canonical vector (coordinates: 0, -1, 0). */
-    public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);
+    public static final Coordinates3D MINUS_J = new Coordinates3D(0, -1, 0);
 
     /** Third canonical vector (coordinates: 0, 0, 1). */
-    public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);
+    public static final Coordinates3D PLUS_K = new Coordinates3D(0, 0, 1);
 
     /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */
-    public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);
+    public static final Coordinates3D MINUS_K = new Coordinates3D(0, 0, -1);
 
     // CHECKSTYLE: stop ConstantName
     /** A vector with all coordinates set to NaN. */
-    public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);
+    public static final Coordinates3D NaN = new Coordinates3D(Double.NaN, Double.NaN, Double.NaN);
     // CHECKSTYLE: resume ConstantName
 
     /** A vector with all coordinates set to positive infinity. */
-    public static final Vector3D POSITIVE_INFINITY =
-        new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
+    public static final Coordinates3D POSITIVE_INFINITY =
+        new Coordinates3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
 
     /** A vector with all coordinates set to negative infinity. */
-    public static final Vector3D NEGATIVE_INFINITY =
-        new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
+    public static final Coordinates3D NEGATIVE_INFINITY =
+        new Coordinates3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
 
     /** Serializable version identifier. */
     private static final long serialVersionUID = 1313493323784566947L;
@@ -92,7 +96,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @see #getY()
      * @see #getZ()
      */
-    public Vector3D(double x, double y, double z) {
+    public Coordinates3D(double x, double y, double z) {
         this.x = x;
         this.y = y;
         this.z = z;
@@ -104,7 +108,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @exception DimensionMismatchException if array does not have 3 elements
      * @see #toArray()
      */
-    public Vector3D(double[] v) throws DimensionMismatchException {
+    public Coordinates3D(double[] v) throws DimensionMismatchException {
         if (v.length != 3) {
             throw new DimensionMismatchException(v.length, 3);
         }
@@ -121,7 +125,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @see #getAlpha()
      * @see #getDelta()
      */
-    public Vector3D(double alpha, double delta) {
+    public Coordinates3D(double alpha, double delta) {
         double cosDelta = FastMath.cos(delta);
         this.x = FastMath.cos(alpha) * cosDelta;
         this.y = FastMath.sin(alpha) * cosDelta;
@@ -134,7 +138,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param a scale factor
      * @param u base (unscaled) vector
      */
-    public Vector3D(double a, Vector3D u) {
+    public Coordinates3D(double a, Coordinates3D u) {
         this.x = a * u.x;
         this.y = a * u.y;
         this.z = a * u.z;
@@ -148,7 +152,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param a2 second scale factor
      * @param u2 second base (unscaled) vector
      */
-    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {
+    public Coordinates3D(double a1, Coordinates3D u1, double a2, Coordinates3D u2) {
         this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x);
         this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y);
         this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z);
@@ -164,8 +168,8 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param a3 third scale factor
      * @param u3 third base (unscaled) vector
      */
-    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,
-                    double a3, Vector3D u3) {
+    public Coordinates3D(double a1, Coordinates3D u1, double a2, Coordinates3D u2,
+                    double a3, Coordinates3D u3) {
         this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);
         this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);
         this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);
@@ -183,8 +187,8 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param a4 fourth scale factor
      * @param u4 fourth base (unscaled) vector
      */
-    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,
-                    double a3, Vector3D u3, double a4, Vector3D u4) {
+    public Coordinates3D(double a1, Coordinates3D u1, double a2, Coordinates3D u2,
+                    double a3, Coordinates3D u3, double a4, Coordinates3D u4) {
         this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x, a4, u4.x);
         this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y, a4, u4.y);
         this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z, a4, u4.z);
@@ -230,7 +234,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
 
     /** {@inheritDoc} */
     @Override
-    public Vector3D getZero() {
+    public Coordinates3D getZero() {
         return ZERO;
     }
 
@@ -278,33 +282,33 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
 
     /** {@inheritDoc} */
     @Override
-    public Vector3D add(final Vector<Euclidean3D> v) {
-        final Vector3D v3 = (Vector3D) v;
-        return new Vector3D(x + v3.x, y + v3.y, z + v3.z);
+    public Coordinates3D add(final Vector<Euclidean3D> v) {
+        final Coordinates3D v3 = (Coordinates3D) v;
+        return new Coordinates3D(x + v3.x, y + v3.y, z + v3.z);
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector3D add(double factor, final Vector<Euclidean3D> v) {
-        return new Vector3D(1, this, factor, (Vector3D) v);
+    public Coordinates3D add(double factor, final Vector<Euclidean3D> v) {
+        return new Coordinates3D(1, this, factor, (Coordinates3D) v);
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector3D subtract(final Vector<Euclidean3D> v) {
-        final Vector3D v3 = (Vector3D) v;
-        return new Vector3D(x - v3.x, y - v3.y, z - v3.z);
+    public Coordinates3D subtract(final Vector<Euclidean3D> v) {
+        final Coordinates3D v3 = (Coordinates3D) v;
+        return new Coordinates3D(x - v3.x, y - v3.y, z - v3.z);
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector3D subtract(final double factor, final Vector<Euclidean3D> v) {
-        return new Vector3D(1, this, -factor, (Vector3D) v);
+    public Coordinates3D subtract(final double factor, final Vector<Euclidean3D> v) {
+        return new Coordinates3D(1, this, -factor, (Coordinates3D) v);
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector3D normalize() throws MathArithmeticException {
+    public Coordinates3D normalize() throws MathArithmeticException {
         double s = getNorm();
         if (s == 0) {
             throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);
@@ -327,7 +331,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @return a new normalized vector orthogonal to the instance
      * @exception MathArithmeticException if the norm of the instance is null
      */
-    public Vector3D orthogonal() throws MathArithmeticException {
+    public Coordinates3D orthogonal() throws MathArithmeticException {
 
         double threshold = 0.6 * getNorm();
         if (threshold == 0) {
@@ -336,13 +340,13 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
 
         if (FastMath.abs(x) <= threshold) {
             double inverse  = 1 / FastMath.sqrt(y * y + z * z);
-            return new Vector3D(0, inverse * z, -inverse * y);
+            return new Coordinates3D(0, inverse * z, -inverse * y);
         } else if (FastMath.abs(y) <= threshold) {
             double inverse  = 1 / FastMath.sqrt(x * x + z * z);
-            return new Vector3D(-inverse * z, 0, inverse * x);
+            return new Coordinates3D(-inverse * z, 0, inverse * x);
         }
         double inverse  = 1 / FastMath.sqrt(x * x + y * y);
-        return new Vector3D(inverse * y, -inverse * x, 0);
+        return new Coordinates3D(inverse * y, -inverse * x, 0);
 
     }
 
@@ -357,7 +361,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @return angular separation between v1 and v2
      * @exception MathArithmeticException if either vector has a null norm
      */
-    public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException {
+    public static double angle(Coordinates3D v1, Coordinates3D v2) throws MathArithmeticException {
 
         double normProduct = v1.getNorm() * v2.getNorm();
         if (normProduct == 0) {
@@ -368,7 +372,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
         double threshold = normProduct * 0.9999;
         if ((dot < -threshold) || (dot > threshold)) {
             // the vectors are almost aligned, compute using the sine
-            Vector3D v3 = crossProduct(v1, v2);
+            Coordinates3D v3 = crossProduct(v1, v2);
             if (dot >= 0) {
                 return FastMath.asin(v3.getNorm() / normProduct);
             }
@@ -382,14 +386,14 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
 
     /** {@inheritDoc} */
     @Override
-    public Vector3D negate() {
-        return new Vector3D(-x, -y, -z);
+    public Coordinates3D negate() {
+        return new Coordinates3D(-x, -y, -z);
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector3D scalarMultiply(double a) {
-        return new Vector3D(a * x, a * y, a * z);
+    public Coordinates3D scalarMultiply(double a) {
+        return new Coordinates3D(a * x, a * y, a * z);
     }
 
     /** {@inheritDoc} */
@@ -430,8 +434,8 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
             return true;
         }
 
-        if (other instanceof Vector3D) {
-            final Vector3D rhs = (Vector3D)other;
+        if (other instanceof Coordinates3D) {
+            final Coordinates3D rhs = (Coordinates3D)other;
             if (rhs.isNaN()) {
                 return this.isNaN();
             }
@@ -466,7 +470,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      */
     @Override
     public double dotProduct(final Vector<Euclidean3D> v) {
-        final Vector3D v3 = (Vector3D) v;
+        final Coordinates3D v3 = (Coordinates3D) v;
         return MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);
     }
 
@@ -474,9 +478,9 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param v other vector
      * @return the cross product this ^ v as a new Vector3D
      */
-    public Vector3D crossProduct(final Vector<Euclidean3D> v) {
-        final Vector3D v3 = (Vector3D) v;
-        return new Vector3D(MathArrays.linearCombination(y, v3.z, -z, v3.y),
+    public Coordinates3D crossProduct(final Vector<Euclidean3D> v) {
+        final Coordinates3D v3 = (Coordinates3D) v;
+        return new Coordinates3D(MathArrays.linearCombination(y, v3.z, -z, v3.y),
                             MathArrays.linearCombination(z, v3.x, -x, v3.z),
                             MathArrays.linearCombination(x, v3.y, -y, v3.x));
     }
@@ -484,7 +488,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
     /** {@inheritDoc} */
     @Override
     public double distance1(Vector<Euclidean3D> v) {
-        final Vector3D v3 = (Vector3D) v;
+        final Coordinates3D v3 = (Coordinates3D) v;
         final double dx = FastMath.abs(v3.x - x);
         final double dy = FastMath.abs(v3.y - y);
         final double dz = FastMath.abs(v3.z - z);
@@ -493,18 +497,31 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
 
     /** {@inheritDoc} */
     @Override
-    public double distance(Point<Euclidean3D> v) {
-        final Vector3D v3 = (Vector3D) v;
-        final double dx = v3.x - x;
-        final double dy = v3.y - y;
-        final double dz = v3.z - z;
+    public double distance(Point<Euclidean3D> p) {
+        return distance((Coordinates3D) p);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public double distance(Vector<Euclidean3D> v) {
+        return distance((Coordinates3D) v);
+    }
+
+    /** Compute the distance between the instance and other coordinates.
+     * @param c other coordinates
+     * @return the distance between the instance and c
+     */
+    public double distance(Coordinates3D c) {
+        final double dx = c.x - x;
+        final double dy = c.y - y;
+        final double dz = c.z - z;
         return FastMath.sqrt(dx * dx + dy * dy + dz * dz);
     }
 
     /** {@inheritDoc} */
     @Override
     public double distanceInf(Vector<Euclidean3D> v) {
-        final Vector3D v3 = (Vector3D) v;
+        final Coordinates3D v3 = (Coordinates3D) v;
         final double dx = FastMath.abs(v3.x - x);
         final double dy = FastMath.abs(v3.y - y);
         final double dz = FastMath.abs(v3.z - z);
@@ -514,7 +531,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
     /** {@inheritDoc} */
     @Override
     public double distanceSq(Vector<Euclidean3D> v) {
-        final Vector3D v3 = (Vector3D) v;
+        final Coordinates3D v3 = (Coordinates3D) v;
         final double dx = v3.x - x;
         final double dy = v3.y - y;
         final double dz = v3.z - z;
@@ -526,7 +543,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param v2 second vector
      * @return the dot product v1.v2
      */
-    public static double dotProduct(Vector3D v1, Vector3D v2) {
+    public static double dotProduct(Coordinates3D v1, Coordinates3D v2) {
         return v1.dotProduct(v2);
     }
 
@@ -535,7 +552,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param v2 second vector
      * @return the cross product v1 ^ v2 as a new Vector
      */
-    public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
+    public static Coordinates3D crossProduct(final Coordinates3D v1, final Coordinates3D v2) {
         return v1.crossProduct(v2);
     }
 
@@ -547,7 +564,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param v2 second vector
      * @return the distance between v1 and v2 according to the L<sub>1</sub> norm
      */
-    public static double distance1(Vector3D v1, Vector3D v2) {
+    public static double distance1(Coordinates3D v1, Coordinates3D v2) {
         return v1.distance1(v2);
     }
 
@@ -559,7 +576,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param v2 second vector
      * @return the distance between v1 and v2 according to the L<sub>2</sub> norm
      */
-    public static double distance(Vector3D v1, Vector3D v2) {
+    public static double distance(Coordinates3D v1, Coordinates3D v2) {
         return v1.distance(v2);
     }
 
@@ -571,7 +588,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param v2 second vector
      * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm
      */
-    public static double distanceInf(Vector3D v1, Vector3D v2) {
+    public static double distanceInf(Coordinates3D v1, Coordinates3D v2) {
         return v1.distanceInf(v2);
     }
 
@@ -583,7 +600,7 @@ public class Vector3D implements Serializable, Vector<Euclidean3D> {
      * @param v2 second vector
      * @return the square of the distance between v1 and v2
      */
-    public static double distanceSq(Vector3D v1, Vector3D v2) {
+    public static double distanceSq(Coordinates3D v1, Coordinates3D v2) {
         return v1.distanceSq(v2);
     }
 
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotation.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotation.java
index be89ef41b..a05ab8ec4 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotation.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotation.java
@@ -820,8 +820,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusK) coordinates are :
                 // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)
                 // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_I);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_K);
                 if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(true);
                 }
@@ -836,8 +836,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusJ) coordinates are :
                 // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)
                 // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_I);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_J);
                 if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(true);
                 }
@@ -852,8 +852,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusK) coordinates are :
                 // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)
                 // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_J);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_K);
                 if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(true);
                 }
@@ -868,8 +868,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusI) coordinates are :
                 // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)
                 // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_J);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_I);
                 if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(true);
                 }
@@ -884,8 +884,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusJ) coordinates are :
                 // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)
                 // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_K);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_J);
                 if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(true);
                 }
@@ -900,8 +900,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusI) coordinates are :
                 // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)
                 // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_K);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_I);
                 if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(true);
                 }
@@ -916,8 +916,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusI) coordinates are :
                 // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)
                 // and we can choose to have theta in the interval [0 ; PI]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_I);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_I);
                 if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(false);
                 }
@@ -932,8 +932,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusI) coordinates are :
                 // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)
                 // and we can choose to have psi in the interval [0 ; PI]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_I);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_I);
                 if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(false);
                 }
@@ -948,8 +948,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusJ) coordinates are :
                 //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
                 // and we can choose to have phi in the interval [0 ; PI]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_J);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_J);
                 if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(false);
                 }
@@ -964,8 +964,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusJ) coordinates are :
                 //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
                 // and we can choose to have psi in the interval [0 ; PI]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_J);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_J);
                 if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(false);
                 }
@@ -980,8 +980,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusK) coordinates are :
                 //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
                 // and we can choose to have phi in the interval [0 ; PI]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_K);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_K);
                 if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(false);
                 }
@@ -996,8 +996,8 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
                 // (-r) (Vector3D.plusK) coordinates are :
                 //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
                 // and we can choose to have theta in the interval [0 ; PI]
-                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);
-                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);
+                FieldVector3D<T> v1 = applyTo(Coordinates3D.PLUS_K);
+                FieldVector3D<T> v2 = applyInverseTo(Coordinates3D.PLUS_K);
                 if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {
                     throw new CardanEulerSingularityException(false);
                 }
@@ -1100,7 +1100,7 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
      * @param u vector to apply the rotation to
      * @return a new vector which is the image of u by the rotation
      */
-    public FieldVector3D<T> applyTo(final Vector3D u) {
+    public FieldVector3D<T> applyTo(final Coordinates3D u) {
 
         final double x = u.getX();
         final double y = u.getY();
@@ -1194,7 +1194,7 @@ public class FieldRotation<T extends RealFieldElement<T>> implements Serializabl
      * @param u vector to apply the inverse of the rotation to
      * @return a new vector which such that u is its image by the rotation
      */
-    public FieldVector3D<T> applyInverseTo(final Vector3D u) {
+    public FieldVector3D<T> applyInverseTo(final Coordinates3D u) {
 
         final double x = u.getX();
         final double y = u.getY();
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3D.java
index bec2d74e8..dc538a5a2 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3D.java
@@ -28,7 +28,7 @@ import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.MathArrays;
 
 /**
- * This class is a re-implementation of {@link Vector3D} using {@link RealFieldElement}.
+ * This class is a re-implementation of {@link Coordinates3D} using {@link RealFieldElement}.
  * <p>Instance of this class are guaranteed to be immutable.</p>
  * @param <T> the type of the field elements
  * @since 3.2
@@ -110,7 +110,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param a scale factor
      * @param u base (unscaled) vector
      */
-    public FieldVector3D(final T a, final Vector3D u) {
+    public FieldVector3D(final T a, final Coordinates3D u) {
         this.x = a.multiply(u.getX());
         this.y = a.multiply(u.getY());
         this.z = a.multiply(u.getZ());
@@ -152,8 +152,8 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param a2 second scale factor
      * @param u2 second base (unscaled) vector
      */
-    public FieldVector3D(final T a1, final Vector3D u1,
-                         final T a2, final Vector3D u2) {
+    public FieldVector3D(final T a1, final Coordinates3D u1,
+                         final T a2, final Coordinates3D u2) {
         final T prototype = a1;
         this.x = prototype.linearCombination(u1.getX(), a1, u2.getX(), a2);
         this.y = prototype.linearCombination(u1.getY(), a1, u2.getY(), a2);
@@ -205,9 +205,9 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param a3 third scale factor
      * @param u3 third base (unscaled) vector
      */
-    public FieldVector3D(final T a1, final Vector3D u1,
-                         final T a2, final Vector3D u2,
-                         final T a3, final Vector3D u3) {
+    public FieldVector3D(final T a1, final Coordinates3D u1,
+                         final T a2, final Coordinates3D u2,
+                         final T a3, final Coordinates3D u3) {
         final T prototype = a1;
         this.x = prototype.linearCombination(u1.getX(), a1, u2.getX(), a2, u3.getX(), a3);
         this.y = prototype.linearCombination(u1.getY(), a1, u2.getY(), a2, u3.getY(), a3);
@@ -267,10 +267,10 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param a4 fourth scale factor
      * @param u4 fourth base (unscaled) vector
      */
-    public FieldVector3D(final T a1, final Vector3D u1,
-                         final T a2, final Vector3D u2,
-                         final T a3, final Vector3D u3,
-                         final T a4, final Vector3D u4) {
+    public FieldVector3D(final T a1, final Coordinates3D u1,
+                         final T a2, final Coordinates3D u2,
+                         final T a3, final Coordinates3D u3,
+                         final T a4, final Coordinates3D u4) {
         final T prototype = a1;
         this.x = prototype.linearCombination(u1.getX(), a1, u2.getX(), a2, u3.getX(), a3, u4.getX(), a4);
         this.y = prototype.linearCombination(u1.getY(), a1, u2.getY(), a2, u3.getY(), a3, u4.getY(), a4);
@@ -338,8 +338,8 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
     /** Convert to a constant vector without derivatives.
      * @return a constant vector
      */
-    public Vector3D toVector3D() {
-        return new Vector3D(x.getReal(), y.getReal(), z.getReal());
+    public Coordinates3D toVector3D() {
+        return new Coordinates3D(x.getReal(), y.getReal(), z.getReal());
     }
 
     /** Get the L<sub>1</sub> norm for the vector.
@@ -415,7 +415,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v vector to add
      * @return a new vector
      */
-    public FieldVector3D<T> add(final Vector3D v) {
+    public FieldVector3D<T> add(final Coordinates3D v) {
         return new FieldVector3D<>(x.add(v.getX()), y.add(v.getY()), z.add(v.getZ()));
     }
 
@@ -433,7 +433,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v vector to add
      * @return a new vector
      */
-    public FieldVector3D<T> add(final T factor, final Vector3D v) {
+    public FieldVector3D<T> add(final T factor, final Coordinates3D v) {
         return new FieldVector3D<>(x.add(factor.multiply(v.getX())),
                                     y.add(factor.multiply(v.getY())),
                                     z.add(factor.multiply(v.getZ())));
@@ -453,7 +453,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v vector to add
      * @return a new vector
      */
-    public FieldVector3D<T> add(final double factor, final Vector3D v) {
+    public FieldVector3D<T> add(final double factor, final Coordinates3D v) {
         return new FieldVector3D<>(x.add(factor * v.getX()),
                                     y.add(factor * v.getY()),
                                     z.add(factor * v.getZ()));
@@ -471,7 +471,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v vector to subtract
      * @return a new vector
      */
-    public FieldVector3D<T> subtract(final Vector3D v) {
+    public FieldVector3D<T> subtract(final Coordinates3D v) {
         return new FieldVector3D<>(x.subtract(v.getX()), y.subtract(v.getY()), z.subtract(v.getZ()));
     }
 
@@ -489,7 +489,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v vector to subtract
      * @return a new vector
      */
-    public FieldVector3D<T> subtract(final T factor, final Vector3D v) {
+    public FieldVector3D<T> subtract(final T factor, final Coordinates3D v) {
         return new FieldVector3D<>(x.subtract(factor.multiply(v.getX())),
                                     y.subtract(factor.multiply(v.getY())),
                                     z.subtract(factor.multiply(v.getZ())));
@@ -509,7 +509,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v vector to subtract
      * @return a new vector
      */
-    public FieldVector3D<T> subtract(final double factor, final Vector3D v) {
+    public FieldVector3D<T> subtract(final double factor, final Coordinates3D v) {
         return new FieldVector3D<>(x.subtract(factor * v.getX()),
                                     y.subtract(factor * v.getY()),
                                     z.subtract(factor * v.getZ()));
@@ -610,7 +610,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @return angular separation between v1 and v2
      * @exception MathArithmeticException if either vector has a null norm
      */
-    public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2)
+    public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Coordinates3D v2)
         throws MathArithmeticException {
 
         final T normProduct = v1.getNorm().multiply(v2.getNorm());
@@ -646,7 +646,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @return angular separation between v1 and v2
      * @exception MathArithmeticException if either vector has a null norm
      */
-    public static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2)
+    public static <T extends RealFieldElement<T>> T angle(final Coordinates3D v1, final FieldVector3D<T> v2)
         throws MathArithmeticException {
         return angle(v2, v1);
     }
@@ -770,7 +770,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v second vector
      * @return the dot product this.v
      */
-    public T dotProduct(final Vector3D v) {
+    public T dotProduct(final Coordinates3D v) {
         return x.linearCombination(v.getX(), x, v.getY(), y, v.getZ(), z);
     }
 
@@ -788,7 +788,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v other vector
      * @return the cross product this ^ v as a new Vector3D
      */
-    public FieldVector3D<T> crossProduct(final Vector3D v) {
+    public FieldVector3D<T> crossProduct(final Coordinates3D v) {
         return new FieldVector3D<>(x.linearCombination(v.getZ(), y, -v.getY(), z),
                                     y.linearCombination(v.getX(), z, -v.getZ(), x),
                                     z.linearCombination(v.getY(), x, -v.getX(), y));
@@ -815,7 +815,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v second vector
      * @return the distance between the instance and p according to the L<sub>1</sub> norm
      */
-    public T distance1(final Vector3D v) {
+    public T distance1(final Coordinates3D v) {
         final T dx = x.subtract(v.getX()).abs();
         final T dy = y.subtract(v.getY()).abs();
         final T dz = z.subtract(v.getZ()).abs();
@@ -843,7 +843,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v second vector
      * @return the distance between the instance and p according to the L<sub>2</sub> norm
      */
-    public T distance(final Vector3D v) {
+    public T distance(final Coordinates3D v) {
         final T dx = x.subtract(v.getX());
         final T dy = y.subtract(v.getY());
         final T dz = z.subtract(v.getZ());
@@ -883,7 +883,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v second vector
      * @return the distance between the instance and p according to the L<sub>&infin;</sub> norm
      */
-    public T distanceInf(final Vector3D v) {
+    public T distanceInf(final Coordinates3D v) {
         final T dx = x.subtract(v.getX()).abs();
         final T dy = y.subtract(v.getY()).abs();
         final T dz = z.subtract(v.getZ()).abs();
@@ -923,7 +923,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param v second vector
      * @return the square of the distance between the instance and p
      */
-    public T distanceSq(final Vector3D v) {
+    public T distanceSq(final Coordinates3D v) {
         final T dx = x.subtract(v.getX());
         final T dy = y.subtract(v.getY());
         final T dz = z.subtract(v.getZ());
@@ -948,7 +948,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @return the dot product v1.v2
      */
     public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1,
-                                                                   final Vector3D v2) {
+                                                                   final Coordinates3D v2) {
         return v1.dotProduct(v2);
     }
 
@@ -958,7 +958,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param <T> the type of the field elements
      * @return the dot product v1.v2
      */
-    public static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1,
+    public static <T extends RealFieldElement<T>> T dotProduct(final Coordinates3D v1,
                                                                    final FieldVector3D<T> v2) {
         return v2.dotProduct(v1);
     }
@@ -981,7 +981,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @return the cross product v1 ^ v2 as a new Vector
      */
     public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1,
-                                                                                    final Vector3D v2) {
+                                                                                    final Coordinates3D v2) {
         return v1.crossProduct(v2);
     }
 
@@ -991,7 +991,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param <T> the type of the field elements
      * @return the cross product v1 ^ v2 as a new Vector
      */
-    public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1,
+    public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Coordinates3D v1,
                                                                                     final FieldVector3D<T> v2) {
         return new FieldVector3D<>(v2.x.linearCombination(v1.getY(), v2.z, -v1.getZ(), v2.y),
                                     v2.y.linearCombination(v1.getZ(), v2.x, -v1.getX(), v2.z),
@@ -1022,7 +1022,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @return the distance between v1 and v2 according to the L<sub>1</sub> norm
      */
     public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1,
-                                                                  final Vector3D v2) {
+                                                                  final Coordinates3D v2) {
         return v1.distance1(v2);
     }
 
@@ -1035,7 +1035,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param <T> the type of the field elements
      * @return the distance between v1 and v2 according to the L<sub>1</sub> norm
      */
-    public static <T extends RealFieldElement<T>> T distance1(final Vector3D v1,
+    public static <T extends RealFieldElement<T>> T distance1(final Coordinates3D v1,
                                                                   final FieldVector3D<T> v2) {
         return v2.distance1(v1);
     }
@@ -1064,7 +1064,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @return the distance between v1 and v2 according to the L<sub>2</sub> norm
      */
     public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1,
-                                                                 final Vector3D v2) {
+                                                                 final Coordinates3D v2) {
         return v1.distance(v2);
     }
 
@@ -1077,7 +1077,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param <T> the type of the field elements
      * @return the distance between v1 and v2 according to the L<sub>2</sub> norm
      */
-    public static <T extends RealFieldElement<T>> T distance(final Vector3D v1,
+    public static <T extends RealFieldElement<T>> T distance(final Coordinates3D v1,
                                                                  final FieldVector3D<T> v2) {
         return v2.distance(v1);
     }
@@ -1106,7 +1106,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm
      */
     public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1,
-                                                                    final Vector3D v2) {
+                                                                    final Coordinates3D v2) {
         return v1.distanceInf(v2);
     }
 
@@ -1119,7 +1119,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param <T> the type of the field elements
      * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm
      */
-    public static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1,
+    public static <T extends RealFieldElement<T>> T distanceInf(final Coordinates3D v1,
                                                                     final FieldVector3D<T> v2) {
         return v2.distanceInf(v1);
     }
@@ -1148,7 +1148,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @return the square of the distance between v1 and v2
      */
     public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1,
-                                                                   final Vector3D v2) {
+                                                                   final Coordinates3D v2) {
         return v1.distanceSq(v2);
     }
 
@@ -1161,7 +1161,7 @@ public class FieldVector3D<T extends RealFieldElement<T>> implements Serializabl
      * @param <T> the type of the field elements
      * @return the square of the distance between v1 and v2
      */
-    public static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1,
+    public static <T extends RealFieldElement<T>> T distanceSq(final Coordinates3D v1,
                                                                    final FieldVector3D<T> v2) {
         return v2.distanceSq(v1);
     }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Line.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Line.java
index 3173ac266..d68bb9439 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Line.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Line.java
@@ -22,7 +22,7 @@ import org.apache.commons.math4.geometry.Point;
 import org.apache.commons.math4.geometry.Vector;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
 import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.partitioning.Embedding;
 import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.Precision;
@@ -41,10 +41,10 @@ import org.apache.commons.math4.util.Precision;
 public class Line implements Embedding<Euclidean3D, Euclidean1D> {
 
     /** Line direction. */
-    private Vector3D direction;
+    private Coordinates3D direction;
 
     /** Line point closest to the origin. */
-    private Vector3D zero;
+    private Coordinates3D zero;
 
     /** Tolerance below which points are considered identical. */
     private final double tolerance;
@@ -56,7 +56,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @exception MathIllegalArgumentException if the points are equal
      * @since 3.3
      */
-    public Line(final Vector3D p1, final Vector3D p2, final double tolerance)
+    public Line(final Coordinates3D p1, final Coordinates3D p2, final double tolerance)
         throws MathIllegalArgumentException {
         reset(p1, p2);
         this.tolerance = tolerance;
@@ -78,14 +78,14 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @param p2 second point belonging to the line (this can be any point, different from p1)
      * @exception MathIllegalArgumentException if the points are equal
      */
-    public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {
-        final Vector3D delta = p2.subtract(p1);
+    public void reset(final Coordinates3D p1, final Coordinates3D p2) throws MathIllegalArgumentException {
+        final Coordinates3D delta = p2.subtract(p1);
         final double norm2 = delta.getNormSq();
         if (norm2 == 0.0) {
             throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);
         }
-        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);
-        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);
+        this.direction = new Coordinates3D(1.0 / FastMath.sqrt(norm2), delta);
+        zero = new Coordinates3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);
     }
 
     /** Get the tolerance below which points are considered identical.
@@ -108,14 +108,14 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
     /** Get the normalized direction vector.
      * @return normalized direction vector
      */
-    public Vector3D getDirection() {
+    public Coordinates3D getDirection() {
         return direction;
     }
 
     /** Get the line point closest to the origin.
      * @return line point closest to the origin
      */
-    public Vector3D getOrigin() {
+    public Coordinates3D getOrigin() {
         return zero;
     }
 
@@ -126,7 +126,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @param point point to check
      * @return abscissa of the point
      */
-    public double getAbscissa(final Vector3D point) {
+    public double getAbscissa(final Coordinates3D point) {
         return point.subtract(zero).dotProduct(direction);
     }
 
@@ -134,8 +134,8 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @param abscissa desired abscissa for the point
      * @return one point belonging to the line, at specified abscissa
      */
-    public Vector3D pointAt(final double abscissa) {
-        return new Vector3D(1.0, zero, abscissa, direction);
+    public Coordinates3D pointAt(final double abscissa) {
+        return new Coordinates3D(1.0, zero, abscissa, direction);
     }
 
     /** Transform a space point into a sub-space point.
@@ -143,7 +143,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @return (n-1)-dimension point of the sub-space corresponding to
      * the specified space point
      */
-    public Vector1D toSubSpace(Vector<Euclidean3D> vector) {
+    public Coordinates1D toSubSpace(Vector<Euclidean3D> vector) {
         return toSubSpace((Point<Euclidean3D>) vector);
     }
 
@@ -152,7 +152,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @return n-dimension point of the space corresponding to the
      * specified sub-space point
      */
-    public Vector3D toSpace(Vector<Euclidean1D> vector) {
+    public Coordinates3D toSpace(Vector<Euclidean1D> vector) {
         return toSpace((Point<Euclidean1D>) vector);
     }
 
@@ -160,16 +160,16 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @see #getAbscissa(Vector3D)
      */
     @Override
-    public Vector1D toSubSpace(final Point<Euclidean3D> point) {
-        return new Vector1D(getAbscissa((Vector3D) point));
+    public Coordinates1D toSubSpace(final Point<Euclidean3D> point) {
+        return new Coordinates1D(getAbscissa((Coordinates3D) point));
     }
 
     /** {@inheritDoc}
      * @see #pointAt(double)
      */
     @Override
-    public Vector3D toSpace(final Point<Euclidean1D> point) {
-        return pointAt(((Vector1D) point).getX());
+    public Coordinates3D toSpace(final Point<Euclidean1D> point) {
+        return pointAt(((Coordinates1D) point).getX());
     }
 
     /** Check if the instance is similar to another line.
@@ -180,7 +180,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @return true if the lines are similar
      */
     public boolean isSimilarTo(final Line line) {
-        final double angle = Vector3D.angle(direction, line.direction);
+        final double angle = Coordinates3D.angle(direction, line.direction);
         return ((angle < tolerance) || (angle > (FastMath.PI - tolerance))) && contains(line.zero);
     }
 
@@ -188,7 +188,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @param p point to check
      * @return true if p belongs to the line
      */
-    public boolean contains(final Vector3D p) {
+    public boolean contains(final Coordinates3D p) {
         return distance(p) < tolerance;
     }
 
@@ -196,9 +196,9 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @param p to check
      * @return distance between the instance and the point
      */
-    public double distance(final Vector3D p) {
-        final Vector3D d = p.subtract(zero);
-        final Vector3D n = new Vector3D(1.0, d, -d.dotProduct(direction), direction);
+    public double distance(final Coordinates3D p) {
+        final Coordinates3D d = p.subtract(zero);
+        final Coordinates3D n = new Coordinates3D(1.0, d, -d.dotProduct(direction), direction);
         return n.getNorm();
     }
 
@@ -208,7 +208,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      */
     public double distance(final Line line) {
 
-        final Vector3D normal = Vector3D.crossProduct(direction, line.direction);
+        final Coordinates3D normal = Coordinates3D.crossProduct(direction, line.direction);
         final double n = normal.getNorm();
         if (n < Precision.SAFE_MIN) {
             // lines are parallel
@@ -226,7 +226,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @param line line to check against the instance
      * @return point of the instance closest to another line
      */
-    public Vector3D closestPoint(final Line line) {
+    public Coordinates3D closestPoint(final Line line) {
 
         final double cos = direction.dotProduct(line.direction);
         final double n = 1 - cos * cos;
@@ -235,11 +235,11 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
             return zero;
         }
 
-        final Vector3D delta0 = line.zero.subtract(zero);
+        final Coordinates3D delta0 = line.zero.subtract(zero);
         final double a        = delta0.dotProduct(direction);
         final double b        = delta0.dotProduct(line.direction);
 
-        return new Vector3D(1, zero, (a - b * cos) / n, direction);
+        return new Coordinates3D(1, zero, (a - b * cos) / n, direction);
 
     }
 
@@ -248,8 +248,8 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @return intersection point of the instance and the other line
      * or null if there are no intersection points
      */
-    public Vector3D intersection(final Line line) {
-        final Vector3D closest = closestPoint(line);
+    public Coordinates3D intersection(final Line line) {
+        final Coordinates3D closest = closestPoint(line);
         return line.contains(closest) ? closest : null;
     }
 
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/OutlineExtractor.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/OutlineExtractor.java
index 67abdd199..90eeef7cf 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/OutlineExtractor.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/OutlineExtractor.java
@@ -21,7 +21,7 @@ import java.util.ArrayList;
 import org.apache.commons.math4.geometry.Point;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
 import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
@@ -38,29 +38,29 @@ import org.apache.commons.math4.util.FastMath;
 public class OutlineExtractor {
 
     /** Abscissa axis of the projection plane. */
-    private final Vector3D u;
+    private final Coordinates3D u;
 
     /** Ordinate axis of the projection plane. */
-    private final Vector3D v;
+    private final Coordinates3D v;
 
     /** Normal of the projection plane (viewing direction). */
-    private final Vector3D w;
+    private final Coordinates3D w;
 
     /** Build an extractor for a specific projection plane.
      * @param u abscissa axis of the projection point
      * @param v ordinate axis of the projection point
      */
-    public OutlineExtractor(final Vector3D u, final Vector3D v) {
+    public OutlineExtractor(final Coordinates3D u, final Coordinates3D v) {
         this.u = u;
         this.v = v;
-        w = Vector3D.crossProduct(u, v);
+        w = Coordinates3D.crossProduct(u, v);
     }
 
     /** Extract the outline of a polyhedrons set.
      * @param polyhedronsSet polyhedrons set whose outline must be extracted
      * @return an outline, as an array of loops.
      */
-    public Vector2D[][] getOutline(final PolyhedronsSet polyhedronsSet) {
+    public Coordinates2D[][] getOutline(final PolyhedronsSet polyhedronsSet) {
 
         // project all boundary facets into one polygons set
         final BoundaryProjector projector = new BoundaryProjector(polyhedronsSet.getTolerance());
@@ -68,9 +68,9 @@ public class OutlineExtractor {
         final PolygonsSet projected = projector.getProjected();
 
         // Remove the spurious intermediate vertices from the outline
-        final Vector2D[][] outline = projected.getVertices();
+        final Coordinates2D[][] outline = projected.getVertices();
         for (int i = 0; i < outline.length; ++i) {
-            final Vector2D[] rawLoop = outline[i];
+            final Coordinates2D[] rawLoop = outline[i];
             int end = rawLoop.length;
             int j = 0;
             while (j < end) {
@@ -87,7 +87,7 @@ public class OutlineExtractor {
             }
             if (end != rawLoop.length) {
                 // resize the array
-                outline[i] = new Vector2D[end];
+                outline[i] = new Coordinates2D[end];
                 System.arraycopy(rawLoop, 0, outline[i], 0, end);
             }
         }
@@ -104,10 +104,10 @@ public class OutlineExtractor {
      * @param i index of the point to check (must be between 0 and n-1)
      * @return true if the point is exactly between its neighbors
      */
-    private boolean pointIsBetween(final Vector2D[] loop, final int n, final int i) {
-        final Vector2D previous = loop[(i + n - 1) % n];
-        final Vector2D current  = loop[i];
-        final Vector2D next     = loop[(i + 1) % n];
+    private boolean pointIsBetween(final Coordinates2D[] loop, final int n, final int i) {
+        final Coordinates2D previous = loop[(i + n - 1) % n];
+        final Coordinates2D current  = loop[i];
+        final Coordinates2D next     = loop[(i + 1) % n];
         final double dx1       = current.getX() - previous.getX();
         final double dy1       = current.getY() - previous.getY();
         final double dx2       = next.getX()    - current.getX();
@@ -174,16 +174,16 @@ public class OutlineExtractor {
 
             final double scal = plane.getNormal().dotProduct(w);
             if (FastMath.abs(scal) > 1.0e-3) {
-                Vector2D[][] vertices =
+                Coordinates2D[][] vertices =
                     ((PolygonsSet) absFacet.getRemainingRegion()).getVertices();
 
                 if ((scal < 0) ^ reversed) {
                     // the facet is seen from the inside,
                     // we need to invert its boundary orientation
-                    final Vector2D[][] newVertices = new Vector2D[vertices.length][];
+                    final Coordinates2D[][] newVertices = new Coordinates2D[vertices.length][];
                     for (int i = 0; i < vertices.length; ++i) {
-                        final Vector2D[] loop = vertices[i];
-                        final Vector2D[] newLoop = new Vector2D[loop.length];
+                        final Coordinates2D[] loop = vertices[i];
+                        final Coordinates2D[] newLoop = new Coordinates2D[loop.length];
                         if (loop[0] == null) {
                             newLoop[0] = null;
                             for (int j = 1; j < loop.length; ++j) {
@@ -204,17 +204,17 @@ public class OutlineExtractor {
 
                 // compute the projection of the facet in the outline plane
                 final ArrayList<SubHyperplane<Euclidean2D>> edges = new ArrayList<>();
-                for (Vector2D[] loop : vertices) {
+                for (Coordinates2D[] loop : vertices) {
                     final boolean closed = loop[0] != null;
                     int previous         = closed ? (loop.length - 1) : 1;
-                    Vector3D previous3D  = plane.toSpace((Point<Euclidean2D>) loop[previous]);
+                    Coordinates3D previous3D  = plane.toSpace((Point<Euclidean2D>) loop[previous]);
                     int current          = (previous + 1) % loop.length;
-                    Vector2D pPoint       = new Vector2D(previous3D.dotProduct(u),
+                    Coordinates2D pPoint       = new Coordinates2D(previous3D.dotProduct(u),
                                                          previous3D.dotProduct(v));
                     while (current < loop.length) {
 
-                        final Vector3D current3D = plane.toSpace((Point<Euclidean2D>) loop[current]);
-                        final Vector2D  cPoint    = new Vector2D(current3D.dotProduct(u),
+                        final Coordinates3D current3D = plane.toSpace((Point<Euclidean2D>) loop[current]);
+                        final Coordinates2D  cPoint    = new Coordinates2D(current3D.dotProduct(u),
                                                                  current3D.dotProduct(v));
                         final org.apache.commons.math4.geometry.euclidean.twod.Line line =
                             new org.apache.commons.math4.geometry.euclidean.twod.Line(pPoint, cPoint, tolerance);
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Plane.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Plane.java
index 039f5f2e4..00381944c 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Plane.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Plane.java
@@ -19,12 +19,11 @@ package org.apache.commons.math4.geometry.euclidean.threed;
 import org.apache.commons.math4.exception.MathArithmeticException;
 import org.apache.commons.math4.exception.util.LocalizedFormats;
 import org.apache.commons.math4.geometry.Point;
-import org.apache.commons.math4.geometry.Vector;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.partitioning.Embedding;
 import org.apache.commons.math4.geometry.partitioning.Hyperplane;
 import org.apache.commons.math4.util.FastMath;
@@ -38,16 +37,16 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
     private double originOffset;
 
     /** Origin of the plane frame. */
-    private Vector3D origin;
+    private Coordinates3D origin;
 
     /** First vector of the plane frame (in plane). */
-    private Vector3D u;
+    private Coordinates3D u;
 
     /** Second vector of the plane frame (in plane). */
-    private Vector3D v;
+    private Coordinates3D v;
 
     /** Third vector of the plane frame (plane normal). */
-    private Vector3D w;
+    private Coordinates3D w;
 
     /** Tolerance below which points are considered identical. */
     private final double tolerance;
@@ -58,7 +57,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @exception MathArithmeticException if the normal norm is too small
      * @since 3.3
      */
-    public Plane(final Vector3D normal, final double tolerance)
+    public Plane(final Coordinates3D normal, final double tolerance)
         throws MathArithmeticException {
         setNormal(normal);
         this.tolerance = tolerance;
@@ -73,7 +72,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @exception MathArithmeticException if the normal norm is too small
      * @since 3.3
      */
-    public Plane(final Vector3D p, final Vector3D normal, final double tolerance)
+    public Plane(final Coordinates3D p, final Coordinates3D normal, final double tolerance)
         throws MathArithmeticException {
         setNormal(normal);
         this.tolerance = tolerance;
@@ -91,7 +90,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @exception MathArithmeticException if the points do not constitute a plane
      * @since 3.3
      */
-    public Plane(final Vector3D p1, final Vector3D p2, final Vector3D p3, final double tolerance)
+    public Plane(final Coordinates3D p1, final Coordinates3D p2, final Coordinates3D p3, final double tolerance)
         throws MathArithmeticException {
         this(p1, p2.subtract(p1).crossProduct(p3.subtract(p1)), tolerance);
     }
@@ -127,7 +126,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @param normal normal direction to the plane
      * @exception MathArithmeticException if the normal norm is too small
      */
-    public void reset(final Vector3D p, final Vector3D normal) throws MathArithmeticException {
+    public void reset(final Coordinates3D p, final Coordinates3D normal) throws MathArithmeticException {
         setNormal(normal);
         originOffset = -p.dotProduct(w);
         setFrame();
@@ -151,20 +150,20 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @param normal normal direction to the plane (will be copied)
      * @exception MathArithmeticException if the normal norm is too small
      */
-    private void setNormal(final Vector3D normal) throws MathArithmeticException {
+    private void setNormal(final Coordinates3D normal) throws MathArithmeticException {
         final double norm = normal.getNorm();
         if (norm < 1.0e-10) {
             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
         }
-        w = new Vector3D(1.0 / norm, normal);
+        w = new Coordinates3D(1.0 / norm, normal);
     }
 
     /** Reset the plane frame.
      */
     private void setFrame() {
-        origin = new Vector3D(-originOffset, w);
+        origin = new Coordinates3D(-originOffset, w);
         u = w.orthogonal();
-        v = Vector3D.crossProduct(w, u);
+        v = Coordinates3D.crossProduct(w, u);
     }
 
     /** Get the origin point of the plane frame.
@@ -173,7 +172,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @return the origin point of the plane frame (point closest to the
      * 3D-space origin)
      */
-    public Vector3D getOrigin() {
+    public Coordinates3D getOrigin() {
         return origin;
     }
 
@@ -185,7 +184,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @see #getU
      * @see #getV
      */
-    public Vector3D getNormal() {
+    public Coordinates3D getNormal() {
         return w;
     }
 
@@ -197,7 +196,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @see #getV
      * @see #getNormal
      */
-    public Vector3D getU() {
+    public Coordinates3D getU() {
         return u;
     }
 
@@ -209,7 +208,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @see #getU
      * @see #getNormal
      */
-    public Vector3D getV() {
+    public Coordinates3D getV() {
         return v;
     }
 
@@ -241,7 +240,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * reversed.</p>
      */
     public void revertSelf() {
-        final Vector3D tmp = u;
+        final Coordinates3D tmp = u;
         u = v;
         v = tmp;
         w = w.negate();
@@ -253,42 +252,42 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @return (n-1)-dimension point of the sub-space corresponding to
      * the specified space point
      */
-    public Vector2D toSubSpace(Vector<Euclidean3D> vector) {
-        return toSubSpace((Point<Euclidean3D>) vector);
-    }
+//    public Coordinates2D toSubSpace(Vector<Euclidean3D> vector) {
+//        return toSubSpace((Point<Euclidean3D>) vector);
+//    }
 
     /** Transform a sub-space point into a space point.
      * @param vector (n-1)-dimension point of the sub-space
      * @return n-dimension point of the space corresponding to the
      * specified sub-space point
      */
-    public Vector3D toSpace(Vector<Euclidean2D> vector) {
-        return toSpace((Point<Euclidean2D>) vector);
-    }
+//    public Coordinates3D toSpace(Vector<Euclidean2D> vector) {
+//        return toSpace((Point<Euclidean2D>) vector);
+//    }
 
     /** Transform a 3D space point into an in-plane point.
-     * @param point point of the space (must be a {@link Vector3D
+     * @param point point of the space (must be a {@link Coordinates3D
      * Vector3D} instance)
      * @return in-plane point (really a {@link
-     * org.apache.commons.math4.geometry.euclidean.twod.Vector2D Vector2D} instance)
+     * org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D Vector2D} instance)
      * @see #toSpace
      */
     @Override
-    public Vector2D toSubSpace(final Point<Euclidean3D> point) {
-        final Vector3D p3D = (Vector3D) point;
-        return new Vector2D(p3D.dotProduct(u), p3D.dotProduct(v));
+    public Coordinates2D toSubSpace(final Point<Euclidean3D> point) {
+        final Coordinates3D p3D = (Coordinates3D) point;
+        return new Coordinates2D(p3D.dotProduct(u), p3D.dotProduct(v));
     }
 
     /** Transform an in-plane point into a 3D space point.
      * @param point in-plane point (must be a {@link
-     * org.apache.commons.math4.geometry.euclidean.twod.Vector2D Vector2D} instance)
-     * @return 3D space point (really a {@link Vector3D Vector3D} instance)
+     * org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D Vector2D} instance)
+     * @return 3D space point (really a {@link Coordinates3D Vector3D} instance)
      * @see #toSubSpace
      */
     @Override
-    public Vector3D toSpace(final Point<Euclidean2D> point) {
-        final Vector2D p2D = (Vector2D) point;
-        return new Vector3D(p2D.getX(), u, p2D.getY(), v, -originOffset, w);
+    public Coordinates3D toSpace(final Point<Euclidean2D> point) {
+        final Coordinates2D p2D = (Coordinates2D) point;
+        return new Coordinates3D(p2D.getX(), u, p2D.getY(), v, -originOffset, w);
     }
 
     /** Get one point from the 3D-space.
@@ -298,8 +297,8 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @return one point in the 3D-space, with given coordinates and offset
      * relative to the plane
      */
-    public Vector3D getPointAt(final Vector2D inPlane, final double offset) {
-        return new Vector3D(inPlane.getX(), u, inPlane.getY(), v, offset - originOffset, w);
+    public Coordinates3D getPointAt(final Coordinates2D inPlane, final double offset) {
+        return new Coordinates3D(inPlane.getX(), u, inPlane.getY(), v, offset - originOffset, w);
     }
 
     /** Check if the instance is similar to another plane.
@@ -310,7 +309,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @return true if the planes are similar
      */
     public boolean isSimilarTo(final Plane plane) {
-        final double angle = Vector3D.angle(w, plane.w);
+        final double angle = Coordinates3D.angle(w, plane.w);
         return ((angle < 1.0e-10) && (FastMath.abs(originOffset - plane.originOffset) < tolerance)) ||
                ((angle > (FastMath.PI - 1.0e-10)) && (FastMath.abs(originOffset + plane.originOffset) < tolerance));
     }
@@ -321,9 +320,9 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @param rotation vectorial rotation operator
      * @return a new plane
      */
-    public Plane rotate(final Vector3D center, final Rotation rotation) {
+    public Plane rotate(final Coordinates3D center, final Rotation rotation) {
 
-        final Vector3D delta = origin.subtract(center);
+        final Coordinates3D delta = origin.subtract(center);
         final Plane plane = new Plane(center.add(rotation.applyTo(delta)),
                                       rotation.applyTo(w), tolerance);
 
@@ -340,7 +339,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @param translation translation to apply
      * @return a new plane
      */
-    public Plane translate(final Vector3D translation) {
+    public Plane translate(final Coordinates3D translation) {
 
         final Plane plane = new Plane(origin.add(translation), w, tolerance);
 
@@ -357,15 +356,15 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @return intersection point between between the line and the
      * instance (null if the line is parallel to the instance)
      */
-    public Vector3D intersection(final Line line) {
-        final Vector3D direction = line.getDirection();
+    public Coordinates3D intersection(final Line line) {
+        final Coordinates3D direction = line.getDirection();
         final double   dot       = w.dotProduct(direction);
         if (FastMath.abs(dot) < 1.0e-10) {
             return null;
         }
-        final Vector3D point = line.toSpace((Point<Euclidean1D>) Vector1D.ZERO);
+        final Coordinates3D point = line.toSpace((Point<Euclidean1D>) Coordinates1D.ZERO);
         final double   k     = -(originOffset + w.dotProduct(point)) / dot;
-        return new Vector3D(1.0, point, k, direction);
+        return new Coordinates3D(1.0, point, k, direction);
     }
 
     /** Build the line shared by the instance and another plane.
@@ -374,11 +373,11 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * other plane (really a {@link Line Line} instance)
      */
     public Line intersection(final Plane other) {
-        final Vector3D direction = Vector3D.crossProduct(w, other.w);
+        final Coordinates3D direction = Coordinates3D.crossProduct(w, other.w);
         if (direction.getNorm() < tolerance) {
             return null;
         }
-        final Vector3D point = intersection(this, other, new Plane(direction, tolerance));
+        final Coordinates3D point = intersection(this, other, new Plane(direction, tolerance));
         return new Line(point, point.add(direction), tolerance);
     }
 
@@ -388,7 +387,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @param plane3 third plane2
      * @return intersection point of three planes, null if some planes are parallel
      */
-    public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {
+    public static Coordinates3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {
 
         // coefficients of the three planes linear equations
         final double a1 = plane1.w.getX();
@@ -417,7 +416,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
         }
 
         final double r = 1.0 / determinant;
-        return new Vector3D(
+        return new Coordinates3D(
                             (-a23 * d1 - (c1 * b3 - c3 * b1) * d2 - (c2 * b1 - c1 * b2) * d3) * r,
                             (-b23 * d1 - (c3 * a1 - c1 * a3) * d2 - (c1 * a2 - c2 * a1) * d3) * r,
                             (-c23 * d1 - (b1 * a3 - b3 * a1) * d2 - (b2 * a1 - b1 * a2) * d3) * r);
@@ -445,7 +444,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @param p point to check
      * @return true if p belongs to the plane
      */
-    public boolean contains(final Vector3D p) {
+    public boolean contains(final Coordinates3D p) {
         return FastMath.abs(getOffset(p)) < tolerance;
     }
 
@@ -467,9 +466,9 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      * @param vector vector to check
      * @return offset of the vector
      */
-    public double getOffset(Vector<Euclidean3D> vector) {
-        return getOffset((Point<Euclidean3D>) vector);
-    }
+//    public double getOffset(Vector<Euclidean3D> vector) {
+//        return getOffset((Point<Euclidean3D>) vector);
+//    }
 
     /** Get the offset (oriented distance) of a point.
      * <p>The offset is 0 if the point is on the underlying hyperplane,
@@ -481,7 +480,7 @@ public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Eu
      */
     @Override
     public double getOffset(final Point<Euclidean3D> point) {
-        return ((Vector3D) point).dotProduct(w) + originOffset;
+        return ((Coordinates3D) point).dotProduct(w) + originOffset;
     }
 
     /** Check if the instance has the same orientation as another hyperplane.
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java
index b99c9c224..fcf26f526 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java
@@ -29,7 +29,7 @@ import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
 import org.apache.commons.math4.geometry.euclidean.twod.SubLine;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.partitioning.AbstractRegion;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
 import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
@@ -123,7 +123,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
      * @exception MathIllegalArgumentException if some basic sanity checks fail
      * @since 3.5
      */
-    public PolyhedronsSet(final List<Vector3D> vertices, final List<int[]> facets,
+    public PolyhedronsSet(final List<Coordinates3D> vertices, final List<int[]> facets,
                           final double tolerance) {
         super(buildBoundary(vertices, facets, tolerance), tolerance);
     }
@@ -164,12 +164,12 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
             // too thin box, build an empty polygons set
             return new BSPTree<>(Boolean.FALSE);
         }
-        final Plane pxMin = new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I, tolerance);
-        final Plane pxMax = new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I,  tolerance);
-        final Plane pyMin = new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J, tolerance);
-        final Plane pyMax = new Plane(new Vector3D(0,    yMax, 0),   Vector3D.PLUS_J,  tolerance);
-        final Plane pzMin = new Plane(new Vector3D(0,    0,   zMin), Vector3D.MINUS_K, tolerance);
-        final Plane pzMax = new Plane(new Vector3D(0,    0,   zMax), Vector3D.PLUS_K,  tolerance);
+        final Plane pxMin = new Plane(new Coordinates3D(xMin, 0,    0),   Coordinates3D.MINUS_I, tolerance);
+        final Plane pxMax = new Plane(new Coordinates3D(xMax, 0,    0),   Coordinates3D.PLUS_I,  tolerance);
+        final Plane pyMin = new Plane(new Coordinates3D(0,    yMin, 0),   Coordinates3D.MINUS_J, tolerance);
+        final Plane pyMax = new Plane(new Coordinates3D(0,    yMax, 0),   Coordinates3D.PLUS_J,  tolerance);
+        final Plane pzMin = new Plane(new Coordinates3D(0,    0,   zMin), Coordinates3D.MINUS_K, tolerance);
+        final Plane pzMax = new Plane(new Coordinates3D(0,    0,   zMax), Coordinates3D.PLUS_K,  tolerance);
         final Region<Euclidean3D> boundary =
         new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);
         return boundary.getTree(false);
@@ -183,15 +183,15 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
      * @exception MathIllegalArgumentException if some basic sanity checks fail
      * @since 3.5
      */
-    private static List<SubHyperplane<Euclidean3D>> buildBoundary(final List<Vector3D> vertices,
+    private static List<SubHyperplane<Euclidean3D>> buildBoundary(final List<Coordinates3D> vertices,
                                                                   final List<int[]> facets,
                                                                   final double tolerance) {
 
         // check vertices distances
         for (int i = 0; i < vertices.size() - 1; ++i) {
-            final Vector3D vi = vertices.get(i);
+            final Coordinates3D vi = vertices.get(i);
             for (int j = i + 1; j < vertices.size(); ++j) {
-                if (Vector3D.distance(vi, vertices.get(j)) <= tolerance) {
+                if (Coordinates3D.distance(vi, vertices.get(j)) <= tolerance) {
                     throw new MathIllegalArgumentException(LocalizedFormats.CLOSE_VERTICES,
                                                            vi.getX(), vi.getY(), vi.getZ());
                 }
@@ -216,8 +216,8 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
                         found = found || (v == vA);
                     }
                     if (!found) {
-                        final Vector3D start = vertices.get(vA);
-                        final Vector3D end   = vertices.get(vB);
+                        final Coordinates3D start = vertices.get(vA);
+                        final Coordinates3D end   = vertices.get(vB);
                         throw new MathIllegalArgumentException(LocalizedFormats.EDGE_CONNECTED_TO_ONE_FACET,
                                                                start.getX(), start.getY(), start.getZ(),
                                                                end.getX(),   end.getY(),   end.getZ());
@@ -235,9 +235,9 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
                                     tolerance);
 
             // check all points are in the plane
-            final Vector2D[] two2Points = new Vector2D[facet.length];
+            final Coordinates2D[] two2Points = new Coordinates2D[facet.length];
             for (int i = 0 ; i < facet.length; ++i) {
-                final Vector3D v = vertices.get(facet[i]);
+                final Coordinates3D v = vertices.get(facet[i]);
                 if (!plane.contains(v)) {
                     throw new MathIllegalArgumentException(LocalizedFormats.OUT_OF_PLANE,
                                                            v.getX(), v.getY(), v.getZ());
@@ -261,7 +261,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
      * @exception MathIllegalArgumentException if some facets have fewer than 3 vertices
      * @since 3.5
      */
-    private static int[][] findReferences(final List<Vector3D> vertices, final List<int[]> facets) {
+    private static int[][] findReferences(final List<Coordinates3D> vertices, final List<int[]> facets) {
 
         // find the maximum number of facets a vertex belongs to
         final int[] nbFacets = new int[vertices.size()];
@@ -306,7 +306,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
      * once in the successors list (which means one facet orientation is wrong)
      * @since 3.5
      */
-    private static int[][] successors(final List<Vector3D> vertices, final List<int[]> facets,
+    private static int[][] successors(final List<Coordinates3D> vertices, final List<int[]> facets,
                                       final int[][] references) {
 
         // create an array large enough
@@ -329,8 +329,8 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
                 successors[v][k] = facet[(i + 1) % facet.length];
                 for (int l = 0; l < k; ++l) {
                     if (successors[v][l] == successors[v][k]) {
-                        final Vector3D start = vertices.get(v);
-                        final Vector3D end   = vertices.get(successors[v][k]);
+                        final Coordinates3D start = vertices.get(v);
+                        final Coordinates3D end   = vertices.get(successors[v][k]);
                         throw new MathIllegalArgumentException(LocalizedFormats.FACET_ORIENTATION_MISMATCH,
                                                                start.getX(), start.getY(), start.getZ(),
                                                                end.getX(),   end.getY(),   end.getZ());
@@ -361,11 +361,11 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
             // the polyhedrons set as a finite outside
             // surrounded by an infinite inside
             setSize(Double.POSITIVE_INFINITY);
-            setBarycenter((Point<Euclidean3D>) Vector3D.NaN);
+            setBarycenter((Point<Euclidean3D>) Coordinates3D.NaN);
         } else {
             // the polyhedrons set is finite, apply the remaining scaling factors
             setSize(getSize() / 3.0);
-            setBarycenter((Point<Euclidean3D>) new Vector3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter()));
+            setBarycenter((Point<Euclidean3D>) new Coordinates3D(1.0 / (4 * getSize()), (Coordinates3D) getBarycenter()));
         }
 
     }
@@ -376,7 +376,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
         /** Simple constructor. */
         FacetsContributionVisitor() {
             setSize(0);
-            setBarycenter((Point<Euclidean3D>) new Vector3D(0, 0, 0));
+            setBarycenter((Point<Euclidean3D>) new Coordinates3D(0, 0, 0));
         }
 
         /** {@inheritDoc} */
@@ -415,18 +415,18 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
 
             if (Double.isInfinite(area)) {
                 setSize(Double.POSITIVE_INFINITY);
-                setBarycenter((Point<Euclidean3D>) Vector3D.NaN);
+                setBarycenter((Point<Euclidean3D>) Coordinates3D.NaN);
             } else {
 
                 final Plane    plane  = (Plane) facet.getHyperplane();
-                final Vector3D facetB = plane.toSpace(polygon.getBarycenter());
+                final Coordinates3D facetB = plane.toSpace(polygon.getBarycenter());
                 double   scaled = area * facetB.dotProduct(plane.getNormal());
                 if (reversed) {
                     scaled = -scaled;
                 }
 
                 setSize(getSize() + scaled);
-                setBarycenter((Point<Euclidean3D>) new Vector3D(1.0, (Vector3D) getBarycenter(), scaled, facetB));
+                setBarycenter((Point<Euclidean3D>) new Coordinates3D(1.0, (Coordinates3D) getBarycenter(), scaled, facetB));
 
             }
 
@@ -441,7 +441,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
      * given point, or null if the line does not intersect any
      * sub-hyperplane
      */
-    public SubHyperplane<Euclidean3D> firstIntersection(final Vector3D point, final Line line) {
+    public SubHyperplane<Euclidean3D> firstIntersection(final Coordinates3D point, final Line line) {
         return recurseFirstIntersection(getTree(true), point, line);
     }
 
@@ -454,7 +454,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
      * sub-hyperplane
      */
     private SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node,
-                                                                final Vector3D point,
+                                                                final Coordinates3D point,
                                                                 final Line line) {
 
         final SubHyperplane<Euclidean3D> cut = node.getCut();
@@ -494,7 +494,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
 
         if (!in) {
             // search in the cut hyperplane
-            final Vector3D hit3D = plane.intersection(line);
+            final Coordinates3D hit3D = plane.intersection(line);
             if (hit3D != null && line.getAbscissa(hit3D) > line.getAbscissa(point)) {
                 final SubHyperplane<Euclidean3D> facet = boundaryFacet(hit3D, node);
                 if (facet != null) {
@@ -514,9 +514,9 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
      * @return the boundary facet this points belongs to (or null if it
      * does not belong to any boundary facet)
      */
-    private SubHyperplane<Euclidean3D> boundaryFacet(final Vector3D point,
+    private SubHyperplane<Euclidean3D> boundaryFacet(final Coordinates3D point,
                                                      final BSPTree<Euclidean3D> node) {
-        final Vector2D point2D = ((Plane) node.getCut().getHyperplane()).toSubSpace((Point<Euclidean3D>) point);
+        final Coordinates2D point2D = ((Plane) node.getCut().getHyperplane()).toSubSpace((Point<Euclidean3D>) point);
         @SuppressWarnings("unchecked")
         final BoundaryAttribute<Euclidean3D> attribute =
             (BoundaryAttribute<Euclidean3D>) node.getAttribute();
@@ -537,7 +537,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
      * @param rotation vectorial rotation operator
      * @return a new instance representing the rotated region
      */
-    public PolyhedronsSet rotate(final Vector3D center, final Rotation rotation) {
+    public PolyhedronsSet rotate(final Coordinates3D center, final Rotation rotation) {
         return (PolyhedronsSet) applyTransform(new RotationTransform(center, rotation));
     }
 
@@ -545,7 +545,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
     private static class RotationTransform implements Transform<Euclidean3D, Euclidean2D> {
 
         /** Center point of the rotation. */
-        private final Vector3D   center;
+        private final Coordinates3D   center;
 
         /** Vectorial rotation. */
         private final Rotation   rotation;
@@ -560,16 +560,16 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
          * @param center center point of the rotation
          * @param rotation vectorial rotation
          */
-        RotationTransform(final Vector3D center, final Rotation rotation) {
+        RotationTransform(final Coordinates3D center, final Rotation rotation) {
             this.center   = center;
             this.rotation = rotation;
         }
 
         /** {@inheritDoc} */
         @Override
-        public Vector3D apply(final Point<Euclidean3D> point) {
-            final Vector3D delta = ((Vector3D) point).subtract(center);
-            return new Vector3D(1.0, center, 1.0, rotation.applyTo(delta));
+        public Coordinates3D apply(final Point<Euclidean3D> point) {
+            final Coordinates3D delta = ((Coordinates3D) point).subtract(center);
+            return new Coordinates3D(1.0, center, 1.0, rotation.applyTo(delta));
         }
 
         /** {@inheritDoc} */
@@ -588,12 +588,12 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
 
                 final Plane    oPlane = (Plane) original;
                 final Plane    tPlane = (Plane) transformed;
-                final Vector3D p00    = oPlane.getOrigin();
-                final Vector3D p10    = oPlane.toSpace((Point<Euclidean2D>) new Vector2D(1.0, 0.0));
-                final Vector3D p01    = oPlane.toSpace((Point<Euclidean2D>) new Vector2D(0.0, 1.0));
-                final Vector2D tP00   = tPlane.toSubSpace((Point<Euclidean3D>) apply(p00));
-                final Vector2D tP10   = tPlane.toSubSpace((Point<Euclidean3D>) apply(p10));
-                final Vector2D tP01   = tPlane.toSubSpace((Point<Euclidean3D>) apply(p01));
+                final Coordinates3D p00    = oPlane.getOrigin();
+                final Coordinates3D p10    = oPlane.toSpace((Point<Euclidean2D>) new Coordinates2D(1.0, 0.0));
+                final Coordinates3D p01    = oPlane.toSpace((Point<Euclidean2D>) new Coordinates2D(0.0, 1.0));
+                final Coordinates2D tP00   = tPlane.toSubSpace((Point<Euclidean3D>) apply(p00));
+                final Coordinates2D tP10   = tPlane.toSubSpace((Point<Euclidean3D>) apply(p10));
+                final Coordinates2D tP01   = tPlane.toSubSpace((Point<Euclidean3D>) apply(p01));
 
                 cachedOriginal  = (Plane) original;
                 cachedTransform =
@@ -615,7 +615,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
      * @param translation translation to apply
      * @return a new instance representing the translated region
      */
-    public PolyhedronsSet translate(final Vector3D translation) {
+    public PolyhedronsSet translate(final Coordinates3D translation) {
         return (PolyhedronsSet) applyTransform(new TranslationTransform(translation));
     }
 
@@ -623,7 +623,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
     private static class TranslationTransform implements Transform<Euclidean3D, Euclidean2D> {
 
         /** Translation vector. */
-        private final Vector3D   translation;
+        private final Coordinates3D   translation;
 
         /** Cached original hyperplane. */
         private Plane cachedOriginal;
@@ -634,14 +634,14 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
         /** Build a translation transform.
          * @param translation translation vector
          */
-        TranslationTransform(final Vector3D translation) {
+        TranslationTransform(final Coordinates3D translation) {
             this.translation = translation;
         }
 
         /** {@inheritDoc} */
         @Override
-        public Vector3D apply(final Point<Euclidean3D> point) {
-            return new Vector3D(1.0, (Vector3D) point, 1.0, translation);
+        public Coordinates3D apply(final Point<Euclidean3D> point) {
+            return new Coordinates3D(1.0, (Coordinates3D) point, 1.0, translation);
         }
 
         /** {@inheritDoc} */
@@ -660,7 +660,7 @@ public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {
 
                 final Plane   oPlane = (Plane) original;
                 final Plane   tPlane = (Plane) transformed;
-                final Vector2D shift  = tPlane.toSubSpace((Point<Euclidean3D>) apply(oPlane.getOrigin()));
+                final Coordinates2D shift  = tPlane.toSubSpace((Point<Euclidean3D>) apply(oPlane.getOrigin()));
 
                 cachedOriginal  = (Plane) original;
                 cachedTransform =
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Rotation.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Rotation.java
index 5de70a5f3..ff8f17e48 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Rotation.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Rotation.java
@@ -48,8 +48,8 @@ import org.apache.commons.math4.util.MathArrays;
  * <p>Focus is oriented on what a rotation <em>do</em> rather than on its
  * underlying representation. Once it has been built, and regardless of its
  * internal representation, a rotation is an <em>operator</em> which basically
- * transforms three dimensional {@link Vector3D vectors} into other three
- * dimensional {@link Vector3D vectors}. Depending on the application, the
+ * transforms three dimensional {@link Coordinates3D vectors} into other three
+ * dimensional {@link Coordinates3D vectors}. Depending on the application, the
  * meaning of these vectors may vary and the semantics of the rotation also.</p>
  * <p>For example in an spacecraft attitude simulation tool, users will often
  * consider the vectors are fixed (say the Earth direction for example) and the
@@ -88,7 +88,7 @@ import org.apache.commons.math4.util.MathArrays;
  *
  * <p>Rotations are guaranteed to be immutable objects.</p>
  *
- * @see Vector3D
+ * @see Coordinates3D
  * @see RotationOrder
  * @since 1.2
  */
@@ -162,7 +162,7 @@ public class Rotation implements Serializable {
    * @deprecated as of 3.6, replaced with {@link #Rotation(Vector3D, double, RotationConvention)}
    */
   @Deprecated
-  public Rotation(Vector3D axis, double angle) throws MathIllegalArgumentException {
+  public Rotation(Coordinates3D axis, double angle) throws MathIllegalArgumentException {
       this(axis, angle, RotationConvention.VECTOR_OPERATOR);
   }
 
@@ -173,7 +173,7 @@ public class Rotation implements Serializable {
    * @exception MathIllegalArgumentException if the axis norm is zero
    * @since 3.6
    */
-  public Rotation(final Vector3D axis, final double angle, final RotationConvention convention)
+  public Rotation(final Coordinates3D axis, final double angle, final RotationConvention convention)
       throws MathIllegalArgumentException {
 
     double norm = axis.getNorm();
@@ -272,18 +272,18 @@ public class Rotation implements Serializable {
    * @exception MathArithmeticException if the norm of one of the vectors is zero,
    * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)
    */
-  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)
+  public Rotation(Coordinates3D u1, Coordinates3D u2, Coordinates3D v1, Coordinates3D v2)
       throws MathArithmeticException {
 
       // build orthonormalized base from u1, u2
       // this fails when vectors are null or collinear, which is forbidden to define a rotation
-      final Vector3D u3 = u1.crossProduct(u2).normalize();
+      final Coordinates3D u3 = u1.crossProduct(u2).normalize();
       u2 = u3.crossProduct(u1).normalize();
       u1 = u1.normalize();
 
       // build an orthonormalized base from v1, v2
       // this fails when vectors are null or collinear, which is forbidden to define a rotation
-      final Vector3D v3 = v1.crossProduct(v2).normalize();
+      final Coordinates3D v3 = v1.crossProduct(v2).normalize();
       v2 = v3.crossProduct(v1).normalize();
       v1 = v1.normalize();
 
@@ -327,7 +327,7 @@ public class Rotation implements Serializable {
    * @param v desired image of u by the rotation
    * @exception MathArithmeticException if the norm of one of the vectors is zero
    */
-  public Rotation(Vector3D u, Vector3D v) throws MathArithmeticException {
+  public Rotation(Coordinates3D u, Coordinates3D v) throws MathArithmeticException {
 
     double normProduct = u.getNorm() * v.getNorm();
     if (normProduct == 0) {
@@ -339,7 +339,7 @@ public class Rotation implements Serializable {
     if (dot < ((2.0e-15 - 1.0) * normProduct)) {
       // special case u = -v: we select a PI angle rotation around
       // an arbitrary vector orthogonal to u
-      Vector3D w = u.orthogonal();
+      Coordinates3D w = u.orthogonal();
       q0 = 0.0;
       q1 = -w.getX();
       q2 = -w.getY();
@@ -349,7 +349,7 @@ public class Rotation implements Serializable {
       // the shortest possible rotation: axis orthogonal to this plane
       q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));
       double coeff = 1.0 / (2.0 * q0 * normProduct);
-      Vector3D q = v.crossProduct(u);
+      Coordinates3D q = v.crossProduct(u);
       q1 = coeff * q.getX();
       q2 = coeff * q.getY();
       q3 = coeff * q.getZ();
@@ -522,7 +522,7 @@ public class Rotation implements Serializable {
    * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}
    */
   @Deprecated
-  public Vector3D getAxis() {
+  public Coordinates3D getAxis() {
     return getAxis(RotationConvention.VECTOR_OPERATOR);
   }
 
@@ -537,18 +537,18 @@ public class Rotation implements Serializable {
    * @see #Rotation(Vector3D, double, RotationConvention)
    * @since 3.6
    */
-  public Vector3D getAxis(final RotationConvention convention) {
+  public Coordinates3D getAxis(final RotationConvention convention) {
     final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;
     if (squaredSine == 0) {
-      return convention == RotationConvention.VECTOR_OPERATOR ? Vector3D.PLUS_I : Vector3D.MINUS_I;
+      return convention == RotationConvention.VECTOR_OPERATOR ? Coordinates3D.PLUS_I : Coordinates3D.MINUS_I;
     } else {
         final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;
         if (q0 < 0) {
             final double inverse = sgn / FastMath.sqrt(squaredSine);
-            return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
+            return new Coordinates3D(q1 * inverse, q2 * inverse, q3 * inverse);
         }
         final double inverse = -sgn / FastMath.sqrt(squaredSine);
-        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
+        return new Coordinates3D(q1 * inverse, q2 * inverse, q3 * inverse);
     }
   }
 
@@ -633,8 +633,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusI) coordinates are :
               // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
               // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_K);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_K);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_I);
               if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -651,8 +651,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusI) coordinates are :
               // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
               // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_J);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_J);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_I);
               if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -669,8 +669,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusJ) coordinates are :
               // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
               // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_K);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_K);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_J);
               if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -687,8 +687,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusJ) coordinates are :
               // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
               // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_I);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_I);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_J);
               if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -705,8 +705,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusK) coordinates are :
               // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
               // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_J);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_J);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_K);
               if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -723,8 +723,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusK) coordinates are :
               // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
               // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_I);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_I);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_K);
               if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -741,8 +741,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusI) coordinates are :
               // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
               // and we can choose to have theta in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_I);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_I);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_I);
               if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -759,8 +759,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusI) coordinates are :
               // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
               // and we can choose to have psi in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_I);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_I);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_I);
               if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -777,8 +777,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusJ) coordinates are :
               // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
               // and we can choose to have phi in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_J);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_J);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_J);
               if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -795,8 +795,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusJ) coordinates are :
               // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
               // and we can choose to have psi in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_J);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_J);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_J);
               if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -813,8 +813,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusK) coordinates are :
               // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
               // and we can choose to have phi in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_K);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_K);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_K);
               if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -831,8 +831,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusK) coordinates are :
               // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
               // and we can choose to have theta in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_K);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_K);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_K);
               if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -851,8 +851,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusK) coordinates are :
               // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)
               // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_I);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_I);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_K);
               if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -869,8 +869,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusJ) coordinates are :
               // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)
               // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_I);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_I);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_J);
               if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -887,8 +887,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusK) coordinates are :
               // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)
               // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_J);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_J);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_K);
               if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -905,8 +905,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusI) coordinates are :
               // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)
               // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_J);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_J);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_I);
               if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -923,8 +923,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusJ) coordinates are :
               // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)
               // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_K);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_K);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_J);
               if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -941,8 +941,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusI) coordinates are :
               // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)
               // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
-              Vector3D v1 = applyTo(Vector3D.PLUS_K);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_K);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_I);
               if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(true);
               }
@@ -959,8 +959,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusI) coordinates are :
               // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)
               // and we can choose to have theta in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_I);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_I);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_I);
               if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -977,8 +977,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusI) coordinates are :
               // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)
               // and we can choose to have psi in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_I);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_I);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_I);
               if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -995,8 +995,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusJ) coordinates are :
               //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
               // and we can choose to have phi in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_J);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_J);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_J);
               if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -1013,8 +1013,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusJ) coordinates are :
               //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
               // and we can choose to have psi in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_J);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_J);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_J);
               if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -1031,8 +1031,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusK) coordinates are :
               //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
               // and we can choose to have phi in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_K);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_K);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_K);
               if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -1049,8 +1049,8 @@ public class Rotation implements Serializable {
               // (-r) (Vector3D.plusK) coordinates are :
               //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
               // and we can choose to have theta in the interval [0 ; PI]
-              Vector3D v1 = applyTo(Vector3D.PLUS_K);
-              Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
+              Coordinates3D v1 = applyTo(Coordinates3D.PLUS_K);
+              Coordinates3D v2 = applyInverseTo(Coordinates3D.PLUS_K);
               if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
                   throw new CardanEulerSingularityException(false);
               }
@@ -1108,7 +1108,7 @@ public class Rotation implements Serializable {
    * @param u vector to apply the rotation to
    * @return a new vector which is the image of u by the rotation
    */
-  public Vector3D applyTo(Vector3D u) {
+  public Coordinates3D applyTo(Coordinates3D u) {
 
     double x = u.getX();
     double y = u.getY();
@@ -1116,7 +1116,7 @@ public class Rotation implements Serializable {
 
     double s = q1 * x + q2 * y + q3 * z;
 
-    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,
+    return new Coordinates3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,
                         2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,
                         2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);
 
@@ -1145,7 +1145,7 @@ public class Rotation implements Serializable {
    * @param u vector to apply the inverse of the rotation to
    * @return a new vector which such that u is its image by the rotation
    */
-  public Vector3D applyInverseTo(Vector3D u) {
+  public Coordinates3D applyInverseTo(Coordinates3D u) {
 
     double x = u.getX();
     double y = u.getY();
@@ -1154,7 +1154,7 @@ public class Rotation implements Serializable {
     double s = q1 * x + q2 * y + q3 * z;
     double m0 = -q0;
 
-    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,
+    return new Coordinates3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,
                         2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,
                         2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);
 
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/RotationOrder.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/RotationOrder.java
index 83822e51e..0eec6d0af 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/RotationOrder.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/RotationOrder.java
@@ -35,96 +35,96 @@ public final class RotationOrder {
      * around Z
      */
     public static final RotationOrder XYZ =
-      new RotationOrder("XYZ", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);
+      new RotationOrder("XYZ", Coordinates3D.PLUS_I, Coordinates3D.PLUS_J, Coordinates3D.PLUS_K);
 
     /** Set of Cardan angles.
      * this ordered set of rotations is around X, then around Z, then
      * around Y
      */
     public static final RotationOrder XZY =
-      new RotationOrder("XZY", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);
+      new RotationOrder("XZY", Coordinates3D.PLUS_I, Coordinates3D.PLUS_K, Coordinates3D.PLUS_J);
 
     /** Set of Cardan angles.
      * this ordered set of rotations is around Y, then around X, then
      * around Z
      */
     public static final RotationOrder YXZ =
-      new RotationOrder("YXZ", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);
+      new RotationOrder("YXZ", Coordinates3D.PLUS_J, Coordinates3D.PLUS_I, Coordinates3D.PLUS_K);
 
     /** Set of Cardan angles.
      * this ordered set of rotations is around Y, then around Z, then
      * around X
      */
     public static final RotationOrder YZX =
-      new RotationOrder("YZX", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);
+      new RotationOrder("YZX", Coordinates3D.PLUS_J, Coordinates3D.PLUS_K, Coordinates3D.PLUS_I);
 
     /** Set of Cardan angles.
      * this ordered set of rotations is around Z, then around X, then
      * around Y
      */
     public static final RotationOrder ZXY =
-      new RotationOrder("ZXY", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);
+      new RotationOrder("ZXY", Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, Coordinates3D.PLUS_J);
 
     /** Set of Cardan angles.
      * this ordered set of rotations is around Z, then around Y, then
      * around X
      */
     public static final RotationOrder ZYX =
-      new RotationOrder("ZYX", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);
+      new RotationOrder("ZYX", Coordinates3D.PLUS_K, Coordinates3D.PLUS_J, Coordinates3D.PLUS_I);
 
     /** Set of Euler angles.
      * this ordered set of rotations is around X, then around Y, then
      * around X
      */
     public static final RotationOrder XYX =
-      new RotationOrder("XYX", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);
+      new RotationOrder("XYX", Coordinates3D.PLUS_I, Coordinates3D.PLUS_J, Coordinates3D.PLUS_I);
 
     /** Set of Euler angles.
      * this ordered set of rotations is around X, then around Z, then
      * around X
      */
     public static final RotationOrder XZX =
-      new RotationOrder("XZX", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);
+      new RotationOrder("XZX", Coordinates3D.PLUS_I, Coordinates3D.PLUS_K, Coordinates3D.PLUS_I);
 
     /** Set of Euler angles.
      * this ordered set of rotations is around Y, then around X, then
      * around Y
      */
     public static final RotationOrder YXY =
-      new RotationOrder("YXY", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);
+      new RotationOrder("YXY", Coordinates3D.PLUS_J, Coordinates3D.PLUS_I, Coordinates3D.PLUS_J);
 
     /** Set of Euler angles.
      * this ordered set of rotations is around Y, then around Z, then
      * around Y
      */
     public static final RotationOrder YZY =
-      new RotationOrder("YZY", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);
+      new RotationOrder("YZY", Coordinates3D.PLUS_J, Coordinates3D.PLUS_K, Coordinates3D.PLUS_J);
 
     /** Set of Euler angles.
      * this ordered set of rotations is around Z, then around X, then
      * around Z
      */
     public static final RotationOrder ZXZ =
-      new RotationOrder("ZXZ", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);
+      new RotationOrder("ZXZ", Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, Coordinates3D.PLUS_K);
 
     /** Set of Euler angles.
      * this ordered set of rotations is around Z, then around Y, then
      * around Z
      */
     public static final RotationOrder ZYZ =
-      new RotationOrder("ZYZ", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);
+      new RotationOrder("ZYZ", Coordinates3D.PLUS_K, Coordinates3D.PLUS_J, Coordinates3D.PLUS_K);
 
     /** Name of the rotations order. */
     private final String name;
 
     /** Axis of the first rotation. */
-    private final Vector3D a1;
+    private final Coordinates3D a1;
 
     /** Axis of the second rotation. */
-    private final Vector3D a2;
+    private final Coordinates3D a2;
 
     /** Axis of the third rotation. */
-    private final Vector3D a3;
+    private final Coordinates3D a3;
 
     /** Private constructor.
      * This is a utility class that cannot be instantiated by the user,
@@ -135,7 +135,7 @@ public final class RotationOrder {
      * @param a3 axis of the third rotation
      */
     private RotationOrder(final String name,
-                          final Vector3D a1, final Vector3D a2, final Vector3D a3) {
+                          final Coordinates3D a1, final Coordinates3D a2, final Coordinates3D a3) {
         this.name = name;
         this.a1   = a1;
         this.a2   = a2;
@@ -153,21 +153,21 @@ public final class RotationOrder {
     /** Get the axis of the first rotation.
      * @return axis of the first rotation
      */
-    public Vector3D getA1() {
+    public Coordinates3D getA1() {
         return a1;
     }
 
     /** Get the axis of the second rotation.
      * @return axis of the second rotation
      */
-    public Vector3D getA2() {
+    public Coordinates3D getA2() {
         return a2;
     }
 
     /** Get the axis of the second rotation.
      * @return axis of the second rotation
      */
-    public Vector3D getA3() {
+    public Coordinates3D getA3() {
         return a3;
     }
 
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Segment.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Segment.java
index 2f765de5e..bf7e81fc6 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Segment.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Segment.java
@@ -23,10 +23,10 @@ package org.apache.commons.math4.geometry.euclidean.threed;
 public class Segment {
 
     /** Start point of the segment. */
-    private final Vector3D start;
+    private final Coordinates3D start;
 
     /** End point of the segments. */
-    private final Vector3D end;
+    private final Coordinates3D end;
 
     /** Line containing the segment. */
     private final Line     line;
@@ -36,7 +36,7 @@ public class Segment {
      * @param end end point of the segment
      * @param line line containing the segment
      */
-    public Segment(final Vector3D start, final Vector3D end, final Line line) {
+    public Segment(final Coordinates3D start, final Coordinates3D end, final Line line) {
         this.start  = start;
         this.end    = end;
         this.line   = line;
@@ -45,14 +45,14 @@ public class Segment {
     /** Get the start point of the segment.
      * @return start point of the segment
      */
-    public Vector3D getStart() {
+    public Coordinates3D getStart() {
         return start;
     }
 
     /** Get the end point of the segment.
      * @return end point of the segment
      */
-    public Vector3D getEnd() {
+    public Coordinates3D getEnd() {
         return end;
     }
 
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SphereGenerator.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SphereGenerator.java
index deef1e911..08163ddbb 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SphereGenerator.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SphereGenerator.java
@@ -24,38 +24,38 @@ import org.apache.commons.math4.geometry.enclosing.EnclosingBall;
 import org.apache.commons.math4.geometry.enclosing.SupportBallGenerator;
 import org.apache.commons.math4.geometry.euclidean.twod.DiskGenerator;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.util.FastMath;
 
 /** Class generating an enclosing ball from its support points.
  * @since 3.3
  */
-public class SphereGenerator implements SupportBallGenerator<Euclidean3D, Vector3D> {
+public class SphereGenerator implements SupportBallGenerator<Euclidean3D, Coordinates3D> {
 
     /** {@inheritDoc} */
     @Override
-    public EnclosingBall<Euclidean3D, Vector3D> ballOnSupport(final List<Vector3D> support) {
+    public EnclosingBall<Euclidean3D, Coordinates3D> ballOnSupport(final List<Coordinates3D> support) {
 
         if (support.size() < 1) {
-            return new EnclosingBall<>(Vector3D.ZERO, Double.NEGATIVE_INFINITY);
+            return new EnclosingBall<>(Coordinates3D.ZERO, Double.NEGATIVE_INFINITY);
         } else {
-            final Vector3D vA = support.get(0);
+            final Coordinates3D vA = support.get(0);
             if (support.size() < 2) {
                 return new EnclosingBall<>(vA, 0, vA);
             } else {
-                final Vector3D vB = support.get(1);
+                final Coordinates3D vB = support.get(1);
                 if (support.size() < 3) {
-                    return new EnclosingBall<>(new Vector3D(0.5, vA, 0.5, vB),
+                    return new EnclosingBall<>(new Coordinates3D(0.5, vA, 0.5, vB),
                                                                     0.5 * vA.distance(vB),
                                                                     vA, vB);
                 } else {
-                    final Vector3D vC = support.get(2);
+                    final Coordinates3D vC = support.get(2);
                     if (support.size() < 4) {
 
                         // delegate to 2D disk generator
                         final Plane p = new Plane(vA, vB, vC,
                                                   1.0e-10 * (vA.getNorm1() + vB.getNorm1() + vC.getNorm1()));
-                        final EnclosingBall<Euclidean2D, Vector2D> disk =
+                        final EnclosingBall<Euclidean2D, Coordinates2D> disk =
                                 new DiskGenerator().ballOnSupport(Arrays.asList(p.toSubSpace(vA),
                                                                                 p.toSubSpace(vB),
                                                                                 p.toSubSpace(vC)));
@@ -65,7 +65,7 @@ public class SphereGenerator implements SupportBallGenerator<Euclidean3D, Vector
                                                                         disk.getRadius(), vA, vB, vC);
 
                     } else {
-                        final Vector3D vD = support.get(3);
+                        final Coordinates3D vD = support.get(3);
                         // a sphere is 3D can be defined as:
                         // (1)   (x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 = r^2
                         // which can be written:
@@ -118,7 +118,7 @@ public class SphereGenerator implements SupportBallGenerator<Euclidean3D, Vector
                         final BigFraction dy      = c3[0].subtract(centerY);
                         final BigFraction dz      = c4[0].subtract(centerZ);
                         final BigFraction r2      = dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));
-                        return new EnclosingBall<>(new Vector3D(centerX.doubleValue(),
+                        return new EnclosingBall<>(new Coordinates3D(centerX.doubleValue(),
                                                                                      centerY.doubleValue(),
                                                                                      centerZ.doubleValue()),
                                                                         FastMath.sqrt(r2.doubleValue()),
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SphericalCoordinates.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SphericalCoordinates.java
index 97155b65f..aa4582a78 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SphericalCoordinates.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SphericalCoordinates.java
@@ -55,7 +55,7 @@ public class SphericalCoordinates implements Serializable {
     private static final long serialVersionUID = 20130206L;
 
     /** Cartesian coordinates. */
-    private final Vector3D v;
+    private final Coordinates3D v;
 
     /** Radius. */
     private final double r;
@@ -81,7 +81,7 @@ public class SphericalCoordinates implements Serializable {
     /** Build a spherical coordinates transformer from Cartesian coordinates.
      * @param v Cartesian coordinates
      */
-    public SphericalCoordinates(final Vector3D v) {
+    public SphericalCoordinates(final Coordinates3D v) {
 
         // Cartesian coordinates
         this.v = v;
@@ -111,7 +111,7 @@ public class SphericalCoordinates implements Serializable {
         this.phi   = phi;
 
         // Cartesian coordinates
-        this.v  = new Vector3D(r * cosTheta * sinPhi,
+        this.v  = new Coordinates3D(r * cosTheta * sinPhi,
                                r * sinTheta * sinPhi,
                                r * cosPhi);
 
@@ -120,7 +120,7 @@ public class SphericalCoordinates implements Serializable {
     /** Get the Cartesian coordinates.
      * @return Cartesian coordinates
      */
-    public Vector3D getCartesian() {
+    public Coordinates3D getCartesian() {
         return v;
     }
 
@@ -387,7 +387,7 @@ public class SphericalCoordinates implements Serializable {
          * @return replacement {@link SphericalCoordinates}
          */
         private Object readResolve() {
-            return new SphericalCoordinates(new Vector3D(x, y, z));
+            return new SphericalCoordinates(new Coordinates3D(x, y, z));
         }
 
     }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SubLine.java
index 61499d9e5..1dc0361c0 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SubLine.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SubLine.java
@@ -24,7 +24,7 @@ import org.apache.commons.math4.geometry.Point;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
 import org.apache.commons.math4.geometry.euclidean.oned.Interval;
 import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.partitioning.Region.Location;
 
 /** This class represents a subset of a {@link Line}.
@@ -54,7 +54,7 @@ public class SubLine {
      * @exception MathIllegalArgumentException if the points are equal
      * @since 3.3
      */
-    public SubLine(final Vector3D start, final Vector3D end, final double tolerance)
+    public SubLine(final Coordinates3D start, final Coordinates3D end, final double tolerance)
         throws MathIllegalArgumentException {
         this(new Line(start, end, tolerance), buildIntervalSet(start, end, tolerance));
     }
@@ -88,8 +88,8 @@ public class SubLine {
         final List<Segment> segments = new ArrayList<>(list.size());
 
         for (final Interval interval : list) {
-            final Vector3D start = line.toSpace((Point<Euclidean1D>) new Vector1D(interval.getInf()));
-            final Vector3D end   = line.toSpace((Point<Euclidean1D>) new Vector1D(interval.getSup()));
+            final Coordinates3D start = line.toSpace((Point<Euclidean1D>) new Coordinates1D(interval.getInf()));
+            final Coordinates3D end   = line.toSpace((Point<Euclidean1D>) new Coordinates1D(interval.getSup()));
             segments.add(new Segment(start, end, line));
         }
 
@@ -111,10 +111,10 @@ public class SubLine {
      * occurring on endpoints lead to null being returned
      * @return the intersection point if there is one, null if the sub-lines don't intersect
      */
-    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
+    public Coordinates3D intersection(final SubLine subLine, final boolean includeEndPoints) {
 
         // compute the intersection on infinite line
-        Vector3D v1D = line.intersection(subLine.line);
+        Coordinates3D v1D = line.intersection(subLine.line);
         if (v1D == null) {
             return null;
         }
@@ -140,7 +140,7 @@ public class SubLine {
      * @param tolerance tolerance below which points are considered identical
      * @exception MathIllegalArgumentException if the points are equal
      */
-    private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end, final double tolerance)
+    private static IntervalsSet buildIntervalSet(final Coordinates3D start, final Coordinates3D end, final double tolerance)
         throws MathIllegalArgumentException {
         final Line line = new Line(start, end, tolerance);
         return new IntervalsSet(line.toSubSpace((Point<Euclidean3D>) start).getX(),
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SubPlane.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SubPlane.java
index 0c8958449..bb2de1b89 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SubPlane.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/SubPlane.java
@@ -18,10 +18,10 @@ package org.apache.commons.math4.geometry.euclidean.threed;
 
 import org.apache.commons.math4.geometry.Point;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
 import org.apache.commons.math4.geometry.partitioning.Hyperplane;
@@ -76,11 +76,11 @@ public class SubPlane extends AbstractSubHyperplane<Euclidean3D, Euclidean2D> {
         }
 
         // the hyperplanes do intersect
-        Vector2D p = thisPlane.toSubSpace((Point<Euclidean3D>) inter.toSpace((Point<Euclidean1D>) Vector1D.ZERO));
-        Vector2D q = thisPlane.toSubSpace((Point<Euclidean3D>) inter.toSpace((Point<Euclidean1D>) Vector1D.ONE));
-        Vector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());
+        Coordinates2D p = thisPlane.toSubSpace((Point<Euclidean3D>) inter.toSpace((Point<Euclidean1D>) Coordinates1D.ZERO));
+        Coordinates2D q = thisPlane.toSubSpace((Point<Euclidean3D>) inter.toSpace((Point<Euclidean1D>) Coordinates1D.ONE));
+        Coordinates3D crossP = Coordinates3D.crossProduct(inter.getDirection(), thisPlane.getNormal());
         if (crossP.dotProduct(otherPlane.getNormal()) < 0) {
-            final Vector2D tmp = p;
+            final Coordinates2D tmp = p;
             p           = q;
             q           = tmp;
         }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DFormat.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DFormat.java
index e6033aeae..fd6cce9c7 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DFormat.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DFormat.java
@@ -104,7 +104,7 @@ public class Vector3DFormat extends VectorFormat<Euclidean3D> {
     }
 
     /**
-     * Formats a {@link Vector3D} object to produce a string.
+     * Formats a {@link Coordinates3D} object to produce a string.
      * @param vector the object to format.
      * @param toAppendTo where the text is to be appended
      * @param pos On input: an alignment field, if desired. On output: the
@@ -114,42 +114,42 @@ public class Vector3DFormat extends VectorFormat<Euclidean3D> {
     @Override
     public StringBuffer format(final Vector<Euclidean3D> vector, final StringBuffer toAppendTo,
                                final FieldPosition pos) {
-        final Vector3D v3 = (Vector3D) vector;
+        final Coordinates3D v3 = (Coordinates3D) vector;
         return format(toAppendTo, pos, v3.getX(), v3.getY(), v3.getZ());
     }
 
     /**
-     * Parses a string to produce a {@link Vector3D} object.
+     * Parses a string to produce a {@link Coordinates3D} object.
      * @param source the string to parse
-     * @return the parsed {@link Vector3D} object.
+     * @return the parsed {@link Coordinates3D} object.
      * @throws MathParseException if the beginning of the specified string
      * cannot be parsed.
      */
     @Override
-    public Vector3D parse(final String source) throws MathParseException {
+    public Coordinates3D parse(final String source) throws MathParseException {
         ParsePosition parsePosition = new ParsePosition(0);
-        Vector3D result = parse(source, parsePosition);
+        Coordinates3D result = parse(source, parsePosition);
         if (parsePosition.getIndex() == 0) {
             throw new MathParseException(source,
                                          parsePosition.getErrorIndex(),
-                                         Vector3D.class);
+                                         Coordinates3D.class);
         }
         return result;
     }
 
     /**
-     * Parses a string to produce a {@link Vector3D} object.
+     * Parses a string to produce a {@link Coordinates3D} object.
      * @param source the string to parse
      * @param pos input/ouput parsing parameter.
-     * @return the parsed {@link Vector3D} object.
+     * @return the parsed {@link Coordinates3D} object.
      */
     @Override
-    public Vector3D parse(final String source, final ParsePosition pos) {
+    public Coordinates3D parse(final String source, final ParsePosition pos) {
         final double[] coordinates = parseCoordinates(3, source, pos);
         if (coordinates == null) {
             return null;
         }
-        return new Vector3D(coordinates[0], coordinates[1], coordinates[2]);
+        return new Coordinates3D(coordinates[0], coordinates[1], coordinates[2]);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Coordinates2D.java
similarity index 78%
rename from src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2D.java
rename to src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Coordinates2D.java
index fec599bc6..e68342ed0 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Coordinates2D.java
@@ -28,27 +28,31 @@ import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
-/** This class represents a 2D vector.
+/** This class represents a 2D point or a 2D vector.
+ * <p>An instance of Coordinates2D represents the point with the corresponding
+ * coordinates.</p>
+ * <p>An instance of Coordinates2D also represents the vector which begins at
+ * the origin and ends at the point corresponding to the coordinates.</p>
  * <p>Instances of this class are guaranteed to be immutable.</p>
- * @since 3.0
+ * @since 4.0
  */
-public class Vector2D implements Vector<Euclidean2D> {
+public class Coordinates2D implements Point<Euclidean2D>, Vector<Euclidean2D> {
 
     /** Origin (coordinates: 0, 0). */
-    public static final Vector2D ZERO   = new Vector2D(0, 0);
+    public static final Coordinates2D ZERO   = new Coordinates2D(0, 0);
 
     // CHECKSTYLE: stop ConstantName
     /** A vector with all coordinates set to NaN. */
-    public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);
+    public static final Coordinates2D NaN = new Coordinates2D(Double.NaN, Double.NaN);
     // CHECKSTYLE: resume ConstantName
 
     /** A vector with all coordinates set to positive infinity. */
-    public static final Vector2D POSITIVE_INFINITY =
-        new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
+    public static final Coordinates2D POSITIVE_INFINITY =
+        new Coordinates2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
 
     /** A vector with all coordinates set to negative infinity. */
-    public static final Vector2D NEGATIVE_INFINITY =
-        new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
+    public static final Coordinates2D NEGATIVE_INFINITY =
+        new Coordinates2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
 
     /** Serializable UID. */
     private static final long serialVersionUID = 266938651998679754L;
@@ -66,7 +70,7 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @see #getX()
      * @see #getY()
      */
-    public Vector2D(double x, double y) {
+    public Coordinates2D(double x, double y) {
         this.x = x;
         this.y = y;
     }
@@ -77,7 +81,7 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @exception DimensionMismatchException if array does not have 2 elements
      * @see #toArray()
      */
-    public Vector2D(double[] v) throws DimensionMismatchException {
+    public Coordinates2D(double[] v) throws DimensionMismatchException {
         if (v.length != 2) {
             throw new DimensionMismatchException(v.length, 2);
         }
@@ -91,7 +95,7 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @param a scale factor
      * @param u base (unscaled) vector
      */
-    public Vector2D(double a, Vector2D u) {
+    public Coordinates2D(double a, Coordinates2D u) {
         this.x = a * u.x;
         this.y = a * u.y;
     }
@@ -104,7 +108,7 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @param a2 second scale factor
      * @param u2 second base (unscaled) vector
      */
-    public Vector2D(double a1, Vector2D u1, double a2, Vector2D u2) {
+    public Coordinates2D(double a1, Coordinates2D u1, double a2, Coordinates2D u2) {
         this.x = a1 * u1.x + a2 * u2.x;
         this.y = a1 * u1.y + a2 * u2.y;
     }
@@ -119,8 +123,8 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @param a3 third scale factor
      * @param u3 third base (unscaled) vector
      */
-    public Vector2D(double a1, Vector2D u1, double a2, Vector2D u2,
-                   double a3, Vector2D u3) {
+    public Coordinates2D(double a1, Coordinates2D u1, double a2, Coordinates2D u2,
+                   double a3, Coordinates2D u3) {
         this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;
         this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;
     }
@@ -137,8 +141,8 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @param a4 fourth scale factor
      * @param u4 fourth base (unscaled) vector
      */
-    public Vector2D(double a1, Vector2D u1, double a2, Vector2D u2,
-                   double a3, Vector2D u3, double a4, Vector2D u4) {
+    public Coordinates2D(double a1, Coordinates2D u1, double a2, Coordinates2D u2,
+                   double a3, Coordinates2D u3, double a4, Coordinates2D u4) {
         this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;
         this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;
     }
@@ -175,7 +179,7 @@ public class Vector2D implements Vector<Euclidean2D> {
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D getZero() {
+    public Coordinates2D getZero() {
         return ZERO;
     }
 
@@ -205,35 +209,35 @@ public class Vector2D implements Vector<Euclidean2D> {
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D add(Vector<Euclidean2D> v) {
-        Vector2D v2 = (Vector2D) v;
-        return new Vector2D(x + v2.getX(), y + v2.getY());
+    public Coordinates2D add(Vector<Euclidean2D> v) {
+        Coordinates2D v2 = (Coordinates2D) v;
+        return new Coordinates2D(x + v2.getX(), y + v2.getY());
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D add(double factor, Vector<Euclidean2D> v) {
-        Vector2D v2 = (Vector2D) v;
-        return new Vector2D(x + factor * v2.getX(), y + factor * v2.getY());
+    public Coordinates2D add(double factor, Vector<Euclidean2D> v) {
+        Coordinates2D v2 = (Coordinates2D) v;
+        return new Coordinates2D(x + factor * v2.getX(), y + factor * v2.getY());
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D subtract(Vector<Euclidean2D> p) {
-        Vector2D p3 = (Vector2D) p;
-        return new Vector2D(x - p3.x, y - p3.y);
+    public Coordinates2D subtract(Vector<Euclidean2D> p) {
+        Coordinates2D p3 = (Coordinates2D) p;
+        return new Coordinates2D(x - p3.x, y - p3.y);
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D subtract(double factor, Vector<Euclidean2D> v) {
-        Vector2D v2 = (Vector2D) v;
-        return new Vector2D(x - factor * v2.getX(), y - factor * v2.getY());
+    public Coordinates2D subtract(double factor, Vector<Euclidean2D> v) {
+        Coordinates2D v2 = (Coordinates2D) v;
+        return new Coordinates2D(x - factor * v2.getX(), y - factor * v2.getY());
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D normalize() throws MathArithmeticException {
+    public Coordinates2D normalize() throws MathArithmeticException {
         double s = getNorm();
         if (s == 0) {
             throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);
@@ -252,7 +256,7 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @return angular separation between v1 and v2
      * @exception MathArithmeticException if either vector has a null norm
      */
-    public static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException {
+    public static double angle(Coordinates2D v1, Coordinates2D v2) throws MathArithmeticException {
 
         double normProduct = v1.getNorm() * v2.getNorm();
         if (normProduct == 0) {
@@ -277,14 +281,14 @@ public class Vector2D implements Vector<Euclidean2D> {
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D negate() {
-        return new Vector2D(-x, -y);
+    public Coordinates2D negate() {
+        return new Coordinates2D(-x, -y);
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D scalarMultiply(double a) {
-        return new Vector2D(a * x, a * y);
+    public Coordinates2D scalarMultiply(double a) {
+        return new Coordinates2D(a * x, a * y);
     }
 
     /** {@inheritDoc} */
@@ -302,7 +306,7 @@ public class Vector2D implements Vector<Euclidean2D> {
     /** {@inheritDoc} */
     @Override
     public double distance1(Vector<Euclidean2D> p) {
-        Vector2D p3 = (Vector2D) p;
+        Coordinates2D p3 = (Coordinates2D) p;
         final double dx = FastMath.abs(p3.x - x);
         final double dy = FastMath.abs(p3.y - y);
         return dx + dy;
@@ -311,16 +315,29 @@ public class Vector2D implements Vector<Euclidean2D> {
     /** {@inheritDoc} */
     @Override
     public double distance(Point<Euclidean2D> p) {
-        Vector2D p3 = (Vector2D) p;
-        final double dx = p3.x - x;
-        final double dy = p3.y - y;
+        return distance((Coordinates2D) p);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public double distance(Vector<Euclidean2D> v) {
+        return distance((Coordinates2D) v);
+    }
+
+    /** Compute the distance between the instance and other coordinates.
+     * @param c other coordinates
+     * @return the distance between the instance and c
+     */
+    public double distance(Coordinates2D c) {
+        final double dx = c.x - x;
+        final double dy = c.y - y;
         return FastMath.sqrt(dx * dx + dy * dy);
     }
 
     /** {@inheritDoc} */
     @Override
     public double distanceInf(Vector<Euclidean2D> p) {
-        Vector2D p3 = (Vector2D) p;
+        Coordinates2D p3 = (Coordinates2D) p;
         final double dx = FastMath.abs(p3.x - x);
         final double dy = FastMath.abs(p3.y - y);
         return FastMath.max(dx, dy);
@@ -329,7 +346,7 @@ public class Vector2D implements Vector<Euclidean2D> {
     /** {@inheritDoc} */
     @Override
     public double distanceSq(Vector<Euclidean2D> p) {
-        Vector2D p3 = (Vector2D) p;
+        Coordinates2D p3 = (Coordinates2D) p;
         final double dx = p3.x - x;
         final double dy = p3.y - y;
         return dx * dx + dy * dy;
@@ -338,7 +355,7 @@ public class Vector2D implements Vector<Euclidean2D> {
     /** {@inheritDoc} */
     @Override
     public double dotProduct(final Vector<Euclidean2D> v) {
-        final Vector2D v2 = (Vector2D) v;
+        final Coordinates2D v2 = (Coordinates2D) v;
         return MathArrays.linearCombination(x, v2.x, y, v2.y);
     }
 
@@ -362,7 +379,7 @@ public class Vector2D implements Vector<Euclidean2D> {
      *
      * @see <a href="http://en.wikipedia.org/wiki/Cross_product">Cross product (Wikipedia)</a>
      */
-    public double crossProduct(final Vector2D p1, final Vector2D p2) {
+    public double crossProduct(final Coordinates2D p1, final Coordinates2D p2) {
         final double x1 = p2.getX() - p1.getX();
         final double y1 = getY() - p1.getY();
         final double x2 = getX() - p1.getX();
@@ -378,7 +395,7 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @param p2 second vector
      * @return the distance between p1 and p2 according to the L<sub>2</sub> norm
      */
-    public static double distance(Vector2D p1, Vector2D p2) {
+    public static double distance(Coordinates2D p1, Coordinates2D p2) {
         return p1.distance(p2);
     }
 
@@ -390,7 +407,7 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @param p2 second vector
      * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm
      */
-    public static double distanceInf(Vector2D p1, Vector2D p2) {
+    public static double distanceInf(Coordinates2D p1, Coordinates2D p2) {
         return p1.distanceInf(p2);
     }
 
@@ -402,7 +419,7 @@ public class Vector2D implements Vector<Euclidean2D> {
      * @param p2 second vector
      * @return the square of the distance between p1 and p2
      */
-    public static double distanceSq(Vector2D p1, Vector2D p2) {
+    public static double distanceSq(Coordinates2D p1, Coordinates2D p2) {
         return p1.distanceSq(p2);
     }
 
@@ -432,8 +449,8 @@ public class Vector2D implements Vector<Euclidean2D> {
             return true;
         }
 
-        if (other instanceof Vector2D) {
-            final Vector2D rhs = (Vector2D)other;
+        if (other instanceof Coordinates2D) {
+            final Coordinates2D rhs = (Coordinates2D)other;
             if (rhs.isNaN()) {
                 return this.isNaN();
             }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/DiskGenerator.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/DiskGenerator.java
index a19a8768a..7ac90d4b4 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/DiskGenerator.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/DiskGenerator.java
@@ -26,26 +26,26 @@ import org.apache.commons.math4.util.FastMath;
 /** Class generating an enclosing ball from its support points.
  * @since 3.3
  */
-public class DiskGenerator implements SupportBallGenerator<Euclidean2D, Vector2D> {
+public class DiskGenerator implements SupportBallGenerator<Euclidean2D, Coordinates2D> {
 
     /** {@inheritDoc} */
     @Override
-    public EnclosingBall<Euclidean2D, Vector2D> ballOnSupport(final List<Vector2D> support) {
+    public EnclosingBall<Euclidean2D, Coordinates2D> ballOnSupport(final List<Coordinates2D> support) {
 
         if (support.size() < 1) {
-            return new EnclosingBall<>(Vector2D.ZERO, Double.NEGATIVE_INFINITY);
+            return new EnclosingBall<>(Coordinates2D.ZERO, Double.NEGATIVE_INFINITY);
         } else {
-            final Vector2D vA = support.get(0);
+            final Coordinates2D vA = support.get(0);
             if (support.size() < 2) {
                 return new EnclosingBall<>(vA, 0, vA);
             } else {
-                final Vector2D vB = support.get(1);
+                final Coordinates2D vB = support.get(1);
                 if (support.size() < 3) {
-                    return new EnclosingBall<>(new Vector2D(0.5, vA, 0.5, vB),
+                    return new EnclosingBall<>(new Coordinates2D(0.5, vA, 0.5, vB),
                                                                     0.5 * vA.distance(vB),
                                                                     vA, vB);
                 } else {
-                    final Vector2D vC = support.get(2);
+                    final Coordinates2D vC = support.get(2);
                     // a disk is 2D can be defined as:
                     // (1)   (x - x_0)^2 + (y - y_0)^2 = r^2
                     // which can be written:
@@ -86,7 +86,7 @@ public class DiskGenerator implements SupportBallGenerator<Euclidean2D, Vector2D
                     final BigFraction dx      = c2[0].subtract(centerX);
                     final BigFraction dy      = c3[0].subtract(centerY);
                     final BigFraction r2      = dx.multiply(dx).add(dy.multiply(dy));
-                    return new EnclosingBall<>(new Vector2D(centerX.doubleValue(),
+                    return new EnclosingBall<>(new Coordinates2D(centerX.doubleValue(),
                                                                                  centerY.doubleValue()),
                                                                     FastMath.sqrt(r2.doubleValue()),
                                                                     vA, vB, vC);
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Line.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Line.java
index dd8929646..7df7277f1 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Line.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Line.java
@@ -19,11 +19,10 @@ package org.apache.commons.math4.geometry.euclidean.twod;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.util.LocalizedFormats;
 import org.apache.commons.math4.geometry.Point;
-import org.apache.commons.math4.geometry.Vector;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
 import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
 import org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.partitioning.Embedding;
 import org.apache.commons.math4.geometry.partitioning.Hyperplane;
 import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
@@ -85,7 +84,7 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @param tolerance tolerance below which points are considered identical
      * @since 3.3
      */
-    public Line(final Vector2D p1, final Vector2D p2, final double tolerance) {
+    public Line(final Coordinates2D p1, final Coordinates2D p2, final double tolerance) {
         reset(p1, p2);
         this.tolerance = tolerance;
     }
@@ -96,7 +95,7 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @param tolerance tolerance below which points are considered identical
      * @since 3.3
      */
-    public Line(final Vector2D p, final double angle, final double tolerance) {
+    public Line(final Coordinates2D p, final double angle, final double tolerance) {
         reset(p, angle);
         this.tolerance = tolerance;
     }
@@ -144,7 +143,7 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @param p1 first point
      * @param p2 second point
      */
-    public void reset(final Vector2D p1, final Vector2D p2) {
+    public void reset(final Coordinates2D p1, final Coordinates2D p2) {
         unlinkReverse();
         final double dx = p2.getX() - p1.getX();
         final double dy = p2.getY() - p1.getY();
@@ -166,7 +165,7 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @param p point belonging to the line
      * @param alpha angle of the line with respect to abscissa axis
      */
-    public void reset(final Vector2D p, final double alpha) {
+    public void reset(final Coordinates2D p, final double alpha) {
         unlinkReverse();
         this.angle   = MathUtils.normalizeAngle(alpha, FastMath.PI);
         cos          = FastMath.cos(this.angle);
@@ -226,31 +225,31 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @return (n-1)-dimension point of the sub-space corresponding to
      * the specified space point
      */
-    public Vector1D toSubSpace(Vector<Euclidean2D> vector) {
-        return toSubSpace((Point<Euclidean2D>) vector);
-    }
+//    public Coordinates1D toSubSpace(Vector<Euclidean2D> vector) {
+//        return toSubSpace((Point<Euclidean2D>) vector);
+//    }
 
     /** Transform a sub-space point into a space point.
      * @param vector (n-1)-dimension point of the sub-space
      * @return n-dimension point of the space corresponding to the
      * specified sub-space point
      */
-    public Vector2D toSpace(Vector<Euclidean1D> vector) {
-        return toSpace((Point<Euclidean1D>) vector);
-    }
+//    public Coordinates2D toSpace(Vector<Euclidean1D> vector) {
+//        return toSpace((Point<Euclidean1D>) vector);
+//    }
 
     /** {@inheritDoc} */
     @Override
-    public Vector1D toSubSpace(final Point<Euclidean2D> point) {
-        Vector2D p2 = (Vector2D) point;
-        return new Vector1D(MathArrays.linearCombination(cos, p2.getX(), sin, p2.getY()));
+    public Coordinates1D toSubSpace(final Point<Euclidean2D> point) {
+        Coordinates2D p2 = (Coordinates2D) point;
+        return new Coordinates1D(MathArrays.linearCombination(cos, p2.getX(), sin, p2.getY()));
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D toSpace(final Point<Euclidean1D> point) {
-        final double abscissa = ((Vector1D) point).getX();
-        return new Vector2D(MathArrays.linearCombination(abscissa, cos, -originOffset, sin),
+    public Coordinates2D toSpace(final Point<Euclidean1D> point) {
+        final double abscissa = ((Coordinates1D) point).getX();
+        return new Coordinates2D(MathArrays.linearCombination(abscissa, cos, -originOffset, sin),
                             MathArrays.linearCombination(abscissa, sin,  originOffset, cos));
     }
 
@@ -259,12 +258,12 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @return intersection point of the instance and the other line
      * or null if there are no intersection points
      */
-    public Vector2D intersection(final Line other) {
+    public Coordinates2D intersection(final Line other) {
         final double d = MathArrays.linearCombination(sin, other.cos, -other.sin, cos);
         if (FastMath.abs(d) < tolerance) {
             return null;
         }
-        return new Vector2D(MathArrays.linearCombination(cos, other.originOffset, -other.cos, originOffset) / d,
+        return new Coordinates2D(MathArrays.linearCombination(cos, other.originOffset, -other.cos, originOffset) / d,
                             MathArrays.linearCombination(sin, other.originOffset, -other.sin, originOffset) / d);
     }
 
@@ -318,14 +317,14 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @param vector vector to check
      * @return offset of the vector
      */
-    public double getOffset(Vector<Euclidean2D> vector) {
-        return getOffset((Point<Euclidean2D>) vector);
-    }
+//    public double getOffset(Vector<Euclidean2D> vector) {
+//        return getOffset((Point<Euclidean2D>) vector);
+//    }
 
     /** {@inheritDoc} */
     @Override
     public double getOffset(final Point<Euclidean2D> point) {
-        Vector2D p2 = (Vector2D) point;
+        Coordinates2D p2 = (Coordinates2D) point;
         return MathArrays.linearCombination(sin, p2.getX(), -cos, p2.getY(), 1.0, originOffset);
     }
 
@@ -342,10 +341,10 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @return one point in the plane, with given abscissa and offset
      * relative to the line
      */
-    public Vector2D getPointAt(final Vector1D abscissa, final double offset) {
+    public Coordinates2D getPointAt(final Coordinates1D abscissa, final double offset) {
         final double x       = abscissa.getX();
         final double dOffset = offset - originOffset;
-        return new Vector2D(MathArrays.linearCombination(x, cos,  dOffset, sin),
+        return new Coordinates2D(MathArrays.linearCombination(x, cos,  dOffset, sin),
                             MathArrays.linearCombination(x, sin, -dOffset, cos));
     }
 
@@ -353,7 +352,7 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @param p point to check
      * @return true if p belongs to the line
      */
-    public boolean contains(final Vector2D p) {
+    public boolean contains(final Coordinates2D p) {
         return FastMath.abs(getOffset(p)) < tolerance;
     }
 
@@ -366,7 +365,7 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @return distance between the instance and the point
      * @since 3.1
      */
-    public double distance(final Vector2D p) {
+    public double distance(final Coordinates2D p) {
         return FastMath.abs(getOffset(p));
     }
 
@@ -382,7 +381,7 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
     /** Translate the line to force it passing by a point.
      * @param p point by which the line should pass
      */
-    public void translateToPoint(final Vector2D p) {
+    public void translateToPoint(final Coordinates2D p) {
         originOffset = MathArrays.linearCombination(cos, p.getY(), -sin, p.getX());
     }
 
@@ -427,7 +426,7 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * @param cX1 transform addendum for output abscissa
      * @param cY1 transform addendum for output ordinate
      * @return a new transform that can be applied to either {@link
-     * Vector2D Vector2D}, {@link Line Line} or {@link
+     * Coordinates2D Vector2D}, {@link Line Line} or {@link
      * org.apache.commons.math4.geometry.partitioning.SubHyperplane
      * SubHyperplane} instances
      * @exception MathIllegalArgumentException if the transform is non invertible
@@ -512,11 +511,11 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
 
         /** {@inheritDoc} */
         @Override
-        public Vector2D apply(final Point<Euclidean2D> point) {
-            final Vector2D p2D = (Vector2D) point;
+        public Coordinates2D apply(final Point<Euclidean2D> point) {
+            final Coordinates2D p2D = (Coordinates2D) point;
             final double  x   = p2D.getX();
             final double  y   = p2D.getY();
-            return new Vector2D(MathArrays.linearCombination(cXX, x, cXY, y, cX1, 1),
+            return new Coordinates2D(MathArrays.linearCombination(cXX, x, cXY, y, cX1, 1),
                                 MathArrays.linearCombination(cYX, x, cYY, y, cY1, 1));
         }
 
@@ -541,7 +540,7 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
             final OrientedPoint op     = (OrientedPoint) sub.getHyperplane();
             final Line originalLine    = (Line) original;
             final Line transformedLine = (Line) transformed;
-            final Vector1D newLoc =
+            final Coordinates1D newLoc = 
                 transformedLine.toSubSpace(apply(originalLine.toSpace(op.getLocation())));
             return new OrientedPoint(newLoc, op.isDirect(), originalLine.tolerance).wholeHyperplane();
         }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoops.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoops.java
index a967fb6de..5affbfc7b 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoops.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoops.java
@@ -48,7 +48,7 @@ import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
 class NestedLoops {
 
     /** Boundary loop. */
-    private Vector2D[] loop;
+    private Coordinates2D[] loop;
 
     /** Surrounded loops. */
     private List<NestedLoops> surrounded;
@@ -82,7 +82,7 @@ class NestedLoops {
      * @exception MathIllegalArgumentException if an outline has an open boundary loop
      * @since 3.3
      */
-    private NestedLoops(final Vector2D[] loop, final double tolerance)
+    private NestedLoops(final Coordinates2D[] loop, final double tolerance)
         throws MathIllegalArgumentException {
 
         if (loop[0] == null) {
@@ -95,9 +95,9 @@ class NestedLoops {
 
         // build the polygon defined by the loop
         final ArrayList<SubHyperplane<Euclidean2D>> edges = new ArrayList<>();
-        Vector2D current = loop[loop.length - 1];
+        Coordinates2D current = loop[loop.length - 1];
         for (int i = 0; i < loop.length; ++i) {
-            final Vector2D previous = current;
+            final Coordinates2D previous = current;
             current = loop[i];
             final Line   line   = new Line(previous, current, tolerance);
             final IntervalsSet region =
@@ -123,7 +123,7 @@ class NestedLoops {
      * @exception MathIllegalArgumentException if an outline has crossing
      * boundary loops or open boundary loops
      */
-    public void add(final Vector2D[] bLoop) throws MathIllegalArgumentException {
+    public void add(final Coordinates2D[] bLoop) throws MathIllegalArgumentException {
         add(new NestedLoops(bLoop, tolerance));
     }
 
@@ -185,7 +185,7 @@ class NestedLoops {
             int min = -1;
             int max = loop.length;
             while (++min < --max) {
-                final Vector2D tmp = loop[min];
+                final Coordinates2D tmp = loop[min];
                 loop[min] = loop[max];
                 loop[max] = tmp;
             }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSet.java
index 38b94f493..eb2d66a42 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSet.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSet.java
@@ -24,7 +24,7 @@ import org.apache.commons.math4.geometry.Point;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
 import org.apache.commons.math4.geometry.euclidean.oned.Interval;
 import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.partitioning.AbstractRegion;
 import org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
@@ -42,7 +42,7 @@ import org.apache.commons.math4.util.Precision;
 public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
 
     /** Vertices organized as boundary loops. */
-    private Vector2D[][] vertices;
+    private Coordinates2D[][] vertices;
 
     /** Build a polygons set representing the whole plane.
      * @param tolerance tolerance below which points are considered identical
@@ -147,7 +147,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
      * belong to the hyperplane (which is therefore more a slab)
      * @param vertices vertices of the simple loop boundary
      */
-    public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices) {
+    public PolygonsSet(final double hyperplaneThickness, final Coordinates2D ... vertices) {
         super(verticesToTree(hyperplaneThickness, vertices), hyperplaneThickness);
     }
 
@@ -166,10 +166,10 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
             // too thin box, build an empty polygons set
             return null;
         }
-        final Vector2D minMin = new Vector2D(xMin, yMin);
-        final Vector2D minMax = new Vector2D(xMin, yMax);
-        final Vector2D maxMin = new Vector2D(xMax, yMin);
-        final Vector2D maxMax = new Vector2D(xMax, yMax);
+        final Coordinates2D minMin = new Coordinates2D(xMin, yMin);
+        final Coordinates2D minMax = new Coordinates2D(xMin, yMax);
+        final Coordinates2D maxMin = new Coordinates2D(xMax, yMin);
+        final Coordinates2D maxMax = new Coordinates2D(xMax, yMax);
         return new Line[] {
             new Line(minMin, maxMin, tolerance),
             new Line(maxMin, maxMax, tolerance),
@@ -194,7 +194,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
      * @return the BSP tree of the input vertices
      */
     private static BSPTree<Euclidean2D> verticesToTree(final double hyperplaneThickness,
-                                                       final Vector2D ... vertices) {
+                                                       final Coordinates2D ... vertices) {
 
         final int n = vertices.length;
         if (n == 0) {
@@ -347,7 +347,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
     private static class Vertex {
 
         /** Vertex location. */
-        private final Vector2D location;
+        private final Coordinates2D location;
 
         /** Incoming edge. */
         private Edge incoming;
@@ -361,7 +361,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
         /** Build a non-processed vertex not owned by any node yet.
          * @param location vertex location
          */
-        Vertex(final Vector2D location) {
+        Vertex(final Coordinates2D location) {
             this.location = location;
             this.incoming = null;
             this.outgoing = null;
@@ -371,7 +371,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
         /** Get Vertex location.
          * @return vertex location
          */
-        public Vector2D getLocation() {
+        public Coordinates2D getLocation() {
             return location;
         }
 
@@ -543,22 +543,22 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
     @Override
     protected void computeGeometricalProperties() {
 
-        final Vector2D[][] v = getVertices();
+        final Coordinates2D[][] v = getVertices();
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
             if (tree.getCut() == null && (Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
-                setBarycenter((Point<Euclidean2D>) Vector2D.NaN);
+                setBarycenter((Point<Euclidean2D>) Coordinates2D.NaN);
             } else {
                 setSize(0);
-                setBarycenter((Point<Euclidean2D>) new Vector2D(0, 0));
+                setBarycenter((Point<Euclidean2D>) new Coordinates2D(0, 0));
             }
         } else if (v[0][0] == null) {
             // there is at least one open-loop: the polygon is infinite
             setSize(Double.POSITIVE_INFINITY);
-            setBarycenter((Point<Euclidean2D>) Vector2D.NaN);
+            setBarycenter((Point<Euclidean2D>) Coordinates2D.NaN);
         } else {
             // all loops are closed, we compute some integrals around the shape
 
@@ -566,10 +566,10 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
             double sumX = 0;
             double sumY = 0;
 
-            for (Vector2D[] loop : v) {
+            for (Coordinates2D[] loop : v) {
                 double x1 = loop[loop.length - 1].getX();
                 double y1 = loop[loop.length - 1].getY();
-                for (final Vector2D point : loop) {
+                for (final Coordinates2D point : loop) {
                     final double x0 = x1;
                     final double y0 = y1;
                     x1 = point.getX();
@@ -584,10 +584,10 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
             if (sum < 0) {
                 // the polygon as a finite outside surrounded by an infinite inside
                 setSize(Double.POSITIVE_INFINITY);
-                setBarycenter((Point<Euclidean2D>) Vector2D.NaN);
+                setBarycenter((Point<Euclidean2D>) Coordinates2D.NaN);
             } else {
                 setSize(sum / 2);
-                setBarycenter((Point<Euclidean2D>) new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
+                setBarycenter((Point<Euclidean2D>) new Coordinates2D(sumX / (3 * sum), sumY / (3 * sum)));
             }
 
         }
@@ -617,10 +617,10 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
      * loops with the open loops first (the returned value is guaranteed
      * to be non-null)
      */
-    public Vector2D[][] getVertices() {
+    public Coordinates2D[][] getVertices() {
         if (vertices == null) {
             if (getTree(false).getCut() == null) {
-                vertices = new Vector2D[0][];
+                vertices = new Coordinates2D[0][];
             } else {
 
                 // build the unconnected segments
@@ -655,7 +655,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
                 }
 
                 // transform the loops in an array of arrays of points
-                vertices = new Vector2D[loops.size()][];
+                vertices = new Coordinates2D[loops.size()][];
                 int i = 0;
 
                 for (final List<Segment> loop : loops) {
@@ -663,14 +663,14 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
                         (loop.size() == 2 && loop.get(0).getStart() == null && loop.get(1).getEnd() == null)) {
                         // single infinite line
                         final Line line = loop.get(0).getLine();
-                        vertices[i++] = new Vector2D[] {
+                        vertices[i++] = new Coordinates2D[] {
                             null,
-                            line.toSpace((Point<Euclidean1D>) new Vector1D(-Float.MAX_VALUE)),
-                            line.toSpace((Point<Euclidean1D>) new Vector1D(+Float.MAX_VALUE))
+                            line.toSpace((Point<Euclidean1D>) new Coordinates1D(-Float.MAX_VALUE)),
+                            line.toSpace((Point<Euclidean1D>) new Coordinates1D(+Float.MAX_VALUE))
                         };
                     } else if (loop.get(0).getStart() == null) {
                         // open loop with at least one real point
-                        final Vector2D[] array = new Vector2D[loop.size() + 2];
+                        final Coordinates2D[] array = new Coordinates2D[loop.size() + 2];
                         int j = 0;
                         for (Segment segment : loop) {
 
@@ -679,7 +679,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
                                 double x = segment.getLine().toSubSpace((Point<Euclidean2D>) segment.getEnd()).getX();
                                 x -= FastMath.max(1.0, FastMath.abs(x / 2));
                                 array[j++] = null;
-                                array[j++] = segment.getLine().toSpace((Point<Euclidean1D>) new Vector1D(x));
+                                array[j++] = segment.getLine().toSpace((Point<Euclidean1D>) new Coordinates1D(x));
                             }
 
                             if (j < (array.length - 1)) {
@@ -691,13 +691,13 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
                                 // last dummy point
                                 double x = segment.getLine().toSubSpace((Point<Euclidean2D>) segment.getStart()).getX();
                                 x += FastMath.max(1.0, FastMath.abs(x / 2));
-                                array[j++] = segment.getLine().toSpace((Point<Euclidean1D>) new Vector1D(x));
+                                array[j++] = segment.getLine().toSpace((Point<Euclidean1D>) new Coordinates1D(x));
                             }
 
                         }
                         vertices[i++] = array;
                     } else {
-                        final Vector2D[] array = new Vector2D[loop.size()];
+                        final Coordinates2D[] array = new Coordinates2D[loop.size()];
                         int j = 0;
                         for (Segment segment : loop) {
                             array[j++] = segment.getStart();
@@ -777,12 +777,12 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
         int connected = 0;
         for (final ConnectableSegment segment : segments) {
             if (segment.getNext() == null && segment.getEnd() != null) {
-                final Vector2D end = segment.getEnd();
+                final Coordinates2D end = segment.getEnd();
                 ConnectableSegment selectedNext = null;
                 double min = Double.POSITIVE_INFINITY;
                 for (final ConnectableSegment candidateNext : segments) {
                     if (candidateNext.getPrevious() == null && candidateNext.getStart() != null) {
-                        final double distance = Vector2D.distance(end, candidateNext.getStart());
+                        final double distance = Coordinates2D.distance(end, candidateNext.getStart());
                         if (distance < min) {
                             selectedNext = candidateNext;
                             min          = distance;
@@ -906,7 +906,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
          * @param startNode node whose intersection with current node defines start point
          * @param endNode node whose intersection with current node defines end point
          */
-        ConnectableSegment(final Vector2D start, final Vector2D end, final Line line,
+        ConnectableSegment(final Coordinates2D start, final Coordinates2D end, final Line line,
                            final BSPTree<Euclidean2D> node,
                            final BSPTree<Euclidean2D> startNode,
                            final BSPTree<Euclidean2D> endNode) {
@@ -1044,10 +1044,10 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
             for (final Interval i : intervals) {
 
                 // find the 2D points
-                final Vector2D startV = Double.isInfinite(i.getInf()) ?
-                                        null : (Vector2D) line.toSpace((Point<Euclidean1D>) new Vector1D(i.getInf()));
-                final Vector2D endV   = Double.isInfinite(i.getSup()) ?
-                                        null : (Vector2D) line.toSpace((Point<Euclidean1D>) new Vector1D(i.getSup()));
+                final Coordinates2D startV = Double.isInfinite(i.getInf()) ?
+                                        null : (Coordinates2D) line.toSpace((Point<Euclidean1D>) new Coordinates1D(i.getInf()));
+                final Coordinates2D endV   = Double.isInfinite(i.getSup()) ?
+                                        null : (Coordinates2D) line.toSpace((Point<Euclidean1D>) new Coordinates1D(i.getSup()));
 
                 // recover the connectivity information
                 final BSPTree<Euclidean2D> startN = selectClosest(startV, splitters);
@@ -1069,7 +1069,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
          * @param candidates candidate nodes
          * @return node closest to point, or null if no node is closer than tolerance
          */
-        private BSPTree<Euclidean2D> selectClosest(final Vector2D point, final Iterable<BSPTree<Euclidean2D>> candidates) {
+        private BSPTree<Euclidean2D> selectClosest(final Coordinates2D point, final Iterable<BSPTree<Euclidean2D>> candidates) {
 
             BSPTree<Euclidean2D> selected = null;
             double min = Double.POSITIVE_INFINITY;
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Segment.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Segment.java
index 32e5c6b7f..2e48541c7 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Segment.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Segment.java
@@ -25,10 +25,10 @@ import org.apache.commons.math4.util.FastMath;
 public class Segment {
 
     /** Start point of the segment. */
-    private final Vector2D start;
+    private final Coordinates2D start;
 
     /** End point of the segment. */
-    private final Vector2D end;
+    private final Coordinates2D end;
 
     /** Line containing the segment. */
     private final Line     line;
@@ -38,7 +38,7 @@ public class Segment {
      * @param end end point of the segment
      * @param line line containing the segment
      */
-    public Segment(final Vector2D start, final Vector2D end, final Line line) {
+    public Segment(final Coordinates2D start, final Coordinates2D end, final Line line) {
         this.start  = start;
         this.end    = end;
         this.line   = line;
@@ -47,14 +47,14 @@ public class Segment {
     /** Get the start point of the segment.
      * @return start point of the segment
      */
-    public Vector2D getStart() {
+    public Coordinates2D getStart() {
         return start;
     }
 
     /** Get the end point of the segment.
      * @return end point of the segment
      */
-    public Vector2D getEnd() {
+    public Coordinates2D getEnd() {
         return end;
     }
 
@@ -80,7 +80,7 @@ public class Segment {
      * @return distance between the instance and the point
      * @since 3.1
      */
-    public double distance(final Vector2D p) {
+    public double distance(final Coordinates2D p) {
         final double deltaX = end.getX() - start.getX();
         final double deltaY = end.getY() - start.getY();
 
@@ -105,7 +105,7 @@ public class Segment {
             final double px = start.getX() + r * deltaX;
             final double py = start.getY() + r * deltaY;
 
-            final Vector2D interPt = new Vector2D(px, py);
+            final Coordinates2D interPt = new Coordinates2D(px, py);
             return interPt.distance((Point<Euclidean2D>) p);
         }
     }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/SubLine.java
index eb247605e..c7c053047 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/SubLine.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/SubLine.java
@@ -24,7 +24,7 @@ import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
 import org.apache.commons.math4.geometry.euclidean.oned.Interval;
 import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
 import org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
 import org.apache.commons.math4.geometry.partitioning.Hyperplane;
@@ -53,7 +53,7 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {
      * @param tolerance tolerance below which points are considered identical
      * @since 3.3
      */
-    public SubLine(final Vector2D start, final Vector2D end, final double tolerance) {
+    public SubLine(final Coordinates2D start, final Coordinates2D end, final double tolerance) {
         super(new Line(start, end, tolerance), buildIntervalSet(start, end, tolerance));
     }
 
@@ -86,8 +86,8 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {
         final List<Segment> segments = new ArrayList<>(list.size());
 
         for (final Interval interval : list) {
-            final Vector2D start = line.toSpace((Point<Euclidean1D>) new Vector1D(interval.getInf()));
-            final Vector2D end   = line.toSpace((Point<Euclidean1D>) new Vector1D(interval.getSup()));
+            final Coordinates2D start = line.toSpace((Point<Euclidean1D>) new Coordinates1D(interval.getInf()));
+            final Coordinates2D end   = line.toSpace((Point<Euclidean1D>) new Coordinates1D(interval.getSup()));
             segments.add(new Segment(start, end, line));
         }
 
@@ -109,14 +109,14 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {
      * occurring on endpoints lead to null being returned
      * @return the intersection point if there is one, null if the sub-lines don't intersect
      */
-    public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
+    public Coordinates2D intersection(final SubLine subLine, final boolean includeEndPoints) {
 
         // retrieve the underlying lines
         Line line1 = (Line) getHyperplane();
         Line line2 = (Line) subLine.getHyperplane();
 
         // compute the intersection on infinite line
-        Vector2D v2D = line1.intersection(line2);
+        Coordinates2D v2D = line1.intersection(line2);
         if (v2D == null) {
             return null;
         }
@@ -141,10 +141,10 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {
      * @param tolerance tolerance below which points are considered identical
      * @return an interval set
      */
-    private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end, final double tolerance) {
+    private static IntervalsSet buildIntervalSet(final Coordinates2D start, final Coordinates2D end, final double tolerance) {
         final Line line = new Line(start, end, tolerance);
-        return new IntervalsSet(line.toSubSpace((Point<Euclidean2D>) start).getX(),
-                                line.toSubSpace((Point<Euclidean2D>) end).getX(),
+        return new IntervalsSet(line.toSubSpace(start).getX(),
+                                line.toSubSpace(end).getX(),
                                 tolerance);
     }
 
@@ -161,7 +161,7 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {
 
         final Line    thisLine  = (Line) getHyperplane();
         final Line    otherLine = (Line) hyperplane;
-        final Vector2D crossing = thisLine.intersection(otherLine);
+        final Coordinates2D crossing = thisLine.intersection(otherLine);
         final double tolerance  = thisLine.getTolerance();
 
         if (crossing == null) {
@@ -178,7 +178,7 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {
 
         // the lines do intersect
         final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
-        final Vector1D x      = thisLine.toSubSpace((Point<Euclidean2D>) crossing);
+        final Coordinates1D x      = thisLine.toSubSpace((Point<Euclidean2D>) crossing);
         final SubHyperplane<Euclidean1D> subPlus  =
                 new OrientedPoint(x, !direct, tolerance).wholeHyperplane();
         final SubHyperplane<Euclidean1D> subMinus =
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DFormat.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DFormat.java
index af5431317..04e825bfc 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DFormat.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DFormat.java
@@ -108,31 +108,31 @@ public class Vector2DFormat extends VectorFormat<Euclidean2D> {
     @Override
     public StringBuffer format(final Vector<Euclidean2D> vector, final StringBuffer toAppendTo,
                                final FieldPosition pos) {
-        final Vector2D p2 = (Vector2D) vector;
+        final Coordinates2D p2 = (Coordinates2D) vector;
         return format(toAppendTo, pos, p2.getX(), p2.getY());
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D parse(final String source) throws MathParseException {
+    public Coordinates2D parse(final String source) throws MathParseException {
         ParsePosition parsePosition = new ParsePosition(0);
-        Vector2D result = parse(source, parsePosition);
+        Coordinates2D result = parse(source, parsePosition);
         if (parsePosition.getIndex() == 0) {
             throw new MathParseException(source,
                                          parsePosition.getErrorIndex(),
-                                         Vector2D.class);
+                                         Coordinates2D.class);
         }
         return result;
     }
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D parse(final String source, final ParsePosition pos) {
+    public Coordinates2D parse(final String source, final ParsePosition pos) {
         final double[] coordinates = parseCoordinates(2, source, pos);
         if (coordinates == null) {
             return null;
         }
-        return new Vector2D(coordinates[0], coordinates[1]);
+        return new Coordinates2D(coordinates[0], coordinates[1]);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AbstractConvexHullGenerator2D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AbstractConvexHullGenerator2D.java
index 9293b4e1d..38b5b4ae2 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AbstractConvexHullGenerator2D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AbstractConvexHullGenerator2D.java
@@ -21,7 +21,7 @@ import java.util.Collection;
 import org.apache.commons.math4.exception.ConvergenceException;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
@@ -86,12 +86,12 @@ abstract class AbstractConvexHullGenerator2D implements ConvexHullGenerator2D {
 
     /** {@inheritDoc} */
     @Override
-    public ConvexHull2D generate(final Collection<Vector2D> points)
+    public ConvexHull2D generate(final Collection<Coordinates2D> points)
             throws NullArgumentException, ConvergenceException {
         // check for null points
         MathUtils.checkNotNull(points);
 
-        Collection<Vector2D> hullVertices = null;
+        Collection<Coordinates2D> hullVertices = null;
         if (points.size() < 2) {
             hullVertices = points;
         } else {
@@ -99,7 +99,7 @@ abstract class AbstractConvexHullGenerator2D implements ConvexHullGenerator2D {
         }
 
         try {
-            return new ConvexHull2D(hullVertices.toArray(new Vector2D[hullVertices.size()]),
+            return new ConvexHull2D(hullVertices.toArray(new Coordinates2D[hullVertices.size()]),
                                     tolerance);
         } catch (MathIllegalArgumentException e) {
             // the hull vertices may not form a convex hull if the tolerance value is to large
@@ -112,6 +112,6 @@ abstract class AbstractConvexHullGenerator2D implements ConvexHullGenerator2D {
      * @param points the set of input points
      * @return the convex hull vertices in CCW winding
      */
-    protected abstract Collection<Vector2D> findHullVertices(Collection<Vector2D> points);
+    protected abstract Collection<Coordinates2D> findHullVertices(Collection<Coordinates2D> points);
 
 }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AklToussaintHeuristic.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AklToussaintHeuristic.java
index 84be4ac39..49c399f33 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AklToussaintHeuristic.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AklToussaintHeuristic.java
@@ -20,7 +20,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 
 /**
  * A simple heuristic to improve the performance of convex hull algorithms.
@@ -50,15 +50,15 @@ public final class AklToussaintHeuristic {
      * @param points the original point set
      * @return a reduced point set, useful as input for convex hull algorithms
      */
-    public static Collection<Vector2D> reducePoints(final Collection<Vector2D> points) {
+    public static Collection<Coordinates2D> reducePoints(final Collection<Coordinates2D> points) {
 
         // find the leftmost point
         int size = 0;
-        Vector2D minX = null;
-        Vector2D maxX = null;
-        Vector2D minY = null;
-        Vector2D maxY = null;
-        for (Vector2D p : points) {
+        Coordinates2D minX = null;
+        Coordinates2D maxX = null;
+        Coordinates2D minY = null;
+        Coordinates2D maxY = null;
+        for (Coordinates2D p : points) {
             if (minX == null || p.getX() < minX.getX()) {
                 minX = p;
             }
@@ -78,14 +78,14 @@ public final class AklToussaintHeuristic {
             return points;
         }
 
-        final List<Vector2D> quadrilateral = buildQuadrilateral(minY, maxX, maxY, minX);
+        final List<Coordinates2D> quadrilateral = buildQuadrilateral(minY, maxX, maxY, minX);
         // if the quadrilateral is not well formed, e.g. only 2 points, do not attempt to reduce
         if (quadrilateral.size() < 3) {
             return points;
         }
 
-        final List<Vector2D> reducedPoints = new ArrayList<>(quadrilateral);
-        for (final Vector2D p : points) {
+        final List<Coordinates2D> reducedPoints = new ArrayList<>(quadrilateral);
+        for (final Coordinates2D p : points) {
             // check all points if they are within the quadrilateral
             // in which case they can not be part of the convex hull
             if (!insideQuadrilateral(p, quadrilateral)) {
@@ -102,9 +102,9 @@ public final class AklToussaintHeuristic {
      * @param points the respective points with min/max x/y coordinate
      * @return the quadrilateral
      */
-    private static List<Vector2D> buildQuadrilateral(final Vector2D... points) {
-        List<Vector2D> quadrilateral = new ArrayList<>();
-        for (Vector2D p : points) {
+    private static List<Coordinates2D> buildQuadrilateral(final Coordinates2D... points) {
+        List<Coordinates2D> quadrilateral = new ArrayList<>();
+        for (Coordinates2D p : points) {
             if (!quadrilateral.contains(p)) {
                 quadrilateral.add(p);
             }
@@ -118,11 +118,11 @@ public final class AklToussaintHeuristic {
      * @param quadrilateralPoints the convex quadrilateral, represented by 4 points
      * @return {@code true} if the point is inside the quadrilateral, {@code false} otherwise
      */
-    private static boolean insideQuadrilateral(final Vector2D point,
-                                               final List<Vector2D> quadrilateralPoints) {
+    private static boolean insideQuadrilateral(final Coordinates2D point,
+                                               final List<Coordinates2D> quadrilateralPoints) {
 
-        Vector2D p1 = quadrilateralPoints.get(0);
-        Vector2D p2 = quadrilateralPoints.get(1);
+        Coordinates2D p1 = quadrilateralPoints.get(0);
+        Coordinates2D p2 = quadrilateralPoints.get(1);
 
         if (point.equals(p1) || point.equals(p2)) {
             return true;
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHull2D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHull2D.java
index 7356da12f..801f4d7a3 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHull2D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHull2D.java
@@ -24,7 +24,7 @@ import org.apache.commons.math4.exception.util.LocalizedFormats;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.Line;
 import org.apache.commons.math4.geometry.euclidean.twod.Segment;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.hull.ConvexHull;
 import org.apache.commons.math4.geometry.partitioning.Region;
 import org.apache.commons.math4.geometry.partitioning.RegionFactory;
@@ -36,13 +36,13 @@ import org.apache.commons.math4.util.Precision;
  *
  * @since 3.3
  */
-public class ConvexHull2D implements ConvexHull<Euclidean2D, Vector2D>, Serializable {
+public class ConvexHull2D implements ConvexHull<Euclidean2D, Coordinates2D>, Serializable {
 
     /** Serializable UID. */
     private static final long serialVersionUID = 20140129L;
 
     /** Vertices of the hull. */
-    private final Vector2D[] vertices;
+    private final Coordinates2D[] vertices;
 
     /** Tolerance threshold used during creation of the hull vertices. */
     private final double tolerance;
@@ -59,7 +59,7 @@ public class ConvexHull2D implements ConvexHull<Euclidean2D, Vector2D>, Serializ
      * @param tolerance tolerance below which points are considered identical
      * @throws MathIllegalArgumentException if the vertices do not form a convex hull
      */
-    public ConvexHull2D(final Vector2D[] vertices, final double tolerance)
+    public ConvexHull2D(final Coordinates2D[] vertices, final double tolerance)
         throws MathIllegalArgumentException {
 
         // assign tolerance as it will be used by the isConvex method
@@ -77,19 +77,19 @@ public class ConvexHull2D implements ConvexHull<Euclidean2D, Vector2D>, Serializ
      * @param hullVertices the hull vertices
      * @return {@code true} if the vertices form a convex hull, {@code false} otherwise
      */
-    private boolean isConvex(final Vector2D[] hullVertices) {
+    private boolean isConvex(final Coordinates2D[] hullVertices) {
         if (hullVertices.length < 3) {
             return true;
         }
 
         int sign = 0;
         for (int i = 0; i < hullVertices.length; i++) {
-            final Vector2D p1 = hullVertices[i == 0 ? hullVertices.length - 1 : i - 1];
-            final Vector2D p2 = hullVertices[i];
-            final Vector2D p3 = hullVertices[i == hullVertices.length - 1 ? 0 : i + 1];
+            final Coordinates2D p1 = hullVertices[i == 0 ? hullVertices.length - 1 : i - 1];
+            final Coordinates2D p2 = hullVertices[i];
+            final Coordinates2D p3 = hullVertices[i == hullVertices.length - 1 ? 0 : i + 1];
 
-            final Vector2D d1 = p2.subtract(p1);
-            final Vector2D d2 = p3.subtract(p2);
+            final Coordinates2D d1 = p2.subtract(p1);
+            final Coordinates2D d2 = p3.subtract(p2);
 
             final double crossProduct = MathArrays.linearCombination(d1.getX(), d2.getY(), -d1.getY(), d2.getX());
             final int cmp = Precision.compareTo(crossProduct, 0.0, tolerance);
@@ -107,7 +107,7 @@ public class ConvexHull2D implements ConvexHull<Euclidean2D, Vector2D>, Serializ
 
     /** {@inheritDoc} */
     @Override
-    public Vector2D[] getVertices() {
+    public Coordinates2D[] getVertices() {
         return vertices.clone();
     }
 
@@ -132,15 +132,15 @@ public class ConvexHull2D implements ConvexHull<Euclidean2D, Vector2D>, Serializ
                 this.lineSegments = new Segment[0];
             } else if (size == 2) {
                 this.lineSegments = new Segment[1];
-                final Vector2D p1 = vertices[0];
-                final Vector2D p2 = vertices[1];
+                final Coordinates2D p1 = vertices[0];
+                final Coordinates2D p2 = vertices[1];
                 this.lineSegments[0] = new Segment(p1, p2, new Line(p1, p2, tolerance));
             } else {
                 this.lineSegments = new Segment[size];
-                Vector2D firstPoint = null;
-                Vector2D lastPoint = null;
+                Coordinates2D firstPoint = null;
+                Coordinates2D lastPoint = null;
                 int index = 0;
-                for (Vector2D point : vertices) {
+                for (Coordinates2D point : vertices) {
                     if (lastPoint == null) {
                         firstPoint = point;
                         lastPoint = point;
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHullGenerator2D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHullGenerator2D.java
index 35571470a..310cb0d86 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHullGenerator2D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHullGenerator2D.java
@@ -21,7 +21,7 @@ import java.util.Collection;
 import org.apache.commons.math4.exception.ConvergenceException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.hull.ConvexHullGenerator;
 
 /**
@@ -29,10 +29,10 @@ import org.apache.commons.math4.geometry.hull.ConvexHullGenerator;
  *
  * @since 3.3
  */
-public interface ConvexHullGenerator2D extends ConvexHullGenerator<Euclidean2D, Vector2D> {
+public interface ConvexHullGenerator2D extends ConvexHullGenerator<Euclidean2D, Coordinates2D> {
 
     /** {@inheritDoc} */
     @Override
-    ConvexHull2D generate(Collection<Vector2D> points) throws NullArgumentException, ConvergenceException;
+    ConvexHull2D generate(Collection<Coordinates2D> points) throws NullArgumentException, ConvergenceException;
 
 }
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/MonotoneChain.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/MonotoneChain.java
index 5746c7f17..08d27f803 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/MonotoneChain.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/hull/MonotoneChain.java
@@ -23,7 +23,7 @@ import java.util.Comparator;
 import java.util.List;
 
 import org.apache.commons.math4.geometry.euclidean.twod.Line;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.Precision;
 
@@ -75,15 +75,15 @@ public class MonotoneChain extends AbstractConvexHullGenerator2D {
 
     /** {@inheritDoc} */
     @Override
-    public Collection<Vector2D> findHullVertices(final Collection<Vector2D> points) {
+    public Collection<Coordinates2D> findHullVertices(final Collection<Coordinates2D> points) {
 
-        final List<Vector2D> pointsSortedByXAxis = new ArrayList<>(points);
+        final List<Coordinates2D> pointsSortedByXAxis = new ArrayList<>(points);
 
         // sort the points in increasing order on the x-axis
-        Collections.sort(pointsSortedByXAxis, new Comparator<Vector2D>() {
+        Collections.sort(pointsSortedByXAxis, new Comparator<Coordinates2D>() {
             /** {@inheritDoc} */
             @Override
-            public int compare(final Vector2D o1, final Vector2D o2) {
+            public int compare(final Coordinates2D o1, final Coordinates2D o2) {
                 final double tolerance = getTolerance();
                 // need to take the tolerance value into account, otherwise collinear points
                 // will not be handled correctly when building the upper/lower hull
@@ -97,21 +97,21 @@ public class MonotoneChain extends AbstractConvexHullGenerator2D {
         });
 
         // build lower hull
-        final List<Vector2D> lowerHull = new ArrayList<>();
-        for (Vector2D p : pointsSortedByXAxis) {
+        final List<Coordinates2D> lowerHull = new ArrayList<>();
+        for (Coordinates2D p : pointsSortedByXAxis) {
             updateHull(p, lowerHull);
         }
 
         // build upper hull
-        final List<Vector2D> upperHull = new ArrayList<>();
+        final List<Coordinates2D> upperHull = new ArrayList<>();
         for (int idx = pointsSortedByXAxis.size() - 1; idx >= 0; idx--) {
-            final Vector2D p = pointsSortedByXAxis.get(idx);
+            final Coordinates2D p = pointsSortedByXAxis.get(idx);
             updateHull(p, upperHull);
         }
 
         // concatenate the lower and upper hulls
         // the last point of each list is omitted as it is repeated at the beginning of the other list
-        final List<Vector2D> hullVertices = new ArrayList<>(lowerHull.size() + upperHull.size() - 2);
+        final List<Coordinates2D> hullVertices = new ArrayList<>(lowerHull.size() + upperHull.size() - 2);
         for (int idx = 0; idx < lowerHull.size() - 1; idx++) {
             hullVertices.add(lowerHull.get(idx));
         }
@@ -133,12 +133,12 @@ public class MonotoneChain extends AbstractConvexHullGenerator2D {
      * @param point the current point
      * @param hull the partial hull
      */
-    private void updateHull(final Vector2D point, final List<Vector2D> hull) {
+    private void updateHull(final Coordinates2D point, final List<Coordinates2D> hull) {
         final double tolerance = getTolerance();
 
         if (hull.size() == 1) {
             // ensure that we do not add an identical point
-            final Vector2D p1 = hull.get(0);
+            final Coordinates2D p1 = hull.get(0);
             if (p1.distance(point) < tolerance) {
                 return;
             }
@@ -146,8 +146,8 @@ public class MonotoneChain extends AbstractConvexHullGenerator2D {
 
         while (hull.size() >= 2) {
             final int size = hull.size();
-            final Vector2D p1 = hull.get(size - 2);
-            final Vector2D p2 = hull.get(size - 1);
+            final Coordinates2D p1 = hull.get(size - 2);
+            final Coordinates2D p2 = hull.get(size - 1);
 
             final double offset = new Line(p1, p2, tolerance).getOffset(point);
             if (FastMath.abs(offset) < tolerance) {
diff --git a/src/main/java/org/apache/commons/math4/geometry/partitioning/AbstractRegion.java b/src/main/java/org/apache/commons/math4/geometry/partitioning/AbstractRegion.java
index 9463bb832..a52c38f08 100644
--- a/src/main/java/org/apache/commons/math4/geometry/partitioning/AbstractRegion.java
+++ b/src/main/java/org/apache/commons/math4/geometry/partitioning/AbstractRegion.java
@@ -321,9 +321,9 @@ public abstract class AbstractRegion<S extends Space, T extends Space> implement
      * Region.Location#INSIDE}, {@link Region.Location#OUTSIDE} or
      * {@link Region.Location#BOUNDARY}
      */
-    public Location checkPoint(final Vector<S> point) {
-        return checkPoint((Point<S>) point);
-    }
+//    public Location checkPoint(final Vector<S> point) {
+//        return checkPoint((Point<S>) point);
+//    }
 
     /** {@inheritDoc} */
     @Override
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/oned/S1Point.java b/src/main/java/org/apache/commons/math4/geometry/spherical/oned/S1Point.java
index 2395fd29b..841d1dbd6 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/oned/S1Point.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/oned/S1Point.java
@@ -18,7 +18,7 @@ package org.apache.commons.math4.geometry.spherical.oned;
 
 import org.apache.commons.math4.geometry.Point;
 import org.apache.commons.math4.geometry.Space;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.MathUtils;
 
@@ -30,7 +30,7 @@ public class S1Point implements Point<Sphere1D> {
 
    // CHECKSTYLE: stop ConstantName
     /** A vector with all coordinates set to NaN. */
-    public static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);
+    public static final S1Point NaN = new S1Point(Double.NaN, Coordinates2D.NaN);
     // CHECKSTYLE: resume ConstantName
 
     /** Serializable UID. */
@@ -40,7 +40,7 @@ public class S1Point implements Point<Sphere1D> {
     private final double alpha;
 
     /** Corresponding 2D normalized vector. */
-    private final Vector2D vector;
+    private final Coordinates2D vector;
 
     /** Simple constructor.
      * Build a vector from its coordinates
@@ -49,14 +49,14 @@ public class S1Point implements Point<Sphere1D> {
      */
     public S1Point(final double alpha) {
         this(MathUtils.normalizeAngle(alpha, FastMath.PI),
-             new Vector2D(FastMath.cos(alpha), FastMath.sin(alpha)));
+             new Coordinates2D(FastMath.cos(alpha), FastMath.sin(alpha)));
     }
 
     /** Build a point from its internal components.
      * @param alpha azimuthal angle \( \alpha \)
      * @param vector corresponding vector
      */
-    private S1Point(final double alpha, final Vector2D vector) {
+    private S1Point(final double alpha, final Coordinates2D vector) {
         this.alpha  = alpha;
         this.vector = vector;
     }
@@ -72,7 +72,7 @@ public class S1Point implements Point<Sphere1D> {
     /** Get the corresponding normalized vector in the 2D euclidean space.
      * @return normalized vector
      */
-    public Vector2D getVector() {
+    public Coordinates2D getVector() {
         return vector;
     }
 
@@ -100,7 +100,7 @@ public class S1Point implements Point<Sphere1D> {
      * @return the angular separation between p1 and p2
      */
     public static double distance(S1Point p1, S1Point p2) {
-        return Vector2D.angle(p1.vector, p2.vector);
+        return Coordinates2D.angle(p1.vector, p2.vector);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Circle.java b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Circle.java
index 62eba4339..871f729f1 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Circle.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Circle.java
@@ -18,7 +18,7 @@ package org.apache.commons.math4.geometry.spherical.twod;
 
 import org.apache.commons.math4.geometry.Point;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.partitioning.Embedding;
 import org.apache.commons.math4.geometry.partitioning.Hyperplane;
 import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
@@ -45,13 +45,13 @@ import org.apache.commons.math4.util.FastMath;
 public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1D> {
 
     /** Pole or circle center. */
-    private Vector3D pole;
+    private Coordinates3D pole;
 
     /** First axis in the equator plane, origin of the phase angles. */
-    private Vector3D x;
+    private Coordinates3D x;
 
     /** Second axis in the equator plane, in quadrature with respect to x. */
-    private Vector3D y;
+    private Coordinates3D y;
 
     /** Tolerance below which close sub-arcs are merged together. */
     private final double tolerance;
@@ -61,7 +61,7 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
      * @param pole circle pole
      * @param tolerance tolerance below which close sub-arcs are merged together
      */
-    public Circle(final Vector3D pole, final double tolerance) {
+    public Circle(final Coordinates3D pole, final double tolerance) {
         reset(pole);
         this.tolerance = tolerance;
     }
@@ -84,7 +84,7 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
      * @param y second axis in the equator plane
      * @param tolerance tolerance below which close sub-arcs are merged together
      */
-    private Circle(final Vector3D pole, final Vector3D x, final Vector3D y,
+    private Circle(final Coordinates3D pole, final Coordinates3D x, final Coordinates3D y,
                    final double tolerance) {
         this.pole      = pole;
         this.x         = x;
@@ -111,10 +111,10 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
      * <p>The circle is oriented in the trigonometric direction around pole.</p>
      * @param newPole circle pole
      */
-    public void reset(final Vector3D newPole) {
+    public void reset(final Coordinates3D newPole) {
         this.pole = newPole.normalize();
         this.x    = newPole.orthogonal();
-        this.y    = Vector3D.crossProduct(newPole, x).normalize();
+        this.y    = Coordinates3D.crossProduct(newPole, x).normalize();
     }
 
     /** Revert the instance.
@@ -164,7 +164,7 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
      * @return phase angle of the direction around the circle
      * @see #toSubSpace(Point)
      */
-    public double getPhase(final Vector3D direction) {
+    public double getPhase(final Coordinates3D direction) {
         return FastMath.PI + FastMath.atan2(-direction.dotProduct(y), -direction.dotProduct(x));
     }
 
@@ -183,8 +183,8 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
      * @see #getXAxis()
      * @see #getYAxis()
      */
-    public Vector3D getPointAt(final double alpha) {
-        return new Vector3D(FastMath.cos(alpha), x, FastMath.sin(alpha), y);
+    public Coordinates3D getPointAt(final double alpha) {
+        return new Coordinates3D(FastMath.cos(alpha), x, FastMath.sin(alpha), y);
     }
 
     /** Get the X axis of the circle.
@@ -198,7 +198,7 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
      * @see #getYAxis()
      * @see #getPole()
      */
-    public Vector3D getXAxis() {
+    public Coordinates3D getXAxis() {
         return x;
     }
 
@@ -213,7 +213,7 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
      * @see #getXAxis()
      * @see #getPole()
      */
-    public Vector3D getYAxis() {
+    public Coordinates3D getYAxis() {
         return y;
     }
 
@@ -226,7 +226,7 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
      * @see #getXAxis()
      * @see #getYAxis()
      */
-    public Vector3D getPole() {
+    public Coordinates3D getPole() {
         return pole;
     }
 
@@ -272,15 +272,15 @@ public class Circle implements Hyperplane<Sphere2D>, Embedding<Sphere2D, Sphere1
      * @return offset of the direction
      * @see #getOffset(Point)
      */
-    public double getOffset(final Vector3D direction) {
-        return Vector3D.angle(pole, direction) - 0.5 * FastMath.PI;
+    public double getOffset(final Coordinates3D direction) {
+        return Coordinates3D.angle(pole, direction) - 0.5 * FastMath.PI;
     }
 
     /** {@inheritDoc} */
     @Override
     public boolean sameOrientationAs(final Hyperplane<Sphere2D> other) {
         final Circle otherC = (Circle) other;
-        return Vector3D.dotProduct(pole, otherC.pole) >= 0.0;
+        return Coordinates3D.dotProduct(pole, otherC.pole) >= 0.0;
     }
 
     /** Get a {@link org.apache.commons.math4.geometry.partitioning.Transform
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Edge.java b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Edge.java
index 8c13baa5c..6fe2635f7 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Edge.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/Edge.java
@@ -18,7 +18,7 @@ package org.apache.commons.math4.geometry.spherical.twod;
 
 import java.util.List;
 
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.spherical.oned.Arc;
 import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.MathUtils;
@@ -99,7 +99,7 @@ public class Edge {
      * @param alpha angle along the edge, counted from {@link #getStart()}
      * @return an intermediate point
      */
-    public Vector3D getPointAt(final double alpha) {
+    public Coordinates3D getPointAt(final double alpha) {
         return circle.getPointAt(alpha + circle.getPhase(start.getLocation().getVector()));
     }
 
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/EdgesBuilder.java b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/EdgesBuilder.java
index 86f12c617..5e3f91870 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/EdgesBuilder.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/EdgesBuilder.java
@@ -23,7 +23,7 @@ import java.util.Map;
 
 import org.apache.commons.math4.exception.MathIllegalStateException;
 import org.apache.commons.math4.exception.util.LocalizedFormats;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
 import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
 import org.apache.commons.math4.geometry.partitioning.BoundaryAttribute;
@@ -128,8 +128,8 @@ class EdgesBuilder implements BSPTreeVisitor<Sphere2D> {
         for (final BSPTree<Sphere2D> node : candidates) {
             for (final Edge edge : nodeToEdgesList.get(node)) {
                 if (edge != previous && edge.getStart().getIncoming() == null) {
-                    final Vector3D edgeStart = edge.getStart().getLocation().getVector();
-                    final double gap         = Vector3D.angle(point.getVector(), edgeStart);
+                    final Coordinates3D edgeStart = edge.getStart().getLocation().getVector();
+                    final double gap         = Coordinates3D.angle(point.getVector(), edgeStart);
                     if (gap <= closest) {
                         closest   = gap;
                         following = edge;
@@ -139,8 +139,8 @@ class EdgesBuilder implements BSPTreeVisitor<Sphere2D> {
         }
 
         if (following == null) {
-            final Vector3D previousStart = previous.getStart().getLocation().getVector();
-            if (Vector3D.angle(point.getVector(), previousStart) <= tolerance) {
+            final Coordinates3D previousStart = previous.getStart().getLocation().getVector();
+            if (Coordinates3D.angle(point.getVector(), previousStart) <= tolerance) {
                 // the edge connects back to itself
                 return previous;
             }
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/PropertiesComputer.java b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/PropertiesComputer.java
index b7bcbf03b..4d61de1ed 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/PropertiesComputer.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/PropertiesComputer.java
@@ -20,7 +20,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.math4.exception.MathInternalError;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
 import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
 import org.apache.commons.math4.util.FastMath;
@@ -38,10 +38,10 @@ class PropertiesComputer implements BSPTreeVisitor<Sphere2D> {
     private double summedArea;
 
     /** Summed barycenter. */
-    private Vector3D summedBarycenter;
+    private Coordinates3D summedBarycenter;
 
     /** List of points strictly inside convex cells. */
-    private final List<Vector3D> convexCellsInsidePoints;
+    private final List<Coordinates3D> convexCellsInsidePoints;
 
     /** Simple constructor.
      * @param tolerance below which points are consider to be identical
@@ -49,7 +49,7 @@ class PropertiesComputer implements BSPTreeVisitor<Sphere2D> {
     PropertiesComputer(final double tolerance) {
         this.tolerance              = tolerance;
         this.summedArea             = 0;
-        this.summedBarycenter       = Vector3D.ZERO;
+        this.summedBarycenter       = Coordinates3D.ZERO;
         this.convexCellsInsidePoints = new ArrayList<>();
     }
 
@@ -86,12 +86,12 @@ class PropertiesComputer implements BSPTreeVisitor<Sphere2D> {
 
             // compute the geometrical properties of the convex cell
             final double area  = convexCellArea(boundary.get(0));
-            final Vector3D barycenter = convexCellBarycenter(boundary.get(0));
+            final Coordinates3D barycenter = convexCellBarycenter(boundary.get(0));
             convexCellsInsidePoints.add(barycenter);
 
             // add the cell contribution to the global properties
             summedArea      += area;
-            summedBarycenter = new Vector3D(1, summedBarycenter, area, barycenter);
+            summedBarycenter = new Coordinates3D(1, summedBarycenter, area, barycenter);
 
         }
     }
@@ -109,11 +109,11 @@ class PropertiesComputer implements BSPTreeVisitor<Sphere2D> {
         for (Edge e = start.getOutgoing(); n == 0 || e.getStart() != start; e = e.getEnd().getOutgoing()) {
 
             // find path interior angle at vertex
-            final Vector3D previousPole = e.getCircle().getPole();
-            final Vector3D nextPole     = e.getEnd().getOutgoing().getCircle().getPole();
-            final Vector3D point        = e.getEnd().getLocation().getVector();
-            double alpha = FastMath.atan2(Vector3D.dotProduct(nextPole, Vector3D.crossProduct(point, previousPole)),
-                                          -Vector3D.dotProduct(nextPole, previousPole));
+            final Coordinates3D previousPole = e.getCircle().getPole();
+            final Coordinates3D nextPole     = e.getEnd().getOutgoing().getCircle().getPole();
+            final Coordinates3D point        = e.getEnd().getLocation().getVector();
+            double alpha = FastMath.atan2(Coordinates3D.dotProduct(nextPole, Coordinates3D.crossProduct(point, previousPole)),
+                                          -Coordinates3D.dotProduct(nextPole, previousPole));
             if (alpha < 0) {
                 alpha += MathUtils.TWO_PI;
             }
@@ -133,14 +133,14 @@ class PropertiesComputer implements BSPTreeVisitor<Sphere2D> {
      * @param start start vertex of the convex cell boundary
      * @return barycenter
      */
-    private Vector3D convexCellBarycenter(final Vertex start) {
+    private Coordinates3D convexCellBarycenter(final Vertex start) {
 
         int n = 0;
-        Vector3D sumB = Vector3D.ZERO;
+        Coordinates3D sumB = Coordinates3D.ZERO;
 
         // loop around the cell
         for (Edge e = start.getOutgoing(); n == 0 || e.getStart() != start; e = e.getEnd().getOutgoing()) {
-            sumB = new Vector3D(1, sumB, e.getLength(), e.getCircle().getPole());
+            sumB = new Coordinates3D(1, sumB, e.getLength(), e.getCircle().getPole());
             n++;
         }
 
@@ -169,7 +169,7 @@ class PropertiesComputer implements BSPTreeVisitor<Sphere2D> {
     /** Get the points strictly inside convex cells.
      * @return points strictly inside convex cells
      */
-    public List<Vector3D> getConvexCellsInsidePoints() {
+    public List<Coordinates3D> getConvexCellsInsidePoints() {
         return convexCellsInsidePoints;
     }
 
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/S2Point.java b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/S2Point.java
index 94fc0c55c..58aea4757 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/S2Point.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/S2Point.java
@@ -20,7 +20,7 @@ import org.apache.commons.math4.exception.MathArithmeticException;
 import org.apache.commons.math4.exception.OutOfRangeException;
 import org.apache.commons.math4.geometry.Point;
 import org.apache.commons.math4.geometry.Space;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.MathUtils;
 
@@ -38,26 +38,26 @@ import org.apache.commons.math4.util.MathUtils;
 public class S2Point implements Point<Sphere2D> {
 
     /** +I (coordinates: \( \theta = 0, \varphi = \pi/2 \)). */
-    public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);
+    public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Coordinates3D.PLUS_I);
 
     /** +J (coordinates: \( \theta = \pi/2, \varphi = \pi/2 \))). */
-    public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);
+    public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Coordinates3D.PLUS_J);
 
     /** +K (coordinates: \( \theta = any angle, \varphi = 0 \)). */
-    public static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);
+    public static final S2Point PLUS_K = new S2Point(0, 0, Coordinates3D.PLUS_K);
 
     /** -I (coordinates: \( \theta = \pi, \varphi = \pi/2 \)). */
-    public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);
+    public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Coordinates3D.MINUS_I);
 
     /** -J (coordinates: \( \theta = 3\pi/2, \varphi = \pi/2 \)). */
-    public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);
+    public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Coordinates3D.MINUS_J);
 
     /** -K (coordinates: \( \theta = any angle, \varphi = \pi \)). */
-    public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);
+    public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Coordinates3D.MINUS_K);
 
     // CHECKSTYLE: stop ConstantName
     /** A vector with all coordinates set to NaN. */
-    public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);
+    public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Coordinates3D.NaN);
     // CHECKSTYLE: resume ConstantName
 
     /** Serializable UID. */
@@ -70,7 +70,7 @@ public class S2Point implements Point<Sphere2D> {
     private final double phi;
 
     /** Corresponding 3D normalized vector. */
-    private final Vector3D vector;
+    private final Coordinates3D vector;
 
     /** Simple constructor.
      * Build a vector from its spherical coordinates
@@ -90,8 +90,8 @@ public class S2Point implements Point<Sphere2D> {
      * @param vector 3D vector
      * @exception MathArithmeticException if vector norm is zero
      */
-    public S2Point(final Vector3D vector) throws MathArithmeticException {
-        this(FastMath.atan2(vector.getY(), vector.getX()), Vector3D.angle(Vector3D.PLUS_K, vector),
+    public S2Point(final Coordinates3D vector) throws MathArithmeticException {
+        this(FastMath.atan2(vector.getY(), vector.getX()), Coordinates3D.angle(Coordinates3D.PLUS_K, vector),
              vector.normalize());
     }
 
@@ -100,7 +100,7 @@ public class S2Point implements Point<Sphere2D> {
      * @param phi polar angle \( \varphi \)
      * @param vector corresponding vector
      */
-    private S2Point(final double theta, final double phi, final Vector3D vector) {
+    private S2Point(final double theta, final double phi, final Coordinates3D vector) {
         this.theta  = theta;
         this.phi    = phi;
         this.vector = vector;
@@ -112,7 +112,7 @@ public class S2Point implements Point<Sphere2D> {
      * @return normalized vector
      * @exception OutOfRangeException if \( \varphi \) is not in the [\( 0; \pi \)] range
      */
-    private static Vector3D vector(final double theta, final double phi)
+    private static Coordinates3D vector(final double theta, final double phi)
        throws OutOfRangeException {
 
         if (phi < 0 || phi > FastMath.PI) {
@@ -124,7 +124,7 @@ public class S2Point implements Point<Sphere2D> {
         final double cosPhi   = FastMath.cos(phi);
         final double sinPhi   = FastMath.sin(phi);
 
-        return new Vector3D(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
+        return new Coordinates3D(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
 
     }
 
@@ -147,7 +147,7 @@ public class S2Point implements Point<Sphere2D> {
     /** Get the corresponding normalized vector in the 3D euclidean space.
      * @return normalized vector
      */
-    public Vector3D getVector() {
+    public Coordinates3D getVector() {
         return vector;
     }
 
@@ -182,7 +182,7 @@ public class S2Point implements Point<Sphere2D> {
      * @return the angular separation between p1 and p2
      */
     public static double distance(S2Point p1, S2Point p2) {
-        return Vector3D.angle(p1.vector, p2.vector);
+        return Coordinates3D.angle(p1.vector, p2.vector);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSet.java b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSet.java
index 6d4d980a5..cbdf2d604 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSet.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSet.java
@@ -29,7 +29,7 @@ import org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
 import org.apache.commons.math4.geometry.euclidean.threed.RotationConvention;
 import org.apache.commons.math4.geometry.euclidean.threed.SphereGenerator;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.partitioning.AbstractRegion;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
 import org.apache.commons.math4.geometry.partitioning.BoundaryProjection;
@@ -58,7 +58,7 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
      * @param pole pole of the hemisphere (the pole is in the inside half)
      * @param tolerance below which points are consider to be identical
      */
-    public SphericalPolygonsSet(final Vector3D pole, final double tolerance) {
+    public SphericalPolygonsSet(final Coordinates3D pole, final double tolerance) {
         super(new BSPTree<>(new Circle(pole, tolerance).wholeHyperplane(),
                                     new BSPTree<Sphere2D>(Boolean.FALSE),
                                     new BSPTree<Sphere2D>(Boolean.TRUE),
@@ -73,7 +73,7 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
      * @param n number of sides of the polygon
      * @param tolerance below which points are consider to be identical
      */
-    public SphericalPolygonsSet(final Vector3D center, final Vector3D meridian,
+    public SphericalPolygonsSet(final Coordinates3D center, final Coordinates3D meridian,
                                 final double outsideRadius, final int n,
                                 final double tolerance) {
         this(tolerance, createRegularPolygonVertices(center, meridian, outsideRadius, n));
@@ -159,10 +159,10 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
      * @param n number of sides of the polygon
      * @return vertices array
      */
-    private static S2Point[] createRegularPolygonVertices(final Vector3D center, final Vector3D meridian,
+    private static S2Point[] createRegularPolygonVertices(final Coordinates3D center, final Coordinates3D meridian,
                                                           final double outsideRadius, final int n) {
         final S2Point[] array = new S2Point[n];
-        final Rotation r0 = new Rotation(Vector3D.crossProduct(center, meridian),
+        final Rotation r0 = new Rotation(Coordinates3D.crossProduct(center, meridian),
                                          outsideRadius, RotationConvention.VECTOR_OPERATOR);
         array[0] = new S2Point(r0.applyTo(center));
 
@@ -226,7 +226,7 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
 
             // create the edge and store it
             edges.add(new Edge(start, end,
-                               Vector3D.angle(start.getLocation().getVector(),
+                               Coordinates3D.angle(start.getLocation().getVector(),
                                               end.getLocation().getVector()),
                                circle));
 
@@ -490,7 +490,7 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
         }
 
         // gather some inside points, to be used by the encloser
-        final List<Vector3D> points = getInsidePoints();
+        final List<Coordinates3D> points = getInsidePoints();
 
         // extract points from the boundary loops, to be used by the encloser as well
         final List<Vertex> boundary = getBoundaryLoops();
@@ -504,10 +504,10 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
 
         // find the smallest enclosing 3D sphere
         final SphereGenerator generator = new SphereGenerator();
-        final WelzlEncloser<Euclidean3D, Vector3D> encloser =
+        final WelzlEncloser<Euclidean3D, Coordinates3D> encloser =
                 new WelzlEncloser<>(getTolerance(), generator);
-        EnclosingBall<Euclidean3D, Vector3D> enclosing3D = encloser.enclose(points);
-        final Vector3D[] support3D = enclosing3D.getSupport();
+        EnclosingBall<Euclidean3D, Coordinates3D> enclosing3D = encloser.enclose(points);
+        final Coordinates3D[] support3D = enclosing3D.getSupport();
 
         // convert to 3D sphere to spherical cap
         final double r = enclosing3D.getRadius();
@@ -517,7 +517,7 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
             // fall back to a crude approximation, based only on outside convex cells
             EnclosingBall<Sphere2D, S2Point> enclosingS2 =
                     new EnclosingBall<>(S2Point.PLUS_K, Double.POSITIVE_INFINITY);
-            for (Vector3D outsidePoint : getOutsidePoints()) {
+            for (Coordinates3D outsidePoint : getOutsidePoints()) {
                 final S2Point outsideS2 = new S2Point(outsidePoint);
                 final BoundaryProjection<Sphere2D> projection = projectToBoundary(outsideS2);
                 if (FastMath.PI - projection.getOffset() < enclosingS2.getRadius()) {
@@ -545,7 +545,7 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
     /** Gather some inside points.
      * @return list of points known to be strictly in all inside convex cells
      */
-    private List<Vector3D> getInsidePoints() {
+    private List<Coordinates3D> getInsidePoints() {
         final PropertiesComputer pc = new PropertiesComputer(getTolerance());
         getTree(true).visit(pc);
         return pc.getConvexCellsInsidePoints();
@@ -554,7 +554,7 @@ public class SphericalPolygonsSet extends AbstractRegion<Sphere2D, Sphere1D> {
     /** Gather some outside points.
      * @return list of points known to be strictly in all outside convex cells
      */
-    private List<Vector3D> getOutsidePoints() {
+    private List<Coordinates3D> getOutsidePoints() {
         final SphericalPolygonsSet complement =
                 (SphericalPolygonsSet) new RegionFactory<Sphere2D>().getComplement(this);
         final PropertiesComputer pc = new PropertiesComputer(getTolerance());
diff --git a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SubCircle.java b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SubCircle.java
index ba74b52b4..1e09a2dd4 100644
--- a/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SubCircle.java
+++ b/src/main/java/org/apache/commons/math4/geometry/spherical/twod/SubCircle.java
@@ -16,7 +16,7 @@
  */
 package org.apache.commons.math4.geometry.spherical.twod;
 
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane;
 import org.apache.commons.math4.geometry.partitioning.Hyperplane;
 import org.apache.commons.math4.geometry.partitioning.Region;
@@ -52,7 +52,7 @@ public class SubCircle extends AbstractSubHyperplane<Sphere2D, Sphere1D> {
 
         final Circle thisCircle   = (Circle) getHyperplane();
         final Circle otherCircle  = (Circle) hyperplane;
-        final double angle = Vector3D.angle(thisCircle.getPole(), otherCircle.getPole());
+        final double angle = Coordinates3D.angle(thisCircle.getPole(), otherCircle.getPole());
 
         if (angle < thisCircle.getTolerance() || angle > FastMath.PI - thisCircle.getTolerance()) {
             // the two circles are aligned or opposite
diff --git a/src/test/java/org/apache/commons/math4/complex/QuaternionTest.java b/src/test/java/org/apache/commons/math4/complex/QuaternionTest.java
index 8dcf56bed..16159ec99 100644
--- a/src/test/java/org/apache/commons/math4/complex/QuaternionTest.java
+++ b/src/test/java/org/apache/commons/math4/complex/QuaternionTest.java
@@ -23,7 +23,7 @@ import org.apache.commons.math4.exception.DimensionMismatchException;
 import org.apache.commons.math4.exception.ZeroException;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
 import org.apache.commons.math4.geometry.euclidean.threed.RotationConvention;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.util.FastMath;
 import org.junit.Test;
 import org.junit.Assert;
@@ -121,16 +121,16 @@ public class QuaternionTest {
         // qResult = (scalarA * scalarB - vectorA . vectorB) + (scalarA * vectorB + scalarB * vectorA + vectorA ^
         // vectorB)
 
-        final Vector3D vectorA = new Vector3D(qA.getVectorPart());
-        final Vector3D vectorB = new Vector3D(qB.getVectorPart());
-        final Vector3D vectorResult = new Vector3D(qResult.getVectorPart());
+        final Coordinates3D vectorA = new Coordinates3D(qA.getVectorPart());
+        final Coordinates3D vectorB = new Coordinates3D(qB.getVectorPart());
+        final Coordinates3D vectorResult = new Coordinates3D(qResult.getVectorPart());
 
-        final double scalarPartRef = qA.getScalarPart() * qB.getScalarPart() - Vector3D.dotProduct(vectorA, vectorB);
+        final double scalarPartRef = qA.getScalarPart() * qB.getScalarPart() - Coordinates3D.dotProduct(vectorA, vectorB);
 
         Assert.assertEquals(scalarPartRef, qResult.getScalarPart(), EPS);
 
-        final Vector3D vectorPartRef = ((vectorA.scalarMultiply(qB.getScalarPart())).add(vectorB.scalarMultiply(qA
-                .getScalarPart()))).add(Vector3D.crossProduct(vectorA, vectorB));
+        final Coordinates3D vectorPartRef = ((vectorA.scalarMultiply(qB.getScalarPart())).add(vectorB.scalarMultiply(qA
+                .getScalarPart()))).add(Coordinates3D.crossProduct(vectorA, vectorB));
         final double norm = (vectorResult.subtract(vectorPartRef)).getNorm();
 
         Assert.assertEquals(0, norm, EPS);
@@ -167,12 +167,12 @@ public class QuaternionTest {
         final double[] vectorQ = quaternion.getVectorPart();
         final double[] vectorResultQxV = qResultQxV.getVectorPart();
 
-        final double scalarPartRefQxV = -Vector3D.dotProduct(new Vector3D(vectorQ), new Vector3D(vector));
+        final double scalarPartRefQxV = -Coordinates3D.dotProduct(new Coordinates3D(vectorQ), new Coordinates3D(vector));
         Assert.assertEquals(scalarPartRefQxV, qResultQxV.getScalarPart(), EPS);
 
-        final Vector3D vectorPartRefQxV = (new Vector3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Vector3D
-                .crossProduct(new Vector3D(vectorQ), new Vector3D(vector)));
-        final double normQxV = (new Vector3D(vectorResultQxV).subtract(vectorPartRefQxV)).getNorm();
+        final Coordinates3D vectorPartRefQxV = (new Coordinates3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Coordinates3D
+                .crossProduct(new Coordinates3D(vectorQ), new Coordinates3D(vector)));
+        final double normQxV = (new Coordinates3D(vectorResultQxV).subtract(vectorPartRefQxV)).getNorm();
         Assert.assertEquals(0, normQxV, EPS);
 
         // Case : Product between a vector and a quaternion : VxQ
@@ -189,12 +189,12 @@ public class QuaternionTest {
         // comparison with the result given by the formula :
         // qResult = (- vector . vectorQ) + (scalarQ * vector + vector ^ vectorQ)
 
-        final double scalarPartRefVxQ = -Vector3D.dotProduct(new Vector3D(vectorQ), new Vector3D(vector));
+        final double scalarPartRefVxQ = -Coordinates3D.dotProduct(new Coordinates3D(vectorQ), new Coordinates3D(vector));
         Assert.assertEquals(scalarPartRefVxQ, qResultVxQ.getScalarPart(), EPS);
 
-        final Vector3D vectorPartRefVxQ = (new Vector3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Vector3D
-                .crossProduct(new Vector3D(vector), new Vector3D(vectorQ)));
-        final double normVxQ = (new Vector3D(vectorResultVxQ).subtract(vectorPartRefVxQ)).getNorm();
+        final Coordinates3D vectorPartRefVxQ = (new Coordinates3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Coordinates3D
+                .crossProduct(new Coordinates3D(vector), new Coordinates3D(vectorQ)));
+        final double normVxQ = (new Coordinates3D(vectorResultVxQ).subtract(vectorPartRefVxQ)).getNorm();
         Assert.assertEquals(0, normVxQ, EPS);
     }
 
diff --git a/src/test/java/org/apache/commons/math4/fitting/leastsquares/AbstractLeastSquaresOptimizerAbstractTest.java b/src/test/java/org/apache/commons/math4/fitting/leastsquares/AbstractLeastSquaresOptimizerAbstractTest.java
index a7d7374b3..648fee312 100644
--- a/src/test/java/org/apache/commons/math4/fitting/leastsquares/AbstractLeastSquaresOptimizerAbstractTest.java
+++ b/src/test/java/org/apache/commons/math4/fitting/leastsquares/AbstractLeastSquaresOptimizerAbstractTest.java
@@ -26,7 +26,7 @@ import org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem;
 import org.apache.commons.math4.fitting.leastsquares.MultivariateJacobianFunction;
 import org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum;
 import org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.linear.Array2DRowRealMatrix;
 import org.apache.commons.math4.linear.ArrayRealVector;
 import org.apache.commons.math4.linear.BlockRealMatrix;
@@ -412,7 +412,7 @@ public abstract class AbstractLeastSquaresOptimizerAbstractTest {
         double rms = optimum.getRMS();
         Assert.assertEquals(1.768262623567235, FastMath.sqrt(circle.getN()) * rms, TOl);
 
-        Vector2D center = new Vector2D(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));
+        Coordinates2D center = new Coordinates2D(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));
         Assert.assertEquals(69.96016176931406, circle.getRadius(center), 1e-6);
         Assert.assertEquals(96.07590211815305, center.getX(), 1e-6);
         Assert.assertEquals(48.13516790438953, center.getY(), 1e-6);
@@ -455,7 +455,7 @@ public abstract class AbstractLeastSquaresOptimizerAbstractTest {
 
         Optimum optimum = optimizer.optimize(builder(circle).weight(new DiagonalMatrix(weights)).start(start).build());
 
-        Vector2D center = new Vector2D(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));
+        Coordinates2D center = new Coordinates2D(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));
         Assert.assertTrue(optimum.getEvaluations() < 25);
         Assert.assertEquals(0.043, optimum.getRMS(), 1e-3);
         Assert.assertEquals(0.292235, circle.getRadius(center), 1e-6);
diff --git a/src/test/java/org/apache/commons/math4/fitting/leastsquares/CircleVectorial.java b/src/test/java/org/apache/commons/math4/fitting/leastsquares/CircleVectorial.java
index 69d0b01fc..414ee2c03 100644
--- a/src/test/java/org/apache/commons/math4/fitting/leastsquares/CircleVectorial.java
+++ b/src/test/java/org/apache/commons/math4/fitting/leastsquares/CircleVectorial.java
@@ -20,29 +20,29 @@ import java.util.ArrayList;
 
 import org.apache.commons.math4.analysis.MultivariateMatrixFunction;
 import org.apache.commons.math4.analysis.MultivariateVectorFunction;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 
 /**
  * Class used in the tests.
  */
 class CircleVectorial {
-    private ArrayList<Vector2D> points;
+    private ArrayList<Coordinates2D> points;
 
     public CircleVectorial() {
         points  = new ArrayList<>();
     }
 
     public void addPoint(double px, double py) {
-        points.add(new Vector2D(px, py));
+        points.add(new Coordinates2D(px, py));
     }
 
     public int getN() {
         return points.size();
     }
 
-    public double getRadius(Vector2D center) {
+    public double getRadius(Coordinates2D center) {
         double r = 0;
-        for (Vector2D point : points) {
+        for (Coordinates2D point : points) {
             r += point.distance(center);
         }
         return r / points.size();
@@ -52,7 +52,7 @@ class CircleVectorial {
         return new MultivariateVectorFunction() {
             @Override
             public double[] value(double[] params) {
-                Vector2D center = new Vector2D(params[0], params[1]);
+                Coordinates2D center = new Coordinates2D(params[0], params[1]);
                 double radius = getRadius(center);
                 double[] residuals = new double[points.size()];
                 for (int i = 0; i < residuals.length; i++) {
@@ -69,11 +69,11 @@ class CircleVectorial {
             @Override
             public double[][] value(double[] params) {
                 final int n = points.size();
-                final Vector2D center = new Vector2D(params[0], params[1]);
+                final Coordinates2D center = new Coordinates2D(params[0], params[1]);
 
                 double dRdX = 0;
                 double dRdY = 0;
-                for (Vector2D pk : points) {
+                for (Coordinates2D pk : points) {
                     double dk = pk.distance(center);
                     dRdX += (center.getX() - pk.getX()) / dk;
                     dRdY += (center.getY() - pk.getY()) / dk;
@@ -84,7 +84,7 @@ class CircleVectorial {
                 // Jacobian of the radius residuals.
                 double[][] jacobian = new double[n][2];
                 for (int i = 0; i < n; i++) {
-                    final Vector2D pi = points.get(i);
+                    final Coordinates2D pi = points.get(i);
                     final double di = pi.distance(center);
                     jacobian[i][0] = (center.getX() - pi.getX()) / di - dRdX;
                     jacobian[i][1] = (center.getY() - pi.getY()) / di - dRdY;
diff --git a/src/test/java/org/apache/commons/math4/fitting/leastsquares/GaussNewtonOptimizerWithSVDTest.java b/src/test/java/org/apache/commons/math4/fitting/leastsquares/GaussNewtonOptimizerWithSVDTest.java
index 3ad564e2a..5f121e0d7 100644
--- a/src/test/java/org/apache/commons/math4/fitting/leastsquares/GaussNewtonOptimizerWithSVDTest.java
+++ b/src/test/java/org/apache/commons/math4/fitting/leastsquares/GaussNewtonOptimizerWithSVDTest.java
@@ -25,7 +25,7 @@ import org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem;
 import org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.Decomposition;
 import org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum;
 import org.apache.commons.math4.geometry.euclidean.threed.Plane;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.optim.SimpleVectorValueChecker;
 import org.apache.commons.math4.util.FastMath;
 import org.junit.Assert;
@@ -140,8 +140,8 @@ public class GaussNewtonOptimizerWithSVDTest
 
         Optimum optimum = optimizer.optimize(problem.getBuilder().build());
 
-        Plane span = new Plane(Vector3D.ZERO, new Vector3D(1, 2, -3), new Vector3D(2, 1, 0), TOl);
-        double expected = FastMath.abs(span.getOffset(new Vector3D(1, 1, 1)));
+        Plane span = new Plane(Coordinates3D.ZERO, new Coordinates3D(1, 2, -3), new Coordinates3D(2, 1, 0), TOl);
+        double expected = FastMath.abs(span.getOffset(new Coordinates3D(1, 1, 1)));
         double actual = optimum.getResiduals().getNorm();
 
         //verify
diff --git a/src/test/java/org/apache/commons/math4/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java b/src/test/java/org/apache/commons/math4/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java
index 29466b6af..56980a625 100644
--- a/src/test/java/org/apache/commons/math4/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math4/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java
@@ -28,7 +28,7 @@ import org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer
 import org.apache.commons.math4.fitting.leastsquares.ParameterValidator;
 import org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum;
 import org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.linear.DiagonalMatrix;
 import org.apache.commons.math4.linear.RealMatrix;
 import org.apache.commons.math4.linear.RealVector;
@@ -270,7 +270,7 @@ public class LevenbergMarquardtOptimizerTest
         final CircleProblem circle = new CircleProblem(xSigma, ySigma);
 
         final int numPoints = 10;
-        for (Vector2D p : factory.generate(numPoints)) {
+        for (Coordinates2D p : factory.generate(numPoints)) {
             circle.addPoint(p.getX(), p.getY());
         }
 
@@ -307,7 +307,7 @@ public class LevenbergMarquardtOptimizerTest
         final CircleProblem circle = new CircleProblem(xSigma, ySigma);
 
         final int numPoints = 10;
-        for (Vector2D p : factory.generate(numPoints)) {
+        for (Coordinates2D p : factory.generate(numPoints)) {
             circle.addPoint(p.getX(), p.getY());
         }
 
diff --git a/src/test/java/org/apache/commons/math4/fitting/leastsquares/RandomCirclePointGenerator.java b/src/test/java/org/apache/commons/math4/fitting/leastsquares/RandomCirclePointGenerator.java
index 5cb66015c..a849c03cb 100644
--- a/src/test/java/org/apache/commons/math4/fitting/leastsquares/RandomCirclePointGenerator.java
+++ b/src/test/java/org/apache/commons/math4/fitting/leastsquares/RandomCirclePointGenerator.java
@@ -19,7 +19,7 @@ package org.apache.commons.math4.fitting.leastsquares;
 import org.apache.commons.math4.distribution.NormalDistribution;
 import org.apache.commons.math4.distribution.RealDistribution;
 import org.apache.commons.math4.distribution.UniformRealDistribution;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.rng.simple.RandomSource;
 import org.apache.commons.math4.util.FastMath;
@@ -65,8 +65,8 @@ public class RandomCirclePointGenerator {
      * @param n Number of points to create.
      * @return the cloud of {@code n} points.
      */
-    public Vector2D[] generate(int n) {
-        final Vector2D[] cloud = new Vector2D[n];
+    public Coordinates2D[] generate(int n) {
+        final Coordinates2D[] cloud = new Coordinates2D[n];
         for (int i = 0; i < n; i++) {
             cloud[i] = create();
         }
@@ -78,11 +78,11 @@ public class RandomCirclePointGenerator {
      *
      * @return a point.
      */
-    private Vector2D create() {
+    private Coordinates2D create() {
         final double t = tP.sample();
         final double pX = cX.sample() + radius * FastMath.cos(t);
         final double pY = cY.sample() + radius * FastMath.sin(t);
 
-        return new Vector2D(pX, pY);
+        return new Coordinates2D(pX, pY);
     }
 }
diff --git a/src/test/java/org/apache/commons/math4/geometry/enclosing/WelzlEncloser2DTest.java b/src/test/java/org/apache/commons/math4/geometry/enclosing/WelzlEncloser2DTest.java
index 51306b349..2e08195d0 100644
--- a/src/test/java/org/apache/commons/math4/geometry/enclosing/WelzlEncloser2DTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/enclosing/WelzlEncloser2DTest.java
@@ -24,7 +24,7 @@ import org.apache.commons.math4.geometry.enclosing.EnclosingBall;
 import org.apache.commons.math4.geometry.enclosing.WelzlEncloser;
 import org.apache.commons.math4.geometry.euclidean.twod.DiskGenerator;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.rng.simple.RandomSource;
 import org.junit.Assert;
@@ -36,36 +36,36 @@ public class WelzlEncloser2DTest {
     @Test
     public void testNullList() {
         DiskGenerator generator = new DiskGenerator();
-        WelzlEncloser<Euclidean2D, Vector2D> encloser =
+        WelzlEncloser<Euclidean2D, Coordinates2D> encloser =
                 new WelzlEncloser<>(1.0e-10, generator);
-        EnclosingBall<Euclidean2D, Vector2D> ball = encloser.enclose(null);
+        EnclosingBall<Euclidean2D, Coordinates2D> ball = encloser.enclose(null);
         Assert.assertTrue(ball.getRadius() < 0);
     }
 
     @Test
     public void testNoPoints() {
         DiskGenerator generator = new DiskGenerator();
-        WelzlEncloser<Euclidean2D, Vector2D> encloser =
+        WelzlEncloser<Euclidean2D, Coordinates2D> encloser =
                 new WelzlEncloser<>(1.0e-10, generator);
-        EnclosingBall<Euclidean2D, Vector2D> ball = encloser.enclose(new ArrayList<Vector2D>());
+        EnclosingBall<Euclidean2D, Coordinates2D> ball = encloser.enclose(new ArrayList<Coordinates2D>());
         Assert.assertTrue(ball.getRadius() < 0);
     }
 
     @Test
     public void testRegularPoints() {
-        List<Vector2D> list = buildList(22, 26, 30, 38, 64, 28,  8, 54, 11, 15);
+        List<Coordinates2D> list = buildList(22, 26, 30, 38, 64, 28,  8, 54, 11, 15);
         checkDisk(list, Arrays.asList(list.get(2), list.get(3), list.get(4)));
     }
 
     @Test
     public void testSolutionOnDiameter() {
-        List<Vector2D> list = buildList(22, 26, 30, 38, 64, 28,  8, 54);
+        List<Coordinates2D> list = buildList(22, 26, 30, 38, 64, 28,  8, 54);
         checkDisk(list, Arrays.asList(list.get(2), list.get(3)));
     }
 
     @Test
     public void testReducingBall1() {
-        List<Vector2D> list = buildList(0.05380958511396061, 0.57332359658700000,
+        List<Coordinates2D> list = buildList(0.05380958511396061, 0.57332359658700000,
                                         0.99348810731127870, 0.02056421361521466,
                                         0.01203950647796437, 0.99779675042261860,
                                         0.00810189987706078, 0.00589246003827815,
@@ -75,7 +75,7 @@ public class WelzlEncloser2DTest {
 
     @Test
     public void testReducingBall2() {
-        List<Vector2D> list = buildList(0.016930586154703, 0.333955448537779,
+        List<Coordinates2D> list = buildList(0.016930586154703, 0.333955448537779,
                                         0.987189104892331, 0.969778855274507,
                                         0.983696889599935, 0.012904580013266,
                                         0.013114499572905, 0.034740156356895);
@@ -87,39 +87,39 @@ public class WelzlEncloser2DTest {
         UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A, 0xa2a63cad12c01fb2l);
         for (int k = 0; k < 100; ++k) {
             int nbPoints = random.nextInt(10000);
-            List<Vector2D> points = new ArrayList<>();
+            List<Coordinates2D> points = new ArrayList<>();
             for (int i = 0; i < nbPoints; ++i) {
                 double x = random.nextDouble();
                 double y = random.nextDouble();
-                points.add(new Vector2D(x, y));
+                points.add(new Coordinates2D(x, y));
             }
             checkDisk(points);
         }
     }
 
-    private List<Vector2D> buildList(final double ... coordinates) {
-        List<Vector2D> list = new ArrayList<>(coordinates.length / 2);
+    private List<Coordinates2D> buildList(final double ... coordinates) {
+        List<Coordinates2D> list = new ArrayList<>(coordinates.length / 2);
         for (int i = 0; i < coordinates.length; i += 2) {
-            list.add(new Vector2D(coordinates[i], coordinates[i + 1]));
+            list.add(new Coordinates2D(coordinates[i], coordinates[i + 1]));
         }
         return list;
     }
 
-    private void checkDisk(List<Vector2D> points, List<Vector2D> refSupport) {
+    private void checkDisk(List<Coordinates2D> points, List<Coordinates2D> refSupport) {
 
-        EnclosingBall<Euclidean2D, Vector2D> disk = checkDisk(points);
+        EnclosingBall<Euclidean2D, Coordinates2D> disk = checkDisk(points);
 
         // compare computed disk with expected disk
         DiskGenerator generator = new DiskGenerator();
-        EnclosingBall<Euclidean2D, Vector2D> expected = generator.ballOnSupport(refSupport);
+        EnclosingBall<Euclidean2D, Coordinates2D> expected = generator.ballOnSupport(refSupport);
         Assert.assertEquals(refSupport.size(), disk.getSupportSize());
         Assert.assertEquals(expected.getRadius(),        disk.getRadius(),        1.0e-10);
         Assert.assertEquals(expected.getCenter().getX(), disk.getCenter().getX(), 1.0e-10);
         Assert.assertEquals(expected.getCenter().getY(), disk.getCenter().getY(), 1.0e-10);
 
-        for (Vector2D s : disk.getSupport()) {
+        for (Coordinates2D s : disk.getSupport()) {
             boolean found = false;
-            for (Vector2D rs : refSupport) {
+            for (Coordinates2D rs : refSupport) {
                 if (s == rs) {
                     found = true;
                 }
@@ -129,14 +129,14 @@ public class WelzlEncloser2DTest {
 
         // check removing any point of the support disk fails to enclose the point
         for (int i = 0; i < disk.getSupportSize(); ++i) {
-            List<Vector2D> reducedSupport = new ArrayList<>();
+            List<Coordinates2D> reducedSupport = new ArrayList<>();
             int count = 0;
-            for (Vector2D s : disk.getSupport()) {
+            for (Coordinates2D s : disk.getSupport()) {
                 if (count++ != i) {
                     reducedSupport.add(s);
                 }
             }
-            EnclosingBall<Euclidean2D, Vector2D> reducedDisk = generator.ballOnSupport(reducedSupport);
+            EnclosingBall<Euclidean2D, Coordinates2D> reducedDisk = generator.ballOnSupport(reducedSupport);
             boolean foundOutside = false;
             for (int j = 0; j < points.size() && !foundOutside; ++j) {
                 if (!reducedDisk.contains(points.get(j), 1.0e-10)) {
@@ -148,20 +148,20 @@ public class WelzlEncloser2DTest {
 
     }
 
-    private EnclosingBall<Euclidean2D, Vector2D> checkDisk(List<Vector2D> points) {
+    private EnclosingBall<Euclidean2D, Coordinates2D> checkDisk(List<Coordinates2D> points) {
 
-        WelzlEncloser<Euclidean2D, Vector2D> encloser =
+        WelzlEncloser<Euclidean2D, Coordinates2D> encloser =
                 new WelzlEncloser<>(1.0e-10, new DiskGenerator());
-        EnclosingBall<Euclidean2D, Vector2D> disk = encloser.enclose(points);
+        EnclosingBall<Euclidean2D, Coordinates2D> disk = encloser.enclose(points);
 
         // all points are enclosed
-        for (Vector2D v : points) {
+        for (Coordinates2D v : points) {
             Assert.assertTrue(disk.contains(v, 1.0e-10));
         }
 
-        for (Vector2D v : points) {
+        for (Coordinates2D v : points) {
             boolean inSupport = false;
-            for (Vector2D s : disk.getSupport()) {
+            for (Coordinates2D s : disk.getSupport()) {
                 if (v == s) {
                     inSupport = true;
                 }
diff --git a/src/test/java/org/apache/commons/math4/geometry/enclosing/WelzlEncloser3DTest.java b/src/test/java/org/apache/commons/math4/geometry/enclosing/WelzlEncloser3DTest.java
index 081865750..c2af26125 100644
--- a/src/test/java/org/apache/commons/math4/geometry/enclosing/WelzlEncloser3DTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/enclosing/WelzlEncloser3DTest.java
@@ -25,7 +25,7 @@ import org.apache.commons.math4.geometry.enclosing.EnclosingBall;
 import org.apache.commons.math4.geometry.enclosing.WelzlEncloser;
 import org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D;
 import org.apache.commons.math4.geometry.euclidean.threed.SphereGenerator;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.random.UnitSphereRandomVectorGenerator;
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.rng.simple.RandomSource;
@@ -38,67 +38,67 @@ public class WelzlEncloser3DTest {
     @Test
     public void testNullList() {
         SphereGenerator generator = new SphereGenerator();
-        WelzlEncloser<Euclidean3D, Vector3D> encloser =
+        WelzlEncloser<Euclidean3D, Coordinates3D> encloser =
                 new WelzlEncloser<>(1.0e-10, generator);
-        EnclosingBall<Euclidean3D, Vector3D> ball = encloser.enclose(null);
+        EnclosingBall<Euclidean3D, Coordinates3D> ball = encloser.enclose(null);
         Assert.assertTrue(ball.getRadius() < 0);
     }
 
     @Test
     public void testNoPoints() {
         SphereGenerator generator = new SphereGenerator();
-        WelzlEncloser<Euclidean3D, Vector3D> encloser =
+        WelzlEncloser<Euclidean3D, Coordinates3D> encloser =
                 new WelzlEncloser<>(1.0e-10, generator);
-        EnclosingBall<Euclidean3D, Vector3D> ball = encloser.enclose(new ArrayList<Vector3D>());
+        EnclosingBall<Euclidean3D, Coordinates3D> ball = encloser.enclose(new ArrayList<Coordinates3D>());
         Assert.assertTrue(ball.getRadius() < 0);
     }
 
     @Test
     public void testReducingBall() {
-        List<Vector3D> list =
-                Arrays.asList(new Vector3D(-7.140397329568118, -16.571661242582177,  11.714458961735405),
-                              new Vector3D(-7.137986707455888, -16.570767323375720,  11.708602108715928),
-                              new Vector3D(-7.139185068549035, -16.570891204702250,  11.715554057357394),
-                              new Vector3D(-7.142682716997507, -16.571609818234290,  11.710787934580328),
-                              new Vector3D(-7.139018392423351, -16.574405614157020,  11.710518716711425),
-                              new Vector3D(-7.140870659936730, -16.567993074240455,  11.710914678204503),
-                              new Vector3D(-7.136350173659562, -16.570498228820930,  11.713965225900928),
-                              new Vector3D(-7.141675762759172, -16.572852471407028,  11.714033471449508),
-                              new Vector3D(-7.140453077221105, -16.570212820780647,  11.708624578004980),
-                              new Vector3D(-7.140322188726825, -16.574152894557717,  11.710305611121410),
-                              new Vector3D(-7.141116131477088, -16.574061164624560,  11.712938509321699));
-        WelzlEncloser<Euclidean3D, Vector3D> encloser =
+        List<Coordinates3D> list =
+                Arrays.asList(new Coordinates3D(-7.140397329568118, -16.571661242582177,  11.714458961735405),
+                              new Coordinates3D(-7.137986707455888, -16.570767323375720,  11.708602108715928),
+                              new Coordinates3D(-7.139185068549035, -16.570891204702250,  11.715554057357394),
+                              new Coordinates3D(-7.142682716997507, -16.571609818234290,  11.710787934580328),
+                              new Coordinates3D(-7.139018392423351, -16.574405614157020,  11.710518716711425),
+                              new Coordinates3D(-7.140870659936730, -16.567993074240455,  11.710914678204503),
+                              new Coordinates3D(-7.136350173659562, -16.570498228820930,  11.713965225900928),
+                              new Coordinates3D(-7.141675762759172, -16.572852471407028,  11.714033471449508),
+                              new Coordinates3D(-7.140453077221105, -16.570212820780647,  11.708624578004980),
+                              new Coordinates3D(-7.140322188726825, -16.574152894557717,  11.710305611121410),
+                              new Coordinates3D(-7.141116131477088, -16.574061164624560,  11.712938509321699));
+        WelzlEncloser<Euclidean3D, Coordinates3D> encloser =
                 new WelzlEncloser<>(1.0e-10, new SphereGenerator());
-        EnclosingBall<Euclidean3D, Vector3D> ball = encloser.enclose(list);
+        EnclosingBall<Euclidean3D, Coordinates3D> ball = encloser.enclose(list);
         Assert.assertTrue(ball.getRadius() > 0);
     }
 
     @Test
     public void testInfiniteLoop() {
         // this test used to generate an infinite loop
-        List<Vector3D> list =
-                Arrays.asList(new Vector3D( -0.89227075512164380,  -2.89317694645713900,  14.84572323743355500),
-                              new Vector3D( -0.92099498940693580,  -2.31086108263908940,  12.92071026467688300),
-                              new Vector3D( -0.85227999411005200,  -3.06314731441320730,  15.40163831651287000),
-                              new Vector3D( -1.77399413020785970,  -3.65630391378114260,  14.13190097751873400),
-                              new Vector3D(  0.33157833272465354,  -2.22813591757792160,  14.21225234159008200),
-                              new Vector3D( -1.53065579165484400,  -1.65692084770139570,  14.61483055714788500),
-                              new Vector3D( -1.08457093941217140,  -1.96100325935602980,  13.09265170575555000),
-                              new Vector3D(  0.30029469589708850,  -3.05470831395667370,  14.56352400426342600),
-                              new Vector3D( -0.95007443938638460,  -1.86810946486118360,  15.14491234340057000),
-                              new Vector3D( -1.89661503804130830,  -2.17004080885185860,  14.81235128513927000),
-                              new Vector3D( -0.72193328761607530,  -1.44513142833618270,  14.52355724218561800),
-                              new Vector3D( -0.26895980939606550,  -3.69512371522084140,  14.72272846327652000),
-                              new Vector3D( -1.53501693431786170,  -3.25055166611021900,  15.15509062584274800),
-                              new Vector3D( -0.71727553535519410,  -3.62284279460799100,  13.26256700929380700),
-                              new Vector3D( -0.30220950676137365,  -3.25410412500779070,  13.13682612771606000),
-                              new Vector3D( -0.04543996608267075,  -1.93081853923797750,  14.79497997883171400),
-                              new Vector3D( -1.53348892951571640,  -3.66688919703524900,  14.73095600812074200),
-                              new Vector3D( -0.98034899533935820,  -3.34004481162763960,  13.03245014017556800));
-
-        WelzlEncloser<Euclidean3D, Vector3D> encloser =
+        List<Coordinates3D> list =
+                Arrays.asList(new Coordinates3D( -0.89227075512164380,  -2.89317694645713900,  14.84572323743355500),
+                              new Coordinates3D( -0.92099498940693580,  -2.31086108263908940,  12.92071026467688300),
+                              new Coordinates3D( -0.85227999411005200,  -3.06314731441320730,  15.40163831651287000),
+                              new Coordinates3D( -1.77399413020785970,  -3.65630391378114260,  14.13190097751873400),
+                              new Coordinates3D(  0.33157833272465354,  -2.22813591757792160,  14.21225234159008200),
+                              new Coordinates3D( -1.53065579165484400,  -1.65692084770139570,  14.61483055714788500),
+                              new Coordinates3D( -1.08457093941217140,  -1.96100325935602980,  13.09265170575555000),
+                              new Coordinates3D(  0.30029469589708850,  -3.05470831395667370,  14.56352400426342600),
+                              new Coordinates3D( -0.95007443938638460,  -1.86810946486118360,  15.14491234340057000),
+                              new Coordinates3D( -1.89661503804130830,  -2.17004080885185860,  14.81235128513927000),
+                              new Coordinates3D( -0.72193328761607530,  -1.44513142833618270,  14.52355724218561800),
+                              new Coordinates3D( -0.26895980939606550,  -3.69512371522084140,  14.72272846327652000),
+                              new Coordinates3D( -1.53501693431786170,  -3.25055166611021900,  15.15509062584274800),
+                              new Coordinates3D( -0.71727553535519410,  -3.62284279460799100,  13.26256700929380700),
+                              new Coordinates3D( -0.30220950676137365,  -3.25410412500779070,  13.13682612771606000),
+                              new Coordinates3D( -0.04543996608267075,  -1.93081853923797750,  14.79497997883171400),
+                              new Coordinates3D( -1.53348892951571640,  -3.66688919703524900,  14.73095600812074200),
+                              new Coordinates3D( -0.98034899533935820,  -3.34004481162763960,  13.03245014017556800));
+
+        WelzlEncloser<Euclidean3D, Coordinates3D> encloser =
                 new WelzlEncloser<>(1.0e-10, new SphereGenerator());
-        EnclosingBall<Euclidean3D, Vector3D> ball = encloser.enclose(list);
+        EnclosingBall<Euclidean3D, Coordinates3D> ball = encloser.enclose(list);
         Assert.assertTrue(ball.getRadius() > 0);
     }
 
@@ -112,13 +112,13 @@ public class WelzlEncloser3DTest {
             // define the reference sphere we want to compute
             double d = 25 * random.nextDouble();
             double refRadius = 10 * random.nextDouble();
-            Vector3D refCenter = new Vector3D(d, new Vector3D(sr.nextVector()));
+            Coordinates3D refCenter = new Coordinates3D(d, new Coordinates3D(sr.nextVector()));
             // set up a large sample inside the reference sphere
             int nbPoints = random.nextInt(1000);
-            List<Vector3D> points = new ArrayList<>();
+            List<Coordinates3D> points = new ArrayList<>();
             for (int i = 0; i < nbPoints; ++i) {
                 double r = refRadius * random.nextDouble();
-                points.add(new Vector3D(1.0, refCenter, r, new Vector3D(sr.nextVector())));
+                points.add(new Coordinates3D(1.0, refCenter, r, new Coordinates3D(sr.nextVector())));
             }
 
             // test we find a sphere at most as large as the one used for random drawings
@@ -127,23 +127,23 @@ public class WelzlEncloser3DTest {
         }
     }
 
-    private void checkSphere(List<Vector3D> points, double refRadius) {
+    private void checkSphere(List<Coordinates3D> points, double refRadius) {
 
-        EnclosingBall<Euclidean3D, Vector3D> sphere = checkSphere(points);
+        EnclosingBall<Euclidean3D, Coordinates3D> sphere = checkSphere(points);
 
         // compare computed sphere with bounding sphere
         Assert.assertTrue(sphere.getRadius() <= refRadius);
 
         // check removing any point of the support Sphere fails to enclose the point
         for (int i = 0; i < sphere.getSupportSize(); ++i) {
-            List<Vector3D> reducedSupport = new ArrayList<>();
+            List<Coordinates3D> reducedSupport = new ArrayList<>();
             int count = 0;
-            for (Vector3D s : sphere.getSupport()) {
+            for (Coordinates3D s : sphere.getSupport()) {
                 if (count++ != i) {
                     reducedSupport.add(s);
                 }
             }
-            EnclosingBall<Euclidean3D, Vector3D> reducedSphere =
+            EnclosingBall<Euclidean3D, Coordinates3D> reducedSphere =
                     new SphereGenerator().ballOnSupport(reducedSupport);
             boolean foundOutside = false;
             for (int j = 0; j < points.size() && !foundOutside; ++j) {
@@ -156,20 +156,20 @@ public class WelzlEncloser3DTest {
 
     }
 
-    private EnclosingBall<Euclidean3D, Vector3D> checkSphere(List<Vector3D> points) {
+    private EnclosingBall<Euclidean3D, Coordinates3D> checkSphere(List<Coordinates3D> points) {
 
-        WelzlEncloser<Euclidean3D, Vector3D> encloser =
+        WelzlEncloser<Euclidean3D, Coordinates3D> encloser =
                 new WelzlEncloser<>(1.0e-10, new SphereGenerator());
-        EnclosingBall<Euclidean3D, Vector3D> Sphere = encloser.enclose(points);
+        EnclosingBall<Euclidean3D, Coordinates3D> Sphere = encloser.enclose(points);
 
         // all points are enclosed
-        for (Vector3D v : points) {
+        for (Coordinates3D v : points) {
             Assert.assertTrue(Sphere.contains(v, 1.0e-10));
         }
 
-        for (Vector3D v : points) {
+        for (Coordinates3D v : points) {
             boolean inSupport = false;
-            for (Vector3D s : Sphere.getSupport()) {
+            for (Coordinates3D s : Sphere.getSupport()) {
                 if (v == s) {
                     inSupport = true;
                 }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/IntervalsSetTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/IntervalsSetTest.java
index b7c839913..50b406b22 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/IntervalsSetTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/IntervalsSetTest.java
@@ -21,7 +21,7 @@ import java.util.List;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
 import org.apache.commons.math4.geometry.euclidean.oned.Interval;
 import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.partitioning.Region;
 import org.apache.commons.math4.geometry.partitioning.RegionFactory;
 import org.apache.commons.math4.util.FastMath;
@@ -35,12 +35,12 @@ public class IntervalsSetTest {
     public void testInterval() {
         IntervalsSet set = new IntervalsSet(2.3, 5.7, 1.0e-10);
         Assert.assertEquals(3.4, set.getSize(), 1.0e-10);
-        Assert.assertEquals(4.0, ((Vector1D) set.getBarycenter()).getX(), 1.0e-10);
-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(2.3)));
-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(5.7)));
-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(1.2)));
-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(8.7)));
-        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(3.0)));
+        Assert.assertEquals(4.0, ((Coordinates1D) set.getBarycenter()).getX(), 1.0e-10);
+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Coordinates1D(2.3)));
+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Coordinates1D(5.7)));
+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Coordinates1D(1.2)));
+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Coordinates1D(8.7)));
+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Coordinates1D(3.0)));
         Assert.assertEquals(2.3, set.getInf(), 1.0e-10);
         Assert.assertEquals(5.7, set.getSup(), 1.0e-10);
     }
@@ -48,11 +48,11 @@ public class IntervalsSetTest {
     @Test
     public void testInfinite() {
         IntervalsSet set = new IntervalsSet(9.0, Double.POSITIVE_INFINITY, 1.0e-10);
-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(9.0)));
-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(8.4)));
+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Coordinates1D(9.0)));
+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Coordinates1D(8.4)));
         for (double e = 1.0; e <= 6.0; e += 1.0) {
             Assert.assertEquals(Region.Location.INSIDE,
-                                set.checkPoint(new Vector1D(FastMath.pow(10.0, e))));
+                                set.checkPoint(new Coordinates1D(FastMath.pow(10.0, e))));
         }
         Assert.assertTrue(Double.isInfinite(set.getSize()));
         Assert.assertEquals(9.0, set.getInf(), 1.0e-10);
@@ -73,16 +73,16 @@ public class IntervalsSetTest {
                                                               new IntervalsSet(9.0, Double.POSITIVE_INFINITY, 1.0e-10)),
                                                               new IntervalsSet(Double.NEGATIVE_INFINITY, 11.0, 1.0e-10));
         Assert.assertEquals(5.0, set.getSize(), 1.0e-10);
-        Assert.assertEquals(5.9, ((Vector1D) set.getBarycenter()).getX(), 1.0e-10);
-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(0.0)));
-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(4.0)));
-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(8.0)));
-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(12.0)));
-        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(1.2)));
-        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(5.9)));
-        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(9.01)));
-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(5.0)));
-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(11.0)));
+        Assert.assertEquals(5.9, ((Coordinates1D) set.getBarycenter()).getX(), 1.0e-10);
+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Coordinates1D(0.0)));
+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Coordinates1D(4.0)));
+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Coordinates1D(8.0)));
+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Coordinates1D(12.0)));
+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Coordinates1D(1.2)));
+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Coordinates1D(5.9)));
+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Coordinates1D(9.01)));
+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Coordinates1D(5.0)));
+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Coordinates1D(11.0)));
         Assert.assertEquals( 1.0, set.getInf(), 1.0e-10);
         Assert.assertEquals(11.0, set.getSup(), 1.0e-10);
 
@@ -101,7 +101,7 @@ public class IntervalsSetTest {
     public void testSinglePoint() {
         IntervalsSet set = new IntervalsSet(1.0, 1.0, 1.0e-10);
         Assert.assertEquals(0.0, set.getSize(), Precision.SAFE_MIN);
-        Assert.assertEquals(1.0, ((Vector1D) set.getBarycenter()).getX(), Precision.EPSILON);
+        Assert.assertEquals(1.0, ((Coordinates1D) set.getBarycenter()).getX(), Precision.EPSILON);
     }
 
 }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DFormatAbstractTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DFormatAbstractTest.java
index 699ff1343..2e26cef79 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DFormatAbstractTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DFormatAbstractTest.java
@@ -22,7 +22,7 @@ import java.text.ParsePosition;
 import java.util.Locale;
 
 import org.apache.commons.math4.exception.MathParseException;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat;
 import org.junit.Assert;
 import org.junit.Test;
@@ -45,7 +45,7 @@ public abstract class Vector1DFormatAbstractTest {
 
     @Test
     public void testSimpleNoDecimals() {
-        Vector1D c = new Vector1D(1);
+        Coordinates1D c = new Coordinates1D(1);
         String expected = "{1}";
         String actual = vector1DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -53,7 +53,7 @@ public abstract class Vector1DFormatAbstractTest {
 
     @Test
     public void testSimpleWithDecimals() {
-        Vector1D c = new Vector1D(1.23);
+        Coordinates1D c = new Coordinates1D(1.23);
         String expected =
             "{1"    + getDecimalCharacter() +
             "23}";
@@ -63,7 +63,7 @@ public abstract class Vector1DFormatAbstractTest {
 
     @Test
     public void testSimpleWithDecimalsTrunc() {
-        Vector1D c = new Vector1D(1.232323232323);
+        Coordinates1D c = new Coordinates1D(1.232323232323);
         String expected =
             "{1"    + getDecimalCharacter() +
             "2323232323}";
@@ -73,7 +73,7 @@ public abstract class Vector1DFormatAbstractTest {
 
     @Test
     public void testNegativeX() {
-        Vector1D c = new Vector1D(-1.232323232323);
+        Coordinates1D c = new Coordinates1D(-1.232323232323);
         String expected =
             "{-1"    + getDecimalCharacter() +
             "2323232323}";
@@ -83,7 +83,7 @@ public abstract class Vector1DFormatAbstractTest {
 
     @Test
     public void testNonDefaultSetting() {
-        Vector1D c = new Vector1D(1);
+        Coordinates1D c = new Coordinates1D(1);
         String expected = "[1]";
         String actual = vector1DFormatSquare.format(c);
         Assert.assertEquals(expected, actual);
@@ -94,7 +94,7 @@ public abstract class Vector1DFormatAbstractTest {
         Locale defaultLocal = Locale.getDefault();
         Locale.setDefault(getLocale());
 
-        Vector1D c = new Vector1D(232.22222222222);
+        Coordinates1D c = new Coordinates1D(232.22222222222);
         String expected =
             "{232"    + getDecimalCharacter() +
             "2222222222}";
@@ -106,7 +106,7 @@ public abstract class Vector1DFormatAbstractTest {
 
     @Test
     public void testNan() {
-        Vector1D c = Vector1D.NaN;
+        Coordinates1D c = Coordinates1D.NaN;
         String expected = "{(NaN)}";
         String actual = vector1DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -114,7 +114,7 @@ public abstract class Vector1DFormatAbstractTest {
 
     @Test
     public void testPositiveInfinity() {
-        Vector1D c = Vector1D.POSITIVE_INFINITY;
+        Coordinates1D c = Coordinates1D.POSITIVE_INFINITY;
         String expected = "{(Infinity)}";
         String actual = vector1DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -122,7 +122,7 @@ public abstract class Vector1DFormatAbstractTest {
 
     @Test
     public void tesNegativeInfinity() {
-        Vector1D c = Vector1D.NEGATIVE_INFINITY;
+        Coordinates1D c = Coordinates1D.NEGATIVE_INFINITY;
         String expected = "{(-Infinity)}";
         String actual = vector1DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -131,14 +131,14 @@ public abstract class Vector1DFormatAbstractTest {
     @Test
     public void testParseSimpleNoDecimals() throws MathParseException {
         String source = "{1}";
-        Vector1D expected = new Vector1D(1);
-        Vector1D actual = vector1DFormat.parse(source);
+        Coordinates1D expected = new Coordinates1D(1);
+        Coordinates1D actual = vector1DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
     @Test
     public void testParseIgnoredWhitespace() {
-        Vector1D expected = new Vector1D(1);
+        Coordinates1D expected = new Coordinates1D(1);
         ParsePosition pos1 = new ParsePosition(0);
         String source1 = "{1}";
         Assert.assertEquals(expected, vector1DFormat.parse(source1, pos1));
@@ -154,8 +154,8 @@ public abstract class Vector1DFormatAbstractTest {
         String source =
             "{1" + getDecimalCharacter() +
             "23}";
-        Vector1D expected = new Vector1D(1.23);
-        Vector1D actual = vector1DFormat.parse(source);
+        Coordinates1D expected = new Coordinates1D(1.23);
+        Coordinates1D actual = vector1DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -164,8 +164,8 @@ public abstract class Vector1DFormatAbstractTest {
         String source =
             "{1" + getDecimalCharacter() +
             "2323}";
-        Vector1D expected = new Vector1D(1.2323);
-        Vector1D actual = vector1DFormat.parse(source);
+        Coordinates1D expected = new Coordinates1D(1.2323);
+        Coordinates1D actual = vector1DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -174,8 +174,8 @@ public abstract class Vector1DFormatAbstractTest {
         String source =
             "{-1" + getDecimalCharacter() +
             "2323}";
-        Vector1D expected = new Vector1D(-1.2323);
-        Vector1D actual = vector1DFormat.parse(source);
+        Coordinates1D expected = new Coordinates1D(-1.2323);
+        Coordinates1D actual = vector1DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -184,8 +184,8 @@ public abstract class Vector1DFormatAbstractTest {
         String source =
             "{1" + getDecimalCharacter() +
             "2323}";
-        Vector1D expected = new Vector1D(1.2323);
-        Vector1D actual = vector1DFormat.parse(source);
+        Coordinates1D expected = new Coordinates1D(1.2323);
+        Coordinates1D actual = vector1DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -194,8 +194,8 @@ public abstract class Vector1DFormatAbstractTest {
         String source =
             "{1" + getDecimalCharacter() +
             "2323}";
-        Vector1D expected = new Vector1D(1.2323);
-        Vector1D actual = vector1DFormat.parse(source);
+        Coordinates1D expected = new Coordinates1D(1.2323);
+        Coordinates1D actual = vector1DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -204,8 +204,8 @@ public abstract class Vector1DFormatAbstractTest {
         String source =
             "{-1" + getDecimalCharacter() +
             "2323}";
-        Vector1D expected = new Vector1D(-1.2323);
-        Vector1D actual = vector1DFormat.parse(source);
+        Coordinates1D expected = new Coordinates1D(-1.2323);
+        Coordinates1D actual = vector1DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -214,8 +214,8 @@ public abstract class Vector1DFormatAbstractTest {
         String source =
             "{0" + getDecimalCharacter() +
             "0}";
-        Vector1D expected = new Vector1D(0.0);
-        Vector1D actual = vector1DFormat.parse(source);
+        Coordinates1D expected = new Coordinates1D(0.0);
+        Coordinates1D actual = vector1DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -224,30 +224,30 @@ public abstract class Vector1DFormatAbstractTest {
         String source =
             "[1" + getDecimalCharacter() +
             "2323]";
-        Vector1D expected = new Vector1D(1.2323);
-        Vector1D actual = vector1DFormatSquare.parse(source);
+        Coordinates1D expected = new Coordinates1D(1.2323);
+        Coordinates1D actual = vector1DFormatSquare.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
     @Test
     public void testParseNan() throws MathParseException {
         String source = "{(NaN)}";
-        Vector1D actual = vector1DFormat.parse(source);
-        Assert.assertEquals(Vector1D.NaN, actual);
+        Coordinates1D actual = vector1DFormat.parse(source);
+        Assert.assertEquals(Coordinates1D.NaN, actual);
     }
 
     @Test
     public void testParsePositiveInfinity() throws MathParseException {
         String source = "{(Infinity)}";
-        Vector1D actual = vector1DFormat.parse(source);
-        Assert.assertEquals(Vector1D.POSITIVE_INFINITY, actual);
+        Coordinates1D actual = vector1DFormat.parse(source);
+        Assert.assertEquals(Coordinates1D.POSITIVE_INFINITY, actual);
     }
 
     @Test
     public void testParseNegativeInfinity() throws MathParseException {
         String source = "{(-Infinity)}";
-        Vector1D actual = vector1DFormat.parse(source);
-        Assert.assertEquals(Vector1D.NEGATIVE_INFINITY, actual);
+        Coordinates1D actual = vector1DFormat.parse(source);
+        Assert.assertEquals(Coordinates1D.NEGATIVE_INFINITY, actual);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DTest.java
index 0bf6b84ae..832716cef 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/oned/Vector1DTest.java
@@ -25,7 +25,7 @@ import java.util.Locale;
 import org.apache.commons.math4.exception.DimensionMismatchException;
 import org.apache.commons.math4.exception.MathArithmeticException;
 import org.apache.commons.math4.geometry.Space;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.Precision;
 import org.junit.Assert;
@@ -34,143 +34,143 @@ import org.junit.Test;
 public class Vector1DTest {
     @Test
     public void testConstructors() throws DimensionMismatchException {
-        checkVector(new Vector1D(3, new Vector1D(FastMath.PI / 3)),
+        checkVector(new Coordinates1D(3, new Coordinates1D(FastMath.PI / 3)),
                     FastMath.PI);
-        checkVector(new Vector1D(2, Vector1D.ONE, -3, new Vector1D(2)),
+        checkVector(new Coordinates1D(2, Coordinates1D.ONE, -3, new Coordinates1D(2)),
                     -4);
-        checkVector(new Vector1D(2, Vector1D.ONE,
-                                 5, new Vector1D(2),
-                                 -3, new Vector1D(3)),
+        checkVector(new Coordinates1D(2, Coordinates1D.ONE,
+                                 5, new Coordinates1D(2),
+                                 -3, new Coordinates1D(3)),
                     3);
-        checkVector(new Vector1D(2, Vector1D.ONE,
-                                 5, new Vector1D(2),
-                                 5, new Vector1D(-2),
-                                 -3, new Vector1D(-3)),
+        checkVector(new Coordinates1D(2, Coordinates1D.ONE,
+                                 5, new Coordinates1D(2),
+                                 5, new Coordinates1D(-2),
+                                 -3, new Coordinates1D(-3)),
                     11);
     }
 
     @Test
     public void testSpace() {
-        Space space = new Vector1D(1).getSpace();
+        Space space = new Coordinates1D(1).getSpace();
         Assert.assertEquals(1, space.getDimension());
     }
 
     @Test
     public void testZero() {
-        Assert.assertEquals(0, new Vector1D(1).getZero().getNorm(), 1.0e-15);
+        Assert.assertEquals(0, new Coordinates1D(1).getZero().getNorm(), 1.0e-15);
     }
 
     @Test
     public void testEquals() {
-        Vector1D u1 = new Vector1D(1);
-        Vector1D u2 = new Vector1D(1);
+        Coordinates1D u1 = new Coordinates1D(1);
+        Coordinates1D u2 = new Coordinates1D(1);
         Assert.assertTrue(u1.equals(u1));
         Assert.assertTrue(u1.equals(u2));
-        Assert.assertFalse(u1.equals(new Vector1D(1 + 10 * Precision.EPSILON)));
-        Assert.assertTrue(new Vector1D(Double.NaN).equals(new Vector1D(Double.NaN)));
+        Assert.assertFalse(u1.equals(new Coordinates1D(1 + 10 * Precision.EPSILON)));
+        Assert.assertTrue(new Coordinates1D(Double.NaN).equals(new Coordinates1D(Double.NaN)));
     }
 
     @Test
     public void testHash() {
-        Assert.assertEquals(new Vector1D(Double.NaN).hashCode(), new Vector1D(Double.NaN).hashCode());
-        Vector1D u = new Vector1D(1);
-        Vector1D v = new Vector1D(1 + 10 * Precision.EPSILON);
+        Assert.assertEquals(new Coordinates1D(Double.NaN).hashCode(), new Coordinates1D(Double.NaN).hashCode());
+        Coordinates1D u = new Coordinates1D(1);
+        Coordinates1D v = new Coordinates1D(1 + 10 * Precision.EPSILON);
         Assert.assertTrue(u.hashCode() != v.hashCode());
     }
 
     @Test
     public void testInfinite() {
-        Assert.assertTrue(new Vector1D(Double.NEGATIVE_INFINITY).isInfinite());
-        Assert.assertTrue(new Vector1D(Double.POSITIVE_INFINITY).isInfinite());
-        Assert.assertFalse(new Vector1D(1).isInfinite());
-        Assert.assertFalse(new Vector1D(Double.NaN).isInfinite());
+        Assert.assertTrue(new Coordinates1D(Double.NEGATIVE_INFINITY).isInfinite());
+        Assert.assertTrue(new Coordinates1D(Double.POSITIVE_INFINITY).isInfinite());
+        Assert.assertFalse(new Coordinates1D(1).isInfinite());
+        Assert.assertFalse(new Coordinates1D(Double.NaN).isInfinite());
     }
 
     @Test
     public void testNaN() {
-        Assert.assertTrue(new Vector1D(Double.NaN).isNaN());
-        Assert.assertFalse(new Vector1D(1).isNaN());
-        Assert.assertFalse(new Vector1D(Double.NEGATIVE_INFINITY).isNaN());
+        Assert.assertTrue(new Coordinates1D(Double.NaN).isNaN());
+        Assert.assertFalse(new Coordinates1D(1).isNaN());
+        Assert.assertFalse(new Coordinates1D(Double.NEGATIVE_INFINITY).isNaN());
     }
 
     @Test
     public void testToString() {
-        Assert.assertEquals("{3}", new Vector1D(3).toString());
+        Assert.assertEquals("{3}", new Coordinates1D(3).toString());
         NumberFormat format = new DecimalFormat("0.000", new DecimalFormatSymbols(Locale.US));
-        Assert.assertEquals("{3.000}", new Vector1D(3).toString(format));
+        Assert.assertEquals("{3.000}", new Coordinates1D(3).toString(format));
     }
 
     @Test
     public void testCoordinates() {
-        Vector1D v = new Vector1D(1);
+        Coordinates1D v = new Coordinates1D(1);
         Assert.assertTrue(FastMath.abs(v.getX() - 1) < 1.0e-12);
     }
 
     @Test
     public void testNorm1() {
-        Assert.assertEquals(0.0, Vector1D.ZERO.getNorm1(), 0);
-        Assert.assertEquals(6.0, new Vector1D(6).getNorm1(), 0);
+        Assert.assertEquals(0.0, Coordinates1D.ZERO.getNorm1(), 0);
+        Assert.assertEquals(6.0, new Coordinates1D(6).getNorm1(), 0);
     }
 
     @Test
     public void testNorm() {
-        Assert.assertEquals(0.0, Vector1D.ZERO.getNorm(), 0);
-        Assert.assertEquals(3.0, new Vector1D(-3).getNorm(), 1.0e-12);
+        Assert.assertEquals(0.0, Coordinates1D.ZERO.getNorm(), 0);
+        Assert.assertEquals(3.0, new Coordinates1D(-3).getNorm(), 1.0e-12);
     }
 
     @Test
     public void testNormSq() {
-        Assert.assertEquals(0.0, new Vector1D(0).getNormSq(), 0);
-        Assert.assertEquals(9.0, new Vector1D(-3).getNormSq(), 1.0e-12);
+        Assert.assertEquals(0.0, new Coordinates1D(0).getNormSq(), 0);
+        Assert.assertEquals(9.0, new Coordinates1D(-3).getNormSq(), 1.0e-12);
     }
 
     @Test
     public void testNormInf() {
-        Assert.assertEquals(0.0, Vector1D.ZERO.getNormInf(), 0);
-        Assert.assertEquals(3.0, new Vector1D(-3).getNormInf(), 0);
+        Assert.assertEquals(0.0, Coordinates1D.ZERO.getNormInf(), 0);
+        Assert.assertEquals(3.0, new Coordinates1D(-3).getNormInf(), 0);
     }
 
     @Test
     public void testDistance1() {
-        Vector1D v1 = new Vector1D(1);
-        Vector1D v2 = new Vector1D(-4);
-        Assert.assertEquals(0.0, new Vector1D(-1).distance1(new Vector1D(-1)), 0);
+        Coordinates1D v1 = new Coordinates1D(1);
+        Coordinates1D v2 = new Coordinates1D(-4);
+        Assert.assertEquals(0.0, new Coordinates1D(-1).distance1(new Coordinates1D(-1)), 0);
         Assert.assertEquals(5.0, v1.distance1(v2), 1.0e-12);
         Assert.assertEquals(v1.subtract(v2).getNorm1(), v1.distance1(v2), 1.0e-12);
     }
 
     @Test
     public void testDistance() {
-        Vector1D v1 = new Vector1D(1);
-        Vector1D v2 = new Vector1D(-4);
-        Assert.assertEquals(0.0, Vector1D.distance(new Vector1D(-1), new Vector1D(-1)), 0);
-        Assert.assertEquals(5.0, Vector1D.distance(v1, v2), 1.0e-12);
-        Assert.assertEquals(v1.subtract(v2).getNorm(), Vector1D.distance(v1, v2), 1.0e-12);
+        Coordinates1D v1 = new Coordinates1D(1);
+        Coordinates1D v2 = new Coordinates1D(-4);
+        Assert.assertEquals(0.0, Coordinates1D.distance(new Coordinates1D(-1), new Coordinates1D(-1)), 0);
+        Assert.assertEquals(5.0, Coordinates1D.distance(v1, v2), 1.0e-12);
+        Assert.assertEquals(v1.subtract(v2).getNorm(), Coordinates1D.distance(v1, v2), 1.0e-12);
     }
 
     @Test
     public void testDistanceSq() {
-        Vector1D v1 = new Vector1D(1);
-        Vector1D v2 = new Vector1D(-4);
-        Assert.assertEquals(0.0, Vector1D.distanceSq(new Vector1D(-1), new Vector1D(-1)), 0);
-        Assert.assertEquals(25.0, Vector1D.distanceSq(v1, v2), 1.0e-12);
-        Assert.assertEquals(Vector1D.distance(v1, v2) * Vector1D.distance(v1, v2),
-                            Vector1D.distanceSq(v1, v2), 1.0e-12);
+        Coordinates1D v1 = new Coordinates1D(1);
+        Coordinates1D v2 = new Coordinates1D(-4);
+        Assert.assertEquals(0.0, Coordinates1D.distanceSq(new Coordinates1D(-1), new Coordinates1D(-1)), 0);
+        Assert.assertEquals(25.0, Coordinates1D.distanceSq(v1, v2), 1.0e-12);
+        Assert.assertEquals(Coordinates1D.distance(v1, v2) * Coordinates1D.distance(v1, v2),
+                            Coordinates1D.distanceSq(v1, v2), 1.0e-12);
   }
 
     @Test
     public void testDistanceInf() {
-        Vector1D v1 = new Vector1D(1);
-        Vector1D v2 = new Vector1D(-4);
-        Assert.assertEquals(0.0, Vector1D.distanceInf(new Vector1D(-1), new Vector1D(-1)), 0);
-        Assert.assertEquals(5.0, Vector1D.distanceInf(v1, v2), 1.0e-12);
-        Assert.assertEquals(v1.subtract(v2).getNormInf(), Vector1D.distanceInf(v1, v2), 1.0e-12);
+        Coordinates1D v1 = new Coordinates1D(1);
+        Coordinates1D v2 = new Coordinates1D(-4);
+        Assert.assertEquals(0.0, Coordinates1D.distanceInf(new Coordinates1D(-1), new Coordinates1D(-1)), 0);
+        Assert.assertEquals(5.0, Coordinates1D.distanceInf(v1, v2), 1.0e-12);
+        Assert.assertEquals(v1.subtract(v2).getNormInf(), Coordinates1D.distanceInf(v1, v2), 1.0e-12);
     }
 
     @Test
     public void testSubtract() {
-        Vector1D v1 = new Vector1D(1);
-        Vector1D v2 = new Vector1D(-3);
+        Coordinates1D v1 = new Coordinates1D(1);
+        Coordinates1D v2 = new Coordinates1D(-3);
         v1 = v1.subtract(v2);
         checkVector(v1, 4);
 
@@ -180,8 +180,8 @@ public class Vector1DTest {
 
     @Test
     public void testAdd() {
-        Vector1D v1 = new Vector1D(1);
-        Vector1D v2 = new Vector1D(-3);
+        Coordinates1D v1 = new Coordinates1D(1);
+        Coordinates1D v2 = new Coordinates1D(-3);
         v1 = v1.add(v2);
         checkVector(v1, -2);
 
@@ -191,7 +191,7 @@ public class Vector1DTest {
 
     @Test
     public void testScalarProduct() {
-        Vector1D v = new Vector1D(1);
+        Coordinates1D v = new Coordinates1D(1);
         v = v.scalarMultiply(3);
         checkVector(v, 3);
 
@@ -200,9 +200,9 @@ public class Vector1DTest {
 
     @Test
     public void testNormalize() throws MathArithmeticException {
-        Assert.assertEquals(1.0, new Vector1D(5).normalize().getNorm(), 1.0e-12);
+        Assert.assertEquals(1.0, new Coordinates1D(5).normalize().getNorm(), 1.0e-12);
         try {
-            Vector1D.ZERO.normalize();
+            Coordinates1D.ZERO.normalize();
             Assert.fail("an exception should have been thrown");
         } catch (MathArithmeticException ae) {
             // expected behavior
@@ -211,10 +211,10 @@ public class Vector1DTest {
 
     @Test
     public void testNegate() {
-        checkVector(new Vector1D(0.1).negate(), -0.1);
+        checkVector(new Coordinates1D(0.1).negate(), -0.1);
     }
 
-    private void checkVector(Vector1D v, double x) {
+    private void checkVector(Coordinates1D v, double x) {
         Assert.assertEquals(x, v.getX(), 1.0e-12);
     }
 }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotationDSTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotationDSTest.java
index 4c87742e5..65f45a301 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotationDSTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotationDSTest.java
@@ -26,7 +26,7 @@ import org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D;
 import org.apache.commons.math4.geometry.euclidean.threed.NotARotationMatrixException;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
 import org.apache.commons.math4.geometry.euclidean.threed.RotationOrder;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.linear.MatrixUtils;
 import org.apache.commons.math4.linear.RealMatrix;
 import org.apache.commons.math4.random.UnitSphereRandomVectorGenerator;
@@ -975,7 +975,7 @@ public class FieldRotationDSTest {
                         FieldVector3D<DerivativeStructure> uds   = createVector(x, y, z);
                         FieldVector3D<DerivativeStructure> ruds  = r.applyTo(uds);
                         FieldVector3D<DerivativeStructure> rIuds = r.applyInverseTo(uds);
-                        Vector3D   u     = new Vector3D(x, y, z);
+                        Coordinates3D   u     = new Coordinates3D(x, y, z);
                         FieldVector3D<DerivativeStructure> ru    = r.applyTo(u);
                         FieldVector3D<DerivativeStructure> rIu   = r.applyInverseTo(u);
                         DerivativeStructure[] ruArray = new DerivativeStructure[3];
@@ -1000,7 +1000,7 @@ public class FieldRotationDSTest {
         UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random);
         for (int i = 0; i < 10; ++i) {
             double[] unit1 = g.nextVector();
-            Rotation r1 = new Rotation(new Vector3D(unit1[0], unit1[1], unit1[2]),
+            Rotation r1 = new Rotation(new Coordinates3D(unit1[0], unit1[1], unit1[2]),
                                       random.nextDouble(), RotationConvention.VECTOR_OPERATOR);
             FieldRotation<DerivativeStructure> r1Prime = new FieldRotation<>(new DerivativeStructure(4, 1, 0, r1.getQ0()),
                                                 new DerivativeStructure(4, 1, 1, r1.getQ1()),
@@ -1051,7 +1051,7 @@ public class FieldRotationDSTest {
         FieldRotation<DerivativeStructure> r    = new FieldRotation<>(createAxis(kx, ky, kz),
                                                                                          createAngle(theta),
                                                                                          RotationConvention.VECTOR_OPERATOR);
-        Vector3D a      = new Vector3D(kx / n, ky / n, kz / n);
+        Coordinates3D a      = new Coordinates3D(kx / n, ky / n, kz / n);
 
         // Jacobian of the normalized rotation axis a with respect to the Cartesian vector k
         RealMatrix dadk = MatrixUtils.createRealMatrix(new double[][] {
@@ -1063,15 +1063,15 @@ public class FieldRotationDSTest {
         for (double x = -0.9; x < 0.9; x += 0.2) {
             for (double y = -0.9; y < 0.9; y += 0.2) {
                 for (double z = -0.9; z < 0.9; z += 0.2) {
-                    Vector3D   u = new Vector3D(x, y, z);
+                    Coordinates3D   u = new Coordinates3D(x, y, z);
                     FieldVector3D<DerivativeStructure> v = r.applyTo(createVector(x, y, z));
 
                     // explicit formula for rotation of vector u around axis a with angle theta
-                    double dot     = Vector3D.dotProduct(u, a);
-                    Vector3D cross = Vector3D.crossProduct(a, u);
+                    double dot     = Coordinates3D.dotProduct(u, a);
+                    Coordinates3D cross = Coordinates3D.crossProduct(a, u);
                     double c1      = 1 - cosTheta;
                     double c2      = c1 * dot;
-                    Vector3D rt    = new Vector3D(cosTheta, u, c2, a, sinTheta, cross);
+                    Coordinates3D rt    = new Coordinates3D(cosTheta, u, c2, a, sinTheta, cross);
                     Assert.assertEquals(rt.getX(), v.getX().getReal(), eps);
                     Assert.assertEquals(rt.getY(), v.getY().getReal(), eps);
                     Assert.assertEquals(rt.getZ(), v.getZ().getReal(), eps);
@@ -1100,8 +1100,8 @@ public class FieldRotationDSTest {
 
                     // derivative with respect to rotation angle
                     // (analytical differentiation of the explicit formula)
-                    Vector3D dvdTheta =
-                            new Vector3D(-sinTheta, u, sinTheta * dot, a, cosTheta, cross);
+                    Coordinates3D dvdTheta =
+                            new Coordinates3D(-sinTheta, u, sinTheta * dot, a, cosTheta, cross);
                     Assert.assertEquals(dvdTheta.getX(), v.getX().getPartialDerivative(0, 0, 0, 1), eps);
                     Assert.assertEquals(dvdTheta.getY(), v.getY().getPartialDerivative(0, 0, 0, 1), eps);
                     Assert.assertEquals(dvdTheta.getZ(), v.getZ().getPartialDerivative(0, 0, 0, 1), eps);
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotationDfpTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotationDfpTest.java
index 5377bff27..4e250c0ac 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotationDfpTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldRotationDfpTest.java
@@ -27,7 +27,7 @@ import org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D;
 import org.apache.commons.math4.geometry.euclidean.threed.NotARotationMatrixException;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
 import org.apache.commons.math4.geometry.euclidean.threed.RotationOrder;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.random.UnitSphereRandomVectorGenerator;
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.rng.simple.RandomSource;
@@ -816,7 +816,7 @@ public class FieldRotationDfpTest {
                         FieldVector3D<Dfp> uds   = createVector(x, y, z);
                         FieldVector3D<Dfp> ruds  = r.applyTo(uds);
                         FieldVector3D<Dfp> rIuds = r.applyInverseTo(uds);
-                        Vector3D   u     = new Vector3D(x, y, z);
+                        Coordinates3D   u     = new Coordinates3D(x, y, z);
                         FieldVector3D<Dfp> ru    = r.applyTo(u);
                         FieldVector3D<Dfp> rIu   = r.applyInverseTo(u);
                         Dfp[] ruArray = new Dfp[3];
@@ -842,7 +842,7 @@ public class FieldRotationDfpTest {
         UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random);
         for (int i = 0; i < 10; ++i) {
             double[] unit1 = g.nextVector();
-            Rotation r1 = new Rotation(new Vector3D(unit1[0], unit1[1], unit1[2]),
+            Rotation r1 = new Rotation(new Coordinates3D(unit1[0], unit1[1], unit1[2]),
                                       random.nextDouble(), RotationConvention.VECTOR_OPERATOR);
             FieldRotation<Dfp> r1Prime = new FieldRotation<>(field.newDfp(r1.getQ0()),
                                                                 field.newDfp(r1.getQ1()),
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3DTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3DTest.java
index e832ea8fb..7728b96f9 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3DTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/FieldVector3DTest.java
@@ -26,7 +26,7 @@ import org.apache.commons.math4.analysis.differentiation.DerivativeStructure;
 import org.apache.commons.math4.exception.DimensionMismatchException;
 import org.apache.commons.math4.exception.MathArithmeticException;
 import org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.rng.simple.RandomSource;
 import org.apache.commons.math4.util.FastMath;
@@ -59,7 +59,7 @@ public class FieldVector3DTest {
                                    createVector(1, 0,  0, 4)),
                                    2, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 0, 0, 2, 0);
         checkVector(new FieldVector3D<>(new DerivativeStructure(4, 1, 3,  2.0),
-                                   new Vector3D(1, 0,  0)),
+                                   new Coordinates3D(1, 0,  0)),
                                    2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0);
 
         checkVector(new FieldVector3D<>(2, createVector(1, 0,  0, 3),
@@ -71,9 +71,9 @@ public class FieldVector3DTest {
                                    createVector(0, 0, -1, 4)),
                                    2, 0, 3, -1, 0, 0, 1, 0, -1, 0, 0, 0, 0, -1, -1);
         checkVector(new FieldVector3D<>(new DerivativeStructure(4, 1, 3,  2.0),
-                                   new Vector3D(1, 0,  0),
+                                   new Coordinates3D(1, 0,  0),
                                    new DerivativeStructure(4, 1, 3, -3.0),
-                                   new Vector3D(0, 0, -1)),
+                                   new Coordinates3D(0, 0, -1)),
                                    2, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1);
 
         checkVector(new FieldVector3D<>(2, createVector(1, 0, 0, 3),
@@ -88,11 +88,11 @@ public class FieldVector3DTest {
                                    createVector(0, 0, -1, 4)),
                                    2, 5, 3, 4, 0, 0, 1, 0, 4, 0, 1, 0, 0, 4, -1);
         checkVector(new FieldVector3D<>(new DerivativeStructure(4, 1, 3,  2.0),
-                                   new Vector3D(1, 0,  0),
+                                   new Coordinates3D(1, 0,  0),
                                    new DerivativeStructure(4, 1, 3,  5.0),
-                                   new Vector3D(0, 1,  0),
+                                   new Coordinates3D(0, 1,  0),
                                    new DerivativeStructure(4, 1, 3, -3.0),
-                                   new Vector3D(0, 0, -1)),
+                                   new Coordinates3D(0, 0, -1)),
                                    2, 5, 3, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, -1);
 
         checkVector(new FieldVector3D<>(2, createVector(1, 0, 0, 3),
@@ -110,13 +110,13 @@ public class FieldVector3DTest {
                                    createVector(0, 0, -1, 4)),
                                    2, 0, 3, 9, 0, 0, 1, 0, 9, 0, 0, 0, 0, 9, -1);
         checkVector(new FieldVector3D<>(new DerivativeStructure(4, 1, 3,  2.0),
-                                   new Vector3D(1, 0,  0),
+                                   new Coordinates3D(1, 0,  0),
                                    new DerivativeStructure(4, 1, 3,  5.0),
-                                   new Vector3D(0, 1,  0),
+                                   new Coordinates3D(0, 1,  0),
                                    new DerivativeStructure(4, 1, 3,  5.0),
-                                   new Vector3D(0, -1,  0),
+                                   new Coordinates3D(0, -1,  0),
                                    new DerivativeStructure(4, 1, 3, -3.0),
-                                   new Vector3D(0, 0, -1)),
+                                   new Coordinates3D(0, 0, -1)),
                                    2, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1);
 
         checkVector(new FieldVector3D<>(new DerivativeStructure[] {
@@ -270,12 +270,12 @@ public class FieldVector3DTest {
         Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);
         Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);
-        distance = FieldVector3D.distance1(v1, new Vector3D(-4, 2, 0));
+        distance = FieldVector3D.distance1(v1, new Coordinates3D(-4, 2, 0));
         Assert.assertEquals(12.0, distance.getReal(), 1.0e-12);
         Assert.assertEquals( 1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(-1, distance.getPartialDerivative(0, 1, 0), 1.0e-12);
         Assert.assertEquals( 1, distance.getPartialDerivative(0, 0, 1), 1.0e-12);
-        distance = FieldVector3D.distance1(new Vector3D(-4, 2, 0), v1);
+        distance = FieldVector3D.distance1(new Coordinates3D(-4, 2, 0), v1);
         Assert.assertEquals(12.0, distance.getReal(), 1.0e-12);
         Assert.assertEquals( 1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(-1, distance.getPartialDerivative(0, 1, 0), 1.0e-12);
@@ -292,12 +292,12 @@ public class FieldVector3DTest {
         Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);
         Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);
-        distance = FieldVector3D.distance(v1, new Vector3D(-4, 2, 0));
+        distance = FieldVector3D.distance(v1, new Coordinates3D(-4, 2, 0));
         Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12);
         Assert.assertEquals( 5 / FastMath.sqrt(50), distance.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(-4 / FastMath.sqrt(50), distance.getPartialDerivative(0, 1, 0), 1.0e-12);
         Assert.assertEquals( 3 / FastMath.sqrt(50), distance.getPartialDerivative(0, 0, 1), 1.0e-12);
-        distance = FieldVector3D.distance(new Vector3D(-4, 2, 0), v1);
+        distance = FieldVector3D.distance(new Coordinates3D(-4, 2, 0), v1);
         Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12);
         Assert.assertEquals( 5 / FastMath.sqrt(50), distance.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(-4 / FastMath.sqrt(50), distance.getPartialDerivative(0, 1, 0), 1.0e-12);
@@ -314,12 +314,12 @@ public class FieldVector3DTest {
         Assert.assertEquals(0, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);
         Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12);
-        distanceSq = FieldVector3D.distanceSq(v1, new Vector3D(-4, 2, 0));
+        distanceSq = FieldVector3D.distanceSq(v1, new Coordinates3D(-4, 2, 0));
         Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12);
         Assert.assertEquals(10, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(-8, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);
         Assert.assertEquals( 6, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12);
-        distanceSq = FieldVector3D.distanceSq(new Vector3D(-4, 2, 0), v1);
+        distanceSq = FieldVector3D.distanceSq(new Coordinates3D(-4, 2, 0), v1);
         Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12);
         Assert.assertEquals(10, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(-8, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);
@@ -336,12 +336,12 @@ public class FieldVector3DTest {
         Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);
         Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);
-        distance = FieldVector3D.distanceInf(v1, new Vector3D(-4, 2, 0));
+        distance = FieldVector3D.distanceInf(v1, new Coordinates3D(-4, 2, 0));
         Assert.assertEquals(5.0, distance.getReal(), 1.0e-12);
         Assert.assertEquals(1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);
         Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);
-        distance = FieldVector3D.distanceInf(new Vector3D(-4, 2, 0), v1);
+        distance = FieldVector3D.distanceInf(new Coordinates3D(-4, 2, 0), v1);
         Assert.assertEquals(5.0, distance.getReal(), 1.0e-12);
         Assert.assertEquals(1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);
         Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);
@@ -368,22 +368,22 @@ public class FieldVector3DTest {
                             1.0e-12);
 
         Assert.assertEquals(5.0,
-                            FieldVector3D.distanceInf(createVector( 1, -2, 3, 3), new Vector3D(-4,  2, 0)).getReal(),
+                            FieldVector3D.distanceInf(createVector( 1, -2, 3, 3), new Coordinates3D(-4,  2, 0)).getReal(),
                             1.0e-12);
         Assert.assertEquals(5.0,
-                            FieldVector3D.distanceInf(createVector( 1, 3, -2, 3), new Vector3D(-4, 0,  2)).getReal(),
+                            FieldVector3D.distanceInf(createVector( 1, 3, -2, 3), new Coordinates3D(-4, 0,  2)).getReal(),
                             1.0e-12);
         Assert.assertEquals(5.0,
-                            FieldVector3D.distanceInf(createVector(-2,  1, 3, 3), new Vector3D( 2, -4, 0)).getReal(),
+                            FieldVector3D.distanceInf(createVector(-2,  1, 3, 3), new Coordinates3D( 2, -4, 0)).getReal(),
                             1.0e-12);
         Assert.assertEquals(5.0,
-                            FieldVector3D.distanceInf(createVector(-2, 3,  1, 3), new Vector3D( 2, 0, -4)).getReal(),
+                            FieldVector3D.distanceInf(createVector(-2, 3,  1, 3), new Coordinates3D( 2, 0, -4)).getReal(),
                             1.0e-12);
         Assert.assertEquals(5.0,
-                            FieldVector3D.distanceInf(createVector(3, -2,  1, 3), new Vector3D(0,  2, -4)).getReal(),
+                            FieldVector3D.distanceInf(createVector(3, -2,  1, 3), new Coordinates3D(0,  2, -4)).getReal(),
                             1.0e-12);
         Assert.assertEquals(5.0,
-                            FieldVector3D.distanceInf(createVector(3,  1, -2, 3), new Vector3D(0, -4,  2)).getReal(),
+                            FieldVector3D.distanceInf(createVector(3,  1, -2, 3), new Coordinates3D(0, -4,  2)).getReal(),
                             1.0e-12);
 
     }
@@ -396,10 +396,10 @@ public class FieldVector3DTest {
         checkVector(v1, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0);
 
         checkVector(v2.subtract(v1), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1);
-        checkVector(v2.subtract(new Vector3D(4, 4, 4)), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1);
+        checkVector(v2.subtract(new Coordinates3D(4, 4, 4)), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1);
         checkVector(v2.subtract(3, v1), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1);
-        checkVector(v2.subtract(3, new Vector3D(4, 4, 4)), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1);
-        checkVector(v2.subtract(new DerivativeStructure(3, 1, 2, 3), new Vector3D(4, 4, 4)),
+        checkVector(v2.subtract(3, new Coordinates3D(4, 4, 4)), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1);
+        checkVector(v2.subtract(new DerivativeStructure(3, 1, 2, 3), new Coordinates3D(4, 4, 4)),
                     -15, -14, -13, 1, 0, -4, 0, 1, -4, 0, 0, -3);
 
         checkVector(createVector(1, 2, 3, 4).subtract(new DerivativeStructure(4, 1, 3, 5.0),
@@ -419,10 +419,10 @@ public class FieldVector3DTest {
         checkVector(v1, -2, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 2);
 
         checkVector(v2.add(v1), -5, -2, 1, 3, 0, 0, 0, 3, 0, 0, 0, 3);
-        checkVector(v2.add(new Vector3D(-2, 0, 2)), -5, -2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1);
+        checkVector(v2.add(new Coordinates3D(-2, 0, 2)), -5, -2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1);
         checkVector(v2.add(3, v1), -9, -2, 5, 7, 0, 0, 0, 7, 0, 0, 0, 7);
-        checkVector(v2.add(3, new Vector3D(-2, 0, 2)), -9, -2, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1);
-        checkVector(v2.add(new DerivativeStructure(3, 1, 2, 3), new Vector3D(-2, 0, 2)),
+        checkVector(v2.add(3, new Coordinates3D(-2, 0, 2)), -9, -2, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1);
+        checkVector(v2.add(new DerivativeStructure(3, 1, 2, 3), new Coordinates3D(-2, 0, 2)),
                     -9, -2, 5, 1, 0, -2, 0, 1, 0, 0, 0, 3);
 
         checkVector(createVector(1, 2, 3, 4).add(new DerivativeStructure(4, 1, 3, 5.0),
@@ -508,7 +508,7 @@ public class FieldVector3DTest {
         Assert.assertTrue(FastMath.abs(FieldVector3D.angle(v1.toVector3D(), v2).getReal() - 1.2) < 1.0e-12);
 
         try {
-            FieldVector3D.angle(v1, Vector3D.ZERO);
+            FieldVector3D.angle(v1, Coordinates3D.ZERO);
             Assert.fail("an exception should have been thrown");
         } catch (MathArithmeticException mae) {
             // expected
@@ -605,7 +605,7 @@ public class FieldVector3DTest {
 
             FieldVector3D<DerivativeStructure> uds = createVector(ux, uy, uz, 3);
             FieldVector3D<DerivativeStructure> vds = createVector(vx, vy, vz, 3);
-            Vector3D v = new Vector3D(vx, vy, vz);
+            Coordinates3D v = new Coordinates3D(vx, vy, vz);
 
             DerivativeStructure sAccurate = FieldVector3D.dotProduct(uds, vds);
             Assert.assertEquals(sNaive, sAccurate.getReal(), 2.5e-16 * sNaive);
@@ -658,11 +658,11 @@ public class FieldVector3DTest {
             double vx = random.nextDouble();
             double vy = random.nextDouble();
             double vz = random.nextDouble();
-            Vector3D cNaive = new Vector3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);
+            Coordinates3D cNaive = new Coordinates3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);
 
             FieldVector3D<DerivativeStructure> uds = createVector(ux, uy, uz, 3);
             FieldVector3D<DerivativeStructure> vds = createVector(vx, vy, vz, 3);
-            Vector3D v = new Vector3D(vx, vy, vz);
+            Coordinates3D v = new Coordinates3D(vx, vy, vz);
 
             checkVector(FieldVector3D.crossProduct(uds, vds),
                         cNaive.getX(), cNaive.getY(), cNaive.getZ(),
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/LineTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/LineTest.java
index ad03bfa34..16688c9ca 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/LineTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/LineTest.java
@@ -19,7 +19,7 @@ package org.apache.commons.math4.geometry.euclidean.threed;
 import org.apache.commons.math4.exception.MathArithmeticException;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.geometry.euclidean.threed.Line;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.util.FastMath;
 import org.junit.Assert;
 import org.junit.Test;
@@ -28,22 +28,22 @@ public class LineTest {
 
     @Test
     public void testContains() throws MathIllegalArgumentException, MathArithmeticException {
-        Vector3D p1 = new Vector3D(0, 0, 1);
-        Line l = new Line(p1, new Vector3D(0, 0, 2), 1.0e-10);
+        Coordinates3D p1 = new Coordinates3D(0, 0, 1);
+        Line l = new Line(p1, new Coordinates3D(0, 0, 2), 1.0e-10);
         Assert.assertTrue(l.contains(p1));
-        Assert.assertTrue(l.contains(new Vector3D(1.0, p1, 0.3, l.getDirection())));
-        Vector3D u = l.getDirection().orthogonal();
-        Vector3D v = Vector3D.crossProduct(l.getDirection(), u);
+        Assert.assertTrue(l.contains(new Coordinates3D(1.0, p1, 0.3, l.getDirection())));
+        Coordinates3D u = l.getDirection().orthogonal();
+        Coordinates3D v = Coordinates3D.crossProduct(l.getDirection(), u);
         for (double alpha = 0; alpha < 2 * FastMath.PI; alpha += 0.3) {
-            Assert.assertTrue(! l.contains(p1.add(new Vector3D(FastMath.cos(alpha), u,
+            Assert.assertTrue(! l.contains(p1.add(new Coordinates3D(FastMath.cos(alpha), u,
                                                                FastMath.sin(alpha), v))));
         }
     }
 
     @Test
     public void testSimilar() throws MathIllegalArgumentException, MathArithmeticException {
-        Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);
-        Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);
+        Coordinates3D p1  = new Coordinates3D (1.2, 3.4, -5.8);
+        Coordinates3D p2  = new Coordinates3D (3.4, -5.8, 1.2);
         Line     lA  = new Line(p1, p2, 1.0e-10);
         Line     lB  = new Line(p2, p1, 1.0e-10);
         Assert.assertTrue(lA.isSimilarTo(lB));
@@ -52,91 +52,91 @@ public class LineTest {
 
     @Test
     public void testPointDistance() throws MathIllegalArgumentException {
-        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2), 1.0e-10);
-        Assert.assertEquals(FastMath.sqrt(3.0 / 2.0), l.distance(new Vector3D(1, 0, 1)), 1.0e-10);
-        Assert.assertEquals(0, l.distance(new Vector3D(0, -4, -4)), 1.0e-10);
+        Line l = new Line(new Coordinates3D(0, 1, 1), new Coordinates3D(0, 2, 2), 1.0e-10);
+        Assert.assertEquals(FastMath.sqrt(3.0 / 2.0), l.distance(new Coordinates3D(1, 0, 1)), 1.0e-10);
+        Assert.assertEquals(0, l.distance(new Coordinates3D(0, -4, -4)), 1.0e-10);
     }
 
     @Test
     public void testLineDistance() throws MathIllegalArgumentException {
-        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2), 1.0e-10);
+        Line l = new Line(new Coordinates3D(0, 1, 1), new Coordinates3D(0, 2, 2), 1.0e-10);
         Assert.assertEquals(1.0,
-                            l.distance(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2), 1.0e-10)),
+                            l.distance(new Line(new Coordinates3D(1, 0, 1), new Coordinates3D(1, 0, 2), 1.0e-10)),
                             1.0e-10);
         Assert.assertEquals(0.5,
-                            l.distance(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1), 1.0e-10)),
+                            l.distance(new Line(new Coordinates3D(-0.5, 0, 0), new Coordinates3D(-0.5, -1, -1), 1.0e-10)),
                             1.0e-10);
         Assert.assertEquals(0.0,
                             l.distance(l),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5), 1.0e-10)),
+                            l.distance(new Line(new Coordinates3D(0, -4, -4), new Coordinates3D(0, -5, -5), 1.0e-10)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4), 1.0e-10)),
+                            l.distance(new Line(new Coordinates3D(0, -4, -4), new Coordinates3D(0, -3, -4), 1.0e-10)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4), 1.0e-10)),
+                            l.distance(new Line(new Coordinates3D(0, -4, -4), new Coordinates3D(1, -4, -4), 1.0e-10)),
                             1.0e-10);
         Assert.assertEquals(FastMath.sqrt(8),
-                            l.distance(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0), 1.0e-10)),
+                            l.distance(new Line(new Coordinates3D(0, -4, 0), new Coordinates3D(1, -4, 0), 1.0e-10)),
                             1.0e-10);
     }
 
     @Test
     public void testClosest() throws MathIllegalArgumentException {
-        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2), 1.0e-10);
+        Line l = new Line(new Coordinates3D(0, 1, 1), new Coordinates3D(0, 2, 2), 1.0e-10);
         Assert.assertEquals(0.0,
-                            l.closestPoint(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2), 1.0e-10)).distance(new Vector3D(0, 0, 0)),
+                            l.closestPoint(new Line(new Coordinates3D(1, 0, 1), new Coordinates3D(1, 0, 2), 1.0e-10)).distance(new Coordinates3D(0, 0, 0)),
                             1.0e-10);
         Assert.assertEquals(0.5,
-                            l.closestPoint(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1), 1.0e-10)).distance(new Vector3D(-0.5, 0, 0)),
+                            l.closestPoint(new Line(new Coordinates3D(-0.5, 0, 0), new Coordinates3D(-0.5, -1, -1), 1.0e-10)).distance(new Coordinates3D(-0.5, 0, 0)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.closestPoint(l).distance(new Vector3D(0, 0, 0)),
+                            l.closestPoint(l).distance(new Coordinates3D(0, 0, 0)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5), 1.0e-10)).distance(new Vector3D(0, 0, 0)),
+                            l.closestPoint(new Line(new Coordinates3D(0, -4, -4), new Coordinates3D(0, -5, -5), 1.0e-10)).distance(new Coordinates3D(0, 0, 0)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4), 1.0e-10)).distance(new Vector3D(0, -4, -4)),
+                            l.closestPoint(new Line(new Coordinates3D(0, -4, -4), new Coordinates3D(0, -3, -4), 1.0e-10)).distance(new Coordinates3D(0, -4, -4)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4), 1.0e-10)).distance(new Vector3D(0, -4, -4)),
+                            l.closestPoint(new Line(new Coordinates3D(0, -4, -4), new Coordinates3D(1, -4, -4), 1.0e-10)).distance(new Coordinates3D(0, -4, -4)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.closestPoint(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0), 1.0e-10)).distance(new Vector3D(0, -2, -2)),
+                            l.closestPoint(new Line(new Coordinates3D(0, -4, 0), new Coordinates3D(1, -4, 0), 1.0e-10)).distance(new Coordinates3D(0, -2, -2)),
                             1.0e-10);
     }
 
     @Test
     public void testIntersection() throws MathIllegalArgumentException {
-        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2), 1.0e-10);
-        Assert.assertNull(l.intersection(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2), 1.0e-10)));
-        Assert.assertNull(l.intersection(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1), 1.0e-10)));
+        Line l = new Line(new Coordinates3D(0, 1, 1), new Coordinates3D(0, 2, 2), 1.0e-10);
+        Assert.assertNull(l.intersection(new Line(new Coordinates3D(1, 0, 1), new Coordinates3D(1, 0, 2), 1.0e-10)));
+        Assert.assertNull(l.intersection(new Line(new Coordinates3D(-0.5, 0, 0), new Coordinates3D(-0.5, -1, -1), 1.0e-10)));
         Assert.assertEquals(0.0,
-                            l.intersection(l).distance(new Vector3D(0, 0, 0)),
+                            l.intersection(l).distance(new Coordinates3D(0, 0, 0)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5), 1.0e-10)).distance(new Vector3D(0, 0, 0)),
+                            l.intersection(new Line(new Coordinates3D(0, -4, -4), new Coordinates3D(0, -5, -5), 1.0e-10)).distance(new Coordinates3D(0, 0, 0)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4), 1.0e-10)).distance(new Vector3D(0, -4, -4)),
+                            l.intersection(new Line(new Coordinates3D(0, -4, -4), new Coordinates3D(0, -3, -4), 1.0e-10)).distance(new Coordinates3D(0, -4, -4)),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4), 1.0e-10)).distance(new Vector3D(0, -4, -4)),
+                            l.intersection(new Line(new Coordinates3D(0, -4, -4), new Coordinates3D(1, -4, -4), 1.0e-10)).distance(new Coordinates3D(0, -4, -4)),
                             1.0e-10);
-        Assert.assertNull(l.intersection(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0), 1.0e-10)));
+        Assert.assertNull(l.intersection(new Line(new Coordinates3D(0, -4, 0), new Coordinates3D(1, -4, 0), 1.0e-10)));
     }
 
     @Test
     public void testRevert() {
 
         // setup
-        Line line = new Line(new Vector3D(1653345.6696423641, 6170370.041579291, 90000),
-                             new Vector3D(1650757.5050732433, 6160710.879908984, 0.9),
+        Line line = new Line(new Coordinates3D(1653345.6696423641, 6170370.041579291, 90000),
+                             new Coordinates3D(1650757.5050732433, 6160710.879908984, 0.9),
                              1.0e-10);
-        Vector3D expected = line.getDirection().negate();
+        Coordinates3D expected = line.getDirection().negate();
 
         // action
         Line reverted = line.revert();
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PLYParser.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PLYParser.java
index 7670e69ad..5439d8d2d 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PLYParser.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PLYParser.java
@@ -40,7 +40,7 @@ import org.apache.commons.math4.util.Precision;
 public class PLYParser {
 
     /** Parsed vertices. */
-    private Vector3D[] vertices;
+    private Coordinates3D[] vertices;
 
     /** Parsed faces. */
     private int[][] faces;
@@ -167,7 +167,7 @@ public class PLYParser {
             ++vPropertiesNumber;
 
             // parse vertices
-            vertices = new Vector3D[nbVertices];
+            vertices = new Coordinates3D[nbVertices];
             for (int i = 0; i < nbVertices; ++i) {
                 fields = parseNextLine();
                 if (fields.size() != vPropertiesNumber ||
@@ -176,7 +176,7 @@ public class PLYParser {
                     fields.get(zIndex).getToken() != Token.UNKNOWN) {
                     complain();
                 }
-                vertices[i] = new Vector3D(Double.parseDouble(fields.get(xIndex).getValue()),
+                vertices[i] = new Coordinates3D(Double.parseDouble(fields.get(xIndex).getValue()),
                                            Double.parseDouble(fields.get(yIndex).getValue()),
                                            Double.parseDouble(fields.get(zIndex).getValue()));
             }
@@ -229,7 +229,7 @@ public class PLYParser {
     /** Get the parsed vertices.
      * @return parsed vertices
      */
-    public List<Vector3D> getVertices() {
+    public List<Coordinates3D> getVertices() {
         return Arrays.asList(vertices);
     }
 
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PlaneTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PlaneTest.java
index 3991a102f..53de398b1 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PlaneTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PlaneTest.java
@@ -21,7 +21,7 @@ import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.geometry.euclidean.threed.Line;
 import org.apache.commons.math4.geometry.euclidean.threed.Plane;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -29,37 +29,37 @@ public class PlaneTest {
 
     @Test
     public void testContains() throws MathArithmeticException {
-        Plane p = new Plane(new Vector3D(0, 0, 1), new Vector3D(0, 0, 1), 1.0e-10);
-        Assert.assertTrue(p.contains(new Vector3D(0, 0, 1)));
-        Assert.assertTrue(p.contains(new Vector3D(17, -32, 1)));
-        Assert.assertTrue(! p.contains(new Vector3D(17, -32, 1.001)));
+        Plane p = new Plane(new Coordinates3D(0, 0, 1), new Coordinates3D(0, 0, 1), 1.0e-10);
+        Assert.assertTrue(p.contains(new Coordinates3D(0, 0, 1)));
+        Assert.assertTrue(p.contains(new Coordinates3D(17, -32, 1)));
+        Assert.assertTrue(! p.contains(new Coordinates3D(17, -32, 1.001)));
     }
 
     @Test
     public void testOffset() throws MathArithmeticException {
-        Vector3D p1 = new Vector3D(1, 1, 1);
-        Plane p = new Plane(p1, new Vector3D(0.2, 0, 0), 1.0e-10);
-        Assert.assertEquals(-5.0, p.getOffset(new Vector3D(-4, 0, 0)), 1.0e-10);
-        Assert.assertEquals(+5.0, p.getOffset(new Vector3D(6, 10, -12)), 1.0e-10);
+        Coordinates3D p1 = new Coordinates3D(1, 1, 1);
+        Plane p = new Plane(p1, new Coordinates3D(0.2, 0, 0), 1.0e-10);
+        Assert.assertEquals(-5.0, p.getOffset(new Coordinates3D(-4, 0, 0)), 1.0e-10);
+        Assert.assertEquals(+5.0, p.getOffset(new Coordinates3D(6, 10, -12)), 1.0e-10);
         Assert.assertEquals(0.3,
-                            p.getOffset(new Vector3D(1.0, p1, 0.3, p.getNormal())),
+                            p.getOffset(new Coordinates3D(1.0, p1, 0.3, p.getNormal())),
                             1.0e-10);
         Assert.assertEquals(-0.3,
-                            p.getOffset(new Vector3D(1.0, p1, -0.3, p.getNormal())),
+                            p.getOffset(new Coordinates3D(1.0, p1, -0.3, p.getNormal())),
                             1.0e-10);
     }
 
     @Test
     public void testPoint() throws MathArithmeticException {
-        Plane p = new Plane(new Vector3D(2, -3, 1), new Vector3D(1, 4, 9), 1.0e-10);
+        Plane p = new Plane(new Coordinates3D(2, -3, 1), new Coordinates3D(1, 4, 9), 1.0e-10);
         Assert.assertTrue(p.contains(p.getOrigin()));
     }
 
     @Test
     public void testThreePoints() throws MathArithmeticException {
-        Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);
-        Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);
-        Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);
+        Coordinates3D p1 = new Coordinates3D(1.2, 3.4, -5.8);
+        Coordinates3D p2 = new Coordinates3D(3.4, -5.8, 1.2);
+        Coordinates3D p3 = new Coordinates3D(-2.0, 4.3, 0.7);
         Plane    p  = new Plane(p1, p2, p3, 1.0e-10);
         Assert.assertTrue(p.contains(p1));
         Assert.assertTrue(p.contains(p2));
@@ -68,11 +68,11 @@ public class PlaneTest {
 
     @Test
     public void testRotate() throws MathArithmeticException, MathIllegalArgumentException {
-        Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);
-        Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);
-        Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);
+        Coordinates3D p1 = new Coordinates3D(1.2, 3.4, -5.8);
+        Coordinates3D p2 = new Coordinates3D(3.4, -5.8, 1.2);
+        Coordinates3D p3 = new Coordinates3D(-2.0, 4.3, 0.7);
         Plane    p  = new Plane(p1, p2, p3, 1.0e-10);
-        Vector3D oldNormal = p.getNormal();
+        Coordinates3D oldNormal = p.getNormal();
 
         p = p.rotate(p2, new Rotation(p2.subtract(p1), 1.7, RotationConvention.VECTOR_OPERATOR));
         Assert.assertTrue(p.contains(p1));
@@ -93,22 +93,22 @@ public class PlaneTest {
 
     @Test
     public void testTranslate() throws MathArithmeticException {
-        Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);
-        Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);
-        Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);
+        Coordinates3D p1 = new Coordinates3D(1.2, 3.4, -5.8);
+        Coordinates3D p2 = new Coordinates3D(3.4, -5.8, 1.2);
+        Coordinates3D p3 = new Coordinates3D(-2.0, 4.3, 0.7);
         Plane    p  = new Plane(p1, p2, p3, 1.0e-10);
 
-        p = p.translate(new Vector3D(2.0, p.getU(), -1.5, p.getV()));
+        p = p.translate(new Coordinates3D(2.0, p.getU(), -1.5, p.getV()));
         Assert.assertTrue(p.contains(p1));
         Assert.assertTrue(p.contains(p2));
         Assert.assertTrue(p.contains(p3));
 
-        p = p.translate(new Vector3D(-1.2, p.getNormal()));
+        p = p.translate(new Coordinates3D(-1.2, p.getNormal()));
         Assert.assertTrue(! p.contains(p1));
         Assert.assertTrue(! p.contains(p2));
         Assert.assertTrue(! p.contains(p3));
 
-        p = p.translate(new Vector3D(+1.2, p.getNormal()));
+        p = p.translate(new Coordinates3D(+1.2, p.getNormal()));
         Assert.assertTrue(p.contains(p1));
         Assert.assertTrue(p.contains(p2));
         Assert.assertTrue(p.contains(p3));
@@ -117,22 +117,22 @@ public class PlaneTest {
 
     @Test
     public void testIntersection() throws MathArithmeticException, MathIllegalArgumentException {
-        Plane p = new Plane(new Vector3D(1, 2, 3), new Vector3D(-4, 1, -5), 1.0e-10);
-        Line  l = new Line(new Vector3D(0.2, -3.5, 0.7), new Vector3D(1.2, -2.5, -0.3), 1.0e-10);
-        Vector3D point = p.intersection(l);
+        Plane p = new Plane(new Coordinates3D(1, 2, 3), new Coordinates3D(-4, 1, -5), 1.0e-10);
+        Line  l = new Line(new Coordinates3D(0.2, -3.5, 0.7), new Coordinates3D(1.2, -2.5, -0.3), 1.0e-10);
+        Coordinates3D point = p.intersection(l);
         Assert.assertTrue(p.contains(point));
         Assert.assertTrue(l.contains(point));
-        Assert.assertNull(p.intersection(new Line(new Vector3D(10, 10, 10),
-                                                  new Vector3D(10, 10, 10).add(p.getNormal().orthogonal()),
+        Assert.assertNull(p.intersection(new Line(new Coordinates3D(10, 10, 10),
+                                                  new Coordinates3D(10, 10, 10).add(p.getNormal().orthogonal()),
                                                   1.0e-10)));
     }
 
     @Test
     public void testIntersection2() throws MathArithmeticException {
-        Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);
-        Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);
-        Plane    pA  = new Plane(p1, p2, new Vector3D (-2.0, 4.3, 0.7), 1.0e-10);
-        Plane    pB  = new Plane(p1, new Vector3D (11.4, -3.8, 5.1), p2, 1.0e-10);
+        Coordinates3D p1  = new Coordinates3D (1.2, 3.4, -5.8);
+        Coordinates3D p2  = new Coordinates3D (3.4, -5.8, 1.2);
+        Plane    pA  = new Plane(p1, p2, new Coordinates3D (-2.0, 4.3, 0.7), 1.0e-10);
+        Plane    pB  = new Plane(p1, new Coordinates3D (11.4, -3.8, 5.1), p2, 1.0e-10);
         Line     l   = pA.intersection(pB);
         Assert.assertTrue(l.contains(p1));
         Assert.assertTrue(l.contains(p2));
@@ -141,11 +141,11 @@ public class PlaneTest {
 
     @Test
     public void testIntersection3() throws MathArithmeticException {
-        Vector3D reference = new Vector3D (1.2, 3.4, -5.8);
-        Plane p1 = new Plane(reference, new Vector3D(1, 3, 3), 1.0e-10);
-        Plane p2 = new Plane(reference, new Vector3D(-2, 4, 0), 1.0e-10);
-        Plane p3 = new Plane(reference, new Vector3D(7, 0, -4), 1.0e-10);
-        Vector3D p = Plane.intersection(p1, p2, p3);
+        Coordinates3D reference = new Coordinates3D (1.2, 3.4, -5.8);
+        Plane p1 = new Plane(reference, new Coordinates3D(1, 3, 3), 1.0e-10);
+        Plane p2 = new Plane(reference, new Coordinates3D(-2, 4, 0), 1.0e-10);
+        Plane p3 = new Plane(reference, new Coordinates3D(7, 0, -4), 1.0e-10);
+        Coordinates3D p = Plane.intersection(p1, p2, p3);
         Assert.assertEquals(reference.getX(), p.getX(), 1.0e-10);
         Assert.assertEquals(reference.getY(), p.getY(), 1.0e-10);
         Assert.assertEquals(reference.getZ(), p.getZ(), 1.0e-10);
@@ -153,15 +153,15 @@ public class PlaneTest {
 
     @Test
     public void testSimilar() throws MathArithmeticException {
-        Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);
-        Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);
-        Vector3D p3  = new Vector3D (-2.0, 4.3, 0.7);
+        Coordinates3D p1  = new Coordinates3D (1.2, 3.4, -5.8);
+        Coordinates3D p2  = new Coordinates3D (3.4, -5.8, 1.2);
+        Coordinates3D p3  = new Coordinates3D (-2.0, 4.3, 0.7);
         Plane    pA  = new Plane(p1, p2, p3, 1.0e-10);
-        Plane    pB  = new Plane(p1, new Vector3D (11.4, -3.8, 5.1), p2, 1.0e-10);
+        Plane    pB  = new Plane(p1, new Coordinates3D (11.4, -3.8, 5.1), p2, 1.0e-10);
         Assert.assertTrue(! pA.isSimilarTo(pB));
         Assert.assertTrue(pA.isSimilarTo(pA));
         Assert.assertTrue(pA.isSimilarTo(new Plane(p1, p3, p2, 1.0e-10)));
-        Vector3D shift = new Vector3D(0.3, pA.getNormal());
+        Coordinates3D shift = new Coordinates3D(0.3, pA.getNormal());
         Assert.assertTrue(! pA.isSimilarTo(new Plane(p1.add(shift),
                                                      p3.add(shift),
                                                      p2.add(shift),
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSetTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSetTest.java
index 8e1bd32bd..73b11684f 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSetTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSetTest.java
@@ -37,11 +37,11 @@ import org.apache.commons.math4.geometry.euclidean.threed.Plane;
 import org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
 import org.apache.commons.math4.geometry.euclidean.threed.SubPlane;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
 import org.apache.commons.math4.geometry.euclidean.twod.SubLine;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
 import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
 import org.apache.commons.math4.geometry.partitioning.BoundaryAttribute;
@@ -63,7 +63,7 @@ public class PolyhedronsSetTest {
         PolyhedronsSet tree = new PolyhedronsSet(0, 1, 0, 1, 0, 1, 1.0e-10);
         Assert.assertEquals(1.0, tree.getSize(), 1.0e-10);
         Assert.assertEquals(6.0, tree.getBoundarySize(), 1.0e-10);
-        Vector3D barycenter = (Vector3D) tree.getBarycenter();
+        Coordinates3D barycenter = (Coordinates3D) tree.getBarycenter();
         Assert.assertEquals(0.5, barycenter.getX(), 1.0e-10);
         Assert.assertEquals(0.5, barycenter.getY(), 1.0e-10);
         Assert.assertEquals(0.5, barycenter.getZ(), 1.0e-10);
@@ -75,34 +75,34 @@ public class PolyhedronsSetTest {
                     boolean zOK = (z >= 0.0) && (z <= 1.0);
                     Region.Location expected =
                         (xOK && yOK && zOK) ? Region.Location.INSIDE : Region.Location.OUTSIDE;
-                    Assert.assertEquals(expected, tree.checkPoint(new Vector3D(x, y, z)));
+                    Assert.assertEquals(expected, tree.checkPoint(new Coordinates3D(x, y, z)));
                 }
             }
         }
-        checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] {
-            new Vector3D(0.0, 0.5, 0.5),
-            new Vector3D(1.0, 0.5, 0.5),
-            new Vector3D(0.5, 0.0, 0.5),
-            new Vector3D(0.5, 1.0, 0.5),
-            new Vector3D(0.5, 0.5, 0.0),
-            new Vector3D(0.5, 0.5, 1.0)
+        checkPoints(Region.Location.BOUNDARY, tree, new Coordinates3D[] {
+            new Coordinates3D(0.0, 0.5, 0.5),
+            new Coordinates3D(1.0, 0.5, 0.5),
+            new Coordinates3D(0.5, 0.0, 0.5),
+            new Coordinates3D(0.5, 1.0, 0.5),
+            new Coordinates3D(0.5, 0.5, 0.0),
+            new Coordinates3D(0.5, 0.5, 1.0)
         });
-        checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] {
-            new Vector3D(0.0, 1.2, 1.2),
-            new Vector3D(1.0, 1.2, 1.2),
-            new Vector3D(1.2, 0.0, 1.2),
-            new Vector3D(1.2, 1.0, 1.2),
-            new Vector3D(1.2, 1.2, 0.0),
-            new Vector3D(1.2, 1.2, 1.0)
+        checkPoints(Region.Location.OUTSIDE, tree, new Coordinates3D[] {
+            new Coordinates3D(0.0, 1.2, 1.2),
+            new Coordinates3D(1.0, 1.2, 1.2),
+            new Coordinates3D(1.2, 0.0, 1.2),
+            new Coordinates3D(1.2, 1.0, 1.2),
+            new Coordinates3D(1.2, 1.2, 0.0),
+            new Coordinates3D(1.2, 1.2, 1.0)
         });
     }
 
     @Test
     public void testTetrahedron() throws MathArithmeticException {
-        Vector3D vertex1 = new Vector3D(1, 2, 3);
-        Vector3D vertex2 = new Vector3D(2, 2, 4);
-        Vector3D vertex3 = new Vector3D(2, 3, 3);
-        Vector3D vertex4 = new Vector3D(1, 3, 4);
+        Coordinates3D vertex1 = new Coordinates3D(1, 2, 3);
+        Coordinates3D vertex2 = new Coordinates3D(2, 2, 4);
+        Coordinates3D vertex3 = new Coordinates3D(2, 3, 3);
+        Coordinates3D vertex4 = new Coordinates3D(1, 3, 4);
         PolyhedronsSet tree =
             (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex(
                 new Plane(vertex3, vertex2, vertex1, 1.0e-10),
@@ -111,64 +111,64 @@ public class PolyhedronsSetTest {
                 new Plane(vertex1, vertex2, vertex4, 1.0e-10));
         Assert.assertEquals(1.0 / 3.0, tree.getSize(), 1.0e-10);
         Assert.assertEquals(2.0 * FastMath.sqrt(3.0), tree.getBoundarySize(), 1.0e-10);
-        Vector3D barycenter = (Vector3D) tree.getBarycenter();
+        Coordinates3D barycenter = (Coordinates3D) tree.getBarycenter();
         Assert.assertEquals(1.5, barycenter.getX(), 1.0e-10);
         Assert.assertEquals(2.5, barycenter.getY(), 1.0e-10);
         Assert.assertEquals(3.5, barycenter.getZ(), 1.0e-10);
         double third = 1.0 / 3.0;
-        checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] {
+        checkPoints(Region.Location.BOUNDARY, tree, new Coordinates3D[] {
             vertex1, vertex2, vertex3, vertex4,
-            new Vector3D(third, vertex1, third, vertex2, third, vertex3),
-            new Vector3D(third, vertex2, third, vertex3, third, vertex4),
-            new Vector3D(third, vertex3, third, vertex4, third, vertex1),
-            new Vector3D(third, vertex4, third, vertex1, third, vertex2)
+            new Coordinates3D(third, vertex1, third, vertex2, third, vertex3),
+            new Coordinates3D(third, vertex2, third, vertex3, third, vertex4),
+            new Coordinates3D(third, vertex3, third, vertex4, third, vertex1),
+            new Coordinates3D(third, vertex4, third, vertex1, third, vertex2)
         });
-        checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] {
-            new Vector3D(1, 2, 4),
-            new Vector3D(2, 2, 3),
-            new Vector3D(2, 3, 4),
-            new Vector3D(1, 3, 3)
+        checkPoints(Region.Location.OUTSIDE, tree, new Coordinates3D[] {
+            new Coordinates3D(1, 2, 4),
+            new Coordinates3D(2, 2, 3),
+            new Coordinates3D(2, 3, 4),
+            new Coordinates3D(1, 3, 3)
         });
     }
 
     @Test
     public void testIsometry() throws MathArithmeticException, MathIllegalArgumentException {
-        Vector3D vertex1 = new Vector3D(1.1, 2.2, 3.3);
-        Vector3D vertex2 = new Vector3D(2.0, 2.4, 4.2);
-        Vector3D vertex3 = new Vector3D(2.8, 3.3, 3.7);
-        Vector3D vertex4 = new Vector3D(1.0, 3.6, 4.5);
+        Coordinates3D vertex1 = new Coordinates3D(1.1, 2.2, 3.3);
+        Coordinates3D vertex2 = new Coordinates3D(2.0, 2.4, 4.2);
+        Coordinates3D vertex3 = new Coordinates3D(2.8, 3.3, 3.7);
+        Coordinates3D vertex4 = new Coordinates3D(1.0, 3.6, 4.5);
         PolyhedronsSet tree =
             (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex(
                 new Plane(vertex3, vertex2, vertex1, 1.0e-10),
                 new Plane(vertex2, vertex3, vertex4, 1.0e-10),
                 new Plane(vertex4, vertex3, vertex1, 1.0e-10),
                 new Plane(vertex1, vertex2, vertex4, 1.0e-10));
-        Vector3D barycenter = (Vector3D) tree.getBarycenter();
-        Vector3D s = new Vector3D(10.2, 4.3, -6.7);
-        Vector3D c = new Vector3D(-0.2, 2.1, -3.2);
-        Rotation r = new Rotation(new Vector3D(6.2, -4.4, 2.1), 0.12, RotationConvention.VECTOR_OPERATOR);
+        Coordinates3D barycenter = (Coordinates3D) tree.getBarycenter();
+        Coordinates3D s = new Coordinates3D(10.2, 4.3, -6.7);
+        Coordinates3D c = new Coordinates3D(-0.2, 2.1, -3.2);
+        Rotation r = new Rotation(new Coordinates3D(6.2, -4.4, 2.1), 0.12, RotationConvention.VECTOR_OPERATOR);
 
         tree = tree.rotate(c, r).translate(s);
 
-        Vector3D newB =
-            new Vector3D(1.0, s,
+        Coordinates3D newB =
+            new Coordinates3D(1.0, s,
                          1.0, c,
                          1.0, r.applyTo(barycenter.subtract(c)));
         Assert.assertEquals(0.0,
                             newB.subtract((Vector<Euclidean3D>) tree.getBarycenter()).getNorm(),
                             1.0e-10);
 
-        final Vector3D[] expectedV = new Vector3D[] {
-            new Vector3D(1.0, s,
+        final Coordinates3D[] expectedV = new Coordinates3D[] {
+            new Coordinates3D(1.0, s,
                          1.0, c,
                          1.0, r.applyTo(vertex1.subtract(c))),
-                         new Vector3D(1.0, s,
+                         new Coordinates3D(1.0, s,
                                       1.0, c,
                                       1.0, r.applyTo(vertex2.subtract(c))),
-                                      new Vector3D(1.0, s,
+                                      new Coordinates3D(1.0, s,
                                                    1.0, c,
                                                    1.0, r.applyTo(vertex3.subtract(c))),
-                                                   new Vector3D(1.0, s,
+                                                   new Coordinates3D(1.0, s,
                                                                 1.0, c,
                                                                 1.0, r.applyTo(vertex4.subtract(c)))
         };
@@ -198,11 +198,11 @@ public class PolyhedronsSetTest {
 
             private void checkFacet(SubPlane facet) {
                 Plane plane = (Plane) facet.getHyperplane();
-                Vector2D[][] vertices =
+                Coordinates2D[][] vertices =
                     ((PolygonsSet) facet.getRemainingRegion()).getVertices();
                 Assert.assertEquals(1, vertices.length);
                 for (int i = 0; i < vertices[0].length; ++i) {
-                    Vector3D v = plane.toSpace(vertices[0][i]);
+                    Coordinates3D v = plane.toSpace(vertices[0][i]);
                     double d = Double.POSITIVE_INFINITY;
                     for (int k = 0; k < expectedV.length; ++k) {
                         d = FastMath.min(d, v.subtract(expectedV[k]).getNorm());
@@ -224,7 +224,7 @@ public class PolyhedronsSetTest {
         double l = 1.0;
         PolyhedronsSet tree =
             new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w, 1.0e-10);
-        Vector3D barycenter = (Vector3D) tree.getBarycenter();
+        Coordinates3D barycenter = (Coordinates3D) tree.getBarycenter();
         Assert.assertEquals(x, barycenter.getX(), 1.0e-10);
         Assert.assertEquals(y, barycenter.getY(), 1.0e-10);
         Assert.assertEquals(z, barycenter.getZ(), 1.0e-10);
@@ -248,7 +248,7 @@ public class PolyhedronsSetTest {
             new PolyhedronsSet(x - w, x + w, y - w, y + w, z - l, z + l, 1.0e-10);
         RegionFactory<Euclidean3D> factory = new RegionFactory<>();
         PolyhedronsSet tree = (PolyhedronsSet) factory.union(xBeam, factory.union(yBeam, zBeam));
-        Vector3D barycenter = (Vector3D) tree.getBarycenter();
+        Coordinates3D barycenter = (Coordinates3D) tree.getBarycenter();
 
         Assert.assertEquals(x, barycenter.getX(), 1.0e-10);
         Assert.assertEquals(y, barycenter.getY(), 1.0e-10);
@@ -281,14 +281,14 @@ public class PolyhedronsSetTest {
             int idxA = indices[idx] * 3;
             int idxB = indices[idx + 1] * 3;
             int idxC = indices[idx + 2] * 3;
-            Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);
-            Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);
-            Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);
-            Vector3D[] vertices = {v_1, v_2, v_3};
+            Coordinates3D v_1 = new Coordinates3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);
+            Coordinates3D v_2 = new Coordinates3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);
+            Coordinates3D v_3 = new Coordinates3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);
+            Coordinates3D[] vertices = {v_1, v_2, v_3};
             Plane polyPlane = new Plane(v_1, v_2, v_3, 1.0e-10);
             ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<>();
 
-            Vector2D[] projPts = new Vector2D[vertices.length];
+            Coordinates2D[] projPts = new Coordinates2D[vertices.length];
             for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {
                 projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);
             }
@@ -322,7 +322,7 @@ public class PolyhedronsSetTest {
         PolyhedronsSet ps = new PolyhedronsSet(new BSPTree<Euclidean3D>(), 1.0e-10);
         Assert.assertNotNull(ps);
         try {
-            ps.checkPoint(Vector3D.ZERO);
+            ps.checkPoint(Coordinates3D.ZERO);
             Assert.fail("an exception should have been thrown");
         } catch (NullPointerException npe) {
             // this is expected
@@ -333,18 +333,18 @@ public class PolyhedronsSetTest {
     public void testDumpParse() throws IOException, ParseException {
         double tol=1e-8;
 
-            Vector3D[] verts=new Vector3D[8];
+            Coordinates3D[] verts=new Coordinates3D[8];
             double xmin=-1,xmax=1;
             double ymin=-1,ymax=1;
             double zmin=-1,zmax=1;
-            verts[0]=new Vector3D(xmin,ymin,zmin);
-            verts[1]=new Vector3D(xmax,ymin,zmin);
-            verts[2]=new Vector3D(xmax,ymax,zmin);
-            verts[3]=new Vector3D(xmin,ymax,zmin);
-            verts[4]=new Vector3D(xmin,ymin,zmax);
-            verts[5]=new Vector3D(xmax,ymin,zmax);
-            verts[6]=new Vector3D(xmax,ymax,zmax);
-            verts[7]=new Vector3D(xmin,ymax,zmax);
+            verts[0]=new Coordinates3D(xmin,ymin,zmin);
+            verts[1]=new Coordinates3D(xmax,ymin,zmin);
+            verts[2]=new Coordinates3D(xmax,ymax,zmin);
+            verts[3]=new Coordinates3D(xmin,ymax,zmin);
+            verts[4]=new Coordinates3D(xmin,ymin,zmax);
+            verts[5]=new Coordinates3D(xmax,ymin,zmax);
+            verts[6]=new Coordinates3D(xmax,ymax,zmax);
+            verts[7]=new Coordinates3D(xmin,ymax,zmax);
             //
             int[][] faces=new int[12][];
             faces[0]=new int[]{3,1,0};  // bottom (-z)
@@ -401,7 +401,7 @@ public class PolyhedronsSetTest {
 
     @Test
     public void testFacet2Vertices() throws IOException, ParseException {
-        checkError(Arrays.asList(Vector3D.ZERO, Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K),
+        checkError(Arrays.asList(Coordinates3D.ZERO, Coordinates3D.PLUS_I, Coordinates3D.PLUS_J, Coordinates3D.PLUS_K),
                    Arrays.asList(new int[] { 0, 1, 2 }, new int[] {2, 3}),
                    LocalizedFormats.WRONG_NUMBER_OF_POINTS);
     }
@@ -419,7 +419,7 @@ public class PolyhedronsSetTest {
         }
     }
 
-    private void checkError(final List<Vector3D> vertices, final List<int[]> facets,
+    private void checkError(final List<Coordinates3D> vertices, final List<int[]> facets,
                             final LocalizedFormats expected) {
         try {
             new PolyhedronsSet(vertices, facets, 1.0e-10);
@@ -446,14 +446,14 @@ public class PolyhedronsSetTest {
         UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A, 0xb97c9d1ade21e40al);
         int nrays = 1000;
         for (int i = 0; i < nrays; i++) {
-            Vector3D origin    = Vector3D.ZERO;
-            Vector3D direction = new Vector3D(2 * random.nextDouble() - 1,
+            Coordinates3D origin    = Coordinates3D.ZERO;
+            Coordinates3D direction = new Coordinates3D(2 * random.nextDouble() - 1,
                                               2 * random.nextDouble() - 1,
                                               2 * random.nextDouble() - 1).normalize();
             Line line = new Line(origin, origin.add(direction), polyset.getTolerance());
             SubHyperplane<Euclidean3D> plane = polyset.firstIntersection(origin, line);
             if (plane != null) {
-                Vector3D intersectionPoint = ((Plane)plane.getHyperplane()).intersection(line);
+                Coordinates3D intersectionPoint = ((Plane)plane.getHyperplane()).intersection(line);
                 double dotProduct = direction.dotProduct(intersectionPoint.subtract(origin));
                 Assert.assertTrue(dotProduct > 0);
             }
@@ -471,7 +471,7 @@ public class PolyhedronsSetTest {
             return builder.toString();
         }
 
-    private void checkPoints(Region.Location expected, PolyhedronsSet tree, Vector3D[] points) {
+    private void checkPoints(Region.Location expected, PolyhedronsSet tree, Coordinates3D[] points) {
         for (int i = 0; i < points.length; ++i) {
             Assert.assertEquals(expected, tree.checkPoint(points[i]));
         }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/RotationTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/RotationTest.java
index 5f5732680..a2ebce822 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/RotationTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/RotationTest.java
@@ -23,7 +23,7 @@ import org.apache.commons.math4.geometry.euclidean.threed.CardanEulerSingularity
 import org.apache.commons.math4.geometry.euclidean.threed.NotARotationMatrixException;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
 import org.apache.commons.math4.geometry.euclidean.threed.RotationOrder;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.MathUtils;
 import org.junit.Assert;
@@ -36,21 +36,21 @@ public class RotationTest {
   public void testIdentity() {
 
     Rotation r = Rotation.IDENTITY;
-    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);
-    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);
-    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);
+    checkVector(r.applyTo(Coordinates3D.PLUS_I), Coordinates3D.PLUS_I);
+    checkVector(r.applyTo(Coordinates3D.PLUS_J), Coordinates3D.PLUS_J);
+    checkVector(r.applyTo(Coordinates3D.PLUS_K), Coordinates3D.PLUS_K);
     checkAngle(r.getAngle(), 0);
 
     r = new Rotation(-1, 0, 0, 0, false);
-    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);
-    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);
-    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);
+    checkVector(r.applyTo(Coordinates3D.PLUS_I), Coordinates3D.PLUS_I);
+    checkVector(r.applyTo(Coordinates3D.PLUS_J), Coordinates3D.PLUS_J);
+    checkVector(r.applyTo(Coordinates3D.PLUS_K), Coordinates3D.PLUS_K);
     checkAngle(r.getAngle(), 0);
 
     r = new Rotation(42, 0, 0, 0, true);
-    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);
-    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);
-    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);
+    checkVector(r.applyTo(Coordinates3D.PLUS_I), Coordinates3D.PLUS_I);
+    checkVector(r.applyTo(Coordinates3D.PLUS_J), Coordinates3D.PLUS_J);
+    checkVector(r.applyTo(Coordinates3D.PLUS_K), Coordinates3D.PLUS_K);
     checkAngle(r.getAngle(), 0);
 
   }
@@ -59,95 +59,95 @@ public class RotationTest {
   @Deprecated
   public void testAxisAngleDeprecated() throws MathIllegalArgumentException {
 
-    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3);
-    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);
-    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);
-    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);
+    Rotation r = new Rotation(new Coordinates3D(10, 10, 10), 2 * FastMath.PI / 3);
+    checkVector(r.applyTo(Coordinates3D.PLUS_I), Coordinates3D.PLUS_J);
+    checkVector(r.applyTo(Coordinates3D.PLUS_J), Coordinates3D.PLUS_K);
+    checkVector(r.applyTo(Coordinates3D.PLUS_K), Coordinates3D.PLUS_I);
     double s = 1 / FastMath.sqrt(3);
-    checkVector(r.getAxis(), new Vector3D(s, s, s));
+    checkVector(r.getAxis(), new Coordinates3D(s, s, s));
     checkAngle(r.getAngle(), 2 * FastMath.PI / 3);
 
     try {
-      new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3);
+      new Rotation(new Coordinates3D(0, 0, 0), 2 * FastMath.PI / 3);
       Assert.fail("an exception should have been thrown");
     } catch (MathIllegalArgumentException e) {
     }
 
-    r = new Rotation(Vector3D.PLUS_K, 1.5 * FastMath.PI);
-    checkVector(r.getAxis(), new Vector3D(0, 0, -1));
+    r = new Rotation(Coordinates3D.PLUS_K, 1.5 * FastMath.PI);
+    checkVector(r.getAxis(), new Coordinates3D(0, 0, -1));
     checkAngle(r.getAngle(), 0.5 * FastMath.PI);
 
-    r = new Rotation(Vector3D.PLUS_J, FastMath.PI);
-    checkVector(r.getAxis(), Vector3D.PLUS_J);
+    r = new Rotation(Coordinates3D.PLUS_J, FastMath.PI);
+    checkVector(r.getAxis(), Coordinates3D.PLUS_J);
     checkAngle(r.getAngle(), FastMath.PI);
 
-    checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);
+    checkVector(Rotation.IDENTITY.getAxis(), Coordinates3D.PLUS_I);
 
   }
 
   @Test
   public void testAxisAngleVectorOperator() throws MathIllegalArgumentException {
 
-    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3, RotationConvention.VECTOR_OPERATOR);
-    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);
-    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);
-    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);
+    Rotation r = new Rotation(new Coordinates3D(10, 10, 10), 2 * FastMath.PI / 3, RotationConvention.VECTOR_OPERATOR);
+    checkVector(r.applyTo(Coordinates3D.PLUS_I), Coordinates3D.PLUS_J);
+    checkVector(r.applyTo(Coordinates3D.PLUS_J), Coordinates3D.PLUS_K);
+    checkVector(r.applyTo(Coordinates3D.PLUS_K), Coordinates3D.PLUS_I);
     double s = 1 / FastMath.sqrt(3);
-    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Vector3D( s,  s,  s));
-    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Vector3D(-s, -s, -s));
+    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Coordinates3D( s,  s,  s));
+    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Coordinates3D(-s, -s, -s));
     checkAngle(r.getAngle(), 2 * FastMath.PI / 3);
 
     try {
-      new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3, RotationConvention.VECTOR_OPERATOR);
+      new Rotation(new Coordinates3D(0, 0, 0), 2 * FastMath.PI / 3, RotationConvention.VECTOR_OPERATOR);
       Assert.fail("an exception should have been thrown");
     } catch (MathIllegalArgumentException e) {
     }
 
-    r = new Rotation(Vector3D.PLUS_K, 1.5 * FastMath.PI, RotationConvention.VECTOR_OPERATOR);
-    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Vector3D(0, 0, -1));
-    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Vector3D(0, 0, +1));
+    r = new Rotation(Coordinates3D.PLUS_K, 1.5 * FastMath.PI, RotationConvention.VECTOR_OPERATOR);
+    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Coordinates3D(0, 0, -1));
+    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Coordinates3D(0, 0, +1));
     checkAngle(r.getAngle(), 0.5 * FastMath.PI);
 
-    r = new Rotation(Vector3D.PLUS_J, FastMath.PI, RotationConvention.VECTOR_OPERATOR);
-    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), Vector3D.PLUS_J);
-    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), Vector3D.MINUS_J);
+    r = new Rotation(Coordinates3D.PLUS_J, FastMath.PI, RotationConvention.VECTOR_OPERATOR);
+    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), Coordinates3D.PLUS_J);
+    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), Coordinates3D.MINUS_J);
     checkAngle(r.getAngle(), FastMath.PI);
 
-    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.VECTOR_OPERATOR), Vector3D.PLUS_I);
-    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.FRAME_TRANSFORM), Vector3D.MINUS_I);
+    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.VECTOR_OPERATOR), Coordinates3D.PLUS_I);
+    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.FRAME_TRANSFORM), Coordinates3D.MINUS_I);
 
   }
 
   @Test
   public void testAxisAngleFrameTransform() throws MathIllegalArgumentException {
 
-    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3, RotationConvention.FRAME_TRANSFORM);
-    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);
-    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);
-    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);
+    Rotation r = new Rotation(new Coordinates3D(10, 10, 10), 2 * FastMath.PI / 3, RotationConvention.FRAME_TRANSFORM);
+    checkVector(r.applyTo(Coordinates3D.PLUS_I), Coordinates3D.PLUS_K);
+    checkVector(r.applyTo(Coordinates3D.PLUS_J), Coordinates3D.PLUS_I);
+    checkVector(r.applyTo(Coordinates3D.PLUS_K), Coordinates3D.PLUS_J);
     double s = 1 / FastMath.sqrt(3);
-    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Vector3D( s,  s,  s));
-    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Vector3D(-s, -s, -s));
+    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Coordinates3D( s,  s,  s));
+    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Coordinates3D(-s, -s, -s));
     checkAngle(r.getAngle(), 2 * FastMath.PI / 3);
 
     try {
-      new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3, RotationConvention.FRAME_TRANSFORM);
+      new Rotation(new Coordinates3D(0, 0, 0), 2 * FastMath.PI / 3, RotationConvention.FRAME_TRANSFORM);
       Assert.fail("an exception should have been thrown");
     } catch (MathIllegalArgumentException e) {
     }
 
-    r = new Rotation(Vector3D.PLUS_K, 1.5 * FastMath.PI, RotationConvention.FRAME_TRANSFORM);
-    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Vector3D(0, 0, -1));
-    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Vector3D(0, 0, +1));
+    r = new Rotation(Coordinates3D.PLUS_K, 1.5 * FastMath.PI, RotationConvention.FRAME_TRANSFORM);
+    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Coordinates3D(0, 0, -1));
+    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Coordinates3D(0, 0, +1));
     checkAngle(r.getAngle(), 0.5 * FastMath.PI);
 
-    r = new Rotation(Vector3D.PLUS_J, FastMath.PI, RotationConvention.FRAME_TRANSFORM);
-    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), Vector3D.PLUS_J);
-    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), Vector3D.MINUS_J);
+    r = new Rotation(Coordinates3D.PLUS_J, FastMath.PI, RotationConvention.FRAME_TRANSFORM);
+    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), Coordinates3D.PLUS_J);
+    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), Coordinates3D.MINUS_J);
     checkAngle(r.getAngle(), FastMath.PI);
 
-    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.FRAME_TRANSFORM), Vector3D.MINUS_I);
-    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.VECTOR_OPERATOR), Vector3D.PLUS_I);
+    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.FRAME_TRANSFORM), Coordinates3D.MINUS_I);
+    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.VECTOR_OPERATOR), Coordinates3D.PLUS_I);
 
   }
 
@@ -159,7 +159,7 @@ public class RotationTest {
     checkRotation(reverted.applyTo(r), 1, 0, 0, 0);
     Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);
     Assert.assertEquals(-1,
-                        Vector3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),
+                        Coordinates3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),
                                            reverted.getAxis(RotationConvention.VECTOR_OPERATOR)),
                         1.0e-12);
   }
@@ -172,7 +172,7 @@ public class RotationTest {
     checkRotation(reverted.compose(r, RotationConvention.VECTOR_OPERATOR), 1, 0, 0, 0);
     Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);
     Assert.assertEquals(-1,
-                        Vector3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),
+                        Coordinates3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),
                                            reverted.getAxis(RotationConvention.VECTOR_OPERATOR)),
                         1.0e-12);
   }
@@ -185,7 +185,7 @@ public class RotationTest {
     checkRotation(reverted.compose(r, RotationConvention.FRAME_TRANSFORM), 1, 0, 0, 0);
     Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);
     Assert.assertEquals(-1,
-                        Vector3D.dotProduct(r.getAxis(RotationConvention.FRAME_TRANSFORM),
+                        Coordinates3D.dotProduct(r.getAxis(RotationConvention.FRAME_TRANSFORM),
                                            reverted.getAxis(RotationConvention.FRAME_TRANSFORM)),
                         1.0e-12);
   }
@@ -193,15 +193,15 @@ public class RotationTest {
   @Test
   public void testVectorOnePair() throws MathArithmeticException {
 
-    Vector3D u = new Vector3D(3, 2, 1);
-    Vector3D v = new Vector3D(-4, 2, 2);
+    Coordinates3D u = new Coordinates3D(3, 2, 1);
+    Coordinates3D v = new Coordinates3D(-4, 2, 2);
     Rotation r = new Rotation(u, v);
     checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));
 
     checkAngle(new Rotation(u, u.negate()).getAngle(), FastMath.PI);
 
     try {
-        new Rotation(u, Vector3D.ZERO);
+        new Rotation(u, Coordinates3D.ZERO);
         Assert.fail("an exception should have been thrown");
     } catch (MathArithmeticException e) {
         // expected behavior
@@ -212,36 +212,36 @@ public class RotationTest {
   @Test
   public void testVectorTwoPairs() throws MathArithmeticException {
 
-    Vector3D u1 = new Vector3D(3, 0, 0);
-    Vector3D u2 = new Vector3D(0, 5, 0);
-    Vector3D v1 = new Vector3D(0, 0, 2);
-    Vector3D v2 = new Vector3D(-2, 0, 2);
+    Coordinates3D u1 = new Coordinates3D(3, 0, 0);
+    Coordinates3D u2 = new Coordinates3D(0, 5, 0);
+    Coordinates3D v1 = new Coordinates3D(0, 0, 2);
+    Coordinates3D v2 = new Coordinates3D(-2, 0, 2);
     Rotation r = new Rotation(u1, u2, v1, v2);
-    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);
-    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);
+    checkVector(r.applyTo(Coordinates3D.PLUS_I), Coordinates3D.PLUS_K);
+    checkVector(r.applyTo(Coordinates3D.PLUS_J), Coordinates3D.MINUS_I);
 
     r = new Rotation(u1, u2, u1.negate(), u2.negate());
-    Vector3D axis = r.getAxis(RotationConvention.VECTOR_OPERATOR);
-    if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {
-      checkVector(axis, Vector3D.PLUS_K);
+    Coordinates3D axis = r.getAxis(RotationConvention.VECTOR_OPERATOR);
+    if (Coordinates3D.dotProduct(axis, Coordinates3D.PLUS_K) > 0) {
+      checkVector(axis, Coordinates3D.PLUS_K);
     } else {
-      checkVector(axis, Vector3D.MINUS_K);
+      checkVector(axis, Coordinates3D.MINUS_K);
     }
     checkAngle(r.getAngle(), FastMath.PI);
 
     double sqrt = FastMath.sqrt(2) / 2;
-    r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,
-                     new Vector3D(0.5, 0.5,  sqrt),
-                     new Vector3D(0.5, 0.5, -sqrt));
+    r = new Rotation(Coordinates3D.PLUS_I,  Coordinates3D.PLUS_J,
+                     new Coordinates3D(0.5, 0.5,  sqrt),
+                     new Coordinates3D(0.5, 0.5, -sqrt));
     checkRotation(r, sqrt, 0.5, 0.5, 0);
 
-    r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2));
+    r = new Rotation(u1, u2, u1, Coordinates3D.crossProduct(u1, u2));
     checkRotation(r, sqrt, -sqrt, 0, 0);
 
     checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);
 
     try {
-        new Rotation(u1, u2, Vector3D.ZERO, v2);
+        new Rotation(u1, u2, Coordinates3D.ZERO, v2);
         Assert.fail("an exception should have been thrown");
     } catch (MathArithmeticException e) {
       // expected behavior
@@ -317,9 +317,9 @@ public class RotationTest {
                       { 0.0, 0.0, 1.0 },
                       { 1.0, 0.0, 0.0 } };
     Rotation r = new Rotation(m1, 1.0e-7);
-    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);
-    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);
-    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);
+    checkVector(r.applyTo(Coordinates3D.PLUS_I), Coordinates3D.PLUS_K);
+    checkVector(r.applyTo(Coordinates3D.PLUS_J), Coordinates3D.PLUS_I);
+    checkVector(r.applyTo(Coordinates3D.PLUS_K), Coordinates3D.PLUS_J);
 
     double[][] m2 = { { 0.83203, -0.55012, -0.07139 },
                       { 0.48293,  0.78164, -0.39474 },
@@ -370,12 +370,12 @@ public class RotationTest {
       }
     }
 
-    checkVector(r.applyTo(Vector3D.PLUS_I),
-                new Vector3D(m3[0][0], m3[1][0], m3[2][0]));
-    checkVector(r.applyTo(Vector3D.PLUS_J),
-                new Vector3D(m3[0][1], m3[1][1], m3[2][1]));
-    checkVector(r.applyTo(Vector3D.PLUS_K),
-                new Vector3D(m3[0][2], m3[1][2], m3[2][2]));
+    checkVector(r.applyTo(Coordinates3D.PLUS_I),
+                new Coordinates3D(m3[0][0], m3[1][0], m3[2][0]));
+    checkVector(r.applyTo(Coordinates3D.PLUS_J),
+                new Coordinates3D(m3[0][1], m3[1][1], m3[2][1]));
+    checkVector(r.applyTo(Coordinates3D.PLUS_K),
+                new Coordinates3D(m3[0][2], m3[1][2], m3[2][2]));
 
     double[][] m4 = { { 1.0,  0.0,  0.0 },
                       { 0.0, -1.0,  0.0 },
@@ -535,7 +535,7 @@ public class RotationTest {
   @Test
   public void testQuaternion() throws MathIllegalArgumentException {
 
-    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
+    Rotation r1 = new Rotation(new Coordinates3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
     double n = 23.5;
     Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),
                                n * r1.getQ2(), n * r1.getQ3(),
@@ -543,7 +543,7 @@ public class RotationTest {
     for (double x = -0.9; x < 0.9; x += 0.2) {
       for (double y = -0.9; y < 0.9; y += 0.2) {
         for (double z = -0.9; z < 0.9; z += 0.2) {
-          Vector3D u = new Vector3D(x, y, z);
+          Coordinates3D u = new Coordinates3D(x, y, z);
           checkVector(r2.applyTo(u), r1.applyTo(u));
         }
       }
@@ -557,14 +557,14 @@ public class RotationTest {
   @Test
   public void testApplyTo() throws MathIllegalArgumentException {
 
-    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
-    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
+    Rotation r1 = new Rotation(new Coordinates3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
+    Rotation r2 = new Rotation(new Coordinates3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
     Rotation r3 = r2.applyTo(r1);
 
     for (double x = -0.9; x < 0.9; x += 0.2) {
       for (double y = -0.9; y < 0.9; y += 0.2) {
         for (double z = -0.9; z < 0.9; z += 0.2) {
-          Vector3D u = new Vector3D(x, y, z);
+          Coordinates3D u = new Coordinates3D(x, y, z);
           checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));
         }
       }
@@ -575,14 +575,14 @@ public class RotationTest {
   @Test
   public void testComposeVectorOperator() throws MathIllegalArgumentException {
 
-    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
-    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
+    Rotation r1 = new Rotation(new Coordinates3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
+    Rotation r2 = new Rotation(new Coordinates3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
     Rotation r3 = r2.compose(r1, RotationConvention.VECTOR_OPERATOR);
 
     for (double x = -0.9; x < 0.9; x += 0.2) {
       for (double y = -0.9; y < 0.9; y += 0.2) {
         for (double z = -0.9; z < 0.9; z += 0.2) {
-          Vector3D u = new Vector3D(x, y, z);
+          Coordinates3D u = new Coordinates3D(x, y, z);
           checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));
         }
       }
@@ -593,8 +593,8 @@ public class RotationTest {
   @Test
   public void testComposeFrameTransform() throws MathIllegalArgumentException {
 
-    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7, RotationConvention.FRAME_TRANSFORM);
-    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3, RotationConvention.FRAME_TRANSFORM);
+    Rotation r1 = new Rotation(new Coordinates3D(2, -3, 5), 1.7, RotationConvention.FRAME_TRANSFORM);
+    Rotation r2 = new Rotation(new Coordinates3D(-1, 3, 2), 0.3, RotationConvention.FRAME_TRANSFORM);
     Rotation r3 = r2.compose(r1, RotationConvention.FRAME_TRANSFORM);
     Rotation r4 = r1.compose(r2, RotationConvention.VECTOR_OPERATOR);
     Assert.assertEquals(0.0, Rotation.distance(r3, r4), 1.0e-15);
@@ -602,7 +602,7 @@ public class RotationTest {
     for (double x = -0.9; x < 0.9; x += 0.2) {
       for (double y = -0.9; y < 0.9; y += 0.2) {
         for (double z = -0.9; z < 0.9; z += 0.2) {
-          Vector3D u = new Vector3D(x, y, z);
+          Coordinates3D u = new Coordinates3D(x, y, z);
           checkVector(r1.applyTo(r2.applyTo(u)), r3.applyTo(u));
         }
       }
@@ -613,14 +613,14 @@ public class RotationTest {
   @Test
   public void testApplyInverseToRotation() throws MathIllegalArgumentException {
 
-    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
-    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
+    Rotation r1 = new Rotation(new Coordinates3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
+    Rotation r2 = new Rotation(new Coordinates3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
     Rotation r3 = r2.applyInverseTo(r1);
 
     for (double x = -0.9; x < 0.9; x += 0.2) {
       for (double y = -0.9; y < 0.9; y += 0.2) {
         for (double z = -0.9; z < 0.9; z += 0.2) {
-          Vector3D u = new Vector3D(x, y, z);
+          Coordinates3D u = new Coordinates3D(x, y, z);
           checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));
         }
       }
@@ -631,14 +631,14 @@ public class RotationTest {
   @Test
   public void testComposeInverseVectorOperator() throws MathIllegalArgumentException {
 
-    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
-    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
+    Rotation r1 = new Rotation(new Coordinates3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
+    Rotation r2 = new Rotation(new Coordinates3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
     Rotation r3 = r2.composeInverse(r1, RotationConvention.VECTOR_OPERATOR);
 
     for (double x = -0.9; x < 0.9; x += 0.2) {
       for (double y = -0.9; y < 0.9; y += 0.2) {
         for (double z = -0.9; z < 0.9; z += 0.2) {
-          Vector3D u = new Vector3D(x, y, z);
+          Coordinates3D u = new Coordinates3D(x, y, z);
           checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));
         }
       }
@@ -649,8 +649,8 @@ public class RotationTest {
   @Test
   public void testComposeInverseFrameTransform() throws MathIllegalArgumentException {
 
-    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7, RotationConvention.FRAME_TRANSFORM);
-    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3, RotationConvention.FRAME_TRANSFORM);
+    Rotation r1 = new Rotation(new Coordinates3D(2, -3, 5), 1.7, RotationConvention.FRAME_TRANSFORM);
+    Rotation r2 = new Rotation(new Coordinates3D(-1, 3, 2), 0.3, RotationConvention.FRAME_TRANSFORM);
     Rotation r3 = r2.composeInverse(r1, RotationConvention.FRAME_TRANSFORM);
     Rotation r4 = r1.revert().composeInverse(r2.revert(), RotationConvention.VECTOR_OPERATOR);
     Assert.assertEquals(0.0, Rotation.distance(r3, r4), 1.0e-15);
@@ -658,7 +658,7 @@ public class RotationTest {
     for (double x = -0.9; x < 0.9; x += 0.2) {
       for (double y = -0.9; y < 0.9; y += 0.2) {
         for (double z = -0.9; z < 0.9; z += 0.2) {
-          Vector3D u = new Vector3D(x, y, z);
+          Coordinates3D u = new Coordinates3D(x, y, z);
           checkVector(r1.applyTo(r2.applyInverseTo(u)), r3.applyTo(u));
         }
       }
@@ -669,13 +669,13 @@ public class RotationTest {
   @Test
   public void testArray() throws MathIllegalArgumentException {
 
-      Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
+      Rotation r = new Rotation(new Coordinates3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
 
       for (double x = -0.9; x < 0.9; x += 0.2) {
           for (double y = -0.9; y < 0.9; y += 0.2) {
               for (double z = -0.9; z < 0.9; z += 0.2) {
-                  Vector3D u = new Vector3D(x, y, z);
-                  Vector3D v = r.applyTo(u);
+                  Coordinates3D u = new Coordinates3D(x, y, z);
+                  Coordinates3D v = r.applyTo(u);
                   double[] inOut = new double[] { x, y, z };
                   r.applyTo(inOut, inOut);
                   Assert.assertEquals(v.getX(), inOut[0], 1.0e-10);
@@ -694,10 +694,10 @@ public class RotationTest {
   @Test
   public void testApplyInverseTo() throws MathIllegalArgumentException {
 
-    Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
+    Rotation r = new Rotation(new Coordinates3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {
       for (double phi = -1.55; phi < 1.55; phi += 0.2) {
-          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),
+          Coordinates3D u = new Coordinates3D(FastMath.cos(lambda) * FastMath.cos(phi),
                                     FastMath.sin(lambda) * FastMath.cos(phi),
                                     FastMath.sin(phi));
           r.applyInverseTo(r.applyTo(u));
@@ -709,7 +709,7 @@ public class RotationTest {
     r = Rotation.IDENTITY;
     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {
       for (double phi = -1.55; phi < 1.55; phi += 0.2) {
-          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),
+          Coordinates3D u = new Coordinates3D(FastMath.cos(lambda) * FastMath.cos(phi),
                                     FastMath.sin(lambda) * FastMath.cos(phi),
                                     FastMath.sin(phi));
           checkVector(u, r.applyInverseTo(r.applyTo(u)));
@@ -717,10 +717,10 @@ public class RotationTest {
       }
     }
 
-    r = new Rotation(Vector3D.PLUS_K, FastMath.PI, RotationConvention.VECTOR_OPERATOR);
+    r = new Rotation(Coordinates3D.PLUS_K, FastMath.PI, RotationConvention.VECTOR_OPERATOR);
     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {
       for (double phi = -1.55; phi < 1.55; phi += 0.2) {
-          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),
+          Coordinates3D u = new Coordinates3D(FastMath.cos(lambda) * FastMath.cos(phi),
                                     FastMath.sin(lambda) * FastMath.cos(phi),
                                     FastMath.sin(phi));
           checkVector(u, r.applyInverseTo(r.applyTo(u)));
@@ -732,13 +732,13 @@ public class RotationTest {
 
   @Test
   public void testIssue639() throws MathArithmeticException{
-      Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,
+      Coordinates3D u1 = new Coordinates3D(-1321008684645961.0 /  268435456.0,
                                  -5774608829631843.0 /  268435456.0,
                                  -3822921525525679.0 / 4294967296.0);
-      Vector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0,
+      Coordinates3D u2 =new Coordinates3D( -5712344449280879.0 /    2097152.0,
                                  -2275058564560979.0 /    1048576.0,
                                   4423475992255071.0 /      65536.0);
-      Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K);
+      Rotation rot = new Rotation(u1, u2, Coordinates3D.PLUS_I,Coordinates3D.PLUS_K);
       Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15);
       Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1(), 1.0e-15);
       Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2(), 1.0e-15);
@@ -747,11 +747,11 @@ public class RotationTest {
 
   @Test
   public void testIssue801() throws MathArithmeticException {
-      Vector3D u1 = new Vector3D(0.9999988431610581, -0.0015210774290851095, 0.0);
-      Vector3D u2 = new Vector3D(0.0, 0.0, 1.0);
+      Coordinates3D u1 = new Coordinates3D(0.9999988431610581, -0.0015210774290851095, 0.0);
+      Coordinates3D u2 = new Coordinates3D(0.0, 0.0, 1.0);
 
-      Vector3D v1 = new Vector3D(0.9999999999999999, 0.0, 0.0);
-      Vector3D v2 = new Vector3D(0.0, 0.0, -1.0);
+      Coordinates3D v1 = new Coordinates3D(0.9999999999999999, 0.0, 0.0);
+      Coordinates3D v2 = new Coordinates3D(0.0, 0.0, -1.0);
 
       Rotation quat = new Rotation(u1, u2, v1, v2);
       double q2 = quat.getQ0() * quat.getQ0() +
@@ -759,8 +759,8 @@ public class RotationTest {
                   quat.getQ2() * quat.getQ2() +
                   quat.getQ3() * quat.getQ3();
       Assert.assertEquals(1.0, q2, 1.0e-14);
-      Assert.assertEquals(0.0, Vector3D.angle(v1, quat.applyTo(u1)), 1.0e-14);
-      Assert.assertEquals(0.0, Vector3D.angle(v2, quat.applyTo(u2)), 1.0e-14);
+      Assert.assertEquals(0.0, Coordinates3D.angle(v1, quat.applyTo(u1)), 1.0e-14);
+      Assert.assertEquals(0.0, Coordinates3D.angle(v2, quat.applyTo(u2)), 1.0e-14);
 
   }
 
@@ -770,13 +770,13 @@ public class RotationTest {
       final double xRotation = FastMath.toDegrees(30);
       final double yRotation = FastMath.toDegrees(20);
       final double zRotation = FastMath.toDegrees(10);
-      final Vector3D startingVector = Vector3D.PLUS_I;
-      Vector3D appliedIndividually = startingVector;
+      final Coordinates3D startingVector = Coordinates3D.PLUS_I;
+      Coordinates3D appliedIndividually = startingVector;
       appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, zRotation, 0, 0).applyTo(appliedIndividually);
       appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, 0, yRotation, 0).applyTo(appliedIndividually);
       appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, 0, 0, xRotation).applyTo(appliedIndividually);
 
-      final Vector3D bad = new Rotation(order, RotationConvention.FRAME_TRANSFORM, zRotation, yRotation, xRotation).applyTo(startingVector);
+      final Coordinates3D bad = new Rotation(order, RotationConvention.FRAME_TRANSFORM, zRotation, yRotation, xRotation).applyTo(startingVector);
 
       Assert.assertEquals(bad.getX(), appliedIndividually.getX(), 1e-12);
       Assert.assertEquals(bad.getY(), appliedIndividually.getY(), 1e-12);
@@ -789,8 +789,8 @@ public class RotationTest {
       final double xRotation = FastMath.toDegrees(30);
       final double yRotation = FastMath.toDegrees(20);
       final double zRotation = FastMath.toDegrees(10);
-      final Vector3D startingVector = Vector3D.PLUS_I;
-      Vector3D appliedIndividually = startingVector;
+      final Coordinates3D startingVector = Coordinates3D.PLUS_I;
+      Coordinates3D appliedIndividually = startingVector;
       appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, zRotation, 0, 0).applyTo(appliedIndividually);
       appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, 0, yRotation, 0).applyTo(appliedIndividually);
       appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, 0, 0, xRotation).applyTo(appliedIndividually);
@@ -801,14 +801,14 @@ public class RotationTest {
       final Rotation composite = r1.compose(r2.compose(r3,
                                                        RotationConvention.FRAME_TRANSFORM),
                                             RotationConvention.FRAME_TRANSFORM);
-      final Vector3D good = composite.applyTo(startingVector);
+      final Coordinates3D good = composite.applyTo(startingVector);
 
       Assert.assertEquals(good.getX(), appliedIndividually.getX(), 1e-12);
       Assert.assertEquals(good.getY(), appliedIndividually.getY(), 1e-12);
       Assert.assertEquals(good.getZ(), appliedIndividually.getZ(), 1e-12);
   }
 
-  private void checkVector(Vector3D v1, Vector3D v2) {
+  private void checkVector(Coordinates3D v1, Coordinates3D v2) {
     Assert.assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);
   }
 
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SphereGeneratorTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SphereGeneratorTest.java
index 23934a3f5..cae331b6b 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SphereGeneratorTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SphereGeneratorTest.java
@@ -23,7 +23,7 @@ import java.util.List;
 import org.apache.commons.math4.geometry.enclosing.EnclosingBall;
 import org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D;
 import org.apache.commons.math4.geometry.euclidean.threed.SphereGenerator;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.random.UnitSphereRandomVectorGenerator;
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.rng.simple.RandomSource;
@@ -36,8 +36,8 @@ public class SphereGeneratorTest {
 
     @Test
     public void testSupport0Point() {
-        List<Vector3D> support = Arrays.asList(new Vector3D[0]);
-        EnclosingBall<Euclidean3D, Vector3D> sphere = new SphereGenerator().ballOnSupport(support);
+        List<Coordinates3D> support = Arrays.asList(new Coordinates3D[0]);
+        EnclosingBall<Euclidean3D, Coordinates3D> sphere = new SphereGenerator().ballOnSupport(support);
         Assert.assertTrue(sphere.getRadius() < 0);
         Assert.assertEquals(0, sphere.getSupportSize());
         Assert.assertEquals(0, sphere.getSupport().length);
@@ -45,16 +45,16 @@ public class SphereGeneratorTest {
 
     @Test
     public void testSupport1Point() {
-        List<Vector3D> support = Arrays.asList(new Vector3D(1, 2, 3));
-        EnclosingBall<Euclidean3D, Vector3D> sphere = new SphereGenerator().ballOnSupport(support);
+        List<Coordinates3D> support = Arrays.asList(new Coordinates3D(1, 2, 3));
+        EnclosingBall<Euclidean3D, Coordinates3D> sphere = new SphereGenerator().ballOnSupport(support);
         Assert.assertEquals(0.0, sphere.getRadius(), 1.0e-10);
         Assert.assertTrue(sphere.contains(support.get(0)));
         Assert.assertTrue(sphere.contains(support.get(0), 0.5));
-        Assert.assertFalse(sphere.contains(new Vector3D(support.get(0).getX() + 0.1,
+        Assert.assertFalse(sphere.contains(new Coordinates3D(support.get(0).getX() + 0.1,
                                                         support.get(0).getY() + 0.1,
                                                         support.get(0).getZ() + 0.1),
                                            0.001));
-        Assert.assertTrue(sphere.contains(new Vector3D(support.get(0).getX() + 0.1,
+        Assert.assertTrue(sphere.contains(new Coordinates3D(support.get(0).getX() + 0.1,
                                                        support.get(0).getY() + 0.1,
                                                        support.get(0).getZ() + 0.1),
                                           0.5));
@@ -65,73 +65,73 @@ public class SphereGeneratorTest {
 
     @Test
     public void testSupport2Points() {
-        List<Vector3D> support = Arrays.asList(new Vector3D(1, 0, 0),
-                                               new Vector3D(3, 0, 0));
-        EnclosingBall<Euclidean3D, Vector3D> sphere = new SphereGenerator().ballOnSupport(support);
+        List<Coordinates3D> support = Arrays.asList(new Coordinates3D(1, 0, 0),
+                                               new Coordinates3D(3, 0, 0));
+        EnclosingBall<Euclidean3D, Coordinates3D> sphere = new SphereGenerator().ballOnSupport(support);
         Assert.assertEquals(1.0, sphere.getRadius(), 1.0e-10);
         int i = 0;
-        for (Vector3D v : support) {
+        for (Coordinates3D v : support) {
             Assert.assertTrue(sphere.contains(v));
             Assert.assertEquals(1.0, v.distance(sphere.getCenter()), 1.0e-10);
             Assert.assertTrue(v == sphere.getSupport()[i++]);
         }
-        Assert.assertTrue(sphere.contains(new Vector3D(2, 0.9, 0)));
-        Assert.assertFalse(sphere.contains(Vector3D.ZERO));
-        Assert.assertEquals(0.0, new Vector3D(2, 0, 0).distance(sphere.getCenter()), 1.0e-10);
+        Assert.assertTrue(sphere.contains(new Coordinates3D(2, 0.9, 0)));
+        Assert.assertFalse(sphere.contains(Coordinates3D.ZERO));
+        Assert.assertEquals(0.0, new Coordinates3D(2, 0, 0).distance(sphere.getCenter()), 1.0e-10);
         Assert.assertEquals(2, sphere.getSupportSize());
     }
 
     @Test
     public void testSupport3Points() {
-        List<Vector3D> support = Arrays.asList(new Vector3D(1, 0, 0),
-                                               new Vector3D(3, 0, 0),
-                                               new Vector3D(2, 2, 0));
-        EnclosingBall<Euclidean3D, Vector3D> sphere = new SphereGenerator().ballOnSupport(support);
+        List<Coordinates3D> support = Arrays.asList(new Coordinates3D(1, 0, 0),
+                                               new Coordinates3D(3, 0, 0),
+                                               new Coordinates3D(2, 2, 0));
+        EnclosingBall<Euclidean3D, Coordinates3D> sphere = new SphereGenerator().ballOnSupport(support);
         Assert.assertEquals(5.0 / 4.0, sphere.getRadius(), 1.0e-10);
         int i = 0;
-        for (Vector3D v : support) {
+        for (Coordinates3D v : support) {
             Assert.assertTrue(sphere.contains(v));
             Assert.assertEquals(5.0 / 4.0, v.distance(sphere.getCenter()), 1.0e-10);
             Assert.assertTrue(v == sphere.getSupport()[i++]);
         }
-        Assert.assertTrue(sphere.contains(new Vector3D(2, 0.9, 0)));
-        Assert.assertFalse(sphere.contains(new Vector3D(0.9,  0, 0)));
-        Assert.assertFalse(sphere.contains(new Vector3D(3.1,  0, 0)));
-        Assert.assertTrue(sphere.contains(new Vector3D(2.0, -0.499, 0)));
-        Assert.assertFalse(sphere.contains(new Vector3D(2.0, -0.501, 0)));
-        Assert.assertTrue(sphere.contains(new Vector3D(2.0, 3.0 / 4.0, -1.249)));
-        Assert.assertFalse(sphere.contains(new Vector3D(2.0, 3.0 / 4.0, -1.251)));
-        Assert.assertEquals(0.0, new Vector3D(2.0, 3.0 / 4.0, 0).distance(sphere.getCenter()), 1.0e-10);
+        Assert.assertTrue(sphere.contains(new Coordinates3D(2, 0.9, 0)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D(0.9,  0, 0)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D(3.1,  0, 0)));
+        Assert.assertTrue(sphere.contains(new Coordinates3D(2.0, -0.499, 0)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D(2.0, -0.501, 0)));
+        Assert.assertTrue(sphere.contains(new Coordinates3D(2.0, 3.0 / 4.0, -1.249)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D(2.0, 3.0 / 4.0, -1.251)));
+        Assert.assertEquals(0.0, new Coordinates3D(2.0, 3.0 / 4.0, 0).distance(sphere.getCenter()), 1.0e-10);
         Assert.assertEquals(3, sphere.getSupportSize());
     }
 
     @Test
     public void testSupport4Points() {
-        List<Vector3D> support = Arrays.asList(new Vector3D(17, 14,  18),
-                                               new Vector3D(11, 14,  22),
-                                               new Vector3D( 2, 22,  17),
-                                               new Vector3D(22, 11, -10));
-        EnclosingBall<Euclidean3D, Vector3D> sphere = new SphereGenerator().ballOnSupport(support);
+        List<Coordinates3D> support = Arrays.asList(new Coordinates3D(17, 14,  18),
+                                               new Coordinates3D(11, 14,  22),
+                                               new Coordinates3D( 2, 22,  17),
+                                               new Coordinates3D(22, 11, -10));
+        EnclosingBall<Euclidean3D, Coordinates3D> sphere = new SphereGenerator().ballOnSupport(support);
         Assert.assertEquals(25.0, sphere.getRadius(), 1.0e-10);
         int i = 0;
-        for (Vector3D v : support) {
+        for (Coordinates3D v : support) {
             Assert.assertTrue(sphere.contains(v));
             Assert.assertEquals(25.0, v.distance(sphere.getCenter()), 1.0e-10);
             Assert.assertTrue(v == sphere.getSupport()[i++]);
         }
-        Assert.assertTrue(sphere.contains (new Vector3D(-22.999, 2, 2)));
-        Assert.assertFalse(sphere.contains(new Vector3D(-23.001, 2, 2)));
-        Assert.assertTrue(sphere.contains (new Vector3D( 26.999, 2, 2)));
-        Assert.assertFalse(sphere.contains(new Vector3D( 27.001, 2, 2)));
-        Assert.assertTrue(sphere.contains (new Vector3D(2, -22.999, 2)));
-        Assert.assertFalse(sphere.contains(new Vector3D(2, -23.001, 2)));
-        Assert.assertTrue(sphere.contains (new Vector3D(2,  26.999, 2)));
-        Assert.assertFalse(sphere.contains(new Vector3D(2,  27.001, 2)));
-        Assert.assertTrue(sphere.contains (new Vector3D(2, 2, -22.999)));
-        Assert.assertFalse(sphere.contains(new Vector3D(2, 2, -23.001)));
-        Assert.assertTrue(sphere.contains (new Vector3D(2, 2,  26.999)));
-        Assert.assertFalse(sphere.contains(new Vector3D(2, 2,  27.001)));
-        Assert.assertEquals(0.0, new Vector3D(2.0, 2.0, 2.0).distance(sphere.getCenter()), 1.0e-10);
+        Assert.assertTrue(sphere.contains (new Coordinates3D(-22.999, 2, 2)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D(-23.001, 2, 2)));
+        Assert.assertTrue(sphere.contains (new Coordinates3D( 26.999, 2, 2)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D( 27.001, 2, 2)));
+        Assert.assertTrue(sphere.contains (new Coordinates3D(2, -22.999, 2)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D(2, -23.001, 2)));
+        Assert.assertTrue(sphere.contains (new Coordinates3D(2,  26.999, 2)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D(2,  27.001, 2)));
+        Assert.assertTrue(sphere.contains (new Coordinates3D(2, 2, -22.999)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D(2, 2, -23.001)));
+        Assert.assertTrue(sphere.contains (new Coordinates3D(2, 2,  26.999)));
+        Assert.assertFalse(sphere.contains(new Coordinates3D(2, 2,  27.001)));
+        Assert.assertEquals(0.0, new Coordinates3D(2.0, 2.0, 2.0).distance(sphere.getCenter()), 1.0e-10);
         Assert.assertEquals(4, sphere.getSupportSize());
     }
 
@@ -143,12 +143,12 @@ public class SphereGeneratorTest {
         for (int i = 0; i < 100; ++i) {
             double d = 25 * random.nextDouble();
             double refRadius = 10 * random.nextDouble();
-            Vector3D refCenter = new Vector3D(d, new Vector3D(sr.nextVector()));
-            List<Vector3D> support = new ArrayList<>();
+            Coordinates3D refCenter = new Coordinates3D(d, new Coordinates3D(sr.nextVector()));
+            List<Coordinates3D> support = new ArrayList<>();
             for (int j = 0; j < 5; ++j) {
-                support.add(new Vector3D(1.0, refCenter, refRadius, new Vector3D(sr.nextVector())));
+                support.add(new Coordinates3D(1.0, refCenter, refRadius, new Coordinates3D(sr.nextVector())));
             }
-            EnclosingBall<Euclidean3D, Vector3D> sphere = new SphereGenerator().ballOnSupport(support);
+            EnclosingBall<Euclidean3D, Coordinates3D> sphere = new SphereGenerator().ballOnSupport(support);
             Assert.assertEquals(0.0, refCenter.distance(sphere.getCenter()), 4e-7 * refRadius);
             Assert.assertEquals(refRadius, sphere.getRadius(), 1e-7 * refRadius);
         }
@@ -156,20 +156,20 @@ public class SphereGeneratorTest {
 
     @Test
     public void testDegeneratedCase() {
-       final List<Vector3D> support =
-               Arrays.asList(new Vector3D(FastMath.scalb(-8039905610797991.0, -50),   //   -7.140870659936730
+       final List<Coordinates3D> support =
+               Arrays.asList(new Coordinates3D(FastMath.scalb(-8039905610797991.0, -50),   //   -7.140870659936730
                                           FastMath.scalb(-4663475464714142.0, -48),   //  -16.567993074240455
                                           FastMath.scalb( 6592658872616184.0, -49)),  //   11.710914678204503
-                             new Vector3D(FastMath.scalb(-8036658568968473.0, -50),   //   -7.137986707455888
+                             new Coordinates3D(FastMath.scalb(-8036658568968473.0, -50),   //   -7.137986707455888
                                           FastMath.scalb(-4664256346424880.0, -48),   //  -16.570767323375720
                                           FastMath.scalb( 6591357011730307.0, -49)),  //  11.708602108715928)
-                             new Vector3D(FastMath.scalb(-8037820142977230.0, -50),   //   -7.139018392423351
+                             new Coordinates3D(FastMath.scalb(-8037820142977230.0, -50),   //   -7.139018392423351
                                           FastMath.scalb(-4665280434237813.0, -48),   //  -16.574405614157020
                                           FastMath.scalb( 6592435966112099.0, -49)),  //   11.710518716711425
-                             new Vector3D(FastMath.scalb(-8038007803611611.0, -50),   //   -7.139185068549035
+                             new Coordinates3D(FastMath.scalb(-8038007803611611.0, -50),   //   -7.139185068549035
                                           FastMath.scalb(-4664291215918380.0, -48),   //  -16.570891204702250
                                           FastMath.scalb( 6595270610894208.0, -49))); //   11.715554057357394
-        EnclosingBall<Euclidean3D, Vector3D> sphere = new SphereGenerator().ballOnSupport(support);
+        EnclosingBall<Euclidean3D, Coordinates3D> sphere = new SphereGenerator().ballOnSupport(support);
 
         // the following values have been computed using Emacs calc with exact arithmetic from the
         // rational representation corresponding to the scalb calls (i.e. -8039905610797991/2^50, ...)
@@ -180,7 +180,7 @@ public class SphereGeneratorTest {
         Assert.assertEquals(-16.571096474251747245361467833760, sphere.getCenter().getY(), 1.0e-20);
         Assert.assertEquals( 11.711945804096960876521111630800, sphere.getCenter().getZ(), 1.0e-20);
 
-        for (Vector3D v : support) {
+        for (Coordinates3D v : support) {
             Assert.assertTrue(sphere.contains(v, 1.0e-14));
         }
 
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SphericalCoordinatesTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SphericalCoordinatesTest.java
index 48e5fca39..36c9ed47d 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SphericalCoordinatesTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SphericalCoordinatesTest.java
@@ -21,7 +21,7 @@ import org.apache.commons.math4.TestUtils;
 import org.apache.commons.math4.analysis.differentiation.DerivativeStructure;
 import org.apache.commons.math4.exception.DimensionMismatchException;
 import org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.util.FastMath;
 import org.junit.Assert;
 import org.junit.Test;
@@ -32,43 +32,43 @@ public class SphericalCoordinatesTest {
     public void testCoordinatesStoC() throws DimensionMismatchException {
         double piO2 = 0.5 * FastMath.PI;
         SphericalCoordinates sc1 = new SphericalCoordinates(2.0, 0, piO2);
-        Assert.assertEquals(0, sc1.getCartesian().distance(new Vector3D(2, 0, 0)), 1.0e-10);
+        Assert.assertEquals(0, sc1.getCartesian().distance(new Coordinates3D(2, 0, 0)), 1.0e-10);
         SphericalCoordinates sc2 = new SphericalCoordinates(2.0, piO2, piO2);
-        Assert.assertEquals(0, sc2.getCartesian().distance(new Vector3D(0, 2, 0)), 1.0e-10);
+        Assert.assertEquals(0, sc2.getCartesian().distance(new Coordinates3D(0, 2, 0)), 1.0e-10);
         SphericalCoordinates sc3 = new SphericalCoordinates(2.0, FastMath.PI, piO2);
-        Assert.assertEquals(0, sc3.getCartesian().distance(new Vector3D(-2, 0, 0)), 1.0e-10);
+        Assert.assertEquals(0, sc3.getCartesian().distance(new Coordinates3D(-2, 0, 0)), 1.0e-10);
         SphericalCoordinates sc4 = new SphericalCoordinates(2.0, -piO2, piO2);
-        Assert.assertEquals(0, sc4.getCartesian().distance(new Vector3D(0, -2, 0)), 1.0e-10);
+        Assert.assertEquals(0, sc4.getCartesian().distance(new Coordinates3D(0, -2, 0)), 1.0e-10);
         SphericalCoordinates sc5 = new SphericalCoordinates(2.0, 1.23456, 0);
-        Assert.assertEquals(0, sc5.getCartesian().distance(new Vector3D(0, 0, 2)), 1.0e-10);
+        Assert.assertEquals(0, sc5.getCartesian().distance(new Coordinates3D(0, 0, 2)), 1.0e-10);
         SphericalCoordinates sc6 = new SphericalCoordinates(2.0, 6.54321, FastMath.PI);
-        Assert.assertEquals(0, sc6.getCartesian().distance(new Vector3D(0, 0, -2)), 1.0e-10);
+        Assert.assertEquals(0, sc6.getCartesian().distance(new Coordinates3D(0, 0, -2)), 1.0e-10);
     }
 
     @Test
     public void testCoordinatesCtoS() throws DimensionMismatchException {
         double piO2 = 0.5 * FastMath.PI;
-        SphericalCoordinates sc1 = new SphericalCoordinates(new Vector3D(2, 0, 0));
+        SphericalCoordinates sc1 = new SphericalCoordinates(new Coordinates3D(2, 0, 0));
         Assert.assertEquals(2,           sc1.getR(),     1.0e-10);
         Assert.assertEquals(0,           sc1.getTheta(), 1.0e-10);
         Assert.assertEquals(piO2,        sc1.getPhi(),   1.0e-10);
-        SphericalCoordinates sc2 = new SphericalCoordinates(new Vector3D(0, 2, 0));
+        SphericalCoordinates sc2 = new SphericalCoordinates(new Coordinates3D(0, 2, 0));
         Assert.assertEquals(2,           sc2.getR(),     1.0e-10);
         Assert.assertEquals(piO2,        sc2.getTheta(), 1.0e-10);
         Assert.assertEquals(piO2,        sc2.getPhi(),   1.0e-10);
-        SphericalCoordinates sc3 = new SphericalCoordinates(new Vector3D(-2, 0, 0));
+        SphericalCoordinates sc3 = new SphericalCoordinates(new Coordinates3D(-2, 0, 0));
         Assert.assertEquals(2,           sc3.getR(),     1.0e-10);
         Assert.assertEquals(FastMath.PI, sc3.getTheta(), 1.0e-10);
         Assert.assertEquals(piO2,        sc3.getPhi(),   1.0e-10);
-        SphericalCoordinates sc4 = new SphericalCoordinates(new Vector3D(0, -2, 0));
+        SphericalCoordinates sc4 = new SphericalCoordinates(new Coordinates3D(0, -2, 0));
         Assert.assertEquals(2,           sc4.getR(),     1.0e-10);
         Assert.assertEquals(-piO2,       sc4.getTheta(), 1.0e-10);
         Assert.assertEquals(piO2,        sc4.getPhi(),   1.0e-10);
-        SphericalCoordinates sc5 = new SphericalCoordinates(new Vector3D(0, 0, 2));
+        SphericalCoordinates sc5 = new SphericalCoordinates(new Coordinates3D(0, 0, 2));
         Assert.assertEquals(2,           sc5.getR(),     1.0e-10);
         //  don't check theta on poles, as it is singular
         Assert.assertEquals(0,           sc5.getPhi(),   1.0e-10);
-        SphericalCoordinates sc6 = new SphericalCoordinates(new Vector3D(0, 0, -2));
+        SphericalCoordinates sc6 = new SphericalCoordinates(new Coordinates3D(0, 0, -2));
         Assert.assertEquals(2,           sc6.getR(),     1.0e-10);
         //  don't check theta on poles, as it is singular
         Assert.assertEquals(FastMath.PI, sc6.getPhi(),   1.0e-10);
@@ -93,11 +93,11 @@ public class SphericalCoordinatesTest {
                     DerivativeStructure cvalue = valueCartesian(new DerivativeStructure(3, 1, 0, sc.getCartesian().getX()),
                                                                 new DerivativeStructure(3, 1, 1, sc.getCartesian().getY()),
                                                                 new DerivativeStructure(3, 1, 2, sc.getCartesian().getZ()));
-                    Vector3D refCGradient = new Vector3D(cvalue.getPartialDerivative(1, 0, 0),
+                    Coordinates3D refCGradient = new Coordinates3D(cvalue.getPartialDerivative(1, 0, 0),
                                                          cvalue.getPartialDerivative(0, 1, 0),
                                                          cvalue.getPartialDerivative(0, 0, 1));
 
-                    Vector3D testCGradient = new Vector3D(sc.toCartesianGradient(sGradient));
+                    Coordinates3D testCGradient = new Coordinates3D(sc.toCartesianGradient(sGradient));
 
                     Assert.assertEquals(0, testCGradient.distance(refCGradient) / refCGradient.getNorm(), 5.0e-14);
 
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SubLineTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SubLineTest.java
index 2c2b17d01..cb967fb2a 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SubLineTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/SubLineTest.java
@@ -24,7 +24,7 @@ import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
 import org.apache.commons.math4.geometry.euclidean.threed.Line;
 import org.apache.commons.math4.geometry.euclidean.threed.Segment;
 import org.apache.commons.math4.geometry.euclidean.threed.SubLine;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.partitioning.RegionFactory;
 import org.junit.Assert;
 import org.junit.Test;
@@ -33,19 +33,19 @@ public class SubLineTest {
 
     @Test
     public void testEndPoints() throws MathIllegalArgumentException {
-        Vector3D p1 = new Vector3D(-1, -7, 2);
-        Vector3D p2 = new Vector3D(7, -1, 0);
+        Coordinates3D p1 = new Coordinates3D(-1, -7, 2);
+        Coordinates3D p2 = new Coordinates3D(7, -1, 0);
         Segment segment = new Segment(p1, p2, new Line(p1, p2, 1.0e-10));
         SubLine sub = new SubLine(segment);
         List<Segment> segments = sub.getSegments();
         Assert.assertEquals(1, segments.size());
-        Assert.assertEquals(0.0, new Vector3D(-1, -7, 2).distance(segments.get(0).getStart()), 1.0e-10);
-        Assert.assertEquals(0.0, new Vector3D( 7, -1, 0).distance(segments.get(0).getEnd()), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates3D(-1, -7, 2).distance(segments.get(0).getStart()), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates3D( 7, -1, 0).distance(segments.get(0).getEnd()), 1.0e-10);
     }
 
     @Test
     public void testNoEndPoints() throws MathIllegalArgumentException {
-        SubLine wholeLine = new Line(new Vector3D(-1, 7, 2), new Vector3D(7, 1, 0), 1.0e-10).wholeLine();
+        SubLine wholeLine = new Line(new Coordinates3D(-1, 7, 2), new Coordinates3D(7, 1, 0), 1.0e-10).wholeLine();
         List<Segment> segments = wholeLine.getSegments();
         Assert.assertEquals(1, segments.size());
         Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&
@@ -64,7 +64,7 @@ public class SubLineTest {
 
     @Test
     public void testNoSegments() throws MathIllegalArgumentException {
-        SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0), 1.0e-10),
+        SubLine empty = new SubLine(new Line(new Coordinates3D(-1, -7, 2), new Coordinates3D(7, -1, 0), 1.0e-10),
                                     (IntervalsSet) new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet(1.0e-10)));
         List<Segment> segments = empty.getSegments();
         Assert.assertEquals(0, segments.size());
@@ -72,7 +72,7 @@ public class SubLineTest {
 
     @Test
     public void testSeveralSegments() throws MathIllegalArgumentException {
-        SubLine twoSubs = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0), 1.0e-10),
+        SubLine twoSubs = new SubLine(new Line(new Coordinates3D(-1, -7, 2), new Coordinates3D(7, -1, 0), 1.0e-10),
                                       (IntervalsSet) new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2, 1.0e-10),
                                                                                             new IntervalsSet(3, 4, 1.0e-10)));
         List<Segment> segments = twoSubs.getSegments();
@@ -81,7 +81,7 @@ public class SubLineTest {
 
     @Test
     public void testHalfInfiniteNeg() throws MathIllegalArgumentException {
-        SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2), 1.0e-10),
+        SubLine empty = new SubLine(new Line(new Coordinates3D(-1, -7, 2), new Coordinates3D(7, -1, -2), 1.0e-10),
                                     new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0, 1.0e-10));
         List<Segment> segments = empty.getSegments();
         Assert.assertEquals(1, segments.size());
@@ -91,16 +91,16 @@ public class SubLineTest {
                           segments.get(0).getStart().getY() < 0);
         Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getZ()) &&
                           segments.get(0).getStart().getZ() > 0);
-        Assert.assertEquals(0.0, new Vector3D(3, -4, 0).distance(segments.get(0).getEnd()), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates3D(3, -4, 0).distance(segments.get(0).getEnd()), 1.0e-10);
     }
 
     @Test
     public void testHalfInfinitePos() throws MathIllegalArgumentException {
-        SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2), 1.0e-10),
+        SubLine empty = new SubLine(new Line(new Coordinates3D(-1, -7, 2), new Coordinates3D(7, -1, -2), 1.0e-10),
                                     new IntervalsSet(0.0, Double.POSITIVE_INFINITY, 1.0e-10));
         List<Segment> segments = empty.getSegments();
         Assert.assertEquals(1, segments.size());
-        Assert.assertEquals(0.0, new Vector3D(3, -4, 0).distance(segments.get(0).getStart()), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates3D(3, -4, 0).distance(segments.get(0).getStart()), 1.0e-10);
         Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&
                           segments.get(0).getEnd().getX() > 0);
         Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&
@@ -111,56 +111,56 @@ public class SubLineTest {
 
     @Test
     public void testIntersectionInsideInside() throws MathIllegalArgumentException {
-        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 2, 2), 1.0e-10);
-        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
-        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);
+        SubLine sub1 = new SubLine(new Coordinates3D(1, 1, 1), new Coordinates3D(3, 1, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates3D(2, 0, 0), new Coordinates3D(2, 2, 2), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
+        Assert.assertEquals(0.0, new Coordinates3D(2, 1, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);
     }
 
     @Test
     public void testIntersectionInsideBoundary() throws MathIllegalArgumentException {
-        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1), 1.0e-10);
-        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
+        SubLine sub1 = new SubLine(new Coordinates3D(1, 1, 1), new Coordinates3D(3, 1, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates3D(2, 0, 0), new Coordinates3D(2, 1, 1), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionInsideOutside() throws MathIllegalArgumentException {
-        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5), 1.0e-10);
+        SubLine sub1 = new SubLine(new Coordinates3D(1, 1, 1), new Coordinates3D(3, 1, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates3D(2, 0, 0), new Coordinates3D(2, 0.5, 0.5), 1.0e-10);
         Assert.assertNull(sub1.intersection(sub2, true));
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionBoundaryBoundary() throws MathIllegalArgumentException {
-        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1), 1.0e-10);
-        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
+        SubLine sub1 = new SubLine(new Coordinates3D(1, 1, 1), new Coordinates3D(2, 1, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates3D(2, 0, 0), new Coordinates3D(2, 1, 1), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionBoundaryOutside() throws MathIllegalArgumentException {
-        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5), 1.0e-10);
+        SubLine sub1 = new SubLine(new Coordinates3D(1, 1, 1), new Coordinates3D(2, 1, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates3D(2, 0, 0), new Coordinates3D(2, 0.5, 0.5), 1.0e-10);
         Assert.assertNull(sub1.intersection(sub2, true));
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionOutsideOutside() throws MathIllegalArgumentException {
-        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5), 1.0e-10);
+        SubLine sub1 = new SubLine(new Coordinates3D(1, 1, 1), new Coordinates3D(1.5, 1, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates3D(2, 0, 0), new Coordinates3D(2, 0.5, 0.5), 1.0e-10);
         Assert.assertNull(sub1.intersection(sub2, true));
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionNotIntersecting() throws MathIllegalArgumentException {
-        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5), 1.0e-10);
+        SubLine sub1 = new SubLine(new Coordinates3D(1, 1, 1), new Coordinates3D(1.5, 1, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates3D(2, 3, 0), new Coordinates3D(2, 3, 0.5), 1.0e-10);
         Assert.assertNull(sub1.intersection(sub2, true));
         Assert.assertNull(sub1.intersection(sub2, false));
     }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DFormatAbstractTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DFormatAbstractTest.java
index a8c13e648..048a76965 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DFormatAbstractTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DFormatAbstractTest.java
@@ -22,7 +22,7 @@ import java.text.ParsePosition;
 import java.util.Locale;
 
 import org.apache.commons.math4.exception.MathParseException;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat;
 import org.junit.Test;
 import org.junit.Assert;
@@ -45,7 +45,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void testSimpleNoDecimals() {
-        Vector3D c = new Vector3D(1, 1, 1);
+        Coordinates3D c = new Coordinates3D(1, 1, 1);
         String expected = "{1; 1; 1}";
         String actual = vector3DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -53,7 +53,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void testSimpleWithDecimals() {
-        Vector3D c = new Vector3D(1.23, 1.43, 1.63);
+        Coordinates3D c = new Coordinates3D(1.23, 1.43, 1.63);
         String expected =
             "{1"    + getDecimalCharacter() +
             "23; 1" + getDecimalCharacter() +
@@ -65,7 +65,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void testSimpleWithDecimalsTrunc() {
-        Vector3D c = new Vector3D(1.232323232323, 1.434343434343, 1.633333333333);
+        Coordinates3D c = new Coordinates3D(1.232323232323, 1.434343434343, 1.633333333333);
         String expected =
             "{1"    + getDecimalCharacter() +
             "2323232323; 1" + getDecimalCharacter() +
@@ -77,7 +77,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void testNegativeX() {
-        Vector3D c = new Vector3D(-1.232323232323, 1.43, 1.63);
+        Coordinates3D c = new Coordinates3D(-1.232323232323, 1.43, 1.63);
         String expected =
             "{-1"    + getDecimalCharacter() +
             "2323232323; 1" + getDecimalCharacter() +
@@ -89,7 +89,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void testNegativeY() {
-        Vector3D c = new Vector3D(1.23, -1.434343434343, 1.63);
+        Coordinates3D c = new Coordinates3D(1.23, -1.434343434343, 1.63);
         String expected =
             "{1"    + getDecimalCharacter() +
             "23; -1" + getDecimalCharacter() +
@@ -101,7 +101,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void testNegativeZ() {
-        Vector3D c = new Vector3D(1.23, 1.43, -1.633333333333);
+        Coordinates3D c = new Coordinates3D(1.23, 1.43, -1.633333333333);
         String expected =
             "{1"    + getDecimalCharacter() +
             "23; 1" + getDecimalCharacter() +
@@ -113,7 +113,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void testNonDefaultSetting() {
-        Vector3D c = new Vector3D(1, 1, 1);
+        Coordinates3D c = new Coordinates3D(1, 1, 1);
         String expected = "[1 : 1 : 1]";
         String actual = vector3DFormatSquare.format(c);
         Assert.assertEquals(expected, actual);
@@ -124,7 +124,7 @@ public abstract class Vector3DFormatAbstractTest {
         Locale defaultLocal = Locale.getDefault();
         Locale.setDefault(getLocale());
 
-        Vector3D c = new Vector3D(232.22222222222, -342.3333333333, 432.44444444444);
+        Coordinates3D c = new Coordinates3D(232.22222222222, -342.3333333333, 432.44444444444);
         String expected =
             "{232"    + getDecimalCharacter() +
             "2222222222; -342" + getDecimalCharacter() +
@@ -138,7 +138,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void testNan() {
-        Vector3D c = Vector3D.NaN;
+        Coordinates3D c = Coordinates3D.NaN;
         String expected = "{(NaN); (NaN); (NaN)}";
         String actual = vector3DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -146,7 +146,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void testPositiveInfinity() {
-        Vector3D c = Vector3D.POSITIVE_INFINITY;
+        Coordinates3D c = Coordinates3D.POSITIVE_INFINITY;
         String expected = "{(Infinity); (Infinity); (Infinity)}";
         String actual = vector3DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -154,7 +154,7 @@ public abstract class Vector3DFormatAbstractTest {
 
     @Test
     public void tesNegativeInfinity() {
-        Vector3D c = Vector3D.NEGATIVE_INFINITY;
+        Coordinates3D c = Coordinates3D.NEGATIVE_INFINITY;
         String expected = "{(-Infinity); (-Infinity); (-Infinity)}";
         String actual = vector3DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -163,14 +163,14 @@ public abstract class Vector3DFormatAbstractTest {
     @Test
     public void testParseSimpleNoDecimals() throws MathParseException {
         String source = "{1; 1; 1}";
-        Vector3D expected = new Vector3D(1, 1, 1);
-        Vector3D actual = vector3DFormat.parse(source);
+        Coordinates3D expected = new Coordinates3D(1, 1, 1);
+        Coordinates3D actual = vector3DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
     @Test
     public void testParseIgnoredWhitespace() {
-        Vector3D expected = new Vector3D(1, 1, 1);
+        Coordinates3D expected = new Coordinates3D(1, 1, 1);
         ParsePosition pos1 = new ParsePosition(0);
         String source1 = "{1;1;1}";
         Assert.assertEquals(expected, vector3DFormat.parse(source1, pos1));
@@ -188,8 +188,8 @@ public abstract class Vector3DFormatAbstractTest {
             "23; 1" + getDecimalCharacter() +
             "43; 1" + getDecimalCharacter() +
             "63}";
-        Vector3D expected = new Vector3D(1.23, 1.43, 1.63);
-        Vector3D actual = vector3DFormat.parse(source);
+        Coordinates3D expected = new Coordinates3D(1.23, 1.43, 1.63);
+        Coordinates3D actual = vector3DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -200,8 +200,8 @@ public abstract class Vector3DFormatAbstractTest {
             "2323; 1" + getDecimalCharacter() +
             "4343; 1" + getDecimalCharacter() +
             "6333}";
-        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);
-        Vector3D actual = vector3DFormat.parse(source);
+        Coordinates3D expected = new Coordinates3D(1.2323, 1.4343, 1.6333);
+        Coordinates3D actual = vector3DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -212,8 +212,8 @@ public abstract class Vector3DFormatAbstractTest {
             "2323; 1" + getDecimalCharacter() +
             "4343; 1" + getDecimalCharacter() +
             "6333}";
-        Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);
-        Vector3D actual = vector3DFormat.parse(source);
+        Coordinates3D expected = new Coordinates3D(-1.2323, 1.4343, 1.6333);
+        Coordinates3D actual = vector3DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -224,8 +224,8 @@ public abstract class Vector3DFormatAbstractTest {
             "2323; -1" + getDecimalCharacter() +
             "4343; 1" + getDecimalCharacter() +
             "6333}";
-        Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);
-        Vector3D actual = vector3DFormat.parse(source);
+        Coordinates3D expected = new Coordinates3D(1.2323, -1.4343, 1.6333);
+        Coordinates3D actual = vector3DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -236,8 +236,8 @@ public abstract class Vector3DFormatAbstractTest {
             "2323; 1" + getDecimalCharacter() +
             "4343; -1" + getDecimalCharacter() +
             "6333}";
-        Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);
-        Vector3D actual = vector3DFormat.parse(source);
+        Coordinates3D expected = new Coordinates3D(1.2323, 1.4343, -1.6333);
+        Coordinates3D actual = vector3DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -248,8 +248,8 @@ public abstract class Vector3DFormatAbstractTest {
             "2323; -1" + getDecimalCharacter() +
             "4343; -1" + getDecimalCharacter() +
             "6333}";
-        Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);
-        Vector3D actual = vector3DFormat.parse(source);
+        Coordinates3D expected = new Coordinates3D(-1.2323, -1.4343, -1.6333);
+        Coordinates3D actual = vector3DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -260,8 +260,8 @@ public abstract class Vector3DFormatAbstractTest {
             "0; -1" + getDecimalCharacter() +
             "4343; 1" + getDecimalCharacter() +
             "6333}";
-        Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);
-        Vector3D actual = vector3DFormat.parse(source);
+        Coordinates3D expected = new Coordinates3D(0.0, -1.4343, 1.6333);
+        Coordinates3D actual = vector3DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -272,30 +272,30 @@ public abstract class Vector3DFormatAbstractTest {
             "2323 : 1" + getDecimalCharacter() +
             "4343 : 1" + getDecimalCharacter() +
             "6333]";
-        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);
-        Vector3D actual = vector3DFormatSquare.parse(source);
+        Coordinates3D expected = new Coordinates3D(1.2323, 1.4343, 1.6333);
+        Coordinates3D actual = vector3DFormatSquare.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
     @Test
     public void testParseNan() throws MathParseException {
         String source = "{(NaN); (NaN); (NaN)}";
-        Vector3D actual = vector3DFormat.parse(source);
-        Assert.assertEquals(Vector3D.NaN, actual);
+        Coordinates3D actual = vector3DFormat.parse(source);
+        Assert.assertEquals(Coordinates3D.NaN, actual);
     }
 
     @Test
     public void testParsePositiveInfinity() throws MathParseException {
         String source = "{(Infinity); (Infinity); (Infinity)}";
-        Vector3D actual = vector3DFormat.parse(source);
-        Assert.assertEquals(Vector3D.POSITIVE_INFINITY, actual);
+        Coordinates3D actual = vector3DFormat.parse(source);
+        Assert.assertEquals(Coordinates3D.POSITIVE_INFINITY, actual);
     }
 
     @Test
     public void testParseNegativeInfinity() throws MathParseException {
         String source = "{(-Infinity); (-Infinity); (-Infinity)}";
-        Vector3D actual = vector3DFormat.parse(source);
-        Assert.assertEquals(Vector3D.NEGATIVE_INFINITY, actual);
+        Coordinates3D actual = vector3DFormat.parse(source);
+        Assert.assertEquals(Coordinates3D.NEGATIVE_INFINITY, actual);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DTest.java
index dbf1b3e20..296ade8d2 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/threed/Vector3DTest.java
@@ -27,7 +27,7 @@ import org.apache.commons.math4.exception.DimensionMismatchException;
 import org.apache.commons.math4.exception.MathArithmeticException;
 import org.apache.commons.math4.geometry.Space;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.rng.simple.RandomSource;
 import org.apache.commons.math4.util.FastMath;
@@ -39,27 +39,27 @@ public class Vector3DTest {
     @Test
     public void testConstructors() throws DimensionMismatchException {
         double r = FastMath.sqrt(2) /2;
-        checkVector(new Vector3D(2, new Vector3D(FastMath.PI / 3, -FastMath.PI / 4)),
+        checkVector(new Coordinates3D(2, new Coordinates3D(FastMath.PI / 3, -FastMath.PI / 4)),
                     r, r * FastMath.sqrt(3), -2 * r);
-        checkVector(new Vector3D(2, Vector3D.PLUS_I,
-                                 -3, Vector3D.MINUS_K),
+        checkVector(new Coordinates3D(2, Coordinates3D.PLUS_I,
+                                 -3, Coordinates3D.MINUS_K),
                     2, 0, 3);
-        checkVector(new Vector3D(2, Vector3D.PLUS_I,
-                                 5, Vector3D.PLUS_J,
-                                 -3, Vector3D.MINUS_K),
+        checkVector(new Coordinates3D(2, Coordinates3D.PLUS_I,
+                                 5, Coordinates3D.PLUS_J,
+                                 -3, Coordinates3D.MINUS_K),
                     2, 5, 3);
-        checkVector(new Vector3D(2, Vector3D.PLUS_I,
-                                 5, Vector3D.PLUS_J,
-                                 5, Vector3D.MINUS_J,
-                                 -3, Vector3D.MINUS_K),
+        checkVector(new Coordinates3D(2, Coordinates3D.PLUS_I,
+                                 5, Coordinates3D.PLUS_J,
+                                 5, Coordinates3D.MINUS_J,
+                                 -3, Coordinates3D.MINUS_K),
                     2, 0, 3);
-        checkVector(new Vector3D(new double[] { 2,  5,  -3 }),
+        checkVector(new Coordinates3D(new double[] { 2,  5,  -3 }),
                     2, 5, -3);
     }
 
     @Test
     public void testSpace() {
-        Space space = new Vector3D(1, 2, 2).getSpace();
+        Space space = new Coordinates3D(1, 2, 2).getSpace();
         Assert.assertEquals(3, space.getDimension());
         Assert.assertEquals(2, space.getSubSpace().getDimension());
         Space deserialized = (Space) TestUtils.serializeAndRecover(space);
@@ -68,63 +68,63 @@ public class Vector3DTest {
 
     @Test
     public void testZero() {
-        Assert.assertEquals(0, new Vector3D(1, 2, 2).getZero().getNorm(), 1.0e-15);
+        Assert.assertEquals(0, new Coordinates3D(1, 2, 2).getZero().getNorm(), 1.0e-15);
     }
 
     @Test
     public void testEquals() {
-        Vector3D u1 = new Vector3D(1, 2, 3);
-        Vector3D u2 = new Vector3D(1, 2, 3);
+        Coordinates3D u1 = new Coordinates3D(1, 2, 3);
+        Coordinates3D u2 = new Coordinates3D(1, 2, 3);
         Assert.assertTrue(u1.equals(u1));
         Assert.assertTrue(u1.equals(u2));
         Assert.assertFalse(u1.equals(new Rotation(1, 0, 0, 0, false)));
-        Assert.assertFalse(u1.equals(new Vector3D(1, 2, 3 + 10 * Precision.EPSILON)));
-        Assert.assertFalse(u1.equals(new Vector3D(1, 2 + 10 * Precision.EPSILON, 3)));
-        Assert.assertFalse(u1.equals(new Vector3D(1 + 10 * Precision.EPSILON, 2, 3)));
-        Assert.assertTrue(new Vector3D(0, Double.NaN, 0).equals(new Vector3D(0, 0, Double.NaN)));
+        Assert.assertFalse(u1.equals(new Coordinates3D(1, 2, 3 + 10 * Precision.EPSILON)));
+        Assert.assertFalse(u1.equals(new Coordinates3D(1, 2 + 10 * Precision.EPSILON, 3)));
+        Assert.assertFalse(u1.equals(new Coordinates3D(1 + 10 * Precision.EPSILON, 2, 3)));
+        Assert.assertTrue(new Coordinates3D(0, Double.NaN, 0).equals(new Coordinates3D(0, 0, Double.NaN)));
     }
 
     @Test
     public void testHash() {
-        Assert.assertEquals(new Vector3D(0, Double.NaN, 0).hashCode(), new Vector3D(0, 0, Double.NaN).hashCode());
-        Vector3D u = new Vector3D(1, 2, 3);
-        Vector3D v = new Vector3D(1, 2, 3 + 10 * Precision.EPSILON);
+        Assert.assertEquals(new Coordinates3D(0, Double.NaN, 0).hashCode(), new Coordinates3D(0, 0, Double.NaN).hashCode());
+        Coordinates3D u = new Coordinates3D(1, 2, 3);
+        Coordinates3D v = new Coordinates3D(1, 2, 3 + 10 * Precision.EPSILON);
         Assert.assertTrue(u.hashCode() != v.hashCode());
     }
 
     @Test
     public void testInfinite() {
-        Assert.assertTrue(new Vector3D(1, 1, Double.NEGATIVE_INFINITY).isInfinite());
-        Assert.assertTrue(new Vector3D(1, Double.NEGATIVE_INFINITY, 1).isInfinite());
-        Assert.assertTrue(new Vector3D(Double.NEGATIVE_INFINITY, 1, 1).isInfinite());
-        Assert.assertFalse(new Vector3D(1, 1, 2).isInfinite());
-        Assert.assertFalse(new Vector3D(1, Double.NaN, Double.NEGATIVE_INFINITY).isInfinite());
+        Assert.assertTrue(new Coordinates3D(1, 1, Double.NEGATIVE_INFINITY).isInfinite());
+        Assert.assertTrue(new Coordinates3D(1, Double.NEGATIVE_INFINITY, 1).isInfinite());
+        Assert.assertTrue(new Coordinates3D(Double.NEGATIVE_INFINITY, 1, 1).isInfinite());
+        Assert.assertFalse(new Coordinates3D(1, 1, 2).isInfinite());
+        Assert.assertFalse(new Coordinates3D(1, Double.NaN, Double.NEGATIVE_INFINITY).isInfinite());
     }
 
     @Test
     public void testNaN() {
-        Assert.assertTrue(new Vector3D(1, 1, Double.NaN).isNaN());
-        Assert.assertTrue(new Vector3D(1, Double.NaN, 1).isNaN());
-        Assert.assertTrue(new Vector3D(Double.NaN, 1, 1).isNaN());
-        Assert.assertFalse(new Vector3D(1, 1, 2).isNaN());
-        Assert.assertFalse(new Vector3D(1, 1, Double.NEGATIVE_INFINITY).isNaN());
+        Assert.assertTrue(new Coordinates3D(1, 1, Double.NaN).isNaN());
+        Assert.assertTrue(new Coordinates3D(1, Double.NaN, 1).isNaN());
+        Assert.assertTrue(new Coordinates3D(Double.NaN, 1, 1).isNaN());
+        Assert.assertFalse(new Coordinates3D(1, 1, 2).isNaN());
+        Assert.assertFalse(new Coordinates3D(1, 1, Double.NEGATIVE_INFINITY).isNaN());
     }
 
     @Test
     public void testToString() {
-        Assert.assertEquals("{3; 2; 1}", new Vector3D(3, 2, 1).toString());
+        Assert.assertEquals("{3; 2; 1}", new Coordinates3D(3, 2, 1).toString());
         NumberFormat format = new DecimalFormat("0.000", new DecimalFormatSymbols(Locale.US));
-        Assert.assertEquals("{3.000; 2.000; 1.000}", new Vector3D(3, 2, 1).toString(format));
+        Assert.assertEquals("{3.000; 2.000; 1.000}", new Coordinates3D(3, 2, 1).toString(format));
     }
 
     @Test(expected=DimensionMismatchException.class)
     public void testWrongDimension() throws DimensionMismatchException {
-        new Vector3D(new double[] { 2,  5 });
+        new Coordinates3D(new double[] { 2,  5 });
     }
 
     @Test
     public void testCoordinates() {
-        Vector3D v = new Vector3D(1, 2, 3);
+        Coordinates3D v = new Coordinates3D(1, 2, 3);
         Assert.assertTrue(FastMath.abs(v.getX() - 1) < 1.0e-12);
         Assert.assertTrue(FastMath.abs(v.getY() - 2) < 1.0e-12);
         Assert.assertTrue(FastMath.abs(v.getZ() - 3) < 1.0e-12);
@@ -136,69 +136,69 @@ public class Vector3DTest {
 
     @Test
     public void testNorm1() {
-        Assert.assertEquals(0.0, Vector3D.ZERO.getNorm1(), 0);
-        Assert.assertEquals(6.0, new Vector3D(1, -2, 3).getNorm1(), 0);
+        Assert.assertEquals(0.0, Coordinates3D.ZERO.getNorm1(), 0);
+        Assert.assertEquals(6.0, new Coordinates3D(1, -2, 3).getNorm1(), 0);
     }
 
     @Test
     public void testNorm() {
-        Assert.assertEquals(0.0, Vector3D.ZERO.getNorm(), 0);
-        Assert.assertEquals(FastMath.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12);
+        Assert.assertEquals(0.0, Coordinates3D.ZERO.getNorm(), 0);
+        Assert.assertEquals(FastMath.sqrt(14), new Coordinates3D(1, 2, 3).getNorm(), 1.0e-12);
     }
 
     @Test
     public void testNormSq() {
-        Assert.assertEquals(0.0, new Vector3D(0, 0, 0).getNormSq(), 0);
-        Assert.assertEquals(14, new Vector3D(1, 2, 3).getNormSq(), 1.0e-12);
+        Assert.assertEquals(0.0, new Coordinates3D(0, 0, 0).getNormSq(), 0);
+        Assert.assertEquals(14, new Coordinates3D(1, 2, 3).getNormSq(), 1.0e-12);
     }
 
     @Test
     public void testNormInf() {
-        Assert.assertEquals(0.0, Vector3D.ZERO.getNormInf(), 0);
-        Assert.assertEquals(3.0, new Vector3D(1, -2, 3).getNormInf(), 0);
+        Assert.assertEquals(0.0, Coordinates3D.ZERO.getNormInf(), 0);
+        Assert.assertEquals(3.0, new Coordinates3D(1, -2, 3).getNormInf(), 0);
     }
 
     @Test
     public void testDistance1() {
-        Vector3D v1 = new Vector3D(1, -2, 3);
-        Vector3D v2 = new Vector3D(-4, 2, 0);
-        Assert.assertEquals(0.0, Vector3D.distance1(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);
-        Assert.assertEquals(12.0, Vector3D.distance1(v1, v2), 1.0e-12);
-        Assert.assertEquals(v1.subtract(v2).getNorm1(), Vector3D.distance1(v1, v2), 1.0e-12);
+        Coordinates3D v1 = new Coordinates3D(1, -2, 3);
+        Coordinates3D v2 = new Coordinates3D(-4, 2, 0);
+        Assert.assertEquals(0.0, Coordinates3D.distance1(Coordinates3D.MINUS_I, Coordinates3D.MINUS_I), 0);
+        Assert.assertEquals(12.0, Coordinates3D.distance1(v1, v2), 1.0e-12);
+        Assert.assertEquals(v1.subtract(v2).getNorm1(), Coordinates3D.distance1(v1, v2), 1.0e-12);
     }
 
     @Test
     public void testDistance() {
-        Vector3D v1 = new Vector3D(1, -2, 3);
-        Vector3D v2 = new Vector3D(-4, 2, 0);
-        Assert.assertEquals(0.0, Vector3D.distance(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);
-        Assert.assertEquals(FastMath.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12);
-        Assert.assertEquals(v1.subtract(v2).getNorm(), Vector3D.distance(v1, v2), 1.0e-12);
+        Coordinates3D v1 = new Coordinates3D(1, -2, 3);
+        Coordinates3D v2 = new Coordinates3D(-4, 2, 0);
+        Assert.assertEquals(0.0, Coordinates3D.distance(Coordinates3D.MINUS_I, Coordinates3D.MINUS_I), 0);
+        Assert.assertEquals(FastMath.sqrt(50), Coordinates3D.distance(v1, v2), 1.0e-12);
+        Assert.assertEquals(v1.subtract(v2).getNorm(), Coordinates3D.distance(v1, v2), 1.0e-12);
     }
 
     @Test
     public void testDistanceSq() {
-        Vector3D v1 = new Vector3D(1, -2, 3);
-        Vector3D v2 = new Vector3D(-4, 2, 0);
-        Assert.assertEquals(0.0, Vector3D.distanceSq(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);
-        Assert.assertEquals(50.0, Vector3D.distanceSq(v1, v2), 1.0e-12);
-        Assert.assertEquals(Vector3D.distance(v1, v2) * Vector3D.distance(v1, v2),
-                            Vector3D.distanceSq(v1, v2), 1.0e-12);
+        Coordinates3D v1 = new Coordinates3D(1, -2, 3);
+        Coordinates3D v2 = new Coordinates3D(-4, 2, 0);
+        Assert.assertEquals(0.0, Coordinates3D.distanceSq(Coordinates3D.MINUS_I, Coordinates3D.MINUS_I), 0);
+        Assert.assertEquals(50.0, Coordinates3D.distanceSq(v1, v2), 1.0e-12);
+        Assert.assertEquals(Coordinates3D.distance(v1, v2) * Coordinates3D.distance(v1, v2),
+                            Coordinates3D.distanceSq(v1, v2), 1.0e-12);
   }
 
     @Test
     public void testDistanceInf() {
-        Vector3D v1 = new Vector3D(1, -2, 3);
-        Vector3D v2 = new Vector3D(-4, 2, 0);
-        Assert.assertEquals(0.0, Vector3D.distanceInf(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);
-        Assert.assertEquals(5.0, Vector3D.distanceInf(v1, v2), 1.0e-12);
-        Assert.assertEquals(v1.subtract(v2).getNormInf(), Vector3D.distanceInf(v1, v2), 1.0e-12);
+        Coordinates3D v1 = new Coordinates3D(1, -2, 3);
+        Coordinates3D v2 = new Coordinates3D(-4, 2, 0);
+        Assert.assertEquals(0.0, Coordinates3D.distanceInf(Coordinates3D.MINUS_I, Coordinates3D.MINUS_I), 0);
+        Assert.assertEquals(5.0, Coordinates3D.distanceInf(v1, v2), 1.0e-12);
+        Assert.assertEquals(v1.subtract(v2).getNormInf(), Coordinates3D.distanceInf(v1, v2), 1.0e-12);
     }
 
     @Test
     public void testSubtract() {
-        Vector3D v1 = new Vector3D(1, 2, 3);
-        Vector3D v2 = new Vector3D(-3, -2, -1);
+        Coordinates3D v1 = new Coordinates3D(1, 2, 3);
+        Coordinates3D v2 = new Coordinates3D(-3, -2, -1);
         v1 = v1.subtract(v2);
         checkVector(v1, 4, 4, 4);
 
@@ -208,8 +208,8 @@ public class Vector3DTest {
 
     @Test
     public void testAdd() {
-        Vector3D v1 = new Vector3D(1, 2, 3);
-        Vector3D v2 = new Vector3D(-3, -2, -1);
+        Coordinates3D v1 = new Coordinates3D(1, 2, 3);
+        Coordinates3D v2 = new Coordinates3D(-3, -2, -1);
         v1 = v1.add(v2);
         checkVector(v1, -2, 0, 2);
 
@@ -219,7 +219,7 @@ public class Vector3DTest {
 
     @Test
     public void testScalarProduct() {
-        Vector3D v = new Vector3D(1, 2, 3);
+        Coordinates3D v = new Coordinates3D(1, 2, 3);
         v = v.scalarMultiply(3);
         checkVector(v, 3, 6, 9);
 
@@ -228,61 +228,61 @@ public class Vector3DTest {
 
     @Test
     public void testVectorialProducts() {
-        Vector3D v1 = new Vector3D(2, 1, -4);
-        Vector3D v2 = new Vector3D(3, 1, -1);
+        Coordinates3D v1 = new Coordinates3D(2, 1, -4);
+        Coordinates3D v2 = new Coordinates3D(3, 1, -1);
 
-        Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);
+        Assert.assertTrue(FastMath.abs(Coordinates3D.dotProduct(v1, v2) - 11) < 1.0e-12);
 
-        Vector3D v3 = Vector3D.crossProduct(v1, v2);
+        Coordinates3D v3 = Coordinates3D.crossProduct(v1, v2);
         checkVector(v3, 3, -10, -1);
 
-        Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);
-        Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);
+        Assert.assertTrue(FastMath.abs(Coordinates3D.dotProduct(v1, v3)) < 1.0e-12);
+        Assert.assertTrue(FastMath.abs(Coordinates3D.dotProduct(v2, v3)) < 1.0e-12);
     }
 
     @Test
     public void testCrossProductCancellation() {
-        Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1);
-        Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1);
-        checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1);
+        Coordinates3D v1 = new Coordinates3D(9070467121.0, 4535233560.0, 1);
+        Coordinates3D v2 = new Coordinates3D(9070467123.0, 4535233561.0, 1);
+        checkVector(Coordinates3D.crossProduct(v1, v2), -1, 2, 1);
 
         double scale    = FastMath.scalb(1.0, 100);
-        Vector3D big1   = new Vector3D(scale, v1);
-        Vector3D small2 = new Vector3D(1 / scale, v2);
-        checkVector(Vector3D.crossProduct(big1, small2), -1, 2, 1);
+        Coordinates3D big1   = new Coordinates3D(scale, v1);
+        Coordinates3D small2 = new Coordinates3D(1 / scale, v2);
+        checkVector(Coordinates3D.crossProduct(big1, small2), -1, 2, 1);
 
     }
 
     @Test
     public void testAngular() {
-        Assert.assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);
-        Assert.assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);
-        Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);
-        Assert.assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);
-        Assert.assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);
-        Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);
-
-        Vector3D u = new Vector3D(-1, 1, -1);
+        Assert.assertEquals(0,           Coordinates3D.PLUS_I.getAlpha(), 1.0e-10);
+        Assert.assertEquals(0,           Coordinates3D.PLUS_I.getDelta(), 1.0e-10);
+        Assert.assertEquals(FastMath.PI / 2, Coordinates3D.PLUS_J.getAlpha(), 1.0e-10);
+        Assert.assertEquals(0,           Coordinates3D.PLUS_J.getDelta(), 1.0e-10);
+        Assert.assertEquals(0,           Coordinates3D.PLUS_K.getAlpha(), 1.0e-10);
+        Assert.assertEquals(FastMath.PI / 2, Coordinates3D.PLUS_K.getDelta(), 1.0e-10);
+
+        Coordinates3D u = new Coordinates3D(-1, 1, -1);
         Assert.assertEquals(3 * FastMath.PI /4, u.getAlpha(), 1.0e-10);
         Assert.assertEquals(-1.0 / FastMath.sqrt(3), FastMath.sin(u.getDelta()), 1.0e-10);
     }
 
     @Test
     public void testAngularSeparation() throws MathArithmeticException {
-        Vector3D v1 = new Vector3D(2, -1, 4);
+        Coordinates3D v1 = new Coordinates3D(2, -1, 4);
 
-        Vector3D  k = v1.normalize();
-        Vector3D  i = k.orthogonal();
-        Vector3D v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));
+        Coordinates3D  k = v1.normalize();
+        Coordinates3D  i = k.orthogonal();
+        Coordinates3D v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));
 
-        Assert.assertTrue(FastMath.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);
+        Assert.assertTrue(FastMath.abs(Coordinates3D.angle(v1, v2) - 1.2) < 1.0e-12);
   }
 
     @Test
     public void testNormalize() throws MathArithmeticException {
-        Assert.assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);
+        Assert.assertEquals(1.0, new Coordinates3D(5, -4, 2).normalize().getNorm(), 1.0e-12);
         try {
-            Vector3D.ZERO.normalize();
+            Coordinates3D.ZERO.normalize();
             Assert.fail("an exception should have been thrown");
         } catch (MathArithmeticException ae) {
             // expected behavior
@@ -291,21 +291,21 @@ public class Vector3DTest {
 
     @Test
     public void testNegate() {
-        checkVector(new Vector3D(0.1, 2.5, 1.3).negate(), -0.1, -2.5, -1.3);
+        checkVector(new Coordinates3D(0.1, 2.5, 1.3).negate(), -0.1, -2.5, -1.3);
     }
 
     @Test
     public void testOrthogonal() throws MathArithmeticException {
-        Vector3D v1 = new Vector3D(0.1, 2.5, 1.3);
-        Assert.assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);
-        Vector3D v2 = new Vector3D(2.3, -0.003, 7.6);
-        Assert.assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12);
-        Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2);
-        Assert.assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12);
-        Vector3D v4 = new Vector3D(4.2, 0.1, -1.8);
-        Assert.assertEquals(0.0, Vector3D.dotProduct(v4, v4.orthogonal()), 1.0e-12);
+        Coordinates3D v1 = new Coordinates3D(0.1, 2.5, 1.3);
+        Assert.assertEquals(0.0, Coordinates3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);
+        Coordinates3D v2 = new Coordinates3D(2.3, -0.003, 7.6);
+        Assert.assertEquals(0.0, Coordinates3D.dotProduct(v2, v2.orthogonal()), 1.0e-12);
+        Coordinates3D v3 = new Coordinates3D(-1.7, 1.4, 0.2);
+        Assert.assertEquals(0.0, Coordinates3D.dotProduct(v3, v3.orthogonal()), 1.0e-12);
+        Coordinates3D v4 = new Coordinates3D(4.2, 0.1, -1.8);
+        Assert.assertEquals(0.0, Coordinates3D.dotProduct(v4, v4.orthogonal()), 1.0e-12);
         try {
-            new Vector3D(0, 0, 0).orthogonal();
+            new Coordinates3D(0, 0, 0).orthogonal();
             Assert.fail("an exception should have been thrown");
         } catch (MathArithmeticException ae) {
             // expected behavior
@@ -314,16 +314,16 @@ public class Vector3DTest {
     @Test
     public void testAngle() throws MathArithmeticException {
         Assert.assertEquals(0.22572612855273393616,
-                            Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)),
+                            Coordinates3D.angle(new Coordinates3D(1, 2, 3), new Coordinates3D(4, 5, 6)),
                             1.0e-12);
         Assert.assertEquals(7.98595620686106654517199e-8,
-                            Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)),
+                            Coordinates3D.angle(new Coordinates3D(1, 2, 3), new Coordinates3D(2, 4, 6.000001)),
                             1.0e-12);
         Assert.assertEquals(3.14159257373023116985197793156,
-                            Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),
+                            Coordinates3D.angle(new Coordinates3D(1, 2, 3), new Coordinates3D(-2, -4, -6.000001)),
                             1.0e-12);
         try {
-            Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);
+            Coordinates3D.angle(Coordinates3D.ZERO, Coordinates3D.PLUS_I);
             Assert.fail("an exception should have been thrown");
         } catch (MathArithmeticException ae) {
             // expected behavior
@@ -335,10 +335,10 @@ public class Vector3DTest {
         // the following two vectors are nearly but not exactly orthogonal
         // naive dot product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z
         // leads to a result of 0.0, instead of the correct -1.855129...
-        Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,
+        Coordinates3D u1 = new Coordinates3D(-1321008684645961.0 /  268435456.0,
                                    -5774608829631843.0 /  268435456.0,
                                    -7645843051051357.0 / 8589934592.0);
-        Vector3D u2 = new Vector3D(-5712344449280879.0 /    2097152.0,
+        Coordinates3D u2 = new Coordinates3D(-5712344449280879.0 /    2097152.0,
                                    -4550117129121957.0 /    2097152.0,
                                     8846951984510141.0 /     131072.0);
         double sNaive = u1.getX() * u2.getX() + u1.getY() * u2.getY() + u1.getZ() * u2.getZ();
@@ -360,7 +360,7 @@ public class Vector3DTest {
             double vy = 10000 * random.nextDouble();
             double vz = 10000 * random.nextDouble();
             double sNaive = ux * vx + uy * vy + uz * vz;
-            double sAccurate = new Vector3D(ux, uy, uz).dotProduct(new Vector3D(vx, vy, vz));
+            double sAccurate = new Coordinates3D(ux, uy, uz).dotProduct(new Coordinates3D(vx, vy, vz));
             Assert.assertEquals(sNaive, sAccurate, 2.5e-16 * sAccurate);
         }
     }
@@ -372,19 +372,19 @@ public class Vector3DTest {
         // computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z
         // leads to a result of   [0.0009765, -0.0001220, -0.0039062],
         // instead of the correct [0.0006913, -0.0001254, -0.0007909]
-        final Vector3D u1 = new Vector3D(-1321008684645961.0 /   268435456.0,
+        final Coordinates3D u1 = new Coordinates3D(-1321008684645961.0 /   268435456.0,
                                          -5774608829631843.0 /   268435456.0,
                                          -7645843051051357.0 /  8589934592.0);
-        final Vector3D u2 = new Vector3D( 1796571811118507.0 /  2147483648.0,
+        final Coordinates3D u2 = new Coordinates3D( 1796571811118507.0 /  2147483648.0,
                                           7853468008299307.0 /  2147483648.0,
                                           2599586637357461.0 / 17179869184.0);
-        final Vector3D u3 = new Vector3D(12753243807587107.0 / 18446744073709551616.0,
+        final Coordinates3D u3 = new Coordinates3D(12753243807587107.0 / 18446744073709551616.0,
                                          -2313766922703915.0 / 18446744073709551616.0,
                                           -227970081415313.0 /   288230376151711744.0);
-        Vector3D cNaive = new Vector3D(u1.getY() * u2.getZ() - u1.getZ() * u2.getY(),
+        Coordinates3D cNaive = new Coordinates3D(u1.getY() * u2.getZ() - u1.getZ() * u2.getY(),
                                        u1.getZ() * u2.getX() - u1.getX() * u2.getZ(),
                                        u1.getX() * u2.getY() - u1.getY() * u2.getX());
-        Vector3D cAccurate = u1.crossProduct(u2);
+        Coordinates3D cAccurate = u1.crossProduct(u2);
         Assert.assertTrue(u3.distance(cNaive) > 2.9 * u3.getNorm());
         Assert.assertEquals(0.0, u3.distance(cAccurate), 1.0e-30 * cAccurate.getNorm());
     }
@@ -401,13 +401,13 @@ public class Vector3DTest {
             double vx = 10000 * random.nextDouble();
             double vy = 10000 * random.nextDouble();
             double vz = 10000 * random.nextDouble();
-            Vector3D cNaive = new Vector3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);
-            Vector3D cAccurate = new Vector3D(ux, uy, uz).crossProduct(new Vector3D(vx, vy, vz));
+            Coordinates3D cNaive = new Coordinates3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);
+            Coordinates3D cAccurate = new Coordinates3D(ux, uy, uz).crossProduct(new Coordinates3D(vx, vy, vz));
             Assert.assertEquals(0.0, cAccurate.distance(cNaive), 6.0e-15 * cAccurate.getNorm());
         }
     }
 
-    private void checkVector(Vector3D v, double x, double y, double z) {
+    private void checkVector(Coordinates3D v, double x, double y, double z) {
         Assert.assertEquals(x, v.getX(), 1.0e-12);
         Assert.assertEquals(y, v.getY(), 1.0e-12);
         Assert.assertEquals(z, v.getZ(), 1.0e-12);
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/DiskGeneratorTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/DiskGeneratorTest.java
index 4f1561080..841a87cec 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/DiskGeneratorTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/DiskGeneratorTest.java
@@ -23,7 +23,7 @@ import java.util.List;
 import org.apache.commons.math4.geometry.enclosing.EnclosingBall;
 import org.apache.commons.math4.geometry.euclidean.twod.DiskGenerator;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.random.UnitSphereRandomVectorGenerator;
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.rng.simple.RandomSource;
@@ -35,8 +35,8 @@ public class DiskGeneratorTest {
 
     @Test
     public void testSupport0Point() {
-        List<Vector2D> support = Arrays.asList(new Vector2D[0]);
-        EnclosingBall<Euclidean2D, Vector2D> disk = new DiskGenerator().ballOnSupport(support);
+        List<Coordinates2D> support = Arrays.asList(new Coordinates2D[0]);
+        EnclosingBall<Euclidean2D, Coordinates2D> disk = new DiskGenerator().ballOnSupport(support);
         Assert.assertTrue(disk.getRadius() < 0);
         Assert.assertEquals(0, disk.getSupportSize());
         Assert.assertEquals(0, disk.getSupport().length);
@@ -44,15 +44,15 @@ public class DiskGeneratorTest {
 
     @Test
     public void testSupport1Point() {
-        List<Vector2D> support = Arrays.asList(new Vector2D(1, 2));
-        EnclosingBall<Euclidean2D, Vector2D> disk = new DiskGenerator().ballOnSupport(support);
+        List<Coordinates2D> support = Arrays.asList(new Coordinates2D(1, 2));
+        EnclosingBall<Euclidean2D, Coordinates2D> disk = new DiskGenerator().ballOnSupport(support);
         Assert.assertEquals(0.0, disk.getRadius(), 1.0e-10);
         Assert.assertTrue(disk.contains(support.get(0)));
         Assert.assertTrue(disk.contains(support.get(0), 0.5));
-        Assert.assertFalse(disk.contains(new Vector2D(support.get(0).getX() + 0.1,
+        Assert.assertFalse(disk.contains(new Coordinates2D(support.get(0).getX() + 0.1,
                                                       support.get(0).getY() - 0.1),
                                          0.001));
-        Assert.assertTrue(disk.contains(new Vector2D(support.get(0).getX() + 0.1,
+        Assert.assertTrue(disk.contains(new Coordinates2D(support.get(0).getX() + 0.1,
                                                      support.get(0).getY() - 0.1),
                                         0.5));
         Assert.assertEquals(0, support.get(0).distance(disk.getCenter()), 1.0e-10);
@@ -62,41 +62,41 @@ public class DiskGeneratorTest {
 
     @Test
     public void testSupport2Points() {
-        List<Vector2D> support = Arrays.asList(new Vector2D(1, 0),
-                                               new Vector2D(3, 0));
-        EnclosingBall<Euclidean2D, Vector2D> disk = new DiskGenerator().ballOnSupport(support);
+        List<Coordinates2D> support = Arrays.asList(new Coordinates2D(1, 0),
+                                               new Coordinates2D(3, 0));
+        EnclosingBall<Euclidean2D, Coordinates2D> disk = new DiskGenerator().ballOnSupport(support);
         Assert.assertEquals(1.0, disk.getRadius(), 1.0e-10);
         int i = 0;
-        for (Vector2D v : support) {
+        for (Coordinates2D v : support) {
             Assert.assertTrue(disk.contains(v));
             Assert.assertEquals(1.0, v.distance(disk.getCenter()), 1.0e-10);
             Assert.assertTrue(v == disk.getSupport()[i++]);
         }
-        Assert.assertTrue(disk.contains(new Vector2D(2, 0.9)));
-        Assert.assertFalse(disk.contains(Vector2D.ZERO));
-        Assert.assertEquals(0.0, new Vector2D(2, 0).distance(disk.getCenter()), 1.0e-10);
+        Assert.assertTrue(disk.contains(new Coordinates2D(2, 0.9)));
+        Assert.assertFalse(disk.contains(Coordinates2D.ZERO));
+        Assert.assertEquals(0.0, new Coordinates2D(2, 0).distance(disk.getCenter()), 1.0e-10);
         Assert.assertEquals(2, disk.getSupportSize());
     }
 
     @Test
     public void testSupport3Points() {
-        List<Vector2D> support = Arrays.asList(new Vector2D(1, 0),
-                                               new Vector2D(3, 0),
-                                               new Vector2D(2, 2));
-        EnclosingBall<Euclidean2D, Vector2D> disk = new DiskGenerator().ballOnSupport(support);
+        List<Coordinates2D> support = Arrays.asList(new Coordinates2D(1, 0),
+                                               new Coordinates2D(3, 0),
+                                               new Coordinates2D(2, 2));
+        EnclosingBall<Euclidean2D, Coordinates2D> disk = new DiskGenerator().ballOnSupport(support);
         Assert.assertEquals(5.0 / 4.0, disk.getRadius(), 1.0e-10);
         int i = 0;
-        for (Vector2D v : support) {
+        for (Coordinates2D v : support) {
             Assert.assertTrue(disk.contains(v));
             Assert.assertEquals(5.0 / 4.0, v.distance(disk.getCenter()), 1.0e-10);
             Assert.assertTrue(v == disk.getSupport()[i++]);
         }
-        Assert.assertTrue(disk.contains(new Vector2D(2, 0.9)));
-        Assert.assertFalse(disk.contains(new Vector2D(0.9,  0)));
-        Assert.assertFalse(disk.contains(new Vector2D(3.1,  0)));
-        Assert.assertTrue(disk.contains(new Vector2D(2.0, -0.499)));
-        Assert.assertFalse(disk.contains(new Vector2D(2.0, -0.501)));
-        Assert.assertEquals(0.0, new Vector2D(2.0, 3.0 / 4.0).distance(disk.getCenter()), 1.0e-10);
+        Assert.assertTrue(disk.contains(new Coordinates2D(2, 0.9)));
+        Assert.assertFalse(disk.contains(new Coordinates2D(0.9,  0)));
+        Assert.assertFalse(disk.contains(new Coordinates2D(3.1,  0)));
+        Assert.assertTrue(disk.contains(new Coordinates2D(2.0, -0.499)));
+        Assert.assertFalse(disk.contains(new Coordinates2D(2.0, -0.501)));
+        Assert.assertEquals(0.0, new Coordinates2D(2.0, 3.0 / 4.0).distance(disk.getCenter()), 1.0e-10);
         Assert.assertEquals(3, disk.getSupportSize());
     }
 
@@ -108,12 +108,12 @@ public class DiskGeneratorTest {
         for (int i = 0; i < 500; ++i) {
             double d = 25 * random.nextDouble();
             double refRadius = 10 * random.nextDouble();
-            Vector2D refCenter = new Vector2D(d, new Vector2D(sr.nextVector()));
-            List<Vector2D> support = new ArrayList<>();
+            Coordinates2D refCenter = new Coordinates2D(d, new Coordinates2D(sr.nextVector()));
+            List<Coordinates2D> support = new ArrayList<>();
             for (int j = 0; j < 3; ++j) {
-                support.add(new Vector2D(1.0, refCenter, refRadius, new Vector2D(sr.nextVector())));
+                support.add(new Coordinates2D(1.0, refCenter, refRadius, new Coordinates2D(sr.nextVector())));
             }
-            EnclosingBall<Euclidean2D, Vector2D> disk = new DiskGenerator().ballOnSupport(support);
+            EnclosingBall<Euclidean2D, Coordinates2D> disk = new DiskGenerator().ballOnSupport(support);
             Assert.assertEquals(0.0, refCenter.distance(disk.getCenter()), 3e-9 * refRadius);
             Assert.assertEquals(refRadius, disk.getRadius(), 7e-10 * refRadius);
         }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/LineTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/LineTest.java
index a7810e729..79e9fa41e 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/LineTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/LineTest.java
@@ -19,10 +19,10 @@ package org.apache.commons.math4.geometry.euclidean.twod;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.geometry.Point;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.Line;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.partitioning.Transform;
 import org.apache.commons.math4.util.FastMath;
 import org.junit.Assert;
@@ -32,54 +32,54 @@ public class LineTest {
 
     @Test
     public void testContains() {
-        Line l = new Line(new Vector2D(0, 1), new Vector2D(1, 2), 1.0e-10);
-        Assert.assertTrue(l.contains(new Vector2D(0, 1)));
-        Assert.assertTrue(l.contains(new Vector2D(1, 2)));
-        Assert.assertTrue(l.contains(new Vector2D(7, 8)));
-        Assert.assertTrue(! l.contains(new Vector2D(8, 7)));
+        Line l = new Line(new Coordinates2D(0, 1), new Coordinates2D(1, 2), 1.0e-10);
+        Assert.assertTrue(l.contains(new Coordinates2D(0, 1)));
+        Assert.assertTrue(l.contains(new Coordinates2D(1, 2)));
+        Assert.assertTrue(l.contains(new Coordinates2D(7, 8)));
+        Assert.assertTrue(! l.contains(new Coordinates2D(8, 7)));
     }
 
     @Test
     public void testAbscissa() {
-        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2), 1.0e-10);
+        Line l = new Line(new Coordinates2D(2, 1), new Coordinates2D(-2, -2), 1.0e-10);
         Assert.assertEquals(0.0,
-                            (l.toSubSpace(new Vector2D(-3,  4))).getX(),
+                            (l.toSubSpace(new Coordinates2D(-3,  4))).getX(),
                             1.0e-10);
         Assert.assertEquals(0.0,
-                            (l.toSubSpace(new Vector2D( 3, -4))).getX(),
+                            (l.toSubSpace(new Coordinates2D( 3, -4))).getX(),
                             1.0e-10);
         Assert.assertEquals(-5.0,
-                            (l.toSubSpace(new Vector2D( 7, -1))).getX(),
+                            (l.toSubSpace(new Coordinates2D( 7, -1))).getX(),
                             1.0e-10);
-        Assert.assertEquals( 5.0,
-                             (l.toSubSpace(new Vector2D(-1, -7))).getX(),
+        Assert.assertEquals(5.0,
+                             (l.toSubSpace(new Coordinates2D(-1, -7))).getX(),
                              1.0e-10);
     }
 
     @Test
     public void testOffset() {
-        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2), 1.0e-10);
-        Assert.assertEquals(-5.0, l.getOffset(new Vector2D(5, -3)), 1.0e-10);
-        Assert.assertEquals(+5.0, l.getOffset(new Vector2D(-5, 2)), 1.0e-10);
+        Line l = new Line(new Coordinates2D(2, 1), new Coordinates2D(-2, -2), 1.0e-10);
+        Assert.assertEquals(-5.0, l.getOffset(new Coordinates2D(5, -3)), 1.0e-10);
+        Assert.assertEquals(+5.0, l.getOffset(new Coordinates2D(-5, 2)), 1.0e-10);
     }
 
     @Test
     public void testDistance() {
-        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2), 1.0e-10);
-        Assert.assertEquals(+5.0, l.distance(new Vector2D(5, -3)), 1.0e-10);
-        Assert.assertEquals(+5.0, l.distance(new Vector2D(-5, 2)), 1.0e-10);
+        Line l = new Line(new Coordinates2D(2, 1), new Coordinates2D(-2, -2), 1.0e-10);
+        Assert.assertEquals(+5.0, l.distance(new Coordinates2D(5, -3)), 1.0e-10);
+        Assert.assertEquals(+5.0, l.distance(new Coordinates2D(-5, 2)), 1.0e-10);
     }
 
     @Test
     public void testPointAt() {
-        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2), 1.0e-10);
+        Line l = new Line(new Coordinates2D(2, 1), new Coordinates2D(-2, -2), 1.0e-10);
         for (double a = -2.0; a < 2.0; a += 0.2) {
-            Point<Euclidean1D> pA = new Vector1D(a);
+            Point<Euclidean1D> pA = new Coordinates1D(a);
             Point<Euclidean2D> point = l.toSpace(pA);
             Assert.assertEquals(a, (l.toSubSpace(point)).getX(), 1.0e-10);
             Assert.assertEquals(0.0, l.getOffset(point),   1.0e-10);
             for (double o = -2.0; o < 2.0; o += 0.2) {
-                point = l.getPointAt((Vector1D) pA, o);
+                point = l.getPointAt((Coordinates1D) pA, o);
                 Assert.assertEquals(a, (l.toSubSpace(point)).getX(), 1.0e-10);
                 Assert.assertEquals(o, l.getOffset(point),   1.0e-10);
             }
@@ -88,34 +88,34 @@ public class LineTest {
 
     @Test
     public void testOriginOffset() {
-        Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2), 1.0e-10);
+        Line l1 = new Line(new Coordinates2D(0, 1), new Coordinates2D(1, 2), 1.0e-10);
         Assert.assertEquals(FastMath.sqrt(0.5), l1.getOriginOffset(), 1.0e-10);
-        Line l2 = new Line(new Vector2D(1, 2), new Vector2D(0, 1), 1.0e-10);
+        Line l2 = new Line(new Coordinates2D(1, 2), new Coordinates2D(0, 1), 1.0e-10);
         Assert.assertEquals(-FastMath.sqrt(0.5), l2.getOriginOffset(), 1.0e-10);
     }
 
     @Test
     public void testParallel() {
-        Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2), 1.0e-10);
-        Line l2 = new Line(new Vector2D(2, 2), new Vector2D(3, 3), 1.0e-10);
+        Line l1 = new Line(new Coordinates2D(0, 1), new Coordinates2D(1, 2), 1.0e-10);
+        Line l2 = new Line(new Coordinates2D(2, 2), new Coordinates2D(3, 3), 1.0e-10);
         Assert.assertTrue(l1.isParallelTo(l2));
-        Line l3 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.5), 1.0e-10);
+        Line l3 = new Line(new Coordinates2D(1, 0), new Coordinates2D(0.5, -0.5), 1.0e-10);
         Assert.assertTrue(l1.isParallelTo(l3));
-        Line l4 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.51), 1.0e-10);
+        Line l4 = new Line(new Coordinates2D(1, 0), new Coordinates2D(0.5, -0.51), 1.0e-10);
         Assert.assertTrue(! l1.isParallelTo(l4));
     }
 
     @Test
     public void testTransform() throws MathIllegalArgumentException {
 
-        Line l1 = new Line(new Vector2D(1.0 ,1.0), new Vector2D(4.0 ,1.0), 1.0e-10);
+        Line l1 = new Line(new Coordinates2D(1.0 ,1.0), new Coordinates2D(4.0 ,1.0), 1.0e-10);
         Transform<Euclidean2D, Euclidean1D> t1 =
             Line.getTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5);
         Assert.assertEquals(0.5 * FastMath.PI,
                             ((Line) t1.apply(l1)).getAngle(),
                             1.0e-10);
 
-        Line l2 = new Line(new Vector2D(0.0, 0.0), new Vector2D(1.0, 1.0), 1.0e-10);
+        Line l2 = new Line(new Coordinates2D(0.0, 0.0), new Coordinates2D(1.0, 1.0), 1.0e-10);
         Transform<Euclidean2D, Euclidean1D> t2 =
             Line.getTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5);
         Assert.assertEquals(FastMath.atan2(1.0, -2.0),
@@ -126,9 +126,9 @@ public class LineTest {
 
     @Test
     public void testIntersection() {
-        Line    l1 = new Line(new Vector2D( 0, 1), new Vector2D(1, 2), 1.0e-10);
-        Line    l2 = new Line(new Vector2D(-1, 2), new Vector2D(2, 1), 1.0e-10);
-        Vector2D p  = l1.intersection(l2);
+        Line    l1 = new Line(new Coordinates2D( 0, 1), new Coordinates2D(1, 2), 1.0e-10);
+        Line    l2 = new Line(new Coordinates2D(-1, 2), new Coordinates2D(2, 1), 1.0e-10);
+        Coordinates2D p  = l1.intersection(l2);
         Assert.assertEquals(0.5, p.getX(), 1.0e-10);
         Assert.assertEquals(1.5, p.getY(), 1.0e-10);
     }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoopsTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoopsTest.java
index e46008aea..822cea789 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoopsTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoopsTest.java
@@ -32,13 +32,13 @@ public class NestedLoopsTest {
 
     @Test
     public void testNestedLoops() throws Exception {
-        Vector2D oneOne = new Vector2D(1.0, 1.0);
-        Vector2D oneNegativeOne = new Vector2D(1.0, -1.0);
-        Vector2D negativeOneNegativeOne = new Vector2D(-1.0, -1.0);
-        Vector2D negativeOneOne = new Vector2D(-1.0, 1.0);
-        Vector2D origin = new Vector2D(0, 0);
+        Coordinates2D oneOne = new Coordinates2D(1.0, 1.0);
+        Coordinates2D oneNegativeOne = new Coordinates2D(1.0, -1.0);
+        Coordinates2D negativeOneNegativeOne = new Coordinates2D(-1.0, -1.0);
+        Coordinates2D negativeOneOne = new Coordinates2D(-1.0, 1.0);
+        Coordinates2D origin = new Coordinates2D(0, 0);
 
-        Vector2D [] vertices = new Vector2D[]{
+        Coordinates2D [] vertices = new Coordinates2D[]{
                 oneOne,
                 oneNegativeOne,
                 negativeOneNegativeOne,
@@ -55,8 +55,8 @@ public class NestedLoopsTest {
         surroundedField.setAccessible(Boolean.TRUE);
         loopField.setAccessible(Boolean.TRUE);
         List<NestedLoops> surrounded = (List<NestedLoops>) surroundedField.get(nestedLoops);
-        Vector2D[] loop = (Vector2D []) loopField.get(surrounded.get(0));
-        Set<Vector2D> vertexSet = new HashSet<>(Arrays.asList(loop));
+        Coordinates2D[] loop = (Coordinates2D []) loopField.get(surrounded.get(0));
+        Set<Coordinates2D> vertexSet = new HashSet<>(Arrays.asList(loop));
         Assert.assertTrue(vertexSet.contains(oneOne));
         Assert.assertTrue(vertexSet.contains(oneNegativeOne));
         Assert.assertTrue(vertexSet.contains(negativeOneNegativeOne));
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSetTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSetTest.java
index 08ffdcdf6..01bfdb3d3 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSetTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSetTest.java
@@ -22,12 +22,12 @@ import java.util.List;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.geometry.euclidean.oned.Interval;
 import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.Line;
 import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
 import org.apache.commons.math4.geometry.euclidean.twod.SubLine;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.partitioning.BSPTree;
 import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
 import org.apache.commons.math4.geometry.partitioning.BoundaryProjection;
@@ -44,41 +44,41 @@ public class PolygonsSetTest {
 
     @Test
     public void testSimplyConnected() {
-        Vector2D[][] vertices = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D(36.0, 22.0),
-                new Vector2D(39.0, 32.0),
-                new Vector2D(19.0, 32.0),
-                new Vector2D( 6.0, 16.0),
-                new Vector2D(31.0, 10.0),
-                new Vector2D(42.0, 16.0),
-                new Vector2D(34.0, 20.0),
-                new Vector2D(29.0, 19.0),
-                new Vector2D(23.0, 22.0),
-                new Vector2D(33.0, 25.0)
+        Coordinates2D[][] vertices = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D(36.0, 22.0),
+                new Coordinates2D(39.0, 32.0),
+                new Coordinates2D(19.0, 32.0),
+                new Coordinates2D( 6.0, 16.0),
+                new Coordinates2D(31.0, 10.0),
+                new Coordinates2D(42.0, 16.0),
+                new Coordinates2D(34.0, 20.0),
+                new Coordinates2D(29.0, 19.0),
+                new Coordinates2D(23.0, 22.0),
+                new Coordinates2D(33.0, 25.0)
             }
         };
         PolygonsSet set = buildSet(vertices);
-        Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector2D(50.0, 30.0)));
-        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {
-            new Vector2D(30.0, 15.0),
-            new Vector2D(15.0, 20.0),
-            new Vector2D(24.0, 25.0),
-            new Vector2D(35.0, 30.0),
-            new Vector2D(19.0, 17.0)
+        Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Coordinates2D(50.0, 30.0)));
+        checkPoints(Region.Location.INSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(30.0, 15.0),
+            new Coordinates2D(15.0, 20.0),
+            new Coordinates2D(24.0, 25.0),
+            new Coordinates2D(35.0, 30.0),
+            new Coordinates2D(19.0, 17.0)
         });
-        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {
-            new Vector2D(50.0, 30.0),
-            new Vector2D(30.0, 35.0),
-            new Vector2D(10.0, 25.0),
-            new Vector2D(10.0, 10.0),
-            new Vector2D(40.0, 10.0),
-            new Vector2D(50.0, 15.0),
-            new Vector2D(30.0, 22.0)
+        checkPoints(Region.Location.OUTSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(50.0, 30.0),
+            new Coordinates2D(30.0, 35.0),
+            new Coordinates2D(10.0, 25.0),
+            new Coordinates2D(10.0, 10.0),
+            new Coordinates2D(40.0, 10.0),
+            new Coordinates2D(50.0, 15.0),
+            new Coordinates2D(30.0, 22.0)
         });
-        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {
-            new Vector2D(30.0, 32.0),
-            new Vector2D(34.0, 20.0)
+        checkPoints(Region.Location.BOUNDARY, set, new Coordinates2D[] {
+            new Coordinates2D(30.0, 32.0),
+            new Coordinates2D(34.0, 20.0)
         });
         checkVertices(set.getVertices(), vertices);
     }
@@ -98,18 +98,18 @@ public class PolygonsSetTest {
 
     @Test
     public void testStair() {
-        Vector2D[][] vertices = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0, 0.0),
-                new Vector2D( 0.0, 2.0),
-                new Vector2D(-0.1, 2.0),
-                new Vector2D(-0.1, 1.0),
-                new Vector2D(-0.3, 1.0),
-                new Vector2D(-0.3, 1.5),
-                new Vector2D(-1.3, 1.5),
-                new Vector2D(-1.3, 2.0),
-                new Vector2D(-1.8, 2.0),
-                new Vector2D(-1.8 - 1.0 / FastMath.sqrt(2.0),
+        Coordinates2D[][] vertices = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0, 0.0),
+                new Coordinates2D( 0.0, 2.0),
+                new Coordinates2D(-0.1, 2.0),
+                new Coordinates2D(-0.1, 1.0),
+                new Coordinates2D(-0.3, 1.0),
+                new Coordinates2D(-0.3, 1.5),
+                new Coordinates2D(-1.3, 1.5),
+                new Coordinates2D(-1.3, 2.0),
+                new Coordinates2D(-1.8, 2.0),
+                new Coordinates2D(-1.8 - 1.0 / FastMath.sqrt(2.0),
                             2.0 - 1.0 / FastMath.sqrt(2.0))
             }
         };
@@ -131,7 +131,7 @@ public class PolygonsSetTest {
         for (double y = -1; y < 1; y += 0.1) {
             for (double x = -1; x < 1; x += 0.1) {
                 Assert.assertEquals(Double.POSITIVE_INFINITY,
-                                    empty.projectToBoundary(new Vector2D(x, y)).getOffset(),
+                                    empty.projectToBoundary(new Coordinates2D(x, y)).getOffset(),
                                     1.0e-10);
             }
         }
@@ -147,7 +147,7 @@ public class PolygonsSetTest {
         for (double y = -1; y < 1; y += 0.1) {
             for (double x = -1; x < 1; x += 0.1) {
                 Assert.assertEquals(Double.NEGATIVE_INFINITY,
-                                    empty.projectToBoundary(new Vector2D(x, y)).getOffset(),
+                                    empty.projectToBoundary(new Coordinates2D(x, y)).getOffset(),
                                     1.0e-10);
             }
         }
@@ -155,56 +155,56 @@ public class PolygonsSetTest {
 
     @Test
     public void testHole() {
-        Vector2D[][] vertices = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D(0.0, 0.0),
-                new Vector2D(3.0, 0.0),
-                new Vector2D(3.0, 3.0),
-                new Vector2D(0.0, 3.0)
-            }, new Vector2D[] {
-                new Vector2D(1.0, 2.0),
-                new Vector2D(2.0, 2.0),
-                new Vector2D(2.0, 1.0),
-                new Vector2D(1.0, 1.0)
+        Coordinates2D[][] vertices = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D(0.0, 0.0),
+                new Coordinates2D(3.0, 0.0),
+                new Coordinates2D(3.0, 3.0),
+                new Coordinates2D(0.0, 3.0)
+            }, new Coordinates2D[] {
+                new Coordinates2D(1.0, 2.0),
+                new Coordinates2D(2.0, 2.0),
+                new Coordinates2D(2.0, 1.0),
+                new Coordinates2D(1.0, 1.0)
             }
         };
         PolygonsSet set = buildSet(vertices);
-        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {
-            new Vector2D(0.5, 0.5),
-            new Vector2D(1.5, 0.5),
-            new Vector2D(2.5, 0.5),
-            new Vector2D(0.5, 1.5),
-            new Vector2D(2.5, 1.5),
-            new Vector2D(0.5, 2.5),
-            new Vector2D(1.5, 2.5),
-            new Vector2D(2.5, 2.5),
-            new Vector2D(0.5, 1.0)
+        checkPoints(Region.Location.INSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(0.5, 0.5),
+            new Coordinates2D(1.5, 0.5),
+            new Coordinates2D(2.5, 0.5),
+            new Coordinates2D(0.5, 1.5),
+            new Coordinates2D(2.5, 1.5),
+            new Coordinates2D(0.5, 2.5),
+            new Coordinates2D(1.5, 2.5),
+            new Coordinates2D(2.5, 2.5),
+            new Coordinates2D(0.5, 1.0)
         });
-        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {
-            new Vector2D(1.5, 1.5),
-            new Vector2D(3.5, 1.0),
-            new Vector2D(4.0, 1.5),
-            new Vector2D(6.0, 6.0)
+        checkPoints(Region.Location.OUTSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(1.5, 1.5),
+            new Coordinates2D(3.5, 1.0),
+            new Coordinates2D(4.0, 1.5),
+            new Coordinates2D(6.0, 6.0)
         });
-        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {
-            new Vector2D(1.0, 1.0),
-            new Vector2D(1.5, 0.0),
-            new Vector2D(1.5, 1.0),
-            new Vector2D(1.5, 2.0),
-            new Vector2D(1.5, 3.0),
-            new Vector2D(3.0, 3.0)
+        checkPoints(Region.Location.BOUNDARY, set, new Coordinates2D[] {
+            new Coordinates2D(1.0, 1.0),
+            new Coordinates2D(1.5, 0.0),
+            new Coordinates2D(1.5, 1.0),
+            new Coordinates2D(1.5, 2.0),
+            new Coordinates2D(1.5, 3.0),
+            new Coordinates2D(3.0, 3.0)
         });
         checkVertices(set.getVertices(), vertices);
 
         for (double x = -0.999; x < 3.999; x += 0.11) {
-            Vector2D v = new Vector2D(x, x + 0.5);
+            Coordinates2D v = new Coordinates2D(x, x + 0.5);
             BoundaryProjection<Euclidean2D> projection = set.projectToBoundary(v);
             Assert.assertTrue(projection.getOriginal() == v);
-            Vector2D p = (Vector2D) projection.getProjected();
+            Coordinates2D p = (Coordinates2D) projection.getProjected();
             if (x < -0.5) {
                 Assert.assertEquals(0.0,      p.getX(), 1.0e-10);
                 Assert.assertEquals(0.0,      p.getY(), 1.0e-10);
-                Assert.assertEquals(+v.distance(Vector2D.ZERO), projection.getOffset(), 1.0e-10);
+                Assert.assertEquals(+v.distance(Coordinates2D.ZERO), projection.getOffset(), 1.0e-10);
             } else if (x < 0.5) {
                 Assert.assertEquals(0.0,      p.getX(), 1.0e-10);
                 Assert.assertEquals(v.getY(), p.getY(), 1.0e-10);
@@ -224,7 +224,7 @@ public class PolygonsSetTest {
             } else {
                 Assert.assertEquals(3.0,      p.getX(), 1.0e-10);
                 Assert.assertEquals(3.0,      p.getY(), 1.0e-10);
-                Assert.assertEquals(+v.distance(new Vector2D(3, 3)), projection.getOffset(), 1.0e-10);
+                Assert.assertEquals(+v.distance(new Coordinates2D(3, 3)), projection.getOffset(), 1.0e-10);
             }
 
         }
@@ -233,47 +233,47 @@ public class PolygonsSetTest {
 
     @Test
     public void testDisjointPolygons() {
-        Vector2D[][] vertices = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D(0.0, 1.0),
-                new Vector2D(2.0, 1.0),
-                new Vector2D(1.0, 2.0)
-            }, new Vector2D[] {
-                new Vector2D(4.0, 0.0),
-                new Vector2D(5.0, 1.0),
-                new Vector2D(3.0, 1.0)
+        Coordinates2D[][] vertices = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D(0.0, 1.0),
+                new Coordinates2D(2.0, 1.0),
+                new Coordinates2D(1.0, 2.0)
+            }, new Coordinates2D[] {
+                new Coordinates2D(4.0, 0.0),
+                new Coordinates2D(5.0, 1.0),
+                new Coordinates2D(3.0, 1.0)
             }
         };
         PolygonsSet set = buildSet(vertices);
-        Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Vector2D(1.0, 1.5)));
-        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {
-            new Vector2D(1.0, 1.5),
-            new Vector2D(4.5, 0.8)
+        Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Coordinates2D(1.0, 1.5)));
+        checkPoints(Region.Location.INSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(1.0, 1.5),
+            new Coordinates2D(4.5, 0.8)
         });
-        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {
-            new Vector2D(1.0, 0.0),
-            new Vector2D(3.5, 1.2),
-            new Vector2D(2.5, 1.0),
-            new Vector2D(3.0, 4.0)
+        checkPoints(Region.Location.OUTSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(1.0, 0.0),
+            new Coordinates2D(3.5, 1.2),
+            new Coordinates2D(2.5, 1.0),
+            new Coordinates2D(3.0, 4.0)
         });
-        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {
-            new Vector2D(1.0, 1.0),
-            new Vector2D(3.5, 0.5),
-            new Vector2D(0.0, 1.0)
+        checkPoints(Region.Location.BOUNDARY, set, new Coordinates2D[] {
+            new Coordinates2D(1.0, 1.0),
+            new Coordinates2D(3.5, 0.5),
+            new Coordinates2D(0.0, 1.0)
         });
         checkVertices(set.getVertices(), vertices);
     }
 
     @Test
     public void testOppositeHyperplanes() {
-        Vector2D[][] vertices = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D(1.0, 0.0),
-                new Vector2D(2.0, 1.0),
-                new Vector2D(3.0, 1.0),
-                new Vector2D(2.0, 2.0),
-                new Vector2D(1.0, 1.0),
-                new Vector2D(0.0, 1.0)
+        Coordinates2D[][] vertices = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D(1.0, 0.0),
+                new Coordinates2D(2.0, 1.0),
+                new Coordinates2D(3.0, 1.0),
+                new Coordinates2D(2.0, 2.0),
+                new Coordinates2D(1.0, 1.0),
+                new Coordinates2D(0.0, 1.0)
             }
         };
         PolygonsSet set = buildSet(vertices);
@@ -282,16 +282,16 @@ public class PolygonsSetTest {
 
     @Test
     public void testSingularPoint() {
-        Vector2D[][] vertices = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0,  0.0),
-                new Vector2D( 1.0,  0.0),
-                new Vector2D( 1.0,  1.0),
-                new Vector2D( 0.0,  1.0),
-                new Vector2D( 0.0,  0.0),
-                new Vector2D(-1.0,  0.0),
-                new Vector2D(-1.0, -1.0),
-                new Vector2D( 0.0, -1.0)
+        Coordinates2D[][] vertices = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D( 1.0,  0.0),
+                new Coordinates2D( 1.0,  1.0),
+                new Coordinates2D( 0.0,  1.0),
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D(-1.0,  0.0),
+                new Coordinates2D(-1.0, -1.0),
+                new Coordinates2D( 0.0, -1.0)
             }
         };
         PolygonsSet set = buildSet(vertices);
@@ -300,48 +300,48 @@ public class PolygonsSetTest {
 
     @Test
     public void testLineIntersection() {
-        Vector2D[][] vertices = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0,  0.0),
-                new Vector2D( 2.0,  0.0),
-                new Vector2D( 2.0,  1.0),
-                new Vector2D( 3.0,  1.0),
-                new Vector2D( 3.0,  3.0),
-                new Vector2D( 1.0,  3.0),
-                new Vector2D( 1.0,  2.0),
-                new Vector2D( 0.0,  2.0)
+        Coordinates2D[][] vertices = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D( 2.0,  0.0),
+                new Coordinates2D( 2.0,  1.0),
+                new Coordinates2D( 3.0,  1.0),
+                new Coordinates2D( 3.0,  3.0),
+                new Coordinates2D( 1.0,  3.0),
+                new Coordinates2D( 1.0,  2.0),
+                new Coordinates2D( 0.0,  2.0)
             }
         };
         PolygonsSet set = buildSet(vertices);
 
-        Line l1 = new Line(new Vector2D(-1.5, 0.0), FastMath.PI / 4, 1.0e-10);
+        Line l1 = new Line(new Coordinates2D(-1.5, 0.0), FastMath.PI / 4, 1.0e-10);
         SubLine s1 = (SubLine) set.intersection(l1.wholeHyperplane());
         List<Interval> i1 = ((IntervalsSet) s1.getRemainingRegion()).asList();
         Assert.assertEquals(2, i1.size());
         Interval v10 = i1.get(0);
-        Vector2D p10Lower = l1.toSpace(new Vector1D(v10.getInf()));
+        Coordinates2D p10Lower = l1.toSpace(new Coordinates1D(v10.getInf()));
         Assert.assertEquals(0.0, p10Lower.getX(), 1.0e-10);
         Assert.assertEquals(1.5, p10Lower.getY(), 1.0e-10);
-        Vector2D p10Upper = l1.toSpace(new Vector1D(v10.getSup()));
+        Coordinates2D p10Upper = l1.toSpace(new Coordinates1D(v10.getSup()));
         Assert.assertEquals(0.5, p10Upper.getX(), 1.0e-10);
         Assert.assertEquals(2.0, p10Upper.getY(), 1.0e-10);
         Interval v11 = i1.get(1);
-        Vector2D p11Lower = l1.toSpace(new Vector1D(v11.getInf()));
+        Coordinates2D p11Lower = l1.toSpace(new Coordinates1D(v11.getInf()));
         Assert.assertEquals(1.0, p11Lower.getX(), 1.0e-10);
         Assert.assertEquals(2.5, p11Lower.getY(), 1.0e-10);
-        Vector2D p11Upper = l1.toSpace(new Vector1D(v11.getSup()));
+        Coordinates2D p11Upper = l1.toSpace(new Coordinates1D(v11.getSup()));
         Assert.assertEquals(1.5, p11Upper.getX(), 1.0e-10);
         Assert.assertEquals(3.0, p11Upper.getY(), 1.0e-10);
 
-        Line l2 = new Line(new Vector2D(-1.0, 2.0), 0, 1.0e-10);
+        Line l2 = new Line(new Coordinates2D(-1.0, 2.0), 0, 1.0e-10);
         SubLine s2 = (SubLine) set.intersection(l2.wholeHyperplane());
         List<Interval> i2 = ((IntervalsSet) s2.getRemainingRegion()).asList();
         Assert.assertEquals(1, i2.size());
         Interval v20 = i2.get(0);
-        Vector2D p20Lower = l2.toSpace(new Vector1D(v20.getInf()));
+        Coordinates2D p20Lower = l2.toSpace(new Coordinates1D(v20.getInf()));
         Assert.assertEquals(1.0, p20Lower.getX(), 1.0e-10);
         Assert.assertEquals(2.0, p20Lower.getY(), 1.0e-10);
-        Vector2D p20Upper = l2.toSpace(new Vector1D(v20.getSup()));
+        Coordinates2D p20Upper = l2.toSpace(new Coordinates1D(v20.getSup()));
         Assert.assertEquals(3.0, p20Upper.getX(), 1.0e-10);
         Assert.assertEquals(2.0, p20Upper.getY(), 1.0e-10);
 
@@ -349,20 +349,20 @@ public class PolygonsSetTest {
 
     @Test
     public void testUnlimitedSubHyperplane() {
-        Vector2D[][] vertices1 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D(0.0, 0.0),
-                new Vector2D(4.0, 0.0),
-                new Vector2D(1.4, 1.5),
-                new Vector2D(0.0, 3.5)
+        Coordinates2D[][] vertices1 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D(0.0, 0.0),
+                new Coordinates2D(4.0, 0.0),
+                new Coordinates2D(1.4, 1.5),
+                new Coordinates2D(0.0, 3.5)
             }
         };
         PolygonsSet set1 = buildSet(vertices1);
-        Vector2D[][] vertices2 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D(1.4,  0.2),
-                new Vector2D(2.8, -1.2),
-                new Vector2D(2.5,  0.6)
+        Coordinates2D[][] vertices2 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D(1.4,  0.2),
+                new Coordinates2D(2.8, -1.2),
+                new Coordinates2D(2.5,  0.6)
             }
         };
         PolygonsSet set2 = buildSet(vertices2);
@@ -372,15 +372,15 @@ public class PolygonsSetTest {
                                                                  set2.copySelf());
         checkVertices(set1.getVertices(), vertices1);
         checkVertices(set2.getVertices(), vertices2);
-        checkVertices(set.getVertices(), new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D(0.0,  0.0),
-                new Vector2D(1.6,  0.0),
-                new Vector2D(2.8, -1.2),
-                new Vector2D(2.6,  0.0),
-                new Vector2D(4.0,  0.0),
-                new Vector2D(1.4,  1.5),
-                new Vector2D(0.0,  3.5)
+        checkVertices(set.getVertices(), new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D(0.0,  0.0),
+                new Coordinates2D(1.6,  0.0),
+                new Coordinates2D(2.8, -1.2),
+                new Coordinates2D(2.6,  0.0),
+                new Coordinates2D(4.0,  0.0),
+                new Coordinates2D(1.4,  1.5),
+                new Coordinates2D(0.0,  3.5)
             }
         });
 
@@ -388,21 +388,21 @@ public class PolygonsSetTest {
 
     @Test
     public void testUnion() {
-        Vector2D[][] vertices1 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0,  0.0),
-                new Vector2D( 2.0,  0.0),
-                new Vector2D( 2.0,  2.0),
-                new Vector2D( 0.0,  2.0)
+        Coordinates2D[][] vertices1 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D( 2.0,  0.0),
+                new Coordinates2D( 2.0,  2.0),
+                new Coordinates2D( 0.0,  2.0)
             }
         };
         PolygonsSet set1 = buildSet(vertices1);
-        Vector2D[][] vertices2 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 1.0,  1.0),
-                new Vector2D( 3.0,  1.0),
-                new Vector2D( 3.0,  3.0),
-                new Vector2D( 1.0,  3.0)
+        Coordinates2D[][] vertices2 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 1.0,  1.0),
+                new Coordinates2D( 3.0,  1.0),
+                new Coordinates2D( 3.0,  3.0),
+                new Coordinates2D( 1.0,  3.0)
             }
         };
         PolygonsSet set2 = buildSet(vertices2);
@@ -410,63 +410,63 @@ public class PolygonsSetTest {
                                                                                 set2.copySelf());
         checkVertices(set1.getVertices(), vertices1);
         checkVertices(set2.getVertices(), vertices2);
-        checkVertices(set.getVertices(), new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0,  0.0),
-                new Vector2D( 2.0,  0.0),
-                new Vector2D( 2.0,  1.0),
-                new Vector2D( 3.0,  1.0),
-                new Vector2D( 3.0,  3.0),
-                new Vector2D( 1.0,  3.0),
-                new Vector2D( 1.0,  2.0),
-                new Vector2D( 0.0,  2.0)
+        checkVertices(set.getVertices(), new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D( 2.0,  0.0),
+                new Coordinates2D( 2.0,  1.0),
+                new Coordinates2D( 3.0,  1.0),
+                new Coordinates2D( 3.0,  3.0),
+                new Coordinates2D( 1.0,  3.0),
+                new Coordinates2D( 1.0,  2.0),
+                new Coordinates2D( 0.0,  2.0)
             }
         });
-        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {
-            new Vector2D(1.0, 1.0),
-            new Vector2D(0.5, 0.5),
-            new Vector2D(2.0, 2.0),
-            new Vector2D(2.5, 2.5),
-            new Vector2D(0.5, 1.5),
-            new Vector2D(1.5, 1.5),
-            new Vector2D(1.5, 0.5),
-            new Vector2D(1.5, 2.5),
-            new Vector2D(2.5, 1.5),
-            new Vector2D(2.5, 2.5)
+        checkPoints(Region.Location.INSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(1.0, 1.0),
+            new Coordinates2D(0.5, 0.5),
+            new Coordinates2D(2.0, 2.0),
+            new Coordinates2D(2.5, 2.5),
+            new Coordinates2D(0.5, 1.5),
+            new Coordinates2D(1.5, 1.5),
+            new Coordinates2D(1.5, 0.5),
+            new Coordinates2D(1.5, 2.5),
+            new Coordinates2D(2.5, 1.5),
+            new Coordinates2D(2.5, 2.5)
         });
-        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {
-            new Vector2D(-0.5, 0.5),
-            new Vector2D( 0.5, 2.5),
-            new Vector2D( 2.5, 0.5),
-            new Vector2D( 3.5, 2.5)
+        checkPoints(Region.Location.OUTSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(-0.5, 0.5),
+            new Coordinates2D( 0.5, 2.5),
+            new Coordinates2D( 2.5, 0.5),
+            new Coordinates2D( 3.5, 2.5)
         });
-        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {
-            new Vector2D(0.0, 0.0),
-            new Vector2D(0.5, 2.0),
-            new Vector2D(2.0, 0.5),
-            new Vector2D(2.5, 1.0),
-            new Vector2D(3.0, 2.5)
+        checkPoints(Region.Location.BOUNDARY, set, new Coordinates2D[] {
+            new Coordinates2D(0.0, 0.0),
+            new Coordinates2D(0.5, 2.0),
+            new Coordinates2D(2.0, 0.5),
+            new Coordinates2D(2.5, 1.0),
+            new Coordinates2D(3.0, 2.5)
         });
 
     }
 
     @Test
     public void testIntersection() {
-        Vector2D[][] vertices1 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0,  0.0),
-                new Vector2D( 2.0,  0.0),
-                new Vector2D( 2.0,  2.0),
-                new Vector2D( 0.0,  2.0)
+        Coordinates2D[][] vertices1 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D( 2.0,  0.0),
+                new Coordinates2D( 2.0,  2.0),
+                new Coordinates2D( 0.0,  2.0)
             }
         };
         PolygonsSet set1 = buildSet(vertices1);
-        Vector2D[][] vertices2 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 1.0,  1.0),
-                new Vector2D( 3.0,  1.0),
-                new Vector2D( 3.0,  3.0),
-                new Vector2D( 1.0,  3.0)
+        Coordinates2D[][] vertices2 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 1.0,  1.0),
+                new Coordinates2D( 3.0,  1.0),
+                new Coordinates2D( 3.0,  3.0),
+                new Coordinates2D( 1.0,  3.0)
             }
         };
         PolygonsSet set2 = buildSet(vertices2);
@@ -474,48 +474,48 @@ public class PolygonsSetTest {
                                                                                        set2.copySelf());
         checkVertices(set1.getVertices(), vertices1);
         checkVertices(set2.getVertices(), vertices2);
-        checkVertices(set.getVertices(), new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 1.0,  1.0),
-                new Vector2D( 2.0,  1.0),
-                new Vector2D( 2.0,  2.0),
-                new Vector2D( 1.0,  2.0)
+        checkVertices(set.getVertices(), new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 1.0,  1.0),
+                new Coordinates2D( 2.0,  1.0),
+                new Coordinates2D( 2.0,  2.0),
+                new Coordinates2D( 1.0,  2.0)
             }
         });
-        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {
-            new Vector2D(1.5, 1.5)
+        checkPoints(Region.Location.INSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(1.5, 1.5)
         });
-        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {
-            new Vector2D(0.5, 1.5),
-            new Vector2D(2.5, 1.5),
-            new Vector2D(1.5, 0.5),
-            new Vector2D(0.5, 0.5)
+        checkPoints(Region.Location.OUTSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(0.5, 1.5),
+            new Coordinates2D(2.5, 1.5),
+            new Coordinates2D(1.5, 0.5),
+            new Coordinates2D(0.5, 0.5)
         });
-        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {
-            new Vector2D(1.0, 1.0),
-            new Vector2D(2.0, 2.0),
-            new Vector2D(1.0, 1.5),
-            new Vector2D(1.5, 2.0)
+        checkPoints(Region.Location.BOUNDARY, set, new Coordinates2D[] {
+            new Coordinates2D(1.0, 1.0),
+            new Coordinates2D(2.0, 2.0),
+            new Coordinates2D(1.0, 1.5),
+            new Coordinates2D(1.5, 2.0)
         });
     }
 
     @Test
     public void testXor() {
-        Vector2D[][] vertices1 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0,  0.0),
-                new Vector2D( 2.0,  0.0),
-                new Vector2D( 2.0,  2.0),
-                new Vector2D( 0.0,  2.0)
+        Coordinates2D[][] vertices1 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D( 2.0,  0.0),
+                new Coordinates2D( 2.0,  2.0),
+                new Coordinates2D( 0.0,  2.0)
             }
         };
         PolygonsSet set1 = buildSet(vertices1);
-        Vector2D[][] vertices2 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 1.0,  1.0),
-                new Vector2D( 3.0,  1.0),
-                new Vector2D( 3.0,  3.0),
-                new Vector2D( 1.0,  3.0)
+        Coordinates2D[][] vertices2 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 1.0,  1.0),
+                new Coordinates2D( 3.0,  1.0),
+                new Coordinates2D( 3.0,  3.0),
+                new Coordinates2D( 1.0,  3.0)
             }
         };
         PolygonsSet set2 = buildSet(vertices2);
@@ -523,70 +523,70 @@ public class PolygonsSetTest {
                                                                               set2.copySelf());
         checkVertices(set1.getVertices(), vertices1);
         checkVertices(set2.getVertices(), vertices2);
-        checkVertices(set.getVertices(), new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0,  0.0),
-                new Vector2D( 2.0,  0.0),
-                new Vector2D( 2.0,  1.0),
-                new Vector2D( 3.0,  1.0),
-                new Vector2D( 3.0,  3.0),
-                new Vector2D( 1.0,  3.0),
-                new Vector2D( 1.0,  2.0),
-                new Vector2D( 0.0,  2.0)
+        checkVertices(set.getVertices(), new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D( 2.0,  0.0),
+                new Coordinates2D( 2.0,  1.0),
+                new Coordinates2D( 3.0,  1.0),
+                new Coordinates2D( 3.0,  3.0),
+                new Coordinates2D( 1.0,  3.0),
+                new Coordinates2D( 1.0,  2.0),
+                new Coordinates2D( 0.0,  2.0)
             },
-            new Vector2D[] {
-                new Vector2D( 1.0,  1.0),
-                new Vector2D( 1.0,  2.0),
-                new Vector2D( 2.0,  2.0),
-                new Vector2D( 2.0,  1.0)
+            new Coordinates2D[] {
+                new Coordinates2D( 1.0,  1.0),
+                new Coordinates2D( 1.0,  2.0),
+                new Coordinates2D( 2.0,  2.0),
+                new Coordinates2D( 2.0,  1.0)
             }
         });
-        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {
-            new Vector2D(0.5, 0.5),
-            new Vector2D(2.5, 2.5),
-            new Vector2D(0.5, 1.5),
-            new Vector2D(1.5, 0.5),
-            new Vector2D(1.5, 2.5),
-            new Vector2D(2.5, 1.5),
-            new Vector2D(2.5, 2.5)
+        checkPoints(Region.Location.INSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(0.5, 0.5),
+            new Coordinates2D(2.5, 2.5),
+            new Coordinates2D(0.5, 1.5),
+            new Coordinates2D(1.5, 0.5),
+            new Coordinates2D(1.5, 2.5),
+            new Coordinates2D(2.5, 1.5),
+            new Coordinates2D(2.5, 2.5)
         });
-        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {
-            new Vector2D(-0.5, 0.5),
-            new Vector2D( 0.5, 2.5),
-            new Vector2D( 2.5, 0.5),
-            new Vector2D( 1.5, 1.5),
-            new Vector2D( 3.5, 2.5)
+        checkPoints(Region.Location.OUTSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(-0.5, 0.5),
+            new Coordinates2D( 0.5, 2.5),
+            new Coordinates2D( 2.5, 0.5),
+            new Coordinates2D( 1.5, 1.5),
+            new Coordinates2D( 3.5, 2.5)
         });
-        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {
-            new Vector2D(1.0, 1.0),
-            new Vector2D(2.0, 2.0),
-            new Vector2D(1.5, 1.0),
-            new Vector2D(2.0, 1.5),
-            new Vector2D(0.0, 0.0),
-            new Vector2D(0.5, 2.0),
-            new Vector2D(2.0, 0.5),
-            new Vector2D(2.5, 1.0),
-            new Vector2D(3.0, 2.5)
+        checkPoints(Region.Location.BOUNDARY, set, new Coordinates2D[] {
+            new Coordinates2D(1.0, 1.0),
+            new Coordinates2D(2.0, 2.0),
+            new Coordinates2D(1.5, 1.0),
+            new Coordinates2D(2.0, 1.5),
+            new Coordinates2D(0.0, 0.0),
+            new Coordinates2D(0.5, 2.0),
+            new Coordinates2D(2.0, 0.5),
+            new Coordinates2D(2.5, 1.0),
+            new Coordinates2D(3.0, 2.5)
         });
     }
 
     @Test
     public void testDifference() {
-        Vector2D[][] vertices1 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0,  0.0),
-                new Vector2D( 2.0,  0.0),
-                new Vector2D( 2.0,  2.0),
-                new Vector2D( 0.0,  2.0)
+        Coordinates2D[][] vertices1 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D( 2.0,  0.0),
+                new Coordinates2D( 2.0,  2.0),
+                new Coordinates2D( 0.0,  2.0)
             }
         };
         PolygonsSet set1 = buildSet(vertices1);
-        Vector2D[][] vertices2 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 1.0,  1.0),
-                new Vector2D( 3.0,  1.0),
-                new Vector2D( 3.0,  3.0),
-                new Vector2D( 1.0,  3.0)
+        Coordinates2D[][] vertices2 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 1.0,  1.0),
+                new Coordinates2D( 3.0,  1.0),
+                new Coordinates2D( 3.0,  3.0),
+                new Coordinates2D( 1.0,  3.0)
             }
         };
         PolygonsSet set2 = buildSet(vertices2);
@@ -594,62 +594,62 @@ public class PolygonsSetTest {
                                                                                      set2.copySelf());
         checkVertices(set1.getVertices(), vertices1);
         checkVertices(set2.getVertices(), vertices2);
-        checkVertices(set.getVertices(), new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.0,  0.0),
-                new Vector2D( 2.0,  0.0),
-                new Vector2D( 2.0,  1.0),
-                new Vector2D( 1.0,  1.0),
-                new Vector2D( 1.0,  2.0),
-                new Vector2D( 0.0,  2.0)
+        checkVertices(set.getVertices(), new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.0,  0.0),
+                new Coordinates2D( 2.0,  0.0),
+                new Coordinates2D( 2.0,  1.0),
+                new Coordinates2D( 1.0,  1.0),
+                new Coordinates2D( 1.0,  2.0),
+                new Coordinates2D( 0.0,  2.0)
             }
         });
-        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {
-            new Vector2D(0.5, 0.5),
-            new Vector2D(0.5, 1.5),
-            new Vector2D(1.5, 0.5)
+        checkPoints(Region.Location.INSIDE, set, new Coordinates2D[] {
+            new Coordinates2D(0.5, 0.5),
+            new Coordinates2D(0.5, 1.5),
+            new Coordinates2D(1.5, 0.5)
         });
-        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {
-            new Vector2D( 2.5, 2.5),
-            new Vector2D(-0.5, 0.5),
-            new Vector2D( 0.5, 2.5),
-            new Vector2D( 2.5, 0.5),
-            new Vector2D( 1.5, 1.5),
-            new Vector2D( 3.5, 2.5),
-            new Vector2D( 1.5, 2.5),
-            new Vector2D( 2.5, 1.5),
-            new Vector2D( 2.0, 1.5),
-            new Vector2D( 2.0, 2.0),
-            new Vector2D( 2.5, 1.0),
-            new Vector2D( 2.5, 2.5),
-            new Vector2D( 3.0, 2.5)
+        checkPoints(Region.Location.OUTSIDE, set, new Coordinates2D[] {
+            new Coordinates2D( 2.5, 2.5),
+            new Coordinates2D(-0.5, 0.5),
+            new Coordinates2D( 0.5, 2.5),
+            new Coordinates2D( 2.5, 0.5),
+            new Coordinates2D( 1.5, 1.5),
+            new Coordinates2D( 3.5, 2.5),
+            new Coordinates2D( 1.5, 2.5),
+            new Coordinates2D( 2.5, 1.5),
+            new Coordinates2D( 2.0, 1.5),
+            new Coordinates2D( 2.0, 2.0),
+            new Coordinates2D( 2.5, 1.0),
+            new Coordinates2D( 2.5, 2.5),
+            new Coordinates2D( 3.0, 2.5)
         });
-        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {
-            new Vector2D(1.0, 1.0),
-            new Vector2D(1.5, 1.0),
-            new Vector2D(0.0, 0.0),
-            new Vector2D(0.5, 2.0),
-            new Vector2D(2.0, 0.5)
+        checkPoints(Region.Location.BOUNDARY, set, new Coordinates2D[] {
+            new Coordinates2D(1.0, 1.0),
+            new Coordinates2D(1.5, 1.0),
+            new Coordinates2D(0.0, 0.0),
+            new Coordinates2D(0.5, 2.0),
+            new Coordinates2D(2.0, 0.5)
         });
     }
 
     @Test
     public void testEmptyDifference() {
-        Vector2D[][] vertices1 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.5, 3.5),
-                new Vector2D( 0.5, 4.5),
-                new Vector2D(-0.5, 4.5),
-                new Vector2D(-0.5, 3.5)
+        Coordinates2D[][] vertices1 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.5, 3.5),
+                new Coordinates2D( 0.5, 4.5),
+                new Coordinates2D(-0.5, 4.5),
+                new Coordinates2D(-0.5, 3.5)
             }
         };
         PolygonsSet set1 = buildSet(vertices1);
-        Vector2D[][] vertices2 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 1.0, 2.0),
-                new Vector2D( 1.0, 8.0),
-                new Vector2D(-1.0, 8.0),
-                new Vector2D(-1.0, 2.0)
+        Coordinates2D[][] vertices2 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 1.0, 2.0),
+                new Coordinates2D( 1.0, 8.0),
+                new Coordinates2D(-1.0, 8.0),
+                new Coordinates2D(-1.0, 2.0)
             }
         };
         PolygonsSet set2 = buildSet(vertices2);
@@ -661,13 +661,13 @@ public class PolygonsSetTest {
         double pi6   = FastMath.PI / 6.0;
         double sqrt3 = FastMath.sqrt(3.0);
         SubLine[] hyp = {
-            new Line(new Vector2D(   0.0, 1.0),  5 * pi6, 1.0e-10).wholeHyperplane(),
-            new Line(new Vector2D(-sqrt3, 1.0),  7 * pi6, 1.0e-10).wholeHyperplane(),
-            new Line(new Vector2D(-sqrt3, 1.0),  9 * pi6, 1.0e-10).wholeHyperplane(),
-            new Line(new Vector2D(-sqrt3, 0.0), 11 * pi6, 1.0e-10).wholeHyperplane(),
-            new Line(new Vector2D(   0.0, 0.0), 13 * pi6, 1.0e-10).wholeHyperplane(),
-            new Line(new Vector2D(   0.0, 1.0),  3 * pi6, 1.0e-10).wholeHyperplane(),
-            new Line(new Vector2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6, 1.0e-10).wholeHyperplane()
+            new Line(new Coordinates2D(   0.0, 1.0),  5 * pi6, 1.0e-10).wholeHyperplane(),
+            new Line(new Coordinates2D(-sqrt3, 1.0),  7 * pi6, 1.0e-10).wholeHyperplane(),
+            new Line(new Coordinates2D(-sqrt3, 1.0),  9 * pi6, 1.0e-10).wholeHyperplane(),
+            new Line(new Coordinates2D(-sqrt3, 0.0), 11 * pi6, 1.0e-10).wholeHyperplane(),
+            new Line(new Coordinates2D(   0.0, 0.0), 13 * pi6, 1.0e-10).wholeHyperplane(),
+            new Line(new Coordinates2D(   0.0, 1.0),  3 * pi6, 1.0e-10).wholeHyperplane(),
+            new Line(new Coordinates2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6, 1.0e-10).wholeHyperplane()
         };
         hyp[1] = (SubLine) hyp[1].split(hyp[0].getHyperplane()).getMinus();
         hyp[2] = (SubLine) hyp[2].split(hyp[1].getHyperplane()).getMinus();
@@ -681,14 +681,14 @@ public class PolygonsSetTest {
         }
         PolygonsSet set = new PolygonsSet(tree, 1.0e-10);
         SubLine splitter =
-            new Line(new Vector2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6, 1.0e-10).wholeHyperplane();
+            new Line(new Coordinates2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6, 1.0e-10).wholeHyperplane();
         PolygonsSet slice =
             new PolygonsSet(new BSPTree<>(splitter,
                                                      set.getTree(false).split(splitter).getPlus(),
                                                      new BSPTree<Euclidean2D>(Boolean.FALSE), null),
                             1.0e-10);
         Assert.assertEquals(Region.Location.OUTSIDE,
-                            slice.checkPoint(new Vector2D(0.1, 0.5)));
+                            slice.checkPoint(new Coordinates2D(0.1, 0.5)));
         Assert.assertEquals(11.0 / 3.0, slice.getBoundarySize(), 1.0e-10);
 
     }
@@ -696,27 +696,27 @@ public class PolygonsSetTest {
     @Test
     public void testConcentric() {
         double h = FastMath.sqrt(3.0) / 2.0;
-        Vector2D[][] vertices1 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.00, 0.1 * h),
-                new Vector2D( 0.05, 0.1 * h),
-                new Vector2D( 0.10, 0.2 * h),
-                new Vector2D( 0.05, 0.3 * h),
-                new Vector2D(-0.05, 0.3 * h),
-                new Vector2D(-0.10, 0.2 * h),
-                new Vector2D(-0.05, 0.1 * h)
+        Coordinates2D[][] vertices1 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.00, 0.1 * h),
+                new Coordinates2D( 0.05, 0.1 * h),
+                new Coordinates2D( 0.10, 0.2 * h),
+                new Coordinates2D( 0.05, 0.3 * h),
+                new Coordinates2D(-0.05, 0.3 * h),
+                new Coordinates2D(-0.10, 0.2 * h),
+                new Coordinates2D(-0.05, 0.1 * h)
             }
         };
         PolygonsSet set1 = buildSet(vertices1);
-        Vector2D[][] vertices2 = new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D( 0.00, 0.0 * h),
-                new Vector2D( 0.10, 0.0 * h),
-                new Vector2D( 0.20, 0.2 * h),
-                new Vector2D( 0.10, 0.4 * h),
-                new Vector2D(-0.10, 0.4 * h),
-                new Vector2D(-0.20, 0.2 * h),
-                new Vector2D(-0.10, 0.0 * h)
+        Coordinates2D[][] vertices2 = new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D( 0.00, 0.0 * h),
+                new Coordinates2D( 0.10, 0.0 * h),
+                new Coordinates2D( 0.20, 0.2 * h),
+                new Coordinates2D( 0.10, 0.4 * h),
+                new Coordinates2D(-0.10, 0.4 * h),
+                new Coordinates2D(-0.20, 0.2 * h),
+                new Coordinates2D(-0.10, 0.0 * h)
             }
         };
         PolygonsSet set2 = buildSet(vertices2);
@@ -726,126 +726,126 @@ public class PolygonsSetTest {
     @Test
     public void testBug20040520() {
         BSPTree<Euclidean2D> a0 =
-            new BSPTree<>(buildSegment(new Vector2D(0.85, -0.05),
-                                                  new Vector2D(0.90, -0.10)),
+            new BSPTree<>(buildSegment(new Coordinates2D(0.85, -0.05),
+                                                  new Coordinates2D(0.90, -0.10)),
                                                   new BSPTree<Euclidean2D>(Boolean.FALSE),
                                                   new BSPTree<Euclidean2D>(Boolean.TRUE),
                                                   null);
         BSPTree<Euclidean2D> a1 =
-            new BSPTree<>(buildSegment(new Vector2D(0.85, -0.10),
-                                                  new Vector2D(0.90, -0.10)),
+            new BSPTree<>(buildSegment(new Coordinates2D(0.85, -0.10),
+                                                  new Coordinates2D(0.90, -0.10)),
                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), a0, null);
         BSPTree<Euclidean2D> a2 =
-            new BSPTree<>(buildSegment(new Vector2D(0.90, -0.05),
-                                                  new Vector2D(0.85, -0.05)),
+            new BSPTree<>(buildSegment(new Coordinates2D(0.90, -0.05),
+                                                  new Coordinates2D(0.85, -0.05)),
                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), a1, null);
         BSPTree<Euclidean2D> a3 =
-            new BSPTree<>(buildSegment(new Vector2D(0.82, -0.05),
-                                                  new Vector2D(0.82, -0.08)),
+            new BSPTree<>(buildSegment(new Coordinates2D(0.82, -0.05),
+                                                  new Coordinates2D(0.82, -0.08)),
                                                   new BSPTree<Euclidean2D>(Boolean.FALSE),
                                                   new BSPTree<Euclidean2D>(Boolean.TRUE),
                                                   null);
         BSPTree<Euclidean2D> a4 =
-            new BSPTree<>(buildHalfLine(new Vector2D(0.85, -0.05),
-                                                   new Vector2D(0.80, -0.05),
+            new BSPTree<>(buildHalfLine(new Coordinates2D(0.85, -0.05),
+                                                   new Coordinates2D(0.80, -0.05),
                                                    false),
                                                    new BSPTree<Euclidean2D>(Boolean.FALSE), a3, null);
         BSPTree<Euclidean2D> a5 =
-            new BSPTree<>(buildSegment(new Vector2D(0.82, -0.08),
-                                                  new Vector2D(0.82, -0.18)),
+            new BSPTree<>(buildSegment(new Coordinates2D(0.82, -0.08),
+                                                  new Coordinates2D(0.82, -0.18)),
                                                   new BSPTree<Euclidean2D>(Boolean.FALSE),
                                                   new BSPTree<Euclidean2D>(Boolean.TRUE),
                                                   null);
         BSPTree<Euclidean2D> a6 =
-            new BSPTree<>(buildHalfLine(new Vector2D(0.82, -0.18),
-                                                   new Vector2D(0.85, -0.15),
+            new BSPTree<>(buildHalfLine(new Coordinates2D(0.82, -0.18),
+                                                   new Coordinates2D(0.85, -0.15),
                                                    true),
                                                    new BSPTree<Euclidean2D>(Boolean.FALSE), a5, null);
         BSPTree<Euclidean2D> a7 =
-            new BSPTree<>(buildHalfLine(new Vector2D(0.85, -0.05),
-                                                   new Vector2D(0.82, -0.08),
+            new BSPTree<>(buildHalfLine(new Coordinates2D(0.85, -0.05),
+                                                   new Coordinates2D(0.82, -0.08),
                                                    false),
                                                    a4, a6, null);
         BSPTree<Euclidean2D> a8 =
-            new BSPTree<>(buildLine(new Vector2D(0.85, -0.25),
-                                               new Vector2D(0.85,  0.05)),
+            new BSPTree<>(buildLine(new Coordinates2D(0.85, -0.25),
+                                               new Coordinates2D(0.85,  0.05)),
                                                a2, a7, null);
         BSPTree<Euclidean2D> a9 =
-            new BSPTree<>(buildLine(new Vector2D(0.90,  0.05),
-                                               new Vector2D(0.90, -0.50)),
+            new BSPTree<>(buildLine(new Coordinates2D(0.90,  0.05),
+                                               new Coordinates2D(0.90, -0.50)),
                                                a8, new BSPTree<Euclidean2D>(Boolean.FALSE), null);
 
         BSPTree<Euclidean2D> b0 =
-            new BSPTree<>(buildSegment(new Vector2D(0.92, -0.12),
-                                                  new Vector2D(0.92, -0.08)),
+            new BSPTree<>(buildSegment(new Coordinates2D(0.92, -0.12),
+                                                  new Coordinates2D(0.92, -0.08)),
                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE),
                                                   null);
         BSPTree<Euclidean2D> b1 =
-            new BSPTree<>(buildHalfLine(new Vector2D(0.92, -0.08),
-                                                   new Vector2D(0.90, -0.10),
+            new BSPTree<>(buildHalfLine(new Coordinates2D(0.92, -0.08),
+                                                   new Coordinates2D(0.90, -0.10),
                                                    true),
                                                    new BSPTree<Euclidean2D>(Boolean.FALSE), b0, null);
         BSPTree<Euclidean2D> b2 =
-            new BSPTree<>(buildSegment(new Vector2D(0.92, -0.18),
-                                                  new Vector2D(0.92, -0.12)),
+            new BSPTree<>(buildSegment(new Coordinates2D(0.92, -0.18),
+                                                  new Coordinates2D(0.92, -0.12)),
                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE),
                                                   null);
         BSPTree<Euclidean2D> b3 =
-            new BSPTree<>(buildSegment(new Vector2D(0.85, -0.15),
-                                                  new Vector2D(0.90, -0.20)),
+            new BSPTree<>(buildSegment(new Coordinates2D(0.85, -0.15),
+                                                  new Coordinates2D(0.90, -0.20)),
                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), b2, null);
         BSPTree<Euclidean2D> b4 =
-            new BSPTree<>(buildSegment(new Vector2D(0.95, -0.15),
-                                                  new Vector2D(0.85, -0.05)),
+            new BSPTree<>(buildSegment(new Coordinates2D(0.95, -0.15),
+                                                  new Coordinates2D(0.85, -0.05)),
                                                   b1, b3, null);
         BSPTree<Euclidean2D> b5 =
-            new BSPTree<>(buildHalfLine(new Vector2D(0.85, -0.05),
-                                                   new Vector2D(0.85, -0.25),
+            new BSPTree<>(buildHalfLine(new Coordinates2D(0.85, -0.05),
+                                                   new Coordinates2D(0.85, -0.25),
                                                    true),
                                                    new BSPTree<Euclidean2D>(Boolean.FALSE), b4, null);
         BSPTree<Euclidean2D> b6 =
-            new BSPTree<>(buildLine(new Vector2D(0.0, -1.10),
-                                               new Vector2D(1.0, -0.10)),
+            new BSPTree<>(buildLine(new Coordinates2D(0.0, -1.10),
+                                               new Coordinates2D(1.0, -0.10)),
                                                new BSPTree<Euclidean2D>(Boolean.FALSE), b5, null);
 
         PolygonsSet c =
             (PolygonsSet) new RegionFactory<Euclidean2D>().union(new PolygonsSet(a9, 1.0e-10),
                                                                  new PolygonsSet(b6, 1.0e-10));
 
-        checkPoints(Region.Location.INSIDE, c, new Vector2D[] {
-            new Vector2D(0.83, -0.06),
-            new Vector2D(0.83, -0.15),
-            new Vector2D(0.88, -0.15),
-            new Vector2D(0.88, -0.09),
-            new Vector2D(0.88, -0.07),
-            new Vector2D(0.91, -0.18),
-            new Vector2D(0.91, -0.10)
+        checkPoints(Region.Location.INSIDE, c, new Coordinates2D[] {
+            new Coordinates2D(0.83, -0.06),
+            new Coordinates2D(0.83, -0.15),
+            new Coordinates2D(0.88, -0.15),
+            new Coordinates2D(0.88, -0.09),
+            new Coordinates2D(0.88, -0.07),
+            new Coordinates2D(0.91, -0.18),
+            new Coordinates2D(0.91, -0.10)
         });
 
-        checkPoints(Region.Location.OUTSIDE, c, new Vector2D[] {
-            new Vector2D(0.80, -0.10),
-            new Vector2D(0.83, -0.50),
-            new Vector2D(0.83, -0.20),
-            new Vector2D(0.83, -0.02),
-            new Vector2D(0.87, -0.50),
-            new Vector2D(0.87, -0.20),
-            new Vector2D(0.87, -0.02),
-            new Vector2D(0.91, -0.20),
-            new Vector2D(0.91, -0.08),
-            new Vector2D(0.93, -0.15)
+        checkPoints(Region.Location.OUTSIDE, c, new Coordinates2D[] {
+            new Coordinates2D(0.80, -0.10),
+            new Coordinates2D(0.83, -0.50),
+            new Coordinates2D(0.83, -0.20),
+            new Coordinates2D(0.83, -0.02),
+            new Coordinates2D(0.87, -0.50),
+            new Coordinates2D(0.87, -0.20),
+            new Coordinates2D(0.87, -0.02),
+            new Coordinates2D(0.91, -0.20),
+            new Coordinates2D(0.91, -0.08),
+            new Coordinates2D(0.93, -0.15)
         });
 
         checkVertices(c.getVertices(),
-                      new Vector2D[][] {
-            new Vector2D[] {
-                new Vector2D(0.85, -0.15),
-                new Vector2D(0.90, -0.20),
-                new Vector2D(0.92, -0.18),
-                new Vector2D(0.92, -0.08),
-                new Vector2D(0.90, -0.10),
-                new Vector2D(0.90, -0.05),
-                new Vector2D(0.82, -0.05),
-                new Vector2D(0.82, -0.18),
+                      new Coordinates2D[][] {
+            new Coordinates2D[] {
+                new Coordinates2D(0.85, -0.15),
+                new Coordinates2D(0.90, -0.20),
+                new Coordinates2D(0.92, -0.18),
+                new Coordinates2D(0.92, -0.08),
+                new Coordinates2D(0.90, -0.10),
+                new Coordinates2D(0.90, -0.05),
+                new Coordinates2D(0.82, -0.05),
+                new Coordinates2D(0.82, -0.18),
             }
         });
 
@@ -855,14 +855,14 @@ public class PolygonsSetTest {
     public void testBug20041003() {
 
         Line[] l = {
-            new Line(new Vector2D(0.0, 0.625000007541172),
-                     new Vector2D(1.0, 0.625000007541172), 1.0e-10),
-            new Line(new Vector2D(-0.19204433621902645, 0.0),
-                     new Vector2D(-0.19204433621902645, 1.0), 1.0e-10),
-            new Line(new Vector2D(-0.40303524786887,  0.4248364535319128),
-                     new Vector2D(-1.12851149797877, -0.2634107480798909), 1.0e-10),
-            new Line(new Vector2D(0.0, 2.0),
-                     new Vector2D(1.0, 2.0), 1.0e-10)
+            new Line(new Coordinates2D(0.0, 0.625000007541172),
+                     new Coordinates2D(1.0, 0.625000007541172), 1.0e-10),
+            new Line(new Coordinates2D(-0.19204433621902645, 0.0),
+                     new Coordinates2D(-0.19204433621902645, 1.0), 1.0e-10),
+            new Line(new Coordinates2D(-0.40303524786887,  0.4248364535319128),
+                     new Coordinates2D(-1.12851149797877, -0.2634107480798909), 1.0e-10),
+            new Line(new Coordinates2D(0.0, 2.0),
+                     new Coordinates2D(1.0, 2.0), 1.0e-10)
         };
 
         BSPTree<Euclidean2D> node1 =
@@ -902,182 +902,182 @@ public class PolygonsSetTest {
     @Test
     public void testSqueezedHexa() {
         PolygonsSet set = new PolygonsSet(1.0e-10,
-                                          new Vector2D(-6, -4), new Vector2D(-8, -8), new Vector2D(  8, -8),
-                                          new Vector2D( 6, -4), new Vector2D(10,  4), new Vector2D(-10,  4));
-        Assert.assertEquals(Location.OUTSIDE, set.checkPoint(new Vector2D(0, 6)));
+                                          new Coordinates2D(-6, -4), new Coordinates2D(-8, -8), new Coordinates2D(  8, -8),
+                                          new Coordinates2D( 6, -4), new Coordinates2D(10,  4), new Coordinates2D(-10,  4));
+        Assert.assertEquals(Location.OUTSIDE, set.checkPoint(new Coordinates2D(0, 6)));
     }
 
     @Test
     public void testIssue880Simplified() {
 
-        Vector2D[] vertices1 = new Vector2D[] {
-            new Vector2D( 90.13595870833188,  38.33604606376991),
-            new Vector2D( 90.14047850603913,  38.34600084496253),
-            new Vector2D( 90.11045289492762,  38.36801537312368),
-            new Vector2D( 90.10871471476526,  38.36878044144294),
-            new Vector2D( 90.10424901707671,  38.374300101757),
-            new Vector2D( 90.0979455456843,   38.373578376172475),
-            new Vector2D( 90.09081227075944,  38.37526295920463),
-            new Vector2D( 90.09081378927135,  38.375193883266434)
+        Coordinates2D[] vertices1 = new Coordinates2D[] {
+            new Coordinates2D( 90.13595870833188,  38.33604606376991),
+            new Coordinates2D( 90.14047850603913,  38.34600084496253),
+            new Coordinates2D( 90.11045289492762,  38.36801537312368),
+            new Coordinates2D( 90.10871471476526,  38.36878044144294),
+            new Coordinates2D( 90.10424901707671,  38.374300101757),
+            new Coordinates2D( 90.0979455456843,   38.373578376172475),
+            new Coordinates2D( 90.09081227075944,  38.37526295920463),
+            new Coordinates2D( 90.09081378927135,  38.375193883266434)
         };
         PolygonsSet set1 = new PolygonsSet(1.0e-10, vertices1);
-        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.12,  38.32)));
-        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.135, 38.355)));
+        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Coordinates2D(90.12,  38.32)));
+        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Coordinates2D(90.135, 38.355)));
 
     }
 
     @Test
     public void testIssue880Complete() {
-        Vector2D[] vertices1 = new Vector2D[] {
-                new Vector2D( 90.08714908223715,  38.370299337260235),
-                new Vector2D( 90.08709517675004,  38.3702895991413),
-                new Vector2D( 90.08401538704919,  38.368849330127944),
-                new Vector2D( 90.08258210430711,  38.367634558585564),
-                new Vector2D( 90.08251455106665,  38.36763409247078),
-                new Vector2D( 90.08106599752608,  38.36761621664249),
-                new Vector2D( 90.08249585300035,  38.36753627557965),
-                new Vector2D( 90.09075743352184,  38.35914647644972),
-                new Vector2D( 90.09099945896571,  38.35896264724079),
-                new Vector2D( 90.09269383800086,  38.34595756121246),
-                new Vector2D( 90.09638631543191,  38.3457988093121),
-                new Vector2D( 90.09666417351019,  38.34523360999418),
-                new Vector2D( 90.1297082145872,  38.337670454923625),
-                new Vector2D( 90.12971687748956,  38.337669827794684),
-                new Vector2D( 90.1240820219179,  38.34328502001131),
-                new Vector2D( 90.13084259656404,  38.34017811765017),
-                new Vector2D( 90.13378567942857,  38.33860579180606),
-                new Vector2D( 90.13519557833206,  38.33621054663689),
-                new Vector2D( 90.13545616732307,  38.33614965452864),
-                new Vector2D( 90.13553111202748,  38.33613962818305),
-                new Vector2D( 90.1356903436448,  38.33610227127048),
-                new Vector2D( 90.13576283227428,  38.33609255422783),
-                new Vector2D( 90.13595870833188,  38.33604606376991),
-                new Vector2D( 90.1361556630693,  38.3360024198866),
-                new Vector2D( 90.13622408795709,  38.335987048115726),
-                new Vector2D( 90.13696189099994,  38.33581914328681),
-                new Vector2D( 90.13746655304897,  38.33616706665265),
-                new Vector2D( 90.13845973716064,  38.33650776167099),
-                new Vector2D( 90.13950901827667,  38.3368469456463),
-                new Vector2D( 90.14393814424852,  38.337591835857495),
-                new Vector2D( 90.14483839716831,  38.337076122362475),
-                new Vector2D( 90.14565474433601,  38.33769000964429),
-                new Vector2D( 90.14569421179482,  38.3377117256905),
-                new Vector2D( 90.14577067124333,  38.33770883625908),
-                new Vector2D( 90.14600350631684,  38.337714326520995),
-                new Vector2D( 90.14600355139731,  38.33771435193319),
-                new Vector2D( 90.14600369112401,  38.33771443882085),
-                new Vector2D( 90.14600382486884,  38.33771453466096),
-                new Vector2D( 90.14600395205912,  38.33771463904344),
-                new Vector2D( 90.14600407214999,  38.337714751520764),
-                new Vector2D( 90.14600418462749,  38.337714871611695),
-                new Vector2D( 90.14600422249327,  38.337714915811034),
-                new Vector2D( 90.14867838361471,  38.34113888210675),
-                new Vector2D( 90.14923750157374,  38.341582537502575),
-                new Vector2D( 90.14877083250991,  38.34160685841391),
-                new Vector2D( 90.14816667319519,  38.34244232585684),
-                new Vector2D( 90.14797696744586,  38.34248455284745),
-                new Vector2D( 90.14484318014337,  38.34385573215269),
-                new Vector2D( 90.14477919958296,  38.3453797747614),
-                new Vector2D( 90.14202393306448,  38.34464324839456),
-                new Vector2D( 90.14198920640195,  38.344651155237216),
-                new Vector2D( 90.14155207025175,  38.34486424263724),
-                new Vector2D( 90.1415196143314,  38.344871730519),
-                new Vector2D( 90.14128611910814,  38.34500196593859),
-                new Vector2D( 90.14047850603913,  38.34600084496253),
-                new Vector2D( 90.14045907000337,  38.34601860032171),
-                new Vector2D( 90.14039496493928,  38.346223030432384),
-                new Vector2D( 90.14037626063737,  38.346240203360026),
-                new Vector2D( 90.14030005823724,  38.34646920000705),
-                new Vector2D( 90.13799164754806,  38.34903093011013),
-                new Vector2D( 90.11045289492762,  38.36801537312368),
-                new Vector2D( 90.10871471476526,  38.36878044144294),
-                new Vector2D( 90.10424901707671,  38.374300101757),
-                new Vector2D( 90.10263482039932,  38.37310041316073),
-                new Vector2D( 90.09834601753448,  38.373615053823414),
-                new Vector2D( 90.0979455456843,  38.373578376172475),
-                new Vector2D( 90.09086514328669,  38.37527884194668),
-                new Vector2D( 90.09084931407364,  38.37590801712463),
-                new Vector2D( 90.09081227075944,  38.37526295920463),
-                new Vector2D( 90.09081378927135,  38.375193883266434)
+        Coordinates2D[] vertices1 = new Coordinates2D[] {
+                new Coordinates2D( 90.08714908223715,  38.370299337260235),
+                new Coordinates2D( 90.08709517675004,  38.3702895991413),
+                new Coordinates2D( 90.08401538704919,  38.368849330127944),
+                new Coordinates2D( 90.08258210430711,  38.367634558585564),
+                new Coordinates2D( 90.08251455106665,  38.36763409247078),
+                new Coordinates2D( 90.08106599752608,  38.36761621664249),
+                new Coordinates2D( 90.08249585300035,  38.36753627557965),
+                new Coordinates2D( 90.09075743352184,  38.35914647644972),
+                new Coordinates2D( 90.09099945896571,  38.35896264724079),
+                new Coordinates2D( 90.09269383800086,  38.34595756121246),
+                new Coordinates2D( 90.09638631543191,  38.3457988093121),
+                new Coordinates2D( 90.09666417351019,  38.34523360999418),
+                new Coordinates2D( 90.1297082145872,  38.337670454923625),
+                new Coordinates2D( 90.12971687748956,  38.337669827794684),
+                new Coordinates2D( 90.1240820219179,  38.34328502001131),
+                new Coordinates2D( 90.13084259656404,  38.34017811765017),
+                new Coordinates2D( 90.13378567942857,  38.33860579180606),
+                new Coordinates2D( 90.13519557833206,  38.33621054663689),
+                new Coordinates2D( 90.13545616732307,  38.33614965452864),
+                new Coordinates2D( 90.13553111202748,  38.33613962818305),
+                new Coordinates2D( 90.1356903436448,  38.33610227127048),
+                new Coordinates2D( 90.13576283227428,  38.33609255422783),
+                new Coordinates2D( 90.13595870833188,  38.33604606376991),
+                new Coordinates2D( 90.1361556630693,  38.3360024198866),
+                new Coordinates2D( 90.13622408795709,  38.335987048115726),
+                new Coordinates2D( 90.13696189099994,  38.33581914328681),
+                new Coordinates2D( 90.13746655304897,  38.33616706665265),
+                new Coordinates2D( 90.13845973716064,  38.33650776167099),
+                new Coordinates2D( 90.13950901827667,  38.3368469456463),
+                new Coordinates2D( 90.14393814424852,  38.337591835857495),
+                new Coordinates2D( 90.14483839716831,  38.337076122362475),
+                new Coordinates2D( 90.14565474433601,  38.33769000964429),
+                new Coordinates2D( 90.14569421179482,  38.3377117256905),
+                new Coordinates2D( 90.14577067124333,  38.33770883625908),
+                new Coordinates2D( 90.14600350631684,  38.337714326520995),
+                new Coordinates2D( 90.14600355139731,  38.33771435193319),
+                new Coordinates2D( 90.14600369112401,  38.33771443882085),
+                new Coordinates2D( 90.14600382486884,  38.33771453466096),
+                new Coordinates2D( 90.14600395205912,  38.33771463904344),
+                new Coordinates2D( 90.14600407214999,  38.337714751520764),
+                new Coordinates2D( 90.14600418462749,  38.337714871611695),
+                new Coordinates2D( 90.14600422249327,  38.337714915811034),
+                new Coordinates2D( 90.14867838361471,  38.34113888210675),
+                new Coordinates2D( 90.14923750157374,  38.341582537502575),
+                new Coordinates2D( 90.14877083250991,  38.34160685841391),
+                new Coordinates2D( 90.14816667319519,  38.34244232585684),
+                new Coordinates2D( 90.14797696744586,  38.34248455284745),
+                new Coordinates2D( 90.14484318014337,  38.34385573215269),
+                new Coordinates2D( 90.14477919958296,  38.3453797747614),
+                new Coordinates2D( 90.14202393306448,  38.34464324839456),
+                new Coordinates2D( 90.14198920640195,  38.344651155237216),
+                new Coordinates2D( 90.14155207025175,  38.34486424263724),
+                new Coordinates2D( 90.1415196143314,  38.344871730519),
+                new Coordinates2D( 90.14128611910814,  38.34500196593859),
+                new Coordinates2D( 90.14047850603913,  38.34600084496253),
+                new Coordinates2D( 90.14045907000337,  38.34601860032171),
+                new Coordinates2D( 90.14039496493928,  38.346223030432384),
+                new Coordinates2D( 90.14037626063737,  38.346240203360026),
+                new Coordinates2D( 90.14030005823724,  38.34646920000705),
+                new Coordinates2D( 90.13799164754806,  38.34903093011013),
+                new Coordinates2D( 90.11045289492762,  38.36801537312368),
+                new Coordinates2D( 90.10871471476526,  38.36878044144294),
+                new Coordinates2D( 90.10424901707671,  38.374300101757),
+                new Coordinates2D( 90.10263482039932,  38.37310041316073),
+                new Coordinates2D( 90.09834601753448,  38.373615053823414),
+                new Coordinates2D( 90.0979455456843,  38.373578376172475),
+                new Coordinates2D( 90.09086514328669,  38.37527884194668),
+                new Coordinates2D( 90.09084931407364,  38.37590801712463),
+                new Coordinates2D( 90.09081227075944,  38.37526295920463),
+                new Coordinates2D( 90.09081378927135,  38.375193883266434)
         };
         PolygonsSet set1 = new PolygonsSet(1.0e-8, vertices1);
-        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0905,  38.3755)));
-        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Vector2D(90.09084, 38.3755)));
-        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0913,  38.3755)));
-        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Vector2D(90.1042,  38.3739)));
-        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Vector2D(90.1111,  38.3673)));
-        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0959,  38.3457)));
-
-        Vector2D[] vertices2 = new Vector2D[] {
-                new Vector2D( 90.13067558880044,  38.36977255037573),
-                new Vector2D( 90.12907570488,  38.36817308242706),
-                new Vector2D( 90.1342774136516,  38.356886880294724),
-                new Vector2D( 90.13090330629757,  38.34664392676211),
-                new Vector2D( 90.13078571364593,  38.344904617518466),
-                new Vector2D( 90.1315602208914,  38.3447185040846),
-                new Vector2D( 90.1316336226821,  38.34470643148342),
-                new Vector2D( 90.134020944832,  38.340936644972885),
-                new Vector2D( 90.13912536387306,  38.335497255122334),
-                new Vector2D( 90.1396178806582,  38.334878075552126),
-                new Vector2D( 90.14083049696671,  38.33316530644106),
-                new Vector2D( 90.14145252901329,  38.33152722916191),
-                new Vector2D( 90.1404779335565,  38.32863516047786),
-                new Vector2D( 90.14282712131586,  38.327504432532066),
-                new Vector2D( 90.14616669875488,  38.3237354115015),
-                new Vector2D( 90.14860976050608,  38.315714862457924),
-                new Vector2D( 90.14999277782437,  38.3164932507504),
-                new Vector2D( 90.15005207194997,  38.316534677663356),
-                new Vector2D( 90.15508513859612,  38.31878731691609),
-                new Vector2D( 90.15919938519221,  38.31852743183782),
-                new Vector2D( 90.16093758658837,  38.31880662005153),
-                new Vector2D( 90.16099420184912,  38.318825953291594),
-                new Vector2D( 90.1665411125756,  38.31859497874757),
-                new Vector2D( 90.16999653861313,  38.32505772048029),
-                new Vector2D( 90.17475243391698,  38.32594398441148),
-                new Vector2D( 90.17940844844992,  38.327427213761325),
-                new Vector2D( 90.20951909541378,  38.330616833491774),
-                new Vector2D( 90.2155400467941,  38.331746223670336),
-                new Vector2D( 90.21559881391778,  38.33175551425302),
-                new Vector2D( 90.21916646426041,  38.332584299620805),
-                new Vector2D( 90.23863749852285,  38.34778978875795),
-                new Vector2D( 90.25459855175802,  38.357790570608984),
-                new Vector2D( 90.25964298227257,  38.356918010203174),
-                new Vector2D( 90.26024593994703,  38.361692743151366),
-                new Vector2D( 90.26146187570015,  38.36311080550837),
-                new Vector2D( 90.26614159359622,  38.36510808579902),
-                new Vector2D( 90.26621342936448,  38.36507942500333),
-                new Vector2D( 90.26652190211962,  38.36494042196722),
-                new Vector2D( 90.26621240678867,  38.365113172030874),
-                new Vector2D( 90.26614057102057,  38.365141832826794),
-                new Vector2D( 90.26380080055299,  38.3660381760273),
-                new Vector2D( 90.26315345241,  38.36670658276421),
-                new Vector2D( 90.26251574942881,  38.367490323488084),
-                new Vector2D( 90.26247873448426,  38.36755266444749),
-                new Vector2D( 90.26234628016698,  38.36787989125406),
-                new Vector2D( 90.26214559424784,  38.36945909356126),
-                new Vector2D( 90.25861728442555,  38.37200753430875),
-                new Vector2D( 90.23905557537864,  38.375405314295904),
-                new Vector2D( 90.22517251874075,  38.38984691662256),
-                new Vector2D( 90.22549955153215,  38.3911564273979),
-                new Vector2D( 90.22434386063355,  38.391476432092134),
-                new Vector2D( 90.22147729457276,  38.39134652252034),
-                new Vector2D( 90.22142070120117,  38.391349167741964),
-                new Vector2D( 90.20665060751588,  38.39475580900313),
-                new Vector2D( 90.20042268367109,  38.39842558622888),
-                new Vector2D( 90.17423771242085,  38.402727751805344),
-                new Vector2D( 90.16756796257476,  38.40913898597597),
-                new Vector2D( 90.16728283954308,  38.411255399912875),
-                new Vector2D( 90.16703538220418,  38.41136059866693),
-                new Vector2D( 90.16725865657685,  38.41013618805954),
-                new Vector2D( 90.16746107640665,  38.40902614307544),
-                new Vector2D( 90.16122795307462,  38.39773101873203)
+        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Coordinates2D(90.0905,  38.3755)));
+        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Coordinates2D(90.09084, 38.3755)));
+        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Coordinates2D(90.0913,  38.3755)));
+        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Coordinates2D(90.1042,  38.3739)));
+        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Coordinates2D(90.1111,  38.3673)));
+        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Coordinates2D(90.0959,  38.3457)));
+
+        Coordinates2D[] vertices2 = new Coordinates2D[] {
+                new Coordinates2D( 90.13067558880044,  38.36977255037573),
+                new Coordinates2D( 90.12907570488,  38.36817308242706),
+                new Coordinates2D( 90.1342774136516,  38.356886880294724),
+                new Coordinates2D( 90.13090330629757,  38.34664392676211),
+                new Coordinates2D( 90.13078571364593,  38.344904617518466),
+                new Coordinates2D( 90.1315602208914,  38.3447185040846),
+                new Coordinates2D( 90.1316336226821,  38.34470643148342),
+                new Coordinates2D( 90.134020944832,  38.340936644972885),
+                new Coordinates2D( 90.13912536387306,  38.335497255122334),
+                new Coordinates2D( 90.1396178806582,  38.334878075552126),
+                new Coordinates2D( 90.14083049696671,  38.33316530644106),
+                new Coordinates2D( 90.14145252901329,  38.33152722916191),
+                new Coordinates2D( 90.1404779335565,  38.32863516047786),
+                new Coordinates2D( 90.14282712131586,  38.327504432532066),
+                new Coordinates2D( 90.14616669875488,  38.3237354115015),
+                new Coordinates2D( 90.14860976050608,  38.315714862457924),
+                new Coordinates2D( 90.14999277782437,  38.3164932507504),
+                new Coordinates2D( 90.15005207194997,  38.316534677663356),
+                new Coordinates2D( 90.15508513859612,  38.31878731691609),
+                new Coordinates2D( 90.15919938519221,  38.31852743183782),
+                new Coordinates2D( 90.16093758658837,  38.31880662005153),
+                new Coordinates2D( 90.16099420184912,  38.318825953291594),
+                new Coordinates2D( 90.1665411125756,  38.31859497874757),
+                new Coordinates2D( 90.16999653861313,  38.32505772048029),
+                new Coordinates2D( 90.17475243391698,  38.32594398441148),
+                new Coordinates2D( 90.17940844844992,  38.327427213761325),
+                new Coordinates2D( 90.20951909541378,  38.330616833491774),
+                new Coordinates2D( 90.2155400467941,  38.331746223670336),
+                new Coordinates2D( 90.21559881391778,  38.33175551425302),
+                new Coordinates2D( 90.21916646426041,  38.332584299620805),
+                new Coordinates2D( 90.23863749852285,  38.34778978875795),
+                new Coordinates2D( 90.25459855175802,  38.357790570608984),
+                new Coordinates2D( 90.25964298227257,  38.356918010203174),
+                new Coordinates2D( 90.26024593994703,  38.361692743151366),
+                new Coordinates2D( 90.26146187570015,  38.36311080550837),
+                new Coordinates2D( 90.26614159359622,  38.36510808579902),
+                new Coordinates2D( 90.26621342936448,  38.36507942500333),
+                new Coordinates2D( 90.26652190211962,  38.36494042196722),
+                new Coordinates2D( 90.26621240678867,  38.365113172030874),
+                new Coordinates2D( 90.26614057102057,  38.365141832826794),
+                new Coordinates2D( 90.26380080055299,  38.3660381760273),
+                new Coordinates2D( 90.26315345241,  38.36670658276421),
+                new Coordinates2D( 90.26251574942881,  38.367490323488084),
+                new Coordinates2D( 90.26247873448426,  38.36755266444749),
+                new Coordinates2D( 90.26234628016698,  38.36787989125406),
+                new Coordinates2D( 90.26214559424784,  38.36945909356126),
+                new Coordinates2D( 90.25861728442555,  38.37200753430875),
+                new Coordinates2D( 90.23905557537864,  38.375405314295904),
+                new Coordinates2D( 90.22517251874075,  38.38984691662256),
+                new Coordinates2D( 90.22549955153215,  38.3911564273979),
+                new Coordinates2D( 90.22434386063355,  38.391476432092134),
+                new Coordinates2D( 90.22147729457276,  38.39134652252034),
+                new Coordinates2D( 90.22142070120117,  38.391349167741964),
+                new Coordinates2D( 90.20665060751588,  38.39475580900313),
+                new Coordinates2D( 90.20042268367109,  38.39842558622888),
+                new Coordinates2D( 90.17423771242085,  38.402727751805344),
+                new Coordinates2D( 90.16756796257476,  38.40913898597597),
+                new Coordinates2D( 90.16728283954308,  38.411255399912875),
+                new Coordinates2D( 90.16703538220418,  38.41136059866693),
+                new Coordinates2D( 90.16725865657685,  38.41013618805954),
+                new Coordinates2D( 90.16746107640665,  38.40902614307544),
+                new Coordinates2D( 90.16122795307462,  38.39773101873203)
         };
         PolygonsSet set2 = new PolygonsSet(1.0e-8, vertices2);
         PolygonsSet set  = (PolygonsSet) new
                 RegionFactory<Euclidean2D>().difference(set1.copySelf(),
                                                         set2.copySelf());
 
-        Vector2D[][] vertices = set.getVertices();
+        Coordinates2D[][] vertices = set.getVertices();
         Assert.assertTrue(vertices[0][0] != null);
         Assert.assertEquals(1, vertices.length);
     }
@@ -1107,17 +1107,17 @@ public class PolygonsSetTest {
     @Test
     public void testIssue1162() {
         PolygonsSet p = new PolygonsSet(1.0e-10,
-                                                new Vector2D(4.267199999996532, -11.928637756014894),
-                                                new Vector2D(4.267200000026445, -14.12360595809307),
-                                                new Vector2D(9.144000000273694, -14.12360595809307),
-                                                new Vector2D(9.144000000233383, -11.928637756020067));
+                                                new Coordinates2D(4.267199999996532, -11.928637756014894),
+                                                new Coordinates2D(4.267200000026445, -14.12360595809307),
+                                                new Coordinates2D(9.144000000273694, -14.12360595809307),
+                                                new Coordinates2D(9.144000000233383, -11.928637756020067));
 
         PolygonsSet w = new PolygonsSet(1.0e-10,
-                                                new Vector2D(2.56735636510452512E-9, -11.933116461089332),
-                                                new Vector2D(2.56735636510452512E-9, -12.393225665247766),
-                                                new Vector2D(2.56735636510452512E-9, -27.785625665247778),
-                                                new Vector2D(4.267200000030211,      -27.785625665247778),
-                                                new Vector2D(4.267200000030211,      -11.933116461089332));
+                                                new Coordinates2D(2.56735636510452512E-9, -11.933116461089332),
+                                                new Coordinates2D(2.56735636510452512E-9, -12.393225665247766),
+                                                new Coordinates2D(2.56735636510452512E-9, -27.785625665247778),
+                                                new Coordinates2D(4.267200000030211,      -27.785625665247778),
+                                                new Coordinates2D(4.267200000030211,      -11.933116461089332));
 
         Assert.assertFalse(p.contains(w));
 
@@ -1127,10 +1127,10 @@ public class PolygonsSetTest {
     public void testThinRectangle() {
 
         RegionFactory<Euclidean2D> factory = new RegionFactory<>();
-        Vector2D pA = new Vector2D(0.0,        1.0);
-        Vector2D pB = new Vector2D(0.0,        0.0);
-        Vector2D pC = new Vector2D(1.0 / 64.0, 0.0);
-        Vector2D pD = new Vector2D(1.0 / 64.0, 1.0);
+        Coordinates2D pA = new Coordinates2D(0.0,        1.0);
+        Coordinates2D pB = new Coordinates2D(0.0,        0.0);
+        Coordinates2D pC = new Coordinates2D(1.0 / 64.0, 0.0);
+        Coordinates2D pD = new Coordinates2D(1.0 / 64.0, 1.0);
 
         // if tolerance is smaller than rectangle width, the rectangle is computed accurately
         Hyperplane<Euclidean2D>[] h1 = new Line[] {
@@ -1163,8 +1163,8 @@ public class PolygonsSetTest {
     @Test(expected=MathIllegalArgumentException.class)
     public void testInconsistentHyperplanes() {
         double tolerance = 1.0e-10;
-        new RegionFactory<Euclidean2D>().buildConvex(new Line(new Vector2D(0, 0), new Vector2D(0, 1), tolerance),
-                                                     new Line(new Vector2D(1, 1), new Vector2D(1, 0), tolerance));
+        new RegionFactory<Euclidean2D>().buildConvex(new Line(new Coordinates2D(0, 0), new Coordinates2D(0, 1), tolerance),
+                                                     new Line(new Coordinates2D(1, 1), new Coordinates2D(1, 0), tolerance));
     }
 
     @Test
@@ -1172,11 +1172,11 @@ public class PolygonsSetTest {
 
         // a simple square will result in a 4 cuts and 5 leafs tree
         PolygonsSet square = new PolygonsSet(1.0e-10,
-                                             new Vector2D(0, 0),
-                                             new Vector2D(1, 0),
-                                             new Vector2D(1, 1),
-                                             new Vector2D(0, 1));
-        Vector2D[][] squareBoundary = square.getVertices();
+                                             new Coordinates2D(0, 0),
+                                             new Coordinates2D(1, 0),
+                                             new Coordinates2D(1, 1),
+                                             new Coordinates2D(0, 1));
+        Coordinates2D[][] squareBoundary = square.getVertices();
         Assert.assertEquals(1, squareBoundary.length);
         Assert.assertEquals(4, squareBoundary[0].length);
         Counter squareCount = new Counter();
@@ -1186,7 +1186,7 @@ public class PolygonsSetTest {
 
         // splitting the square in two halves increases the BSP tree
         // with 3 more cuts and 3 more leaf nodes
-        SubLine cut = new Line(new Vector2D(0.5, 0.5), 0.0, square.getTolerance()).wholeHyperplane();
+        SubLine cut = new Line(new Coordinates2D(0.5, 0.5), 0.0, square.getTolerance()).wholeHyperplane();
         PolygonsSet splitSquare = new PolygonsSet(square.getTree(false).split(cut),
                                                   square.getTolerance());
         Counter splitSquareCount = new Counter();
@@ -1197,7 +1197,7 @@ public class PolygonsSetTest {
         // the number of vertices should not change, as the intermediate vertices
         // at (0.0, 0.5) and (1.0, 0.5) induced by the top level horizontal split
         // should be removed during the boundary extraction process
-        Vector2D[][] splitBoundary = splitSquare.getVertices();
+        Coordinates2D[][] splitBoundary = splitSquare.getVertices();
         Assert.assertEquals(1, splitBoundary.length);
         Assert.assertEquals(4, splitBoundary[0].length);
 
@@ -1238,7 +1238,7 @@ public class PolygonsSetTest {
 
     }
 
-    private PolygonsSet buildSet(Vector2D[][] vertices) {
+    private PolygonsSet buildSet(Coordinates2D[][] vertices) {
         ArrayList<SubHyperplane<Euclidean2D>> edges = new ArrayList<>();
         for (int i = 0; i < vertices.length; ++i) {
             int l = vertices[i].length;
@@ -1249,16 +1249,16 @@ public class PolygonsSetTest {
         return new PolygonsSet(edges, 1.0e-10);
     }
 
-    private SubHyperplane<Euclidean2D> buildLine(Vector2D start, Vector2D end) {
+    private SubHyperplane<Euclidean2D> buildLine(Coordinates2D start, Coordinates2D end) {
         return new Line(start, end, 1.0e-10).wholeHyperplane();
     }
 
     private double intersectionAbscissa(Line l0, Line l1) {
-        Vector2D p = l0.intersection(l1);
+        Coordinates2D p = l0.intersection(l1);
         return (l0.toSubSpace(p)).getX();
     }
 
-    private SubHyperplane<Euclidean2D> buildHalfLine(Vector2D start, Vector2D end,
+    private SubHyperplane<Euclidean2D> buildHalfLine(Coordinates2D start, Coordinates2D end,
                                                      boolean startIsVirtual) {
         Line   line  = new Line(start, end, 1.0e-10);
         double lower = startIsVirtual ? Double.NEGATIVE_INFINITY : (line.toSubSpace(start)).getX();
@@ -1266,7 +1266,7 @@ public class PolygonsSetTest {
         return new SubLine(line, new IntervalsSet(lower, upper, 1.0e-10));
     }
 
-    private SubHyperplane<Euclidean2D> buildSegment(Vector2D start, Vector2D end) {
+    private SubHyperplane<Euclidean2D> buildSegment(Coordinates2D start, Coordinates2D end) {
         Line   line  = new Line(start, end, 1.0e-10);
         double lower = (line.toSubSpace(start)).getX();
         double upper = (line.toSubSpace(end)).getX();
@@ -1274,14 +1274,14 @@ public class PolygonsSetTest {
     }
 
     private void checkPoints(Region.Location expected, PolygonsSet set,
-                             Vector2D[] points) {
+                             Coordinates2D[] points) {
         for (int i = 0; i < points.length; ++i) {
             Assert.assertEquals(expected, set.checkPoint(points[i]));
         }
     }
 
-    private boolean checkInSegment(Vector2D p,
-                                   Vector2D p1, Vector2D p2,
+    private boolean checkInSegment(Coordinates2D p,
+                                   Coordinates2D p1, Coordinates2D p2,
                                    double tolerance) {
         Line line = new Line(p1, p2, 1.0e-10);
         if (line.getOffset(p) < tolerance) {
@@ -1296,16 +1296,16 @@ public class PolygonsSetTest {
         }
     }
 
-    private void checkVertices(Vector2D[][] rebuiltVertices,
-                               Vector2D[][] vertices) {
+    private void checkVertices(Coordinates2D[][] rebuiltVertices,
+                               Coordinates2D[][] vertices) {
 
         // each rebuilt vertex should be in a segment joining two original vertices
         for (int i = 0; i < rebuiltVertices.length; ++i) {
             for (int j = 0; j < rebuiltVertices[i].length; ++j) {
                 boolean inSegment = false;
-                Vector2D p = rebuiltVertices[i][j];
+                Coordinates2D p = rebuiltVertices[i][j];
                 for (int k = 0; k < vertices.length; ++k) {
-                    Vector2D[] loop = vertices[k];
+                    Coordinates2D[] loop = vertices[k];
                     int length = loop.length;
                     for (int l = 0; (! inSegment) && (l < length); ++l) {
                         inSegment = checkInSegment(p, loop[l], loop[(l + 1) % length], 1.0e-10);
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/SegmentTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/SegmentTest.java
index 6c2ea15ca..41f9d7798 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/SegmentTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/SegmentTest.java
@@ -18,7 +18,7 @@ package org.apache.commons.math4.geometry.euclidean.twod;
 
 import org.apache.commons.math4.geometry.euclidean.twod.Line;
 import org.apache.commons.math4.geometry.euclidean.twod.Segment;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.util.FastMath;
 import org.junit.Assert;
 import org.junit.Test;
@@ -27,20 +27,20 @@ public class SegmentTest {
 
     @Test
     public void testDistance() {
-        Vector2D start = new Vector2D(2, 2);
-        Vector2D end = new Vector2D(-2, -2);
+        Coordinates2D start = new Coordinates2D(2, 2);
+        Coordinates2D end = new Coordinates2D(-2, -2);
         Segment segment = new Segment(start, end, new Line(start, end, 1.0e-10));
 
         // distance to center of segment
-        Assert.assertEquals(FastMath.sqrt(2), segment.distance(new Vector2D(1, -1)), 1.0e-10);
+        Assert.assertEquals(FastMath.sqrt(2), segment.distance(new Coordinates2D(1, -1)), 1.0e-10);
 
         // distance a point on segment
-        Assert.assertEquals(FastMath.sin(Math.PI / 4.0), segment.distance(new Vector2D(0, -1)), 1.0e-10);
+        Assert.assertEquals(FastMath.sin(Math.PI / 4.0), segment.distance(new Coordinates2D(0, -1)), 1.0e-10);
 
         // distance to end point
-        Assert.assertEquals(FastMath.sqrt(8), segment.distance(new Vector2D(0, 4)), 1.0e-10);
+        Assert.assertEquals(FastMath.sqrt(8), segment.distance(new Coordinates2D(0, 4)), 1.0e-10);
 
         // distance to start point
-        Assert.assertEquals(FastMath.sqrt(8), segment.distance(new Vector2D(0, -4)), 1.0e-10);
+        Assert.assertEquals(FastMath.sqrt(8), segment.distance(new Coordinates2D(0, -4)), 1.0e-10);
     }
 }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/SubLineTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/SubLineTest.java
index 249c5d7cf..c59ab8cf3 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/SubLineTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/SubLineTest.java
@@ -23,7 +23,7 @@ import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
 import org.apache.commons.math4.geometry.euclidean.twod.Line;
 import org.apache.commons.math4.geometry.euclidean.twod.Segment;
 import org.apache.commons.math4.geometry.euclidean.twod.SubLine;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.partitioning.RegionFactory;
 import org.junit.Assert;
 import org.junit.Test;
@@ -32,19 +32,19 @@ public class SubLineTest {
 
     @Test
     public void testEndPoints() {
-        Vector2D p1 = new Vector2D(-1, -7);
-        Vector2D p2 = new Vector2D(7, -1);
+        Coordinates2D p1 = new Coordinates2D(-1, -7);
+        Coordinates2D p2 = new Coordinates2D(7, -1);
         Segment segment = new Segment(p1, p2, new Line(p1, p2, 1.0e-10));
         SubLine sub = new SubLine(segment);
         List<Segment> segments = sub.getSegments();
         Assert.assertEquals(1, segments.size());
-        Assert.assertEquals(0.0, new Vector2D(-1, -7).distance(segments.get(0).getStart()), 1.0e-10);
-        Assert.assertEquals(0.0, new Vector2D( 7, -1).distance(segments.get(0).getEnd()), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates2D(-1, -7).distance(segments.get(0).getStart()), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates2D( 7, -1).distance(segments.get(0).getEnd()), 1.0e-10);
     }
 
     @Test
     public void testNoEndPoints() {
-        SubLine wholeLine = new Line(new Vector2D(-1, 7), new Vector2D(7, 1), 1.0e-10).wholeHyperplane();
+        SubLine wholeLine = new Line(new Coordinates2D(-1, 7), new Coordinates2D(7, 1), 1.0e-10).wholeHyperplane();
         List<Segment> segments = wholeLine.getSegments();
         Assert.assertEquals(1, segments.size());
         Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&
@@ -59,7 +59,7 @@ public class SubLineTest {
 
     @Test
     public void testNoSegments() {
-        SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1), 1.0e-10),
+        SubLine empty = new SubLine(new Line(new Coordinates2D(-1, -7), new Coordinates2D(7, -1), 1.0e-10),
                                     new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet(1.0e-10)));
         List<Segment> segments = empty.getSegments();
         Assert.assertEquals(0, segments.size());
@@ -67,7 +67,7 @@ public class SubLineTest {
 
     @Test
     public void testSeveralSegments() {
-        SubLine twoSubs = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1), 1.0e-10),
+        SubLine twoSubs = new SubLine(new Line(new Coordinates2D(-1, -7), new Coordinates2D(7, -1), 1.0e-10),
                                     new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2, 1.0e-10),
                                                                            new IntervalsSet(3, 4, 1.0e-10)));
         List<Segment> segments = twoSubs.getSegments();
@@ -76,7 +76,7 @@ public class SubLineTest {
 
     @Test
     public void testHalfInfiniteNeg() {
-        SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1), 1.0e-10),
+        SubLine empty = new SubLine(new Line(new Coordinates2D(-1, -7), new Coordinates2D(7, -1), 1.0e-10),
                                     new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0, 1.0e-10));
         List<Segment> segments = empty.getSegments();
         Assert.assertEquals(1, segments.size());
@@ -84,16 +84,16 @@ public class SubLineTest {
                           segments.get(0).getStart().getX() < 0);
         Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) &&
                           segments.get(0).getStart().getY() < 0);
-        Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getEnd()), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates2D(3, -4).distance(segments.get(0).getEnd()), 1.0e-10);
     }
 
     @Test
     public void testHalfInfinitePos() {
-        SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1), 1.0e-10),
+        SubLine empty = new SubLine(new Line(new Coordinates2D(-1, -7), new Coordinates2D(7, -1), 1.0e-10),
                                     new IntervalsSet(0.0, Double.POSITIVE_INFINITY, 1.0e-10));
         List<Segment> segments = empty.getSegments();
         Assert.assertEquals(1, segments.size());
-        Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getStart()), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates2D(3, -4).distance(segments.get(0).getStart()), 1.0e-10);
         Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&
                           segments.get(0).getEnd().getX() > 0);
         Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&
@@ -102,56 +102,56 @@ public class SubLineTest {
 
     @Test
     public void testIntersectionInsideInside() {
-        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 2), 1.0e-10);
-        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
-        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);
+        SubLine sub1 = new SubLine(new Coordinates2D(1, 1), new Coordinates2D(3, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates2D(2, 0), new Coordinates2D(2, 2), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
+        Assert.assertEquals(0.0, new Coordinates2D(2, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);
     }
 
     @Test
     public void testIntersectionInsideBoundary() {
-        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1), 1.0e-10);
-        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
+        SubLine sub1 = new SubLine(new Coordinates2D(1, 1), new Coordinates2D(3, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates2D(2, 0), new Coordinates2D(2, 1), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionInsideOutside() {
-        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5), 1.0e-10);
+        SubLine sub1 = new SubLine(new Coordinates2D(1, 1), new Coordinates2D(3, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates2D(2, 0), new Coordinates2D(2, 0.5), 1.0e-10);
         Assert.assertNull(sub1.intersection(sub2, true));
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionBoundaryBoundary() {
-        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1), 1.0e-10);
-        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
+        SubLine sub1 = new SubLine(new Coordinates2D(1, 1), new Coordinates2D(2, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates2D(2, 0), new Coordinates2D(2, 1), 1.0e-10);
+        Assert.assertEquals(0.0, new Coordinates2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionBoundaryOutside() {
-        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5), 1.0e-10);
+        SubLine sub1 = new SubLine(new Coordinates2D(1, 1), new Coordinates2D(2, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates2D(2, 0), new Coordinates2D(2, 0.5), 1.0e-10);
         Assert.assertNull(sub1.intersection(sub2, true));
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionOutsideOutside() {
-        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(1.5, 1), 1.0e-10);
-        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5), 1.0e-10);
+        SubLine sub1 = new SubLine(new Coordinates2D(1, 1), new Coordinates2D(1.5, 1), 1.0e-10);
+        SubLine sub2 = new SubLine(new Coordinates2D(2, 0), new Coordinates2D(2, 0.5), 1.0e-10);
         Assert.assertNull(sub1.intersection(sub2, true));
         Assert.assertNull(sub1.intersection(sub2, false));
     }
 
     @Test
     public void testIntersectionParallel() {
-        final SubLine sub1 = new SubLine(new Vector2D(0, 1), new Vector2D(0, 2), 1.0e-10);
-        final SubLine sub2 = new SubLine(new Vector2D(66, 3), new Vector2D(66, 4), 1.0e-10);
+        final SubLine sub1 = new SubLine(new Coordinates2D(0, 1), new Coordinates2D(0, 2), 1.0e-10);
+        final SubLine sub2 = new SubLine(new Coordinates2D(66, 3), new Coordinates2D(66, 4), 1.0e-10);
         Assert.assertNull(sub1.intersection(sub2, true));
         Assert.assertNull(sub1.intersection(sub2, false));
     }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DFormatAbstractTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DFormatAbstractTest.java
index ef1c7650e..491a04d02 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DFormatAbstractTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DFormatAbstractTest.java
@@ -22,7 +22,7 @@ import java.text.ParsePosition;
 import java.util.Locale;
 
 import org.apache.commons.math4.exception.MathParseException;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat;
 import org.junit.Assert;
 import org.junit.Test;
@@ -45,7 +45,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void testSimpleNoDecimals() {
-        Vector2D c = new Vector2D(1, 1);
+        Coordinates2D c = new Coordinates2D(1, 1);
         String expected = "{1; 1}";
         String actual = vector2DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -53,7 +53,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void testSimpleWithDecimals() {
-        Vector2D c = new Vector2D(1.23, 1.43);
+        Coordinates2D c = new Coordinates2D(1.23, 1.43);
         String expected =
             "{1"    + getDecimalCharacter() +
             "23; 1" + getDecimalCharacter() +
@@ -64,7 +64,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void testSimpleWithDecimalsTrunc() {
-        Vector2D c = new Vector2D(1.232323232323, 1.434343434343);
+        Coordinates2D c = new Coordinates2D(1.232323232323, 1.434343434343);
         String expected =
             "{1"    + getDecimalCharacter() +
             "2323232323; 1" + getDecimalCharacter() +
@@ -75,7 +75,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void testNegativeX() {
-        Vector2D c = new Vector2D(-1.232323232323, 1.43);
+        Coordinates2D c = new Coordinates2D(-1.232323232323, 1.43);
         String expected =
             "{-1"    + getDecimalCharacter() +
             "2323232323; 1" + getDecimalCharacter() +
@@ -86,7 +86,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void testNegativeY() {
-        Vector2D c = new Vector2D(1.23, -1.434343434343);
+        Coordinates2D c = new Coordinates2D(1.23, -1.434343434343);
         String expected =
             "{1"    + getDecimalCharacter() +
             "23; -1" + getDecimalCharacter() +
@@ -97,7 +97,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void testNegativeZ() {
-        Vector2D c = new Vector2D(1.23, 1.43);
+        Coordinates2D c = new Coordinates2D(1.23, 1.43);
         String expected =
             "{1"    + getDecimalCharacter() +
             "23; 1" + getDecimalCharacter() +
@@ -108,7 +108,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void testNonDefaultSetting() {
-        Vector2D c = new Vector2D(1, 1);
+        Coordinates2D c = new Coordinates2D(1, 1);
         String expected = "[1 : 1]";
         String actual = vector2DFormatSquare.format(c);
         Assert.assertEquals(expected, actual);
@@ -119,7 +119,7 @@ public abstract class Vector2DFormatAbstractTest {
         Locale defaultLocal = Locale.getDefault();
         Locale.setDefault(getLocale());
 
-        Vector2D c = new Vector2D(232.22222222222, -342.3333333333);
+        Coordinates2D c = new Coordinates2D(232.22222222222, -342.3333333333);
         String expected =
             "{232"    + getDecimalCharacter() +
             "2222222222; -342" + getDecimalCharacter() +
@@ -132,7 +132,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void testNan() {
-        Vector2D c = Vector2D.NaN;
+        Coordinates2D c = Coordinates2D.NaN;
         String expected = "{(NaN); (NaN)}";
         String actual = vector2DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -140,7 +140,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void testPositiveInfinity() {
-        Vector2D c = Vector2D.POSITIVE_INFINITY;
+        Coordinates2D c = Coordinates2D.POSITIVE_INFINITY;
         String expected = "{(Infinity); (Infinity)}";
         String actual = vector2DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -148,7 +148,7 @@ public abstract class Vector2DFormatAbstractTest {
 
     @Test
     public void tesNegativeInfinity() {
-        Vector2D c = Vector2D.NEGATIVE_INFINITY;
+        Coordinates2D c = Coordinates2D.NEGATIVE_INFINITY;
         String expected = "{(-Infinity); (-Infinity)}";
         String actual = vector2DFormat.format(c);
         Assert.assertEquals(expected, actual);
@@ -157,14 +157,14 @@ public abstract class Vector2DFormatAbstractTest {
     @Test
     public void testParseSimpleNoDecimals() throws MathParseException {
         String source = "{1; 1}";
-        Vector2D expected = new Vector2D(1, 1);
-        Vector2D actual = vector2DFormat.parse(source);
+        Coordinates2D expected = new Coordinates2D(1, 1);
+        Coordinates2D actual = vector2DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
     @Test
     public void testParseIgnoredWhitespace() {
-        Vector2D expected = new Vector2D(1, 1);
+        Coordinates2D expected = new Coordinates2D(1, 1);
         ParsePosition pos1 = new ParsePosition(0);
         String source1 = "{1;1}";
         Assert.assertEquals(expected, vector2DFormat.parse(source1, pos1));
@@ -181,8 +181,8 @@ public abstract class Vector2DFormatAbstractTest {
             "{1" + getDecimalCharacter() +
             "23; 1" + getDecimalCharacter() +
             "43}";
-        Vector2D expected = new Vector2D(1.23, 1.43);
-        Vector2D actual = vector2DFormat.parse(source);
+        Coordinates2D expected = new Coordinates2D(1.23, 1.43);
+        Coordinates2D actual = vector2DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -192,8 +192,8 @@ public abstract class Vector2DFormatAbstractTest {
             "{1" + getDecimalCharacter() +
             "2323; 1" + getDecimalCharacter() +
             "4343}";
-        Vector2D expected = new Vector2D(1.2323, 1.4343);
-        Vector2D actual = vector2DFormat.parse(source);
+        Coordinates2D expected = new Coordinates2D(1.2323, 1.4343);
+        Coordinates2D actual = vector2DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -203,8 +203,8 @@ public abstract class Vector2DFormatAbstractTest {
             "{-1" + getDecimalCharacter() +
             "2323; 1" + getDecimalCharacter() +
             "4343}";
-        Vector2D expected = new Vector2D(-1.2323, 1.4343);
-        Vector2D actual = vector2DFormat.parse(source);
+        Coordinates2D expected = new Coordinates2D(-1.2323, 1.4343);
+        Coordinates2D actual = vector2DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -214,8 +214,8 @@ public abstract class Vector2DFormatAbstractTest {
             "{1" + getDecimalCharacter() +
             "2323; -1" + getDecimalCharacter() +
             "4343}";
-        Vector2D expected = new Vector2D(1.2323, -1.4343);
-        Vector2D actual = vector2DFormat.parse(source);
+        Coordinates2D expected = new Coordinates2D(1.2323, -1.4343);
+        Coordinates2D actual = vector2DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -225,8 +225,8 @@ public abstract class Vector2DFormatAbstractTest {
             "{1" + getDecimalCharacter() +
             "2323; 1" + getDecimalCharacter() +
             "4343}";
-        Vector2D expected = new Vector2D(1.2323, 1.4343);
-        Vector2D actual = vector2DFormat.parse(source);
+        Coordinates2D expected = new Coordinates2D(1.2323, 1.4343);
+        Coordinates2D actual = vector2DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -236,8 +236,8 @@ public abstract class Vector2DFormatAbstractTest {
             "{-1" + getDecimalCharacter() +
             "2323; -1" + getDecimalCharacter() +
             "4343}";
-        Vector2D expected = new Vector2D(-1.2323, -1.4343);
-        Vector2D actual = vector2DFormat.parse(source);
+        Coordinates2D expected = new Coordinates2D(-1.2323, -1.4343);
+        Coordinates2D actual = vector2DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -247,8 +247,8 @@ public abstract class Vector2DFormatAbstractTest {
             "{0" + getDecimalCharacter() +
             "0; -1" + getDecimalCharacter() +
             "4343}";
-        Vector2D expected = new Vector2D(0.0, -1.4343);
-        Vector2D actual = vector2DFormat.parse(source);
+        Coordinates2D expected = new Coordinates2D(0.0, -1.4343);
+        Coordinates2D actual = vector2DFormat.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
@@ -258,30 +258,30 @@ public abstract class Vector2DFormatAbstractTest {
             "[1" + getDecimalCharacter() +
             "2323 : 1" + getDecimalCharacter() +
             "4343]";
-        Vector2D expected = new Vector2D(1.2323, 1.4343);
-        Vector2D actual = vector2DFormatSquare.parse(source);
+        Coordinates2D expected = new Coordinates2D(1.2323, 1.4343);
+        Coordinates2D actual = vector2DFormatSquare.parse(source);
         Assert.assertEquals(expected, actual);
     }
 
     @Test
     public void testParseNan() throws MathParseException {
         String source = "{(NaN); (NaN)}";
-        Vector2D actual = vector2DFormat.parse(source);
-        Assert.assertEquals(Vector2D.NaN, actual);
+        Coordinates2D actual = vector2DFormat.parse(source);
+        Assert.assertEquals(Coordinates2D.NaN, actual);
     }
 
     @Test
     public void testParsePositiveInfinity() throws MathParseException {
         String source = "{(Infinity); (Infinity)}";
-        Vector2D actual = vector2DFormat.parse(source);
-        Assert.assertEquals(Vector2D.POSITIVE_INFINITY, actual);
+        Coordinates2D actual = vector2DFormat.parse(source);
+        Assert.assertEquals(Coordinates2D.POSITIVE_INFINITY, actual);
     }
 
     @Test
     public void testParseNegativeInfinity() throws MathParseException {
         String source = "{(-Infinity); (-Infinity)}";
-        Vector2D actual = vector2DFormat.parse(source);
-        Assert.assertEquals(Vector2D.NEGATIVE_INFINITY, actual);
+        Coordinates2D actual = vector2DFormat.parse(source);
+        Assert.assertEquals(Coordinates2D.NEGATIVE_INFINITY, actual);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DTest.java
index 18c36495c..77b68d11a 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DTest.java
@@ -28,11 +28,11 @@ public class Vector2DTest {
 
     @Test
     public void testScaledVectorTripleConstructor() {
-        Vector2D oneOne = new Vector2D(1.0,1.0);
-        Vector2D oneTwo = new Vector2D(1.0,2.0);
-        Vector2D oneThree = new Vector2D(1.0,3.0);
+        Coordinates2D oneOne = new Coordinates2D(1.0,1.0);
+        Coordinates2D oneTwo = new Coordinates2D(1.0,2.0);
+        Coordinates2D oneThree = new Coordinates2D(1.0,3.0);
 
-        Vector2D tripleCombo = new Vector2D(3.0, oneOne, 1.0, oneTwo, 2.5, oneThree);
+        Coordinates2D tripleCombo = new Coordinates2D(3.0, oneOne, 1.0, oneTwo, 2.5, oneThree);
 
         Assert.assertEquals(3.0 * 1 + 1.0 * 1 + 2.5 * 1,tripleCombo.getX(), EPS);
         Assert.assertEquals(3.0 * 1 + 1.0 * 2 + 2.5 * 3,tripleCombo.getY(), EPS);
@@ -40,12 +40,12 @@ public class Vector2DTest {
 
     @Test
     public void testScaledVectorQuadrupleConstructor() {
-        Vector2D oneOne = new Vector2D(1.0, 1.0);
-        Vector2D oneTwo = new Vector2D(1.0, 2.0);
-        Vector2D oneThree = new Vector2D(1.0, 3.0);
-        Vector2D oneFour = new Vector2D(1.0, 4.0);
+        Coordinates2D oneOne = new Coordinates2D(1.0, 1.0);
+        Coordinates2D oneTwo = new Coordinates2D(1.0, 2.0);
+        Coordinates2D oneThree = new Coordinates2D(1.0, 3.0);
+        Coordinates2D oneFour = new Coordinates2D(1.0, 4.0);
 
-        Vector2D tripleCombo = new Vector2D(3.0, oneOne, 1.0, oneTwo, 2.5, oneThree, 2.0, oneFour);
+        Coordinates2D tripleCombo = new Coordinates2D(3.0, oneOne, 1.0, oneTwo, 2.5, oneThree, 2.0, oneFour);
 
         Assert.assertEquals(3.0 * 1.0 + 1.0 * 1.0 + 2.5 * 1.0 + 2.0 * 1.0,tripleCombo.getX(), EPS);
         Assert.assertEquals(3.0 * 1.0 + 1.0 * 2.0 + 2.5 * 3.0 + 2.0 * 4.0,tripleCombo.getY(), EPS);
@@ -55,7 +55,7 @@ public class Vector2DTest {
     public void testConstructorExceptions() {
         double[] v = new double[] {0.0, 1.0, 2.0};
         try {
-            new Vector2D(v);
+            new Coordinates2D(v);
         }
         catch (Exception e) {
             Assert.assertTrue(e instanceof DimensionMismatchException);
@@ -64,7 +64,7 @@ public class Vector2DTest {
 
     @Test
     public void testToArray() {
-        Vector2D oneTwo = new Vector2D(1.0, 2.0);
+        Coordinates2D oneTwo = new Coordinates2D(1.0, 2.0);
         double[] array = oneTwo.toArray();
         Assert.assertEquals(1.0, array[0], EPS);
         Assert.assertEquals(2.0, array[1], EPS);
@@ -72,72 +72,72 @@ public class Vector2DTest {
 
     @Test
     public void testGetZero() {
-        Vector2D zero = (new Vector2D(1.0, 1.0)).getZero();
+        Coordinates2D zero = (new Coordinates2D(1.0, 1.0)).getZero();
         Assert.assertEquals(0.0, zero.getX(), EPS);
         Assert.assertEquals(0.0, zero.getY(), EPS);
     }
 
     @Test
     public void testNorm1() {
-        Vector2D oneTwo = new Vector2D(-1.0, 2.0);
+        Coordinates2D oneTwo = new Coordinates2D(-1.0, 2.0);
         Assert.assertEquals(3.0, oneTwo.getNorm1(), EPS);
     }
 
     @Test
     public void testNormSq() {
-        Vector2D oneTwo = new Vector2D(-1.0, 2.0);
+        Coordinates2D oneTwo = new Coordinates2D(-1.0, 2.0);
         Assert.assertEquals(5.0, oneTwo.getNormSq(), EPS);
     }
 
     @Test
     public void testNormInf() {
-        Vector2D oneTwo = new Vector2D(-1.0, 2.0);
+        Coordinates2D oneTwo = new Coordinates2D(-1.0, 2.0);
         Assert.assertEquals(2.0, oneTwo.getNormInf(), EPS);
     }
 
     @Test
     public void testVectorAddition() {
-        Vector2D minusOneTwo = new Vector2D(-1.0,2.0);
-        Vector2D threeFive = new Vector2D(3.0,5.0);
-        Vector2D addition = minusOneTwo.add(threeFive);
+        Coordinates2D minusOneTwo = new Coordinates2D(-1.0,2.0);
+        Coordinates2D threeFive = new Coordinates2D(3.0,5.0);
+        Coordinates2D addition = minusOneTwo.add(threeFive);
         Assert.assertEquals(2.0, addition.getX(), EPS);
         Assert.assertEquals(7.0, addition.getY(), EPS);
     }
 
     @Test
     public void testScaledVectorAddition() {
-        Vector2D minusOneTwo = new Vector2D(-1.0,2.0);
-        Vector2D threeFive = new Vector2D(3.0,5.0);
-        Vector2D addition = minusOneTwo.add(2.0, threeFive);
+        Coordinates2D minusOneTwo = new Coordinates2D(-1.0,2.0);
+        Coordinates2D threeFive = new Coordinates2D(3.0,5.0);
+        Coordinates2D addition = minusOneTwo.add(2.0, threeFive);
         Assert.assertEquals(5.0, addition.getX(), EPS);
         Assert.assertEquals(12.0, addition.getY(), EPS);
     }
 
     @Test
     public void testVectorSubtraction() {
-        Vector2D minusOneTwo = new Vector2D(-1.0,2.0);
-        Vector2D threeFive = new Vector2D(3.0,5.0);
-        Vector2D addition = minusOneTwo.subtract(threeFive);
+        Coordinates2D minusOneTwo = new Coordinates2D(-1.0,2.0);
+        Coordinates2D threeFive = new Coordinates2D(3.0,5.0);
+        Coordinates2D addition = minusOneTwo.subtract(threeFive);
         Assert.assertEquals(-4.0, addition.getX(), EPS);
         Assert.assertEquals(-3.0, addition.getY(), EPS);
     }
 
     @Test
     public void testScaledVectorSubtraction() {
-        Vector2D minusOneTwo = new Vector2D(-1.0,2.0);
-        Vector2D threeFive = new Vector2D(3.0,5.0);
-        Vector2D addition = minusOneTwo.subtract(2.0, threeFive);
+        Coordinates2D minusOneTwo = new Coordinates2D(-1.0,2.0);
+        Coordinates2D threeFive = new Coordinates2D(3.0,5.0);
+        Coordinates2D addition = minusOneTwo.subtract(2.0, threeFive);
         Assert.assertEquals(-7.0, addition.getX(), EPS);
         Assert.assertEquals(-8.0, addition.getY(), EPS);
     }
 
     @Test
     public void testNormalize() {
-        Vector2D minusOneTwo = new Vector2D(-1.0,2.0);
-        Vector2D normalizedMinusOneTwo = minusOneTwo.normalize();
+        Coordinates2D minusOneTwo = new Coordinates2D(-1.0,2.0);
+        Coordinates2D normalizedMinusOneTwo = minusOneTwo.normalize();
         Assert.assertEquals(-1.0/FastMath.sqrt(5), normalizedMinusOneTwo.getX(), EPS);
         Assert.assertEquals(2.0/FastMath.sqrt(5), normalizedMinusOneTwo.getY(), EPS);
-        Vector2D zero = minusOneTwo.getZero();
+        Coordinates2D zero = minusOneTwo.getZero();
         try {
             zero.normalize();
         }
@@ -148,88 +148,88 @@ public class Vector2DTest {
 
     @Test
     public void testAngle() {
-        Vector2D oneOne = new Vector2D(1.0, 1.0);
+        Coordinates2D oneOne = new Coordinates2D(1.0, 1.0);
         try {
-            Vector2D.angle(oneOne.getZero(), oneOne.getZero());
+            Coordinates2D.angle(oneOne.getZero(), oneOne.getZero());
         }
         catch (Exception e) {
             Assert.assertTrue(e instanceof MathArithmeticException);
         }
-        Vector2D oneZero = new Vector2D(1.0,0.0);
-        double angle = Vector2D.angle(oneOne, oneZero);
+        Coordinates2D oneZero = new Coordinates2D(1.0,0.0);
+        double angle = Coordinates2D.angle(oneOne, oneZero);
         Assert.assertEquals(FastMath.PI/4, angle, EPS);
-        Assert.assertEquals(0.004999958333958323, Vector2D.angle(new Vector2D(20.0,0.0), new Vector2D(20.0,0.1)), EPS);
+        Assert.assertEquals(0.004999958333958323, Coordinates2D.angle(new Coordinates2D(20.0,0.0), new Coordinates2D(20.0,0.1)), EPS);
     }
 
     @Test
     public void testNegate() {
-        Vector2D oneOne = new Vector2D(1.0,1.0);
-        Vector2D negated = oneOne.negate();
+        Coordinates2D oneOne = new Coordinates2D(1.0,1.0);
+        Coordinates2D negated = oneOne.negate();
         Assert.assertEquals(-1.0, negated.getX(), EPS);
         Assert.assertEquals(-1.0, negated.getY(), EPS);
     }
 
     @Test
     public void testIsInfinite() {
-        Vector2D oneOne = new Vector2D(1.0, 1.0);
-        Vector2D infiniteVector = new Vector2D(Double.POSITIVE_INFINITY, 0.0);
+        Coordinates2D oneOne = new Coordinates2D(1.0, 1.0);
+        Coordinates2D infiniteVector = new Coordinates2D(Double.POSITIVE_INFINITY, 0.0);
         Assert.assertFalse(oneOne.isInfinite());
         Assert.assertTrue(infiniteVector.isInfinite());
     }
 
     @Test
     public void testDistance1() {
-        Vector2D oneOne = new Vector2D(1.0,1.0);
-        Vector2D fiveEleven = new Vector2D(5.0,11.0);
+        Coordinates2D oneOne = new Coordinates2D(1.0,1.0);
+        Coordinates2D fiveEleven = new Coordinates2D(5.0,11.0);
         double distance1 = oneOne.distance1(fiveEleven);
         Assert.assertEquals(14.0, distance1, EPS);
     }
 
     @Test
     public void testDistanceInf() {
-        Vector2D oneOne = new Vector2D(1.0,1.0);
-        Vector2D fiveEleven = new Vector2D(5.0,11.0);
+        Coordinates2D oneOne = new Coordinates2D(1.0,1.0);
+        Coordinates2D fiveEleven = new Coordinates2D(5.0,11.0);
         double distanceInf = oneOne.distanceInf(fiveEleven);
-        double staticDistanceInf = Vector2D.distanceInf(oneOne, fiveEleven);
+        double staticDistanceInf = Coordinates2D.distanceInf(oneOne, fiveEleven);
         Assert.assertEquals(10.0, distanceInf, EPS);
         Assert.assertEquals(distanceInf, staticDistanceInf, EPS);
     }
 
     @Test
     public void testDistanceSq() {
-        Vector2D oneFive = new Vector2D(1.0, 5.0);
-        Vector2D fourOne = new Vector2D(4.0, 1.0);
+        Coordinates2D oneFive = new Coordinates2D(1.0, 5.0);
+        Coordinates2D fourOne = new Coordinates2D(4.0, 1.0);
         double distanceSq = oneFive.distanceSq(fourOne);
-        double staticDistanceSq = Vector2D.distanceSq(oneFive, fourOne);
+        double staticDistanceSq = Coordinates2D.distanceSq(oneFive, fourOne);
         Assert.assertEquals(25.0, distanceSq, EPS);
         Assert.assertEquals(distanceSq, staticDistanceSq, EPS);
     }
 
     @Test
     public void testHashCode() {
-        int hashCode = (new Vector2D(1.0,1.0)).hashCode();
+        int hashCode = (new Coordinates2D(1.0,1.0)).hashCode();
         Assert.assertEquals(887095296, hashCode);
-        Assert.assertEquals(542, (new Vector2D(Double.NaN, Double.NaN)).hashCode());
+        Assert.assertEquals(542, (new Coordinates2D(Double.NaN, Double.NaN)).hashCode());
     }
 
 
     @Test
     public void testToString() {
-        Assert.assertEquals("{1; 2}", (new Vector2D(1.0,2.0)).toString());
+        Assert.assertEquals("{1; 2}", (new Coordinates2D(1.0,2.0)).toString());
     }
 
     @Test
     public void testCrossProduct() {
-        Vector2D p1 = new Vector2D(1, 1);
-        Vector2D p2 = new Vector2D(2, 2);
+        Coordinates2D p1 = new Coordinates2D(1, 1);
+        Coordinates2D p2 = new Coordinates2D(2, 2);
 
-        Vector2D p3 = new Vector2D(3, 3);
+        Coordinates2D p3 = new Coordinates2D(3, 3);
         Assert.assertEquals(0.0, p3.crossProduct(p1, p2), EPS);
 
-        Vector2D p4 = new Vector2D(1, 2);
+        Coordinates2D p4 = new Coordinates2D(1, 2);
         Assert.assertEquals(1.0, p4.crossProduct(p1, p2), EPS);
 
-        Vector2D p5 = new Vector2D(2, 1);
+        Coordinates2D p5 = new Coordinates2D(2, 1);
         Assert.assertEquals(-1.0, p5.crossProduct(p1, p2), EPS);
     }
 }
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AklToussaintHeuristicTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AklToussaintHeuristicTest.java
index 219e5b29e..d91016afb 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AklToussaintHeuristicTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/AklToussaintHeuristicTest.java
@@ -18,7 +18,7 @@ package org.apache.commons.math4.geometry.euclidean.twod.hull;
 
 import java.util.Collection;
 
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.AklToussaintHeuristic;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHullGenerator2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChain;
@@ -34,7 +34,7 @@ public class AklToussaintHeuristicTest extends ConvexHullGenerator2DAbstractTest
     }
 
     @Override
-    protected Collection<Vector2D> reducePoints(Collection<Vector2D> points) {
+    protected Collection<Coordinates2D> reducePoints(Collection<Coordinates2D> points) {
         return AklToussaintHeuristic.reducePoints(points);
     }
 
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java
index 818c10921..7f2fc7e7a 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java
@@ -24,7 +24,7 @@ import java.util.List;
 
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHullGenerator2D;
 import org.apache.commons.math4.geometry.partitioning.Region;
@@ -49,7 +49,7 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     protected abstract ConvexHullGenerator2D createConvexHullGenerator(boolean includeCollinearPoints);
 
-    protected Collection<Vector2D> reducePoints(Collection<Vector2D> points) {
+    protected Collection<Coordinates2D> reducePoints(Collection<Coordinates2D> points) {
         // do nothing by default, may be overridden by other tests
         return points;
     }
@@ -70,14 +70,14 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testEmpty() {
-        ConvexHull2D hull = generator.generate(Collections.<Vector2D>emptyList());
+        ConvexHull2D hull = generator.generate(Collections.<Coordinates2D>emptyList());
         Assert.assertTrue(hull.getVertices().length == 0);
         Assert.assertTrue(hull.getLineSegments().length == 0);
     }
 
     @Test
     public void testOnePoint() {
-        List<Vector2D> points = createRandomPoints(1);
+        List<Coordinates2D> points = createRandomPoints(1);
         ConvexHull2D hull = generator.generate(points);
         Assert.assertTrue(hull.getVertices().length == 1);
         Assert.assertTrue(hull.getLineSegments().length == 0);
@@ -85,7 +85,7 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testTwoPoints() {
-        List<Vector2D> points = createRandomPoints(2);
+        List<Coordinates2D> points = createRandomPoints(2);
         ConvexHull2D hull = generator.generate(points);
         Assert.assertTrue(hull.getVertices().length == 2);
         Assert.assertTrue(hull.getLineSegments().length == 1);
@@ -93,11 +93,11 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testAllIdentical() {
-        final Collection<Vector2D> points = new ArrayList<>();
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(1, 1));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(1, 1));
 
         final ConvexHull2D hull = generator.generate(points);
         Assert.assertTrue(hull.getVertices().length == 1);
@@ -110,7 +110,7 @@ public abstract class ConvexHullGenerator2DAbstractTest {
             // randomize the size from 4 to 100
             int size = (int) FastMath.floor(random.nextDouble() * 96.0 + 4.0);
 
-            List<Vector2D> points = createRandomPoints(size);
+            List<Coordinates2D> points = createRandomPoints(size);
             ConvexHull2D hull = generator.generate(reducePoints(points));
             checkConvexHull(points, hull);
         }
@@ -118,12 +118,12 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testCollinearPoints() {
-        final Collection<Vector2D> points = new ArrayList<>();
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(2, 2));
-        points.add(new Vector2D(2, 4));
-        points.add(new Vector2D(4, 1));
-        points.add(new Vector2D(10, 1));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(2, 2));
+        points.add(new Coordinates2D(2, 4));
+        points.add(new Coordinates2D(4, 1));
+        points.add(new Coordinates2D(10, 1));
 
         final ConvexHull2D hull = generator.generate(points);
         checkConvexHull(points, hull);
@@ -131,12 +131,12 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testCollinearPointsReverse() {
-        final Collection<Vector2D> points = new ArrayList<>();
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(2, 2));
-        points.add(new Vector2D(2, 4));
-        points.add(new Vector2D(10, 1));
-        points.add(new Vector2D(4, 1));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(2, 2));
+        points.add(new Coordinates2D(2, 4));
+        points.add(new Coordinates2D(10, 1));
+        points.add(new Coordinates2D(4, 1));
 
         final ConvexHull2D hull = generator.generate(points);
         checkConvexHull(points, hull);
@@ -144,12 +144,12 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testCollinearPointsIncluded() {
-        final Collection<Vector2D> points = new ArrayList<>();
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(2, 2));
-        points.add(new Vector2D(2, 4));
-        points.add(new Vector2D(4, 1));
-        points.add(new Vector2D(10, 1));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(2, 2));
+        points.add(new Coordinates2D(2, 4));
+        points.add(new Coordinates2D(4, 1));
+        points.add(new Coordinates2D(10, 1));
 
         final ConvexHull2D hull = createConvexHullGenerator(true).generate(points);
         checkConvexHull(points, hull, true);
@@ -157,12 +157,12 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testCollinearPointsIncludedReverse() {
-        final Collection<Vector2D> points = new ArrayList<>();
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(2, 2));
-        points.add(new Vector2D(2, 4));
-        points.add(new Vector2D(10, 1));
-        points.add(new Vector2D(4, 1));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(2, 2));
+        points.add(new Coordinates2D(2, 4));
+        points.add(new Coordinates2D(10, 1));
+        points.add(new Coordinates2D(4, 1));
 
         final ConvexHull2D hull = createConvexHullGenerator(true).generate(points);
         checkConvexHull(points, hull, true);
@@ -170,12 +170,12 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testIdenticalPoints() {
-        final Collection<Vector2D> points = new ArrayList<>();
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(2, 2));
-        points.add(new Vector2D(2, 4));
-        points.add(new Vector2D(4, 1));
-        points.add(new Vector2D(1, 1));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(2, 2));
+        points.add(new Coordinates2D(2, 4));
+        points.add(new Coordinates2D(4, 1));
+        points.add(new Coordinates2D(1, 1));
 
         final ConvexHull2D hull = generator.generate(points);
         checkConvexHull(points, hull);
@@ -183,12 +183,12 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testIdenticalPoints2() {
-        final Collection<Vector2D> points = new ArrayList<>();
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(2, 2));
-        points.add(new Vector2D(2, 4));
-        points.add(new Vector2D(4, 1));
-        points.add(new Vector2D(1, 1));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(2, 2));
+        points.add(new Coordinates2D(2, 4));
+        points.add(new Coordinates2D(4, 1));
+        points.add(new Coordinates2D(1, 1));
 
         final ConvexHull2D hull = createConvexHullGenerator(true).generate(points);
         checkConvexHull(points, hull, true);
@@ -196,12 +196,12 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     @Test
     public void testClosePoints() {
-        final Collection<Vector2D> points = new ArrayList<>();
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(2, 2));
-        points.add(new Vector2D(2, 4));
-        points.add(new Vector2D(4, 1));
-        points.add(new Vector2D(1.00001, 1));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(2, 2));
+        points.add(new Coordinates2D(2, 4));
+        points.add(new Coordinates2D(4, 1));
+        points.add(new Coordinates2D(1.00001, 1));
 
         final ConvexHull2D hull = generator.generate(points);
         checkConvexHull(points, hull);
@@ -211,17 +211,17 @@ public abstract class ConvexHullGenerator2DAbstractTest {
     public void testCollinearPointOnExistingBoundary() {
         // MATH-1135: check that collinear points on the hull are handled correctly
         //            when only a minimal hull shall be constructed
-        final Collection<Vector2D> points = new ArrayList<>();
-        points.add(new Vector2D(7.3152, 34.7472));
-        points.add(new Vector2D(6.400799999999997, 34.747199999999985));
-        points.add(new Vector2D(5.486399999999997, 34.7472));
-        points.add(new Vector2D(4.876799999999999, 34.7472));
-        points.add(new Vector2D(4.876799999999999, 34.1376));
-        points.add(new Vector2D(4.876799999999999, 30.48));
-        points.add(new Vector2D(6.0959999999999965, 30.48));
-        points.add(new Vector2D(6.0959999999999965, 34.1376));
-        points.add(new Vector2D(7.315199999999996, 34.1376));
-        points.add(new Vector2D(7.3152, 30.48));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+        points.add(new Coordinates2D(7.3152, 34.7472));
+        points.add(new Coordinates2D(6.400799999999997, 34.747199999999985));
+        points.add(new Coordinates2D(5.486399999999997, 34.7472));
+        points.add(new Coordinates2D(4.876799999999999, 34.7472));
+        points.add(new Coordinates2D(4.876799999999999, 34.1376));
+        points.add(new Coordinates2D(4.876799999999999, 30.48));
+        points.add(new Coordinates2D(6.0959999999999965, 30.48));
+        points.add(new Coordinates2D(6.0959999999999965, 34.1376));
+        points.add(new Coordinates2D(7.315199999999996, 34.1376));
+        points.add(new Coordinates2D(7.3152, 30.48));
 
         final ConvexHull2D hull = createConvexHullGenerator(false).generate(points);
         checkConvexHull(points, hull);
@@ -233,13 +233,13 @@ public abstract class ConvexHullGenerator2DAbstractTest {
         //            make sure that they are processed in the proper order
         //            for each algorithm.
 
-        List<Vector2D> points = new ArrayList<>();
+        List<Coordinates2D> points = new ArrayList<>();
 
         // first case: 3 points are collinear
-        points.add(new Vector2D(16.078200000000184, -36.52519999989808));
-        points.add(new Vector2D(19.164300000000186, -36.52519999989808));
-        points.add(new Vector2D(19.1643, -25.28136477910407));
-        points.add(new Vector2D(19.1643, -17.678400000004157));
+        points.add(new Coordinates2D(16.078200000000184, -36.52519999989808));
+        points.add(new Coordinates2D(19.164300000000186, -36.52519999989808));
+        points.add(new Coordinates2D(19.1643, -25.28136477910407));
+        points.add(new Coordinates2D(19.1643, -17.678400000004157));
 
         ConvexHull2D hull = createConvexHullGenerator(false).generate(points);
         checkConvexHull(points, hull);
@@ -250,15 +250,15 @@ public abstract class ConvexHullGenerator2DAbstractTest {
         points.clear();
 
         // second case: multiple points are collinear
-        points.add(new Vector2D(0, -29.959696875));
-        points.add(new Vector2D(0, -31.621809375));
-        points.add(new Vector2D(0, -28.435696875));
-        points.add(new Vector2D(0, -33.145809375));
-        points.add(new Vector2D(3.048, -33.145809375));
-        points.add(new Vector2D(3.048, -31.621809375));
-        points.add(new Vector2D(3.048, -29.959696875));
-        points.add(new Vector2D(4.572, -33.145809375));
-        points.add(new Vector2D(4.572, -28.435696875));
+        points.add(new Coordinates2D(0, -29.959696875));
+        points.add(new Coordinates2D(0, -31.621809375));
+        points.add(new Coordinates2D(0, -28.435696875));
+        points.add(new Coordinates2D(0, -33.145809375));
+        points.add(new Coordinates2D(3.048, -33.145809375));
+        points.add(new Coordinates2D(3.048, -31.621809375));
+        points.add(new Coordinates2D(3.048, -29.959696875));
+        points.add(new Coordinates2D(4.572, -33.145809375));
+        points.add(new Coordinates2D(4.572, -28.435696875));
 
         hull = createConvexHullGenerator(false).generate(points);
         checkConvexHull(points, hull);
@@ -270,7 +270,7 @@ public abstract class ConvexHullGenerator2DAbstractTest {
     @Test
     public void testIssue1123() {
 
-        List<Vector2D> points = new ArrayList<>();
+        List<Coordinates2D> points = new ArrayList<>();
 
         int[][] data = new int[][] { { -11, -1 }, { -11, 0 }, { -11, 1 },
                 { -10, -3 }, { -10, -2 }, { -10, -1 }, { -10, 0 }, { -10, 1 },
@@ -324,26 +324,26 @@ public abstract class ConvexHullGenerator2DAbstractTest {
                 { 11, -1 }, { 11, 0 }, { 11, 1 } };
 
         for (int[] line : data) {
-            points.add(new Vector2D(line[0], line[1]));
+            points.add(new Coordinates2D(line[0], line[1]));
         }
 
-        Vector2D[] referenceHull = new Vector2D[] {
-            new Vector2D(-11.0, -1.0),
-            new Vector2D(-10.0, -3.0),
-            new Vector2D( -6.0, -7.0),
-            new Vector2D( -3.0, -8.0),
-            new Vector2D(  3.0, -8.0),
-            new Vector2D(  6.0, -7.0),
-            new Vector2D( 10.0, -3.0),
-            new Vector2D( 11.0, -1.0),
-            new Vector2D( 11.0,  1.0),
-            new Vector2D( 10.0,  3.0),
-            new Vector2D(  6.0,  7.0),
-            new Vector2D(  3.0,  8.0),
-            new Vector2D( -3.0,  8.0),
-            new Vector2D( -6.0,  7.0),
-            new Vector2D(-10.0,  3.0),
-            new Vector2D(-11.0,  1.0),
+        Coordinates2D[] referenceHull = new Coordinates2D[] {
+            new Coordinates2D(-11.0, -1.0),
+            new Coordinates2D(-10.0, -3.0),
+            new Coordinates2D( -6.0, -7.0),
+            new Coordinates2D( -3.0, -8.0),
+            new Coordinates2D(  3.0, -8.0),
+            new Coordinates2D(  6.0, -7.0),
+            new Coordinates2D( 10.0, -3.0),
+            new Coordinates2D( 11.0, -1.0),
+            new Coordinates2D( 11.0,  1.0),
+            new Coordinates2D( 10.0,  3.0),
+            new Coordinates2D(  6.0,  7.0),
+            new Coordinates2D(  3.0,  8.0),
+            new Coordinates2D( -3.0,  8.0),
+            new Coordinates2D( -6.0,  7.0),
+            new Coordinates2D(-10.0,  3.0),
+            new Coordinates2D(-11.0,  1.0),
         };
 
         ConvexHull2D convHull = generator.generate(points);
@@ -352,7 +352,7 @@ public abstract class ConvexHullGenerator2DAbstractTest {
         Assert.assertEquals(274.0, hullRegion.getSize(), 1.0e-12);
         double perimeter = 0;
         for (int i = 0; i < referenceHull.length; ++i) {
-            perimeter += Vector2D.distance(referenceHull[i],
+            perimeter += Coordinates2D.distance(referenceHull[i],
                                            referenceHull[(i + 1) % referenceHull.length]);
         }
         Assert.assertEquals(perimeter, hullRegion.getBoundarySize(), 1.0e-12);
@@ -365,26 +365,26 @@ public abstract class ConvexHullGenerator2DAbstractTest {
 
     // ------------------------------------------------------------------------------
 
-    protected final List<Vector2D> createRandomPoints(int size) {
+    protected final List<Coordinates2D> createRandomPoints(int size) {
         // create the cloud container
-        List<Vector2D> points = new ArrayList<>(size);
+        List<Coordinates2D> points = new ArrayList<>(size);
         // fill the cloud with a random distribution of points
         for (int i = 0; i < size; i++) {
-            points.add(new Vector2D(random.nextDouble() * 2.0 - 1.0, random.nextDouble() * 2.0 - 1.0));
+            points.add(new Coordinates2D(random.nextDouble() * 2.0 - 1.0, random.nextDouble() * 2.0 - 1.0));
         }
         return points;
     }
 
-    protected final void checkConvexHull(final Collection<Vector2D> points, final ConvexHull2D hull) {
+    protected final void checkConvexHull(final Collection<Coordinates2D> points, final ConvexHull2D hull) {
         checkConvexHull(points, hull, false);
     }
 
-    protected final void checkConvexHull(final Collection<Vector2D> points, final ConvexHull2D hull,
+    protected final void checkConvexHull(final Collection<Coordinates2D> points, final ConvexHull2D hull,
                                          final boolean includesCollinearPoints) {
         checkConvexHull(points, hull, includesCollinearPoints, 1e-10);
     }
 
-    protected final void checkConvexHull(final Collection<Vector2D> points, final ConvexHull2D hull,
+    protected final void checkConvexHull(final Collection<Coordinates2D> points, final ConvexHull2D hull,
                                          final boolean includesCollinearPoints, final double tolerance) {
         Assert.assertNotNull(hull);
         Assert.assertTrue(isConvex(hull, includesCollinearPoints, tolerance));
@@ -395,16 +395,16 @@ public abstract class ConvexHullGenerator2DAbstractTest {
     protected final boolean isConvex(final ConvexHull2D hull, final boolean includesCollinearPoints,
                                      final double tolerance) {
 
-        final Vector2D[] points = hull.getVertices();
+        final Coordinates2D[] points = hull.getVertices();
         int sign = 0;
 
         for (int i = 0; i < points.length; i++) {
-            Vector2D p1 = points[i == 0 ? points.length - 1 : i - 1];
-            Vector2D p2 = points[i];
-            Vector2D p3 = points[i == points.length - 1 ? 0 : i + 1];
+            Coordinates2D p1 = points[i == 0 ? points.length - 1 : i - 1];
+            Coordinates2D p2 = points[i];
+            Coordinates2D p3 = points[i == points.length - 1 ? 0 : i + 1];
 
-            Vector2D d1 = p2.subtract(p1);
-            Vector2D d2 = p3.subtract(p2);
+            Coordinates2D d1 = p2.subtract(p1);
+            Coordinates2D d2 = p3.subtract(p2);
 
             Assert.assertTrue(d1.getNorm() > 1e-10);
             Assert.assertTrue(d2.getNorm() > 1e-10);
@@ -427,14 +427,14 @@ public abstract class ConvexHullGenerator2DAbstractTest {
     }
 
     // verify that all points are inside the convex hull region
-    protected final void checkPointsInsideHullRegion(final Collection<Vector2D> points,
+    protected final void checkPointsInsideHullRegion(final Collection<Coordinates2D> points,
                                                      final ConvexHull2D hull,
                                                      final boolean includesCollinearPoints) {
 
-        final Collection<Vector2D> hullVertices = Arrays.asList(hull.getVertices());
+        final Collection<Coordinates2D> hullVertices = Arrays.asList(hull.getVertices());
         final Region<Euclidean2D> region = hull.createRegion();
 
-        for (final Vector2D p : points) {
+        for (final Coordinates2D p : points) {
             Location location = region.checkPoint(p);
             Assert.assertTrue(location != Location.OUTSIDE);
 
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/MonotoneChainTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/MonotoneChainTest.java
index 7860b9db5..4813fdd99 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/MonotoneChainTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/hull/MonotoneChainTest.java
@@ -20,7 +20,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 
 import org.apache.commons.math4.exception.ConvergenceException;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHullGenerator2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChain;
@@ -40,16 +40,16 @@ public class MonotoneChainTest extends ConvexHullGenerator2DAbstractTest {
 
     @Test(expected=ConvergenceException.class)
     public void testConvergenceException() {
-        final Collection<Vector2D> points = new ArrayList<>();
-
-        points.add(new Vector2D(1, 1));
-        points.add(new Vector2D(1, 5));
-        points.add(new Vector2D(0, 7));
-        points.add(new Vector2D(1, 10));
-        points.add(new Vector2D(1, 20));
-        points.add(new Vector2D(20, 20));
-        points.add(new Vector2D(20, 40));
-        points.add(new Vector2D(40, 1));
+        final Collection<Coordinates2D> points = new ArrayList<>();
+
+        points.add(new Coordinates2D(1, 1));
+        points.add(new Coordinates2D(1, 5));
+        points.add(new Coordinates2D(0, 7));
+        points.add(new Coordinates2D(1, 10));
+        points.add(new Coordinates2D(1, 20));
+        points.add(new Coordinates2D(20, 20));
+        points.add(new Coordinates2D(20, 40));
+        points.add(new Coordinates2D(40, 1));
 
         @SuppressWarnings("unused")
         final ConvexHull2D hull = new MonotoneChain(true, 2).generate(points);
diff --git a/src/test/java/org/apache/commons/math4/geometry/partitioning/RegionDumper.java b/src/test/java/org/apache/commons/math4/geometry/partitioning/RegionDumper.java
index 274ff9e29..5c356a243 100644
--- a/src/test/java/org/apache/commons/math4/geometry/partitioning/RegionDumper.java
+++ b/src/test/java/org/apache/commons/math4/geometry/partitioning/RegionDumper.java
@@ -23,15 +23,15 @@ import org.apache.commons.math4.geometry.Space;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
 import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
 import org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D;
 import org.apache.commons.math4.geometry.euclidean.threed.Plane;
 import org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.Line;
 import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.spherical.oned.ArcsSet;
 import org.apache.commons.math4.geometry.spherical.oned.LimitAngle;
 import org.apache.commons.math4.geometry.spherical.oned.Sphere1D;
@@ -125,7 +125,7 @@ public class RegionDumper {
             @Override
             protected void formatHyperplane(final Hyperplane<Euclidean2D> hyperplane) {
                 final Line h = (Line) hyperplane;
-                final Vector2D p = h.toSpace(Vector1D.ZERO);
+                final Coordinates2D p = h.toSpace(Coordinates1D.ZERO);
                 getFormatter().format("%22.15e %22.15e %22.15e %22.15e",
                                       p.getX(), p.getY(), h.getAngle(), h.getTolerance());
             }
@@ -146,7 +146,7 @@ public class RegionDumper {
             @Override
             protected void formatHyperplane(final Hyperplane<Euclidean3D> hyperplane) {
                 final Plane h = (Plane) hyperplane;
-                final Vector3D p = h.toSpace(Vector2D.ZERO);
+                final Coordinates3D p = h.toSpace(Coordinates2D.ZERO);
                 getFormatter().format("%22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e",
                                       p.getX(), p.getY(), p.getZ(),
                                       h.getNormal().getX(), h.getNormal().getY(), h.getNormal().getZ(),
diff --git a/src/test/java/org/apache/commons/math4/geometry/partitioning/RegionParser.java b/src/test/java/org/apache/commons/math4/geometry/partitioning/RegionParser.java
index ced198978..23a4c014c 100644
--- a/src/test/java/org/apache/commons/math4/geometry/partitioning/RegionParser.java
+++ b/src/test/java/org/apache/commons/math4/geometry/partitioning/RegionParser.java
@@ -24,15 +24,15 @@ import org.apache.commons.math4.geometry.Space;
 import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
 import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
 import org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint;
-import org.apache.commons.math4.geometry.euclidean.oned.Vector1D;
+import org.apache.commons.math4.geometry.euclidean.oned.Coordinates1D;
 import org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D;
 import org.apache.commons.math4.geometry.euclidean.threed.Plane;
 import org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.Line;
 import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.geometry.spherical.oned.ArcsSet;
 import org.apache.commons.math4.geometry.spherical.oned.LimitAngle;
 import org.apache.commons.math4.geometry.spherical.oned.S1Point;
@@ -90,7 +90,7 @@ public class RegionParser {
             @Override
             public Circle parseHyperplane()
                 throws IOException, ParseException {
-                return new Circle(new Vector3D(getNumber(), getNumber(), getNumber()), getNumber());
+                return new Circle(new Coordinates3D(getNumber(), getNumber(), getNumber()), getNumber());
             }
 
         };
@@ -111,7 +111,7 @@ public class RegionParser {
             @Override
             public OrientedPoint parseHyperplane()
                 throws IOException, ParseException {
-                return new OrientedPoint(new Vector1D(getNumber()), getBoolean(), getNumber());
+                return new OrientedPoint(new Coordinates1D(getNumber()), getBoolean(), getNumber());
             }
 
         };
@@ -132,7 +132,7 @@ public class RegionParser {
             @Override
             public Line parseHyperplane()
                 throws IOException, ParseException {
-                return new Line(new Vector2D(getNumber(), getNumber()), getNumber(), getNumber());
+                return new Line(new Coordinates2D(getNumber(), getNumber()), getNumber(), getNumber());
             }
 
         };
@@ -153,8 +153,8 @@ public class RegionParser {
             @Override
             public Plane parseHyperplane()
                 throws IOException, ParseException {
-                return new Plane(new Vector3D(getNumber(), getNumber(), getNumber()),
-                                 new Vector3D(getNumber(), getNumber(), getNumber()),
+                return new Plane(new Coordinates3D(getNumber(), getNumber(), getNumber()),
+                                 new Coordinates3D(getNumber(), getNumber(), getNumber()),
                                  getNumber());
             }
 
diff --git a/src/test/java/org/apache/commons/math4/geometry/spherical/twod/CircleTest.java b/src/test/java/org/apache/commons/math4/geometry/spherical/twod/CircleTest.java
index cba801d10..3b6cd9dbc 100644
--- a/src/test/java/org/apache/commons/math4/geometry/spherical/twod/CircleTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/spherical/twod/CircleTest.java
@@ -18,7 +18,7 @@ package org.apache.commons.math4.geometry.spherical.twod;
 
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
 import org.apache.commons.math4.geometry.euclidean.threed.RotationConvention;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.partitioning.Transform;
 import org.apache.commons.math4.geometry.spherical.oned.Arc;
 import org.apache.commons.math4.geometry.spherical.oned.LimitAngle;
@@ -40,13 +40,13 @@ public class CircleTest {
 
     @Test
     public void testEquator() {
-        Circle circle = new Circle(new Vector3D(0, 0, 1000), 1.0e-10).copySelf();
-        Assert.assertEquals(Vector3D.PLUS_K, circle.getPole());
+        Circle circle = new Circle(new Coordinates3D(0, 0, 1000), 1.0e-10).copySelf();
+        Assert.assertEquals(Coordinates3D.PLUS_K, circle.getPole());
         Assert.assertEquals(1.0e-10, circle.getTolerance(), 1.0e-20);
         circle.revertSelf();
-        Assert.assertEquals(Vector3D.MINUS_K, circle.getPole());
-        Assert.assertEquals(Vector3D.PLUS_K, circle.getReverse().getPole());
-        Assert.assertEquals(Vector3D.MINUS_K, circle.getPole());
+        Assert.assertEquals(Coordinates3D.MINUS_K, circle.getPole());
+        Assert.assertEquals(Coordinates3D.PLUS_K, circle.getReverse().getPole());
+        Assert.assertEquals(Coordinates3D.MINUS_K, circle.getPole());
     }
 
     @Test
@@ -54,11 +54,11 @@ public class CircleTest {
         Circle circle = new Circle(new S2Point(1.2, 2.5), new S2Point(-4.3, 0), 1.0e-10);
         Assert.assertEquals(0.0, circle.getPointAt(0).distance(circle.getXAxis()), 1.0e-10);
         Assert.assertEquals(0.0, circle.getPointAt(0.5 * FastMath.PI).distance(circle.getYAxis()), 1.0e-10);
-        Assert.assertEquals(0.5 * FastMath.PI, Vector3D.angle(circle.getXAxis(), circle.getYAxis()), 1.0e-10);
-        Assert.assertEquals(0.5 * FastMath.PI, Vector3D.angle(circle.getXAxis(), circle.getPole()), 1.0e-10);
-        Assert.assertEquals(0.5 * FastMath.PI, Vector3D.angle(circle.getPole(), circle.getYAxis()), 1.0e-10);
+        Assert.assertEquals(0.5 * FastMath.PI, Coordinates3D.angle(circle.getXAxis(), circle.getYAxis()), 1.0e-10);
+        Assert.assertEquals(0.5 * FastMath.PI, Coordinates3D.angle(circle.getXAxis(), circle.getPole()), 1.0e-10);
+        Assert.assertEquals(0.5 * FastMath.PI, Coordinates3D.angle(circle.getPole(), circle.getYAxis()), 1.0e-10);
         Assert.assertEquals(0.0,
-                            circle.getPole().distance(Vector3D.crossProduct(circle.getXAxis(), circle.getYAxis())),
+                            circle.getPole().distance(Coordinates3D.crossProduct(circle.getXAxis(), circle.getYAxis())),
                             1.0e-10);
     }
 
@@ -68,16 +68,16 @@ public class CircleTest {
         Circle reversed = circle.getReverse();
         Assert.assertEquals(0.0, reversed.getPointAt(0).distance(reversed.getXAxis()), 1.0e-10);
         Assert.assertEquals(0.0, reversed.getPointAt(0.5 * FastMath.PI).distance(reversed.getYAxis()), 1.0e-10);
-        Assert.assertEquals(0.5 * FastMath.PI, Vector3D.angle(reversed.getXAxis(), reversed.getYAxis()), 1.0e-10);
-        Assert.assertEquals(0.5 * FastMath.PI, Vector3D.angle(reversed.getXAxis(), reversed.getPole()), 1.0e-10);
-        Assert.assertEquals(0.5 * FastMath.PI, Vector3D.angle(reversed.getPole(), reversed.getYAxis()), 1.0e-10);
+        Assert.assertEquals(0.5 * FastMath.PI, Coordinates3D.angle(reversed.getXAxis(), reversed.getYAxis()), 1.0e-10);
+        Assert.assertEquals(0.5 * FastMath.PI, Coordinates3D.angle(reversed.getXAxis(), reversed.getPole()), 1.0e-10);
+        Assert.assertEquals(0.5 * FastMath.PI, Coordinates3D.angle(reversed.getPole(), reversed.getYAxis()), 1.0e-10);
         Assert.assertEquals(0.0,
-                            reversed.getPole().distance(Vector3D.crossProduct(reversed.getXAxis(), reversed.getYAxis())),
+                            reversed.getPole().distance(Coordinates3D.crossProduct(reversed.getXAxis(), reversed.getYAxis())),
                             1.0e-10);
 
-        Assert.assertEquals(0, Vector3D.angle(circle.getXAxis(), reversed.getXAxis()), 1.0e-10);
-        Assert.assertEquals(FastMath.PI, Vector3D.angle(circle.getYAxis(), reversed.getYAxis()), 1.0e-10);
-        Assert.assertEquals(FastMath.PI, Vector3D.angle(circle.getPole(), reversed.getPole()), 1.0e-10);
+        Assert.assertEquals(0, Coordinates3D.angle(circle.getXAxis(), reversed.getXAxis()), 1.0e-10);
+        Assert.assertEquals(FastMath.PI, Coordinates3D.angle(circle.getYAxis(), reversed.getYAxis()), 1.0e-10);
+        Assert.assertEquals(FastMath.PI, Coordinates3D.angle(circle.getPole(), reversed.getPole()), 1.0e-10);
 
         Assert.assertTrue(circle.sameOrientationAs(circle));
         Assert.assertFalse(circle.sameOrientationAs(reversed));
@@ -87,13 +87,13 @@ public class CircleTest {
     @Test
     public void testPhase() {
         Circle circle = new Circle(new S2Point(1.2, 2.5), new S2Point(-4.3, 0), 1.0e-10);
-        Vector3D p = new Vector3D(1, 2, -4);
-        Vector3D samePhase = circle.getPointAt(circle.getPhase(p));
+        Coordinates3D p = new Coordinates3D(1, 2, -4);
+        Coordinates3D samePhase = circle.getPointAt(circle.getPhase(p));
         Assert.assertEquals(0.0,
-                            Vector3D.angle(Vector3D.crossProduct(circle.getPole(), p),
-                                           Vector3D.crossProduct(circle.getPole(), samePhase)),
+                            Coordinates3D.angle(Coordinates3D.crossProduct(circle.getPole(), p),
+                                           Coordinates3D.crossProduct(circle.getPole(), samePhase)),
                             1.0e-10);
-        Assert.assertEquals(0.5 * FastMath.PI, Vector3D.angle(circle.getPole(), samePhase), 1.0e-10);
+        Assert.assertEquals(0.5 * FastMath.PI, Coordinates3D.angle(circle.getPole(), samePhase), 1.0e-10);
         Assert.assertEquals(circle.getPhase(p), circle.getPhase(samePhase), 1.0e-10);
         Assert.assertEquals(0.0, circle.getPhase(circle.getXAxis()), 1.0e-10);
         Assert.assertEquals(0.5 * FastMath.PI, circle.getPhase(circle.getYAxis()), 1.0e-10);
@@ -105,7 +105,7 @@ public class CircleTest {
         Circle circle = new Circle(new S2Point(1.2, 2.5), new S2Point(-4.3, 0), 1.0e-10);
         Assert.assertEquals(0.0, circle.toSubSpace(new S2Point(circle.getXAxis())).getAlpha(), 1.0e-10);
         Assert.assertEquals(0.5 * FastMath.PI, circle.toSubSpace(new S2Point(circle.getYAxis())).getAlpha(), 1.0e-10);
-        Vector3D p = new Vector3D(1, 2, -4);
+        Coordinates3D p = new Coordinates3D(1, 2, -4);
         Assert.assertEquals(circle.getPhase(p), circle.toSubSpace(new S2Point(p)).getAlpha(), 1.0e-10);
     }
 
@@ -113,23 +113,23 @@ public class CircleTest {
     public void testSpace() {
         Circle circle = new Circle(new S2Point(1.2, 2.5), new S2Point(-4.3, 0), 1.0e-10);
         for (double alpha = 0; alpha < MathUtils.TWO_PI; alpha += 0.1) {
-            Vector3D p = new Vector3D(FastMath.cos(alpha), circle.getXAxis(),
+            Coordinates3D p = new Coordinates3D(FastMath.cos(alpha), circle.getXAxis(),
                                       FastMath.sin(alpha), circle.getYAxis());
-            Vector3D q = circle.toSpace(new S1Point(alpha)).getVector();
+            Coordinates3D q = circle.toSpace(new S1Point(alpha)).getVector();
             Assert.assertEquals(0.0, p.distance(q), 1.0e-10);
-            Assert.assertEquals(0.5 * FastMath.PI, Vector3D.angle(circle.getPole(), q), 1.0e-10);
+            Assert.assertEquals(0.5 * FastMath.PI, Coordinates3D.angle(circle.getPole(), q), 1.0e-10);
         }
     }
 
     @Test
     public void testOffset() {
-        Circle circle = new Circle(Vector3D.PLUS_K, 1.0e-10);
-        Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Vector3D.PLUS_I)),  1.0e-10);
-        Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Vector3D.MINUS_I)), 1.0e-10);
-        Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Vector3D.PLUS_J)),  1.0e-10);
-        Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Vector3D.MINUS_J)), 1.0e-10);
-        Assert.assertEquals(-0.5 * FastMath.PI, circle.getOffset(new S2Point(Vector3D.PLUS_K)),  1.0e-10);
-        Assert.assertEquals( 0.5 * FastMath.PI, circle.getOffset(new S2Point(Vector3D.MINUS_K)), 1.0e-10);
+        Circle circle = new Circle(Coordinates3D.PLUS_K, 1.0e-10);
+        Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Coordinates3D.PLUS_I)),  1.0e-10);
+        Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Coordinates3D.MINUS_I)), 1.0e-10);
+        Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Coordinates3D.PLUS_J)),  1.0e-10);
+        Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Coordinates3D.MINUS_J)), 1.0e-10);
+        Assert.assertEquals(-0.5 * FastMath.PI, circle.getOffset(new S2Point(Coordinates3D.PLUS_K)),  1.0e-10);
+        Assert.assertEquals(0.5 * FastMath.PI, circle.getOffset(new S2Point(Coordinates3D.MINUS_K)), 1.0e-10);
 
     }
 
@@ -138,8 +138,8 @@ public class CircleTest {
         UnitSphereRandomVectorGenerator sphRandom = new UnitSphereRandomVectorGenerator(3, RandomSource.create(RandomSource.WELL_1024_A,
                                                                                                                0xbfd34e92231bbcfel));
         for (int i = 0; i < 100; ++i) {
-            Circle c1 = new Circle(new Vector3D(sphRandom.nextVector()), 1.0e-10);
-            Circle c2 = new Circle(new Vector3D(sphRandom.nextVector()), 1.0e-10);
+            Circle c1 = new Circle(new Coordinates3D(sphRandom.nextVector()), 1.0e-10);
+            Circle c2 = new Circle(new Coordinates3D(sphRandom.nextVector()), 1.0e-10);
             checkArcIsInside(c1, c2);
             checkArcIsInside(c2, c1);
         }
@@ -163,16 +163,16 @@ public class CircleTest {
         UnitSphereRandomVectorGenerator sphRandom = new UnitSphereRandomVectorGenerator(3, random);
         for (int i = 0; i < 100; ++i) {
 
-            Rotation r = new Rotation(new Vector3D(sphRandom.nextVector()),
+            Rotation r = new Rotation(new Coordinates3D(sphRandom.nextVector()),
                                       FastMath.PI * random.nextDouble(),
                                       RotationConvention.VECTOR_OPERATOR);
             Transform<Sphere2D, Sphere1D> t = Circle.getTransform(r);
 
-            S2Point  p = new S2Point(new Vector3D(sphRandom.nextVector()));
+            S2Point  p = new S2Point(new Coordinates3D(sphRandom.nextVector()));
             S2Point tp = (S2Point) t.apply(p);
             Assert.assertEquals(0.0, r.applyTo(p.getVector()).distance(tp.getVector()), 1.0e-10);
 
-            Circle  c = new Circle(new Vector3D(sphRandom.nextVector()), 1.0e-10);
+            Circle  c = new Circle(new Coordinates3D(sphRandom.nextVector()), 1.0e-10);
             Circle tc = (Circle) t.apply(c);
             Assert.assertEquals(0.0, r.applyTo(c.getPole()).distance(tc.getPole()),   1.0e-10);
             Assert.assertEquals(0.0, r.applyTo(c.getXAxis()).distance(tc.getXAxis()), 1.0e-10);
@@ -181,9 +181,9 @@ public class CircleTest {
 
             SubLimitAngle  sub = new LimitAngle(new S1Point(MathUtils.TWO_PI * random.nextDouble()),
                                                 random.nextBoolean(), 1.0e-10).wholeHyperplane();
-            Vector3D psub = c.getPointAt(((LimitAngle) sub.getHyperplane()).getLocation().getAlpha());
+            Coordinates3D psub = c.getPointAt(((LimitAngle) sub.getHyperplane()).getLocation().getAlpha());
             SubLimitAngle tsub = (SubLimitAngle) t.apply(sub, c, tc);
-            Vector3D ptsub = tc.getPointAt(((LimitAngle) tsub.getHyperplane()).getLocation().getAlpha());
+            Coordinates3D ptsub = tc.getPointAt(((LimitAngle) tsub.getHyperplane()).getLocation().getAlpha());
             Assert.assertEquals(0.0, r.applyTo(psub).distance(ptsub), 1.0e-10);
 
         }
diff --git a/src/test/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSetTest.java b/src/test/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSetTest.java
index 92ca21ad3..22fb23216 100644
--- a/src/test/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSetTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/spherical/twod/SphericalPolygonsSetTest.java
@@ -21,7 +21,7 @@ import java.util.List;
 
 import org.apache.commons.math4.geometry.enclosing.EnclosingBall;
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.partitioning.RegionFactory;
 import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
 import org.apache.commons.math4.geometry.partitioning.Region.Location;
@@ -50,7 +50,7 @@ public class SphericalPolygonsSetTest {
                 new UnitSphereRandomVectorGenerator(3, RandomSource.create(RandomSource.WELL_1024_A,
                                                                            0x852fd2a0ed8d2f6dl));
         for (int i = 0; i < 1000; ++i) {
-            Vector3D v = new Vector3D(random.nextVector());
+            Coordinates3D v = new Coordinates3D(random.nextVector());
             Assert.assertEquals(Location.INSIDE, full.checkPoint(new S2Point(v)));
         }
         Assert.assertEquals(4 * FastMath.PI, new SphericalPolygonsSet(0.01, new S2Point[0]).getSize(), 1.0e-10);
@@ -68,7 +68,7 @@ public class SphericalPolygonsSetTest {
                 new UnitSphereRandomVectorGenerator(3, RandomSource.create(RandomSource.WELL_1024_A,
                                                                            0x76d9205d6167b6ddl));
         for (int i = 0; i < 1000; ++i) {
-            Vector3D v = new Vector3D(random.nextVector());
+            Coordinates3D v = new Coordinates3D(random.nextVector());
             Assert.assertEquals(Location.OUTSIDE, empty.checkPoint(new S2Point(v)));
         }
         Assert.assertEquals(0, empty.getSize(), 1.0e-10);
@@ -82,12 +82,12 @@ public class SphericalPolygonsSetTest {
     public void testSouthHemisphere() {
         double tol = 0.01;
         double sinTol = FastMath.sin(tol);
-        SphericalPolygonsSet south = new SphericalPolygonsSet(Vector3D.MINUS_K, tol);
+        SphericalPolygonsSet south = new SphericalPolygonsSet(Coordinates3D.MINUS_K, tol);
         UnitSphereRandomVectorGenerator random =
                 new UnitSphereRandomVectorGenerator(3, RandomSource.create(RandomSource.WELL_1024_A,
                                                                            0x6b9d4a6ad90d7b0bl));
         for (int i = 0; i < 1000; ++i) {
-            Vector3D v = new Vector3D(random.nextVector());
+            Coordinates3D v = new Coordinates3D(random.nextVector());
             if (v.getZ() < -sinTol) {
                 Assert.assertEquals(Location.INSIDE, south.checkPoint(new S2Point(v)));
             } else if (v.getZ() > sinTol) {
@@ -114,16 +114,16 @@ public class SphericalPolygonsSetTest {
         double tol = 0.01;
         double sinTol = FastMath.sin(tol);
         RegionFactory<Sphere2D> factory = new RegionFactory<>();
-        SphericalPolygonsSet plusX = new SphericalPolygonsSet(Vector3D.PLUS_I, tol);
-        SphericalPolygonsSet plusY = new SphericalPolygonsSet(Vector3D.PLUS_J, tol);
-        SphericalPolygonsSet plusZ = new SphericalPolygonsSet(Vector3D.PLUS_K, tol);
+        SphericalPolygonsSet plusX = new SphericalPolygonsSet(Coordinates3D.PLUS_I, tol);
+        SphericalPolygonsSet plusY = new SphericalPolygonsSet(Coordinates3D.PLUS_J, tol);
+        SphericalPolygonsSet plusZ = new SphericalPolygonsSet(Coordinates3D.PLUS_K, tol);
         SphericalPolygonsSet octant =
                 (SphericalPolygonsSet) factory.intersection(factory.intersection(plusX, plusY), plusZ);
         UnitSphereRandomVectorGenerator random =
                 new UnitSphereRandomVectorGenerator(3, RandomSource.create(RandomSource.WELL_1024_A,
                                                                            0x9c9802fde3cbcf25l));
         for (int i = 0; i < 1000; ++i) {
-            Vector3D v = new Vector3D(random.nextVector());
+            Coordinates3D v = new Coordinates3D(random.nextVector());
             if ((v.getX() > sinTol) && (v.getY() > sinTol) && (v.getZ() > sinTol)) {
                 Assert.assertEquals(Location.INSIDE, octant.checkPoint(new S2Point(v)));
             } else if ((v.getX() < -sinTol) || (v.getY() < -sinTol) || (v.getZ() < -sinTol)) {
@@ -147,13 +147,13 @@ public class SphericalPolygonsSetTest {
             ++count;
             Edge e = v.getIncoming();
             Assert.assertTrue(v == e.getStart().getOutgoing().getEnd());
-            xPFound = xPFound || e.getCircle().getPole().distance(Vector3D.PLUS_I) < 1.0e-10;
-            yPFound = yPFound || e.getCircle().getPole().distance(Vector3D.PLUS_J) < 1.0e-10;
-            zPFound = zPFound || e.getCircle().getPole().distance(Vector3D.PLUS_K) < 1.0e-10;
+            xPFound = xPFound || e.getCircle().getPole().distance(Coordinates3D.PLUS_I) < 1.0e-10;
+            yPFound = yPFound || e.getCircle().getPole().distance(Coordinates3D.PLUS_J) < 1.0e-10;
+            zPFound = zPFound || e.getCircle().getPole().distance(Coordinates3D.PLUS_K) < 1.0e-10;
             Assert.assertEquals(0.5 * FastMath.PI, e.getLength(), 1.0e-10);
-            xVFound = xVFound || v.getLocation().getVector().distance(Vector3D.PLUS_I) < 1.0e-10;
-            yVFound = yVFound || v.getLocation().getVector().distance(Vector3D.PLUS_J) < 1.0e-10;
-            zVFound = zVFound || v.getLocation().getVector().distance(Vector3D.PLUS_K) < 1.0e-10;
+            xVFound = xVFound || v.getLocation().getVector().distance(Coordinates3D.PLUS_I) < 1.0e-10;
+            yVFound = yVFound || v.getLocation().getVector().distance(Coordinates3D.PLUS_J) < 1.0e-10;
+            zVFound = zVFound || v.getLocation().getVector().distance(Coordinates3D.PLUS_K) < 1.0e-10;
         }
         Assert.assertTrue(xPFound);
         Assert.assertTrue(yPFound);
@@ -164,7 +164,7 @@ public class SphericalPolygonsSetTest {
         Assert.assertEquals(3, count);
 
         Assert.assertEquals(0.0,
-                            ((S2Point) octant.getBarycenter()).distance(new S2Point(new Vector3D(1, 1, 1))),
+                            ((S2Point) octant.getBarycenter()).distance(new S2Point(new Coordinates3D(1, 1, 1))),
                             1.0e-10);
         Assert.assertEquals(0.5 * FastMath.PI, octant.getSize(), 1.0e-10);
 
@@ -174,7 +174,7 @@ public class SphericalPolygonsSetTest {
 
         EnclosingBall<Sphere2D, S2Point> reversedCap =
                 ((SphericalPolygonsSet) factory.getComplement(octant)).getEnclosingCap();
-        Assert.assertEquals(0, reversedCap.getCenter().distance(new S2Point(new Vector3D(-1, -1, -1))), 1.0e-10);
+        Assert.assertEquals(0, reversedCap.getCenter().distance(new S2Point(new Coordinates3D(-1, -1, -1))), 1.0e-10);
         Assert.assertEquals(FastMath.PI - FastMath.asin(1.0 / FastMath.sqrt(3)), reversedCap.getRadius(), 1.0e-10);
 
     }
@@ -188,7 +188,7 @@ public class SphericalPolygonsSetTest {
                 new UnitSphereRandomVectorGenerator(3, RandomSource.create(RandomSource.WELL_1024_A,
                                                                            0xb8fc5acc91044308l));
         for (int i = 0; i < 1000; ++i) {
-            Vector3D v = new Vector3D(random.nextVector());
+            Coordinates3D v = new Coordinates3D(random.nextVector());
             if ((v.getX() > sinTol) && (v.getY() > sinTol) && (v.getZ() > sinTol)) {
                 Assert.assertEquals(Location.INSIDE, octant.checkPoint(new S2Point(v)));
             } else if ((v.getX() < -sinTol) || (v.getY() < -sinTol) || (v.getZ() < -sinTol)) {
@@ -204,9 +204,9 @@ public class SphericalPolygonsSetTest {
         double tol = 0.01;
         double sinTol = FastMath.sin(tol);
         RegionFactory<Sphere2D> factory = new RegionFactory<>();
-        SphericalPolygonsSet plusX = new SphericalPolygonsSet(Vector3D.PLUS_I, tol);
-        SphericalPolygonsSet plusY = new SphericalPolygonsSet(Vector3D.PLUS_J, tol);
-        SphericalPolygonsSet plusZ = new SphericalPolygonsSet(Vector3D.PLUS_K, tol);
+        SphericalPolygonsSet plusX = new SphericalPolygonsSet(Coordinates3D.PLUS_I, tol);
+        SphericalPolygonsSet plusY = new SphericalPolygonsSet(Coordinates3D.PLUS_J, tol);
+        SphericalPolygonsSet plusZ = new SphericalPolygonsSet(Coordinates3D.PLUS_K, tol);
         SphericalPolygonsSet threeOctants =
                 (SphericalPolygonsSet) factory.difference(plusZ, factory.intersection(plusX, plusY));
 
@@ -214,7 +214,7 @@ public class SphericalPolygonsSetTest {
                 new UnitSphereRandomVectorGenerator(3, RandomSource.create(RandomSource.WELL_1024_A,
                                                                            0x9c9802fde3cbcf25l));
         for (int i = 0; i < 1000; ++i) {
-            Vector3D v = new Vector3D(random.nextVector());
+            Coordinates3D v = new Coordinates3D(random.nextVector());
             if (((v.getX() < -sinTol) || (v.getY() < -sinTol)) && (v.getZ() > sinTol)) {
                 Assert.assertEquals(Location.INSIDE, threeOctants.checkPoint(new S2Point(v)));
             } else if (((v.getX() > sinTol) && (v.getY() > sinTol)) || (v.getZ() < -sinTol)) {
@@ -241,20 +241,20 @@ public class SphericalPolygonsSetTest {
             ++count;
             Edge e = v.getIncoming();
             Assert.assertTrue(v == e.getStart().getOutgoing().getEnd());
-            if (e.getCircle().getPole().distance(Vector3D.MINUS_I) < 1.0e-10) {
+            if (e.getCircle().getPole().distance(Coordinates3D.MINUS_I) < 1.0e-10) {
                 xPFound = true;
                 sumPoleX += e.getLength();
-            } else if (e.getCircle().getPole().distance(Vector3D.MINUS_J) < 1.0e-10) {
+            } else if (e.getCircle().getPole().distance(Coordinates3D.MINUS_J) < 1.0e-10) {
                 yPFound = true;
                 sumPoleY += e.getLength();
             } else {
-                Assert.assertEquals(0.0, e.getCircle().getPole().distance(Vector3D.PLUS_K), 1.0e-10);
+                Assert.assertEquals(0.0, e.getCircle().getPole().distance(Coordinates3D.PLUS_K), 1.0e-10);
                 zPFound = true;
                 sumPoleZ += e.getLength();
             }
-            xVFound = xVFound || v.getLocation().getVector().distance(Vector3D.PLUS_I) < 1.0e-10;
-            yVFound = yVFound || v.getLocation().getVector().distance(Vector3D.PLUS_J) < 1.0e-10;
-            zVFound = zVFound || v.getLocation().getVector().distance(Vector3D.PLUS_K) < 1.0e-10;
+            xVFound = xVFound || v.getLocation().getVector().distance(Coordinates3D.PLUS_I) < 1.0e-10;
+            yVFound = yVFound || v.getLocation().getVector().distance(Coordinates3D.PLUS_J) < 1.0e-10;
+            zVFound = zVFound || v.getLocation().getVector().distance(Coordinates3D.PLUS_K) < 1.0e-10;
         }
         Assert.assertTrue(xPFound);
         Assert.assertTrue(yPFound);
@@ -274,22 +274,22 @@ public class SphericalPolygonsSetTest {
     public void testModeratlyComplexShape() {
         double tol = 0.01;
         List<SubHyperplane<Sphere2D>> boundary = new ArrayList<>();
-        boundary.add(create(Vector3D.MINUS_J, Vector3D.PLUS_I,  Vector3D.PLUS_K,  tol, 0.0, 0.5 * FastMath.PI));
-        boundary.add(create(Vector3D.MINUS_I, Vector3D.PLUS_K,  Vector3D.PLUS_J,  tol, 0.0, 0.5 * FastMath.PI));
-        boundary.add(create(Vector3D.PLUS_K,  Vector3D.PLUS_J,  Vector3D.MINUS_I, tol, 0.0, 0.5 * FastMath.PI));
-        boundary.add(create(Vector3D.MINUS_J, Vector3D.MINUS_I, Vector3D.MINUS_K, tol, 0.0, 0.5 * FastMath.PI));
-        boundary.add(create(Vector3D.MINUS_I, Vector3D.MINUS_K, Vector3D.MINUS_J, tol, 0.0, 0.5 * FastMath.PI));
-        boundary.add(create(Vector3D.PLUS_K,  Vector3D.MINUS_J, Vector3D.PLUS_I,  tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.MINUS_J, Coordinates3D.PLUS_I,  Coordinates3D.PLUS_K,  tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.MINUS_I, Coordinates3D.PLUS_K,  Coordinates3D.PLUS_J,  tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.PLUS_K,  Coordinates3D.PLUS_J,  Coordinates3D.MINUS_I, tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.MINUS_J, Coordinates3D.MINUS_I, Coordinates3D.MINUS_K, tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.MINUS_I, Coordinates3D.MINUS_K, Coordinates3D.MINUS_J, tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.PLUS_K,  Coordinates3D.MINUS_J, Coordinates3D.PLUS_I,  tol, 0.0, 0.5 * FastMath.PI));
         SphericalPolygonsSet polygon = new SphericalPolygonsSet(boundary, tol);
 
-        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Vector3D( 1,  1,  1).normalize())));
-        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Vector3D(-1,  1,  1).normalize())));
-        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Vector3D(-1, -1,  1).normalize())));
-        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Vector3D( 1, -1,  1).normalize())));
-        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Vector3D( 1,  1, -1).normalize())));
-        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Vector3D(-1,  1, -1).normalize())));
-        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Vector3D(-1, -1, -1).normalize())));
-        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Vector3D( 1, -1, -1).normalize())));
+        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Coordinates3D( 1,  1,  1).normalize())));
+        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Coordinates3D(-1,  1,  1).normalize())));
+        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Coordinates3D(-1, -1,  1).normalize())));
+        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Coordinates3D( 1, -1,  1).normalize())));
+        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Coordinates3D( 1,  1, -1).normalize())));
+        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Coordinates3D(-1,  1, -1).normalize())));
+        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Coordinates3D(-1, -1, -1).normalize())));
+        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Coordinates3D( 1, -1, -1).normalize())));
 
         Assert.assertEquals(MathUtils.TWO_PI, polygon.getSize(), 1.0e-10);
         Assert.assertEquals(3 * FastMath.PI, polygon.getBoundarySize(), 1.0e-10);
@@ -308,12 +308,12 @@ public class SphericalPolygonsSetTest {
             ++count;
             Edge e = v.getIncoming();
             Assert.assertTrue(v == e.getStart().getOutgoing().getEnd());
-            pXFound = pXFound || v.getLocation().getVector().distance(Vector3D.PLUS_I)  < 1.0e-10;
-            mXFound = mXFound || v.getLocation().getVector().distance(Vector3D.MINUS_I) < 1.0e-10;
-            pYFound = pYFound || v.getLocation().getVector().distance(Vector3D.PLUS_J)  < 1.0e-10;
-            mYFound = mYFound || v.getLocation().getVector().distance(Vector3D.MINUS_J) < 1.0e-10;
-            pZFound = pZFound || v.getLocation().getVector().distance(Vector3D.PLUS_K)  < 1.0e-10;
-            mZFound = mZFound || v.getLocation().getVector().distance(Vector3D.MINUS_K) < 1.0e-10;
+            pXFound = pXFound || v.getLocation().getVector().distance(Coordinates3D.PLUS_I)  < 1.0e-10;
+            mXFound = mXFound || v.getLocation().getVector().distance(Coordinates3D.MINUS_I) < 1.0e-10;
+            pYFound = pYFound || v.getLocation().getVector().distance(Coordinates3D.PLUS_J)  < 1.0e-10;
+            mYFound = mYFound || v.getLocation().getVector().distance(Coordinates3D.MINUS_J) < 1.0e-10;
+            pZFound = pZFound || v.getLocation().getVector().distance(Coordinates3D.PLUS_K)  < 1.0e-10;
+            mZFound = mZFound || v.getLocation().getVector().distance(Coordinates3D.MINUS_K) < 1.0e-10;
             Assert.assertEquals(0.5 * FastMath.PI, e.getLength(), 1.0e-10);
         }
         Assert.assertTrue(pXFound);
@@ -333,14 +333,14 @@ public class SphericalPolygonsSetTest {
         List<SubHyperplane<Sphere2D>> boundary = new ArrayList<>();
 
         // first part: +X, +Y, +Z octant
-        boundary.add(create(Vector3D.PLUS_J,  Vector3D.PLUS_K,  Vector3D.PLUS_I,  tol, 0.0, 0.5 * FastMath.PI));
-        boundary.add(create(Vector3D.PLUS_K,  Vector3D.PLUS_I,  Vector3D.PLUS_J,  tol, 0.0, 0.5 * FastMath.PI));
-        boundary.add(create(Vector3D.PLUS_I,  Vector3D.PLUS_J,  Vector3D.PLUS_K,  tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.PLUS_J,  Coordinates3D.PLUS_K,  Coordinates3D.PLUS_I,  tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.PLUS_K,  Coordinates3D.PLUS_I,  Coordinates3D.PLUS_J,  tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.PLUS_I,  Coordinates3D.PLUS_J,  Coordinates3D.PLUS_K,  tol, 0.0, 0.5 * FastMath.PI));
 
         // first part: -X, -Y, -Z octant
-        boundary.add(create(Vector3D.MINUS_J, Vector3D.MINUS_I, Vector3D.MINUS_K, tol, 0.0, 0.5 * FastMath.PI));
-        boundary.add(create(Vector3D.MINUS_I, Vector3D.MINUS_K, Vector3D.MINUS_J, tol, 0.0, 0.5 * FastMath.PI));
-        boundary.add(create(Vector3D.MINUS_K, Vector3D.MINUS_J, Vector3D.MINUS_I,  tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.MINUS_J, Coordinates3D.MINUS_I, Coordinates3D.MINUS_K, tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.MINUS_I, Coordinates3D.MINUS_K, Coordinates3D.MINUS_J, tol, 0.0, 0.5 * FastMath.PI));
+        boundary.add(create(Coordinates3D.MINUS_K, Coordinates3D.MINUS_J, Coordinates3D.MINUS_I,  tol, 0.0, 0.5 * FastMath.PI));
 
         SphericalPolygonsSet polygon = new SphericalPolygonsSet(boundary, tol);
 
@@ -348,7 +348,7 @@ public class SphericalPolygonsSetTest {
                 new UnitSphereRandomVectorGenerator(3, RandomSource.create(RandomSource.WELL_1024_A,
                                                                            0xcc5ce49949e0d3ecl));
         for (int i = 0; i < 1000; ++i) {
-            Vector3D v = new Vector3D(random.nextVector());
+            Coordinates3D v = new Coordinates3D(random.nextVector());
             if ((v.getX() < -sinTol) && (v.getY() < -sinTol) && (v.getZ() < -sinTol)) {
                 Assert.assertEquals(Location.INSIDE, polygon.checkPoint(new S2Point(v)));
             } else if ((v.getX() < sinTol) && (v.getY() < sinTol) && (v.getZ() < sinTol)) {
@@ -374,8 +374,8 @@ public class SphericalPolygonsSetTest {
     public void testPartWithHole() {
         double tol = 0.01;
         double alpha = 0.7;
-        S2Point center = new S2Point(new Vector3D(1, 1, 1));
-        SphericalPolygonsSet hexa = new SphericalPolygonsSet(center.getVector(), Vector3D.PLUS_K, alpha, 6, tol);
+        S2Point center = new S2Point(new Coordinates3D(1, 1, 1));
+        SphericalPolygonsSet hexa = new SphericalPolygonsSet(center.getVector(), Coordinates3D.PLUS_K, alpha, 6, tol);
         SphericalPolygonsSet hole  = new SphericalPolygonsSet(tol,
                                                               new S2Point(FastMath.PI / 6, FastMath.PI / 3),
                                                               new S2Point(FastMath.PI / 3, FastMath.PI / 3),
@@ -403,15 +403,15 @@ public class SphericalPolygonsSetTest {
     @Test
     public void testConcentricSubParts() {
         double tol = 0.001;
-        Vector3D center = new Vector3D(1, 1, 1);
-        SphericalPolygonsSet hexaOut   = new SphericalPolygonsSet(center, Vector3D.PLUS_K, 0.9,  6, tol);
-        SphericalPolygonsSet hexaIn    = new SphericalPolygonsSet(center, Vector3D.PLUS_K, 0.8,  6, tol);
-        SphericalPolygonsSet pentaOut  = new SphericalPolygonsSet(center, Vector3D.PLUS_K, 0.7,  5, tol);
-        SphericalPolygonsSet pentaIn   = new SphericalPolygonsSet(center, Vector3D.PLUS_K, 0.6,  5, tol);
-        SphericalPolygonsSet quadriOut = new SphericalPolygonsSet(center, Vector3D.PLUS_K, 0.5,  4, tol);
-        SphericalPolygonsSet quadriIn  = new SphericalPolygonsSet(center, Vector3D.PLUS_K, 0.4,  4, tol);
-        SphericalPolygonsSet triOut    = new SphericalPolygonsSet(center, Vector3D.PLUS_K, 0.25, 3, tol);
-        SphericalPolygonsSet triIn     = new SphericalPolygonsSet(center, Vector3D.PLUS_K, 0.15, 3, tol);
+        Coordinates3D center = new Coordinates3D(1, 1, 1);
+        SphericalPolygonsSet hexaOut   = new SphericalPolygonsSet(center, Coordinates3D.PLUS_K, 0.9,  6, tol);
+        SphericalPolygonsSet hexaIn    = new SphericalPolygonsSet(center, Coordinates3D.PLUS_K, 0.8,  6, tol);
+        SphericalPolygonsSet pentaOut  = new SphericalPolygonsSet(center, Coordinates3D.PLUS_K, 0.7,  5, tol);
+        SphericalPolygonsSet pentaIn   = new SphericalPolygonsSet(center, Coordinates3D.PLUS_K, 0.6,  5, tol);
+        SphericalPolygonsSet quadriOut = new SphericalPolygonsSet(center, Coordinates3D.PLUS_K, 0.5,  4, tol);
+        SphericalPolygonsSet quadriIn  = new SphericalPolygonsSet(center, Coordinates3D.PLUS_K, 0.4,  4, tol);
+        SphericalPolygonsSet triOut    = new SphericalPolygonsSet(center, Coordinates3D.PLUS_K, 0.25, 3, tol);
+        SphericalPolygonsSet triIn     = new SphericalPolygonsSet(center, Coordinates3D.PLUS_K, 0.15, 3, tol);
 
         RegionFactory<Sphere2D> factory = new RegionFactory<>();
         SphericalPolygonsSet hexa   = (SphericalPolygonsSet) factory.difference(hexaOut,   hexaIn);
@@ -477,7 +477,7 @@ public class SphericalPolygonsSetTest {
         RegionFactory<Sphere2D> factory = new RegionFactory<>();
         SphericalPolygonsSet zone = (SphericalPolygonsSet) factory.union(continental, corsica);
         EnclosingBall<Sphere2D, S2Point> enclosing = zone.getEnclosingCap();
-        Vector3D enclosingCenter = ((S2Point) enclosing.getCenter()).getVector();
+        Coordinates3D enclosingCenter = ((S2Point) enclosing.getCenter()).getVector();
 
         double step = FastMath.toRadians(0.1);
         for (Vertex loopStart : zone.getBoundaryLoops()) {
@@ -485,8 +485,8 @@ public class SphericalPolygonsSetTest {
             for (Vertex v = loopStart; count == 0 || v != loopStart; v = v.getOutgoing().getEnd()) {
                 ++count;
                 for (int i = 0; i < FastMath.ceil(v.getOutgoing().getLength() / step); ++i) {
-                    Vector3D p = v.getOutgoing().getPointAt(i * step);
-                    Assert.assertTrue(Vector3D.angle(p, enclosingCenter) <= enclosing.getRadius());
+                    Coordinates3D p = v.getOutgoing().getPointAt(i * step);
+                    Assert.assertTrue(Coordinates3D.angle(p, enclosingCenter) <= enclosing.getRadius());
                 }
             }
         }
@@ -500,37 +500,37 @@ public class SphericalPolygonsSetTest {
 
         EnclosingBall<Sphere2D, S2Point> continentalInscribed =
                 ((SphericalPolygonsSet) factory.getComplement(continental)).getEnclosingCap();
-        Vector3D continentalCenter = ((S2Point) continentalInscribed.getCenter()).getVector();
+        Coordinates3D continentalCenter = ((S2Point) continentalInscribed.getCenter()).getVector();
         Assert.assertEquals(2.2, FastMath.toDegrees(FastMath.PI - continentalInscribed.getRadius()), 0.1);
         for (Vertex loopStart : continental.getBoundaryLoops()) {
             int count = 0;
             for (Vertex v = loopStart; count == 0 || v != loopStart; v = v.getOutgoing().getEnd()) {
                 ++count;
                 for (int i = 0; i < FastMath.ceil(v.getOutgoing().getLength() / step); ++i) {
-                    Vector3D p = v.getOutgoing().getPointAt(i * step);
-                    Assert.assertTrue(Vector3D.angle(p, continentalCenter) <= continentalInscribed.getRadius());
+                    Coordinates3D p = v.getOutgoing().getPointAt(i * step);
+                    Assert.assertTrue(Coordinates3D.angle(p, continentalCenter) <= continentalInscribed.getRadius());
                 }
             }
         }
 
         EnclosingBall<Sphere2D, S2Point> corsicaInscribed =
                 ((SphericalPolygonsSet) factory.getComplement(corsica)).getEnclosingCap();
-        Vector3D corsicaCenter = ((S2Point) corsicaInscribed.getCenter()).getVector();
+        Coordinates3D corsicaCenter = ((S2Point) corsicaInscribed.getCenter()).getVector();
         Assert.assertEquals(0.34, FastMath.toDegrees(FastMath.PI - corsicaInscribed.getRadius()), 0.01);
         for (Vertex loopStart : corsica.getBoundaryLoops()) {
             int count = 0;
             for (Vertex v = loopStart; count == 0 || v != loopStart; v = v.getOutgoing().getEnd()) {
                 ++count;
                 for (int i = 0; i < FastMath.ceil(v.getOutgoing().getLength() / step); ++i) {
-                    Vector3D p = v.getOutgoing().getPointAt(i * step);
-                    Assert.assertTrue(Vector3D.angle(p, corsicaCenter) <= corsicaInscribed.getRadius());
+                    Coordinates3D p = v.getOutgoing().getPointAt(i * step);
+                    Assert.assertTrue(Coordinates3D.angle(p, corsicaCenter) <= corsicaInscribed.getRadius());
                 }
             }
         }
 
     }
 
-    private SubCircle create(Vector3D pole, Vector3D x, Vector3D y,
+    private SubCircle create(Coordinates3D pole, Coordinates3D x, Coordinates3D y,
                              double tolerance, double ... limits) {
         RegionFactory<Sphere1D> factory = new RegionFactory<>();
         Circle circle = new Circle(pole, tolerance);
diff --git a/src/test/java/org/apache/commons/math4/geometry/spherical/twod/SubCircleTest.java b/src/test/java/org/apache/commons/math4/geometry/spherical/twod/SubCircleTest.java
index 34b6278f7..4404f607d 100644
--- a/src/test/java/org/apache/commons/math4/geometry/spherical/twod/SubCircleTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/spherical/twod/SubCircleTest.java
@@ -17,7 +17,7 @@
 package org.apache.commons.math4.geometry.spherical.twod;
 
 import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
-import org.apache.commons.math4.geometry.euclidean.threed.Vector3D;
+import org.apache.commons.math4.geometry.euclidean.threed.Coordinates3D;
 import org.apache.commons.math4.geometry.partitioning.RegionFactory;
 import org.apache.commons.math4.geometry.partitioning.Side;
 import org.apache.commons.math4.geometry.partitioning.SubHyperplane.SplitSubHyperplane;
@@ -34,7 +34,7 @@ public class SubCircleTest {
 
     @Test
     public void testFullCircle() {
-        Circle circle = new Circle(Vector3D.PLUS_K, 1.0e-10);
+        Circle circle = new Circle(Coordinates3D.PLUS_K, 1.0e-10);
         SubCircle set = circle.wholeHyperplane();
         Assert.assertEquals(MathUtils.TWO_PI, set.getSize(), 1.0e-10);
         Assert.assertTrue(circle == set.getHyperplane());
@@ -44,21 +44,21 @@ public class SubCircleTest {
     @Test
     public void testSide() {
 
-        Circle xzPlane = new Circle(Vector3D.PLUS_J, 1.0e-10);
+        Circle xzPlane = new Circle(Coordinates3D.PLUS_J, 1.0e-10);
 
-        SubCircle sc1 = create(Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J, 1.0e-10, 1.0, 3.0, 5.0, 6.0);
+        SubCircle sc1 = create(Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, Coordinates3D.PLUS_J, 1.0e-10, 1.0, 3.0, 5.0, 6.0);
         Assert.assertEquals(Side.BOTH, sc1.split(xzPlane).getSide());
 
-        SubCircle sc2 = create(Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J, 1.0e-10, 1.0, 3.0);
+        SubCircle sc2 = create(Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, Coordinates3D.PLUS_J, 1.0e-10, 1.0, 3.0);
         Assert.assertEquals(Side.MINUS, sc2.split(xzPlane).getSide());
 
-        SubCircle sc3 = create(Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J, 1.0e-10, 5.0, 6.0);
+        SubCircle sc3 = create(Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, Coordinates3D.PLUS_J, 1.0e-10, 5.0, 6.0);
         Assert.assertEquals(Side.PLUS, sc3.split(xzPlane).getSide());
 
-        SubCircle sc4 = create(Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I, 1.0e-10, 5.0, 6.0);
+        SubCircle sc4 = create(Coordinates3D.PLUS_J, Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, 1.0e-10, 5.0, 6.0);
         Assert.assertEquals(Side.HYPER, sc4.split(xzPlane).getSide());
 
-        SubCircle sc5 = create(Vector3D.MINUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K, 1.0e-10, 5.0, 6.0);
+        SubCircle sc5 = create(Coordinates3D.MINUS_J, Coordinates3D.PLUS_I, Coordinates3D.PLUS_K, 1.0e-10, 5.0, 6.0);
         Assert.assertEquals(Side.HYPER, sc5.split(xzPlane).getSide());
 
     }
@@ -66,9 +66,9 @@ public class SubCircleTest {
     @Test
     public void testSPlit() {
 
-        Circle xzPlane = new Circle(Vector3D.PLUS_J, 1.0e-10);
+        Circle xzPlane = new Circle(Coordinates3D.PLUS_J, 1.0e-10);
 
-        SubCircle sc1 = create(Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J, 1.0e-10, 1.0, 3.0, 5.0, 6.0);
+        SubCircle sc1 = create(Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, Coordinates3D.PLUS_J, 1.0e-10, 1.0, 3.0, 5.0, 6.0);
         SplitSubHyperplane<Sphere2D> split1 = sc1.split(xzPlane);
         ArcsSet plus1  = (ArcsSet) ((SubCircle) split1.getPlus()).getRemainingRegion();
         ArcsSet minus1 = (ArcsSet) ((SubCircle) split1.getMinus()).getRemainingRegion();
@@ -79,7 +79,7 @@ public class SubCircleTest {
         Assert.assertEquals(1.0, minus1.asList().get(0).getInf(), 1.0e-10);
         Assert.assertEquals(3.0, minus1.asList().get(0).getSup(), 1.0e-10);
 
-        SubCircle sc2 = create(Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J, 1.0e-10, 1.0, 3.0);
+        SubCircle sc2 = create(Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, Coordinates3D.PLUS_J, 1.0e-10, 1.0, 3.0);
         SplitSubHyperplane<Sphere2D> split2 = sc2.split(xzPlane);
         Assert.assertNull(split2.getPlus());
         ArcsSet minus2 = (ArcsSet) ((SubCircle) split2.getMinus()).getRemainingRegion();
@@ -87,7 +87,7 @@ public class SubCircleTest {
         Assert.assertEquals(1.0, minus2.asList().get(0).getInf(), 1.0e-10);
         Assert.assertEquals(3.0, minus2.asList().get(0).getSup(), 1.0e-10);
 
-        SubCircle sc3 = create(Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J, 1.0e-10, 5.0, 6.0);
+        SubCircle sc3 = create(Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, Coordinates3D.PLUS_J, 1.0e-10, 5.0, 6.0);
         SplitSubHyperplane<Sphere2D> split3 = sc3.split(xzPlane);
         ArcsSet plus3  = (ArcsSet) ((SubCircle) split3.getPlus()).getRemainingRegion();
         Assert.assertEquals(1, plus3.asList().size());
@@ -95,13 +95,13 @@ public class SubCircleTest {
         Assert.assertEquals(6.0, plus3.asList().get(0).getSup(), 1.0e-10);
         Assert.assertNull(split3.getMinus());
 
-        SubCircle sc4 = create(Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I, 1.0e-10, 5.0, 6.0);
+        SubCircle sc4 = create(Coordinates3D.PLUS_J, Coordinates3D.PLUS_K, Coordinates3D.PLUS_I, 1.0e-10, 5.0, 6.0);
         SplitSubHyperplane<Sphere2D> split4 = sc4.split(xzPlane);
         Assert.assertEquals(Side.HYPER, sc4.split(xzPlane).getSide());
         Assert.assertNull(split4.getPlus());
         Assert.assertNull(split4.getMinus());
 
-        SubCircle sc5 = create(Vector3D.MINUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K, 1.0e-10, 5.0, 6.0);
+        SubCircle sc5 = create(Coordinates3D.MINUS_J, Coordinates3D.PLUS_I, Coordinates3D.PLUS_K, 1.0e-10, 5.0, 6.0);
         SplitSubHyperplane<Sphere2D> split5 = sc5.split(xzPlane);
         Assert.assertEquals(Side.HYPER, sc5.split(xzPlane).getSide());
         Assert.assertNull(split5.getPlus());
@@ -113,9 +113,9 @@ public class SubCircleTest {
     public void testSideSplitConsistency() {
 
         double tolerance = 1.0e-6;
-        Circle hyperplane = new Circle(new Vector3D(9.738804529764676E-5, -0.6772824575010357, -0.7357230887208355),
+        Circle hyperplane = new Circle(new Coordinates3D(9.738804529764676E-5, -0.6772824575010357, -0.7357230887208355),
                                        tolerance);
-        SubCircle sub = new SubCircle(new Circle(new Vector3D(2.1793884139073498E-4, 0.9790647032675541, -0.20354915700704285),
+        SubCircle sub = new SubCircle(new Circle(new Coordinates3D(2.1793884139073498E-4, 0.9790647032675541, -0.20354915700704285),
                                                  tolerance),
                                       new ArcsSet(4.7121441684170700, 4.7125386635004760, tolerance));
         SplitSubHyperplane<Sphere2D> split = sub.split(hyperplane);
@@ -125,7 +125,7 @@ public class SubCircleTest {
 
     }
 
-    private SubCircle create(Vector3D pole, Vector3D x, Vector3D y,
+    private SubCircle create(Coordinates3D pole, Coordinates3D x, Coordinates3D y,
                              double tolerance, double ... limits) {
         RegionFactory<Sphere1D> factory = new RegionFactory<>();
         Circle circle = new Circle(pole, tolerance);
diff --git a/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/MultiStartMultivariateOptimizerTest.java b/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/MultiStartMultivariateOptimizerTest.java
index 0a7090caf..e52fa34de 100644
--- a/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/MultiStartMultivariateOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/MultiStartMultivariateOptimizerTest.java
@@ -17,7 +17,7 @@
 package org.apache.commons.math4.optim.nonlinear.scalar;
 
 import org.apache.commons.math4.analysis.MultivariateFunction;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.optim.InitialGuess;
 import org.apache.commons.math4.optim.MaxEval;
 import org.apache.commons.math4.optim.PointValuePair;
@@ -72,7 +72,7 @@ public class MultiStartMultivariateOptimizerTest {
         Assert.assertEquals(nbStarts, optima.length);
         for (PointValuePair o : optima) {
             // we check the results of all intermediate restarts here (there are 10 such results)
-            Vector2D center = new Vector2D(o.getPointRef()[0], o.getPointRef()[1]);
+            Coordinates2D center = new Coordinates2D(o.getPointRef()[0], o.getPointRef()[1]);
             Assert.assertEquals(69.9597, circle.getRadius(center), 1e-3);
             Assert.assertEquals(96.07535, center.getX(), 1.4e-3);
             Assert.assertEquals(48.1349, center.getY(), 5e-3);
diff --git a/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/gradient/CircleScalar.java b/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/gradient/CircleScalar.java
index 5e5e90a7b..beb353287 100644
--- a/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/gradient/CircleScalar.java
+++ b/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/gradient/CircleScalar.java
@@ -21,7 +21,7 @@ import java.util.ArrayList;
 
 import org.apache.commons.math4.analysis.MultivariateFunction;
 import org.apache.commons.math4.analysis.MultivariateVectorFunction;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction;
 import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunctionGradient;
 
@@ -29,19 +29,19 @@ import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunctionGradient
  * Class used in the tests.
  */
 public class CircleScalar {
-    private ArrayList<Vector2D> points;
+    private ArrayList<Coordinates2D> points;
 
     public CircleScalar() {
         points  = new ArrayList<>();
     }
 
     public void addPoint(double px, double py) {
-        points.add(new Vector2D(px, py));
+        points.add(new Coordinates2D(px, py));
     }
 
-    public double getRadius(Vector2D center) {
+    public double getRadius(Coordinates2D center) {
         double r = 0;
-        for (Vector2D point : points) {
+        for (Coordinates2D point : points) {
             r += point.distance(center);
         }
         return r / points.size();
@@ -51,10 +51,10 @@ public class CircleScalar {
         return new ObjectiveFunction(new MultivariateFunction() {
                 @Override
                 public double value(double[] params)  {
-                    Vector2D center = new Vector2D(params[0], params[1]);
+                    Coordinates2D center = new Coordinates2D(params[0], params[1]);
                     double radius = getRadius(center);
                     double sum = 0;
-                    for (Vector2D point : points) {
+                    for (Coordinates2D point : points) {
                         double di = point.distance(center) - radius;
                         sum += di * di;
                     }
@@ -67,12 +67,12 @@ public class CircleScalar {
         return new ObjectiveFunctionGradient(new MultivariateVectorFunction() {
                 @Override
                 public double[] value(double[] params) {
-                    Vector2D center = new Vector2D(params[0], params[1]);
+                    Coordinates2D center = new Coordinates2D(params[0], params[1]);
                     double radius = getRadius(center);
                     // gradient of the sum of squared residuals
                     double dJdX = 0;
                     double dJdY = 0;
-                    for (Vector2D pk : points) {
+                    for (Coordinates2D pk : points) {
                         double dk = pk.distance(center);
                         dJdX += (center.getX() - pk.getX()) * (dk - radius) / dk;
                         dJdY += (center.getY() - pk.getY()) * (dk - radius) / dk;
diff --git a/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java b/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java
index 12b2897ed..54a827e4a 100644
--- a/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math4/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java
@@ -20,7 +20,7 @@ package org.apache.commons.math4.optim.nonlinear.scalar.gradient;
 import org.apache.commons.math4.analysis.MultivariateFunction;
 import org.apache.commons.math4.analysis.MultivariateVectorFunction;
 import org.apache.commons.math4.exception.MathUnsupportedOperationException;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Coordinates2D;
 import org.apache.commons.math4.linear.BlockRealMatrix;
 import org.apache.commons.math4.linear.RealMatrix;
 import org.apache.commons.math4.optim.InitialGuess;
@@ -431,7 +431,7 @@ public class NonLinearConjugateGradientOptimizerTest {
                                  problem.getObjectiveFunctionGradient(),
                                  GoalType.MINIMIZE,
                                  new InitialGuess(new double[] { 98.680, 47.345 }));
-        Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]);
+        Coordinates2D center = new Coordinates2D(optimum.getPointRef()[0], optimum.getPointRef()[1]);
         Assert.assertEquals(69.960161753, problem.getRadius(center), 1.0e-8);
         Assert.assertEquals(96.075902096, center.getX(), 1.0e-7);
         Assert.assertEquals(48.135167894, center.getY(), 1.0e-6);
