diff --git a/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java b/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java
index 36b2de77f..b4f5ec6a2 100644
--- a/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java
+++ b/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java
@@ -19,8 +19,6 @@ package org.apache.commons.math.analysis;
 
 import org.apache.commons.math.FunctionEvaluationException;
 
-
-
 /**
  * An interface representing a bivariate real function.
  *
@@ -28,14 +26,15 @@ import org.apache.commons.math.FunctionEvaluationException;
  * @version $Revision$ $Date$
  */
 public interface BivariateRealFunction {
-
     /**
      * Compute the value for the function.
-     * @param x abscissa for which the function value should be computed
-     * @param y ordinate for which the function value should be computed
-     * @return the value
-     * @throws FunctionEvaluationException if the function evaluation fails
+     *
+     * @param x Abscissa for which the function value should be computed.
+     * @param y Ordinate for which the function value should be computed.
+     * @return the value.
+     * @throws FunctionEvaluationException if the function evaluation fails.
      */
-    double value(double x, double y) throws FunctionEvaluationException;
+    public double value(double x, double y)
+        throws FunctionEvaluationException;
 
 }
diff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java
new file mode 100644
index 000000000..90168b5eb
--- /dev/null
+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java
@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.math.analysis.interpolation;
+
+import org.apache.commons.math.DimensionMismatchException;
+import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.MathException;
+import org.apache.commons.math.util.MathUtils;
+import org.apache.commons.math.analysis.UnivariateRealFunction;
+import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;
+
+/**
+ * Generates a bicubic interpolating function.
+ *
+ * @version $Revision$ $Date$
+ * @since 2.2
+ */
+public class BicubicSplineInterpolator
+    implements BivariateRealGridInterpolator {
+    /**
+     * {@inheritDoc}
+     */
+    public BicubicSplineInterpolatingFunction interpolate(final double[] xval,
+                                                          final double[] yval,
+                                                          final double[][] fval)
+        throws MathException, IllegalArgumentException {
+        if (xval.length == 0 || yval.length == 0 || fval.length == 0) {
+            throw MathRuntimeException.createIllegalArgumentException("no data");
+        }
+        if (xval.length != fval.length) {
+            throw new DimensionMismatchException(xval.length, fval.length);
+        }
+
+        MathUtils.checkOrder(xval, 1, true);
+        MathUtils.checkOrder(yval, 1, true);
+
+        final int xLen = xval.length;
+        final int yLen = yval.length;
+
+        // Samples (first index is y-coordinate, i.e. subarray variable is x)
+        // 0 <= i < xval.length
+        // 0 <= j < yval.length
+        // fX[j][i] = f(xval[i], yval[j])
+        final double[][] fX = new double[yLen][xLen];
+        for (int i = 0; i < xLen; i++) {
+            if (fval[i].length != yLen) {
+                throw new DimensionMismatchException(fval[i].length, yLen);
+            }
+
+            for (int j = 0; j < yLen; j++) {
+                fX[j][i] = fval[i][j];
+            }
+        }
+
+        final SplineInterpolator spInterpolator = new SplineInterpolator();
+
+        // For each line y[j] (0 <= j < yLen), construct a 1D spline with
+        // respect to variable x
+        final PolynomialSplineFunction[] ySplineX = new PolynomialSplineFunction[yLen];
+        for (int j = 0; j < yLen; j++) {
+            ySplineX[j] = spInterpolator.interpolate(xval, fX[j]);
+        }
+
+        // For each line x[i] (0 <= i < xLen), construct a 1D spline with
+        // respect to variable y generated by array fY_1[i]
+        final PolynomialSplineFunction[] xSplineY = new PolynomialSplineFunction[xLen];
+        for (int i = 0; i < xLen; i++) {
+            xSplineY[i] = spInterpolator.interpolate(yval, fval[i]);
+        }
+
+        // Partial derivatives with respect to x at the grid knots
+        final double[][] dFdX = new double[xLen][yLen];
+        for (int j = 0; j < yLen; j++) {
+            final UnivariateRealFunction f = ySplineX[j].derivative();
+            for (int i = 0; i < xLen; i++) {
+                dFdX[i][j] = f.value(xval[i]);
+            }
+        }
+
+        // Partial derivatives with respect to y at the grid knots
+        final double[][] dFdY = new double[xLen][yLen];
+        for (int i = 0; i < xLen; i++) {
+            final UnivariateRealFunction f = xSplineY[i].derivative();
+            for (int j = 0; j < yLen; j++) {
+                dFdY[i][j] = f.value(yval[j]);
+            }
+        }
+
+        // Cross partial derivatives
+        final double[][] d2FdXdY = new double[xLen][yLen];
+        for (int i = 0; i < xLen ; i++) {
+            final int nI = nextIndex(i, xLen);
+            final int pI = previousIndex(i);
+            for (int j = 0; j < yLen; j++) {
+                final int nJ = nextIndex(j, yLen);
+                final int pJ = previousIndex(j);
+                d2FdXdY[i][j] = (fval[nI][nJ] - fval[nI][pJ] -
+                                 fval[pI][nJ] + fval[pI][pJ]) /
+                    ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]));
+            }
+        }
+
+        // Create the interpolating splines
+        return new BicubicSplineInterpolatingFunction(xval, yval, fval,
+                                                      dFdX, dFdY, d2FdXdY);
+    }
+
+    /**
+     * Compute the next index of an array, clipping if necessary.
+     * It is assumed (but not checked) that {@code i} is larger than or equal to 0}.
+     *
+     * @param i Index
+     * @param max Upper limit of the array
+     * @return the next index
+     */
+    private int nextIndex(int i, int max) {
+        final int index = i + 1;
+        return index < max ? index : index - 1;
+    }
+    /**
+     * Compute the previous index of an array, clipping if necessary.
+     * It is assumed (but not checked) that {@code i} is smaller than the size of the array.
+     *
+     * @param i Index
+     * @return the previous index
+     */
+    private int previousIndex(int i) {
+        final int index = i - 1;
+        return index >= 0 ? index : 0;
+    }
+}
diff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateRealGridInterpolator.java b/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateRealGridInterpolator.java
index f2ae7c786..7eaa4e226 100644
--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateRealGridInterpolator.java
+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateRealGridInterpolator.java
@@ -26,20 +26,19 @@ import org.apache.commons.math.analysis.BivariateRealFunction;
  * @version $Revision$ $Date$
  */
 public interface BivariateRealGridInterpolator {
-
     /**
      * Computes an interpolating function for the data set.
      *
-     * @param xval all the x-coordinates of the interpolation points, sorted
+     * @param xval All the x-coordinates of the interpolation points, sorted
      * in increasing order.
-     * @param yval all the y-coordinates of the interpolation points, sorted
+     * @param yval All the y-coordinates of the interpolation points, sorted
      * in increasing order.
-     * @param zval the values of the interpolation points on all the grid knots:
-     * {@code zval[i][j] = f(xval[i], yval[j])}
-     * @return a function which interpolates the data set
+     * @param fval The values of the interpolation points on all the grid knots:
+     * {@code fval[i][j] = f(xval[i], yval[j])}.
+     * @return a function which interpolates the data set.
      * @throws MathException if arguments violate assumptions made by the
-     *         interpolation algorithm
+     *         interpolation algorithm.
      */
-    BivariateRealFunction interpolate(double[] xval, double[] yval, double[][] zval)
+    BivariateRealFunction interpolate(double[] xval, double[] yval, double[][] fval)
         throws MathException;
 }
diff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java
index 95f26d155..3eaba1857 100644
--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java
+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java
@@ -21,7 +21,6 @@ import org.apache.commons.math.MathRuntimeException;
 import org.apache.commons.math.MathException;
 import org.apache.commons.math.util.MathUtils;
 import org.apache.commons.math.analysis.UnivariateRealFunction;
-import org.apache.commons.math.analysis.BivariateRealFunction;
 import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;
 
 /**
@@ -33,15 +32,20 @@ import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;
  *
  * @version $Revision$ $Date$
  * @since 2.1
+ * @deprecated This class does not perform smoothing; the name is thus misleading.
+ * Please use {@link org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolator}
+ * instead. If smoothing is desired, a tentative implementation is provided in class
+ * {@link org.apache.commons.math.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator}.
+ * This class will be removed in math 3.0.
  */
 public class SmoothingBicubicSplineInterpolator
     implements BivariateRealGridInterpolator {
     /**
      * {@inheritDoc}
      */
-    public BivariateRealFunction interpolate(final double[] xval,
-                                             final double[] yval,
-                                             final double[][] zval)
+    public BicubicSplineInterpolatingFunction interpolate(final double[] xval,
+                                                          final double[] yval,
+                                                          final double[][] zval)
         throws MathException, IllegalArgumentException {
         if (xval.length == 0 || yval.length == 0 || zval.length == 0) {
             throw MathRuntimeException.createIllegalArgumentException("no data");
@@ -133,9 +137,9 @@ public class SmoothingBicubicSplineInterpolator
             for (int j = 0; j < yLen; j++) {
                 final int nJ = nextIndex(j, yLen);
                 final int pJ = previousIndex(j);
-                dZdXdY[i][j] =  (zY_2[nI][nJ] - zY_2[nI][pJ] -
-                                 zY_2[pI][nJ] + zY_2[pI][pJ]) /
-                    ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ])) ;
+                dZdXdY[i][j] = (zY_2[nI][nJ] - zY_2[nI][pJ] -
+                                zY_2[pI][nJ] + zY_2[pI][pJ]) /
+                    ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]));
             }
         }
 
diff --git a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java
new file mode 100644
index 000000000..0e1eefb82
--- /dev/null
+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java
@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.math.analysis.interpolation;
+
+import org.apache.commons.math.DimensionMismatchException;
+import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.MathException;
+import org.apache.commons.math.util.MathUtils;
+import org.apache.commons.math.analysis.UnivariateRealFunction;
+import org.apache.commons.math.analysis.BivariateRealFunction;
+import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;
+import org.apache.commons.math.optimization.fitting.PolynomialFitter;
+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;
+
+/**
+ * Generates a bicubic interpolation function.
+ * Prior to generating the interpolating function, the input is smoothed using
+ * polynomial fitting.
+ *
+ * @version $Revision$ $Date$
+ * @since 2.2
+ */
+public class SmoothingPolynomialBicubicSplineInterpolator
+    extends BicubicSplineInterpolator {
+    private final PolynomialFitter xFitter;
+    private final PolynomialFitter yFitter;
+
+    /**
+     * Default constructor. The degree of the fitting polynomials are set to 3.
+     */
+    public SmoothingPolynomialBicubicSplineInterpolator() {
+        this(3);
+    }
+
+    /**
+     * @param degree Degree of the polynomial fitting functions.
+     */
+    public SmoothingPolynomialBicubicSplineInterpolator(int degree) {
+        this(degree, degree);
+    }
+
+    /**
+     * @param xDegree Degree of the polynomial fitting functions along the
+     * x-dimension.
+     * @param yDegree Degree of the polynomial fitting functions along the
+     * y-dimension.
+     */
+    public SmoothingPolynomialBicubicSplineInterpolator(int xDegree,
+                                                        int yDegree) {
+        xFitter = new PolynomialFitter(xDegree, new GaussNewtonOptimizer(false));
+        yFitter = new PolynomialFitter(yDegree, new GaussNewtonOptimizer(false));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public BicubicSplineInterpolatingFunction interpolate(final double[] xval,
+                                                          final double[] yval,
+                                                          final double[][] fval)
+        throws MathException, IllegalArgumentException {
+        if (xval.length == 0 || yval.length == 0 || fval.length == 0) {
+            throw MathRuntimeException.createIllegalArgumentException("no data");
+        }
+        if (xval.length != fval.length) {
+            throw new DimensionMismatchException(xval.length, fval.length);
+        }
+
+        final int xLen = xval.length;
+        final int yLen = yval.length;
+
+        for (int i = 0; i < xLen; i++) {
+            if (fval[i].length != yLen) {
+                throw new DimensionMismatchException(fval[i].length, yLen);
+            }
+        }
+
+        MathUtils.checkOrder(xval, 1, true);
+        MathUtils.checkOrder(yval, 1, true);
+
+        // For each line y[j] (0 <= j < yLen), construct a polynomial, with
+        // respect to variable x, fitting array fval[][j]
+        final PolynomialFunction[] yPolyX = new PolynomialFunction[yLen];
+        for (int j = 0; j < yLen; j++) {
+            xFitter.clearObservations();
+            for (int i = 0; i < xLen; i++) {
+                xFitter.addObservedPoint(1, xval[i], fval[i][j]);
+            }
+
+            yPolyX[j] = xFitter.fit();
+        }
+
+        // For every knot (xval[i], yval[j]) of the grid, calculate corrected
+        // values fval_1
+        final double[][] fval_1 = new double[xLen][yLen];
+        for (int j = 0; j < yLen; j++) {
+            final PolynomialFunction f = yPolyX[j];
+            for (int i = 0; i < xLen; i++) {
+                fval_1[i][j] = f.value(xval[i]);
+            }
+        }
+
+        // For each line x[i] (0 <= i < xLen), construct a polynomial, with
+        // respect to variable y, fitting array fval_1[i][]
+        final PolynomialFunction[] xPolyY = new PolynomialFunction[xLen];
+        for (int i = 0; i < xLen; i++) {
+            yFitter.clearObservations();
+            for (int j = 0; j < yLen; j++) {
+                yFitter.addObservedPoint(1, yval[j], fval_1[i][j]);
+            }
+
+            xPolyY[i] = yFitter.fit();
+        }
+
+        // For every knot (xval[i], yval[j]) of the grid, calculate corrected
+        // values fval_2
+        final double[][] fval_2 = new double[xLen][yLen];
+        for (int i = 0; i < xLen; i++) {
+            final PolynomialFunction f = xPolyY[i];
+            for (int j = 0; j < yLen; j++) {
+                fval_2[i][j] = f.value(yval[j]);
+            }
+        }
+
+        return super.interpolate(xval, yval, fval_2);
+    }
+}
diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java
index b5b503cfe..b79525653 100644
--- a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java
+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java
@@ -60,6 +60,13 @@ public class PolynomialFitter {
         fitter.addObservedPoint(weight, x, y);
     }
 
+    /**
+     * Remove all observations.
+     */
+    public void clearObservations() {
+        fitter.clearObservations();
+    }
+
     /** Get the polynomial fitting the weighted (x, y) points.
      * @return polynomial function best fitting the observed points
      * @exception OptimizationException if the algorithm failed to converge
diff --git a/src/site/xdoc/changes.xml b/src/site/xdoc/changes.xml
index aebbeb407..4e4881304 100644
--- a/src/site/xdoc/changes.xml
+++ b/src/site/xdoc/changes.xml
@@ -69,6 +69,12 @@ This is primarily a maintenance release, but it also includes new features and e
   DummyStepInterpolator requires an additional argument for one of its constructors;
   some protected fields have been removed from AbstractLeastSquaresOptimizer, AbstractScalarDifferentiableOptimizer and AbstractLinearOptimizer;
   and the isOptimal(SimplexTableau) method has been removed from SimplexSolver. ">
+      <action dev="erans" type="update" issue="MATH-365">
+        Deprecated SmoothingBicubicSplineInterpolator and SmoothingBicubicSplineInterpolatorTest.
+        Added BicubicSplineInterpolator and BicubicSplineInterpolatorTest.
+        Added SmoothingPolynomialBicubicSplineInterpolator and SmoothingPolynomialBicubicSplineInterpolatorTest.
+        Added method to clear the list of observations in PolynomialFitter.
+      </action>
       <action dev="sebb" type="fix" issue="MATH-360">
         Fix use of wrong variable in SmoothingBicubicSplineInterpolatorTest.testPreconditions()
       </action>
diff --git a/src/site/xdoc/userguide/analysis.xml b/src/site/xdoc/userguide/analysis.xml
index 6f41b79a4..32b57ff5a 100644
--- a/src/site/xdoc/userguide/analysis.xml
+++ b/src/site/xdoc/userguide/analysis.xml
@@ -329,11 +329,15 @@ System.out println("f(" + interpolationX + ") = " + interpolatedY);</source>
         </p>
         <p>
           From two-dimensional data sampled on a regular grid, the
-          <a href="../apidocs/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.html">
-          org.apache.commons.math.analysis.interpolation.SmoothingBicubicSplineInterpolator</a>
+          <a href="../apidocs/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.html">
+          org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolator</a>
           computes a <a href="../apidocs/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.html">
-          bicubic interpolating function</a>. The data is first smoothed, along each grid dimension,
-          using one-dimensional splines.
+          bicubic interpolating function</a>.
+          Prior to computing an interpolating function, the
+          <a href="../apidocs/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html">
+          org.apache.commons.math.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator</a> class performs
+          smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each
+          of the coordinate axes.
         </p>
       </subsection>
       <subsection name="4.4 Integration" href="integration">
diff --git a/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java
new file mode 100644
index 000000000..de807a45d
--- /dev/null
+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.math.analysis.interpolation;
+
+import org.apache.commons.math.MathException;
+import org.apache.commons.math.DimensionMismatchException;
+import org.apache.commons.math.analysis.BivariateRealFunction;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Testcase for the bicubic interpolator.
+ * 
+ * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ 
+ */
+public final class BicubicSplineInterpolatorTest {
+    /**
+     * Test preconditions.
+     */
+    @Test
+    public void testPreconditions() throws MathException {
+        double[] xval = new double[] {3, 4, 5, 6.5};
+        double[] yval = new double[] {-4, -3, -1, 2.5};
+        double[][] zval = new double[xval.length][yval.length];
+
+        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();
+        
+        @SuppressWarnings("unused")
+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);
+        
+        double[] wxval = new double[] {3, 2, 5, 6.5};
+        try {
+            p = interpolator.interpolate(wxval, yval, zval);
+            Assert.fail("an exception should have been thrown");
+        } catch (IllegalArgumentException e) {
+            // Expected
+        }
+
+        double[] wyval = new double[] {-4, -3, -1, -1};
+        try {
+            p = interpolator.interpolate(xval, wyval, zval);
+            Assert.fail("an exception should have been thrown");
+        } catch (IllegalArgumentException e) {
+            // Expected
+        }
+
+        double[][] wzval = new double[xval.length][yval.length + 1];
+        try {
+            p = interpolator.interpolate(xval, yval, wzval);
+            Assert.fail("an exception should have been thrown");
+        } catch (DimensionMismatchException e) {
+            // Expected
+        }
+        wzval = new double[xval.length - 1][yval.length];
+        try {
+            p = interpolator.interpolate(xval, yval, wzval);
+            Assert.fail("an exception should have been thrown");
+        } catch (DimensionMismatchException e) {
+            // Expected
+        }
+    }
+
+    /**
+     * Test of interpolator for a plane.
+     * <p>
+     * z = 2 x - 3 y + 5
+     */
+    @Test
+    public void testPlane() throws MathException {
+        BivariateRealFunction f = new BivariateRealFunction() {
+                public double value(double x, double y) {
+                    return 2 * x - 3 * y + 5;
+                }
+            };
+
+        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();
+
+        double[] xval = new double[] {3, 4, 5, 6.5};
+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};
+        double[][] zval = new double[xval.length][yval.length];
+        for (int i = 0; i < xval.length; i++) {
+            for (int j = 0; j < yval.length; j++) {
+                zval[i][j] = f.value(xval[i], yval[j]);
+            }
+        }
+
+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);
+        double x, y;
+        double expected, result;
+        
+        x = 4;
+        y = -3;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("On sample point", expected, result, 1e-15);
+
+        x = 4.5;
+        y = -1.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.3);
+
+        x = 3.5;
+        y = -3.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.3);
+    }
+
+    /**
+     * Test of interpolator for a paraboloid.
+     * <p>
+     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5
+     */
+    @Test
+    public void testParaboloid() throws MathException {
+        BivariateRealFunction f = new BivariateRealFunction() {
+                public double value(double x, double y) {
+                    return 2 * x * x - 3 * y * y + 4 * x * y - 5;
+                }
+            };
+
+        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();
+
+        double[] xval = new double[] {3, 4, 5, 6.5};
+        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};
+        double[][] zval = new double[xval.length][yval.length];
+        for (int i = 0; i < xval.length; i++) {
+            for (int j = 0; j < yval.length; j++) {
+                zval[i][j] = f.value(xval[i], yval[j]);
+            }
+        }
+
+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);
+        double x, y;
+        double expected, result;
+        
+        x = 5;
+        y = 0.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("On sample point", expected, result, 1e-13);
+
+        x = 4.5;
+        y = -1.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.2);
+
+        x = 3.5;
+        y = -3.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.2);
+    }
+}
diff --git a/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolatorTest.java b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolatorTest.java
index 15add05f3..05f7de4a9 100644
--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolatorTest.java
+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolatorTest.java
@@ -26,6 +26,7 @@ import org.junit.Test;
  * Testcase for the bicubic interpolator.
  * 
  * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ 
+ * @deprecated To be removed in  math 3.0 (when the class for which it is a test will also be removed).
  */
 public final class SmoothingBicubicSplineInterpolatorTest {
     /**
@@ -60,9 +61,9 @@ public final class SmoothingBicubicSplineInterpolatorTest {
 
         double[][] wzval = new double[xval.length][yval.length + 1];
         try {
-            p = interpolator.interpolate(xval, wyval, wzval);
+            p = interpolator.interpolate(xval, yval, wzval);
             Assert.fail("an exception should have been thrown");
-        } catch (IllegalArgumentException e) {
+        } catch (DimensionMismatchException e) {
             // Expected
         }
         wzval = new double[xval.length - 1][yval.length];
diff --git a/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java
new file mode 100644
index 000000000..f57b712da
--- /dev/null
+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java
@@ -0,0 +1,179 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.math.analysis.interpolation;
+
+import org.apache.commons.math.MathException;
+import org.apache.commons.math.DimensionMismatchException;
+import org.apache.commons.math.analysis.BivariateRealFunction;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Testcase for the smoothing bicubic interpolator.
+ * 
+ * @version $Revision$ $Date$
+ */
+public final class SmoothingPolynomialBicubicSplineInterpolatorTest {
+    /**
+     * Test preconditions.
+     */
+    @Test
+    public void testPreconditions() throws MathException {
+        double[] xval = new double[] {3, 4, 5, 6.5};
+        double[] yval = new double[] {-4, -3, -1, 2.5};
+        double[][] zval = new double[xval.length][yval.length];
+
+        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(0);
+        
+        @SuppressWarnings("unused")
+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);
+        
+        double[] wxval = new double[] {3, 2, 5, 6.5};
+        try {
+            p = interpolator.interpolate(wxval, yval, zval);
+            Assert.fail("an exception should have been thrown");
+        } catch (IllegalArgumentException e) {
+            // Expected
+        }
+
+        double[] wyval = new double[] {-4, -3, -1, -1};
+        try {
+            p = interpolator.interpolate(xval, wyval, zval);
+            Assert.fail("an exception should have been thrown");
+        } catch (IllegalArgumentException e) {
+            // Expected
+        }
+
+        double[][] wzval = new double[xval.length][yval.length + 1];
+        try {
+            p = interpolator.interpolate(xval, yval, wzval);
+            Assert.fail("an exception should have been thrown");
+        } catch (DimensionMismatchException e) {
+            // Expected
+        }
+        wzval = new double[xval.length - 1][yval.length];
+        try {
+            p = interpolator.interpolate(xval, yval, wzval);
+            Assert.fail("an exception should have been thrown");
+        } catch (DimensionMismatchException e) {
+            // Expected
+        }
+        wzval = new double[xval.length][yval.length - 1];
+        try {
+            p = interpolator.interpolate(xval, yval, wzval);
+            Assert.fail("an exception should have been thrown");
+        } catch (DimensionMismatchException e) {
+            // Expected
+        }
+    }
+
+    /**
+     * Test of interpolator for a plane.
+     * <p>
+     * z = 2 x - 3 y + 5
+     */
+    @Test
+    public void testPlane() throws MathException {
+        BivariateRealFunction f = new BivariateRealFunction() {
+                public double value(double x, double y) {
+                    return 2 * x - 3 * y + 5
+                        + ((int) (Math.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);
+                }
+            };
+
+        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(1);
+
+        double[] xval = new double[] {3, 4, 5, 6.5};
+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};
+        double[][] zval = new double[xval.length][yval.length];
+        for (int i = 0; i < xval.length; i++) {
+            for (int j = 0; j < yval.length; j++) {
+                zval[i][j] = f.value(xval[i], yval[j]);
+            }
+        }
+
+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);
+        double x, y;
+        double expected, result;
+        
+        x = 4;
+        y = -3;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("On sample point", expected, result, 2);
+
+        x = 4.5;
+        y = -1.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 2);
+
+        x = 3.5;
+        y = -3.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 2);
+    }
+
+    /**
+     * Test of interpolator for a paraboloid.
+     * <p>
+     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5
+     */
+    @Test
+    public void testParaboloid() throws MathException {
+        BivariateRealFunction f = new BivariateRealFunction() {
+                public double value(double x, double y) {
+                    return 2 * x * x - 3 * y * y + 4 * x * y - 5
+                        + ((int) (Math.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);
+                }
+            };
+
+        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(4);
+
+        double[] xval = new double[] {3, 4, 5, 6.5};
+        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};
+        double[][] zval = new double[xval.length][yval.length];
+        for (int i = 0; i < xval.length; i++) {
+            for (int j = 0; j < yval.length; j++) {
+                zval[i][j] = f.value(xval[i], yval[j]);
+            }
+        }
+
+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);
+        double x, y;
+        double expected, result;
+
+        x = 5;
+        y = 0.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("On sample point", expected, result, 2);
+
+        x = 4.5;
+        y = -1.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 2);
+
+        x = 3.5;
+        y = -3.5;
+        expected = f.value(x, y);
+        result = p.value(x, y);
+        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 2);
+    }
+}
