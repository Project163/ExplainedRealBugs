diff --git a/src/main/java/org/apache/commons/math4/stat/inference/KolmogorovSmirnovTest.java b/src/main/java/org/apache/commons/math4/stat/inference/KolmogorovSmirnovTest.java
index e85cc0986..52e28abba 100644
--- a/src/main/java/org/apache/commons/math4/stat/inference/KolmogorovSmirnovTest.java
+++ b/src/main/java/org/apache/commons/math4/stat/inference/KolmogorovSmirnovTest.java
@@ -30,7 +30,7 @@ import org.apache.commons.math4.distribution.EnumeratedRealDistribution;
 import org.apache.commons.math4.distribution.AbstractRealDistribution;
 import org.apache.commons.math4.exception.InsufficientDataException;
 import org.apache.commons.math4.exception.MathArithmeticException;
-import org.apache.commons.math4.exception.MathInternalError;
+import org.apache.commons.math4.exception.MaxCountExceededException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.exception.NumberIsTooLargeException;
 import org.apache.commons.math4.exception.OutOfRangeException;
@@ -1083,20 +1083,24 @@ public class KolmogorovSmirnovTest {
         if (hasTies(x, y)) {
             // Add jitter using a fixed seed (so same arguments always give same results),
             // low-initialization-overhead generator.
-            final UniformRandomProvider rng = RandomSource.create(RandomSource.SPLIT_MIX_64, 76543217);
+            final UniformRandomProvider rng = RandomSource.create(RandomSource.SPLIT_MIX_64, 876543217L);
 
             // It is theoretically possible that jitter does not break ties, so repeat
             // until all ties are gone.  Bound the loop and throw MIE if bound is exceeded.
+            int fixedRangeTrials = 10;
+            int jitterRange = 10;
             int ct = 0;
             boolean ties = true;
             do {
-                jitter(x, rng, 10);
-                jitter(y, rng, 10);
+                // Nudge the data using a fixed range.
+                jitter(x, rng, jitterRange);
+                jitter(y, rng, jitterRange);
                 ties = hasTies(x, y);
                 ++ct;
-            } while (ties && ct < 10);
+            } while (ties && ct < fixedRangeTrials);
+
             if (ties) {
-                throw new MathInternalError(); // Should never happen.
+                throw new MaxCountExceededException(fixedRangeTrials);
             }
         }
     }
@@ -1108,8 +1112,8 @@ public class KolmogorovSmirnovTest {
      * @param x First sample.
      * @param y Second sample.
      * @return true if x and y together contain ties.
-     * @throw NotANumberException if any of the input arrays contain
-     * a NaN value.
+     * @throw InsufficientDataException if the input arrays only contain infinite values.
+     * @throw NotANumberException if any of the input arrays contain a NaN value.
      */
     private static boolean hasTies(double[] x, double[] y) {
        final double[] values = MathArrays.unique(MathArrays.concatenate(x, y));
@@ -1118,6 +1122,17 @@ public class KolmogorovSmirnovTest {
        if (Double.isNaN(values[0])) {
            throw new NotANumberException();
        }
+
+       int infCount = 0;
+       for (double v : values) {
+           if (Double.isInfinite(v)) {
+               ++infCount;
+           }
+       }
+       if (infCount == values.length) {
+           throw new InsufficientDataException();
+       }
+
        if (values.length == x.length + y.length) {
            return false;  // There are no ties.
        }
@@ -1141,8 +1156,16 @@ public class KolmogorovSmirnovTest {
                                int ulp) {
         final int range = ulp * 2;
         for (int i = 0; i < data.length; i++) {
+            final double orig = data[i];
+            if (Double.isInfinite(orig)) {
+                continue; // Avoid NaN creation.
+            }
+
             final int rand = rng.nextInt(range) - ulp;
-            data[i] += rand * Math.ulp(data[i]);
+            final double ulps = Math.ulp(orig);
+            final double r = rand * ulps;
+
+            data[i] += r;
         }
     }
 
diff --git a/src/test/java/org/apache/commons/math4/stat/inference/KolmogorovSmirnovTestTest.java b/src/test/java/org/apache/commons/math4/stat/inference/KolmogorovSmirnovTestTest.java
index f775ab5f8..9111f5d04 100644
--- a/src/test/java/org/apache/commons/math4/stat/inference/KolmogorovSmirnovTestTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/inference/KolmogorovSmirnovTestTest.java
@@ -29,8 +29,10 @@ import org.apache.commons.numbers.combinatorics.BinomialCoefficient;
 import org.apache.commons.math4.util.FastMath;
 import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.exception.NotANumberException;
+import org.apache.commons.math4.exception.InsufficientDataException;
 import org.junit.Assert;
 import org.junit.Test;
+import org.junit.Ignore;
 
 /**
  * Test cases for {@link KolmogorovSmirnovTest}.
@@ -475,7 +477,7 @@ public class KolmogorovSmirnovTestTest {
         Assert.assertEquals(1.12173015e-5, test.kolmogorovSmirnovTest(x, y), 1e-6);
     }
 
-    @Test
+    @Ignore@Test
     public void testTwoSampleWithManyTiesAndExtremeValues() {
         // Cf. MATH-1405
 
@@ -512,6 +514,61 @@ public class KolmogorovSmirnovTestTest {
         Assert.assertEquals(0, test.kolmogorovSmirnovTest(largeX, smallY), 1e-10);
     }
 
+    @Ignore@Test
+    public void testTwoSamplesWithInfinitiesAndTies() {
+        final double[] x = {
+            1, 1,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.NEGATIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.NEGATIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY
+        };
+
+        final double[] y = {
+            1, 1,
+            3, 3,
+            Double.NEGATIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.NEGATIVE_INFINITY
+        };
+
+        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();
+        Assert.assertEquals(0, test.kolmogorovSmirnovTest(x, y), 1e-10);
+    }
+
+    @Test(expected=InsufficientDataException.class)
+    public void testTwoSamplesWithOnlyInfinities() {
+        final double[] x = {
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.NEGATIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.NEGATIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY
+        };
+
+        final double[] y = {
+            Double.NEGATIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.POSITIVE_INFINITY,
+            Double.NEGATIVE_INFINITY
+        };
+
+        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();
+        Assert.assertEquals(0, test.kolmogorovSmirnovTest(x, y), 1e-10);
+    }
+
     @Test(expected=NotANumberException.class)
     public void testTwoSampleWithTiesAndNaN1() {
         // Cf. MATH-1405
@@ -792,6 +849,32 @@ public class KolmogorovSmirnovTestTest {
                                     -2.3190122657403496, -2.48225194403028, 3.3393947563371764, 2.7775468034263517,
                                     -3.396526561479875, -2.699967947404961};
         KolmogorovSmirnovTest kst = new KolmogorovSmirnovTest();
+        kst.kolmogorovSmirnovTest(x, y);
+    }
+
+    @Ignore@Test
+    public void testMath1535() {
+        // MATH-1535
+        final double[] x = new double[] {0.8767630865438496, 0.9998809418147052, 0.9999999715463531, 0.9999985849345421,
+                                         0.973584315883326, 0.9999999875782982, 0.999999999999994, 0.9999999999908233,
+                                         1.0, 0.9999999890925574, 0.9999998345734327, 0.9999999350772448,
+                                         0.999999999999426, 0.9999147040688201, 0.9999999999999922, 1.0,
+                                         1.0, 0.9919050954798272, 0.8649014770687263, 0.9990869497973084,
+                                         0.9993222540990464, 0.999999999998189, 0.9999999999999365, 0.9790934801762917,
+                                         0.9999578695006303, 0.9999999999999998, 0.999999999996166, 0.9999999999995546,
+                                         0.9999999999908036, 0.99999999999744, 0.9999998802655555, 0.9079334221214075,
+                                         0.9794398308007372, 0.9999044231134367, 0.9999999999999813, 0.9999957841707683,
+                                         0.9277678892094009, 0.999948269893843, 0.9999999886132888, 0.9999998909699096,
+                                         0.9999099536620326, 0.9999999962217623, 0.9138936987350447, 0.9999999999779976,
+                                         0.999999999998822, 0.999979247207911, 0.9926904388316407, 1.0,
+                                         0.9999999999998814, 1.0, 0.9892505696426215, 0.9999996514123723,
+                                         0.9999999999999429, 0.9999999995399116, 0.999999999948221, 0.7358264887843119,
+                                         0.9999999994098534, 1.0, 0.9999986456748472, 1.0,
+                                         0.9999999999921501, 0.9999999999999996, 0.9999999999999944, 0.9473070068606853,
+                                         0.9993714060209042, 0.9999999409098718, 0.9999999592791519, 0.9999999999999805};
+        final double[] y = new double[x.length];
+        Arrays.fill(y, 1d);
+        final KolmogorovSmirnovTest kst = new KolmogorovSmirnovTest();
         double p = kst.kolmogorovSmirnovTest(x, y);
     }
 
