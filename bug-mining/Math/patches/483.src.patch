diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 327fc0d7f..2ff90e763 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -83,7 +83,8 @@ Users are encouraged to upgrade to this version as this release not
       </action>
       <action dev="tn" type="fix" issue="MATH-1131" due-to="Schalk W. CronjÃ©">
         Improve performance of "KolmogorovSmirnovTest#kolmogorovSmirnovTest(...)" for
-        large samples.
+        large samples. Also changed implementation for large n to use Pelz-Good
+        approximation.
       </action>
       <action dev="erans" type="fix" issue="MATH-1134">
         "BicubicSplineInterpolatingFunction": all fields made final and initialized in
diff --git a/src/main/java/org/apache/commons/math3/stat/inference/KolmogorovSmirnovTest.java b/src/main/java/org/apache/commons/math3/stat/inference/KolmogorovSmirnovTest.java
index 061ab6fb3..0d122c0e7 100644
--- a/src/main/java/org/apache/commons/math3/stat/inference/KolmogorovSmirnovTest.java
+++ b/src/main/java/org/apache/commons/math3/stat/inference/KolmogorovSmirnovTest.java
@@ -42,6 +42,9 @@ import org.apache.commons.math3.util.CombinatoricsUtils;
 import org.apache.commons.math3.util.FastMath;
 import org.apache.commons.math3.util.MathArrays;
 
+import static org.apache.commons.math3.util.MathUtils.PI_SQUARED;
+import static org.apache.commons.math3.util.FastMath.PI;
+
 /**
  * Implementation of the <a href="http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test">
  * Kolmogorov-Smirnov (K-S) test</a> for equality of continuous distributions.
@@ -120,6 +123,9 @@ public class KolmogorovSmirnovTest {
     /** Convergence criterion for {@link #ksSum(double, double, int)} */
     protected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;
 
+    /** Convergence criterion for the sums in #pelzGood(double, double, int)} */
+    protected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;
+
     /** When product of sample sizes is less than this value, 2-sample K-S test is exact */
     protected static final int SMALL_SAMPLE_PRODUCT = 200;
 
@@ -422,7 +428,13 @@ public class KolmogorovSmirnovTest {
         } else if (1 <= d) {
             return 1;
         }
-        return exact ? exactK(d, n) : roundedK(d, n);
+        if (exact) {
+            return exactK(d,n);
+        }
+        if (n <= 140) {
+            return roundedK(d, n);
+        }
+        return pelzGood(d, n);
     }
 
     /**
@@ -464,7 +476,7 @@ public class KolmogorovSmirnovTest {
      *
      * @param d statistic
      * @param n sample size
-     * @return the two-sided probability of \(P(D_n < d)\)
+     * @return \(P(D_n < d)\)
      */
     private double roundedK(double d, int n) {
 
@@ -480,6 +492,148 @@ public class KolmogorovSmirnovTest {
         return pFrac;
     }
 
+    /**
+     * Computes the Pelz-Good approximation for \(P(D_n < d)\) as described in [2] in the class javadoc.
+     *
+     * @param d value of d-statistic (x in [2])
+     * @param n sample size
+     * @return \(P(D_n < d)\)
+     * @since 3.4
+     */
+    public double pelzGood(double d, int n) {
+
+        // Change the variable since approximation is for the distribution evaluated at d / sqrt(n)
+        final double sqrtN = FastMath.sqrt(n);
+        final double z = d * sqrtN;
+        final double z2 = d * d * n;
+        final double z4 = z2 * z2;
+        final double z6 = z4 * z2;
+        final double z8 = z4 * z4;
+
+        // Eventual return value
+        double ret = 0;
+
+        // Compute K_0(z)
+        double sum = 0;
+        double increment = 0;
+        double kTerm = 0;
+        double z2Term = PI_SQUARED / (8 * z2);
+        int k = 1;
+        for (; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
+            kTerm = 2 * k - 1;
+            increment = FastMath.exp(-z2Term * kTerm * kTerm);
+            sum += increment;
+            if (increment <= PG_SUM_RELATIVE_ERROR * sum) {
+                break;
+            }
+        }
+        if (k == MAXIMUM_PARTIAL_SUM_COUNT) {
+            throw new TooManyIterationsException(MAXIMUM_PARTIAL_SUM_COUNT);
+        }
+        ret = sum * FastMath.sqrt(2 * FastMath.PI) / z;
+
+        // K_1(z)
+        // Sum is -inf to inf, but k term is always (k + 1/2) ^ 2, so really have
+        // twice the sum from k = 0 to inf (k = -1 is same as 0, -2 same as 1, ...)
+        final double twoZ2 = 2 * z2;
+        sum = 0;
+        kTerm = 0;
+        double kTerm2 = 0;
+        for (k = 0; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
+            kTerm = k + 0.5;
+            kTerm2 = kTerm * kTerm;
+            increment = (PI_SQUARED * kTerm2 - z2) * FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
+            sum += increment;
+            if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum)) {
+                break;
+            }
+        }
+        if (k == MAXIMUM_PARTIAL_SUM_COUNT) {
+            throw new TooManyIterationsException(MAXIMUM_PARTIAL_SUM_COUNT);
+        }
+        final double sqrtHalfPi = FastMath.sqrt(PI / 2);
+        // Instead of doubling sum, divide by 3 instead of 6
+        ret += sum * sqrtHalfPi / (3 * z4 * sqrtN);
+
+        // K_2(z)
+        // Same drill as K_1, but with two doubly infinite sums, all k terms are even powers.
+        final double z4Term = 2 * z4;
+        final double z6Term = 6 * z6;
+        z2Term = 5 * z2;
+        final double pi4 = PI_SQUARED * PI_SQUARED;
+        sum = 0;
+        kTerm = 0;
+        kTerm2 = 0;
+        for (k = 0; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
+            kTerm = k + 0.5;
+            kTerm2 = kTerm * kTerm;
+            increment =  (z6Term + z4Term + PI_SQUARED * (z4Term - z2Term) * kTerm2 +
+                    pi4 * (1 - twoZ2) * kTerm2 * kTerm2) * FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
+            sum += increment;
+            if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum)) {
+                break;
+            }
+        }
+        if (k == MAXIMUM_PARTIAL_SUM_COUNT) {
+            throw new TooManyIterationsException(MAXIMUM_PARTIAL_SUM_COUNT);
+        }
+        double sum2 = 0;
+        kTerm2 = 0;
+        for (k = 1; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
+            kTerm2 = k * k;
+            increment = PI_SQUARED * kTerm2 * FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
+            sum2 += increment;
+            if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum2)) {
+                break;
+            }
+        }
+        if (k == MAXIMUM_PARTIAL_SUM_COUNT) {
+            throw new TooManyIterationsException(MAXIMUM_PARTIAL_SUM_COUNT);
+        }
+        // Again, adjust coefficients instead of doubling sum, sum2
+        ret += (sqrtHalfPi / n) * (sum / (36 * z2 * z2 * z2 * z) - sum2 / (18 * z2 * z));
+
+        // K_3(z) One more time with feeling - two doubly infinite sums, all k powers even.
+        // Multiply coefficient denominators by 2, so omit doubling sums.
+        final double pi6 = pi4 * PI_SQUARED;
+        sum = 0;
+        double kTerm4 = 0;
+        double kTerm6 = 0;
+        for (k = 0; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
+            kTerm = k + 0.5;
+            kTerm2 = kTerm * kTerm;
+            kTerm4 = kTerm2 * kTerm2;
+            kTerm6 = kTerm4 * kTerm2;
+            increment = (pi6 * kTerm6 * (5 - 30 * z2) + pi4 * kTerm4 * (-60 * z2 + 212 * z4) +
+                    PI_SQUARED * kTerm2 * (135 * z4 - 96 * z6) - 30 * z6 - 90 * z8) *
+                    FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
+            sum += increment;
+            if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum)) {
+                break;
+            }
+        }
+        if (k == MAXIMUM_PARTIAL_SUM_COUNT) {
+            throw new TooManyIterationsException(MAXIMUM_PARTIAL_SUM_COUNT);
+        }
+        sum2 = 0;
+        for (k = 1; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
+            kTerm2 = k * k;
+            kTerm4 = kTerm2 * kTerm2;
+            increment = (-pi4 * kTerm4 + 3 * PI_SQUARED * kTerm2 * z2) *
+                    FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
+            sum2 += increment;
+            if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum2)) {
+                break;
+            }
+        }
+        if (k == MAXIMUM_PARTIAL_SUM_COUNT) {
+            throw new TooManyIterationsException(MAXIMUM_PARTIAL_SUM_COUNT);
+        }
+        return ret + (sqrtHalfPi / (sqrtN * n)) * (sum / (3240 * z6 * z4) +
+                + sum2 / (108 * z6));
+
+    }
+
     /***
      * Creates {@code H} of size {@code m x m} as described in [1] (see above).
      *
diff --git a/src/main/java/org/apache/commons/math3/util/MathUtils.java b/src/main/java/org/apache/commons/math3/util/MathUtils.java
index 047cd3fe6..f586d42bd 100644
--- a/src/main/java/org/apache/commons/math3/util/MathUtils.java
+++ b/src/main/java/org/apache/commons/math3/util/MathUtils.java
@@ -36,11 +36,18 @@ import org.apache.commons.math3.exception.util.LocalizedFormats;
  */
 public final class MathUtils {
     /**
-     * 2 &pi;.
+     * \(2\pi\)
      * @since 2.1
      */
     public static final double TWO_PI = 2 * FastMath.PI;
 
+    /**
+     * \(\pi^2\)
+     * @since 3.4
+     */
+    public static final double PI_SQUARED = FastMath.PI * FastMath.PI;
+
+
     /**
      * Class contains only static methods.
      */
diff --git a/src/test/java/org/apache/commons/math3/stat/inference/KolmogorovSmirnovTestTest.java b/src/test/java/org/apache/commons/math3/stat/inference/KolmogorovSmirnovTestTest.java
index d0cb94258..0abb9957f 100644
--- a/src/test/java/org/apache/commons/math3/stat/inference/KolmogorovSmirnovTestTest.java
+++ b/src/test/java/org/apache/commons/math3/stat/inference/KolmogorovSmirnovTestTest.java
@@ -90,90 +90,6 @@ public class KolmogorovSmirnovTestTest {
         0.97660425
     };
 
-    @Test
-    public void testCumulativeDensityFunction() {
-
-        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();
-
-        /*
-         * The code below is generated using the R-script located in
-         * /src/test/R/KolmogorovSmirnovDistributionTestCases.R R version 2.11.1 (2010-05-31)
-         */
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(200), PACKAGE =
-         * "stats")$p, 40) gives 4.907829957616471622388047046469198862537e-86
-         */
-
-        Assert.assertEquals(4.907829957616471622388047046469198862537e-86, test.cdf(0.005, 200, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(200), PACKAGE =
-         * "stats")$p, 40) gives 5.151982014280041957199687829849210629618e-06
-         */
-        Assert.assertEquals(5.151982014280041957199687829849210629618e-06, test.cdf(0.02, 200, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(200), PACKAGE =
-         * "stats")$p, 40) gives 0.01291614648162886340443389343590752105229
-         */
-        Assert.assertEquals(0.01291614648162886340443389343590752105229, test.cdf(0.031111, 200, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(200), PACKAGE =
-         * "stats")$p, 40) gives 0.1067137011362679355208626930107129737735
-         */
-        Assert.assertEquals(0.1067137011362679355208626930107129737735, test.cdf(0.04, 200, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(341), PACKAGE =
-         * "stats")$p, 40) gives 1.914734701559404553985102395145063418825e-53
-         */
-        Assert.assertEquals(1.914734701559404553985102395145063418825e-53, test.cdf(0.005, 341, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(341), PACKAGE =
-         * "stats")$p, 40) gives 0.001171328985781981343872182321774744195864
-         */
-        Assert.assertEquals(0.001171328985781981343872182321774744195864, test.cdf(0.02, 341, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(341), PACKAGE =
-         * "stats")$p, 40) gives 0.1142955196267499418105728636874118819833
-         */
-        Assert.assertEquals(0.1142955196267499418105728636874118819833, test.cdf(0.031111, 341, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(341), PACKAGE =
-         * "stats")$p, 40) gives 0.3685529520496805266915885113121476024389
-         */
-        Assert.assertEquals(0.3685529520496805266915885113121476024389, test.cdf(0.04, 341, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(389), PACKAGE =
-         * "stats")$p, 40) gives 1.810657144595055888918455512707637574637e-47
-         */
-        Assert.assertEquals(1.810657144595055888918455512707637574637e-47, test.cdf(0.005, 389, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(389), PACKAGE =
-         * "stats")$p, 40) gives 0.003068542559702356568168690742481885536108
-         */
-        Assert.assertEquals(0.003068542559702356568168690742481885536108, test.cdf(0.02, 389, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(389), PACKAGE =
-         * "stats")$p, 40) gives 0.1658291700122746237244797384846606291831
-         */
-        Assert.assertEquals(0.1658291700122746237244797384846606291831, test.cdf(0.031111, 389, false), TOLERANCE);
-
-        /*
-         * formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(389), PACKAGE =
-         * "stats")$p, 40) gives 0.4513143712128902529379104180407011881471
-         */
-        Assert.assertEquals(0.4513143712128902529379104180407011881471, test.cdf(0.04, 389, false), TOLERANCE);
-    }
-
     /** Unit normal distribution, unit normal data */
     @Test
     public void testOneSampleGaussianGaussian() {
@@ -305,6 +221,31 @@ public class KolmogorovSmirnovTestTest {
             }
         }
     }
+    
+    @Test
+    public void testPelzGoodApproximation() {
+        KolmogorovSmirnovTest ksTest = new KolmogorovSmirnovTest();
+        final double d[] = {0.15, 0.20, 0.25, 0.3, 0.35, 0.4};
+        final int n[] = {141, 150, 180, 220, 1000};
+        // Reference values computed using the Pelz method from
+        // http://simul.iro.umontreal.ca/ksdir/KolmogorovSmirnovDist.java
+        final double ref[] = {
+            0.9968940168727819, 0.9979326624184857, 0.9994677598604506, 0.9999128354780209, 0.9999999999998661,
+            0.9999797514476236, 0.9999902122242081, 0.9999991327060908, 0.9999999657681911, 0.9999999999977929,
+            0.9999999706444976, 0.9999999906571532, 0.9999999997949596, 0.999999999998745, 0.9999999999993876,
+            0.9999999999916627, 0.9999999999984447, 0.9999999999999936, 0.999999999999341, 0.9999999999971508,
+            0.9999999999999877, 0.9999999999999191, 0.9999999999999254, 0.9999999999998178, 0.9999999999917788,
+            0.9999999999998556, 0.9999999999992014, 0.9999999999988859, 0.9999999999999325, 0.9999999999821726
+        };
+        
+        final double tol = 10e-15;
+        int k = 0;
+        for (int i = 0; i < 6; i++) {
+            for (int j = 0; j < 5; j++, k++) {
+                Assert.assertEquals(ref[k], ksTest.pelzGood(d[i], n[j]), tol);
+            }
+        }
+    }
 
     /** Verifies large sample approximate p values against R */
     @Test
@@ -379,4 +320,5 @@ public class KolmogorovSmirnovTestTest {
         final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();
         Assert.assertEquals(alpha, test.approximateP(criticalValue, n, m), epsilon);
     }
-}
+    
+}
\ No newline at end of file
