diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 39fe6fedb..8eaca42f3 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -54,6 +54,31 @@ If the output is not quite correct, check for invisible trailing spaces!
     </release>
 
     <release version="4.0" date="XXXX-XX-XX" description="">
+      <action dev="tn" type="remove" issue="MATH-1205">
+        Removed methods "test(...)" from "AbstractUnivariateStatistic".
+        The already existing methods "MathArrays#verifyValues(...)" shall
+        be used instead.
+      </action>    
+      <action dev="tn" type="update" issue="MATH-1205">
+        The abstract class "AbstractStorelessUnivariateStatistic" does not
+        extend anymore from "AbstractUnivariateStatistic".
+      </action>    
+      <action dev="tn" type="update" issue="MATH-1205">
+        Default implementation of
+        "AbstractStorelessUnivariateStatistic#equals(Object)"
+        will only return true if both instances have the same type. Previously
+        different statistics were considered to be equal if their current state
+        happened to be equal.
+      </action>    
+      <action dev="tn" type="update" issue="MATH-1205">
+        Default implementations of "AbstractStorelessUnivariateStatistic#evaluate(...)"
+        do not alter the internal state anymore. Instead a temporary copy of
+        the statistic is created for evaluation purposes.
+      </action>    
+      <action dev="tn" type="fix" issue="MATH-1205">
+        Methods "evaluate(...)" of class "Variance" changed the internal state
+        although it was stated differently in the javadoc.
+      </action>    
       <action dev="luc" type="fix" issue="MATH-1191">
         Fixed ignored method parameters in QRDecomposition protected methods.
       </action>    
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/AbstractStorelessUnivariateStatistic.java b/src/main/java/org/apache/commons/math4/stat/descriptive/AbstractStorelessUnivariateStatistic.java
index 197f93f41..599188f93 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/AbstractStorelessUnivariateStatistic.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/AbstractStorelessUnivariateStatistic.java
@@ -19,37 +19,34 @@ package org.apache.commons.math4.stat.descriptive;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.exception.util.LocalizedFormats;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 import org.apache.commons.math4.util.Precision;
 
 /**
- *
- * Abstract implementation of the {@link StorelessUnivariateStatistic} interface.
+ * Abstract base class for implementations of the
+ * {@link StorelessUnivariateStatistic} interface.
  * <p>
- * Provides default <code>evaluate()</code> and <code>incrementAll(double[])</code>
- * implementations.</p>
+ * Provides default {@code evaluate(double[],...)} and {@code incrementAll(double[])}
+ * implementations.
  * <p>
- * <strong>Note that these implementations are not synchronized.</strong></p>
- *
+ * <strong>Note that these implementations are not synchronized.</strong>
  */
 public abstract class AbstractStorelessUnivariateStatistic
-    extends AbstractUnivariateStatistic
     implements StorelessUnivariateStatistic {
 
     /**
-     * This default implementation calls {@link #clear}, then invokes
-     * {@link #increment} in a loop over the the input array, and then uses
-     * {@link #getResult} to compute the return value.
+     * This default implementation creates a copy of this {@link StorelessUnivariateStatistic}
+     * instance, calls {@link #clear} on it, then calls {@link #incrementAll} with the specified
+     * portion of the input array, and then uses {@link #getResult} to compute the return value.
      * <p>
-     * Note that this implementation changes the internal state of the
-     * statistic.  Its side effects are the same as invoking {@link #clear} and
-     * then {@link #incrementAll(double[])}.</p>
+     * Note that this implementation does not change the internal state of the statistic.
      * <p>
-     * Implementations may override this method with a more efficient and
-     * possibly more accurate implementation that works directly with the
-     * input array.</p>
+     * Implementations may override this method with a more efficient and possibly more
+     * accurate implementation that works directly with the input array.
      * <p>
-     * If the array is null, a MathIllegalArgumentException is thrown.</p>
+     * If the array is null, a MathIllegalArgumentException is thrown.
+     *
      * @param values input array
      * @return the value of the statistic applied to the input array
      * @throws MathIllegalArgumentException if values is null
@@ -64,20 +61,18 @@ public abstract class AbstractStorelessUnivariateStatistic
     }
 
     /**
-     * This default implementation calls {@link #clear}, then invokes
-     * {@link #increment} in a loop over the specified portion of the input
-     * array, and then uses {@link #getResult} to compute the return value.
+     * This default implementation creates a copy of this {@link StorelessUnivariateStatistic}
+     * instance, calls {@link #clear} on it, then calls {@link #incrementAll} with the specified
+     * portion of the input array, and then uses {@link #getResult} to compute the return value.
      * <p>
-     * Note that this implementation changes the internal state of the
-     * statistic.  Its side effects are the same as invoking {@link #clear} and
-     * then {@link #incrementAll(double[], int, int)}.</p>
+     * Note that this implementation does not change the internal state of the statistic.
      * <p>
-     * Implementations may override this method with a more efficient and
-     * possibly more accurate implementation that works directly with the
-     * input array.</p>
+     * Implementations may override this method with a more efficient and possibly more
+     * accurate implementation that works directly with the input array.
      * <p>
      * If the array is null or the index parameters are not valid, an
-     * MathIllegalArgumentException is thrown.</p>
+     * MathIllegalArgumentException is thrown.
+     *
      * @param values the input array
      * @param begin the index of the first element to include
      * @param length the number of elements to include
@@ -86,13 +81,16 @@ public abstract class AbstractStorelessUnivariateStatistic
      * @see org.apache.commons.math4.stat.descriptive.UnivariateStatistic#evaluate(double[], int, int)
      */
     @Override
-    public double evaluate(final double[] values, final int begin,
-            final int length) throws MathIllegalArgumentException {
-        if (test(values, begin, length)) {
-            clear();
-            incrementAll(values, begin, length);
+    public double evaluate(final double[] values, final int begin, final int length)
+        throws MathIllegalArgumentException {
+
+        if (MathArrays.verifyValues(values, begin, length)) {
+            final StorelessUnivariateStatistic stat = copy();
+            stat.clear();
+            stat.incrementAll(values, begin, length);
+            return stat.getResult();
         }
-        return getResult();
+        return Double.NaN;
     }
 
     /**
@@ -123,11 +121,11 @@ public abstract class AbstractStorelessUnivariateStatistic
      * This default implementation just calls {@link #increment} in a loop over
      * the input array.
      * <p>
-     * Throws IllegalArgumentException if the input values array is null.</p>
+     * Throws IllegalArgumentException if the input values array is null.
      *
      * @param values values to add
      * @throws MathIllegalArgumentException if values is null
-     * @see org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[])
+     * @see StorelessUnivariateStatistic#incrementAll(double[])
      */
     @Override
     public void incrementAll(double[] values) throws MathIllegalArgumentException {
@@ -141,17 +139,17 @@ public abstract class AbstractStorelessUnivariateStatistic
      * This default implementation just calls {@link #increment} in a loop over
      * the specified portion of the input array.
      * <p>
-     * Throws IllegalArgumentException if the input values array is null.</p>
+     * Throws IllegalArgumentException if the input values array is null.
      *
      * @param values  array holding values to add
      * @param begin   index of the first array element to add
      * @param length  number of array elements to add
      * @throws MathIllegalArgumentException if values is null
-     * @see org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[], int, int)
+     * @see StorelessUnivariateStatistic#incrementAll(double[], int, int)
      */
     @Override
     public void incrementAll(double[] values, int begin, int length) throws MathIllegalArgumentException {
-        if (test(values, begin, length)) {
+        if (MathArrays.verifyValues(values, begin, length)) {
             int k = begin + length;
             for (int i = begin; i < k; i++) {
                 increment(values[i]);
@@ -160,9 +158,11 @@ public abstract class AbstractStorelessUnivariateStatistic
     }
 
     /**
-     * Returns true iff <code>object</code> is an
-     * <code>AbstractStorelessUnivariateStatistic</code> returning the same
-     * values as this for <code>getResult()</code> and <code>getN()</code>
+     * Returns true iff <code>object</code> is the same type of
+     * {@link StorelessUnivariateStatistic} (the object's class equals this
+     * instance) returning the same values as this for <code>getResult()</code>
+     * and <code>getN()</code>.
+     *
      * @param object object to test equality against.
      * @return true if object returns the same value as this
      */
@@ -171,22 +171,22 @@ public abstract class AbstractStorelessUnivariateStatistic
         if (object == this ) {
             return true;
         }
-       if (object instanceof AbstractStorelessUnivariateStatistic == false) {
+        if (object == null || object.getClass() != this.getClass()) {
             return false;
         }
-        AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;
+        StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) object;
         return Precision.equalsIncludingNaN(stat.getResult(), this.getResult()) &&
                Precision.equalsIncludingNaN(stat.getN(), this.getN());
     }
 
     /**
-     * Returns hash code based on getResult() and getN()
+     * Returns hash code based on getResult() and getN().
      *
      * @return hash code
      */
     @Override
     public int hashCode() {
-        return 31* (31 + MathUtils.hash(getResult())) + MathUtils.hash(getN());
+        return 31 * (31 + MathUtils.hash(getResult())) + MathUtils.hash(getN());
     }
 
 }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/AbstractUnivariateStatistic.java b/src/main/java/org/apache/commons/math4/stat/descriptive/AbstractUnivariateStatistic.java
index ab8e02d29..e953aed02 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/AbstractUnivariateStatistic.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/AbstractUnivariateStatistic.java
@@ -24,16 +24,10 @@ import org.apache.commons.math4.exception.util.LocalizedFormats;
 import org.apache.commons.math4.util.MathArrays;
 
 /**
- * Abstract base class for all implementations of the
- * {@link UnivariateStatistic} interface.
+ * Abstract base class for implementations of the {@link UnivariateStatistic} interface.
  * <p>
  * Provides a default implementation of <code>evaluate(double[]),</code>
  * delegating to <code>evaluate(double[], int, int)</code> in the natural way.
- * </p>
- * <p>
- * Also includes a <code>test</code> method that performs generic parameter
- * validation for the <code>evaluate</code> methods.</p>
- *
  */
 public abstract class AbstractUnivariateStatistic
     implements UnivariateStatistic {
@@ -41,6 +35,28 @@ public abstract class AbstractUnivariateStatistic
     /** Stored data. */
     private double[] storedData;
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public double evaluate(final double[] values) throws MathIllegalArgumentException {
+        MathArrays.verifyValues(values, 0, 0);
+        return evaluate(values, 0, values.length);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public abstract double evaluate(final double[] values, final int begin, final int length)
+        throws MathIllegalArgumentException;
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public abstract UnivariateStatistic copy();
+
     /**
      * Set the data array.
      * <p>
@@ -80,7 +96,7 @@ public abstract class AbstractUnivariateStatistic
      * @see #evaluate()
      */
     public void setData(final double[] values, final int begin, final int length)
-    throws MathIllegalArgumentException {
+            throws MathIllegalArgumentException {
         if (values == null) {
             throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
         }
@@ -113,154 +129,4 @@ public abstract class AbstractUnivariateStatistic
         return evaluate(storedData);
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public double evaluate(final double[] values) throws MathIllegalArgumentException {
-        test(values, 0, 0);
-        return evaluate(values, 0, values.length);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public abstract double evaluate(final double[] values, final int begin, final int length)
-    throws MathIllegalArgumentException;
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public abstract UnivariateStatistic copy();
-
-    /**
-     * This method is used by <code>evaluate(double[], int, int)</code> methods
-     * to verify that the input parameters designate a subarray of positive length.
-     * <p>
-     * <ul>
-     * <li>returns <code>true</code> iff the parameters designate a subarray of
-     * positive length</li>
-     * <li>throws <code>MathIllegalArgumentException</code> if the array is null or
-     * or the indices are invalid</li>
-     * <li>returns <code>false</li> if the array is non-null, but
-     * <code>length</code> is 0.
-     * </ul></p>
-     *
-     * @param values the input array
-     * @param begin index of the first array element to include
-     * @param length the number of elements to include
-     * @return true if the parameters are valid and designate a subarray of positive length
-     * @throws MathIllegalArgumentException if the indices are invalid or the array is null
-     */
-    protected boolean test(
-        final double[] values,
-        final int begin,
-        final int length) throws MathIllegalArgumentException {
-        return MathArrays.verifyValues(values, begin, length, false);
-    }
-
-    /**
-     * This method is used by <code>evaluate(double[], int, int)</code> methods
-     * to verify that the input parameters designate a subarray of positive length.
-     * <p>
-     * <ul>
-     * <li>returns <code>true</code> iff the parameters designate a subarray of
-     * non-negative length</li>
-     * <li>throws <code>IllegalArgumentException</code> if the array is null or
-     * or the indices are invalid</li>
-     * <li>returns <code>false</li> if the array is non-null, but
-     * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>
-     * </ul></p>
-     *
-     * @param values the input array
-     * @param begin index of the first array element to include
-     * @param length the number of elements to include
-     * @param allowEmpty if <code>true</code> then zero length arrays are allowed
-     * @return true if the parameters are valid
-     * @throws MathIllegalArgumentException if the indices are invalid or the array is null
-     * @since 3.0
-     */
-    protected boolean test(final double[] values, final int begin,
-            final int length, final boolean allowEmpty) throws MathIllegalArgumentException {
-        return MathArrays.verifyValues(values, begin, length, allowEmpty);
-    }
-
-    /**
-     * This method is used by <code>evaluate(double[], double[], int, int)</code> methods
-     * to verify that the begin and length parameters designate a subarray of positive length
-     * and the weights are all non-negative, non-NaN, finite, and not all zero.
-     * <p>
-     * <ul>
-     * <li>returns <code>true</code> iff the parameters designate a subarray of
-     * positive length and the weights array contains legitimate values.</li>
-     * <li>throws <code>IllegalArgumentException</code> if any of the following are true:
-     * <ul><li>the values array is null</li>
-     *     <li>the weights array is null</li>
-     *     <li>the weights array does not have the same length as the values array</li>
-     *     <li>the weights array contains one or more infinite values</li>
-     *     <li>the weights array contains one or more NaN values</li>
-     *     <li>the weights array contains negative values</li>
-     *     <li>the start and length arguments do not determine a valid array</li></ul>
-     * </li>
-     * <li>returns <code>false</li> if the array is non-null, but
-     * <code>length</code> is 0.
-     * </ul></p>
-     *
-     * @param values the input array
-     * @param weights the weights array
-     * @param begin index of the first array element to include
-     * @param length the number of elements to include
-     * @return true if the parameters are valid and designate a subarray of positive length
-     * @throws MathIllegalArgumentException if the indices are invalid or the array is null
-     * @since 2.1
-     */
-    protected boolean test(
-        final double[] values,
-        final double[] weights,
-        final int begin,
-        final int length) throws MathIllegalArgumentException {
-        return MathArrays.verifyValues(values, weights, begin, length, false);
-    }
-
-    /**
-     * This method is used by <code>evaluate(double[], double[], int, int)</code> methods
-     * to verify that the begin and length parameters designate a subarray of positive length
-     * and the weights are all non-negative, non-NaN, finite, and not all zero.
-     * <p>
-     * <ul>
-     * <li>returns <code>true</code> iff the parameters designate a subarray of
-     * non-negative length and the weights array contains legitimate values.</li>
-     * <li>throws <code>MathIllegalArgumentException</code> if any of the following are true:
-     * <ul><li>the values array is null</li>
-     *     <li>the weights array is null</li>
-     *     <li>the weights array does not have the same length as the values array</li>
-     *     <li>the weights array contains one or more infinite values</li>
-     *     <li>the weights array contains one or more NaN values</li>
-     *     <li>the weights array contains negative values</li>
-     *     <li>the start and length arguments do not determine a valid array</li></ul>
-     * </li>
-     * <li>returns <code>false</li> if the array is non-null, but
-     * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>.
-     * </ul></p>
-     *
-     * @param values the input array.
-     * @param weights the weights array.
-     * @param begin index of the first array element to include.
-     * @param length the number of elements to include.
-     * @param allowEmpty if {@code true} than allow zero length arrays to pass.
-     * @return {@code true} if the parameters are valid.
-     * @throws NullArgumentException if either of the arrays are null
-     * @throws MathIllegalArgumentException if the array indices are not valid,
-     * the weights array contains NaN, infinite or negative elements, or there
-     * are no positive weights.
-     * @since 3.0
-     */
-    protected boolean test(final double[] values, final double[] weights,
-            final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {
-
-        return MathArrays.verifyValues(values, weights, begin, length, allowEmpty);
-    }
 }
-
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/StorelessUnivariateStatistic.java b/src/main/java/org/apache/commons/math4/stat/descriptive/StorelessUnivariateStatistic.java
index 938e093bd..e3db965f9 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/StorelessUnivariateStatistic.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/StorelessUnivariateStatistic.java
@@ -25,8 +25,11 @@ import org.apache.commons.math4.exception.MathIllegalArgumentException;
  * <p>
  * This interface is designed to be used for calculating statistics that can be
  * computed in one pass through the data without storing the full array of
- * sample values.</p>
- *
+ * sample values.
+ * <p>
+ * Note: unless otherwise stated, the {@link #evaluate(double[])} and
+ * {@link #evaluate(double[], int, int)} methods do <b>NOT</b> alter the internal
+ * state of the respective statistic.
  */
 public interface StorelessUnivariateStatistic extends UnivariateStatistic {
 
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/UnivariateStatistic.java b/src/main/java/org/apache/commons/math4/stat/descriptive/UnivariateStatistic.java
index 03228be07..3a07a92ee 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/UnivariateStatistic.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/UnivariateStatistic.java
@@ -22,7 +22,6 @@ import org.apache.commons.math4.util.MathArrays;
 
 /**
  * Base interface implemented by all statistics.
- *
  */
 public interface UnivariateStatistic extends MathArrays.Function {
     /**
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/FirstMoment.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/FirstMoment.java
index 00d85132c..a1eb34057 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/FirstMoment.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/FirstMoment.java
@@ -46,14 +46,12 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 class FirstMoment extends AbstractStorelessUnivariateStatistic
     implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = 6112755307178490473L;
-
+    private static final long serialVersionUID = 20150412L;
 
     /** Count of values that have been added */
     protected long n;
@@ -161,7 +159,6 @@ class FirstMoment extends AbstractStorelessUnivariateStatistic
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.n = source.n;
         dest.m1 = source.m1;
         dest.dev = source.dev;
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/FourthMoment.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/FourthMoment.java
index d7d07dfe2..d0057620c 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/FourthMoment.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/FourthMoment.java
@@ -52,12 +52,11 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally. </p>
- *
  */
 class FourthMoment extends ThirdMoment implements Serializable{
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = 4763990447117157611L;
+    private static final long serialVersionUID = 20150412L;
 
     /** fourth moment of values that have been added */
     private double m4;
@@ -72,7 +71,7 @@ class FourthMoment extends ThirdMoment implements Serializable{
 
     /**
      * Copy constructor, creates a new {@code FourthMoment} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code FourthMoment} instance to copy
      * @throws NullArgumentException if original is null
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/GeometricMean.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/GeometricMean.java
index ab628ded6..938930b52 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/GeometricMean.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/GeometricMean.java
@@ -48,19 +48,17 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
- *
  */
 public class GeometricMean extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -8178734905303459453L;
+    private static final long serialVersionUID = 20150412L;
 
     /** Wrapped SumOfLogs instance */
     private StorelessUnivariateStatistic sumOfLogs;
 
     /**
-     * Create a GeometricMean instance
+     * Create a GeometricMean instance.
      */
     public GeometricMean() {
         sumOfLogs = new SumOfLogs();
@@ -68,7 +66,7 @@ public class GeometricMean extends AbstractStorelessUnivariateStatistic implemen
 
     /**
      * Copy constructor, creates a new {@code GeometricMean} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code GeometricMean} instance to copy
      * @throws NullArgumentException if original is null
@@ -80,7 +78,7 @@ public class GeometricMean extends AbstractStorelessUnivariateStatistic implemen
 
     /**
      * Create a GeometricMean instance using the given SumOfLogs instance
-     * @param sumOfLogs sum of logs instance to use for computation
+     * @param sumOfLogs sum of logs instance to use for computation.
      */
     public GeometricMean(SumOfLogs sumOfLogs) {
         this.sumOfLogs = sumOfLogs;
@@ -142,11 +140,9 @@ public class GeometricMean extends AbstractStorelessUnivariateStatistic implemen
      * index parameters are not valid
      */
     @Override
-    public double evaluate(
-        final double[] values, final int begin, final int length)
-    throws MathIllegalArgumentException {
-        return FastMath.exp(
-            sumOfLogs.evaluate(values, begin, length) / length);
+    public double evaluate(final double[] values, final int begin, final int length)
+        throws MathIllegalArgumentException {
+        return FastMath.exp(sumOfLogs.evaluate(values, begin, length) / length);
     }
 
     /**
@@ -169,13 +165,13 @@ public class GeometricMean extends AbstractStorelessUnivariateStatistic implemen
      *  (i.e if n > 0)
      */
     public void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl)
-    throws MathIllegalStateException {
+        throws MathIllegalStateException {
         checkEmpty();
         this.sumOfLogs = sumLogImpl;
     }
 
     /**
-     * Returns the currently configured sum of logs implementation
+     * Returns the currently configured sum of logs implementation.
      *
      * @return the StorelessUnivariateStatistic implementing the log sum
      */
@@ -195,11 +191,9 @@ public class GeometricMean extends AbstractStorelessUnivariateStatistic implemen
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.sumOfLogs = source.sumOfLogs.copy();
     }
 
-
     /**
      * Throws MathIllegalStateException if n > 0.
      * @throws MathIllegalStateException if data has been added to this statistic
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Kurtosis.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Kurtosis.java
index 2164ed9f3..8e5f2802e 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Kurtosis.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Kurtosis.java
@@ -22,6 +22,7 @@ import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
 import org.apache.commons.math4.util.FastMath;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 
@@ -29,27 +30,26 @@ import org.apache.commons.math4.util.MathUtils;
  * Computes the Kurtosis of the available values.
  * <p>
  * We use the following (unbiased) formula to define kurtosis:</p>
- *  <p>
- *  kurtosis = { [n(n+1) / (n -1)(n - 2)(n-3)] sum[(x_i - mean)^4] / std^4 } - [3(n-1)^2 / (n-2)(n-3)]
- *  </p><p>
- *  where n is the number of values, mean is the {@link Mean} and std is the
+ * <p>
+ * kurtosis = { [n(n+1) / (n -1)(n - 2)(n-3)] sum[(x_i - mean)^4] / std^4 } - [3(n-1)^2 / (n-2)(n-3)]
+ * </p><p>
+ * where n is the number of values, mean is the {@link Mean} and std is the
  * {@link StandardDeviation}</p>
  * <p>
- *  Note that this statistic is undefined for n < 4.  <code>Double.Nan</code>
- *  is returned when there is not sufficient data to compute the statistic.
- *  Note that Double.NaN may also be returned if the input includes NaN
- *  and / or infinite values.</p>
+ * Note that this statistic is undefined for n < 4.  <code>Double.Nan</code>
+ * is returned when there is not sufficient data to compute the statistic.
+ * Note that Double.NaN may also be returned if the input includes NaN
+ * and / or infinite values.</p>
  * <p>
  * <strong>Note that this implementation is not synchronized.</strong> If
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class Kurtosis extends AbstractStorelessUnivariateStatistic  implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = 2784465764798260919L;
+    private static final long serialVersionUID = 20150412L;
 
     /**Fourth Moment on which this statistic is based */
     protected FourthMoment moment;
@@ -59,11 +59,11 @@ public class Kurtosis extends AbstractStorelessUnivariateStatistic  implements S
      * <p>
      * Statistics based on (constructed from) external moments cannot
      * be incremented or cleared.</p>
-    */
+     */
     protected boolean incMoment;
 
     /**
-     * Construct a Kurtosis
+     * Construct a Kurtosis.
      */
     public Kurtosis() {
         incMoment = true;
@@ -71,7 +71,7 @@ public class Kurtosis extends AbstractStorelessUnivariateStatistic  implements S
     }
 
     /**
-     * Construct a Kurtosis from an external moment
+     * Construct a Kurtosis from an external moment.
      *
      * @param m4 external Moment
      */
@@ -82,7 +82,7 @@ public class Kurtosis extends AbstractStorelessUnivariateStatistic  implements S
 
     /**
      * Copy constructor, creates a new {@code Kurtosis} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code Kurtosis} instance to copy
      * @throws NullArgumentException if original is null
@@ -161,13 +161,13 @@ public class Kurtosis extends AbstractStorelessUnivariateStatistic  implements S
      * index parameters are not valid
      */
     @Override
-    public double evaluate(final double[] values,final int begin, final int length)
-    throws MathIllegalArgumentException {
+    public double evaluate(final double[] values, final int begin, final int length)
+        throws MathIllegalArgumentException {
+
         // Initialize the kurtosis
         double kurt = Double.NaN;
 
-        if (test(values, begin, length) && length > 3) {
-
+        if (MathArrays.verifyValues(values, begin, length) && length > 3) {
             // Compute the mean and standard deviation
             Variance variance = new Variance();
             variance.incrementAll(values, begin, length);
@@ -219,7 +219,6 @@ public class Kurtosis extends AbstractStorelessUnivariateStatistic  implements S
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.moment = source.moment.copy();
         dest.incMoment = source.incMoment;
     }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Mean.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Mean.java
index 46a4551b5..4a23b0eb3 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Mean.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Mean.java
@@ -23,11 +23,12 @@ import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
 import org.apache.commons.math4.stat.descriptive.WeightedEvaluation;
 import org.apache.commons.math4.stat.descriptive.summary.Sum;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
- * <p>Computes the arithmetic mean of a set of values. Uses the definitional
- * formula:</p>
+ * Computes the arithmetic mean of a set of values. Uses the definitional
+ * formula:
  * <p>
  * mean = sum(x_i) / n
  * </p>
@@ -58,13 +59,12 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.
- *
  */
 public class Mean extends AbstractStorelessUnivariateStatistic
     implements Serializable, WeightedEvaluation {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -1296043746617791564L;
+    private static final long serialVersionUID = 20150412L;
 
     /** First moment on which this statistic is based. */
     protected FirstMoment moment;
@@ -95,7 +95,7 @@ public class Mean extends AbstractStorelessUnivariateStatistic
 
     /**
      * Copy constructor, creates a new {@code Mean} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code Mean} instance to copy
      * @throws NullArgumentException if original is null
@@ -160,9 +160,10 @@ public class Mean extends AbstractStorelessUnivariateStatistic
      *  parameters are not valid
      */
     @Override
-    public double evaluate(final double[] values,final int begin, final int length)
-    throws MathIllegalArgumentException {
-        if (test(values, begin, length)) {
+    public double evaluate(final double[] values, final int begin, final int length)
+        throws MathIllegalArgumentException {
+
+        if (MathArrays.verifyValues(values, begin, length)) {
             Sum sum = new Sum();
             double sampleSize = length;
 
@@ -211,7 +212,7 @@ public class Mean extends AbstractStorelessUnivariateStatistic
     @Override
     public double evaluate(final double[] values, final double[] weights,
                            final int begin, final int length) throws MathIllegalArgumentException {
-        if (test(values, weights, begin, length)) {
+        if (MathArrays.verifyValues(values, weights, begin, length)) {
             Sum sum = new Sum();
 
             // Compute initial estimate using definitional formula
@@ -254,7 +255,7 @@ public class Mean extends AbstractStorelessUnivariateStatistic
      */
     @Override
     public double evaluate(final double[] values, final double[] weights)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
         return evaluate(values, weights, 0, values.length);
     }
 
@@ -269,7 +270,6 @@ public class Mean extends AbstractStorelessUnivariateStatistic
         return result;
     }
 
-
     /**
      * Copies source to dest.
      * <p>Neither source nor dest can be null.</p>
@@ -282,7 +282,6 @@ public class Mean extends AbstractStorelessUnivariateStatistic
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.incMoment = source.incMoment;
         dest.moment = source.moment.copy();
     }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/SecondMoment.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/SecondMoment.java
index e617adaa1..6cab87548 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/SecondMoment.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/SecondMoment.java
@@ -44,18 +44,17 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class SecondMoment extends FirstMoment implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = 3942403127395076445L;
+    private static final long serialVersionUID = 20150412L;
 
     /** second moment of values that have been added */
     protected double m2;
 
     /**
-     * Create a SecondMoment instance
+     * Create a SecondMoment instance.
      */
     public SecondMoment() {
         super();
@@ -64,13 +63,12 @@ public class SecondMoment extends FirstMoment implements Serializable {
 
     /**
      * Copy constructor, creates a new {@code SecondMoment} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code SecondMoment} instance to copy
      * @throws NullArgumentException if original is null
      */
-    public SecondMoment(SecondMoment original)
-    throws NullArgumentException {
+    public SecondMoment(SecondMoment original) throws NullArgumentException {
         super(original);
         this.m2 = original.m2;
     }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/SemiVariance.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/SemiVariance.java
index 10c865995..2c8f840a9 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/SemiVariance.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/SemiVariance.java
@@ -22,6 +22,7 @@ import java.io.Serializable;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
@@ -66,11 +67,11 @@ public class SemiVariance extends AbstractUnivariateStatistic implements Seriali
     public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -2653430366886024994L;
+    private static final long serialVersionUID = 20150412L;
 
     /**
      * Determines whether or not bias correction is applied when computing the
-     * value of the statisic.  True means that bias is corrected.
+     * value of the statistic.  True means that bias is corrected.
      */
     private boolean biasCorrected = true;
 
@@ -98,7 +99,6 @@ public class SemiVariance extends AbstractUnivariateStatistic implements Seriali
         this.biasCorrected = biasCorrected;
     }
 
-
     /**
      * Constructs a SemiVariance with the specified <code>Direction</code> property
      * and default (true) <code>biasCorrected</code> property
@@ -110,7 +110,6 @@ public class SemiVariance extends AbstractUnivariateStatistic implements Seriali
         this.varianceDirection = direction;
     }
 
-
     /**
      * Constructs a SemiVariance with the specified <code>isBiasCorrected</code>
      * property and the specified <code>Direction</code> property.
@@ -127,10 +126,9 @@ public class SemiVariance extends AbstractUnivariateStatistic implements Seriali
         this.varianceDirection = direction;
     }
 
-
     /**
      * Copy constructor, creates a new {@code SemiVariance} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code SemiVariance} instance to copy
      * @throws NullArgumentException  if original is null
@@ -139,7 +137,6 @@ public class SemiVariance extends AbstractUnivariateStatistic implements Seriali
         copy(original, this);
     }
 
-
     /**
      * {@inheritDoc}
      */
@@ -151,7 +148,6 @@ public class SemiVariance extends AbstractUnivariateStatistic implements Seriali
         return result;
     }
 
-
     /**
      * Copies source to dest.
      * <p>Neither source nor dest can be null.</p>
@@ -164,84 +160,81 @@ public class SemiVariance extends AbstractUnivariateStatistic implements Seriali
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.biasCorrected = source.biasCorrected;
         dest.varianceDirection = source.varianceDirection;
     }
 
     /**
-      * <p>Returns the {@link SemiVariance} of the designated values against the mean, using
-      * instance properties varianceDirection and biasCorrection.</p>
+     * <p>Returns the {@link SemiVariance} of the designated values against the mean, using
+     * instance properties varianceDirection and biasCorrection.</p>
+     *
+     * <p>Returns <code>NaN</code> if the array is empty and throws
+     * <code>IllegalArgumentException</code> if the array is null.</p>
+     *
+     * @param values the input array
+     * @param start index of the first array element to include
+     * @param length the number of elements to include
+     * @return the SemiVariance
+     * @throws MathIllegalArgumentException if the parameters are not valid
+     *
+     */
+     @Override
+     public double evaluate(final double[] values, final int start, final int length)
+         throws MathIllegalArgumentException {
+         double m = (new Mean()).evaluate(values, start, length);
+         return evaluate(values, m, varianceDirection, biasCorrected, 0, values.length);
+     }
+
+     /**
+      * This method calculates {@link SemiVariance} for the entire array against the mean, using
+      * the current value of the biasCorrection instance property.
+      *
+      * @param values the input array
+      * @param direction the {@link Direction} of the semivariance
+      * @return the SemiVariance
+      * @throws MathIllegalArgumentException if values is null
+      *
+      */
+     public double evaluate(final double[] values, Direction direction)
+         throws MathIllegalArgumentException {
+         double m = (new Mean()).evaluate(values);
+         return evaluate(values, m, direction, biasCorrected, 0, values.length);
+     }
+
+     /**
+      * <p>Returns the {@link SemiVariance} of the designated values against the cutoff, using
+      * instance properties variancDirection and biasCorrection.</p>
       *
       * <p>Returns <code>NaN</code> if the array is empty and throws
-      * <code>IllegalArgumentException</code> if the array is null.</p>
+      * <code>MathIllegalArgumentException</code> if the array is null.</p>
       *
       * @param values the input array
-      * @param start index of the first array element to include
-      * @param length the number of elements to include
+      * @param cutoff the reference point
       * @return the SemiVariance
-      * @throws MathIllegalArgumentException if the parameters are not valid
-      *
+      * @throws MathIllegalArgumentException if values is null
       */
-      @Override
-      public double evaluate(final double[] values, final int start, final int length)
-      throws MathIllegalArgumentException {
-        double m = (new Mean()).evaluate(values, start, length);
-        return evaluate(values, m, varianceDirection, biasCorrected, 0, values.length);
-      }
-
-
-      /**
-       * This method calculates {@link SemiVariance} for the entire array against the mean, using
-       * the current value of the biasCorrection instance property.
-       *
-       * @param values the input array
-       * @param direction the {@link Direction} of the semivariance
-       * @return the SemiVariance
-       * @throws MathIllegalArgumentException if values is null
-       *
-       */
-      public double evaluate(final double[] values, Direction direction)
-      throws MathIllegalArgumentException {
-          double m = (new Mean()).evaluate(values);
-          return evaluate (values, m, direction, biasCorrected, 0, values.length);
-      }
-
-      /**
-       * <p>Returns the {@link SemiVariance} of the designated values against the cutoff, using
-       * instance properties variancDirection and biasCorrection.</p>
-       *
-       * <p>Returns <code>NaN</code> if the array is empty and throws
-       * <code>MathIllegalArgumentException</code> if the array is null.</p>
-       *
-       * @param values the input array
-       * @param cutoff the reference point
-       * @return the SemiVariance
-       * @throws MathIllegalArgumentException if values is null
-       */
-      public double evaluate(final double[] values, final double cutoff)
-      throws MathIllegalArgumentException {
-          return evaluate(values, cutoff, varianceDirection, biasCorrected, 0, values.length);
-      }
-
-      /**
-       * <p>Returns the {@link SemiVariance} of the designated values against the cutoff in the
-       * given direction, using the current value of the biasCorrection instance property.</p>
-       *
-       * <p>Returns <code>NaN</code> if the array is empty and throws
-       * <code>MathIllegalArgumentException</code> if the array is null.</p>
-       *
-       * @param values the input array
-       * @param cutoff the reference point
-       * @param direction the {@link Direction} of the semivariance
-       * @return the SemiVariance
-       * @throws MathIllegalArgumentException if values is null
-       */
-      public double evaluate(final double[] values, final double cutoff, final Direction direction)
-      throws MathIllegalArgumentException {
-          return evaluate(values, cutoff, direction, biasCorrected, 0, values.length);
-      }
+     public double evaluate(final double[] values, final double cutoff)
+         throws MathIllegalArgumentException {
+         return evaluate(values, cutoff, varianceDirection, biasCorrected, 0, values.length);
+     }
 
+     /**
+      * <p>Returns the {@link SemiVariance} of the designated values against the cutoff in the
+      * given direction, using the current value of the biasCorrection instance property.</p>
+      *
+      * <p>Returns <code>NaN</code> if the array is empty and throws
+      * <code>MathIllegalArgumentException</code> if the array is null.</p>
+      *
+      * @param values the input array
+      * @param cutoff the reference point
+      * @param direction the {@link Direction} of the semivariance
+      * @return the SemiVariance
+      * @throws MathIllegalArgumentException if values is null
+      */
+     public double evaluate(final double[] values, final double cutoff, final Direction direction)
+         throws MathIllegalArgumentException {
+         return evaluate(values, cutoff, direction, biasCorrected, 0, values.length);
+     }
 
      /**
       * <p>Returns the {@link SemiVariance} of the designated values against the cutoff
@@ -260,110 +253,111 @@ public class SemiVariance extends AbstractUnivariateStatistic implements Seriali
       * @throws MathIllegalArgumentException if the parameters are not valid
       *
       */
-    public double evaluate (final double[] values, final double cutoff, final Direction direction,
-            final boolean corrected, final int start, final int length) throws MathIllegalArgumentException {
-
-        test(values, start, length);
-        if (values.length == 0) {
-            return Double.NaN;
-        } else {
-            if (values.length == 1) {
-                return 0.0;
-            } else {
-                final boolean booleanDirection = direction.getDirection();
-
-                double dev = 0.0;
-                double sumsq = 0.0;
-                for (int i = start; i < length; i++) {
-                    if ((values[i] > cutoff) == booleanDirection) {
-                       dev = values[i] - cutoff;
-                       sumsq += dev * dev;
-                    }
-                }
-
-                if (corrected) {
-                    return sumsq / (length - 1.0);
-                } else {
-                    return sumsq / length;
-                }
-            }
-        }
-    }
+     public double evaluate (final double[] values, final double cutoff, final Direction direction,
+                             final boolean corrected, final int start, final int length)
+         throws MathIllegalArgumentException {
+
+         MathArrays.verifyValues(values, start, length);
+         if (values.length == 0) {
+             return Double.NaN;
+         } else {
+             if (values.length == 1) {
+                 return 0.0;
+             } else {
+                 final boolean booleanDirection = direction.getDirection();
+
+                 double dev = 0.0;
+                 double sumsq = 0.0;
+                 for (int i = start; i < length; i++) {
+                     if ((values[i] > cutoff) == booleanDirection) {
+                         dev = values[i] - cutoff;
+                         sumsq += dev * dev;
+                     }
+                 }
+
+                 if (corrected) {
+                     return sumsq / (length - 1.0);
+                 } else {
+                     return sumsq / length;
+                 }
+             }
+         }
+     }
 
-    /**
-     * Returns true iff biasCorrected property is set to true.
-     *
-     * @return the value of biasCorrected.
-     */
-    public boolean isBiasCorrected() {
-        return biasCorrected;
-    }
+     /**
+      * Returns true iff biasCorrected property is set to true.
+      *
+      * @return the value of biasCorrected.
+      */
+     public boolean isBiasCorrected() {
+         return biasCorrected;
+     }
 
-    /**
-     * Sets the biasCorrected property.
-     *
-     * @param biasCorrected new biasCorrected property value
-     */
-    public void setBiasCorrected(boolean biasCorrected) {
-        this.biasCorrected = biasCorrected;
-    }
+     /**
+      * Sets the biasCorrected property.
+      *
+      * @param biasCorrected new biasCorrected property value
+      */
+     public void setBiasCorrected(boolean biasCorrected) {
+         this.biasCorrected = biasCorrected;
+     }
 
-    /**
-     * Returns the varianceDirection property.
-     *
-     * @return the varianceDirection
-     */
-    public Direction getVarianceDirection () {
-        return varianceDirection;
-    }
+     /**
+      * Returns the varianceDirection property.
+      *
+      * @return the varianceDirection
+      */
+     public Direction getVarianceDirection () {
+         return varianceDirection;
+     }
 
-    /**
-     * Sets the variance direction
-     *
-     * @param varianceDirection the direction of the semivariance
-     */
-    public void setVarianceDirection(Direction varianceDirection) {
-        this.varianceDirection = varianceDirection;
-    }
+     /**
+      * Sets the variance direction
+      *
+      * @param varianceDirection the direction of the semivariance
+      */
+     public void setVarianceDirection(Direction varianceDirection) {
+         this.varianceDirection = varianceDirection;
+     }
 
-    /**
-     * The direction of the semivariance - either upside or downside. The direction
-     * is represented by boolean, with true corresponding to UPSIDE semivariance.
-     */
-    public enum Direction {
-        /**
-         * The UPSIDE Direction is used to specify that the observations above the
-         * cutoff point will be used to calculate SemiVariance
-         */
-        UPSIDE (true),
-
-        /**
-         * The DOWNSIDE Direction is used to specify that the observations below
-         * the cutoff point will be used to calculate SemiVariance
-         */
-        DOWNSIDE (false);
-
-        /**
-         *   boolean value  UPSIDE <-> true
-         */
-        private boolean direction;
-
-        /**
-         * Create a Direction with the given value.
-         *
-         * @param b boolean value representing the Direction. True corresponds to UPSIDE.
-         */
-        Direction (boolean b) {
-            direction = b;
-        }
-
-        /**
-         * Returns the value of this Direction. True corresponds to UPSIDE.
-         *
-         * @return true if direction is UPSIDE; false otherwise
-         */
-        boolean getDirection () {
-            return direction;
-        }
-    }
+     /**
+      * The direction of the semivariance - either upside or downside. The direction
+      * is represented by boolean, with true corresponding to UPSIDE semivariance.
+      */
+     public enum Direction {
+         /**
+          * The UPSIDE Direction is used to specify that the observations above the
+          * cutoff point will be used to calculate SemiVariance
+          */
+         UPSIDE (true),
+
+         /**
+          * The DOWNSIDE Direction is used to specify that the observations below
+          * the cutoff point will be used to calculate SemiVariance
+          */
+         DOWNSIDE (false);
+
+         /**
+          * boolean value  UPSIDE <-> true
+          */
+         private boolean direction;
+
+         /**
+          * Create a Direction with the given value.
+          *
+          * @param b boolean value representing the Direction. True corresponds to UPSIDE.
+          */
+         Direction (boolean b) {
+             direction = b;
+         }
+
+         /**
+          * Returns the value of this Direction. True corresponds to UPSIDE.
+          *
+          * @return true if direction is UPSIDE; false otherwise
+          */
+         boolean getDirection () {
+             return direction;
+         }
+     }
 }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Skewness.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Skewness.java
index 3b488c9b0..8dca668fc 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Skewness.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Skewness.java
@@ -22,6 +22,7 @@ import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
 import org.apache.commons.math4.util.FastMath;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
@@ -38,12 +39,11 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally. </p>
- *
  */
 public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = 7101857578996691352L;
+    private static final long serialVersionUID = 20150412L;
 
     /** Third moment on which this statistic is based */
     protected ThirdMoment moment = null;
@@ -57,7 +57,7 @@ public class Skewness extends AbstractStorelessUnivariateStatistic implements Se
     protected boolean incMoment;
 
     /**
-     * Constructs a Skewness
+     * Constructs a Skewness.
      */
     public Skewness() {
         incMoment = true;
@@ -65,7 +65,7 @@ public class Skewness extends AbstractStorelessUnivariateStatistic implements Se
     }
 
     /**
-     * Constructs a Skewness with an external moment
+     * Constructs a Skewness with an external moment.
      * @param m3 external moment
      */
     public Skewness(final ThirdMoment m3) {
@@ -75,7 +75,7 @@ public class Skewness extends AbstractStorelessUnivariateStatistic implements Se
 
     /**
      * Copy constructor, creates a new {@code Skewness} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code Skewness} instance to copy
      * @throws NullArgumentException if original is null
@@ -139,7 +139,7 @@ public class Skewness extends AbstractStorelessUnivariateStatistic implements Se
     }
 
     /**
-     * Returns the Skewness of the entries in the specifed portion of the
+     * Returns the Skewness of the entries in the specified portion of the
      * input array.
      * <p>
      * See {@link Skewness} for the definition used in the computation.</p>
@@ -149,19 +149,18 @@ public class Skewness extends AbstractStorelessUnivariateStatistic implements Se
      * @param values the input array
      * @param begin the index of the first array element to include
      * @param length the number of elements to include
-     * @return the skewness of the values or Double.NaN if length is less than
-     * 3
+     * @return the skewness of the values or Double.NaN if length is less than 3
      * @throws MathIllegalArgumentException if the array is null or the array index
      *  parameters are not valid
      */
     @Override
-    public double evaluate(final double[] values,final int begin,
-            final int length) throws MathIllegalArgumentException {
+    public double evaluate(final double[] values,final int begin, final int length)
+        throws MathIllegalArgumentException {
 
         // Initialize the skewness
         double skew = Double.NaN;
 
-        if (test(values, begin, length) && length > 2 ){
+        if (MathArrays.verifyValues(values, begin, length) && length > 2 ) {
             Mean mean = new Mean();
             // Get the mean and the standard deviation
             double m = mean.evaluate(values, begin, length);
@@ -217,7 +216,6 @@ public class Skewness extends AbstractStorelessUnivariateStatistic implements Se
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.moment = new ThirdMoment(source.moment.copy());
         dest.incMoment = source.incMoment;
     }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/StandardDeviation.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/StandardDeviation.java
index 0d86be2cb..d2f5e8bc2 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/StandardDeviation.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/StandardDeviation.java
@@ -38,13 +38,12 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class StandardDeviation extends AbstractStorelessUnivariateStatistic
     implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = 5728716329662425188L;
+    private static final long serialVersionUID = 20150412L;
 
     /** Wrapped Variance instance */
     private Variance variance = null;
@@ -68,7 +67,7 @@ public class StandardDeviation extends AbstractStorelessUnivariateStatistic
 
     /**
      * Copy constructor, creates a new {@code StandardDeviation} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code StandardDeviation} instance to copy
      * @throws NullArgumentException if original is null
@@ -78,7 +77,7 @@ public class StandardDeviation extends AbstractStorelessUnivariateStatistic
     }
 
     /**
-     * Contructs a StandardDeviation with the specified value for the
+     * Constructs a StandardDeviation with the specified value for the
      * <code>isBiasCorrected</code> property.  If this property is set to
      * <code>true</code>, the {@link Variance} used in computing results will
      * use the bias-corrected, or "sample" formula.  See {@link Variance} for
@@ -92,7 +91,7 @@ public class StandardDeviation extends AbstractStorelessUnivariateStatistic
     }
 
     /**
-     * Contructs a StandardDeviation with the specified value for the
+     * Constructs a StandardDeviation with the specified value for the
      * <code>isBiasCorrected</code> property and the supplied external moment.
      * If <code>isBiasCorrected</code> is set to <code>true</code>, the
      * {@link Variance} used in computing results will use the bias-corrected,
@@ -177,8 +176,8 @@ public class StandardDeviation extends AbstractStorelessUnivariateStatistic
      */
     @Override
     public double evaluate(final double[] values, final int begin, final int length)
-    throws MathIllegalArgumentException  {
-       return FastMath.sqrt(variance.evaluate(values, begin, length));
+        throws MathIllegalArgumentException  {
+        return FastMath.sqrt(variance.evaluate(values, begin, length));
     }
 
     /**
@@ -206,7 +205,7 @@ public class StandardDeviation extends AbstractStorelessUnivariateStatistic
      *  parameters are not valid
      */
     public double evaluate(final double[] values, final double mean,
-            final int begin, final int length) throws MathIllegalArgumentException  {
+                           final int begin, final int length) throws MathIllegalArgumentException  {
         return FastMath.sqrt(variance.evaluate(values, mean, begin, length));
     }
 
@@ -232,7 +231,7 @@ public class StandardDeviation extends AbstractStorelessUnivariateStatistic
      * @throws MathIllegalArgumentException if the array is null
      */
     public double evaluate(final double[] values, final double mean)
-    throws MathIllegalArgumentException  {
+        throws MathIllegalArgumentException  {
         return FastMath.sqrt(variance.evaluate(values, mean));
     }
 
@@ -261,7 +260,6 @@ public class StandardDeviation extends AbstractStorelessUnivariateStatistic
         return result;
     }
 
-
     /**
      * Copies source to dest.
      * <p>Neither source nor dest can be null.</p>
@@ -270,11 +268,9 @@ public class StandardDeviation extends AbstractStorelessUnivariateStatistic
      * @param dest StandardDeviation to copy to
      * @throws NullArgumentException if either source or dest is null
      */
-    public static void copy(StandardDeviation source, StandardDeviation dest)
-        throws NullArgumentException {
+    public static void copy(StandardDeviation source, StandardDeviation dest) throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.variance = source.variance.copy();
     }
 
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/ThirdMoment.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/ThirdMoment.java
index ba740554e..b26b77faa 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/ThirdMoment.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/ThirdMoment.java
@@ -51,12 +51,12 @@ import org.apache.commons.math4.util.MathUtils;
 class ThirdMoment extends SecondMoment implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -7818711964045118679L;
+    private static final long serialVersionUID = 20150412L;
 
     /** third moment of values that have been added */
     protected double m3;
 
-     /**
+    /**
      * Square of deviation of most recently added value from previous first
      * moment, normalized by previous sample size.  Retained to prevent
      * repeated computation in higher order moments.  nDevSq = nDev * nDev.
@@ -64,7 +64,7 @@ class ThirdMoment extends SecondMoment implements Serializable {
     protected double nDevSq;
 
     /**
-     * Create a FourthMoment instance
+     * Create a FourthMoment instance.
      */
     public ThirdMoment() {
         super();
@@ -74,10 +74,10 @@ class ThirdMoment extends SecondMoment implements Serializable {
 
     /**
      * Copy constructor, creates a new {@code ThirdMoment} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code ThirdMoment} instance to copy
-     * @throws NullArgumentException if orginal is null
+     * @throws NullArgumentException if original is null
      */
     public ThirdMoment(ThirdMoment original) throws NullArgumentException {
         copy(original, this);
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Variance.java b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Variance.java
index c7602aea0..d88f95280 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Variance.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/moment/Variance.java
@@ -23,6 +23,7 @@ import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.exception.util.LocalizedFormats;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
 import org.apache.commons.math4.stat.descriptive.WeightedEvaluation;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
@@ -64,12 +65,11 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable, WeightedEvaluation {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -9111962718267217978L;
+    private static final long serialVersionUID = 20150412L;
 
     /** SecondMoment is used in incremental calculation of Variance*/
     protected SecondMoment moment = null;
@@ -100,13 +100,13 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
 
     /**
      * Constructs a Variance based on an external second moment.
+     * <p>
      * When this constructor is used, the statistic may only be
      * incremented via the moment, i.e., {@link #increment(double)}
      * does nothing; whereas {@code m2.increment(value)} increments
      * both {@code m2} and the Variance instance constructed from it.
      *
-     * @param m2 the SecondMoment (Third or Fourth moments work
-     * here as well.)
+     * @param m2 the SecondMoment (Third or Fourth moments work here as well.)
      */
     public Variance(final SecondMoment m2) {
         incMoment = false;
@@ -115,7 +115,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
 
     /**
      * Constructs a Variance with the specified <code>isBiasCorrected</code>
-     * property
+     * property.
      *
      * @param isBiasCorrected  setting for bias correction - true means
      * bias will be corrected and is equivalent to using the argumentless
@@ -143,7 +143,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
 
     /**
      * Copy constructor, creates a new {@code Variance} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code Variance} instance to copy
      * @throws NullArgumentException if original is null
@@ -177,17 +177,17 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
      */
     @Override
     public double getResult() {
-            if (moment.n == 0) {
-                return Double.NaN;
-            } else if (moment.n == 1) {
-                return 0d;
+        if (moment.n == 0) {
+            return Double.NaN;
+        } else if (moment.n == 1) {
+            return 0d;
+        } else {
+            if (isBiasCorrected) {
+                return moment.m2 / (moment.n - 1d);
             } else {
-                if (isBiasCorrected) {
-                    return moment.m2 / (moment.n - 1d);
-                } else {
-                    return moment.m2 / (moment.n);
-                }
+                return moment.m2 / (moment.n);
             }
+        }
     }
 
     /**
@@ -255,12 +255,11 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
      */
     @Override
     public double evaluate(final double[] values, final int begin, final int length)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
 
         double var = Double.NaN;
 
-        if (test(values, begin, length)) {
-            clear();
+        if (MathArrays.verifyValues(values, begin, length)) {
             if (length == 1) {
                 var = 0.0;
             } else if (length > 1) {
@@ -320,8 +319,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
 
         double var = Double.NaN;
 
-        if (test(values, weights,begin, length)) {
-            clear();
+        if (MathArrays.verifyValues(values, weights,begin, length)) {
             if (length == 1) {
                 var = 0.0;
             } else if (length > 1) {
@@ -373,7 +371,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
      */
     @Override
     public double evaluate(final double[] values, final double[] weights)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
         return evaluate(values, weights, 0, values.length);
     }
 
@@ -404,11 +402,11 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
      *  parameters are not valid
      */
     public double evaluate(final double[] values, final double mean,
-            final int begin, final int length) throws MathIllegalArgumentException {
+                           final int begin, final int length) throws MathIllegalArgumentException {
 
         double var = Double.NaN;
 
-        if (test(values, begin, length)) {
+        if (MathArrays.verifyValues(values, begin, length)) {
             if (length == 1) {
                 var = 0.0;
             } else if (length > 1) {
@@ -506,12 +504,12 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
      * @since 2.1
      */
     public double evaluate(final double[] values, final double[] weights,
-    final double mean, final int begin, final int length)
-    throws MathIllegalArgumentException {
+                           final double mean, final int begin, final int length)
+        throws MathIllegalArgumentException {
 
         double var = Double.NaN;
 
-        if (test(values, weights, begin, length)) {
+        if (MathArrays.verifyValues(values, weights, begin, length)) {
             if (length == 1) {
                 var = 0.0;
             } else if (length > 1) {
@@ -581,7 +579,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
      * @since 2.1
      */
     public double evaluate(final double[] values, final double[] weights, final double mean)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
         return evaluate(values, weights, mean, 0, values.length);
     }
 
@@ -622,7 +620,6 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.moment = source.moment.copy();
         dest.isBiasCorrected = source.isBiasCorrected;
         dest.incMoment = source.incMoment;
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Max.java b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Max.java
index 60efe1b1c..502d2d413 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Max.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Max.java
@@ -21,6 +21,7 @@ import java.io.Serializable;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
@@ -37,12 +38,11 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class Max extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -5593383832225844641L;
+    private static final long serialVersionUID = 20150412L;
 
     /** Number of values that have been added */
     private long n;
@@ -51,7 +51,7 @@ public class Max extends AbstractStorelessUnivariateStatistic implements Seriali
     private double value;
 
     /**
-     * Create a Max instance
+     * Create a Max instance.
      */
     public Max() {
         n = 0;
@@ -60,7 +60,7 @@ public class Max extends AbstractStorelessUnivariateStatistic implements Seriali
 
     /**
      * Copy constructor, creates a new {@code Max} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code Max} instance to copy
      * @throws NullArgumentException if original is null
@@ -129,9 +129,10 @@ public class Max extends AbstractStorelessUnivariateStatistic implements Seriali
      */
     @Override
     public double evaluate(final double[] values, final int begin, final int length)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
+
         double max = Double.NaN;
-        if (test(values, begin, length)) {
+        if (MathArrays.verifyValues(values, begin, length)) {
             max = values[begin];
             for (int i = begin; i < begin + length; i++) {
                 if (!Double.isNaN(values[i])) {
@@ -165,7 +166,6 @@ public class Max extends AbstractStorelessUnivariateStatistic implements Seriali
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.n = source.n;
         dest.value = source.value;
     }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Median.java b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Median.java
index 4aa10bf1e..d2a62cc7c 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Median.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Median.java
@@ -32,12 +32,11 @@ import org.apache.commons.math4.util.KthSelector;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class Median extends Percentile implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -3961477041290915687L;
+    private static final long serialVersionUID = 20150412L;
 
     /** Fixed quantile. */
     private static final double FIXED_QUANTILE_50 = 50.0;
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Min.java b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Min.java
index 0152e48de..72eaef448 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Min.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Min.java
@@ -21,6 +21,7 @@ import java.io.Serializable;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
@@ -37,12 +38,11 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -2941995784909003131L;
+    private static final long serialVersionUID = 20150412L;
 
     /**Number of values that have been added */
     private long n;
@@ -51,7 +51,7 @@ public class Min extends AbstractStorelessUnivariateStatistic implements Seriali
     private double value;
 
     /**
-     * Create a Min instance
+     * Create a Min instance.
      */
     public Min() {
         n = 0;
@@ -60,7 +60,7 @@ public class Min extends AbstractStorelessUnivariateStatistic implements Seriali
 
     /**
      * Copy constructor, creates a new {@code Min} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code Min} instance to copy
      * @throws NullArgumentException if original is null
@@ -129,9 +129,10 @@ public class Min extends AbstractStorelessUnivariateStatistic implements Seriali
      */
     @Override
     public double evaluate(final double[] values,final int begin, final int length)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
+
         double min = Double.NaN;
-        if (test(values, begin, length)) {
+        if (MathArrays.verifyValues(values, begin, length)) {
             min = values[begin];
             for (int i = begin; i < begin + length; i++) {
                 if (!Double.isNaN(values[i])) {
@@ -165,7 +166,6 @@ public class Min extends AbstractStorelessUnivariateStatistic implements Seriali
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.n = source.n;
         dest.value = source.value;
     }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/PSquarePercentile.java b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/PSquarePercentile.java
index 2e1e27bb5..097b8fd9a 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/PSquarePercentile.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/PSquarePercentile.java
@@ -70,20 +70,18 @@ public class PSquarePercentile extends AbstractStorelessUnivariateStatistic
     /**
      * Serial ID
      */
-    private static final long serialVersionUID = 2283912083175715479L;
+    private static final long serialVersionUID = 20150412L;
 
     /**
      * A decimal formatter for print convenience
      */
-    private static final DecimalFormat DECIMAL_FORMAT = new DecimalFormat(
-            "00.00");
+    private static final DecimalFormat DECIMAL_FORMAT = new DecimalFormat("00.00");
 
     /**
      * Initial list of 5 numbers corresponding to 5 markers. <b>NOTE:</b>watch
      * out for the add methods that are overloaded
      */
-    private final List<Double> initialFive = new FixedCapacityList<Double>(
-            PSQUARE_CONSTANT);
+    private final List<Double> initialFive = new FixedCapacityList<Double>(PSQUARE_CONSTANT);
 
     /**
      * The quantile needed should be in range of 0-1. The constructor
@@ -122,15 +120,14 @@ public class PSquarePercentile extends AbstractStorelessUnivariateStatistic
      */
     public PSquarePercentile(final double p) {
         if (p > 100 || p < 0) {
-            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE,
-                    p, 0, 100);
+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE, p, 0, 100);
         }
         this.quantile = p / 100d;// always set it within (0,1]
     }
 
     /**
      * Default constructor that assumes a {@link #DEFAULT_QUANTILE_DESIRED
-     * default quantile} needed
+     * default quantile} needed.
      */
     PSquarePercentile() {
         this(DEFAULT_QUANTILE_DESIRED);
@@ -540,13 +537,10 @@ public class PSquarePercentile extends AbstractStorelessUnivariateStatistic
             anInputStream.defaultReadObject();
             // Build links
             for (int i = 1; i < PSQUARE_CONSTANT; i++) {
-                markerArray[i].previous(markerArray[i - 1])
-                        .next(markerArray[i + 1]).index(i);
+                markerArray[i].previous(markerArray[i - 1]).next(markerArray[i + 1]).index(i);
             }
-            markerArray[0].previous(markerArray[0]).next(markerArray[1])
-                    .index(0);
-            markerArray[5].previous(markerArray[4]).next(markerArray[5])
-                    .index(5);
+            markerArray[0].previous(markerArray[0]).next(markerArray[1]).index(0);
+            markerArray[5].previous(markerArray[4]).next(markerArray[5]).index(5);
         }
 
         /**
@@ -558,8 +552,7 @@ public class PSquarePercentile extends AbstractStorelessUnivariateStatistic
         @Override
         public double height(final int markerIndex) {
             if (markerIndex >= markerArray.length || markerIndex <= 0) {
-                throw new OutOfRangeException(markerIndex, 1,
-                        markerArray.length);
+                throw new OutOfRangeException(markerIndex, 1, markerArray.length);
             }
             return markerArray[markerIndex].markerHeight;
         }
@@ -649,14 +642,12 @@ public class PSquarePercentile extends AbstractStorelessUnivariateStatistic
         /**
          * Nonlinear interpolator
          */
-        private final UnivariateInterpolator nonLinear =
-                new NevilleInterpolator();
+        private final UnivariateInterpolator nonLinear = new NevilleInterpolator();
 
         /**
          * Linear interpolator which is not serializable
          */
-        private transient UnivariateInterpolator linear =
-                new LinearInterpolator();
+        private transient UnivariateInterpolator linear = new LinearInterpolator();
 
         /**
          * Default constructor
@@ -861,8 +852,7 @@ public class PSquarePercentile extends AbstractStorelessUnivariateStatistic
          */
         @Override
         public Object clone() {
-            return new Marker(markerHeight, desiredMarkerPosition,
-                    desiredMarkerIncrement, intMarkerPosition);
+            return new Marker(markerHeight, desiredMarkerPosition, desiredMarkerIncrement, intMarkerPosition);
         }
 
         /**
@@ -887,8 +877,8 @@ public class PSquarePercentile extends AbstractStorelessUnivariateStatistic
      *
      * @param <E>
      */
-    private static class FixedCapacityList<E> extends ArrayList<E> implements
-            Serializable {
+    private static class FixedCapacityList<E> extends ArrayList<E> implements Serializable {
+
         /**
          * Serialization Version Id
          */
@@ -945,8 +935,7 @@ public class PSquarePercentile extends AbstractStorelessUnivariateStatistic
      * @param p the quantile desired
      * @return an instance of PSquareMarkers
      */
-    public static PSquareMarkers newMarkers(final List<Double> initialFive,
-            final double p) {
+    public static PSquareMarkers newMarkers(final List<Double> initialFive, final double p) {
         return new Markers(initialFive, p);
     }
 
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Percentile.java b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Percentile.java
index 3b6f06564..f82043775 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Percentile.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/rank/Percentile.java
@@ -90,12 +90,11 @@ import org.apache.commons.math4.util.Precision;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class Percentile extends AbstractUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -8091216485095130416L;
+    private static final long serialVersionUID = 20150412L;
 
     /** Maximum number of partitioning pivots cached (each level double the number of pivots). */
     private static final int MAX_CACHED_LEVELS = 10;
@@ -112,8 +111,10 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
     /** NaN Handling of the input as defined by {@link NaNStrategy} */
     private final NaNStrategy nanStrategy;
 
-    /** Determines what percentile is computed when evaluate() is activated
-     * with no quantile argument */
+    /**
+     * Determines what percentile is computed when evaluate() is activated
+     * with no quantile argument.
+     */
     private double quantile;
 
     /** Cached pivots. */
@@ -263,12 +264,12 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
      * @param values input array of values
      * @param p the percentile value to compute
      * @return the percentile value or Double.NaN if the array is empty
-     * @throws MathIllegalArgumentException if <code>values</code> is null
-     *     or p is invalid
+     * @throws MathIllegalArgumentException if <code>values</code> is null or p is invalid
      */
     public double evaluate(final double[] values, final double p)
-    throws MathIllegalArgumentException {
-        test(values, 0, 0);
+        throws MathIllegalArgumentException {
+
+        MathArrays.verifyValues(values, 0, 0);
         return evaluate(values, 0, values.length, p);
     }
 
@@ -297,7 +298,7 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
      */
     @Override
     public double evaluate(final double[] values, final int start, final int length)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
         return evaluate(values, start, length, quantile);
     }
 
@@ -335,10 +336,9 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
                            final int length, final double p)
         throws MathIllegalArgumentException {
 
-        test(values, begin, length);
+        MathArrays.verifyValues(values, begin, length);
         if (p > 100 || p <= 0) {
-            throw new OutOfRangeException(
-                    LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p, 0, 100);
+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p, 0, 100);
         }
         if (length == 0) {
             return Double.NaN;
@@ -401,11 +401,11 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
      * @throws MathIllegalArgumentException if values or indices are invalid
      */
     protected double[] getWorkArray(final double[] values, final int begin, final int length) {
-            final double[] work;
-            if (values == getDataRef()) {
-                work = getDataRef();
-            } else {
-                switch (nanStrategy) {
+        final double[] work;
+        if (values == getDataRef()) {
+            work = getDataRef();
+        } else {
+            switch (nanStrategy) {
                 case MAXIMAL:// Replace NaNs with +INFs
                     work = replaceAndSlice(values, begin, length, Double.NaN, Double.POSITIVE_INFINITY);
                     break;
@@ -422,9 +422,9 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
                 default: //FIXED
                     work = copyOf(values,begin,length);
                     break;
-                }
             }
-            return work;
+        }
+        return work;
     }
 
     /**
@@ -486,7 +486,7 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
         //Check if empty then create a new copy
         if (bits.isEmpty()) {
             temp = copyOf(values, begin, length); // Nothing removed, just copy
-        } else if(bits.cardinality() == length){
+        } else if(bits.cardinality() == length) {
             temp = new double[0];                 // All removed, just empty
         }else {                                   // Some removable, so new
             temp = new double[length - bits.cardinality()];
@@ -630,8 +630,7 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
      * @throws NullArgumentException when newKthSelector is null
      */
     public Percentile withKthSelector(final KthSelector newKthSelector) {
-        return new Percentile(quantile, estimationType, nanStrategy,
-                                newKthSelector);
+        return new Percentile(quantile, estimationType, nanStrategy, newKthSelector);
     }
 
     /**
@@ -669,7 +668,6 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
      * <a href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html">
      * R-Manual </a></li>
      * </ol>
-     *
      */
     public static enum EstimationType {
         /**
@@ -808,7 +806,7 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
          * &amp;maxLimit = (N-0.5)/N
          * \end{align}\)
          */
-        R_5("R-5"){
+        R_5("R-5") {
 
             @Override
             protected double index(final double p, final int length) {
@@ -836,7 +834,7 @@ public class Percentile extends AbstractUnivariateStatistic implements Serializa
          * first element (p&lt;1(N+1)) and last elements (p&gt;N/(N+1))are done.
          * While in default case; these are done with p=0 and p=1 respectively.
          */
-        R_6("R-6"){
+        R_6("R-6") {
 
             @Override
             protected double index(final double p, final int length) {
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/summary/Product.java b/src/main/java/org/apache/commons/math4/stat/descriptive/summary/Product.java
index 99e1fa73a..5be6ce9b2 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/summary/Product.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/summary/Product.java
@@ -23,6 +23,7 @@ import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
 import org.apache.commons.math4.stat.descriptive.WeightedEvaluation;
 import org.apache.commons.math4.util.FastMath;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
@@ -36,12 +37,11 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class Product extends AbstractStorelessUnivariateStatistic implements Serializable, WeightedEvaluation {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = 2824226005990582538L;
+    private static final long serialVersionUID = 20150412L;
 
     /**The number of values that have been added */
     private long n;
@@ -52,7 +52,7 @@ public class Product extends AbstractStorelessUnivariateStatistic implements Ser
     private double value;
 
     /**
-     * Create a Product instance
+     * Create a Product instance.
      */
     public Product() {
         n = 0;
@@ -61,7 +61,7 @@ public class Product extends AbstractStorelessUnivariateStatistic implements Ser
 
     /**
      * Copy constructor, creates a new {@code Product} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code Product} instance to copy
      * @throws NullArgumentException  if original is null
@@ -120,9 +120,9 @@ public class Product extends AbstractStorelessUnivariateStatistic implements Ser
      */
     @Override
     public double evaluate(final double[] values, final int begin, final int length)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
         double product = Double.NaN;
-        if (test(values, begin, length, true)) {
+        if (MathArrays.verifyValues(values, begin, length, true)) {
             product = 1.0;
             for (int i = begin; i < begin + length; i++) {
                 product *= values[i];
@@ -161,9 +161,9 @@ public class Product extends AbstractStorelessUnivariateStatistic implements Ser
      */
     @Override
     public double evaluate(final double[] values, final double[] weights,
-        final int begin, final int length) throws MathIllegalArgumentException {
+                           final int begin, final int length) throws MathIllegalArgumentException {
         double product = Double.NaN;
-        if (test(values, weights, begin, length, true)) {
+        if (MathArrays.verifyValues(values, weights, begin, length, true)) {
             product = 1.0;
             for (int i = begin; i < begin + length; i++) {
                 product *= FastMath.pow(values[i], weights[i]);
@@ -184,7 +184,8 @@ public class Product extends AbstractStorelessUnivariateStatistic implements Ser
      *     <li>the weights array contains negative values</li>
      * </ul></p>
      *
-     * <p>Uses the formula, <pre>
+     * <p>Uses the formula,
+     * <pre>
      *    weighted product = &prod;values[i]<sup>weights[i]</sup>
      * </pre>
      * that is, the weights are applied as exponents when computing the weighted product.</p>
@@ -196,12 +197,10 @@ public class Product extends AbstractStorelessUnivariateStatistic implements Ser
      * @since 2.1
      */
     @Override
-    public double evaluate(final double[] values, final double[] weights)
-    throws MathIllegalArgumentException {
+    public double evaluate(final double[] values, final double[] weights) throws MathIllegalArgumentException {
         return evaluate(values, weights, 0, values.length);
     }
 
-
     /**
      * {@inheritDoc}
      */
@@ -225,7 +224,6 @@ public class Product extends AbstractStorelessUnivariateStatistic implements Ser
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.n = source.n;
         dest.value = source.value;
     }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/summary/Sum.java b/src/main/java/org/apache/commons/math4/stat/descriptive/summary/Sum.java
index 523de97a9..bbe29fa8b 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/summary/Sum.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/summary/Sum.java
@@ -21,6 +21,7 @@ import java.io.Serializable;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 
@@ -35,12 +36,11 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class Sum extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -8231831954703408316L;
+    private static final long serialVersionUID = 20150412L;
 
     /** */
     private long n;
@@ -51,7 +51,7 @@ public class Sum extends AbstractStorelessUnivariateStatistic implements Seriali
     private double value;
 
     /**
-     * Create a Sum instance
+     * Create a Sum instance.
      */
     public Sum() {
         n = 0;
@@ -60,7 +60,7 @@ public class Sum extends AbstractStorelessUnivariateStatistic implements Seriali
 
     /**
      * Copy constructor, creates a new {@code Sum} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code Sum} instance to copy
      * @throws NullArgumentException if original is null
@@ -104,9 +104,8 @@ public class Sum extends AbstractStorelessUnivariateStatistic implements Seriali
     }
 
     /**
-     * The sum of the entries in the specified portion of
-     * the input array, or 0 if the designated subarray
-     * is empty.
+     * The sum of the entries in the specified portion of the input array,
+     * or 0 if the designated subarray is empty.
      * <p>
      * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>
      *
@@ -119,9 +118,10 @@ public class Sum extends AbstractStorelessUnivariateStatistic implements Seriali
      */
     @Override
     public double evaluate(final double[] values, final int begin, final int length)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
+
         double sum = Double.NaN;
-        if (test(values, begin, length, true)) {
+        if (MathArrays.verifyValues(values, begin, length, true)) {
             sum = 0.0;
             for (int i = begin; i < begin + length; i++) {
                 sum += values[i];
@@ -158,9 +158,9 @@ public class Sum extends AbstractStorelessUnivariateStatistic implements Seriali
      * @since 2.1
      */
     public double evaluate(final double[] values, final double[] weights,
-        final int begin, final int length) throws MathIllegalArgumentException {
+                           final int begin, final int length) throws MathIllegalArgumentException {
         double sum = Double.NaN;
-        if (test(values, weights, begin, length, true)) {
+        if (MathArrays.verifyValues(values, weights, begin, length, true)) {
             sum = 0.0;
             for (int i = begin; i < begin + length; i++) {
                 sum += values[i] * weights[i];
@@ -191,8 +191,7 @@ public class Sum extends AbstractStorelessUnivariateStatistic implements Seriali
      * @throws MathIllegalArgumentException if the parameters are not valid
      * @since 2.1
      */
-    public double evaluate(final double[] values, final double[] weights)
-    throws MathIllegalArgumentException {
+    public double evaluate(final double[] values, final double[] weights) throws MathIllegalArgumentException {
         return evaluate(values, weights, 0, values.length);
     }
 
@@ -219,7 +218,6 @@ public class Sum extends AbstractStorelessUnivariateStatistic implements Seriali
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.n = source.n;
         dest.value = source.value;
     }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/summary/SumOfLogs.java b/src/main/java/org/apache/commons/math4/stat/descriptive/summary/SumOfLogs.java
index 5a95de1e2..fcb00b9b8 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/summary/SumOfLogs.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/summary/SumOfLogs.java
@@ -22,6 +22,7 @@ import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
 import org.apache.commons.math4.util.FastMath;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
@@ -43,14 +44,13 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = -370076995648386763L;
+    private static final long serialVersionUID = 20150412L;
 
-    /**Number of values that have been added */
+    /** Number of values that have been added */
     private int n;
 
     /**
@@ -59,7 +59,7 @@ public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements S
     private double value;
 
     /**
-     * Create a SumOfLogs instance
+     * Create a SumOfLogs instance.
      */
     public SumOfLogs() {
        value = 0d;
@@ -68,7 +68,7 @@ public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements S
 
     /**
      * Copy constructor, creates a new {@code SumOfLogs} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code SumOfLogs} instance to copy
      * @throws NullArgumentException if original is null
@@ -130,9 +130,10 @@ public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements S
      */
     @Override
     public double evaluate(final double[] values, final int begin, final int length)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
+
         double sumLog = Double.NaN;
-        if (test(values, begin, length, true)) {
+        if (MathArrays.verifyValues(values, begin, length, true)) {
             sumLog = 0.0;
             for (int i = begin; i < begin + length; i++) {
                 sumLog += FastMath.log(values[i]);
@@ -164,7 +165,6 @@ public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements S
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.n = source.n;
         dest.value = source.value;
     }
diff --git a/src/main/java/org/apache/commons/math4/stat/descriptive/summary/SumOfSquares.java b/src/main/java/org/apache/commons/math4/stat/descriptive/summary/SumOfSquares.java
index d55c89005..d37e35ba7 100644
--- a/src/main/java/org/apache/commons/math4/stat/descriptive/summary/SumOfSquares.java
+++ b/src/main/java/org/apache/commons/math4/stat/descriptive/summary/SumOfSquares.java
@@ -21,6 +21,7 @@ import java.io.Serializable;
 import org.apache.commons.math4.exception.MathIllegalArgumentException;
 import org.apache.commons.math4.exception.NullArgumentException;
 import org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic;
+import org.apache.commons.math4.util.MathArrays;
 import org.apache.commons.math4.util.MathUtils;
 
 /**
@@ -34,14 +35,13 @@ import org.apache.commons.math4.util.MathUtils;
  * multiple threads access an instance of this class concurrently, and at least
  * one of the threads invokes the <code>increment()</code> or
  * <code>clear()</code> method, it must be synchronized externally.</p>
- *
  */
 public class SumOfSquares extends AbstractStorelessUnivariateStatistic implements Serializable {
 
     /** Serializable version identifier */
-    private static final long serialVersionUID = 1460986908574398008L;
+    private static final long serialVersionUID = 20150412L;
 
-    /** */
+    /** Number of values that have been added */
     private long n;
 
     /**
@@ -50,7 +50,7 @@ public class SumOfSquares extends AbstractStorelessUnivariateStatistic implement
     private double value;
 
     /**
-     * Create a SumOfSquares instance
+     * Create a SumOfSquares instance.
      */
     public SumOfSquares() {
         n = 0;
@@ -59,7 +59,7 @@ public class SumOfSquares extends AbstractStorelessUnivariateStatistic implement
 
     /**
      * Copy constructor, creates a new {@code SumOfSquares} identical
-     * to the {@code original}
+     * to the {@code original}.
      *
      * @param original the {@code SumOfSquares} instance to copy
      * @throws NullArgumentException if original is null
@@ -118,9 +118,10 @@ public class SumOfSquares extends AbstractStorelessUnivariateStatistic implement
      */
     @Override
     public double evaluate(final double[] values,final int begin, final int length)
-    throws MathIllegalArgumentException {
+        throws MathIllegalArgumentException {
+
         double sumSq = Double.NaN;
-        if (test(values, begin, length, true)) {
+        if (MathArrays.verifyValues(values, begin, length, true)) {
             sumSq = 0.0;
             for (int i = begin; i < begin + length; i++) {
                 sumSq += values[i] * values[i];
@@ -152,7 +153,6 @@ public class SumOfSquares extends AbstractStorelessUnivariateStatistic implement
         throws NullArgumentException {
         MathUtils.checkNotNull(source);
         MathUtils.checkNotNull(dest);
-        dest.setData(source.getDataRef());
         dest.n = source.n;
         dest.value = source.value;
     }
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/AbstractUnivariateStatisticTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/AbstractUnivariateStatisticTest.java
deleted file mode 100644
index b455f5b7b..000000000
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/AbstractUnivariateStatisticTest.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.math4.stat.descriptive;
-
-
-import org.apache.commons.math4.exception.MathIllegalArgumentException;
-import org.apache.commons.math4.exception.NullArgumentException;
-import org.apache.commons.math4.stat.descriptive.moment.Mean;
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- * Tests for AbstractUnivariateStatistic
- *
- */
-public class AbstractUnivariateStatisticTest {
-
-    protected double[] testArray = {0, 1, 2, 3, 4, 5};
-    protected double[] testWeightsArray = {0.3, 0.2, 1.3, 1.1, 1.0, 1.8};
-    protected double[] testNegativeWeightsArray = {-0.3, 0.2, -1.3, 1.1, 1.0, 1.8};
-    protected double[] nullArray = null;
-    protected double[] singletonArray = {0};
-    protected Mean testStatistic = new Mean();
-
-    @Test
-    public void testTestPositive() {
-        for (int j = 0; j < 6; j++) {
-            for (int i = 1; i < (7 - j); i++) {
-                Assert.assertTrue(testStatistic.test(testArray, 0, i));
-            }
-        }
-        Assert.assertTrue(testStatistic.test(singletonArray, 0, 1));
-        Assert.assertTrue(testStatistic.test(singletonArray, 0, 0, true));
-    }
-
-    @Test
-    public void testTestNegative() {
-        Assert.assertFalse(testStatistic.test(singletonArray, 0, 0));
-        Assert.assertFalse(testStatistic.test(testArray, 0, 0));
-        try {
-            testStatistic.test(singletonArray, 2, 1);  // start past end
-            Assert.fail("Expecting MathIllegalArgumentException");
-        } catch (MathIllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            testStatistic.test(testArray, 0, 7);  // end past end
-            Assert.fail("Expecting MathIllegalArgumentException");
-        } catch (MathIllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            testStatistic.test(testArray, -1, 1);  // start negative
-            Assert.fail("Expecting MathIllegalArgumentException");
-        } catch (MathIllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            testStatistic.test(testArray, 0, -1);  // length negative
-            Assert.fail("Expecting MathIllegalArgumentException");
-        } catch (MathIllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            testStatistic.test(nullArray, 0, 1);  // null array
-            Assert.fail("Expecting NullArgumentException");
-        } catch (NullArgumentException ex) {
-            // expected
-        }
-        try {
-            testStatistic.test(testArray, nullArray, 0, 1);  // null weights array
-            Assert.fail("Expecting NullArgumentException");
-        } catch (NullArgumentException ex) {
-            // expected
-        }
-        try {
-            testStatistic.test(singletonArray, testWeightsArray, 0, 1);  // weights.length != value.length
-            Assert.fail("Expecting MathIllegalArgumentException");
-        } catch (MathIllegalArgumentException ex) {
-            // expected
-        }
-        try {
-            testStatistic.test(testArray, testNegativeWeightsArray, 0, 6);  // can't have negative weights
-            Assert.fail("Expecting MathIllegalArgumentException");
-        } catch (MathIllegalArgumentException ex) {
-            // expected
-        }
-    }
-}
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/DescriptiveStatisticsTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/DescriptiveStatisticsTest.java
index 5afedd573..5f25f8865 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/DescriptiveStatisticsTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/DescriptiveStatisticsTest.java
@@ -226,7 +226,7 @@ public class DescriptiveStatisticsTest {
         checkremoval(dstat, DescriptiveStatistics.INFINITE_WINDOW, 3.5, 2.5, 3.0);
 
     }
-    
+
     @Test
     public void testSummaryConsistency() {
         final DescriptiveStatistics dstats = new DescriptiveStatistics();
@@ -316,13 +316,16 @@ public class DescriptiveStatisticsTest {
      */
     static class deepMean implements UnivariateStatistic {
 
+        @Override
         public double evaluate(double[] values, int begin, int length) {
             return 42;
         }
 
+        @Override
         public double evaluate(double[] values) {
             return 42;
         }
+        @Override
         public UnivariateStatistic copy() {
             return new deepMean();
         }
@@ -332,16 +335,19 @@ public class DescriptiveStatisticsTest {
      * Test percentile implementation - wraps a Percentile
      */
     static class goodPercentile implements UnivariateStatistic {
-        private Percentile percentile = new Percentile();
+        private final Percentile percentile = new Percentile();
         public void setQuantile(double quantile) {
             percentile.setQuantile(quantile);
         }
+        @Override
         public double evaluate(double[] values, int begin, int length) {
             return percentile.evaluate(values, begin, length);
         }
+        @Override
         public double evaluate(double[] values) {
             return percentile.evaluate(values);
         }
+        @Override
         public UnivariateStatistic copy() {
             goodPercentile result = new goodPercentile();
             result.setQuantile(percentile.getQuantile());
@@ -374,13 +380,16 @@ public class DescriptiveStatisticsTest {
      * "Bad" test percentile implementation - no setQuantile
      */
     static class badPercentile implements UnivariateStatistic {
-        private Percentile percentile = new Percentile();
+        private final Percentile percentile = new Percentile();
+        @Override
         public double evaluate(double[] values, int begin, int length) {
             return percentile.evaluate(values, begin, length);
         }
+        @Override
         public double evaluate(double[] values) {
             return percentile.evaluate(values);
         }
+        @Override
         public UnivariateStatistic copy() {
             return new badPercentile();
         }
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/MixedListUnivariateImplTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/MixedListUnivariateImplTest.java
index 8e6906463..410a2e1b8 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/MixedListUnivariateImplTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/MixedListUnivariateImplTest.java
@@ -29,23 +29,21 @@ import org.junit.Test;
 
 /**
  * Test cases for the {@link ListUnivariateImpl} class.
- *
  */
-
 public final class MixedListUnivariateImplTest {
-    private double one = 1;
-    private float two = 2;
-    private int three = 3;
-
-    private double mean = 2;
-    private double sumSq = 18;
-    private double sum = 8;
-    private double var = 0.666666666666666666667;
-    private double std = FastMath.sqrt(var);
-    private double n = 4;
-    private double min = 1;
-    private double max = 3;
-    private double tolerance = 10E-15;
+    private final double one = 1;
+    private final float two = 2;
+    private final int three = 3;
+
+    private final double mean = 2;
+    private final double sumSq = 18;
+    private final double sum = 8;
+    private final double var = 0.666666666666666666667;
+    private final double std = FastMath.sqrt(var);
+    private final double n = 4;
+    private final double min = 1;
+    private final double max = 3;
+    private final double tolerance = 10E-15;
 
     private TransformerMap transformers = new TransformerMap();
 
@@ -184,6 +182,7 @@ public final class MixedListUnivariateImplTest {
 
     public static final class FooTransformer implements NumberTransformer, Serializable {
         private static final long serialVersionUID = -4252248129291326127L;
+        @Override
         public double transform(Object o) {
             return Double.parseDouble(((Foo) o).heresFoo());
         }
@@ -197,6 +196,7 @@ public final class MixedListUnivariateImplTest {
 
     public static final class BarTransformer implements NumberTransformer, Serializable {
         private static final long serialVersionUID = -1768345377764262043L;
+        @Override
         public double transform(Object o) {
             return Double.parseDouble(((Bar) o).heresBar());
         }
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/MultivariateSummaryStatisticsTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/MultivariateSummaryStatisticsTest.java
index 398242874..c9d8c37bb 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/MultivariateSummaryStatisticsTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/MultivariateSummaryStatisticsTest.java
@@ -142,30 +142,39 @@ public class MultivariateSummaryStatisticsTest {
     static class sumMean implements StorelessUnivariateStatistic {
         private double sum = 0;
         private long n = 0;
+        @Override
         public double evaluate(double[] values, int begin, int length) {
             return 0;
         }
+        @Override
         public double evaluate(double[] values) {
             return 0;
         }
+        @Override
         public void clear() {
           sum = 0;
           n = 0;
         }
+        @Override
         public long getN() {
             return n;
         }
+        @Override
         public double getResult() {
             return sum;
         }
+        @Override
         public void increment(double d) {
             sum += d;
             n++;
         }
+        @Override
         public void incrementAll(double[] values, int start, int length) {
         }
+        @Override
         public void incrementAll(double[] values) {
         }
+        @Override
         public StorelessUnivariateStatistic copy() {
             return new sumMean();
         }
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java
index 8ac326908..bcbceae37 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java
@@ -76,7 +76,7 @@ public abstract class StorelessUnivariateStatisticAbstractTest
     protected void checkClearValue(StorelessUnivariateStatistic statistic){
         Assert.assertTrue(Double.isNaN(statistic.getResult()));
     }
-    
+
     @Test
     public void testSerialization() {
 
@@ -182,7 +182,6 @@ public abstract class StorelessUnivariateStatisticAbstractTest
     /**
      * Verifies that copied statistics remain equal to originals when
      * incremented the same way.
-     *
      */
     @Test
     public void testCopyConsistency() {
@@ -218,4 +217,24 @@ public abstract class StorelessUnivariateStatisticAbstractTest
             (StorelessUnivariateStatistic) getUnivariateStatistic();
         Assert.assertEquals(s, TestUtils.serializeAndRecover(s));
     }
+
+    /**
+     * Make sure that evaluate(double[]) does not alter the internal state.
+     */
+    @Test
+    public void testEvaluateInternalState() {
+        StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();
+        stat.evaluate(testArray);
+        Assert.assertEquals(0, stat.getN());
+
+        stat.incrementAll(testArray);
+
+        StorelessUnivariateStatistic savedStatistic = stat.copy();
+
+        Assert.assertNotEquals(stat.getResult(), stat.evaluate(testArray, 0, 5), getTolerance());
+
+        Assert.assertEquals(savedStatistic.getResult(), stat.getResult(), 0.0);
+        Assert.assertEquals(savedStatistic.getN(), stat.getN());
+    }
+
 }
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/UnivariateStatisticAbstractTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/UnivariateStatisticAbstractTest.java
index bca7dc8f4..6f12b1e18 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/UnivariateStatisticAbstractTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/UnivariateStatisticAbstractTest.java
@@ -96,12 +96,9 @@ public abstract class UnivariateStatisticAbstractTest {
 
     @Test
     public void testEvaluation() {
-        Assert.assertEquals(
-            expectedValue(),
-            getUnivariateStatistic().evaluate(testArray),
-            getTolerance());
+        Assert.assertEquals(expectedValue(), getUnivariateStatistic().evaluate(testArray), getTolerance());
     }
-    
+
     @Test
     public void testEvaluateArraySegment() {
         final UnivariateStatistic stat = getUnivariateStatistic();
@@ -115,7 +112,7 @@ public abstract class UnivariateStatisticAbstractTest {
         System.arraycopy(testArray, testArray.length - 5, arrayEnd, 0, 5);
         Assert.assertEquals(stat.evaluate(arrayEnd), stat.evaluate(testArray, testArray.length - 5, 5), 0);
     }
-    
+
     @Test
     public void testEvaluateArraySegmentWeighted() {
         // See if this statistic computes weighted statistics
@@ -149,10 +146,7 @@ public abstract class UnivariateStatisticAbstractTest {
     public void testCopy() {
         UnivariateStatistic original = getUnivariateStatistic();
         UnivariateStatistic copy = original.copy();
-        Assert.assertEquals(
-                expectedValue(),
-                copy.evaluate(testArray),
-                getTolerance());
+        Assert.assertEquals(expectedValue(), copy.evaluate(testArray), getTolerance());
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/moment/KurtosisTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/moment/KurtosisTest.java
index eb34f864b..288aa65e4 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/moment/KurtosisTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/moment/KurtosisTest.java
@@ -47,7 +47,6 @@ public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{
 
     /**
      * Make sure Double.NaN is returned iff n < 4
-     *
      */
     @Test
     public void testNaN() {
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/moment/SkewnessTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/moment/SkewnessTest.java
index 099607fa8..5911c01bc 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/moment/SkewnessTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/moment/SkewnessTest.java
@@ -48,7 +48,6 @@ public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{
 
     /**
      * Make sure Double.NaN is returned iff n < 3
-     *
      */
     @Test
     public void testNaN() {
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/moment/StandardDeviationTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/moment/StandardDeviationTest.java
index f695fc6fb..b29138f4b 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/moment/StandardDeviationTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/moment/StandardDeviationTest.java
@@ -69,7 +69,7 @@ public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractT
         double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};
         double sigma = populationStandardDeviation(values);
         SecondMoment m = new SecondMoment();
-        m.evaluate(values);  // side effect is to add values
+        m.incrementAll(values);  // side effect is to add values
         StandardDeviation s1 = new StandardDeviation();
         s1.setBiasCorrected(false);
         Assert.assertEquals(sigma, s1.evaluate(values), 1E-14);
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/moment/VarianceTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/moment/VarianceTest.java
index c683f836c..fc5644c9c 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/moment/VarianceTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/moment/VarianceTest.java
@@ -74,7 +74,7 @@ public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{
     public void testPopulation() {
         double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};
         SecondMoment m = new SecondMoment();
-        m.evaluate(values);  // side effect is to add values
+        m.incrementAll(values);  // side effect is to add values
         Variance v1 = new Variance();
         v1.setBiasCorrected(false);
         Assert.assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MaxTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MaxTest.java
index da807922d..57363d540 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MaxTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MaxTest.java
@@ -47,8 +47,7 @@ public class MaxTest extends StorelessUnivariateStatisticAbstractTest {
 
     @Test
     public void testSpecialValues() {
-        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY,
-                Double.POSITIVE_INFINITY};
+        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY};
         Max max = new Max();
         Assert.assertTrue(Double.isNaN(max.getResult()));
         max.increment(testArray[0]);
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MedianTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MedianTest.java
index c4bd11430..6144b58f6 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MedianTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MedianTest.java
@@ -82,26 +82,21 @@ public class MedianTest extends UnivariateStatisticAbstractTest{
         for (EstimationType e : EstimationType.values()) {
             UnivariateStatistic percentile = getTestMedian(e);
             Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0);
-            Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1),
-                    0);
-            Assert.assertEquals(1d,
-                    new Median().evaluate(singletonArray, 0, 1, 5), 0);
-            Assert.assertEquals(1d,
-                    new Median().evaluate(singletonArray, 0, 1, 100), 0);
-            Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray,
-                    0, 0)));
+            Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);
+            Assert.assertEquals(1d, new Median().evaluate(singletonArray, 0, 1, 5), 0);
+            Assert.assertEquals(1d, new Median().evaluate(singletonArray, 0, 1, 100), 0);
+            Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));
         }
     }
+
     @Test
     public void testAllTechniquesMedian() {
         double[] d = new double[] { 1, 3, 2, 4 };
         testAssertMappedValues(d, new Object[][] { { LEGACY, 2.5d },
             { R_1, 2d }, { R_2, 2.5d }, { R_3, 2d }, { R_4, 2d }, { R_5, 2.5 },
             { R_6, 2.5 },{ R_7, 2.5 },{ R_8, 2.5 }, { R_9 , 2.5 } },  1.0e-05);
-
     }
 
-
     /**
      * Simple test assertion utility method
      *
@@ -109,8 +104,7 @@ public class MedianTest extends UnivariateStatisticAbstractTest{
      * @param map of expected result against a {@link EstimationType}
      * @param tolerance the tolerance of difference allowed
      */
-    protected void testAssertMappedValues(double[] d, Object[][] map,
-            Double tolerance) {
+    protected void testAssertMappedValues(double[] d, Object[][] map, Double tolerance) {
         for (Object[] o : map) {
             EstimationType e = (EstimationType) o[0];
             double expected = (Double) o[1];
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MinTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MinTest.java
index 296248a5b..7ce8ee39e 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MinTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/rank/MinTest.java
@@ -47,8 +47,7 @@ public class MinTest extends StorelessUnivariateStatisticAbstractTest{
 
     @Test
     public void testSpecialValues() {
-        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY,
-                Double.NEGATIVE_INFINITY};
+        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};
         Min min = new Min();
         Assert.assertTrue(Double.isNaN(min.getResult()));
         min.increment(testArray[0]);
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/rank/PSquarePercentileTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/rank/PSquarePercentileTest.java
index 8751b00b9..dfdcd4ece 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/rank/PSquarePercentileTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/rank/PSquarePercentileTest.java
@@ -44,7 +44,7 @@ import org.junit.Test;
 
 /**
  * Test cases for the {@link PSquarePercentile} class which naturally extends
- * {@link StorelessUnivariateStatisticAbstractTest}. 
+ * {@link StorelessUnivariateStatisticAbstractTest}.
  */
 public class PSquarePercentileTest extends
         StorelessUnivariateStatisticAbstractTest {
@@ -52,7 +52,7 @@ public class PSquarePercentileTest extends
     protected double percentile5 = 8.2299d;
     protected double percentile95 = 16.72195;// 20.82d; this is approximation
     protected double tolerance = 10E-12;
-    
+
     private final RandomGenerator randomGenerator = new Well19937c(1000);
 
     @Override
@@ -330,7 +330,7 @@ public class PSquarePercentileTest extends
         Assert.assertTrue(Double.isNaN(new PSquarePercentile(100).getResult()));
 
         double[] d = new double[] { 1, 3, 2, 4, 9, 10, 11 };
-        ptile.evaluate(d);
+        ptile.incrementAll(d);
         Assert.assertEquals(ptile, ptile);
         Assert.assertEquals(1d, ptile.getResult(), 1e-02);// this calls min
     }
@@ -343,8 +343,7 @@ public class PSquarePercentileTest extends
         ptile.increment(2);
         ptile.increment(3);
         Assert.assertNotNull(ptile.toString());
-        Assert.assertEquals(expectedValue(), ptile.evaluate(testArray),
-                getTolerance());
+        Assert.assertEquals(expectedValue(), ptile.evaluate(testArray), getTolerance());
         Assert.assertNotNull(ptile.toString());
     }
 
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/summary/ProductTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/summary/ProductTest.java
index 8bd238cc4..bc65e122c 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/summary/ProductTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/summary/ProductTest.java
@@ -54,7 +54,7 @@ public class ProductTest extends StorelessUnivariateStatisticAbstractTest{
         return this.product;
     }
 
-    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */
+    /** Expected value for  the testArray defined in UnivariateStatisticAbstractTest */
     public double expectedWeightedValue() {
         return this.weightedProduct;
     }
@@ -78,14 +78,15 @@ public class ProductTest extends StorelessUnivariateStatisticAbstractTest{
     @Test
     public void testWeightedProduct() {
         Product product = new Product();
-        Assert.assertEquals(expectedWeightedValue(), product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance());
-        Assert.assertEquals(expectedValue(), product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());
+        Assert.assertEquals(expectedWeightedValue(),
+                            product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance());
+        Assert.assertEquals(expectedValue(),
+                            product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());
     }
-    
+
     @Override
     protected void checkClearValue(StorelessUnivariateStatistic statistic){
         Assert.assertEquals(1, statistic.getResult(), 0);
     }
 
-
 }
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumLogTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumLogTest.java
index d7f6495eb..1696dff01 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumLogTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumLogTest.java
@@ -76,11 +76,10 @@ public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{
         sum.increment(-2d);
         Assert.assertTrue(Double.isNaN(sum.getResult()));
     }
-    
+
     @Override
-    protected void checkClearValue(StorelessUnivariateStatistic statistic){
+    protected void checkClearValue(StorelessUnivariateStatistic statistic) {
         Assert.assertEquals(0, statistic.getResult(), 0);
     }
-    
 
 }
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumSqTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumSqTest.java
index 0b722edda..1f278c666 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumSqTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumSqTest.java
@@ -25,7 +25,6 @@ import org.junit.Test;
 
 /**
  * Test cases for the {@link SumOfSquares} class.
- *
  */
 public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{
 
@@ -62,11 +61,10 @@ public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{
         sumSq.increment(1);
         Assert.assertTrue(Double.isNaN(sumSq.getResult()));
     }
-    
+
     @Override
-    protected void checkClearValue(StorelessUnivariateStatistic statistic){
+    protected void checkClearValue(StorelessUnivariateStatistic statistic) {
         Assert.assertEquals(0, statistic.getResult(), 0);
     }
 
-
 }
diff --git a/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumTest.java b/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumTest.java
index fa726456a..88e509d37 100644
--- a/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumTest.java
+++ b/src/test/java/org/apache/commons/math4/stat/descriptive/summary/SumTest.java
@@ -68,14 +68,15 @@ public class SumTest extends StorelessUnivariateStatisticAbstractTest{
     @Test
     public void testWeightedSum() {
         Sum sum = new Sum();
-        Assert.assertEquals(expectedWeightedValue(), sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());
-        Assert.assertEquals(expectedValue(), sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());
+        Assert.assertEquals(expectedWeightedValue(),
+                            sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());
+        Assert.assertEquals(expectedValue(),
+                            sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());
     }
-    
+
     @Override
-    protected void checkClearValue(StorelessUnivariateStatistic statistic){
+    protected void checkClearValue(StorelessUnivariateStatistic statistic) {
         Assert.assertEquals(0, statistic.getResult(), 0);
     }
 
-
 }
