diff --git a/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java
index 15a84819b..7a6597b98 100644
--- a/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java
+++ b/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java
@@ -68,6 +68,11 @@ class SimplexTableau implements Serializable {
     /** Serializable version identifier. */
     private static final long serialVersionUID = -1369660067587938365L;
 
+    /** bit mask for IEEE double exponent **/
+    private static final long EXPN = 0x7ff0000000000000L;
+    /** bit mask for IEEE double mantissa and sign **/
+    private static final long FRAC = 0x800fffffffffffffL;
+
     /** Linear objective function. */
     private final LinearObjectiveFunction f;
 
@@ -104,6 +109,9 @@ class SimplexTableau implements Serializable {
     /** Maps rows to their corresponding basic variables. */
     private int[] basicRows;
 
+    /** changes in floating point exponent to standardize the input */
+    private int[] variableExpChange;
+
     /**
      * Builds a tableau for a linear problem.
      *
@@ -219,13 +227,30 @@ class SimplexTableau implements Serializable {
 
         int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
         matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
+
+        double[][] standardized = new double[constraints.size() + 1][];
+
         RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
-        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);
-        matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());
+        standardized[0] = objectiveCoefficients.toArray();
+        double[] standardRhs = new double[constraints.size() + 1];
+        double value = maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
+        standardRhs[0] = value;
+
+        for (int i = 0; i < constraints.size(); i++) {
+            LinearConstraint constraint = constraints.get(i);
+            standardized[i + 1] = constraint.getCoefficients().toArray();
+            standardRhs[i + 1] = constraint.getValue();
+        }
+        variableExpChange = new int[standardized[0].length];
+
+        standardize(standardized, standardRhs);
+
+        copyArray(standardized[0], matrix.getDataRef()[zIndex]);
+        matrix.setEntry(zIndex, width - 1, standardRhs[0]);
 
         if (!restrictToNonNegative) {
             matrix.setEntry(zIndex, getSlackVariableOffset() - 1,
-                            getInvertedCoefficientSum(objectiveCoefficients));
+                            getInvertedCoefficientSum(standardized[0]));
         }
 
         // initialize the constraint rows
@@ -236,16 +261,16 @@ class SimplexTableau implements Serializable {
             int row = getNumObjectiveFunctions() + i;
 
             // decision variable coefficients
-            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);
+            copyArray(standardized[i+1], matrix.getDataRef()[row]);
 
             // x-
             if (!restrictToNonNegative) {
                 matrix.setEntry(row, getSlackVariableOffset() - 1,
-                                getInvertedCoefficientSum(constraint.getCoefficients()));
+                                getInvertedCoefficientSum(standardized[i+1]));
             }
 
             // RHS
-            matrix.setEntry(row, width - 1, constraint.getValue());
+            matrix.setEntry(row, width - 1, standardRhs[i+1]);
 
             // slack variables
             if (constraint.getRelationship() == Relationship.LEQ) {
@@ -266,6 +291,113 @@ class SimplexTableau implements Serializable {
         return matrix;
     }
 
+    /** We standardize the constants in the equations and objective, which means we try
+     * to get the IEEE double exponent as close to zero (1023) as possible, which makes the
+     * constants closer to 1.
+     * We use exponent shifts instead of division because that introduces no bit errors.
+     *
+     * @param standardized coefficients before standardization
+     * @param standardRhs right hand side before standardization
+     */
+    private void standardize(double[][] standardized, double[] standardRhs)
+    {
+        /*
+            first transform across:
+            c0 x0 + c1 x1 + ... + cn xn = vn ==> (2^expChange) * (c0 x0 + c1 x1 + ... + cn xn = vn)
+
+            expChange will be negative if the constants are larger than 1,
+            it'll be positive if the constants are less than 1.
+        */
+        for(int i = 0; i < standardized.length; i++) {
+            int minExp = 10000;
+            int maxExp = -1;
+            for(double d: standardized[i]) {
+                if (d != 0) {
+                    int e = exponent(d);
+                    if (e < minExp) {
+                        minExp = e;
+                    }
+                    if (e > maxExp) {
+                        maxExp = e;
+                    }
+                }
+            }
+            if (standardRhs[i] != 0) {
+                int e = exponent(standardRhs[i]);
+                if (e < minExp) {
+                    minExp = e;
+                }
+                if (e > maxExp) {
+                    maxExp = e;
+                }
+            }
+            int expChange = 0;
+            if (minExp < 10000 && minExp > 1023 ) {
+                expChange = 1023 - minExp;
+            }
+            else if (maxExp > -1 && maxExp < 1023) {
+                expChange = 1023 - maxExp;
+            }
+            if (expChange != 0) {
+                standardRhs[i] = updateExponent(standardRhs[i], expChange);
+                updateExponent(standardized[i], expChange);
+            }
+        }
+
+        /*
+            second, transform down the columns. this is like defining a new variable for that column
+            that is yi = xi * (2^expChange)
+            After solving for yi, we compute xi by shifting again. See getSolution()
+         */
+        for(int i = 0; i < variableExpChange.length; i++) {
+            int minExp = 10000;
+            int maxExp = -1;
+
+            for(double[] coefficients: standardized) {
+                double d = coefficients[i];
+                if (d != 0) {
+                    int e = exponent(d);
+                    if (e < minExp) {
+                        minExp = e;
+                    }
+                    if (e > maxExp) {
+                        maxExp = e;
+                    }
+                }
+            }
+            int expChange = 0;
+            if (minExp < 10000 && minExp > 1023 ) {
+                expChange = 1023 - minExp;
+            }
+            else if (maxExp > -1 && maxExp < 1023) {
+                expChange = 1023 - maxExp;
+            }
+            variableExpChange[i] = expChange;
+            if (expChange != 0) {
+                for(double[] coefficients: standardized) {
+                     coefficients[i] = updateExponent(coefficients[i], expChange);
+                }
+            }
+        }
+    }
+
+    private static void updateExponent(double[] dar, int exp) {
+        for(int i = 0; i < dar.length; i++) {
+            dar[i] = updateExponent(dar[i], exp);
+        }
+    }
+
+    private static int exponent(double d) {
+        long bits = Double.doubleToLongBits(d);
+        return (int) ((bits & EXPN) >>> 52);
+    }
+
+    private static double updateExponent(double d, int exp) {
+        if (d == 0 || exp == 0) return d;
+        long bits = Double.doubleToLongBits(d);
+        return Double.longBitsToDouble((bits & FRAC) | ((((bits & EXPN) >>> 52) + exp) << 52));
+    }
+
     /**
      * Get new versions of the constraints which have positive right hand sides.
      * @param originalConstraints original (not normalized) constraints
@@ -323,8 +455,12 @@ class SimplexTableau implements Serializable {
      * @return the -1 times the sum of all coefficients in the given array.
      */
     protected static double getInvertedCoefficientSum(final RealVector coefficients) {
+        return getInvertedCoefficientSum(coefficients.toArray());
+    }
+
+    protected static double getInvertedCoefficientSum(final double[] arr) {
         double sum = 0;
-        for (double coefficient : coefficients.toArray()) {
+        for (double coefficient : arr) {
             sum -= coefficient;
         }
         return sum;
@@ -493,6 +629,7 @@ class SimplexTableau implements Serializable {
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             }
+            coefficients[i] = updateExponent(coefficients[i], variableExpChange[i]);
         }
         return new PointValuePair(coefficients, f.value(coefficients));
     }
diff --git a/src/test/java/org/apache/commons/math4/optim/linear/SimplexSolverTest.java b/src/test/java/org/apache/commons/math4/optim/linear/SimplexSolverTest.java
index 7e46583c9..eb15c9166 100644
--- a/src/test/java/org/apache/commons/math4/optim/linear/SimplexSolverTest.java
+++ b/src/test/java/org/apache/commons/math4/optim/linear/SimplexSolverTest.java
@@ -20,7 +20,6 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import org.junit.Test;
-import org.junit.Ignore;
 import org.junit.Assert;
 
 import org.apache.commons.numbers.core.Precision;
@@ -28,16 +27,6 @@ import org.apache.commons.math4.exception.DimensionMismatchException;
 import org.apache.commons.math4.exception.TooManyIterationsException;
 import org.apache.commons.math4.optim.MaxIter;
 import org.apache.commons.math4.optim.PointValuePair;
-import org.apache.commons.math4.optim.linear.LinearConstraint;
-import org.apache.commons.math4.optim.linear.LinearConstraintSet;
-import org.apache.commons.math4.optim.linear.LinearObjectiveFunction;
-import org.apache.commons.math4.optim.linear.NoFeasibleSolutionException;
-import org.apache.commons.math4.optim.linear.NonNegativeConstraint;
-import org.apache.commons.math4.optim.linear.PivotSelectionRule;
-import org.apache.commons.math4.optim.linear.Relationship;
-import org.apache.commons.math4.optim.linear.SimplexSolver;
-import org.apache.commons.math4.optim.linear.SolutionCallback;
-import org.apache.commons.math4.optim.linear.UnboundedSolutionException;
 import org.apache.commons.math4.optim.nonlinear.scalar.GoalType;
 
 public class SimplexSolverTest {
@@ -820,25 +809,15 @@ public class SimplexSolverTest {
                         PivotSelectionRule.BLAND);
     }
 
-    /* XXX Skipped until issue is solved: https://issues.apache.org/jira/browse/MATH-1549 */
-    @Ignore@Test
+    /* linear transformation of constants should produce the same result */
+    @Test
     public void testMath1549() {
         final double m = 10;
-        double scale = 1;
-        int numFailures = 0;
-        for (int pow = 0; pow < 13; pow++) {
-            try {
-                tryMath1549(scale);
-            } catch (RuntimeException e) {
-                e.printStackTrace();
-                ++numFailures;
-            }
+        double scale = 1e-12;
+        for (int pow = 0; pow < 26; pow++) {
+            tryMath1549(scale);
             scale *= m;
         }
-
-        if (numFailures > 0) {
-            Assert.fail(numFailures + " failures");
-        }
     }
 
     /* See JIRA issue: MATH-1549 */
@@ -857,7 +836,7 @@ public class SimplexSolverTest {
         final LinearConstraintSet constraintSet = new LinearConstraintSet(constraints);
         final PointValuePair solution = solver.optimize(f, constraintSet, GoalType.MINIMIZE, nnegconstr);
 
-        System.out.println("scale=" + scale + ": sol=" + java.util.Arrays.toString(solution.getPoint()));
+        Assert.assertEquals(2.0, solution.getPoint()[0], eps);
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/math4/optim/linear/SimplexTableauTest.java b/src/test/java/org/apache/commons/math4/optim/linear/SimplexTableauTest.java
index be774c4cc..1141ae6bd 100644
--- a/src/test/java/org/apache/commons/math4/optim/linear/SimplexTableauTest.java
+++ b/src/test/java/org/apache/commons/math4/optim/linear/SimplexTableauTest.java
@@ -20,10 +20,6 @@ import java.util.ArrayList;
 import java.util.Collection;
 
 import org.apache.commons.math4.TestUtils;
-import org.apache.commons.math4.optim.linear.LinearConstraint;
-import org.apache.commons.math4.optim.linear.LinearObjectiveFunction;
-import org.apache.commons.math4.optim.linear.Relationship;
-import org.apache.commons.math4.optim.linear.SimplexTableau;
 import org.apache.commons.math4.optim.nonlinear.scalar.GoalType;
 import org.junit.Assert;
 import org.junit.Test;
@@ -38,7 +34,7 @@ public class SimplexTableauTest {
             new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);
         double[][] expectedInitialTableau = {
                                              {-1, 0,  -1,  -1,  2, 0, 0, 0, -4},
-                                             { 0, 1, -15, -10, 25, 0, 0, 0,  0},
+                                             { 0, 1, -1.875, -1.25, 3.125, 0, 0, 0,  0},
                                              { 0, 0,   1,   0, -1, 1, 0, 0,  2},
                                              { 0, 0,   0,   1, -1, 0, 1, 0,  3},
                                              { 0, 0,   1,   1, -2, 0, 0, 1,  4}
@@ -53,7 +49,7 @@ public class SimplexTableauTest {
         SimplexTableau tableau =
             new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);
         double[][] expectedTableau = {
-                                      { 1, -15, -10, 0, 0, 0, 0},
+                                      { 1, -1.875, -1.25, 0, 0, 0, 0},
                                       { 0,   1,   0, 1, 0, 0, 2},
                                       { 0,   0,   1, 0, 1, 0, 3},
                                       { 0,   1,   1, 0, 0, 1, 4}
@@ -72,7 +68,7 @@ public class SimplexTableauTest {
         SimplexTableau tableau =
             new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);
         double[][] initialTableau = {
-                                     {1, -15, -10, 25, 0, 0, 0, 0},
+                                     {1, -1.875, -1.25, 3.125, 0, 0, 0, 0},
                                      {0,   1,   0, -1, 1, 0, 0, 2},
                                      {0,   0,   1, -1, 0, 1, 0, 3},
                                      {0,   1,   1, -2, 0, 0, 1, 4}
