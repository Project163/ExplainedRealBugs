diff --git a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java
index 28e50d91a..85a7b4945 100644
--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java
@@ -21,11 +21,12 @@ import java.io.Serializable;
 import org.apache.commons.math.ConvergenceException;
 import org.apache.commons.math.FunctionEvaluationException;
 import org.apache.commons.math.MathException;
-import org.apache.commons.math.MathRuntimeException;
 import org.apache.commons.math.analysis.UnivariateRealFunction;
 import org.apache.commons.math.analysis.solvers.BrentSolver;
 import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;
 import org.apache.commons.math.exception.util.LocalizedFormats;
+import org.apache.commons.math.exception.OutOfRangeException;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.random.RandomDataImpl;
 import org.apache.commons.math.util.FastMath;
 
@@ -39,57 +40,42 @@ import org.apache.commons.math.util.FastMath;
 public abstract class AbstractContinuousDistribution
     extends AbstractDistribution
     implements ContinuousDistribution, Serializable {
-
     /** Serializable version identifier */
     private static final long serialVersionUID = -38038050983108802L;
-
     /**
      * RandomData instance used to generate samples from the distribution
      * @since 2.2
      */
     protected final RandomDataImpl randomData = new RandomDataImpl();
-
     /**
      * Solver absolute accuracy for inverse cum computation
      * @since 2.1
      */
     private double solverAbsoluteAccuracy = BrentSolver.DEFAULT_ABSOLUTE_ACCURACY;
-
     /**
      * Default constructor.
      */
-    protected AbstractContinuousDistribution() {
-        super();
-    }
+    protected AbstractContinuousDistribution() {}
 
     /**
-     * Return the probability density for a particular point.
-     * @param x  The point at which the density should be computed.
-     * @return  The pdf at point x.
-     * @throws MathRuntimeException if the specialized class hasn't implemented this function
-     * @since 2.1
+     * {@inheritDoc}
      */
-    public double density(double x) throws MathRuntimeException {
-        throw new MathRuntimeException(new UnsupportedOperationException(),
-                LocalizedFormats.NO_DENSITY_FOR_THIS_DISTRIBUTION);
-    }
+    public abstract double density(double x);
 
     /**
-     * For this distribution, X, this method returns the critical point x, such
-     * that P(X &lt; x) = <code>p</code>.
+     * For this distribution, {@code X}, this method returns the critical
+     * point {@code x}, such that {@code P(X < x) = p}.
      *
-     * @param p the desired probability
-     * @return x, such that P(X &lt; x) = <code>p</code>
+     * @param p Desired probability.
+     * @return {@code x}, such that {@code P(X < x) = p}.
      * @throws MathException if the inverse cumulative probability can not be
-     *         computed due to convergence or other numerical errors.
-     * @throws IllegalArgumentException if <code>p</code> is not a valid
-     *         probability.
+     * computed due to convergence or other numerical errors.
+     * @throws OutOfRangeException if {@code p} is not a valid probability.
      */
     public double inverseCumulativeProbability(final double p)
         throws MathException {
         if (p < 0.0 || p > 1.0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);
+            throw new OutOfRangeException(p, 0, 1);
         }
 
         // by default, do simple root finding using bracketing and default solver.
@@ -101,7 +87,8 @@ public abstract class AbstractContinuousDistribution
                 try {
                     ret = cumulativeProbability(x) - p;
                 } catch (MathException ex) {
-                    throw new FunctionEvaluationException(ex, x, ex.getLocalizablePattern(), ex.getArguments());
+                    throw new FunctionEvaluationException(ex, x, ex.getLocalizablePattern(),
+                                                          ex.getArguments());
                 }
                 if (Double.isNaN(ret)) {
                     throw new FunctionEvaluationException(x,
@@ -119,7 +106,7 @@ public abstract class AbstractContinuousDistribution
             bracket = UnivariateRealSolverUtils.bracket(
                     rootFindingFunction, getInitialDomain(p),
                     lowerBound, upperBound);
-        }  catch (ConvergenceException ex) {
+        } catch (ConvergenceException ex) {
             /*
              * Check domain endpoints to see if one gives value that is within
              * the default solver's defaultAbsoluteAccuracy of 0 (will be the
@@ -144,9 +131,9 @@ public abstract class AbstractContinuousDistribution
     }
 
     /**
-     * Reseeds the random generator used to generate samples.
+     * Reseed the random generator used to generate samples.
      *
-     * @param seed the new seed
+     * @param seed New seed.
      * @since 2.2
      */
     public void reseedRandomGenerator(long seed) {
@@ -154,31 +141,34 @@ public abstract class AbstractContinuousDistribution
     }
 
     /**
-     * Generates a random value sampled from this distribution. The default
+     * Generate a random value sampled from this distribution. The default
      * implementation uses the
-     * <a href="http://en.wikipedia.org/wiki/Inverse_transform_sampling"> inversion method.</a>
+     * <a href="http://en.wikipedia.org/wiki/Inverse_transform_sampling">
+     *  inversion method.
+     * </a>
      *
-     * @return random value
+     * @return a random value.
+     * @throws MathException if an error occurs generating the random value.
      * @since 2.2
-     * @throws MathException if an error occurs generating the random value
      */
     public double sample() throws MathException {
         return randomData.nextInversionDeviate(this);
     }
 
     /**
-     * Generates a random sample from the distribution.  The default implementation
+     * Generate a random sample from the distribution.  The default implementation
      * generates the sample by calling {@link #sample()} in a loop.
      *
-     * @param sampleSize number of random values to generate
+     * @param sampleSize Number of random values to generate.
+     * @return an array representing the random sample.
+     * @throws MathException if an error occurs generating the sample.
+     * @throws NotStrictlyPositiveException if {@code sampleSize} is not positive.
      * @since 2.2
-     * @return an array representing the random sample
-     * @throws MathException if an error occurs generating the sample
-     * @throws IllegalArgumentException if sampleSize is not positive
      */
     public double[] sample(int sampleSize) throws MathException {
         if (sampleSize <= 0) {
-            MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, sampleSize);
+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
+                                                   sampleSize);
         }
         double[] out = new double[sampleSize];
         for (int i = 0; i < sampleSize; i++) {
@@ -188,34 +178,32 @@ public abstract class AbstractContinuousDistribution
     }
 
     /**
-     * Access the initial domain value, based on <code>p</code>, used to
+     * Access the initial domain value, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return initial domain value
+     * @param p Desired probability for the critical value.
+     * @return the initial domain value.
      */
     protected abstract double getInitialDomain(double p);
 
     /**
-     * Access the domain value lower bound, based on <code>p</code>, used to
+     * Access the domain value lower bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value lower bound, i.e.
-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.
      */
     protected abstract double getDomainLowerBound(double p);
 
     /**
-     * Access the domain value upper bound, based on <code>p</code>, used to
+     * Access the domain value upper bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value upper bound, i.e.
-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
      */
     protected abstract double getDomainUpperBound(double p);
 
diff --git a/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java b/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java
index 25637c524..5a81430f9 100644
--- a/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java
@@ -37,12 +37,4 @@ public interface BetaDistribution extends ContinuousDistribution {
       * @return beta.
       */
      double getBeta();
-
-     /**
-      * Return the probability density for a particular point.
-      *
-      * @param x  Point at which the density should be computed.
-      * @return the pdf at point {@code x}.
-      */
-     double density(double x);
 }
diff --git a/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java
index 1b78d52e6..92538a01a 100644
--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java
@@ -23,8 +23,9 @@ package org.apache.commons.math.distribution;
  * <p>
  * References:
  * <ul>
- * <li><a href="http://mathworld.wolfram.com/CauchyDistribution.html">
- * Cauchy Distribution</a></li>
+ *  <li><a href="http://mathworld.wolfram.com/CauchyDistribution.html">
+ *   Cauchy Distribution</a>
+ *  </li>
  * </ul>
  * </p>
  *
@@ -32,32 +33,17 @@ package org.apache.commons.math.distribution;
  * @version $Revision$ $Date$
  */
 public interface CauchyDistribution extends ContinuousDistribution {
-
     /**
      * Access the median.
-     * @return median for this distribution
+     *
+     * @return the median for this distribution.
      */
     double getMedian();
 
     /**
      * Access the scale parameter.
-     * @return scale parameter for this distribution
+     *
+     * @return the scale parameter for this distribution.
      */
     double getScale();
-
-    /**
-     * Modify the median.
-     * @param median for this distribution
-     * @deprecated as of v2.1
-     */
-    @Deprecated
-    void setMedian(double median);
-
-    /**
-     * Modify the scale parameter.
-     * @param s scale parameter for this distribution
-     * @deprecated as of v2.1
-     */
-    @Deprecated
-    void setScale(double s);
 }
diff --git a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java
index 7b79a1bf6..1a84daa7f 100644
--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java
+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java
@@ -19,7 +19,8 @@ package org.apache.commons.math.distribution;
 
 import java.io.Serializable;
 
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
+import org.apache.commons.math.exception.OutOfRangeException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.FastMath;
 
@@ -32,22 +33,17 @@ import org.apache.commons.math.util.FastMath;
  */
 public class CauchyDistributionImpl extends AbstractContinuousDistribution
         implements CauchyDistribution, Serializable {
-
     /**
      * Default inverse cumulative probability accuracy
      * @since 2.1
      */
     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
-
     /** Serializable version identifier */
     private static final long serialVersionUID = 8589540077390120676L;
-
     /** The median of this distribution. */
     private double median = 0;
-
     /** The scale of this distribution. */
     private double scale = 1;
-
     /** Inverse cumulative probability accuracy */
     private final double solverAbsoluteAccuracy;
 
@@ -55,65 +51,67 @@ public class CauchyDistributionImpl extends AbstractContinuousDistribution
      * Creates cauchy distribution with the medain equal to zero and scale
      * equal to one.
      */
-    public CauchyDistributionImpl(){
-        this(0.0, 1.0);
+    public CauchyDistributionImpl() {
+        this(0, 1);
     }
 
     /**
      * Create a cauchy distribution using the given median and scale.
-     * @param median median for this distribution
-     * @param s scale parameter for this distribution
+     *
+     * @param median Median for this distribution.
+     * @param scale Scale parameter for this distribution.
      */
-    public CauchyDistributionImpl(double median, double s){
-        this(median, s, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
+    public CauchyDistributionImpl(double median, double scale) {
+        this(median, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
     }
 
     /**
      * Create a cauchy distribution using the given median and scale.
-     * @param median median for this distribution
-     * @param s scale parameter for this distribution
-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates
-     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})
+     *
+     * @param median Median for this distribution.
+     * @param scale Scale parameter for this distribution.
+     * @param inverseCumAccuracy Maximum absolute error in inverse
+     * cumulative probability estimates
+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).
+     * @throws NotStrictlyPositiveException if {@code s <= 0}.
      * @since 2.1
      */
-    public CauchyDistributionImpl(double median, double s, double inverseCumAccuracy) {
-        super();
-        setMedianInternal(median);
-        setScaleInternal(s);
+    public CauchyDistributionImpl(double median, double scale,
+                                  double inverseCumAccuracy) {
+        if (scale <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, scale);
+        }
+        this.scale = scale;
+        this.median = median;
         solverAbsoluteAccuracy = inverseCumAccuracy;
     }
 
     /**
-     * For this distribution, X, this method returns P(X &lt; <code>x</code>).
-     * @param x the value at which the CDF is evaluated.
-     * @return CDF evaluted at <code>x</code>.
+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.
+     *
+     * @param x Value at which the CDF is evaluated.
+     * @return CDF evaluted at {@code x}.
      */
     public double cumulativeProbability(double x) {
         return 0.5 + (FastMath.atan((x - median) / scale) / FastMath.PI);
     }
 
     /**
-     * Access the median.
-     * @return median for this distribution
+     * {@inheritDoc}
      */
     public double getMedian() {
         return median;
     }
 
     /**
-     * Access the scale parameter.
-     * @return scale parameter for this distribution
+     * {@inheritDoc}
      */
     public double getScale() {
         return scale;
     }
 
     /**
-     * Returns the probability density for a particular point.
-     *
-     * @param x The point at which the density should be computed.
-     * @return The pdf at point x.
-     * @since 2.1
+     * {@inheritDoc}
      */
     @Override
     public double density(double x) {
@@ -122,23 +120,20 @@ public class CauchyDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * For this distribution, X, this method returns the critical point x, such
-     * that P(X &lt; x) = <code>p</code>.
-     * <p>
-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and
-     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
+     * For this distribution, {@code X}, this method returns the critical
+     * point {@code x}, such that {@code P(X < x) = p}.
+     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and
+     * {@code Double.POSITIVE_INFINITY} when p = 1.
      *
-     * @param p the desired probability
-     * @return x, such that P(X &lt; x) = <code>p</code>
-     * @throws IllegalArgumentException if <code>p</code> is not a valid
-     *         probability.
+     * @param p Desired probability.
+     * @return {@code x}, such that {@code P(X < x) = p}.
+     * @throws OutOfRangeException if {@code p} is not a valid probability.
      */
     @Override
     public double inverseCumulativeProbability(double p) {
         double ret;
-        if (p < 0.0 || p > 1.0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);
+        if (p < 0 || p > 1) {
+            throw new OutOfRangeException(p, 0, 1);
         } else if (p == 0) {
             ret = Double.NEGATIVE_INFINITY;
         } else  if (p == 1) {
@@ -150,59 +145,18 @@ public class CauchyDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * Modify the median.
-     * @param median for this distribution
-     * @deprecated as of 2.1 (class will become immutable in 3.0)
-     */
-    @Deprecated
-    public void setMedian(double median) {
-        setMedianInternal(median);
-    }
-    /**
-     * Modify the median.
-     * @param newMedian for this distribution
-     */
-    private void setMedianInternal(double newMedian) {
-        this.median = newMedian;
-    }
-
-    /**
-     * Modify the scale parameter.
-     * @param s scale parameter for this distribution
-     * @throws IllegalArgumentException if <code>sd</code> is not positive.
-     * @deprecated as of 2.1 (class will become immutable in 3.0)
-     */
-    @Deprecated
-    public void setScale(double s) {
-        setScaleInternal(s);
-    }
-    /**
-     * Modify the scale parameter.
-     * @param s scale parameter for this distribution
-     * @throws IllegalArgumentException if <code>sd</code> is not positive.
-     */
-    private void setScaleInternal(double s) {
-        if (s <= 0.0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.NOT_POSITIVE_SCALE, s);
-        }
-        scale = s;
-    }
-
-    /**
-     * Access the domain value lower bound, based on <code>p</code>, used to
+     * Access the domain value lower bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value lower bound, i.e.
-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.
      */
     @Override
     protected double getDomainLowerBound(double p) {
         double ret;
 
-        if (p < .5) {
+        if (p < 0.5) {
             ret = -Double.MAX_VALUE;
         } else {
             ret = median;
@@ -216,15 +170,14 @@ public class CauchyDistributionImpl extends AbstractContinuousDistribution
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value upper bound, i.e.
-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return domain value lower bound, i.e. {@code P(X < 'upper bound') > p}.
      */
     @Override
     protected double getDomainUpperBound(double p) {
         double ret;
 
-        if (p < .5) {
+        if (p < 0.5) {
             ret = median;
         } else {
             ret = Double.MAX_VALUE;
@@ -234,20 +187,20 @@ public class CauchyDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * Access the initial domain value, based on <code>p</code>, used to
+     * Access the initial domain value, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return initial domain value
+     * @param p Desired probability for the critical value.
+     * @return the initial domain value.
      */
     @Override
     protected double getInitialDomain(double p) {
         double ret;
 
-        if (p < .5) {
+        if (p < 0.5) {
             ret = median - scale;
-        } else if (p > .5) {
+        } else if (p > 0.5) {
             ret = median + scale;
         } else {
             ret = median;
diff --git a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java
index deeee68b1..f1c329f65 100644
--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java
@@ -31,15 +31,9 @@ package org.apache.commons.math.distribution;
  */
 public interface ChiSquaredDistribution extends ContinuousDistribution {
     /**
-     * Access the degrees of freedom.
+     * Access the number of degrees of freedom.
+     *
      * @return the degrees of freedom.
      */
     double getDegreesOfFreedom();
-
-    /**
-     * Return the probability density for a particular point.
-     * @param x  The point at which the density should be computed.
-     * @return  The pdf at point x.
-     */
-    double density(double x);
 }
diff --git a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java
index 914f22789..8e88ee8ea 100644
--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java
+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java
@@ -73,11 +73,7 @@ public class ChiSquaredDistributionImpl
     }
 
     /**
-     * Return the probability density for a particular point.
-     *
-     * @param x The point at which the density should be computed.
-     * @return The pdf at point x.
-     * @since 2.1
+     * {@inheritDoc}
      */
     @Override
     public double density(double x) {
@@ -85,28 +81,29 @@ public class ChiSquaredDistributionImpl
     }
 
     /**
-     * For this distribution, X, this method returns P(X &lt; x).
+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.
+     *
      * @param x the value at which the CDF is evaluated.
      * @return CDF for this distribution.
-     * @throws MathException if the cumulative probability can not be
-     *            computed due to convergence or other numerical errors.
+     * @throws MathException if the cumulative probability cannot be
+     * computed due to convergence or other numerical errors.
      */
     public double cumulativeProbability(double x) throws MathException {
         return gamma.cumulativeProbability(x);
     }
 
     /**
-     * For this distribution, X, this method returns the critical point x, such
-     * that P(X &lt; x) = <code>p</code>.
-     * <p>
-     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
+     * For this distribution, X, this method returns the critical point
+     * {@code x}, such that {@code P(X < x) = p}.
+     * It will return 0 when p = 0 and {@code Double.POSITIVE_INFINITY}
+     * when p = 1.
      *
-     * @param p the desired probability
-     * @return x, such that P(X &lt; x) = <code>p</code>
+     * @param p Desired probability.
+     * @return {@code x}, such that {@code P(X < x) = p}.
      * @throws MathException if the inverse cumulative probability can not be
-     *         computed due to convergence or other numerical errors.
-     * @throws IllegalArgumentException if <code>p</code> is not a valid
-     *         probability.
+     * computed due to convergence or other numerical errors.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * {@code p} is not a valid probability.
      */
     @Override
     public double inverseCumulativeProbability(final double p)
@@ -121,13 +118,12 @@ public class ChiSquaredDistributionImpl
     }
 
     /**
-     * Access the domain value lower bound, based on <code>p</code>, used to
+     * Access the domain value lower bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
      * @param p the desired probability for the critical value
-     * @return domain value lower bound, i.e.
-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>
+     * @return domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.
      */
     @Override
     protected double getDomainLowerBound(double p) {
@@ -135,13 +131,12 @@ public class ChiSquaredDistributionImpl
     }
 
     /**
-     * Access the domain value upper bound, based on <code>p</code>, used to
+     * Access the domain value upper bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value upper bound, i.e.
-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
      */
     @Override
     protected double getDomainUpperBound(double p) {
@@ -162,12 +157,12 @@ public class ChiSquaredDistributionImpl
     }
 
     /**
-     * Access the initial domain value, based on <code>p</code>, used to
+     * Access the initial domain value, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return initial domain value
+     * @param p Desired probability for the critical value.
+     * @return the initial domain value.
      */
     @Override
     protected double getInitialDomain(double p) {
diff --git a/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java b/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java
index 02a4b0869..db1101a76 100644
--- a/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java
@@ -19,25 +19,27 @@ package org.apache.commons.math.distribution;
 import org.apache.commons.math.MathException;
 
 /**
- * <p>Base interface for continuous distributions.</p>
- *
- * <p>Note: this interface will be extended in version 3.0 to include
- * <br/><code>public double density(double x)</code><br/>
- * that is, from version 3.0 forward, continuous distributions <strong>must</strong>
- * include implementations of probability density functions. As of version
- * 2.1, all continuous distribution implementations included in commons-math
- * provide implementations of this method.</p>
+ * Base interface for continuous distributions.
  *
  * @version $Revision$ $Date$
  */
 public interface ContinuousDistribution extends Distribution {
-
     /**
-     * For this distribution, X, this method returns x such that P(X &lt; x) = p.
-     * @param p the cumulative probability.
-     * @return x.
-     * @throws MathException if the inverse cumulative probability can not be
-     *            computed due to convergence or other numerical errors.
+     * For a distribution, {@code X}, compute {@code x} such that
+     * {@code P(X < x) = p}.
+     *
+     * @param p Cumulative probability.
+     * @return {@code x} such that {@code P(X < x) = p}.
+     * @throws MathException if the inverse cumulative probability cannot be
+     * computed due to convergence or other numerical errors.
      */
     double inverseCumulativeProbability(double p) throws MathException;
+
+    /**
+     * Probability density for a particular point.
+     *
+     * @param x Point at which the density should be computed.
+     * @return the pdf at point {@code x}.
+     */
+    double density(double x);
 }
diff --git a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java
index 033fb9a20..ff4fb9ac3 100644
--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java
@@ -36,12 +36,4 @@ public interface ExponentialDistribution extends ContinuousDistribution {
      * @return the mean.
      */
     double getMean();
-
-    /**
-     * Return the probability density for a particular point.
-     *
-     * @param x Point at which the density should be computed.
-     * @return the pdf at point {@code x}.
-     */
-    double density(double x);
 }
diff --git a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java
index 708d512e0..be91ed0e3 100644
--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java
+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java
@@ -53,8 +53,9 @@ public class ExponentialDistributionImpl extends AbstractContinuousDistribution
 
     /**
      * Create a exponential distribution with the given mean.
-     * @param mean mean of this distribution.
-     * @param inverseCumAccuracy the maximum absolute error in inverse
+     *
+     * @param mean Mean of this distribution.
+     * @param inverseCumAccuracy Maximum absolute error in inverse
      * cumulative probability estimates (defaults to
      * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).
      * @throws NotStrictlyPositiveException if {@code mean <= 0}.
@@ -96,7 +97,7 @@ public class ExponentialDistributionImpl extends AbstractContinuousDistribution
      * Exponential Distribution</a>, equation (1).</li>
      * </ul>
      *
-     * @param x the value at which the CDF is evaluated.
+     * @param x Value at which the CDF is evaluated.
      * @return the CDF for this distribution.
      * @throws MathException if the cumulative probability can not be
      * computed due to convergence or other numerical errors.
@@ -114,9 +115,10 @@ public class ExponentialDistributionImpl extends AbstractContinuousDistribution
     /**
      * For this distribution, X, this method returns the critical point x, such
      * that {@code P(X < x) = p}.
-     * Returns 0 when p = 0 and {@code Double.POSITIVE_INFINITY} when p = 1.
+     * It will return 0 when p = 0 and {@code Double.POSITIVE_INFINITY}
+     * when p = 1.
      *
-     * @param p the desired probability
+     * @param p Desired probability.
      * @return {@code x}, such that {@code P(X < x) = p}.
      * @throws MathException if the inverse cumulative probability can not be
      * computed due to convergence or other numerical errors.
@@ -167,7 +169,7 @@ public class ExponentialDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * Access the domain value upper bound, based on <code>p</code>, used to
+     * Access the domain value upper bound, based on {@code p}, used to
      * bracket a CDF root.
      *
      * @param p Desired probability for the critical value.
diff --git a/src/main/java/org/apache/commons/math/distribution/FDistribution.java b/src/main/java/org/apache/commons/math/distribution/FDistribution.java
index 1a2afe3a4..0b5948463 100644
--- a/src/main/java/org/apache/commons/math/distribution/FDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/FDistribution.java
@@ -30,30 +30,16 @@ package org.apache.commons.math.distribution;
  * @version $Revision$ $Date$
  */
 public interface FDistribution extends ContinuousDistribution {
-    /**
-     * Modify the numerator degrees of freedom.
-     * @param degreesOfFreedom the new numerator degrees of freedom.
-     * @deprecated as of v2.1
-     */
-    @Deprecated
-    void setNumeratorDegreesOfFreedom(double degreesOfFreedom);
-
     /**
      * Access the numerator degrees of freedom.
+     *
      * @return the numerator degrees of freedom.
      */
     double getNumeratorDegreesOfFreedom();
 
-    /**
-     * Modify the denominator degrees of freedom.
-     * @param degreesOfFreedom the new denominator degrees of freedom.
-     * @deprecated as of v2.1
-     */
-    @Deprecated
-    void setDenominatorDegreesOfFreedom(double degreesOfFreedom);
-
     /**
      * Access the denominator degrees of freedom.
+     *
      * @return the denominator degrees of freedom.
      */
     double getDenominatorDegreesOfFreedom();
diff --git a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java
index 624be0acd..28c4a7d64 100644
--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java
+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java
@@ -14,12 +14,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.commons.math.distribution;
 
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Beta;
 import org.apache.commons.math.util.FastMath;
@@ -33,48 +34,58 @@ import org.apache.commons.math.util.FastMath;
 public class FDistributionImpl
     extends AbstractContinuousDistribution
     implements FDistribution, Serializable  {
-
     /**
      * Default inverse cumulative probability accuracy
      * @since 2.1
      */
     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
-
     /** Serializable version identifier */
     private static final long serialVersionUID = -8516354193418641566L;
-
     /** The numerator degrees of freedom*/
     private double numeratorDegreesOfFreedom;
-
     /** The numerator degrees of freedom*/
     private double denominatorDegreesOfFreedom;
-
     /** Inverse cumulative probability accuracy */
     private final double solverAbsoluteAccuracy;
 
     /**
      * Create a F distribution using the given degrees of freedom.
-     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.
-     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.
+     * @param numeratorDegreesOfFreedom Numerator degrees of freedom.
+     * @param denominatorDegreesOfFreedom Denominator degrees of freedom.
+     * @throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0}
+     * or {@code denominatorDegreesOfFreedom <= 0}.
      */
     public FDistributionImpl(double numeratorDegreesOfFreedom,
                              double denominatorDegreesOfFreedom) {
-        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
+        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,
+             DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
     }
 
     /**
-     * Create a F distribution using the given degrees of freedom and inverse cumulative probability accuracy.
-     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.
-     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.
-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates
+     * Create an F distribution using the given degrees of freedom
+     * and inverse cumulative probability accuracy.
+     * @param numeratorDegreesOfFreedom Numerator degrees of freedom.
+     * @param denominatorDegreesOfFreedom Denominator degrees of freedom.
+     * @param inverseCumAccuracy the maximum absolute error in inverse
+     * cumulative probability estimates.
      * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})
+     * @throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0}
+     * or {@code denominatorDegreesOfFreedom <= 0}.
      * @since 2.1
      */
-    public FDistributionImpl(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom,
-            double inverseCumAccuracy) {
-        super();
-        setNumeratorDegreesOfFreedomInternal(numeratorDegreesOfFreedom);
-        setDenominatorDegreesOfFreedomInternal(denominatorDegreesOfFreedom);
+    public FDistributionImpl(double numeratorDegreesOfFreedom,
+                             double denominatorDegreesOfFreedom,
+                             double inverseCumAccuracy) {
+        if (numeratorDegreesOfFreedom <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,
+                                                   numeratorDegreesOfFreedom);
+        }
+        if (denominatorDegreesOfFreedom <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,
+                                                   denominatorDegreesOfFreedom);
+        }
+        this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;
+        this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;
         solverAbsoluteAccuracy = inverseCumAccuracy;
     }
 
@@ -92,30 +103,33 @@ public class FDistributionImpl
         final double logx = FastMath.log(x);
         final double logn = FastMath.log(numeratorDegreesOfFreedom);
         final double logm = FastMath.log(denominatorDegreesOfFreedom);
-        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x + denominatorDegreesOfFreedom);
-        return FastMath.exp(nhalf*logn + nhalf*logx - logx + mhalf*logm - nhalf*lognxm -
-               mhalf*lognxm - Beta.logBeta(nhalf, mhalf));
+        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +
+                                           denominatorDegreesOfFreedom);
+        return FastMath.exp(nhalf * logn + nhalf * logx - logx +
+                            mhalf * logm - nhalf * lognxm - mhalf * lognxm -
+                            Beta.logBeta(nhalf, mhalf));
     }
 
     /**
-     * For this distribution, X, this method returns P(X &lt; x).
+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.
      *
-     * The implementation of this method is based on:
+     * The implementation of this method is based on
      * <ul>
-     * <li>
-     * <a href="http://mathworld.wolfram.com/F-Distribution.html">
-     * F-Distribution</a>, equation (4).</li>
+     *  <li>
+     *   <a href="http://mathworld.wolfram.com/F-Distribution.html">
+     *   F-Distribution</a>, equation (4).
+     *  </li>
      * </ul>
      *
-     * @param x the value at which the CDF is evaluated.
+     * @param x Value at which the CDF is evaluated.
      * @return CDF for this distribution.
-     * @throws MathException if the cumulative probability can not be
-     *            computed due to convergence or other numerical errors.
+     * @throws MathException if the cumulative probability cannot be
+     * computed due to convergence or other numerical errors.
      */
     public double cumulativeProbability(double x) throws MathException {
         double ret;
-        if (x <= 0.0) {
-            ret = 0.0;
+        if (x <= 0) {
+            ret = 0;
         } else {
             double n = numeratorDegreesOfFreedom;
             double m = denominatorDegreesOfFreedom;
@@ -128,23 +142,22 @@ public class FDistributionImpl
     }
 
     /**
-     * For this distribution, X, this method returns the critical point x, such
-     * that P(X &lt; x) = <code>p</code>.
-     * <p>
-     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
+     * For this distribution, {@code X}, this method returns the critical
+     * point {@code x}, such that {@code P(X < x) = p}.
+     * Returns 0 when p = 0 and {@code Double.POSITIVE_INFINITY} when p = 1.
      *
-     * @param p the desired probability
-     * @return x, such that P(X &lt; x) = <code>p</code>
-     * @throws MathException if the inverse cumulative probability can not be
-     *         computed due to convergence or other numerical errors.
-     * @throws IllegalArgumentException if <code>p</code> is not a valid
-     *         probability.
+     * @param p Desired probability.
+     * @return {@code x}, such that {@code P(X < x) = p}.
+     * @throws MathException if the inverse cumulative probability cannot be
+     * computed due to convergence or other numerical errors.
+     * @throws IllegalArgumentException if {@code p} is not a valid
+     * probability.
      */
     @Override
     public double inverseCumulativeProbability(final double p)
         throws MathException {
         if (p == 0) {
-            return 0d;
+            return 0;
         }
         if (p == 1) {
             return Double.POSITIVE_INFINITY;
@@ -153,27 +166,25 @@ public class FDistributionImpl
     }
 
     /**
-     * Access the domain value lower bound, based on <code>p</code>, used to
+     * Access the domain value lower bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value lower bound, i.e.
-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.
      */
     @Override
     protected double getDomainLowerBound(double p) {
-        return 0.0;
+        return 0;
     }
 
     /**
-     * Access the domain value upper bound, based on <code>p</code>, used to
+     * Access the domain value upper bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value upper bound, i.e.
-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
      */
     @Override
     protected double getDomainUpperBound(double p) {
@@ -181,87 +192,33 @@ public class FDistributionImpl
     }
 
     /**
-     * Access the initial domain value, based on <code>p</code>, used to
+     * Access the initial domain value, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return initial domain value
+     * @param p Desired probability for the critical value.
+     * @return the initial domain value.
      */
     @Override
     protected double getInitialDomain(double p) {
-        double ret = 1.0;
+        double ret = 1;
         double d = denominatorDegreesOfFreedom;
-        if (d > 2.0) {
+        if (d > 2) {
             // use mean
-            ret = d / (d - 2.0);
+            ret = d / (d - 2);
         }
         return ret;
     }
 
     /**
-     * Modify the numerator degrees of freedom.
-     * @param degreesOfFreedom the new numerator degrees of freedom.
-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not
-     *         positive.
-     * @deprecated as of 2.1 (class will become immutable in 3.0)
-     */
-    @Deprecated
-    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {
-        setNumeratorDegreesOfFreedomInternal(degreesOfFreedom);
-    }
-
-    /**
-     * Modify the numerator degrees of freedom.
-     * @param degreesOfFreedom the new numerator degrees of freedom.
-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not
-     *         positive.
-     */
-    private void setNumeratorDegreesOfFreedomInternal(double degreesOfFreedom) {
-        if (degreesOfFreedom <= 0.0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM, degreesOfFreedom);
-        }
-        this.numeratorDegreesOfFreedom = degreesOfFreedom;
-    }
-
-    /**
-     * Access the numerator degrees of freedom.
-     * @return the numerator degrees of freedom.
+     * {@inheritDoc}
      */
     public double getNumeratorDegreesOfFreedom() {
         return numeratorDegreesOfFreedom;
     }
 
     /**
-     * Modify the denominator degrees of freedom.
-     * @param degreesOfFreedom the new denominator degrees of freedom.
-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not
-     *         positive.
-     * @deprecated as of 2.1 (class will become immutable in 3.0)
-     */
-    @Deprecated
-    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {
-        setDenominatorDegreesOfFreedomInternal(degreesOfFreedom);
-    }
-
-    /**
-     * Modify the denominator degrees of freedom.
-     * @param degreesOfFreedom the new denominator degrees of freedom.
-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not
-     *         positive.
-     */
-    private void setDenominatorDegreesOfFreedomInternal(double degreesOfFreedom) {
-        if (degreesOfFreedom <= 0.0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM, degreesOfFreedom);
-        }
-        this.denominatorDegreesOfFreedom = degreesOfFreedom;
-    }
-
-    /**
-     * Access the denominator degrees of freedom.
-     * @return the denominator degrees of freedom.
+     * {@inheritDoc}
      */
     public double getDenominatorDegreesOfFreedom() {
         return denominatorDegreesOfFreedom;
diff --git a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java
index 4cb3f2637..483ee1b43 100644
--- a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java
@@ -43,12 +43,4 @@ public interface GammaDistribution extends ContinuousDistribution {
      * @return beta.
      */
     double getBeta();
-
-    /**
-     * Return the probability density for a particular point.
-     *
-     * @param x Point at which the density should be computed..
-     * @return the pdf at point {@code x}.
-     */
-    double density(double x);
 }
diff --git a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java
index 155d6a51e..f1e2fd84b 100644
--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java
+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java
@@ -61,9 +61,10 @@ public class GammaDistributionImpl extends AbstractContinuousDistribution
 
     /**
      * Create a new gamma distribution with the given alpha and beta values.
-     * @param alpha the shape parameter.
-     * @param beta the scale parameter.
-     * @param inverseCumAccuracy the maximum absolute error in inverse
+     *
+     * @param alpha Shape parameter.
+     * @param beta Scale parameter.
+     * @param inverseCumAccuracy Maximum absolute error in inverse
      * cumulative probability estimates (defaults to
      * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).
      * @throws NotStrictlyPositiveException if {@code alpha <= 0} or
@@ -84,21 +85,23 @@ public class GammaDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * For this distribution, X, this method returns P(X &lt; x).
+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.
      *
      * The implementation of this method is based on:
      * <ul>
-     * <li>
-     * <a href="http://mathworld.wolfram.com/Chi-SquaredDistribution.html">
-     * Chi-Squared Distribution</a>, equation (9).</li>
-     * <li>Casella, G., & Berger, R. (1990). <i>Statistical Inference</i>.
-     * Belmont, CA: Duxbury Press.</li>
+     *  <li>
+     *   <a href="http://mathworld.wolfram.com/Chi-SquaredDistribution.html">
+     *    Chi-Squared Distribution</a>, equation (9).
+     *  </li>
+     *  <li>Casella, G., & Berger, R. (1990). <i>Statistical Inference</i>.
+     *    Belmont, CA: Duxbury Press.
+     *  </li>
      * </ul>
      *
-     * @param x the value at which the CDF is evaluated.
+     * @param x Value at which the CDF is evaluated.
      * @return CDF for this distribution.
      * @throws MathException if the cumulative probability can not be
-     *            computed due to convergence or other numerical errors.
+     * computed due to convergence or other numerical errors.
      */
     public double cumulativeProbability(double x) throws MathException{
         double ret;
@@ -113,16 +116,17 @@ public class GammaDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * For this distribution, X, this method returns the critical point x, such
-     * that {@code P(X < x) = p}.
-     * Returns 0 when p = 0 and {@code Double.POSITIVE_INFINITY} when p = 1.
+     * For this distribution, {@code X}, this method returns the critical
+     * point {@code x}, such that {@code P(X < x) = p}.
+     * It will return 0 when p = 0 and {@code Double.POSITIVE_INFINITY}
+     * when p = 1.
      *
      * @param p Desired probability.
      * @return {@code x}, such that {@code P(X < x) = p}.
-     * @throws MathException if the inverse cumulative probability can not be
+     * @throws MathException if the inverse cumulative probability cannot be
      * computed due to convergence or other numerical errors.
-     * @throws IllegalArgumentException if {@code p} is not a valid
-     * probability.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * {@code p} is not a valid probability.
      */
     @Override
     public double inverseCumulativeProbability(final double p)
@@ -161,7 +165,7 @@ public class GammaDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * Access the domain value lower bound, based on <code>p</code>, used to
+     * Access the domain value lower bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
@@ -175,12 +179,12 @@ public class GammaDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * Access the domain value upper bound, based on <code>p</code>, used to
+     * Access the domain value upper bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
+     * @param p Desired probability for the critical value.
+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
      */
     @Override
     protected double getDomainUpperBound(double p) {
diff --git a/src/main/java/org/apache/commons/math/distribution/HasDensity.java b/src/main/java/org/apache/commons/math/distribution/HasDensity.java
deleted file mode 100644
index 0c4db77ef..000000000
--- a/src/main/java/org/apache/commons/math/distribution/HasDensity.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.math.distribution;
-
-import org.apache.commons.math.MathException;
-
-/**
- * <p>Interface that signals that a distribution can compute the probability density function
- * for a particular point.
- * @param <P> the type of the point at which density is to be computed, this
- * may be for example <code>Double.</code></p>
- *
- * <p>This interface is deprecated.  As of version 2.0, the {@link ContinuousDistribution}
- * interface will be extended to include a <code>density(double)<code> method.</p>
- *
- * @deprecated to be removed in math 3.0
- * @version $Revision$ $Date$
- */
-public interface HasDensity<P> {
-
-    /**
-     * Compute the probability density function.
-     * @param x point for which the probability density is requested
-     * @return probability density at point x
-     * @throws MathException if probability density cannot be computed at specifed point
-     */
-    double density(P x) throws MathException;
-
-}
diff --git a/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java
index 3c7959f08..9acc84b7c 100644
--- a/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java
@@ -44,12 +44,4 @@ public interface NormalDistribution extends ContinuousDistribution {
      * @return the standard deviation for this distribution.
      */
     double getStandardDeviation();
-
-    /**
-     * Return the probability density for a particular point.
-     *
-     * @param x Point at which the density should be computed.
-     * @return the pdf at point {@code x}.
-     */
-    double density(double x);
 }
diff --git a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java
index 1be131f23..66a69a047 100644
--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java
+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java
@@ -52,8 +52,9 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
 
     /**
      * Create a normal distribution using the given mean and standard deviation.
-     * @param mean mean for this distribution
-     * @param sd standard deviation for this distribution
+     *
+     * @param mean Mean for this distribution.
+     * @param sd Standard deviation for this distribution.
      */
     public NormalDistributionImpl(double mean, double sd){
         this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
@@ -65,7 +66,7 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
      *
      * @param mean Mean for this distribution.
      * @param sd Standard deviation for this distribution.
-     * @param inverseCumAccuracy inverse cumulative probability accuracy.
+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.
      * @throws NotStrictlyPositiveException if {@code sd <= 0}.
      * @since 2.1
      */
@@ -73,7 +74,7 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
         if (sd <= 0) {
             throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);
         }
-        
+
         this.mean = mean;
         standardDeviation = sd;
         solverAbsoluteAccuracy = inverseCumAccuracy;
@@ -104,6 +105,7 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
     /**
      * {@inheritDoc}
      */
+    @Override
     public double density(double x) {
         final double x0 = x - mean;
         final double x1 = x0 / standardDeviation;
@@ -138,7 +140,7 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
      * Return the absolute accuracy setting of the solver used to estimate
      * inverse cumulative probabilities.
      *
-     * @return the solver absolute accuracy
+     * @return the solver absolute accuracy.
      * @since 2.1
      */
     @Override
@@ -147,17 +149,17 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * For this distribution, X, this method returns the critical point 
+     * For this distribution, X, this method returns the critical point
      * {@code x}, such that {@code P(X < x) = p}.
-     * Returns {@code Double.NEGATIVE_INFINITY} when p = 0 and
+     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and
      * {@code Double.POSITIVE_INFINITY} for p = 1.
      *
-     * @param p the desired probability
+     * @param p Desired probability.
      * @return {@code x}, such that {@code P(X < x) = p}.
-     * @throws MathException if the inverse cumulative probability can not be
-     *         computed due to convergence or other numerical errors.
-     * @throws IllegalArgumentException if <code>p</code> is not a valid
-     *         probability.
+     * @throws MathException if the inverse cumulative probability cannot be
+     * computed due to convergence or other numerical errors.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * {@code p} is not a valid probability.
      */
     @Override
     public double inverseCumulativeProbability(final double p)
@@ -172,11 +174,11 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * Generates a random value sampled from this distribution.
+     * Generate a random value sampled from this distribution.
      *
-     * @return random value
+     * @return a random value.
      * @since 2.2
-     * @throws MathException if an error occurs generating the random value
+     * @throws MathException if an error occurs generating the random value.
      */
     @Override
     public double sample() throws MathException {
@@ -188,8 +190,8 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.
+     * @param p Desired probability for the critical value.
+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.
      */
     @Override
     protected double getDomainLowerBound(double p) {
@@ -209,8 +211,8 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
+     * @param p Desired probability for the critical value.
+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
      */
     @Override
     protected double getDomainUpperBound(double p) {
@@ -230,8 +232,8 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return initial domain value
+     * @param p Desired probability for the critical value.
+     * @return the initial domain value.
      */
     @Override
     protected double getInitialDomain(double p) {
diff --git a/src/main/java/org/apache/commons/math/distribution/TDistribution.java b/src/main/java/org/apache/commons/math/distribution/TDistribution.java
index 233fe6d95..3b0bd8cb5 100644
--- a/src/main/java/org/apache/commons/math/distribution/TDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/TDistribution.java
@@ -31,15 +31,8 @@ package org.apache.commons.math.distribution;
  */
 public interface TDistribution extends ContinuousDistribution {
     /**
-     * Modify the degrees of freedom.
-     * @param degreesOfFreedom the new degrees of freedom.
-     * @deprecated as of v2.1
-     */
-    @Deprecated
-    void setDegreesOfFreedom(double degreesOfFreedom);
-
-    /**
-     * Access the degrees of freedom.
+     * Access the number of degrees of freedom.
+     *
      * @return the degrees of freedom.
      */
     double getDegreesOfFreedom();
diff --git a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java
index 3f0bbfbeb..708e3f9d9 100644
--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java
+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java
@@ -19,7 +19,7 @@ package org.apache.commons.math.distribution;
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Beta;
 import org.apache.commons.math.special.Gamma;
@@ -34,69 +34,50 @@ import org.apache.commons.math.util.FastMath;
 public class TDistributionImpl
     extends AbstractContinuousDistribution
     implements TDistribution, Serializable  {
-
     /**
-     * Default inverse cumulative probability accuracy
+     * Default inverse cumulative probability accuracy.
      * @since 2.1
-    */
+     */
     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
-
     /** Serializable version identifier */
     private static final long serialVersionUID = -5852615386664158222L;
-
-    /** The degrees of freedom*/
+    /** The degrees of freedom. */
     private double degreesOfFreedom;
-
-    /** Inverse cumulative probability accuracy */
+    /** Inverse cumulative probability accuracy. */
     private final double solverAbsoluteAccuracy;
 
     /**
      * Create a t distribution using the given degrees of freedom and the
      * specified inverse cumulative probability absolute accuracy.
      *
-     * @param degreesOfFreedom the degrees of freedom.
-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates
-     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})
+     * @param degreesOfFreedom Degrees of freedom.
+     * @param inverseCumAccuracy the maximum absolute error in inverse
+     * cumulative probability estimates
+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).
+     * @throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}
      * @since 2.1
      */
     public TDistributionImpl(double degreesOfFreedom, double inverseCumAccuracy) {
-        super();
-        setDegreesOfFreedomInternal(degreesOfFreedom);
+        if (degreesOfFreedom <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,
+                                                   degreesOfFreedom);
+        }
+        this.degreesOfFreedom = degreesOfFreedom;
         solverAbsoluteAccuracy = inverseCumAccuracy;
     }
 
     /**
      * Create a t distribution using the given degrees of freedom.
-     * @param degreesOfFreedom the degrees of freedom.
+     *
+     * @param degreesOfFreedom Degrees of freedom.
      */
     public TDistributionImpl(double degreesOfFreedom) {
         this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
     }
 
-    /**
-     * Modify the degrees of freedom.
-     * @param degreesOfFreedom the new degrees of freedom.
-     * @deprecated as of 2.1 (class will become immutable in 3.0)
-     */
-    @Deprecated
-    public void setDegreesOfFreedom(double degreesOfFreedom) {
-        setDegreesOfFreedomInternal(degreesOfFreedom);
-    }
-    /**
-     * Modify the degrees of freedom.
-     * @param newDegreesOfFreedom the new degrees of freedom.
-     */
-    private void setDegreesOfFreedomInternal(double newDegreesOfFreedom) {
-        if (newDegreesOfFreedom <= 0.0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM,
-                  newDegreesOfFreedom);
-        }
-        this.degreesOfFreedom = newDegreesOfFreedom;
-    }
-
     /**
      * Access the degrees of freedom.
+     *
      * @return the degrees of freedom.
      */
     public double getDegreesOfFreedom() {
@@ -104,30 +85,28 @@ public class TDistributionImpl
     }
 
     /**
-     * Returns the probability density for a particular point.
-     *
-     * @param x The point at which the density should be computed.
-     * @return The pdf at point x.
-     * @since 2.1
+     * {@inheritDoc}
      */
     @Override
     public double density(double x) {
         final double n = degreesOfFreedom;
         final double nPlus1Over2 = (n + 1) / 2;
-        return FastMath.exp(Gamma.logGamma(nPlus1Over2) - 0.5 * (FastMath.log(FastMath.PI) + FastMath.log(n)) -
-                Gamma.logGamma(n/2) - nPlus1Over2 * FastMath.log(1 + x * x /n));
+        return FastMath.exp(Gamma.logGamma(nPlus1Over2) -
+                            0.5 * (FastMath.log(FastMath.PI) + FastMath.log(n)) -
+                            Gamma.logGamma(n/2) - nPlus1Over2 * FastMath.log(1 + x * x /n));
     }
 
     /**
-     * For this distribution, X, this method returns P(X &lt; <code>x</code>).
-     * @param x the value at which the CDF is evaluated.
-     * @return CDF evaluated at <code>x</code>.
+     * For this distribution, X, this method returns {@code P(X < x}).
+     *
+     * @param x Value at which the CDF is evaluated.
+     * @return CDF evaluated at {@code x}.
      * @throws MathException if the cumulative probability can not be
-     *            computed due to convergence or other numerical errors.
+     * computed due to convergence or other numerical errors.
      */
     public double cumulativeProbability(double x) throws MathException{
         double ret;
-        if (x == 0.0) {
+        if (x == 0) {
             ret = 0.5;
         } else {
             double t =
@@ -146,18 +125,17 @@ public class TDistributionImpl
     }
 
     /**
-     * For this distribution, X, this method returns the critical point x, such
-     * that P(X &lt; x) = <code>p</code>.
-     * <p>
-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and
-     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
+     * For this distribution, {@code X}, this method returns the critical
+     * point {@code x}, such that {@code P(X < x) = p}.
+     * Returns {@code Double.NEGATIVE_INFINITY} when p = 0 and
+     * {@code Double.POSITIVE_INFINITY} when p = 1.
      *
-     * @param p the desired probability
-     * @return x, such that P(X &lt; x) = <code>p</code>
-     * @throws MathException if the inverse cumulative probability can not be
-     *         computed due to convergence or other numerical errors.
-     * @throws IllegalArgumentException if <code>p</code> is not a valid
-     *         probability.
+     * @param p Desired probability.
+     * @return {@code x}, such that {@code P(X < x) = p}.
+     * @throws MathException if the inverse cumulative probability cannot be
+     * computed due to convergence or other numerical errors.
+     * @throws org.apache.commons.math.exception.OutOfRangeException if
+     * {@code p} is not a valid probability.
      */
     @Override
     public double inverseCumulativeProbability(final double p)
@@ -172,13 +150,12 @@ public class TDistributionImpl
     }
 
     /**
-     * Access the domain value lower bound, based on <code>p</code>, used to
+     * Access the domain value lower bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value lower bound, i.e.
-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>
+     * @param p Desired probability for the critical value
+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') > p}.
      */
     @Override
     protected double getDomainLowerBound(double p) {
@@ -186,13 +163,12 @@ public class TDistributionImpl
     }
 
     /**
-     * Access the domain value upper bound, based on <code>p</code>, used to
+     * Access the domain value upper bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value upper bound, i.e.
-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
      */
     @Override
     protected double getDomainUpperBound(double p) {
@@ -200,23 +176,23 @@ public class TDistributionImpl
     }
 
     /**
-     * Access the initial domain value, based on <code>p</code>, used to
+     * Access the initial domain value, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return initial domain value
+     * @param p Desired probability for the critical value.
+     * @return the initial domain value.
      */
     @Override
     protected double getInitialDomain(double p) {
-        return 0.0;
+        return 0;
     }
 
     /**
      * Return the absolute accuracy setting of the solver used to estimate
      * inverse cumulative probabilities.
      *
-     * @return the solver absolute accuracy
+     * @return the solver absolute accuracy.
      * @since 2.1
      */
     @Override
diff --git a/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java
index 834ffb234..a25d1e3af 100644
--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java
@@ -35,32 +35,17 @@ package org.apache.commons.math.distribution;
  * @version $Revision$ $Date$
  */
 public interface WeibullDistribution extends ContinuousDistribution {
-
     /**
      * Access the shape parameter.
+     *
      * @return the shape parameter.
      */
     double getShape();
 
     /**
      * Access the scale parameter.
+     *
      * @return the scale parameter.
      */
     double getScale();
-
-    /**
-     * Modify the shape parameter.
-     * @param alpha The new shape parameter value.
-     * @deprecated as of v2.1
-     */
-    @Deprecated
-    void setShape(double alpha);
-
-    /**
-     * Modify the scale parameter.
-     * @param beta The new scale parameter value.
-     * @deprecated as of v2.1
-     */
-    @Deprecated
-    void setScale(double beta);
 }
diff --git a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java
index 706986e48..bc7e6432b 100644
--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java
+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java
@@ -19,7 +19,8 @@ package org.apache.commons.math.distribution;
 
 import java.io.Serializable;
 
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.OutOfRangeException;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.FastMath;
 
@@ -32,55 +33,64 @@ import org.apache.commons.math.util.FastMath;
  */
 public class WeibullDistributionImpl extends AbstractContinuousDistribution
         implements WeibullDistribution, Serializable {
-
     /**
      * Default inverse cumulative probability accuracy
      * @since 2.1
      */
     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
-
     /** Serializable version identifier */
     private static final long serialVersionUID = 8589540077390120676L;
-
     /** The shape parameter. */
     private double shape;
-
     /** The scale parameter. */
     private double scale;
-
-    /** Inverse cumulative probability accuracy */
+    /** Inverse cumulative probability accuracy. */
     private final double solverAbsoluteAccuracy;
 
     /**
-     * Creates weibull distribution with the given shape and scale and a
+     * Create a Weibull distribution with the given shape and scale and a
      * location equal to zero.
-     * @param alpha the shape parameter.
-     * @param beta the scale parameter.
+     *
+     * @param alpha Shape parameter.
+     * @param beta Scale parameter.
      */
-    public WeibullDistributionImpl(double alpha, double beta){
+    public WeibullDistributionImpl(double alpha, double beta) {
         this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
     }
 
     /**
-     * Creates weibull distribution with the given shape, scale and inverse
+     * Create a Weibull distribution with the given shape, scale and inverse
      * cumulative probability accuracy and a location equal to zero.
-     * @param alpha the shape parameter.
-     * @param beta the scale parameter.
-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates
-     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})
+     *
+     * @param alpha Shape parameter.
+     * @param beta Scale parameter.
+     * @param inverseCumAccuracy Maximum absolute error in inverse
+     * cumulative probability estimates
+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).
+     * @throws NotStrictlyPositiveException if {@code alpha <= 0} or
+     * {@code beta <= 0}.
      * @since 2.1
      */
-    public WeibullDistributionImpl(double alpha, double beta, double inverseCumAccuracy){
-        super();
-        setShapeInternal(alpha);
-        setScaleInternal(beta);
+    public WeibullDistributionImpl(double alpha, double beta,
+                                   double inverseCumAccuracy) {
+        if (alpha <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE,
+                                                   alpha);
+        }
+        if (beta <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.SCALE,
+                                                   beta);
+        }
+        scale = beta;
+        shape = alpha;
         solverAbsoluteAccuracy = inverseCumAccuracy;
     }
 
     /**
-     * For this distribution, X, this method returns P(X &lt; <code>x</code>).
-     * @param x the value at which the CDF is evaluated.
-     * @return CDF evaluted at <code>x</code>.
+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.
+     *
+     * @param x Value at which the CDF is evaluated.
+     * @return the CDF evaluted at {@code x}.
      */
     public double cumulativeProbability(double x) {
         double ret;
@@ -93,27 +103,21 @@ public class WeibullDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * Access the shape parameter.
-     * @return the shape parameter.
+     * {@inheritDoc}
      */
     public double getShape() {
         return shape;
     }
 
     /**
-     * Access the scale parameter.
-     * @return the scale parameter.
+     * {@inheritDoc}
      */
     public double getScale() {
         return scale;
     }
 
     /**
-     * Returns the probability density for a particular point.
-     *
-     * @param x The point at which the density should be computed.
-     * @return The pdf at point x.
-     * @since 2.1
+     * {@inheritDoc}
      */
     @Override
     public double density(double x) {
@@ -135,23 +139,20 @@ public class WeibullDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * For this distribution, X, this method returns the critical point x, such
-     * that P(X &lt; x) = <code>p</code>.
-     * <p>
-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and
-     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>
+     * For this distribution, {@code X}, this method returns the critical
+     * point {@code x}, such that {@code P(X < x) = p}.
+     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and
+     * {@code Double.POSITIVE_INFINITY} when p = 1.
      *
-     * @param p the desired probability
-     * @return x, such that P(X &lt; x) = <code>p</code>
-     * @throws IllegalArgumentException if <code>p</code> is not a valid
-     *         probability.
+     * @param p Desired probability.
+     * @return {@code x}, such that {@code P(X < x) = p}.
+     * @throws OutOfRangeException if {@code p} is not a valid probability.
      */
     @Override
     public double inverseCumulativeProbability(double p) {
         double ret;
         if (p < 0.0 || p > 1.0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);
+            throw new OutOfRangeException(p, 0.0, 1.0);
         } else if (p == 0) {
             ret = 0.0;
         } else  if (p == 1) {
@@ -162,72 +163,27 @@ public class WeibullDistributionImpl extends AbstractContinuousDistribution
         return ret;
     }
 
-    /**
-     * Modify the shape parameter.
-     * @param alpha the new shape parameter value.
-     * @deprecated as of 2.1 (class will become immutable in 3.0)
-     */
-    @Deprecated
-    public void setShape(double alpha) {
-        setShapeInternal(alpha);
-    }
-    /**
-     * Modify the shape parameter.
-     * @param alpha the new shape parameter value.
-     */
-    private void setShapeInternal(double alpha) {
-        if (alpha <= 0.0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.NOT_POSITIVE_SHAPE,
-                  alpha);
-        }
-        this.shape = alpha;
-    }
-
-    /**
-     * Modify the scale parameter.
-     * @param beta the new scale parameter value.
-     * @deprecated as of 2.1 (class will become immutable in 3.0)
-     */
-    @Deprecated
-    public void setScale(double beta) {
-        setScaleInternal(beta);
-    }
-    /**
-     * Modify the scale parameter.
-     * @param beta the new scale parameter value.
-     */
-    private void setScaleInternal(double beta) {
-        if (beta <= 0.0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.NOT_POSITIVE_SCALE,
-                  beta);
-        }
-        this.scale = beta;
-    }
 
     /**
-     * Access the domain value lower bound, based on <code>p</code>, used to
+     * Access the domain value lower bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value lower bound, i.e.
-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.
      */
     @Override
     protected double getDomainLowerBound(double p) {
-        return 0.0;
+        return 0;
     }
 
     /**
-     * Access the domain value upper bound, based on <code>p</code>, used to
+     * Access the domain value upper bound, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return domain value upper bound, i.e.
-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>
+     * @param p Desired probability for the critical value.
+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
      */
     @Override
     protected double getDomainUpperBound(double p) {
@@ -235,12 +191,12 @@ public class WeibullDistributionImpl extends AbstractContinuousDistribution
     }
 
     /**
-     * Access the initial domain value, based on <code>p</code>, used to
+     * Access the initial domain value, based on {@code p}, used to
      * bracket a CDF root.  This method is used by
      * {@link #inverseCumulativeProbability(double)} to find critical values.
      *
-     * @param p the desired probability for the critical value
-     * @return initial domain value
+     * @param p Desired probability for the critical value.
+     * @return the initial domain value.
      */
     @Override
     protected double getInitialDomain(double p) {
@@ -252,7 +208,7 @@ public class WeibullDistributionImpl extends AbstractContinuousDistribution
      * Return the absolute accuracy setting of the solver used to estimate
      * inverse cumulative probabilities.
      *
-     * @return the solver absolute accuracy
+     * @return the solver absolute accuracy.
      * @since 2.1
      */
     @Override
diff --git a/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java b/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java
index 268fcb50c..8c7835450 100644
--- a/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java
+++ b/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java
@@ -17,6 +17,7 @@
 package org.apache.commons.math.exception;
 
 import org.apache.commons.math.exception.util.LocalizedFormats;
+import org.apache.commons.math.exception.util.Localizable;
 
 /**
  * Exception to be thrown when some argument is out of range.
@@ -44,10 +45,28 @@ public class OutOfRangeException extends MathIllegalNumberException {
     public OutOfRangeException(Number wrong,
                                Number lo,
                                Number hi) {
-        super(LocalizedFormats.OUT_OF_RANGE_SIMPLE, wrong, lo, hi);
+        this(null, wrong, lo, hi);
+    }
+
+    /**
+     * Construct an exception from the mismatched dimensions with a
+     * specific context information.
+     *
+     * @param specific Context information.
+     * @param wrong Requested value.
+     * @param lo Lower bound.
+     * @param hi Higher bound.
+     */
+    public OutOfRangeException(Localizable specific,
+                               Number wrong,
+                               Number lo,
+                               Number hi) {
+        super(specific, LocalizedFormats.OUT_OF_RANGE_SIMPLE,
+              wrong, lo, hi);
         this.lo = lo;
         this.hi = hi;
     }
+
     /**
      * @return the lower bound.
      */
diff --git a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java
index e2f61b11a..966e6542c 100644
--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java
+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java
@@ -174,6 +174,7 @@ public enum LocalizedFormats implements Localizable {
     BETA("beta"), /* keep */
     NOT_POSITIVE_COLUMNDIMENSION("invalid column dimension: {0} (must be positive)"),
     NOT_POSITIVE_DEFINITE_MATRIX("not positive definite matrix"),
+    DEGREES_OF_FREEDOM("degrees of freedom ({0})"), /* keep */
     NOT_POSITIVE_DEGREES_OF_FREEDOM("degrees of freedom must be positive ({0})"),
     NOT_POSITIVE_ELEMENT_AT_INDEX("element {0} is not positive: {1}"),
     NOT_POSITIVE_EXPONENT("invalid exponent {0} (must be positive)"),
@@ -190,7 +191,9 @@ public enum LocalizedFormats implements Localizable {
     NOT_POSITIVE_ROW_DIMENSION("invalid row dimension: {0} (must be positive)"),
     NOT_POSITIVE_SAMPLE_SIZE("sample size must be positive ({0})"),
     NOT_POSITIVE_SCALE("scale must be positive ({0})"),
+    SCALE("scale ({0})"), /* keep */
     NOT_POSITIVE_SHAPE("shape must be positive ({0})"),
+    SHAPE("shape ({0})"), /* keep */
     NOT_POSITIVE_STANDARD_DEVIATION("standard deviation must be positive ({0})"),
     STANDARD_DEVIATION("standard deviation ({0})"), /* keep */
     NOT_POSITIVE_UPPER_BOUND("upper bound must be positive ({0})"),
@@ -238,6 +241,7 @@ public enum LocalizedFormats implements Localizable {
     OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY("observed counts are both zero for entry {0}"),
     OUT_OF_BOUNDS_QUANTILE_VALUE("out of bounds quantile value: {0}, must be in (0, 100]"),
     OUT_OF_BOUND_SIGNIFICANCE_LEVEL("out of bounds significance level {0}, must be between {1} and {2}"),
+    SIGNIFICANCE_LEVEL("significance level ({0})"), /* keep */
     OUT_OF_ORDER_ABSCISSA_ARRAY("the abscissae array must be sorted in a strictly increasing order, but the {0}-th element is {1} whereas {2}-th is {3}"),
     OUT_OF_RANGE_ROOT_OF_UNITY_INDEX("out of range root of unity index {0} (must be in [{1};{2}])"),
     OUT_OF_RANGE_SIMPLE("{0} out of [{1}, {2}] range"), /* keep */
diff --git a/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java
index 20a81a187..534c001f2 100644
--- a/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java
+++ b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java
@@ -17,7 +17,9 @@
 package org.apache.commons.math.stat.inference;
 
 import org.apache.commons.math.MathException;
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.OutOfRangeException;
+import org.apache.commons.math.exception.NullArgumentException;
+import org.apache.commons.math.exception.NumberIsTooSmallException;
 import org.apache.commons.math.distribution.TDistribution;
 import org.apache.commons.math.distribution.TDistributionImpl;
 import org.apache.commons.math.exception.util.LocalizedFormats;
@@ -34,28 +36,6 @@ import org.apache.commons.math.util.FastMath;
  * @version $Revision$ $Date$
  */
 public class TTestImpl implements TTest  {
-
-    /** Distribution used to compute inference statistics. */
-    private TDistribution distribution;
-
-    /**
-     * Default constructor.
-     */
-    public TTestImpl() {
-        this(new TDistributionImpl(1.0));
-    }
-
-    /**
-     * Create a test instance using the given distribution for computing
-     * inference statistics.
-     * @param t distribution used to compute inference statistics.
-     * @since 1.2
-     */
-    public TTestImpl(TDistribution t) {
-        super();
-        setDistribution(t);
-    }
-
     /**
      * Computes a paired, 2-sample t-statistic based on the data in the input
      * arrays.  The t-statistic returned is equivalent to what would be returned by
@@ -82,8 +62,8 @@ public class TTestImpl implements TTest  {
         checkSampleData(sample2);
         double meanDifference = StatUtils.meanDifference(sample1, sample2);
         return t(meanDifference, 0,
-                StatUtils.varianceDifference(sample1, sample2, meanDifference),
-                sample1.length);
+                 StatUtils.varianceDifference(sample1, sample2, meanDifference),
+                 sample1.length);
     }
 
      /**
@@ -873,8 +853,9 @@ public class TTestImpl implements TTest  {
      * @throws MathException if an error occurs performing the test
      */
     public boolean tTest(StatisticalSummary sampleStats1,
-            StatisticalSummary sampleStats2, double alpha)
-    throws IllegalArgumentException, MathException {
+                         StatisticalSummary sampleStats2,
+                         double alpha)
+        throws MathException {
         checkSignificanceLevel(alpha);
         return tTest(sampleStats1, sampleStats2) < alpha;
     }
@@ -956,9 +937,9 @@ public class TTestImpl implements TTest  {
      * @throws MathException if an error occurs computing the p-value
      */
     protected double tTest(double m, double mu, double v, double n)
-    throws MathException {
+        throws MathException {
         double t = FastMath.abs(t(m, mu, v, n));
-        distribution.setDegreesOfFreedom(n - 1);
+        TDistribution distribution = new TDistributionImpl(n - 1);
         return 2.0 * distribution.cumulativeProbability(-t);
     }
 
@@ -977,13 +958,14 @@ public class TTestImpl implements TTest  {
      * @return p-value
      * @throws MathException if an error occurs computing the p-value
      */
-    protected double tTest(double m1, double m2, double v1, double v2,
-            double n1, double n2)
-    throws MathException {
+    protected double tTest(double m1, double m2,
+                           double v1, double v2,
+                           double n1, double n2)
+        throws MathException {
         double t = FastMath.abs(t(m1, m2, v1, v2, n1, n2));
         double degreesOfFreedom = 0;
         degreesOfFreedom = df(v1, v2, n1, n2);
-        distribution.setDegreesOfFreedom(degreesOfFreedom);
+        TDistribution distribution = new TDistributionImpl(degreesOfFreedom);
         return 2.0 * distribution.cumulativeProbability(-t);
     }
 
@@ -1002,61 +984,60 @@ public class TTestImpl implements TTest  {
      * @return p-value
      * @throws MathException if an error occurs computing the p-value
      */
-    protected double homoscedasticTTest(double m1, double m2, double v1,
-            double v2, double n1, double n2)
-    throws MathException {
+    protected double homoscedasticTTest(double m1, double m2,
+                                        double v1, double v2,
+                                        double n1, double n2)
+        throws MathException {
         double t = FastMath.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));
         double degreesOfFreedom = n1 + n2 - 2;
-        distribution.setDegreesOfFreedom(degreesOfFreedom);
+        TDistribution distribution = new TDistributionImpl(degreesOfFreedom);
         return 2.0 * distribution.cumulativeProbability(-t);
     }
 
     /**
-     * Modify the distribution used to compute inference statistics.
-     * @param value the new distribution
-     * @since 1.2
-     */
-    public void setDistribution(TDistribution value) {
-        distribution = value;
-    }
-
-    /** Check significance level.
+     * Check significance level.
+     *
      * @param alpha significance level
-     * @exception IllegalArgumentException if significance level is out of bounds
+     * @throws OutOfRangeException if the significance level is out of bounds.
      */
-    private void checkSignificanceLevel(final double alpha)
-        throws IllegalArgumentException {
-        if ((alpha <= 0) || (alpha > 0.5)) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,
-                  alpha, 0.0, 0.5);
+    private void checkSignificanceLevel(final double alpha) {
+        if (alpha <= 0 || alpha > 0.5) {
+            throw new OutOfRangeException(LocalizedFormats.SIGNIFICANCE_LEVEL,
+                                          alpha, 0.0, 0.5);
         }
     }
 
-    /** Check sample data.
-     * @param data sample data
-     * @exception IllegalArgumentException if there is not enough sample data
+    /**
+     * Check sample data.
+     *
+     * @param data Sample data.
+     * @throws NullArgumentException if {@code data} is {@code null}.
+     * @throws NumberIsTooSmallException if there is not enough sample data.
      */
-    private void checkSampleData(final double[] data)
-        throws IllegalArgumentException {
-        if ((data == null) || (data.length < 2)) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,
-                  (data == null) ? 0 : data.length);
+    private void checkSampleData(final double[] data) {
+        if (data == null) {
+            throw new NullArgumentException();
+        }
+        if (data.length < 2) {
+            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,
+                                                data.length, 2, true);
         }
     }
 
-    /** Check sample data.
-     * @param stat statistical summary
-     * @exception IllegalArgumentException if there is not enough sample data
+    /**
+     * Check sample data.
+     *
+     * @param stat Statistical summary.
+     * @throws NullArgumentException if {@code data} is {@code null}.
+     * @throws NumberIsTooSmallException if there is not enough sample data.
      */
-    private void checkSampleData(final StatisticalSummary stat)
-        throws IllegalArgumentException {
-        if ((stat == null) || (stat.getN() < 2)) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,
-                  (stat == null) ? 0 : stat.getN());
+    private void checkSampleData(final StatisticalSummary stat) {
+        if (stat == null) {
+            throw new NullArgumentException();
+        }
+        if (stat.getN() < 2) {
+            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,
+                                                stat.getN(), 2, true);
         }
     }
-
 }
diff --git a/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java
index d5f8d5d69..cbc4f46f3 100644
--- a/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java
+++ b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java
@@ -19,7 +19,7 @@ package org.apache.commons.math.stat.regression;
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.OutOfRangeException;
 import org.apache.commons.math.distribution.TDistribution;
 import org.apache.commons.math.distribution.TDistributionImpl;
 import org.apache.commons.math.exception.util.LocalizedFormats;
@@ -93,18 +93,19 @@ public class SimpleRegression implements Serializable {
      * Create an empty SimpleRegression instance
      */
     public SimpleRegression() {
-        this(new TDistributionImpl(1.0));
+        this(1);
     }
 
     /**
      * Create an empty SimpleRegression using the given distribution object to
      * compute inference statistics.
-     * @param t the distribution used to compute inference statistics.
-     * @since 1.2
+     *
+     * @param degrees Number of degrees of freedom of the distribution used
+     * to compute inference statistics.
+     * @since 2.2
      */
-    public SimpleRegression(TDistribution t) {
-        super();
-        setDistribution(t);
+    public SimpleRegression(int degrees) {
+        distribution = new TDistributionImpl(degrees);
     }
 
     /**
@@ -138,7 +139,7 @@ public class SimpleRegression implements Serializable {
         n++;
 
         if (n > 2) {
-            distribution.setDegreesOfFreedom(n - 2);
+            distribution = new TDistributionImpl(n - 2);
         }
     }
 
@@ -170,7 +171,7 @@ public class SimpleRegression implements Serializable {
             n--;
 
             if (n > 2) {
-                distribution.setDegreesOfFreedom(n - 2);
+                distribution = new TDistributionImpl(n - 2);
             }
         }
     }
@@ -549,9 +550,8 @@ public class SimpleRegression implements Serializable {
     public double getSlopeConfidenceInterval(double alpha)
         throws MathException {
         if (alpha >= 1 || alpha <= 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,
-                  alpha, 0.0, 1.0);
+            throw new OutOfRangeException(LocalizedFormats.SIGNIFICANCE_LEVEL,
+                                          alpha, 0, 1);
         }
         return getSlopeStdErr() *
             distribution.inverseCumulativeProbability(1d - alpha / 2d);
@@ -606,18 +606,4 @@ public class SimpleRegression implements Serializable {
     private double getRegressionSumSquares(double slope) {
         return slope * slope * sumXX;
     }
-
-    /**
-     * Modify the distribution used to compute inference statistics.
-     * @param value the new distribution
-     * @since 1.2
-     */
-    public void setDistribution(TDistribution value) {
-        distribution = value;
-
-        // modify degrees of freedom
-        if (n > 2) {
-            distribution.setDegreesOfFreedom(n - 2);
-        }
-    }
 }
diff --git a/src/main/resources/META-INF/localization/LocalizedFormats_fr.properties b/src/main/resources/META-INF/localization/LocalizedFormats_fr.properties
index f05161f35..da723d608 100644
--- a/src/main/resources/META-INF/localization/LocalizedFormats_fr.properties
+++ b/src/main/resources/META-INF/localization/LocalizedFormats_fr.properties
@@ -147,6 +147,7 @@ BETA = beta
 NOT_POSITIVE_COLUMNDIMENSION = nombre de colonnes invalide : {0} (doit \u00eatre positif)
 NOT_POSITIVE_DEFINITE_MATRIX = matrice non d\u00e9finie positive
 NOT_POSITIVE_DEGREES_OF_FREEDOM = les degr\u00e9s de libert\u00e9 doivent \u00eatre positifs ({0})
+DEGREES_OF_FREEDOM = degr\u00e9s de libert\u00e9 ({0})
 NOT_POSITIVE_ELEMENT_AT_INDEX = l''\u00e9l\u00e9ment {0} n''est pas positif : {1}
 NOT_POSITIVE_EXPONENT = exposant {0} invalide (doit \u00eatre positif)
 NOT_POSITIVE_LENGTH = la longueur doit \u00eatre positive ({0})
@@ -162,7 +163,9 @@ NOT_POSITIVE_POPULATION_SIZE = la taille de la population doit \u00eatre positiv
 NOT_POSITIVE_ROW_DIMENSION = nombre de lignes invalide : {0} (doit \u00eatre positif)
 NOT_POSITIVE_SAMPLE_SIZE = la taille de l''\u00e9chantillon doit \u00eatre positive ({0})
 NOT_POSITIVE_SCALE = l''\u00e9chelle doit \u00eatre positive ({0})
+SCALE = facteur d''\u00e9chelle ({0})
 NOT_POSITIVE_SHAPE = le facteur de forme doit \u00eatre positif ({0})
+SHAPE = facteur de forme ({0})
 NOT_POSITIVE_STANDARD_DEVIATION = l''\u00e9cart type doit \u00eatre positif ({0})
 STANDARD_DEVIATION = \u00e9cart type
 NOT_POSITIVE_UPPER_BOUND = la borne sup\u00e9rieure doit \u00eatre positive ({0})
@@ -210,6 +213,7 @@ OBSERVED_COUNTS_ALL_ZERO = aucune occurrence dans le tableau des observations {0
 OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY = les occurrences observ\u00e9es sont toutes deux nulles pour l''entr\u00e9e {0}
 OUT_OF_BOUNDS_QUANTILE_VALUE = valeur de quantile {0} hors bornes, doit \u00eatre dans l''intervalle ]0, 100]
 OUT_OF_BOUND_SIGNIFICANCE_LEVEL = niveau de signification {0} hors domaine, doit \u00eatre entre {1} et {2}
+SIGNIFICANCE_LEVEL = niveau de signification ({0})
 OUT_OF_ORDER_ABSCISSA_ARRAY = les abscisses doivent \u00eatre en ordre strictement croissant, mais l''\u00e9l\u00e9ment {0} vaut {1} alors que l''\u00e9l\u00e9ment {2} vaut {3}
 OUT_OF_RANGE_ROOT_OF_UNITY_INDEX = l''indice de racine de l''unit\u00e9 {0} est hors du domaine autoris\u00e9 [{1};{2}]
 OUT_OF_RANGE_SIMPLE = {0} hors du domaine [{1}, {2}]
diff --git a/src/site/xdoc/changes.xml b/src/site/xdoc/changes.xml
index 9dafcb353..71160793d 100644
--- a/src/site/xdoc/changes.xml
+++ b/src/site/xdoc/changes.xml
@@ -53,7 +53,7 @@ The <action> type attribute can be add,update,fix,remove.
      -->
     <release version="3.0" date="TBD" description="TBD">
       <action dev="erans" type="fix" issue="MATH-349">
-        "ChiSquaredDistributionImpl" and "PoissonDistributionImpl" are immutable.
+        All distribution classes (in package "distribution") are immutable.
       </action>
       <action dev="erans" type="update" issue="MATH-195">
         Created "MatrixDimensionMismatch" to replace "InvalidMatrixException"
diff --git a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java
index 8dad7e858..4440e3edd 100644
--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java
@@ -18,6 +18,7 @@
 package org.apache.commons.math.distribution;
 
 import org.apache.commons.math.util.FastMath;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 
 /**
  * Test cases for CauchyDistribution.
@@ -85,32 +86,27 @@ public class CauchyDistributionTest extends ContinuousDistributionAbstractTest
 
     public void testMedian() {
         CauchyDistribution distribution = (CauchyDistribution) getDistribution();
-        double expected = FastMath.random();
-        distribution.setMedian(expected);
-        assertEquals(expected, distribution.getMedian(), 0.0);
+        assertEquals(1.2, distribution.getMedian(), 0.0);
     }
 
     public void testScale() {
         CauchyDistribution distribution = (CauchyDistribution) getDistribution();
-        double expected = FastMath.random();
-        distribution.setScale(expected);
-        assertEquals(expected, distribution.getScale(), 0.0);
+        assertEquals(2.1, distribution.getScale(), 0.0);
     }
 
-    public void testSetScale() {
-        CauchyDistribution distribution = (CauchyDistribution) getDistribution();
+    public void testPreconditions() {
+        CauchyDistribution dist;
         try {
-            distribution.setScale(0.0);
-            fail("Can not have 0.0 scale.");
-        } catch (IllegalArgumentException ex) {
-            // success
+            dist = new CauchyDistributionImpl(0, 0);
+            fail("Cannot have zero scale");
+        } catch (NotStrictlyPositiveException ex) {
+            // Expected.
         }
-
         try {
-            distribution.setScale(-1.0);
-            fail("Can not have negative scale.");
-        } catch (IllegalArgumentException ex) {
-            // success
+            dist = new CauchyDistributionImpl(0, -1);
+            fail("Cannot have negative scale");
+        } catch (NotStrictlyPositiveException ex) {
+            // Expected.
         }
     }
 }
diff --git a/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java
index c69dcd60e..ce567d488 100644
--- a/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.commons.math.distribution;
 
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 
 /**
  * Test cases for FDistribution.
@@ -85,48 +86,43 @@ public class FDistributionTest extends ContinuousDistributionAbstractTest {
     }
 
     public void testDfAccessors() {
-        FDistribution distribution = (FDistribution) getDistribution();
-        assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);
-        distribution.setNumeratorDegreesOfFreedom(4d);
-        assertEquals(4d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);
-        assertEquals(6d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);
-        distribution.setDenominatorDegreesOfFreedom(4d);
-        assertEquals(4d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);
+        FDistribution dist = (FDistribution) getDistribution();
+        assertEquals(5d, dist.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);
+        assertEquals(6d, dist.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);
+    }
+
+    public void testPreconditions() {
+        FDistribution dist;
         try {
-            distribution.setNumeratorDegreesOfFreedom(0d);
-            fail("Expecting IllegalArgumentException for df = 0");
-        } catch (IllegalArgumentException ex) {
-            // expected
+            dist = new FDistributionImpl(0, 1);
+            fail("Expecting NotStrictlyPositiveException for df = 0");
+        } catch (NotStrictlyPositiveException ex) {
+            // Expected.
         }
         try {
-            distribution.setDenominatorDegreesOfFreedom(0d);
-            fail("Expecting IllegalArgumentException for df = 0");
-        } catch (IllegalArgumentException ex) {
-            // expected
+            dist = new FDistributionImpl(1, 0);
+            fail("Expecting NotStrictlyPositiveException for df = 0");
+        } catch (NotStrictlyPositiveException ex) {
+            // Expected.
         }
     }
 
     public void testLargeDegreesOfFreedom() throws Exception {
-        org.apache.commons.math.distribution.FDistributionImpl fd =
-            new org.apache.commons.math.distribution.FDistributionImpl(
-                100000., 100000.);
+        FDistributionImpl fd = new FDistributionImpl(100000, 100000);
         double p = fd.cumulativeProbability(.999);
         double x = fd.inverseCumulativeProbability(p);
         assertEquals(.999, x, 1.0e-5);
     }
 
     public void testSmallDegreesOfFreedom() throws Exception {
-        org.apache.commons.math.distribution.FDistributionImpl fd =
-            new org.apache.commons.math.distribution.FDistributionImpl(
-                1.0, 1.0);
+        FDistributionImpl fd = new FDistributionImpl(1, 1);
         double p = fd.cumulativeProbability(0.975);
         double x = fd.inverseCumulativeProbability(p);
         assertEquals(0.975, x, 1.0e-5);
 
-        fd.setDenominatorDegreesOfFreedom(2.0);
+        fd = new FDistributionImpl(1, 2);
         p = fd.cumulativeProbability(0.975);
         x = fd.inverseCumulativeProbability(p);
         assertEquals(0.975, x, 1.0e-5);
     }
-
 }
diff --git a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java
index 9c9fd75de..4b386d0af 100644
--- a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java
@@ -16,6 +16,8 @@
  */
 package org.apache.commons.math.distribution;
 
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
+
 /**
  * Test cases for TDistribution.
  * Extends ContinuousDistributionAbstractTest.  See class javadoc for
@@ -104,16 +106,16 @@ public class TDistributionTest extends ContinuousDistributionAbstractTest {
     }
 
     public void testDfAccessors() {
-        TDistribution distribution = (TDistribution) getDistribution();
-        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);
-        distribution.setDegreesOfFreedom(4d);
-        assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);
+        TDistribution dist = (TDistribution) getDistribution();
+        assertEquals(5d, dist.getDegreesOfFreedom(), Double.MIN_VALUE);
+    }
+
+    public void testPreconditions() {
         try {
-            distribution.setDegreesOfFreedom(0d);
-            fail("Expecting IllegalArgumentException for df = 0");
-        } catch (IllegalArgumentException ex) {
+            TDistribution dist = new TDistributionImpl(0);
+            fail("Expecting NotStrictlyPositiveException for df = 0");
+        } catch (NotStrictlyPositiveException ex) {
             // expected
         }
     }
-
 }
diff --git a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java
index cfd8cd963..bf78ec0a7 100644
--- a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java
@@ -18,6 +18,7 @@
 package org.apache.commons.math.distribution;
 
 import org.apache.commons.math.util.FastMath;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 
 /**
  * Test cases for WeibullDistribution.
@@ -75,50 +76,24 @@ public class WeibullDistributionTest extends ContinuousDistributionAbstractTest
     }
 
     public void testAlpha() {
-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();
-        double expected = FastMath.random();
-        distribution.setShape(expected);
-        assertEquals(expected, distribution.getShape(), 0.0);
-    }
-
-    public void testBeta() {
-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();
-        double expected = FastMath.random();
-        distribution.setScale(expected);
-        assertEquals(expected, distribution.getScale(), 0.0);
-    }
-
-    public void testSetAlpha() {
-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();
-        try {
-            distribution.setShape(0.0);
-            fail("Can not have 0.0 alpha.");
-        } catch (IllegalArgumentException ex) {
-            // success
-        }
-
+        WeibullDistribution dist = new WeibullDistributionImpl(1, 2);
+        assertEquals(1, dist.getShape(), 0);
         try {
-            distribution.setShape(-1.0);
-            fail("Can not have negative alpha.");
-        } catch (IllegalArgumentException ex) {
-            // success
+            dist = new WeibullDistributionImpl(0, 2);
+            fail("NotStrictlyPositiveException expected");
+        } catch (NotStrictlyPositiveException e) {
+            // Expected.
         }
     }
 
-    public void testSetBeta() {
-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();
-        try {
-            distribution.setScale(0.0);
-            fail("Can not have 0.0 beta.");
-        } catch (IllegalArgumentException ex) {
-            // success
-        }
-
+    public void testBeta() {
+        WeibullDistribution dist = new WeibullDistributionImpl(1, 2);
+        assertEquals(2, dist.getScale(), 0);
         try {
-            distribution.setScale(-1.0);
-            fail("Can not have negative beta.");
-        } catch (IllegalArgumentException ex) {
-            // success
+            dist = new WeibullDistributionImpl(1, 0);
+            fail("NotStrictlyPositiveException expected");
+        } catch (NotStrictlyPositiveException e) {
+            // Expected.
         }
     }
 }
