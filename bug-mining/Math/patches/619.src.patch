diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSet.java
index e8bffbcf4..00d1f70fa 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSet.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSet.java
@@ -644,7 +644,11 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
                 for (ConnectableSegment s = getUnprocessed(segments); s != null; s = getUnprocessed(segments)) {
                     final List<Segment> loop = followLoop(s);
                     if (loop != null) {
-                        if (loop.get(0).getStart() == null) {
+                    	// an open loop is one that has fewer than two segments or has a null
+                    	// start point; the case where we have two segments in a closed loop
+                    	// (ie, an infinitely thin, degenerate loop) will result in null being
+                    	// returned from the followLoops method
+                        if (loop.size() < 2 || loop.get(0).getStart() == null) {
                             // this is an open loop, we put it on the front
                             loops.add(0, loop);
                         } else {
@@ -863,18 +867,22 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
      * @param loop segments loop to filter (will be modified in-place)
      */
     private void filterSpuriousVertices(final List<Segment> loop) {
-        for (int i = 0; i < loop.size(); ++i) {
-            final Segment previous = loop.get(i);
-            int j = (i + 1) % loop.size();
-            final Segment next = loop.get(j);
-            if (next != null &&
-                Precision.equals(previous.getLine().getAngle(), next.getLine().getAngle(), Precision.EPSILON)) {
-                // the vertex between the two edges is a spurious one
-                // replace the two segments by a single one
-                loop.set(j, new Segment(previous.getStart(), next.getEnd(), previous.getLine()));
-                loop.remove(i--);
-            }
-        }
+    	// we need at least 2 segments in order for one of the contained vertices
+    	// to be unnecessary
+    	if (loop.size() > 1) { 
+	        for (int i = 0; i < loop.size(); ++i) {
+	            final Segment previous = loop.get(i);
+	            int j = (i + 1) % loop.size();
+	            final Segment next = loop.get(j);
+	            if (next != null &&
+	                Precision.equals(previous.getLine().getAngle(), next.getLine().getAngle(), Precision.EPSILON)) {
+	                // the vertex between the two edges is a spurious one
+	                // replace the two segments by a single one
+	                loop.set(j, new Segment(previous.getStart(), next.getEnd(), previous.getLine()));
+	                loop.remove(i--);
+	            }
+	        }
+    	}
     }
 
     /** Private extension of Segment allowing connection. */
@@ -1067,23 +1075,26 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
         /** Select the node whose cut sub-hyperplane is closest to specified point.
          * @param point reference point
          * @param candidates candidate nodes
-         * @return node closest to point, or null if no node is closer than tolerance
+         * @return node closest to point, or null if point is null or no node is closer than tolerance
          */
         private BSPTree<Euclidean2D> selectClosest(final Cartesian2D point, final Iterable<BSPTree<Euclidean2D>> candidates) {
-
-            BSPTree<Euclidean2D> selected = null;
-            double min = Double.POSITIVE_INFINITY;
-
-            for (final BSPTree<Euclidean2D> node : candidates) {
-                final double distance = FastMath.abs(node.getCut().getHyperplane().getOffset(point));
-                if (distance < min) {
-                    selected = node;
-                    min      = distance;
-                }
-            }
-
-            return min <= tolerance ? selected : null;
-
+        	if (point != null) {
+	            BSPTree<Euclidean2D> selected = null;
+	            double min = Double.POSITIVE_INFINITY;
+	
+	            for (final BSPTree<Euclidean2D> node : candidates) {
+	                final double distance = FastMath.abs(node.getCut().getHyperplane().getOffset(point));
+	                if (distance < min) {
+	                    selected = node;
+	                    min      = distance;
+	                }
+	            }
+	
+	            if (min <= tolerance) {
+	            	return selected;
+	            }
+        	}
+        	return null;
         }
 
         /** Get the segments.
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSetTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSetTest.java
index 041958550..cdb9d7153 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSetTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/PolygonsSetTest.java
@@ -95,6 +95,61 @@ public class PolygonsSetTest {
         PolygonsSet box = new PolygonsSet(new BSPTree<Euclidean2D>(Boolean.TRUE), 1.0e-10);
         Assert.assertTrue(Double.isInfinite(box.getSize()));
     }
+    
+    @Test
+    public void testSingleInfiniteLine() {
+    	// arrange
+        double tolerance = 1e-10;
+        Line line = new Line(new Cartesian2D(0, 0), new Cartesian2D(1, 1), tolerance);
+        
+        List<SubHyperplane<Euclidean2D>> boundaries = new ArrayList<SubHyperplane<Euclidean2D>>();
+        boundaries.add(line.wholeHyperplane());
+        
+        // act
+        PolygonsSet polygon = new PolygonsSet(boundaries, tolerance);
+        
+        // assert
+        Assert.assertTrue(Double.isInfinite(polygon.getSize()));
+        
+        Cartesian2D[][] vertices = polygon.getVertices();
+        Assert.assertEquals(1, vertices.length);
+        
+        Cartesian2D[] loop = vertices[0];
+        Assert.assertEquals(3, loop.length);
+        Assert.assertEquals(null, loop[0]);
+        checkPointsEqual(line.toSpace(new Cartesian1D(-Float.MAX_VALUE)), loop[1], tolerance);
+        checkPointsEqual(line.toSpace(new Cartesian1D(Float.MAX_VALUE)), loop[2], tolerance);
+    }
+    
+    @Test
+    public void testMixOfFiniteAndInfiniteBoundaries() {
+    	// arrange
+        double tolerance = 1e-10;
+        
+        Line line = new Line(new Cartesian2D(1, 0), new Cartesian2D(1, 1), tolerance);
+     
+        List<SubHyperplane<Euclidean2D>> boundaries = new ArrayList<SubHyperplane<Euclidean2D>>();
+        boundaries.add(buildSegment(new Cartesian2D(0, 1), new Cartesian2D(0, 0)));
+        boundaries.add(buildSegment(new Cartesian2D(0, 0), new Cartesian2D(1, 0)));
+        boundaries.add(new SubLine(line, new IntervalsSet(0, Double.POSITIVE_INFINITY, tolerance)));
+        
+        // act
+        PolygonsSet polygon = new PolygonsSet(boundaries, tolerance);
+
+        // assert
+        Assert.assertTrue(Double.isInfinite(polygon.getSize()));
+        
+        Cartesian2D[][] vertices = polygon.getVertices();
+        Assert.assertEquals(1, vertices.length);
+        
+        Cartesian2D[] loop = vertices[0];
+        Assert.assertEquals(5, loop.length);
+        Assert.assertEquals(null, loop[0]);
+        checkPointsEqual(new Cartesian2D(0, 1), loop[1], tolerance);
+        checkPointsEqual(new Cartesian2D(0, 0), loop[2], tolerance);
+        checkPointsEqual(new Cartesian2D(1, 0), loop[3], tolerance);
+        checkPointsEqual(new Cartesian2D(1, 0), loop[4], tolerance);
+    }
 
     @Test
     public void testStair() {
@@ -1272,6 +1327,11 @@ public class PolygonsSetTest {
         double upper = (line.toSubSpace(end)).getX();
         return new SubLine(line, new IntervalsSet(lower, upper, 1.0e-10));
     }
+    
+    private void checkPointsEqual(Cartesian2D expected, Cartesian2D actual, double tolerance) {
+        Assert.assertEquals(expected.getX(), actual.getX(), tolerance);
+        Assert.assertEquals(expected.getY(), actual.getY(), tolerance);
+    }
 
     private void checkPoints(Region.Location expected, PolygonsSet set,
                              Cartesian2D[] points) {
