diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Cartesian2D.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Cartesian2D.java
index 027232236..51109d08b 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Cartesian2D.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Cartesian2D.java
@@ -149,7 +149,7 @@ public class Cartesian2D implements Point<Euclidean2D>, Vector<Euclidean2D> {
 
     /** Get the abscissa of the vector.
      * @return abscissa of the vector
-     * @see #Vector2D(double, double)
+     * @see #Cartesian2D(double, double)
      */
     public double getX() {
         return x;
@@ -157,7 +157,7 @@ public class Cartesian2D implements Point<Euclidean2D>, Vector<Euclidean2D> {
 
     /** Get the ordinate of the vector.
      * @return ordinate of the vector
-     * @see #Vector2D(double, double)
+     * @see #Cartesian2D(double, double)
      */
     public double getY() {
         return y;
@@ -165,7 +165,7 @@ public class Cartesian2D implements Point<Euclidean2D>, Vector<Euclidean2D> {
 
     /** Get the vector coordinates as a dimension 2 array.
      * @return vector coordinates
-     * @see #Vector2D(double[])
+     * @see #Cartesian2D(double[])
      */
     public double[] toArray() {
         return new double[] { x, y };
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Line.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Line.java
index 36f09984e..561cdc7c4 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Line.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/Line.java
@@ -202,8 +202,8 @@ public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euc
      * instance.</p>
      * <p>
      * As long as neither the instance nor its reverse are modified
-     * (i.e. as long as none of the {@link #reset(Vector2D, Vector2D)},
-     * {@link #reset(Vector2D, double)}, {@link #revertSelf()},
+     * (i.e. as long as none of the {@link #reset(Cartesian2D, Cartesian2D)},
+     * {@link #reset(Cartesian2D, double)}, {@link #revertSelf()},
      * {@link #setAngle(double)} or {@link #setOriginOffset(double)}
      * methods are called), then the line and its reverse remain linked
      * together so that {@code line.getReverse().getReverse() == line}.
diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoops.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoops.java
index 3a5038eab..dcfc76a9e 100644
--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoops.java
+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/twod/NestedLoops.java
@@ -165,7 +165,7 @@ class NestedLoops {
 
     /** Correct the orientation of the loops contained in the tree.
      * <p>This is this method that really inverts the loops that where
-     * provided through the {@link #add(Vector2D[]) add} method if
+     * provided through the {@link #add(Cartesian2D[]) add} method if
      * they are mis-oriented</p>
      */
     public void correctOrientation() {
diff --git a/src/site/design/twoD.puml b/src/site/design/twoD.puml
index b7f02d728..fb738bb58 100644
--- a/src/site/design/twoD.puml
+++ b/src/site/design/twoD.puml
@@ -64,13 +64,13 @@
       package twod #DDDBD8 {
 
         class Euclidean2D
-        class Vector2D
+        class Cartesian2D
         class Line
         class SubLine
         class PolygonsSet
 
         Space            <|.. Euclidean2D
-        Vector_S_        <|.. Vector2D
+        Vector_S_        <|.. Cartesian2D
         Hyperplane_S_    <|.. Line
         SubHyperplane_S_ <|.. SubLine
         Region_S_        <|.. PolygonsSet
diff --git a/src/site/xdoc/userguide/geometry.xml b/src/site/xdoc/userguide/geometry.xml
index ab9c55131..6c76e3b12 100644
--- a/src/site/xdoc/userguide/geometry.xml
+++ b/src/site/xdoc/userguide/geometry.xml
@@ -77,8 +77,8 @@
       <subsection name="11.2 Euclidean spaces" href="euclidean">
         <p>
           <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/oned/Vector1D.html">
-          Vector1D</a>, <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/twod/Vector2D.html">
-          Vector2D</a> and <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/threed/Cartesian3D.html">
+          Vector1D</a>, <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/twod/Cartesian2D.html">
+          Cartesian2D</a> and <a href="../apidocs/org/apache/commons/math4/geometry/euclidean/threed/Cartesian3D.html">
           Cartesian3D</a> provide simple vector types. One important feature is
           that instances of these classes are guaranteed
           to be immutable, this greatly simplifies modeling dynamical systems
diff --git a/src/site/xdoc/userguide/leastsquares.xml b/src/site/xdoc/userguide/leastsquares.xml
index 8da9e78a6..35cd27bbf 100644
--- a/src/site/xdoc/userguide/leastsquares.xml
+++ b/src/site/xdoc/userguide/leastsquares.xml
@@ -306,12 +306,12 @@
         </p>
         <source>
   final double radius = 70.0;
-  final Vector2D[] observedPoints = new Vector2D[] {
-      new Vector2D( 30.0,  68.0),
-      new Vector2D( 50.0,  -6.0),
-      new Vector2D(110.0, -20.0),
-      new Vector2D( 35.0,  15.0),
-      new Vector2D( 45.0,  97.0)
+  final Cartesian2D[] observedPoints = new Cartesian2D[] {
+      new Cartesian2D( 30.0,  68.0),
+      new Cartesian2D( 50.0,  -6.0),
+      new Cartesian2D(110.0, -20.0),
+      new Cartesian2D( 35.0,  15.0),
+      new Cartesian2D( 45.0,  97.0)
   };
 
   // the model function components are the distances to current estimated center,
@@ -319,14 +319,14 @@
   MultivariateJacobianFunction distancesToCurrentCenter = new MultivariateJacobianFunction() {
       public Pair&lt;RealVector, RealMatrix&gt; value(final RealVector point) {
 
-          Vector2D center = new Vector2D(point.getEntry(0), point.getEntry(1));
+          Cartesian2D center = new Cartesian2D(point.getEntry(0), point.getEntry(1));
 
           RealVector value = new ArrayRealVector(observedPoints.length);
           RealMatrix jacobian = new Array2DRowRealMatrix(observedPoints.length, 2);
 
           for (int i = 0; i &lt; observedPoints.length; ++i) {
-              Vector2D o = observedPoints[i];
-              double modelI = Vector2D.distance(o, center);
+              Cartesian2D o = observedPoints[i];
+              double modelI = Cartesian2D.distance(o, center);
               value.setEntry(i, modelI);
               // derivative with respect to p0 = x center
               jacobian.setEntry(i, 0, (center.getX() - o.getX()) / modelI);
@@ -353,7 +353,7 @@
                                 maxIterations(1000).
                                 build();
   LeastSquaresOptimizer.Optimum optimum = new LevenbergMarquardtOptimizer().optimize(problem);
-  Vector2D fittedCenter = new Vector2D(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));
+  Cartesian2D fittedCenter = new Cartesian2D(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));
   System.out.println("fitted center: " + fittedCenter.getX() + " " + fittedCenter.getY());
   System.out.println("RMS: "           + optimum.getRMS());
   System.out.println("evaluations: "   + optimum.getEvaluations());
diff --git a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DTest.java b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Cartesian2DTest.java
similarity index 99%
rename from src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DTest.java
rename to src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Cartesian2DTest.java
index cb760b247..924a4efb1 100644
--- a/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Vector2DTest.java
+++ b/src/test/java/org/apache/commons/math4/geometry/euclidean/twod/Cartesian2DTest.java
@@ -22,7 +22,7 @@ import org.apache.commons.math4.util.FastMath;
 import org.junit.Assert;
 import org.junit.Test;
 
-public class Vector2DTest {
+public class Cartesian2DTest {
 
     private static final double EPS = Math.ulp(1d);
 
diff --git a/src/userguide/java/org/apache/commons/math4/userguide/ClusterAlgorithmComparison.java b/src/userguide/java/org/apache/commons/math4/userguide/ClusterAlgorithmComparison.java
index 035c2e92a..3c5ddd1fd 100644
--- a/src/userguide/java/org/apache/commons/math4/userguide/ClusterAlgorithmComparison.java
+++ b/src/userguide/java/org/apache/commons/math4/userguide/ClusterAlgorithmComparison.java
@@ -40,7 +40,7 @@ import org.apache.commons.rng.sampling.ListSampler;
 import org.apache.commons.math4.distribution.RealDistribution;
 import org.apache.commons.math4.distribution.UniformRealDistribution;
 import org.apache.commons.math4.distribution.NormalDistribution;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D;
 import org.apache.commons.math4.ml.clustering.CentroidCluster;
 import org.apache.commons.math4.ml.clustering.Cluster;
 import org.apache.commons.math4.ml.clustering.Clusterable;
@@ -61,7 +61,7 @@ import org.apache.commons.math4.userguide.ExampleUtils.ExampleFrame;
  */
 public class ClusterAlgorithmComparison {
 
-    public static List<Vector2D> makeCircles(int samples,
+    public static List<Cartesian2D> makeCircles(int samples,
                                              boolean shuffle,
                                              double noise,
                                              double factor,
@@ -72,12 +72,12 @@ public class ClusterAlgorithmComparison {
         
         RealDistribution.Sampler dist = new NormalDistribution(0.0, noise).createSampler(rng);
 
-        List<Vector2D> points = new ArrayList<Vector2D>();
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>();
         double range = 2.0 * FastMath.PI;
         double step = range / (samples / 2.0 + 1);
         for (double angle = 0; angle < range; angle += step) {
-            Vector2D outerCircle = new Vector2D(FastMath.cos(angle), FastMath.sin(angle));
-            Vector2D innerCircle = outerCircle.scalarMultiply(factor);
+            Cartesian2D outerCircle = new Cartesian2D(FastMath.cos(angle), FastMath.sin(angle));
+            Cartesian2D innerCircle = outerCircle.scalarMultiply(factor);
             
             points.add(outerCircle.add(generateNoiseVector(dist)));
             points.add(innerCircle.add(generateNoiseVector(dist)));
@@ -90,7 +90,7 @@ public class ClusterAlgorithmComparison {
         return points;
     }
 
-    public static List<Vector2D> makeMoons(int samples,
+    public static List<Cartesian2D> makeMoons(int samples,
                                            boolean shuffle,
                                            double noise,
                                            UniformRandomProvider rng) {
@@ -99,17 +99,17 @@ public class ClusterAlgorithmComparison {
         int nSamplesOut = samples / 2;
         int nSamplesIn = samples - nSamplesOut;
         
-        List<Vector2D> points = new ArrayList<Vector2D>();
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>();
         double range = FastMath.PI;
         double step = range / (nSamplesOut / 2.0);
         for (double angle = 0; angle < range; angle += step) {
-            Vector2D outerCircle = new Vector2D(FastMath.cos(angle), FastMath.sin(angle));
+            Cartesian2D outerCircle = new Cartesian2D(FastMath.cos(angle), FastMath.sin(angle));
             points.add(outerCircle.add(generateNoiseVector(dist)));
         }
 
         step = range / (nSamplesIn / 2.0);
         for (double angle = 0; angle < range; angle += step) {
-            Vector2D innerCircle = new Vector2D(1 - FastMath.cos(angle), 1 - FastMath.sin(angle) - 0.5);
+            Cartesian2D innerCircle = new Cartesian2D(1 - FastMath.cos(angle), 1 - FastMath.sin(angle) - 0.5);
             points.add(innerCircle.add(generateNoiseVector(dist)));
         }
         
@@ -120,7 +120,7 @@ public class ClusterAlgorithmComparison {
         return points;
     }
 
-    public static List<Vector2D> makeBlobs(int samples,
+    public static List<Cartesian2D> makeBlobs(int samples,
                                            int centers,
                                            double clusterStd,
                                            double min,
@@ -130,9 +130,9 @@ public class ClusterAlgorithmComparison {
         RealDistribution.Sampler uniform = new UniformRealDistribution(min, max).createSampler(rng);
         RealDistribution.Sampler gauss = new NormalDistribution(0.0, clusterStd).createSampler(rng);
 
-        Vector2D[] centerPoints = new Vector2D[centers];
+        Cartesian2D[] centerPoints = new Cartesian2D[centers];
         for (int i = 0; i < centers; i++) {
-            centerPoints[i] = new Vector2D(uniform.sample(), uniform.sample());
+            centerPoints[i] = new Cartesian2D(uniform.sample(), uniform.sample());
         }
         
         int[] nSamplesPerCenter = new int[centers];
@@ -143,7 +143,7 @@ public class ClusterAlgorithmComparison {
             nSamplesPerCenter[i]++;
         }
         
-        List<Vector2D> points = new ArrayList<Vector2D>();
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>();
         for (int i = 0; i < centers; i++) {
             for (int j = 0; j < nSamplesPerCenter[i]; j++) {
                 points.add(centerPoints[i].add(generateNoiseVector(gauss)));
@@ -157,26 +157,26 @@ public class ClusterAlgorithmComparison {
         return points;
     }
     
-    public static List<Vector2D> makeRandom(int samples) {
+    public static List<Cartesian2D> makeRandom(int samples) {
         SobolSequenceGenerator generator = new SobolSequenceGenerator(2);
         generator.skipTo(999999);
-        List<Vector2D> points = new ArrayList<Vector2D>();
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>();
         for (double i = 0; i < samples; i++) {
             double[] vector = generator.nextVector();
             vector[0] = vector[0] * 2 - 1;
             vector[1] = vector[1] * 2 - 1;
-            Vector2D point = new Vector2D(vector);
+            Cartesian2D point = new Cartesian2D(vector);
             points.add(point);
         }
         
         return points;
     }
 
-    public static Vector2D generateNoiseVector(RealDistribution.Sampler distribution) {
-        return new Vector2D(distribution.sample(), distribution.sample());
+    public static Cartesian2D generateNoiseVector(RealDistribution.Sampler distribution) {
+        return new Cartesian2D(distribution.sample(), distribution.sample());
     }
     
-    public static List<DoublePoint> normalize(final List<Vector2D> input,
+    public static List<DoublePoint> normalize(final List<Cartesian2D> input,
                                               double minX,
                                               double maxX,
                                               double minY,
@@ -184,7 +184,7 @@ public class ClusterAlgorithmComparison {
         double rangeX = maxX - minX;
         double rangeY = maxY - minY;
         List<DoublePoint> points = new ArrayList<DoublePoint>();
-        for (Vector2D p : input) {
+        for (Cartesian2D p : input) {
             double[] arr = p.toArray();
             arr[0] = (arr[0] - minX) / rangeX * 2 - 1;
             arr[1] = (arr[1] - minY) / rangeY * 2 - 1;
diff --git a/src/userguide/java/org/apache/commons/math4/userguide/LowDiscrepancyGeneratorComparison.java b/src/userguide/java/org/apache/commons/math4/userguide/LowDiscrepancyGeneratorComparison.java
index e43cba4b0..12b3be392 100644
--- a/src/userguide/java/org/apache/commons/math4/userguide/LowDiscrepancyGeneratorComparison.java
+++ b/src/userguide/java/org/apache/commons/math4/userguide/LowDiscrepancyGeneratorComparison.java
@@ -35,9 +35,8 @@ import javax.swing.JTextArea;
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.rng.simple.RandomSource;
 
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D;
 import org.apache.commons.math4.random.HaltonSequenceGenerator;
-import org.apache.commons.math4.random.RandomGenerator;
 import org.apache.commons.math4.random.RandomVectorGenerator;
 import org.apache.commons.math4.random.SobolSequenceGenerator;
 import org.apache.commons.math4.random.UncorrelatedRandomVectorGenerator;
@@ -51,11 +50,11 @@ import org.apache.commons.math4.userguide.ExampleUtils.ExampleFrame;
  */
 public class LowDiscrepancyGeneratorComparison {
 
-    public static List<Vector2D> makeCircle(int samples, final RandomVectorGenerator generator) {
-        List<Vector2D> points = new ArrayList<Vector2D>();
+    public static List<Cartesian2D> makeCircle(int samples, final RandomVectorGenerator generator) {
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>();
         for (double i = 0; i < samples; i++) {
             double[] vector = generator.nextVector();
-            Vector2D point = new Vector2D(vector);
+            Cartesian2D point = new Cartesian2D(vector);
             points.add(point);
         }
 
@@ -63,8 +62,8 @@ public class LowDiscrepancyGeneratorComparison {
         points = normalize(points);
         
         // now test if the sample is within the unit circle
-        List<Vector2D> circlePoints = new ArrayList<Vector2D>();
-        for (Vector2D p : points) {
+        List<Cartesian2D> circlePoints = new ArrayList<Cartesian2D>();
+        for (Cartesian2D p : points) {
             double criteria = FastMath.pow(p.getX(), 2) + FastMath.pow(p.getY(), 2);
             if (criteria < 1.0) {
                 circlePoints.add(p);
@@ -74,22 +73,22 @@ public class LowDiscrepancyGeneratorComparison {
         return circlePoints;
     }
 
-    public static List<Vector2D> makeRandom(int samples, RandomVectorGenerator generator) {
-        List<Vector2D> points = new ArrayList<Vector2D>();
+    public static List<Cartesian2D> makeRandom(int samples, RandomVectorGenerator generator) {
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>();
         for (double i = 0; i < samples; i++) {
             double[] vector = generator.nextVector();
-            Vector2D point = new Vector2D(vector);
+            Cartesian2D point = new Cartesian2D(vector);
             points.add(point);
         }
         
         return normalize(points);
     }
 
-    public static List<Vector2D> normalize(final List<Vector2D> input) {
+    public static List<Cartesian2D> normalize(final List<Cartesian2D> input) {
         // find the mininum and maximum x value in the dataset
         double minX = Double.MAX_VALUE;
         double maxX = Double.MIN_VALUE;
-        for (Vector2D p : input) {
+        for (Cartesian2D p : input) {
             minX = FastMath.min(minX, p.getX());
             maxX = FastMath.max(maxX, p.getX());
         }
@@ -107,13 +106,13 @@ public class LowDiscrepancyGeneratorComparison {
 
         double rangeX = maxX - minX;
         double rangeY = maxY - minY;
-        List<Vector2D> points = new ArrayList<Vector2D>();
-        for (Vector2D p : input) {
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>();
+        for (Cartesian2D p : input) {
             double[] arr = p.toArray();
             // normalize to the range [-1, 1]
             arr[0] = (arr[0] - minX) / rangeX * 2 - 1;
             arr[1] = (arr[1] - minY) / rangeY * 2 - 1;
-            points.add(new Vector2D(arr));
+            points.add(new Cartesian2D(arr));
         }
         return points;
     }
@@ -178,7 +177,7 @@ public class LowDiscrepancyGeneratorComparison {
                 c.gridx = 1;
 
                 for (Pair<String, RandomVectorGenerator> pair : generators) {
-                    List<Vector2D> points = null;
+                    List<Cartesian2D> points = null;
                     int samples = datasets[type];
                     switch (type) {
                         case 0:
@@ -208,9 +207,9 @@ public class LowDiscrepancyGeneratorComparison {
 
         private static double PAD = 10;
 
-        private List<Vector2D> points;
+        private List<Cartesian2D> points;
 
-        public Plot(final List<Vector2D> points) {
+        public Plot(final List<Cartesian2D> points) {
             this.points = points;
         }
         
@@ -229,8 +228,8 @@ public class LowDiscrepancyGeneratorComparison {
             g2.setPaint(Color.black);
             g2.drawRect(0, 0, w - 1, h - 1);
             
-            for (Vector2D point : points) {
-                Vector2D p = transform(point, w, h);
+            for (Cartesian2D point : points) {
+                Cartesian2D p = transform(point, w, h);
                 double[] arr = p.toArray();
                 g2.draw(new Rectangle2D.Double(arr[0] - 1, arr[1] - 1, 2, 2));
             }
@@ -241,9 +240,9 @@ public class LowDiscrepancyGeneratorComparison {
             return new Dimension(140, 140);
         }
 
-        private Vector2D transform(Vector2D point, int width, int height) {
+        private Cartesian2D transform(Cartesian2D point, int width, int height) {
             double[] arr = point.toArray();
-            return new Vector2D(new double[] { PAD + (arr[0] + 1) / 2.0 * (width - 2 * PAD),
+            return new Cartesian2D(new double[] { PAD + (arr[0] + 1) / 2.0 * (width - 2 * PAD),
                                                   height - PAD - (arr[1] + 1) / 2.0 * (height - 2 * PAD) });
         }
     }
diff --git a/src/userguide/java/org/apache/commons/math4/userguide/geometry/GeometryExample.java b/src/userguide/java/org/apache/commons/math4/userguide/geometry/GeometryExample.java
index fb8252271..4bbe7e6b0 100644
--- a/src/userguide/java/org/apache/commons/math4/userguide/geometry/GeometryExample.java
+++ b/src/userguide/java/org/apache/commons/math4/userguide/geometry/GeometryExample.java
@@ -40,7 +40,7 @@ import org.apache.commons.math4.geometry.enclosing.WelzlEncloser;
 import org.apache.commons.math4.geometry.euclidean.twod.DiskGenerator;
 import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
 import org.apache.commons.math4.geometry.euclidean.twod.Segment;
-import org.apache.commons.math4.geometry.euclidean.twod.Vector2D;
+import org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHullGenerator2D;
 import org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChain;
@@ -65,39 +65,39 @@ import org.piccolo2d.nodes.PText;
  */
 public class GeometryExample {
 
-    public static List<Vector2D> createRandomPoints(int size) {
+    public static List<Cartesian2D> createRandomPoints(int size) {
         final UniformRandomProvider random = RandomSource.create(RandomSource.MT);
 
         // create the cloud container
-        List<Vector2D> points = new ArrayList<Vector2D>(size);
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>(size);
         // fill the cloud with a random distribution of points
         for (int i = 0; i < size; i++) {
-            points.add(new Vector2D(FastMath.round(random.nextDouble() * 400 + 100),
+            points.add(new Cartesian2D(FastMath.round(random.nextDouble() * 400 + 100),
                     FastMath.round(random.nextDouble() * 400 + 100)));
         }
         
         return points;
     }
 
-    public static List<Vector2D> createCircle(int samples) {
-        List<Vector2D> points = new ArrayList<Vector2D>();
-        final Vector2D center = new Vector2D(300, 300);
+    public static List<Cartesian2D> createCircle(int samples) {
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>();
+        final Cartesian2D center = new Cartesian2D(300, 300);
         double range = 2.0 * FastMath.PI;
         double step = range / (samples + 1);
         for (double angle = 0; angle < range; angle += step) {
-            Vector2D circle = new Vector2D(FastMath.cos(angle), FastMath.sin(angle));
+            Cartesian2D circle = new Cartesian2D(FastMath.cos(angle), FastMath.sin(angle));
             points.add(circle.scalarMultiply(200).add(center));
         }
         
         return points;
     }
 
-    public static List<Vector2D> createCross() {
-        List<Vector2D> points = new ArrayList<Vector2D>();
+    public static List<Cartesian2D> createCross() {
+        List<Cartesian2D> points = new ArrayList<Cartesian2D>();
         
         for (int i = 100; i < 500; i += 10) {
-            points.add(new Vector2D(300, i));
-            points.add(new Vector2D(i, 300));
+            points.add(new Cartesian2D(300, i));
+            points.add(new Cartesian2D(i, 300));
         }
 
         return points;
@@ -150,7 +150,7 @@ public class GeometryExample {
     @SuppressWarnings("serial")
     public static class Display extends ExampleFrame {
 
-        private List<Vector2D> points;
+        private List<Cartesian2D> points;
         private PCanvas canvas;
         private JComponent container;
         private JComponent controlPanel;
@@ -223,7 +223,7 @@ public class GeometryExample {
         
         public void paintConvexHull() {
             PNode pointSet = new PNode();
-            for (Vector2D point : points) {
+            for (Cartesian2D point : points) {
                 final PNode node = PPath.createEllipse(point.getX() - 1, point.getY() - 1, 2, 2);
                 node.addAttribute("tooltip", point);
                 node.setPaint(Color.gray);
@@ -236,7 +236,7 @@ public class GeometryExample {
             ConvexHull2D hull = generator.generate(points); //AklToussaintHeuristic.reducePoints(points));
 
             PNode hullNode = new PNode();
-            for (Vector2D vertex : hull.getVertices()) {
+            for (Cartesian2D vertex : hull.getVertices()) {
                 final PPath node = PPath.createEllipse(vertex.getX() - 1, vertex.getY() - 1, 2, 2);
                 node.addAttribute("tooltip", vertex);
                 node.setPaint(Color.red);
@@ -255,9 +255,9 @@ public class GeometryExample {
 
             canvas.getLayer().addChild(hullNode);
 
-            Encloser<Euclidean2D, Vector2D> encloser =
-                    new WelzlEncloser<Euclidean2D, Vector2D>(1e-10, new DiskGenerator());
-            EnclosingBall<Euclidean2D, Vector2D> ball = encloser.enclose(points);
+            Encloser<Euclidean2D, Cartesian2D> encloser =
+                    new WelzlEncloser<Euclidean2D, Cartesian2D>(1e-10, new DiskGenerator());
+            EnclosingBall<Euclidean2D, Cartesian2D> ball = encloser.enclose(points);
 
             final double radius = ball.getRadius();
             PPath ballCenter =
