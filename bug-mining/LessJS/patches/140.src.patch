diff --git a/lib/less/tree/ruleset.js b/lib/less/tree/ruleset.js
index 7571b0e7..d657976d 100644
--- a/lib/less/tree/ruleset.js
+++ b/lib/less/tree/ruleset.js
@@ -111,20 +111,25 @@ tree.Ruleset.prototype = {
             rule = rsRules[i];
             if (! (rule instanceof tree.mixin.Definition || rule instanceof tree.DetachedRuleset)) {
                 rsRules[i] = rule = rule.eval ? rule.eval(env) : rule;
-                // for rulesets, check if it is a css guard and can be removed
-                if (rule instanceof tree.Ruleset && rule.selectors && rule.selectors.length === 1) {
-                    // check if it can be folded in (e.g. & where)
-                    if (rule.selectors[0].isJustParentSelector()) {
-                        rsRules.splice(i--, 1);
-                        // cannot call if there is no selector, so we can just continue
-                        if (!rule.selectors[0].evaldCondition) {
-                            continue;
-                        }
-                        for(var j = 0; j < rule.rules.length; j++) {
-                            subRule = rule.rules[j];
-                            if (!(subRule instanceof tree.Rule) || !subRule.variable) {
-                                rsRules.splice(++i, 0, subRule);
-                            }
+            }
+        }
+        
+        // Evaluate everything else
+        for (i = 0; i < rsRules.length; i++) {
+            rule = rsRules[i];
+            // for rulesets, check if it is a css guard and can be removed
+            if (rule instanceof tree.Ruleset && rule.selectors && rule.selectors.length === 1) {
+                // check if it can be folded in (e.g. & where)
+                if (rule.selectors[0].isJustParentSelector()) {
+                    rsRules.splice(i--, 1);
+                    // cannot call if there is no selector, so we can just continue
+                    if (!rule.selectors[0].evaldCondition) {
+                        continue;
+                    }
+                    for(var j = 0; j < rule.rules.length; j++) {
+                        subRule = rule.rules[j];
+                        if (!(subRule instanceof tree.Rule) || !subRule.variable) {
+                            rsRules.splice(++i, 0, subRule);
                         }
                     }
                 }
diff --git a/test/css/scope.css b/test/css/scope.css
index baa05523..0e4c17d5 100644
--- a/test/css/scope.css
+++ b/test/css/scope.css
@@ -33,3 +33,6 @@
   scope: 'top level';
   sub-scope-only: 'inside';
 }
+#parentSelectorScope {
+  prop: #ffffff;
+}
diff --git a/test/less/errors/mixin-not-visible-in-scope-1.less b/test/less/errors/mixin-not-visible-in-scope-1.less
new file mode 100644
index 00000000..2842613e
--- /dev/null
+++ b/test/less/errors/mixin-not-visible-in-scope-1.less
@@ -0,0 +1,9 @@
+.something {
+    & {
+        .a {value: a}
+    }
+
+    & {
+        .b {.a} // was Err. before 1.6.2
+    }
+}
\ No newline at end of file
diff --git a/test/less/errors/mixin-not-visible-in-scope-1.txt b/test/less/errors/mixin-not-visible-in-scope-1.txt
new file mode 100644
index 00000000..15e64dc2
--- /dev/null
+++ b/test/less/errors/mixin-not-visible-in-scope-1.txt
@@ -0,0 +1,4 @@
+NameError: .a is undefined in {path}mixin-not-visible-in-scope-1.less on line 7, column 13:
+6     & {
+7         .b {.a} // was Err. before 1.6.2
+8     }
diff --git a/test/less/scope.less b/test/less/scope.less
index 36d37061..475b1f6d 100644
--- a/test/less/scope.less
+++ b/test/less/scope.less
@@ -76,4 +76,29 @@
   @subScopeOnly: 'inside';
   //use the mixin
   .mixinNoParam();
+}
+#parentSelectorScope {
+  @col: white;
+  & {
+    @col: black;
+  }
+  prop: @col;
+  & {
+    @col: black;
+  }
+}
+.test-empty-mixin() {
+}
+#parentSelectorScopeMixins {
+  & {
+    .test-empty-mixin() {
+      should: never seee 1;
+    }
+  }
+  .test-empty-mixin();
+  & {
+    .test-empty-mixin() {
+      should: never seee 2;
+    }
+  }
 }
\ No newline at end of file
