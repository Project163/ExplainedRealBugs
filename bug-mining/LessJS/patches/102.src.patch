diff --git a/.jshintrc b/.jshintrc
index 2f830954..0d5dbf2a 100644
--- a/.jshintrc
+++ b/.jshintrc
@@ -3,7 +3,9 @@
     "boss": true,
     "expr": true,
     "laxbreak": true,
+    "latedef": true,
     "node": true,
+    "undef": true,
     "unused": "vars",
     "noarg": true
 }
diff --git a/lib/less/browser.js b/lib/less/browser.js
index cc8b8fe7..4e1c68cd 100644
--- a/lib/less/browser.js
+++ b/lib/less/browser.js
@@ -1,7 +1,7 @@
 //
 // browser.js - client-side engine
 //
-/*global less */
+/*global less, window, document, XMLHttpRequest, location */
 
 var isFileProtocol = /^(file|chrome(-extension)?|resource|qrc|app):/.test(location.protocol);
 
@@ -49,103 +49,241 @@ if (dumpLineNumbers) {
     less.dumpLineNumbers = dumpLineNumbers[1];
 }
 
-//
-// Watch mode
-//
-less.watch   = function () {
-    if (!less.watchMode ){
-        less.env = 'development';
-         initRunningMode();
-    }
-    return this.watchMode = true;
-};
-
-less.unwatch = function () {clearInterval(less.watchTimer); return this.watchMode = false; };
+var typePattern = /^text\/(x-)?less$/;
+var cache = null;
+var fileCache = {};
 
-function initRunningMode(){
-    if (less.env === 'development') {
-        less.optimization = 0;
-        less.watchTimer = setInterval(function () {
-            if (less.watchMode) {
-                loadStyleSheets(function (e, root, _, sheet, env) {
-                    if (e) {
-                        error(e, sheet.href);
-                    } else if (root) {
-                        createCSS(root.toCSS(less), sheet, env.lastModified);
-                    }
-                });
-            }
-        }, less.poll);
-    } else {
-        less.optimization = 3;
+function log(str, level) {
+    if (less.env == 'development' && typeof(console) !== 'undefined' && less.logLevel >= level) {
+        console.log('less: ' + str);
     }
 }
 
-if (/!watch/.test(location.hash)) {
-    less.watch();
+function extractId(href) {
+    return href.replace(/^[a-z-]+:\/+?[^\/]+/, '' )  // Remove protocol & domain
+        .replace(/^\//,                 '' )  // Remove root /
+        .replace(/\.[a-zA-Z]+$/,        '' )  // Remove simple extension
+        .replace(/[^\.\w-]+/g,          '-')  // Replace illegal characters
+        .replace(/\./g,                 ':'); // Replace dots with colons(for valid id)
 }
 
-var cache = null;
+function errorConsole(e, rootHref) {
+    var template = '{line} {content}';
+    var filename = e.filename || rootHref;
+    var errors = [];
+    var content = (e.type || "Syntax") + "Error: " + (e.message || 'There is an error in your .less file') +
+        " in " + filename + " ";
 
-if (less.env != 'development') {
-    try {
-        cache = (typeof(window.localStorage) === 'undefined') ? null : window.localStorage;
-    } catch (_) {}
+    var errorline = function (e, i, classname) {
+        if (e.extract[i] !== undefined) {
+            errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
+                .replace(/\{class\}/, classname)
+                .replace(/\{content\}/, e.extract[i]));
+        }
+    };
+
+    if (e.extract) {
+        errorline(e, 0, '');
+        errorline(e, 1, 'line');
+        errorline(e, 2, '');
+        content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':\n' +
+            errors.join('\n');
+    } else if (e.stack) {
+        content += e.stack;
+    }
+    log(content, logLevel.errors);
 }
 
-//
-// Get all <link> tags with the 'rel' attribute set to "stylesheet/less"
-//
-var links = document.getElementsByTagName('link');
-var typePattern = /^text\/(x-)?less$/;
+function createCSS(styles, sheet, lastModified) {
+    // Strip the query-string
+    var href = sheet.href || '';
 
-less.sheets = [];
+    // If there is no title set, use the filename, minus the extension
+    var id = 'less:' + (sheet.title || extractId(href));
 
-for (var i = 0; i < links.length; i++) {
-    if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&
-       (links[i].type.match(typePattern)))) {
-        less.sheets.push(links[i]);
+    // If this has already been inserted into the DOM, we may need to replace it
+    var oldCss = document.getElementById(id);
+    var keepOldCss = false;
+
+    // Create a new stylesheet node for insertion or (if necessary) replacement
+    var css = document.createElement('style');
+    css.setAttribute('type', 'text/css');
+    if (sheet.media) {
+        css.setAttribute('media', sheet.media);
     }
-}
+    css.id = id;
 
-//
-// With this function, it's possible to alter variables and re-render
-// CSS without reloading less-files
-//
-var fileCache = {};
-less.modifyVars = function(record) {
-    var newVars = "";
-    for (var name in record) {
-        newVars += ((name.slice(0,1) === '@')? '' : '@') + name +': '+
-                ((record[name].slice(-1) === ';')? record[name] : record[name] +';');
+    if (css.styleSheet) { // IE
+        try {
+            css.styleSheet.cssText = styles;
+        } catch (e) {
+            throw new(Error)("Couldn't reassign styleSheet.cssText.");
+        }
+    } else {
+        css.appendChild(document.createTextNode(styles));
+
+        // If new contents match contents of oldCss, don't replace oldCss
+        keepOldCss = (oldCss !== null && oldCss.childNodes.length > 0 && css.childNodes.length > 0 &&
+            oldCss.firstChild.nodeValue === css.firstChild.nodeValue);
     }
-    less.refresh(false, newVars);
-};
 
-less.refresh = function (reload, newVars) {
-    var startTime, endTime;
-    startTime = endTime = new Date();
+    var head = document.getElementsByTagName('head')[0];
 
-    loadStyleSheets(function (e, root, _, sheet, env) {
-        if (e) {
-            return error(e, sheet.href);
-        }
-        if (env.local) {
-            log("loading " + sheet.href + " from cache.", logLevel.info);
+    // If there is no oldCss, just append; otherwise, only append if we need
+    // to replace oldCss with an updated stylesheet
+    if (oldCss === null || keepOldCss === false) {
+        var nextEl = sheet && sheet.nextSibling || null;
+        if (nextEl) {
+            nextEl.parentNode.insertBefore(css, nextEl);
         } else {
-            log("parsed " + sheet.href + " successfully.", logLevel.info);
-            createCSS(root.toCSS(less), sheet, env.lastModified);
+            head.appendChild(css);
         }
-        log("css for " + sheet.href + " generated in " + (new Date() - endTime) + 'ms', logLevel.info);
-        if (env.remaining === 0) {
-            log("css generated in " + (new Date() - startTime) + 'ms', logLevel.info);
+    }
+    if (oldCss && keepOldCss === false) {
+        oldCss.parentNode.removeChild(oldCss);
+    }
+
+    // Don't update the local store if the file wasn't modified
+    if (lastModified && cache) {
+        log('saving ' + href + ' to cache.', logLevel.info);
+        try {
+            cache.setItem(href, styles);
+            cache.setItem(href + ':timestamp', lastModified);
+        } catch(e) {
+            //TODO - could do with adding more robust error handling
+            log('failed to save', logLevel.errors);
         }
-        endTime = new Date();
-    }, reload, newVars);
+    }
+}
 
-    loadStyles(newVars);
-};
-less.refreshStyles = loadStyles;
+function errorHTML(e, rootHref) {
+    var id = 'less-error-message:' + extractId(rootHref || "");
+    var template = '<li><label>{line}</label><pre class="{class}">{content}</pre></li>';
+    var elem = document.createElement('div'), timer, content, errors = [];
+    var filename = e.filename || rootHref;
+    var filenameNoPath = filename.match(/([^\/]+(\?.*)?)$/)[1];
+
+    elem.id        = id;
+    elem.className = "less-error-message";
+
+    content = '<h3>'  + (e.type || "Syntax") + "Error: " + (e.message || 'There is an error in your .less file') +
+        '</h3>' + '<p>in <a href="' + filename   + '">' + filenameNoPath + "</a> ";
+
+    var errorline = function (e, i, classname) {
+        if (e.extract[i] !== undefined) {
+            errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
+                .replace(/\{class\}/, classname)
+                .replace(/\{content\}/, e.extract[i]));
+        }
+    };
+
+    if (e.extract) {
+        errorline(e, 0, '');
+        errorline(e, 1, 'line');
+        errorline(e, 2, '');
+        content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':</p>' +
+            '<ul>' + errors.join('') + '</ul>';
+    } else if (e.stack) {
+        content += '<br/>' + e.stack.split('\n').slice(1).join('<br/>');
+    }
+    elem.innerHTML = content;
+
+    // CSS for error messages
+    createCSS([
+        '.less-error-message ul, .less-error-message li {',
+        'list-style-type: none;',
+        'margin-right: 15px;',
+        'padding: 4px 0;',
+        'margin: 0;',
+        '}',
+        '.less-error-message label {',
+        'font-size: 12px;',
+        'margin-right: 15px;',
+        'padding: 4px 0;',
+        'color: #cc7777;',
+        '}',
+        '.less-error-message pre {',
+        'color: #dd6666;',
+        'padding: 4px 0;',
+        'margin: 0;',
+        'display: inline-block;',
+        '}',
+        '.less-error-message pre.line {',
+        'color: #ff0000;',
+        '}',
+        '.less-error-message h3 {',
+        'font-size: 20px;',
+        'font-weight: bold;',
+        'padding: 15px 0 5px 0;',
+        'margin: 0;',
+        '}',
+        '.less-error-message a {',
+        'color: #10a',
+        '}',
+        '.less-error-message .error {',
+        'color: red;',
+        'font-weight: bold;',
+        'padding-bottom: 2px;',
+        'border-bottom: 1px dashed red;',
+        '}'
+    ].join('\n'), { title: 'error-message' });
+
+    elem.style.cssText = [
+        "font-family: Arial, sans-serif",
+        "border: 1px solid #e00",
+        "background-color: #eee",
+        "border-radius: 5px",
+        "-webkit-border-radius: 5px",
+        "-moz-border-radius: 5px",
+        "color: #e00",
+        "padding: 15px",
+        "margin-bottom: 15px"
+    ].join(';');
+
+    if (less.env == 'development') {
+        timer = setInterval(function () {
+            if (document.body) {
+                if (document.getElementById(id)) {
+                    document.body.replaceChild(elem, document.getElementById(id));
+                } else {
+                    document.body.insertBefore(elem, document.body.firstChild);
+                }
+                clearInterval(timer);
+            }
+        }, 10);
+    }
+}
+
+function error(e, rootHref) {
+    if (!less.errorReporting || less.errorReporting === "html") {
+        errorHTML(e, rootHref);
+    } else if (less.errorReporting === "console") {
+        errorConsole(e, rootHref);
+    } else if (typeof less.errorReporting === 'function') {
+        less.errorReporting("add", e, rootHref);
+    }
+}
+
+function removeErrorHTML(path) {
+    var node = document.getElementById('less-error-message:' + extractId(path));
+    if (node) {
+        node.parentNode.removeChild(node);
+    }
+}
+
+function removeErrorConsole(path) {
+    //no action
+}
+
+function removeError(path) {
+    if (!less.errorReporting || less.errorReporting === "html") {
+        removeErrorHTML(path);
+    } else if (less.errorReporting === "console") {
+        removeErrorConsole(path);
+    } else if (typeof less.errorReporting === 'function') {
+        less.errorReporting("remove", path);
+    }
+}
 
 function loadStyles(newVars) {
     var styles = document.getElementsByTagName('style'),
@@ -182,36 +320,6 @@ function loadStyles(newVars) {
     }
 }
 
-function loadStyleSheets(callback, reload, newVars) {
-    for (var i = 0; i < less.sheets.length; i++) {
-        loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), newVars);
-    }
-}
-
-function pathDiff(url, baseUrl) {
-    // diff between two paths to create a relative path
-
-    var urlParts = extractUrlParts(url),
-        baseUrlParts = extractUrlParts(baseUrl),
-        i, max, urlDirectories, baseUrlDirectories, diff = "";
-    if (urlParts.hostPart !== baseUrlParts.hostPart) {
-        return "";
-    }
-    max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);
-    for(i = 0; i < max; i++) {
-        if (baseUrlParts.directories[i] !== urlParts.directories[i]) { break; }
-    }
-    baseUrlDirectories = baseUrlParts.directories.slice(i);
-    urlDirectories = urlParts.directories.slice(i);
-    for(i = 0; i < baseUrlDirectories.length-1; i++) {
-        diff += "../";
-    }
-    for(i = 0; i < urlDirectories.length-1; i++) {
-        diff += urlDirectories[i] + "/";
-    }
-    return diff;
-}
-
 function extractUrlParts(url, baseUrl) {
     // urlParts[1] = protocol&hostname || /
     // urlParts[2] = / if path relative to host base
@@ -266,51 +374,80 @@ function extractUrlParts(url, baseUrl) {
     return returner;
 }
 
-function loadStyleSheet(sheet, callback, reload, remaining, newVars) {
-
-    var env = new less.tree.parseEnv(less);
-    env.mime = sheet.type;
+function pathDiff(url, baseUrl) {
+    // diff between two paths to create a relative path
 
-    if (newVars) {
-        env.useFileCache = true;
+    var urlParts = extractUrlParts(url),
+        baseUrlParts = extractUrlParts(baseUrl),
+        i, max, urlDirectories, baseUrlDirectories, diff = "";
+    if (urlParts.hostPart !== baseUrlParts.hostPart) {
+        return "";
     }
+    max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);
+    for(i = 0; i < max; i++) {
+        if (baseUrlParts.directories[i] !== urlParts.directories[i]) { break; }
+    }
+    baseUrlDirectories = baseUrlParts.directories.slice(i);
+    urlDirectories = urlParts.directories.slice(i);
+    for(i = 0; i < baseUrlDirectories.length-1; i++) {
+        diff += "../";
+    }
+    for(i = 0; i < urlDirectories.length-1; i++) {
+        diff += urlDirectories[i] + "/";
+    }
+    return diff;
+}
 
-    loadFile(sheet.href, null, function(e, data, path, newFileInfo, webInfo) {
+function getXMLHttpRequest() {
+    if (window.XMLHttpRequest) {
+        return new XMLHttpRequest();
+    } else {
+        try {
+            /*global ActiveXObject */
+            return new ActiveXObject("MSXML2.XMLHTTP.3.0");
+        } catch (e) {
+            log("browser doesn't support AJAX.", logLevel.errors);
+            return null;
+        }
+    }
+}
 
-        if (webInfo) {
-            webInfo.remaining = remaining;
+function doXHR(url, type, callback, errback) {
+    var xhr = getXMLHttpRequest();
+    var async = isFileProtocol ? less.fileAsync : less.async;
 
-            var css       = cache && cache.getItem(path),
-                timestamp = cache && cache.getItem(path + ':timestamp');
+    if (typeof(xhr.overrideMimeType) === 'function') {
+        xhr.overrideMimeType('text/css');
+    }
+    log("XHR: Getting '" + url + "'", logLevel.info);
+    xhr.open('GET', url, async);
+    xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');
+    xhr.send(null);
 
-            if (!reload && timestamp && webInfo.lastModified &&
-                (new(Date)(webInfo.lastModified).valueOf() ===
-                    new(Date)(timestamp).valueOf())) {
-                // Use local copy
-                createCSS(css, sheet);
-                webInfo.local = true;
-                callback(null, null, data, sheet, webInfo, path);
-                return;
-            }
+    function handleResponse(xhr, callback, errback) {
+        if (xhr.status >= 200 && xhr.status < 300) {
+            callback(xhr.responseText,
+                xhr.getResponseHeader("Last-Modified"));
+        } else if (typeof(errback) === 'function') {
+            errback(xhr.status, url);
         }
+    }
 
-        //TODO add tests around how this behaves when reloading
-        removeError(path);
-
-        if (data) {
-            env.currentFileInfo = newFileInfo;
-            new(less.Parser)(env).parse(data, function (e, root) {
-                if (e) { return callback(e, null, null, sheet); }
-                try {
-                    callback(e, root, data, sheet, webInfo, path);
-                } catch (e) {
-                    callback(e, null, null, sheet);
-                }
-            });
+    if (isFileProtocol && !less.fileAsync) {
+        if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
+            callback(xhr.responseText);
         } else {
-            callback(e, null, null, sheet, webInfo, path);
+            errback(xhr.status, url);
         }
-    }, env, newVars);
+    } else if (async) {
+        xhr.onreadystatechange = function () {
+            if (xhr.readyState == 4) {
+                handleResponse(xhr, callback, errback);
+            }
+        };
+    } else {
+        handleResponse(xhr, callback, errback);
+    }
 }
 
 function loadFile(originalHref, currentFileInfo, callback, env, newVars) {
@@ -324,9 +461,9 @@ function loadFile(originalHref, currentFileInfo, callback, env, newVars) {
     var hrefParts = extractUrlParts(originalHref, window.location.href);
     var href      = hrefParts.url;
     var newFileInfo = {
-            currentDirectory: hrefParts.path,
-            filename: href
-        };
+        currentDirectory: hrefParts.path,
+        filename: href
+    };
 
     if (currentFileInfo) {
         newFileInfo.entryPath = currentFileInfo.entryPath;
@@ -356,310 +493,174 @@ function loadFile(originalHref, currentFileInfo, callback, env, newVars) {
             }
             callback(null, lessText, href, newFileInfo, { lastModified: new Date() });
         } catch (e) {
-            callback(e, null, href);
-        }
-        return;
-    }
-
-    doXHR(href, env.mime, function (data, lastModified) {
-        // per file cache
-        fileCache[href] = data;
-
-        // Use remote copy (re-parse)
-        try {
-            callback(null, data, href, newFileInfo, { lastModified: lastModified });
-        } catch (e) {
-            callback(e, null, href);
-        }
-    }, function (status, url) {
-        callback({ type: 'File', message: "'" + url + "' wasn't found (" + status + ")" }, null, href);
-    });
-}
-
-less.Parser.fileLoader = loadFile;
-
-function extractId(href) {
-    return href.replace(/^[a-z-]+:\/+?[^\/]+/, '' )  // Remove protocol & domain
-               .replace(/^\//,                 '' )  // Remove root /
-               .replace(/\.[a-zA-Z]+$/,        '' )  // Remove simple extension
-               .replace(/[^\.\w-]+/g,          '-')  // Replace illegal characters
-               .replace(/\./g,                 ':'); // Replace dots with colons(for valid id)
-}
-
-function createCSS(styles, sheet, lastModified) {
-    // Strip the query-string
-    var href = sheet.href || '';
-
-    // If there is no title set, use the filename, minus the extension
-    var id = 'less:' + (sheet.title || extractId(href));
-
-    // If this has already been inserted into the DOM, we may need to replace it
-    var oldCss = document.getElementById(id);
-    var keepOldCss = false;
-
-    // Create a new stylesheet node for insertion or (if necessary) replacement
-    var css = document.createElement('style');
-    css.setAttribute('type', 'text/css');
-    if (sheet.media) {
-        css.setAttribute('media', sheet.media);
-    }
-    css.id = id;
-
-    if (css.styleSheet) { // IE
-        try {
-            css.styleSheet.cssText = styles;
-        } catch (e) {
-            throw new(Error)("Couldn't reassign styleSheet.cssText.");
-        }
-    } else {
-        css.appendChild(document.createTextNode(styles));
-
-        // If new contents match contents of oldCss, don't replace oldCss
-        keepOldCss = (oldCss !== null && oldCss.childNodes.length > 0 && css.childNodes.length > 0 &&
-            oldCss.firstChild.nodeValue === css.firstChild.nodeValue);
-    }
-
-    var head = document.getElementsByTagName('head')[0];
-
-    // If there is no oldCss, just append; otherwise, only append if we need
-    // to replace oldCss with an updated stylesheet
-    if (oldCss === null || keepOldCss === false) {
-        var nextEl = sheet && sheet.nextSibling || null;
-        if (nextEl) {
-            nextEl.parentNode.insertBefore(css, nextEl);
-        } else {
-            head.appendChild(css);
-        }
-    }
-    if (oldCss && keepOldCss === false) {
-        oldCss.parentNode.removeChild(oldCss);
-    }
-
-    // Don't update the local store if the file wasn't modified
-    if (lastModified && cache) {
-        log('saving ' + href + ' to cache.', logLevel.info);
-        try {
-            cache.setItem(href, styles);
-            cache.setItem(href + ':timestamp', lastModified);
-        } catch(e) {
-            //TODO - could do with adding more robust error handling
-            log('failed to save', logLevel.errors);
-        }
-    }
-}
-
-function doXHR(url, type, callback, errback) {
-    var xhr = getXMLHttpRequest();
-    var async = isFileProtocol ? less.fileAsync : less.async;
-
-    if (typeof(xhr.overrideMimeType) === 'function') {
-        xhr.overrideMimeType('text/css');
-    }
-    log("XHR: Getting '" + url + "'", logLevel.info);
-    xhr.open('GET', url, async);
-    xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');
-    xhr.send(null);
-
-    if (isFileProtocol && !less.fileAsync) {
-        if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
-            callback(xhr.responseText);
-        } else {
-            errback(xhr.status, url);
-        }
-    } else if (async) {
-        xhr.onreadystatechange = function () {
-            if (xhr.readyState == 4) {
-                handleResponse(xhr, callback, errback);
-            }
-        };
-    } else {
-        handleResponse(xhr, callback, errback);
-    }
-
-    function handleResponse(xhr, callback, errback) {
-        if (xhr.status >= 200 && xhr.status < 300) {
-            callback(xhr.responseText,
-                     xhr.getResponseHeader("Last-Modified"));
-        } else if (typeof(errback) === 'function') {
-            errback(xhr.status, url);
+            callback(e, null, href);
         }
+        return;
     }
-}
 
-function getXMLHttpRequest() {
-    if (window.XMLHttpRequest) {
-        return new XMLHttpRequest();
-    } else {
+    doXHR(href, env.mime, function (data, lastModified) {
+        // per file cache
+        fileCache[href] = data;
+
+        // Use remote copy (re-parse)
         try {
-            /*global ActiveXObject */
-            return new ActiveXObject("MSXML2.XMLHTTP.3.0");
+            callback(null, data, href, newFileInfo, { lastModified: lastModified });
         } catch (e) {
-            log("browser doesn't support AJAX.", logLevel.errors);
-            return null;
+            callback(e, null, href);
         }
-    }
+    }, function (status, url) {
+        callback({ type: 'File', message: "'" + url + "' wasn't found (" + status + ")" }, null, href);
+    });
 }
 
-function log(str, level) {
-    if (less.env == 'development' && typeof(console) !== 'undefined' && less.logLevel >= level) {
-        console.log('less: ' + str);
+function loadStyleSheet(sheet, callback, reload, remaining, newVars) {
+
+    var env = new less.tree.parseEnv(less);
+    env.mime = sheet.type;
+
+    if (newVars) {
+        env.useFileCache = true;
     }
+
+    loadFile(sheet.href, null, function(e, data, path, newFileInfo, webInfo) {
+
+        if (webInfo) {
+            webInfo.remaining = remaining;
+
+            var css       = cache && cache.getItem(path),
+                timestamp = cache && cache.getItem(path + ':timestamp');
+
+            if (!reload && timestamp && webInfo.lastModified &&
+                (new(Date)(webInfo.lastModified).valueOf() ===
+                    new(Date)(timestamp).valueOf())) {
+                // Use local copy
+                createCSS(css, sheet);
+                webInfo.local = true;
+                callback(null, null, data, sheet, webInfo, path);
+                return;
+            }
+        }
+
+        //TODO add tests around how this behaves when reloading
+        removeError(path);
+
+        if (data) {
+            env.currentFileInfo = newFileInfo;
+            new(less.Parser)(env).parse(data, function (e, root) {
+                if (e) { return callback(e, null, null, sheet); }
+                try {
+                    callback(e, root, data, sheet, webInfo, path);
+                } catch (e) {
+                    callback(e, null, null, sheet);
+                }
+            });
+        } else {
+            callback(e, null, null, sheet, webInfo, path);
+        }
+    }, env, newVars);
 }
 
-function error(e, rootHref) {
-    if (!less.errorReporting || less.errorReporting === "html") {
-        errorHTML(e, rootHref);
-    } else if (less.errorReporting === "console") {
-        errorConsole(e, rootHref);
-    } else if (typeof less.errorReporting === 'function') {
-        less.errorReporting("add", e, rootHref);
+function loadStyleSheets(callback, reload, newVars) {
+    for (var i = 0; i < less.sheets.length; i++) {
+        loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), newVars);
     }
 }
 
-function removeError(path) {
-    if (!less.errorReporting || less.errorReporting === "html") {
-        removeErrorHTML(path);
-    } else if (less.errorReporting === "console") {
-        removeErrorConsole(path);
-    } else if (typeof less.errorReporting === 'function') {
-        less.errorReporting("remove", path);
+function initRunningMode(){
+    if (less.env === 'development') {
+        less.optimization = 0;
+        less.watchTimer = setInterval(function () {
+            if (less.watchMode) {
+                loadStyleSheets(function (e, root, _, sheet, env) {
+                    if (e) {
+                        error(e, sheet.href);
+                    } else if (root) {
+                        createCSS(root.toCSS(less), sheet, env.lastModified);
+                    }
+                });
+            }
+        }, less.poll);
+    } else {
+        less.optimization = 3;
     }
 }
 
-function removeErrorHTML(path) {
-    var node = document.getElementById('less-error-message:' + extractId(path));
-    if (node) {
-        node.parentNode.removeChild(node);
+//
+// Watch mode
+//
+less.watch   = function () {
+    if (!less.watchMode ){
+        less.env = 'development';
+         initRunningMode();
     }
+    return this.watchMode = true;
+};
+
+less.unwatch = function () {clearInterval(less.watchTimer); return this.watchMode = false; };
+
+if (/!watch/.test(location.hash)) {
+    less.watch();
 }
 
-function removeErrorConsole(path) {
-    //no action
+if (less.env != 'development') {
+    try {
+        cache = (typeof(window.localStorage) === 'undefined') ? null : window.localStorage;
+    } catch (_) {}
 }
 
-function errorConsole(e, rootHref) {
-    var template = '{line} {content}';
-    var filename = e.filename || rootHref;
-    var errors = [];
-    var content = (e.type || "Syntax") + "Error: " + (e.message || 'There is an error in your .less file') +
-        " in " + filename + " ";
+//
+// Get all <link> tags with the 'rel' attribute set to "stylesheet/less"
+//
+var links = document.getElementsByTagName('link');
 
-    var errorline = function (e, i, classname) {
-        if (e.extract[i] !== undefined) {
-            errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
-                .replace(/\{class\}/, classname)
-                .replace(/\{content\}/, e.extract[i]));
-        }
-    };
+less.sheets = [];
 
-    if (e.extract) {
-        errorline(e, 0, '');
-        errorline(e, 1, 'line');
-        errorline(e, 2, '');
-        content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':\n' +
-            errors.join('\n');
-    } else if (e.stack) {
-        content += e.stack;
+for (var i = 0; i < links.length; i++) {
+    if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&
+       (links[i].type.match(typePattern)))) {
+        less.sheets.push(links[i]);
     }
-    log(content, logLevel.errors);
 }
 
-function errorHTML(e, rootHref) {
-    var id = 'less-error-message:' + extractId(rootHref || "");
-    var template = '<li><label>{line}</label><pre class="{class}">{content}</pre></li>';
-    var elem = document.createElement('div'), timer, content, errors = [];
-    var filename = e.filename || rootHref;
-    var filenameNoPath = filename.match(/([^\/]+(\?.*)?)$/)[1];
-
-    elem.id        = id;
-    elem.className = "less-error-message";
+//
+// With this function, it's possible to alter variables and re-render
+// CSS without reloading less-files
+//
+less.modifyVars = function(record) {
+    var newVars = "";
+    for (var name in record) {
+        newVars += ((name.slice(0,1) === '@')? '' : '@') + name +': '+
+                ((record[name].slice(-1) === ';')? record[name] : record[name] +';');
+    }
+    less.refresh(false, newVars);
+};
 
-    content = '<h3>'  + (e.type || "Syntax") + "Error: " + (e.message || 'There is an error in your .less file') +
-              '</h3>' + '<p>in <a href="' + filename   + '">' + filenameNoPath + "</a> ";
+less.refresh = function (reload, newVars) {
+    var startTime, endTime;
+    startTime = endTime = new Date();
 
-    var errorline = function (e, i, classname) {
-        if (e.extract[i] !== undefined) {
-            errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
-                               .replace(/\{class\}/, classname)
-                               .replace(/\{content\}/, e.extract[i]));
+    loadStyleSheets(function (e, root, _, sheet, env) {
+        if (e) {
+            return error(e, sheet.href);
         }
-    };
-
-    if (e.extract) {
-        errorline(e, 0, '');
-        errorline(e, 1, 'line');
-        errorline(e, 2, '');
-        content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':</p>' +
-                    '<ul>' + errors.join('') + '</ul>';
-    } else if (e.stack) {
-        content += '<br/>' + e.stack.split('\n').slice(1).join('<br/>');
-    }
-    elem.innerHTML = content;
+        if (env.local) {
+            log("loading " + sheet.href + " from cache.", logLevel.info);
+        } else {
+            log("parsed " + sheet.href + " successfully.", logLevel.info);
+            createCSS(root.toCSS(less), sheet, env.lastModified);
+        }
+        log("css for " + sheet.href + " generated in " + (new Date() - endTime) + 'ms', logLevel.info);
+        if (env.remaining === 0) {
+            log("css generated in " + (new Date() - startTime) + 'ms', logLevel.info);
+        }
+        endTime = new Date();
+    }, reload, newVars);
 
-    // CSS for error messages
-    createCSS([
-        '.less-error-message ul, .less-error-message li {',
-            'list-style-type: none;',
-            'margin-right: 15px;',
-            'padding: 4px 0;',
-            'margin: 0;',
-        '}',
-        '.less-error-message label {',
-            'font-size: 12px;',
-            'margin-right: 15px;',
-            'padding: 4px 0;',
-            'color: #cc7777;',
-        '}',
-        '.less-error-message pre {',
-            'color: #dd6666;',
-            'padding: 4px 0;',
-            'margin: 0;',
-            'display: inline-block;',
-        '}',
-        '.less-error-message pre.line {',
-            'color: #ff0000;',
-        '}',
-        '.less-error-message h3 {',
-            'font-size: 20px;',
-            'font-weight: bold;',
-            'padding: 15px 0 5px 0;',
-            'margin: 0;',
-        '}',
-        '.less-error-message a {',
-            'color: #10a',
-        '}',
-        '.less-error-message .error {',
-            'color: red;',
-            'font-weight: bold;',
-            'padding-bottom: 2px;',
-            'border-bottom: 1px dashed red;',
-        '}'
-    ].join('\n'), { title: 'error-message' });
+    loadStyles(newVars);
+};
 
-    elem.style.cssText = [
-        "font-family: Arial, sans-serif",
-        "border: 1px solid #e00",
-        "background-color: #eee",
-        "border-radius: 5px",
-        "-webkit-border-radius: 5px",
-        "-moz-border-radius: 5px",
-        "color: #e00",
-        "padding: 15px",
-        "margin-bottom: 15px"
-    ].join(';');
+less.refreshStyles = loadStyles;
 
-    if (less.env == 'development') {
-        timer = setInterval(function () {
-            if (document.body) {
-                if (document.getElementById(id)) {
-                    document.body.replaceChild(elem, document.getElementById(id));
-                } else {
-                    document.body.insertBefore(elem, document.body.firstChild);
-                }
-                clearInterval(timer);
-            }
-        }, 10);
-    }
-}
+less.Parser.fileLoader = loadFile;
 
 less.refresh(less.env === 'development');
diff --git a/lib/less/functions.js b/lib/less/functions.js
index 2806bfde..249aaf17 100644
--- a/lib/less/functions.js
+++ b/lib/less/functions.js
@@ -13,6 +13,14 @@ tree.functions = {
         return this.hsla(h, s, l, 1.0);
     },
     hsla: function (h, s, l, a) {
+        function hue(h) {
+            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
+            if      (h * 6 < 1) { return m1 + (m2 - m1) * h * 6; }
+            else if (h * 2 < 1) { return m2; }
+            else if (h * 3 < 2) { return m1 + (m2 - m1) * (2/3 - h) * 6; }
+            else                { return m1; }
+        }
+
         h = (number(h) % 360) / 360;
         s = clamp(number(s)); l = clamp(number(l)); a = clamp(number(a));
 
@@ -23,14 +31,6 @@ tree.functions = {
                          hue(h)       * 255,
                          hue(h - 1/3) * 255,
                          a);
-
-        function hue(h) {
-            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
-            if      (h * 6 < 1) { return m1 + (m2 - m1) * h * 6; }
-            else if (h * 2 < 1) { return m2; }
-            else if (h * 3 < 2) { return m1 + (m2 - m1) * (2/3 - h) * 6; }
-            else                { return m1; }
-        }
     },
 
     hsv: function(h, s, v) {
diff --git a/lib/less/rhino.js b/lib/less/rhino.js
index 5feb2e74..08f31102 100644
--- a/lib/less/rhino.js
+++ b/lib/less/rhino.js
@@ -2,6 +2,35 @@
 /*global name:true, less, loadStyleSheet */
 var name;
 
+function error(e, filename) {
+
+    var content = "Error : " + filename + "\n";
+
+    filename = e.filename || filename;
+
+    if (e.message) {
+        content += e.message + "\n";
+    }
+
+    var errorline = function (e, i, classname) {
+        if (e.extract[i]) {
+            content +=
+                String(parseInt(e.line, 10) + (i - 1)) +
+                    ":" + e.extract[i] + "\n";
+        }
+    };
+
+    if (e.stack) {
+        content += e.stack;
+    } else if (e.extract) {
+        content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':\n';
+        errorline(e, 0);
+        errorline(e, 1);
+        errorline(e, 2);
+    }
+    print(content);
+}
+
 function loadStyleSheet(sheet, callback, reload, remaining) {
     var endOfPath = Math.max(name.lastIndexOf('/'), name.lastIndexOf('\\')),
         sheetName = name.slice(0, endOfPath + 1) + sheet.href,
@@ -96,33 +125,4 @@ function writeFile(filename, content) {
         quit(1);
     }
     print("done");
-}(arguments));
-
-function error(e, filename) {
-
-    var content = "Error : " + filename + "\n";
-    
-    filename = e.filename || filename;
-    
-    if (e.message) {
-        content += e.message + "\n";
-    }
-
-    var errorline = function (e, i, classname) {
-        if (e.extract[i]) {
-            content += 
-                String(parseInt(e.line, 10) + (i - 1)) +
-                ":" + e.extract[i] + "\n";
-        }
-    };
-
-    if (e.stack) {
-        content += e.stack;
-    } else if (e.extract) {
-        content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':\n';
-        errorline(e, 0);
-        errorline(e, 1);
-        errorline(e, 2);
-    }
-    print(content);
-}
+}(arguments));
\ No newline at end of file
diff --git a/test/less-test.js b/test/less-test.js
index bc00bc6c..30e62c2b 100644
--- a/test/less-test.js
+++ b/test/less-test.js
@@ -1,3 +1,4 @@
+/*jshint latedef: nofunc */
 var path = require('path'),
     fs = require('fs'),
     sys = require('util');
