diff --git a/src/main/java/org/shredzone/commons/suncalc/MoonTimes.java b/src/main/java/org/shredzone/commons/suncalc/MoonTimes.java
index 49c504a..5f14b0f 100644
--- a/src/main/java/org/shredzone/commons/suncalc/MoonTimes.java
+++ b/src/main/java/org/shredzone/commons/suncalc/MoonTimes.java
@@ -119,32 +119,40 @@ public final class MoonTimes {
             boolean alwaysUp = false;
             boolean alwaysDown = false;
 
-            double y_minus = correctedMoonHeight(jd);
-
+            int hour = 0;
             int maxHours = fullCycle ? 365 * 24 : 24;
-            for (int hour = 1; hour < maxHours; hour += 2) {
-                double y_0 = correctedMoonHeight(jd.atHour(hour));
-                double y_plus = correctedMoonHeight(jd.atHour(hour + 1.0));
 
+            double y_minus = correctedMoonHeight(jd.atHour(hour - 1.0));
+            double y_0 = correctedMoonHeight(jd.atHour(hour));
+            double y_plus = correctedMoonHeight(jd.atHour(hour + 1.0));
+
+            while (hour <= maxHours) {
                 QuadraticInterpolation qi = new QuadraticInterpolation(y_minus, y_0, y_plus);
                 double ye = qi.getYe();
 
                 if (qi.getNumberOfRoots() == 1) {
+                    double rt = qi.getRoot1() + hour;
                     if (y_minus < 0.0) {
-                        if (rise == null) {
-                            rise = qi.getRoot1() + hour;
+                        if (rise == null && rt >= 0.0) {
+                            rise = rt;
                         }
                     } else {
-                        if (set == null) {
-                            set = qi.getRoot1() + hour;
+                        if (set == null && rt >= 0.0) {
+                            set = rt;
                         }
                     }
                 } else if (qi.getNumberOfRoots() == 2) {
                     if (rise == null) {
-                        rise = hour + (ye < 0.0 ? qi.getRoot2() : qi.getRoot1());
+                        double rt = hour + (ye < 0.0 ? qi.getRoot2() : qi.getRoot1());
+                        if (rt >= 0.0) {
+                            rise = rt;
+                        }
                     }
                     if (set == null) {
-                        set = hour + (ye < 0.0 ? qi.getRoot1() : qi.getRoot2());
+                        double rt = hour + (ye < 0.0 ? qi.getRoot1() : qi.getRoot2());
+                        if (rt >= 0.0) {
+                            set = rt;
+                        }
                     }
                 }
 
@@ -157,7 +165,19 @@ public final class MoonTimes {
                     break;
                 }
 
-                y_minus = y_plus;
+                hour++;
+                y_minus = y_0;
+                y_0 = y_plus;
+                y_plus = correctedMoonHeight(jd.atHour(hour + 1.0));
+            }
+
+            if (!fullCycle) {
+                if (rise != null && rise >= 24.0) {
+                    rise = null;
+                }
+                if (set != null && set >= 24.0) {
+                    set = null;
+                }
             }
 
             return new MoonTimes(
diff --git a/src/main/java/org/shredzone/commons/suncalc/SunTimes.java b/src/main/java/org/shredzone/commons/suncalc/SunTimes.java
index a9bc319..d43dfd4 100644
--- a/src/main/java/org/shredzone/commons/suncalc/SunTimes.java
+++ b/src/main/java/org/shredzone/commons/suncalc/SunTimes.java
@@ -278,48 +278,59 @@ public class SunTimes {
             boolean alwaysDown = false;
             double ye;
 
-            double y_minus = correctedSunHeight(jd);
-            if (y_minus > 0.0) {
+            int hour = 0;
+            int maxHours = fullCycle ? 365 * 24 : 24;
+
+            double y_minus = correctedSunHeight(jd.atHour(hour - 1.0));
+            double y_0 = correctedSunHeight(jd.atHour(hour));
+            double y_plus = correctedSunHeight(jd.atHour(hour + 1.0));
+
+            if (y_0 > 0.0) {
                 alwaysUp = true;
             } else {
                 alwaysDown = true;
             }
 
-            int maxHours = fullCycle ? 365 * 24 : 24;
-            for (int hour = 1; hour < maxHours; hour++) {
-                double y_0 = correctedSunHeight(jd.atHour(hour));
-                double y_plus = correctedSunHeight(jd.atHour(hour + 1.0));
-
+            while (hour <= maxHours) {
                 QuadraticInterpolation qi = new QuadraticInterpolation(y_minus, y_0, y_plus);
                 ye = qi.getYe();
 
                 if (qi.getNumberOfRoots() == 1) {
+                    double rt = qi.getRoot1() + hour;
                     if (y_minus < 0.0) {
-                        if (rise == null) {
-                            rise = qi.getRoot1() + hour;
+                        if (rise == null && rt >= 0.0) {
+                            rise = rt;
                         }
                     } else {
-                        if (set == null) {
-                            set = qi.getRoot1() + hour;
+                        if (set == null && rt >= 0.0) {
+                            set = rt;
                         }
                     }
                 } else if (qi.getNumberOfRoots() == 2) {
                     if (rise == null) {
-                        rise = hour + (ye < 0.0 ? qi.getRoot2() : qi.getRoot1());
+                        double rt = hour + (ye < 0.0 ? qi.getRoot2() : qi.getRoot1());
+                        if (rt >= 0.0) {
+                            rise = rt;
+                        }
                     }
                     if (set == null) {
-                        set = hour + (ye < 0.0 ? qi.getRoot1() : qi.getRoot2());
+                        double rt = hour + (ye < 0.0 ? qi.getRoot1() : qi.getRoot2());
+                        if (rt >= 0.0) {
+                            set = rt;
+                        }
                     }
                 }
 
-                if (hour < 24) {
+                if (hour <= 24) {
                     double xeAbs = Math.abs(qi.getXe());
                     if (xeAbs <= 1.0) {
                         double xeHour = qi.getXe() + hour;
-                        if (qi.isMaximum()) {
-                            noon = xeHour;
-                        } else {
-                            nadir = xeHour;
+                        if (xeHour >= 0.0 && xeHour < 24.0) {
+                            if (qi.isMaximum()) {
+                                noon = xeHour;
+                            } else {
+                                nadir = xeHour;
+                            }
                         }
                     }
                 }
@@ -337,7 +348,19 @@ public class SunTimes {
                     break;
                 }
 
+                hour++;
                 y_minus = y_0;
+                y_0 = y_plus;
+                y_plus = correctedSunHeight(jd.atHour(hour + 1.0));
+            }
+
+            if (!fullCycle) {
+                if (rise != null && rise >= 24.0) {
+                    rise = null;
+                }
+                if (set != null && set >= 24.0) {
+                    set = null;
+                }
             }
 
             return new SunTimes(
diff --git a/src/test/java/org/shredzone/commons/suncalc/Locations.java b/src/test/java/org/shredzone/commons/suncalc/Locations.java
index 02b73c9..90b6de5 100644
--- a/src/test/java/org/shredzone/commons/suncalc/Locations.java
+++ b/src/test/java/org/shredzone/commons/suncalc/Locations.java
@@ -66,4 +66,10 @@ public final class Locations {
     public static final double[] SYDNEY = new double[] { -33.744272, 151.231291 };
     public static final TimeZone SYDNEY_TZ = TimeZone.getTimeZone("Australia/Sydney");
 
+    /**
+     * Santa Monica, CA. To test a fix for issue #18.
+     */
+    public static final double[] SANTA_MONICA = new double[] { 34.0, -118.5 };
+    public static final TimeZone SANTA_MONICA_TZ = TimeZone.getTimeZone("PDT");
+
 }
diff --git a/src/test/java/org/shredzone/commons/suncalc/MoonTimesTest.java b/src/test/java/org/shredzone/commons/suncalc/MoonTimesTest.java
index 0ad713f..373aa3a 100644
--- a/src/test/java/org/shredzone/commons/suncalc/MoonTimesTest.java
+++ b/src/test/java/org/shredzone/commons/suncalc/MoonTimesTest.java
@@ -40,7 +40,7 @@ public class MoonTimesTest {
         MoonTimes mt = MoonTimes.compute().on(2017, 7, 12).utc().at(COLOGNE)
                         .truncatedTo(Unit.SECONDS).execute();
         assertThat(mt.getRise()).as("rise").isEqualTo("2017-07-12T21:25:58Z");
-        assertThat(mt.getSet()).as("set").isEqualTo("2017-07-12T06:53:19Z");
+        assertThat(mt.getSet()).as("set").isEqualTo("2017-07-12T06:53:27Z");
         assertThat(mt.isAlwaysUp()).as("alwaysup").isFalse();
         assertThat(mt.isAlwaysDown()).as("alwaysdown").isFalse();
     }
@@ -74,7 +74,7 @@ public class MoonTimesTest {
         MoonTimes mt5 = MoonTimes.compute().on(2017, 7, 18).utc().at(ALERT).fullCycle()
                         .truncatedTo(Unit.SECONDS).execute();
         assertThat(mt5.getRise()).as("rise").isEqualTo("2017-07-27T11:59:07Z");
-        assertThat(mt5.getSet()).as("set").isEqualTo("2017-07-27T04:07:14Z");
+        assertThat(mt5.getSet()).as("set").isEqualTo("2017-07-27T04:07:24Z");
         assertThat(mt5.isAlwaysUp()).as("alwaysup").isTrue();
         assertThat(mt5.isAlwaysDown()).as("alwaysdown").isFalse();
     }
@@ -83,12 +83,12 @@ public class MoonTimesTest {
     public void testWellington() {
         MoonTimes mt1 = MoonTimes.compute().on(2017, 7, 12).utc().at(WELLINGTON)
                         .truncatedTo(Unit.SECONDS).execute();
-        assertThat(mt1.getRise()).as("rise").isEqualTo("2017-07-12T08:05:50Z");
+        assertThat(mt1.getRise()).as("rise").isEqualTo("2017-07-12T08:05:55Z");
         assertThat(mt1.getSet()).as("set").isEqualTo("2017-07-12T21:57:35Z");
 
         MoonTimes mt2 = MoonTimes.compute().on(2017, 7, 12).timezone("NZ").at(WELLINGTON)
                         .truncatedTo(Unit.SECONDS).execute();
-        assertThat(mt2.getRise()).as("rise").isEqualTo("2017-07-12T20:05:50+12:00");
+        assertThat(mt2.getRise()).as("rise").isEqualTo("2017-07-12T20:05:55+12:00");
         assertThat(mt2.getSet()).as("set").isEqualTo("2017-07-12T09:22:59+12:00");
     }
 
@@ -96,8 +96,8 @@ public class MoonTimesTest {
     public void testPuertoWilliams() {
         MoonTimes mt = MoonTimes.compute().on(2017, 7, 13).utc().at(PUERTO_WILLIAMS)
                         .truncatedTo(Unit.SECONDS).execute();
-        assertThat(mt.getRise()).as("rise").isEqualTo("2017-07-13T00:31:12Z");
-        assertThat(mt.getSet()).as("set").isEqualTo("2017-07-13T14:48:21Z");
+        assertThat(mt.getRise()).as("rise").isEqualTo("2017-07-13T00:31:33Z");
+        assertThat(mt.getSet()).as("set").isEqualTo("2017-07-13T14:48:33Z");
     }
 
     @Test
@@ -105,7 +105,7 @@ public class MoonTimesTest {
         MoonTimes mt = MoonTimes.compute().on(2017, 7, 13).utc().at(SINGAPORE)
                         .truncatedTo(Unit.SECONDS).execute();
         assertThat(mt.getRise()).as("rise").isEqualTo("2017-07-13T14:35:11Z");
-        assertThat(mt.getSet()).as("set").isEqualTo("2017-07-13T02:08:54Z");
+        assertThat(mt.getSet()).as("set").isEqualTo("2017-07-13T02:08:55Z");
     }
 
     @Test
diff --git a/src/test/java/org/shredzone/commons/suncalc/SunTimesTest.java b/src/test/java/org/shredzone/commons/suncalc/SunTimesTest.java
index 1741575..19caa3c 100644
--- a/src/test/java/org/shredzone/commons/suncalc/SunTimesTest.java
+++ b/src/test/java/org/shredzone/commons/suncalc/SunTimesTest.java
@@ -67,7 +67,7 @@ public class SunTimesTest {
             assertThat(times.getRise()).as("%s-rise", angle.name()).isEqualTo(riseTimes.get(angle));
             assertThat(times.getSet()).as("%s-set", angle.name()).isEqualTo(setTimes.get(angle));
             assertThat(times.getNoon()).as("noon").isEqualTo("2017-08-10T11:37:38Z");
-            assertThat(times.getNadir()).as("nadir").isEqualTo("2017-08-10T23:37:59Z");
+            assertThat(times.getNadir()).as("nadir").isEqualTo("2017-08-10T23:37:51Z");
             assertThat(times.isAlwaysDown()).as("always-down").isFalse();
             assertThat(times.isAlwaysUp()).as("always-up").isFalse();
         }
@@ -78,7 +78,7 @@ public class SunTimesTest {
         assertThat(times.getRise()).as("rise").isEqualTo("2017-08-10T03:48:59Z");
         assertThat(times.getSet()).as("set").isEqualTo("2017-08-10T19:25:16Z");
         assertThat(times.getNoon()).as("noon").isEqualTo("2017-08-10T11:37:38Z");
-        assertThat(times.getNadir()).as("nadir").isEqualTo("2017-08-10T23:37:59Z");
+        assertThat(times.getNadir()).as("nadir").isEqualTo("2017-08-10T23:37:51Z");
         assertThat(times.isAlwaysDown()).as("always-down").isFalse();
         assertThat(times.isAlwaysUp()).as("always-up").isFalse();
     }
@@ -145,6 +145,51 @@ public class SunTimesTest {
         assertTimes(t1, "2019-07-02T21:00:35Z", "2019-07-03T06:58:02Z", "2019-07-03T01:59:18Z");
     }
 
+    @Test
+    public void testJustBeforeJustAfter() {
+        // Thanks to @isomeme for providing the test cases for issue #18.
+
+        long shortDuration = 2 * 60 * 1000L;
+        long longDuration = 30 * 60 * 1000L;
+        SunTimes.Parameters param = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)
+                .on(2020, 5, 3).truncatedTo(Unit.SECONDS);
+        Date noon = param.execute().getNoon();
+        Date noonNextDay = param.plusDays(1).execute().getNoon();
+        long acceptableError = 65 * 1000L;
+
+        Date wellBeforeNoon = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)
+                .on(new Date(noon.getTime() - longDuration))
+                .truncatedTo(Unit.SECONDS).execute().getNoon();
+        assertThat(Math.abs(wellBeforeNoon.getTime() - noon.getTime()))
+                .as("wellBeforeNoon").isLessThan(acceptableError);
+
+        Date justBeforeNoon = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)
+                .on(new Date(noon.getTime() - shortDuration))
+                .truncatedTo(Unit.SECONDS).execute().getNoon();
+        assertThat(Math.abs(justBeforeNoon.getTime() - noon.getTime()))
+                .as("justBeforeNoon").isLessThan(acceptableError);
+
+        Date justAfterNoon = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)
+                .on(new Date(noon.getTime() + shortDuration))
+                .truncatedTo(Unit.SECONDS).execute().getNoon();
+        assertThat(Math.abs(justAfterNoon.getTime() - noonNextDay.getTime()))
+                .as("justAfterNoon").isLessThan(acceptableError);
+
+        Date wellAfterNoon = SunTimes.compute().at(SANTA_MONICA).timezone(SANTA_MONICA_TZ)
+                .on(new Date(noon.getTime() + longDuration))
+                .truncatedTo(Unit.SECONDS).execute().getNoon();
+        assertThat(Math.abs(wellAfterNoon.getTime() - noonNextDay.getTime()))
+                .as("wellAfterNoon").isLessThan(acceptableError);
+
+        Date nadirWellAfterNoon = SunTimes.compute().on(wellAfterNoon).timezone(SANTA_MONICA_TZ)
+                .at(SANTA_MONICA).execute().getNadir();
+        Date nadirJustBeforeNadir = SunTimes.compute()
+                .on(new Date(nadirWellAfterNoon.getTime() - shortDuration))
+                .at(SANTA_MONICA).timezone(SANTA_MONICA_TZ).execute().getNadir();
+        assertThat(Math.abs(nadirWellAfterNoon.getTime() - nadirJustBeforeNadir.getTime()))
+                .as("nadir").isLessThan(acceptableError);
+    }
+
     @Test
     public void testSequence() {
         long acceptableError = 62 * 1000L;
