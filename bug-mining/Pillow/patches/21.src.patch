diff --git a/PIL/Image.py b/PIL/Image.py
index ec5ff548d..2e5efeb28 100644
--- a/PIL/Image.py
+++ b/PIL/Image.py
@@ -731,6 +731,10 @@ class Image:
             self.palette.dirty = 1
             self.load()
 
+        # Use transparent conversion to promote from transparent color to an alpha channel.
+        if self.mode == "RGB" and mode == "RGBA" and "transparency" in self.info:
+            return self._new(self.im.convert_transparent(mode, self.info['transparency']))
+            
         try:
             im = self.im.convert(mode, dither)
         except ValueError:
diff --git a/_imaging.c b/_imaging.c
index 37dab7839..ce6584788 100644
--- a/_imaging.c
+++ b/_imaging.c
@@ -794,6 +794,18 @@ _convert_matrix(ImagingObject* self, PyObject* args)
     return PyImagingNew(ImagingConvertMatrix(self->image, mode, m));
 }
 
+static PyObject*
+_convert_transparent(ImagingObject* self, PyObject* args)
+{
+    char* mode;
+    int r,g,b;
+    if (!PyArg_ParseTuple(args, "s(iii)", &mode, &r, &g, &b)) {
+        return NULL;
+    }
+
+    return PyImagingNew(ImagingConvertTransparent(self->image, mode, r, g, b));
+}
+
 static PyObject*
 _copy(ImagingObject* self, PyObject* args)
 {
@@ -2931,6 +2943,7 @@ static struct PyMethodDef methods[] = {
     {"convert", (PyCFunction)_convert, 1},
     {"convert2", (PyCFunction)_convert2, 1},
     {"convert_matrix", (PyCFunction)_convert_matrix, 1},
+    {"convert_transparent", (PyCFunction)_convert_transparent, 1},
     {"copy", (PyCFunction)_copy, 1},
     {"copy2", (PyCFunction)_copy2, 1},
 #ifdef WITH_CRACKCODE
diff --git a/libImaging/Convert.c b/libImaging/Convert.c
index 2caf219ea..cedff2d04 100644
--- a/libImaging/Convert.c
+++ b/libImaging/Convert.c
@@ -312,7 +312,36 @@ rgba2rgbA(UINT8* out, const UINT8* in, int xsize)
     }
 }
 
+/*
+ * Conversion of RGB + single transparent color to RGBA, 
+ * where any pixel that matches the color will have the 
+ * alpha channel set to 0
+ */
+ 
+static void
+rgbT2rgba(UINT8* out, const UINT8* in, int xsize, int r, int g, int b) 
+{
+#ifdef WORDS_BIGENDIAN
+    UINT32 trns = ((r & 0xff)<<24) | ((g & 0xff)<<16) | ((b & 0xff)<<8) | 0xff;
+    UINT32 repl = trns & 0xffffff00;
+#else
+    UINT32 trns = (0xff <<24) | ((b & 0xff)<<16) | ((g & 0xff)<<8) | (r & 0xff);
+    UINT32 repl = trns & 0x00ffffff;
+#endif
 
+    UINT32* tmp = (UINT32 *)out;
+    int i;
+
+    rgb2rgba(out, in, xsize);
+
+    for (i=0; i < xsize; i++ ,tmp++) {
+        if (tmp[0]==trns) {
+            tmp[0]=repl;
+        }
+    }
+}
+            
+    
 
 /* ---------------- */
 /* CMYK conversions */
@@ -1162,6 +1191,49 @@ ImagingConvert2(Imaging imOut, Imaging imIn)
     return convert(imOut, imIn, imOut->mode, NULL, 0);
 }
 
+
+Imaging
+ImagingConvertTransparent(Imaging imIn, const char *mode,
+                          int r, int g, int b)
+{
+    ImagingSectionCookie cookie;
+    Imaging imOut = NULL;
+    int y;
+
+    if (!imIn){
+        return (Imaging) ImagingError_ModeError();
+    }
+    
+    if (!(strcmp(imIn->mode, "RGB") == 0 && strcmp(mode, "RGBA") == 0))
+#ifdef notdef
+    {
+        return (Imaging) ImagingError_ValueError("conversion not supported");
+    }
+#else
+    {
+      static char buf[256];
+      /* FIXME: may overflow if mode is too large */
+      sprintf(buf, "conversion from %s to %s not supported in convert_transparent", imIn->mode, mode);
+      return (Imaging) ImagingError_ValueError(buf);
+    }
+#endif
+
+
+    imOut = ImagingNew2(mode, imOut, imIn);
+    if (!imOut){
+        return NULL;
+    }
+
+    ImagingSectionEnter(&cookie);
+    for (y = 0; y < imIn->ysize; y++)
+        rgbT2rgba((UINT8*) imOut->image[y], (UINT8*) imIn->image[y],
+                  imIn->xsize, r, g, b);
+    ImagingSectionLeave(&cookie);
+
+    return imOut; 
+
+}
+
 Imaging
 ImagingConvertInPlace(Imaging imIn, const char* mode)
 {
diff --git a/libImaging/Imaging.h b/libImaging/Imaging.h
index c139aed88..b45dcbe23 100644
--- a/libImaging/Imaging.h
+++ b/libImaging/Imaging.h
@@ -248,6 +248,7 @@ extern Imaging ImagingCopy(Imaging im);
 extern Imaging ImagingConvert(Imaging im, const char* mode, ImagingPalette palette, int dither);
 extern Imaging ImagingConvertInPlace(Imaging im, const char* mode);
 extern Imaging ImagingConvertMatrix(Imaging im, const char *mode, float m[]);
+extern Imaging ImagingConvertTransparent(Imaging im, const char *mode, int r, int g, int b);
 extern Imaging ImagingCrop(Imaging im, int x0, int y0, int x1, int y1);
 extern Imaging ImagingExpand(Imaging im, int x, int y, int mode);
 extern Imaging ImagingFill(Imaging im, const void* ink);
