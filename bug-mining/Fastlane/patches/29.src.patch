diff --git a/fastlane/lib/fastlane/fast_file.rb b/fastlane/lib/fastlane/fast_file.rb
index 0c1dea279..79bfef71d 100644
--- a/fastlane/lib/fastlane/fast_file.rb
+++ b/fastlane/lib/fastlane/fast_file.rb
@@ -254,7 +254,9 @@ module Fastlane
           branch_option = "--branch #{branch}" if branch != 'HEAD'
 
           UI.message("Cloning remote git repo...")
-          Actions.sh("GIT_TERMINAL_PROMPT=0 git clone '#{url}' '#{clone_folder}' --depth 1 -n #{branch_option}")
+          Helper.with_env_values('GIT_TERMINAL_PROMPT' => '0') do
+            Actions.sh("git clone #{url.shellescape} #{clone_folder.shellescape} --depth 1 -n #{branch_option}")
+          end
 
           unless version.nil?
             req = Gem::Requirement.new(version)
@@ -263,14 +265,14 @@ module Fastlane
             UI.user_error!("No tag found matching #{version.inspect}") if checkout_param.nil?
           end
 
-          Actions.sh("cd '#{clone_folder}' && git checkout #{checkout_param} '#{path}'")
+          Actions.sh("cd #{clone_folder.shellescape} && git checkout #{checkout_param.shellescape} #{path.shellescape}")
 
           # We also want to check out all the local actions of this fastlane setup
           containing = path.split(File::SEPARATOR)[0..-2]
           containing = "." if containing.count == 0
           actions_folder = File.join(containing, "actions")
           begin
-            Actions.sh("cd '#{clone_folder}' && git checkout #{checkout_param} '#{actions_folder}'")
+            Actions.sh("cd #{clone_folder.shellescape} && git checkout #{checkout_param.shellescape} #{actions_folder.shellescape}")
           rescue
             # We don't care about a failure here, as local actions are optional
           end
@@ -290,10 +292,12 @@ module Fastlane
 
     def fetch_remote_tags(folder: nil)
       UI.message("Fetching remote git tags...")
-      Actions.sh("cd '#{folder}' && GIT_TERMINAL_PROMPT=0 git fetch --all --tags -q")
+      Helper.with_env_values('GIT_TERMINAL_PROMPT' => '0') do
+        Actions.sh("cd #{folder.shellescape} && git fetch --all --tags -q")
+      end
 
       # Fetch all possible tags
-      git_tags_string = Actions.sh("cd '#{folder}' && git tag -l")
+      git_tags_string = Actions.sh("cd #{folder.shellescape} && git tag -l")
       git_tags = git_tags_string.split("\n")
 
       # Sort tags based on their version number
diff --git a/fastlane_core/lib/fastlane_core/helper.rb b/fastlane_core/lib/fastlane_core/helper.rb
index 833cc38a9..24ebabf97 100644
--- a/fastlane_core/lib/fastlane_core/helper.rb
+++ b/fastlane_core/lib/fastlane_core/helper.rb
@@ -299,6 +299,22 @@ module FastlaneCore
       Helper.backticks(command, print: print)
     end
 
+    # Executes the provided block after adjusting the ENV to have the
+    # provided keys and values set as defined in hash. After the block
+    # completes, restores the ENV to its previous state.
+    def self.with_env_values(hash, &block)
+      old_vals = ENV.select { |k, v| hash.include?(k) }
+      hash.each do |k, v|
+        ENV[k] = hash[k]
+      end
+      yield
+    ensure
+      hash.each do |k, v|
+        ENV.delete(k) unless old_vals.include?(k)
+        ENV[k] = old_vals[k]
+      end
+    end
+
     # loading indicator
     #
 
diff --git a/fastlane_core/lib/fastlane_core/provisioning_profile.rb b/fastlane_core/lib/fastlane_core/provisioning_profile.rb
index e20b72ec4..41c3e47fd 100644
--- a/fastlane_core/lib/fastlane_core/provisioning_profile.rb
+++ b/fastlane_core/lib/fastlane_core/provisioning_profile.rb
@@ -91,10 +91,16 @@ module FastlaneCore
           err = "#{dir}/cms.err"
           # we want to prevent the error output to mix up with the standard output because of
           # /dev/null: https://github.com/fastlane/fastlane/issues/6387
-          if keychain_path.nil?
-            decoded = `security cms -D -i "#{path}" 2> #{err}`
+          if Helper.mac?
+            if keychain_path.nil?
+              decoded = `security cms -D -i "#{path}" 2> #{err}`
+            else
+              decoded = `security cms -D -i "#{path}" -k "#{keychain_path.shellescape}" 2> #{err}`
+            end
           else
-            decoded = `security cms -D -i "#{path}" -k "#{keychain_path.shellescape}" 2> #{err}`
+            # `security` only works on Mac, fallback to `openssl`
+            # via https://stackoverflow.com/a/14379814/252627
+            decoded = `openssl smime -inform der -verify -noverify -in #{path} 2> #{err}`
           end
           UI.error("Failure to decode #{path}. Exit: #{$?.exitstatus}: #{File.read(err)}") if $?.exitstatus != 0
           decoded
diff --git a/match/lib/match/encryption/openssl.rb b/match/lib/match/encryption/openssl.rb
index 1e46666e1..5ffc389b2 100644
--- a/match/lib/match/encryption/openssl.rb
+++ b/match/lib/match/encryption/openssl.rb
@@ -116,7 +116,7 @@ module Match
       def encrypt_specific_file(path: nil, password: nil)
         UI.user_error!("No password supplied") if password.to_s.strip.length == 0
 
-        data_to_encrypt = File.read(path)
+        data_to_encrypt = File.binread(path)
         salt = SecureRandom.random_bytes(8)
 
         # The :: is important, as there is a name clash
diff --git a/match/lib/match/options.rb b/match/lib/match/options.rb
index d57cd2c83..8cbf141cd 100644
--- a/match/lib/match/options.rb
+++ b/match/lib/match/options.rb
@@ -174,6 +174,10 @@ module Match
                                      description: "The name of provisioning profile template. If the developer account has provisioning profile templates (aka: custom entitlements), the template name can be found by inspecting the Entitlements drop-down while creating/editing a provisioning profile (e.g. \"Apple Pay Pass Suppression Development\")",
                                      optional: true,
                                      default_value: nil),
+        FastlaneCore::ConfigItem.new(key: :output_path,
+                                     env_name: "MATCH_OUTPUT_PATH",
+                                     description: "Path in which to export certificates, key and profile",
+                                     optional: true),
 
         # other
         FastlaneCore::ConfigItem.new(key: :verbose,
diff --git a/match/lib/match/runner.rb b/match/lib/match/runner.rb
index 217240406..3d4d5314c 100644
--- a/match/lib/match/runner.rb
+++ b/match/lib/match/runner.rb
@@ -25,6 +25,8 @@ module Match
     def run(params)
       self.files_to_commit = []
 
+      FileUtils.mkdir_p(params[:output_path]) if params[:output_path]
+
       FastlaneCore::PrintTable.print_values(config: params,
                                              title: "Summary for match #{Fastlane::VERSION}")
 
@@ -166,21 +168,31 @@ module Match
         self.files_to_commit << private_key_path
       else
         cert_path = certs.last
-        UI.message("Installing certificate...")
 
-        # Only looking for cert in "custom" (non login.keychain) keychain
-        # Doing this for backwards compatability
-        keychain_name = params[:keychain_name] == "login.keychain" ? nil : params[:keychain_name]
+        if Helper.mac?
+          UI.message("Installing certificate...")
+
+          # Only looking for cert in "custom" (non login.keychain) keychain
+          # Doing this for backwards compatability
+          keychain_name = params[:keychain_name] == "login.keychain" ? nil : params[:keychain_name]
+
+          if FastlaneCore::CertChecker.installed?(cert_path, in_keychain: keychain_name)
+            UI.verbose("Certificate '#{File.basename(cert_path)}' is already installed on this machine")
+          else
+            Utils.import(cert_path, params[:keychain_name], password: params[:keychain_password])
+          end
 
-        if FastlaneCore::CertChecker.installed?(cert_path, in_keychain: keychain_name)
-          UI.verbose("Certificate '#{File.basename(cert_path)}' is already installed on this machine")
+          # Import the private key
+          # there seems to be no good way to check if it's already installed - so just install it
+          Utils.import(keys.last, params[:keychain_name], password: params[:keychain_password])
         else
-          Utils.import(cert_path, params[:keychain_name], password: params[:keychain_password])
+          UI.message("Skipping installation of certificate as it would not work on this operating system.")
         end
 
-        # Import the private key
-        # there seems to be no good way to check if it's already installed - so just install it
-        Utils.import(keys.last, params[:keychain_name], password: params[:keychain_password])
+        if params[:output_path]
+          FileUtils.cp(cert_path, params[:output_path])
+          FileUtils.cp(keys.last, params[:output_path])
+        end
 
         # Get and print info of certificate
         info = Utils.get_cert_info(cert_path)
@@ -202,7 +214,9 @@ module Match
       profile_name = names.join("_").gsub("*", '\*') # this is important, as it shouldn't be a wildcard
       base_dir = File.join(prefixed_working_directory(working_directory), "profiles", prov_type.to_s)
       profiles = Dir[File.join(base_dir, "#{profile_name}.mobileprovision")]
-      keychain_path = FastlaneCore::Helper.keychain_path(params[:keychain_name]) unless params[:keychain_name].nil?
+      if Helper.mac?
+        keychain_path = FastlaneCore::Helper.keychain_path(params[:keychain_name]) unless params[:keychain_name].nil?
+      end
 
       # Install the provisioning profiles
       profile = profiles.last
@@ -220,11 +234,13 @@ module Match
 
       if profile.nil? || params[:force]
         if params[:readonly]
-          all_profiles = Dir.entries(base_dir).reject { |f| f.start_with?(".") }
           UI.error("No matching provisioning profiles found for '#{profile_name}'")
           UI.error("A new one cannot be created because you enabled `readonly`")
-          UI.error("Provisioning profiles in your repo for type `#{prov_type}`:")
-          all_profiles.each { |p| UI.error("- '#{p}'") }
+          if Dir.exist?(base_dir) # folder for `prov_type` does not exist on first match use for that type
+            all_profiles = Dir.entries(base_dir).reject { |f| f.start_with?(".") }
+            UI.error("Provisioning profiles in your repo for type `#{prov_type}`:")
+            all_profiles.each { |p| UI.error("- '#{p}'") }
+          end
           UI.error("If you are certain that a profile should exist, double-check the recent changes to your match repository")
           UI.user_error!("No matching provisioning profiles found and can not create a new one because you enabled `readonly`. Check the output above for more information.")
         end
@@ -236,10 +252,16 @@ module Match
         self.files_to_commit << profile
       end
 
-      installed_profile = FastlaneCore::ProvisioningProfile.install(profile, keychain_path)
+      if Helper.mac?
+        installed_profile = FastlaneCore::ProvisioningProfile.install(profile, keychain_path)
+      end
       parsed = FastlaneCore::ProvisioningProfile.parse(profile, keychain_path)
       uuid = parsed["UUID"]
 
+      if params[:output_path]
+        FileUtils.cp(profile, params[:output_path])
+      end
+
       if spaceship && !spaceship.profile_exists(username: params[:username], uuid: uuid)
         # This profile is invalid, let's remove the local file and generate a new one
         File.delete(profile)
diff --git a/match/lib/match/storage/git_storage.rb b/match/lib/match/storage/git_storage.rb
index 7908f58ac..33203f3d1 100644
--- a/match/lib/match/storage/git_storage.rb
+++ b/match/lib/match/storage/git_storage.rb
@@ -60,7 +60,7 @@ module Match
         # No existing working directory, creating a new one now
         self.working_directory = Dir.mktmpdir
 
-        command = "git clone '#{self.git_url}' '#{self.working_directory}'"
+        command = "git clone #{self.git_url.shellescape} #{self.working_directory.shellescape}"
         if self.shallow_clone
           command << " --depth 1 --no-single-branch"
         elsif self.clone_branch_directly
@@ -74,9 +74,11 @@ module Match
 
         begin
           # GIT_TERMINAL_PROMPT will fail the `git clone` command if user credentials are missing
-          FastlaneCore::CommandExecutor.execute(command: "GIT_TERMINAL_PROMPT=0 #{command}",
-                                              print_all: FastlaneCore::Globals.verbose?,
-                                          print_command: FastlaneCore::Globals.verbose?)
+          Helper.with_env_values('GIT_TERMINAL_PROMPT' => '0') do
+            FastlaneCore::CommandExecutor.execute(command: command,
+                                                print_all: FastlaneCore::Globals.verbose?,
+                                            print_command: FastlaneCore::Globals.verbose?)
+          end
         rescue
           UI.error("Error cloning certificates repo, please make sure you have read access to the repository you want to use")
           if self.branch && self.clone_branch_directly
@@ -193,13 +195,15 @@ module Match
       def git_push(commands: [], commit_message: nil)
         commit_message ||= generate_commit_message
         commands << "git commit -m #{commit_message.shellescape}"
-        commands << "GIT_TERMINAL_PROMPT=0 git push origin #{self.branch.shellescape}"
+        commands << "git push origin #{self.branch.shellescape}"
 
         UI.message("Pushing changes to remote git repo...")
-        commands.each do |command|
-          FastlaneCore::CommandExecutor.execute(command: command,
+        Helper.with_env_values('GIT_TERMINAL_PROMPT' => '0') do
+          commands.each do |command|
+            FastlaneCore::CommandExecutor.execute(command: command,
                                                 print_all: FastlaneCore::Globals.verbose?,
-                                                print_command: FastlaneCore::Globals.verbose?)
+                                            print_command: FastlaneCore::Globals.verbose?)
+          end
         end
 
         self.clear_changes
diff --git a/match/lib/match/utils.rb b/match/lib/match/utils.rb
index 21907161f..1e366a088 100644
--- a/match/lib/match/utils.rb
+++ b/match/lib/match/utils.rb
@@ -32,7 +32,7 @@ module Match
     end
 
     def self.get_cert_info(cer_certificate_path)
-      cert = OpenSSL::X509::Certificate.new(File.read(cer_certificate_path))
+      cert = OpenSSL::X509::Certificate.new(File.binread(cer_certificate_path))
 
       # openssl output:
       # subject= /UID={User ID}/CN={Certificate Name}/OU={Certificate User}/O={Organisation}/C={Country}
@@ -54,7 +54,7 @@ module Match
                       .push([openssl_keys_to_readable_keys.fetch("notBefore"), cert.not_before])
                       .push([openssl_keys_to_readable_keys.fetch("notAfter"), cert.not_after])
     rescue => ex
-      UI.error(ex)
+      UI.error("get_cert_info: #{ex}")
       return {}
     end
 
diff --git a/match/spec/encryption/openssl_spec.rb b/match/spec/encryption/openssl_spec.rb
index 7683ad2ef..2237d2186 100644
--- a/match/spec/encryption/openssl_spec.rb
+++ b/match/spec/encryption/openssl_spec.rb
@@ -2,9 +2,10 @@ describe Match do
   describe Match::Encryption::OpenSSL do
     before do
       @directory = Dir.mktmpdir
-      @content = "#{Time.now.to_i} so random"
-      @full_path = File.join(@directory, "randomFile.mobileprovision")
-      File.write(@full_path, @content)
+      profile_path = "./match/spec/fixtures/test.mobileprovision"
+      FileUtils.cp(profile_path, @directory)
+      @full_path = File.join(@directory, "test.mobileprovision")
+      @content = File.binread(@full_path)
       @git_url = "https://github.com/fastlane/fastlane/tree/master/so_random"
       allow(Dir).to receive(:mktmpdir).and_return(@directory)
       ENV["MATCH_PASSWORD"] = '2"QAHg@v(Qp{=*n^'
@@ -15,12 +16,12 @@ describe Match do
       )
     end
 
-    it "encrypt" do
+    it "first encrypt, different content, then decrypt, initial content again" do
       @e.encrypt_files
-      expect(File.read(@full_path)).to_not(eq(@content))
+      expect(File.binread(@full_path)).to_not(eq(@content))
 
       @e.decrypt_files
-      expect(File.read(@full_path)).to eq(@content)
+      expect(File.binread(@full_path)).to eq(@content)
     end
 
     it "raises an exception if invalid password is passed" do
diff --git a/match/spec/storage/git_storage_spec.rb b/match/spec/storage/git_storage_spec.rb
index 1648cbd7a..beef9598a 100644
--- a/match/spec/storage/git_storage_spec.rb
+++ b/match/spec/storage/git_storage_spec.rb
@@ -17,7 +17,7 @@ describe Match do
         expect(Dir).to receive(:mktmpdir).and_return(path)
         git_url = "https://github.com/fastlane/fastlane/tree/master/certificates"
         shallow_clone = true
-        command = "GIT_TERMINAL_PROMPT=0 git clone '#{git_url}' '#{path}' --depth 1 --no-single-branch"
+        command = "git clone #{git_url.shellescape} #{path.shellescape} --depth 1 --no-single-branch"
         to_params = {
           command: command,
           print_all: nil,
@@ -44,7 +44,7 @@ describe Match do
         expect(Dir).to receive(:mktmpdir).and_return(path)
         git_url = "https://github.com/fastlane/fastlane/tree/master/certificates"
         shallow_clone = false
-        command = "GIT_TERMINAL_PROMPT=0 git clone '#{git_url}' '#{path}'"
+        command = "git clone #{git_url.shellescape} #{path.shellescape}"
         to_params = {
           command: command,
           print_all: nil,
@@ -74,7 +74,7 @@ describe Match do
         shallow_clone = false
 
         expected_commands = [
-          "GIT_TERMINAL_PROMPT=0 git clone '#{git_url}' '#{path}'",
+          "git clone #{git_url.shellescape} #{path.shellescape}",
           "git --no-pager branch --list origin/#{git_branch} --no-color -r",
           "git checkout --orphan #{git_branch}",
           "git reset --hard"
@@ -118,8 +118,8 @@ describe Match do
           "git add #{random_file}",
           "git add match_version.txt",
           "git commit -m " + '[fastlane] Updated appstore and platform ios'.shellescape,
-          "GIT_TERMINAL_PROMPT=0 git push origin master",
-          "GIT_TERMINAL_PROMPT=0 git clone '#{git_url}' '#{path}'"
+          "git push origin master",
+          "git clone #{git_url.shellescape} #{path.shellescape}"
         ]
 
         expected_commands.each do |command|
diff --git a/sigh/lib/sigh/runner.rb b/sigh/lib/sigh/runner.rb
index 312495fe3..9c8b5c8b1 100644
--- a/sigh/lib/sigh/runner.rb
+++ b/sigh/lib/sigh/runner.rb
@@ -199,13 +199,16 @@ module Sigh
         true
       end
 
-      unless Sigh.config[:skip_certificate_verification]
-        certificates = certificates.find_all do |c|
-          file = Tempfile.new('cert')
-          file.write(c.download_raw)
-          file.close
-
-          FastlaneCore::CertChecker.installed?(file.path)
+      # verify certificates
+      if Helper.mac?
+        unless Sigh.config[:skip_certificate_verification]
+          certificates = certificates.find_all do |c|
+            file = Tempfile.new('cert')
+            file.write(c.download_raw)
+            file.close
+
+            FastlaneCore::CertChecker.installed?(file.path)
+          end
         end
       end
 
