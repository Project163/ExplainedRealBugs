diff --git a/fastlane/lib/fastlane.rb b/fastlane/lib/fastlane.rb
index 2cfa2a22f..2cff36178 100644
--- a/fastlane/lib/fastlane.rb
+++ b/fastlane/lib/fastlane.rb
@@ -20,8 +20,6 @@ require 'fastlane/supported_platforms'
 require 'fastlane/configuration_helper'
 require 'fastlane/one_off'
 require 'fastlane/server/socket_server_action_command_executor'
-require 'fastlane/server/command_executor'
-require 'fastlane/server/command'
 require 'fastlane/server/socket_server'
 require 'fastlane/command_line_handler'
 require 'fastlane/documentation/docs_generator'
diff --git a/fastlane/lib/fastlane/commands_generator.rb b/fastlane/lib/fastlane/commands_generator.rb
index 317506bbb..183c7be42 100644
--- a/fastlane/lib/fastlane/commands_generator.rb
+++ b/fastlane/lib/fastlane/commands_generator.rb
@@ -43,7 +43,10 @@ module Fastlane
     ensure
       Fastlane::PluginUpdateManager.show_update_status
       if FastlaneCore::Globals.capture_output?
-        FastlaneCore::Globals.captured_output = Helper.strip_ansi_colors($stdout.string)
+        if $stdout.respond_to?(:string)
+          # Sometimes you can get NoMethodError: undefined method `string' for #<IO:<STDOUT>> when runing with FastlaneRunner (swift)
+          FastlaneCore::Globals.captured_output = Helper.strip_ansi_colors($stdout.string)
+        end
         $stdout = STDOUT
         $stderr = STDERR
 
@@ -87,7 +90,7 @@ module Fastlane
 
       global_option('--verbose') { FastlaneCore::Globals.verbose = true }
       global_option('--capture_output', 'Captures the output of the current run, and generates a markdown issue template') do
-        FastlaneCore::Globals.capture_output = true
+        FastlaneCore::Globals.capture_output = false
         FastlaneCore::Globals.verbose = true
       end
       global_option('--troubleshoot', 'Enables extended verbose mode. Use with caution, as this even includes ALL sensitive data. Cannot be used on CI.')
diff --git a/fastlane/lib/fastlane/lane_manager.rb b/fastlane/lib/fastlane/lane_manager.rb
index 89369c07d..9ce604ac3 100644
--- a/fastlane/lib/fastlane/lane_manager.rb
+++ b/fastlane/lib/fastlane/lane_manager.rb
@@ -68,7 +68,6 @@ module Fastlane
       Fastlane::DocsGenerator.run(ff) unless skip_docs?
 
       duration = ((Time.now - started) / 60.0).round
-
       finish_fastlane(ff, duration, e)
 
       return ff
@@ -78,50 +77,6 @@ module Fastlane
       Helper.test? || FastlaneCore::Env.truthy?("FASTLANE_SKIP_DOCS")
     end
 
-    # All the finishing up that needs to be done
-    def self.finish_fastlane(ff, duration, error)
-      # Finished with all the lanes
-      Fastlane::JUnitGenerator.generate(Fastlane::Actions.executed_actions)
-      print_table(Fastlane::Actions.executed_actions)
-
-      Fastlane::PluginUpdateManager.show_update_status
-
-      if error
-        UI.error 'fastlane finished with errors'
-        raise error
-      elsif duration > 5
-        UI.success "fastlane.tools just saved you #{duration} minutes! ðŸŽ‰"
-      else
-        UI.success 'fastlane.tools finished successfully ðŸŽ‰'
-      end
-    end
-
-    # Print a table as summary of the executed actions
-    def self.print_table(actions)
-      return if actions.count == 0
-
-      require 'terminal-table'
-
-      rows = []
-      actions.each_with_index do |current, i|
-        is_error_step = !current[:error].to_s.empty?
-
-        name = current[:name][0..60]
-        name = name.red if is_error_step
-        index = i + 1
-        index = "ðŸ’¥" if is_error_step
-        rows << [index, name, current[:time].to_i]
-      end
-
-      puts ""
-      puts Terminal::Table.new(
-        title: "fastlane summary".green,
-        headings: ["Step", "Action", "Time (in s)"],
-        rows: FastlaneCore::PrintTable.transform_output(rows)
-      )
-      puts ""
-    end
-
     # Lane chooser if user didn't provide a lane
     # @param platform: is probably nil, but user might have called `fastlane android`, and only wants to list those actions
     def self.choose_lane(ff, platform)
diff --git a/fastlane/lib/fastlane/lane_manager_base.rb b/fastlane/lib/fastlane/lane_manager_base.rb
index 49d1d8e0f..fa456b48f 100644
--- a/fastlane/lib/fastlane/lane_manager_base.rb
+++ b/fastlane/lib/fastlane/lane_manager_base.rb
@@ -7,7 +7,7 @@ module Fastlane
     end
 
     # All the finishing up that needs to be done
-    def self.finish_fastlane(ff, duration, error)
+    def self.finish_fastlane(ff, duration, error, skip_message: false)
       # Sometimes we don't have a fastfile because we're using Fastfile.swift
       unless ff.nil?
         ff.runner.did_finish
@@ -20,12 +20,12 @@ module Fastlane
       Fastlane::PluginUpdateManager.show_update_status
 
       if error
-        UI.error 'fastlane finished with errors'
+        UI.error 'fastlane finished with errors' unless skip_message
         raise error
       elsif duration > 5
-        UI.success "fastlane.tools just saved you #{duration} minutes! ðŸŽ‰"
+        UI.success "fastlane.tools just saved you #{duration} minutes! ðŸŽ‰" unless skip_message
       else
-        UI.success 'fastlane.tools finished successfully ðŸŽ‰'
+        UI.success 'fastlane.tools finished successfully ðŸŽ‰' unless skip_message
       end
     end
 
diff --git a/fastlane/lib/fastlane/runner.rb b/fastlane/lib/fastlane/runner.rb
index 1758ff02c..bc16937cc 100644
--- a/fastlane/lib/fastlane/runner.rb
+++ b/fastlane/lib/fastlane/runner.rb
@@ -347,6 +347,10 @@ module Fastlane
       @lanes ||= {}
     end
 
+    def did_finish
+      # to maintain compatibility with other sibling classes that have this API
+    end
+
     def before_each_blocks
       @before_each ||= {}
     end
diff --git a/fastlane/lib/fastlane/server/command.rb b/fastlane/lib/fastlane/server/action_command.rb
similarity index 63%
rename from fastlane/lib/fastlane/server/command.rb
rename to fastlane/lib/fastlane/server/action_command.rb
index f6fccd6c2..21a048653 100644
--- a/fastlane/lib/fastlane/server/command.rb
+++ b/fastlane/lib/fastlane/server/action_command.rb
@@ -1,6 +1,5 @@
-require 'json'
-
 module Fastlane
+  # Represents an argument to the ActionCommand
   class Argument
     def initialize(json: nil)
       @name = json['name']
@@ -25,19 +24,28 @@ module Fastlane
     attr_reader :value_type
   end
 
-  class Command
+  # Represents a command that is meant to execute an Action on the client's behalf
+  class ActionCommand
+    attr_reader :command_id # always present
+    attr_reader :args # always present
+    attr_reader :method_name # always present
+    attr_reader :class_name # only present when executing a class-method
+
     def initialize(json: nil)
-      command_json = JSON.parse(json)
-      @method_name = command_json['methodName']
-      @class_name = command_json['className']
-      @command_id = command_json['commandID']
+      @method_name = json['methodName']
+      @class_name = json['className']
+      @command_id = json['commandID']
 
-      args_json = command_json['args'] ||= []
+      args_json = json['args'] ||= []
       @args = args_json.map do |arg|
         Argument.new(json: arg)
       end
     end
 
+    def cancel_signal?
+      return @command_id == "cancelFastlaneRun"
+    end
+
     def target_class
       unless class_name
         return nil
@@ -49,22 +57,5 @@ module Fastlane
     def is_class_method_command
       return class_name.to_s.length > 0
     end
-
-    attr_reader :command_id # always present
-    attr_reader :args # always present
-    attr_reader :method_name # always present
-    attr_reader :class_name # only present when executing a class-method
-  end
-
-  class CommandReturn
-    attr_reader :return_value
-    attr_reader :return_value_type
-    attr_reader :closure_argument_value
-
-    def initialize(return_value: nil, return_value_type: nil, closure_argument_value: nil)
-      @return_value = return_value
-      @closure_argument_value = closure_argument_value
-      @return_value_type = return_value_type
-    end
   end
 end
diff --git a/fastlane/lib/fastlane/server/action_command_return.rb b/fastlane/lib/fastlane/server/action_command_return.rb
new file mode 100644
index 000000000..35f4d27be
--- /dev/null
+++ b/fastlane/lib/fastlane/server/action_command_return.rb
@@ -0,0 +1,14 @@
+module Fastlane
+  # Encapsulates the result and description of a return object returned by an executed fastlane action
+  class ActionCommandReturn
+    attr_reader :return_value
+    attr_reader :return_value_type
+    attr_reader :closure_argument_value
+
+    def initialize(return_value: nil, return_value_type: nil, closure_argument_value: nil)
+      @return_value = return_value
+      @closure_argument_value = closure_argument_value
+      @return_value_type = return_value_type
+    end
+  end
+end
diff --git a/fastlane/lib/fastlane/server/command_executor.rb b/fastlane/lib/fastlane/server/command_executor.rb
index 5cd6b4824..d59423173 100644
--- a/fastlane/lib/fastlane/server/command_executor.rb
+++ b/fastlane/lib/fastlane/server/command_executor.rb
@@ -1,5 +1,3 @@
-require 'fastlane/server/command.rb'
-
 module Fastlane
   class CommandExecutor
     def execute(command: nil, target_object: nil)
diff --git a/fastlane/lib/fastlane/server/command_parser.rb b/fastlane/lib/fastlane/server/command_parser.rb
new file mode 100644
index 000000000..dadd53f8e
--- /dev/null
+++ b/fastlane/lib/fastlane/server/command_parser.rb
@@ -0,0 +1,20 @@
+require 'fastlane/server/action_command.rb'
+require 'fastlane/server/control_command.rb'
+require 'json'
+
+module Fastlane
+  class CommandParser
+    def self.parse(json: nil)
+      command_json = JSON.parse(json)
+      command_type = command_json['commandType'].to_sym
+      command = command_json['command']
+
+      case command_type
+      when :action
+        return ActionCommand.new(json: command)
+      when :control
+        return ControlCommand.new(json: command)
+      end
+    end
+  end
+end
diff --git a/fastlane/lib/fastlane/server/control_command.rb b/fastlane/lib/fastlane/server/control_command.rb
new file mode 100644
index 000000000..c1e32cec9
--- /dev/null
+++ b/fastlane/lib/fastlane/server/control_command.rb
@@ -0,0 +1,23 @@
+module Fastlane
+  # Represents a command that is meant to signal the server to do something on the client's behalf
+  # Examples are: :cancelFastlaneRune, and :done
+  class ControlCommand
+    attr_reader :command
+    attr_reader :user_message
+    attr_reader :reason
+
+    def initialize(json: nil)
+      @command = json['command'].to_sym
+      @user_message = json['userMessage']
+      @reason = json['reason'].to_sym if json['reason']
+    end
+
+    def cancel_signal?
+      return @command == :cancelFastlaneRun
+    end
+
+    def done_signal?
+      return @command == :done
+    end
+  end
+end
diff --git a/fastlane/lib/fastlane/server/json_return_value_processor.rb b/fastlane/lib/fastlane/server/json_return_value_processor.rb
new file mode 100644
index 000000000..c9fbaee7d
--- /dev/null
+++ b/fastlane/lib/fastlane/server/json_return_value_processor.rb
@@ -0,0 +1,71 @@
+require 'json'
+
+module Fastlane
+  class JSONReturnValueProcessor
+    def prepare_object(return_value: nil, return_value_type: nil)
+      case return_value_type
+      when nil
+        UI.verbose("return_value_type is nil value: #{return_value}")
+        return process_value_as_string(return_value: return_value)
+      when :string
+        return process_value_as_string(return_value: return_value)
+      when :int
+        return process_value_as_int(return_value: return_value)
+      when :bool
+        return process_value_as_bool(return_value: return_value)
+      when :array_of_strings
+        return process_value_as_array_of_strings(return_value: return_value)
+      when :hash_of_strings
+        return process_value_as_hash_of_strings(return_value: return_value)
+      else
+        UI.verbose("Unknown return type defined: #{return_value_type} for value: #{return_value}")
+        return process_value_as_string(return_value: return_value)
+      end
+    end
+
+    def process_value_as_string(return_value: nil)
+      if return_value.nil?
+        return_value = ""
+      end
+
+      # quirks_mode because sometimes the built-in library is used for some folks and that needs quirks_mode: true
+      return JSON.generate(return_value.to_s, quirks_mode: true)
+    end
+
+    def process_value_as_array_of_strings(return_value: nil)
+      if return_value.nil?
+        return_value = []
+      end
+
+      # quirks_mode shouldn't be required for real objects
+      return JSON.generate(return_value)
+    end
+
+    def process_value_as_hash_of_strings(return_value: nil)
+      if return_value.nil?
+        return_value = {}
+      end
+
+      # quirks_mode shouldn't be required for real objects
+      return JSON.generate(return_value)
+    end
+
+    def process_value_as_bool(return_value: nil)
+      if return_value.nil?
+        return_value = false
+      end
+
+      # quirks_mode because sometimes the built-in library is used for some folks and that needs quirks_mode: true
+      return JSON.generate(return_value.to_s, quirks_mode: true)
+    end
+
+    def process_value_as_int(return_value: nil)
+      if return_value.nil?
+        return_value = 0
+      end
+
+      # quirks_mode because sometimes the built-in library is used for some folks and that needs quirks_mode: true
+      return JSON.generate(return_value.to_s, quirks_mode: true)
+    end
+  end
+end
diff --git a/fastlane/lib/fastlane/server/socket_server.rb b/fastlane/lib/fastlane/server/socket_server.rb
index efab066c9..d62e0c5a6 100644
--- a/fastlane/lib/fastlane/server/socket_server.rb
+++ b/fastlane/lib/fastlane/server/socket_server.rb
@@ -1,10 +1,17 @@
-require 'fastlane/server/command.rb'
 require 'fastlane/server/command_executor.rb'
+require 'fastlane/server/command_parser.rb'
+require 'fastlane/server/json_return_value_processor.rb'
 require 'socket'
 require 'json'
 
 module Fastlane
   class SocketServer
+    COMMAND_EXECUTION_STATE = {
+      ready: :ready,
+      already_shutdown: :already_shutdown,
+      error: :error
+    }
+
     attr_accessor :command_executor
     attr_accessor :return_value_processor
 
@@ -24,53 +31,112 @@ module Fastlane
       @stay_alive = stay_alive
     end
 
-    # This is the public API, don't call anything else
+    # this is the public API, don't call anything else
     def start
-      while listen
-        # Loop for-ev-er
+      listen
+
+      while @stay_alive
+        UI.important("stay_alive is set to true, restarting server")
+        listen
       end
     end
 
     private
 
     def receive_and_process_commands
-      # We'll break out of the infinite loop somehow, either error or 'done' message
-      ended_loop_due_to_error = true
-
-      loop do # No idea how many commands are coming, so we loop until an error or the done command is sent
-        str = nil
+      loop do # no idea how many commands are coming, so we loop until an error or the done command is sent
+        execution_state = COMMAND_EXECUTION_STATE[:ready]
 
+        command_string = nil
         begin
-          str = @client.recv(1_048_576) # 1024 * 1024
+          command_string = @client.recv(1_048_576) # 1024 * 1024
         rescue Errno::ECONNRESET => e
           UI.verbose(e)
-          break
+          execution_state = COMMAND_EXECUTION_STATE[:error]
         end
 
-        if str == 'done'
-          time = Time.new
-          UI.verbose("[#{time.usec}]: received done signal, shutting down")
-          ended_loop_due_to_error = false
-          break
+        if execution_state == COMMAND_EXECUTION_STATE[:ready]
+          # Ok, all is good, let's see what command we have
+          execution_state = parse_and_execute_command(command_string: command_string)
         end
-        response_json = process_command(command_json: str)
 
-        time = Time.new
-        UI.verbose("[#{time.usec}]: sending #{response_json}")
-        begin
-          @client.puts(response_json) # Send some json to the client
-        rescue Errno::EPIPE => e
-          UI.verbose(e)
+        case execution_state
+        when COMMAND_EXECUTION_STATE[:ready]
+          # command executed successfully, let's setup for the next command
+          next
+        when COMMAND_EXECUTION_STATE[:already_shutdown]
+          # we shutdown in response to a command, nothing left to do but exit
+          break
+        when COMMAND_EXECUTION_STATE[:error]
+          # we got an error somewhere, let's shutdown and exit
+          handle_disconnect(error: true, exit_reason: :error)
           break
         end
       end
+    end
+
+    def parse_and_execute_command(command_string: nil)
+      command = CommandParser.parse(json: command_string)
+      case command
+      when ControlCommand
+        return handle_control_command(command)
+      when ActionCommand
+        return handle_action_command(command)
+      end
 
-      return handle_disconnect(error: ended_loop_due_to_error)
+      # catch all
+      raise "Command #{command} not supported"
+    end
+
+    # we got a server control command from the client to do something like shutdown
+    def handle_control_command(command)
+      exit_reason = nil
+      if command.cancel_signal?
+        UI.verbose("received cancel signal shutting down, reason: #{command.reason}")
+
+        # send an ack to the client to let it know we're shutting down
+        cancel_response = '{"payload":{"status":"cancelled"}}'
+        send_response(cancel_response)
+
+        exit_reason = :cancelled
+      elsif command.done_signal?
+        UI.verbose("received done signal shutting down")
+
+        # client is already in the process of shutting down, no need to ack
+        exit_reason = :done
+      end
+
+      # if the command came in with a user-facing message, display it
+      if command.user_message
+        UI.important(command.user_message)
+      end
+
+      # currently all control commands should trigger a disconnect and shutdown
+      handle_disconnect(error: false, exit_reason: exit_reason)
+      return COMMAND_EXECUTION_STATE[:already_shutdown]
+    end
+
+    # execute and send back response to client
+    def handle_action_command(command)
+      response_json = process_action_command(command: command)
+      return send_response(response_json)
+    end
+
+    # send json back to client
+    def send_response(json)
+      UI.verbose("sending #{json}")
+      begin
+        @client.puts(json) # Send some json to the client
+      rescue Errno::EPIPE => e
+        UI.verbose(e)
+        return COMMAND_EXECUTION_STATE[:error]
+      end
+      return COMMAND_EXECUTION_STATE[:ready]
     end
 
     def listen
       @server = TCPServer.open('localhost', 2000) # Socket to listen on port 2000
-      UI.message("Waiting for #{@connection_timeout} seconds for a connection from FastlaneRunner")
+      UI.verbose("Waiting for #{@connection_timeout} seconds for a connection from FastlaneRunner")
 
       # set thread local to ready so we can check it
       Thread.current[:ready] = true
@@ -84,34 +150,32 @@ module Fastlane
       rescue StandardError => e
         UI.user_error!("Something went wrong while waiting for a connection from the FastlaneRunner binary, shutting down\n#{e}")
       end
-      UI.message("Client connected")
+      UI.verbose("Client connected")
 
+      # this loops forever
       receive_and_process_commands
     end
 
-    def handle_disconnect(error: false)
-      UI.important("Client disconnected, or a pipe broke") if error
-      if @stay_alive
-        UI.important("stay_alive is set to true, restarting server")
-        # clean up before restart
-        @client.close
-        @client = nil
+    def handle_disconnect(error: false, exit_reason: :error)
+      Thread.current[:exit_reason] = exit_reason
 
-        @server.close
-        @server = nil
-        return true # Restart server
-      end
-      return false # Don't restart server
+      UI.important("Client disconnected, a pipe broke, or received malformed data") if exit_reason == :error
+      # clean up
+      @client.close
+      @client = nil
+
+      @server.close
+      @server = nil
     end
 
-    def process_command(command_json: nil)
-      time = Time.new
-      UI.verbose("[#{time.usec}]: received command:#{command_json}")
-      return execute_command(command_json: command_json)
+    # record fastlane action command and then execute it
+    def process_action_command(command: nil)
+      UI.verbose("received command:#{command.inspect}")
+      return execute_action_command(command: command)
     end
 
-    def execute_command(command_json: nil)
-      command = Command.new(json: command_json)
+    # execute fastlane action command
+    def execute_action_command(command: nil)
       command_return = @command_executor.execute(command: command, target_object: nil)
       ## probably need to just return Strings, or ready_for_next with object isn't String
       return_object = command_return.return_value
@@ -133,8 +197,11 @@ module Fastlane
         closure_arg = ', "closure_argument_value": ' + closure_arg
       end
 
+      Thread.current[:exception] = nil
       return '{"payload":{"status":"ready_for_next", "return_object":' + return_object + closure_arg + '}}'
     rescue StandardError => e
+      Thread.current[:exception] = e
+
       exception_array = []
       exception_array << "#{e.class}:"
       exception_array << e.backtrace
@@ -146,72 +213,4 @@ module Fastlane
       return "{\"payload\":{\"status\":\"failure\",\"failure_information\":#{exception_array.flatten}}}"
     end
   end
-
-  class JSONReturnValueProcessor
-    def prepare_object(return_value: nil, return_value_type: nil)
-      case return_value_type
-      when nil
-        UI.verbose("return_value_type is nil value: #{return_value}")
-        return process_value_as_string(return_value: return_value)
-      when :string
-        return process_value_as_string(return_value: return_value)
-      when :int
-        return process_value_as_int(return_value: return_value)
-      when :bool
-        return process_value_as_bool(return_value: return_value)
-      when :array_of_strings
-        return process_value_as_array_of_strings(return_value: return_value)
-      when :hash_of_strings
-        return process_value_as_hash_of_strings(return_value: return_value)
-      else
-        UI.verbose("Unknown return type defined: #{return_value_type} for value: #{return_value}")
-        return process_value_as_string(return_value: return_value)
-      end
-    end
-
-    def process_value_as_string(return_value: nil)
-      if return_value.nil?
-        return_value = ""
-      end
-
-      # quirks_mode because sometimes the built-in library is used for some folks and that needs quirks_mode: true
-      return JSON.generate(return_value.to_s, quirks_mode: true)
-    end
-
-    def process_value_as_array_of_strings(return_value: nil)
-      if return_value.nil?
-        return_value = []
-      end
-
-      # quirks_mode shouldn't be required for real objects
-      return JSON.generate(return_value)
-    end
-
-    def process_value_as_hash_of_strings(return_value: nil)
-      if return_value.nil?
-        return_value = {}
-      end
-
-      # quirks_mode shouldn't be required for real objects
-      return JSON.generate(return_value)
-    end
-
-    def process_value_as_bool(return_value: nil)
-      if return_value.nil?
-        return_value = false
-      end
-
-      # quirks_mode because sometimes the built-in library is used for some folks and that needs quirks_mode: true
-      return JSON.generate(return_value.to_s, quirks_mode: true)
-    end
-
-    def process_value_as_int(return_value: nil)
-      if return_value.nil?
-        return_value = 0
-      end
-
-      # quirks_mode because sometimes the built-in library is used for some folks and that needs quirks_mode: true
-      return JSON.generate(return_value.to_s, quirks_mode: true)
-    end
-  end
 end
diff --git a/fastlane/lib/fastlane/server/socket_server_action_command_executor.rb b/fastlane/lib/fastlane/server/socket_server_action_command_executor.rb
index 4bbf127a8..2601b9c3a 100644
--- a/fastlane/lib/fastlane/server/socket_server_action_command_executor.rb
+++ b/fastlane/lib/fastlane/server/socket_server_action_command_executor.rb
@@ -1,4 +1,5 @@
-require 'fastlane/server/command.rb'
+require 'fastlane/server/action_command_return.rb'
+require 'fastlane/server/command_parser.rb'
 require 'fastlane/server/command_executor.rb'
 
 module Fastlane
@@ -44,7 +45,7 @@ module Fastlane
         parameter_map: parameter_map
       )
 
-      command_return = CommandReturn.new(
+      command_return = ActionCommandReturn.new(
         return_value: action_return,
         return_value_type: action_class_ref.return_type,
         closure_argument_value: closure_argument_value
@@ -88,7 +89,7 @@ module Fastlane
         action_return = Fastlane::FastFile.sh(command_param, log: log_param, error_callback: error_callback)
       end
 
-      command_return = CommandReturn.new(
+      command_return = ActionCommandReturn.new(
         return_value: action_return,
         return_value_type: action_return_type,
         closure_argument_value: closure_argument_value
diff --git a/fastlane/lib/fastlane/swift_lane_manager.rb b/fastlane/lib/fastlane/swift_lane_manager.rb
index a0ddbc366..e92823ee2 100644
--- a/fastlane/lib/fastlane/swift_lane_manager.rb
+++ b/fastlane/lib/fastlane/swift_lane_manager.rb
@@ -26,23 +26,34 @@ module Fastlane
         socket_thread = self.start_socket_thread
         sleep(0.250) while socket_thread[:ready].nil?
         # wait on socket_thread to be in ready state, then start the runner thread
-        runner_thread = self.cruise_swift_lane_in_thread(lane, parameters)
+        self.cruise_swift_lane_in_thread(lane, parameters)
 
-        runner_thread.join
         socket_thread.join
       rescue Exception => ex # rubocop:disable Lint/RescueException
+        e = ex
+      end
+      # If we have a thread exception, drop that in the exception
+      # won't ever have a situation where e is non-nil, and socket_thread[:exception] is also non-nil
+      e ||= socket_thread[:exception]
+
+      unless e.nil?
+        print_lane_context
+
         # We also catch Exception, since the implemented action might send a SystemExit signal
         # (or similar). We still want to catch that, since we want properly finish running fastlane
         # Tested with `xcake`, which throws a `Xcake::Informative` object
+        UI.error e.to_s if e.kind_of?(StandardError) # we don't want to print things like 'system exit'
+      end
 
-        print_lane_context
-        UI.error ex.to_s if ex.kind_of?(StandardError) # we don't want to print things like 'system exit'
-        e = ex
+      skip_message = false
+      exit_reason = socket_thread[:exit_reason]
+      if exit_reason == :cancelled && e.nil?
+        skip_message = true
       end
 
       duration = ((Time.now - started) / 60.0).round
 
-      finish_fastlane(nil, duration, e)
+      finish_fastlane(nil, duration, e, skip_message: skip_message)
     end
 
     def self.display_lanes
diff --git a/fastlane/swift/ControlCommand.swift b/fastlane/swift/ControlCommand.swift
new file mode 100644
index 000000000..ca6c916de
--- /dev/null
+++ b/fastlane/swift/ControlCommand.swift
@@ -0,0 +1,71 @@
+//
+//  ClientShutdownCommand.swift
+//  FastlaneRunner
+//
+//  Created by Joshua Liebowitz on 1/3/18.
+//  Copyright Â© 2018 Joshua Liebowitz. All rights reserved.
+//
+
+import Foundation
+
+struct ControlCommand: RubyCommandable {
+    static let commandKey = "command"
+    var type: CommandType { return .control }
+
+    enum ShutdownCommandType {
+        static let userMessageKey: String = "userMessage"
+
+        enum CancelReason {
+            static let reasonKey: String = "reason"
+            case clientError
+            case serverError
+
+            var reasonText: String {
+                switch self {
+                case .clientError:
+                    return "clientError"
+                case .serverError:
+                    return "serverError"
+                }
+            }
+        }
+
+        case done
+        case cancel(cancelReason: CancelReason)
+
+        var token: String {
+            switch self {
+            case .done:
+                return "done"
+            case .cancel:
+                return "cancelFastlaneRun"
+            }
+        }
+    }
+
+    let message: String?
+    let shutdownCommandType: ShutdownCommandType
+    var commandJson: String {
+        var jsonDictionary: [String: Any] = [ControlCommand.commandKey : self.shutdownCommandType.token]
+
+        if let message = message {
+            jsonDictionary[ShutdownCommandType.userMessageKey] = message
+        }
+        if case .cancel(let reason) = shutdownCommandType {
+            jsonDictionary[ShutdownCommandType.CancelReason.reasonKey] = reason.reasonText
+        }
+
+        let jsonData = try! JSONSerialization.data(withJSONObject: jsonDictionary, options: [])
+        let jsonString = String(data: jsonData, encoding: .utf8)!
+        return jsonString
+    }
+
+    init(commandType: ShutdownCommandType, message: String? = nil) {
+        self.shutdownCommandType = commandType
+        self.message = message
+    }
+}
+
+// Please don't remove the lines below
+// They are used to detect outdated files
+// FastlaneRunnerAPIVersion [0.9.2]
diff --git a/fastlane/swift/FastlaneSwiftRunner/FastlaneSwiftRunner.xcodeproj/project.pbxproj b/fastlane/swift/FastlaneSwiftRunner/FastlaneSwiftRunner.xcodeproj/project.pbxproj
index 52476b5c5..b902d6b24 100644
--- a/fastlane/swift/FastlaneSwiftRunner/FastlaneSwiftRunner.xcodeproj/project.pbxproj
+++ b/fastlane/swift/FastlaneSwiftRunner/FastlaneSwiftRunner.xcodeproj/project.pbxproj
@@ -32,7 +32,9 @@
 		D55B28C91F6C588300DC42C5 /* Snapshotfile.swift in Sources */ = {isa = PBXBuildFile; fileRef = D55B28C21F6C588300DC42C5 /* Snapshotfile.swift */; };
 		D5A7C48F1F7C4DAF00A91DE6 /* Appfile.swift in Sources */ = {isa = PBXBuildFile; fileRef = D5A7C48D1F7C4DAF00A91DE6 /* Appfile.swift */; };
 		D5A7C4901F7C4DAF00A91DE6 /* Fastfile.swift in Sources */ = {isa = PBXBuildFile; fileRef = D5A7C48E1F7C4DAF00A91DE6 /* Fastfile.swift */; };
+		D5B8A5B31FFDC49E00536B24 /* ControlCommand.swift in Sources */ = {isa = PBXBuildFile; fileRef = D5B8A5B21FFDC49D00536B24 /* ControlCommand.swift */; };
 		D5BAFD121F7DAAFC0030B324 /* ArgumentProcessor.swift in Sources */ = {isa = PBXBuildFile; fileRef = D5BAFD111F7DAAFC0030B324 /* ArgumentProcessor.swift */; };
+		D5D1DE991FFEE8EA00502A00 /* RubyCommandable.swift in Sources */ = {isa = PBXBuildFile; fileRef = D5D1DE981FFEE8E900502A00 /* RubyCommandable.swift */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXFileReference section */
@@ -62,7 +64,9 @@
 		D55B28C21F6C588300DC42C5 /* Snapshotfile.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; name = Snapshotfile.swift; path = ../Snapshotfile.swift; sourceTree = "<group>"; };
 		D5A7C48D1F7C4DAF00A91DE6 /* Appfile.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = Appfile.swift; path = ../Appfile.swift; sourceTree = "<group>"; };
 		D5A7C48E1F7C4DAF00A91DE6 /* Fastfile.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = Fastfile.swift; path = ../Fastfile.swift; sourceTree = "<group>"; };
+		D5B8A5B21FFDC49D00536B24 /* ControlCommand.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; name = ControlCommand.swift; path = ../ControlCommand.swift; sourceTree = "<group>"; };
 		D5BAFD111F7DAAFC0030B324 /* ArgumentProcessor.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = ArgumentProcessor.swift; path = ../ArgumentProcessor.swift; sourceTree = "<group>"; };
+		D5D1DE981FFEE8E900502A00 /* RubyCommandable.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; name = RubyCommandable.swift; path = ../RubyCommandable.swift; sourceTree = "<group>"; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
@@ -107,7 +111,9 @@
 		B3BA65B11F5A325E00B34850 /* Networking */ = {
 			isa = PBXGroup;
 			children = (
+				D5B8A5B21FFDC49D00536B24 /* ControlCommand.swift */,
 				B3BA65A01F5A269100B34850 /* RubyCommand.swift */,
+				D5D1DE981FFEE8E900502A00 /* RubyCommandable.swift */,
 				B3BA65A11F5A269100B34850 /* Runner.swift */,
 				B3BA65A21F5A269100B34850 /* SocketClient.swift */,
 				B3BA65A31F5A269100B34850 /* SocketClientDelegateProtocol.swift */,
@@ -225,6 +231,7 @@
 			buildActionMask = 2147483647;
 			files = (
 				B3BA65A91F5A269100B34850 /* RubyCommand.swift in Sources */,
+				D5D1DE991FFEE8EA00502A00 /* RubyCommandable.swift in Sources */,
 				D55B28C41F6C588300DC42C5 /* Gymfile.swift in Sources */,
 				B302067D1F5E3E9000DE6EBD /* MatchfileProtocol.swift in Sources */,
 				B3BA65AC1F5A269100B34850 /* SocketClientDelegateProtocol.swift in Sources */,
@@ -243,6 +250,7 @@
 				B30206811F5E3E9000DE6EBD /* DeliverfileProtocol.swift in Sources */,
 				B3BA65AA1F5A269100B34850 /* Runner.swift in Sources */,
 				B3BA65AF1F5A2D5C00B34850 /* RunnerArgument.swift in Sources */,
+				D5B8A5B31FFDC49E00536B24 /* ControlCommand.swift in Sources */,
 				B302067E1F5E3E9000DE6EBD /* PrecheckfileProtocol.swift in Sources */,
 				B3BA65AD1F5A269100B34850 /* SocketResponse.swift in Sources */,
 				B3BA65A81F5A269100B34850 /* main.swift in Sources */,
diff --git a/fastlane/swift/LaneFileProtocol.swift b/fastlane/swift/LaneFileProtocol.swift
index ed11a7f9e..cc422fa47 100644
--- a/fastlane/swift/LaneFileProtocol.swift
+++ b/fastlane/swift/LaneFileProtocol.swift
@@ -10,8 +10,8 @@ import Foundation
 
 public protocol LaneFileProtocol: class {
     var fastlaneVersion: String { get }
-    static func runLane(named: String, parameters: [String : String])
-    
+    static func runLane(named: String, parameters: [String : String]) -> Bool
+
     func recordLaneDescriptions()
     func beforeAll()
     func afterAll(currentLane: String)
@@ -29,38 +29,54 @@ public extension LaneFileProtocol {
 @objcMembers
 public class LaneFile: NSObject, LaneFileProtocol {
     private(set) static var fastfileInstance: Fastfile?
-    
+
     // Called before any lane is executed.
     private func setupAllTheThings() {
-        // Step 1, add lange descriptions
-        (self as! Fastfile).recordLaneDescriptions()
-        
-        // Step 2, run beforeAll() function
         LaneFile.fastfileInstance!.beforeAll()
     }
-    
-    public static var lanes: [String : String] {
-        var laneToMethodName: [String : String] = [:]
+
+    private static func trimLaneFromName(laneName: String) -> String {
+        return String(laneName.prefix(laneName.count - 4))
+    }
+
+    private static func trimLaneWithOptionsFromName(laneName: String) -> String {
+        return String(laneName.prefix(laneName.count - 12))
+    }
+
+    private static var laneFunctionNames: [String] {
+        var lanes: [String] = []
         var methodCount: UInt32 = 0
         let methodList = class_copyMethodList(self, &methodCount)
         for i in 0..<Int(methodCount) {
             let selName = sel_getName(method_getName(methodList![i]))
             let name = String(cString: selName)
+            let lowercasedName = name.lowercased()
+            if lowercasedName.hasSuffix("lane") || lowercasedName.hasSuffix("lanewithoptions:") {
+                lanes.append(name)
+            }
+        }
+        return lanes
+    }
+
+    public static var lanes: [String : String] {
+        var laneToMethodName: [String : String] = [:]
+        self.laneFunctionNames.forEach { name in
             let lowercasedName = name.lowercased()
             if lowercasedName.hasSuffix("lane") {
                 laneToMethodName[lowercasedName] = name
-                let lowercasedNameNoLane = String(lowercasedName.prefix(lowercasedName.count - 4))
+                let lowercasedNameNoLane = trimLaneFromName(laneName: lowercasedName)
                 laneToMethodName[lowercasedNameNoLane] = name
             } else if lowercasedName.hasSuffix("lanewithoptions:") {
-                let lowercasedNameNoOptions = String(lowercasedName.prefix(lowercasedName.count - 12))
+                let lowercasedNameNoOptions = trimLaneWithOptionsFromName(laneName: lowercasedName)
                 laneToMethodName[lowercasedNameNoOptions] = name
-                let lowercasedNameNoLane = String(lowercasedNameNoOptions.prefix(lowercasedNameNoOptions.count - 4))
+                let lowercasedNameNoLane = trimLaneFromName(laneName: lowercasedNameNoOptions)
                 laneToMethodName[lowercasedNameNoLane] = name
             }
         }
+
         return laneToMethodName
     }
-    
+
     public static func loadFastfile() {
         if self.fastfileInstance == nil {
             let fastfileType: AnyObject.Type = NSClassFromString(self.className())!
@@ -69,38 +85,50 @@ public class LaneFile: NSObject, LaneFileProtocol {
             self.fastfileInstance = currentFastfileInstance
         }
     }
-    
-    public static func runLane(named: String, parameters: [String : String]) {
+
+    public static func runLane(named: String, parameters: [String : String]) -> Bool {
         log(message: "Running lane: \(named)")
         self.loadFastfile()
-        
+
         guard let fastfileInstance: Fastfile = self.fastfileInstance else {
             let message = "Unable to instantiate class named: \(self.className())"
             log(message: message)
             fatalError(message)
         }
-        
-        // call all methods that need to be called before we start calling lanes
-        fastfileInstance.setupAllTheThings()
-        
+
         let currentLanes = self.lanes
         let lowerCasedLaneRequested = named.lowercased()
-        
+
         guard let laneMethod = currentLanes[lowerCasedLaneRequested] else {
-            let message = "unable to find lane named: \(named)"
+            let laneNames = self.laneFunctionNames.map { laneFuctionName in
+                if laneFuctionName.hasSuffix("lanewithoptions:") {
+                    return trimLaneWithOptionsFromName(laneName: laneFuctionName)
+                } else {
+                    return trimLaneFromName(laneName: laneFuctionName)
+                }
+            }.joined(separator: ", ")
+
+            let message = "[!] Could not find lane '\(named)'. Available lanes: \(laneNames)"
             log(message: message)
-            fatalError(message)
+
+            let shutdownCommand = ControlCommand(commandType: .cancel(cancelReason: .clientError), message: message)
+            _ = runner.executeCommand(shutdownCommand)
+            return false
         }
-        
+
+        // call all methods that need to be called before we start calling lanes
+        fastfileInstance.setupAllTheThings()
+
         // We need to catch all possible errors here and display a nice message
         _ = fastfileInstance.perform(NSSelectorFromString(laneMethod), with: parameters)
-        
+
         // only call on success
         fastfileInstance.afterAll(currentLane: named)
         log(message: "Done running lane: \(named) ðŸš€")
+        return true
     }
 }
 
 // Please don't remove the lines below
 // They are used to detect outdated files
-// FastlaneRunnerAPIVersion [0.9.1]
+// FastlaneRunnerAPIVersion [0.9.2]
diff --git a/fastlane/swift/RubyCommand.swift b/fastlane/swift/RubyCommand.swift
index 0cf2cddaa..44750558c 100644
--- a/fastlane/swift/RubyCommand.swift
+++ b/fastlane/swift/RubyCommand.swift
@@ -8,11 +8,9 @@
 
 import Foundation
 
-protocol RubyCommandable {
-    var json: String { get }
-}
-
 struct RubyCommand: RubyCommandable {
+    var type: CommandType { return .action }
+
     struct Argument {
         enum ArgType {
             case stringClosure
@@ -41,7 +39,6 @@ struct RubyCommand: RubyCommandable {
 
         var json: String {
             get {
-
                 if let someValue = value {
                     let typeJson: String
                     if let type = type {
@@ -102,7 +99,7 @@ struct RubyCommand: RubyCommandable {
         callbackClosure(callbackArg)
     }
 
-    var json: String {
+    var commandJson: String {
         let argsArrayJson = self.args
             .map { $0.json }
             .filter { $0 != "" }
diff --git a/fastlane/swift/RubyCommandable.swift b/fastlane/swift/RubyCommandable.swift
new file mode 100644
index 000000000..216514ce3
--- /dev/null
+++ b/fastlane/swift/RubyCommandable.swift
@@ -0,0 +1,38 @@
+//
+//  RubyCommandable.swift
+//  FastlaneRunner
+//
+//  Created by Joshua Liebowitz on 1/4/18.
+//  Copyright Â© 2018 Joshua Liebowitz. All rights reserved.
+//
+
+import Foundation
+
+enum CommandType {
+    case action
+    case control
+
+    var token: String {
+        switch self {
+        case .action:
+            return "action"
+        case .control:
+            return "control"
+        }
+    }
+}
+
+protocol RubyCommandable {
+    var type: CommandType { get }
+    var commandJson: String { get }
+}
+
+extension RubyCommandable {
+    var json: String {
+        return "{\"commandType\" : \"\(self.type.token)\", \"command\" : \(self.commandJson)}"
+    }
+}
+
+// Please don't remove the lines below
+// They are used to detect outdated files
+// FastlaneRunnerAPIVersion [0.9.2]
diff --git a/fastlane/swift/Runner.swift b/fastlane/swift/Runner.swift
index 595fe6cd5..9a5d6e5db 100644
--- a/fastlane/swift/Runner.swift
+++ b/fastlane/swift/Runner.swift
@@ -27,7 +27,7 @@ class Runner {
     fileprivate var returnValue: String? // lol, so safe
     fileprivate var currentlyExecutingCommand: RubyCommandable? = nil
     fileprivate var shouldLeaveDispatchGroupDuringDisconnect = false
-    
+
     func executeCommand(_ command: RubyCommandable) -> String {
         self.dispatchGroup.enter()
         currentlyExecutingCommand = command
@@ -115,7 +115,10 @@ extension Runner : SocketClientDelegateProtocol {
                 }
             }
             self.dispatchGroup.leave()
-            
+        case .clientInitiatedCancelAcknowledged:
+            verbose(message: "server acknowledged a cancel request")
+            self.dispatchGroup.leave()
+
         case .alreadyClosedSockets, .connectionFailure, .malformedRequest, .malformedResponse, .serverError:
             log(message: "error encountered while executing command:\n\(serverResponse)")
             self.dispatchGroup.leave()
@@ -187,4 +190,4 @@ func verbose(message: String) {
 
 // Please don't remove the lines below
 // They are used to detect outdated files
-// FastlaneRunnerAPIVersion [0.9.1]
+// FastlaneRunnerAPIVersion [0.9.2]
diff --git a/fastlane/swift/SocketClient.swift b/fastlane/swift/SocketClient.swift
index 27af90622..8ebf3ed54 100644
--- a/fastlane/swift/SocketClient.swift
+++ b/fastlane/swift/SocketClient.swift
@@ -13,6 +13,7 @@ public enum SocketClientResponse: Error {
     case malformedRequest
     case malformedResponse
     case serverError
+    case clientInitiatedCancelAcknowledged
     case commandTimeout(seconds: Int)
     case connectionFailure
     case success(returnedObject: String?, closureArgumentValue: String?)
@@ -27,7 +28,8 @@ class SocketClient: NSObject {
     
     static let connectTimeoutSeconds = 2
     static let defaultCommandTimeoutSeconds = 3_600 // Hopefully 1 hr is enough Â¯\_(ãƒ„)_/Â¯
-    static let doneToken = "done"
+    static let doneToken = "done" // TODO: remove these
+    static let cancelToken = "cancelFastlaneRun"
     
     fileprivate var inputStream: InputStream!
     fileprivate var outputStream: OutputStream!
@@ -106,7 +108,7 @@ class SocketClient: NSObject {
     }
     
     public func sendComplete() {
-        sendAbort()
+        closeSession(sendAbort: true)
     }
     
     private func testDispatchTimeoutResult(_ timeoutResult: DispatchTimeoutResult, failureMessage: String, timeToWait: DispatchTimeInterval) -> Bool {
@@ -130,42 +132,50 @@ class SocketClient: NSObject {
     private func stopOutputSession() {
         outputStream.close()
     }
-    
-    private func send(string: String) {
-        guard !self.cleaningUpAfterDone else {
-            // This will happen after we abort if there are commands waiting to be executed
-            // Need to check state of SocketClient in command runner to make sure we can accept `send`
-            socketDelegate?.commandExecuted(serverResponse: .alreadyClosedSockets)
-            return
-        }
-        
-        if string == SocketClient.doneToken {
-            self.cleaningUpAfterDone = true
-        }
-        
-        self.dispatchGroup.enter()
+
+    private func sendThroughQueue(string: String) {
         streamQueue.async {
             let data = string.data(using: .utf8)!
             _ = data.withUnsafeBytes { self.outputStream.write($0, maxLength: data.count) }
         }
+    }
 
-        let timeoutSeconds = self.cleaningUpAfterDone ? 1 : self.commandTimeoutSeconds
+    private func privateSend(string: String) {
+        self.dispatchGroup.enter()
+        sendThroughQueue(string: string)
 
+        let timeoutSeconds = self.cleaningUpAfterDone ? 1 : self.commandTimeoutSeconds
         let timeToWait = DispatchTimeInterval.seconds(timeoutSeconds)
         let commandTimeout = DispatchTime.now() + timeToWait
         let timeoutResult =  self.dispatchGroup.wait(timeout: commandTimeout)
 
         _ = testDispatchTimeoutResult(timeoutResult, failureMessage: "Ruby process didn't return after: \(SocketClient.connectTimeoutSeconds) seconds", timeToWait: timeToWait)
     }
-    
-    func sendAbort() {
+
+    private func send(string: String) {
+        guard !self.cleaningUpAfterDone else {
+            // This will happen after we abort if there are commands waiting to be executed
+            // Need to check state of SocketClient in command runner to make sure we can accept `send`
+            socketDelegate?.commandExecuted(serverResponse: .alreadyClosedSockets)
+            return
+        }
+
+        if string == SocketClient.doneToken {
+            self.cleaningUpAfterDone = true
+        }
+
+        privateSend(string: string)
+    }
+
+    func closeSession(sendAbort: Bool = true) {
         self.socketStatus = .closed
-        
+
         stopInputSession()
-        
-        // and error occured, let's try to send the "done" message
-        send(string: SocketClient.doneToken)
-        
+
+        if sendAbort {
+            send(rubyCommand: ControlCommand(commandType: .done))
+        }
+
         stopOutputSession()
         self.socketDelegate?.connectionsClosed()
     }
@@ -188,7 +198,7 @@ extension SocketClient: StreamDelegate {
                 
             case Stream.Event.errorOccurred:
                 verbose(message: "input stream error occurred")
-                sendAbort()
+                closeSession(sendAbort: true)
                 
             case Stream.Event.hasBytesAvailable:
                 read()
@@ -246,7 +256,8 @@ extension SocketClient: StreamDelegate {
     
     func handleFailure(message: [String]) {
         log(message: "Encountered a problem: \(message.joined(separator:"\n"))")
-        sendAbort()
+        let shutdownCommand = ControlCommand(commandType: .cancel(cancelReason: .serverError))
+        self.send(rubyCommand: shutdownCommand)
     }
     
     func processResponse(string: String) {
@@ -261,6 +272,10 @@ extension SocketClient: StreamDelegate {
         let socketResponse = SocketResponse(payload: responseString)
         verbose(message: "response is: \(responseString)")
         switch socketResponse.responseType {
+        case .clientInitiatedCancel:
+            self.socketDelegate?.commandExecuted(serverResponse: .clientInitiatedCancelAcknowledged)
+            self.closeSession(sendAbort: false)
+
         case .failure(let failureInformation):
             self.socketDelegate?.commandExecuted(serverResponse: .serverError)
             self.handleFailure(message: failureInformation)
@@ -274,10 +289,11 @@ extension SocketClient: StreamDelegate {
             // cool, ready for next command
             break
         }
+
         self.dispatchGroup.leave() // should now pull the next piece of work
     }
 }
 
 // Please don't remove the lines below
 // They are used to detect outdated files
-// FastlaneRunnerAPIVersion [0.9.1]
+// FastlaneRunnerAPIVersion [0.9.2]
diff --git a/fastlane/swift/SocketResponse.swift b/fastlane/swift/SocketResponse.swift
index 90959b868..4054f85d9 100644
--- a/fastlane/swift/SocketResponse.swift
+++ b/fastlane/swift/SocketResponse.swift
@@ -13,6 +13,7 @@ struct SocketResponse {
         case parseFailure(failureInformation: [String])
         case failure(failureInformation: [String])
         case readyForNext(returnedObject: String?, closureArgumentValue: String?)
+        case clientInitiatedCancel
         
         init(statusDictionary: [String : Any]) {
             guard let status = statusDictionary["status"] as? String else {
@@ -25,7 +26,11 @@ struct SocketResponse {
                 let closureArgumentValue = statusDictionary["closure_argument_value"] as? String
                 self = .readyForNext(returnedObject: returnedObject, closureArgumentValue: closureArgumentValue)
                 return
-                
+
+            } else if status == "cancelled" {
+                self = .clientInitiatedCancel
+                return
+
             } else if status == "failure" {
                 guard let failureInformation = statusDictionary["failure_information"] as? [String] else {
                     self = .parseFailure(failureInformation: ["Ruby server indicated failure but Swift couldn't receive it"])
@@ -71,4 +76,4 @@ extension SocketResponse {
 
 // Please don't remove the lines below
 // They are used to detect outdated files
-// FastlaneRunnerAPIVersion [0.9.1]
+// FastlaneRunnerAPIVersion [0.9.2]
diff --git a/fastlane/swift/main.swift b/fastlane/swift/main.swift
index 7b8525534..eb2550b49 100644
--- a/fastlane/swift/main.swift
+++ b/fastlane/swift/main.swift
@@ -18,8 +18,10 @@ class MainProcess {
     @objc func connectToFastlaneAndRunLane() {
         runner.startSocketThread()
         
-        Fastfile.runLane(named: argumentProcessor.currentLane, parameters: argumentProcessor.laneParameters())
-        runner.disconnectFromFastlaneProcess()
+        let completedRun = Fastfile.runLane(named: argumentProcessor.currentLane, parameters: argumentProcessor.laneParameters())
+        if completedRun {
+            runner.disconnectFromFastlaneProcess()
+        }
         
         doneRunningLane = true
     }
@@ -40,4 +42,4 @@ while (!process.doneRunningLane && (RunLoop.current.run(mode: RunLoopMode.defaul
 
 // Please don't remove the lines below
 // They are used to detect outdated files
-// FastlaneRunnerAPIVersion [0.9.1]
+// FastlaneRunnerAPIVersion [0.9.2]
