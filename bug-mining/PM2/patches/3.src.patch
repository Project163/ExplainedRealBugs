diff --git a/README.md b/README.md
index 2c946736..2429f8e1 100644
--- a/README.md
+++ b/README.md
@@ -8,6 +8,8 @@ The next generation daemon process manager for Node.js with native clusterizatio
 
 PM2 is mainly a production module for Linux servers.
 
+Tested with Node v0.8, v0.10, v0.11
+
 # Installation
 
 ```
@@ -47,6 +49,15 @@ $ pm2 start app.js -i max -- -a 23 // Pass arguments after -- to app.js
 $ pm2 start app.js -i max -e err.log -o out.log -w // Will start and generate a configuration file
 ```
 
+## Updating pm2 and keeping processes alive
+
+```
+$ pm2 dump
+$ npm install -g pm2@latest
+$ pm2 kill
+$ pm2 resurect
+```
+
 ## pm2 list
 
 List infos about all processes managed by pm2. It shows also how many times a process has been restarted because of an unhandled exception.
diff --git a/bin/pm2 b/bin/pm2
index d406e3f4..b12d3b74 100755
--- a/bin/pm2
+++ b/bin/pm2
@@ -13,6 +13,7 @@ var util      = require('util');
 var watch     = require('watch');
 
 const PREFIX_MSG        = '\x1B[32m⌬ PM2 \x1B[39m';
+const PREFIX_MSG_ERR    = '\x1B[31m⌬ PM2 [ERROR] \x1B[39m';
 const SUCCESS_EXIT      = 0;
 const ERROR_EXIT        = 1;
 const SAMPLE_FILE_PATH  = '../lib/sample.json';
@@ -33,7 +34,7 @@ commander.version(pkg.version)
 //
 // Start command
 //
-commander.command('start <part>')
+commander.command('start <script>')
          .description('start specific part')
          .action(function(cmd) {
   if (cmd.indexOf('.json') > 0)
@@ -59,7 +60,7 @@ commander.command('stopAll')
 commander.command('stop <pm2_id>')
   .description('stop specific process pm2 id')
   .action(function(pm2_id) {    
-    console.log(PREFIX_MSG + 'Stopping process' + pm2_id);
+    console.log(PREFIX_MSG + 'Stopping process ' + pm2_id);
     UX.processing.start();
     CLI.stopId(pm2_id);
   });
@@ -284,7 +285,7 @@ CLI.startFile = function(script) {
 
   Satan.executeRemote('findByScript', {script : appConf.script}, function(err, exec) {
       if (exec && !commander.force) {
-        console.log(PREFIX_MSG + 'Script already launched, add -f option to force re execution');
+        console.log(PREFIX_MSG_ERR + 'Script already launched, add -f option to force re execution');
         process.exit(ERROR_EXIT);
       }
 
@@ -445,11 +446,14 @@ CLI.web = function() {
 CLI.restart = function(pm2_id) {
   Satan.executeRemote('list', {}, function(err, list) {
     list.forEach(function(l) {
-      if (l.pm_id == pm2_id) {
+      if (l.pm_id == pm2_id && l.status != 'stopped') {
         try {
           process.kill(l.pid);
         } catch(e) { }
       }
+      else if (l.pm_id == pm2_id && l.status == 'stopped') {
+        Satan.executeRemote('startId', {id : l.pm_id}, function(err, list) {});
+      }
     });
     setTimeout(function() {
       console.log('\n' + PREFIX_MSG + 'Process ' + pm2_id + ' restarted');
@@ -486,7 +490,11 @@ CLI.stopId = function(pm2_id) {
   Satan.executeRemote('stopId', {
     id : pm2_id
   }, function(err, list) {
-    if (err) process.exit(ERROR_EXIT);
+    if (err) {
+      console.log('\n' + PREFIX_MSG_ERR + pm2_id + ' : pm2 id not found');
+      process.exit(ERROR_EXIT);
+    }
+
     console.log('\n');
     console.log(PREFIX_MSG + 'Process stopped');
     UX.processing.stop();
@@ -606,7 +614,10 @@ function speedList() {
 function resolvePaths(app) {
   app["pm_exec_path"]    = path.resolve(process.cwd(), app.script);
 
-  fs.existsSync(app.pm_exec_path);
+  if (fs.existsSync(app.pm_exec_path) == false) {
+    console.log(PREFIX_MSG_ERR + 'script not found : ' + app.pm_exec_path);
+    process.exit(ERROR_EXIT);
+  }
 
   // Set current env
   util._extend(app, process.env);
@@ -615,7 +626,7 @@ function resolvePaths(app) {
     app["pm_out_log_path"] = path.resolve(process.cwd(), app.fileOutput);
   else {
     if (!app.name) {
-      console.log(PREFIX_MSG + 'You havent specified log path, please specify at least a "name" field in the JSON');
+      console.log(PREFIX_MSG_ERR + 'You havent specified log path, please specify at least a "name" field in the JSON');
       process.exit(ERROR_EXIT);
     }
     app["pm_out_log_path"] = path.resolve(cst.DEFAULT_LOG_PATH, [app.name, '-out.log'].join(''));
@@ -636,8 +647,9 @@ function resolvePaths(app) {
     app.pidFile            = app["pm_pid_path"];
   }
 
-  fs.existsSync(app.pm_out_log_path);
-  fs.existsSync(app.pm_err_log_path);
-
+  if (!fs.existsSync(app.pm_out_log_path) || !fs.existsSync(app.pm_err_log_path)) {
+    console.log(PREFIX_MSG_ERR + 'logs file not accessible : ' + app.pm_out_log_path + ' | ' + app.pm_err_log_path);
+    process.exit(ERROR_EXIT);
+  }
   return app;
 }
diff --git a/lib/CliUx.js b/lib/CliUx.js
index 505f6059..9bbb52e8 100644
--- a/lib/CliUx.js
+++ b/lib/CliUx.js
@@ -6,7 +6,7 @@ var p = require('path');
 var UX = module.exports = {};
 
 UX.dispAsTable = function(list) {
-  var table = new Table({ head: ["Script", "id", "PID","status", "Restarted", "memory", "err logs"] });
+  var table = new Table({ head: ["Script", "id", "PID","status", "Restarted", "Last restart", "memory", "err logs"] });
   list.forEach(function(l) {
     var u =  l.opts.script;
     var obj = {};
@@ -16,8 +16,9 @@ UX.dispAsTable = function(list) {
       l.pid,
       l.status,
       l.opts.restart_time ? l.opts.restart_time : 0,
+      l.opts.pm_uptime ? new Date(l.opts.pm_uptime).toISOString().replace(/T/, ' ').replace(/\..+/, '') : 0,
       l.monit ? UX.bytesToSize(l.monit.memory, 3) : '',
-      l.opts.fileError,
+      l.opts.fileError
     ];
 
     table.push(obj);
diff --git a/lib/God.js b/lib/God.js
index 1bfe95e1..b4c491ef 100644
--- a/lib/God.js
+++ b/lib/God.js
@@ -172,11 +172,14 @@ God.stopProcess = function(clu, cb) {
 };
 
 God.stopProcessId = function(id, cb) {
-  console.log(id);
+  if (!(id in God.clusters_db))
+    return cb({msg : 'Process not found'});
   God.clusters_db[id].opts.max = 0;
   process.kill(God.clusters_db[id].process.pid);
   God.clusters_db[id].process.pid = 0;
-  setTimeout(cb, 200);
+  setTimeout(function() {
+    cb(null, null);
+  }, 200);
 };
 
 //
@@ -210,6 +213,9 @@ God.prepare = function(opts, cb) {
 function execute(env, cb) {
   var id;
 
+  if (env.pm_id && env.opts && env.opts.status == 'stopped') {
+    delete God.clusters_db[env.pm_id];
+  }
   id = God.next_id;
   God.next_id += 1;
 
diff --git a/lib/Satan.js b/lib/Satan.js
index 6d6c3aaf..852ee853 100644
--- a/lib/Satan.js
+++ b/lib/Satan.js
@@ -24,8 +24,8 @@ var bind = (function(addr) {
 
   return {
     HOST: hostport[0],
-    PORT: Number(hostport[1]),
-  }
+    PORT: Number(hostport[1])
+  };
 })(cst.DAEMON_BIND_ADDR);
 
 var Satan = module.exports = {};
@@ -104,7 +104,10 @@ Satan.remoteWrapper = function() {
     },
     stopId : function(opts, fn) {
       God.stopProcessId(opts.id, function(err, clu) {
-        fn(err, stringifyOnce(clu, undefined, 0));
+        if (err)
+          fn(new Error('Process not found'));
+        else
+          fn(err, stringifyOnce(clu, undefined, 0));
       });
     },
     stopAll : function(opts, fn) {
diff --git a/package.json b/package.json
index 2593f4fb..d19c31d2 100644
--- a/package.json
+++ b/package.json
@@ -18,7 +18,7 @@
   "description": "The next generation process manager for Node.js with native clusterization ",
   "main": "index.js",
   "scripts": {
-    "test": "bash ./test/cli.sh ; NODE_ENV=test ./node_modules/mocha/bin/mocha test",
+    "test": "bash ./test/cli.sh && NODE_ENV=test ./node_modules/mocha/bin/mocha test",
     "froze": "npm shrinkwrap"
   },
   "keywords": [
diff --git a/test/cli.sh b/test/cli.sh
index 1f458eb6..2cb6f2ef 100755
--- a/test/cli.sh
+++ b/test/cli.sh
@@ -46,6 +46,12 @@ cd $file_path
 $pm2 kill
 spec "kill daemon"
 
+$pm2 start eyayimfake
+ispec "should fail if script doesnt exist"
+
+$pm2 start $file_path/child.js -o /sadadsax
+ispec "should fail if output log unreachable"
+
 $pm2
 ispec "No argument"
 
@@ -114,6 +120,7 @@ spec "Should restart all processes"
 sleep 0.3
 wget -q http://localhost:9615/ -O $JSON_FILE
 OUT=`cat $JSON_FILE | grep -o "restart_time\":1" | wc -l`
+
 [ $OUT -eq 7 ] || fail "$1"
 success "$1"
 
