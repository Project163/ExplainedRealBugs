{"url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3601","repository_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy","labels_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3601/labels{/name}","comments_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3601/comments","events_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3601/events","html_url":"https://github.com/sqlalchemy/sqlalchemy/issues/3601","id":384635572,"node_id":"MDU6SXNzdWUzODQ2MzU1NzI=","number":3601,"title":"session.merge already does non-deterministic reconciliation for persistent objects, add this to pending","user":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":1141269142,"node_id":"MDU6TGFiZWwxMTQxMjY5MTQy","url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"},{"id":1141273966,"node_id":"MDU6TGFiZWwxMTQxMjczOTY2","url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/labels/orm","name":"orm","color":"20C0B0","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":{"url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/milestones/41","html_url":"https://github.com/sqlalchemy/sqlalchemy/milestone/41","labels_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/milestones/41/labels","id":3850610,"node_id":"MDk6TWlsZXN0b25lMzg1MDYxMA==","number":41,"title":"1.1","description":null,"creator":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":0,"closed_issues":96,"state":"closed","created_at":"2018-11-27T04:03:36Z","updated_at":"2018-11-28T16:49:52Z","due_on":null,"closed_at":"2018-11-28T16:49:52Z"},"comments":15,"created_at":"2015-12-04T13:49:46Z","updated_at":"2015-12-04T17:03:41Z","closed_at":"2015-12-04T16:58:34Z","author_association":"COLLABORATOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"**Migrated issue, originally created by Sheer El Showk ([@sheer](https://github.com/sheer))**\n\nThis bug was discussed on stack overview here:\n\n[http://stackoverflow.com/questions/33888539/getting-sqlalchemy-to-do-on-duplicate-key-update-inside-an-orm-cascade-in-mys?noredirect=1#comment55890922_33888539\n](Link URL)\n\nWe create a simple object hierarchy: Groups contain Users and Users have Email addresses.  We want the email address to be stored uniquely even if its shared between users.  Constructing two users with the same address and using session.merge() to add them has the correct behaviour (the same key is reused and no error is thrown).  If, on the other hand, we add the two users to a group and then use session.merge() on the group instead them the two identical addresses lead to a unique key exception on address (due to an insert many).\n\nHere is the relevant code:\n\n\n```\nfrom sqlalchemy import create_engine, Column, types\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, scoped_session\nfrom sqlalchemy.orm import Session\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import relationship, backref\n\n\nengine = create_engine('sqlite:///:memory:', echo=False)\nBase = declarative_base()\n\nsession = scoped_session(sessionmaker(bind=engine))\n\nclass Group(Base):\n    __tablename__ = \"groups\"\n    gid = Column(types.Integer, primary_key=True)\n    name = Column(types.String(255))\n\n    users = relationship(\"User\", backref=\"group\")\n\n    def __repr__(self):\n        ret =  \"Group(name=%r)\" % self.name\n        for user in self.users:\n            ret += str(user)\n\nclass User(Base):\n    __tablename__ = \"users\"\n    login = Column(types.String(50), primary_key=True)\n    name = Column(types.String(255))\n    group_id = Column(types.Integer, ForeignKey('groups.gid'))\n    address = Column(types.String(200), \n                            ForeignKey('addresses.email_address'))\n    email = relationship(\"Address\")\n\n    def __repr__(self):\n        return \"User(login=%r, name=%r)\\n%s\" % (self.login, self.name,\n                str(self.email))\n\n\nclass Address(Base):\n    __tablename__ = 'addresses'\n    email_address = Column(types.String(200), nullable=False, primary_key=True)\n    #user_login = Column(types.String(50), ForeignKey('users.login'))\n\n    def __repr__(self):\n        return \"<Address(email_address='%s')>\" % self.email_address\n\n\nBase.metadata.create_all(engine)\n\nif __name__ == '__main__':\n\n    # this works correctly even though we reuse a unique key\n    u1 = User(login='Guy', name=\"Some Guy\")\n    u1.email=Address(email_address='nameless@yahoo.com')\n    u2 = User(login='Gal', name=\"Some Gal\")\n    u2.email=Address(email_address='nameless@yahoo.com')\n    session.merge(u1) \n    session.merge(u2) \n    session.commit()\n\n    print(\"two users with addresses\")\n    for u in session.query(User):\n        print(u)\n\n\n    # though this is similar it ends up using insertmany and throws a unique key\n    # constraint even with the merge\n    u3 = User(login='Mr. User', name=\"A dude\")\n    u3.email=Address(email_address='james@yahoo.com')\n    u4 = User(login='Mrs. User', name=\"A dudette\")\n    u4.email=Address(email_address='jill@yahoo.com')\n    u5 = User(login='Mrs. User2', name=\"A dudette2\")\n    u5.email=Address(email_address='jill@yahoo.com')\n    g1 = Group(name=\"G1\")\n    g1.users.append(u3)\n    g1.users.append(u4)\n    g1.users.append(u5)\n    session.merge(g1) \n    session.commit()\n\n    print(g1)\n```\n\n","closed_by":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3601/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3601/timeline","performed_via_github_app":null,"state_reason":"completed"}