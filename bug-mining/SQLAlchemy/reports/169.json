{"url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3090","repository_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy","labels_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3090/labels{/name}","comments_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3090/comments","events_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3090/events","html_url":"https://github.com/sqlalchemy/sqlalchemy/issues/3090","id":384630855,"node_id":"MDU6SXNzdWUzODQ2MzA4NTU=","number":3090,"title":"Parameter order wrong for SQLite request","user":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":1141269142,"node_id":"MDU6TGFiZWwxMTQxMjY5MTQy","url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"},{"id":1141273873,"node_id":"MDU6TGFiZWwxMTQxMjczODcz","url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/labels/high%20priority","name":"high priority","color":"C0B0E0","default":false,"description":null},{"id":1141274001,"node_id":"MDU6TGFiZWwxMTQxMjc0MDAx","url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/labels/sql","name":"sql","color":"5060F0","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":{"url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/milestones/75","html_url":"https://github.com/sqlalchemy/sqlalchemy/milestone/75","labels_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/milestones/75/labels","id":3850660,"node_id":"MDk6TWlsZXN0b25lMzg1MDY2MA==","number":75,"title":"0.9.7","description":null,"creator":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":0,"closed_issues":41,"state":"closed","created_at":"2018-11-27T04:30:51Z","updated_at":"2018-11-28T16:50:03Z","due_on":null,"closed_at":"2018-11-28T16:50:03Z"},"comments":17,"created_at":"2014-06-20T12:11:26Z","updated_at":"2014-07-15T00:27:26Z","closed_at":"2014-07-15T00:27:26Z","author_association":"COLLABORATOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"**Migrated issue, originally created by mike_solomon**\n\nThe following code fails to compile for SQLite with the correct parameter order.  The user-defined callback function \"pow\" shows the wrong arguments coming in (strings instead of numbers).  These strings are used as positional arguments elsewhere in the statement.\n\nSorry that I can't get it any smaller than this, but for the smaller examples I concocted SQLAlchemy gets things right so it is difficult to isolate the problem.\n\n\n```\nfrom sqlalchemy import Table, MetaData, Column, Integer, Float, String\nfrom sqlalchemy import select\nfrom sqlalchemy import and_, or_\nfrom sqlalchemy import func\nfrom plain import *\n\n_metadata = MetaData()\n\ndef make_table(name, tp) :\n  return Table(name, _metadata,\n                     Column('id', Integer, primary_key = True),\n                     Column('val', tp))\n\nclass JoinK(object) :\n  def __init__(self, table) :\n    self.table = table\n\nclass Join(JoinK) : pass\nclass Outerjoin(JoinK) : pass\n\ndef easy_sj(l, use_id = False, extras=[]) :\n  to_join = filter(lambda x : isinstance(x, Table) or isinstance(x,JoinK), l)\n  return easy_join(easy_select(l, use_id), to_join + extras)\n\ndef easy_select(l, use_id = False) :\n  vals = [(t if not isinstance(t,Table) else t.c.val.label(t.name+'_val')) for t in l]\n  if use_id :\n    vals = [l[0].c.id.label('id')] + vals\n  return select(vals)\n\ndef easy_join(stmt, lTables) :\n  joins = lTables[0]\n  for table in lTables[1:] :\n    joink = table if isinstance(table, JoinK) else Join(table)\n    joins = getattr(joins, 'join' if isinstance(joink, Join) else 'outerjoin' )(joink.table, onclause = joink.table.c.id == lTables[0].c.id)\n  return stmt.select_from(joins)\n\ndef and_eq(table1, table2, vals) :\n  return and_(*[table1.c[x] == table2.c[x] for x in vals])\n\ndef product(row) :\n  return func.round(func.exp(func.sum(func.log(1.0 * row))))\n\nScore = make_table('score', Integer)\nStaff = make_table('staff', Integer)\nVoice = make_table('voice', Integer)\nTime_next = make_table('next', Integer)\nDots = make_table('dots', Integer)\nOnset = make_table('onset', Float)  \nDuration = make_table('duration', Float)\nDuration_log = make_table('duration_log', Integer)\nName = make_table('name', String(50))\nNumerator = make_table('numerator', Integer)\nDenominator = make_table('denominator', Integer)\nLeft_bound = make_table('left_bound', Integer)\nRight_bound = make_table('right_bound', Integer)\n\ndef make_statement(score, voice, name, left_bound, right_bound, duration_log, time_next, dots) :\n\n  tuplets = easy_sj([score, voice, name, left_bound, right_bound,\n                     Numerator, Denominator],\n                    use_id = True).\\\n              where(name.c.val == \"tuplet\").\\\n              cte(\"tuplets\")\n\n  rhythmic_events = easy_sj([score, voice, Onset, duration_log],\n                            use_id = True,\n                            extras=[name]).\\\n                      where(or_(name.c.val == \"chord\",\n                                name.c.val == \"rest\",\n                                name.c.val == \"space\")).\\\n                      cte(name = \"rhythmic_events\")\n\n\n  first_rhythmic_events = select([rhythmic_events.c.score_val,\n                                  rhythmic_events.c.voice_val,\n                                  func.max(rhythmic_events.c.onset_val).label('onset_val')]).\\\n                            group_by(rhythmic_events.c.score_val,\n                                     rhythmic_events.c.voice_val).\\\n                            cte(name = \"first_rhythmic_events\")\n\n  first_rhythmic_events_to_ids =\\\n       select([rhythmic_events.c.id,\n               rhythmic_events.c.score_val,\n               rhythmic_events.c.voice_val,\n               rhythmic_events.c.onset_val]).\\\n         select_from(first_rhythmic_events.\\\n           join(rhythmic_events,\n             onclause = and_eq(rhythmic_events,\n                               first_rhythmic_events,\n                               ['score_val', 'voice_val', 'onset_val']))).\\\n           cte(\"first_rhythmic_events_to_ids\")\n\n  rhythmic_events_to_tuplets =\\\n    select([rhythmic_events.c.id.label('rhythmic_id'),\n            tuplets.c.id.label('tuplet_id'),\n            tuplets.c.left_bound_val.label('left_val'),\n            tuplets.c.right_bound_val.label('right_val')]).\\\n      where(and_eq(rhythmic_events, tuplets, ['score_val', 'voice_val'])).\\\n      cte(name = \"rhythmic_events_to_tuplets\", recursive = True)\n\n  rhythmic_events_to_tuplets_a = rhythmic_events_to_tuplets.alias(name=\"rhythmic_events_to_tuplets_prev\")\n\n  rhythmic_events_to_tuplets =\\\n    rhythmic_events_to_tuplets.union_all(\n      select([rhythmic_events_to_tuplets_a.c.rhythmic_id,\n              rhythmic_events_to_tuplets_a.c.tuplet_id,\n              time_next.c.val,\n              rhythmic_events_to_tuplets_a.c.right_val]).\\\n      where(and_(time_next.c.val == rhythmic_events_to_tuplets_a.c.left_val,\n                 time_next.c.val != rhythmic_events_to_tuplets_a.c.right_val)))\n\n  rhythmic_events_to_matching_tuplets =\\\n    select([rhythmic_events_to_tuplets.c.rhythmic_id,\n            product(tuplets.c.numerator_val).label('combined_numerator'),\n            product(tuplets.c.denominator_val).label('combined_denominator')]).\\\n      select_from(rhythmic_events_to_tuplets.\\\n        join(tuplets, onclause = tuplets.c.id == rhythmic_events_to_tuplets.c.tuplet_id)).\\\n      where(rhythmic_events_to_tuplets.c.rhythmic_id ==\\\n            rhythmic_events_to_tuplets.c.left_val).\\\n      group_by(rhythmic_events_to_tuplets.c.rhythmic_id).\\\n      cte(name=\"rhythmic_events_to_matching_tuplets\")\n\n  rhythmic_events_to_durations =\\\n    select([duration_log.c.id,\n            ((1.0 * func.ifnull(rhythmic_events_to_matching_tuplets.c.combined_numerator, 1.0) /\\\n                   func.ifnull(rhythmic_events_to_matching_tuplets.c.combined_denominator, 1.0)) *\\\n             (1.0 + ((func.pow(2, func.ifnull(dots.c.val, 0)) - 1) / func.pow(2, func.ifnull(dots.c.val,0)))) *\\\n             func.pow(2, duration_log.c.val))]).\\\n      select_from(duration_log.\\\n        outerjoin(rhythmic_events_to_matching_tuplets, onclause = duration_log.c.id == rhythmic_events_to_matching_tuplets.c.rhythmic_id).\\\n        outerjoin(dots, onclause = dots.c.id == duration_log.c.id))\n\n  return rhythmic_events_to_durations\n\nif __name__ == \"__main__\" :\n  import math\n  from properties import *\n  from sqlalchemy import create_engine\n  stmt = make_statement(score = Score,\n                        voice = Voice,\n                        name = Name,\n                        left_bound = Left_bound,\n                        right_bound = Right_bound,\n                        duration_log = Duration_log,\n                        time_next = Time_next,\n                        dots = Dots)\n  #print stmt\n\n  engine = create_engine('sqlite:///:memory:', echo=False)\n  conn = engine.connect()\n  def my_log(in_val) :\n    print in_val, \"log\"\n    return math.log(in_val)\n  def my_exp(x) :\n    print in_val, \"exp\"\n    return math.log(in_val)\n  def my_pow(in_val_0, in_val_1) :\n    print in_val_0, in_val_1, \"pow\", type(in_val_0)\n    return in_val_0 ** in_val_1\n  conn.connection.create_function(\"log\",\n                                  1,\n                                  my_log)\n  conn.connection.create_function(\"exp\",\n                                  1,\n                                  my_exp)\n  conn.connection.create_function(\"pow\",\n                                  2,\n                                  my_pow)\n  Score.metadata.create_all(engine)\n  stmts = []\n  for x in range(32) :\n    stmts.append(Score.insert().values(id=x, val=0))\n    stmts.append(Voice.insert().values(id=x, val=x%2))\n    stmts.append(Duration_log.insert().values(id=x, val=-2))\n  for st in stmts :\n    conn.execute(st)\n  #print stmt\n  for row in conn.execute(stmt).fetchall() :\n    print row\n  \n\n```\n\n----------------------------------------\nAttachments: [3090_potential.patch](../wiki/imported_issue_attachments/3090/3090_potential.patch) | [3090_2.patch](../wiki/imported_issue_attachments/3090/3090_2.patch)\n\n","closed_by":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3090/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3090/timeline","performed_via_github_app":null,"state_reason":"completed"}