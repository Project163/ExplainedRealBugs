{"url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3448","repository_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy","labels_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3448/labels{/name}","comments_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3448/comments","events_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3448/events","html_url":"https://github.com/sqlalchemy/sqlalchemy/issues/3448","id":384634185,"node_id":"MDU6SXNzdWUzODQ2MzQxODU=","number":3448,"title":"row_processor is None when querying with hybrid_property","user":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":1141269142,"node_id":"MDU6TGFiZWwxMTQxMjY5MTQy","url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/labels/bug","name":"bug","color":"d73a4a","default":true,"description":"Something isn't working"},{"id":1141286348,"node_id":"MDU6TGFiZWwxMTQxMjg2MzQ4","url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/labels/sqlalchemy.ext","name":"sqlalchemy.ext","color":"90E060","default":false,"description":"extension modules, most of which are ORM related"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":8,"created_at":"2015-06-11T18:42:08Z","updated_at":"2015-06-12T14:09:47Z","closed_at":"2015-06-11T20:48:37Z","author_association":"COLLABORATOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"**Migrated issue, originally created by Richard Frank ([@richafrank](https://github.com/richafrank))**\n\nI'm using a hybrid_property to map a column containing int identifiers to the un-persisted python objects they identify.  We're writing queries that compare that column with those python objects. In this example, I'm mapping an int \"id\" column to a python IdObject wrapper.  \n\nIn SQLAlchemy 0.9.9, this example ran with 1 row being returned, but in SQLAlchemy 1.0.5, I get a TypeError (traceback pasted below).  Is there a better (working) way to do this?\n\n```\nfrom sqlalchemy import Table, Column, Integer, MetaData, create_engine\nfrom sqlalchemy.ext.hybrid import hybrid_property, Comparator\nfrom sqlalchemy.orm import mapper, Query, Session\n\n\nclass Entity(object):\n    pass\n\n\nclass IdObject(object):\n    def __init__(self, id_):\n        self.id = id_\n\n    def __cmp__(self, other):\n        if isinstance(other, int):\n            return cmp(self.id, other)\n        return cmp(self.id, other.id)\n\n\nclass IdObjComparator(Comparator):\n    def __init__(self, id_):\n        if isinstance(id_, (IdObject, IdObjComparator)):\n            self.id = id_.id\n        else:\n            self.id = id_\n\n    def operate(self, op, *other, **kwargs):\n        return op(self.id,\n                  *(IdObjComparator(id_).id\n                    for id_ in other),\n                  **kwargs)\n\n    def __clause_element__(self):\n        return self.id\n\n\ndef test_hybrid_property(url):\n    engine = create_engine(url)\n    metadata = MetaData(bind=engine)\n    table = Table('test_tbl', metadata,\n                  Column('id', Integer, primary_key=True),\n                  Column('value', Integer))\n\n    metadata.create_all()\n\n    engine.execute(table.insert().values([{'value': 1}]))\n\n    mapper(Entity,\n           table,\n           properties={'_id': table.c.id},\n           include_properties=())\n\n    hybrid_id = hybrid_property(\n        lambda zelf: IdObject(zelf._id)\n    ).comparator(lambda klass: IdObjComparator(klass._id))\n\n    Entity.id = hybrid_id\n\n    query_for_id1 = (Query([Entity.id])\n                     .filter(Entity.id == IdObject(1))\n                     .order_by(Entity.id))\n\n    results = list(query_for_id1.with_session(Session(bind=engine)))\n    assert len(results) == 1\n\n\nif __name__ == '__main__':\n    test_hybrid_property('postgresql://rich@/test_hybrid_prop')\n\n```\n\n```\nTraceback (most recent call last):\n  File \"/Users/rich/Dev/test/test/test_hybrid_property.py\", line 63, in <module>\n    test_hybrid_property('postgresql://rich@/test_hybrid_prop')\n  File \"/Users/rich/Dev/test/test/test_hybrid_property.py\", line 58, in test_hybrid_property\n    results = list(query_for_id1.with_session(Session(bind=engine)))\n  File \"/Users/rich/.virtualenvs/test/lib/python2.7/site-packages/sqlalchemy/orm/loading.py\", line 84, in instances\n    util.raise_from_cause(err)\n  File \"/Users/rich/.virtualenvs/test/lib/python2.7/site-packages/sqlalchemy/util/compat.py\", line 199, in raise_from_cause\n    reraise(type(exception), exception, tb=exc_tb)\n  File \"/Users/rich/.virtualenvs/test/lib/python2.7/site-packages/sqlalchemy/orm/loading.py\", line 72, in instances\n    for row in fetch]\nTypeError: 'NoneType' object is not callable\n```\n\n","closed_by":{"login":"sqlalchemy-bot","id":36047385,"node_id":"MDQ6VXNlcjM2MDQ3Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/36047385?v=4","gravatar_id":"","url":"https://api.github.com/users/sqlalchemy-bot","html_url":"https://github.com/sqlalchemy-bot","followers_url":"https://api.github.com/users/sqlalchemy-bot/followers","following_url":"https://api.github.com/users/sqlalchemy-bot/following{/other_user}","gists_url":"https://api.github.com/users/sqlalchemy-bot/gists{/gist_id}","starred_url":"https://api.github.com/users/sqlalchemy-bot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sqlalchemy-bot/subscriptions","organizations_url":"https://api.github.com/users/sqlalchemy-bot/orgs","repos_url":"https://api.github.com/users/sqlalchemy-bot/repos","events_url":"https://api.github.com/users/sqlalchemy-bot/events{/privacy}","received_events_url":"https://api.github.com/users/sqlalchemy-bot/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3448/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sqlalchemy/sqlalchemy/issues/3448/timeline","performed_via_github_app":null,"state_reason":"completed"}