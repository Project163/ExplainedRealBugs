diff --git a/doc/build/changelog/changelog_09.rst b/doc/build/changelog/changelog_09.rst
index 5f01883b0..01a083716 100644
--- a/doc/build/changelog/changelog_09.rst
+++ b/doc/build/changelog/changelog_09.rst
@@ -14,6 +14,14 @@
 .. changelog::
     :version: 0.9.4
 
+    .. change::
+        :tags: bug, general
+        :tickets: 2979
+
+        Fixed some test/feature failures occurring in Python 3.4,
+        in particular the logic used to wrap "column default" callables
+        wouldn't work properly for Python built-ins.
+
     .. change::
         :tags: orm feature
         :tickets: 2976
diff --git a/lib/sqlalchemy/sql/schema.py b/lib/sqlalchemy/sql/schema.py
index a9d5a69b1..2614c08c8 100644
--- a/lib/sqlalchemy/sql/schema.py
+++ b/lib/sqlalchemy/sql/schema.py
@@ -27,6 +27,7 @@ Since these objects are part of the SQL expression language, they are usable
 as components in SQL expressions.
 
 """
+from __future__ import absolute_import
 
 import inspect
 from .. import exc, util, event, inspection
@@ -41,6 +42,7 @@ from .selectable import TableClause
 import collections
 import sqlalchemy
 from . import ddl
+import types
 
 RETAIN_SCHEMA = util.symbol('retain_schema')
 
@@ -1844,7 +1846,12 @@ class ColumnDefault(DefaultGenerator):
         on everyone.
 
         """
-        if inspect.isfunction(fn) or inspect.ismethod(fn):
+        # TODO: why aren't we using a util.langhelpers function
+        # for this?  e.g. get_callable_argspec
+
+        if isinstance(fn, (types.BuiltinMethodType, types.BuiltinFunctionType)):
+            return lambda ctx: fn()
+        elif inspect.isfunction(fn) or inspect.ismethod(fn):
             inspectable = fn
         elif inspect.isclass(fn):
             inspectable = fn.__init__
diff --git a/lib/sqlalchemy/util/langhelpers.py b/lib/sqlalchemy/util/langhelpers.py
index 82e37ce99..94ddb242c 100644
--- a/lib/sqlalchemy/util/langhelpers.py
+++ b/lib/sqlalchemy/util/langhelpers.py
@@ -362,15 +362,15 @@ def format_argspec_init(method, grouped=True):
       other unreflectable (usually C) -> (self, *args, **kwargs)
 
     """
-    try:
-        return format_argspec_plus(method, grouped=grouped)
-    except TypeError:
-        if method is object.__init__:
-            args = grouped and '(self)' or 'self'
-        else:
+    if method is object.__init__:
+        args = grouped and '(self)' or 'self'
+    else:
+        try:
+            return format_argspec_plus(method, grouped=grouped)
+        except TypeError:
             args = (grouped and '(self, *args, **kwargs)'
                             or 'self, *args, **kwargs')
-        return dict(self_arg='self', args=args, apply_pos=args, apply_kw=args)
+    return dict(self_arg='self', args=args, apply_pos=args, apply_kw=args)
 
 
 def getargspec_init(method):
diff --git a/test/orm/test_attributes.py b/test/orm/test_attributes.py
index c282bc44c..4f8092f31 100644
--- a/test/orm/test_attributes.py
+++ b/test/orm/test_attributes.py
@@ -236,21 +236,6 @@ class AttributesTest(fixtures.ORMTest):
         o2 = pickle.loads(pk_o)
         pk_o2 = pickle.dumps(o2)
 
-        # so... pickle is creating a new 'mt2' string after a roundtrip here,
-        # so we'll brute-force set it to be id-equal to the original string
-        if False:
-            o_mt2_str = [ k for k in o.__dict__ if k == 'mt2'][0]
-            o2_mt2_str = [ k for k in o2.__dict__ if k == 'mt2'][0]
-            self.assert_(o_mt2_str == o2_mt2_str)
-            self.assert_(o_mt2_str is not o2_mt2_str)
-            # change the id of o2.__dict__['mt2']
-            former = o2.__dict__['mt2']
-            del o2.__dict__['mt2']
-            o2.__dict__[o_mt2_str] = former
-
-            # Relies on dict ordering
-            if not jython:
-                self.assert_(pk_o == pk_o2)
 
         # the above is kind of distrurbing, so let's do it again a little
         # differently.  the string-id in serialization thing is just an
@@ -261,11 +246,6 @@ class AttributesTest(fixtures.ORMTest):
         o3 = pickle.loads(pk_o2)
         pk_o3 = pickle.dumps(o3)
         o4 = pickle.loads(pk_o3)
-        pk_o4 = pickle.dumps(o4)
-
-        # Relies on dict ordering
-        if not jython:
-            self.assert_(pk_o3 == pk_o4)
 
         # and lastly make sure we still have our data after all that.
         # identical serialzation is great, *if* it's complete :)
