diff --git a/doc/build/changelog/changelog_10.rst b/doc/build/changelog/changelog_10.rst
index b8d61de2e..1b1ab383f 100644
--- a/doc/build/changelog/changelog_10.rst
+++ b/doc/build/changelog/changelog_10.rst
@@ -18,6 +18,20 @@
 .. changelog::
     :version: 1.0.0b5
 
+    .. change::
+        :tags: bug, sql
+        :tickets: 3346
+
+        The warning emitted by the unicode type for a non-unicode type
+        has been liberalized to warn for values that aren't even string
+        values, such as integers; previously, the updated warning system
+        of 1.0 made use of string formatting operations which
+        would raise an internal TypeError.   While these cases should ideally
+        raise totally, some backends like SQLite and MySQL do accept them
+        and are potentially in use by legacy code, not to mention that they
+        will always pass through if unicode conversion is turned off
+        for the target backend.
+
     .. change::
         :tags: bug, orm
         :tickets: 3347
diff --git a/lib/sqlalchemy/util/langhelpers.py b/lib/sqlalchemy/util/langhelpers.py
index 6c52e41f8..3d7bfad0a 100644
--- a/lib/sqlalchemy/util/langhelpers.py
+++ b/lib/sqlalchemy/util/langhelpers.py
@@ -1257,9 +1257,12 @@ def warn_exception(func, *args, **kwargs):
 
 
 def ellipses_string(value, len_=25):
-    if len(value) > len_:
-        return "%s..." % value[0:len_]
-    else:
+    try:
+        if len(value) > len_:
+            return "%s..." % value[0:len_]
+        else:
+            return value
+    except TypeError:
         return value
 
 
diff --git a/test/sql/test_types.py b/test/sql/test_types.py
index 1fac13b05..017a176db 100644
--- a/test/sql/test_types.py
+++ b/test/sql/test_types.py
@@ -1,5 +1,5 @@
 # coding: utf-8
-from sqlalchemy.testing import eq_, assert_raises, assert_raises_message
+from sqlalchemy.testing import eq_, assert_raises, assert_raises_message, expect_warnings
 import decimal
 import datetime
 import os
@@ -1015,6 +1015,15 @@ class UnicodeTest(fixtures.TestBase):
 
         eq_(uni(unicodedata), unicodedata.encode('utf-8'))
 
+    def test_unicode_warnings_totally_wrong_type(self):
+        u = Unicode()
+        dialect = default.DefaultDialect()
+        dialect.supports_unicode_binds = False
+        uni = u.dialect_impl(dialect).bind_processor(dialect)
+        with expect_warnings(
+                "Unicode type received non-unicode bind param value 5."):
+            eq_(uni(5), 5)
+
     def test_unicode_warnings_dialectlevel(self):
 
         unicodedata = self.data
