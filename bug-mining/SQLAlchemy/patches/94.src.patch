diff --git a/doc/build/changelog/changelog_08.rst b/doc/build/changelog/changelog_08.rst
index fbc59c6c6..f861a3c6c 100644
--- a/doc/build/changelog/changelog_08.rst
+++ b/doc/build/changelog/changelog_08.rst
@@ -11,6 +11,20 @@
 .. changelog::
     :version: 0.8.6
 
+    .. change::
+        :tags: bug, sql
+        :versions: 0.9.4
+        :tickets: 2977
+
+        Fixed bug in :func:`.tuple_` construct where the "type" of essentially
+        the first SQL expression would be applied as the "comparison type"
+        to a compared tuple value; this has the effect in some cases of an
+        inappropriate "type coersion" occurring, such as when a tuple that
+        has a mix of String and Binary values improperly coerces target
+        values to Binary even though that's not what they are on the left
+        side.  :func:`.tuple_` now expects heterogeneous types within its
+        list of values.
+
     .. change::
         :tags: orm, bug
         :versions: 0.9.4
diff --git a/lib/sqlalchemy/sql/elements.py b/lib/sqlalchemy/sql/elements.py
index f2ce0619c..c230fb0d3 100644
--- a/lib/sqlalchemy/sql/elements.py
+++ b/lib/sqlalchemy/sql/elements.py
@@ -1856,9 +1856,10 @@ class Tuple(ClauseList, ColumnElement):
         """
 
         clauses = [_literal_as_binds(c) for c in clauses]
-        self.type = kw.pop('type_', None)
-        if self.type is None:
-            self.type = _type_from_args(clauses)
+        self._type_tuple = [arg.type for arg in clauses]
+        self.type = kw.pop('type_', self._type_tuple[0]
+                            if self._type_tuple else type_api.NULLTYPE)
+
         super(Tuple, self).__init__(*clauses, **kw)
 
     @property
@@ -1868,8 +1869,8 @@ class Tuple(ClauseList, ColumnElement):
     def _bind_param(self, operator, obj):
         return Tuple(*[
             BindParameter(None, o, _compared_to_operator=operator,
-                             _compared_to_type=self.type, unique=True)
-            for o in obj
+                             _compared_to_type=type_, unique=True)
+            for o, type_ in zip(obj, self._type_tuple)
         ]).self_group()
 
 
diff --git a/test/sql/test_operators.py b/test/sql/test_operators.py
index d46a9fbd2..1001e598c 100644
--- a/test/sql/test_operators.py
+++ b/test/sql/test_operators.py
@@ -7,7 +7,7 @@ from sqlalchemy.sql.expression import BinaryExpression, \
                 UnaryExpression, select, union, func, tuple_
 from sqlalchemy.sql import operators, table
 import operator
-from sqlalchemy import String, Integer
+from sqlalchemy import String, Integer, LargeBinary
 from sqlalchemy import exc
 from sqlalchemy.engine import default
 from sqlalchemy.sql.elements import _literal_as_text
@@ -1628,3 +1628,23 @@ class CustomOpTest(fixtures.TestBase):
         assert operators.is_comparison(op1)
         assert not operators.is_comparison(op2)
 
+class TupleTypingTest(fixtures.TestBase):
+
+    def _assert_types(self, expr):
+        eq_(expr.clauses[0].type._type_affinity, Integer)
+        eq_(expr.clauses[1].type._type_affinity, String)
+        eq_(expr.clauses[2].type._type_affinity, LargeBinary()._type_affinity)
+
+    def test_type_coersion_on_eq(self):
+        a, b, c = column('a', Integer), column('b', String), column('c', LargeBinary)
+        t1 = tuple_(a, b, c)
+        expr = t1 == (3, 'hi', 'there')
+        self._assert_types(expr.right)
+
+    def test_type_coersion_on_in(self):
+        a, b, c = column('a', Integer), column('b', String), column('c', LargeBinary)
+        t1 = tuple_(a, b, c)
+        expr = t1.in_([(3, 'hi', 'there'), (4, 'Q', 'P')])
+        eq_(len(expr.right.clauses), 2)
+        for elem in expr.right.clauses:
+            self._assert_types(elem)
