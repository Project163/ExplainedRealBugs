diff --git a/doc/build/changelog/changelog_09.rst b/doc/build/changelog/changelog_09.rst
index b1ec9cbec..8d4c8d7f6 100644
--- a/doc/build/changelog/changelog_09.rst
+++ b/doc/build/changelog/changelog_09.rst
@@ -14,6 +14,22 @@
 .. changelog::
     :version: 0.9.9
 
+    .. change::
+        :tags: bug, schema
+        :tickets: 3298, 1765
+
+        Fixed bug in 0.9's foreign key setup system, such that
+        the logic used to link a :class:`.ForeignKey` to its parent could fail
+        when the foreign key used "link_to_name=True" in conjunction with
+        a target :class:`.Table` that would not receive its parent column until
+        later, such as within a reflection + "useexisting" scenario,
+        if the target column in fact had a key value different from its name,
+        as would occur in reflection if column reflect events were used to
+        alter the .key of reflected :class:`.Column` objects so that the
+        link_to_name becomes significant.  Also repaired support for column
+        type via FK transmission in a similar way when target columns had a
+        different key and were referenced using link_to_name.
+
     .. change::
         :tags: feature, engine
         :versions: 1.0.0
diff --git a/lib/sqlalchemy/sql/schema.py b/lib/sqlalchemy/sql/schema.py
index 65a1da877..f3752a726 100644
--- a/lib/sqlalchemy/sql/schema.py
+++ b/lib/sqlalchemy/sql/schema.py
@@ -1288,10 +1288,18 @@ class Column(SchemaItem, ColumnClause):
                     "Index object external to the Table.")
             table.append_constraint(UniqueConstraint(self.key))
 
-        fk_key = (table.key, self.key)
-        if fk_key in self.table.metadata._fk_memos:
-            for fk in self.table.metadata._fk_memos[fk_key]:
-                fk._set_remote_table(table)
+        self._setup_on_memoized_fks(lambda fk: fk._set_remote_table(table))
+
+    def _setup_on_memoized_fks(self, fn):
+        fk_keys = [
+            ((self.table.key, self.key), False),
+            ((self.table.key, self.name), True),
+        ]
+        for fk_key, link_to_name in fk_keys:
+            if fk_key in self.table.metadata._fk_memos:
+                for fk in self.table.metadata._fk_memos[fk_key]:
+                    if fk.link_to_name is link_to_name:
+                        fn(fk)
 
     def _on_table_attach(self, fn):
         if self.table is not None:
@@ -1740,11 +1748,11 @@ class ForeignKey(DialectKWArgs, SchemaItem):
         # super-edgy case, if other FKs point to our column,
         # they'd get the type propagated out also.
         if isinstance(self.parent.table, Table):
-            fk_key = (self.parent.table.key, self.parent.key)
-            if fk_key in self.parent.table.metadata._fk_memos:
-                for fk in self.parent.table.metadata._fk_memos[fk_key]:
-                    if fk.parent.type._isnull:
-                        fk.parent.type = column.type
+
+            def set_type(fk):
+                if fk.parent.type._isnull:
+                    fk.parent.type = column.type
+            self.parent._setup_on_memoized_fks(set_type)
 
         self.column = column
 
diff --git a/test/sql/test_metadata.py b/test/sql/test_metadata.py
index cc7d0eb4f..206f4bd16 100644
--- a/test/sql/test_metadata.py
+++ b/test/sql/test_metadata.py
@@ -2002,6 +2002,37 @@ class ConstraintTest(fixtures.TestBase):
         assert fk.column is base_table.c.q
         assert isinstance(derived_table.c.id.type, Integer)
 
+    def test_related_column_not_present_atfirst_ok_onname(self):
+        m = MetaData()
+        base_table = Table("base", m,
+                           Column("id", Integer, primary_key=True)
+                           )
+        fk = ForeignKey('base.q', link_to_name=True)
+        derived_table = Table("derived", m,
+                              Column("id", None, fk,
+                                     primary_key=True),
+                              )
+
+        base_table.append_column(Column('q', Integer, key='zz'))
+        assert fk.column is base_table.c.zz
+        assert isinstance(derived_table.c.id.type, Integer)
+
+    def test_related_column_not_present_atfirst_ok_linktoname_conflict(self):
+        m = MetaData()
+        base_table = Table("base", m,
+                           Column("id", Integer, primary_key=True)
+                           )
+        fk = ForeignKey('base.q', link_to_name=True)
+        derived_table = Table("derived", m,
+                              Column("id", None, fk,
+                                     primary_key=True),
+                              )
+
+        base_table.append_column(Column('zz', Integer, key='q'))
+        base_table.append_column(Column('q', Integer, key='zz'))
+        assert fk.column is base_table.c.zz
+        assert isinstance(derived_table.c.id.type, Integer)
+
     def test_invalid_composite_fk_check_strings(self):
         m = MetaData()
 
@@ -2160,6 +2191,67 @@ class ConstraintTest(fixtures.TestBase):
         assert isinstance(b.c.a_key1.type, Integer)
         assert isinstance(c.c.b_key1.type, Integer)
 
+    def test_type_propagate_chained_string_source_last_onname(self):
+        metadata = MetaData()
+
+        b = Table('b', metadata,
+                  Column(
+                      'a_key1', None,
+                      ForeignKey("a.key1", link_to_name=True), key="ak1"),
+                  )
+
+        c = Table('c', metadata,
+                  Column(
+                      'b_key1', None,
+                      ForeignKey("b.a_key1", link_to_name=True), key="bk1"),
+                  )
+
+        Table(
+            'a', metadata,
+            Column('key1', Integer, primary_key=True, key='ak1'))
+
+        assert isinstance(b.c.ak1.type, Integer)
+        assert isinstance(c.c.bk1.type, Integer)
+
+    def test_type_propagate_chained_string_source_last_onname_conflict(self):
+        metadata = MetaData()
+
+        b = Table('b', metadata,
+                  # b.c.key1 -> a.c.key1 -> String
+                  Column(
+                      'ak1', None,
+                      ForeignKey("a.key1", link_to_name=False), key="key1"),
+                  # b.c.ak1 -> a.c.ak1 -> Integer
+                  Column(
+                      'a_key1', None,
+                      ForeignKey("a.key1", link_to_name=True), key="ak1"),
+                  )
+
+        c = Table('c', metadata,
+                  # c.c.b_key1 -> b.c.ak1 -> Integer
+                  Column(
+                      'b_key1', None,
+                      ForeignKey("b.ak1", link_to_name=False)),
+                  # c.c.b_ak1 -> b.c.ak1
+                  Column(
+                      'b_ak1', None,
+                      ForeignKey("b.ak1", link_to_name=True)),
+                  )
+
+        Table(
+            'a', metadata,
+            # a.c.key1
+            Column('ak1', String, key="key1"),
+            # a.c.ak1
+            Column('key1', Integer, primary_key=True, key='ak1'),
+        )
+
+        assert isinstance(b.c.key1.type, String)
+        assert isinstance(b.c.ak1.type, Integer)
+
+        assert isinstance(c.c.b_ak1.type, String)
+        assert isinstance(c.c.b_key1.type, Integer)
+
     def test_type_propagate_chained_col_orig_first(self):
         metadata = MetaData()
         a = Table('a', metadata,
