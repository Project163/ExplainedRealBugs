diff --git a/doc/build/changelog/changelog_10.rst b/doc/build/changelog/changelog_10.rst
index 9f68d05eb..2caa48a5e 100644
--- a/doc/build/changelog/changelog_10.rst
+++ b/doc/build/changelog/changelog_10.rst
@@ -18,6 +18,16 @@
 .. changelog::
     :version: 1.0.0b4
 
+    .. change::
+        :tags: bug, sql
+        :tickets: 3340
+
+        Fixed bug in new "label resolution" feature of :ticket:`2992` where
+        a label that was anonymous, then labeled again with a name, would
+        fail to be locatable via a textual label.  This situation occurs
+        naturally when a mapped :func:`.column_property` is given an
+        explicit label in a query.
+
     .. change::
         :tags: bug, sql
         :tickets: 3335
diff --git a/lib/sqlalchemy/sql/compiler.py b/lib/sqlalchemy/sql/compiler.py
index 8e709a474..755193552 100644
--- a/lib/sqlalchemy/sql/compiler.py
+++ b/lib/sqlalchemy/sql/compiler.py
@@ -560,7 +560,6 @@ class SQLCompiler(Compiled):
 
         selectable = self.stack[-1]['selectable']
         with_cols, only_froms = selectable._label_resolve_dict
-
         try:
             if within_columns_clause:
                 col = only_froms[element.element]
diff --git a/lib/sqlalchemy/sql/elements.py b/lib/sqlalchemy/sql/elements.py
index 7d64c2c4a..ca8ec1f55 100644
--- a/lib/sqlalchemy/sql/elements.py
+++ b/lib/sqlalchemy/sql/elements.py
@@ -3040,10 +3040,12 @@ class Label(ColumnElement):
 
         if name:
             self.name = name
+            self._resolve_label = self.name
         else:
             self.name = _anonymous_label(
                 '%%(%d %s)s' % (id(self), getattr(element, 'name', 'anon'))
             )
+
         self.key = self._label = self._key_label = self.name
         self._element = element
         self._type = type_
@@ -3094,7 +3096,7 @@ class Label(ColumnElement):
         self.element = clone(self.element, **kw)
         self.__dict__.pop('_allow_label_resolve', None)
         if anonymize_labels:
-            self.name = _anonymous_label(
+            self.name = self._resolve_label = _anonymous_label(
                 '%%(%d %s)s' % (
                     id(self), getattr(self.element, 'name', 'anon'))
             )
diff --git a/test/sql/test_text.py b/test/sql/test_text.py
index 4483597ac..1c3cb0cb4 100644
--- a/test/sql/test_text.py
+++ b/test/sql/test_text.py
@@ -574,6 +574,15 @@ class OrderByLabelResolutionTest(fixtures.TestBase, AssertsCompiledSQL):
             "FROM mytable AS mytable_1 ORDER BY mytable_1.name"
         )
 
+    def test_order_by_named_label_from_anon_label(self):
+        s1 = select([table1.c.myid.label(None).label("foo"), table1.c.name])
+        stmt = s1.order_by("foo")
+        self.assert_compile(
+            stmt,
+            "SELECT mytable.myid AS foo, mytable.name "
+            "FROM mytable ORDER BY foo"
+        )
+
     def test_order_by_outermost_label(self):
         # test [ticket:3335], assure that order_by("foo")
         # catches the label named "foo" in the columns clause only,
