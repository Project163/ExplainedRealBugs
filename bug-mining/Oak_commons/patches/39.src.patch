diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/ExternalSort.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/ExternalSort.java
index 03a6404009..706bae7aca 100644
--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/ExternalSort.java
+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/ExternalSort.java
@@ -627,7 +627,7 @@ public class ExternalSort {
                 // Write if  filterPredicate return true and line is not duplicate
                 if (!distinct || (lastLine == null || (lastLine != null && cmp.compare(r, lastLine) != 0))) {
                     fbw.write(typeToString.apply(r));
-                    fbw.newLine();
+                    fbw.write('\n');
                     lastLine = r;
                 }
             }
diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortByteArray.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortByteArray.java
new file mode 100644
index 0000000000..10c3d7735e
--- /dev/null
+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortByteArray.java
@@ -0,0 +1,223 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.commons.sort;
+
+import org.apache.jackrabbit.guava.common.base.Preconditions;
+import org.apache.jackrabbit.oak.commons.Compression;
+
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.PriorityQueue;
+import java.util.function.Function;
+
+/**
+ * Variation of ExternalSort that stores the lines read from intermediate files as byte arrays to avoid the conversion
+ * from byte[] to String and then back.
+ */
+public class ExternalSortByteArray {
+    private final static int DEFAULT_BUFFER_SIZE = 16 * 1024;
+
+    public static <T> void mergeSortedFilesBinary(List<Path> files, BufferedOutputStream fbw, final Comparator<T> cmp,
+                                                  boolean distinct, Compression algorithm,
+                                                  Function<T, byte[]> typeToByteArray, Function<byte[], T> byteArrayToType)
+            throws IOException {
+        mergeSortedFilesBinary(files, fbw, cmp, distinct, algorithm, typeToByteArray, byteArrayToType, DEFAULT_BUFFER_SIZE);
+    }
+
+    public static <T> void mergeSortedFilesBinary(List<Path> files, BufferedOutputStream fbw, final Comparator<T> cmp,
+                                                  boolean distinct, Compression algorithm,
+                                                  Function<T, byte[]> typeToByteArray, Function<byte[], T> byteArrayToType, int readBufferSize)
+            throws IOException {
+        ArrayList<BinaryFileBuffer<T>> bfbs = new ArrayList<>();
+        try {
+            for (Path f : files) {
+                InputStream in = algorithm.getInputStream(Files.newInputStream(f));
+                bfbs.add(new BinaryFileBuffer<>(in, byteArrayToType, readBufferSize));
+            }
+            mergeBinary(fbw, cmp, distinct, bfbs, typeToByteArray);
+        } finally {
+            for (BinaryFileBuffer<T> buffer : bfbs) {
+                try {
+                    buffer.close();
+                } catch (Exception ignored) {
+                }
+            }
+            for (Path f : files) {
+                Files.deleteIfExists(f);
+            }
+        }
+    }
+
+    private static <T> int mergeBinary(BufferedOutputStream fbw, final Comparator<T> cmp, boolean distinct,
+                                       List<BinaryFileBuffer<T>> buffers, Function<T, byte[]> typeToByteArray)
+            throws IOException {
+        PriorityQueue<BinaryFileBuffer<T>> pq = new PriorityQueue<>(
+                11,
+                (i, j) -> cmp.compare(i.peek(), j.peek())
+        );
+        for (BinaryFileBuffer<T> bfb : buffers) {
+            if (!bfb.empty()) {
+                pq.add(bfb);
+            }
+        }
+        int rowcounter = 0;
+        T lastLine = null;
+        while (!pq.isEmpty()) {
+            BinaryFileBuffer<T> bfb = pq.poll();
+            T r = bfb.pop();
+            // Skip duplicate lines
+            if (!distinct || lastLine == null || cmp.compare(r, lastLine) != 0) {
+                fbw.write(typeToByteArray.apply(r));
+                fbw.write('\n');
+                lastLine = r;
+            }
+            ++rowcounter;
+            if (bfb.empty()) {
+                bfb.fbr.close();
+            } else {
+                pq.add(bfb); // add it back
+            }
+        }
+        return rowcounter;
+    }
+
+    /**
+     * WARNING: Uses '\n' as a line separator, it will not work with other line separators.
+     */
+    private static class BinaryFileBuffer<T> {
+        public final InputStream fbr;
+        private final Function<byte[], T> byteArrayToType;
+        private T cache;
+        private boolean empty;
+
+        // Used to reassemble the lines read from the source input stream.
+        private final ByteArrayOutputStream bais = new ByteArrayOutputStream();
+        private final byte[] buffer;
+        private int bufferPos = 0;
+        private int bufferLimit = 0;
+
+        public BinaryFileBuffer(InputStream r, Function<byte[], T> byteArrayToType, int bufferSize)
+                throws IOException {
+            Preconditions.checkArgument(bufferSize > 1024, "Buffer size must be greater than 1024 bytes");
+            this.fbr = r;
+            this.byteArrayToType = byteArrayToType;
+            this.buffer = new byte[bufferSize];
+            reload();
+        }
+
+        public boolean empty() {
+            return this.empty;
+        }
+
+        private void reload() throws IOException {
+            try {
+                byte[] line = readLine();
+                this.cache = byteArrayToType.apply(line);
+                this.empty = this.cache == null;
+            } catch (EOFException oef) {
+                this.empty = true;
+                this.cache = null;
+            }
+        }
+
+        private boolean bufferIsEmpty() {
+            return bufferPos >= bufferLimit;
+        }
+
+        /*
+         * Read a line from the source input as a byte array. This is adapted from the implementation of
+         * BufferedReader#readLine() but without converting the line to a String.
+         */
+        private byte[] readLine() throws IOException {
+            bais.reset();
+
+            for (; ; ) {
+                if (bufferIsEmpty()) {
+                    bufferLimit = fbr.read(buffer);
+                    bufferPos = 0;
+                }
+                if (bufferIsEmpty()) { /* EOF */
+                    // Buffer is still empty even after trying to read from input stream. We have reached the EOF
+                    // Return whatever is left on the bais
+                    if (bais.size() == 0) {
+                        return null;
+                    } else {
+                        return bais.toByteArray();
+                    }
+                }
+                // Start reading a new line
+                int startByte = bufferPos;
+                while (!bufferIsEmpty()) {
+                    byte c = buffer[bufferPos];
+                    bufferPos++;
+                    if (c == '\n') { /* EOL */
+                        int lineSegmentSize = bufferPos - startByte - 1; // exclude \n
+                        if (bais.size() == 0) {
+                            // There is no partial data on the bais, which means that the whole line is in the
+                            // buffer. In this case, we can extract the line directly from the buffer without
+                            // copying first to the bais
+                            if (lineSegmentSize == 0) {
+                                return null;
+                            } else {
+                                // Copy the line from the buffer to a new byte array and return it
+                                byte[] line = new byte[lineSegmentSize];
+                                System.arraycopy(buffer, startByte, line, 0, lineSegmentSize);
+                                return line;
+                            }
+                        } else {
+                            // The first section of the line is in the bais, the remainder in the buffer. Finish
+                            // reassembling the line in the bais and return it
+                            bais.write(buffer, startByte, lineSegmentSize);
+                            if (bais.size() == 0) {
+                                return null;
+                            } else {
+                                return bais.toByteArray();
+                            }
+                        }
+                    }
+                }
+                // Reached the end of the buffer. Copy whatever is left in the buffer and read more from the source stream
+                bais.write(buffer, startByte, bufferPos - startByte);
+            }
+        }
+
+        public void close() throws IOException {
+            this.fbr.close();
+        }
+
+        public T peek() {
+            if (empty()) {
+                return null;
+            }
+            return this.cache;
+        }
+
+        public T pop() throws IOException {
+            T answer = peek();
+            reload();
+            return answer;
+        }
+    }
+}
diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/package-info.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/package-info.java
index 37c743fdaa..10f91cc554 100644
--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/package-info.java
+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/package-info.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-@Version("1.2.0")
+@Version("1.3.0")
 package org.apache.jackrabbit.oak.commons.sort;
 
 import org.osgi.annotation.versioning.Version;
diff --git a/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortByteArrayTest.java b/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortByteArrayTest.java
new file mode 100644
index 0000000000..3279a582a6
--- /dev/null
+++ b/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortByteArrayTest.java
@@ -0,0 +1,183 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.commons.sort;
+
+import org.apache.jackrabbit.oak.commons.Compression;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.Function;
+
+import static org.junit.Assert.assertArrayEquals;
+
+public class ExternalSortByteArrayTest {
+    @Rule
+    public TemporaryFolder folder = new TemporaryFolder(new File("target"));
+    private final static Charset charset = StandardCharsets.UTF_8;
+    private final static Comparator<BinaryTestLine> cmp = Comparator.naturalOrder();
+    private final static Function<byte[], BinaryTestLine> byteArrayToType = line -> line != null ? new BinaryTestLine(line) : null;
+    private final static Function<BinaryTestLine, byte[]> typeToByteArray = tl -> tl != null ? tl.bytes : null;
+
+    @Test
+    public void sortManyFilesNoCompression() throws Exception {
+        sortManyFiles(Compression.NONE);
+    }
+
+    @Test
+    public void sortManyFilesGzipCompression() throws Exception {
+        sortManyFiles(Compression.GZIP);
+    }
+
+    @Test
+    public void sortManyFilesLZ4Compression() throws Exception {
+        sortManyFiles(ExternalSortTest.LZ4());
+    }
+
+    public void sortManyFiles(Compression compression) throws Exception {
+        int testCount = 1000;
+        List<BinaryTestLine> testLines = generateTestLines(testCount);
+
+        List<BinaryTestLine> testLinesShuffled = new ArrayList<>(testLines);
+        Collections.shuffle(testLinesShuffled);
+
+        List<Path> intermediateFiles = createIntermediateFiles(testLinesShuffled, 10, compression);
+        Path resultFile = folder.newFile(compression.addSuffix("sorted.json")).toPath();
+
+        try (BufferedOutputStream bos = new BufferedOutputStream(compression.getOutputStream(Files.newOutputStream(resultFile)))) {
+            ExternalSortByteArray.mergeSortedFilesBinary(intermediateFiles,
+                    bos,
+                    cmp,
+                    true,
+                    compression,
+                    typeToByteArray,
+                    byteArrayToType);
+        }
+
+        ArrayList<String> lines = new ArrayList<>();
+        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(compression.getInputStream(Files.newInputStream(resultFile)), charset))) {
+            while (true) {
+                String line = bufferedReader.readLine();
+                if (line == null) {
+                    break;
+                }
+                lines.add(line);
+            }
+        }
+        String[] actual = lines.toArray(new String[0]);
+        String[] expected = testLines.stream().map(tl -> tl.line).toArray(String[]::new);
+        assertArrayEquals(expected, actual);
+    }
+
+    private List<BinaryTestLine> generateTestLines(int numberOfLines) {
+        List<BinaryTestLine> testLines = new ArrayList<>(numberOfLines);
+        for (int i = 0; i < numberOfLines; i++) {
+            testLines.add(new BinaryTestLine(i + ":" + "foo-" + i));
+        }
+        return testLines;
+    }
+
+    private List<Path> createIntermediateFiles(List<BinaryTestLine> ffsLines, int numberOfFiles, Compression compression) throws Exception {
+        Iterator<BinaryTestLine> ffsIter = ffsLines.iterator();
+        Path workFolder = folder.newFolder("merge_many_test").toPath();
+        ArrayList<Path> intermediateFiles = new ArrayList<>(numberOfFiles);
+        int linesPerFile = ffsLines.size() / numberOfFiles;
+
+        for (int fileIdx = 0; fileIdx < numberOfFiles; fileIdx++) {
+            Path intermediateFile = workFolder.resolve(compression.addSuffix("intermediate-" + fileIdx + ".json"));
+            ArrayList<BinaryTestLine> binaryTestLinesInFile = new ArrayList<>();
+            while (binaryTestLinesInFile.size() < linesPerFile && ffsIter.hasNext()) {
+                binaryTestLinesInFile.add(ffsIter.next());
+            }
+            if (fileIdx == numberOfFiles - 1) {
+                // Add the remaining elements to the last file
+                while (ffsIter.hasNext()) {
+                    binaryTestLinesInFile.add(ffsIter.next());
+                }
+            }
+            binaryTestLinesInFile.sort(cmp);
+
+            try (BufferedWriter bw = new BufferedWriter(
+                    new OutputStreamWriter(
+                            compression.getOutputStream(
+                                    Files.newOutputStream(intermediateFile))))) {
+                for (BinaryTestLine binaryTestLine : binaryTestLinesInFile) {
+                    bw.write(binaryTestLine.line);
+                    bw.write("\n");
+                }
+            }
+            intermediateFiles.add(intermediateFile);
+        }
+        return intermediateFiles;
+    }
+
+    private static class BinaryTestLine implements Comparable<BinaryTestLine> {
+        final String line;
+        final int value;
+        final byte[] bytes;
+
+        public BinaryTestLine(String line) {
+            this.line = line;
+            this.value = Integer.parseInt(line.substring(0, line.indexOf(':')));
+            this.bytes = line.getBytes(StandardCharsets.UTF_8);
+        }
+
+        public BinaryTestLine(byte[] bytes) {
+            this.bytes = bytes;
+            this.line = new String(bytes, StandardCharsets.UTF_8);
+            this.value = Integer.parseInt(line.substring(0, line.indexOf(':')));
+        }
+
+        @Override
+        public int compareTo(BinaryTestLine o) {
+            return Integer.compare(value, o.value);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            BinaryTestLine binaryTestLine = (BinaryTestLine) o;
+            return line.equals(binaryTestLine.line);
+        }
+
+        @Override
+        public int hashCode() {
+            return line.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return line;
+        }
+    }
+}
\ No newline at end of file
diff --git a/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortTest.java b/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortTest.java
index 359bda6646..47530a471b 100644
--- a/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortTest.java
+++ b/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/ExternalSortTest.java
@@ -518,7 +518,7 @@ public class ExternalSortTest {
 
     }
 
-    private static class TestLine implements Comparable<TestLine> {
+    static class TestLine implements Comparable<TestLine> {
         final String line;
         final int value;
 
@@ -589,7 +589,7 @@ public class ExternalSortTest {
         }
     }
 
-    private static Compression LZ4() {
+    static Compression LZ4() {
         return new Compression() {
             @Override
             public InputStream getInputStream(InputStream in) throws IOException {
