diff --git a/oak-commons/pom.xml b/oak-commons/pom.xml
index d8ba9b5931..21bf5f2890 100644
--- a/oak-commons/pom.xml
+++ b/oak-commons/pom.xml
@@ -93,6 +93,11 @@
       <artifactId>oak-mk-api</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <version>2.4</version>
+    </dependency>
 
     <!-- Test dependencies -->
     <dependency>
diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/StringSort.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/StringSort.java
new file mode 100644
index 0000000000..c8f60bdedc
--- /dev/null
+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/sort/StringSort.java
@@ -0,0 +1,255 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.jackrabbit.oak.commons.sort;
+
+import java.io.BufferedWriter;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+
+import com.google.common.base.Charsets;
+import com.google.common.collect.Lists;
+import com.google.common.io.Closer;
+import com.google.common.io.Files;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.LineIterator;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Utility class to store a list of string and perform sort on that. For small size
+ * the list would be maintained in memory. If the size crosses the required threshold then
+ * the sorting would be performed externally
+ */
+public class StringSort implements Closeable {
+    private final Logger log = LoggerFactory.getLogger(getClass());
+    public static final int BATCH_SIZE = 2048;
+
+    private final int overflowToDiskThreshold;
+    private final Comparator<String> comparator;
+
+    private final List<String> ids = Lists.newArrayList();
+    private long size;
+
+    private final List<String> inMemBatch = Lists.newArrayList();
+
+    private boolean useFile;
+    private PersistentState persistentState;
+
+    public StringSort(int overflowToDiskThreshold, Comparator<String> comparator) {
+        this.overflowToDiskThreshold = overflowToDiskThreshold;
+        this.comparator = comparator;
+    }
+
+    public void add(String id) throws IOException {
+        if (useFile) {
+            addToBatch(id);
+        } else {
+            ids.add(id);
+            if (ids.size() >= overflowToDiskThreshold) {
+                flushToFile(ids);
+                useFile = true;
+                log.debug("In memory buffer crossed the threshold of {}. " +
+                        "Switching to filesystem [{}] to manage the state", overflowToDiskThreshold, persistentState);
+            }
+        }
+        size++;
+    }
+
+    public void sort() throws IOException {
+        if (useFile) {
+            //Flush the last batch
+            flushToFile(inMemBatch);
+            persistentState.sort();
+        } else {
+            Collections.sort(ids, comparator);
+        }
+    }
+
+    public Iterator<String> getIds() throws IOException {
+        if (useFile) {
+            return persistentState.getIterator();
+        } else {
+            return ids.iterator();
+        }
+    }
+
+    public long getSize() {
+        return size;
+    }
+
+    public boolean isEmpty() {
+        return size == 0;
+    }
+
+    public boolean usingFile() {
+        return useFile;
+    }
+
+    @Override
+    public void close() throws IOException {
+        if (persistentState != null) {
+            persistentState.close();
+        }
+    }
+
+    private void addToBatch(String id) throws IOException {
+        inMemBatch.add(id);
+        if (inMemBatch.size() >= BATCH_SIZE) {
+            flushToFile(inMemBatch);
+        }
+    }
+
+    private void flushToFile(List<String> ids) throws IOException {
+        BufferedWriter w = getPersistentState().getWriter();
+        for (String id : ids) {
+            w.write(id);
+            w.newLine();
+        }
+        ids.clear();
+    }
+
+    private PersistentState getPersistentState() {
+        //Lazily initialize the persistent state
+        if (persistentState == null) {
+            persistentState = new PersistentState(comparator);
+        }
+        return persistentState;
+    }
+
+    private static class PersistentState implements Closeable {
+        /**
+         * Maximum loop count when creating temp directories.
+         */
+        private static final int TEMP_DIR_ATTEMPTS = 10000;
+
+        private final Charset charset = Charsets.UTF_8;
+        private final File workDir;
+        private final Comparator<String> comparator;
+        private File idFile;
+        private File sortedFile;
+        private BufferedWriter writer;
+        private List<CloseableIterator> openedIterators = Lists.newArrayList();
+
+        public PersistentState(Comparator<String> comparator) {
+            this(comparator, createTempDir("oak-sorter-"));
+        }
+
+        public PersistentState(Comparator<String> comparator, File workDir) {
+            this.workDir = workDir;
+            this.comparator = comparator;
+        }
+
+        public BufferedWriter getWriter() throws FileNotFoundException {
+            if (idFile == null) {
+                idFile = new File(workDir, "strings.txt");
+                sortedFile = new File(workDir, "strings-sorted.txt");
+                writer = Files.newWriter(idFile, charset);
+            }
+            return writer;
+        }
+
+        public void sort() throws IOException {
+            closeWriter();
+
+            List<File> sortedFiles = ExternalSort.sortInBatch(idFile,
+                    comparator, //Comparator to use
+                    ExternalSort.DEFAULTMAXTEMPFILES,
+                    ExternalSort.DEFAULT_MAX_MEM_BYTES,
+                    charset, //charset
+                    workDir,  //temp directory where intermediate files are created
+                    true //distinct
+            );
+
+            ExternalSort.mergeSortedFiles(sortedFiles,
+                    sortedFile,
+                    comparator,
+                    charset,
+                    true
+            );
+        }
+
+        public Iterator<String> getIterator() throws IOException {
+            CloseableIterator itr = new CloseableIterator(Files.newReader(sortedFile, charset));
+            openedIterators.add(itr);
+            return itr;
+        }
+
+        @Override
+        public String toString() {
+            return "PersistentState : workDir=" + workDir.getAbsolutePath();
+        }
+
+        @Override
+        public void close() throws IOException {
+            Closer closer = Closer.create();
+            try {
+                closer.register(writer);
+                for (CloseableIterator citr : openedIterators) {
+                    closer.register(citr);
+                }
+                closer.register(new Closeable() {
+                    @Override
+                    public void close() throws IOException {
+                        FileUtils.deleteDirectory(workDir);
+                    }
+                });
+            } finally {
+                closer.close();
+            }
+        }
+
+        private void closeWriter() throws IOException {
+            writer.close();
+        }
+
+        /**
+         * Taken from com.google.common.io.Files#createTempDir()
+         * Modified to provide a prefix
+         */
+        private static File createTempDir(String prefix) {
+            File baseDir = new File(System.getProperty("java.io.tmpdir"));
+            String baseName = System.currentTimeMillis() + "-";
+
+            for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) {
+                File tempDir = new File(baseDir, prefix + baseName + counter);
+                if (tempDir.mkdir()) {
+                    return tempDir;
+                }
+            }
+            throw new IllegalStateException("Failed to create directory within "
+                    + TEMP_DIR_ATTEMPTS + " attempts (tried "
+                    + baseName + "0 to " + baseName + (TEMP_DIR_ATTEMPTS - 1) + ')');
+        }
+    }
+
+    private static class CloseableIterator extends LineIterator implements Closeable {
+        public CloseableIterator(Reader reader) throws IllegalArgumentException {
+            super(reader);
+        }
+    }
+}
diff --git a/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/StringSortTest.java b/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/StringSortTest.java
new file mode 100644
index 0000000000..65ee33d3dc
--- /dev/null
+++ b/oak-commons/src/test/java/org/apache/jackrabbit/oak/commons/sort/StringSortTest.java
@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.jackrabbit.oak.commons.sort;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.Collections2;
+import com.google.common.collect.ImmutableList;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class StringSortTest {
+    private Comparator<String> comparator = new PathComparator();
+    private StringSort collector;
+
+    @Test
+    public void inMemory() throws Exception{
+        List<String> paths = createTestPaths(5, false);
+        collector = new StringSort(paths.size() + 1,comparator);
+        addPathsToCollector(paths);
+
+        assertConstraints(paths);
+        assertFalse(collector.usingFile());
+        collector.close();
+    }
+
+    @Test
+    public void overflowToDisk() throws Exception{
+        //Create ~50k paths
+        List<String> paths = createTestPaths(10, true);
+        collector = new StringSort(1000, comparator);
+        addPathsToCollector(paths);
+
+        assertTrue(collector.usingFile());
+        assertConstraints(paths);
+
+        collector.close();
+    }
+
+    private void assertConstraints(List<String> paths) throws IOException {
+        assertEquals(paths.size(), collector.getSize());
+
+        Collections.sort(paths, comparator);
+        collector.sort();
+
+        List<String> sortedPaths = ImmutableList.copyOf(collector.getIds());
+        assertEquals(paths.size(), sortedPaths.size());
+        assertEquals(paths, sortedPaths);
+    }
+
+    private void addPathsToCollector(Iterable<String> paths) throws IOException {
+        for (String path : paths){
+            collector.add(path);
+        }
+    }
+
+    private static List<String> createTestPaths(int depth, boolean permutation){
+        List<String> rootPaths = Arrays.asList("a", "b", "c", "d", "e", "f", "g");
+        List<String> paths = new ArrayList<String>();
+
+
+        if (permutation){
+            List<String> newRoots = new ArrayList<String>();
+            for (List<String> permuts : Collections2.orderedPermutations(rootPaths)){
+                newRoots.add(Joiner.on("").join(permuts));
+            }
+            rootPaths = newRoots;
+        }
+
+        for (String root : rootPaths){
+            List<String> pathElements = new ArrayList<String>();
+            pathElements.add(root);
+            paths.add(createId(pathElements));
+            for (int i = 0; i < depth; i++){
+                pathElements.add(root + i);
+                paths.add(createId(pathElements));
+            }
+        }
+
+        Set<String> idSet = new HashSet<String>(paths);
+        assertEquals(paths.size(), idSet.size());
+
+        Collections.shuffle(paths);
+        return paths;
+    }
+
+    private static String createId(Iterable<String> pathElements){
+        return "/" + Joiner.on('/').join(pathElements);
+    }
+
+    private static  class PathComparator implements Comparator<String>, Serializable {
+        @Override
+        public int compare(String o1, String o2) {
+            int d1 = pathDepth(o1);
+            int d2 = pathDepth(o2);
+            if (d1 != d2) {
+                return Integer.signum(d2 - d1);
+            }
+            return o1.compareTo(o2);
+        }
+
+        private static int pathDepth(String path) {
+            if (path.equals("/")) {
+                return 0;
+            }
+            int depth = 0;
+            for (int i = 0; i < path.length(); i++) {
+                if (path.charAt(i) == '/') {
+                    depth++;
+                }
+            }
+            return depth;
+        }
+    }
+}
