diff --git a/core/src/main/java/org/apache/metamodel/data/RowPublisherDataSet.java b/core/src/main/java/org/apache/metamodel/data/RowPublisherDataSet.java
index 47f03259..2640246c 100644
--- a/core/src/main/java/org/apache/metamodel/data/RowPublisherDataSet.java
+++ b/core/src/main/java/org/apache/metamodel/data/RowPublisherDataSet.java
@@ -18,8 +18,11 @@
  */
 package org.apache.metamodel.data;
 
+import java.io.Closeable;
+
 import org.apache.metamodel.query.SelectItem;
 import org.apache.metamodel.util.Action;
+import org.apache.metamodel.util.FileHelper;
 import org.apache.metamodel.util.SharedExecutorService;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -33,80 +36,85 @@ import org.slf4j.LoggerFactory;
  */
 public final class RowPublisherDataSet extends AbstractDataSet {
 
-	private static final Logger logger = LoggerFactory
-			.getLogger(RowPublisherDataSet.class);
+    private static final Logger logger = LoggerFactory.getLogger(RowPublisherDataSet.class);
+
+    private final int _maxRows;
+    private final Action<RowPublisher> _publishAction;
+    private final Closeable[] _closeables;
+    private RowPublisherImpl _rowPublisher;
+    private boolean _closed;
 
-	private final int _maxRows;
-	private final Action<RowPublisher> _publishAction;
-	private RowPublisherImpl _rowPublisher;
-	private boolean _closed;
+    public RowPublisherDataSet(SelectItem[] selectItems, int maxRows, Action<RowPublisher> publishAction) {
+        this(selectItems, maxRows, publishAction, new Closeable[0]);
+    }
 
-	public RowPublisherDataSet(SelectItem[] selectItems, int maxRows,
-			Action<RowPublisher> publishAction) {
-	    super(selectItems);
-		_maxRows = maxRows;
-		_publishAction = publishAction;
-		_closed = false;
-	}
+    public RowPublisherDataSet(SelectItem[] selectItems, int maxRows, Action<RowPublisher> publishAction,
+            Closeable... closeables) {
+        super(selectItems);
+        _maxRows = maxRows;
+        _publishAction = publishAction;
+        _closed = false;
+        _closeables = closeables;
+    }
 
-	public int getMaxRows() {
-		return _maxRows;
-	}
+    public int getMaxRows() {
+        return _maxRows;
+    }
 
-	@Override
-	public void close() {
-		super.close();
-		_closed = true;
-		if (_rowPublisher != null) {
-		    _rowPublisher.finished();
-		    _rowPublisher = null;
-		}
-	}
+    @Override
+    public void close() {
+        super.close();
+        _closed = true;
+        if (_rowPublisher != null) {
+            _rowPublisher.finished();
+            _rowPublisher = null;
+        }
+        if (_closeables != null) {
+            FileHelper.safeClose((Object[]) _closeables);
+        }
+    }
 
-	@Override
-	protected void finalize() throws Throwable {
-		super.finalize();
-		if (!_closed) {
-			logger.warn(
-					"finalize() invoked, but DataSet is not closed. Invoking close() on {}",
-					this);
-			close();
-		}
-	}
+    @Override
+    protected void finalize() throws Throwable {
+        super.finalize();
+        if (!_closed) {
+            logger.warn("finalize() invoked, but DataSet is not closed. Invoking close() on {}", this);
+            close();
+        }
+    }
 
-	@Override
-	public boolean next() {
-		if (_rowPublisher == null) {
-			// first time, create the publisher
-			_rowPublisher = new RowPublisherImpl(this);
-			logger.info("Starting separate thread for publishing action: {}",
-					_publishAction);
-			Runnable runnable = new Runnable() {
-				public void run() {
-					boolean successful = false;
-					try {
-						_publishAction.run(_rowPublisher);
-						logger.debug("Publshing action finished!");
-						successful = true;
-					} catch (Exception e) {
-						_rowPublisher.failed(e);
-					}
-					if (successful) {
-						_rowPublisher.finished();
-					}
-				};
-			};
-			SharedExecutorService.get().submit(runnable);
-		}
-		return _rowPublisher.next();
-	}
+    @Override
+    public boolean next() {
+        if (_rowPublisher == null) {
+            // first time, create the publisher
+            _rowPublisher = new RowPublisherImpl(this);
+            logger.info("Starting separate thread for publishing action: {}", _publishAction);
+            Runnable runnable = new Runnable() {
+                public void run() {
+                    boolean successful = false;
+                    try {
+                        _publishAction.run(_rowPublisher);
+                        logger.debug("Publshing action finished!");
+                        successful = true;
+                    } catch (Exception e) {
+                        _rowPublisher.failed(e);
+                    }
+                    if (successful) {
+                        _rowPublisher.finished();
+                    }
+                };
+            };
+            SharedExecutorService.get().submit(runnable);
+        }
+        return _rowPublisher.next();
+    }
 
-	@Override
-	public Row getRow() {
-		if (_rowPublisher == null) {
-			return null;
-		}
-		return _rowPublisher.getRow();
-	}
+    @Override
+    public Row getRow() {
+        if (_rowPublisher == null) {
+            return null;
+        }
+        return _rowPublisher.getRow();
+    }
 
 }
diff --git a/core/src/main/java/org/apache/metamodel/util/FileHelper.java b/core/src/main/java/org/apache/metamodel/util/FileHelper.java
index d5676cc0..0ff06a80 100644
--- a/core/src/main/java/org/apache/metamodel/util/FileHelper.java
+++ b/core/src/main/java/org/apache/metamodel/util/FileHelper.java
@@ -39,6 +39,8 @@ import java.io.Reader;
 import java.io.Writer;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.nio.file.Files;
+import java.nio.file.StandardCopyOption;
 import java.sql.Connection;
 import java.sql.ResultSet;
 import java.sql.Statement;
@@ -90,7 +92,8 @@ public final class FileHelper {
                 logger.error("Could not create tempFile in order to find temporary dir", e);
                 result = new File("metamodel.tmp.dir");
                 if (!result.mkdir()) {
-                    throw new IllegalStateException("Could not create directory for temporary files: " + result.getName());
+                    throw new IllegalStateException("Could not create directory for temporary files: "
+                            + result.getName());
                 }
                 result.deleteOnExit();
             }
@@ -110,7 +113,8 @@ public final class FileHelper {
         return getWriter(outputStream, encoding, false);
     }
 
-    public static Writer getWriter(OutputStream outputStream, String encoding, boolean insertBom) throws IllegalStateException {
+    public static Writer getWriter(OutputStream outputStream, String encoding, boolean insertBom)
+            throws IllegalStateException {
         if (!(outputStream instanceof BufferedOutputStream)) {
             outputStream = new BufferedOutputStream(outputStream);
         }
@@ -128,7 +132,8 @@ public final class FileHelper {
         }
     }
 
-    public static Writer getWriter(File file, String encoding, boolean append, boolean insertBom) throws IllegalStateException {
+    public static Writer getWriter(File file, String encoding, boolean append, boolean insertBom)
+            throws IllegalStateException {
         if (append && insertBom) {
             throw new IllegalArgumentException("Can not insert BOM into appending writer");
         }
@@ -144,13 +149,13 @@ public final class FileHelper {
     public static Reader getReader(InputStream inputStream, String encoding) throws IllegalStateException {
         try {
             if (encoding == null || encoding.toLowerCase().indexOf("utf") != -1) {
-                byte bom[] = new byte[4];
+                final byte bom[] = new byte[4];
                 int unread;
 
                 // auto-detect byte-order-mark
                 @SuppressWarnings("resource")
-                PushbackInputStream pushbackInputStream = new PushbackInputStream(inputStream, bom.length);
-                int n = pushbackInputStream.read(bom, 0, bom.length);
+                final PushbackInputStream pushbackInputStream = new PushbackInputStream(inputStream, bom.length);
+                final int n = pushbackInputStream.read(bom, 0, bom.length);
 
                 // Read ahead four bytes and check for BOM marks.
                 if ((bom[0] == (byte) 0xEF) && (bom[1] == (byte) 0xBB) && (bom[2] == (byte) 0xBF)) {
@@ -324,7 +329,8 @@ public final class FileHelper {
         return new BufferedReader(reader);
     }
 
-    public static BufferedReader getBufferedReader(InputStream inputStream, String encoding) throws IllegalStateException {
+    public static BufferedReader getBufferedReader(InputStream inputStream, String encoding)
+            throws IllegalStateException {
         Reader reader = getReader(inputStream, encoding);
         return new BufferedReader(reader);
     }
@@ -349,7 +355,8 @@ public final class FileHelper {
         writeString(outputStream, string, DEFAULT_ENCODING);
     }
 
-    public static void writeString(OutputStream outputStream, String string, String encoding) throws IllegalStateException {
+    public static void writeString(OutputStream outputStream, String string, String encoding)
+            throws IllegalStateException {
         final Writer writer = getWriter(outputStream, encoding);
         writeString(writer, string, encoding);
     }
@@ -416,16 +423,45 @@ public final class FileHelper {
         }
     }
 
-    public static void copy(File from, File to) throws IllegalStateException {
-        assert from.exists();
+    public static void copy(Resource from, Resource to) throws IllegalStateException {
+        assert from.isExists();
 
-        final InputStream fromStream = getInputStream(from);
-        final OutputStream toStream = getOutputStream(to);
+        if (from instanceof FileResource && to instanceof FileResource) {
+            final File fromFile = ((FileResource) from).getFile();
+            final File toFile = ((FileResource) to).getFile();
+            copy(fromFile, toFile);
+            return;
+        }
 
+        final InputStream fromStream = from.read();
         try {
-            copy(fromStream, toStream);
+            if (to instanceof FileResource) {
+                final File toFile = ((FileResource) to).getFile();
+                try {
+                    Files.copy(fromStream, toFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
+                } catch (IOException e) {
+                    throw new IllegalStateException(e);
+                }
+            } else {
+                final OutputStream toStream = to.write();
+                try {
+                    copy(fromStream, toStream);
+                } finally {
+                    safeClose(toStream);
+                }
+            }
         } finally {
-            safeClose(fromStream, toStream);
+            safeClose(fromStream);
+        }
+    }
+
+    public static void copy(File from, File to) throws IllegalStateException {
+        assert from.exists();
+
+        try {
+            Files.copy(from.toPath(), to.toPath(), StandardCopyOption.REPLACE_EXISTING);
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
         }
     }
 
diff --git a/core/src/main/java/org/apache/metamodel/util/ObjectComparator.java b/core/src/main/java/org/apache/metamodel/util/ObjectComparator.java
index 697cf46c..6f442d51 100644
--- a/core/src/main/java/org/apache/metamodel/util/ObjectComparator.java
+++ b/core/src/main/java/org/apache/metamodel/util/ObjectComparator.java
@@ -96,7 +96,7 @@ public final class ObjectComparator implements Comparator<Object> {
 				return -1 * c2.compareTo(o1);
 			}
 		}
-		logger.info("Using ToStringComparator because no apparent better comparison method could be found");
+		logger.debug("Using ToStringComparator because no apparent better comparison method could be found");
 		return ToStringComparator.getComparator().compare(o1, o2);
 	}
 }
\ No newline at end of file
