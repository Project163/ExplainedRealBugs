diff --git a/activemq-client/src/main/java/org/apache/activemq/broker/SslContext.java b/activemq-client/src/main/java/org/apache/activemq/broker/SslContext.java
index c3843ae98..61e534a5e 100644
--- a/activemq-client/src/main/java/org/apache/activemq/broker/SslContext.java
+++ b/activemq-client/src/main/java/org/apache/activemq/broker/SslContext.java
@@ -38,6 +38,7 @@ public class SslContext {
     protected List<KeyManager> keyManagers = new ArrayList<KeyManager>();
     protected List<TrustManager> trustManagers = new ArrayList<TrustManager>();
     protected SecureRandom secureRandom;
+    private volatile boolean initialized;
     private SSLContext sslContext;
     
     private static final ThreadLocal<SslContext> current = new ThreadLocal<SslContext>();
@@ -117,18 +118,24 @@ public class SslContext {
     }
 
     public SSLContext getSSLContext() throws NoSuchProviderException, NoSuchAlgorithmException, KeyManagementException {
-        if( sslContext == null ) {
-            if( provider == null ) {
-                sslContext = SSLContext.getInstance(protocol);
-            } else {
-                sslContext = SSLContext.getInstance(protocol, provider);
+        if (!initialized) {
+            synchronized (this) {
+                if (!initialized) {
+                    if (provider == null) {
+                        sslContext = SSLContext.getInstance(protocol);
+                    } else {
+                        sslContext = SSLContext.getInstance(protocol, provider);
+                    }
+                    sslContext.init(getKeyManagersAsArray(), getTrustManagersAsArray(), getSecureRandom());
+                    initialized = true;
+                }
             }
-            sslContext.init(getKeyManagersAsArray(), getTrustManagersAsArray(), getSecureRandom());
         }
         return sslContext;
     }
-    public void setSSLContext(SSLContext sslContext) {
+    public synchronized void setSSLContext(SSLContext sslContext) {
         this.sslContext = sslContext;
+        initialized = true;
     }
     
     
diff --git a/activemq-client/src/test/java/org/apache/activemq/broker/scheduler/SslContextTest.java b/activemq-client/src/test/java/org/apache/activemq/broker/scheduler/SslContextTest.java
new file mode 100644
index 000000000..f0405b045
--- /dev/null
+++ b/activemq-client/src/test/java/org/apache/activemq/broker/scheduler/SslContextTest.java
@@ -0,0 +1,69 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.broker.scheduler;
+
+import org.apache.activemq.broker.SslContext;
+import org.junit.Test;
+
+import javax.net.ssl.SSLContext;
+import java.security.KeyManagementException;
+import java.security.NoSuchAlgorithmException;
+import java.security.NoSuchProviderException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public class SslContextTest {
+    SslContext underTest = new SslContext();
+
+    @Test
+    public void testConcurrentGet() throws Exception {
+
+        final int numReps = 100;
+        ExecutorService executorService = Executors.newFixedThreadPool(numReps);
+        final SSLContext[] results = new SSLContext[numReps];
+
+        for (int i=0; i<numReps; i++) {
+            final int instanceIndex = i;
+            executorService.execute(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        results[instanceIndex] = underTest.getSSLContext();
+                    } catch (NoSuchProviderException e) {
+                        e.printStackTrace();
+                    } catch (NoSuchAlgorithmException e) {
+                        e.printStackTrace();
+                    } catch (KeyManagementException e) {
+                        e.printStackTrace();
+                    }
+                }
+            });
+        }
+
+        executorService.shutdown();
+        assertTrue(executorService.awaitTermination(10, TimeUnit.SECONDS));
+
+        for (int i=0; i<numReps; i++) {
+            assertEquals("single instance", results[0], results[i]);
+        }
+    }
+}
