diff --git a/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionImpl.java b/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionImpl.java
index ee1940374..40de7d73b 100644
--- a/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionImpl.java
+++ b/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionImpl.java
@@ -17,6 +17,7 @@
 package org.apache.activemq.ra;
 
 import java.lang.reflect.Method;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import jakarta.jms.JMSException;
 import jakarta.jms.Message;
@@ -64,11 +65,11 @@ public class ServerSessionImpl implements ServerSession, InboundContext, Work, D
     private MessageProducer messageProducer;
     private final ServerSessionPoolImpl pool;
 
-    private Object runControlMutex = new Object();
-    private boolean runningFlag;
+    private final AtomicBoolean running = new AtomicBoolean(false);
+
     /**
      * True if an error was detected that cause this session to be stale. When a
-     * session is stale, it should not be used again for proccessing.
+     * session is stale, it should not be used again for processing.
      */
     private boolean stale;
     /**
@@ -90,9 +91,12 @@ public class ServerSessionImpl implements ServerSession, InboundContext, Work, D
         this.workManager = workManager;
         this.endpoint = endpoint;
         this.useRAManagedTx = useRAManagedTx;
+        this.batchSize = batchSize;
+
+        // Ideally we would do that in the start() method, such as we don't stack messages in the session while it's not
+        // yet started.
         this.session.setMessageListener((MessageListener)endpoint);
         this.session.setDeliveryListener(this);
-        this.batchSize = batchSize;
     }
 
     private static synchronized int getNextLogId() {
@@ -107,6 +111,10 @@ public class ServerSessionImpl implements ServerSession, InboundContext, Work, D
         return stale || !session.isRunning();
     }
 
+    protected boolean isRunning() {
+        return running.get();
+    }
+
     public MessageProducer getMessageProducer() throws JMSException {
         if (messageProducer == null) {
             messageProducer = getSession().createProducer(null);
@@ -119,12 +127,9 @@ public class ServerSessionImpl implements ServerSession, InboundContext, Work, D
      */
     public void start() throws JMSException {
 
-        synchronized (runControlMutex) {
-            if (runningFlag) {
-                log.debug("Start request ignored, already running.");
-                return;
-            }
-            runningFlag = true;
+        if (!running.compareAndSet(false, true)) {
+            log.debug("Start request ignored, already running.");
+            return; // already running
         }
 
         // We get here because we need to start a async worker.
@@ -149,7 +154,9 @@ public class ServerSessionImpl implements ServerSession, InboundContext, Work, D
                 }
 
             });
-        } catch (WorkException e) {
+        } catch (final WorkException e) {
+            log.warn("Failed to schedule work for session {}, marking not running", this, e);
+            running.set(false); // make sure we don't leave the ServerSession in a running state (misleading)
             throw (JMSException)new JMSException("Start failed: " + e).initCause(e);
         }
     }
@@ -177,27 +184,25 @@ public class ServerSessionImpl implements ServerSession, InboundContext, Work, D
                 if ( log.isDebugEnabled() ) {
                     log.debug("Endpoint {} failed to process message.", this, e);
                 } else if ( log.isInfoEnabled() ) {
-                    log.info("Endpoint {} failed to process message. Reason: " + e.getMessage(), this);
+                    log.info("Endpoint {} failed to process message. Reason: {}", this, e.getMessage());
                 }
             } finally {
                 InboundContextSupport.unregister(this);
                 log.debug("run loop end");
-                synchronized (runControlMutex) {
-                    // This endpoint may have gone stale due to error
-                    if (stale) {
-                        log.debug("Session {} stale, removing from pool", this);
-                        runningFlag = false;
-                        pool.removeFromPool(this);
-                        break;
-                    }
-                    if (!session.hasUncomsumedMessages()) {
-                        runningFlag = false;
-                        log.debug("Session {} has no unconsumed message, returning to pool", this);
-                        pool.returnToPool(this);
-                        break;
-                    } else {
-                        log.debug("Session {} has more work to do b/c of unconsumed", this);
-                    }
+                // This endpoint may have gone stale due to error
+                if (stale) {
+                    log.debug("Session {} stale, removing from pool", this);
+                    running.set(false);
+                    pool.removeFromPool(this);
+                    break;
+                }
+                if (!session.hasUncomsumedMessages()) {
+                    log.debug("Session {} has no unconsumed message, returning to pool", this);
+                    running.set(false);
+                    pool.returnToPool(this);
+                    break;
+                } else {
+                    log.debug("Session {} has more work to do b/c of unconsumed", this);
                 }
             }
         }
diff --git a/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionPoolImpl.java b/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionPoolImpl.java
index 76c836b47..d4700252e 100644
--- a/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionPoolImpl.java
+++ b/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionPoolImpl.java
@@ -177,9 +177,21 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
      */
     private ServerSessionImpl getExistingActiveServerSession() {
         ServerSessionImpl ss = null;
+        // try to find a session that is not in use already (all message consumed and back to the pool or stale to be removed)
+        for (ServerSessionImpl activeSession : activeSessions) {
+            if (!activeSession.isRunning()) {
+                activeSessions.remove(activeSession);
+                activeSessions.add(activeSession);
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Selected non-running active session: {}", activeSession);
+                }
+                return activeSession;
+            }
+        }
+        // if none, we'll have to pull a running active session
         if (!activeSessions.isEmpty()) {
             if (activeSessions.size() > 1) {
-                // round robin
+                // round-robin
                 ss = activeSessions.remove(0);
                 activeSessions.add(ss);
             } else {
@@ -187,7 +199,7 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
             }
         }
         if (LOG.isDebugEnabled()) {
-            LOG.debug("Reusing an active session: " + ss);
+            LOG.debug("Reusing a running active session: {}", ss);
         }
         return ss;
     }
diff --git a/activemq-ra/src/test/java/org/apache/activemq/ra/ServerSessionImplTest.java b/activemq-ra/src/test/java/org/apache/activemq/ra/ServerSessionImplTest.java
index 8f1006a3c..11359eec4 100644
--- a/activemq-ra/src/test/java/org/apache/activemq/ra/ServerSessionImplTest.java
+++ b/activemq-ra/src/test/java/org/apache/activemq/ra/ServerSessionImplTest.java
@@ -33,9 +33,11 @@ import org.jmock.api.Action;
 import org.jmock.api.Invocation;
 import org.jmock.imposters.ByteBuddyClassImposteriser;
 import org.jmock.integration.junit4.JMock;
+import org.jmock.integration.junit4.JUnitRuleMockery;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.slf4j.Logger;
@@ -58,6 +60,7 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
+import static org.hamcrest.Matchers.nullValue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -65,6 +68,13 @@ import static org.junit.Assert.assertTrue;
 @RunWith(JMock.class)
 public class ServerSessionImplTest {
 
+    @Rule
+    public JUnitRuleMockery context = new JUnitRuleMockery() {
+        {
+            setImposteriser(ByteBuddyClassImposteriser.INSTANCE);
+        }
+    };
+
     private static final Logger LOG = LoggerFactory.getLogger(ServerSessionImplTest.class);
     private static final String BROKER_URL = "vm://localhost?broker.persistent=false";
 
@@ -75,16 +85,9 @@ public class ServerSessionImplTest {
     private ActiveMQConnection con;
     private ActiveMQSession session;
     private ActiveMQEndpointWorker endpointWorker;
-    private Mockery context;
 
     @Before
     public void setUp() throws Exception {
-        context = new Mockery() {
-            {
-                setImposteriser(ByteBuddyClassImposteriser.INSTANCE);
-            }
-        };
-
         org.apache.activemq.ActiveMQConnectionFactory factory = new org.apache.activemq.ActiveMQConnectionFactory(BROKER_URL);
         con = (ActiveMQConnection) factory.createConnection();
         con.start();
@@ -155,7 +158,7 @@ public class ServerSessionImplTest {
                 will(returnValue(Boolean.FALSE));
                 allowing(messageActivationSpec).isUseRAManagedTransactionEnabled();
                 will(returnValue(Boolean.TRUE));
-                allowing(messageEndpointFactory).createEndpoint(with(any(XAResource.class)));
+                allowing(messageEndpointFactory).createEndpoint(with(nullValue(XAResource.class)));
                 will(returnValue(messageEndpoint));
 
                 allowing(workManager).scheduleWork((Work) with(any(Work.class)), with(any(long.class)), with(any(ExecutionContext.class)),
@@ -191,6 +194,12 @@ public class ServerSessionImplTest {
                 allowing(messageEndpoint).afterDelivery();
                 allowing(messageEndpoint).release();
 
+                allowing(workManager).scheduleWork(
+                    with(any(Work.class)),
+                    with(any(Long.TYPE)),
+                    with(nullValue(ExecutionContext.class)),
+                    with(nullValue(WorkListener.class)));
+
             }
         });
 
@@ -283,7 +292,7 @@ public class ServerSessionImplTest {
                 will(returnValue(Boolean.FALSE));
                 allowing(messageActivationSpec).isUseRAManagedTransactionEnabled();
                 will(returnValue(Boolean.TRUE));
-                allowing(messageEndpointFactory).createEndpoint(with(any(XAResource.class)));
+                allowing(messageEndpointFactory).createEndpoint(with(nullValue(XAResource.class)));
                 will(returnValue(messageEndpoint));
 
                 allowing(workManager).scheduleWork((Work) with(any(Work.class)), with(any(long.class)), with(any(ExecutionContext.class)),
@@ -346,6 +355,12 @@ public class ServerSessionImplTest {
                 });
                 allowing(messageEndpoint).release();
 
+                allowing(workManager).scheduleWork(
+                    with(any(Work.class)),
+                    with(any(Long.TYPE)),
+                    with(nullValue(ExecutionContext.class)),
+                    with(nullValue(WorkListener.class)));
+
             }
         });
 
@@ -474,12 +489,18 @@ public class ServerSessionImplTest {
                 will(returnValue(Boolean.FALSE));
                 allowing(messageActivationSpec).isUseRAManagedTransactionEnabled();
                 will(returnValue(Boolean.TRUE));
-                allowing(messageEndpointFactory).createEndpoint(with(any(XAResource.class)));
+                allowing(messageEndpointFactory).createEndpoint(with(nullValue(XAResource.class)));
                 will(returnValue(messageEndpoint));
 
                 allowing(workManager).scheduleWork((Work) with(any(Work.class)), with(any(long.class)), with(any(ExecutionContext.class)),
                         with(any(WorkListener.class)));
                 allowing(messageEndpoint).release();
+
+                allowing(workManager).scheduleWork(
+                    with(any(Work.class)),
+                    with(any(Long.TYPE)),
+                    with(nullValue(ExecutionContext.class)),
+                    with(nullValue(WorkListener.class)));
             }
         });
 
diff --git a/pom.xml b/pom.xml
index ea4c9bbb0..c6a607347 100644
--- a/pom.xml
+++ b/pom.xml
@@ -32,6 +32,7 @@
 
   <properties>
     <maven.compiler.target>17</maven.compiler.target>
+
     <siteId>activemq-${project.version}</siteId>
     <projectName>Apache ActiveMQ</projectName>
     <!-- base url for site deployment.  See distribution management for full url.  Override this in settings.xml for staging -->
