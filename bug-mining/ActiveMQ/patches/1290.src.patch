diff --git a/activemq-core/src/main/java/org/apache/activemq/broker/region/BaseDestination.java b/activemq-core/src/main/java/org/apache/activemq/broker/region/BaseDestination.java
index f0d4f4eac..d16ef123c 100755
--- a/activemq-core/src/main/java/org/apache/activemq/broker/region/BaseDestination.java
+++ b/activemq-core/src/main/java/org/apache/activemq/broker/region/BaseDestination.java
@@ -17,7 +17,6 @@
 package org.apache.activemq.broker.region;
 
 import java.io.IOException;
-import java.util.Collection;
 import java.util.List;
 import javax.jms.ResourceAllocationException;
 import org.apache.activemq.advisory.AdvisorySupport;
@@ -148,13 +147,13 @@ public abstract class BaseDestination implements Destination {
     public void setProducerFlowControl(boolean producerFlowControl) {
         this.producerFlowControl = producerFlowControl;
     }
-    
+
     public boolean isAlwaysRetroactive() {
-    	return alwaysRetroactive;
+        return alwaysRetroactive;
     }
-    
+
     public void setAlwaysRetroactive(boolean alwaysRetroactive) {
-    	this.alwaysRetroactive = alwaysRetroactive;
+        this.alwaysRetroactive = alwaysRetroactive;
     }
 
     /**
@@ -515,7 +514,7 @@ public abstract class BaseDestination implements Destination {
      * @param context
      * @param usage
      */
-    public void isFull(ConnectionContext context, Usage usage) {
+    public void isFull(ConnectionContext context, Usage<?> usage) {
         if (advisoryWhenFull) {
             broker.isFull(context, this, usage);
         }
diff --git a/activemq-core/src/main/java/org/apache/activemq/broker/region/Destination.java b/activemq-core/src/main/java/org/apache/activemq/broker/region/Destination.java
index c1ff4a1e0..f666fa8d2 100755
--- a/activemq-core/src/main/java/org/apache/activemq/broker/region/Destination.java
+++ b/activemq-core/src/main/java/org/apache/activemq/broker/region/Destination.java
@@ -54,6 +54,12 @@ public interface Destination extends Service, Task {
 
     void acknowledge(ConnectionContext context, Subscription sub, final MessageAck ack, final MessageReference node) throws IOException;
 
+    long getInactiveTimoutBeforeGC();
+
+    void markForGC(long timeStamp);
+
+    boolean canGC();
+
     void gc();
 
     ActiveMQDestination getActiveMQDestination();
@@ -77,9 +83,9 @@ public interface Destination extends Service, Task {
     boolean isProducerFlowControl();
 
     void setProducerFlowControl(boolean value);
-    
+
     boolean isAlwaysRetroactive();
-    
+
     void setAlwaysRetroactive(boolean value);
 
     /**
@@ -208,7 +214,7 @@ public interface Destination extends Service, Task {
      * @param context
      * @param usage
      */
-    void isFull(ConnectionContext context, Usage usage);
+    void isFull(ConnectionContext context, Usage<?> usage);
 
     List<Subscription> getConsumers();
 
diff --git a/activemq-core/src/main/java/org/apache/activemq/broker/region/DestinationFilter.java b/activemq-core/src/main/java/org/apache/activemq/broker/region/DestinationFilter.java
index 3d6537932..f6e9985d9 100644
--- a/activemq-core/src/main/java/org/apache/activemq/broker/region/DestinationFilter.java
+++ b/activemq-core/src/main/java/org/apache/activemq/broker/region/DestinationFilter.java
@@ -69,6 +69,18 @@ public class DestinationFilter implements Destination {
         next.gc();
     }
 
+    public void markForGC(long timeStamp) {
+        next.markForGC(timeStamp);
+    }
+
+    public boolean canGC() {
+        return next.canGC();
+    }
+
+    public long getInactiveTimoutBeforeGC() {
+        return next.getInactiveTimoutBeforeGC();
+    }
+
     public ActiveMQDestination getActiveMQDestination() {
         return next.getActiveMQDestination();
     }
@@ -137,13 +149,13 @@ public class DestinationFilter implements Destination {
     public void setProducerFlowControl(boolean value) {
         next.setProducerFlowControl(value);
     }
-    
+
     public boolean isAlwaysRetroactive() {
-    	return next.isAlwaysRetroactive();
+        return next.isAlwaysRetroactive();
     }
-    
+
     public void setAlwaysRetroactive(boolean value) {
-    	next.setAlwaysRetroactive(value);
+        next.setAlwaysRetroactive(value);
     }
 
     public void setBlockedProducerWarningInterval(long blockedProducerWarningInterval) {
@@ -156,7 +168,6 @@ public class DestinationFilter implements Destination {
 
     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
         next.addProducer(context, info);
-
     }
 
     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {
@@ -239,7 +250,7 @@ public class DestinationFilter implements Destination {
         next.fastProducer(context, producerInfo);
     }
 
-    public void isFull(ConnectionContext context, Usage usage) {
+    public void isFull(ConnectionContext context, Usage<?> usage) {
         next.isFull(context, usage);
     }
 
@@ -290,4 +301,5 @@ public class DestinationFilter implements Destination {
     public SlowConsumerStrategy getSlowConsumerStrategy() {
         return next.getSlowConsumerStrategy();
     }
+
 }
diff --git a/activemq-core/src/main/java/org/apache/activemq/broker/region/RegionBroker.java b/activemq-core/src/main/java/org/apache/activemq/broker/region/RegionBroker.java
index 07a6be27b..2fd5cc7c5 100755
--- a/activemq-core/src/main/java/org/apache/activemq/broker/region/RegionBroker.java
+++ b/activemq-core/src/main/java/org/apache/activemq/broker/region/RegionBroker.java
@@ -155,6 +155,7 @@ public class RegionBroker extends EmptyBroker {
     }
 
     @Override
+    @SuppressWarnings("rawtypes")
     public Broker getAdaptor(Class type) {
         if (type.isInstance(this)) {
             return this;
@@ -957,7 +958,7 @@ public class RegionBroker extends EmptyBroker {
     protected void purgeInactiveDestinations() {
         inactiveDestinationsPurgeLock.writeLock().lock();
         try {
-            List<BaseDestination> list = new ArrayList<BaseDestination>();
+            List<Destination> list = new ArrayList<Destination>();
             Map<ActiveMQDestination, Destination> map = getDestinationMap();
             if (isAllowTempAutoCreationOnSend()) {
                 map.putAll(tempQueueRegion.getDestinationMap());
@@ -966,28 +967,26 @@ public class RegionBroker extends EmptyBroker {
             long maxPurgedDests = this.brokerService.getMaxPurgedDestinationsPerSweep();
             long timeStamp = System.currentTimeMillis();
             for (Destination d : map.values()) {
-                if (d instanceof BaseDestination) {
-                    BaseDestination bd = (BaseDestination) d;
-                    bd.markForGC(timeStamp);
-                    if (bd.canGC()) {
-                        list.add(bd);
-
-                        if (maxPurgedDests > 0 && list.size() == maxPurgedDests) {
-                            break;
-                        }
+                d.markForGC(timeStamp);
+                if (d.canGC()) {
+                    list.add(d);
+                    if (maxPurgedDests > 0 && list.size() == maxPurgedDests) {
+                        break;
                     }
                 }
             }
 
-            if (list.isEmpty() == false) {
-
+            if (!list.isEmpty()) {
                 ConnectionContext context = BrokerSupport.getConnectionContext(this);
                 context.setBroker(this);
 
-                for (BaseDestination dest : list) {
-                    dest.getLog().info(
-                            dest.getName() + " Inactive for longer than " + dest.getInactiveTimoutBeforeGC()
-                                    + " ms - removing ...");
+                for (Destination dest : list) {
+                    Logger log = LOG;
+                    if (dest instanceof BaseDestination) {
+                        log = ((BaseDestination) dest).getLog();
+                    }
+                    log.info(dest.getName() + " Inactive for longer than " +
+                             dest.getInactiveTimoutBeforeGC() + " ms - removing ...");
                     try {
                         getRoot().removeDestination(context, dest.getActiveMQDestination(), isAllowTempAutoCreationOnSend() ? 1 : 0);
                     } catch (Exception e) {
diff --git a/activemq-core/src/test/java/org/apache/activemq/bugs/AMQ3157Test.java b/activemq-core/src/test/java/org/apache/activemq/bugs/AMQ3157Test.java
new file mode 100644
index 000000000..baf3f8f97
--- /dev/null
+++ b/activemq-core/src/test/java/org/apache/activemq/bugs/AMQ3157Test.java
@@ -0,0 +1,172 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.bugs;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import javax.jms.Connection;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Session;
+import javax.management.ObjectName;
+
+import org.apache.activemq.EmbeddedBrokerTestSupport;
+import org.apache.activemq.broker.BrokerService;
+import org.apache.activemq.broker.jmx.DestinationViewMBean;
+import org.apache.activemq.broker.region.DestinationInterceptor;
+import org.apache.activemq.broker.region.policy.PolicyEntry;
+import org.apache.activemq.broker.region.policy.PolicyMap;
+import org.apache.activemq.broker.region.virtual.MirroredQueue;
+import org.apache.activemq.command.ActiveMQDestination;
+import org.apache.activemq.command.ActiveMQQueue;
+import org.apache.activemq.command.ActiveMQTopic;
+import org.apache.activemq.spring.ConsumerBean;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class AMQ3157Test extends EmbeddedBrokerTestSupport {
+
+    private static final transient Logger LOG = LoggerFactory.getLogger(AMQ3157Test.class);
+    private Connection connection;
+
+    public void testInactiveMirroredQueueIsCleanedUp() throws Exception {
+
+        if (connection == null) {
+            connection = createConnection();
+        }
+        connection.start();
+
+        ConsumerBean messageList = new ConsumerBean();
+        messageList.setVerbose(true);
+
+        ActiveMQDestination consumeDestination = createConsumeDestination();
+
+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+        LOG.info("Consuming from: " + consumeDestination);
+
+        MessageConsumer c1 = session.createConsumer(consumeDestination);
+        c1.setMessageListener(messageList);
+
+        // create topic producer
+        ActiveMQQueue sendDestination = new ActiveMQQueue(getQueueName());
+        LOG.info("Sending to: " + sendDestination);
+
+        MessageProducer producer = session.createProducer(sendDestination);
+        assertNotNull(producer);
+
+        final int total = 10;
+        for (int i = 0; i < total; i++) {
+            producer.send(session.createTextMessage("message: " + i));
+        }
+
+        messageList.assertMessagesArrived(total);
+        LOG.info("Received: " + messageList);
+        messageList.flushMessages();
+
+        MessageConsumer c2 = session.createConsumer(sendDestination);
+        c2.setMessageListener(messageList);
+        messageList.assertMessagesArrived(total);
+        LOG.info("Q Received: " + messageList);
+
+        connection.close();
+
+        List<ObjectName> topics = Arrays.asList(broker.getAdminView().getTopics());
+        assertTrue(topics.contains(createObjectName(consumeDestination)));
+        List<ObjectName> queues = Arrays.asList(broker.getAdminView().getQueues());
+        assertTrue(queues.contains(createObjectName(sendDestination)));
+
+        Thread.sleep(TimeUnit.SECONDS.toMillis(10));
+
+        topics = Arrays.asList(broker.getAdminView().getTopics());
+        if (topics != null) {
+            assertFalse("Virtual Topic Desination did not get cleaned up.",
+                        topics.contains(createObjectName(consumeDestination)));
+        }
+        queues = Arrays.asList(broker.getAdminView().getQueues());
+        if (queues != null) {
+            assertFalse("Mirrored Queue Desination did not get cleaned up.",
+                        queues.contains(createObjectName(sendDestination)));
+        }
+    }
+
+    protected ActiveMQDestination createConsumeDestination() {
+        return new ActiveMQTopic("VirtualTopic.Mirror." + getQueueName());
+    }
+
+    protected String getQueueName() {
+        return "My.Queue";
+    }
+
+    @Override
+    protected BrokerService createBroker() throws Exception {
+        BrokerService answer = new BrokerService();
+        answer.setUseMirroredQueues(true);
+        answer.setPersistent(isPersistent());
+        answer.setSchedulePeriodForDestinationPurge(1000);
+
+        PolicyEntry entry = new PolicyEntry();
+        entry.setGcInactiveDestinations(true);
+        entry.setInactiveTimoutBeforeGC(5000);
+        entry.setProducerFlowControl(true);
+        PolicyMap map = new PolicyMap();
+        map.setDefaultEntry(entry);
+
+        MirroredQueue mirrorQ = new MirroredQueue();
+        mirrorQ.setCopyMessage(true);
+        DestinationInterceptor[] destinationInterceptors = new DestinationInterceptor[]{mirrorQ};
+        answer.setDestinationInterceptors(destinationInterceptors);
+
+        answer.setDestinationPolicy(map);
+        answer.addConnector(bindAddress);
+
+        return answer;
+    }
+
+    protected DestinationViewMBean createView(ActiveMQDestination destination) throws Exception {
+        String domain = "org.apache.activemq";
+        ObjectName name;
+        if (destination.isQueue()) {
+            name = new ObjectName(domain + ":BrokerName=localhost,Type=Queue,Destination=" + destination.getPhysicalName());
+        } else {
+            name = new ObjectName(domain + ":BrokerName=localhost,Type=Topic,Destination=" + destination.getPhysicalName());
+        }
+        return (DestinationViewMBean) broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class,
+                true);
+    }
+
+    protected ObjectName createObjectName(ActiveMQDestination destination) throws Exception {
+        String domain = "org.apache.activemq";
+        ObjectName name;
+        if (destination.isQueue()) {
+            name = new ObjectName(domain + ":BrokerName=localhost,Type=Queue,Destination=" + destination.getPhysicalName());
+        } else {
+            name = new ObjectName(domain + ":BrokerName=localhost,Type=Topic,Destination=" + destination.getPhysicalName());
+        }
+
+        return name;
+    }
+
+    protected void tearDown() throws Exception {
+        if (connection != null) {
+            connection.close();
+        }
+        super.tearDown();
+    }
+
+}
