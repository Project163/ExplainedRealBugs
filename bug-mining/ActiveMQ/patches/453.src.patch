diff --git a/activemq-core/src/main/java/org/apache/activemq/broker/region/Queue.java b/activemq-core/src/main/java/org/apache/activemq/broker/region/Queue.java
index eacc577c3..f36b29603 100755
--- a/activemq-core/src/main/java/org/apache/activemq/broker/region/Queue.java
+++ b/activemq-core/src/main/java/org/apache/activemq/broker/region/Queue.java
@@ -724,6 +724,8 @@ public class Queue extends BaseDestination implements Task {
             }
         } while (!pagedInMessages.isEmpty() || this.destinationStatistics.getMessages().getCount() > 0);
         gc();
+        this.destinationStatistics.getMessages().setCount(0);
+        getMessages().clear();
     }
 
     /**
@@ -1205,18 +1207,24 @@ public class Queue extends BaseDestination implements Task {
     private void doDispatch(List<QueueMessageReference> list) throws Exception {
         dispatchLock.lock();
         try {
-            synchronized(pagedInPendingDispatch) {
-                if(!pagedInPendingDispatch.isEmpty()) {
-                    // Try to first dispatch anything that had not been dispatched before.
+            synchronized (pagedInPendingDispatch) {
+                if (!pagedInPendingDispatch.isEmpty()) {
+                    // Try to first dispatch anything that had not been
+                    // dispatched before.
                     pagedInPendingDispatch = doActualDispatch(pagedInPendingDispatch);
                 }
-                // and now see if we can dispatch the new stuff.. and append to the pending 
+                // and now see if we can dispatch the new stuff.. and append to
+                // the pending
                 // list anything that does not actually get dispatched.
                 if (list != null && !list.isEmpty()) {
                     if (pagedInPendingDispatch.isEmpty()) {
                         pagedInPendingDispatch.addAll(doActualDispatch(list));
                     } else {
-                        pagedInPendingDispatch.addAll(list);
+                        for (QueueMessageReference qmr : list) {
+                            if (!pagedInPendingDispatch.contains(qmr)) {
+                                pagedInPendingDispatch.add(qmr);
+                            }
+                        }
                     }
                 }
             }
@@ -1226,7 +1234,8 @@ public class Queue extends BaseDestination implements Task {
     }
     
     /**
-     * @return list of messages that could get dispatched to consumers if they were not full.
+     * @return list of messages that could get dispatched to consumers if they
+     *         were not full.
      */
     private List<QueueMessageReference> doActualDispatch(List<QueueMessageReference> list) throws Exception {
         List<QueueMessageReference> rc = new ArrayList<QueueMessageReference>(list.size());
diff --git a/activemq-core/src/main/java/org/apache/activemq/broker/region/cursors/AbstractStoreCursor.java b/activemq-core/src/main/java/org/apache/activemq/broker/region/cursors/AbstractStoreCursor.java
index 039014520..7e7c6ecb7 100644
--- a/activemq-core/src/main/java/org/apache/activemq/broker/region/cursors/AbstractStoreCursor.java
+++ b/activemq-core/src/main/java/org/apache/activemq/broker/region/cursors/AbstractStoreCursor.java
@@ -194,6 +194,7 @@ public abstract class AbstractStoreCursor extends AbstractPendingMessageCursor i
         batchList.clear();
         batchResetNeeded = true;
         this.cacheEnabled=false;
+        size=0;
     }
     
     protected final synchronized void fillBatch() {
diff --git a/activemq-core/src/test/java/org/apache/activemq/broker/region/QueuePurgeTest.java b/activemq-core/src/test/java/org/apache/activemq/broker/region/QueuePurgeTest.java
new file mode 100644
index 000000000..5734bd54b
--- /dev/null
+++ b/activemq-core/src/test/java/org/apache/activemq/broker/region/QueuePurgeTest.java
@@ -0,0 +1,104 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.broker.region;
+
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.JMSException;
+import javax.jms.Message;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Queue;
+import javax.jms.Session;
+import javax.jms.TextMessage;
+import javax.management.MBeanServerInvocationHandler;
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectName;
+import junit.framework.TestCase;
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.broker.BrokerService;
+import org.apache.activemq.broker.jmx.QueueViewMBean;
+
+public class QueuePurgeTest extends TestCase {
+    BrokerService broker;
+    ConnectionFactory factory;
+    Connection connection;
+    Session session;
+    Queue queue;
+    MessageConsumer consumer;
+
+    protected void setUp() throws Exception {
+        broker = new BrokerService();
+        broker.setUseJmx(true);
+        broker.setPersistent(false);
+        broker.addConnector("tcp://localhost:0");
+        broker.start();
+        factory = new ActiveMQConnectionFactory("vm://localhost");
+        connection = factory.createConnection();
+        connection.start();
+    }
+
+    protected void tearDown() throws Exception {
+        consumer.close();
+        session.close();
+        connection.stop();
+        connection.close();
+        broker.stop();
+    }
+
+    public void testPurgeQueueWithActiveConsumer() throws Exception {
+        createProducerAndSendMessages();
+        QueueViewMBean proxy = getProxyToQueueViewMBean();
+        createConsumer();
+        proxy.purge();
+        assertEquals("Queue size is not zero, it's " + proxy.getQueueSize(), 0,
+                proxy.getQueueSize());
+    }
+
+    private QueueViewMBean getProxyToQueueViewMBean()
+            throws MalformedObjectNameException, JMSException {
+        ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq"
+                + ":Type=Queue,Destination=" + queue.getQueueName()
+                + ",BrokerName=localhost");
+        QueueViewMBean proxy = (QueueViewMBean) MBeanServerInvocationHandler
+                .newProxyInstance(broker.getManagementContext()
+                        .getMBeanServer(), queueViewMBeanName,
+                        QueueViewMBean.class, true);
+        return proxy;
+    }
+
+    private void createProducerAndSendMessages() throws Exception {
+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
+        queue = session.createQueue("test1");
+        MessageProducer producer = session.createProducer(queue);
+        for (int i = 0; i < 10000; i++) {
+            TextMessage message = session.createTextMessage("message " + i);
+            producer.send(message);
+        }
+        producer.close();
+    }
+
+    private void createConsumer() throws Exception {
+        consumer = session.createConsumer(queue);
+        // wait for buffer fill out
+        Thread.sleep(5 * 1000);
+        for (int i = 0; i < 100; ++i) {
+            Message message = consumer.receive();
+            message.acknowledge();
+        }
+    }
+}
