diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/DBManager.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/DBManager.scala
index 7fcd59b57..b0c9a823f 100644
--- a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/DBManager.scala
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/DBManager.scala
@@ -41,7 +41,7 @@ case class QueueEntryRecord(id:MessageId, queueKey:Long, queueSeq:Long)
 case class QueueRecord(id:ActiveMQDestination, queue_key:Long)
 case class QueueEntryRange()
 case class SubAckRecord(subKey:Long, ackPosition:Long)
-case class XaAckRecord(container:Long, seq:Long, ack:MessageAck)
+case class XaAckRecord(container:Long, seq:Long, ack:MessageAck, sub:Long = -1)
 
 sealed trait UowState {
   def stage:Int
@@ -217,13 +217,13 @@ class DelayableUOW(val manager:DBManager) extends BaseRetained {
     }
   }
 
-  def updateAckPosition(sub:DurableSubscription) = {
-    subAcks += SubAckRecord(sub.subKey, sub.lastAckPosition)
+  def updateAckPosition(sub_key:Long, ack_seq:Long) = {
+    subAcks += SubAckRecord(sub_key, ack_seq)
   }
 
-  def xaAck(container:Long, seq:Long, ack:MessageAck) = {
+  def xaAck(record:XaAckRecord) = {
     this.synchronized {
-      getAction(ack.getLastMessageId).xaAcks+=(XaAckRecord(container, seq, ack))
+      getAction(record.ack.getLastMessageId).xaAcks+=record
     }
     countDownFuture
   }
@@ -642,11 +642,11 @@ class DBManager(val parent:LevelDBStore) {
 
   def getXAActions(key:Long) = {
     val msgs = ListBuffer[Message]()
-    val acks = ListBuffer[MessageAck]()
+    val acks = ListBuffer[XaAckRecord]()
     client.transactionCursor(key) { command =>
       command match {
         case message:Message => msgs += message
-        case record:XaAckRecord => acks += record.ack
+        case record:XaAckRecord => acks += record
       }
       true
     }
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBClient.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBClient.scala
index eb06fc7a5..b00f0b203 100755
--- a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBClient.scala
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBClient.scala
@@ -954,11 +954,12 @@ class LevelDBClient(store: LevelDBStore) {
         val offset = is.readInt()
         val qid = is.readLong()
         val seq = is.readLong()
+        val sub = is.readLong()
         val ack = store.wireFormat.unmarshal(is).asInstanceOf[MessageAck]
         ack.getLastMessageId.setDataLocator((log, offset))
         ack.getLastMessageId.setEntryLocator((qid, seq))
 
-        func(XaAckRecord(collectionKey, seq, ack))
+        func(XaAckRecord(collectionKey, seq, ack, sub))
       } else {
         var locator = (value.getValueLocation, value.getValueLength)
         val msg = getMessage(locator)
@@ -1134,7 +1135,7 @@ class LevelDBClient(store: LevelDBStore) {
                 write_enqueue_total += System.nanoTime() - start
               }
 
-              action.xaAcks.foreach { entry =>
+              action.xaAcks.foreach { entry:XaAckRecord =>
                 val ack = entry.ack
                 if( dataLocator==null ) {
                   dataLocator = ack.getLastMessageId.getDataLocator match {
@@ -1144,6 +1145,7 @@ class LevelDBClient(store: LevelDBStore) {
                       throw new RuntimeException("Unexpected locator type")
                   }
                 }
+                println(dataLocator)
 
                 val (qid, seq) = ack.getLastMessageId.getEntryLocator.asInstanceOf[(Long, Long)];
                 val os = new DataByteArrayOutputStream()
@@ -1151,6 +1153,7 @@ class LevelDBClient(store: LevelDBStore) {
                 os.writeInt(dataLocator._2)
                 os.writeLong(qid)
                 os.writeLong(seq)
+                os.writeLong(entry.sub)
                 store.wireFormat.marshal(ack, os)
                 var ack_encoded = os.toBuffer
 
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStore.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStore.scala
index ef156fec0..c2e1d6ba0 100644
--- a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStore.scala
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStore.scala
@@ -222,16 +222,24 @@ class LevelDBStore extends ServiceSupport with BrokerServiceAware with Persisten
     for( (txid, transaction) <- transactions ) {
       assert( transaction.xacontainer_id != -1 )
       val (msgs, acks) = db.getXAActions(transaction.xacontainer_id)
-      transaction.xarecovery = (msgs, acks)
+      transaction.xarecovery = (msgs, acks.map(_.ack))
       for ( msg <- msgs ) {
         transaction.add(createMessageStore(msg.getDestination), msg, false);
       }
-      for ( ack <- acks ) {
-        // think we might have store design issue /w XA transactions and durable sub acks.
-        // does it even work for the other stores?
+      for ( record <- acks ) {
+        var ack = record.ack
         var store = createMessageStore(ack.getDestination)
-        store.preparedAcks.add(ack.getLastMessageId)
-        transaction.remove(store, ack);
+        if( record.sub == -1 ) {
+          store.preparedAcks.add(ack.getLastMessageId)
+          transaction.remove(store, ack);
+        } else {
+          val topic = store.asInstanceOf[LevelDBTopicMessageStore];
+          for ( sub <- topic.subscription_with_key(record.sub) ) {
+            val position = db.queuePosition(ack.getLastMessageId)
+            transaction.updateAckPosition( topic, sub, position, ack);
+            sub.lastAckPosition = position
+          }
+        }
       }
     }
     debug("started")
@@ -334,7 +342,7 @@ class LevelDBStore extends ServiceSupport with BrokerServiceAware with Persisten
 
         def prepare(uow:DelayableUOW) = {
           // add it to the xa container instead of the actual store container.
-          uow.xaAck(xacontainer_id, xaseqcounter.incrementAndGet, ack)
+          uow.xaAck(XaAckRecord(xacontainer_id, xaseqcounter.incrementAndGet, ack))
           xarecovery._2 += ack
           store.preparedAcks.add(ack.getLastMessageId)
         }
@@ -347,14 +355,22 @@ class LevelDBStore extends ServiceSupport with BrokerServiceAware with Persisten
       }
     }
 
-    def updateAckPosition(store:LevelDBStore#LevelDBTopicMessageStore, sub: DurableSubscription, position: Long) = {
+    def updateAckPosition(store:LevelDBStore#LevelDBTopicMessageStore, sub: DurableSubscription, position: Long, ack:MessageAck) = {
       commitActions += new TransactionAction() {
+        var prev_position = sub.lastAckPosition
+
         def commit(uow:DelayableUOW) = {
           store.doUpdateAckPosition(uow, sub, position)
         }
         def prepare(uow:DelayableUOW) = {
+          prev_position = sub.lastAckPosition
+          sub.lastAckPosition = position
+          uow.xaAck(XaAckRecord(xacontainer_id, xaseqcounter.incrementAndGet, ack, sub.subKey))
         }
         def rollback(uow: DelayableUOW) {
+          if ( prepared ) {
+            sub.lastAckPosition = prev_position
+          }
         }
       }
     }
@@ -393,7 +409,7 @@ class LevelDBStore extends ServiceSupport with BrokerServiceAware with Persisten
         if( tx.prepared ) {
           val done = new CountDownLatch(1)
           withUow { uow =>
-            for( action <- tx.commitActions ) {
+            for( action <- tx.commitActions.reverse ) {
               action.rollback(uow)
             }
             uow.syncFlag = true
@@ -661,6 +677,12 @@ class LevelDBStore extends ServiceSupport with BrokerServiceAware with Persisten
     val subscriptions = collection.mutable.HashMap[(String, String), DurableSubscription]()
     var firstSeq = 0L
 
+    def subscription_with_key(key:Long) = subscriptions.find(_._2.subKey == key).map(_._2)
+
+    override def asyncAddQueueMessage(context: ConnectionContext, message: Message, delay: Boolean): Future[AnyRef] = {
+      super.asyncAddQueueMessage(context, message, false)
+    }
+
     def gcPosition:Option[(Long, Long)] = {
       var pos = lastSeq.get()
       subscriptions.synchronized {
@@ -685,7 +707,7 @@ class LevelDBStore extends ServiceSupport with BrokerServiceAware with Persisten
       }
       sub.lastAckPosition = if (retroactive) 0 else lastSeq.get()
       waitOn(withUow{ uow=>
-        uow.updateAckPosition(sub)
+        uow.updateAckPosition(sub.subKey, sub.lastAckPosition)
         uow.countDownFuture
       })
     }
@@ -710,14 +732,14 @@ class LevelDBStore extends ServiceSupport with BrokerServiceAware with Persisten
 
     def doUpdateAckPosition(uow: DelayableUOW, sub: DurableSubscription, position: Long) = {
       sub.lastAckPosition = position
-      uow.updateAckPosition(sub)
+      uow.updateAckPosition(sub.subKey, sub.lastAckPosition)
     }
 
     def acknowledge(context: ConnectionContext, clientId: String, subscriptionName: String, messageId: MessageId, ack: MessageAck): Unit = {
       lookup(clientId, subscriptionName).foreach { sub =>
         var position = db.queuePosition(messageId)
         if(  ack.getTransactionId!=null ) {
-          transaction(ack.getTransactionId).updateAckPosition(this, sub, position)
+          transaction(ack.getTransactionId).updateAckPosition(this, sub, position, ack)
           DONE
         } else {
           waitOn(withUow{ uow=>
@@ -748,7 +770,8 @@ class LevelDBStore extends ServiceSupport with BrokerServiceAware with Persisten
     
     def getMessageCount(clientId: String, subscriptionName: String): Int = {
       lookup(clientId, subscriptionName) match {
-        case Some(sub) => (lastSeq.get - sub.lastAckPosition).toInt
+        case Some(sub) =>
+          (lastSeq.get - sub.lastAckPosition).toInt
         case None => 0
       }
     }
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBXARecoveryBrokerTest.java b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBXARecoveryBrokerTest.java
index eaa7119f6..6e26c50b5 100644
--- a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBXARecoveryBrokerTest.java
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBXARecoveryBrokerTest.java
@@ -27,15 +27,4 @@ public class LevelDBXARecoveryBrokerTest extends XARecoveryBrokerTest {
         broker.setPersistenceAdapter(store);
     }
 
-
-    @Override
-    public void testTopicPersistentPreparedAcksAvailableAfterRestartAndRollback() throws Exception {
-//        XA Durable Subs not yet implemented
-//        super.testTopicPersistentPreparedAcksAvailableAfterRestartAndRollback();
-    }
-    @Override
-    public void testTopicPersistentPreparedAcksAvailableAfterRollback() throws Exception {
-//        XA Durable Subs not yet implemented
-//        super.testTopicPersistentPreparedAcksAvailableAfterRollback();
-    }
 }
