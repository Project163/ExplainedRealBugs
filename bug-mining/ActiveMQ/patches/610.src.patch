diff --git a/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java b/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java
index 77f7f0454..dd6010b56 100755
--- a/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java
+++ b/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java
@@ -397,6 +397,7 @@ public class FailoverTransport implements CompositeTransport {
                     }
                     if(command instanceof RemoveInfo) {
                         // Simulate response to RemoveInfo command
+                        stateTracker.track(command);
                         Response response = new Response();
                         response.setCorrelationId(command.getCommandId());
                         myTransportListener.onCommand(response);
diff --git a/activemq-ra/src/test/java/org/apache/activemq/ra/FailoverManagedConnectionTest.java b/activemq-ra/src/test/java/org/apache/activemq/ra/FailoverManagedConnectionTest.java
new file mode 100755
index 000000000..49661eba6
--- /dev/null
+++ b/activemq-ra/src/test/java/org/apache/activemq/ra/FailoverManagedConnectionTest.java
@@ -0,0 +1,102 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.ra;
+
+import java.util.HashSet;
+
+import javax.resource.spi.ManagedConnection;
+
+import junit.framework.TestCase;
+
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.broker.BrokerService;
+
+
+public class FailoverManagedConnectionTest extends TestCase {
+
+    private static final String BROKER_TRANSPORT = "tcp://localhost:61616";
+    private static final String BROKER_URL = "failover://" + BROKER_TRANSPORT;
+    
+    private ActiveMQManagedConnectionFactory managedConnectionFactory;
+    private ManagedConnection managedConnection;
+    private ManagedConnectionProxy proxy;
+    private BrokerService broker;
+    private HashSet<ManagedConnection> connections;
+    private ActiveMQConnectionRequestInfo connectionInfo;
+
+    protected void setUp() throws Exception {
+
+        createAndStartBroker();
+    
+        connectionInfo = new ActiveMQConnectionRequestInfo();
+        connectionInfo.setServerUrl(BROKER_URL);
+        connectionInfo.setUserName(ActiveMQConnectionFactory.DEFAULT_USER);
+        connectionInfo.setPassword(ActiveMQConnectionFactory.DEFAULT_PASSWORD);
+
+        managedConnectionFactory = new ActiveMQManagedConnectionFactory();
+        managedConnection = managedConnectionFactory.createManagedConnection(null, connectionInfo);
+        
+        connections = new HashSet<ManagedConnection>();
+        connections.add(managedConnection);
+    }
+    
+
+    private void createAndStartBroker() throws Exception {
+        broker = new BrokerService();
+        broker.addConnector(BROKER_TRANSPORT);
+        broker.start();
+        broker.waitUntilStarted();
+    }
+
+    public void testFailoverBeforeClose() throws Exception {  
+        
+        createConnectionAndProxyAndSession();
+        
+        stopBroker();
+        
+        cleanupConnectionAndProxyAndSession();
+        
+        createAndStartBroker();
+        
+        for (int i=0; i<2; i++) {
+            createConnectionAndProxyAndSession();
+            cleanupConnectionAndProxyAndSession();
+        }
+    }
+    
+
+    private void cleanupConnectionAndProxyAndSession() throws Exception {
+        proxy.close();
+        managedConnection.cleanup();
+    }
+
+
+    private void createConnectionAndProxyAndSession() throws Exception {
+        managedConnection = 
+            managedConnectionFactory.matchManagedConnections(connections, null, connectionInfo);
+        proxy = 
+            (ManagedConnectionProxy) managedConnection.getConnection(null, null);
+        proxy.createSession(false, 0);
+    }
+
+
+    private void stopBroker() throws Exception {
+        broker.stop();
+        broker.waitUntilStopped();
+    }
+
+}
