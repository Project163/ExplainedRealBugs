diff --git a/activemq-core/src/test/java/org/apache/activemq/bugs/embedded/EmbeddedActiveMQ.java b/activemq-core/src/test/java/org/apache/activemq/bugs/embedded/EmbeddedActiveMQ.java
new file mode 100644
index 000000000..8daa9ce0c
--- /dev/null
+++ b/activemq-core/src/test/java/org/apache/activemq/bugs/embedded/EmbeddedActiveMQ.java
@@ -0,0 +1,117 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.bugs.embedded;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.Destination;
+import javax.jms.Message;
+import javax.jms.MessageProducer;
+import javax.jms.Session;
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.broker.BrokerService;
+import org.apache.activemq.thread.Scheduler;
+import org.apache.log4j.Logger;
+
+public class EmbeddedActiveMQ
+{
+ 
+        private static Logger logger = Logger.getLogger(EmbeddedActiveMQ.class);
+ 
+        public static void main(String[] args)
+        {
+ 
+                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+                BrokerService brokerService = null;
+ 
+                logger.info("Start...");
+                try
+                {
+                        brokerService = new BrokerService();
+                        brokerService.setBrokerName("TestMQ");
+                        brokerService.setUseJmx(true);
+                        logger.info("Broker '" + brokerService.getBrokerName() + "' is starting........");
+                        brokerService.start();
+                        ConnectionFactory fac = new ActiveMQConnectionFactory("vm://TestMQ");
+                        Connection connection = fac.createConnection();
+                        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+                        Destination queue = session.createQueue("TEST.QUEUE");
+                        MessageProducer producer = session.createProducer(queue);
+                        for (int i = 0; i < 1000;i++) {
+                            Message msg = session.createTextMessage("test"+i);
+                            producer.send(msg);
+                        }
+                        logger.info(ThreadExplorer.show("Active threads after start:"));
+                        System.out.println("Press return to stop........");
+                        String key = br.readLine();
+                }
+ 
+                catch (Exception e)
+                {
+                        e.printStackTrace();
+                }
+                finally
+                {
+                        try
+                        {
+                                br.close();
+                                Scheduler scheduler = Scheduler.getInstance();
+                                scheduler.shutdown();
+                                logger.info("Broker '" + brokerService.getBrokerName() + "' is stopping........");
+                                brokerService.stop();
+                                Scheduler.getInstance().shutdown();
+ 
+                                sleep(8);
+                                logger.info(ThreadExplorer.show("Active threads after stop:"));
+ 
+                        }
+                        catch (Exception e)
+                        {
+                                e.printStackTrace();
+                        }
+                }
+ 
+                logger.info("Waiting for list theads is greater then 1 ...");
+                int numTh = ThreadExplorer.active();
+ 
+                while (numTh > 1)
+                {
+                        sleep(3);
+                        numTh = ThreadExplorer.active();
+                        logger.info(ThreadExplorer.show("Still active threads:"));
+                }
+ 
+                System.out.println("Stop...");
+        }
+ 
+        private static void sleep(int second)
+        {
+                try
+                {
+                        logger.info("Waiting for " + second + "s...");
+                        Thread.sleep(second * 1000L);
+                }
+                catch (InterruptedException e)
+                {
+                        // TODO Auto-generated catch block
+                        e.printStackTrace();
+                }
+        }
+ 
+}
diff --git a/activemq-core/src/test/java/org/apache/activemq/bugs/embedded/ThreadExplorer.java b/activemq-core/src/test/java/org/apache/activemq/bugs/embedded/ThreadExplorer.java
new file mode 100644
index 000000000..0b17831bb
--- /dev/null
+++ b/activemq-core/src/test/java/org/apache/activemq/bugs/embedded/ThreadExplorer.java
@@ -0,0 +1,167 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.bugs.embedded;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.apache.log4j.Logger;
+
+public class ThreadExplorer
+{
+    static Logger logger = Logger.getLogger(ThreadExplorer.class);
+
+    public static Thread[] listThreads()
+    {
+
+        int nThreads = Thread.activeCount();
+        Thread ret[] = new Thread[nThreads];
+
+        Thread.enumerate(ret);
+
+        return ret;
+
+    }
+
+    /**
+     * Helper function to access a thread per name (ignoring case)
+     * 
+     * @param name
+     * @return
+     */
+    public static Thread fetchThread(String name)
+    {
+        Thread[] threadArray = listThreads();
+        // for (Thread t : threadArray)
+        for (int i = 0; i < threadArray.length; i++)
+        {
+            Thread t = threadArray[i];
+            if (t.getName().equalsIgnoreCase(name))
+                return t;
+        }
+        return null;
+    }
+
+    /**
+     * Allow for killing threads
+     * 
+     * @param threadName
+     * @param isStarredExp
+     *            (regular expressions with *)
+     */
+    public static int kill(String threadName, boolean isStarredExp, String motivation)
+    {
+        String me = "ThreadExplorer.kill: ";
+        if (logger.isDebugEnabled())
+        {
+            logger.debug("Entering " + me + " with " + threadName + " isStarred: " + isStarredExp);
+        }
+        int ret = 0;
+        Pattern mypattern = null;
+        if (isStarredExp)
+        {
+            String realreg = threadName.toLowerCase().replaceAll("\\*", "\\.\\*");
+            mypattern = Pattern.compile(realreg);
+
+        }
+        Thread[] threads = listThreads();
+        for (int i = 0; i < threads.length; i++)
+        {
+            Thread thread = threads[i];
+            if (thread == null)
+                continue;
+            // kill the thread unless it is not current thread
+            boolean matches = false;
+
+            if (isStarredExp)
+            {
+                Matcher matcher = mypattern.matcher(thread.getName().toLowerCase());
+                matches = matcher.matches();
+            }
+            else
+            {
+                matches = (thread.getName().equalsIgnoreCase(threadName));
+            }
+            if (matches && (Thread.currentThread() != thread) && !thread.getName().equals("main"))
+            {
+                if (logger.isInfoEnabled())
+                    logger.info("Killing thread named [" + thread.getName() + "]"); // , removing its uncaught
+                // exception handler to
+                // avoid ThreadDeath
+                // exception tracing
+                // "+motivation );
+
+                ret++;
+
+                // PK leaving uncaught exception handler otherwise master push
+                // cannot recover from this error
+                // thread.setUncaughtExceptionHandler(null);
+                try
+                {
+                    thread.stop();
+                }
+                catch (ThreadDeath e)
+                {
+                    logger.warn("Thread already death.", e);
+                }
+
+            }
+        }
+        return ret;
+    }
+
+    public static String show(String title)
+    {
+        StringBuffer out = new StringBuffer();
+        Thread[] threadArray = ThreadExplorer.listThreads();
+
+        out.append(title + "\n");
+        for (int i = 0; i < threadArray.length; i++)
+        {
+            Thread thread = threadArray[i];
+
+            if (thread != null)
+            {
+                out.append("* [" + thread.getName() + "] " + (thread.isDaemon() ? "(Daemon)" : "")
+                        + " Group: " + thread.getThreadGroup().getName() + "\n");
+            }
+            else
+            {
+                out.append("* ThreadDeath: " + thread + "\n");
+            }
+
+        }
+        return out.toString();
+    }
+
+    public static int active()
+    {
+        int count = 0;
+        Thread[] threadArray = ThreadExplorer.listThreads();
+
+        for (int i = 0; i < threadArray.length; i++)
+        {
+            Thread thread = threadArray[i];
+            if (thread != null)
+            {
+                count++;
+            }
+        }
+
+        return count;
+    }
+
+}
