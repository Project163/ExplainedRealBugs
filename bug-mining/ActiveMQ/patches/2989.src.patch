diff --git a/activemq-broker/src/main/java/org/apache/activemq/broker/region/BaseDestination.java b/activemq-broker/src/main/java/org/apache/activemq/broker/region/BaseDestination.java
index 26a8ccc1f..a80e292fe 100644
--- a/activemq-broker/src/main/java/org/apache/activemq/broker/region/BaseDestination.java
+++ b/activemq-broker/src/main/java/org/apache/activemq/broker/region/BaseDestination.java
@@ -18,6 +18,7 @@ package org.apache.activemq.broker.region;
 
 import java.io.IOException;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.jms.ResourceAllocationException;
 
@@ -59,6 +60,7 @@ public abstract class BaseDestination implements Destination {
     public static final int MAX_PRODUCERS_TO_AUDIT = 64;
     public static final int MAX_AUDIT_DEPTH = 10000;
 
+    protected final AtomicBoolean started = new AtomicBoolean();
     protected final ActiveMQDestination destination;
     protected final Broker broker;
     protected final MessageStore store;
diff --git a/activemq-broker/src/main/java/org/apache/activemq/broker/region/Queue.java b/activemq-broker/src/main/java/org/apache/activemq/broker/region/Queue.java
index 6a42ebc52..b841b89b1 100644
--- a/activemq-broker/src/main/java/org/apache/activemq/broker/region/Queue.java
+++ b/activemq-broker/src/main/java/org/apache/activemq/broker/region/Queue.java
@@ -16,6 +16,8 @@
  */
 package org.apache.activemq.broker.region;
 
+import static org.apache.activemq.broker.region.cursors.AbstractStoreCursor.gotToTheStore;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -36,7 +38,6 @@ import java.util.concurrent.DelayQueue;
 import java.util.concurrent.Delayed;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
@@ -96,8 +97,6 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.slf4j.MDC;
 
-import static org.apache.activemq.broker.region.cursors.AbstractStoreCursor.gotToTheStore;
-
 /**
  * The Queue is a List of MessageEntry objects that are dispatched to matching
  * subscriptions.
@@ -132,7 +131,6 @@ public class Queue extends BaseDestination implements Task, UsageListener, Index
     private CountDownLatch consumersBeforeStartsLatch;
     private final AtomicLong pendingWakeups = new AtomicLong();
     private boolean allConsumersExclusiveByDefault = false;
-    private final AtomicBoolean started = new AtomicBoolean();
 
     private volatile boolean resetNeeded;
 
@@ -217,7 +215,7 @@ public class Queue extends BaseDestination implements Task, UsageListener, Index
                 LOG.debug(getName() + "Producer Flow Control Timeout Task is stopping");
             }
         }
-    };
+    }
 
     private final FlowControlTimeoutTask flowControlTimeoutTask = new FlowControlTimeoutTask();
 
diff --git a/activemq-broker/src/main/java/org/apache/activemq/broker/region/Topic.java b/activemq-broker/src/main/java/org/apache/activemq/broker/region/Topic.java
index 0842467ec..7707bf599 100644
--- a/activemq-broker/src/main/java/org/apache/activemq/broker/region/Topic.java
+++ b/activemq-broker/src/main/java/org/apache/activemq/broker/region/Topic.java
@@ -83,7 +83,7 @@ public class Topic extends BaseDestination implements Task {
                 Topic.this.taskRunner.wakeup();
             } catch (InterruptedException e) {
             }
-        };
+        }
     };
 
     public Topic(BrokerService brokerService, ActiveMQDestination destination, TopicMessageStore store,
@@ -598,30 +598,34 @@ public class Topic extends BaseDestination implements Task {
 
     @Override
     public void start() throws Exception {
-        this.subscriptionRecoveryPolicy.start();
-        if (memoryUsage != null) {
-            memoryUsage.start();
-        }
+        if (started.compareAndSet(false, true)) {
+            this.subscriptionRecoveryPolicy.start();
+            if (memoryUsage != null) {
+                memoryUsage.start();
+            }
 
-        if (getExpireMessagesPeriod() > 0 && !AdvisorySupport.isAdvisoryTopic(getActiveMQDestination())) {
-            scheduler.executePeriodically(expireMessagesTask, getExpireMessagesPeriod());
+            if (getExpireMessagesPeriod() > 0 && !AdvisorySupport.isAdvisoryTopic(getActiveMQDestination())) {
+                scheduler.executePeriodically(expireMessagesTask, getExpireMessagesPeriod());
+            }
         }
     }
 
     @Override
     public void stop() throws Exception {
-        if (taskRunner != null) {
-            taskRunner.shutdown();
-        }
-        this.subscriptionRecoveryPolicy.stop();
-        if (memoryUsage != null) {
-            memoryUsage.stop();
-        }
-        if (this.topicStore != null) {
-            this.topicStore.stop();
-        }
+        if (started.compareAndSet(true, false)) {
+            if (taskRunner != null) {
+                taskRunner.shutdown();
+            }
+            this.subscriptionRecoveryPolicy.stop();
+            if (memoryUsage != null) {
+                memoryUsage.stop();
+            }
+            if (this.topicStore != null) {
+                this.topicStore.stop();
+            }
 
-         scheduler.cancel(expireMessagesTask);
+            scheduler.cancel(expireMessagesTask);
+        }
     }
 
     @Override
diff --git a/activemq-client/src/main/java/org/apache/activemq/thread/Scheduler.java b/activemq-client/src/main/java/org/apache/activemq/thread/Scheduler.java
index 2fdb11aab..2e2de95f3 100644
--- a/activemq-client/src/main/java/org/apache/activemq/thread/Scheduler.java
+++ b/activemq-client/src/main/java/org/apache/activemq/thread/Scheduler.java
@@ -22,12 +22,15 @@ import java.util.TimerTask;
 
 import org.apache.activemq.util.ServiceStopper;
 import org.apache.activemq.util.ServiceSupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  *
  */
 public final class Scheduler extends ServiceSupport {
 
+    private static final Logger LOG  = LoggerFactory.getLogger(Scheduler.class);
     private final String name;
     private Timer timer;
     private final HashMap<Runnable, TimerTask> timerTasks = new HashMap<Runnable, TimerTask>();
@@ -37,6 +40,11 @@ public final class Scheduler extends ServiceSupport {
     }
 
     public synchronized void executePeriodically(final Runnable task, long period) {
+        TimerTask existing = timerTasks.get(task);
+        if (existing != null) {
+            LOG.debug("Task {} already scheduled, cancelling and rescheduling", task);
+            cancel(task);
+        }
         TimerTask timerTask = new SchedulerTimerTask(task);
         timer.schedule(timerTask, period, period);
         timerTasks.put(task, timerTask);
diff --git a/activemq-client/src/test/java/org/apache/activemq/thread/SchedulerTest.java b/activemq-client/src/test/java/org/apache/activemq/thread/SchedulerTest.java
new file mode 100644
index 000000000..d63c8310a
--- /dev/null
+++ b/activemq-client/src/test/java/org/apache/activemq/thread/SchedulerTest.java
@@ -0,0 +1,85 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.thread;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class SchedulerTest {
+
+    private final static String schedulerName = "testScheduler";
+    private Scheduler scheduler;
+
+    @Before
+    public void before() throws Exception {
+        scheduler = new Scheduler(schedulerName);
+        scheduler.start();
+    }
+
+    @After
+    public void after() throws Exception {
+        scheduler.stop();
+    }
+
+    @Test
+    public void testExecutePeriodically() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(1);
+        scheduler.executePeriodically(new CountDownRunnable(latch), 10);
+        assertTrue(latch.await(5000, TimeUnit.MILLISECONDS));
+    }
+
+    @Test
+    public void executeAfterDelay() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(1);
+        scheduler.executeAfterDelay(new CountDownRunnable(latch), 10);
+        assertTrue(latch.await(5000, TimeUnit.MILLISECONDS));
+    }
+
+    @Test
+    public void testExecutePeriodicallyReplace() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final CountDownRunnable task = new CountDownRunnable(latch);
+
+        scheduler.executePeriodically(task, 500);
+        scheduler.executePeriodically(task, 500);
+        scheduler.cancel(task);
+
+        //make sure the task never runs
+        assertFalse(latch.await(1000, TimeUnit.MILLISECONDS));
+    }
+
+    private static class CountDownRunnable implements Runnable {
+        final CountDownLatch latch;
+
+        CountDownRunnable(final CountDownLatch latch) {
+            this.latch = latch;
+        }
+
+        @Override
+        public void run() {
+            latch.countDown();
+        }
+    }
+
+}
