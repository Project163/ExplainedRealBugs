diff --git a/activemq-client/src/main/java/org/apache/activemq/transport/discovery/multicast/MulticastDiscoveryAgent.java b/activemq-client/src/main/java/org/apache/activemq/transport/discovery/multicast/MulticastDiscoveryAgent.java
index 98d3dd27c..345ffdb39 100755
--- a/activemq-client/src/main/java/org/apache/activemq/transport/discovery/multicast/MulticastDiscoveryAgent.java
+++ b/activemq-client/src/main/java/org/apache/activemq/transport/discovery/multicast/MulticastDiscoveryAgent.java
@@ -21,12 +21,17 @@ import java.io.IOException;
 import java.net.DatagramPacket;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.net.InterfaceAddress;
 import java.net.MulticastSocket;
 import java.net.NetworkInterface;
 import java.net.SocketAddress;
+import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.URI;
+import java.util.ArrayList;
+import java.util.Enumeration;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
@@ -316,6 +321,7 @@ public class MulticastDiscoveryAgent implements DiscoveryAgent, Runnable {
                 mcast.joinGroup(sockAddress, NetworkInterface.getByName(mcJoinNetworkInterface));
             }
             else {
+                mcast.setNetworkInterface(findNetworkInterface());
             	mcast.joinGroup(inetAddress);
             }
             mcast.setSoTimeout((int)keepAliveInterval);
@@ -332,6 +338,25 @@ public class MulticastDiscoveryAgent implements DiscoveryAgent, Runnable {
             doAdvertizeSelf();
         }
     }
+    
+    private NetworkInterface findNetworkInterface() throws SocketException {
+        Enumeration<NetworkInterface> ifcs = NetworkInterface.getNetworkInterfaces();
+        List<NetworkInterface> possibles = new ArrayList<NetworkInterface>();
+        while (ifcs.hasMoreElements()) {
+            NetworkInterface ni = ifcs.nextElement();
+            if (ni.supportsMulticast()
+                && ni.isUp()) {
+                for (InterfaceAddress ia : ni.getInterfaceAddresses()) {
+                    if (ia.getAddress() instanceof java.net.Inet4Address
+                        && !ia.getAddress().isLoopbackAddress()
+                        && !ni.getDisplayName().startsWith("vnic")) {
+                        possibles.add(ni);
+                    }
+                }
+            }
+        }
+        return possibles.isEmpty() ? null : possibles.get(possibles.size() - 1);
+    }
 
     /**
      * stop the channel
