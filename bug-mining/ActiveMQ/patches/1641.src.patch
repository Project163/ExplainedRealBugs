diff --git a/activemq-core/pom.xml b/activemq-core/pom.xml
index 77f1ecfe3..d87ca8a28 100755
--- a/activemq-core/pom.xml
+++ b/activemq-core/pom.xml
@@ -1056,6 +1056,8 @@
           </execution>
         </executions>
       </plugin>
+      <!-- disabled until the xbean 3.11.2 plugin is released -->
+      <!--
       <plugin>
         <groupId>org.apache.xbean</groupId>
         <artifactId>maven-xbean-plugin</artifactId>
@@ -1064,6 +1066,9 @@
           <execution>
           <phase>process-classes</phase>
             <configuration>
+              <includes>
+                <include>${basedir}/../activemq-leveldb/src/main/scala</include>
+              </includes>
               <strictXsdOrder>false</strictXsdOrder>
               <namespace>http://activemq.apache.org/schema/core</namespace>
               <schema>${basedir}/target/classes/activemq.xsd</schema>
@@ -1084,6 +1089,7 @@
           </dependency>
         </dependencies>
       </plugin>
+      -->
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>cobertura-maven-plugin</artifactId>
@@ -1222,5 +1228,47 @@
         </plugins>
       </build>
     </profile>
+    <!-- To generate the XBean meta-data, run: mvn -P xbean-generate clean process-classes -->
+    <profile>
+      <id>xbean-generate</id>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.apache.xbean</groupId>
+            <artifactId>maven-xbean-plugin</artifactId>
+            <version>3.11.2-SNAPSHOT</version>
+            <executions>
+              <execution>
+              <phase>process-classes</phase>
+                <configuration>
+                  <includes>
+                    <include>${basedir}/../activemq-leveldb/src/main/java</include>
+                  </includes>
+                  <classPathIncludes>
+                    <classPathInclude>${basedir}/../activemq-leveldb/target/classes</classPathInclude>
+                  </classPathIncludes>
+                  <strictXsdOrder>false</strictXsdOrder>
+                  <namespace>http://activemq.apache.org/schema/core</namespace>
+                  <schema>${basedir}/src/main/resources/activemq.xsd</schema>
+                  <outputDir>${basedir}/src/main/resources</outputDir>
+                  <generateSpringSchemasFile>false</generateSpringSchemasFile>
+                  <excludedClasses>org.apache.activemq.broker.jmx.AnnotatedMBean,org.apache.activemq.broker.jmx.DestinationViewMBean</excludedClasses>
+                </configuration>
+                <goals>
+                  <goal>mapping</goal>
+                </goals>
+              </execution>
+            </executions>
+            <dependencies>
+              <dependency>
+                <groupId>com.thoughtworks.qdox</groupId>
+                <artifactId>qdox</artifactId>
+                <version>1.12</version>
+              </dependency>
+            </dependencies>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
   </profiles>
 </project>
diff --git a/activemq-core/src/main/resources/META-INF/services/org/apache/xbean/spring/http/activemq.apache.org/schema/core b/activemq-core/src/main/resources/META-INF/services/org/apache/xbean/spring/http/activemq.apache.org/schema/core
new file mode 100644
index 000000000..e2ab90d92
--- /dev/null
+++ b/activemq-core/src/main/resources/META-INF/services/org/apache/xbean/spring/http/activemq.apache.org/schema/core
@@ -0,0 +1,381 @@
+# NOTE: this file is autogenerated by Apache XBean
+
+# beans
+abortSlowConsumerStrategy = org.apache.activemq.broker.region.policy.AbortSlowConsumerStrategy
+
+amqPersistenceAdapter = org.apache.activemq.store.amq.AMQPersistenceAdapter
+amqPersistenceAdapter.indexPageSize.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+amqPersistenceAdapter.maxCheckpointMessageAddSize.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+amqPersistenceAdapter.maxFileLength.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+amqPersistenceAdapter.maxReferenceFileLength.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+
+amqPersistenceAdapterFactory = org.apache.activemq.store.amq.AMQPersistenceAdapterFactory
+
+authenticationUser = org.apache.activemq.security.AuthenticationUser
+org.apache.activemq.security.AuthenticationUser(java.lang.String,java.lang.String,java.lang.String).parameterNames = username password groups
+
+authorizationEntry = org.apache.activemq.security.AuthorizationEntry
+
+authorizationMap = org.apache.activemq.security.DefaultAuthorizationMap
+org.apache.activemq.security.DefaultAuthorizationMap(java.util.List).parameterNames = authorizationEntries
+
+authorizationPlugin = org.apache.activemq.security.AuthorizationPlugin
+org.apache.activemq.security.AuthorizationPlugin(org.apache.activemq.security.AuthorizationMap).parameterNames = map
+
+axionJDBCAdapter = org.apache.activemq.store.jdbc.adapter.AxionJDBCAdapter
+
+blobJDBCAdapter = org.apache.activemq.store.jdbc.adapter.BlobJDBCAdapter
+
+broker = org.apache.activemq.xbean.XBeanBrokerService
+broker.initMethod = afterPropertiesSet
+broker.destroyMethod = destroy
+broker.advisorySupport.propertyEditor = org.apache.activemq.util.BooleanEditor
+broker.deleteAllMessagesOnStartup.propertyEditor = org.apache.activemq.util.BooleanEditor
+broker.passiveSlave.propertyEditor = org.apache.activemq.util.BooleanEditor
+broker.persistent.propertyEditor = org.apache.activemq.util.BooleanEditor
+broker.schedulerSupport.propertyEditor = org.apache.activemq.util.BooleanEditor
+broker.shutdownOnSlaveFailure.propertyEditor = org.apache.activemq.util.BooleanEditor
+broker.systemExitOnShutdown.propertyEditor = org.apache.activemq.util.BooleanEditor
+broker.useJmx.propertyEditor = org.apache.activemq.util.BooleanEditor
+broker.waitForSlave.propertyEditor = org.apache.activemq.util.BooleanEditor
+
+brokerService = org.apache.activemq.broker.BrokerService
+brokerService.advisorySupport.propertyEditor = org.apache.activemq.util.BooleanEditor
+brokerService.deleteAllMessagesOnStartup.propertyEditor = org.apache.activemq.util.BooleanEditor
+brokerService.passiveSlave.propertyEditor = org.apache.activemq.util.BooleanEditor
+brokerService.persistent.propertyEditor = org.apache.activemq.util.BooleanEditor
+brokerService.schedulerSupport.propertyEditor = org.apache.activemq.util.BooleanEditor
+brokerService.shutdownOnSlaveFailure.propertyEditor = org.apache.activemq.util.BooleanEditor
+brokerService.systemExitOnShutdown.propertyEditor = org.apache.activemq.util.BooleanEditor
+brokerService.useJmx.propertyEditor = org.apache.activemq.util.BooleanEditor
+brokerService.waitForSlave.propertyEditor = org.apache.activemq.util.BooleanEditor
+
+bytesJDBCAdapter = org.apache.activemq.store.jdbc.adapter.BytesJDBCAdapter
+
+cachedLDAPAuthorizationMap = org.apache.activemq.security.CachedLDAPAuthorizationMap
+
+commandAgent = org.apache.activemq.broker.util.CommandAgent
+commandAgent.initMethod = start
+commandAgent.destroyMethod = stop
+
+compositeDemandForwardingBridge = org.apache.activemq.network.CompositeDemandForwardingBridge
+org.apache.activemq.network.CompositeDemandForwardingBridge(org.apache.activemq.network.NetworkBridgeConfiguration,org.apache.activemq.transport.Transport,org.apache.activemq.transport.Transport).parameterNames = configuration localBroker remoteBroker
+
+compositeQueue = org.apache.activemq.broker.region.virtual.CompositeQueue
+
+compositeTopic = org.apache.activemq.broker.region.virtual.CompositeTopic
+
+conditionalNetworkBridgeFilterFactory = org.apache.activemq.network.ConditionalNetworkBridgeFilterFactory
+
+connectionDotFilePlugin = org.apache.activemq.broker.view.ConnectionDotFilePlugin
+
+connectionFactory = org.apache.activemq.spring.ActiveMQConnectionFactory
+connectionFactory.initMethod = afterPropertiesSet
+
+constantPendingMessageLimitStrategy = org.apache.activemq.broker.region.policy.ConstantPendingMessageLimitStrategy
+
+database-locker = org.apache.activemq.store.jdbc.DefaultDatabaseLocker
+
+db2JDBCAdapter = org.apache.activemq.store.jdbc.adapter.DB2JDBCAdapter
+
+defaultIOExceptionHandler = org.apache.activemq.util.DefaultIOExceptionHandler
+
+defaultJDBCAdapter = org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter
+
+defaultNetworkBridgeFilterFactory = org.apache.activemq.network.DefaultNetworkBridgeFilterFactory
+
+defaultUsageCapacity = org.apache.activemq.usage.DefaultUsageCapacity
+
+demandForwardingBridge = org.apache.activemq.network.DemandForwardingBridge
+org.apache.activemq.network.DemandForwardingBridge(org.apache.activemq.network.NetworkBridgeConfiguration,org.apache.activemq.transport.Transport,org.apache.activemq.transport.Transport).parameterNames = configuration localBroker remoteBroker
+
+destinationDotFilePlugin = org.apache.activemq.broker.view.DestinationDotFilePlugin
+
+destinationEntry = org.apache.activemq.filter.DefaultDestinationMapEntry
+
+destinationPathSeparatorPlugin = org.apache.activemq.broker.util.DestinationPathSeparatorBroker
+
+discardingDLQBrokerPlugin = org.apache.activemq.plugin.DiscardingDLQBrokerPlugin
+
+fileCursor = org.apache.activemq.broker.region.policy.FilePendingSubscriberMessageStoragePolicy
+
+fileDurableSubscriberCursor = org.apache.activemq.broker.region.policy.FilePendingDurableSubscriberMessageStoragePolicy
+
+fileQueueCursor = org.apache.activemq.broker.region.policy.FilePendingQueueMessageStoragePolicy
+
+filteredDestination = org.apache.activemq.broker.region.virtual.FilteredDestination
+
+filteredKahaDB = org.apache.activemq.store.kahadb.FilteredKahaDBPersistenceAdapter
+org.apache.activemq.store.kahadb.FilteredKahaDBPersistenceAdapter(org.apache.activemq.command.ActiveMQDestination,org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter).parameterNames = destination adapter
+
+fixedCountSubscriptionRecoveryPolicy = org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy
+
+fixedSizedSubscriptionRecoveryPolicy = org.apache.activemq.broker.region.policy.FixedSizedSubscriptionRecoveryPolicy
+
+forcePersistencyModeBroker = org.apache.activemq.plugin.ForcePersistencyModeBroker
+org.apache.activemq.plugin.ForcePersistencyModeBroker(org.apache.activemq.broker.Broker).parameterNames = next
+
+forcePersistencyModeBrokerPlugin = org.apache.activemq.plugin.ForcePersistencyModeBrokerPlugin
+
+forwardingBridge = org.apache.activemq.network.ForwardingBridge
+org.apache.activemq.network.ForwardingBridge(org.apache.activemq.transport.Transport,org.apache.activemq.transport.Transport).parameterNames = localBroker remoteBroker
+
+hsqldb-jdbc-adapter = org.apache.activemq.store.jdbc.adapter.HsqldbJDBCAdapter
+
+imageBasedJDBCAdaptor = org.apache.activemq.store.jdbc.adapter.ImageBasedJDBCAdaptor
+
+inboundQueueBridge = org.apache.activemq.network.jms.InboundQueueBridge
+org.apache.activemq.network.jms.InboundQueueBridge(java.lang.String).parameterNames = inboundQueueName
+
+inboundTopicBridge = org.apache.activemq.network.jms.InboundTopicBridge
+org.apache.activemq.network.jms.InboundTopicBridge(java.lang.String).parameterNames = inboundTopicName
+
+individualDeadLetterStrategy = org.apache.activemq.broker.region.policy.IndividualDeadLetterStrategy
+
+informixJDBCAdapter = org.apache.activemq.store.jdbc.adapter.InformixJDBCAdapter
+
+jDBCIOExceptionHandler = org.apache.activemq.store.jdbc.JDBCIOExceptionHandler
+
+jaasAuthenticationPlugin = org.apache.activemq.security.JaasAuthenticationPlugin
+
+jaasCertificateAuthenticationPlugin = org.apache.activemq.security.JaasCertificateAuthenticationPlugin
+
+jaasDualAuthenticationPlugin = org.apache.activemq.security.JaasDualAuthenticationPlugin
+
+jdbcPersistenceAdapter = org.apache.activemq.store.jdbc.JDBCPersistenceAdapter
+org.apache.activemq.store.jdbc.JDBCPersistenceAdapter(javax.sql.DataSource,org.apache.activemq.wireformat.WireFormat).parameterNames = ds wireFormat
+
+jmsQueueConnector = org.apache.activemq.network.jms.JmsQueueConnector
+
+jmsTopicConnector = org.apache.activemq.network.jms.JmsTopicConnector
+
+journalPersistenceAdapter = org.apache.activemq.store.journal.JournalPersistenceAdapter
+org.apache.activemq.store.journal.JournalPersistenceAdapter(org.apache.activeio.journal.Journal,org.apache.activemq.store.PersistenceAdapter,org.apache.activemq.thread.TaskRunnerFactory).parameterNames = journal longTermPersistence taskRunnerFactory
+
+journalPersistenceAdapterFactory = org.apache.activemq.store.journal.JournalPersistenceAdapterFactory
+journalPersistenceAdapterFactory.journalLogFileSize.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+
+journaledJDBC = org.apache.activemq.store.PersistenceAdapterFactoryBean
+journaledJDBC.journalLogFileSize.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+
+kahaDB = org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter
+kahaDB.indexCacheSize.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+kahaDB.indexWriteBatchSize.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+kahaDB.journalMaxFileLength.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+kahaDB.journalMaxWriteBatchSize.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+
+kahaPersistenceAdapter = org.apache.activemq.store.kahadaptor.KahaPersistenceAdapter
+kahaPersistenceAdapter.maxDataFileLength.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+org.apache.activemq.store.kahadaptor.KahaPersistenceAdapter(java.util.concurrent.atomic.AtomicLong).parameterNames = size
+
+lDAPAuthorizationMap = org.apache.activemq.security.LDAPAuthorizationMap
+org.apache.activemq.security.LDAPAuthorizationMap(java.util.Map).parameterNames = options
+
+lastImageSubscriptionRecoveryPolicy = org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy
+
+ldapNetworkConnector = org.apache.activemq.network.LdapNetworkConnector
+ldapNetworkConnector.prefetchSize.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+
+lease-database-locker = org.apache.activemq.store.jdbc.LeaseDatabaseLocker
+
+levelDB = org.apache.activemq.store.leveldb.LevelDBPersistenceAdapter
+
+loggingBrokerPlugin = org.apache.activemq.broker.util.LoggingBrokerPlugin
+loggingBrokerPlugin.initMethod = afterPropertiesSet
+
+mKahaDB = org.apache.activemq.store.kahadb.MultiKahaDBPersistenceAdapter
+mKahaDB.journalMaxFileLength.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+mKahaDB.journalWriteBatchSize.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+
+managementContext = org.apache.activemq.broker.jmx.ManagementContext
+managementContext.connectorPort.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+managementContext.createConnector.propertyEditor = org.apache.activemq.util.BooleanEditor
+managementContext.rmiServerPort.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+org.apache.activemq.broker.jmx.ManagementContext(javax.management.MBeanServer).parameterNames = server
+
+masterConnector = org.apache.activemq.broker.ft.MasterConnector
+org.apache.activemq.broker.ft.MasterConnector(java.lang.String).parameterNames = remoteUri
+
+maxdb-jdbc-adapter = org.apache.activemq.store.jdbc.adapter.MaxDBJDBCAdapter
+
+memoryPersistenceAdapter = org.apache.activemq.store.memory.MemoryPersistenceAdapter
+
+memoryUsage = org.apache.activemq.usage.MemoryUsage
+memoryUsage.limit.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+memoryUsage.percentUsageMinDelta.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+org.apache.activemq.usage.MemoryUsage(org.apache.activemq.usage.MemoryUsage).parameterNames = parent
+org.apache.activemq.usage.MemoryUsage(java.lang.String).parameterNames = name
+org.apache.activemq.usage.MemoryUsage(org.apache.activemq.usage.MemoryUsage,java.lang.String).parameterNames = parent name
+org.apache.activemq.usage.MemoryUsage(org.apache.activemq.usage.MemoryUsage,java.lang.String,float).parameterNames = parent name portion
+
+messageGroupHashBucketFactory = org.apache.activemq.broker.region.group.MessageGroupHashBucketFactory
+
+mirroredQueue = org.apache.activemq.broker.region.virtual.MirroredQueue
+
+multicastNetworkConnector = org.apache.activemq.network.MulticastNetworkConnector
+multicastNetworkConnector.prefetchSize.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+org.apache.activemq.network.MulticastNetworkConnector(java.net.URI).parameterNames = remoteURI
+
+multicastTraceBrokerPlugin = org.apache.activemq.broker.util.MulticastTraceBrokerPlugin
+
+mysql-jdbc-adapter = org.apache.activemq.store.jdbc.adapter.MySqlJDBCAdapter
+
+networkConnector = org.apache.activemq.network.DiscoveryNetworkConnector
+networkConnector.prefetchSize.propertyEditor = org.apache.activemq.util.MemoryIntPropertyEditor
+org.apache.activemq.network.DiscoveryNetworkConnector(java.net.URI).parameterNames = discoveryURI
+
+noSubscriptionRecoveryPolicy = org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy
+
+oldestMessageEvictionStrategy = org.apache.activemq.broker.region.policy.OldestMessageEvictionStrategy
+
+oldestMessageWithLowestPriorityEvictionStrategy = org.apache.activemq.broker.region.policy.OldestMessageWithLowestPriorityEvictionStrategy
+
+oracleBlobJDBCAdapter = org.apache.activemq.store.jdbc.adapter.OracleBlobJDBCAdapter
+
+oracleJDBCAdapter = org.apache.activemq.store.jdbc.adapter.OracleJDBCAdapter
+
+outboundQueueBridge = org.apache.activemq.network.jms.OutboundQueueBridge
+org.apache.activemq.network.jms.OutboundQueueBridge(java.lang.String).parameterNames = outboundQueueName
+
+outboundTopicBridge = org.apache.activemq.network.jms.OutboundTopicBridge
+org.apache.activemq.network.jms.OutboundTopicBridge(java.lang.String).parameterNames = outboundTopicName
+
+pListStore = org.apache.activemq.store.kahadb.plist.PListStore
+
+policyEntry = org.apache.activemq.broker.region.policy.PolicyEntry
+policyEntry.memoryLimit.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+
+policyMap = org.apache.activemq.broker.region.policy.PolicyMap
+
+postgresql-jdbc-adapter = org.apache.activemq.store.jdbc.adapter.PostgresqlJDBCAdapter
+
+prefetchPolicy = org.apache.activemq.ActiveMQPrefetchPolicy
+
+prefetchRatePendingMessageLimitStrategy = org.apache.activemq.broker.region.policy.PrefetchRatePendingMessageLimitStrategy
+
+priorityNetworkDispatchPolicy = org.apache.activemq.broker.region.policy.PriorityNetworkDispatchPolicy
+
+proxyConnector = org.apache.activemq.proxy.ProxyConnector
+
+queryBasedSubscriptionRecoveryPolicy = org.apache.activemq.broker.region.policy.QueryBasedSubscriptionRecoveryPolicy
+
+queue = org.apache.activemq.command.ActiveMQQueue
+org.apache.activemq.command.ActiveMQQueue(java.lang.String).parameterNames = name
+
+queueDispatchSelector = org.apache.activemq.broker.region.QueueDispatchSelector
+org.apache.activemq.broker.region.QueueDispatchSelector(org.apache.activemq.command.ActiveMQDestination).parameterNames = destination
+
+reconnectionPolicy = org.apache.activemq.network.jms.ReconnectionPolicy
+
+redeliveryPlugin = org.apache.activemq.broker.util.RedeliveryPlugin
+
+redeliveryPolicy = org.apache.activemq.RedeliveryPolicy
+
+redeliveryPolicyMap = org.apache.activemq.broker.region.policy.RedeliveryPolicyMap
+
+roundRobinDispatchPolicy = org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy
+
+shared-file-locker = org.apache.activemq.store.SharedFileLocker
+
+sharedDeadLetterStrategy = org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy
+
+simpleAuthenticationPlugin = org.apache.activemq.security.SimpleAuthenticationPlugin
+org.apache.activemq.security.SimpleAuthenticationPlugin(java.util.List).parameterNames = users
+
+simpleAuthorizationMap = org.apache.activemq.security.SimpleAuthorizationMap
+org.apache.activemq.security.SimpleAuthorizationMap(org.apache.activemq.filter.DestinationMap,org.apache.activemq.filter.DestinationMap,org.apache.activemq.filter.DestinationMap).parameterNames = writeACLs readACLs adminACLs
+
+simpleDispatchPolicy = org.apache.activemq.broker.region.policy.SimpleDispatchPolicy
+
+simpleDispatchSelector = org.apache.activemq.broker.region.policy.SimpleDispatchSelector
+org.apache.activemq.broker.region.policy.SimpleDispatchSelector(org.apache.activemq.command.ActiveMQDestination).parameterNames = destination
+
+simpleJmsMessageConvertor = org.apache.activemq.network.jms.SimpleJmsMessageConvertor
+
+simpleMessageGroupMapFactory = org.apache.activemq.broker.region.group.SimpleMessageGroupMapFactory
+
+sslContext = org.apache.activemq.spring.SpringSslContext
+sslContext.initMethod = afterPropertiesSet
+
+statements = org.apache.activemq.store.jdbc.Statements
+
+statisticsBrokerPlugin = org.apache.activemq.plugin.StatisticsBrokerPlugin
+
+storeCursor = org.apache.activemq.broker.region.policy.StorePendingQueueMessageStoragePolicy
+
+storeDurableSubscriberCursor = org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy
+
+storeUsage = org.apache.activemq.usage.StoreUsage
+storeUsage.limit.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+storeUsage.percentUsageMinDelta.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+org.apache.activemq.usage.StoreUsage(java.lang.String,org.apache.activemq.store.PersistenceAdapter).parameterNames = name store
+org.apache.activemq.usage.StoreUsage(org.apache.activemq.usage.StoreUsage,java.lang.String).parameterNames = parent name
+
+streamJDBCAdapter = org.apache.activemq.store.jdbc.adapter.StreamJDBCAdapter
+
+strictOrderDispatchPolicy = org.apache.activemq.broker.region.policy.StrictOrderDispatchPolicy
+
+sybase-jdbc-adapter = org.apache.activemq.store.jdbc.adapter.SybaseJDBCAdapter
+
+systemUsage = org.apache.activemq.usage.SystemUsage
+org.apache.activemq.usage.SystemUsage(java.lang.String,org.apache.activemq.store.PersistenceAdapter,org.apache.activemq.store.kahadb.plist.PListStore).parameterNames = name adapter tempStore
+org.apache.activemq.usage.SystemUsage(org.apache.activemq.usage.SystemUsage,java.lang.String).parameterNames = parent name
+
+taskRunnerFactory = org.apache.activemq.thread.TaskRunnerFactory
+org.apache.activemq.thread.TaskRunnerFactory(java.lang.String).parameterNames = name
+org.apache.activemq.thread.TaskRunnerFactory(java.lang.String,int,boolean,int,boolean).parameterNames = name priority daemon maxIterationsPerRun dedicatedTaskRunner
+org.apache.activemq.thread.TaskRunnerFactory(java.lang.String,int,boolean,int,boolean,int).parameterNames = name priority daemon maxIterationsPerRun dedicatedTaskRunner maxThreadPoolSize
+
+tempDestinationAuthorizationEntry = org.apache.activemq.security.TempDestinationAuthorizationEntry
+
+tempQueue = org.apache.activemq.command.ActiveMQTempQueue
+org.apache.activemq.command.ActiveMQTempQueue(java.lang.String).parameterNames = name
+org.apache.activemq.command.ActiveMQTempQueue(org.apache.activemq.command.ConnectionId,long).parameterNames = connectionId sequenceId
+
+tempTopic = org.apache.activemq.command.ActiveMQTempTopic
+org.apache.activemq.command.ActiveMQTempTopic(java.lang.String).parameterNames = name
+org.apache.activemq.command.ActiveMQTempTopic(org.apache.activemq.command.ConnectionId,long).parameterNames = connectionId sequenceId
+
+tempUsage = org.apache.activemq.usage.TempUsage
+tempUsage.limit.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+tempUsage.percentUsageMinDelta.propertyEditor = org.apache.activemq.util.MemoryPropertyEditor
+org.apache.activemq.usage.TempUsage(java.lang.String,org.apache.activemq.store.kahadb.plist.PListStore).parameterNames = name store
+org.apache.activemq.usage.TempUsage(org.apache.activemq.usage.TempUsage,java.lang.String).parameterNames = parent name
+
+timeStampingBrokerPlugin = org.apache.activemq.broker.util.TimeStampingBrokerPlugin
+
+timedSubscriptionRecoveryPolicy = org.apache.activemq.broker.region.policy.TimedSubscriptionRecoveryPolicy
+
+topic = org.apache.activemq.command.ActiveMQTopic
+org.apache.activemq.command.ActiveMQTopic(java.lang.String).parameterNames = name
+
+traceBrokerPathPlugin = org.apache.activemq.broker.util.TraceBrokerPathPlugin
+
+transact-database-locker = org.apache.activemq.store.jdbc.adapter.TransactDatabaseLocker
+
+transact-jdbc-adapter = org.apache.activemq.store.jdbc.adapter.TransactJDBCAdapter
+
+transportConnector = org.apache.activemq.broker.TransportConnector
+org.apache.activemq.broker.TransportConnector(org.apache.activemq.transport.TransportServer).parameterNames = server
+
+udpTraceBrokerPlugin = org.apache.activemq.broker.util.UDPTraceBrokerPlugin
+
+uniquePropertyMessageEvictionStrategy = org.apache.activemq.broker.region.policy.UniquePropertyMessageEvictionStrategy
+
+usageCapacity = org.apache.activemq.usage.UsageCapacity
+
+virtualDestinationInterceptor = org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor
+
+virtualSelectorCacheBrokerPlugin = org.apache.activemq.plugin.SubQueueSelectorCacheBrokerPlugin
+
+virtualTopic = org.apache.activemq.broker.region.virtual.VirtualTopic
+
+vmCursor = org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy
+
+vmDurableCursor = org.apache.activemq.broker.region.policy.VMPendingDurableSubscriberMessageStoragePolicy
+
+vmQueueCursor = org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy
+
+xaConnectionFactory = org.apache.activemq.spring.ActiveMQXAConnectionFactory
+xaConnectionFactory.initMethod = afterPropertiesSet
+
diff --git a/activemq-core/src/main/resources/META-INF/spring.handlers b/activemq-core/src/main/resources/META-INF/spring.handlers
new file mode 100644
index 000000000..06743926d
--- /dev/null
+++ b/activemq-core/src/main/resources/META-INF/spring.handlers
@@ -0,0 +1,3 @@
+#Generated by xbean-spring
+#Tue Sep 25 10:20:04 EDT 2012
+http\://activemq.apache.org/schema/core=org.apache.xbean.spring.context.v2.XBeanNamespaceHandler
diff --git a/activemq-core/src/main/resources/activemq.xsd b/activemq-core/src/main/resources/activemq.xsd
new file mode 100644
index 000000000..cd5cd7ed0
--- /dev/null
+++ b/activemq-core/src/main/resources/activemq.xsd
@@ -0,0 +1,9296 @@
+<?xml version='1.0'?>
+<!-- NOTE: this file is autogenerated by Apache XBean -->
+
+<xs:schema elementFormDefault='qualified'
+           targetNamespace='http://activemq.apache.org/schema/core'
+           xmlns:xs='http://www.w3.org/2001/XMLSchema'
+           xmlns:tns='http://activemq.apache.org/schema/core'>
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.AbortSlowConsumerStrategy -->
+  <xs:element name='abortSlowConsumerStrategy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Abort slow consumers when they reach the configured threshold of slowness, default is slow for 30 seconds
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='abortConnection' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            abort the consumers connection rather than sending a stop command to the remote consumer
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='checkPeriod' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            time in milliseconds between checks for slow subscriptions
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maxSlowCount' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            number of times a subscription can be deemed slow before triggering abort
+effect depends on dispatch rate as slow determination is done on dispatch
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maxSlowDuration' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            time in milliseconds that a sub can remain slow before triggering
+an abort.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.amq.AMQPersistenceAdapter -->
+  <xs:element name='amqPersistenceAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='asyncDataManager' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='referenceStoreAdapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='wireFormat' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='archiveDataLogs' type='xs:boolean'/>
+      <xs:attribute name='asyncDataManager' type='xs:string'/>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='checkpointInterval' type='xs:long'/>
+      <xs:attribute name='cleanupInterval' type='xs:long'/>
+      <xs:attribute name='directory' type='xs:string'/>
+      <xs:attribute name='directoryArchive' type='xs:string'/>
+      <xs:attribute name='disableLocking' type='xs:boolean'/>
+      <xs:attribute name='forceRecoverReferenceStore' type='xs:boolean'/>
+      <xs:attribute name='indexBinSize' type='xs:integer'/>
+      <xs:attribute name='indexKeySize' type='xs:integer'/>
+      <xs:attribute name='indexLoadFactor' type='xs:integer'/>
+      <xs:attribute name='indexMaxBinSize' type='xs:integer'/>
+      <xs:attribute name='indexPageSize' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='journalThreadPriority' type='xs:integer'/>
+      <xs:attribute name='maxCheckpointMessageAddSize' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maxFileLength' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maxReferenceFileLength' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='persistentIndex' type='xs:boolean'/>
+      <xs:attribute name='recoverReferenceStore' type='xs:boolean'/>
+      <xs:attribute name='referenceStoreAdapter' type='xs:string'/>
+      <xs:attribute name='syncOnWrite' type='xs:boolean'/>
+      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='usageManager' type='xs:string'/>
+      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
+      <xs:attribute name='useNio' type='xs:boolean'/>
+      <xs:attribute name='wireFormat' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.amq.AMQPersistenceAdapterFactory -->
+  <xs:element name='amqPersistenceAdapterFactory'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An implementation of {@link PersistenceAdapterFactory}
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='referenceStoreAdapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='checkpointInterval' type='xs:long'/>
+      <xs:attribute name='cleanupInterval' type='xs:long'/>
+      <xs:attribute name='dataDirectory' type='xs:string'/>
+      <xs:attribute name='forceRecoverReferenceStore' type='xs:boolean'/>
+      <xs:attribute name='indexBinSize' type='xs:integer'/>
+      <xs:attribute name='indexKeySize' type='xs:integer'/>
+      <xs:attribute name='indexLoadFactor' type='xs:integer'/>
+      <xs:attribute name='indexMaxBinSize' type='xs:integer'/>
+      <xs:attribute name='indexPageSize' type='xs:integer'/>
+      <xs:attribute name='journalThreadPriority' type='xs:integer'/>
+      <xs:attribute name='maxFileLength' type='xs:integer'/>
+      <xs:attribute name='maxReferenceFileLength' type='xs:integer'/>
+      <xs:attribute name='persistentIndex' type='xs:boolean'/>
+      <xs:attribute name='recoverReferenceStore' type='xs:boolean'/>
+      <xs:attribute name='referenceStoreAdapter' type='xs:string'/>
+      <xs:attribute name='syncOnTransaction' type='xs:boolean'/>
+      <xs:attribute name='syncOnWrite' type='xs:boolean'/>
+      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
+      <xs:attribute name='useNio' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.AuthenticationUser -->
+  <xs:element name='authenticationUser'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A helper object used to configure simple authentiaction plugin
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='groups' type='xs:string'/>
+      <xs:attribute name='password' type='xs:string'/>
+      <xs:attribute name='username' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.AuthorizationEntry -->
+  <xs:element name='authorizationEntry'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a specific
+destination or a hierarchical wildcard area of destinations.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminACLs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='readACLs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='writeACLs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='admin' type='xs:string'/>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='groupClass' type='xs:string'/>
+      <xs:attribute name='queue' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='read' type='xs:string'/>
+      <xs:attribute name='tempQueue' type='xs:boolean'/>
+      <xs:attribute name='tempTopic' type='xs:boolean'/>
+      <xs:attribute name='topic' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='write' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.DefaultAuthorizationMap -->
+  <xs:element name='authorizationMap'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies. Each entry in the map represents the authorization ACLs
+for each operation.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='authorizationEntries' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the individual entries on the authorization map
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='defaultEntry' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:authorizationEntry'/>
+              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='entries' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='tempDestinationAuthorizationEntry' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='defaultEntry' type='xs:string'/>
+      <xs:attribute name='tempDestinationAuthorizationEntry' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.AuthorizationPlugin -->
+  <xs:element name='authorizationPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An authorization plugin where each operation on a destination is checked
+against an authorizationMap
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='map' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:authorizationMap'/>
+              <xs:element ref='tns:cachedLDAPAuthorizationMap'/>
+              <xs:element ref='tns:lDAPAuthorizationMap'/>
+              <xs:element ref='tns:simpleAuthorizationMap'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='map' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.AxionJDBCAdapter -->
+  <xs:element name='axionJDBCAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Axion specific Adapter.
+
+Axion does not seem to support ALTER statements or sub-selects.  This means:
+- We cannot auto upgrade the schema was we roll out new versions of ActiveMQ
+- We cannot delete durable sub messages that have be acknowledged by all consumers.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.BlobJDBCAdapter -->
+  <xs:element name='blobJDBCAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This JDBCAdapter inserts and extracts BLOB data using the getBlob()/setBlob()
+operations. This is a little more involved since to insert a blob you have
+to:
+
+1: insert empty blob. 2: select the blob 3: finally update the blob with data
+value.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.xbean.XBeanBrokerService -->
+  <xs:element name='broker'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An ActiveMQ Message Broker. It consists of a number of transport
+connectors, network connectors and a bunch of properties which can be used to
+configure the broker as its lazily created.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminView' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Returns the administration view of the broker; used to create and destroy
+resources such as queues and topics. Note this method returns null if JMX
+is disabled.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='brokerContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerSystemUsage' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destinationFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destinationInterceptors' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the destination interceptors to use
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:mirroredQueue'/>
+              <xs:element ref='tns:virtualDestinationInterceptor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destinationPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the destination specific policies available either for exact
+destinations or for wildcard areas of destinations.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:policyMap'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destinations' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the destinations which should be loaded/created on startup
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='ioExceptionHandler' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              override the Default IOException handler, called when persistence adapter
+has experiences File or JDBC I/O Exceptions
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:defaultIOExceptionHandler'/>
+              <xs:element ref='tns:jDBCIOExceptionHandler'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsBridgeConnectors' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:jmsQueueConnector'/>
+              <xs:element ref='tns:jmsTopicConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='managementContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:managementContext'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='messageAuthorizationPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the policy used to decide if the current connection is authorized to
+consume a given message
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='networkConnectorURIs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='networkConnectors' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the network connectors which this broker will use to connect to
+other brokers in a federated network
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:ldapNetworkConnector'/>
+              <xs:element ref='tns:multicastNetworkConnector'/>
+              <xs:element ref='tns:networkConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='persistenceAdapter' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the persistence adaptor implementation to use for this broker
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:amqPersistenceAdapter'/>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:element ref='tns:journalPersistenceAdapter'/>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:element ref='tns:kahaPersistenceAdapter'/>
+              <xs:element ref='tns:levelDB'/>
+              <xs:element ref='tns:mKahaDB'/>
+              <xs:element ref='tns:memoryPersistenceAdapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='persistenceFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:amqPersistenceAdapterFactory'/>
+              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
+              <xs:element ref='tns:journaledJDBC'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='persistenceTaskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='plugins' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets a number of broker plugins to install such as for security
+authentication or authorization
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:authorizationPlugin'/>
+              <xs:element ref='tns:connectionDotFilePlugin'/>
+              <xs:element ref='tns:destinationDotFilePlugin'/>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:discardingDLQBrokerPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBrokerPlugin'/>
+              <xs:element ref='tns:jaasAuthenticationPlugin'/>
+              <xs:element ref='tns:jaasCertificateAuthenticationPlugin'/>
+              <xs:element ref='tns:jaasDualAuthenticationPlugin'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:simpleAuthenticationPlugin'/>
+              <xs:element ref='tns:statisticsBrokerPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:element ref='tns:virtualSelectorCacheBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerSystemUsage' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='proxyConnectors' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the network connectors which this broker will use to connect to
+other brokers in a federated network
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='regionBroker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='services' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the services associated with this broker such as a
+{@link MasterConnector}
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:element ref='tns:commandAgent'/>
+              <xs:element ref='tns:database-locker'/>
+              <xs:element ref='tns:forwardingBridge'/>
+              <xs:element ref='tns:inboundQueueBridge'/>
+              <xs:element ref='tns:inboundTopicBridge'/>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:element ref='tns:jmsQueueConnector'/>
+              <xs:element ref='tns:jmsTopicConnector'/>
+              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
+              <xs:element ref='tns:journaledJDBC'/>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:element ref='tns:ldapNetworkConnector'/>
+              <xs:element ref='tns:lease-database-locker'/>
+              <xs:element ref='tns:levelDB'/>
+              <xs:element ref='tns:managementContext'/>
+              <xs:element ref='tns:masterConnector'/>
+              <xs:element ref='tns:memoryUsage'/>
+              <xs:element ref='tns:multicastNetworkConnector'/>
+              <xs:element ref='tns:networkConnector'/>
+              <xs:element ref='tns:outboundQueueBridge'/>
+              <xs:element ref='tns:outboundTopicBridge'/>
+              <xs:element ref='tns:pListStore'/>
+              <xs:element ref='tns:proxyConnector'/>
+              <xs:element ref='tns:shared-file-locker'/>
+              <xs:element ref='tns:storeUsage'/>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:element ref='tns:tempUsage'/>
+              <xs:element ref='tns:transact-database-locker'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='shutdownHooks' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets hooks to be executed when broker shut down
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='sslContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:sslContext'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='systemUsage' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='tempDataStore' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:pListStore'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='transportConnectorURIs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='transportConnectors' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the transport connectors which this broker will listen on for new
+clients
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:transportConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminView' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Returns the administration view of the broker; used to create and destroy
+resources such as queues and topics. Note this method returns null if JMX
+is disabled.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='advisorySupport' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Allows the support of advisory messages to be disabled for performance
+reasons.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='allowTempAutoCreationOnSend' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            enable if temp destinations need to be propagated through a network when
+advisorySupport==false. This is used in conjunction with the policy
+gcInactiveDestinations for matching temps so they can get removed
+when inactive
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='brokerContext' type='xs:string'/>
+      <xs:attribute name='brokerId' type='xs:string'/>
+      <xs:attribute name='brokerName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the name of this broker; which must be unique in the network
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='brokerObjectName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JMX ObjectName for this broker
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='cacheTempDestinations' type='xs:boolean'/>
+      <xs:attribute name='consumerSystemUsage' type='xs:string'/>
+      <xs:attribute name='consumerSystemUsagePortion' type='xs:integer'/>
+      <xs:attribute name='dataDirectory' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='dataDirectoryFile' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='dedicatedTaskRunner' type='xs:boolean'/>
+      <xs:attribute name='deleteAllMessagesOnStartup' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not all messages are deleted on startup - mostly only
+useful for testing.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='destinationFactory' type='xs:string'/>
+      <xs:attribute name='destinationPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the destination specific policies available either for exact
+destinations or for wildcard areas of destinations.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='enableStatistics' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not the Broker's services enable statistics or not.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='ioExceptionHandler' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            override the Default IOException handler, called when persistence adapter
+has experiences File or JDBC I/O Exceptions
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='keepDurableSubsActive' type='xs:boolean'/>
+      <xs:attribute name='managementContext' type='xs:string'/>
+      <xs:attribute name='masterConnectorURI' type='xs:string'/>
+      <xs:attribute name='maxPurgedDestinationsPerSweep' type='xs:integer'/>
+      <xs:attribute name='mbeanInvocationTimeout' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the time in Milliseconds that an invocation of an MBean method will wait before
+failing.  The default value is to wait forever (zero).
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='messageAuthorizationPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the policy used to decide if the current connection is authorized to
+consume a given message
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='monitorConnectionSplits' type='xs:boolean'/>
+      <xs:attribute name='networkConnectorStartAsync' type='xs:boolean'/>
+      <xs:attribute name='offlineDurableSubscriberTaskSchedule' type='xs:integer'/>
+      <xs:attribute name='offlineDurableSubscriberTimeout' type='xs:integer'/>
+      <xs:attribute name='passiveSlave' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the passiveSlave
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='persistenceAdapter' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the persistence adaptor implementation to use for this broker
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='persistenceFactory' type='xs:string'/>
+      <xs:attribute name='persistenceTaskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='persistenceThreadPriority' type='xs:integer'/>
+      <xs:attribute name='persistent' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not persistence is enabled or disabled.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='populateJMSXUserID' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not the broker should populate the JMSXUserID header.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='populateUserNameInMBeans' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Should MBeans that support showing the Authenticated User Name information have this
+value filled in or not.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='producerSystemUsage' type='xs:string'/>
+      <xs:attribute name='producerSystemUsagePortion' type='xs:integer'/>
+      <xs:attribute name='regionBroker' type='xs:string'/>
+      <xs:attribute name='schedulePeriodForDestinationPurge' type='xs:integer'/>
+      <xs:attribute name='schedulerDirectory' type='xs:string'/>
+      <xs:attribute name='schedulerDirectoryFile' type='xs:string'/>
+      <xs:attribute name='schedulerSupport' type='xs:string'/>
+      <xs:attribute name='shutdownOnMasterFailure' type='xs:boolean'/>
+      <xs:attribute name='shutdownOnSlaveFailure' type='xs:string'/>
+      <xs:attribute name='splitSystemUsageForProducersConsumers' type='xs:boolean'/>
+      <xs:attribute name='sslContext' type='xs:string'/>
+      <xs:attribute name='start' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not the broker is started along with the ApplicationContext it is defined within.
+Normally you would want the broker to start up along with the ApplicationContext but sometimes when working
+with JUnit tests you may wish to start and stop the broker explicitly yourself.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='startAsync' type='xs:boolean'/>
+      <xs:attribute name='supportFailOver' type='xs:boolean'/>
+      <xs:attribute name='systemExitOnShutdown' type='xs:string'/>
+      <xs:attribute name='systemExitOnShutdownExitCode' type='xs:integer'/>
+      <xs:attribute name='systemUsage' type='xs:string'/>
+      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='taskRunnerPriority' type='xs:integer'/>
+      <xs:attribute name='tempDataStore' type='xs:string'/>
+      <xs:attribute name='timeBeforePurgeTempDestinations' type='xs:integer'/>
+      <xs:attribute name='tmpDataDirectory' type='xs:string'/>
+      <xs:attribute name='useAuthenticatedPrincipalForJMSXUserID' type='xs:boolean'/>
+      <xs:attribute name='useJmx' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not the Broker's services should be exposed into JMX or
+not.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useLocalHostBrokerName' type='xs:boolean'/>
+      <xs:attribute name='useLoggingForShutdownErrors' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not we should use commons-logging when reporting errors
+when shutting down the broker
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useMirroredQueues' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not <a
+href="http://activemq.apache.org/mirrored-queues.html">Mirrored
+Queues</a> should be supported by default if they have not been
+explicitly configured.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useShutdownHook' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not we should use a shutdown handler to close down the
+broker cleanly if the JVM is terminated. It is recommended you leave this
+enabled.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useTempMirroredQueues' type='xs:boolean'/>
+      <xs:attribute name='useVirtualTopics' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual
+Topics</a> should be supported by default if they have not been
+explicitly configured.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='vmConnectorURI' type='xs:string'/>
+      <xs:attribute name='waitForSlave' type='xs:string'/>
+      <xs:attribute name='waitForSlaveTimeout' type='xs:long'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.BrokerService -->
+  <xs:element name='brokerService'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Manages the lifecycle of an ActiveMQ Broker. A BrokerService consists of a
+number of transport connectors, network connectors and a bunch of properties
+which can be used to configure the broker as its lazily created.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminView' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Returns the administration view of the broker; used to create and destroy
+resources such as queues and topics. Note this method returns null if JMX
+is disabled.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='brokerContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerSystemUsage' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destinationFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destinationInterceptors' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the destination interceptors to use
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:mirroredQueue'/>
+              <xs:element ref='tns:virtualDestinationInterceptor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destinationPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the destination specific policies available either for exact
+destinations or for wildcard areas of destinations.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:policyMap'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destinations' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the destinations which should be loaded/created on startup
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='ioExceptionHandler' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              override the Default IOException handler, called when persistence adapter
+has experiences File or JDBC I/O Exceptions
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:defaultIOExceptionHandler'/>
+              <xs:element ref='tns:jDBCIOExceptionHandler'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsBridgeConnectors' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:jmsQueueConnector'/>
+              <xs:element ref='tns:jmsTopicConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='managementContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:managementContext'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='messageAuthorizationPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the policy used to decide if the current connection is authorized to
+consume a given message
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='networkConnectorURIs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='networkConnectors' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the network connectors which this broker will use to connect to
+other brokers in a federated network
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:ldapNetworkConnector'/>
+              <xs:element ref='tns:multicastNetworkConnector'/>
+              <xs:element ref='tns:networkConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='persistenceAdapter' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the persistence adaptor implementation to use for this broker
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:amqPersistenceAdapter'/>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:element ref='tns:journalPersistenceAdapter'/>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:element ref='tns:kahaPersistenceAdapter'/>
+              <xs:element ref='tns:levelDB'/>
+              <xs:element ref='tns:mKahaDB'/>
+              <xs:element ref='tns:memoryPersistenceAdapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='persistenceFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:amqPersistenceAdapterFactory'/>
+              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
+              <xs:element ref='tns:journaledJDBC'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='persistenceTaskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='plugins' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets a number of broker plugins to install such as for security
+authentication or authorization
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:authorizationPlugin'/>
+              <xs:element ref='tns:connectionDotFilePlugin'/>
+              <xs:element ref='tns:destinationDotFilePlugin'/>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:discardingDLQBrokerPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBrokerPlugin'/>
+              <xs:element ref='tns:jaasAuthenticationPlugin'/>
+              <xs:element ref='tns:jaasCertificateAuthenticationPlugin'/>
+              <xs:element ref='tns:jaasDualAuthenticationPlugin'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:simpleAuthenticationPlugin'/>
+              <xs:element ref='tns:statisticsBrokerPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:element ref='tns:virtualSelectorCacheBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerSystemUsage' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='proxyConnectors' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the network connectors which this broker will use to connect to
+other brokers in a federated network
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='regionBroker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='services' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the services associated with this broker such as a
+{@link MasterConnector}
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:element ref='tns:commandAgent'/>
+              <xs:element ref='tns:database-locker'/>
+              <xs:element ref='tns:forwardingBridge'/>
+              <xs:element ref='tns:inboundQueueBridge'/>
+              <xs:element ref='tns:inboundTopicBridge'/>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:element ref='tns:jmsQueueConnector'/>
+              <xs:element ref='tns:jmsTopicConnector'/>
+              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
+              <xs:element ref='tns:journaledJDBC'/>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:element ref='tns:ldapNetworkConnector'/>
+              <xs:element ref='tns:lease-database-locker'/>
+              <xs:element ref='tns:levelDB'/>
+              <xs:element ref='tns:managementContext'/>
+              <xs:element ref='tns:masterConnector'/>
+              <xs:element ref='tns:memoryUsage'/>
+              <xs:element ref='tns:multicastNetworkConnector'/>
+              <xs:element ref='tns:networkConnector'/>
+              <xs:element ref='tns:outboundQueueBridge'/>
+              <xs:element ref='tns:outboundTopicBridge'/>
+              <xs:element ref='tns:pListStore'/>
+              <xs:element ref='tns:proxyConnector'/>
+              <xs:element ref='tns:shared-file-locker'/>
+              <xs:element ref='tns:storeUsage'/>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:element ref='tns:tempUsage'/>
+              <xs:element ref='tns:transact-database-locker'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='shutdownHooks' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets hooks to be executed when broker shut down
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='sslContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:sslContext'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='systemUsage' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='tempDataStore' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:pListStore'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='transportConnectorURIs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='transportConnectors' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the transport connectors which this broker will listen on for new
+clients
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:transportConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminView' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Returns the administration view of the broker; used to create and destroy
+resources such as queues and topics. Note this method returns null if JMX
+is disabled.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='advisorySupport' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Allows the support of advisory messages to be disabled for performance
+reasons.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='allowTempAutoCreationOnSend' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            enable if temp destinations need to be propagated through a network when
+advisorySupport==false. This is used in conjunction with the policy
+gcInactiveDestinations for matching temps so they can get removed
+when inactive
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='brokerContext' type='xs:string'/>
+      <xs:attribute name='brokerId' type='xs:string'/>
+      <xs:attribute name='brokerName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the name of this broker; which must be unique in the network
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='brokerObjectName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JMX ObjectName for this broker
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='cacheTempDestinations' type='xs:boolean'/>
+      <xs:attribute name='consumerSystemUsage' type='xs:string'/>
+      <xs:attribute name='consumerSystemUsagePortion' type='xs:integer'/>
+      <xs:attribute name='dataDirectory' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='dataDirectoryFile' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='dedicatedTaskRunner' type='xs:boolean'/>
+      <xs:attribute name='deleteAllMessagesOnStartup' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not all messages are deleted on startup - mostly only
+useful for testing.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='destinationFactory' type='xs:string'/>
+      <xs:attribute name='destinationPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the destination specific policies available either for exact
+destinations or for wildcard areas of destinations.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='enableStatistics' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not the Broker's services enable statistics or not.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='ioExceptionHandler' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            override the Default IOException handler, called when persistence adapter
+has experiences File or JDBC I/O Exceptions
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='keepDurableSubsActive' type='xs:boolean'/>
+      <xs:attribute name='managementContext' type='xs:string'/>
+      <xs:attribute name='masterConnectorURI' type='xs:string'/>
+      <xs:attribute name='maxPurgedDestinationsPerSweep' type='xs:integer'/>
+      <xs:attribute name='mbeanInvocationTimeout' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the time in Milliseconds that an invocation of an MBean method will wait before
+failing.  The default value is to wait forever (zero).
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='messageAuthorizationPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the policy used to decide if the current connection is authorized to
+consume a given message
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='monitorConnectionSplits' type='xs:boolean'/>
+      <xs:attribute name='networkConnectorStartAsync' type='xs:boolean'/>
+      <xs:attribute name='offlineDurableSubscriberTaskSchedule' type='xs:integer'/>
+      <xs:attribute name='offlineDurableSubscriberTimeout' type='xs:integer'/>
+      <xs:attribute name='passiveSlave' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the passiveSlave
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='persistenceAdapter' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the persistence adaptor implementation to use for this broker
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='persistenceFactory' type='xs:string'/>
+      <xs:attribute name='persistenceTaskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='persistenceThreadPriority' type='xs:integer'/>
+      <xs:attribute name='persistent' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not persistence is enabled or disabled.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='populateJMSXUserID' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not the broker should populate the JMSXUserID header.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='populateUserNameInMBeans' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Should MBeans that support showing the Authenticated User Name information have this
+value filled in or not.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='producerSystemUsage' type='xs:string'/>
+      <xs:attribute name='producerSystemUsagePortion' type='xs:integer'/>
+      <xs:attribute name='regionBroker' type='xs:string'/>
+      <xs:attribute name='schedulePeriodForDestinationPurge' type='xs:integer'/>
+      <xs:attribute name='schedulerDirectory' type='xs:string'/>
+      <xs:attribute name='schedulerDirectoryFile' type='xs:string'/>
+      <xs:attribute name='schedulerSupport' type='xs:string'/>
+      <xs:attribute name='shutdownOnMasterFailure' type='xs:boolean'/>
+      <xs:attribute name='shutdownOnSlaveFailure' type='xs:string'/>
+      <xs:attribute name='splitSystemUsageForProducersConsumers' type='xs:boolean'/>
+      <xs:attribute name='sslContext' type='xs:string'/>
+      <xs:attribute name='startAsync' type='xs:boolean'/>
+      <xs:attribute name='supportFailOver' type='xs:boolean'/>
+      <xs:attribute name='systemExitOnShutdown' type='xs:string'/>
+      <xs:attribute name='systemExitOnShutdownExitCode' type='xs:integer'/>
+      <xs:attribute name='systemUsage' type='xs:string'/>
+      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='taskRunnerPriority' type='xs:integer'/>
+      <xs:attribute name='tempDataStore' type='xs:string'/>
+      <xs:attribute name='timeBeforePurgeTempDestinations' type='xs:integer'/>
+      <xs:attribute name='tmpDataDirectory' type='xs:string'/>
+      <xs:attribute name='useAuthenticatedPrincipalForJMSXUserID' type='xs:boolean'/>
+      <xs:attribute name='useJmx' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not the Broker's services should be exposed into JMX or
+not.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useLocalHostBrokerName' type='xs:boolean'/>
+      <xs:attribute name='useLoggingForShutdownErrors' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not we should use commons-logging when reporting errors
+when shutting down the broker
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useMirroredQueues' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not <a
+href="http://activemq.apache.org/mirrored-queues.html">Mirrored
+Queues</a> should be supported by default if they have not been
+explicitly configured.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useShutdownHook' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not we should use a shutdown handler to close down the
+broker cleanly if the JVM is terminated. It is recommended you leave this
+enabled.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useTempMirroredQueues' type='xs:boolean'/>
+      <xs:attribute name='useVirtualTopics' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual
+Topics</a> should be supported by default if they have not been
+explicitly configured.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='vmConnectorURI' type='xs:string'/>
+      <xs:attribute name='waitForSlave' type='xs:string'/>
+      <xs:attribute name='waitForSlaveTimeout' type='xs:long'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.BytesJDBCAdapter -->
+  <xs:element name='bytesJDBCAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This JDBCAdapter inserts and extracts BLOB data using the
+setBytes()/getBytes() operations. The databases/JDBC drivers that use this
+adapter are:
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.CachedLDAPAuthorizationMap -->
+  <xs:element name='cachedLDAPAuthorizationMap'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update authorization
+policy.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='authorizationEntries' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the individual entries on the authorization map
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='defaultEntry' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:authorizationEntry'/>
+              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='entries' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='tempDestinationAuthorizationEntry' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminPermissionGroupSearchFilter' type='xs:string'/>
+      <xs:attribute name='authentication' type='xs:string'/>
+      <xs:attribute name='connectionPassword' type='xs:string'/>
+      <xs:attribute name='connectionProtocol' type='xs:string'/>
+      <xs:attribute name='connectionURL' type='xs:string'/>
+      <xs:attribute name='connectionUsername' type='xs:string'/>
+      <xs:attribute name='defaultEntry' type='xs:string'/>
+      <xs:attribute name='groupNameAttribute' type='xs:string'/>
+      <xs:attribute name='groupObjectClass' type='xs:string'/>
+      <xs:attribute name='legacyGroupMapping' type='xs:boolean'/>
+      <xs:attribute name='permissionGroupMemberAttribute' type='xs:string'/>
+      <xs:attribute name='queueSearchBase' type='xs:string'/>
+      <xs:attribute name='readPermissionGroupSearchFilter' type='xs:string'/>
+      <xs:attribute name='refreshDisabled' type='xs:boolean'/>
+      <xs:attribute name='refreshInterval' type='xs:integer'/>
+      <xs:attribute name='tempDestinationAuthorizationEntry' type='xs:string'/>
+      <xs:attribute name='tempSearchBase' type='xs:string'/>
+      <xs:attribute name='topicSearchBase' type='xs:string'/>
+      <xs:attribute name='userNameAttribute' type='xs:string'/>
+      <xs:attribute name='userObjectClass' type='xs:string'/>
+      <xs:attribute name='writePermissionGroupSearchFilter' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.util.CommandAgent -->
+  <xs:element name='commandAgent'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An agent which listens to commands on a JMS destination
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='commandDestination' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='connection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='connectionFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:connectionFactory'/>
+              <xs:element ref='tns:xaConnectionFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerUrl' type='xs:string'/>
+      <xs:attribute name='commandDestination' type='xs:string'/>
+      <xs:attribute name='connection' type='xs:string'/>
+      <xs:attribute name='connectionFactory' type='xs:string'/>
+      <xs:attribute name='password' type='xs:string'/>
+      <xs:attribute name='username' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.CompositeDemandForwardingBridge -->
+  <xs:element name='compositeDemandForwardingBridge'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A demand forwarding bridge which works with multicast style transports where
+a single Transport could be communicating with multiple remote brokers
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='configuration' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:ldapNetworkConnector'/>
+              <xs:element ref='tns:multicastNetworkConnector'/>
+              <xs:element ref='tns:networkConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='localBroker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='networkBridgeListener' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='remoteBroker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='configuration' type='xs:string'/>
+      <xs:attribute name='createdByDuplex' type='xs:boolean'/>
+      <xs:attribute name='localBroker' type='xs:string'/>
+      <xs:attribute name='mbeanObjectName' type='xs:string'/>
+      <xs:attribute name='networkBridgeListener' type='xs:string'/>
+      <xs:attribute name='remoteBroker' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.virtual.CompositeQueue -->
+  <xs:element name='compositeQueue'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents a virtual queue which forwards to a number of other destinations.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='forwardTo' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the list of destinations to forward to
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='copyMessage' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether a copy of the message will be sent to each destination.
+Defaults to true so that the forward destination is set as the
+destination of the message
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='forwardOnly' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets if the virtual destination is forward only (and so there is no
+physical queue to match the virtual queue) or if there is also a physical
+queue with the same name).
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='name' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the name of this composite destination
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.virtual.CompositeTopic -->
+  <xs:element name='compositeTopic'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents a virtual topic which forwards to a number of other destinations.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='forwardTo' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the list of destinations to forward to
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='copyMessage' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether a copy of the message will be sent to each destination.
+Defaults to true so that the forward destination is set as the
+destination of the message
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='forwardOnly' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets if the virtual destination is forward only (and so there is no
+physical queue to match the virtual queue) or if there is also a physical
+queue with the same name).
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='name' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the name of this composite destination
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.ConditionalNetworkBridgeFilterFactory -->
+  <xs:element name='conditionalNetworkBridgeFilterFactory'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        implement conditional behaviour for queue consumers,
+allows replaying back to origin if no consumers are present on the local broker
+after a configurable delay, irrespective of the networkTTL
+Also allows rate limiting of messages through the network, useful for static includes
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='rateDuration' type='xs:integer'/>
+      <xs:attribute name='rateLimit' type='xs:integer'/>
+      <xs:attribute name='replayDelay' type='xs:integer'/>
+      <xs:attribute name='replayWhenNoConsumers' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.view.ConnectionDotFilePlugin -->
+  <xs:element name='connectionDotFilePlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A <a href="http://www.graphviz.org/">DOT</a> file creator plugin which
+creates a DOT file showing the current connections
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='file' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the destination file name to create the destination diagram
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.spring.ActiveMQConnectionFactory -->
+  <xs:element name='connectionFactory'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A <a href="http://www.springframework.org/">Spring</a> enhanced connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='blobTransferPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the policy used to describe how out-of-band BLOBs (Binary Large
+OBjects) are transferred from producers to brokers to consumers
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='clientIdGenerator' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='clientInternalExceptionListener' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='connectionIdGenerator' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='exceptionListener' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:commandAgent'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='prefetchPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the <a
+href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
+policy</a> for consumers created by this connection.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:prefetchPolicy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Get the properties from this instance for storing in JNDI
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='redeliveryPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the global default redelivery policy to be used when a message is delivered
+but the session is rolled back
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:redeliveryPolicy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='redeliveryPolicyMap' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the global redelivery policy mapping to be used when a message is delivered
+but the session is rolled back
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:redeliveryPolicyMap'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='rejectedTaskHandler' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='sessionTaskRunner' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='transformer' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the transformer used to transform messages before they are sent on
+to the JMS bus or when they are received from the bus but before they are
+delivered to the JMS client
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='transportListener' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Allows a listener to be configured on the ConnectionFactory so that when this factory is used
+with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
+a transport listener.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='alwaysSessionAsync' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            If this flag is not set then a separate thread is not used for dispatching messages for each Session in
+the Connection. However, a separate thread is always used if there is more than one session, or the session
+isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
+happens asynchronously.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='alwaysSyncSend' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Set true if always require messages to be sync sent
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='auditDepth' type='xs:integer'/>
+      <xs:attribute name='auditMaximumProducerNumber' type='xs:integer'/>
+      <xs:attribute name='beanName' type='xs:string'/>
+      <xs:attribute name='blobTransferPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the policy used to describe how out-of-band BLOBs (Binary Large
+OBjects) are transferred from producers to brokers to consumers
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='brokerURL' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the <a
+href="http://activemq.apache.org/configuring-transports.html">connection
+URL</a> used to connect to the ActiveMQ broker.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='checkForDuplicates' type='xs:boolean'/>
+      <xs:attribute name='clientID' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JMS clientID to use for the created connection. Note that this
+can only be used by one connection at once so generally its a better idea
+to set the clientID on a Connection
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='clientIDPrefix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the prefix used by autogenerated JMS Client ID values which are used
+if the JMS client does not explicitly specify on.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='clientIdGenerator' type='xs:string'/>
+      <xs:attribute name='clientInternalExceptionListener' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='closeTimeout' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the timeout before a close is considered complete. Normally a
+close() on a connection waits for confirmation from the broker; this
+allows that operation to timeout to save the client hanging if there is
+no broker
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='connectionIDPrefix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the prefix used by connection id generator
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='connectionIdGenerator' type='xs:string'/>
+      <xs:attribute name='consumerFailoverRedeliveryWaitPeriod' type='xs:long'/>
+      <xs:attribute name='copyMessageOnSend' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Should a JMS message be copied to a new JMS Message object as part of the
+send() method in JMS. This is enabled by default to be compliant with the
+JMS specification. You can disable it if you do not mutate JMS messages
+after they are sent for a performance boost
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='disableTimeStampsByDefault' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not timestamps on messages should be disabled or not. If
+you disable them it adds a small performance boost.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='dispatchAsync' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables the default setting of whether or not consumers have
+their messages <a
+href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
+synchronously or asynchronously by the broker</a>. For non-durable
+topics for example we typically dispatch synchronously by default to
+minimize context switches which boost performance. However sometimes its
+better to go slower to ensure that a single blocked consumer socket does
+not block delivery to other consumers.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='exceptionListener' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='exclusiveConsumer' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables whether or not queue consumers should be exclusive or
+not for example to preserve ordering when not using <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a>
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maxThreadPoolSize' type='xs:integer'/>
+      <xs:attribute name='messagePrioritySupported' type='xs:boolean'/>
+      <xs:attribute name='nestedMapAndListEnabled' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables/disables whether or not Message properties and MapMessage entries
+support <a
+href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
+Structures</a> of Map and List objects
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='nonBlockingRedelivery' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When true a MessageConsumer will not stop Message delivery before re-delivering Messages
+from a rolled back transaction.  This implies that message order will not be preserved and
+also will result in the TransactedIndividualAck option to be enabled.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='objectMessageSerializationDefered' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When an object is set on an ObjectMessage, the JMS spec requires the
+object to be serialized by that set method. Enabling this flag causes the
+object to not get serialized. The object may subsequently get serialized
+if the message needs to be sent over a socket or stored to disk.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='optimizeAcknowledge' type='xs:boolean'/>
+      <xs:attribute name='optimizeAcknowledgeTimeOut' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            The max time in milliseconds between optimized ack batches
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='optimizedAckScheduledAckInterval' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
+to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
+will not do any background Message acknowledgment.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='optimizedMessageDispatch' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            If this flag is set then an larger prefetch limit is used - only
+applicable for durable topic subscribers.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='password' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JMS password used for connections created from this factory
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='prefetchPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the <a
+href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
+policy</a> for consumers created by this connection.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='producerWindowSize' type='xs:integer'/>
+      <xs:attribute name='properties' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the properties from this instance for storing in JNDI
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='redeliveryPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the global default redelivery policy to be used when a message is delivered
+but the session is rolled back
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='redeliveryPolicyMap' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the global redelivery policy mapping to be used when a message is delivered
+but the session is rolled back
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='rejectedTaskHandler' type='xs:string'/>
+      <xs:attribute name='sendAcksAsync' type='xs:boolean'/>
+      <xs:attribute name='sendTimeout' type='xs:integer'/>
+      <xs:attribute name='sessionTaskRunner' type='xs:string'/>
+      <xs:attribute name='statsEnabled' type='xs:boolean'/>
+      <xs:attribute name='transactedIndividualAck' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            when true, submit individual transacted acks immediately rather than with transaction completion.
+This allows the acks to represent delivery status which can be persisted on rollback
+Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='transformer' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the transformer used to transform messages before they are sent on
+to the JMS bus or when they are received from the bus but before they are
+delivered to the JMS client
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='transportListener' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Allows a listener to be configured on the ConnectionFactory so that when this factory is used
+with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
+a transport listener.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useAsyncSend' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Forces the use of <a
+href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
+adds a massive performance boost; but means that the send() method will
+return immediately whether the message has been sent or not which could
+lead to message loss.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useBeanNameAsClientIdPrefix' type='xs:boolean'/>
+      <xs:attribute name='useCompression' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables the use of compression of the message bodies
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
+      <xs:attribute name='useRetroactiveConsumer' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not retroactive consumers are enabled. Retroactive
+consumers allow non-durable topic subscribers to receive old messages
+that were published before the non-durable subscriber started.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='userName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JMS userName used by connections created by this factory
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='warnAboutUnstartedConnectionTimeout' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables the timeout from a connection creation to when a warning is
+generated if the connection is not properly started via
+{@link Connection#start()} and a message is received by a consumer. It is
+a very common gotcha to forget to <a
+href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
+the connection</a> so this option makes the default case to create a
+warning if the user forgets. To disable the warning just set the value to <
+0 (say -1).
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='watchTopicAdvisories' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.ConstantPendingMessageLimitStrategy -->
+  <xs:element name='constantPendingMessageLimitStrategy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This PendingMessageLimitStrategy is configured to a constant value for all subscriptions.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='limit' type='xs:integer'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.DefaultDatabaseLocker -->
+  <xs:element name='database-locker'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='exceptionHandler' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='exceptionHandler' type='xs:string'/>
+      <xs:attribute name='failIfLocked' type='xs:boolean'/>
+      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='queryTimeout' type='xs:integer'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.DB2JDBCAdapter -->
+  <xs:element name='db2JDBCAdapter'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.util.DefaultIOExceptionHandler -->
+  <xs:element name='defaultIOExceptionHandler'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='ignoreAllErrors' type='xs:boolean'/>
+      <xs:attribute name='ignoreNoSpaceErrors' type='xs:boolean'/>
+      <xs:attribute name='ignoreSQLExceptions' type='xs:boolean'/>
+      <xs:attribute name='noSpaceMessage' type='xs:string'/>
+      <xs:attribute name='resumeCheckSleepPeriod' type='xs:long'/>
+      <xs:attribute name='sqlExceptionMessage' type='xs:string'/>
+      <xs:attribute name='stopStartConnectors' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter -->
+  <xs:element name='defaultJDBCAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Implements all the default JDBC operations that are used by the JDBCPersistenceAdapter. <p/> sub-classing is
+encouraged to override the default implementation of methods to account for differences in JDBC Driver
+implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using the getBytes()/setBytes() operations. <p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.DefaultNetworkBridgeFilterFactory -->
+  <xs:element name='defaultNetworkBridgeFilterFactory'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        implement default behaviour, filter that will not allow resend to origin
+based on brokerPath and which respects networkTTL
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.usage.DefaultUsageCapacity -->
+  <xs:element name='defaultUsageCapacity'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Identify if a limit has been reached
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='limit' type='xs:long'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.DemandForwardingBridge -->
+  <xs:element name='demandForwardingBridge'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Forwards messages from the local broker to the remote broker based on demand.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='configuration' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:ldapNetworkConnector'/>
+              <xs:element ref='tns:multicastNetworkConnector'/>
+              <xs:element ref='tns:networkConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='localBroker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='networkBridgeListener' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='remoteBroker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='configuration' type='xs:string'/>
+      <xs:attribute name='createdByDuplex' type='xs:boolean'/>
+      <xs:attribute name='localBroker' type='xs:string'/>
+      <xs:attribute name='mbeanObjectName' type='xs:string'/>
+      <xs:attribute name='networkBridgeListener' type='xs:string'/>
+      <xs:attribute name='remoteBroker' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.view.DestinationDotFilePlugin -->
+  <xs:element name='destinationDotFilePlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A <a href="http://www.graphviz.org/">DOT</a> 
+file creator plugin which creates a DOT file showing the current topic & queue hierarchies.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='file' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the destination file name to create the destination diagram
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.filter.DefaultDestinationMapEntry -->
+  <xs:element name='destinationEntry'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A default entry in a DestinationMap which holds a single value.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='value' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:authorizationEntry'/>
+              <xs:element ref='tns:destinationEntry'/>
+              <xs:element ref='tns:filteredKahaDB'/>
+              <xs:element ref='tns:policyEntry'/>
+              <xs:element ref='tns:redeliveryPolicy'/>
+              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='queue' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='tempQueue' type='xs:boolean'/>
+      <xs:attribute name='tempTopic' type='xs:boolean'/>
+      <xs:attribute name='topic' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='value' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.util.DestinationPathSeparatorBroker -->
+  <xs:element name='destinationPathSeparatorPlugin'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='next' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminConnectionContext' type='xs:string'/>
+      <xs:attribute name='next' type='xs:string'/>
+      <xs:attribute name='pathSeparator' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.plugin.DiscardingDLQBrokerPlugin -->
+  <xs:element name='discardingDLQBrokerPlugin'>
+    <xs:complexType>
+      <xs:attribute name='dropAll' type='xs:boolean'/>
+      <xs:attribute name='dropOnly' type='xs:string'/>
+      <xs:attribute name='dropTemporaryQueues' type='xs:boolean'/>
+      <xs:attribute name='dropTemporaryTopics' type='xs:boolean'/>
+      <xs:attribute name='reportInterval' type='xs:integer'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.FilePendingSubscriberMessageStoragePolicy -->
+  <xs:element name='fileCursor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Pending messages
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.FilePendingDurableSubscriberMessageStoragePolicy -->
+  <xs:element name='fileDurableSubscriberCursor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Pending messages for durable subscribers
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.FilePendingQueueMessageStoragePolicy -->
+  <xs:element name='fileQueueCursor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Pending
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.virtual.FilteredDestination -->
+  <xs:element name='filteredDestination'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents a destination which is filtered using some predicate such as a selector
+so that messages are only dispatched to the destination if they match the filter.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              The destination to send messages to if they match the filter
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='filter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='destination' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            The destination to send messages to if they match the filter
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='filter' type='xs:string'/>
+      <xs:attribute name='queue' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the destination property to the given queue name
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='selector' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JMS selector used to filter messages before forwarding them to this destination
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='topic' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the destination property to the given topic name
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.kahadb.FilteredKahaDBPersistenceAdapter -->
+  <xs:element name='filteredKahaDB'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='persistenceAdapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adapter' type='xs:string'/>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='perDestination' type='xs:boolean'/>
+      <xs:attribute name='persistenceAdapter' type='xs:string'/>
+      <xs:attribute name='queue' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='tempQueue' type='xs:boolean'/>
+      <xs:attribute name='tempTopic' type='xs:boolean'/>
+      <xs:attribute name='topic' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy -->
+  <xs:element name='fixedCountSubscriptionRecoveryPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+count of last messages.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='broker' type='xs:string'/>
+      <xs:attribute name='maximumSize' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the maximum number of messages that this destination will hold
+around in RAM
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.FixedSizedSubscriptionRecoveryPolicy -->
+  <xs:element name='fixedSizedSubscriptionRecoveryPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+amount of memory available in RAM for message history which is evicted in
+time order.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='buffer' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='broker' type='xs:string'/>
+      <xs:attribute name='buffer' type='xs:string'/>
+      <xs:attribute name='maximumSize' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the maximum amount of RAM in bytes that this buffer can hold in RAM
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useSharedBuffer' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.plugin.ForcePersistencyModeBroker -->
+  <xs:element name='forcePersistencyModeBroker'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='next' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminConnectionContext' type='xs:string'/>
+      <xs:attribute name='next' type='xs:string'/>
+      <xs:attribute name='persistenceFlag' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.plugin.ForcePersistencyModeBrokerPlugin -->
+  <xs:element name='forcePersistencyModeBrokerPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='persistenceFlag' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the persistency mode.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.ForwardingBridge -->
+  <xs:element name='forwardingBridge'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Forwards all messages from the local broker to the remote broker.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='localBroker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='networkBridgeFailedListener' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='remoteBroker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='clientId' type='xs:string'/>
+      <xs:attribute name='destinationFilter' type='xs:string'/>
+      <xs:attribute name='dispatchAsync' type='xs:boolean'/>
+      <xs:attribute name='localBroker' type='xs:string'/>
+      <xs:attribute name='networkBridgeFailedListener' type='xs:string'/>
+      <xs:attribute name='prefetchSize' type='xs:integer'/>
+      <xs:attribute name='remoteBroker' type='xs:string'/>
+      <xs:attribute name='useCompression' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.HsqldbJDBCAdapter -->
+  <xs:element name='hsqldb-jdbc-adapter'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.ImageBasedJDBCAdaptor -->
+  <xs:element name='imageBasedJDBCAdaptor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Provides JDBCAdapter since that uses
+IMAGE datatype to hold binary data.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Sybase</li>
+<li>MS SQL</li>
+</ul>
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.jms.InboundQueueBridge -->
+  <xs:element name='inboundQueueBridge'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Create an Inbound Queue Bridge.  By default this class uses the sname name for
+both the inbound and outbound queue.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud queue names
+separately.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='consumer' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerQueue' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsConnector' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:jmsQueueConnector'/>
+              <xs:element ref='tns:jmsTopicConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsMessageConvertor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:simpleJmsMessageConvertor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerQueue' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='consumer' type='xs:string'/>
+      <xs:attribute name='consumerConnection' type='xs:string'/>
+      <xs:attribute name='consumerQueue' type='xs:string'/>
+      <xs:attribute name='doHandleReplyTo' type='xs:boolean'/>
+      <xs:attribute name='inboundQueueName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the queue name used for the inbound queue, if the outbound queue
+name has not been set, then this method uses the same name to configure
+the outbound queue name.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='jmsConnector' type='xs:string'/>
+      <xs:attribute name='jmsMessageConvertor' type='xs:string'/>
+      <xs:attribute name='localQueueName' type='xs:string'/>
+      <xs:attribute name='producerConnection' type='xs:string'/>
+      <xs:attribute name='producerQueue' type='xs:string'/>
+      <xs:attribute name='selector' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.jms.InboundTopicBridge -->
+  <xs:element name='inboundTopicBridge'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Create an Inbound Topic Bridge.  By default this class uses the topic name for
+both the inbound and outbound topic.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud topic names
+separately.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='consumer' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerTopic' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsConnector' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:jmsQueueConnector'/>
+              <xs:element ref='tns:jmsTopicConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsMessageConvertor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:simpleJmsMessageConvertor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerTopic' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='consumer' type='xs:string'/>
+      <xs:attribute name='consumerConnection' type='xs:string'/>
+      <xs:attribute name='consumerName' type='xs:string'/>
+      <xs:attribute name='consumerTopic' type='xs:string'/>
+      <xs:attribute name='doHandleReplyTo' type='xs:boolean'/>
+      <xs:attribute name='inboundTopicName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the topic name used for the inbound topic, if the outbound topic
+name has not been set, then this method uses the same name to configure
+the outbound topic name.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='jmsConnector' type='xs:string'/>
+      <xs:attribute name='jmsMessageConvertor' type='xs:string'/>
+      <xs:attribute name='localTopicName' type='xs:string'/>
+      <xs:attribute name='producerConnection' type='xs:string'/>
+      <xs:attribute name='producerTopic' type='xs:string'/>
+      <xs:attribute name='selector' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.IndividualDeadLetterStrategy -->
+  <xs:element name='individualDeadLetterStrategy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A {@link DeadLetterStrategy} where each destination has its own individual
+DLQ using the subject naming hierarchy.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='destinationPerDurableSubscriber' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            sets whether durable topic subscriptions are to get individual dead letter destinations.
+When true, the DLQ is of the form 'topicPrefix.clientId:subscriptionName'
+The default is false.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='enableAudit' type='xs:boolean'/>
+      <xs:attribute name='processExpired' type='xs:boolean'/>
+      <xs:attribute name='processNonPersistent' type='xs:boolean'/>
+      <xs:attribute name='queuePrefix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the prefix to use for all dead letter queues for queue messages
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='queueSuffix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the suffix to use for all dead letter queues for queue messages
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='topicPrefix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the prefix to use for all dead letter queues for topic messages
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='topicSuffix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the suffix to use for all dead letter queues for topic messages
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useQueueForQueueMessages' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether a queue or topic should be used for queue messages sent to a
+DLQ. The default is to use a Queue
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useQueueForTopicMessages' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether a queue or topic should be used for topic messages sent to a
+DLQ. The default is to use a Queue
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.InformixJDBCAdapter -->
+  <xs:element name='informixJDBCAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        JDBC Adapter for Informix database.
+Because Informix database restricts length of composite primary keys, length of 
+<i>container name</i> field and <i>subscription id</i> field must be reduced to 150 characters.
+Therefore be sure not to use longer names for container name and subscription id than 150 characters.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.JDBCIOExceptionHandler -->
+  <xs:element name='jDBCIOExceptionHandler'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='ignoreAllErrors' type='xs:boolean'/>
+      <xs:attribute name='ignoreNoSpaceErrors' type='xs:boolean'/>
+      <xs:attribute name='ignoreSQLExceptions' type='xs:boolean'/>
+      <xs:attribute name='noSpaceMessage' type='xs:string'/>
+      <xs:attribute name='resumeCheckSleepPeriod' type='xs:long'/>
+      <xs:attribute name='sqlExceptionMessage' type='xs:string'/>
+      <xs:attribute name='stopStartConnectors' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.JaasAuthenticationPlugin -->
+  <xs:element name='jaasAuthenticationPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Provides a JAAS based authentication plugin
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='configuration' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JAAS configuration domain name used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='discoverLoginConfig' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
+This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
+is not defined then it is set to the location of the <b>login.config</b> file on the classpath.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.JaasCertificateAuthenticationPlugin -->
+  <xs:element name='jaasCertificateAuthenticationPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Provides a JAAS based SSL certificate authentication plugin
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='configuration' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JAAS configuration domain name used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='discoverLoginConfig' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
+This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
+is not defined then it is set to the location of the <b>login.config</b> file on the classpath.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.JaasDualAuthenticationPlugin -->
+  <xs:element name='jaasDualAuthenticationPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Provides a JAAS based authentication plugin
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='configuration' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JAAS configuration domain name used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='discoverLoginConfig' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
+This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
+is not defined then it is set to the location of the <b>login.config</b> file on the classpath.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='sslConfiguration' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Set the JAAS SSL configuration domain
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.JDBCPersistenceAdapter -->
+  <xs:element name='jdbcPersistenceAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A {@link PersistenceAdapter} implementation using JDBC for persistence
+storage.
+
+This persistence adapter will correctly remember prepared XA transactions,
+but it will not keep track of local transaction commits so that operations
+performed against the Message store are done as a single uow.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:axionJDBCAdapter'/>
+              <xs:element ref='tns:blobJDBCAdapter'/>
+              <xs:element ref='tns:bytesJDBCAdapter'/>
+              <xs:element ref='tns:db2JDBCAdapter'/>
+              <xs:element ref='tns:defaultJDBCAdapter'/>
+              <xs:element ref='tns:hsqldb-jdbc-adapter'/>
+              <xs:element ref='tns:imageBasedJDBCAdaptor'/>
+              <xs:element ref='tns:informixJDBCAdapter'/>
+              <xs:element ref='tns:maxdb-jdbc-adapter'/>
+              <xs:element ref='tns:mysql-jdbc-adapter'/>
+              <xs:element ref='tns:oracleBlobJDBCAdapter'/>
+              <xs:element ref='tns:oracleJDBCAdapter'/>
+              <xs:element ref='tns:postgresql-jdbc-adapter'/>
+              <xs:element ref='tns:streamJDBCAdapter'/>
+              <xs:element ref='tns:sybase-jdbc-adapter'/>
+              <xs:element ref='tns:transact-jdbc-adapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dataSource' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='databaseLocker' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the database locker strategy to use to lock the database on startup
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:database-locker'/>
+              <xs:element ref='tns:lease-database-locker'/>
+              <xs:element ref='tns:shared-file-locker'/>
+              <xs:element ref='tns:transact-database-locker'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='ds' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='lockDataSource' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:database-locker'/>
+              <xs:element ref='tns:lease-database-locker'/>
+              <xs:element ref='tns:shared-file-locker'/>
+              <xs:element ref='tns:transact-database-locker'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='scheduledThreadPoolExecutor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='wireFormat' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adapter' type='xs:string'/>
+      <xs:attribute name='auditRecoveryDepth' type='xs:integer'/>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='cleanupPeriod' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the number of milliseconds until the database is attempted to be
+cleaned up for durable topics
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='createTablesOnStartup' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not tables are created on startup
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='dataDirectory' type='xs:string'/>
+      <xs:attribute name='dataDirectoryFile' type='xs:string'/>
+      <xs:attribute name='dataSource' type='xs:string'/>
+      <xs:attribute name='databaseLocker' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the database locker strategy to use to lock the database on startup
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='directory' type='xs:string'/>
+      <xs:attribute name='ds' type='xs:string'/>
+      <xs:attribute name='enableAudit' type='xs:boolean'/>
+      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
+      <xs:attribute name='lockDataSource' type='xs:string'/>
+      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
+      <xs:attribute name='locker' type='xs:string'/>
+      <xs:attribute name='maxAuditDepth' type='xs:integer'/>
+      <xs:attribute name='maxProducersToAudit' type='xs:integer'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='scheduledThreadPoolExecutor' type='xs:string'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='transactionIsolation' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            set the Transaction isolation level to something other that TRANSACTION_READ_UNCOMMITTED
+This allowable dirty isolation level may not be achievable in clustered DB environments
+so a more restrictive and expensive option may be needed like TRANSACTION_REPEATABLE_READ
+see isolation level constants in {@link java.sql.Connection}
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='usageManager' type='xs:string'/>
+      <xs:attribute name='useDatabaseLock' type='xs:boolean'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='useLock' type='xs:boolean'/>
+      <xs:attribute name='wireFormat' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.jms.JmsQueueConnector -->
+  <xs:element name='jmsQueueConnector'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A Bridge to other JMS Queue providers
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              One way to configure the local connection - this is called by The
+BrokerService when the Connector is embedded
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='inboundMessageConvertor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:simpleJmsMessageConvertor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='inboundQueueBridges' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:inboundQueueBridge'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='localQueueConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='localQueueConnectionFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:connectionFactory'/>
+              <xs:element ref='tns:xaConnectionFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='outboundMessageConvertor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:simpleJmsMessageConvertor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='outboundQueueBridges' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:outboundQueueBridge'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='outboundQueueConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='outboundQueueConnectionFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:connectionFactory'/>
+              <xs:element ref='tns:xaConnectionFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='reconnectionPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:reconnectionPolicy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerService' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            One way to configure the local connection - this is called by The
+BrokerService when the Connector is embedded
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='inboundMessageConvertor' type='xs:string'/>
+      <xs:attribute name='jndiLocalTemplate' type='xs:string'/>
+      <xs:attribute name='jndiOutboundTemplate' type='xs:string'/>
+      <xs:attribute name='localClientId' type='xs:string'/>
+      <xs:attribute name='localConnectionFactoryName' type='xs:string'/>
+      <xs:attribute name='localPassword' type='xs:string'/>
+      <xs:attribute name='localQueueConnection' type='xs:string'/>
+      <xs:attribute name='localQueueConnectionFactory' type='xs:string'/>
+      <xs:attribute name='localUsername' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='outboundClientId' type='xs:string'/>
+      <xs:attribute name='outboundMessageConvertor' type='xs:string'/>
+      <xs:attribute name='outboundPassword' type='xs:string'/>
+      <xs:attribute name='outboundQueueConnection' type='xs:string'/>
+      <xs:attribute name='outboundQueueConnectionFactory' type='xs:string'/>
+      <xs:attribute name='outboundQueueConnectionFactoryName' type='xs:string'/>
+      <xs:attribute name='outboundUsername' type='xs:string'/>
+      <xs:attribute name='preferJndiDestinationLookup' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether the connector should prefer to first try to find a destination in JNDI before
+using JMS semantics to create a Destination.  By default the connector will first use JMS
+semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
+ordering.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='reconnectionPolicy' type='xs:string'/>
+      <xs:attribute name='replyToDestinationCacheSize' type='xs:integer'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.jms.JmsTopicConnector -->
+  <xs:element name='jmsTopicConnector'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A Bridge to other JMS Topic providers
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              One way to configure the local connection - this is called by The
+BrokerService when the Connector is embedded
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='inboundMessageConvertor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:simpleJmsMessageConvertor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='inboundTopicBridges' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:inboundTopicBridge'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='localTopicConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='localTopicConnectionFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:connectionFactory'/>
+              <xs:element ref='tns:xaConnectionFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='outboundMessageConvertor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:simpleJmsMessageConvertor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='outboundTopicBridges' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:outboundTopicBridge'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='outboundTopicConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='outboundTopicConnectionFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:connectionFactory'/>
+              <xs:element ref='tns:xaConnectionFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='reconnectionPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:reconnectionPolicy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerService' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            One way to configure the local connection - this is called by The
+BrokerService when the Connector is embedded
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='inboundMessageConvertor' type='xs:string'/>
+      <xs:attribute name='jndiLocalTemplate' type='xs:string'/>
+      <xs:attribute name='jndiOutboundTemplate' type='xs:string'/>
+      <xs:attribute name='localClientId' type='xs:string'/>
+      <xs:attribute name='localConnectionFactoryName' type='xs:string'/>
+      <xs:attribute name='localPassword' type='xs:string'/>
+      <xs:attribute name='localTopicConnection' type='xs:string'/>
+      <xs:attribute name='localTopicConnectionFactory' type='xs:string'/>
+      <xs:attribute name='localUsername' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='outboundClientId' type='xs:string'/>
+      <xs:attribute name='outboundMessageConvertor' type='xs:string'/>
+      <xs:attribute name='outboundPassword' type='xs:string'/>
+      <xs:attribute name='outboundTopicConnection' type='xs:string'/>
+      <xs:attribute name='outboundTopicConnectionFactory' type='xs:string'/>
+      <xs:attribute name='outboundTopicConnectionFactoryName' type='xs:string'/>
+      <xs:attribute name='outboundUsername' type='xs:string'/>
+      <xs:attribute name='preferJndiDestinationLookup' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether the connector should prefer to first try to find a destination in JNDI before
+using JMS semantics to create a Destination.  By default the connector will first use JMS
+semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
+ordering.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='reconnectionPolicy' type='xs:string'/>
+      <xs:attribute name='replyToDestinationCacheSize' type='xs:integer'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.journal.JournalPersistenceAdapter -->
+  <xs:element name='journalPersistenceAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='journal' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='longTermPersistence' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:amqPersistenceAdapter'/>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:element ref='tns:journalPersistenceAdapter'/>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:element ref='tns:kahaPersistenceAdapter'/>
+              <xs:element ref='tns:levelDB'/>
+              <xs:element ref='tns:mKahaDB'/>
+              <xs:element ref='tns:memoryPersistenceAdapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='persistenceAdapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:amqPersistenceAdapter'/>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:element ref='tns:journalPersistenceAdapter'/>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:element ref='tns:kahaPersistenceAdapter'/>
+              <xs:element ref='tns:levelDB'/>
+              <xs:element ref='tns:mKahaDB'/>
+              <xs:element ref='tns:memoryPersistenceAdapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='directory' type='xs:string'/>
+      <xs:attribute name='journal' type='xs:string'/>
+      <xs:attribute name='longTermPersistence' type='xs:string'/>
+      <xs:attribute name='maxCheckpointMessageAddSize' type='xs:integer'/>
+      <xs:attribute name='maxCheckpointWorkers' type='xs:integer'/>
+      <xs:attribute name='persistenceAdapter' type='xs:string'/>
+      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='usageManager' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.journal.JournalPersistenceAdapterFactory -->
+  <xs:element name='journalPersistenceAdapterFactory'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Factory class that can create PersistenceAdapter objects.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:axionJDBCAdapter'/>
+              <xs:element ref='tns:blobJDBCAdapter'/>
+              <xs:element ref='tns:bytesJDBCAdapter'/>
+              <xs:element ref='tns:db2JDBCAdapter'/>
+              <xs:element ref='tns:defaultJDBCAdapter'/>
+              <xs:element ref='tns:hsqldb-jdbc-adapter'/>
+              <xs:element ref='tns:imageBasedJDBCAdaptor'/>
+              <xs:element ref='tns:informixJDBCAdapter'/>
+              <xs:element ref='tns:maxdb-jdbc-adapter'/>
+              <xs:element ref='tns:mysql-jdbc-adapter'/>
+              <xs:element ref='tns:oracleBlobJDBCAdapter'/>
+              <xs:element ref='tns:oracleJDBCAdapter'/>
+              <xs:element ref='tns:postgresql-jdbc-adapter'/>
+              <xs:element ref='tns:streamJDBCAdapter'/>
+              <xs:element ref='tns:sybase-jdbc-adapter'/>
+              <xs:element ref='tns:transact-jdbc-adapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dataSource' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jdbcAdapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='journal' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:database-locker'/>
+              <xs:element ref='tns:lease-database-locker'/>
+              <xs:element ref='tns:shared-file-locker'/>
+              <xs:element ref='tns:transact-database-locker'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adapter' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='createTablesOnStartup' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not tables are created on startup
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='dataDirectory' type='xs:string'/>
+      <xs:attribute name='dataDirectoryFile' type='xs:string'/>
+      <xs:attribute name='dataSource' type='xs:string'/>
+      <xs:attribute name='jdbcAdapter' type='xs:string'/>
+      <xs:attribute name='journal' type='xs:string'/>
+      <xs:attribute name='journalArchiveDirectory' type='xs:string'/>
+      <xs:attribute name='journalLogFileSize' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the size of the journal log files
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='journalLogFiles' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the number of journal log files to use
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='journalThreadPriority' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the thread priority of the journal thread
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
+      <xs:attribute name='locker' type='xs:string'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='useDatabaseLock' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not an exclusive database lock should be used to enable
+JDBC Master/Slave. Enabled by default.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
+      <xs:attribute name='useJournal' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables the use of the journal. The default is to use the
+journal
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useLock' type='xs:boolean'/>
+      <xs:attribute name='useQuickJournal' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables the use of quick journal, which keeps messages in the
+journal and just stores a reference to the messages in JDBC. Defaults to
+false so that messages actually reside long term in the JDBC database.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.PersistenceAdapterFactoryBean -->
+  <xs:element name='journaledJDBC'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Creates a default persistence model using the Journal and JDBC
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:axionJDBCAdapter'/>
+              <xs:element ref='tns:blobJDBCAdapter'/>
+              <xs:element ref='tns:bytesJDBCAdapter'/>
+              <xs:element ref='tns:db2JDBCAdapter'/>
+              <xs:element ref='tns:defaultJDBCAdapter'/>
+              <xs:element ref='tns:hsqldb-jdbc-adapter'/>
+              <xs:element ref='tns:imageBasedJDBCAdaptor'/>
+              <xs:element ref='tns:informixJDBCAdapter'/>
+              <xs:element ref='tns:maxdb-jdbc-adapter'/>
+              <xs:element ref='tns:mysql-jdbc-adapter'/>
+              <xs:element ref='tns:oracleBlobJDBCAdapter'/>
+              <xs:element ref='tns:oracleJDBCAdapter'/>
+              <xs:element ref='tns:postgresql-jdbc-adapter'/>
+              <xs:element ref='tns:streamJDBCAdapter'/>
+              <xs:element ref='tns:sybase-jdbc-adapter'/>
+              <xs:element ref='tns:transact-jdbc-adapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dataSource' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jdbcAdapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='journal' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:database-locker'/>
+              <xs:element ref='tns:lease-database-locker'/>
+              <xs:element ref='tns:shared-file-locker'/>
+              <xs:element ref='tns:transact-database-locker'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adapter' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='createTablesOnStartup' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not tables are created on startup
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='dataDirectory' type='xs:string'/>
+      <xs:attribute name='dataDirectoryFile' type='xs:string'/>
+      <xs:attribute name='dataSource' type='xs:string'/>
+      <xs:attribute name='jdbcAdapter' type='xs:string'/>
+      <xs:attribute name='journal' type='xs:string'/>
+      <xs:attribute name='journalArchiveDirectory' type='xs:string'/>
+      <xs:attribute name='journalLogFileSize' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the size of the journal log files
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='journalLogFiles' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the number of journal log files to use
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='journalThreadPriority' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the thread priority of the journal thread
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
+      <xs:attribute name='locker' type='xs:string'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='useDatabaseLock' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not an exclusive database lock should be used to enable
+JDBC Master/Slave. Enabled by default.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
+      <xs:attribute name='useJournal' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables the use of the journal. The default is to use the
+journal
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useLock' type='xs:boolean'/>
+      <xs:attribute name='useQuickJournal' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables the use of quick journal, which keeps messages in the
+journal and just stores a reference to the messages in JDBC. Defaults to
+false so that messages actually reside long term in the JDBC database.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter -->
+  <xs:element name='kahaDB'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An implementation of {@link PersistenceAdapter} designed for use with
+KahaDB - Embedded Lightweight Non-Relational Database
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:database-locker'/>
+              <xs:element ref='tns:lease-database-locker'/>
+              <xs:element ref='tns:shared-file-locker'/>
+              <xs:element ref='tns:transact-database-locker'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='archiveCorruptedIndex' type='xs:boolean'/>
+      <xs:attribute name='archiveDataLogs' type='xs:boolean'/>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='checkForCorruptJournalFiles' type='xs:boolean'/>
+      <xs:attribute name='checkpointInterval' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the checkpointInterval
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='checksumJournalFiles' type='xs:boolean'/>
+      <xs:attribute name='cleanupInterval' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the cleanupInterval
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='concurrentStoreAndDispatchQueues' type='xs:boolean'/>
+      <xs:attribute name='concurrentStoreAndDispatchTopics' type='xs:boolean'/>
+      <xs:attribute name='databaseLockedWaitDelay' type='xs:integer'/>
+      <xs:attribute name='directory' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the directory
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='directoryArchive' type='xs:string'/>
+      <xs:attribute name='enableIndexDiskSyncs' type='xs:boolean'/>
+      <xs:attribute name='enableIndexPageCaching' type='xs:boolean'/>
+      <xs:attribute name='enableIndexRecoveryFile' type='xs:boolean'/>
+      <xs:attribute name='enableIndexWriteAsync' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the enableIndexWriteAsync
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='enableJournalDiskSyncs' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the enableJournalDiskSyncs
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='failoverProducersAuditDepth' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            set the audit window depth for duplicate suppression (should exceed the max transaction
+batch)
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='forceRecoverIndex' type='xs:boolean'/>
+      <xs:attribute name='ignoreMissingJournalfiles' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the ignoreMissingJournalfiles
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='indexCacheSize' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the indexCacheSize
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='indexLFUEvictionFactor' type='xs:float'/>
+      <xs:attribute name='indexWriteBatchSize' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the indexWriteBatchSize
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='journalMaxFileLength' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the journalMaxFileLength
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='journalMaxWriteBatchSize' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the journalMaxWriteBatchSize
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
+      <xs:attribute name='locker' type='xs:string'/>
+      <xs:attribute name='maxAsyncJobs' type='xs:integer'/>
+      <xs:attribute name='maxFailoverProducersToTrack' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Set the max number of producers (LRU cache) to track for duplicate sends
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='rewriteOnRedelivery' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When true, persist the redelivery status such that the message redelivery flag can survive a broker failure
+used with org.apache.activemq.ActiveMQConnectionFactory#setTransactedIndividualAck(boolean)  true
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='usageManager' type='xs:string'/>
+      <xs:attribute name='useIndexLFRUEviction' type='xs:boolean'/>
+      <xs:attribute name='useLock' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.kahadaptor.KahaPersistenceAdapter -->
+  <xs:element name='kahaPersistenceAdapter'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='size' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='directory' type='xs:string'/>
+      <xs:attribute name='maxDataFileLength' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='persistentIndex' type='xs:boolean'/>
+      <xs:attribute name='size' type='xs:string'/>
+      <xs:attribute name='usageManager' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.LDAPAuthorizationMap -->
+  <xs:element name='lDAPAuthorizationMap'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An {@link AuthorizationMap} which uses LDAP
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='context' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='options' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='queueSearchMatchingFormat' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='topicSearchMatchingFormat' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminAttribute' type='xs:string'/>
+      <xs:attribute name='adminBase' type='xs:string'/>
+      <xs:attribute name='advisorySearchBase' type='xs:string'/>
+      <xs:attribute name='authentication' type='xs:string'/>
+      <xs:attribute name='connectionPassword' type='xs:string'/>
+      <xs:attribute name='connectionProtocol' type='xs:string'/>
+      <xs:attribute name='connectionURL' type='xs:string'/>
+      <xs:attribute name='connectionUsername' type='xs:string'/>
+      <xs:attribute name='context' type='xs:string'/>
+      <xs:attribute name='initialContextFactory' type='xs:string'/>
+      <xs:attribute name='options' type='xs:string'/>
+      <xs:attribute name='queueSearchMatchingFormat' type='xs:string'/>
+      <xs:attribute name='queueSearchSubtreeBool' type='xs:boolean'/>
+      <xs:attribute name='readAttribute' type='xs:string'/>
+      <xs:attribute name='readBase' type='xs:string'/>
+      <xs:attribute name='tempSearchBase' type='xs:string'/>
+      <xs:attribute name='topicSearchMatchingFormat' type='xs:string'/>
+      <xs:attribute name='topicSearchSubtreeBool' type='xs:boolean'/>
+      <xs:attribute name='useAdvisorySearchBase' type='xs:boolean'/>
+      <xs:attribute name='writeAttribute' type='xs:string'/>
+      <xs:attribute name='writeBase' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy -->
+  <xs:element name='lastImageSubscriptionRecoveryPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This implementation of {@link SubscriptionRecoveryPolicy} will only keep the
+last message.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='broker' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.LdapNetworkConnector -->
+  <xs:element name='ldapNetworkConnector'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        class to create dynamic network connectors listed in an directory
+server using the LDAP v3 protocol as defined in RFC 2251, the
+entries listed in the directory server must implement the ipHost
+and ipService objectClasses as defined in RFC 2307.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='connectionFilter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='alwaysSyncSend' type='xs:boolean'/>
+      <xs:attribute name='anonymousAuthentication' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            sets LDAP anonymous authentication access credentials
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='base' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            sets the base LDAP dn used for lookup operations
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='bridgeTempDestinations' type='xs:boolean'/>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='brokerURL' type='xs:string'/>
+      <xs:attribute name='conduitSubscriptions' type='xs:boolean'/>
+      <xs:attribute name='connectionFilter' type='xs:string'/>
+      <xs:attribute name='consumerPriorityBase' type='xs:integer'/>
+      <xs:attribute name='decreaseNetworkConsumerPriority' type='xs:boolean'/>
+      <xs:attribute name='destinationFilter' type='xs:string'/>
+      <xs:attribute name='dispatchAsync' type='xs:boolean'/>
+      <xs:attribute name='duplex' type='xs:boolean'/>
+      <xs:attribute name='dynamicOnly' type='xs:boolean'/>
+      <xs:attribute name='localUri' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='networkTTL' type='xs:integer'/>
+      <xs:attribute name='objectName' type='xs:string'/>
+      <xs:attribute name='password' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            sets the LDAP password for access credentials
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='prefetchSize' type='xs:string'/>
+      <xs:attribute name='searchEventListener' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            enables/disable a persistent search to the LDAP server as defined
+in draft-ietf-ldapext-psearch-03.txt (2.16.840.1.113730.3.4.3)
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='searchFilter' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            sets the LDAP search filter as defined in RFC 2254
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='searchScope' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            sets the LDAP search scope
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='staticBridge' type='xs:boolean'/>
+      <xs:attribute name='suppressDuplicateQueueSubscriptions' type='xs:boolean'/>
+      <xs:attribute name='suppressDuplicateTopicSubscriptions' type='xs:boolean'/>
+      <xs:attribute name='uri' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            returns the next URI from the configured list
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useCompression' type='xs:boolean'/>
+      <xs:attribute name='user' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            sets the LDAP user for access credentials
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='userName' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.LeaseDatabaseLocker -->
+  <xs:element name='lease-database-locker'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents an exclusive lease on a database to avoid multiple brokers running
+against the same logical database.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='failIfLocked' type='xs:boolean'/>
+      <xs:attribute name='leaseHolderId' type='xs:string'/>
+      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
+      <xs:attribute name='maxAllowableDiffFromDBTime' type='xs:integer'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='queryTimeout' type='xs:integer'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.leveldb.LevelDBPersistenceAdapter -->
+  <xs:element name='levelDB'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An implementation of {@link org.apache.activemq.store.PersistenceAdapter} designed for use with
+LevelDB - Embedded Lightweight Non-Relational Database
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='asyncBufferSize' type='xs:integer'/>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='directory' type='xs:string'/>
+      <xs:attribute name='failIfLocked' type='xs:boolean'/>
+      <xs:attribute name='flushDelay' type='xs:integer'/>
+      <xs:attribute name='indexBlockRestartInterval' type='xs:integer'/>
+      <xs:attribute name='indexBlockSize' type='xs:integer'/>
+      <xs:attribute name='indexCacheSize' type='xs:long'/>
+      <xs:attribute name='indexCompression' type='xs:string'/>
+      <xs:attribute name='indexFactory' type='xs:string'/>
+      <xs:attribute name='indexMaxOpenFiles' type='xs:integer'/>
+      <xs:attribute name='indexWriteBufferSize' type='xs:integer'/>
+      <xs:attribute name='logCompression' type='xs:string'/>
+      <xs:attribute name='logDirectory' type='xs:string'/>
+      <xs:attribute name='logSize' type='xs:long'/>
+      <xs:attribute name='monitorStats' type='xs:boolean'/>
+      <xs:attribute name='paranoidChecks' type='xs:boolean'/>
+      <xs:attribute name='sync' type='xs:boolean'/>
+      <xs:attribute name='usageManager' type='xs:string'/>
+      <xs:attribute name='verifyChecksums' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.util.LoggingBrokerPlugin -->
+  <xs:element name='loggingBrokerPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A simple Broker intercepter which allows you to enable/disable logging.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='next' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminConnectionContext' type='xs:string'/>
+      <xs:attribute name='logAll' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Logger all Events that go through the Plugin
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='logConnectionEvents' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Logger Events that are related to connections
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='logConsumerEvents' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Logger Events that are related to Consumers
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='logInternalEvents' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Logger Events that are normally internal to the broker
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='logMessageEvents' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Logger Events that are related to message processing
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='logProducerEvents' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Logger Events that are related to Producers
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='logSessionEvents' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Logger Events that are related to sessions
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='logTransactionEvents' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Logger Events that are related to transaction processing
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='next' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.kahadb.MultiKahaDBPersistenceAdapter -->
+  <xs:element name='mKahaDB'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An implementation of {@link org.apache.activemq.store.PersistenceAdapter}  that supports
+distribution of destinations across multiple kahaDB persistence adapters
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='entries' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='filteredPersistenceAdapters' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the  FilteredKahaDBPersistenceAdapter entries
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='transactionStore' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='directory' type='xs:string'/>
+      <xs:attribute name='journalMaxFileLength' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Set the max file length of the transaction journal
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can
+be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='journalWriteBatchSize' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Set the max write batch size of  the transaction journal
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can
+be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='transactionStore' type='xs:string'/>
+      <xs:attribute name='usageManager' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.jmx.ManagementContext -->
+  <xs:element name='managementContext'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An abstraction over JMX mbean registration
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='MBeanServer' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Get the MBeanServer
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='environment' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='server' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='MBeanServer' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the MBeanServer
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='allowRemoteAddressInMBeanNames' type='xs:boolean'/>
+      <xs:attribute name='brokerName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the broker name this context is used by, may be <tt>null</tt>
+if the broker name was not set.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='connectorHost' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the connectorHost
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='connectorPath' type='xs:string'/>
+      <xs:attribute name='connectorPort' type='xs:string'/>
+      <xs:attribute name='createConnector' type='xs:string'/>
+      <xs:attribute name='createMBeanServer' type='xs:boolean'/>
+      <xs:attribute name='environment' type='xs:string'/>
+      <xs:attribute name='findTigerMbeanServer' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables/disables the searching for the Java 5 platform MBeanServer
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='jmxDomainName' type='xs:string'/>
+      <xs:attribute name='rmiServerPort' type='xs:string'/>
+      <xs:attribute name='server' type='xs:string'/>
+      <xs:attribute name='useMBeanServer' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.ft.MasterConnector -->
+  <xs:element name='masterConnector'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Connects a Slave Broker to a Master when using <a
+href="http://activemq.apache.org/masterslave.html">Master Slave</a> for High
+Availability of messages.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='failedToStart' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the failedToStart
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='localURI' type='xs:string'/>
+      <xs:attribute name='password' type='xs:string'/>
+      <xs:attribute name='remoteURI' type='xs:string'/>
+      <xs:attribute name='remoteUri' type='xs:string'/>
+      <xs:attribute name='userName' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.MaxDBJDBCAdapter -->
+  <xs:element name='maxdb-jdbc-adapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        JDBC Adapter for the MaxDB database.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.memory.MemoryPersistenceAdapter -->
+  <xs:element name='memoryPersistenceAdapter'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='createTransactionStore' type='xs:boolean'/>
+      <xs:attribute name='directory' type='xs:string'/>
+      <xs:attribute name='usageManager' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.usage.MemoryUsage -->
+  <xs:element name='memoryUsage'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='limiter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:defaultUsageCapacity'/>
+              <xs:element ref='tns:usageCapacity'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='parent' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='executor' type='xs:string'/>
+      <xs:attribute name='limit' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the memory limit in bytes. Setting the limit in bytes will set the
+usagePortion to 0 since the UsageManager is not going to be portion based
+off the parent.
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='limiter' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='parent' type='xs:string'/>
+      <xs:attribute name='percentUsage' type='xs:integer'/>
+      <xs:attribute name='percentUsageMinDelta' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the minimum number of percentage points the usage has to change
+before a UsageListener event is fired by the manager.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='pollingTime' type='xs:integer'/>
+      <xs:attribute name='portion' type='xs:float'/>
+      <xs:attribute name='usage' type='xs:long'/>
+      <xs:attribute name='usagePortion' type='xs:float'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.group.MessageGroupHashBucketFactory -->
+  <xs:element name='messageGroupHashBucketFactory'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A factory to create instances of {@link SimpleMessageGroupMap} when
+implementing the <a
+href="http://activemq.apache.org/message-groups.html">Message
+Groups</a> functionality.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='bucketCount' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the number of hash buckets to use for the message group
+functionality. This is only applicable to using message groups to
+parallelize processing of a queue while preserving order across an
+individual JMSXGroupID header value. This value sets the number of hash
+buckets that will be used (i.e. the maximum possible concurrency).
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.virtual.MirroredQueue -->
+  <xs:element name='mirroredQueue'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Creates <a href="http://activemq.org/site/mirrored-queues.html">Mirrored
+Queue</a> using a prefix and postfix to define the topic name on which to mirror the queue to.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='copyMessage' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether a copy of the message will be sent to each destination.
+Defaults to true so that the forward destination is set as the
+destination of the message
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='postfix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets any postix used to identify the queue consumers
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='prefix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the prefix wildcard used to identify the queue consumers for a given
+topic
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.MulticastNetworkConnector -->
+  <xs:element name='multicastNetworkConnector'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A network connector which uses some kind of multicast-like transport that
+communicates with potentially many remote brokers over a single logical
+{@link Transport} instance such as when using multicast.
+
+This implementation does not depend on multicast at all; any other group
+based transport could be used.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='bridge' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:compositeDemandForwardingBridge'/>
+              <xs:element ref='tns:demandForwardingBridge'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='connectionFilter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='localTransport' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='remoteTransport' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the remote transport implementation
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='alwaysSyncSend' type='xs:boolean'/>
+      <xs:attribute name='bridge' type='xs:string'/>
+      <xs:attribute name='bridgeTempDestinations' type='xs:boolean'/>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='brokerURL' type='xs:string'/>
+      <xs:attribute name='conduitSubscriptions' type='xs:boolean'/>
+      <xs:attribute name='connectionFilter' type='xs:string'/>
+      <xs:attribute name='consumerPriorityBase' type='xs:integer'/>
+      <xs:attribute name='decreaseNetworkConsumerPriority' type='xs:boolean'/>
+      <xs:attribute name='destinationFilter' type='xs:string'/>
+      <xs:attribute name='dispatchAsync' type='xs:boolean'/>
+      <xs:attribute name='duplex' type='xs:boolean'/>
+      <xs:attribute name='dynamicOnly' type='xs:boolean'/>
+      <xs:attribute name='localTransport' type='xs:string'/>
+      <xs:attribute name='localUri' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='networkTTL' type='xs:integer'/>
+      <xs:attribute name='objectName' type='xs:string'/>
+      <xs:attribute name='password' type='xs:string'/>
+      <xs:attribute name='prefetchSize' type='xs:string'/>
+      <xs:attribute name='remoteTransport' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the remote transport implementation
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='remoteURI' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the remote transport URI to some group transport like
+<code>multicast://address:port</code>
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='staticBridge' type='xs:boolean'/>
+      <xs:attribute name='suppressDuplicateQueueSubscriptions' type='xs:boolean'/>
+      <xs:attribute name='suppressDuplicateTopicSubscriptions' type='xs:boolean'/>
+      <xs:attribute name='useCompression' type='xs:boolean'/>
+      <xs:attribute name='userName' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.util.MulticastTraceBrokerPlugin -->
+  <xs:element name='multicastTraceBrokerPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A Broker interceptor which allows you to trace all operations to a Multicast
+socket.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='address' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='next' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='wireFormat' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='wireFormatFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='address' type='xs:string'/>
+      <xs:attribute name='adminConnectionContext' type='xs:string'/>
+      <xs:attribute name='broadcast' type='xs:boolean'/>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='maxTraceDatagramSize' type='xs:integer'/>
+      <xs:attribute name='next' type='xs:string'/>
+      <xs:attribute name='timeToLive' type='xs:integer'/>
+      <xs:attribute name='wireFormat' type='xs:string'/>
+      <xs:attribute name='wireFormatFactory' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.MySqlJDBCAdapter -->
+  <xs:element name='mysql-jdbc-adapter'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='engineType' type='xs:string'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='typeStatement' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.DiscoveryNetworkConnector -->
+  <xs:element name='networkConnector'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A network connector which uses a discovery agent to detect the remote brokers
+available and setup a connection to each available remote broker
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='connectionFilter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='discoveryAgent' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='alwaysSyncSend' type='xs:boolean'/>
+      <xs:attribute name='bridgeTempDestinations' type='xs:boolean'/>
+      <xs:attribute name='brokerName' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='brokerURL' type='xs:string'/>
+      <xs:attribute name='conduitSubscriptions' type='xs:boolean'/>
+      <xs:attribute name='connectionFilter' type='xs:string'/>
+      <xs:attribute name='consumerPriorityBase' type='xs:integer'/>
+      <xs:attribute name='decreaseNetworkConsumerPriority' type='xs:boolean'/>
+      <xs:attribute name='destinationFilter' type='xs:string'/>
+      <xs:attribute name='discoveryAgent' type='xs:string'/>
+      <xs:attribute name='discoveryURI' type='xs:string'/>
+      <xs:attribute name='dispatchAsync' type='xs:boolean'/>
+      <xs:attribute name='duplex' type='xs:boolean'/>
+      <xs:attribute name='dynamicOnly' type='xs:boolean'/>
+      <xs:attribute name='localUri' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='networkTTL' type='xs:integer'/>
+      <xs:attribute name='objectName' type='xs:string'/>
+      <xs:attribute name='password' type='xs:string'/>
+      <xs:attribute name='prefetchSize' type='xs:string'/>
+      <xs:attribute name='staticBridge' type='xs:boolean'/>
+      <xs:attribute name='suppressDuplicateQueueSubscriptions' type='xs:boolean'/>
+      <xs:attribute name='suppressDuplicateTopicSubscriptions' type='xs:boolean'/>
+      <xs:attribute name='uri' type='xs:string'/>
+      <xs:attribute name='useCompression' type='xs:boolean'/>
+      <xs:attribute name='userName' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy -->
+  <xs:element name='noSubscriptionRecoveryPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This SubscriptionRecoveryPolicy disable recovery of messages.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='broker' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.OldestMessageEvictionStrategy -->
+  <xs:element name='oldestMessageEvictionStrategy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An eviction strategy which evicts the oldest message first (which is the
+default).
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='evictExpiredMessagesHighWatermark' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the high water mark on which we will eagerly evict expired messages from RAM
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.OldestMessageWithLowestPriorityEvictionStrategy -->
+  <xs:element name='oldestMessageWithLowestPriorityEvictionStrategy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An eviction strategy which evicts the oldest message with the lowest priority first.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='evictExpiredMessagesHighWatermark' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the high water mark on which we will eagerly evict expired messages from RAM
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.OracleBlobJDBCAdapter -->
+  <xs:element name='oracleBlobJDBCAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.OracleJDBCAdapter -->
+  <xs:element name='oracleJDBCAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.jms.OutboundQueueBridge -->
+  <xs:element name='outboundQueueBridge'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Create an Outbound Queue Bridge.  By default the bridge uses the same
+name for both the inbound and outbound queues, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+queue names.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='consumer' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerQueue' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsConnector' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:jmsQueueConnector'/>
+              <xs:element ref='tns:jmsTopicConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsMessageConvertor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:simpleJmsMessageConvertor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerQueue' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='consumer' type='xs:string'/>
+      <xs:attribute name='consumerConnection' type='xs:string'/>
+      <xs:attribute name='consumerQueue' type='xs:string'/>
+      <xs:attribute name='doHandleReplyTo' type='xs:boolean'/>
+      <xs:attribute name='jmsConnector' type='xs:string'/>
+      <xs:attribute name='jmsMessageConvertor' type='xs:string'/>
+      <xs:attribute name='localQueueName' type='xs:string'/>
+      <xs:attribute name='outboundQueueName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the name of the outbound queue name.  If the inbound queue name
+has not been set already then this method uses the provided queue name
+to set the inbound topic name as well.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='producerConnection' type='xs:string'/>
+      <xs:attribute name='producerQueue' type='xs:string'/>
+      <xs:attribute name='selector' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.jms.OutboundTopicBridge -->
+  <xs:element name='outboundTopicBridge'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Create an Outbound Topic Bridge.  By default the bridge uses the same
+name for both the inbound and outbound topics, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+topic names.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='consumer' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='consumerTopic' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsConnector' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:jmsQueueConnector'/>
+              <xs:element ref='tns:jmsTopicConnector'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='jmsMessageConvertor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:simpleJmsMessageConvertor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerConnection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='producerTopic' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='consumer' type='xs:string'/>
+      <xs:attribute name='consumerConnection' type='xs:string'/>
+      <xs:attribute name='consumerName' type='xs:string'/>
+      <xs:attribute name='consumerTopic' type='xs:string'/>
+      <xs:attribute name='doHandleReplyTo' type='xs:boolean'/>
+      <xs:attribute name='jmsConnector' type='xs:string'/>
+      <xs:attribute name='jmsMessageConvertor' type='xs:string'/>
+      <xs:attribute name='localTopicName' type='xs:string'/>
+      <xs:attribute name='outboundTopicName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the name of the outbound topic name.  If the inbound topic name
+has not been set already then this method uses the provided topic name
+to set the inbound topic name as well.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='producerConnection' type='xs:string'/>
+      <xs:attribute name='producerTopic' type='xs:string'/>
+      <xs:attribute name='selector' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.kahadb.plist.PListStore -->
+  <xs:element name='pListStore'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='brokerService' type='xs:string'/>
+      <xs:attribute name='cleanupInterval' type='xs:long'/>
+      <xs:attribute name='directory' type='xs:string'/>
+      <xs:attribute name='enableIndexWriteAsync' type='xs:boolean'/>
+      <xs:attribute name='failIfDatabaseIsLocked' type='xs:boolean'/>
+      <xs:attribute name='indexCacheSize' type='xs:integer'/>
+      <xs:attribute name='indexEnablePageCaching' type='xs:boolean'/>
+      <xs:attribute name='indexPageSize' type='xs:integer'/>
+      <xs:attribute name='indexWriteBatchSize' type='xs:integer'/>
+      <xs:attribute name='journalMaxFileLength' type='xs:integer'/>
+      <xs:attribute name='journalMaxWriteBatchSize' type='xs:integer'/>
+      <xs:attribute name='lazyInit' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.PolicyEntry -->
+  <xs:element name='policyEntry'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents an entry in a {@link PolicyMap} for assigning policies to a
+specific destination or a hierarchical wildcard area of destinations.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='deadLetterStrategy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the policy used to determine which dead letter queue destination
+should be used
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:individualDeadLetterStrategy'/>
+              <xs:element ref='tns:sharedDeadLetterStrategy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dispatchPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:priorityNetworkDispatchPolicy'/>
+              <xs:element ref='tns:roundRobinDispatchPolicy'/>
+              <xs:element ref='tns:simpleDispatchPolicy'/>
+              <xs:element ref='tns:strictOrderDispatchPolicy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='messageEvictionStrategy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the eviction strategy used to decide which message to evict when the
+slow consumer needs to discard messages
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:oldestMessageEvictionStrategy'/>
+              <xs:element ref='tns:oldestMessageWithLowestPriorityEvictionStrategy'/>
+              <xs:element ref='tns:uniquePropertyMessageEvictionStrategy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='messageGroupMapFactory' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the factory used to create new instances of {MessageGroupMap} used
+to implement the <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a>
+functionality.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:messageGroupHashBucketFactory'/>
+              <xs:element ref='tns:simpleMessageGroupMapFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='networkBridgeFilterFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:conditionalNetworkBridgeFilterFactory'/>
+              <xs:element ref='tns:defaultNetworkBridgeFilterFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='pendingDurableSubscriberPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:fileDurableSubscriberCursor'/>
+              <xs:element ref='tns:storeDurableSubscriberCursor'/>
+              <xs:element ref='tns:vmDurableCursor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='pendingMessageLimitStrategy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the strategy to calculate the maximum number of messages that are
+allowed to be pending on consumers (in addition to their prefetch sizes).
+Once the limit is reached, non-durable topics can then start discarding
+old messages. This allows us to keep dispatching messages to slow
+consumers while not blocking fast consumers and discarding the messages
+oldest first.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:constantPendingMessageLimitStrategy'/>
+              <xs:element ref='tns:prefetchRatePendingMessageLimitStrategy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='pendingQueuePolicy' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:fileQueueCursor'/>
+              <xs:element ref='tns:storeCursor'/>
+              <xs:element ref='tns:vmQueueCursor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='pendingSubscriberPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:fileCursor'/>
+              <xs:element ref='tns:vmCursor'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='slowConsumerStrategy' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:abortSlowConsumerStrategy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='subscriptionRecoveryPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:fixedCountSubscriptionRecoveryPolicy'/>
+              <xs:element ref='tns:fixedSizedSubscriptionRecoveryPolicy'/>
+              <xs:element ref='tns:lastImageSubscriptionRecoveryPolicy'/>
+              <xs:element ref='tns:noSubscriptionRecoveryPolicy'/>
+              <xs:element ref='tns:queryBasedSubscriptionRecoveryPolicy'/>
+              <xs:element ref='tns:timedSubscriptionRecoveryPolicy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='advisoryForConsumed' type='xs:boolean'/>
+      <xs:attribute name='advisoryForDelivery' type='xs:boolean'/>
+      <xs:attribute name='advisoryForDiscardingMessages' type='xs:boolean'/>
+      <xs:attribute name='advisoryForFastProducers' type='xs:boolean'/>
+      <xs:attribute name='advisoryForSlowConsumers' type='xs:boolean'/>
+      <xs:attribute name='advisoryWhenFull' type='xs:boolean'/>
+      <xs:attribute name='allConsumersExclusiveByDefault' type='xs:boolean'/>
+      <xs:attribute name='alwaysRetroactive' type='xs:boolean'/>
+      <xs:attribute name='blockedProducerWarningInterval' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Set's the interval at which warnings about producers being blocked by
+resource usage will be triggered. Values of 0 or less will disable
+warnings
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='consumersBeforeDispatchStarts' type='xs:integer'/>
+      <xs:attribute name='cursorMemoryHighWaterMark' type='xs:integer'/>
+      <xs:attribute name='deadLetterStrategy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the policy used to determine which dead letter queue destination
+should be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='dispatchPolicy' type='xs:string'/>
+      <xs:attribute name='doOptimzeMessageStorage' type='xs:boolean'/>
+      <xs:attribute name='durableTopicPrefetch' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the durableTopicPrefetch
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='enableAudit' type='xs:boolean'/>
+      <xs:attribute name='expireMessagesPeriod' type='xs:long'/>
+      <xs:attribute name='gcInactiveDestinations' type='xs:boolean'/>
+      <xs:attribute name='gcWithNetworkConsumers' type='xs:boolean'/>
+      <xs:attribute name='inactiveTimoutBeforeGC' type='xs:long'/>
+      <xs:attribute name='lazyDispatch' type='xs:boolean'/>
+      <xs:attribute name='maxAuditDepth' type='xs:integer'/>
+      <xs:attribute name='maxBrowsePageSize' type='xs:integer'/>
+      <xs:attribute name='maxExpirePageSize' type='xs:integer'/>
+      <xs:attribute name='maxPageSize' type='xs:integer'/>
+      <xs:attribute name='maxProducersToAudit' type='xs:integer'/>
+      <xs:attribute name='maxQueueAuditDepth' type='xs:integer'/>
+      <xs:attribute name='memoryLimit' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='messageEvictionStrategy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the eviction strategy used to decide which message to evict when the
+slow consumer needs to discard messages
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='messageGroupMapFactory' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the factory used to create new instances of {MessageGroupMap} used
+to implement the <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a>
+functionality.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='minimumMessageSize' type='xs:long'/>
+      <xs:attribute name='networkBridgeFilterFactory' type='xs:string'/>
+      <xs:attribute name='optimizeMessageStoreInFlightLimit' type='xs:integer'/>
+      <xs:attribute name='optimizedDispatch' type='xs:boolean'/>
+      <xs:attribute name='pendingDurableSubscriberPolicy' type='xs:string'/>
+      <xs:attribute name='pendingMessageLimitStrategy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the strategy to calculate the maximum number of messages that are
+allowed to be pending on consumers (in addition to their prefetch sizes).
+Once the limit is reached, non-durable topics can then start discarding
+old messages. This allows us to keep dispatching messages to slow
+consumers while not blocking fast consumers and discarding the messages
+oldest first.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='pendingQueuePolicy' type='xs:string'/>
+      <xs:attribute name='pendingSubscriberPolicy' type='xs:string'/>
+      <xs:attribute name='prioritizedMessages' type='xs:boolean'/>
+      <xs:attribute name='producerFlowControl' type='xs:boolean'/>
+      <xs:attribute name='queue' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='queueBrowserPrefetch' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the queueBrowserPrefetch
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='queuePrefetch' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the queuePrefetch
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='reduceMemoryFootprint' type='xs:boolean'/>
+      <xs:attribute name='sendAdvisoryIfNoConsumers' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sends an advisory message if a non-persistent message is sent and there
+are no active consumers
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='slowConsumerStrategy' type='xs:string'/>
+      <xs:attribute name='storeUsageHighWaterMark' type='xs:integer'/>
+      <xs:attribute name='strictOrderDispatch' type='xs:boolean'/>
+      <xs:attribute name='subscriptionRecoveryPolicy' type='xs:string'/>
+      <xs:attribute name='tempQueue' type='xs:boolean'/>
+      <xs:attribute name='tempTopic' type='xs:boolean'/>
+      <xs:attribute name='timeBeforeDispatchStarts' type='xs:integer'/>
+      <xs:attribute name='topic' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='topicPrefetch' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the topicPrefetch
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useCache' type='xs:boolean'/>
+      <xs:attribute name='useConsumerPriority' type='xs:boolean'/>
+      <xs:attribute name='usePrefetchExtension' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.PolicyMap -->
+  <xs:element name='policyMap'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='defaultEntry' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:policyEntry'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='entries' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='policyEntries' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the individual entries on the policy map
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='defaultEntry' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.PostgresqlJDBCAdapter -->
+  <xs:element name='postgresql-jdbc-adapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='acksPkName' type='xs:string'/>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.ActiveMQPrefetchPolicy -->
+  <xs:element name='prefetchPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Defines the prefetch message policies for different types of consumers
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='all' type='xs:integer'/>
+      <xs:attribute name='durableTopicPrefetch' type='xs:integer'/>
+      <xs:attribute name='inputStreamPrefetch' type='xs:integer'/>
+      <xs:attribute name='maximumPendingMessageLimit' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets how many messages a broker will keep around, above the prefetch
+limit, for non-durable topics before starting to discard older messages.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='optimizeDurableTopicPrefetch' type='xs:integer'/>
+      <xs:attribute name='queueBrowserPrefetch' type='xs:integer'/>
+      <xs:attribute name='queuePrefetch' type='xs:integer'/>
+      <xs:attribute name='topicPrefetch' type='xs:integer'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.PrefetchRatePendingMessageLimitStrategy -->
+  <xs:element name='prefetchRatePendingMessageLimitStrategy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This PendingMessageLimitStrategy sets the maximum pending message limit value to be
+a multiplier of the prefetch limit of the subscription.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='multiplier' type='xs:double'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the multiplier of the prefetch size which will be used to define the maximum number of pending
+messages for non-durable topics before messages are discarded.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.PriorityNetworkDispatchPolicy -->
+  <xs:element name='priorityNetworkDispatchPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        dispatch policy that ignores lower priority duplicate network consumers,
+used in conjunction with network bridge suppresDuplicateTopicSubscriptions
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.proxy.ProxyConnector -->
+  <xs:element name='proxyConnector'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='server' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='bind' type='xs:string'/>
+      <xs:attribute name='localUri' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='proxyToLocalBroker' type='xs:boolean'/>
+      <xs:attribute name='remote' type='xs:string'/>
+      <xs:attribute name='server' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.QueryBasedSubscriptionRecoveryPolicy -->
+  <xs:element name='queryBasedSubscriptionRecoveryPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This implementation of {@link SubscriptionRecoveryPolicy} will perform a user
+specific query mechanism to load any messages they may have missed.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='query' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the query strategy to load initial messages
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='broker' type='xs:string'/>
+      <xs:attribute name='query' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the query strategy to load initial messages
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.command.ActiveMQQueue -->
+  <xs:element name='queue'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An ActiveMQ Queue
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='compositeDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Get the properties from this instance for storing in JNDI
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='physicalName' type='xs:string'/>
+      <xs:attribute name='properties' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the properties from this instance for storing in JNDI
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.QueueDispatchSelector -->
+  <xs:element name='queueDispatchSelector'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Queue dispatch policy that determines if a message can be sent to a subscription
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='exclusiveConsumer' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='exclusiveConsumer' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.jms.ReconnectionPolicy -->
+  <xs:element name='reconnectionPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A policy object that defines how a {@link JmsConnector} deals with
+reconnection of the local and foreign connections.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='backOffMultiplier' type='xs:double'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the multiplier used to grow the delay between connection attempts from the initial
+time to the max set time.  By default this value is set to 2.0.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='initialReconnectDelay' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the initial delay value used before a reconnection attempt is made.  If the
+use exponential back-off value is set to false then this will be the fixed time
+between connection attempts.  By default this value is set to one second.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maxInitialConnectAttempts' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the maximum number of times that the {@link JmsConnector} will try
+to connect on startup to before it marks itself as failed and does not
+try any further connections.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maxReconnectAttempts' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the number of time that {@link JmsConnector} will attempt to connect
+or reconnect before giving up.  By default the policy sets this value to
+a negative value meaning try forever.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maxSendRetries' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the maximum number of a times a Message send should be retried before
+a JMSExeception is thrown indicating that the operation failed.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maximumReconnectDelay' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the maximum delay that is inserted between each attempt to connect
+before another attempt is made.  The default setting for this value is
+30 seconds.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='sendRetyDelay' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Set the amount of time the DestionationBridge will wait between attempts
+to forward a message.  The default policy limits the minimum time between
+send attempt to one second.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useExponentialBackOff' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets whether the policy uses the set back-off multiplier to grow the time between
+connection attempts.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.util.RedeliveryPlugin -->
+  <xs:element name='redeliveryPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Replace regular DLQ handling with redelivery via a resend to the original destination
+after a delay
+A destination matching RedeliveryPolicy controls the quantity and delay for re-sends
+If there is no matching policy or an existing policy limit is exceeded by default
+regular DLQ processing resumes. This is controlled via sendToDlqIfMaxRetriesExceeded
+and fallbackToDeadLetter
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='next' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='redeliveryPolicyMap' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:redeliveryPolicyMap'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminConnectionContext' type='xs:string'/>
+      <xs:attribute name='fallbackToDeadLetter' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            What to do if there is no matching redelivery policy for a destination.
+when true, the region broker DLQ processing will be used via sendToDeadLetterQueue
+when false, there is no action
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='next' type='xs:string'/>
+      <xs:attribute name='redeliveryPolicyMap' type='xs:string'/>
+      <xs:attribute name='sendToDlqIfMaxRetriesExceeded' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            What to do if the maxretries on a matching redelivery policy is exceeded.
+when true, the region broker DLQ processing will be used via sendToDeadLetterQueue
+when false, there is no action
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.RedeliveryPolicy -->
+  <xs:element name='redeliveryPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Configuration options for a messageConsumer used to control how messages are re-delivered when they
+are rolled back.
+May be used server side on a per destination basis via the Broker RedeliveryPlugin
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='backOffMultiplier' type='xs:double'/>
+      <xs:attribute name='collisionAvoidancePercent' type='xs:short'/>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='initialRedeliveryDelay' type='xs:long'/>
+      <xs:attribute name='maximumRedeliveries' type='xs:integer'/>
+      <xs:attribute name='maximumRedeliveryDelay' type='xs:long'/>
+      <xs:attribute name='queue' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='redeliveryDelay' type='xs:long'/>
+      <xs:attribute name='tempQueue' type='xs:boolean'/>
+      <xs:attribute name='tempTopic' type='xs:boolean'/>
+      <xs:attribute name='topic' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useCollisionAvoidance' type='xs:boolean'/>
+      <xs:attribute name='useExponentialBackOff' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.RedeliveryPolicyMap -->
+  <xs:element name='redeliveryPolicyMap'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='defaultEntry' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:redeliveryPolicy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='entries' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='redeliveryPolicyEntries' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the individual entries on the redeliveryPolicyMap
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='defaultEntry' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy -->
+  <xs:element name='roundRobinDispatchPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Simple dispatch policy that sends a message to every subscription that
+matches the message.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.SharedFileLocker -->
+  <xs:element name='shared-file-locker'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='directory' type='xs:string'/>
+      <xs:attribute name='failIfLocked' type='xs:boolean'/>
+      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy -->
+  <xs:element name='sharedDeadLetterStrategy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A default implementation of {@link DeadLetterStrategy} which uses
+a constant destination.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='deadLetterQueue' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='deadLetterQueue' type='xs:string'/>
+      <xs:attribute name='enableAudit' type='xs:boolean'/>
+      <xs:attribute name='processExpired' type='xs:boolean'/>
+      <xs:attribute name='processNonPersistent' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.SimpleAuthenticationPlugin -->
+  <xs:element name='simpleAuthenticationPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Provides a simple authentication plugin
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='userGroups' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the groups a user is in. The key is the user name and the value is a
+Set of groups
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='userPasswords' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the map indexed by user name with the value the password
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='users' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets individual users for authentication
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='anonymousAccessAllowed' type='xs:boolean'/>
+      <xs:attribute name='anonymousGroup' type='xs:string'/>
+      <xs:attribute name='anonymousUser' type='xs:string'/>
+      <xs:attribute name='userGroups' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the groups a user is in. The key is the user name and the value is a
+Set of groups
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='userPasswords' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the map indexed by user name with the value the password
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.SimpleAuthorizationMap -->
+  <xs:element name='simpleAuthorizationMap'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An AuthorizationMap which is configured with individual DestinationMaps for
+each operation.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminACLs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:authorizationMap'/>
+              <xs:element ref='tns:cachedLDAPAuthorizationMap'/>
+              <xs:element ref='tns:mKahaDB'/>
+              <xs:element ref='tns:policyMap'/>
+              <xs:element ref='tns:redeliveryPolicyMap'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='readACLs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:authorizationMap'/>
+              <xs:element ref='tns:cachedLDAPAuthorizationMap'/>
+              <xs:element ref='tns:mKahaDB'/>
+              <xs:element ref='tns:policyMap'/>
+              <xs:element ref='tns:redeliveryPolicyMap'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='tempDestinationAuthorizationEntry' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='writeACLs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:authorizationMap'/>
+              <xs:element ref='tns:cachedLDAPAuthorizationMap'/>
+              <xs:element ref='tns:mKahaDB'/>
+              <xs:element ref='tns:policyMap'/>
+              <xs:element ref='tns:redeliveryPolicyMap'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminACLs' type='xs:string'/>
+      <xs:attribute name='readACLs' type='xs:string'/>
+      <xs:attribute name='tempDestinationAuthorizationEntry' type='xs:string'/>
+      <xs:attribute name='writeACLs' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.SimpleDispatchPolicy -->
+  <xs:element name='simpleDispatchPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Simple dispatch policy that sends a message to every subscription that
+matches the message.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.SimpleDispatchSelector -->
+  <xs:element name='simpleDispatchSelector'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Simple dispatch policy that determines if a message can be sent to a subscription
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.network.jms.SimpleJmsMessageConvertor -->
+  <xs:element name='simpleJmsMessageConvertor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Converts Message from one JMS to another
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='connection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='connection' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.group.SimpleMessageGroupMapFactory -->
+  <xs:element name='simpleMessageGroupMapFactory'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A factory to create instances of {@link SimpleMessageGroupMap} when implementing the 
+<a href="http://activemq.apache.org/message-groups.html">Message Groups</a> functionality.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.spring.SpringSslContext -->
+  <xs:element name='sslContext'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Extends the SslContext so that it's easier to configure from spring.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='SSLContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='keyManagers' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='secureRandom' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='trustManagers' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='SSLContext' type='xs:string'/>
+      <xs:attribute name='keyStore' type='xs:string'/>
+      <xs:attribute name='keyStoreAlgorithm' type='xs:string'/>
+      <xs:attribute name='keyStoreKeyPassword' type='xs:string'/>
+      <xs:attribute name='keyStorePassword' type='xs:string'/>
+      <xs:attribute name='keyStoreType' type='xs:string'/>
+      <xs:attribute name='protocol' type='xs:string'/>
+      <xs:attribute name='provider' type='xs:string'/>
+      <xs:attribute name='secureRandom' type='xs:string'/>
+      <xs:attribute name='secureRandomAlgorithm' type='xs:string'/>
+      <xs:attribute name='trustStore' type='xs:string'/>
+      <xs:attribute name='trustStoreAlgorithm' type='xs:string'/>
+      <xs:attribute name='trustStorePassword' type='xs:string'/>
+      <xs:attribute name='trustStoreType' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.Statements -->
+  <xs:element name='statements'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='createSchemaStatements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='dropSchemaStatements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='addMessageStatement' type='xs:string'/>
+      <xs:attribute name='binaryDataType' type='xs:string'/>
+      <xs:attribute name='clearDurableLastAckInTxStatement' type='xs:string'/>
+      <xs:attribute name='clearXidFlagStatement' type='xs:string'/>
+      <xs:attribute name='containerNameDataType' type='xs:string'/>
+      <xs:attribute name='createDurableSubStatement' type='xs:string'/>
+      <xs:attribute name='currentDateTimeStatement' type='xs:string'/>
+      <xs:attribute name='deleteOldMessagesStatementWithPriority' type='xs:string'/>
+      <xs:attribute name='deleteSubscriptionStatement' type='xs:string'/>
+      <xs:attribute name='destinationMessageCountStatement' type='xs:string'/>
+      <xs:attribute name='dropAckPKAlterStatementEnd' type='xs:string'/>
+      <xs:attribute name='durableSubAcksTableName' type='xs:string'/>
+      <xs:attribute name='durableSubscriberMessageCountStatement' type='xs:string'/>
+      <xs:attribute name='durableSubscriberMessageCountStatementWithPriority' type='xs:string'/>
+      <xs:attribute name='findAcksPendingOutcomeStatement' type='xs:string'/>
+      <xs:attribute name='findAllDestinationsStatement' type='xs:string'/>
+      <xs:attribute name='findAllDurableSubMessagesStatement' type='xs:string'/>
+      <xs:attribute name='findAllDurableSubsStatement' type='xs:string'/>
+      <xs:attribute name='findAllMessagesStatement' type='xs:string'/>
+      <xs:attribute name='findDurableSubMessagesStatement' type='xs:string'/>
+      <xs:attribute name='findDurableSubStatement' type='xs:string'/>
+      <xs:attribute name='findLastSequenceIdInAcksStatement' type='xs:string'/>
+      <xs:attribute name='findLastSequenceIdInMsgsStatement' type='xs:string'/>
+      <xs:attribute name='findMessageByIdStatement' type='xs:string'/>
+      <xs:attribute name='findMessageSequenceIdStatement' type='xs:string'/>
+      <xs:attribute name='findMessageStatement' type='xs:string'/>
+      <xs:attribute name='findNextMessagesStatement' type='xs:string'/>
+      <xs:attribute name='findOpsPendingOutcomeStatement' type='xs:string'/>
+      <xs:attribute name='findXidByIdStatement' type='xs:string'/>
+      <xs:attribute name='insertDurablePriorityAckStatement' type='xs:string'/>
+      <xs:attribute name='lastAckedDurableSubscriberMessageStatement' type='xs:string'/>
+      <xs:attribute name='lastProducerSequenceIdStatement' type='xs:string'/>
+      <xs:attribute name='leaseObtainStatement' type='xs:string'/>
+      <xs:attribute name='leaseOwnerStatement' type='xs:string'/>
+      <xs:attribute name='leaseUpdateStatement' type='xs:string'/>
+      <xs:attribute name='lockCreateStatement' type='xs:string'/>
+      <xs:attribute name='lockTableName' type='xs:string'/>
+      <xs:attribute name='lockUpdateStatement' type='xs:string'/>
+      <xs:attribute name='longDataType' type='xs:string'/>
+      <xs:attribute name='messageTableName' type='xs:string'/>
+      <xs:attribute name='msgIdDataType' type='xs:string'/>
+      <xs:attribute name='nextDurableSubscriberMessageStatement' type='xs:string'/>
+      <xs:attribute name='removeAllMessagesStatement' type='xs:string'/>
+      <xs:attribute name='removeAllSubscriptionsStatement' type='xs:string'/>
+      <xs:attribute name='removeMessageStatment' type='xs:string'/>
+      <xs:attribute name='selectDurablePriorityAckStatement' type='xs:string'/>
+      <xs:attribute name='sequenceDataType' type='xs:string'/>
+      <xs:attribute name='stringIdDataType' type='xs:string'/>
+      <xs:attribute name='tablePrefix' type='xs:string'/>
+      <xs:attribute name='updateDurableLastAckInTxStatement' type='xs:string'/>
+      <xs:attribute name='updateDurableLastAckStatement' type='xs:string'/>
+      <xs:attribute name='updateDurableLastAckWithPriorityInTxStatement' type='xs:string'/>
+      <xs:attribute name='updateDurableLastAckWithPriorityStatement' type='xs:string'/>
+      <xs:attribute name='updateLastPriorityAckRowOfDurableSubStatement' type='xs:string'/>
+      <xs:attribute name='updateMessageStatement' type='xs:string'/>
+      <xs:attribute name='updateXidFlagStatement' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='useLockCreateWhereClause' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.plugin.StatisticsBrokerPlugin -->
+  <xs:element name='statisticsBrokerPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A StatisticsBrokerPlugin
+You can retrieve a Map Message for a Destination - or
+Broker containing statistics as key-value pairs The message must contain a
+replyTo Destination - else its ignored
+To retrieve stats on the broker send a empty message to ActiveMQ.Statistics.Broker (Queue or Topic)
+With a replyTo set to the destination you want the stats returned to.
+To retrieve stats for a destination - e.g. foo - send an empty message to ActiveMQ.Statistics.Destination.foo
+- this works with wildcards to - you get a message for each wildcard match on the replyTo destination.
+The stats message is a MapMessage populated with statistics for the target
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.StorePendingQueueMessageStoragePolicy -->
+  <xs:element name='storeCursor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Pending messages
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy -->
+  <xs:element name='storeDurableSubscriberCursor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Pending messages for a durable
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='immediatePriorityDispatch' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Ensure that new higher priority messages will get an immediate dispatch
+rather than wait for the end of the current cursor batch.
+Useful when there is a large message backlog and intermittent high priority messages.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useCache' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.usage.StoreUsage -->
+  <xs:element name='storeUsage'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='limiter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:defaultUsageCapacity'/>
+              <xs:element ref='tns:usageCapacity'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='parent' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='store' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:amqPersistenceAdapter'/>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:element ref='tns:journalPersistenceAdapter'/>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:element ref='tns:kahaPersistenceAdapter'/>
+              <xs:element ref='tns:levelDB'/>
+              <xs:element ref='tns:mKahaDB'/>
+              <xs:element ref='tns:memoryPersistenceAdapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='executor' type='xs:string'/>
+      <xs:attribute name='limit' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the memory limit in bytes. Setting the limit in bytes will set the
+usagePortion to 0 since the UsageManager is not going to be portion based
+off the parent.
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='limiter' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='parent' type='xs:string'/>
+      <xs:attribute name='percentUsage' type='xs:integer'/>
+      <xs:attribute name='percentUsageMinDelta' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the minimum number of percentage points the usage has to change
+before a UsageListener event is fired by the manager.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='pollingTime' type='xs:integer'/>
+      <xs:attribute name='store' type='xs:string'/>
+      <xs:attribute name='usagePortion' type='xs:float'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.StreamJDBCAdapter -->
+  <xs:element name='streamJDBCAdapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This JDBCAdapter inserts and extracts BLOB data using the
+setBinaryStream()/getBinaryStream() operations.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Axion</li>
+</ul>
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.StrictOrderDispatchPolicy -->
+  <xs:element name='strictOrderDispatchPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Dispatch policy that causes every subscription to see messages in the same
+order.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.SybaseJDBCAdapter -->
+  <xs:element name='sybase-jdbc-adapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A JDBC Adapter for Sybase databases
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.usage.SystemUsage -->
+  <xs:element name='systemUsage'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Holder for Usage instances for memory, store and temp files Main use case is
+manage memory usage.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:amqPersistenceAdapter'/>
+              <xs:element ref='tns:jdbcPersistenceAdapter'/>
+              <xs:element ref='tns:journalPersistenceAdapter'/>
+              <xs:element ref='tns:kahaDB'/>
+              <xs:element ref='tns:kahaPersistenceAdapter'/>
+              <xs:element ref='tns:levelDB'/>
+              <xs:element ref='tns:mKahaDB'/>
+              <xs:element ref='tns:memoryPersistenceAdapter'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='memoryUsage' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:memoryUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='parent' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:systemUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='storeUsage' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:storeUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='tempStore' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:pListStore'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='tempUsage' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:tempUsage'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adapter' type='xs:string'/>
+      <xs:attribute name='executor' type='xs:string'/>
+      <xs:attribute name='memoryUsage' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='parent' type='xs:string'/>
+      <xs:attribute name='sendFailIfNoSpace' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not a send() should fail if there is no space free. The
+default value is false which means to block the send() method until space
+becomes available
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='sendFailIfNoSpaceAfterTimeout' type='xs:long'/>
+      <xs:attribute name='sendFailIfNoSpaceExplicitySet' type='xs:boolean'/>
+      <xs:attribute name='storeUsage' type='xs:string'/>
+      <xs:attribute name='tempStore' type='xs:string'/>
+      <xs:attribute name='tempUsage' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.thread.TaskRunnerFactory -->
+  <xs:element name='taskRunnerFactory'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Manages the thread pool for long running tasks. Long running tasks are not
+always active but when they are active, they may need a few iterations of
+processing for them to become idle. The manager ensures that each task is
+processes but that no one task overtakes the system. This is kinda like
+cooperative multitasking.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='rejectedTaskHandler' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='daemon' type='xs:boolean'/>
+      <xs:attribute name='dedicatedTaskRunner' type='xs:boolean'/>
+      <xs:attribute name='executor' type='xs:string'/>
+      <xs:attribute name='maxIterationsPerRun' type='xs:integer'/>
+      <xs:attribute name='maxThreadPoolSize' type='xs:integer'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='priority' type='xs:integer'/>
+      <xs:attribute name='rejectedTaskHandler' type='xs:string'/>
+      <xs:attribute name='shutdownAwaitTermination' type='xs:long'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.security.TempDestinationAuthorizationEntry -->
+  <xs:element name='tempDestinationAuthorizationEntry'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a temporary
+destination
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminACLs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='readACLs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='writeACLs' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='admin' type='xs:string'/>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='groupClass' type='xs:string'/>
+      <xs:attribute name='queue' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='read' type='xs:string'/>
+      <xs:attribute name='tempQueue' type='xs:boolean'/>
+      <xs:attribute name='tempTopic' type='xs:boolean'/>
+      <xs:attribute name='topic' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            A helper method to set the destination from a configuration file
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='write' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.command.ActiveMQTempQueue -->
+  <xs:element name='tempQueue'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An ActiveMQ Temporary Queue Destination
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='compositeDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='connection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Get the properties from this instance for storing in JNDI
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='connection' type='xs:string'/>
+      <xs:attribute name='connectionId' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='physicalName' type='xs:string'/>
+      <xs:attribute name='properties' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the properties from this instance for storing in JNDI
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='sequenceId' type='xs:long'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.command.ActiveMQTempTopic -->
+  <xs:element name='tempTopic'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An ActiveMQ Temporary Topic Destination
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='compositeDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='connection' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Get the properties from this instance for storing in JNDI
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='connection' type='xs:string'/>
+      <xs:attribute name='connectionId' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='physicalName' type='xs:string'/>
+      <xs:attribute name='properties' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the properties from this instance for storing in JNDI
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='sequenceId' type='xs:long'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.usage.TempUsage -->
+  <xs:element name='tempUsage'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='limiter' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:defaultUsageCapacity'/>
+              <xs:element ref='tns:usageCapacity'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='parent' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='store' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:pListStore'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='executor' type='xs:string'/>
+      <xs:attribute name='limit' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the memory limit in bytes. Setting the limit in bytes will set the
+usagePortion to 0 since the UsageManager is not going to be portion based
+off the parent.
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='limiter' type='xs:string'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='parent' type='xs:string'/>
+      <xs:attribute name='percentUsage' type='xs:integer'/>
+      <xs:attribute name='percentUsageMinDelta' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the minimum number of percentage points the usage has to change
+before a UsageListener event is fired by the manager.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='pollingTime' type='xs:integer'/>
+      <xs:attribute name='store' type='xs:string'/>
+      <xs:attribute name='usagePortion' type='xs:float'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.util.TimeStampingBrokerPlugin -->
+  <xs:element name='timeStampingBrokerPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A Broker interceptor which updates a JMS Client's timestamp on the message
+with a broker timestamp. Useful when the clocks on client machines are known
+to not be correct and you can only trust the time set on the broker machines.
+
+Enabling this plugin will break JMS compliance since the timestamp that the
+producer sees on the messages after as send() will be different from the
+timestamp the consumer will observe when he receives the message. This plugin
+is not enabled in the default ActiveMQ configuration.
+
+2 new attributes have been added which will allow the administrator some override control
+over the expiration time for incoming messages:
+
+Attribute 'zeroExpirationOverride' can be used to apply an expiration
+time to incoming messages with no expiration defined (messages that would never expire)
+
+Attribute 'ttlCeiling' can be used to apply a limit to the expiration time
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='next' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='processNetworkMessages' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminConnectionContext' type='xs:string'/>
+      <xs:attribute name='futureOnly' type='xs:boolean'/>
+      <xs:attribute name='next' type='xs:string'/>
+      <xs:attribute name='processNetworkMessages' type='xs:string'/>
+      <xs:attribute name='ttlCeiling' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            setter method for ttlCeiling
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='zeroExpirationOverride' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            setter method for zeroExpirationOverride
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.TimedSubscriptionRecoveryPolicy -->
+  <xs:element name='timedSubscriptionRecoveryPolicy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        This implementation of {@link SubscriptionRecoveryPolicy} will keep a timed
+buffer of messages around in memory and use that to recover new
+subscriptions.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='broker' type='xs:string'/>
+      <xs:attribute name='recoverDuration' type='xs:long'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.command.ActiveMQTopic -->
+  <xs:element name='topic'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An ActiveMQ Topic
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='compositeDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:queue'/>
+              <xs:element ref='tns:tempQueue'/>
+              <xs:element ref='tns:tempTopic'/>
+              <xs:element ref='tns:topic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Get the properties from this instance for storing in JNDI
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='physicalName' type='xs:string'/>
+      <xs:attribute name='properties' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the properties from this instance for storing in JNDI
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.util.TraceBrokerPathPlugin -->
+  <xs:element name='traceBrokerPathPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        The TraceBrokerPathPlugin can be used in a network of Brokers. Each Broker
+that has the plugin configured, will add it's brokerName to the content
+of a JMS Property. If all Brokers have this property enabled, the path the
+message actually took through the network can be seen in the defined property.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='next' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='adminConnectionContext' type='xs:string'/>
+      <xs:attribute name='next' type='xs:string'/>
+      <xs:attribute name='stampProperty' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.TransactDatabaseLocker -->
+  <xs:element name='transact-database-locker'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='exceptionHandler' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='exceptionHandler' type='xs:string'/>
+      <xs:attribute name='failIfLocked' type='xs:boolean'/>
+      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='queryTimeout' type='xs:integer'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.store.jdbc.adapter.TransactJDBCAdapter -->
+  <xs:element name='transact-jdbc-adapter'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A JDBC Adapter for Transact-SQL based databases such as SQL Server or Sybase
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:statements'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='batchStatments' type='xs:boolean'/>
+      <xs:attribute name='maxRows' type='xs:integer'/>
+      <xs:attribute name='statements' type='xs:string'/>
+      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.TransportConnector -->
+  <xs:element name='transportConnector'>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='brokerInfo' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              This is called by the BrokerService right before it starts the transport.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:broker'/>
+              <xs:element ref='tns:brokerService'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='discoveryAgent' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='messageAuthorizationPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the policy used to decide if the current connection is authorized to
+consume a given message
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='server' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='auditNetworkProducers' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enable a producer audit on network connections, Traps the case of a missing send reply and resend.
+Note: does not work with conduit=false, networked composite destinations or networked virtual topics
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='brokerInfo' type='xs:string'/>
+      <xs:attribute name='brokerService' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            This is called by the BrokerService right before it starts the transport.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='disableAsyncDispatch' type='xs:boolean'/>
+      <xs:attribute name='discoveryAgent' type='xs:string'/>
+      <xs:attribute name='discoveryUri' type='xs:string'/>
+      <xs:attribute name='enableStatusMonitor' type='xs:boolean'/>
+      <xs:attribute name='maximumConsumersAllowedPerConnection' type='xs:integer'/>
+      <xs:attribute name='maximumProducersAllowedPerConnection' type='xs:integer'/>
+      <xs:attribute name='messageAuthorizationPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the policy used to decide if the current connection is authorized to
+consume a given message
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='rebalanceClusterClients' type='xs:boolean'/>
+      <xs:attribute name='server' type='xs:string'/>
+      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
+      <xs:attribute name='updateClusterClients' type='xs:boolean'/>
+      <xs:attribute name='updateClusterClientsOnRemove' type='xs:boolean'/>
+      <xs:attribute name='updateClusterFilter' type='xs:string'/>
+      <xs:attribute name='uri' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the server transport URI to use if there is not a
+{@link TransportServer} configured via the
+{@link #setServer(TransportServer)} method. This value is used to lazy
+create a {@link TransportServer} instance
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.util.UDPTraceBrokerPlugin -->
+  <xs:element name='udpTraceBrokerPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A Broker interceptor which allows you to trace all operations to a UDP
+socket.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='address' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='next' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
+              <xs:element ref='tns:forcePersistencyModeBroker'/>
+              <xs:element ref='tns:loggingBrokerPlugin'/>
+              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
+              <xs:element ref='tns:redeliveryPlugin'/>
+              <xs:element ref='tns:timeStampingBrokerPlugin'/>
+              <xs:element ref='tns:traceBrokerPathPlugin'/>
+              <xs:element ref='tns:udpTraceBrokerPlugin'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='wireFormat' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='wireFormatFactory' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='address' type='xs:string'/>
+      <xs:attribute name='adminConnectionContext' type='xs:string'/>
+      <xs:attribute name='broadcast' type='xs:boolean'/>
+      <xs:attribute name='destination' type='xs:string'/>
+      <xs:attribute name='maxTraceDatagramSize' type='xs:integer'/>
+      <xs:attribute name='next' type='xs:string'/>
+      <xs:attribute name='wireFormat' type='xs:string'/>
+      <xs:attribute name='wireFormatFactory' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.UniquePropertyMessageEvictionStrategy -->
+  <xs:element name='uniquePropertyMessageEvictionStrategy'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        An eviction strategy which evicts the oldest message within messages with the same property value
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='evictExpiredMessagesHighWatermark' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the high water mark on which we will eagerly evict expired messages from RAM
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='propertyName' type='xs:string'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.usage.UsageCapacity -->
+  <xs:element name='usageCapacity'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Identify if a limit has been reached
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='limit' type='xs:long'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor -->
+  <xs:element name='virtualDestinationInterceptor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Implements <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual Topics</a>.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='virtualDestinations' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='unbounded'>
+              <xs:element ref='tns:compositeQueue'/>
+              <xs:element ref='tns:compositeTopic'/>
+              <xs:element ref='tns:virtualTopic'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.plugin.SubQueueSelectorCacheBrokerPlugin -->
+  <xs:element name='virtualSelectorCacheBrokerPlugin'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A plugin which allows the caching of the selector from a subscription queue.
+<p/>
+This stops the build-up of unwanted messages, especially when consumers may
+disconnect from time to time when using virtual destinations.
+<p/>
+This is influenced by code snippets developed by Maciej Rakowicz
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='persistFile' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the location of the persistent cache
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.virtual.VirtualTopic -->
+  <xs:element name='virtualTopic'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Creates <a href="http://activemq.org/site/virtual-destinations.html">Virtual
+Topics</a> using a prefix and postfix. The virtual destination creates a
+wildcard that is then used to look up all active queue subscriptions which
+match.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='local' type='xs:boolean'/>
+      <xs:attribute name='name' type='xs:string'/>
+      <xs:attribute name='postfix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets any postix used to identify the queue consumers
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='prefix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the prefix wildcard used to identify the queue consumers for a given
+topic
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='selectorAware' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Indicates whether the selectors of consumers are used to determine dispatch
+to a virtual destination, when true only messages matching an existing 
+consumer will be dispatched.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy -->
+  <xs:element name='vmCursor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Pending messages held
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.VMPendingDurableSubscriberMessageStoragePolicy -->
+  <xs:element name='vmDurableCursor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Pending
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy -->
+  <xs:element name='vmQueueCursor'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        Pending messages
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+  <!-- element for type: org.apache.activemq.spring.ActiveMQXAConnectionFactory -->
+  <xs:element name='xaConnectionFactory'>
+    <xs:annotation>
+      <xs:documentation><![CDATA[
+        A <a href="http://www.springframework.org/">Spring</a> enhanced XA connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.
+      ]]></xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
+        <xs:element name='blobTransferPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the policy used to describe how out-of-band BLOBs (Binary Large
+OBjects) are transferred from producers to brokers to consumers
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='clientIdGenerator' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='clientInternalExceptionListener' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='connectionIdGenerator' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='exceptionListener' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:commandAgent'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='prefetchPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the <a
+href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
+policy</a> for consumers created by this connection.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:prefetchPolicy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Get the properties from this instance for storing in JNDI
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='redeliveryPolicy' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the global default redelivery policy to be used when a message is delivered
+but the session is rolled back
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:redeliveryPolicy'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='redeliveryPolicyMap' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the global redelivery policy mapping to be used when a message is delivered
+but the session is rolled back
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:redeliveryPolicyMap'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='rejectedTaskHandler' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='sessionTaskRunner' minOccurs='0' maxOccurs='1'>
+          <xs:complexType>
+            <xs:choice minOccurs='0' maxOccurs='1'>
+              <xs:element ref='tns:taskRunnerFactory'/>
+              <xs:any namespace='##other'/>
+            </xs:choice>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='transformer' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Sets the transformer used to transform messages before they are sent on
+to the JMS bus or when they are received from the bus but before they are
+delivered to the JMS client
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name='transportListener' minOccurs='0' maxOccurs='1'>
+          <xs:annotation>
+            <xs:documentation><![CDATA[
+              Allows a listener to be configured on the ConnectionFactory so that when this factory is used
+with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
+a transport listener.
+            ]]></xs:documentation>
+          </xs:annotation>
+          <xs:complexType>
+            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
+          </xs:complexType>
+        </xs:element>
+        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
+      </xs:choice></xs:choice>
+      <xs:attribute name='alwaysSessionAsync' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            If this flag is not set then a separate thread is not used for dispatching messages for each Session in
+the Connection. However, a separate thread is always used if there is more than one session, or the session
+isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
+happens asynchronously.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='alwaysSyncSend' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Set true if always require messages to be sync sent
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='auditDepth' type='xs:integer'/>
+      <xs:attribute name='auditMaximumProducerNumber' type='xs:integer'/>
+      <xs:attribute name='beanName' type='xs:string'/>
+      <xs:attribute name='blobTransferPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the policy used to describe how out-of-band BLOBs (Binary Large
+OBjects) are transferred from producers to brokers to consumers
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='brokerURL' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the <a
+href="http://activemq.apache.org/configuring-transports.html">connection
+URL</a> used to connect to the ActiveMQ broker.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='checkForDuplicates' type='xs:boolean'/>
+      <xs:attribute name='clientID' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JMS clientID to use for the created connection. Note that this
+can only be used by one connection at once so generally its a better idea
+to set the clientID on a Connection
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='clientIDPrefix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the prefix used by autogenerated JMS Client ID values which are used
+if the JMS client does not explicitly specify on.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='clientIdGenerator' type='xs:string'/>
+      <xs:attribute name='clientInternalExceptionListener' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='closeTimeout' type='xs:integer'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the timeout before a close is considered complete. Normally a
+close() on a connection waits for confirmation from the broker; this
+allows that operation to timeout to save the client hanging if there is
+no broker
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='connectionIDPrefix' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the prefix used by connection id generator
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='connectionIdGenerator' type='xs:string'/>
+      <xs:attribute name='consumerFailoverRedeliveryWaitPeriod' type='xs:long'/>
+      <xs:attribute name='copyMessageOnSend' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Should a JMS message be copied to a new JMS Message object as part of the
+send() method in JMS. This is enabled by default to be compliant with the
+JMS specification. You can disable it if you do not mutate JMS messages
+after they are sent for a performance boost
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='disableTimeStampsByDefault' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not timestamps on messages should be disabled or not. If
+you disable them it adds a small performance boost.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='dispatchAsync' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables the default setting of whether or not consumers have
+their messages <a
+href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
+synchronously or asynchronously by the broker</a>. For non-durable
+topics for example we typically dispatch synchronously by default to
+minimize context switches which boost performance. However sometimes its
+better to go slower to ensure that a single blocked consumer socket does
+not block delivery to other consumers.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='exceptionListener' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='exclusiveConsumer' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables or disables whether or not queue consumers should be exclusive or
+not for example to preserve ordering when not using <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a>
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='maxThreadPoolSize' type='xs:integer'/>
+      <xs:attribute name='messagePrioritySupported' type='xs:boolean'/>
+      <xs:attribute name='nestedMapAndListEnabled' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables/disables whether or not Message properties and MapMessage entries
+support <a
+href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
+Structures</a> of Map and List objects
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='nonBlockingRedelivery' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When true a MessageConsumer will not stop Message delivery before re-delivering Messages
+from a rolled back transaction.  This implies that message order will not be preserved and
+also will result in the TransactedIndividualAck option to be enabled.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='objectMessageSerializationDefered' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            When an object is set on an ObjectMessage, the JMS spec requires the
+object to be serialized by that set method. Enabling this flag causes the
+object to not get serialized. The object may subsequently get serialized
+if the message needs to be sent over a socket or stored to disk.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='optimizeAcknowledge' type='xs:boolean'/>
+      <xs:attribute name='optimizeAcknowledgeTimeOut' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            The max time in milliseconds between optimized ack batches
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='optimizedAckScheduledAckInterval' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
+to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
+will not do any background Message acknowledgment.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='optimizedMessageDispatch' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            If this flag is set then an larger prefetch limit is used - only
+applicable for durable topic subscribers.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='password' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JMS password used for connections created from this factory
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='prefetchPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the <a
+href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
+policy</a> for consumers created by this connection.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='producerWindowSize' type='xs:integer'/>
+      <xs:attribute name='properties' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Get the properties from this instance for storing in JNDI
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='redeliveryPolicy' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the global default redelivery policy to be used when a message is delivered
+but the session is rolled back
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='redeliveryPolicyMap' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the global redelivery policy mapping to be used when a message is delivered
+but the session is rolled back
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='rejectedTaskHandler' type='xs:string'/>
+      <xs:attribute name='sendAcksAsync' type='xs:boolean'/>
+      <xs:attribute name='sendTimeout' type='xs:integer'/>
+      <xs:attribute name='sessionTaskRunner' type='xs:string'/>
+      <xs:attribute name='statsEnabled' type='xs:boolean'/>
+      <xs:attribute name='transactedIndividualAck' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            when true, submit individual transacted acks immediately rather than with transaction completion.
+This allows the acks to represent delivery status which can be persisted on rollback
+Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='transformer' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the transformer used to transform messages before they are sent on
+to the JMS bus or when they are received from the bus but before they are
+delivered to the JMS client
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='transportListener' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Allows a listener to be configured on the ConnectionFactory so that when this factory is used
+with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
+a transport listener.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useAsyncSend' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Forces the use of <a
+href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
+adds a massive performance boost; but means that the send() method will
+return immediately whether the message has been sent or not which could
+lead to message loss.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useBeanNameAsClientIdPrefix' type='xs:boolean'/>
+      <xs:attribute name='useCompression' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables the use of compression of the message bodies
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
+      <xs:attribute name='useRetroactiveConsumer' type='xs:boolean'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets whether or not retroactive consumers are enabled. Retroactive
+consumers allow non-durable topic subscribers to receive old messages
+that were published before the non-durable subscriber started.
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='userName' type='xs:string'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Sets the JMS userName used by connections created by this factory
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='warnAboutUnstartedConnectionTimeout' type='xs:long'>
+        <xs:annotation>
+          <xs:documentation><![CDATA[
+            Enables the timeout from a connection creation to when a warning is
+generated if the connection is not properly started via
+{@link Connection#start()} and a message is received by a consumer. It is
+a very common gotcha to forget to <a
+href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
+the connection</a> so this option makes the default case to create a
+warning if the user forgets. To disable the warning just set the value to <
+0 (say -1).
+          ]]></xs:documentation>
+        </xs:annotation>
+      </xs:attribute>
+      <xs:attribute name='watchTopicAdvisories' type='xs:boolean'/>
+      <xs:attribute name='id' type='xs:ID'/>
+      <xs:anyAttribute namespace='##other' processContents='lax'/>
+    </xs:complexType>
+  </xs:element>
+
+
+</xs:schema>
diff --git a/activemq-core/src/main/resources/activemq.xsd.html b/activemq-core/src/main/resources/activemq.xsd.html
new file mode 100644
index 000000000..5e3ca8e3e
--- /dev/null
+++ b/activemq-core/src/main/resources/activemq.xsd.html
@@ -0,0 +1,2843 @@
+<!-- NOTE: this file is autogenerated by Apache XBean -->
+<html>
+<head>
+<title>Schema for namespace: http://activemq.apache.org/schema/core</title>
+<link rel='stylesheet' href='style.css' type='text/css'>
+<link rel='stylesheet' href='http://activemq.org/style.css' type='text/css'>
+<link rel='stylesheet' href='http://activemq.org/style-xb.css' type='text/css'>
+</head>
+
+<body>
+
+<h1>Root Element</h1>
+<table>
+  <tr><th>Element</th><th>Description</th><th>Class</th>
+  <tr><td><a href='#broker'>broker</a></td><td>An ActiveMQ Message Broker. It consists of a number of transport
+connectors, network connectors and a bunch of properties which can be used to
+configure the broker as its lazily created.</td><td>org.apache.activemq.xbean.XBeanBrokerService</td></tr>
+</table>
+
+<h1>Element Summary</h1>
+<table>
+  <tr><th>Element</th><th>Description</th><th>Class</th>
+  <tr><td><a href='#abortSlowConsumerStrategy'>abortSlowConsumerStrategy</a></td><td>Abort slow consumers when they reach the configured threshold of slowness, default is slow for 30 seconds</td><td>org.apache.activemq.broker.region.policy.AbortSlowConsumerStrategy</td></tr>
+  <tr><td><a href='#amqPersistenceAdapter'>amqPersistenceAdapter</a></td><td>An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.</td><td>org.apache.activemq.store.amq.AMQPersistenceAdapter</td></tr>
+  <tr><td><a href='#amqPersistenceAdapterFactory'>amqPersistenceAdapterFactory</a></td><td>An implementation of {@link PersistenceAdapterFactory}</td><td>org.apache.activemq.store.amq.AMQPersistenceAdapterFactory</td></tr>
+  <tr><td><a href='#authenticationUser'>authenticationUser</a></td><td>A helper object used to configure simple authentiaction plugin</td><td>org.apache.activemq.security.AuthenticationUser</td></tr>
+  <tr><td><a href='#authorizationEntry'>authorizationEntry</a></td><td>Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a specific
+destination or a hierarchical wildcard area of destinations.</td><td>org.apache.activemq.security.AuthorizationEntry</td></tr>
+  <tr><td><a href='#authorizationMap'>authorizationMap</a></td><td>Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies. Each entry in the map represents the authorization ACLs
+for each operation.</td><td>org.apache.activemq.security.DefaultAuthorizationMap</td></tr>
+  <tr><td><a href='#authorizationPlugin'>authorizationPlugin</a></td><td>An authorization plugin where each operation on a destination is checked
+against an authorizationMap</td><td>org.apache.activemq.security.AuthorizationPlugin</td></tr>
+  <tr><td><a href='#axionJDBCAdapter'>axionJDBCAdapter</a></td><td>Axion specific Adapter.
+
+Axion does not seem to support ALTER statements or sub-selects.  This means:
+- We cannot auto upgrade the schema was we roll out new versions of ActiveMQ
+- We cannot delete durable sub messages that have be acknowledged by all consumers.</td><td>org.apache.activemq.store.jdbc.adapter.AxionJDBCAdapter</td></tr>
+  <tr><td><a href='#blobJDBCAdapter'>blobJDBCAdapter</a></td><td>This JDBCAdapter inserts and extracts BLOB data using the getBlob()/setBlob()
+operations. This is a little more involved since to insert a blob you have
+to:
+
+1: insert empty blob. 2: select the blob 3: finally update the blob with data
+value.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul></td><td>org.apache.activemq.store.jdbc.adapter.BlobJDBCAdapter</td></tr>
+  <tr><td><a href='#broker'>broker</a></td><td>An ActiveMQ Message Broker. It consists of a number of transport
+connectors, network connectors and a bunch of properties which can be used to
+configure the broker as its lazily created.</td><td>org.apache.activemq.xbean.XBeanBrokerService</td></tr>
+  <tr><td><a href='#brokerService'>brokerService</a></td><td>Manages the lifecycle of an ActiveMQ Broker. A BrokerService consists of a
+number of transport connectors, network connectors and a bunch of properties
+which can be used to configure the broker as its lazily created.</td><td>org.apache.activemq.broker.BrokerService</td></tr>
+  <tr><td><a href='#bytesJDBCAdapter'>bytesJDBCAdapter</a></td><td>This JDBCAdapter inserts and extracts BLOB data using the
+setBytes()/getBytes() operations. The databases/JDBC drivers that use this
+adapter are:</td><td>org.apache.activemq.store.jdbc.adapter.BytesJDBCAdapter</td></tr>
+  <tr><td><a href='#cachedLDAPAuthorizationMap'>cachedLDAPAuthorizationMap</a></td><td>A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update authorization
+policy.</td><td>org.apache.activemq.security.CachedLDAPAuthorizationMap</td></tr>
+  <tr><td><a href='#commandAgent'>commandAgent</a></td><td>An agent which listens to commands on a JMS destination</td><td>org.apache.activemq.broker.util.CommandAgent</td></tr>
+  <tr><td><a href='#compositeDemandForwardingBridge'>compositeDemandForwardingBridge</a></td><td>A demand forwarding bridge which works with multicast style transports where
+a single Transport could be communicating with multiple remote brokers</td><td>org.apache.activemq.network.CompositeDemandForwardingBridge</td></tr>
+  <tr><td><a href='#compositeQueue'>compositeQueue</a></td><td>Represents a virtual queue which forwards to a number of other destinations.</td><td>org.apache.activemq.broker.region.virtual.CompositeQueue</td></tr>
+  <tr><td><a href='#compositeTopic'>compositeTopic</a></td><td>Represents a virtual topic which forwards to a number of other destinations.</td><td>org.apache.activemq.broker.region.virtual.CompositeTopic</td></tr>
+  <tr><td><a href='#conditionalNetworkBridgeFilterFactory'>conditionalNetworkBridgeFilterFactory</a></td><td>implement conditional behaviour for queue consumers,
+allows replaying back to origin if no consumers are present on the local broker
+after a configurable delay, irrespective of the networkTTL
+Also allows rate limiting of messages through the network, useful for static includes</td><td>org.apache.activemq.network.ConditionalNetworkBridgeFilterFactory</td></tr>
+  <tr><td><a href='#connectionDotFilePlugin'>connectionDotFilePlugin</a></td><td>A <a href="http://www.graphviz.org/">DOT</a> file creator plugin which
+creates a DOT file showing the current connections</td><td>org.apache.activemq.broker.view.ConnectionDotFilePlugin</td></tr>
+  <tr><td><a href='#connectionFactory'>connectionFactory</a></td><td>A <a href="http://www.springframework.org/">Spring</a> enhanced connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.</td><td>org.apache.activemq.spring.ActiveMQConnectionFactory</td></tr>
+  <tr><td><a href='#constantPendingMessageLimitStrategy'>constantPendingMessageLimitStrategy</a></td><td>This PendingMessageLimitStrategy is configured to a constant value for all subscriptions.</td><td>org.apache.activemq.broker.region.policy.ConstantPendingMessageLimitStrategy</td></tr>
+  <tr><td><a href='#database-locker'>database-locker</a></td><td>Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.</td><td>org.apache.activemq.store.jdbc.DefaultDatabaseLocker</td></tr>
+  <tr><td><a href='#db2JDBCAdapter'>db2JDBCAdapter</a></td><td></td><td>org.apache.activemq.store.jdbc.adapter.DB2JDBCAdapter</td></tr>
+  <tr><td><a href='#defaultIOExceptionHandler'>defaultIOExceptionHandler</a></td><td></td><td>org.apache.activemq.util.DefaultIOExceptionHandler</td></tr>
+  <tr><td><a href='#defaultJDBCAdapter'>defaultJDBCAdapter</a></td><td>Implements all the default JDBC operations that are used by the JDBCPersistenceAdapter. <p/> sub-classing is
+encouraged to override the default implementation of methods to account for differences in JDBC Driver
+implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using the getBytes()/setBytes() operations. <p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul></td><td>org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter</td></tr>
+  <tr><td><a href='#defaultNetworkBridgeFilterFactory'>defaultNetworkBridgeFilterFactory</a></td><td>implement default behaviour, filter that will not allow resend to origin
+based on brokerPath and which respects networkTTL</td><td>org.apache.activemq.network.DefaultNetworkBridgeFilterFactory</td></tr>
+  <tr><td><a href='#defaultUsageCapacity'>defaultUsageCapacity</a></td><td>Identify if a limit has been reached</td><td>org.apache.activemq.usage.DefaultUsageCapacity</td></tr>
+  <tr><td><a href='#demandForwardingBridge'>demandForwardingBridge</a></td><td>Forwards messages from the local broker to the remote broker based on demand.</td><td>org.apache.activemq.network.DemandForwardingBridge</td></tr>
+  <tr><td><a href='#destinationDotFilePlugin'>destinationDotFilePlugin</a></td><td>A <a href="http://www.graphviz.org/">DOT</a> 
+file creator plugin which creates a DOT file showing the current topic & queue hierarchies.</td><td>org.apache.activemq.broker.view.DestinationDotFilePlugin</td></tr>
+  <tr><td><a href='#destinationEntry'>destinationEntry</a></td><td>A default entry in a DestinationMap which holds a single value.</td><td>org.apache.activemq.filter.DefaultDestinationMapEntry</td></tr>
+  <tr><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a></td><td></td><td>org.apache.activemq.broker.util.DestinationPathSeparatorBroker</td></tr>
+  <tr><td><a href='#discardingDLQBrokerPlugin'>discardingDLQBrokerPlugin</a></td><td></td><td>org.apache.activemq.plugin.DiscardingDLQBrokerPlugin</td></tr>
+  <tr><td><a href='#fileCursor'>fileCursor</a></td><td>Pending messages</td><td>org.apache.activemq.broker.region.policy.FilePendingSubscriberMessageStoragePolicy</td></tr>
+  <tr><td><a href='#fileDurableSubscriberCursor'>fileDurableSubscriberCursor</a></td><td>Pending messages for durable subscribers</td><td>org.apache.activemq.broker.region.policy.FilePendingDurableSubscriberMessageStoragePolicy</td></tr>
+  <tr><td><a href='#fileQueueCursor'>fileQueueCursor</a></td><td>Pending</td><td>org.apache.activemq.broker.region.policy.FilePendingQueueMessageStoragePolicy</td></tr>
+  <tr><td><a href='#filteredDestination'>filteredDestination</a></td><td>Represents a destination which is filtered using some predicate such as a selector
+so that messages are only dispatched to the destination if they match the filter.</td><td>org.apache.activemq.broker.region.virtual.FilteredDestination</td></tr>
+  <tr><td><a href='#filteredKahaDB'>filteredKahaDB</a></td><td></td><td>org.apache.activemq.store.kahadb.FilteredKahaDBPersistenceAdapter</td></tr>
+  <tr><td><a href='#fixedCountSubscriptionRecoveryPolicy'>fixedCountSubscriptionRecoveryPolicy</a></td><td>This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+count of last messages.</td><td>org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy</td></tr>
+  <tr><td><a href='#fixedSizedSubscriptionRecoveryPolicy'>fixedSizedSubscriptionRecoveryPolicy</a></td><td>This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+amount of memory available in RAM for message history which is evicted in
+time order.</td><td>org.apache.activemq.broker.region.policy.FixedSizedSubscriptionRecoveryPolicy</td></tr>
+  <tr><td><a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a></td><td>A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.</td><td>org.apache.activemq.plugin.ForcePersistencyModeBroker</td></tr>
+  <tr><td><a href='#forcePersistencyModeBrokerPlugin'>forcePersistencyModeBrokerPlugin</a></td><td>A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.</td><td>org.apache.activemq.plugin.ForcePersistencyModeBrokerPlugin</td></tr>
+  <tr><td><a href='#forwardingBridge'>forwardingBridge</a></td><td>Forwards all messages from the local broker to the remote broker.</td><td>org.apache.activemq.network.ForwardingBridge</td></tr>
+  <tr><td><a href='#hsqldb-jdbc-adapter'>hsqldb-jdbc-adapter</a></td><td></td><td>org.apache.activemq.store.jdbc.adapter.HsqldbJDBCAdapter</td></tr>
+  <tr><td><a href='#imageBasedJDBCAdaptor'>imageBasedJDBCAdaptor</a></td><td>Provides JDBCAdapter since that uses
+IMAGE datatype to hold binary data.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Sybase</li>
+<li>MS SQL</li>
+</ul></td><td>org.apache.activemq.store.jdbc.adapter.ImageBasedJDBCAdaptor</td></tr>
+  <tr><td><a href='#inboundQueueBridge'>inboundQueueBridge</a></td><td>Create an Inbound Queue Bridge.  By default this class uses the sname name for
+both the inbound and outbound queue.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud queue names
+separately.</td><td>org.apache.activemq.network.jms.InboundQueueBridge</td></tr>
+  <tr><td><a href='#inboundTopicBridge'>inboundTopicBridge</a></td><td>Create an Inbound Topic Bridge.  By default this class uses the topic name for
+both the inbound and outbound topic.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud topic names
+separately.</td><td>org.apache.activemq.network.jms.InboundTopicBridge</td></tr>
+  <tr><td><a href='#individualDeadLetterStrategy'>individualDeadLetterStrategy</a></td><td>A {@link DeadLetterStrategy} where each destination has its own individual
+DLQ using the subject naming hierarchy.</td><td>org.apache.activemq.broker.region.policy.IndividualDeadLetterStrategy</td></tr>
+  <tr><td><a href='#informixJDBCAdapter'>informixJDBCAdapter</a></td><td>JDBC Adapter for Informix database.
+Because Informix database restricts length of composite primary keys, length of 
+<i>container name</i> field and <i>subscription id</i> field must be reduced to 150 characters.
+Therefore be sure not to use longer names for container name and subscription id than 150 characters.</td><td>org.apache.activemq.store.jdbc.adapter.InformixJDBCAdapter</td></tr>
+  <tr><td><a href='#jDBCIOExceptionHandler'>jDBCIOExceptionHandler</a></td><td></td><td>org.apache.activemq.store.jdbc.JDBCIOExceptionHandler</td></tr>
+  <tr><td><a href='#jaasAuthenticationPlugin'>jaasAuthenticationPlugin</a></td><td>Provides a JAAS based authentication plugin</td><td>org.apache.activemq.security.JaasAuthenticationPlugin</td></tr>
+  <tr><td><a href='#jaasCertificateAuthenticationPlugin'>jaasCertificateAuthenticationPlugin</a></td><td>Provides a JAAS based SSL certificate authentication plugin</td><td>org.apache.activemq.security.JaasCertificateAuthenticationPlugin</td></tr>
+  <tr><td><a href='#jaasDualAuthenticationPlugin'>jaasDualAuthenticationPlugin</a></td><td>Provides a JAAS based authentication plugin</td><td>org.apache.activemq.security.JaasDualAuthenticationPlugin</td></tr>
+  <tr><td><a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a></td><td>A {@link PersistenceAdapter} implementation using JDBC for persistence
+storage.
+
+This persistence adapter will correctly remember prepared XA transactions,
+but it will not keep track of local transaction commits so that operations
+performed against the Message store are done as a single uow.</td><td>org.apache.activemq.store.jdbc.JDBCPersistenceAdapter</td></tr>
+  <tr><td><a href='#jmsQueueConnector'>jmsQueueConnector</a></td><td>A Bridge to other JMS Queue providers</td><td>org.apache.activemq.network.jms.JmsQueueConnector</td></tr>
+  <tr><td><a href='#jmsTopicConnector'>jmsTopicConnector</a></td><td>A Bridge to other JMS Topic providers</td><td>org.apache.activemq.network.jms.JmsTopicConnector</td></tr>
+  <tr><td><a href='#journalPersistenceAdapter'>journalPersistenceAdapter</a></td><td>An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.</td><td>org.apache.activemq.store.journal.JournalPersistenceAdapter</td></tr>
+  <tr><td><a href='#journalPersistenceAdapterFactory'>journalPersistenceAdapterFactory</a></td><td>Factory class that can create PersistenceAdapter objects.</td><td>org.apache.activemq.store.journal.JournalPersistenceAdapterFactory</td></tr>
+  <tr><td><a href='#journaledJDBC'>journaledJDBC</a></td><td>Creates a default persistence model using the Journal and JDBC</td><td>org.apache.activemq.store.PersistenceAdapterFactoryBean</td></tr>
+  <tr><td><a href='#kahaDB'>kahaDB</a></td><td>An implementation of {@link PersistenceAdapter} designed for use with
+KahaDB - Embedded Lightweight Non-Relational Database</td><td>org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter</td></tr>
+  <tr><td><a href='#kahaPersistenceAdapter'>kahaPersistenceAdapter</a></td><td></td><td>org.apache.activemq.store.kahadaptor.KahaPersistenceAdapter</td></tr>
+  <tr><td><a href='#lDAPAuthorizationMap'>lDAPAuthorizationMap</a></td><td>An {@link AuthorizationMap} which uses LDAP</td><td>org.apache.activemq.security.LDAPAuthorizationMap</td></tr>
+  <tr><td><a href='#lastImageSubscriptionRecoveryPolicy'>lastImageSubscriptionRecoveryPolicy</a></td><td>This implementation of {@link SubscriptionRecoveryPolicy} will only keep the
+last message.</td><td>org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy</td></tr>
+  <tr><td><a href='#ldapNetworkConnector'>ldapNetworkConnector</a></td><td>class to create dynamic network connectors listed in an directory
+server using the LDAP v3 protocol as defined in RFC 2251, the
+entries listed in the directory server must implement the ipHost
+and ipService objectClasses as defined in RFC 2307.</td><td>org.apache.activemq.network.LdapNetworkConnector</td></tr>
+  <tr><td><a href='#lease-database-locker'>lease-database-locker</a></td><td>Represents an exclusive lease on a database to avoid multiple brokers running
+against the same logical database.</td><td>org.apache.activemq.store.jdbc.LeaseDatabaseLocker</td></tr>
+  <tr><td><a href='#levelDB'>levelDB</a></td><td>An implementation of {@link org.apache.activemq.store.PersistenceAdapter} designed for use with
+LevelDB - Embedded Lightweight Non-Relational Database</td><td>org.apache.activemq.store.leveldb.LevelDBPersistenceAdapter</td></tr>
+  <tr><td><a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a></td><td>A simple Broker intercepter which allows you to enable/disable logging.</td><td>org.apache.activemq.broker.util.LoggingBrokerPlugin</td></tr>
+  <tr><td><a href='#mKahaDB'>mKahaDB</a></td><td>An implementation of {@link org.apache.activemq.store.PersistenceAdapter}  that supports
+distribution of destinations across multiple kahaDB persistence adapters</td><td>org.apache.activemq.store.kahadb.MultiKahaDBPersistenceAdapter</td></tr>
+  <tr><td><a href='#managementContext'>managementContext</a></td><td>An abstraction over JMX mbean registration</td><td>org.apache.activemq.broker.jmx.ManagementContext</td></tr>
+  <tr><td><a href='#masterConnector'>masterConnector</a></td><td>Connects a Slave Broker to a Master when using <a
+href="http://activemq.apache.org/masterslave.html">Master Slave</a> for High
+Availability of messages.</td><td>org.apache.activemq.broker.ft.MasterConnector</td></tr>
+  <tr><td><a href='#maxdb-jdbc-adapter'>maxdb-jdbc-adapter</a></td><td>JDBC Adapter for the MaxDB database.</td><td>org.apache.activemq.store.jdbc.adapter.MaxDBJDBCAdapter</td></tr>
+  <tr><td><a href='#memoryPersistenceAdapter'>memoryPersistenceAdapter</a></td><td></td><td>org.apache.activemq.store.memory.MemoryPersistenceAdapter</td></tr>
+  <tr><td><a href='#memoryUsage'>memoryUsage</a></td><td>Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.</td><td>org.apache.activemq.usage.MemoryUsage</td></tr>
+  <tr><td><a href='#messageGroupHashBucketFactory'>messageGroupHashBucketFactory</a></td><td>A factory to create instances of {@link SimpleMessageGroupMap} when
+implementing the <a
+href="http://activemq.apache.org/message-groups.html">Message
+Groups</a> functionality.</td><td>org.apache.activemq.broker.region.group.MessageGroupHashBucketFactory</td></tr>
+  <tr><td><a href='#mirroredQueue'>mirroredQueue</a></td><td>Creates <a href="http://activemq.org/site/mirrored-queues.html">Mirrored
+Queue</a> using a prefix and postfix to define the topic name on which to mirror the queue to.</td><td>org.apache.activemq.broker.region.virtual.MirroredQueue</td></tr>
+  <tr><td><a href='#multicastNetworkConnector'>multicastNetworkConnector</a></td><td>A network connector which uses some kind of multicast-like transport that
+communicates with potentially many remote brokers over a single logical
+{@link Transport} instance such as when using multicast.
+
+This implementation does not depend on multicast at all; any other group
+based transport could be used.</td><td>org.apache.activemq.network.MulticastNetworkConnector</td></tr>
+  <tr><td><a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a></td><td>A Broker interceptor which allows you to trace all operations to a Multicast
+socket.</td><td>org.apache.activemq.broker.util.MulticastTraceBrokerPlugin</td></tr>
+  <tr><td><a href='#mysql-jdbc-adapter'>mysql-jdbc-adapter</a></td><td></td><td>org.apache.activemq.store.jdbc.adapter.MySqlJDBCAdapter</td></tr>
+  <tr><td><a href='#networkConnector'>networkConnector</a></td><td>A network connector which uses a discovery agent to detect the remote brokers
+available and setup a connection to each available remote broker</td><td>org.apache.activemq.network.DiscoveryNetworkConnector</td></tr>
+  <tr><td><a href='#noSubscriptionRecoveryPolicy'>noSubscriptionRecoveryPolicy</a></td><td>This SubscriptionRecoveryPolicy disable recovery of messages.</td><td>org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy</td></tr>
+  <tr><td><a href='#oldestMessageEvictionStrategy'>oldestMessageEvictionStrategy</a></td><td>An eviction strategy which evicts the oldest message first (which is the
+default).</td><td>org.apache.activemq.broker.region.policy.OldestMessageEvictionStrategy</td></tr>
+  <tr><td><a href='#oldestMessageWithLowestPriorityEvictionStrategy'>oldestMessageWithLowestPriorityEvictionStrategy</a></td><td>An eviction strategy which evicts the oldest message with the lowest priority first.</td><td>org.apache.activemq.broker.region.policy.OldestMessageWithLowestPriorityEvictionStrategy</td></tr>
+  <tr><td><a href='#oracleBlobJDBCAdapter'>oracleBlobJDBCAdapter</a></td><td>Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul></td><td>org.apache.activemq.store.jdbc.adapter.OracleBlobJDBCAdapter</td></tr>
+  <tr><td><a href='#oracleJDBCAdapter'>oracleJDBCAdapter</a></td><td>Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/></td><td>org.apache.activemq.store.jdbc.adapter.OracleJDBCAdapter</td></tr>
+  <tr><td><a href='#outboundQueueBridge'>outboundQueueBridge</a></td><td>Create an Outbound Queue Bridge.  By default the bridge uses the same
+name for both the inbound and outbound queues, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+queue names.</td><td>org.apache.activemq.network.jms.OutboundQueueBridge</td></tr>
+  <tr><td><a href='#outboundTopicBridge'>outboundTopicBridge</a></td><td>Create an Outbound Topic Bridge.  By default the bridge uses the same
+name for both the inbound and outbound topics, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+topic names.</td><td>org.apache.activemq.network.jms.OutboundTopicBridge</td></tr>
+  <tr><td><a href='#pListStore'>pListStore</a></td><td></td><td>org.apache.activemq.store.kahadb.plist.PListStore</td></tr>
+  <tr><td><a href='#policyEntry'>policyEntry</a></td><td>Represents an entry in a {@link PolicyMap} for assigning policies to a
+specific destination or a hierarchical wildcard area of destinations.</td><td>org.apache.activemq.broker.region.policy.PolicyEntry</td></tr>
+  <tr><td><a href='#policyMap'>policyMap</a></td><td>Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.</td><td>org.apache.activemq.broker.region.policy.PolicyMap</td></tr>
+  <tr><td><a href='#postgresql-jdbc-adapter'>postgresql-jdbc-adapter</a></td><td>Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul></td><td>org.apache.activemq.store.jdbc.adapter.PostgresqlJDBCAdapter</td></tr>
+  <tr><td><a href='#prefetchPolicy'>prefetchPolicy</a></td><td>Defines the prefetch message policies for different types of consumers</td><td>org.apache.activemq.ActiveMQPrefetchPolicy</td></tr>
+  <tr><td><a href='#prefetchRatePendingMessageLimitStrategy'>prefetchRatePendingMessageLimitStrategy</a></td><td>This PendingMessageLimitStrategy sets the maximum pending message limit value to be
+a multiplier of the prefetch limit of the subscription.</td><td>org.apache.activemq.broker.region.policy.PrefetchRatePendingMessageLimitStrategy</td></tr>
+  <tr><td><a href='#priorityNetworkDispatchPolicy'>priorityNetworkDispatchPolicy</a></td><td>dispatch policy that ignores lower priority duplicate network consumers,
+used in conjunction with network bridge suppresDuplicateTopicSubscriptions</td><td>org.apache.activemq.broker.region.policy.PriorityNetworkDispatchPolicy</td></tr>
+  <tr><td><a href='#proxyConnector'>proxyConnector</a></td><td></td><td>org.apache.activemq.proxy.ProxyConnector</td></tr>
+  <tr><td><a href='#queryBasedSubscriptionRecoveryPolicy'>queryBasedSubscriptionRecoveryPolicy</a></td><td>This implementation of {@link SubscriptionRecoveryPolicy} will perform a user
+specific query mechanism to load any messages they may have missed.</td><td>org.apache.activemq.broker.region.policy.QueryBasedSubscriptionRecoveryPolicy</td></tr>
+  <tr><td><a href='#queue'>queue</a></td><td>An ActiveMQ Queue</td><td>org.apache.activemq.command.ActiveMQQueue</td></tr>
+  <tr><td><a href='#queueDispatchSelector'>queueDispatchSelector</a></td><td>Queue dispatch policy that determines if a message can be sent to a subscription</td><td>org.apache.activemq.broker.region.QueueDispatchSelector</td></tr>
+  <tr><td><a href='#reconnectionPolicy'>reconnectionPolicy</a></td><td>A policy object that defines how a {@link JmsConnector} deals with
+reconnection of the local and foreign connections.</td><td>org.apache.activemq.network.jms.ReconnectionPolicy</td></tr>
+  <tr><td><a href='#redeliveryPlugin'>redeliveryPlugin</a></td><td>Replace regular DLQ handling with redelivery via a resend to the original destination
+after a delay
+A destination matching RedeliveryPolicy controls the quantity and delay for re-sends
+If there is no matching policy or an existing policy limit is exceeded by default
+regular DLQ processing resumes. This is controlled via sendToDlqIfMaxRetriesExceeded
+and fallbackToDeadLetter</td><td>org.apache.activemq.broker.util.RedeliveryPlugin</td></tr>
+  <tr><td><a href='#redeliveryPolicy'>redeliveryPolicy</a></td><td>Configuration options for a messageConsumer used to control how messages are re-delivered when they
+are rolled back.
+May be used server side on a per destination basis via the Broker RedeliveryPlugin</td><td>org.apache.activemq.RedeliveryPolicy</td></tr>
+  <tr><td><a href='#redeliveryPolicyMap'>redeliveryPolicyMap</a></td><td>Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.</td><td>org.apache.activemq.broker.region.policy.RedeliveryPolicyMap</td></tr>
+  <tr><td><a href='#roundRobinDispatchPolicy'>roundRobinDispatchPolicy</a></td><td>Simple dispatch policy that sends a message to every subscription that
+matches the message.</td><td>org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy</td></tr>
+  <tr><td><a href='#shared-file-locker'>shared-file-locker</a></td><td>Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.</td><td>org.apache.activemq.store.SharedFileLocker</td></tr>
+  <tr><td><a href='#sharedDeadLetterStrategy'>sharedDeadLetterStrategy</a></td><td>A default implementation of {@link DeadLetterStrategy} which uses
+a constant destination.</td><td>org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy</td></tr>
+  <tr><td><a href='#simpleAuthenticationPlugin'>simpleAuthenticationPlugin</a></td><td>Provides a simple authentication plugin</td><td>org.apache.activemq.security.SimpleAuthenticationPlugin</td></tr>
+  <tr><td><a href='#simpleAuthorizationMap'>simpleAuthorizationMap</a></td><td>An AuthorizationMap which is configured with individual DestinationMaps for
+each operation.</td><td>org.apache.activemq.security.SimpleAuthorizationMap</td></tr>
+  <tr><td><a href='#simpleDispatchPolicy'>simpleDispatchPolicy</a></td><td>Simple dispatch policy that sends a message to every subscription that
+matches the message.</td><td>org.apache.activemq.broker.region.policy.SimpleDispatchPolicy</td></tr>
+  <tr><td><a href='#simpleDispatchSelector'>simpleDispatchSelector</a></td><td>Simple dispatch policy that determines if a message can be sent to a subscription</td><td>org.apache.activemq.broker.region.policy.SimpleDispatchSelector</td></tr>
+  <tr><td><a href='#simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></td><td>Converts Message from one JMS to another</td><td>org.apache.activemq.network.jms.SimpleJmsMessageConvertor</td></tr>
+  <tr><td><a href='#simpleMessageGroupMapFactory'>simpleMessageGroupMapFactory</a></td><td>A factory to create instances of {@link SimpleMessageGroupMap} when implementing the 
+<a href="http://activemq.apache.org/message-groups.html">Message Groups</a> functionality.</td><td>org.apache.activemq.broker.region.group.SimpleMessageGroupMapFactory</td></tr>
+  <tr><td><a href='#sslContext'>sslContext</a></td><td>Extends the SslContext so that it's easier to configure from spring.</td><td>org.apache.activemq.spring.SpringSslContext</td></tr>
+  <tr><td><a href='#statements'>statements</a></td><td></td><td>org.apache.activemq.store.jdbc.Statements</td></tr>
+  <tr><td><a href='#statisticsBrokerPlugin'>statisticsBrokerPlugin</a></td><td>A StatisticsBrokerPlugin
+You can retrieve a Map Message for a Destination - or
+Broker containing statistics as key-value pairs The message must contain a
+replyTo Destination - else its ignored
+To retrieve stats on the broker send a empty message to ActiveMQ.Statistics.Broker (Queue or Topic)
+With a replyTo set to the destination you want the stats returned to.
+To retrieve stats for a destination - e.g. foo - send an empty message to ActiveMQ.Statistics.Destination.foo
+- this works with wildcards to - you get a message for each wildcard match on the replyTo destination.
+The stats message is a MapMessage populated with statistics for the target</td><td>org.apache.activemq.plugin.StatisticsBrokerPlugin</td></tr>
+  <tr><td><a href='#storeCursor'>storeCursor</a></td><td>Pending messages</td><td>org.apache.activemq.broker.region.policy.StorePendingQueueMessageStoragePolicy</td></tr>
+  <tr><td><a href='#storeDurableSubscriberCursor'>storeDurableSubscriberCursor</a></td><td>Pending messages for a durable</td><td>org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy</td></tr>
+  <tr><td><a href='#storeUsage'>storeUsage</a></td><td>Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.</td><td>org.apache.activemq.usage.StoreUsage</td></tr>
+  <tr><td><a href='#streamJDBCAdapter'>streamJDBCAdapter</a></td><td>This JDBCAdapter inserts and extracts BLOB data using the
+setBinaryStream()/getBinaryStream() operations.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Axion</li>
+</ul></td><td>org.apache.activemq.store.jdbc.adapter.StreamJDBCAdapter</td></tr>
+  <tr><td><a href='#strictOrderDispatchPolicy'>strictOrderDispatchPolicy</a></td><td>Dispatch policy that causes every subscription to see messages in the same
+order.</td><td>org.apache.activemq.broker.region.policy.StrictOrderDispatchPolicy</td></tr>
+  <tr><td><a href='#sybase-jdbc-adapter'>sybase-jdbc-adapter</a></td><td>A JDBC Adapter for Sybase databases</td><td>org.apache.activemq.store.jdbc.adapter.SybaseJDBCAdapter</td></tr>
+  <tr><td><a href='#systemUsage'>systemUsage</a></td><td>Holder for Usage instances for memory, store and temp files Main use case is
+manage memory usage.</td><td>org.apache.activemq.usage.SystemUsage</td></tr>
+  <tr><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td>Manages the thread pool for long running tasks. Long running tasks are not
+always active but when they are active, they may need a few iterations of
+processing for them to become idle. The manager ensures that each task is
+processes but that no one task overtakes the system. This is kinda like
+cooperative multitasking.</td><td>org.apache.activemq.thread.TaskRunnerFactory</td></tr>
+  <tr><td><a href='#tempDestinationAuthorizationEntry'>tempDestinationAuthorizationEntry</a></td><td>Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a temporary
+destination</td><td>org.apache.activemq.security.TempDestinationAuthorizationEntry</td></tr>
+  <tr><td><a href='#tempQueue'>tempQueue</a></td><td>An ActiveMQ Temporary Queue Destination</td><td>org.apache.activemq.command.ActiveMQTempQueue</td></tr>
+  <tr><td><a href='#tempTopic'>tempTopic</a></td><td>An ActiveMQ Temporary Topic Destination</td><td>org.apache.activemq.command.ActiveMQTempTopic</td></tr>
+  <tr><td><a href='#tempUsage'>tempUsage</a></td><td>Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.</td><td>org.apache.activemq.usage.TempUsage</td></tr>
+  <tr><td><a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a></td><td>A Broker interceptor which updates a JMS Client's timestamp on the message
+with a broker timestamp. Useful when the clocks on client machines are known
+to not be correct and you can only trust the time set on the broker machines.
+
+Enabling this plugin will break JMS compliance since the timestamp that the
+producer sees on the messages after as send() will be different from the
+timestamp the consumer will observe when he receives the message. This plugin
+is not enabled in the default ActiveMQ configuration.
+
+2 new attributes have been added which will allow the administrator some override control
+over the expiration time for incoming messages:
+
+Attribute 'zeroExpirationOverride' can be used to apply an expiration
+time to incoming messages with no expiration defined (messages that would never expire)
+
+Attribute 'ttlCeiling' can be used to apply a limit to the expiration time</td><td>org.apache.activemq.broker.util.TimeStampingBrokerPlugin</td></tr>
+  <tr><td><a href='#timedSubscriptionRecoveryPolicy'>timedSubscriptionRecoveryPolicy</a></td><td>This implementation of {@link SubscriptionRecoveryPolicy} will keep a timed
+buffer of messages around in memory and use that to recover new
+subscriptions.</td><td>org.apache.activemq.broker.region.policy.TimedSubscriptionRecoveryPolicy</td></tr>
+  <tr><td><a href='#topic'>topic</a></td><td>An ActiveMQ Topic</td><td>org.apache.activemq.command.ActiveMQTopic</td></tr>
+  <tr><td><a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a></td><td>The TraceBrokerPathPlugin can be used in a network of Brokers. Each Broker
+that has the plugin configured, will add it's brokerName to the content
+of a JMS Property. If all Brokers have this property enabled, the path the
+message actually took through the network can be seen in the defined property.</td><td>org.apache.activemq.broker.util.TraceBrokerPathPlugin</td></tr>
+  <tr><td><a href='#transact-database-locker'>transact-database-locker</a></td><td>Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.</td><td>org.apache.activemq.store.jdbc.adapter.TransactDatabaseLocker</td></tr>
+  <tr><td><a href='#transact-jdbc-adapter'>transact-jdbc-adapter</a></td><td>A JDBC Adapter for Transact-SQL based databases such as SQL Server or Sybase</td><td>org.apache.activemq.store.jdbc.adapter.TransactJDBCAdapter</td></tr>
+  <tr><td><a href='#transportConnector'>transportConnector</a></td><td></td><td>org.apache.activemq.broker.TransportConnector</td></tr>
+  <tr><td><a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td>A Broker interceptor which allows you to trace all operations to a UDP
+socket.</td><td>org.apache.activemq.broker.util.UDPTraceBrokerPlugin</td></tr>
+  <tr><td><a href='#uniquePropertyMessageEvictionStrategy'>uniquePropertyMessageEvictionStrategy</a></td><td>An eviction strategy which evicts the oldest message within messages with the same property value</td><td>org.apache.activemq.broker.region.policy.UniquePropertyMessageEvictionStrategy</td></tr>
+  <tr><td><a href='#usageCapacity'>usageCapacity</a></td><td>Identify if a limit has been reached</td><td>org.apache.activemq.usage.UsageCapacity</td></tr>
+  <tr><td><a href='#virtualDestinationInterceptor'>virtualDestinationInterceptor</a></td><td>Implements <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual Topics</a>.</td><td>org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor</td></tr>
+  <tr><td><a href='#virtualSelectorCacheBrokerPlugin'>virtualSelectorCacheBrokerPlugin</a></td><td>A plugin which allows the caching of the selector from a subscription queue.
+<p/>
+This stops the build-up of unwanted messages, especially when consumers may
+disconnect from time to time when using virtual destinations.
+<p/>
+This is influenced by code snippets developed by Maciej Rakowicz</td><td>org.apache.activemq.plugin.SubQueueSelectorCacheBrokerPlugin</td></tr>
+  <tr><td><a href='#virtualTopic'>virtualTopic</a></td><td>Creates <a href="http://activemq.org/site/virtual-destinations.html">Virtual
+Topics</a> using a prefix and postfix. The virtual destination creates a
+wildcard that is then used to look up all active queue subscriptions which
+match.</td><td>org.apache.activemq.broker.region.virtual.VirtualTopic</td></tr>
+  <tr><td><a href='#vmCursor'>vmCursor</a></td><td>Pending messages held</td><td>org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy</td></tr>
+  <tr><td><a href='#vmDurableCursor'>vmDurableCursor</a></td><td>Pending</td><td>org.apache.activemq.broker.region.policy.VMPendingDurableSubscriberMessageStoragePolicy</td></tr>
+  <tr><td><a href='#vmQueueCursor'>vmQueueCursor</a></td><td>Pending messages</td><td>org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy</td></tr>
+  <tr><td><a href='#xaConnectionFactory'>xaConnectionFactory</a></td><td>A <a href="http://www.springframework.org/">Spring</a> enhanced XA connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.</td><td>org.apache.activemq.spring.ActiveMQXAConnectionFactory</td></tr>
+</table>
+
+
+<h1>Element Detail</h1>
+<h2>Element: <a name='abortSlowConsumerStrategy'>abortSlowConsumerStrategy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>abortConnection</td><td>xs:boolean</td><td>abort the consumers connection rather than sending a stop command to the remote consumer</td></tr>
+  <tr><td>checkPeriod</td><td>xs:long</td><td>time in milliseconds between checks for slow subscriptions</td></tr>
+  <tr><td>maxSlowCount</td><td>xs:long</td><td>number of times a subscription can be deemed slow before triggering abort
+effect depends on dispatch rate as slow determination is done on dispatch</td></tr>
+  <tr><td>maxSlowDuration</td><td>xs:long</td><td>time in milliseconds that a sub can remain slow before triggering
+an abort.</td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='amqPersistenceAdapter'>amqPersistenceAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>archiveDataLogs</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>checkpointInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>cleanupInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>directory</td><td>xs:string</td><td></td></tr>
+  <tr><td>directoryArchive</td><td>xs:string</td><td></td></tr>
+  <tr><td>disableLocking</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>forceRecoverReferenceStore</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>indexBinSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexKeySize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexLoadFactor</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexMaxBinSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexPageSize</td><td>xs:string</td><td>When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>journalThreadPriority</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxCheckpointMessageAddSize</td><td>xs:string</td><td>When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>maxFileLength</td><td>xs:string</td><td>When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>maxReferenceFileLength</td><td>xs:string</td><td>When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>persistentIndex</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>recoverReferenceStore</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>syncOnWrite</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useDedicatedTaskRunner</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useNio</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>asyncDataManager</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>referenceStoreAdapter</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>taskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+  <tr><td>usageManager</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+  <tr><td>wireFormat</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='amqPersistenceAdapterFactory'>amqPersistenceAdapterFactory</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>checkpointInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>cleanupInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>dataDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>forceRecoverReferenceStore</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>indexBinSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexKeySize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexLoadFactor</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexMaxBinSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexPageSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>journalThreadPriority</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxFileLength</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxReferenceFileLength</td><td>xs:integer</td><td></td></tr>
+  <tr><td>persistentIndex</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>recoverReferenceStore</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>syncOnTransaction</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>syncOnWrite</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useDedicatedTaskRunner</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useNio</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>referenceStoreAdapter</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>taskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='authenticationUser'>authenticationUser</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>groups</td><td>xs:string</td><td></td></tr>
+  <tr><td>password</td><td>xs:string</td><td></td></tr>
+  <tr><td>username</td><td>xs:string</td><td></td></tr>
+</table>
+<h2>Element: <a name='authorizationEntry'>authorizationEntry</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>admin</td><td>xs:string</td><td></td></tr>
+  <tr><td>groupClass</td><td>xs:string</td><td></td></tr>
+  <tr><td>queue</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>read</td><td>xs:string</td><td></td></tr>
+  <tr><td>tempQueue</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>tempTopic</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>topic</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>write</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminACLs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>destination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+  <tr><td>readACLs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>writeACLs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='authorizationMap'>authorizationMap</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>authorizationEntries</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets the individual entries on the authorization map</td></tr>
+  <tr><td>defaultEntry</td><td><a href='#authorizationEntry'>authorizationEntry</a> | <a href='#tempDestinationAuthorizationEntry'>tempDestinationAuthorizationEntry</a></td><td></td></tr>
+  <tr><td>entries</td><td>(&lt;spring:bean/&gt;)*</td><td>A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring</td></tr>
+  <tr><td>tempDestinationAuthorizationEntry</td><td><a href='#tempDestinationAuthorizationEntry'>tempDestinationAuthorizationEntry</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='authorizationPlugin'>authorizationPlugin</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>map</td><td><a href='#authorizationMap'>authorizationMap</a> | <a href='#cachedLDAPAuthorizationMap'>cachedLDAPAuthorizationMap</a> | <a href='#lDAPAuthorizationMap'>lDAPAuthorizationMap</a> | <a href='#simpleAuthorizationMap'>simpleAuthorizationMap</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='axionJDBCAdapter'>axionJDBCAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='blobJDBCAdapter'>blobJDBCAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='broker'>broker</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>advisorySupport</td><td>xs:string</td><td>Allows the support of advisory messages to be disabled for performance
+reasons.</td></tr>
+  <tr><td>allowTempAutoCreationOnSend</td><td>xs:boolean</td><td>enable if temp destinations need to be propagated through a network when
+advisorySupport==false. This is used in conjunction with the policy
+gcInactiveDestinations for matching temps so they can get removed
+when inactive</td></tr>
+  <tr><td>brokerId</td><td>xs:string</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td>Sets the name of this broker; which must be unique in the network</td></tr>
+  <tr><td>brokerObjectName</td><td>xs:string</td><td>Sets the JMX ObjectName for this broker</td></tr>
+  <tr><td>cacheTempDestinations</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>consumerSystemUsagePortion</td><td>xs:integer</td><td></td></tr>
+  <tr><td>dataDirectory</td><td>xs:string</td><td>Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.</td></tr>
+  <tr><td>dataDirectoryFile</td><td>xs:string</td><td>Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.</td></tr>
+  <tr><td>dedicatedTaskRunner</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>deleteAllMessagesOnStartup</td><td>xs:string</td><td>Sets whether or not all messages are deleted on startup - mostly only
+useful for testing.</td></tr>
+  <tr><td>enableStatistics</td><td>xs:boolean</td><td>Sets whether or not the Broker's services enable statistics or not.</td></tr>
+  <tr><td>keepDurableSubsActive</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>masterConnectorURI</td><td>xs:string</td><td></td></tr>
+  <tr><td>maxPurgedDestinationsPerSweep</td><td>xs:integer</td><td></td></tr>
+  <tr><td>mbeanInvocationTimeout</td><td>xs:long</td><td>Gets the time in Milliseconds that an invocation of an MBean method will wait before
+failing.  The default value is to wait forever (zero).</td></tr>
+  <tr><td>monitorConnectionSplits</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>networkConnectorStartAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>offlineDurableSubscriberTaskSchedule</td><td>xs:integer</td><td></td></tr>
+  <tr><td>offlineDurableSubscriberTimeout</td><td>xs:integer</td><td></td></tr>
+  <tr><td>passiveSlave</td><td>xs:string</td><td>Get the passiveSlave</td></tr>
+  <tr><td>persistenceThreadPriority</td><td>xs:integer</td><td></td></tr>
+  <tr><td>persistent</td><td>xs:string</td><td>Sets whether or not persistence is enabled or disabled.</td></tr>
+  <tr><td>populateJMSXUserID</td><td>xs:boolean</td><td>Sets whether or not the broker should populate the JMSXUserID header.</td></tr>
+  <tr><td>populateUserNameInMBeans</td><td>xs:boolean</td><td>Should MBeans that support showing the Authenticated User Name information have this
+value filled in or not.</td></tr>
+  <tr><td>producerSystemUsagePortion</td><td>xs:integer</td><td></td></tr>
+  <tr><td>schedulePeriodForDestinationPurge</td><td>xs:integer</td><td></td></tr>
+  <tr><td>schedulerDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>schedulerDirectoryFile</td><td>xs:string</td><td></td></tr>
+  <tr><td>schedulerSupport</td><td>xs:string</td><td></td></tr>
+  <tr><td>shutdownOnMasterFailure</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>shutdownOnSlaveFailure</td><td>xs:string</td><td></td></tr>
+  <tr><td>splitSystemUsageForProducersConsumers</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>start</td><td>xs:boolean</td><td>Sets whether or not the broker is started along with the ApplicationContext it is defined within.
+Normally you would want the broker to start up along with the ApplicationContext but sometimes when working
+with JUnit tests you may wish to start and stop the broker explicitly yourself.</td></tr>
+  <tr><td>startAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>supportFailOver</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>systemExitOnShutdown</td><td>xs:string</td><td></td></tr>
+  <tr><td>systemExitOnShutdownExitCode</td><td>xs:integer</td><td></td></tr>
+  <tr><td>taskRunnerPriority</td><td>xs:integer</td><td></td></tr>
+  <tr><td>timeBeforePurgeTempDestinations</td><td>xs:integer</td><td></td></tr>
+  <tr><td>tmpDataDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>useAuthenticatedPrincipalForJMSXUserID</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useJmx</td><td>xs:string</td><td>Sets whether or not the Broker's services should be exposed into JMX or
+not.</td></tr>
+  <tr><td>useLocalHostBrokerName</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useLoggingForShutdownErrors</td><td>xs:boolean</td><td>Sets whether or not we should use commons-logging when reporting errors
+when shutting down the broker</td></tr>
+  <tr><td>useMirroredQueues</td><td>xs:boolean</td><td>Sets whether or not <a
+href="http://activemq.apache.org/mirrored-queues.html">Mirrored
+Queues</a> should be supported by default if they have not been
+explicitly configured.</td></tr>
+  <tr><td>useShutdownHook</td><td>xs:boolean</td><td>Sets whether or not we should use a shutdown handler to close down the
+broker cleanly if the JVM is terminated. It is recommended you leave this
+enabled.</td></tr>
+  <tr><td>useTempMirroredQueues</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useVirtualTopics</td><td>xs:boolean</td><td>Sets whether or not <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual
+Topics</a> should be supported by default if they have not been
+explicitly configured.</td></tr>
+  <tr><td>vmConnectorURI</td><td>xs:string</td><td></td></tr>
+  <tr><td>waitForSlave</td><td>xs:string</td><td></td></tr>
+  <tr><td>waitForSlaveTimeout</td><td>xs:long</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminView</td><td>&lt;spring:bean/&gt;</td><td>Returns the administration view of the broker; used to create and destroy
+resources such as queues and topics. Note this method returns null if JMX
+is disabled.</td></tr>
+  <tr><td>brokerContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerSystemUsage</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+  <tr><td>destinationFactory</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>destinationInterceptors</td><td>(<a href='#mirroredQueue'>mirroredQueue</a> | <a href='#virtualDestinationInterceptor'>virtualDestinationInterceptor</a>)*</td><td>Sets the destination interceptors to use</td></tr>
+  <tr><td>destinationPolicy</td><td><a href='#policyMap'>policyMap</a></td><td>Sets the destination specific policies available either for exact
+destinations or for wildcard areas of destinations.</td></tr>
+  <tr><td>destinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td>Sets the destinations which should be loaded/created on startup</td></tr>
+  <tr><td>ioExceptionHandler</td><td><a href='#defaultIOExceptionHandler'>defaultIOExceptionHandler</a> | <a href='#jDBCIOExceptionHandler'>jDBCIOExceptionHandler</a></td><td>override the Default IOException handler, called when persistence adapter
+has experiences File or JDBC I/O Exceptions</td></tr>
+  <tr><td>jmsBridgeConnectors</td><td>(<a href='#jmsQueueConnector'>jmsQueueConnector</a> | <a href='#jmsTopicConnector'>jmsTopicConnector</a>)*</td><td></td></tr>
+  <tr><td>managementContext</td><td><a href='#managementContext'>managementContext</a></td><td></td></tr>
+  <tr><td>messageAuthorizationPolicy</td><td>&lt;spring:bean/&gt;</td><td>Sets the policy used to decide if the current connection is authorized to
+consume a given message</td></tr>
+  <tr><td>networkConnectorURIs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>networkConnectors</td><td>(<a href='#ldapNetworkConnector'>ldapNetworkConnector</a> | <a href='#multicastNetworkConnector'>multicastNetworkConnector</a> | <a href='#networkConnector'>networkConnector</a>)*</td><td>Sets the network connectors which this broker will use to connect to
+other brokers in a federated network</td></tr>
+  <tr><td>persistenceAdapter</td><td><a href='#amqPersistenceAdapter'>amqPersistenceAdapter</a> | <a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a> | <a href='#journalPersistenceAdapter'>journalPersistenceAdapter</a> | <a href='#kahaDB'>kahaDB</a> | <a href='#kahaPersistenceAdapter'>kahaPersistenceAdapter</a> | <a href='#levelDB'>levelDB</a> | <a href='#mKahaDB'>mKahaDB</a> | <a href='#memoryPersistenceAdapter'>memoryPersistenceAdapter</a></td><td>Sets the persistence adaptor implementation to use for this broker</td></tr>
+  <tr><td>persistenceFactory</td><td><a href='#amqPersistenceAdapterFactory'>amqPersistenceAdapterFactory</a> | <a href='#journalPersistenceAdapterFactory'>journalPersistenceAdapterFactory</a> | <a href='#journaledJDBC'>journaledJDBC</a></td><td></td></tr>
+  <tr><td>persistenceTaskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+  <tr><td>plugins</td><td>(<a href='#authorizationPlugin'>authorizationPlugin</a> | <a href='#connectionDotFilePlugin'>connectionDotFilePlugin</a> | <a href='#destinationDotFilePlugin'>destinationDotFilePlugin</a> | <a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#discardingDLQBrokerPlugin'>discardingDLQBrokerPlugin</a> | <a href='#forcePersistencyModeBrokerPlugin'>forcePersistencyModeBrokerPlugin</a> | <a href='#jaasAuthenticationPlugin'>jaasAuthenticationPlugin</a> | <a href='#jaasCertificateAuthenticationPlugin'>jaasCertificateAuthenticationPlugin</a> | <a href='#jaasDualAuthenticationPlugin'>jaasDualAuthenticationPlugin</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#simpleAuthenticationPlugin'>simpleAuthenticationPlugin</a> | <a href='#statisticsBrokerPlugin'>statisticsBrokerPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a> | <a href='#virtualSelectorCacheBrokerPlugin'>virtualSelectorCacheBrokerPlugin</a>)*</td><td>Sets a number of broker plugins to install such as for security
+authentication or authorization</td></tr>
+  <tr><td>producerSystemUsage</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+  <tr><td>proxyConnectors</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets the network connectors which this broker will use to connect to
+other brokers in a federated network</td></tr>
+  <tr><td>regionBroker</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+  <tr><td>services</td><td>(<a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a> | <a href='#commandAgent'>commandAgent</a> | <a href='#database-locker'>database-locker</a> | <a href='#forwardingBridge'>forwardingBridge</a> | <a href='#inboundQueueBridge'>inboundQueueBridge</a> | <a href='#inboundTopicBridge'>inboundTopicBridge</a> | <a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a> | <a href='#jmsQueueConnector'>jmsQueueConnector</a> | <a href='#jmsTopicConnector'>jmsTopicConnector</a> | <a href='#journalPersistenceAdapterFactory'>journalPersistenceAdapterFactory</a> | <a href='#journaledJDBC'>journaledJDBC</a> | <a href='#kahaDB'>kahaDB</a> | <a href='#ldapNetworkConnector'>ldapNetworkConnector</a> | <a href='#lease-database-locker'>lease-database-locker</a> | <a href='#levelDB'>levelDB</a> | <a href='#managementContext'>managementContext</a> | <a href='#masterConnector'>masterConnector</a> | <a href='#memoryUsage'>memoryUsage</a> | <a href='#multicastNetworkConnector'>multicastNetworkConnector</a> | <a href='#networkConnector'>networkConnector</a> | <a href='#outboundQueueBridge'>outboundQueueBridge</a> | <a href='#outboundTopicBridge'>outboundTopicBridge</a> | <a href='#pListStore'>pListStore</a> | <a href='#proxyConnector'>proxyConnector</a> | <a href='#shared-file-locker'>shared-file-locker</a> | <a href='#storeUsage'>storeUsage</a> | <a href='#systemUsage'>systemUsage</a> | <a href='#tempUsage'>tempUsage</a> | <a href='#transact-database-locker'>transact-database-locker</a>)*</td><td>Sets the services associated with this broker such as a
+{@link MasterConnector}</td></tr>
+  <tr><td>shutdownHooks</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets hooks to be executed when broker shut down</td></tr>
+  <tr><td>sslContext</td><td><a href='#sslContext'>sslContext</a></td><td></td></tr>
+  <tr><td>systemUsage</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+  <tr><td>taskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+  <tr><td>tempDataStore</td><td><a href='#pListStore'>pListStore</a></td><td></td></tr>
+  <tr><td>transportConnectorURIs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>transportConnectors</td><td>(<a href='#transportConnector'>transportConnector</a>)*</td><td>Sets the transport connectors which this broker will listen on for new
+clients</td></tr>
+</table>
+<h2>Element: <a name='brokerService'>brokerService</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>advisorySupport</td><td>xs:string</td><td>Allows the support of advisory messages to be disabled for performance
+reasons.</td></tr>
+  <tr><td>allowTempAutoCreationOnSend</td><td>xs:boolean</td><td>enable if temp destinations need to be propagated through a network when
+advisorySupport==false. This is used in conjunction with the policy
+gcInactiveDestinations for matching temps so they can get removed
+when inactive</td></tr>
+  <tr><td>brokerId</td><td>xs:string</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td>Sets the name of this broker; which must be unique in the network</td></tr>
+  <tr><td>brokerObjectName</td><td>xs:string</td><td>Sets the JMX ObjectName for this broker</td></tr>
+  <tr><td>cacheTempDestinations</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>consumerSystemUsagePortion</td><td>xs:integer</td><td></td></tr>
+  <tr><td>dataDirectory</td><td>xs:string</td><td>Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.</td></tr>
+  <tr><td>dataDirectoryFile</td><td>xs:string</td><td>Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.</td></tr>
+  <tr><td>dedicatedTaskRunner</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>deleteAllMessagesOnStartup</td><td>xs:string</td><td>Sets whether or not all messages are deleted on startup - mostly only
+useful for testing.</td></tr>
+  <tr><td>enableStatistics</td><td>xs:boolean</td><td>Sets whether or not the Broker's services enable statistics or not.</td></tr>
+  <tr><td>keepDurableSubsActive</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>masterConnectorURI</td><td>xs:string</td><td></td></tr>
+  <tr><td>maxPurgedDestinationsPerSweep</td><td>xs:integer</td><td></td></tr>
+  <tr><td>mbeanInvocationTimeout</td><td>xs:long</td><td>Gets the time in Milliseconds that an invocation of an MBean method will wait before
+failing.  The default value is to wait forever (zero).</td></tr>
+  <tr><td>monitorConnectionSplits</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>networkConnectorStartAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>offlineDurableSubscriberTaskSchedule</td><td>xs:integer</td><td></td></tr>
+  <tr><td>offlineDurableSubscriberTimeout</td><td>xs:integer</td><td></td></tr>
+  <tr><td>passiveSlave</td><td>xs:string</td><td>Get the passiveSlave</td></tr>
+  <tr><td>persistenceThreadPriority</td><td>xs:integer</td><td></td></tr>
+  <tr><td>persistent</td><td>xs:string</td><td>Sets whether or not persistence is enabled or disabled.</td></tr>
+  <tr><td>populateJMSXUserID</td><td>xs:boolean</td><td>Sets whether or not the broker should populate the JMSXUserID header.</td></tr>
+  <tr><td>populateUserNameInMBeans</td><td>xs:boolean</td><td>Should MBeans that support showing the Authenticated User Name information have this
+value filled in or not.</td></tr>
+  <tr><td>producerSystemUsagePortion</td><td>xs:integer</td><td></td></tr>
+  <tr><td>schedulePeriodForDestinationPurge</td><td>xs:integer</td><td></td></tr>
+  <tr><td>schedulerDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>schedulerDirectoryFile</td><td>xs:string</td><td></td></tr>
+  <tr><td>schedulerSupport</td><td>xs:string</td><td></td></tr>
+  <tr><td>shutdownOnMasterFailure</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>shutdownOnSlaveFailure</td><td>xs:string</td><td></td></tr>
+  <tr><td>splitSystemUsageForProducersConsumers</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>startAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>supportFailOver</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>systemExitOnShutdown</td><td>xs:string</td><td></td></tr>
+  <tr><td>systemExitOnShutdownExitCode</td><td>xs:integer</td><td></td></tr>
+  <tr><td>taskRunnerPriority</td><td>xs:integer</td><td></td></tr>
+  <tr><td>timeBeforePurgeTempDestinations</td><td>xs:integer</td><td></td></tr>
+  <tr><td>tmpDataDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>useAuthenticatedPrincipalForJMSXUserID</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useJmx</td><td>xs:string</td><td>Sets whether or not the Broker's services should be exposed into JMX or
+not.</td></tr>
+  <tr><td>useLocalHostBrokerName</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useLoggingForShutdownErrors</td><td>xs:boolean</td><td>Sets whether or not we should use commons-logging when reporting errors
+when shutting down the broker</td></tr>
+  <tr><td>useMirroredQueues</td><td>xs:boolean</td><td>Sets whether or not <a
+href="http://activemq.apache.org/mirrored-queues.html">Mirrored
+Queues</a> should be supported by default if they have not been
+explicitly configured.</td></tr>
+  <tr><td>useShutdownHook</td><td>xs:boolean</td><td>Sets whether or not we should use a shutdown handler to close down the
+broker cleanly if the JVM is terminated. It is recommended you leave this
+enabled.</td></tr>
+  <tr><td>useTempMirroredQueues</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useVirtualTopics</td><td>xs:boolean</td><td>Sets whether or not <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual
+Topics</a> should be supported by default if they have not been
+explicitly configured.</td></tr>
+  <tr><td>vmConnectorURI</td><td>xs:string</td><td></td></tr>
+  <tr><td>waitForSlave</td><td>xs:string</td><td></td></tr>
+  <tr><td>waitForSlaveTimeout</td><td>xs:long</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminView</td><td>&lt;spring:bean/&gt;</td><td>Returns the administration view of the broker; used to create and destroy
+resources such as queues and topics. Note this method returns null if JMX
+is disabled.</td></tr>
+  <tr><td>brokerContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerSystemUsage</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+  <tr><td>destinationFactory</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>destinationInterceptors</td><td>(<a href='#mirroredQueue'>mirroredQueue</a> | <a href='#virtualDestinationInterceptor'>virtualDestinationInterceptor</a>)*</td><td>Sets the destination interceptors to use</td></tr>
+  <tr><td>destinationPolicy</td><td><a href='#policyMap'>policyMap</a></td><td>Sets the destination specific policies available either for exact
+destinations or for wildcard areas of destinations.</td></tr>
+  <tr><td>destinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td>Sets the destinations which should be loaded/created on startup</td></tr>
+  <tr><td>ioExceptionHandler</td><td><a href='#defaultIOExceptionHandler'>defaultIOExceptionHandler</a> | <a href='#jDBCIOExceptionHandler'>jDBCIOExceptionHandler</a></td><td>override the Default IOException handler, called when persistence adapter
+has experiences File or JDBC I/O Exceptions</td></tr>
+  <tr><td>jmsBridgeConnectors</td><td>(<a href='#jmsQueueConnector'>jmsQueueConnector</a> | <a href='#jmsTopicConnector'>jmsTopicConnector</a>)*</td><td></td></tr>
+  <tr><td>managementContext</td><td><a href='#managementContext'>managementContext</a></td><td></td></tr>
+  <tr><td>messageAuthorizationPolicy</td><td>&lt;spring:bean/&gt;</td><td>Sets the policy used to decide if the current connection is authorized to
+consume a given message</td></tr>
+  <tr><td>networkConnectorURIs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>networkConnectors</td><td>(<a href='#ldapNetworkConnector'>ldapNetworkConnector</a> | <a href='#multicastNetworkConnector'>multicastNetworkConnector</a> | <a href='#networkConnector'>networkConnector</a>)*</td><td>Sets the network connectors which this broker will use to connect to
+other brokers in a federated network</td></tr>
+  <tr><td>persistenceAdapter</td><td><a href='#amqPersistenceAdapter'>amqPersistenceAdapter</a> | <a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a> | <a href='#journalPersistenceAdapter'>journalPersistenceAdapter</a> | <a href='#kahaDB'>kahaDB</a> | <a href='#kahaPersistenceAdapter'>kahaPersistenceAdapter</a> | <a href='#levelDB'>levelDB</a> | <a href='#mKahaDB'>mKahaDB</a> | <a href='#memoryPersistenceAdapter'>memoryPersistenceAdapter</a></td><td>Sets the persistence adaptor implementation to use for this broker</td></tr>
+  <tr><td>persistenceFactory</td><td><a href='#amqPersistenceAdapterFactory'>amqPersistenceAdapterFactory</a> | <a href='#journalPersistenceAdapterFactory'>journalPersistenceAdapterFactory</a> | <a href='#journaledJDBC'>journaledJDBC</a></td><td></td></tr>
+  <tr><td>persistenceTaskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+  <tr><td>plugins</td><td>(<a href='#authorizationPlugin'>authorizationPlugin</a> | <a href='#connectionDotFilePlugin'>connectionDotFilePlugin</a> | <a href='#destinationDotFilePlugin'>destinationDotFilePlugin</a> | <a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#discardingDLQBrokerPlugin'>discardingDLQBrokerPlugin</a> | <a href='#forcePersistencyModeBrokerPlugin'>forcePersistencyModeBrokerPlugin</a> | <a href='#jaasAuthenticationPlugin'>jaasAuthenticationPlugin</a> | <a href='#jaasCertificateAuthenticationPlugin'>jaasCertificateAuthenticationPlugin</a> | <a href='#jaasDualAuthenticationPlugin'>jaasDualAuthenticationPlugin</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#simpleAuthenticationPlugin'>simpleAuthenticationPlugin</a> | <a href='#statisticsBrokerPlugin'>statisticsBrokerPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a> | <a href='#virtualSelectorCacheBrokerPlugin'>virtualSelectorCacheBrokerPlugin</a>)*</td><td>Sets a number of broker plugins to install such as for security
+authentication or authorization</td></tr>
+  <tr><td>producerSystemUsage</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+  <tr><td>proxyConnectors</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets the network connectors which this broker will use to connect to
+other brokers in a federated network</td></tr>
+  <tr><td>regionBroker</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+  <tr><td>services</td><td>(<a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a> | <a href='#commandAgent'>commandAgent</a> | <a href='#database-locker'>database-locker</a> | <a href='#forwardingBridge'>forwardingBridge</a> | <a href='#inboundQueueBridge'>inboundQueueBridge</a> | <a href='#inboundTopicBridge'>inboundTopicBridge</a> | <a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a> | <a href='#jmsQueueConnector'>jmsQueueConnector</a> | <a href='#jmsTopicConnector'>jmsTopicConnector</a> | <a href='#journalPersistenceAdapterFactory'>journalPersistenceAdapterFactory</a> | <a href='#journaledJDBC'>journaledJDBC</a> | <a href='#kahaDB'>kahaDB</a> | <a href='#ldapNetworkConnector'>ldapNetworkConnector</a> | <a href='#lease-database-locker'>lease-database-locker</a> | <a href='#levelDB'>levelDB</a> | <a href='#managementContext'>managementContext</a> | <a href='#masterConnector'>masterConnector</a> | <a href='#memoryUsage'>memoryUsage</a> | <a href='#multicastNetworkConnector'>multicastNetworkConnector</a> | <a href='#networkConnector'>networkConnector</a> | <a href='#outboundQueueBridge'>outboundQueueBridge</a> | <a href='#outboundTopicBridge'>outboundTopicBridge</a> | <a href='#pListStore'>pListStore</a> | <a href='#proxyConnector'>proxyConnector</a> | <a href='#shared-file-locker'>shared-file-locker</a> | <a href='#storeUsage'>storeUsage</a> | <a href='#systemUsage'>systemUsage</a> | <a href='#tempUsage'>tempUsage</a> | <a href='#transact-database-locker'>transact-database-locker</a>)*</td><td>Sets the services associated with this broker such as a
+{@link MasterConnector}</td></tr>
+  <tr><td>shutdownHooks</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets hooks to be executed when broker shut down</td></tr>
+  <tr><td>sslContext</td><td><a href='#sslContext'>sslContext</a></td><td></td></tr>
+  <tr><td>systemUsage</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+  <tr><td>taskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+  <tr><td>tempDataStore</td><td><a href='#pListStore'>pListStore</a></td><td></td></tr>
+  <tr><td>transportConnectorURIs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>transportConnectors</td><td>(<a href='#transportConnector'>transportConnector</a>)*</td><td>Sets the transport connectors which this broker will listen on for new
+clients</td></tr>
+</table>
+<h2>Element: <a name='bytesJDBCAdapter'>bytesJDBCAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='cachedLDAPAuthorizationMap'>cachedLDAPAuthorizationMap</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>adminPermissionGroupSearchFilter</td><td>xs:string</td><td></td></tr>
+  <tr><td>authentication</td><td>xs:string</td><td></td></tr>
+  <tr><td>connectionPassword</td><td>xs:string</td><td></td></tr>
+  <tr><td>connectionProtocol</td><td>xs:string</td><td></td></tr>
+  <tr><td>connectionURL</td><td>xs:string</td><td></td></tr>
+  <tr><td>connectionUsername</td><td>xs:string</td><td></td></tr>
+  <tr><td>groupNameAttribute</td><td>xs:string</td><td></td></tr>
+  <tr><td>groupObjectClass</td><td>xs:string</td><td></td></tr>
+  <tr><td>legacyGroupMapping</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>permissionGroupMemberAttribute</td><td>xs:string</td><td></td></tr>
+  <tr><td>queueSearchBase</td><td>xs:string</td><td></td></tr>
+  <tr><td>readPermissionGroupSearchFilter</td><td>xs:string</td><td></td></tr>
+  <tr><td>refreshDisabled</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>refreshInterval</td><td>xs:integer</td><td></td></tr>
+  <tr><td>tempSearchBase</td><td>xs:string</td><td></td></tr>
+  <tr><td>topicSearchBase</td><td>xs:string</td><td></td></tr>
+  <tr><td>userNameAttribute</td><td>xs:string</td><td></td></tr>
+  <tr><td>userObjectClass</td><td>xs:string</td><td></td></tr>
+  <tr><td>writePermissionGroupSearchFilter</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>authorizationEntries</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets the individual entries on the authorization map</td></tr>
+  <tr><td>defaultEntry</td><td><a href='#authorizationEntry'>authorizationEntry</a> | <a href='#tempDestinationAuthorizationEntry'>tempDestinationAuthorizationEntry</a></td><td></td></tr>
+  <tr><td>entries</td><td>(&lt;spring:bean/&gt;)*</td><td>A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring</td></tr>
+  <tr><td>tempDestinationAuthorizationEntry</td><td><a href='#tempDestinationAuthorizationEntry'>tempDestinationAuthorizationEntry</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='commandAgent'>commandAgent</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>brokerUrl</td><td>xs:string</td><td></td></tr>
+  <tr><td>password</td><td>xs:string</td><td></td></tr>
+  <tr><td>username</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>commandDestination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+  <tr><td>connection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>connectionFactory</td><td><a href='#connectionFactory'>connectionFactory</a> | <a href='#xaConnectionFactory'>xaConnectionFactory</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='compositeDemandForwardingBridge'>compositeDemandForwardingBridge</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>createdByDuplex</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>mbeanObjectName</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>configuration</td><td><a href='#ldapNetworkConnector'>ldapNetworkConnector</a> | <a href='#multicastNetworkConnector'>multicastNetworkConnector</a> | <a href='#networkConnector'>networkConnector</a></td><td></td></tr>
+  <tr><td>durableDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>dynamicallyIncludedDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>excludedDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>localBroker</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>networkBridgeListener</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>remoteBroker</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>staticallyIncludedDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='compositeQueue'>compositeQueue</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>copyMessage</td><td>xs:boolean</td><td>Sets whether a copy of the message will be sent to each destination.
+Defaults to true so that the forward destination is set as the
+destination of the message</td></tr>
+  <tr><td>forwardOnly</td><td>xs:boolean</td><td>Sets if the virtual destination is forward only (and so there is no
+physical queue to match the virtual queue) or if there is also a physical
+queue with the same name).</td></tr>
+  <tr><td>name</td><td>xs:string</td><td>Sets the name of this composite destination</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>forwardTo</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets the list of destinations to forward to</td></tr>
+</table>
+<h2>Element: <a name='compositeTopic'>compositeTopic</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>copyMessage</td><td>xs:boolean</td><td>Sets whether a copy of the message will be sent to each destination.
+Defaults to true so that the forward destination is set as the
+destination of the message</td></tr>
+  <tr><td>forwardOnly</td><td>xs:boolean</td><td>Sets if the virtual destination is forward only (and so there is no
+physical queue to match the virtual queue) or if there is also a physical
+queue with the same name).</td></tr>
+  <tr><td>name</td><td>xs:string</td><td>Sets the name of this composite destination</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>forwardTo</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets the list of destinations to forward to</td></tr>
+</table>
+<h2>Element: <a name='conditionalNetworkBridgeFilterFactory'>conditionalNetworkBridgeFilterFactory</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>rateDuration</td><td>xs:integer</td><td></td></tr>
+  <tr><td>rateLimit</td><td>xs:integer</td><td></td></tr>
+  <tr><td>replayDelay</td><td>xs:integer</td><td></td></tr>
+  <tr><td>replayWhenNoConsumers</td><td>xs:boolean</td><td></td></tr>
+</table>
+<h2>Element: <a name='connectionDotFilePlugin'>connectionDotFilePlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>file</td><td>xs:string</td><td>Sets the destination file name to create the destination diagram</td></tr>
+</table>
+<h2>Element: <a name='connectionFactory'>connectionFactory</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>alwaysSessionAsync</td><td>xs:boolean</td><td>If this flag is not set then a separate thread is not used for dispatching messages for each Session in
+the Connection. However, a separate thread is always used if there is more than one session, or the session
+isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
+happens asynchronously.</td></tr>
+  <tr><td>alwaysSyncSend</td><td>xs:boolean</td><td>Set true if always require messages to be sync sent</td></tr>
+  <tr><td>auditDepth</td><td>xs:integer</td><td></td></tr>
+  <tr><td>auditMaximumProducerNumber</td><td>xs:integer</td><td></td></tr>
+  <tr><td>beanName</td><td>xs:string</td><td></td></tr>
+  <tr><td>brokerURL</td><td>xs:string</td><td>Sets the <a
+href="http://activemq.apache.org/configuring-transports.html">connection
+URL</a> used to connect to the ActiveMQ broker.</td></tr>
+  <tr><td>checkForDuplicates</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>clientID</td><td>xs:string</td><td>Sets the JMS clientID to use for the created connection. Note that this
+can only be used by one connection at once so generally its a better idea
+to set the clientID on a Connection</td></tr>
+  <tr><td>clientIDPrefix</td><td>xs:string</td><td>Sets the prefix used by autogenerated JMS Client ID values which are used
+if the JMS client does not explicitly specify on.</td></tr>
+  <tr><td>closeTimeout</td><td>xs:integer</td><td>Sets the timeout before a close is considered complete. Normally a
+close() on a connection waits for confirmation from the broker; this
+allows that operation to timeout to save the client hanging if there is
+no broker</td></tr>
+  <tr><td>connectionIDPrefix</td><td>xs:string</td><td>Sets the prefix used by connection id generator</td></tr>
+  <tr><td>consumerFailoverRedeliveryWaitPeriod</td><td>xs:long</td><td></td></tr>
+  <tr><td>copyMessageOnSend</td><td>xs:boolean</td><td>Should a JMS message be copied to a new JMS Message object as part of the
+send() method in JMS. This is enabled by default to be compliant with the
+JMS specification. You can disable it if you do not mutate JMS messages
+after they are sent for a performance boost</td></tr>
+  <tr><td>disableTimeStampsByDefault</td><td>xs:boolean</td><td>Sets whether or not timestamps on messages should be disabled or not. If
+you disable them it adds a small performance boost.</td></tr>
+  <tr><td>dispatchAsync</td><td>xs:boolean</td><td>Enables or disables the default setting of whether or not consumers have
+their messages <a
+href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
+synchronously or asynchronously by the broker</a>. For non-durable
+topics for example we typically dispatch synchronously by default to
+minimize context switches which boost performance. However sometimes its
+better to go slower to ensure that a single blocked consumer socket does
+not block delivery to other consumers.</td></tr>
+  <tr><td>exclusiveConsumer</td><td>xs:boolean</td><td>Enables or disables whether or not queue consumers should be exclusive or
+not for example to preserve ordering when not using <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a></td></tr>
+  <tr><td>maxThreadPoolSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>messagePrioritySupported</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>nestedMapAndListEnabled</td><td>xs:boolean</td><td>Enables/disables whether or not Message properties and MapMessage entries
+support <a
+href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
+Structures</a> of Map and List objects</td></tr>
+  <tr><td>nonBlockingRedelivery</td><td>xs:boolean</td><td>When true a MessageConsumer will not stop Message delivery before re-delivering Messages
+from a rolled back transaction.  This implies that message order will not be preserved and
+also will result in the TransactedIndividualAck option to be enabled.</td></tr>
+  <tr><td>objectMessageSerializationDefered</td><td>xs:boolean</td><td>When an object is set on an ObjectMessage, the JMS spec requires the
+object to be serialized by that set method. Enabling this flag causes the
+object to not get serialized. The object may subsequently get serialized
+if the message needs to be sent over a socket or stored to disk.</td></tr>
+  <tr><td>optimizeAcknowledge</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>optimizeAcknowledgeTimeOut</td><td>xs:long</td><td>The max time in milliseconds between optimized ack batches</td></tr>
+  <tr><td>optimizedAckScheduledAckInterval</td><td>xs:long</td><td>Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
+to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
+will not do any background Message acknowledgment.</td></tr>
+  <tr><td>optimizedMessageDispatch</td><td>xs:boolean</td><td>If this flag is set then an larger prefetch limit is used - only
+applicable for durable topic subscribers.</td></tr>
+  <tr><td>password</td><td>xs:string</td><td>Sets the JMS password used for connections created from this factory</td></tr>
+  <tr><td>producerWindowSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>sendAcksAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>sendTimeout</td><td>xs:integer</td><td></td></tr>
+  <tr><td>statsEnabled</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>transactedIndividualAck</td><td>xs:boolean</td><td>when true, submit individual transacted acks immediately rather than with transaction completion.
+This allows the acks to represent delivery status which can be persisted on rollback
+Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true</td></tr>
+  <tr><td>useAsyncSend</td><td>xs:boolean</td><td>Forces the use of <a
+href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
+adds a massive performance boost; but means that the send() method will
+return immediately whether the message has been sent or not which could
+lead to message loss.</td></tr>
+  <tr><td>useBeanNameAsClientIdPrefix</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useCompression</td><td>xs:boolean</td><td>Enables the use of compression of the message bodies</td></tr>
+  <tr><td>useDedicatedTaskRunner</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useRetroactiveConsumer</td><td>xs:boolean</td><td>Sets whether or not retroactive consumers are enabled. Retroactive
+consumers allow non-durable topic subscribers to receive old messages
+that were published before the non-durable subscriber started.</td></tr>
+  <tr><td>userName</td><td>xs:string</td><td>Sets the JMS userName used by connections created by this factory</td></tr>
+  <tr><td>warnAboutUnstartedConnectionTimeout</td><td>xs:long</td><td>Enables the timeout from a connection creation to when a warning is
+generated if the connection is not properly started via
+{@link Connection#start()} and a message is received by a consumer. It is
+a very common gotcha to forget to <a
+href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
+the connection</a> so this option makes the default case to create a
+warning if the user forgets. To disable the warning just set the value to <
+0 (say -1).</td></tr>
+  <tr><td>watchTopicAdvisories</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>blobTransferPolicy</td><td>&lt;spring:bean/&gt;</td><td>Sets the policy used to describe how out-of-band BLOBs (Binary Large
+OBjects) are transferred from producers to brokers to consumers</td></tr>
+  <tr><td>clientIdGenerator</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>clientInternalExceptionListener</td><td>&lt;spring:bean/&gt;</td><td>Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)</td></tr>
+  <tr><td>connectionIdGenerator</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>exceptionListener</td><td><a href='#commandAgent'>commandAgent</a></td><td>Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)</td></tr>
+  <tr><td>prefetchPolicy</td><td><a href='#prefetchPolicy'>prefetchPolicy</a></td><td>Sets the <a
+href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
+policy</a> for consumers created by this connection.</td></tr>
+  <tr><td>properties</td><td>&lt;spring:bean/&gt;</td><td>Get the properties from this instance for storing in JNDI</td></tr>
+  <tr><td>redeliveryPolicy</td><td><a href='#redeliveryPolicy'>redeliveryPolicy</a></td><td>Sets the global default redelivery policy to be used when a message is delivered
+but the session is rolled back</td></tr>
+  <tr><td>redeliveryPolicyMap</td><td><a href='#redeliveryPolicyMap'>redeliveryPolicyMap</a></td><td>Sets the global redelivery policy mapping to be used when a message is delivered
+but the session is rolled back</td></tr>
+  <tr><td>rejectedTaskHandler</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>sessionTaskRunner</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+  <tr><td>transformer</td><td>&lt;spring:bean/&gt;</td><td>Sets the transformer used to transform messages before they are sent on
+to the JMS bus or when they are received from the bus but before they are
+delivered to the JMS client</td></tr>
+  <tr><td>transportListener</td><td>&lt;spring:bean/&gt;</td><td>Allows a listener to be configured on the ConnectionFactory so that when this factory is used
+with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
+a transport listener.</td></tr>
+</table>
+<h2>Element: <a name='constantPendingMessageLimitStrategy'>constantPendingMessageLimitStrategy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>limit</td><td>xs:integer</td><td></td></tr>
+</table>
+<h2>Element: <a name='database-locker'>database-locker</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>failIfLocked</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>lockAcquireSleepInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>queryTimeout</td><td>xs:integer</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>exceptionHandler</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='db2JDBCAdapter'>db2JDBCAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='defaultIOExceptionHandler'>defaultIOExceptionHandler</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>ignoreAllErrors</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>ignoreNoSpaceErrors</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>ignoreSQLExceptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>noSpaceMessage</td><td>xs:string</td><td></td></tr>
+  <tr><td>resumeCheckSleepPeriod</td><td>xs:long</td><td></td></tr>
+  <tr><td>sqlExceptionMessage</td><td>xs:string</td><td></td></tr>
+  <tr><td>stopStartConnectors</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='defaultJDBCAdapter'>defaultJDBCAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='defaultNetworkBridgeFilterFactory'>defaultNetworkBridgeFilterFactory</a></h2>
+<h2>Element: <a name='defaultUsageCapacity'>defaultUsageCapacity</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>limit</td><td>xs:long</td><td></td></tr>
+</table>
+<h2>Element: <a name='demandForwardingBridge'>demandForwardingBridge</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>createdByDuplex</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>mbeanObjectName</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>configuration</td><td><a href='#ldapNetworkConnector'>ldapNetworkConnector</a> | <a href='#multicastNetworkConnector'>multicastNetworkConnector</a> | <a href='#networkConnector'>networkConnector</a></td><td></td></tr>
+  <tr><td>durableDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>dynamicallyIncludedDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>excludedDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>localBroker</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>networkBridgeListener</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>remoteBroker</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>staticallyIncludedDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='destinationDotFilePlugin'>destinationDotFilePlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>file</td><td>xs:string</td><td>Sets the destination file name to create the destination diagram</td></tr>
+</table>
+<h2>Element: <a name='destinationEntry'>destinationEntry</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>queue</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>tempQueue</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>tempTopic</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>topic</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>destination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+  <tr><td>value</td><td><a href='#authorizationEntry'>authorizationEntry</a> | <a href='#destinationEntry'>destinationEntry</a> | <a href='#filteredKahaDB'>filteredKahaDB</a> | <a href='#policyEntry'>policyEntry</a> | <a href='#redeliveryPolicy'>redeliveryPolicy</a> | <a href='#tempDestinationAuthorizationEntry'>tempDestinationAuthorizationEntry</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>pathSeparator</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminConnectionContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>next</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='discardingDLQBrokerPlugin'>discardingDLQBrokerPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>dropAll</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>dropOnly</td><td>xs:string</td><td></td></tr>
+  <tr><td>dropTemporaryQueues</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>dropTemporaryTopics</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>reportInterval</td><td>xs:integer</td><td></td></tr>
+</table>
+<h2>Element: <a name='fileCursor'>fileCursor</a></h2>
+<h2>Element: <a name='fileDurableSubscriberCursor'>fileDurableSubscriberCursor</a></h2>
+<h2>Element: <a name='fileQueueCursor'>fileQueueCursor</a></h2>
+<h2>Element: <a name='filteredDestination'>filteredDestination</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>queue</td><td>xs:string</td><td>Sets the destination property to the given queue name</td></tr>
+  <tr><td>selector</td><td>xs:string</td><td>Sets the JMS selector used to filter messages before forwarding them to this destination</td></tr>
+  <tr><td>topic</td><td>xs:string</td><td>Sets the destination property to the given topic name</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>destination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td>The destination to send messages to if they match the filter</td></tr>
+  <tr><td>filter</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='filteredKahaDB'>filteredKahaDB</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>perDestination</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>queue</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>tempQueue</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>tempTopic</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>topic</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adapter</td><td><a href='#kahaDB'>kahaDB</a></td><td></td></tr>
+  <tr><td>destination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+  <tr><td>persistenceAdapter</td><td><a href='#kahaDB'>kahaDB</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='fixedCountSubscriptionRecoveryPolicy'>fixedCountSubscriptionRecoveryPolicy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>maximumSize</td><td>xs:integer</td><td>Sets the maximum number of messages that this destination will hold
+around in RAM</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>broker</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='fixedSizedSubscriptionRecoveryPolicy'>fixedSizedSubscriptionRecoveryPolicy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>maximumSize</td><td>xs:integer</td><td>Sets the maximum amount of RAM in bytes that this buffer can hold in RAM</td></tr>
+  <tr><td>useSharedBuffer</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>broker</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+  <tr><td>buffer</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='forcePersistencyModeBroker'>forcePersistencyModeBroker</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>persistenceFlag</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminConnectionContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>next</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='forcePersistencyModeBrokerPlugin'>forcePersistencyModeBrokerPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>persistenceFlag</td><td>xs:boolean</td><td>Sets the persistency mode.</td></tr>
+</table>
+<h2>Element: <a name='forwardingBridge'>forwardingBridge</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>clientId</td><td>xs:string</td><td></td></tr>
+  <tr><td>destinationFilter</td><td>xs:string</td><td></td></tr>
+  <tr><td>dispatchAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>prefetchSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useCompression</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>localBroker</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>networkBridgeFailedListener</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>remoteBroker</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='hsqldb-jdbc-adapter'>hsqldb-jdbc-adapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='imageBasedJDBCAdaptor'>imageBasedJDBCAdaptor</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='inboundQueueBridge'>inboundQueueBridge</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>doHandleReplyTo</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>inboundQueueName</td><td>xs:string</td><td>Sets the queue name used for the inbound queue, if the outbound queue
+name has not been set, then this method uses the same name to configure
+the outbound queue name.</td></tr>
+  <tr><td>localQueueName</td><td>xs:string</td><td></td></tr>
+  <tr><td>selector</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>consumer</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerQueue</td><td><a href='#queue'>queue</a></td><td></td></tr>
+  <tr><td>jmsConnector</td><td><a href='#jmsQueueConnector'>jmsQueueConnector</a> | <a href='#jmsTopicConnector'>jmsTopicConnector</a></td><td></td></tr>
+  <tr><td>jmsMessageConvertor</td><td><a href='#simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></td><td></td></tr>
+  <tr><td>producerConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>producerQueue</td><td><a href='#queue'>queue</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='inboundTopicBridge'>inboundTopicBridge</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>consumerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>doHandleReplyTo</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>inboundTopicName</td><td>xs:string</td><td>Sets the topic name used for the inbound topic, if the outbound topic
+name has not been set, then this method uses the same name to configure
+the outbound topic name.</td></tr>
+  <tr><td>localTopicName</td><td>xs:string</td><td></td></tr>
+  <tr><td>selector</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>consumer</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerTopic</td><td><a href='#topic'>topic</a></td><td></td></tr>
+  <tr><td>jmsConnector</td><td><a href='#jmsQueueConnector'>jmsQueueConnector</a> | <a href='#jmsTopicConnector'>jmsTopicConnector</a></td><td></td></tr>
+  <tr><td>jmsMessageConvertor</td><td><a href='#simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></td><td></td></tr>
+  <tr><td>producerConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>producerTopic</td><td><a href='#topic'>topic</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='individualDeadLetterStrategy'>individualDeadLetterStrategy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>destinationPerDurableSubscriber</td><td>xs:boolean</td><td>sets whether durable topic subscriptions are to get individual dead letter destinations.
+When true, the DLQ is of the form 'topicPrefix.clientId:subscriptionName'
+The default is false.</td></tr>
+  <tr><td>enableAudit</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>processExpired</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>processNonPersistent</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>queuePrefix</td><td>xs:string</td><td>Sets the prefix to use for all dead letter queues for queue messages</td></tr>
+  <tr><td>queueSuffix</td><td>xs:string</td><td>Sets the suffix to use for all dead letter queues for queue messages</td></tr>
+  <tr><td>topicPrefix</td><td>xs:string</td><td>Sets the prefix to use for all dead letter queues for topic messages</td></tr>
+  <tr><td>topicSuffix</td><td>xs:string</td><td>Sets the suffix to use for all dead letter queues for topic messages</td></tr>
+  <tr><td>useQueueForQueueMessages</td><td>xs:boolean</td><td>Sets whether a queue or topic should be used for queue messages sent to a
+DLQ. The default is to use a Queue</td></tr>
+  <tr><td>useQueueForTopicMessages</td><td>xs:boolean</td><td>Sets whether a queue or topic should be used for topic messages sent to a
+DLQ. The default is to use a Queue</td></tr>
+</table>
+<h2>Element: <a name='informixJDBCAdapter'>informixJDBCAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='jDBCIOExceptionHandler'>jDBCIOExceptionHandler</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>ignoreAllErrors</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>ignoreNoSpaceErrors</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>ignoreSQLExceptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>noSpaceMessage</td><td>xs:string</td><td></td></tr>
+  <tr><td>resumeCheckSleepPeriod</td><td>xs:long</td><td></td></tr>
+  <tr><td>sqlExceptionMessage</td><td>xs:string</td><td></td></tr>
+  <tr><td>stopStartConnectors</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='jaasAuthenticationPlugin'>jaasAuthenticationPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>configuration</td><td>xs:string</td><td>Sets the JAAS configuration domain name used</td></tr>
+  <tr><td>discoverLoginConfig</td><td>xs:boolean</td><td>Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
+This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
+is not defined then it is set to the location of the <b>login.config</b> file on the classpath.</td></tr>
+</table>
+<h2>Element: <a name='jaasCertificateAuthenticationPlugin'>jaasCertificateAuthenticationPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>configuration</td><td>xs:string</td><td>Sets the JAAS configuration domain name used</td></tr>
+  <tr><td>discoverLoginConfig</td><td>xs:boolean</td><td>Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
+This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
+is not defined then it is set to the location of the <b>login.config</b> file on the classpath.</td></tr>
+</table>
+<h2>Element: <a name='jaasDualAuthenticationPlugin'>jaasDualAuthenticationPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>configuration</td><td>xs:string</td><td>Sets the JAAS configuration domain name used</td></tr>
+  <tr><td>discoverLoginConfig</td><td>xs:boolean</td><td>Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
+This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
+is not defined then it is set to the location of the <b>login.config</b> file on the classpath.</td></tr>
+  <tr><td>sslConfiguration</td><td>xs:string</td><td>Set the JAAS SSL configuration domain</td></tr>
+</table>
+<h2>Element: <a name='jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>auditRecoveryDepth</td><td>xs:integer</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>cleanupPeriod</td><td>xs:integer</td><td>Sets the number of milliseconds until the database is attempted to be
+cleaned up for durable topics</td></tr>
+  <tr><td>createTablesOnStartup</td><td>xs:boolean</td><td>Sets whether or not tables are created on startup</td></tr>
+  <tr><td>dataDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>dataDirectoryFile</td><td>xs:string</td><td></td></tr>
+  <tr><td>directory</td><td>xs:string</td><td></td></tr>
+  <tr><td>enableAudit</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>lockAcquireSleepInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>lockKeepAlivePeriod</td><td>xs:long</td><td></td></tr>
+  <tr><td>maxAuditDepth</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxProducersToAudit</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>transactionIsolation</td><td>xs:integer</td><td>set the Transaction isolation level to something other that TRANSACTION_READ_UNCOMMITTED
+This allowable dirty isolation level may not be achievable in clustered DB environments
+so a more restrictive and expensive option may be needed like TRANSACTION_REPEATABLE_READ
+see isolation level constants in {@link java.sql.Connection}</td></tr>
+  <tr><td>useDatabaseLock</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useLock</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adapter</td><td><a href='#axionJDBCAdapter'>axionJDBCAdapter</a> | <a href='#blobJDBCAdapter'>blobJDBCAdapter</a> | <a href='#bytesJDBCAdapter'>bytesJDBCAdapter</a> | <a href='#db2JDBCAdapter'>db2JDBCAdapter</a> | <a href='#defaultJDBCAdapter'>defaultJDBCAdapter</a> | <a href='#hsqldb-jdbc-adapter'>hsqldb-jdbc-adapter</a> | <a href='#imageBasedJDBCAdaptor'>imageBasedJDBCAdaptor</a> | <a href='#informixJDBCAdapter'>informixJDBCAdapter</a> | <a href='#maxdb-jdbc-adapter'>maxdb-jdbc-adapter</a> | <a href='#mysql-jdbc-adapter'>mysql-jdbc-adapter</a> | <a href='#oracleBlobJDBCAdapter'>oracleBlobJDBCAdapter</a> | <a href='#oracleJDBCAdapter'>oracleJDBCAdapter</a> | <a href='#postgresql-jdbc-adapter'>postgresql-jdbc-adapter</a> | <a href='#streamJDBCAdapter'>streamJDBCAdapter</a> | <a href='#sybase-jdbc-adapter'>sybase-jdbc-adapter</a> | <a href='#transact-jdbc-adapter'>transact-jdbc-adapter</a></td><td></td></tr>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>dataSource</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>databaseLocker</td><td><a href='#database-locker'>database-locker</a> | <a href='#lease-database-locker'>lease-database-locker</a> | <a href='#shared-file-locker'>shared-file-locker</a> | <a href='#transact-database-locker'>transact-database-locker</a></td><td>Sets the database locker strategy to use to lock the database on startup</td></tr>
+  <tr><td>ds</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>lockDataSource</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>locker</td><td><a href='#database-locker'>database-locker</a> | <a href='#lease-database-locker'>lease-database-locker</a> | <a href='#shared-file-locker'>shared-file-locker</a> | <a href='#transact-database-locker'>transact-database-locker</a></td><td></td></tr>
+  <tr><td>scheduledThreadPoolExecutor</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+  <tr><td>usageManager</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+  <tr><td>wireFormat</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='jmsQueueConnector'>jmsQueueConnector</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>jndiLocalTemplate</td><td>xs:string</td><td></td></tr>
+  <tr><td>jndiOutboundTemplate</td><td>xs:string</td><td></td></tr>
+  <tr><td>localClientId</td><td>xs:string</td><td></td></tr>
+  <tr><td>localConnectionFactoryName</td><td>xs:string</td><td></td></tr>
+  <tr><td>localPassword</td><td>xs:string</td><td></td></tr>
+  <tr><td>localUsername</td><td>xs:string</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundClientId</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundPassword</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundQueueConnectionFactoryName</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundUsername</td><td>xs:string</td><td></td></tr>
+  <tr><td>preferJndiDestinationLookup</td><td>xs:boolean</td><td>Sets whether the connector should prefer to first try to find a destination in JNDI before
+using JMS semantics to create a Destination.  By default the connector will first use JMS
+semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
+ordering.</td></tr>
+  <tr><td>replyToDestinationCacheSize</td><td>xs:integer</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td>One way to configure the local connection - this is called by The
+BrokerService when the Connector is embedded</td></tr>
+  <tr><td>inboundMessageConvertor</td><td><a href='#simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></td><td></td></tr>
+  <tr><td>inboundQueueBridges</td><td>(<a href='#inboundQueueBridge'>inboundQueueBridge</a>)*</td><td></td></tr>
+  <tr><td>localQueueConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>localQueueConnectionFactory</td><td><a href='#connectionFactory'>connectionFactory</a> | <a href='#xaConnectionFactory'>xaConnectionFactory</a></td><td></td></tr>
+  <tr><td>outboundMessageConvertor</td><td><a href='#simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></td><td></td></tr>
+  <tr><td>outboundQueueBridges</td><td>(<a href='#outboundQueueBridge'>outboundQueueBridge</a>)*</td><td></td></tr>
+  <tr><td>outboundQueueConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>outboundQueueConnectionFactory</td><td><a href='#connectionFactory'>connectionFactory</a> | <a href='#xaConnectionFactory'>xaConnectionFactory</a></td><td></td></tr>
+  <tr><td>reconnectionPolicy</td><td><a href='#reconnectionPolicy'>reconnectionPolicy</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='jmsTopicConnector'>jmsTopicConnector</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>jndiLocalTemplate</td><td>xs:string</td><td></td></tr>
+  <tr><td>jndiOutboundTemplate</td><td>xs:string</td><td></td></tr>
+  <tr><td>localClientId</td><td>xs:string</td><td></td></tr>
+  <tr><td>localConnectionFactoryName</td><td>xs:string</td><td></td></tr>
+  <tr><td>localPassword</td><td>xs:string</td><td></td></tr>
+  <tr><td>localUsername</td><td>xs:string</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundClientId</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundPassword</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundTopicConnectionFactoryName</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundUsername</td><td>xs:string</td><td></td></tr>
+  <tr><td>preferJndiDestinationLookup</td><td>xs:boolean</td><td>Sets whether the connector should prefer to first try to find a destination in JNDI before
+using JMS semantics to create a Destination.  By default the connector will first use JMS
+semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
+ordering.</td></tr>
+  <tr><td>replyToDestinationCacheSize</td><td>xs:integer</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td>One way to configure the local connection - this is called by The
+BrokerService when the Connector is embedded</td></tr>
+  <tr><td>inboundMessageConvertor</td><td><a href='#simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></td><td></td></tr>
+  <tr><td>inboundTopicBridges</td><td>(<a href='#inboundTopicBridge'>inboundTopicBridge</a>)*</td><td></td></tr>
+  <tr><td>localTopicConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>localTopicConnectionFactory</td><td><a href='#connectionFactory'>connectionFactory</a> | <a href='#xaConnectionFactory'>xaConnectionFactory</a></td><td></td></tr>
+  <tr><td>outboundMessageConvertor</td><td><a href='#simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></td><td></td></tr>
+  <tr><td>outboundTopicBridges</td><td>(<a href='#outboundTopicBridge'>outboundTopicBridge</a>)*</td><td></td></tr>
+  <tr><td>outboundTopicConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>outboundTopicConnectionFactory</td><td><a href='#connectionFactory'>connectionFactory</a> | <a href='#xaConnectionFactory'>xaConnectionFactory</a></td><td></td></tr>
+  <tr><td>reconnectionPolicy</td><td><a href='#reconnectionPolicy'>reconnectionPolicy</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='journalPersistenceAdapter'>journalPersistenceAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>directory</td><td>xs:string</td><td></td></tr>
+  <tr><td>maxCheckpointMessageAddSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxCheckpointWorkers</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>journal</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>longTermPersistence</td><td><a href='#amqPersistenceAdapter'>amqPersistenceAdapter</a> | <a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a> | <a href='#journalPersistenceAdapter'>journalPersistenceAdapter</a> | <a href='#kahaDB'>kahaDB</a> | <a href='#kahaPersistenceAdapter'>kahaPersistenceAdapter</a> | <a href='#levelDB'>levelDB</a> | <a href='#mKahaDB'>mKahaDB</a> | <a href='#memoryPersistenceAdapter'>memoryPersistenceAdapter</a></td><td></td></tr>
+  <tr><td>persistenceAdapter</td><td><a href='#amqPersistenceAdapter'>amqPersistenceAdapter</a> | <a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a> | <a href='#journalPersistenceAdapter'>journalPersistenceAdapter</a> | <a href='#kahaDB'>kahaDB</a> | <a href='#kahaPersistenceAdapter'>kahaPersistenceAdapter</a> | <a href='#levelDB'>levelDB</a> | <a href='#mKahaDB'>mKahaDB</a> | <a href='#memoryPersistenceAdapter'>memoryPersistenceAdapter</a></td><td></td></tr>
+  <tr><td>taskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+  <tr><td>usageManager</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='journalPersistenceAdapterFactory'>journalPersistenceAdapterFactory</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>createTablesOnStartup</td><td>xs:boolean</td><td>Sets whether or not tables are created on startup</td></tr>
+  <tr><td>dataDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>dataDirectoryFile</td><td>xs:string</td><td></td></tr>
+  <tr><td>journalArchiveDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>journalLogFileSize</td><td>xs:string</td><td>Sets the size of the journal log files
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>journalLogFiles</td><td>xs:integer</td><td>Sets the number of journal log files to use</td></tr>
+  <tr><td>journalThreadPriority</td><td>xs:integer</td><td>Sets the thread priority of the journal thread</td></tr>
+  <tr><td>lockKeepAlivePeriod</td><td>xs:long</td><td></td></tr>
+  <tr><td>useDatabaseLock</td><td>xs:boolean</td><td>Sets whether or not an exclusive database lock should be used to enable
+JDBC Master/Slave. Enabled by default.</td></tr>
+  <tr><td>useDedicatedTaskRunner</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useJournal</td><td>xs:boolean</td><td>Enables or disables the use of the journal. The default is to use the
+journal</td></tr>
+  <tr><td>useLock</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useQuickJournal</td><td>xs:boolean</td><td>Enables or disables the use of quick journal, which keeps messages in the
+journal and just stores a reference to the messages in JDBC. Defaults to
+false so that messages actually reside long term in the JDBC database.</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adapter</td><td><a href='#axionJDBCAdapter'>axionJDBCAdapter</a> | <a href='#blobJDBCAdapter'>blobJDBCAdapter</a> | <a href='#bytesJDBCAdapter'>bytesJDBCAdapter</a> | <a href='#db2JDBCAdapter'>db2JDBCAdapter</a> | <a href='#defaultJDBCAdapter'>defaultJDBCAdapter</a> | <a href='#hsqldb-jdbc-adapter'>hsqldb-jdbc-adapter</a> | <a href='#imageBasedJDBCAdaptor'>imageBasedJDBCAdaptor</a> | <a href='#informixJDBCAdapter'>informixJDBCAdapter</a> | <a href='#maxdb-jdbc-adapter'>maxdb-jdbc-adapter</a> | <a href='#mysql-jdbc-adapter'>mysql-jdbc-adapter</a> | <a href='#oracleBlobJDBCAdapter'>oracleBlobJDBCAdapter</a> | <a href='#oracleJDBCAdapter'>oracleJDBCAdapter</a> | <a href='#postgresql-jdbc-adapter'>postgresql-jdbc-adapter</a> | <a href='#streamJDBCAdapter'>streamJDBCAdapter</a> | <a href='#sybase-jdbc-adapter'>sybase-jdbc-adapter</a> | <a href='#transact-jdbc-adapter'>transact-jdbc-adapter</a></td><td></td></tr>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>dataSource</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>jdbcAdapter</td><td><a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a></td><td></td></tr>
+  <tr><td>journal</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>locker</td><td><a href='#database-locker'>database-locker</a> | <a href='#lease-database-locker'>lease-database-locker</a> | <a href='#shared-file-locker'>shared-file-locker</a> | <a href='#transact-database-locker'>transact-database-locker</a></td><td></td></tr>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+  <tr><td>taskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='journaledJDBC'>journaledJDBC</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>createTablesOnStartup</td><td>xs:boolean</td><td>Sets whether or not tables are created on startup</td></tr>
+  <tr><td>dataDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>dataDirectoryFile</td><td>xs:string</td><td></td></tr>
+  <tr><td>journalArchiveDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>journalLogFileSize</td><td>xs:string</td><td>Sets the size of the journal log files
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>journalLogFiles</td><td>xs:integer</td><td>Sets the number of journal log files to use</td></tr>
+  <tr><td>journalThreadPriority</td><td>xs:integer</td><td>Sets the thread priority of the journal thread</td></tr>
+  <tr><td>lockKeepAlivePeriod</td><td>xs:long</td><td></td></tr>
+  <tr><td>useDatabaseLock</td><td>xs:boolean</td><td>Sets whether or not an exclusive database lock should be used to enable
+JDBC Master/Slave. Enabled by default.</td></tr>
+  <tr><td>useDedicatedTaskRunner</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useJournal</td><td>xs:boolean</td><td>Enables or disables the use of the journal. The default is to use the
+journal</td></tr>
+  <tr><td>useLock</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useQuickJournal</td><td>xs:boolean</td><td>Enables or disables the use of quick journal, which keeps messages in the
+journal and just stores a reference to the messages in JDBC. Defaults to
+false so that messages actually reside long term in the JDBC database.</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adapter</td><td><a href='#axionJDBCAdapter'>axionJDBCAdapter</a> | <a href='#blobJDBCAdapter'>blobJDBCAdapter</a> | <a href='#bytesJDBCAdapter'>bytesJDBCAdapter</a> | <a href='#db2JDBCAdapter'>db2JDBCAdapter</a> | <a href='#defaultJDBCAdapter'>defaultJDBCAdapter</a> | <a href='#hsqldb-jdbc-adapter'>hsqldb-jdbc-adapter</a> | <a href='#imageBasedJDBCAdaptor'>imageBasedJDBCAdaptor</a> | <a href='#informixJDBCAdapter'>informixJDBCAdapter</a> | <a href='#maxdb-jdbc-adapter'>maxdb-jdbc-adapter</a> | <a href='#mysql-jdbc-adapter'>mysql-jdbc-adapter</a> | <a href='#oracleBlobJDBCAdapter'>oracleBlobJDBCAdapter</a> | <a href='#oracleJDBCAdapter'>oracleJDBCAdapter</a> | <a href='#postgresql-jdbc-adapter'>postgresql-jdbc-adapter</a> | <a href='#streamJDBCAdapter'>streamJDBCAdapter</a> | <a href='#sybase-jdbc-adapter'>sybase-jdbc-adapter</a> | <a href='#transact-jdbc-adapter'>transact-jdbc-adapter</a></td><td></td></tr>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>dataSource</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>jdbcAdapter</td><td><a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a></td><td></td></tr>
+  <tr><td>journal</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>locker</td><td><a href='#database-locker'>database-locker</a> | <a href='#lease-database-locker'>lease-database-locker</a> | <a href='#shared-file-locker'>shared-file-locker</a> | <a href='#transact-database-locker'>transact-database-locker</a></td><td></td></tr>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+  <tr><td>taskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='kahaDB'>kahaDB</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>archiveCorruptedIndex</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>archiveDataLogs</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>checkForCorruptJournalFiles</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>checkpointInterval</td><td>xs:long</td><td>Get the checkpointInterval</td></tr>
+  <tr><td>checksumJournalFiles</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>cleanupInterval</td><td>xs:long</td><td>Get the cleanupInterval</td></tr>
+  <tr><td>concurrentStoreAndDispatchQueues</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>concurrentStoreAndDispatchTopics</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>databaseLockedWaitDelay</td><td>xs:integer</td><td></td></tr>
+  <tr><td>directory</td><td>xs:string</td><td>Get the directory</td></tr>
+  <tr><td>directoryArchive</td><td>xs:string</td><td></td></tr>
+  <tr><td>enableIndexDiskSyncs</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>enableIndexPageCaching</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>enableIndexRecoveryFile</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>enableIndexWriteAsync</td><td>xs:boolean</td><td>Get the enableIndexWriteAsync</td></tr>
+  <tr><td>enableJournalDiskSyncs</td><td>xs:boolean</td><td>Get the enableJournalDiskSyncs</td></tr>
+  <tr><td>failoverProducersAuditDepth</td><td>xs:integer</td><td>set the audit window depth for duplicate suppression (should exceed the max transaction
+batch)</td></tr>
+  <tr><td>forceRecoverIndex</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>ignoreMissingJournalfiles</td><td>xs:boolean</td><td>Get the ignoreMissingJournalfiles</td></tr>
+  <tr><td>indexCacheSize</td><td>xs:string</td><td>Get the indexCacheSize</td></tr>
+  <tr><td>indexLFUEvictionFactor</td><td>xs:float</td><td></td></tr>
+  <tr><td>indexWriteBatchSize</td><td>xs:string</td><td>Get the indexWriteBatchSize</td></tr>
+  <tr><td>journalMaxFileLength</td><td>xs:string</td><td>Get the journalMaxFileLength</td></tr>
+  <tr><td>journalMaxWriteBatchSize</td><td>xs:string</td><td>Get the journalMaxWriteBatchSize</td></tr>
+  <tr><td>lockKeepAlivePeriod</td><td>xs:long</td><td></td></tr>
+  <tr><td>maxAsyncJobs</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxFailoverProducersToTrack</td><td>xs:integer</td><td>Set the max number of producers (LRU cache) to track for duplicate sends</td></tr>
+  <tr><td>rewriteOnRedelivery</td><td>xs:boolean</td><td>When true, persist the redelivery status such that the message redelivery flag can survive a broker failure
+used with org.apache.activemq.ActiveMQConnectionFactory#setTransactedIndividualAck(boolean)  true</td></tr>
+  <tr><td>useIndexLFRUEviction</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useLock</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>locker</td><td><a href='#database-locker'>database-locker</a> | <a href='#lease-database-locker'>lease-database-locker</a> | <a href='#shared-file-locker'>shared-file-locker</a> | <a href='#transact-database-locker'>transact-database-locker</a></td><td></td></tr>
+  <tr><td>usageManager</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='kahaPersistenceAdapter'>kahaPersistenceAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>directory</td><td>xs:string</td><td></td></tr>
+  <tr><td>maxDataFileLength</td><td>xs:string</td><td>When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>persistentIndex</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>size</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>usageManager</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='lDAPAuthorizationMap'>lDAPAuthorizationMap</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>adminAttribute</td><td>xs:string</td><td></td></tr>
+  <tr><td>adminBase</td><td>xs:string</td><td></td></tr>
+  <tr><td>advisorySearchBase</td><td>xs:string</td><td></td></tr>
+  <tr><td>authentication</td><td>xs:string</td><td></td></tr>
+  <tr><td>connectionPassword</td><td>xs:string</td><td></td></tr>
+  <tr><td>connectionProtocol</td><td>xs:string</td><td></td></tr>
+  <tr><td>connectionURL</td><td>xs:string</td><td></td></tr>
+  <tr><td>connectionUsername</td><td>xs:string</td><td></td></tr>
+  <tr><td>initialContextFactory</td><td>xs:string</td><td></td></tr>
+  <tr><td>queueSearchSubtreeBool</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>readAttribute</td><td>xs:string</td><td></td></tr>
+  <tr><td>readBase</td><td>xs:string</td><td></td></tr>
+  <tr><td>tempSearchBase</td><td>xs:string</td><td></td></tr>
+  <tr><td>topicSearchSubtreeBool</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useAdvisorySearchBase</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>writeAttribute</td><td>xs:string</td><td></td></tr>
+  <tr><td>writeBase</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>context</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>options</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>queueSearchMatchingFormat</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>topicSearchMatchingFormat</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='lastImageSubscriptionRecoveryPolicy'>lastImageSubscriptionRecoveryPolicy</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>broker</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='ldapNetworkConnector'>ldapNetworkConnector</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>alwaysSyncSend</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>anonymousAuthentication</td><td>xs:boolean</td><td>sets LDAP anonymous authentication access credentials</td></tr>
+  <tr><td>base</td><td>xs:string</td><td>sets the base LDAP dn used for lookup operations</td></tr>
+  <tr><td>bridgeTempDestinations</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>brokerURL</td><td>xs:string</td><td></td></tr>
+  <tr><td>conduitSubscriptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>consumerPriorityBase</td><td>xs:integer</td><td></td></tr>
+  <tr><td>decreaseNetworkConsumerPriority</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>destinationFilter</td><td>xs:string</td><td></td></tr>
+  <tr><td>dispatchAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>duplex</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>dynamicOnly</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>localUri</td><td>xs:string</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>networkTTL</td><td>xs:integer</td><td></td></tr>
+  <tr><td>objectName</td><td>xs:string</td><td></td></tr>
+  <tr><td>password</td><td>xs:string</td><td>sets the LDAP password for access credentials</td></tr>
+  <tr><td>prefetchSize</td><td>xs:string</td><td></td></tr>
+  <tr><td>searchEventListener</td><td>xs:boolean</td><td>enables/disable a persistent search to the LDAP server as defined
+in draft-ietf-ldapext-psearch-03.txt (2.16.840.1.113730.3.4.3)</td></tr>
+  <tr><td>searchFilter</td><td>xs:string</td><td>sets the LDAP search filter as defined in RFC 2254</td></tr>
+  <tr><td>searchScope</td><td>xs:string</td><td>sets the LDAP search scope</td></tr>
+  <tr><td>staticBridge</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>suppressDuplicateQueueSubscriptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>suppressDuplicateTopicSubscriptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>uri</td><td>xs:string</td><td>returns the next URI from the configured list</td></tr>
+  <tr><td>useCompression</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>user</td><td>xs:string</td><td>sets the LDAP user for access credentials</td></tr>
+  <tr><td>userName</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>connectionFilter</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>durableDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>dynamicallyIncludedDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>excludedDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>staticallyIncludedDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='lease-database-locker'>lease-database-locker</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>failIfLocked</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>leaseHolderId</td><td>xs:string</td><td></td></tr>
+  <tr><td>lockAcquireSleepInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>maxAllowableDiffFromDBTime</td><td>xs:integer</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>queryTimeout</td><td>xs:integer</td><td></td></tr>
+</table>
+<h2>Element: <a name='levelDB'>levelDB</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>asyncBufferSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>directory</td><td>xs:string</td><td></td></tr>
+  <tr><td>failIfLocked</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>flushDelay</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexBlockRestartInterval</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexBlockSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexCacheSize</td><td>xs:long</td><td></td></tr>
+  <tr><td>indexCompression</td><td>xs:string</td><td></td></tr>
+  <tr><td>indexFactory</td><td>xs:string</td><td></td></tr>
+  <tr><td>indexMaxOpenFiles</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexWriteBufferSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>logCompression</td><td>xs:string</td><td></td></tr>
+  <tr><td>logDirectory</td><td>xs:string</td><td></td></tr>
+  <tr><td>logSize</td><td>xs:long</td><td></td></tr>
+  <tr><td>monitorStats</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>paranoidChecks</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>sync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>verifyChecksums</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>usageManager</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='loggingBrokerPlugin'>loggingBrokerPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>logAll</td><td>xs:boolean</td><td>Logger all Events that go through the Plugin</td></tr>
+  <tr><td>logConnectionEvents</td><td>xs:boolean</td><td>Logger Events that are related to connections</td></tr>
+  <tr><td>logConsumerEvents</td><td>xs:boolean</td><td>Logger Events that are related to Consumers</td></tr>
+  <tr><td>logInternalEvents</td><td>xs:boolean</td><td>Logger Events that are normally internal to the broker</td></tr>
+  <tr><td>logMessageEvents</td><td>xs:boolean</td><td>Logger Events that are related to message processing</td></tr>
+  <tr><td>logProducerEvents</td><td>xs:boolean</td><td>Logger Events that are related to Producers</td></tr>
+  <tr><td>logSessionEvents</td><td>xs:boolean</td><td>Logger Events that are related to sessions</td></tr>
+  <tr><td>logTransactionEvents</td><td>xs:boolean</td><td>Logger Events that are related to transaction processing</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminConnectionContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>next</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='mKahaDB'>mKahaDB</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>directory</td><td>xs:string</td><td></td></tr>
+  <tr><td>journalMaxFileLength</td><td>xs:string</td><td>Set the max file length of the transaction journal
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can
+be used</td></tr>
+  <tr><td>journalWriteBatchSize</td><td>xs:string</td><td>Set the max write batch size of  the transaction journal
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can
+be used</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>entries</td><td>(&lt;spring:bean/&gt;)*</td><td>A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring</td></tr>
+  <tr><td>filteredPersistenceAdapters</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets the  FilteredKahaDBPersistenceAdapter entries</td></tr>
+  <tr><td>transactionStore</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>usageManager</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='managementContext'>managementContext</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>allowRemoteAddressInMBeanNames</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td>Gets the broker name this context is used by, may be <tt>null</tt>
+if the broker name was not set.</td></tr>
+  <tr><td>connectorHost</td><td>xs:string</td><td>Get the connectorHost</td></tr>
+  <tr><td>connectorPath</td><td>xs:string</td><td></td></tr>
+  <tr><td>connectorPort</td><td>xs:string</td><td></td></tr>
+  <tr><td>createConnector</td><td>xs:string</td><td></td></tr>
+  <tr><td>createMBeanServer</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>findTigerMbeanServer</td><td>xs:boolean</td><td>Enables/disables the searching for the Java 5 platform MBeanServer</td></tr>
+  <tr><td>jmxDomainName</td><td>xs:string</td><td></td></tr>
+  <tr><td>rmiServerPort</td><td>xs:string</td><td></td></tr>
+  <tr><td>useMBeanServer</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>MBeanServer</td><td>&lt;spring:bean/&gt;</td><td>Get the MBeanServer</td></tr>
+  <tr><td>environment</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>server</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='masterConnector'>masterConnector</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>failedToStart</td><td>xs:boolean</td><td>Get the failedToStart</td></tr>
+  <tr><td>localURI</td><td>xs:string</td><td></td></tr>
+  <tr><td>password</td><td>xs:string</td><td></td></tr>
+  <tr><td>remoteURI</td><td>xs:string</td><td></td></tr>
+  <tr><td>remoteUri</td><td>xs:string</td><td></td></tr>
+  <tr><td>userName</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='maxdb-jdbc-adapter'>maxdb-jdbc-adapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='memoryPersistenceAdapter'>memoryPersistenceAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>createTransactionStore</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>directory</td><td>xs:string</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>usageManager</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='memoryUsage'>memoryUsage</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>limit</td><td>xs:string</td><td>Sets the memory limit in bytes. Setting the limit in bytes will set the
+usagePortion to 0 since the UsageManager is not going to be portion based
+off the parent.
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>percentUsage</td><td>xs:integer</td><td></td></tr>
+  <tr><td>percentUsageMinDelta</td><td>xs:string</td><td>Sets the minimum number of percentage points the usage has to change
+before a UsageListener event is fired by the manager.</td></tr>
+  <tr><td>pollingTime</td><td>xs:integer</td><td></td></tr>
+  <tr><td>portion</td><td>xs:float</td><td></td></tr>
+  <tr><td>usage</td><td>xs:long</td><td></td></tr>
+  <tr><td>usagePortion</td><td>xs:float</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>executor</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>limiter</td><td><a href='#defaultUsageCapacity'>defaultUsageCapacity</a> | <a href='#usageCapacity'>usageCapacity</a></td><td></td></tr>
+  <tr><td>parent</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='messageGroupHashBucketFactory'>messageGroupHashBucketFactory</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>bucketCount</td><td>xs:integer</td><td>Sets the number of hash buckets to use for the message group
+functionality. This is only applicable to using message groups to
+parallelize processing of a queue while preserving order across an
+individual JMSXGroupID header value. This value sets the number of hash
+buckets that will be used (i.e. the maximum possible concurrency).</td></tr>
+</table>
+<h2>Element: <a name='mirroredQueue'>mirroredQueue</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>copyMessage</td><td>xs:boolean</td><td>Sets whether a copy of the message will be sent to each destination.
+Defaults to true so that the forward destination is set as the
+destination of the message</td></tr>
+  <tr><td>postfix</td><td>xs:string</td><td>Sets any postix used to identify the queue consumers</td></tr>
+  <tr><td>prefix</td><td>xs:string</td><td>Sets the prefix wildcard used to identify the queue consumers for a given
+topic</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='multicastNetworkConnector'>multicastNetworkConnector</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>alwaysSyncSend</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>bridgeTempDestinations</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>brokerURL</td><td>xs:string</td><td></td></tr>
+  <tr><td>conduitSubscriptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>consumerPriorityBase</td><td>xs:integer</td><td></td></tr>
+  <tr><td>decreaseNetworkConsumerPriority</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>destinationFilter</td><td>xs:string</td><td></td></tr>
+  <tr><td>dispatchAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>duplex</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>dynamicOnly</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>localUri</td><td>xs:string</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>networkTTL</td><td>xs:integer</td><td></td></tr>
+  <tr><td>objectName</td><td>xs:string</td><td></td></tr>
+  <tr><td>password</td><td>xs:string</td><td></td></tr>
+  <tr><td>prefetchSize</td><td>xs:string</td><td></td></tr>
+  <tr><td>remoteURI</td><td>xs:string</td><td>Sets the remote transport URI to some group transport like
+<code>multicast://address:port</code></td></tr>
+  <tr><td>staticBridge</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>suppressDuplicateQueueSubscriptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>suppressDuplicateTopicSubscriptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useCompression</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>userName</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>bridge</td><td><a href='#compositeDemandForwardingBridge'>compositeDemandForwardingBridge</a> | <a href='#demandForwardingBridge'>demandForwardingBridge</a></td><td></td></tr>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>connectionFilter</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>durableDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>dynamicallyIncludedDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>excludedDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>localTransport</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>remoteTransport</td><td>&lt;spring:bean/&gt;</td><td>Sets the remote transport implementation</td></tr>
+  <tr><td>staticallyIncludedDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>broadcast</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>destination</td><td>xs:string</td><td></td></tr>
+  <tr><td>maxTraceDatagramSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>timeToLive</td><td>xs:integer</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>address</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>adminConnectionContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>next</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+  <tr><td>wireFormat</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>wireFormatFactory</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='mysql-jdbc-adapter'>mysql-jdbc-adapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>engineType</td><td>xs:string</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>typeStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='networkConnector'>networkConnector</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>alwaysSyncSend</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>bridgeTempDestinations</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>brokerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>brokerURL</td><td>xs:string</td><td></td></tr>
+  <tr><td>conduitSubscriptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>consumerPriorityBase</td><td>xs:integer</td><td></td></tr>
+  <tr><td>decreaseNetworkConsumerPriority</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>destinationFilter</td><td>xs:string</td><td></td></tr>
+  <tr><td>discoveryURI</td><td>xs:string</td><td></td></tr>
+  <tr><td>dispatchAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>duplex</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>dynamicOnly</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>localUri</td><td>xs:string</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>networkTTL</td><td>xs:integer</td><td></td></tr>
+  <tr><td>objectName</td><td>xs:string</td><td></td></tr>
+  <tr><td>password</td><td>xs:string</td><td></td></tr>
+  <tr><td>prefetchSize</td><td>xs:string</td><td></td></tr>
+  <tr><td>staticBridge</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>suppressDuplicateQueueSubscriptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>suppressDuplicateTopicSubscriptions</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>uri</td><td>xs:string</td><td></td></tr>
+  <tr><td>useCompression</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>userName</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+  <tr><td>connectionFilter</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>discoveryAgent</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>durableDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>dynamicallyIncludedDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>excludedDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>staticallyIncludedDestinations</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='noSubscriptionRecoveryPolicy'>noSubscriptionRecoveryPolicy</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>broker</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='oldestMessageEvictionStrategy'>oldestMessageEvictionStrategy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>evictExpiredMessagesHighWatermark</td><td>xs:integer</td><td>Sets the high water mark on which we will eagerly evict expired messages from RAM</td></tr>
+</table>
+<h2>Element: <a name='oldestMessageWithLowestPriorityEvictionStrategy'>oldestMessageWithLowestPriorityEvictionStrategy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>evictExpiredMessagesHighWatermark</td><td>xs:integer</td><td>Sets the high water mark on which we will eagerly evict expired messages from RAM</td></tr>
+</table>
+<h2>Element: <a name='oracleBlobJDBCAdapter'>oracleBlobJDBCAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='oracleJDBCAdapter'>oracleJDBCAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='outboundQueueBridge'>outboundQueueBridge</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>doHandleReplyTo</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>localQueueName</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundQueueName</td><td>xs:string</td><td>Sets the name of the outbound queue name.  If the inbound queue name
+has not been set already then this method uses the provided queue name
+to set the inbound topic name as well.</td></tr>
+  <tr><td>selector</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>consumer</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerQueue</td><td><a href='#queue'>queue</a></td><td></td></tr>
+  <tr><td>jmsConnector</td><td><a href='#jmsQueueConnector'>jmsQueueConnector</a> | <a href='#jmsTopicConnector'>jmsTopicConnector</a></td><td></td></tr>
+  <tr><td>jmsMessageConvertor</td><td><a href='#simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></td><td></td></tr>
+  <tr><td>producerConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>producerQueue</td><td><a href='#queue'>queue</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='outboundTopicBridge'>outboundTopicBridge</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>consumerName</td><td>xs:string</td><td></td></tr>
+  <tr><td>doHandleReplyTo</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>localTopicName</td><td>xs:string</td><td></td></tr>
+  <tr><td>outboundTopicName</td><td>xs:string</td><td>Sets the name of the outbound topic name.  If the inbound topic name
+has not been set already then this method uses the provided topic name
+to set the inbound topic name as well.</td></tr>
+  <tr><td>selector</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>consumer</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>consumerTopic</td><td><a href='#topic'>topic</a></td><td></td></tr>
+  <tr><td>jmsConnector</td><td><a href='#jmsQueueConnector'>jmsQueueConnector</a> | <a href='#jmsTopicConnector'>jmsTopicConnector</a></td><td></td></tr>
+  <tr><td>jmsMessageConvertor</td><td><a href='#simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></td><td></td></tr>
+  <tr><td>producerConnection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>producerTopic</td><td><a href='#topic'>topic</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='pListStore'>pListStore</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>cleanupInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>directory</td><td>xs:string</td><td></td></tr>
+  <tr><td>enableIndexWriteAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>failIfDatabaseIsLocked</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>indexCacheSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexEnablePageCaching</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>indexPageSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>indexWriteBatchSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>journalMaxFileLength</td><td>xs:integer</td><td></td></tr>
+  <tr><td>journalMaxWriteBatchSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>lazyInit</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='policyEntry'>policyEntry</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>advisoryForConsumed</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>advisoryForDelivery</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>advisoryForDiscardingMessages</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>advisoryForFastProducers</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>advisoryForSlowConsumers</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>advisoryWhenFull</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>allConsumersExclusiveByDefault</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>alwaysRetroactive</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>blockedProducerWarningInterval</td><td>xs:long</td><td>Set's the interval at which warnings about producers being blocked by
+resource usage will be triggered. Values of 0 or less will disable
+warnings</td></tr>
+  <tr><td>consumersBeforeDispatchStarts</td><td>xs:integer</td><td></td></tr>
+  <tr><td>cursorMemoryHighWaterMark</td><td>xs:integer</td><td></td></tr>
+  <tr><td>doOptimzeMessageStorage</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>durableTopicPrefetch</td><td>xs:integer</td><td>Get the durableTopicPrefetch</td></tr>
+  <tr><td>enableAudit</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>expireMessagesPeriod</td><td>xs:long</td><td></td></tr>
+  <tr><td>gcInactiveDestinations</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>gcWithNetworkConsumers</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>inactiveTimoutBeforeGC</td><td>xs:long</td><td></td></tr>
+  <tr><td>lazyDispatch</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxAuditDepth</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxBrowsePageSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxExpirePageSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxPageSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxProducersToAudit</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxQueueAuditDepth</td><td>xs:integer</td><td></td></tr>
+  <tr><td>memoryLimit</td><td>xs:string</td><td>When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>minimumMessageSize</td><td>xs:long</td><td></td></tr>
+  <tr><td>optimizeMessageStoreInFlightLimit</td><td>xs:integer</td><td></td></tr>
+  <tr><td>optimizedDispatch</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>prioritizedMessages</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>producerFlowControl</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>queue</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>queueBrowserPrefetch</td><td>xs:integer</td><td>Get the queueBrowserPrefetch</td></tr>
+  <tr><td>queuePrefetch</td><td>xs:integer</td><td>Get the queuePrefetch</td></tr>
+  <tr><td>reduceMemoryFootprint</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>sendAdvisoryIfNoConsumers</td><td>xs:boolean</td><td>Sends an advisory message if a non-persistent message is sent and there
+are no active consumers</td></tr>
+  <tr><td>storeUsageHighWaterMark</td><td>xs:integer</td><td></td></tr>
+  <tr><td>strictOrderDispatch</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>tempQueue</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>tempTopic</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>timeBeforeDispatchStarts</td><td>xs:integer</td><td></td></tr>
+  <tr><td>topic</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>topicPrefetch</td><td>xs:integer</td><td>Get the topicPrefetch</td></tr>
+  <tr><td>useCache</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useConsumerPriority</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>usePrefetchExtension</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>deadLetterStrategy</td><td><a href='#individualDeadLetterStrategy'>individualDeadLetterStrategy</a> | <a href='#sharedDeadLetterStrategy'>sharedDeadLetterStrategy</a></td><td>Sets the policy used to determine which dead letter queue destination
+should be used</td></tr>
+  <tr><td>destination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+  <tr><td>dispatchPolicy</td><td><a href='#priorityNetworkDispatchPolicy'>priorityNetworkDispatchPolicy</a> | <a href='#roundRobinDispatchPolicy'>roundRobinDispatchPolicy</a> | <a href='#simpleDispatchPolicy'>simpleDispatchPolicy</a> | <a href='#strictOrderDispatchPolicy'>strictOrderDispatchPolicy</a></td><td></td></tr>
+  <tr><td>messageEvictionStrategy</td><td><a href='#oldestMessageEvictionStrategy'>oldestMessageEvictionStrategy</a> | <a href='#oldestMessageWithLowestPriorityEvictionStrategy'>oldestMessageWithLowestPriorityEvictionStrategy</a> | <a href='#uniquePropertyMessageEvictionStrategy'>uniquePropertyMessageEvictionStrategy</a></td><td>Sets the eviction strategy used to decide which message to evict when the
+slow consumer needs to discard messages</td></tr>
+  <tr><td>messageGroupMapFactory</td><td><a href='#messageGroupHashBucketFactory'>messageGroupHashBucketFactory</a> | <a href='#simpleMessageGroupMapFactory'>simpleMessageGroupMapFactory</a></td><td>Sets the factory used to create new instances of {MessageGroupMap} used
+to implement the <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a>
+functionality.</td></tr>
+  <tr><td>networkBridgeFilterFactory</td><td><a href='#conditionalNetworkBridgeFilterFactory'>conditionalNetworkBridgeFilterFactory</a> | <a href='#defaultNetworkBridgeFilterFactory'>defaultNetworkBridgeFilterFactory</a></td><td></td></tr>
+  <tr><td>pendingDurableSubscriberPolicy</td><td><a href='#fileDurableSubscriberCursor'>fileDurableSubscriberCursor</a> | <a href='#storeDurableSubscriberCursor'>storeDurableSubscriberCursor</a> | <a href='#vmDurableCursor'>vmDurableCursor</a></td><td></td></tr>
+  <tr><td>pendingMessageLimitStrategy</td><td><a href='#constantPendingMessageLimitStrategy'>constantPendingMessageLimitStrategy</a> | <a href='#prefetchRatePendingMessageLimitStrategy'>prefetchRatePendingMessageLimitStrategy</a></td><td>Sets the strategy to calculate the maximum number of messages that are
+allowed to be pending on consumers (in addition to their prefetch sizes).
+Once the limit is reached, non-durable topics can then start discarding
+old messages. This allows us to keep dispatching messages to slow
+consumers while not blocking fast consumers and discarding the messages
+oldest first.</td></tr>
+  <tr><td>pendingQueuePolicy</td><td><a href='#fileQueueCursor'>fileQueueCursor</a> | <a href='#storeCursor'>storeCursor</a> | <a href='#vmQueueCursor'>vmQueueCursor</a></td><td></td></tr>
+  <tr><td>pendingSubscriberPolicy</td><td><a href='#fileCursor'>fileCursor</a> | <a href='#vmCursor'>vmCursor</a></td><td></td></tr>
+  <tr><td>slowConsumerStrategy</td><td><a href='#abortSlowConsumerStrategy'>abortSlowConsumerStrategy</a></td><td></td></tr>
+  <tr><td>subscriptionRecoveryPolicy</td><td><a href='#fixedCountSubscriptionRecoveryPolicy'>fixedCountSubscriptionRecoveryPolicy</a> | <a href='#fixedSizedSubscriptionRecoveryPolicy'>fixedSizedSubscriptionRecoveryPolicy</a> | <a href='#lastImageSubscriptionRecoveryPolicy'>lastImageSubscriptionRecoveryPolicy</a> | <a href='#noSubscriptionRecoveryPolicy'>noSubscriptionRecoveryPolicy</a> | <a href='#queryBasedSubscriptionRecoveryPolicy'>queryBasedSubscriptionRecoveryPolicy</a> | <a href='#timedSubscriptionRecoveryPolicy'>timedSubscriptionRecoveryPolicy</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='policyMap'>policyMap</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>defaultEntry</td><td><a href='#policyEntry'>policyEntry</a></td><td></td></tr>
+  <tr><td>entries</td><td>(&lt;spring:bean/&gt;)*</td><td>A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring</td></tr>
+  <tr><td>policyEntries</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets the individual entries on the policy map</td></tr>
+</table>
+<h2>Element: <a name='postgresql-jdbc-adapter'>postgresql-jdbc-adapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>acksPkName</td><td>xs:string</td><td></td></tr>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='prefetchPolicy'>prefetchPolicy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>all</td><td>xs:integer</td><td></td></tr>
+  <tr><td>durableTopicPrefetch</td><td>xs:integer</td><td></td></tr>
+  <tr><td>inputStreamPrefetch</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maximumPendingMessageLimit</td><td>xs:integer</td><td>Sets how many messages a broker will keep around, above the prefetch
+limit, for non-durable topics before starting to discard older messages.</td></tr>
+  <tr><td>optimizeDurableTopicPrefetch</td><td>xs:integer</td><td></td></tr>
+  <tr><td>queueBrowserPrefetch</td><td>xs:integer</td><td></td></tr>
+  <tr><td>queuePrefetch</td><td>xs:integer</td><td></td></tr>
+  <tr><td>topicPrefetch</td><td>xs:integer</td><td></td></tr>
+</table>
+<h2>Element: <a name='prefetchRatePendingMessageLimitStrategy'>prefetchRatePendingMessageLimitStrategy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>multiplier</td><td>xs:double</td><td>Sets the multiplier of the prefetch size which will be used to define the maximum number of pending
+messages for non-durable topics before messages are discarded.</td></tr>
+</table>
+<h2>Element: <a name='priorityNetworkDispatchPolicy'>priorityNetworkDispatchPolicy</a></h2>
+<h2>Element: <a name='proxyConnector'>proxyConnector</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>bind</td><td>xs:string</td><td></td></tr>
+  <tr><td>localUri</td><td>xs:string</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>proxyToLocalBroker</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>remote</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>server</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='queryBasedSubscriptionRecoveryPolicy'>queryBasedSubscriptionRecoveryPolicy</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>broker</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+  <tr><td>query</td><td>&lt;spring:bean/&gt;</td><td>Sets the query strategy to load initial messages</td></tr>
+</table>
+<h2>Element: <a name='queue'>queue</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>physicalName</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>compositeDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>properties</td><td>&lt;spring:bean/&gt;</td><td>Get the properties from this instance for storing in JNDI</td></tr>
+</table>
+<h2>Element: <a name='queueDispatchSelector'>queueDispatchSelector</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>destination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+  <tr><td>exclusiveConsumer</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='reconnectionPolicy'>reconnectionPolicy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>backOffMultiplier</td><td>xs:double</td><td>Gets the multiplier used to grow the delay between connection attempts from the initial
+time to the max set time.  By default this value is set to 2.0.</td></tr>
+  <tr><td>initialReconnectDelay</td><td>xs:long</td><td>Gets the initial delay value used before a reconnection attempt is made.  If the
+use exponential back-off value is set to false then this will be the fixed time
+between connection attempts.  By default this value is set to one second.</td></tr>
+  <tr><td>maxInitialConnectAttempts</td><td>xs:integer</td><td>Gets the maximum number of times that the {@link JmsConnector} will try
+to connect on startup to before it marks itself as failed and does not
+try any further connections.</td></tr>
+  <tr><td>maxReconnectAttempts</td><td>xs:integer</td><td>Gets the number of time that {@link JmsConnector} will attempt to connect
+or reconnect before giving up.  By default the policy sets this value to
+a negative value meaning try forever.</td></tr>
+  <tr><td>maxSendRetries</td><td>xs:integer</td><td>Gets the maximum number of a times a Message send should be retried before
+a JMSExeception is thrown indicating that the operation failed.</td></tr>
+  <tr><td>maximumReconnectDelay</td><td>xs:long</td><td>Gets the maximum delay that is inserted between each attempt to connect
+before another attempt is made.  The default setting for this value is
+30 seconds.</td></tr>
+  <tr><td>sendRetyDelay</td><td>xs:long</td><td>Set the amount of time the DestionationBridge will wait between attempts
+to forward a message.  The default policy limits the minimum time between
+send attempt to one second.</td></tr>
+  <tr><td>useExponentialBackOff</td><td>xs:boolean</td><td>Gets whether the policy uses the set back-off multiplier to grow the time between
+connection attempts.</td></tr>
+</table>
+<h2>Element: <a name='redeliveryPlugin'>redeliveryPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>fallbackToDeadLetter</td><td>xs:boolean</td><td>What to do if there is no matching redelivery policy for a destination.
+when true, the region broker DLQ processing will be used via sendToDeadLetterQueue
+when false, there is no action</td></tr>
+  <tr><td>sendToDlqIfMaxRetriesExceeded</td><td>xs:boolean</td><td>What to do if the maxretries on a matching redelivery policy is exceeded.
+when true, the region broker DLQ processing will be used via sendToDeadLetterQueue
+when false, there is no action</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminConnectionContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>next</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+  <tr><td>redeliveryPolicyMap</td><td><a href='#redeliveryPolicyMap'>redeliveryPolicyMap</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='redeliveryPolicy'>redeliveryPolicy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>backOffMultiplier</td><td>xs:double</td><td></td></tr>
+  <tr><td>collisionAvoidancePercent</td><td>xs:short</td><td></td></tr>
+  <tr><td>initialRedeliveryDelay</td><td>xs:long</td><td></td></tr>
+  <tr><td>maximumRedeliveries</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maximumRedeliveryDelay</td><td>xs:long</td><td></td></tr>
+  <tr><td>queue</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>redeliveryDelay</td><td>xs:long</td><td></td></tr>
+  <tr><td>tempQueue</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>tempTopic</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>topic</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>useCollisionAvoidance</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useExponentialBackOff</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>destination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='redeliveryPolicyMap'>redeliveryPolicyMap</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>defaultEntry</td><td><a href='#redeliveryPolicy'>redeliveryPolicy</a></td><td></td></tr>
+  <tr><td>entries</td><td>(&lt;spring:bean/&gt;)*</td><td>A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring</td></tr>
+  <tr><td>redeliveryPolicyEntries</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets the individual entries on the redeliveryPolicyMap</td></tr>
+</table>
+<h2>Element: <a name='roundRobinDispatchPolicy'>roundRobinDispatchPolicy</a></h2>
+<h2>Element: <a name='shared-file-locker'>shared-file-locker</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>directory</td><td>xs:string</td><td></td></tr>
+  <tr><td>failIfLocked</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>lockAcquireSleepInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+</table>
+<h2>Element: <a name='sharedDeadLetterStrategy'>sharedDeadLetterStrategy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>enableAudit</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>processExpired</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>processNonPersistent</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>deadLetterQueue</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='simpleAuthenticationPlugin'>simpleAuthenticationPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>anonymousAccessAllowed</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>anonymousGroup</td><td>xs:string</td><td></td></tr>
+  <tr><td>anonymousUser</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>userGroups</td><td>&lt;spring:bean/&gt;</td><td>Sets the groups a user is in. The key is the user name and the value is a
+Set of groups</td></tr>
+  <tr><td>userPasswords</td><td>&lt;spring:bean/&gt;</td><td>Sets the map indexed by user name with the value the password</td></tr>
+  <tr><td>users</td><td>(&lt;spring:bean/&gt;)*</td><td>Sets individual users for authentication</td></tr>
+</table>
+<h2>Element: <a name='simpleAuthorizationMap'>simpleAuthorizationMap</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminACLs</td><td><a href='#authorizationMap'>authorizationMap</a> | <a href='#cachedLDAPAuthorizationMap'>cachedLDAPAuthorizationMap</a> | <a href='#mKahaDB'>mKahaDB</a> | <a href='#policyMap'>policyMap</a> | <a href='#redeliveryPolicyMap'>redeliveryPolicyMap</a></td><td></td></tr>
+  <tr><td>readACLs</td><td><a href='#authorizationMap'>authorizationMap</a> | <a href='#cachedLDAPAuthorizationMap'>cachedLDAPAuthorizationMap</a> | <a href='#mKahaDB'>mKahaDB</a> | <a href='#policyMap'>policyMap</a> | <a href='#redeliveryPolicyMap'>redeliveryPolicyMap</a></td><td></td></tr>
+  <tr><td>tempDestinationAuthorizationEntry</td><td><a href='#tempDestinationAuthorizationEntry'>tempDestinationAuthorizationEntry</a></td><td></td></tr>
+  <tr><td>writeACLs</td><td><a href='#authorizationMap'>authorizationMap</a> | <a href='#cachedLDAPAuthorizationMap'>cachedLDAPAuthorizationMap</a> | <a href='#mKahaDB'>mKahaDB</a> | <a href='#policyMap'>policyMap</a> | <a href='#redeliveryPolicyMap'>redeliveryPolicyMap</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='simpleDispatchPolicy'>simpleDispatchPolicy</a></h2>
+<h2>Element: <a name='simpleDispatchSelector'>simpleDispatchSelector</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>destination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='simpleJmsMessageConvertor'>simpleJmsMessageConvertor</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>connection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='simpleMessageGroupMapFactory'>simpleMessageGroupMapFactory</a></h2>
+<h2>Element: <a name='sslContext'>sslContext</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>keyStore</td><td>xs:string</td><td></td></tr>
+  <tr><td>keyStoreAlgorithm</td><td>xs:string</td><td></td></tr>
+  <tr><td>keyStoreKeyPassword</td><td>xs:string</td><td></td></tr>
+  <tr><td>keyStorePassword</td><td>xs:string</td><td></td></tr>
+  <tr><td>keyStoreType</td><td>xs:string</td><td></td></tr>
+  <tr><td>protocol</td><td>xs:string</td><td></td></tr>
+  <tr><td>provider</td><td>xs:string</td><td></td></tr>
+  <tr><td>secureRandomAlgorithm</td><td>xs:string</td><td></td></tr>
+  <tr><td>trustStore</td><td>xs:string</td><td></td></tr>
+  <tr><td>trustStoreAlgorithm</td><td>xs:string</td><td></td></tr>
+  <tr><td>trustStorePassword</td><td>xs:string</td><td></td></tr>
+  <tr><td>trustStoreType</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>SSLContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>keyManagers</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>secureRandom</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>trustManagers</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='statements'>statements</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>addMessageStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>binaryDataType</td><td>xs:string</td><td></td></tr>
+  <tr><td>clearDurableLastAckInTxStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>clearXidFlagStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>containerNameDataType</td><td>xs:string</td><td></td></tr>
+  <tr><td>createDurableSubStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>currentDateTimeStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>deleteOldMessagesStatementWithPriority</td><td>xs:string</td><td></td></tr>
+  <tr><td>deleteSubscriptionStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>destinationMessageCountStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>dropAckPKAlterStatementEnd</td><td>xs:string</td><td></td></tr>
+  <tr><td>durableSubAcksTableName</td><td>xs:string</td><td></td></tr>
+  <tr><td>durableSubscriberMessageCountStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>durableSubscriberMessageCountStatementWithPriority</td><td>xs:string</td><td></td></tr>
+  <tr><td>findAcksPendingOutcomeStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findAllDestinationsStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findAllDurableSubMessagesStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findAllDurableSubsStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findAllMessagesStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findDurableSubMessagesStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findDurableSubStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findLastSequenceIdInAcksStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findLastSequenceIdInMsgsStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findMessageByIdStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findMessageSequenceIdStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findMessageStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findNextMessagesStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findOpsPendingOutcomeStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>findXidByIdStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>insertDurablePriorityAckStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>lastAckedDurableSubscriberMessageStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>lastProducerSequenceIdStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>leaseObtainStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>leaseOwnerStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>leaseUpdateStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>lockCreateStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>lockTableName</td><td>xs:string</td><td></td></tr>
+  <tr><td>lockUpdateStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>longDataType</td><td>xs:string</td><td></td></tr>
+  <tr><td>messageTableName</td><td>xs:string</td><td></td></tr>
+  <tr><td>msgIdDataType</td><td>xs:string</td><td></td></tr>
+  <tr><td>nextDurableSubscriberMessageStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>removeAllMessagesStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>removeAllSubscriptionsStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>removeMessageStatment</td><td>xs:string</td><td></td></tr>
+  <tr><td>selectDurablePriorityAckStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>sequenceDataType</td><td>xs:string</td><td></td></tr>
+  <tr><td>stringIdDataType</td><td>xs:string</td><td></td></tr>
+  <tr><td>tablePrefix</td><td>xs:string</td><td></td></tr>
+  <tr><td>updateDurableLastAckInTxStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>updateDurableLastAckStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>updateDurableLastAckWithPriorityInTxStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>updateDurableLastAckWithPriorityStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>updateLastPriorityAckRowOfDurableSubStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>updateMessageStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>updateXidFlagStatement</td><td>xs:string</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useLockCreateWhereClause</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>createSchemaStatements</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>dropSchemaStatements</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='statisticsBrokerPlugin'>statisticsBrokerPlugin</a></h2>
+<h2>Element: <a name='storeCursor'>storeCursor</a></h2>
+<h2>Element: <a name='storeDurableSubscriberCursor'>storeDurableSubscriberCursor</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>immediatePriorityDispatch</td><td>xs:boolean</td><td>Ensure that new higher priority messages will get an immediate dispatch
+rather than wait for the end of the current cursor batch.
+Useful when there is a large message backlog and intermittent high priority messages.</td></tr>
+  <tr><td>useCache</td><td>xs:boolean</td><td></td></tr>
+</table>
+<h2>Element: <a name='storeUsage'>storeUsage</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>limit</td><td>xs:string</td><td>Sets the memory limit in bytes. Setting the limit in bytes will set the
+usagePortion to 0 since the UsageManager is not going to be portion based
+off the parent.
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>percentUsage</td><td>xs:integer</td><td></td></tr>
+  <tr><td>percentUsageMinDelta</td><td>xs:string</td><td>Sets the minimum number of percentage points the usage has to change
+before a UsageListener event is fired by the manager.</td></tr>
+  <tr><td>pollingTime</td><td>xs:integer</td><td></td></tr>
+  <tr><td>usagePortion</td><td>xs:float</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>executor</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>limiter</td><td><a href='#defaultUsageCapacity'>defaultUsageCapacity</a> | <a href='#usageCapacity'>usageCapacity</a></td><td></td></tr>
+  <tr><td>parent</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>store</td><td><a href='#amqPersistenceAdapter'>amqPersistenceAdapter</a> | <a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a> | <a href='#journalPersistenceAdapter'>journalPersistenceAdapter</a> | <a href='#kahaDB'>kahaDB</a> | <a href='#kahaPersistenceAdapter'>kahaPersistenceAdapter</a> | <a href='#levelDB'>levelDB</a> | <a href='#mKahaDB'>mKahaDB</a> | <a href='#memoryPersistenceAdapter'>memoryPersistenceAdapter</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='streamJDBCAdapter'>streamJDBCAdapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='strictOrderDispatchPolicy'>strictOrderDispatchPolicy</a></h2>
+<h2>Element: <a name='sybase-jdbc-adapter'>sybase-jdbc-adapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='systemUsage'>systemUsage</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>sendFailIfNoSpace</td><td>xs:boolean</td><td>Sets whether or not a send() should fail if there is no space free. The
+default value is false which means to block the send() method until space
+becomes available</td></tr>
+  <tr><td>sendFailIfNoSpaceAfterTimeout</td><td>xs:long</td><td></td></tr>
+  <tr><td>sendFailIfNoSpaceExplicitySet</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adapter</td><td><a href='#amqPersistenceAdapter'>amqPersistenceAdapter</a> | <a href='#jdbcPersistenceAdapter'>jdbcPersistenceAdapter</a> | <a href='#journalPersistenceAdapter'>journalPersistenceAdapter</a> | <a href='#kahaDB'>kahaDB</a> | <a href='#kahaPersistenceAdapter'>kahaPersistenceAdapter</a> | <a href='#levelDB'>levelDB</a> | <a href='#mKahaDB'>mKahaDB</a> | <a href='#memoryPersistenceAdapter'>memoryPersistenceAdapter</a></td><td></td></tr>
+  <tr><td>executor</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>memoryUsage</td><td><a href='#memoryUsage'>memoryUsage</a></td><td></td></tr>
+  <tr><td>parent</td><td><a href='#systemUsage'>systemUsage</a></td><td></td></tr>
+  <tr><td>storeUsage</td><td><a href='#storeUsage'>storeUsage</a></td><td></td></tr>
+  <tr><td>tempStore</td><td><a href='#pListStore'>pListStore</a></td><td></td></tr>
+  <tr><td>tempUsage</td><td><a href='#tempUsage'>tempUsage</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='taskRunnerFactory'>taskRunnerFactory</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>daemon</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>dedicatedTaskRunner</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxIterationsPerRun</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maxThreadPoolSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>priority</td><td>xs:integer</td><td></td></tr>
+  <tr><td>shutdownAwaitTermination</td><td>xs:long</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>executor</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>rejectedTaskHandler</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='tempDestinationAuthorizationEntry'>tempDestinationAuthorizationEntry</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>admin</td><td>xs:string</td><td></td></tr>
+  <tr><td>groupClass</td><td>xs:string</td><td></td></tr>
+  <tr><td>queue</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>read</td><td>xs:string</td><td></td></tr>
+  <tr><td>tempQueue</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>tempTopic</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>topic</td><td>xs:string</td><td>A helper method to set the destination from a configuration file</td></tr>
+  <tr><td>write</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminACLs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>destination</td><td><a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a></td><td></td></tr>
+  <tr><td>readACLs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+  <tr><td>writeACLs</td><td>(&lt;spring:bean/&gt;)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='tempQueue'>tempQueue</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>connectionId</td><td>xs:string</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>physicalName</td><td>xs:string</td><td></td></tr>
+  <tr><td>sequenceId</td><td>xs:long</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>compositeDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>connection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>properties</td><td>&lt;spring:bean/&gt;</td><td>Get the properties from this instance for storing in JNDI</td></tr>
+</table>
+<h2>Element: <a name='tempTopic'>tempTopic</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>connectionId</td><td>xs:string</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>physicalName</td><td>xs:string</td><td></td></tr>
+  <tr><td>sequenceId</td><td>xs:long</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>compositeDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>connection</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>properties</td><td>&lt;spring:bean/&gt;</td><td>Get the properties from this instance for storing in JNDI</td></tr>
+</table>
+<h2>Element: <a name='tempUsage'>tempUsage</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>limit</td><td>xs:string</td><td>Sets the memory limit in bytes. Setting the limit in bytes will set the
+usagePortion to 0 since the UsageManager is not going to be portion based
+off the parent.
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used</td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>percentUsage</td><td>xs:integer</td><td></td></tr>
+  <tr><td>percentUsageMinDelta</td><td>xs:string</td><td>Sets the minimum number of percentage points the usage has to change
+before a UsageListener event is fired by the manager.</td></tr>
+  <tr><td>pollingTime</td><td>xs:integer</td><td></td></tr>
+  <tr><td>usagePortion</td><td>xs:float</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>executor</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>limiter</td><td><a href='#defaultUsageCapacity'>defaultUsageCapacity</a> | <a href='#usageCapacity'>usageCapacity</a></td><td></td></tr>
+  <tr><td>parent</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>store</td><td><a href='#pListStore'>pListStore</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>futureOnly</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>ttlCeiling</td><td>xs:long</td><td>setter method for ttlCeiling</td></tr>
+  <tr><td>zeroExpirationOverride</td><td>xs:long</td><td>setter method for zeroExpirationOverride</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminConnectionContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>next</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+  <tr><td>processNetworkMessages</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='timedSubscriptionRecoveryPolicy'>timedSubscriptionRecoveryPolicy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>recoverDuration</td><td>xs:long</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>broker</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='topic'>topic</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>physicalName</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>compositeDestinations</td><td>(<a href='#queue'>queue</a> | <a href='#tempQueue'>tempQueue</a> | <a href='#tempTopic'>tempTopic</a> | <a href='#topic'>topic</a>)*</td><td></td></tr>
+  <tr><td>properties</td><td>&lt;spring:bean/&gt;</td><td>Get the properties from this instance for storing in JNDI</td></tr>
+</table>
+<h2>Element: <a name='traceBrokerPathPlugin'>traceBrokerPathPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>stampProperty</td><td>xs:string</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>adminConnectionContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>next</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='transact-database-locker'>transact-database-locker</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>failIfLocked</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>lockAcquireSleepInterval</td><td>xs:long</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>queryTimeout</td><td>xs:integer</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>exceptionHandler</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='transact-jdbc-adapter'>transact-jdbc-adapter</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>batchStatments</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maxRows</td><td>xs:integer</td><td></td></tr>
+  <tr><td>useExternalMessageReferences</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>statements</td><td><a href='#statements'>statements</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='transportConnector'>transportConnector</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>auditNetworkProducers</td><td>xs:boolean</td><td>Enable a producer audit on network connections, Traps the case of a missing send reply and resend.
+Note: does not work with conduit=false, networked composite destinations or networked virtual topics</td></tr>
+  <tr><td>disableAsyncDispatch</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>discoveryUri</td><td>xs:string</td><td></td></tr>
+  <tr><td>enableStatusMonitor</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>maximumConsumersAllowedPerConnection</td><td>xs:integer</td><td></td></tr>
+  <tr><td>maximumProducersAllowedPerConnection</td><td>xs:integer</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>rebalanceClusterClients</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>updateClusterClients</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>updateClusterClientsOnRemove</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>updateClusterFilter</td><td>xs:string</td><td></td></tr>
+  <tr><td>uri</td><td>xs:string</td><td>Sets the server transport URI to use if there is not a
+{@link TransportServer} configured via the
+{@link #setServer(TransportServer)} method. This value is used to lazy
+create a {@link TransportServer} instance</td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>brokerInfo</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>brokerService</td><td><a href='#broker'>broker</a> | <a href='#brokerService'>brokerService</a></td><td>This is called by the BrokerService right before it starts the transport.</td></tr>
+  <tr><td>discoveryAgent</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>messageAuthorizationPolicy</td><td>&lt;spring:bean/&gt;</td><td>Sets the policy used to decide if the current connection is authorized to
+consume a given message</td></tr>
+  <tr><td>server</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>taskRunnerFactory</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+</table>
+<h2>Element: <a name='udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>broadcast</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>destination</td><td>xs:string</td><td></td></tr>
+  <tr><td>maxTraceDatagramSize</td><td>xs:integer</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>address</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>adminConnectionContext</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>next</td><td><a href='#destinationPathSeparatorPlugin'>destinationPathSeparatorPlugin</a> | <a href='#forcePersistencyModeBroker'>forcePersistencyModeBroker</a> | <a href='#loggingBrokerPlugin'>loggingBrokerPlugin</a> | <a href='#multicastTraceBrokerPlugin'>multicastTraceBrokerPlugin</a> | <a href='#redeliveryPlugin'>redeliveryPlugin</a> | <a href='#timeStampingBrokerPlugin'>timeStampingBrokerPlugin</a> | <a href='#traceBrokerPathPlugin'>traceBrokerPathPlugin</a> | <a href='#udpTraceBrokerPlugin'>udpTraceBrokerPlugin</a></td><td></td></tr>
+  <tr><td>wireFormat</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>wireFormatFactory</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+</table>
+<h2>Element: <a name='uniquePropertyMessageEvictionStrategy'>uniquePropertyMessageEvictionStrategy</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>evictExpiredMessagesHighWatermark</td><td>xs:integer</td><td>Sets the high water mark on which we will eagerly evict expired messages from RAM</td></tr>
+  <tr><td>propertyName</td><td>xs:string</td><td></td></tr>
+</table>
+<h2>Element: <a name='usageCapacity'>usageCapacity</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>limit</td><td>xs:long</td><td></td></tr>
+</table>
+<h2>Element: <a name='virtualDestinationInterceptor'>virtualDestinationInterceptor</a></h2>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>virtualDestinations</td><td>(<a href='#compositeQueue'>compositeQueue</a> | <a href='#compositeTopic'>compositeTopic</a> | <a href='#virtualTopic'>virtualTopic</a>)*</td><td></td></tr>
+</table>
+<h2>Element: <a name='virtualSelectorCacheBrokerPlugin'>virtualSelectorCacheBrokerPlugin</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>persistFile</td><td>xs:string</td><td>Sets the location of the persistent cache</td></tr>
+</table>
+<h2>Element: <a name='virtualTopic'>virtualTopic</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>local</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>name</td><td>xs:string</td><td></td></tr>
+  <tr><td>postfix</td><td>xs:string</td><td>Sets any postix used to identify the queue consumers</td></tr>
+  <tr><td>prefix</td><td>xs:string</td><td>Sets the prefix wildcard used to identify the queue consumers for a given
+topic</td></tr>
+  <tr><td>selectorAware</td><td>xs:boolean</td><td>Indicates whether the selectors of consumers are used to determine dispatch
+to a virtual destination, when true only messages matching an existing 
+consumer will be dispatched.</td></tr>
+</table>
+<h2>Element: <a name='vmCursor'>vmCursor</a></h2>
+<h2>Element: <a name='vmDurableCursor'>vmDurableCursor</a></h2>
+<h2>Element: <a name='vmQueueCursor'>vmQueueCursor</a></h2>
+<h2>Element: <a name='xaConnectionFactory'>xaConnectionFactory</a></h2>
+<table>
+  <tr><th>Attribute</th><th>Type</th><th>Description</th>
+  <tr><td>alwaysSessionAsync</td><td>xs:boolean</td><td>If this flag is not set then a separate thread is not used for dispatching messages for each Session in
+the Connection. However, a separate thread is always used if there is more than one session, or the session
+isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
+happens asynchronously.</td></tr>
+  <tr><td>alwaysSyncSend</td><td>xs:boolean</td><td>Set true if always require messages to be sync sent</td></tr>
+  <tr><td>auditDepth</td><td>xs:integer</td><td></td></tr>
+  <tr><td>auditMaximumProducerNumber</td><td>xs:integer</td><td></td></tr>
+  <tr><td>beanName</td><td>xs:string</td><td></td></tr>
+  <tr><td>brokerURL</td><td>xs:string</td><td>Sets the <a
+href="http://activemq.apache.org/configuring-transports.html">connection
+URL</a> used to connect to the ActiveMQ broker.</td></tr>
+  <tr><td>checkForDuplicates</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>clientID</td><td>xs:string</td><td>Sets the JMS clientID to use for the created connection. Note that this
+can only be used by one connection at once so generally its a better idea
+to set the clientID on a Connection</td></tr>
+  <tr><td>clientIDPrefix</td><td>xs:string</td><td>Sets the prefix used by autogenerated JMS Client ID values which are used
+if the JMS client does not explicitly specify on.</td></tr>
+  <tr><td>closeTimeout</td><td>xs:integer</td><td>Sets the timeout before a close is considered complete. Normally a
+close() on a connection waits for confirmation from the broker; this
+allows that operation to timeout to save the client hanging if there is
+no broker</td></tr>
+  <tr><td>connectionIDPrefix</td><td>xs:string</td><td>Sets the prefix used by connection id generator</td></tr>
+  <tr><td>consumerFailoverRedeliveryWaitPeriod</td><td>xs:long</td><td></td></tr>
+  <tr><td>copyMessageOnSend</td><td>xs:boolean</td><td>Should a JMS message be copied to a new JMS Message object as part of the
+send() method in JMS. This is enabled by default to be compliant with the
+JMS specification. You can disable it if you do not mutate JMS messages
+after they are sent for a performance boost</td></tr>
+  <tr><td>disableTimeStampsByDefault</td><td>xs:boolean</td><td>Sets whether or not timestamps on messages should be disabled or not. If
+you disable them it adds a small performance boost.</td></tr>
+  <tr><td>dispatchAsync</td><td>xs:boolean</td><td>Enables or disables the default setting of whether or not consumers have
+their messages <a
+href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
+synchronously or asynchronously by the broker</a>. For non-durable
+topics for example we typically dispatch synchronously by default to
+minimize context switches which boost performance. However sometimes its
+better to go slower to ensure that a single blocked consumer socket does
+not block delivery to other consumers.</td></tr>
+  <tr><td>exclusiveConsumer</td><td>xs:boolean</td><td>Enables or disables whether or not queue consumers should be exclusive or
+not for example to preserve ordering when not using <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a></td></tr>
+  <tr><td>maxThreadPoolSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>messagePrioritySupported</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>nestedMapAndListEnabled</td><td>xs:boolean</td><td>Enables/disables whether or not Message properties and MapMessage entries
+support <a
+href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
+Structures</a> of Map and List objects</td></tr>
+  <tr><td>nonBlockingRedelivery</td><td>xs:boolean</td><td>When true a MessageConsumer will not stop Message delivery before re-delivering Messages
+from a rolled back transaction.  This implies that message order will not be preserved and
+also will result in the TransactedIndividualAck option to be enabled.</td></tr>
+  <tr><td>objectMessageSerializationDefered</td><td>xs:boolean</td><td>When an object is set on an ObjectMessage, the JMS spec requires the
+object to be serialized by that set method. Enabling this flag causes the
+object to not get serialized. The object may subsequently get serialized
+if the message needs to be sent over a socket or stored to disk.</td></tr>
+  <tr><td>optimizeAcknowledge</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>optimizeAcknowledgeTimeOut</td><td>xs:long</td><td>The max time in milliseconds between optimized ack batches</td></tr>
+  <tr><td>optimizedAckScheduledAckInterval</td><td>xs:long</td><td>Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
+to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
+will not do any background Message acknowledgment.</td></tr>
+  <tr><td>optimizedMessageDispatch</td><td>xs:boolean</td><td>If this flag is set then an larger prefetch limit is used - only
+applicable for durable topic subscribers.</td></tr>
+  <tr><td>password</td><td>xs:string</td><td>Sets the JMS password used for connections created from this factory</td></tr>
+  <tr><td>producerWindowSize</td><td>xs:integer</td><td></td></tr>
+  <tr><td>sendAcksAsync</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>sendTimeout</td><td>xs:integer</td><td></td></tr>
+  <tr><td>statsEnabled</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>transactedIndividualAck</td><td>xs:boolean</td><td>when true, submit individual transacted acks immediately rather than with transaction completion.
+This allows the acks to represent delivery status which can be persisted on rollback
+Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true</td></tr>
+  <tr><td>useAsyncSend</td><td>xs:boolean</td><td>Forces the use of <a
+href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
+adds a massive performance boost; but means that the send() method will
+return immediately whether the message has been sent or not which could
+lead to message loss.</td></tr>
+  <tr><td>useBeanNameAsClientIdPrefix</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useCompression</td><td>xs:boolean</td><td>Enables the use of compression of the message bodies</td></tr>
+  <tr><td>useDedicatedTaskRunner</td><td>xs:boolean</td><td></td></tr>
+  <tr><td>useRetroactiveConsumer</td><td>xs:boolean</td><td>Sets whether or not retroactive consumers are enabled. Retroactive
+consumers allow non-durable topic subscribers to receive old messages
+that were published before the non-durable subscriber started.</td></tr>
+  <tr><td>userName</td><td>xs:string</td><td>Sets the JMS userName used by connections created by this factory</td></tr>
+  <tr><td>warnAboutUnstartedConnectionTimeout</td><td>xs:long</td><td>Enables the timeout from a connection creation to when a warning is
+generated if the connection is not properly started via
+{@link Connection#start()} and a message is received by a consumer. It is
+a very common gotcha to forget to <a
+href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
+the connection</a> so this option makes the default case to create a
+warning if the user forgets. To disable the warning just set the value to <
+0 (say -1).</td></tr>
+  <tr><td>watchTopicAdvisories</td><td>xs:boolean</td><td></td></tr>
+</table>
+<table>
+  <tr><th>Element</th><th>Type</th><th>Description</th>
+  <tr><td>blobTransferPolicy</td><td>&lt;spring:bean/&gt;</td><td>Sets the policy used to describe how out-of-band BLOBs (Binary Large
+OBjects) are transferred from producers to brokers to consumers</td></tr>
+  <tr><td>clientIdGenerator</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>clientInternalExceptionListener</td><td>&lt;spring:bean/&gt;</td><td>Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)</td></tr>
+  <tr><td>connectionIdGenerator</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>exceptionListener</td><td><a href='#commandAgent'>commandAgent</a></td><td>Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory)</td></tr>
+  <tr><td>prefetchPolicy</td><td><a href='#prefetchPolicy'>prefetchPolicy</a></td><td>Sets the <a
+href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
+policy</a> for consumers created by this connection.</td></tr>
+  <tr><td>properties</td><td>&lt;spring:bean/&gt;</td><td>Get the properties from this instance for storing in JNDI</td></tr>
+  <tr><td>redeliveryPolicy</td><td><a href='#redeliveryPolicy'>redeliveryPolicy</a></td><td>Sets the global default redelivery policy to be used when a message is delivered
+but the session is rolled back</td></tr>
+  <tr><td>redeliveryPolicyMap</td><td><a href='#redeliveryPolicyMap'>redeliveryPolicyMap</a></td><td>Sets the global redelivery policy mapping to be used when a message is delivered
+but the session is rolled back</td></tr>
+  <tr><td>rejectedTaskHandler</td><td>&lt;spring:bean/&gt;</td><td></td></tr>
+  <tr><td>sessionTaskRunner</td><td><a href='#taskRunnerFactory'>taskRunnerFactory</a></td><td></td></tr>
+  <tr><td>transformer</td><td>&lt;spring:bean/&gt;</td><td>Sets the transformer used to transform messages before they are sent on
+to the JMS bus or when they are received from the bus but before they are
+delivered to the JMS client</td></tr>
+  <tr><td>transportListener</td><td>&lt;spring:bean/&gt;</td><td>Allows a listener to be configured on the ConnectionFactory so that when this factory is used
+with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
+a transport listener.</td></tr>
+</table>
+
+</body>
+</html>
diff --git a/activemq-core/src/main/resources/activemq.xsd.wiki b/activemq-core/src/main/resources/activemq.xsd.wiki
new file mode 100644
index 000000000..1bcf3b211
--- /dev/null
+++ b/activemq-core/src/main/resources/activemq.xsd.wiki
@@ -0,0 +1,3789 @@
+h3. Elements By Type
+{anchor:org.apache.activemq.util.IOExceptionHandler-types}
+h4. The _[org.apache.activemq.util.IOExceptionHandler|#org.apache.activemq.util.IOExceptionHandler-types]_ Type Implementations
+    | _[<defaultIOExceptionHandler>|#defaultIOExceptionHandler-element]_ | {html}{html} |
+    | _[<jDBCIOExceptionHandler>|#jDBCIOExceptionHandler-element]_ | {html}{html} |
+
+{anchor:org.apache.activemq.security.AuthorizationMap-types}
+h4. The _[org.apache.activemq.security.AuthorizationMap|#org.apache.activemq.security.AuthorizationMap-types]_ Type Implementations
+    | _[<authorizationMap>|#authorizationMap-element]_ | {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies. Each entry in the map represents the authorization ACLs
+for each operation.{html} |
+    | _[<cachedLDAPAuthorizationMap>|#cachedLDAPAuthorizationMap-element]_ | {html}A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update authorization
+policy.{html} |
+    | _[<lDAPAuthorizationMap>|#lDAPAuthorizationMap-element]_ | {html}An {@link AuthorizationMap} which uses LDAP{html} |
+    | _[<simpleAuthorizationMap>|#simpleAuthorizationMap-element]_ | {html}An AuthorizationMap which is configured with individual DestinationMaps for
+each operation.{html} |
+
+{anchor:org.apache.activemq.usage.SystemUsage-types}
+h4. The _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ Type Implementations
+    | _[<systemUsage>|#systemUsage-element]_ | {html}Holder for Usage instances for memory, store and temp files Main use case is
+manage memory usage.{html} |
+
+{anchor:org.apache.activemq.store.jdbc.JDBCAdapter-types}
+h4. The _[org.apache.activemq.store.jdbc.JDBCAdapter|#org.apache.activemq.store.jdbc.JDBCAdapter-types]_ Type Implementations
+    | _[<axionJDBCAdapter>|#axionJDBCAdapter-element]_ | {html}Axion specific Adapter.
+
+Axion does not seem to support ALTER statements or sub-selects.  This means:
+- We cannot auto upgrade the schema was we roll out new versions of ActiveMQ
+- We cannot delete durable sub messages that have be acknowledged by all consumers.{html} |
+    | _[<blobJDBCAdapter>|#blobJDBCAdapter-element]_ | {html}This JDBCAdapter inserts and extracts BLOB data using the getBlob()/setBlob()
+operations. This is a little more involved since to insert a blob you have
+to:
+
+1: insert empty blob. 2: select the blob 3: finally update the blob with data
+value.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html} |
+    | _[<bytesJDBCAdapter>|#bytesJDBCAdapter-element]_ | {html}This JDBCAdapter inserts and extracts BLOB data using the
+setBytes()/getBytes() operations. The databases/JDBC drivers that use this
+adapter are:{html} |
+    | _[<db2JDBCAdapter>|#db2JDBCAdapter-element]_ | {html}{html} |
+    | _[<defaultJDBCAdapter>|#defaultJDBCAdapter-element]_ | {html}Implements all the default JDBC operations that are used by the JDBCPersistenceAdapter. <p/> sub-classing is
+encouraged to override the default implementation of methods to account for differences in JDBC Driver
+implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using the getBytes()/setBytes() operations. <p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html} |
+    | _[<hsqldb-jdbc-adapter>|#hsqldb-jdbc-adapter-element]_ | {html}{html} |
+    | _[<imageBasedJDBCAdaptor>|#imageBasedJDBCAdaptor-element]_ | {html}Provides JDBCAdapter since that uses
+IMAGE datatype to hold binary data.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Sybase</li>
+<li>MS SQL</li>
+</ul>{html} |
+    | _[<informixJDBCAdapter>|#informixJDBCAdapter-element]_ | {html}JDBC Adapter for Informix database.
+Because Informix database restricts length of composite primary keys, length of 
+<i>container name</i> field and <i>subscription id</i> field must be reduced to 150 characters.
+Therefore be sure not to use longer names for container name and subscription id than 150 characters.{html} |
+    | _[<maxdb-jdbc-adapter>|#maxdb-jdbc-adapter-element]_ | {html}JDBC Adapter for the MaxDB database.{html} |
+    | _[<mysql-jdbc-adapter>|#mysql-jdbc-adapter-element]_ | {html}{html} |
+    | _[<oracleBlobJDBCAdapter>|#oracleBlobJDBCAdapter-element]_ | {html}Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html} |
+    | _[<oracleJDBCAdapter>|#oracleJDBCAdapter-element]_ | {html}Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>{html} |
+    | _[<postgresql-jdbc-adapter>|#postgresql-jdbc-adapter-element]_ | {html}Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html} |
+    | _[<streamJDBCAdapter>|#streamJDBCAdapter-element]_ | {html}This JDBCAdapter inserts and extracts BLOB data using the
+setBinaryStream()/getBinaryStream() operations.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Axion</li>
+</ul>{html} |
+    | _[<sybase-jdbc-adapter>|#sybase-jdbc-adapter-element]_ | {html}A JDBC Adapter for Sybase databases{html} |
+    | _[<transact-jdbc-adapter>|#transact-jdbc-adapter-element]_ | {html}A JDBC Adapter for Transact-SQL based databases such as SQL Server or Sybase{html} |
+
+{anchor:javax.jms.Queue-types}
+h4. The _[javax.jms.Queue|#javax.jms.Queue-types]_ Type Implementations
+    | _[<queue>|#queue-element]_ | {html}An ActiveMQ Queue{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.SlowConsumerStrategy-types}
+h4. The _[org.apache.activemq.broker.region.policy.SlowConsumerStrategy|#org.apache.activemq.broker.region.policy.SlowConsumerStrategy-types]_ Type Implementations
+    | _[<abortSlowConsumerStrategy>|#abortSlowConsumerStrategy-element]_ | {html}Abort slow consumers when they reach the configured threshold of slowness, default is slow for 30 seconds{html} |
+
+{anchor:org.apache.activemq.network.NetworkConnector-types}
+h4. The _[org.apache.activemq.network.NetworkConnector|#org.apache.activemq.network.NetworkConnector-types]_ Type Implementations
+    | _[<ldapNetworkConnector>|#ldapNetworkConnector-element]_ | {html}class to create dynamic network connectors listed in an directory
+server using the LDAP v3 protocol as defined in RFC 2251, the
+entries listed in the directory server must implement the ipHost
+and ipService objectClasses as defined in RFC 2307.{html} |
+    | _[<multicastNetworkConnector>|#multicastNetworkConnector-element]_ | {html}A network connector which uses some kind of multicast-like transport that
+communicates with potentially many remote brokers over a single logical
+{@link Transport} instance such as when using multicast.
+
+This implementation does not depend on multicast at all; any other group
+based transport could be used.{html} |
+    | _[<networkConnector>|#networkConnector-element]_ | {html}A network connector which uses a discovery agent to detect the remote brokers
+available and setup a connection to each available remote broker{html} |
+
+{anchor:org.apache.activemq.broker.region.virtual.VirtualDestination-types}
+h4. The _[org.apache.activemq.broker.region.virtual.VirtualDestination|#org.apache.activemq.broker.region.virtual.VirtualDestination-types]_ Type Implementations
+    | _[<compositeQueue>|#compositeQueue-element]_ | {html}Represents a virtual queue which forwards to a number of other destinations.{html} |
+    | _[<compositeTopic>|#compositeTopic-element]_ | {html}Represents a virtual topic which forwards to a number of other destinations.{html} |
+    | _[<virtualTopic>|#virtualTopic-element]_ | {html}Creates <a href="http://activemq.org/site/virtual-destinations.html">Virtual
+Topics</a> using a prefix and postfix. The virtual destination creates a
+wildcard that is then used to look up all active queue subscriptions which
+match.{html} |
+
+{anchor:javax.jms.Destination-types}
+h4. The _[javax.jms.Destination|#javax.jms.Destination-types]_ Type Implementations
+    | _[<queue>|#queue-element]_ | {html}An ActiveMQ Queue{html} |
+    | _[<tempQueue>|#tempQueue-element]_ | {html}An ActiveMQ Temporary Queue Destination{html} |
+    | _[<tempTopic>|#tempTopic-element]_ | {html}An ActiveMQ Temporary Topic Destination{html} |
+    | _[<topic>|#topic-element]_ | {html}An ActiveMQ Topic{html} |
+
+{anchor:org.apache.activemq.store.jdbc.JDBCPersistenceAdapter-types}
+h4. The _[org.apache.activemq.store.jdbc.JDBCPersistenceAdapter|#org.apache.activemq.store.jdbc.JDBCPersistenceAdapter-types]_ Type Implementations
+    | _[<jdbcPersistenceAdapter>|#jdbcPersistenceAdapter-element]_ | {html}A {@link PersistenceAdapter} implementation using JDBC for persistence
+storage.
+
+This persistence adapter will correctly remember prepared XA transactions,
+but it will not keep track of local transaction commits so that operations
+performed against the Message store are done as a single uow.{html} |
+
+{anchor:org.apache.activemq.store.PersistenceAdapterFactory-types}
+h4. The _[org.apache.activemq.store.PersistenceAdapterFactory|#org.apache.activemq.store.PersistenceAdapterFactory-types]_ Type Implementations
+    | _[<amqPersistenceAdapterFactory>|#amqPersistenceAdapterFactory-element]_ | {html}An implementation of {@link PersistenceAdapterFactory}{html} |
+    | _[<journalPersistenceAdapterFactory>|#journalPersistenceAdapterFactory-element]_ | {html}Factory class that can create PersistenceAdapter objects.{html} |
+    | _[<journaledJDBC>|#journaledJDBC-element]_ | {html}Creates a default persistence model using the Journal and JDBC{html} |
+
+{anchor:org.apache.activemq.usage.MemoryUsage-types}
+h4. The _[org.apache.activemq.usage.MemoryUsage|#org.apache.activemq.usage.MemoryUsage-types]_ Type Implementations
+    | _[<memoryUsage>|#memoryUsage-element]_ | {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.DispatchPolicy-types}
+h4. The _[org.apache.activemq.broker.region.policy.DispatchPolicy|#org.apache.activemq.broker.region.policy.DispatchPolicy-types]_ Type Implementations
+    | _[<priorityNetworkDispatchPolicy>|#priorityNetworkDispatchPolicy-element]_ | {html}dispatch policy that ignores lower priority duplicate network consumers,
+used in conjunction with network bridge suppresDuplicateTopicSubscriptions{html} |
+    | _[<roundRobinDispatchPolicy>|#roundRobinDispatchPolicy-element]_ | {html}Simple dispatch policy that sends a message to every subscription that
+matches the message.{html} |
+    | _[<simpleDispatchPolicy>|#simpleDispatchPolicy-element]_ | {html}Simple dispatch policy that sends a message to every subscription that
+matches the message.{html} |
+    | _[<strictOrderDispatchPolicy>|#strictOrderDispatchPolicy-element]_ | {html}Dispatch policy that causes every subscription to see messages in the same
+order.{html} |
+
+{anchor:org.apache.activemq.usage.TempUsage-types}
+h4. The _[org.apache.activemq.usage.TempUsage|#org.apache.activemq.usage.TempUsage-types]_ Type Implementations
+    | _[<tempUsage>|#tempUsage-element]_ | {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html} |
+
+{anchor:org.apache.activemq.usage.StoreUsage-types}
+h4. The _[org.apache.activemq.usage.StoreUsage|#org.apache.activemq.usage.StoreUsage-types]_ Type Implementations
+    | _[<storeUsage>|#storeUsage-element]_ | {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html} |
+
+{anchor:org.apache.activemq.network.jms.ReconnectionPolicy-types}
+h4. The _[org.apache.activemq.network.jms.ReconnectionPolicy|#org.apache.activemq.network.jms.ReconnectionPolicy-types]_ Type Implementations
+    | _[<reconnectionPolicy>|#reconnectionPolicy-element]_ | {html}A policy object that defines how a {@link JmsConnector} deals with
+reconnection of the local and foreign connections.{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.SubscriptionRecoveryPolicy-types}
+h4. The _[org.apache.activemq.broker.region.policy.SubscriptionRecoveryPolicy|#org.apache.activemq.broker.region.policy.SubscriptionRecoveryPolicy-types]_ Type Implementations
+    | _[<fixedCountSubscriptionRecoveryPolicy>|#fixedCountSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+count of last messages.{html} |
+    | _[<fixedSizedSubscriptionRecoveryPolicy>|#fixedSizedSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+amount of memory available in RAM for message history which is evicted in
+time order.{html} |
+    | _[<lastImageSubscriptionRecoveryPolicy>|#lastImageSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will only keep the
+last message.{html} |
+    | _[<noSubscriptionRecoveryPolicy>|#noSubscriptionRecoveryPolicy-element]_ | {html}This SubscriptionRecoveryPolicy disable recovery of messages.{html} |
+    | _[<queryBasedSubscriptionRecoveryPolicy>|#queryBasedSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will perform a user
+specific query mechanism to load any messages they may have missed.{html} |
+    | _[<timedSubscriptionRecoveryPolicy>|#timedSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will keep a timed
+buffer of messages around in memory and use that to recover new
+subscriptions.{html} |
+
+{anchor:org.apache.activemq.thread.TaskRunnerFactory-types}
+h4. The _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ Type Implementations
+    | _[<taskRunnerFactory>|#taskRunnerFactory-element]_ | {html}Manages the thread pool for long running tasks. Long running tasks are not
+always active but when they are active, they may need a few iterations of
+processing for them to become idle. The manager ensures that each task is
+processes but that no one task overtakes the system. This is kinda like
+cooperative multitasking.{html} |
+
+{anchor:org.apache.activemq.broker.region.group.MessageGroupMapFactory-types}
+h4. The _[org.apache.activemq.broker.region.group.MessageGroupMapFactory|#org.apache.activemq.broker.region.group.MessageGroupMapFactory-types]_ Type Implementations
+    | _[<messageGroupHashBucketFactory>|#messageGroupHashBucketFactory-element]_ | {html}A factory to create instances of {@link SimpleMessageGroupMap} when
+implementing the <a
+href="http://activemq.apache.org/message-groups.html">Message
+Groups</a> functionality.{html} |
+    | _[<simpleMessageGroupMapFactory>|#simpleMessageGroupMapFactory-element]_ | {html}A factory to create instances of {@link SimpleMessageGroupMap} when implementing the 
+<a href="http://activemq.apache.org/message-groups.html">Message Groups</a> functionality.{html} |
+
+{anchor:org.apache.activemq.store.kahadb.plist.PListStore-types}
+h4. The _[org.apache.activemq.store.kahadb.plist.PListStore|#org.apache.activemq.store.kahadb.plist.PListStore-types]_ Type Implementations
+    | _[<pListStore>|#pListStore-element]_ | {html}{html} |
+
+{anchor:org.apache.activemq.broker.SslContext-types}
+h4. The _[org.apache.activemq.broker.SslContext|#org.apache.activemq.broker.SslContext-types]_ Type Implementations
+    | _[<sslContext>|#sslContext-element]_ | {html}Extends the SslContext so that it's easier to configure from spring.{html} |
+
+{anchor:javax.jms.ExceptionListener-types}
+h4. The _[javax.jms.ExceptionListener|#javax.jms.ExceptionListener-types]_ Type Implementations
+    | _[<commandAgent>|#commandAgent-element]_ | {html}An agent which listens to commands on a JMS destination{html} |
+
+{anchor:org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter-types}
+h4. The _[org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter|#org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter-types]_ Type Implementations
+    | _[<kahaDB>|#kahaDB-element]_ | {html}An implementation of {@link PersistenceAdapter} designed for use with
+KahaDB - Embedded Lightweight Non-Relational Database{html} |
+
+{anchor:org.apache.activemq.broker.region.DestinationInterceptor-types}
+h4. The _[org.apache.activemq.broker.region.DestinationInterceptor|#org.apache.activemq.broker.region.DestinationInterceptor-types]_ Type Implementations
+    | _[<mirroredQueue>|#mirroredQueue-element]_ | {html}Creates <a href="http://activemq.org/site/mirrored-queues.html">Mirrored
+Queue</a> using a prefix and postfix to define the topic name on which to mirror the queue to.{html} |
+    | _[<virtualDestinationInterceptor>|#virtualDestinationInterceptor-element]_ | {html}Implements <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual Topics</a>.{html} |
+
+{anchor:org.apache.activemq.network.jms.InboundQueueBridge-types}
+h4. The _[org.apache.activemq.network.jms.InboundQueueBridge|#org.apache.activemq.network.jms.InboundQueueBridge-types]_ Type Implementations
+    | _[<inboundQueueBridge>|#inboundQueueBridge-element]_ | {html}Create an Inbound Queue Bridge.  By default this class uses the sname name for
+both the inbound and outbound queue.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud queue names
+separately.{html} |
+
+{anchor:org.apache.activemq.broker.BrokerService-types}
+h4. The _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ Type Implementations
+    | _[<broker>|#broker-element]_ | {html}An ActiveMQ Message Broker. It consists of a number of transport
+connectors, network connectors and a bunch of properties which can be used to
+configure the broker as its lazily created.{html} |
+    | _[<brokerService>|#brokerService-element]_ | {html}Manages the lifecycle of an ActiveMQ Broker. A BrokerService consists of a
+number of transport connectors, network connectors and a bunch of properties
+which can be used to configure the broker as its lazily created.{html} |
+
+{anchor:org.apache.activemq.network.DemandForwardingBridgeSupport-types}
+h4. The _[org.apache.activemq.network.DemandForwardingBridgeSupport|#org.apache.activemq.network.DemandForwardingBridgeSupport-types]_ Type Implementations
+    | _[<compositeDemandForwardingBridge>|#compositeDemandForwardingBridge-element]_ | {html}A demand forwarding bridge which works with multicast style transports where
+a single Transport could be communicating with multiple remote brokers{html} |
+    | _[<demandForwardingBridge>|#demandForwardingBridge-element]_ | {html}Forwards messages from the local broker to the remote broker based on demand.{html} |
+
+{anchor:javax.jms.QueueConnectionFactory-types}
+h4. The _[javax.jms.QueueConnectionFactory|#javax.jms.QueueConnectionFactory-types]_ Type Implementations
+    | _[<connectionFactory>|#connectionFactory-element]_ | {html}A <a href="http://www.springframework.org/">Spring</a> enhanced connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html} |
+    | _[<xaConnectionFactory>|#xaConnectionFactory-element]_ | {html}A <a href="http://www.springframework.org/">Spring</a> enhanced XA connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html} |
+
+{anchor:org.apache.activemq.ActiveMQPrefetchPolicy-types}
+h4. The _[org.apache.activemq.ActiveMQPrefetchPolicy|#org.apache.activemq.ActiveMQPrefetchPolicy-types]_ Type Implementations
+    | _[<prefetchPolicy>|#prefetchPolicy-element]_ | {html}Defines the prefetch message policies for different types of consumers{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.PolicyMap-types}
+h4. The _[org.apache.activemq.broker.region.policy.PolicyMap|#org.apache.activemq.broker.region.policy.PolicyMap-types]_ Type Implementations
+    | _[<policyMap>|#policyMap-element]_ | {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.{html} |
+
+{anchor:org.apache.activemq.network.jms.OutboundTopicBridge-types}
+h4. The _[org.apache.activemq.network.jms.OutboundTopicBridge|#org.apache.activemq.network.jms.OutboundTopicBridge-types]_ Type Implementations
+    | _[<outboundTopicBridge>|#outboundTopicBridge-element]_ | {html}Create an Outbound Topic Bridge.  By default the bridge uses the same
+name for both the inbound and outbound topics, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+topic names.{html} |
+
+{anchor:org.apache.activemq.RedeliveryPolicy-types}
+h4. The _[org.apache.activemq.RedeliveryPolicy|#org.apache.activemq.RedeliveryPolicy-types]_ Type Implementations
+    | _[<redeliveryPolicy>|#redeliveryPolicy-element]_ | {html}Configuration options for a messageConsumer used to control how messages are re-delivered when they
+are rolled back.
+May be used server side on a per destination basis via the Broker RedeliveryPlugin{html} |
+
+{anchor:org.apache.activemq.Service-types}
+h4. The _[org.apache.activemq.Service|#org.apache.activemq.Service-types]_ Type Implementations
+    | _[<broker>|#broker-element]_ | {html}An ActiveMQ Message Broker. It consists of a number of transport
+connectors, network connectors and a bunch of properties which can be used to
+configure the broker as its lazily created.{html} |
+    | _[<brokerService>|#brokerService-element]_ | {html}Manages the lifecycle of an ActiveMQ Broker. A BrokerService consists of a
+number of transport connectors, network connectors and a bunch of properties
+which can be used to configure the broker as its lazily created.{html} |
+    | _[<commandAgent>|#commandAgent-element]_ | {html}An agent which listens to commands on a JMS destination{html} |
+    | _[<database-locker>|#database-locker-element]_ | {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<forwardingBridge>|#forwardingBridge-element]_ | {html}Forwards all messages from the local broker to the remote broker.{html} |
+    | _[<inboundQueueBridge>|#inboundQueueBridge-element]_ | {html}Create an Inbound Queue Bridge.  By default this class uses the sname name for
+both the inbound and outbound queue.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud queue names
+separately.{html} |
+    | _[<inboundTopicBridge>|#inboundTopicBridge-element]_ | {html}Create an Inbound Topic Bridge.  By default this class uses the topic name for
+both the inbound and outbound topic.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud topic names
+separately.{html} |
+    | _[<jdbcPersistenceAdapter>|#jdbcPersistenceAdapter-element]_ | {html}A {@link PersistenceAdapter} implementation using JDBC for persistence
+storage.
+
+This persistence adapter will correctly remember prepared XA transactions,
+but it will not keep track of local transaction commits so that operations
+performed against the Message store are done as a single uow.{html} |
+    | _[<jmsQueueConnector>|#jmsQueueConnector-element]_ | {html}A Bridge to other JMS Queue providers{html} |
+    | _[<jmsTopicConnector>|#jmsTopicConnector-element]_ | {html}A Bridge to other JMS Topic providers{html} |
+    | _[<journalPersistenceAdapterFactory>|#journalPersistenceAdapterFactory-element]_ | {html}Factory class that can create PersistenceAdapter objects.{html} |
+    | _[<journaledJDBC>|#journaledJDBC-element]_ | {html}Creates a default persistence model using the Journal and JDBC{html} |
+    | _[<kahaDB>|#kahaDB-element]_ | {html}An implementation of {@link PersistenceAdapter} designed for use with
+KahaDB - Embedded Lightweight Non-Relational Database{html} |
+    | _[<ldapNetworkConnector>|#ldapNetworkConnector-element]_ | {html}class to create dynamic network connectors listed in an directory
+server using the LDAP v3 protocol as defined in RFC 2251, the
+entries listed in the directory server must implement the ipHost
+and ipService objectClasses as defined in RFC 2307.{html} |
+    | _[<lease-database-locker>|#lease-database-locker-element]_ | {html}Represents an exclusive lease on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<levelDB>|#levelDB-element]_ | {html}An implementation of {@link org.apache.activemq.store.PersistenceAdapter} designed for use with
+LevelDB - Embedded Lightweight Non-Relational Database{html} |
+    | _[<managementContext>|#managementContext-element]_ | {html}An abstraction over JMX mbean registration{html} |
+    | _[<masterConnector>|#masterConnector-element]_ | {html}Connects a Slave Broker to a Master when using <a
+href="http://activemq.apache.org/masterslave.html">Master Slave</a> for High
+Availability of messages.{html} |
+    | _[<memoryUsage>|#memoryUsage-element]_ | {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html} |
+    | _[<multicastNetworkConnector>|#multicastNetworkConnector-element]_ | {html}A network connector which uses some kind of multicast-like transport that
+communicates with potentially many remote brokers over a single logical
+{@link Transport} instance such as when using multicast.
+
+This implementation does not depend on multicast at all; any other group
+based transport could be used.{html} |
+    | _[<networkConnector>|#networkConnector-element]_ | {html}A network connector which uses a discovery agent to detect the remote brokers
+available and setup a connection to each available remote broker{html} |
+    | _[<outboundQueueBridge>|#outboundQueueBridge-element]_ | {html}Create an Outbound Queue Bridge.  By default the bridge uses the same
+name for both the inbound and outbound queues, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+queue names.{html} |
+    | _[<outboundTopicBridge>|#outboundTopicBridge-element]_ | {html}Create an Outbound Topic Bridge.  By default the bridge uses the same
+name for both the inbound and outbound topics, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+topic names.{html} |
+    | _[<pListStore>|#pListStore-element]_ | {html}{html} |
+    | _[<proxyConnector>|#proxyConnector-element]_ | {html}{html} |
+    | _[<shared-file-locker>|#shared-file-locker-element]_ | {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<storeUsage>|#storeUsage-element]_ | {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html} |
+    | _[<systemUsage>|#systemUsage-element]_ | {html}Holder for Usage instances for memory, store and temp files Main use case is
+manage memory usage.{html} |
+    | _[<tempUsage>|#tempUsage-element]_ | {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html} |
+    | _[<transact-database-locker>|#transact-database-locker-element]_ | {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.DeadLetterStrategy-types}
+h4. The _[org.apache.activemq.broker.region.policy.DeadLetterStrategy|#org.apache.activemq.broker.region.policy.DeadLetterStrategy-types]_ Type Implementations
+    | _[<individualDeadLetterStrategy>|#individualDeadLetterStrategy-element]_ | {html}A {@link DeadLetterStrategy} where each destination has its own individual
+DLQ using the subject naming hierarchy.{html} |
+    | _[<sharedDeadLetterStrategy>|#sharedDeadLetterStrategy-element]_ | {html}A default implementation of {@link DeadLetterStrategy} which uses
+a constant destination.{html} |
+
+{anchor:org.apache.activemq.command.ActiveMQDestination-types}
+h4. The _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ Type Implementations
+    | _[<queue>|#queue-element]_ | {html}An ActiveMQ Queue{html} |
+    | _[<tempQueue>|#tempQueue-element]_ | {html}An ActiveMQ Temporary Queue Destination{html} |
+    | _[<tempTopic>|#tempTopic-element]_ | {html}An ActiveMQ Temporary Topic Destination{html} |
+    | _[<topic>|#topic-element]_ | {html}An ActiveMQ Topic{html} |
+
+{anchor:org.apache.activemq.security.TempDestinationAuthorizationEntry-types}
+h4. The _[org.apache.activemq.security.TempDestinationAuthorizationEntry|#org.apache.activemq.security.TempDestinationAuthorizationEntry-types]_ Type Implementations
+    | _[<tempDestinationAuthorizationEntry>|#tempDestinationAuthorizationEntry-element]_ | {html}Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a temporary
+destination{html} |
+
+{anchor:javax.jms.Topic-types}
+h4. The _[javax.jms.Topic|#javax.jms.Topic-types]_ Type Implementations
+    | _[<topic>|#topic-element]_ | {html}An ActiveMQ Topic{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.PendingDurableSubscriberMessageStoragePolicy-types}
+h4. The _[org.apache.activemq.broker.region.policy.PendingDurableSubscriberMessageStoragePolicy|#org.apache.activemq.broker.region.policy.PendingDurableSubscriberMessageStoragePolicy-types]_ Type Implementations
+    | _[<fileDurableSubscriberCursor>|#fileDurableSubscriberCursor-element]_ | {html}Pending messages for durable subscribers{html} |
+    | _[<storeDurableSubscriberCursor>|#storeDurableSubscriberCursor-element]_ | {html}Pending messages for a durable{html} |
+    | _[<vmDurableCursor>|#vmDurableCursor-element]_ | {html}Pending{html} |
+
+{anchor:javax.jms.TopicConnectionFactory-types}
+h4. The _[javax.jms.TopicConnectionFactory|#javax.jms.TopicConnectionFactory-types]_ Type Implementations
+    | _[<connectionFactory>|#connectionFactory-element]_ | {html}A <a href="http://www.springframework.org/">Spring</a> enhanced connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html} |
+    | _[<xaConnectionFactory>|#xaConnectionFactory-element]_ | {html}A <a href="http://www.springframework.org/">Spring</a> enhanced XA connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html} |
+
+{anchor:org.apache.activemq.store.jdbc.Statements-types}
+h4. The _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ Type Implementations
+    | _[<statements>|#statements-element]_ | {html}{html} |
+
+{anchor:org.apache.activemq.security.AuthorizationEntry-types}
+h4. The _[org.apache.activemq.security.AuthorizationEntry|#org.apache.activemq.security.AuthorizationEntry-types]_ Type Implementations
+    | _[<authorizationEntry>|#authorizationEntry-element]_ | {html}Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a specific
+destination or a hierarchical wildcard area of destinations.{html} |
+    | _[<tempDestinationAuthorizationEntry>|#tempDestinationAuthorizationEntry-element]_ | {html}Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a temporary
+destination{html} |
+
+{anchor:org.apache.activemq.filter.DestinationMap-types}
+h4. The _[org.apache.activemq.filter.DestinationMap|#org.apache.activemq.filter.DestinationMap-types]_ Type Implementations
+    | _[<authorizationMap>|#authorizationMap-element]_ | {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies. Each entry in the map represents the authorization ACLs
+for each operation.{html} |
+    | _[<cachedLDAPAuthorizationMap>|#cachedLDAPAuthorizationMap-element]_ | {html}A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update authorization
+policy.{html} |
+    | _[<mKahaDB>|#mKahaDB-element]_ | {html}An implementation of {@link org.apache.activemq.store.PersistenceAdapter}  that supports
+distribution of destinations across multiple kahaDB persistence adapters{html} |
+    | _[<policyMap>|#policyMap-element]_ | {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.{html} |
+    | _[<redeliveryPolicyMap>|#redeliveryPolicyMap-element]_ | {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.{html} |
+
+{anchor:org.apache.activemq.network.NetworkBridgeConfiguration-types}
+h4. The _[org.apache.activemq.network.NetworkBridgeConfiguration|#org.apache.activemq.network.NetworkBridgeConfiguration-types]_ Type Implementations
+    | _[<ldapNetworkConnector>|#ldapNetworkConnector-element]_ | {html}class to create dynamic network connectors listed in an directory
+server using the LDAP v3 protocol as defined in RFC 2251, the
+entries listed in the directory server must implement the ipHost
+and ipService objectClasses as defined in RFC 2307.{html} |
+    | _[<multicastNetworkConnector>|#multicastNetworkConnector-element]_ | {html}A network connector which uses some kind of multicast-like transport that
+communicates with potentially many remote brokers over a single logical
+{@link Transport} instance such as when using multicast.
+
+This implementation does not depend on multicast at all; any other group
+based transport could be used.{html} |
+    | _[<networkConnector>|#networkConnector-element]_ | {html}A network connector which uses a discovery agent to detect the remote brokers
+available and setup a connection to each available remote broker{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.PendingQueueMessageStoragePolicy-types}
+h4. The _[org.apache.activemq.broker.region.policy.PendingQueueMessageStoragePolicy|#org.apache.activemq.broker.region.policy.PendingQueueMessageStoragePolicy-types]_ Type Implementations
+    | _[<fileQueueCursor>|#fileQueueCursor-element]_ | {html}Pending{html} |
+    | _[<storeCursor>|#storeCursor-element]_ | {html}Pending messages{html} |
+    | _[<vmQueueCursor>|#vmQueueCursor-element]_ | {html}Pending messages{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.RedeliveryPolicyMap-types}
+h4. The _[org.apache.activemq.broker.region.policy.RedeliveryPolicyMap|#org.apache.activemq.broker.region.policy.RedeliveryPolicyMap-types]_ Type Implementations
+    | _[<redeliveryPolicyMap>|#redeliveryPolicyMap-element]_ | {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.PendingSubscriberMessageStoragePolicy-types}
+h4. The _[org.apache.activemq.broker.region.policy.PendingSubscriberMessageStoragePolicy|#org.apache.activemq.broker.region.policy.PendingSubscriberMessageStoragePolicy-types]_ Type Implementations
+    | _[<fileCursor>|#fileCursor-element]_ | {html}Pending messages{html} |
+    | _[<vmCursor>|#vmCursor-element]_ | {html}Pending messages held{html} |
+
+{anchor:org.apache.activemq.network.NetworkBridgeFilterFactory-types}
+h4. The _[org.apache.activemq.network.NetworkBridgeFilterFactory|#org.apache.activemq.network.NetworkBridgeFilterFactory-types]_ Type Implementations
+    | _[<conditionalNetworkBridgeFilterFactory>|#conditionalNetworkBridgeFilterFactory-element]_ | {html}implement conditional behaviour for queue consumers,
+allows replaying back to origin if no consumers are present on the local broker
+after a configurable delay, irrespective of the networkTTL
+Also allows rate limiting of messages through the network, useful for static includes{html} |
+    | _[<defaultNetworkBridgeFilterFactory>|#defaultNetworkBridgeFilterFactory-element]_ | {html}implement default behaviour, filter that will not allow resend to origin
+based on brokerPath and which respects networkTTL{html} |
+
+{anchor:javax.jms.ConnectionFactory-types}
+h4. The _[javax.jms.ConnectionFactory|#javax.jms.ConnectionFactory-types]_ Type Implementations
+    | _[<connectionFactory>|#connectionFactory-element]_ | {html}A <a href="http://www.springframework.org/">Spring</a> enhanced connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html} |
+    | _[<xaConnectionFactory>|#xaConnectionFactory-element]_ | {html}A <a href="http://www.springframework.org/">Spring</a> enhanced XA connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.PolicyEntry-types}
+h4. The _[org.apache.activemq.broker.region.policy.PolicyEntry|#org.apache.activemq.broker.region.policy.PolicyEntry-types]_ Type Implementations
+    | _[<policyEntry>|#policyEntry-element]_ | {html}Represents an entry in a {@link PolicyMap} for assigning policies to a
+specific destination or a hierarchical wildcard area of destinations.{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.PendingMessageLimitStrategy-types}
+h4. The _[org.apache.activemq.broker.region.policy.PendingMessageLimitStrategy|#org.apache.activemq.broker.region.policy.PendingMessageLimitStrategy-types]_ Type Implementations
+    | _[<constantPendingMessageLimitStrategy>|#constantPendingMessageLimitStrategy-element]_ | {html}This PendingMessageLimitStrategy is configured to a constant value for all subscriptions.{html} |
+    | _[<prefetchRatePendingMessageLimitStrategy>|#prefetchRatePendingMessageLimitStrategy-element]_ | {html}This PendingMessageLimitStrategy sets the maximum pending message limit value to be
+a multiplier of the prefetch limit of the subscription.{html} |
+
+{anchor:org.apache.activemq.usage.UsageCapacity-types}
+h4. The _[org.apache.activemq.usage.UsageCapacity|#org.apache.activemq.usage.UsageCapacity-types]_ Type Implementations
+    | _[<defaultUsageCapacity>|#defaultUsageCapacity-element]_ | {html}Identify if a limit has been reached{html} |
+    | _[<usageCapacity>|#usageCapacity-element]_ | {html}Identify if a limit has been reached{html} |
+
+{anchor:org.apache.activemq.broker.BrokerPlugin-types}
+h4. The _[org.apache.activemq.broker.BrokerPlugin|#org.apache.activemq.broker.BrokerPlugin-types]_ Type Implementations
+    | _[<authorizationPlugin>|#authorizationPlugin-element]_ | {html}An authorization plugin where each operation on a destination is checked
+against an authorizationMap{html} |
+    | _[<connectionDotFilePlugin>|#connectionDotFilePlugin-element]_ | {html}A <a href="http://www.graphviz.org/">DOT</a> file creator plugin which
+creates a DOT file showing the current connections{html} |
+    | _[<destinationDotFilePlugin>|#destinationDotFilePlugin-element]_ | {html}A <a href="http://www.graphviz.org/">DOT</a> 
+file creator plugin which creates a DOT file showing the current topic & queue hierarchies.{html} |
+    | _[<destinationPathSeparatorPlugin>|#destinationPathSeparatorPlugin-element]_ | {html}{html} |
+    | _[<discardingDLQBrokerPlugin>|#discardingDLQBrokerPlugin-element]_ | {html}{html} |
+    | _[<forcePersistencyModeBrokerPlugin>|#forcePersistencyModeBrokerPlugin-element]_ | {html}A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.{html} |
+    | _[<jaasAuthenticationPlugin>|#jaasAuthenticationPlugin-element]_ | {html}Provides a JAAS based authentication plugin{html} |
+    | _[<jaasCertificateAuthenticationPlugin>|#jaasCertificateAuthenticationPlugin-element]_ | {html}Provides a JAAS based SSL certificate authentication plugin{html} |
+    | _[<jaasDualAuthenticationPlugin>|#jaasDualAuthenticationPlugin-element]_ | {html}Provides a JAAS based authentication plugin{html} |
+    | _[<loggingBrokerPlugin>|#loggingBrokerPlugin-element]_ | {html}A simple Broker intercepter which allows you to enable/disable logging.{html} |
+    | _[<multicastTraceBrokerPlugin>|#multicastTraceBrokerPlugin-element]_ | {html}A Broker interceptor which allows you to trace all operations to a Multicast
+socket.{html} |
+    | _[<redeliveryPlugin>|#redeliveryPlugin-element]_ | {html}Replace regular DLQ handling with redelivery via a resend to the original destination
+after a delay
+A destination matching RedeliveryPolicy controls the quantity and delay for re-sends
+If there is no matching policy or an existing policy limit is exceeded by default
+regular DLQ processing resumes. This is controlled via sendToDlqIfMaxRetriesExceeded
+and fallbackToDeadLetter{html} |
+    | _[<simpleAuthenticationPlugin>|#simpleAuthenticationPlugin-element]_ | {html}Provides a simple authentication plugin{html} |
+    | _[<statisticsBrokerPlugin>|#statisticsBrokerPlugin-element]_ | {html}A StatisticsBrokerPlugin
+You can retrieve a Map Message for a Destination - or
+Broker containing statistics as key-value pairs The message must contain a
+replyTo Destination - else its ignored
+To retrieve stats on the broker send a empty message to ActiveMQ.Statistics.Broker (Queue or Topic)
+With a replyTo set to the destination you want the stats returned to.
+To retrieve stats for a destination - e.g. foo - send an empty message to ActiveMQ.Statistics.Destination.foo
+- this works with wildcards to - you get a message for each wildcard match on the replyTo destination.
+The stats message is a MapMessage populated with statistics for the target{html} |
+    | _[<timeStampingBrokerPlugin>|#timeStampingBrokerPlugin-element]_ | {html}A Broker interceptor which updates a JMS Client's timestamp on the message
+with a broker timestamp. Useful when the clocks on client machines are known
+to not be correct and you can only trust the time set on the broker machines.
+
+Enabling this plugin will break JMS compliance since the timestamp that the
+producer sees on the messages after as send() will be different from the
+timestamp the consumer will observe when he receives the message. This plugin
+is not enabled in the default ActiveMQ configuration.
+
+2 new attributes have been added which will allow the administrator some override control
+over the expiration time for incoming messages:
+
+Attribute 'zeroExpirationOverride' can be used to apply an expiration
+time to incoming messages with no expiration defined (messages that would never expire)
+
+Attribute 'ttlCeiling' can be used to apply a limit to the expiration time{html} |
+    | _[<traceBrokerPathPlugin>|#traceBrokerPathPlugin-element]_ | {html}The TraceBrokerPathPlugin can be used in a network of Brokers. Each Broker
+that has the plugin configured, will add it's brokerName to the content
+of a JMS Property. If all Brokers have this property enabled, the path the
+message actually took through the network can be seen in the defined property.{html} |
+    | _[<udpTraceBrokerPlugin>|#udpTraceBrokerPlugin-element]_ | {html}A Broker interceptor which allows you to trace all operations to a UDP
+socket.{html} |
+    | _[<virtualSelectorCacheBrokerPlugin>|#virtualSelectorCacheBrokerPlugin-element]_ | {html}A plugin which allows the caching of the selector from a subscription queue.
+<p/>
+This stops the build-up of unwanted messages, especially when consumers may
+disconnect from time to time when using virtual destinations.
+<p/>
+This is influenced by code snippets developed by Maciej Rakowicz{html} |
+
+{anchor:org.apache.activemq.network.jms.JmsMesageConvertor-types}
+h4. The _[org.apache.activemq.network.jms.JmsMesageConvertor|#org.apache.activemq.network.jms.JmsMesageConvertor-types]_ Type Implementations
+    | _[<simpleJmsMessageConvertor>|#simpleJmsMessageConvertor-element]_ | {html}Converts Message from one JMS to another{html} |
+
+{anchor:org.apache.activemq.broker.Broker-types}
+h4. The _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ Type Implementations
+    | _[<destinationPathSeparatorPlugin>|#destinationPathSeparatorPlugin-element]_ | {html}{html} |
+    | _[<forcePersistencyModeBroker>|#forcePersistencyModeBroker-element]_ | {html}A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.{html} |
+    | _[<loggingBrokerPlugin>|#loggingBrokerPlugin-element]_ | {html}A simple Broker intercepter which allows you to enable/disable logging.{html} |
+    | _[<multicastTraceBrokerPlugin>|#multicastTraceBrokerPlugin-element]_ | {html}A Broker interceptor which allows you to trace all operations to a Multicast
+socket.{html} |
+    | _[<redeliveryPlugin>|#redeliveryPlugin-element]_ | {html}Replace regular DLQ handling with redelivery via a resend to the original destination
+after a delay
+A destination matching RedeliveryPolicy controls the quantity and delay for re-sends
+If there is no matching policy or an existing policy limit is exceeded by default
+regular DLQ processing resumes. This is controlled via sendToDlqIfMaxRetriesExceeded
+and fallbackToDeadLetter{html} |
+    | _[<timeStampingBrokerPlugin>|#timeStampingBrokerPlugin-element]_ | {html}A Broker interceptor which updates a JMS Client's timestamp on the message
+with a broker timestamp. Useful when the clocks on client machines are known
+to not be correct and you can only trust the time set on the broker machines.
+
+Enabling this plugin will break JMS compliance since the timestamp that the
+producer sees on the messages after as send() will be different from the
+timestamp the consumer will observe when he receives the message. This plugin
+is not enabled in the default ActiveMQ configuration.
+
+2 new attributes have been added which will allow the administrator some override control
+over the expiration time for incoming messages:
+
+Attribute 'zeroExpirationOverride' can be used to apply an expiration
+time to incoming messages with no expiration defined (messages that would never expire)
+
+Attribute 'ttlCeiling' can be used to apply a limit to the expiration time{html} |
+    | _[<traceBrokerPathPlugin>|#traceBrokerPathPlugin-element]_ | {html}The TraceBrokerPathPlugin can be used in a network of Brokers. Each Broker
+that has the plugin configured, will add it's brokerName to the content
+of a JMS Property. If all Brokers have this property enabled, the path the
+message actually took through the network can be seen in the defined property.{html} |
+    | _[<udpTraceBrokerPlugin>|#udpTraceBrokerPlugin-element]_ | {html}A Broker interceptor which allows you to trace all operations to a UDP
+socket.{html} |
+
+{anchor:org.apache.activemq.broker.TransportConnector-types}
+h4. The _[org.apache.activemq.broker.TransportConnector|#org.apache.activemq.broker.TransportConnector-types]_ Type Implementations
+    | _[<transportConnector>|#transportConnector-element]_ | {html}{html} |
+
+{anchor:org.apache.activemq.network.jms.InboundTopicBridge-types}
+h4. The _[org.apache.activemq.network.jms.InboundTopicBridge|#org.apache.activemq.network.jms.InboundTopicBridge-types]_ Type Implementations
+    | _[<inboundTopicBridge>|#inboundTopicBridge-element]_ | {html}Create an Inbound Topic Bridge.  By default this class uses the topic name for
+both the inbound and outbound topic.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud topic names
+separately.{html} |
+
+{anchor:org.apache.activemq.network.jms.JmsConnector-types}
+h4. The _[org.apache.activemq.network.jms.JmsConnector|#org.apache.activemq.network.jms.JmsConnector-types]_ Type Implementations
+    | _[<jmsQueueConnector>|#jmsQueueConnector-element]_ | {html}A Bridge to other JMS Queue providers{html} |
+    | _[<jmsTopicConnector>|#jmsTopicConnector-element]_ | {html}A Bridge to other JMS Topic providers{html} |
+
+{anchor:org.apache.activemq.store.PersistenceAdapter-types}
+h4. The _[org.apache.activemq.store.PersistenceAdapter|#org.apache.activemq.store.PersistenceAdapter-types]_ Type Implementations
+    | _[<amqPersistenceAdapter>|#amqPersistenceAdapter-element]_ | {html}An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.{html} |
+    | _[<jdbcPersistenceAdapter>|#jdbcPersistenceAdapter-element]_ | {html}A {@link PersistenceAdapter} implementation using JDBC for persistence
+storage.
+
+This persistence adapter will correctly remember prepared XA transactions,
+but it will not keep track of local transaction commits so that operations
+performed against the Message store are done as a single uow.{html} |
+    | _[<journalPersistenceAdapter>|#journalPersistenceAdapter-element]_ | {html}An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.{html} |
+    | _[<kahaDB>|#kahaDB-element]_ | {html}An implementation of {@link PersistenceAdapter} designed for use with
+KahaDB - Embedded Lightweight Non-Relational Database{html} |
+    | _[<kahaPersistenceAdapter>|#kahaPersistenceAdapter-element]_ | {html}{html} |
+    | _[<levelDB>|#levelDB-element]_ | {html}An implementation of {@link org.apache.activemq.store.PersistenceAdapter} designed for use with
+LevelDB - Embedded Lightweight Non-Relational Database{html} |
+    | _[<mKahaDB>|#mKahaDB-element]_ | {html}An implementation of {@link org.apache.activemq.store.PersistenceAdapter}  that supports
+distribution of destinations across multiple kahaDB persistence adapters{html} |
+    | _[<memoryPersistenceAdapter>|#memoryPersistenceAdapter-element]_ | {html}{html} |
+
+{anchor:org.apache.activemq.network.jms.OutboundQueueBridge-types}
+h4. The _[org.apache.activemq.network.jms.OutboundQueueBridge|#org.apache.activemq.network.jms.OutboundQueueBridge-types]_ Type Implementations
+    | _[<outboundQueueBridge>|#outboundQueueBridge-element]_ | {html}Create an Outbound Queue Bridge.  By default the bridge uses the same
+name for both the inbound and outbound queues, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+queue names.{html} |
+
+{anchor:org.apache.activemq.broker.Locker-types}
+h4. The _[org.apache.activemq.broker.Locker|#org.apache.activemq.broker.Locker-types]_ Type Implementations
+    | _[<database-locker>|#database-locker-element]_ | {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<lease-database-locker>|#lease-database-locker-element]_ | {html}Represents an exclusive lease on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<shared-file-locker>|#shared-file-locker-element]_ | {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<transact-database-locker>|#transact-database-locker-element]_ | {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html} |
+
+{anchor:org.apache.activemq.broker.region.policy.MessageEvictionStrategy-types}
+h4. The _[org.apache.activemq.broker.region.policy.MessageEvictionStrategy|#org.apache.activemq.broker.region.policy.MessageEvictionStrategy-types]_ Type Implementations
+    | _[<oldestMessageEvictionStrategy>|#oldestMessageEvictionStrategy-element]_ | {html}An eviction strategy which evicts the oldest message first (which is the
+default).{html} |
+    | _[<oldestMessageWithLowestPriorityEvictionStrategy>|#oldestMessageWithLowestPriorityEvictionStrategy-element]_ | {html}An eviction strategy which evicts the oldest message with the lowest priority first.{html} |
+    | _[<uniquePropertyMessageEvictionStrategy>|#uniquePropertyMessageEvictionStrategy-element]_ | {html}An eviction strategy which evicts the oldest message within messages with the same property value{html} |
+
+{anchor:org.apache.activemq.broker.jmx.ManagementContext-types}
+h4. The _[org.apache.activemq.broker.jmx.ManagementContext|#org.apache.activemq.broker.jmx.ManagementContext-types]_ Type Implementations
+    | _[<managementContext>|#managementContext-element]_ | {html}An abstraction over JMX mbean registration{html} |
+
+{anchor:org.apache.activemq.filter.DestinationMapEntry-types}
+h4. The _[org.apache.activemq.filter.DestinationMapEntry|#org.apache.activemq.filter.DestinationMapEntry-types]_ Type Implementations
+    | _[<authorizationEntry>|#authorizationEntry-element]_ | {html}Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a specific
+destination or a hierarchical wildcard area of destinations.{html} |
+    | _[<destinationEntry>|#destinationEntry-element]_ | {html}A default entry in a DestinationMap which holds a single value.{html} |
+    | _[<filteredKahaDB>|#filteredKahaDB-element]_ | {html}{html} |
+    | _[<policyEntry>|#policyEntry-element]_ | {html}Represents an entry in a {@link PolicyMap} for assigning policies to a
+specific destination or a hierarchical wildcard area of destinations.{html} |
+    | _[<redeliveryPolicy>|#redeliveryPolicy-element]_ | {html}Configuration options for a messageConsumer used to control how messages are re-delivered when they
+are rolled back.
+May be used server side on a per destination basis via the Broker RedeliveryPlugin{html} |
+    | _[<tempDestinationAuthorizationEntry>|#tempDestinationAuthorizationEntry-element]_ | {html}Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a temporary
+destination{html} |
+
+
+{anchor:abortSlowConsumerStrategy-element}
+h3. The _[<abortSlowConsumerStrategy>|#abortSlowConsumerStrategy-element]_ Element
+    {html}Abort slow consumers when they reach the configured threshold of slowness, default is slow for 30 seconds{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | abortConnection | _boolean_ | {html}abort the consumers connection rather than sending a stop command to the remote consumer{html} |
+    | brokerService | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | checkPeriod | _long_ | {html}time in milliseconds between checks for slow subscriptions{html} |
+    | maxSlowCount | _long_ | {html}number of times a subscription can be deemed slow before triggering abort
+effect depends on dispatch rate as slow determination is done on dispatch{html} |
+    | maxSlowDuration | _long_ | {html}time in milliseconds that a sub can remain slow before triggering
+an abort.{html} |
+    | name | _java.lang.String_ | {html}{html} |
+
+{anchor:amqPersistenceAdapter-element}
+h3. The _[<amqPersistenceAdapter>|#amqPersistenceAdapter-element]_ Element
+    {html}An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | archiveDataLogs | _boolean_ | {html}{html} |
+    | asyncDataManager | _org.apache.activemq.kaha.impl.async.AsyncDataManager_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | checkpointInterval | _long_ | {html}{html} |
+    | cleanupInterval | _long_ | {html}{html} |
+    | directory | _java.io.File_ | {html}{html} |
+    | directoryArchive | _java.io.File_ | {html}{html} |
+    | disableLocking | _boolean_ | {html}{html} |
+    | forceRecoverReferenceStore | _boolean_ | {html}{html} |
+    | indexBinSize | _int_ | {html}{html} |
+    | indexKeySize | _int_ | {html}{html} |
+    | indexLoadFactor | _int_ | {html}{html} |
+    | indexMaxBinSize | _int_ | {html}{html} |
+    | indexPageSize | _java.lang.String_ | {html}When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | journalThreadPriority | _int_ | {html}{html} |
+    | maxCheckpointMessageAddSize | _java.lang.String_ | {html}When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | maxFileLength | _java.lang.String_ | {html}When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | maxReferenceFileLength | _java.lang.String_ | {html}When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | persistentIndex | _boolean_ | {html}{html} |
+    | recoverReferenceStore | _boolean_ | {html}{html} |
+    | referenceStoreAdapter | _org.apache.activemq.store.ReferenceStoreAdapter_ | {html}{html} |
+    | syncOnWrite | _boolean_ | {html}{html} |
+    | taskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | usageManager | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | useDedicatedTaskRunner | _boolean_ | {html}{html} |
+    | useNio | _boolean_ | {html}{html} |
+    | wireFormat | _org.apache.activemq.wireformat.WireFormat_ | {html}{html} |
+
+{anchor:amqPersistenceAdapterFactory-element}
+h3. The _[<amqPersistenceAdapterFactory>|#amqPersistenceAdapterFactory-element]_ Element
+    {html}An implementation of {@link PersistenceAdapterFactory}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | checkpointInterval | _long_ | {html}{html} |
+    | cleanupInterval | _long_ | {html}{html} |
+    | dataDirectory | _java.io.File_ | {html}{html} |
+    | forceRecoverReferenceStore | _boolean_ | {html}{html} |
+    | indexBinSize | _int_ | {html}{html} |
+    | indexKeySize | _int_ | {html}{html} |
+    | indexLoadFactor | _int_ | {html}{html} |
+    | indexMaxBinSize | _int_ | {html}{html} |
+    | indexPageSize | _int_ | {html}{html} |
+    | journalThreadPriority | _int_ | {html}{html} |
+    | maxFileLength | _int_ | {html}{html} |
+    | maxReferenceFileLength | _int_ | {html}{html} |
+    | persistentIndex | _boolean_ | {html}{html} |
+    | recoverReferenceStore | _boolean_ | {html}{html} |
+    | referenceStoreAdapter | _org.apache.activemq.store.ReferenceStoreAdapter_ | {html}{html} |
+    | syncOnTransaction | _boolean_ | {html}{html} |
+    | syncOnWrite | _boolean_ | {html}{html} |
+    | taskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | useDedicatedTaskRunner | _boolean_ | {html}{html} |
+    | useNio | _boolean_ | {html}{html} |
+
+{anchor:authenticationUser-element}
+h3. The _[<authenticationUser>|#authenticationUser-element]_ Element
+    {html}A helper object used to configure simple authentiaction plugin{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | groups | _java.lang.String_ | {html}{html} |
+    | password | _java.lang.String_ | {html}{html} |
+    | username | _java.lang.String_ | {html}{html} |
+
+{anchor:authorizationEntry-element}
+h3. The _[<authorizationEntry>|#authorizationEntry-element]_ Element
+    {html}Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a specific
+destination or a hierarchical wildcard area of destinations.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | admin | _java.lang.String_ | {html}{html} |
+    | adminACLs | (_java.lang.Object_)\* | {html}{html} |
+    | destination | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}{html} |
+    | groupClass | _java.lang.String_ | {html}{html} |
+    | queue | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | read | _java.lang.String_ | {html}{html} |
+    | readACLs | (_java.lang.Object_)\* | {html}{html} |
+    | tempQueue | _boolean_ | {html}{html} |
+    | tempTopic | _boolean_ | {html}{html} |
+    | topic | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | write | _java.lang.String_ | {html}{html} |
+    | writeACLs | (_java.lang.Object_)\* | {html}{html} |
+
+{anchor:authorizationMap-element}
+h3. The _[<authorizationMap>|#authorizationMap-element]_ Element
+    {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies. Each entry in the map represents the authorization ACLs
+for each operation.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | authorizationEntries | (_java.lang.Object_)\* | {html}Sets the individual entries on the authorization map{html} |
+    | defaultEntry | _[org.apache.activemq.security.AuthorizationEntry|#org.apache.activemq.security.AuthorizationEntry-types]_ | {html}{html} |
+    | entries | (_java.lang.Object_)\* | {html}A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring{html} |
+    | tempDestinationAuthorizationEntry | _[org.apache.activemq.security.TempDestinationAuthorizationEntry|#org.apache.activemq.security.TempDestinationAuthorizationEntry-types]_ | {html}{html} |
+
+{anchor:authorizationPlugin-element}
+h3. The _[<authorizationPlugin>|#authorizationPlugin-element]_ Element
+    {html}An authorization plugin where each operation on a destination is checked
+against an authorizationMap{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | map | _[org.apache.activemq.security.AuthorizationMap|#org.apache.activemq.security.AuthorizationMap-types]_ | {html}{html} |
+
+{anchor:axionJDBCAdapter-element}
+h3. The _[<axionJDBCAdapter>|#axionJDBCAdapter-element]_ Element
+    {html}Axion specific Adapter.
+
+Axion does not seem to support ALTER statements or sub-selects.  This means:
+- We cannot auto upgrade the schema was we roll out new versions of ActiveMQ
+- We cannot delete durable sub messages that have be acknowledged by all consumers.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:blobJDBCAdapter-element}
+h3. The _[<blobJDBCAdapter>|#blobJDBCAdapter-element]_ Element
+    {html}This JDBCAdapter inserts and extracts BLOB data using the getBlob()/setBlob()
+operations. This is a little more involved since to insert a blob you have
+to:
+
+1: insert empty blob. 2: select the blob 3: finally update the blob with data
+value.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:broker-element}
+h3. The _[<broker>|#broker-element]_ Element
+    {html}An ActiveMQ Message Broker. It consists of a number of transport
+connectors, network connectors and a bunch of properties which can be used to
+configure the broker as its lazily created.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminView | _org.apache.activemq.broker.jmx.BrokerView_ | {html}Returns the administration view of the broker; used to create and destroy
+resources such as queues and topics. Note this method returns null if JMX
+is disabled.{html} |
+    | advisorySupport | _java.lang.String_ | {html}Allows the support of advisory messages to be disabled for performance
+reasons.{html} |
+    | allowTempAutoCreationOnSend | _boolean_ | {html}enable if temp destinations need to be propagated through a network when
+advisorySupport==false. This is used in conjunction with the policy
+gcInactiveDestinations for matching temps so they can get removed
+when inactive{html} |
+    | brokerContext | _org.apache.activemq.broker.BrokerContext_ | {html}{html} |
+    | brokerId | _java.lang.String_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}Sets the name of this broker; which must be unique in the network{html} |
+    | brokerObjectName | _javax.management.ObjectName_ | {html}Sets the JMX ObjectName for this broker{html} |
+    | cacheTempDestinations | _boolean_ | {html}{html} |
+    | consumerSystemUsage | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | consumerSystemUsagePortion | _int_ | {html}{html} |
+    | dataDirectory | _java.lang.String_ | {html}Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.{html} |
+    | dataDirectoryFile | _java.io.File_ | {html}Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.{html} |
+    | dedicatedTaskRunner | _boolean_ | {html}{html} |
+    | deleteAllMessagesOnStartup | _java.lang.String_ | {html}Sets whether or not all messages are deleted on startup - mostly only
+useful for testing.{html} |
+    | destinationFactory | _org.apache.activemq.broker.region.DestinationFactory_ | {html}{html} |
+    | destinationInterceptors | (_[org.apache.activemq.broker.region.DestinationInterceptor|#org.apache.activemq.broker.region.DestinationInterceptor-types]_)\* | {html}Sets the destination interceptors to use{html} |
+    | destinationPolicy | _[org.apache.activemq.broker.region.policy.PolicyMap|#org.apache.activemq.broker.region.policy.PolicyMap-types]_ | {html}Sets the destination specific policies available either for exact
+destinations or for wildcard areas of destinations.{html} |
+    | destinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}Sets the destinations which should be loaded/created on startup{html} |
+    | enableStatistics | _boolean_ | {html}Sets whether or not the Broker's services enable statistics or not.{html} |
+    | ioExceptionHandler | _[org.apache.activemq.util.IOExceptionHandler|#org.apache.activemq.util.IOExceptionHandler-types]_ | {html}override the Default IOException handler, called when persistence adapter
+has experiences File or JDBC I/O Exceptions{html} |
+    | jmsBridgeConnectors | (_[org.apache.activemq.network.jms.JmsConnector|#org.apache.activemq.network.jms.JmsConnector-types]_)\* | {html}{html} |
+    | keepDurableSubsActive | _boolean_ | {html}{html} |
+    | managementContext | _[org.apache.activemq.broker.jmx.ManagementContext|#org.apache.activemq.broker.jmx.ManagementContext-types]_ | {html}{html} |
+    | masterConnectorURI | _java.lang.String_ | {html}{html} |
+    | maxPurgedDestinationsPerSweep | _int_ | {html}{html} |
+    | mbeanInvocationTimeout | _long_ | {html}Gets the time in Milliseconds that an invocation of an MBean method will wait before
+failing.  The default value is to wait forever (zero).{html} |
+    | messageAuthorizationPolicy | _org.apache.activemq.security.MessageAuthorizationPolicy_ | {html}Sets the policy used to decide if the current connection is authorized to
+consume a given message{html} |
+    | monitorConnectionSplits | _boolean_ | {html}{html} |
+    | networkConnectorStartAsync | _boolean_ | {html}{html} |
+    | networkConnectorURIs | (_java.lang.String_)\* | {html}{html} |
+    | networkConnectors | (_[org.apache.activemq.network.NetworkConnector|#org.apache.activemq.network.NetworkConnector-types]_)\* | {html}Sets the network connectors which this broker will use to connect to
+other brokers in a federated network{html} |
+    | offlineDurableSubscriberTaskSchedule | _int_ | {html}{html} |
+    | offlineDurableSubscriberTimeout | _int_ | {html}{html} |
+    | passiveSlave | _java.lang.String_ | {html}Get the passiveSlave{html} |
+    | persistenceAdapter | _[org.apache.activemq.store.PersistenceAdapter|#org.apache.activemq.store.PersistenceAdapter-types]_ | {html}Sets the persistence adaptor implementation to use for this broker{html} |
+    | persistenceFactory | _[org.apache.activemq.store.PersistenceAdapterFactory|#org.apache.activemq.store.PersistenceAdapterFactory-types]_ | {html}{html} |
+    | persistenceTaskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | persistenceThreadPriority | _int_ | {html}{html} |
+    | persistent | _java.lang.String_ | {html}Sets whether or not persistence is enabled or disabled.{html} |
+    | plugins | (_[org.apache.activemq.broker.BrokerPlugin|#org.apache.activemq.broker.BrokerPlugin-types]_)\* | {html}Sets a number of broker plugins to install such as for security
+authentication or authorization{html} |
+    | populateJMSXUserID | _boolean_ | {html}Sets whether or not the broker should populate the JMSXUserID header.{html} |
+    | populateUserNameInMBeans | _boolean_ | {html}Should MBeans that support showing the Authenticated User Name information have this
+value filled in or not.{html} |
+    | producerSystemUsage | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | producerSystemUsagePortion | _int_ | {html}{html} |
+    | proxyConnectors | (_java.lang.Object_)\* | {html}Sets the network connectors which this broker will use to connect to
+other brokers in a federated network{html} |
+    | regionBroker | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | schedulePeriodForDestinationPurge | _int_ | {html}{html} |
+    | schedulerDirectory | _java.lang.String_ | {html}{html} |
+    | schedulerDirectoryFile | _java.io.File_ | {html}{html} |
+    | schedulerSupport | _java.lang.String_ | {html}{html} |
+    | services | (_[org.apache.activemq.Service|#org.apache.activemq.Service-types]_)\* | {html}Sets the services associated with this broker such as a
+{@link MasterConnector}{html} |
+    | shutdownHooks | (_java.lang.Object_)\* | {html}Sets hooks to be executed when broker shut down{html} |
+    | shutdownOnMasterFailure | _boolean_ | {html}{html} |
+    | shutdownOnSlaveFailure | _java.lang.String_ | {html}{html} |
+    | splitSystemUsageForProducersConsumers | _boolean_ | {html}{html} |
+    | sslContext | _[org.apache.activemq.broker.SslContext|#org.apache.activemq.broker.SslContext-types]_ | {html}{html} |
+    | start | _boolean_ | {html}Sets whether or not the broker is started along with the ApplicationContext it is defined within.
+Normally you would want the broker to start up along with the ApplicationContext but sometimes when working
+with JUnit tests you may wish to start and stop the broker explicitly yourself.{html} |
+    | startAsync | _boolean_ | {html}{html} |
+    | supportFailOver | _boolean_ | {html}{html} |
+    | systemExitOnShutdown | _java.lang.String_ | {html}{html} |
+    | systemExitOnShutdownExitCode | _int_ | {html}{html} |
+    | systemUsage | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | taskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | taskRunnerPriority | _int_ | {html}{html} |
+    | tempDataStore | _[org.apache.activemq.store.kahadb.plist.PListStore|#org.apache.activemq.store.kahadb.plist.PListStore-types]_ | {html}{html} |
+    | timeBeforePurgeTempDestinations | _int_ | {html}{html} |
+    | tmpDataDirectory | _java.io.File_ | {html}{html} |
+    | transportConnectorURIs | (_java.lang.String_)\* | {html}{html} |
+    | transportConnectors | (_[org.apache.activemq.broker.TransportConnector|#org.apache.activemq.broker.TransportConnector-types]_)\* | {html}Sets the transport connectors which this broker will listen on for new
+clients{html} |
+    | useAuthenticatedPrincipalForJMSXUserID | _boolean_ | {html}{html} |
+    | useJmx | _java.lang.String_ | {html}Sets whether or not the Broker's services should be exposed into JMX or
+not.{html} |
+    | useLocalHostBrokerName | _boolean_ | {html}{html} |
+    | useLoggingForShutdownErrors | _boolean_ | {html}Sets whether or not we should use commons-logging when reporting errors
+when shutting down the broker{html} |
+    | useMirroredQueues | _boolean_ | {html}Sets whether or not <a
+href="http://activemq.apache.org/mirrored-queues.html">Mirrored
+Queues</a> should be supported by default if they have not been
+explicitly configured.{html} |
+    | useShutdownHook | _boolean_ | {html}Sets whether or not we should use a shutdown handler to close down the
+broker cleanly if the JVM is terminated. It is recommended you leave this
+enabled.{html} |
+    | useTempMirroredQueues | _boolean_ | {html}{html} |
+    | useVirtualTopics | _boolean_ | {html}Sets whether or not <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual
+Topics</a> should be supported by default if they have not been
+explicitly configured.{html} |
+    | vmConnectorURI | _java.net.URI_ | {html}{html} |
+    | waitForSlave | _java.lang.String_ | {html}{html} |
+    | waitForSlaveTimeout | _long_ | {html}{html} |
+
+{anchor:brokerService-element}
+h3. The _[<brokerService>|#brokerService-element]_ Element
+    {html}Manages the lifecycle of an ActiveMQ Broker. A BrokerService consists of a
+number of transport connectors, network connectors and a bunch of properties
+which can be used to configure the broker as its lazily created.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminView | _org.apache.activemq.broker.jmx.BrokerView_ | {html}Returns the administration view of the broker; used to create and destroy
+resources such as queues and topics. Note this method returns null if JMX
+is disabled.{html} |
+    | advisorySupport | _java.lang.String_ | {html}Allows the support of advisory messages to be disabled for performance
+reasons.{html} |
+    | allowTempAutoCreationOnSend | _boolean_ | {html}enable if temp destinations need to be propagated through a network when
+advisorySupport==false. This is used in conjunction with the policy
+gcInactiveDestinations for matching temps so they can get removed
+when inactive{html} |
+    | brokerContext | _org.apache.activemq.broker.BrokerContext_ | {html}{html} |
+    | brokerId | _java.lang.String_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}Sets the name of this broker; which must be unique in the network{html} |
+    | brokerObjectName | _javax.management.ObjectName_ | {html}Sets the JMX ObjectName for this broker{html} |
+    | cacheTempDestinations | _boolean_ | {html}{html} |
+    | consumerSystemUsage | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | consumerSystemUsagePortion | _int_ | {html}{html} |
+    | dataDirectory | _java.lang.String_ | {html}Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.{html} |
+    | dataDirectoryFile | _java.io.File_ | {html}Sets the directory in which the data files will be stored by default for
+the JDBC and Journal persistence adaptors.{html} |
+    | dedicatedTaskRunner | _boolean_ | {html}{html} |
+    | deleteAllMessagesOnStartup | _java.lang.String_ | {html}Sets whether or not all messages are deleted on startup - mostly only
+useful for testing.{html} |
+    | destinationFactory | _org.apache.activemq.broker.region.DestinationFactory_ | {html}{html} |
+    | destinationInterceptors | (_[org.apache.activemq.broker.region.DestinationInterceptor|#org.apache.activemq.broker.region.DestinationInterceptor-types]_)\* | {html}Sets the destination interceptors to use{html} |
+    | destinationPolicy | _[org.apache.activemq.broker.region.policy.PolicyMap|#org.apache.activemq.broker.region.policy.PolicyMap-types]_ | {html}Sets the destination specific policies available either for exact
+destinations or for wildcard areas of destinations.{html} |
+    | destinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}Sets the destinations which should be loaded/created on startup{html} |
+    | enableStatistics | _boolean_ | {html}Sets whether or not the Broker's services enable statistics or not.{html} |
+    | ioExceptionHandler | _[org.apache.activemq.util.IOExceptionHandler|#org.apache.activemq.util.IOExceptionHandler-types]_ | {html}override the Default IOException handler, called when persistence adapter
+has experiences File or JDBC I/O Exceptions{html} |
+    | jmsBridgeConnectors | (_[org.apache.activemq.network.jms.JmsConnector|#org.apache.activemq.network.jms.JmsConnector-types]_)\* | {html}{html} |
+    | keepDurableSubsActive | _boolean_ | {html}{html} |
+    | managementContext | _[org.apache.activemq.broker.jmx.ManagementContext|#org.apache.activemq.broker.jmx.ManagementContext-types]_ | {html}{html} |
+    | masterConnectorURI | _java.lang.String_ | {html}{html} |
+    | maxPurgedDestinationsPerSweep | _int_ | {html}{html} |
+    | mbeanInvocationTimeout | _long_ | {html}Gets the time in Milliseconds that an invocation of an MBean method will wait before
+failing.  The default value is to wait forever (zero).{html} |
+    | messageAuthorizationPolicy | _org.apache.activemq.security.MessageAuthorizationPolicy_ | {html}Sets the policy used to decide if the current connection is authorized to
+consume a given message{html} |
+    | monitorConnectionSplits | _boolean_ | {html}{html} |
+    | networkConnectorStartAsync | _boolean_ | {html}{html} |
+    | networkConnectorURIs | (_java.lang.String_)\* | {html}{html} |
+    | networkConnectors | (_[org.apache.activemq.network.NetworkConnector|#org.apache.activemq.network.NetworkConnector-types]_)\* | {html}Sets the network connectors which this broker will use to connect to
+other brokers in a federated network{html} |
+    | offlineDurableSubscriberTaskSchedule | _int_ | {html}{html} |
+    | offlineDurableSubscriberTimeout | _int_ | {html}{html} |
+    | passiveSlave | _java.lang.String_ | {html}Get the passiveSlave{html} |
+    | persistenceAdapter | _[org.apache.activemq.store.PersistenceAdapter|#org.apache.activemq.store.PersistenceAdapter-types]_ | {html}Sets the persistence adaptor implementation to use for this broker{html} |
+    | persistenceFactory | _[org.apache.activemq.store.PersistenceAdapterFactory|#org.apache.activemq.store.PersistenceAdapterFactory-types]_ | {html}{html} |
+    | persistenceTaskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | persistenceThreadPriority | _int_ | {html}{html} |
+    | persistent | _java.lang.String_ | {html}Sets whether or not persistence is enabled or disabled.{html} |
+    | plugins | (_[org.apache.activemq.broker.BrokerPlugin|#org.apache.activemq.broker.BrokerPlugin-types]_)\* | {html}Sets a number of broker plugins to install such as for security
+authentication or authorization{html} |
+    | populateJMSXUserID | _boolean_ | {html}Sets whether or not the broker should populate the JMSXUserID header.{html} |
+    | populateUserNameInMBeans | _boolean_ | {html}Should MBeans that support showing the Authenticated User Name information have this
+value filled in or not.{html} |
+    | producerSystemUsage | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | producerSystemUsagePortion | _int_ | {html}{html} |
+    | proxyConnectors | (_java.lang.Object_)\* | {html}Sets the network connectors which this broker will use to connect to
+other brokers in a federated network{html} |
+    | regionBroker | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | schedulePeriodForDestinationPurge | _int_ | {html}{html} |
+    | schedulerDirectory | _java.lang.String_ | {html}{html} |
+    | schedulerDirectoryFile | _java.io.File_ | {html}{html} |
+    | schedulerSupport | _java.lang.String_ | {html}{html} |
+    | services | (_[org.apache.activemq.Service|#org.apache.activemq.Service-types]_)\* | {html}Sets the services associated with this broker such as a
+{@link MasterConnector}{html} |
+    | shutdownHooks | (_java.lang.Object_)\* | {html}Sets hooks to be executed when broker shut down{html} |
+    | shutdownOnMasterFailure | _boolean_ | {html}{html} |
+    | shutdownOnSlaveFailure | _java.lang.String_ | {html}{html} |
+    | splitSystemUsageForProducersConsumers | _boolean_ | {html}{html} |
+    | sslContext | _[org.apache.activemq.broker.SslContext|#org.apache.activemq.broker.SslContext-types]_ | {html}{html} |
+    | startAsync | _boolean_ | {html}{html} |
+    | supportFailOver | _boolean_ | {html}{html} |
+    | systemExitOnShutdown | _java.lang.String_ | {html}{html} |
+    | systemExitOnShutdownExitCode | _int_ | {html}{html} |
+    | systemUsage | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | taskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | taskRunnerPriority | _int_ | {html}{html} |
+    | tempDataStore | _[org.apache.activemq.store.kahadb.plist.PListStore|#org.apache.activemq.store.kahadb.plist.PListStore-types]_ | {html}{html} |
+    | timeBeforePurgeTempDestinations | _int_ | {html}{html} |
+    | tmpDataDirectory | _java.io.File_ | {html}{html} |
+    | transportConnectorURIs | (_java.lang.String_)\* | {html}{html} |
+    | transportConnectors | (_[org.apache.activemq.broker.TransportConnector|#org.apache.activemq.broker.TransportConnector-types]_)\* | {html}Sets the transport connectors which this broker will listen on for new
+clients{html} |
+    | useAuthenticatedPrincipalForJMSXUserID | _boolean_ | {html}{html} |
+    | useJmx | _java.lang.String_ | {html}Sets whether or not the Broker's services should be exposed into JMX or
+not.{html} |
+    | useLocalHostBrokerName | _boolean_ | {html}{html} |
+    | useLoggingForShutdownErrors | _boolean_ | {html}Sets whether or not we should use commons-logging when reporting errors
+when shutting down the broker{html} |
+    | useMirroredQueues | _boolean_ | {html}Sets whether or not <a
+href="http://activemq.apache.org/mirrored-queues.html">Mirrored
+Queues</a> should be supported by default if they have not been
+explicitly configured.{html} |
+    | useShutdownHook | _boolean_ | {html}Sets whether or not we should use a shutdown handler to close down the
+broker cleanly if the JVM is terminated. It is recommended you leave this
+enabled.{html} |
+    | useTempMirroredQueues | _boolean_ | {html}{html} |
+    | useVirtualTopics | _boolean_ | {html}Sets whether or not <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual
+Topics</a> should be supported by default if they have not been
+explicitly configured.{html} |
+    | vmConnectorURI | _java.net.URI_ | {html}{html} |
+    | waitForSlave | _java.lang.String_ | {html}{html} |
+    | waitForSlaveTimeout | _long_ | {html}{html} |
+
+{anchor:bytesJDBCAdapter-element}
+h3. The _[<bytesJDBCAdapter>|#bytesJDBCAdapter-element]_ Element
+    {html}This JDBCAdapter inserts and extracts BLOB data using the
+setBytes()/getBytes() operations. The databases/JDBC drivers that use this
+adapter are:{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:cachedLDAPAuthorizationMap-element}
+h3. The _[<cachedLDAPAuthorizationMap>|#cachedLDAPAuthorizationMap-element]_ Element
+    {html}A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update authorization
+policy.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminPermissionGroupSearchFilter | _java.lang.String_ | {html}{html} |
+    | authentication | _java.lang.String_ | {html}{html} |
+    | authorizationEntries | (_java.lang.Object_)\* | {html}Sets the individual entries on the authorization map{html} |
+    | connectionPassword | _java.lang.String_ | {html}{html} |
+    | connectionProtocol | _java.lang.String_ | {html}{html} |
+    | connectionURL | _java.lang.String_ | {html}{html} |
+    | connectionUsername | _java.lang.String_ | {html}{html} |
+    | defaultEntry | _[org.apache.activemq.security.AuthorizationEntry|#org.apache.activemq.security.AuthorizationEntry-types]_ | {html}{html} |
+    | entries | (_java.lang.Object_)\* | {html}A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring{html} |
+    | groupNameAttribute | _java.lang.String_ | {html}{html} |
+    | groupObjectClass | _java.lang.String_ | {html}{html} |
+    | legacyGroupMapping | _boolean_ | {html}{html} |
+    | permissionGroupMemberAttribute | _java.lang.String_ | {html}{html} |
+    | queueSearchBase | _java.lang.String_ | {html}{html} |
+    | readPermissionGroupSearchFilter | _java.lang.String_ | {html}{html} |
+    | refreshDisabled | _boolean_ | {html}{html} |
+    | refreshInterval | _int_ | {html}{html} |
+    | tempDestinationAuthorizationEntry | _[org.apache.activemq.security.TempDestinationAuthorizationEntry|#org.apache.activemq.security.TempDestinationAuthorizationEntry-types]_ | {html}{html} |
+    | tempSearchBase | _java.lang.String_ | {html}{html} |
+    | topicSearchBase | _java.lang.String_ | {html}{html} |
+    | userNameAttribute | _java.lang.String_ | {html}{html} |
+    | userObjectClass | _java.lang.String_ | {html}{html} |
+    | writePermissionGroupSearchFilter | _java.lang.String_ | {html}{html} |
+
+{anchor:commandAgent-element}
+h3. The _[<commandAgent>|#commandAgent-element]_ Element
+    {html}An agent which listens to commands on a JMS destination{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerUrl | _java.lang.String_ | {html}{html} |
+    | commandDestination | _[javax.jms.Destination|#javax.jms.Destination-types]_ | {html}{html} |
+    | connection | _javax.jms.Connection_ | {html}{html} |
+    | connectionFactory | _[javax.jms.ConnectionFactory|#javax.jms.ConnectionFactory-types]_ | {html}{html} |
+    | password | _java.lang.String_ | {html}{html} |
+    | username | _java.lang.String_ | {html}{html} |
+
+{anchor:compositeDemandForwardingBridge-element}
+h3. The _[<compositeDemandForwardingBridge>|#compositeDemandForwardingBridge-element]_ Element
+    {html}A demand forwarding bridge which works with multicast style transports where
+a single Transport could be communicating with multiple remote brokers{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | configuration | _[org.apache.activemq.network.NetworkBridgeConfiguration|#org.apache.activemq.network.NetworkBridgeConfiguration-types]_ | {html}{html} |
+    | createdByDuplex | _boolean_ | {html}{html} |
+    | durableDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | dynamicallyIncludedDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | excludedDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | localBroker | _org.apache.activemq.transport.Transport_ | {html}{html} |
+    | mbeanObjectName | _javax.management.ObjectName_ | {html}{html} |
+    | networkBridgeListener | _org.apache.activemq.network.NetworkBridgeListener_ | {html}{html} |
+    | remoteBroker | _org.apache.activemq.transport.Transport_ | {html}{html} |
+    | staticallyIncludedDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+
+{anchor:compositeQueue-element}
+h3. The _[<compositeQueue>|#compositeQueue-element]_ Element
+    {html}Represents a virtual queue which forwards to a number of other destinations.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | copyMessage | _boolean_ | {html}Sets whether a copy of the message will be sent to each destination.
+Defaults to true so that the forward destination is set as the
+destination of the message{html} |
+    | forwardOnly | _boolean_ | {html}Sets if the virtual destination is forward only (and so there is no
+physical queue to match the virtual queue) or if there is also a physical
+queue with the same name).{html} |
+    | forwardTo | (_java.lang.Object_)\* | {html}Sets the list of destinations to forward to{html} |
+    | name | _java.lang.String_ | {html}Sets the name of this composite destination{html} |
+
+{anchor:compositeTopic-element}
+h3. The _[<compositeTopic>|#compositeTopic-element]_ Element
+    {html}Represents a virtual topic which forwards to a number of other destinations.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | copyMessage | _boolean_ | {html}Sets whether a copy of the message will be sent to each destination.
+Defaults to true so that the forward destination is set as the
+destination of the message{html} |
+    | forwardOnly | _boolean_ | {html}Sets if the virtual destination is forward only (and so there is no
+physical queue to match the virtual queue) or if there is also a physical
+queue with the same name).{html} |
+    | forwardTo | (_java.lang.Object_)\* | {html}Sets the list of destinations to forward to{html} |
+    | name | _java.lang.String_ | {html}Sets the name of this composite destination{html} |
+
+{anchor:conditionalNetworkBridgeFilterFactory-element}
+h3. The _[<conditionalNetworkBridgeFilterFactory>|#conditionalNetworkBridgeFilterFactory-element]_ Element
+    {html}implement conditional behaviour for queue consumers,
+allows replaying back to origin if no consumers are present on the local broker
+after a configurable delay, irrespective of the networkTTL
+Also allows rate limiting of messages through the network, useful for static includes{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | rateDuration | _int_ | {html}{html} |
+    | rateLimit | _int_ | {html}{html} |
+    | replayDelay | _int_ | {html}{html} |
+    | replayWhenNoConsumers | _boolean_ | {html}{html} |
+
+{anchor:connectionDotFilePlugin-element}
+h3. The _[<connectionDotFilePlugin>|#connectionDotFilePlugin-element]_ Element
+    {html}A <a href="http://www.graphviz.org/">DOT</a> file creator plugin which
+creates a DOT file showing the current connections{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | file | _java.lang.String_ | {html}Sets the destination file name to create the destination diagram{html} |
+
+{anchor:connectionFactory-element}
+h3. The _[<connectionFactory>|#connectionFactory-element]_ Element
+    {html}A <a href="http://www.springframework.org/">Spring</a> enhanced connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | alwaysSessionAsync | _boolean_ | {html}If this flag is not set then a separate thread is not used for dispatching messages for each Session in
+the Connection. However, a separate thread is always used if there is more than one session, or the session
+isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
+happens asynchronously.{html} |
+    | alwaysSyncSend | _boolean_ | {html}Set true if always require messages to be sync sent{html} |
+    | auditDepth | _int_ | {html}{html} |
+    | auditMaximumProducerNumber | _int_ | {html}{html} |
+    | beanName | _java.lang.String_ | {html}{html} |
+    | blobTransferPolicy | _org.apache.activemq.blob.BlobTransferPolicy_ | {html}Sets the policy used to describe how out-of-band BLOBs (Binary Large
+OBjects) are transferred from producers to brokers to consumers{html} |
+    | brokerURL | _java.lang.String_ | {html}Sets the <a
+href="http://activemq.apache.org/configuring-transports.html">connection
+URL</a> used to connect to the ActiveMQ broker.{html} |
+    | checkForDuplicates | _boolean_ | {html}{html} |
+    | clientID | _java.lang.String_ | {html}Sets the JMS clientID to use for the created connection. Note that this
+can only be used by one connection at once so generally its a better idea
+to set the clientID on a Connection{html} |
+    | clientIDPrefix | _java.lang.String_ | {html}Sets the prefix used by autogenerated JMS Client ID values which are used
+if the JMS client does not explicitly specify on.{html} |
+    | clientIdGenerator | _org.apache.activemq.util.IdGenerator_ | {html}{html} |
+    | clientInternalExceptionListener | _org.apache.activemq.ClientInternalExceptionListener_ | {html}Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory){html} |
+    | closeTimeout | _int_ | {html}Sets the timeout before a close is considered complete. Normally a
+close() on a connection waits for confirmation from the broker; this
+allows that operation to timeout to save the client hanging if there is
+no broker{html} |
+    | connectionIDPrefix | _java.lang.String_ | {html}Sets the prefix used by connection id generator{html} |
+    | connectionIdGenerator | _org.apache.activemq.util.IdGenerator_ | {html}{html} |
+    | consumerFailoverRedeliveryWaitPeriod | _long_ | {html}{html} |
+    | copyMessageOnSend | _boolean_ | {html}Should a JMS message be copied to a new JMS Message object as part of the
+send() method in JMS. This is enabled by default to be compliant with the
+JMS specification. You can disable it if you do not mutate JMS messages
+after they are sent for a performance boost{html} |
+    | disableTimeStampsByDefault | _boolean_ | {html}Sets whether or not timestamps on messages should be disabled or not. If
+you disable them it adds a small performance boost.{html} |
+    | dispatchAsync | _boolean_ | {html}Enables or disables the default setting of whether or not consumers have
+their messages <a
+href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
+synchronously or asynchronously by the broker</a>. For non-durable
+topics for example we typically dispatch synchronously by default to
+minimize context switches which boost performance. However sometimes its
+better to go slower to ensure that a single blocked consumer socket does
+not block delivery to other consumers.{html} |
+    | exceptionListener | _[javax.jms.ExceptionListener|#javax.jms.ExceptionListener-types]_ | {html}Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory){html} |
+    | exclusiveConsumer | _boolean_ | {html}Enables or disables whether or not queue consumers should be exclusive or
+not for example to preserve ordering when not using <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a>{html} |
+    | maxThreadPoolSize | _int_ | {html}{html} |
+    | messagePrioritySupported | _boolean_ | {html}{html} |
+    | nestedMapAndListEnabled | _boolean_ | {html}Enables/disables whether or not Message properties and MapMessage entries
+support <a
+href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
+Structures</a> of Map and List objects{html} |
+    | nonBlockingRedelivery | _boolean_ | {html}When true a MessageConsumer will not stop Message delivery before re-delivering Messages
+from a rolled back transaction.  This implies that message order will not be preserved and
+also will result in the TransactedIndividualAck option to be enabled.{html} |
+    | objectMessageSerializationDefered | _boolean_ | {html}When an object is set on an ObjectMessage, the JMS spec requires the
+object to be serialized by that set method. Enabling this flag causes the
+object to not get serialized. The object may subsequently get serialized
+if the message needs to be sent over a socket or stored to disk.{html} |
+    | optimizeAcknowledge | _boolean_ | {html}{html} |
+    | optimizeAcknowledgeTimeOut | _long_ | {html}The max time in milliseconds between optimized ack batches{html} |
+    | optimizedAckScheduledAckInterval | _long_ | {html}Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
+to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
+will not do any background Message acknowledgment.{html} |
+    | optimizedMessageDispatch | _boolean_ | {html}If this flag is set then an larger prefetch limit is used - only
+applicable for durable topic subscribers.{html} |
+    | password | _java.lang.String_ | {html}Sets the JMS password used for connections created from this factory{html} |
+    | prefetchPolicy | _[org.apache.activemq.ActiveMQPrefetchPolicy|#org.apache.activemq.ActiveMQPrefetchPolicy-types]_ | {html}Sets the <a
+href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
+policy</a> for consumers created by this connection.{html} |
+    | producerWindowSize | _int_ | {html}{html} |
+    | properties | _java.util.Properties_ | {html}Get the properties from this instance for storing in JNDI{html} |
+    | redeliveryPolicy | _[org.apache.activemq.RedeliveryPolicy|#org.apache.activemq.RedeliveryPolicy-types]_ | {html}Sets the global default redelivery policy to be used when a message is delivered
+but the session is rolled back{html} |
+    | redeliveryPolicyMap | _[org.apache.activemq.broker.region.policy.RedeliveryPolicyMap|#org.apache.activemq.broker.region.policy.RedeliveryPolicyMap-types]_ | {html}Sets the global redelivery policy mapping to be used when a message is delivered
+but the session is rolled back{html} |
+    | rejectedTaskHandler | _java.util.concurrent.RejectedExecutionHandler_ | {html}{html} |
+    | sendAcksAsync | _boolean_ | {html}{html} |
+    | sendTimeout | _int_ | {html}{html} |
+    | sessionTaskRunner | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | statsEnabled | _boolean_ | {html}{html} |
+    | transactedIndividualAck | _boolean_ | {html}when true, submit individual transacted acks immediately rather than with transaction completion.
+This allows the acks to represent delivery status which can be persisted on rollback
+Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true{html} |
+    | transformer | _org.apache.activemq.MessageTransformer_ | {html}Sets the transformer used to transform messages before they are sent on
+to the JMS bus or when they are received from the bus but before they are
+delivered to the JMS client{html} |
+    | transportListener | _org.apache.activemq.transport.TransportListener_ | {html}Allows a listener to be configured on the ConnectionFactory so that when this factory is used
+with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
+a transport listener.{html} |
+    | useAsyncSend | _boolean_ | {html}Forces the use of <a
+href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
+adds a massive performance boost; but means that the send() method will
+return immediately whether the message has been sent or not which could
+lead to message loss.{html} |
+    | useBeanNameAsClientIdPrefix | _boolean_ | {html}{html} |
+    | useCompression | _boolean_ | {html}Enables the use of compression of the message bodies{html} |
+    | useDedicatedTaskRunner | _boolean_ | {html}{html} |
+    | useRetroactiveConsumer | _boolean_ | {html}Sets whether or not retroactive consumers are enabled. Retroactive
+consumers allow non-durable topic subscribers to receive old messages
+that were published before the non-durable subscriber started.{html} |
+    | userName | _java.lang.String_ | {html}Sets the JMS userName used by connections created by this factory{html} |
+    | warnAboutUnstartedConnectionTimeout | _long_ | {html}Enables the timeout from a connection creation to when a warning is
+generated if the connection is not properly started via
+{@link Connection#start()} and a message is received by a consumer. It is
+a very common gotcha to forget to <a
+href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
+the connection</a> so this option makes the default case to create a
+warning if the user forgets. To disable the warning just set the value to <
+0 (say -1).{html} |
+    | watchTopicAdvisories | _boolean_ | {html}{html} |
+
+{anchor:constantPendingMessageLimitStrategy-element}
+h3. The _[<constantPendingMessageLimitStrategy>|#constantPendingMessageLimitStrategy-element]_ Element
+    {html}This PendingMessageLimitStrategy is configured to a constant value for all subscriptions.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | limit | _int_ | {html}{html} |
+
+{anchor:database-locker-element}
+h3. The _[<database-locker>|#database-locker-element]_ Element
+    {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | exceptionHandler | _org.apache.activemq.util.Handler_ | {html}{html} |
+    | failIfLocked | _boolean_ | {html}{html} |
+    | lockAcquireSleepInterval | _long_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | queryTimeout | _int_ | {html}{html} |
+
+{anchor:db2JDBCAdapter-element}
+h3. The _[<db2JDBCAdapter>|#db2JDBCAdapter-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:defaultIOExceptionHandler-element}
+h3. The _[<defaultIOExceptionHandler>|#defaultIOExceptionHandler-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | ignoreAllErrors | _boolean_ | {html}{html} |
+    | ignoreNoSpaceErrors | _boolean_ | {html}{html} |
+    | ignoreSQLExceptions | _boolean_ | {html}{html} |
+    | noSpaceMessage | _java.lang.String_ | {html}{html} |
+    | resumeCheckSleepPeriod | _long_ | {html}{html} |
+    | sqlExceptionMessage | _java.lang.String_ | {html}{html} |
+    | stopStartConnectors | _boolean_ | {html}{html} |
+
+{anchor:defaultJDBCAdapter-element}
+h3. The _[<defaultJDBCAdapter>|#defaultJDBCAdapter-element]_ Element
+    {html}Implements all the default JDBC operations that are used by the JDBCPersistenceAdapter. <p/> sub-classing is
+encouraged to override the default implementation of methods to account for differences in JDBC Driver
+implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using the getBytes()/setBytes() operations. <p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:defaultNetworkBridgeFilterFactory-element}
+h3. The _[<defaultNetworkBridgeFilterFactory>|#defaultNetworkBridgeFilterFactory-element]_ Element
+    {html}implement default behaviour, filter that will not allow resend to origin
+based on brokerPath and which respects networkTTL{html}
+
+{anchor:defaultUsageCapacity-element}
+h3. The _[<defaultUsageCapacity>|#defaultUsageCapacity-element]_ Element
+    {html}Identify if a limit has been reached{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | limit | _long_ | {html}{html} |
+
+{anchor:demandForwardingBridge-element}
+h3. The _[<demandForwardingBridge>|#demandForwardingBridge-element]_ Element
+    {html}Forwards messages from the local broker to the remote broker based on demand.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | configuration | _[org.apache.activemq.network.NetworkBridgeConfiguration|#org.apache.activemq.network.NetworkBridgeConfiguration-types]_ | {html}{html} |
+    | createdByDuplex | _boolean_ | {html}{html} |
+    | durableDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | dynamicallyIncludedDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | excludedDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | localBroker | _org.apache.activemq.transport.Transport_ | {html}{html} |
+    | mbeanObjectName | _javax.management.ObjectName_ | {html}{html} |
+    | networkBridgeListener | _org.apache.activemq.network.NetworkBridgeListener_ | {html}{html} |
+    | remoteBroker | _org.apache.activemq.transport.Transport_ | {html}{html} |
+    | staticallyIncludedDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+
+{anchor:destinationDotFilePlugin-element}
+h3. The _[<destinationDotFilePlugin>|#destinationDotFilePlugin-element]_ Element
+    {html}A <a href="http://www.graphviz.org/">DOT</a> 
+file creator plugin which creates a DOT file showing the current topic & queue hierarchies.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | file | _java.lang.String_ | {html}Sets the destination file name to create the destination diagram{html} |
+
+{anchor:destinationEntry-element}
+h3. The _[<destinationEntry>|#destinationEntry-element]_ Element
+    {html}A default entry in a DestinationMap which holds a single value.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | destination | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}{html} |
+    | queue | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | tempQueue | _boolean_ | {html}{html} |
+    | tempTopic | _boolean_ | {html}{html} |
+    | topic | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | value | _[org.apache.activemq.filter.DestinationMapEntry|#org.apache.activemq.filter.DestinationMapEntry-types]_ | {html}{html} |
+
+{anchor:destinationPathSeparatorPlugin-element}
+h3. The _[<destinationPathSeparatorPlugin>|#destinationPathSeparatorPlugin-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminConnectionContext | _org.apache.activemq.broker.ConnectionContext_ | {html}{html} |
+    | next | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | pathSeparator | _java.lang.String_ | {html}{html} |
+
+{anchor:discardingDLQBrokerPlugin-element}
+h3. The _[<discardingDLQBrokerPlugin>|#discardingDLQBrokerPlugin-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | dropAll | _boolean_ | {html}{html} |
+    | dropOnly | _java.lang.String_ | {html}{html} |
+    | dropTemporaryQueues | _boolean_ | {html}{html} |
+    | dropTemporaryTopics | _boolean_ | {html}{html} |
+    | reportInterval | _int_ | {html}{html} |
+
+{anchor:fileCursor-element}
+h3. The _[<fileCursor>|#fileCursor-element]_ Element
+    {html}Pending messages{html}
+
+{anchor:fileDurableSubscriberCursor-element}
+h3. The _[<fileDurableSubscriberCursor>|#fileDurableSubscriberCursor-element]_ Element
+    {html}Pending messages for durable subscribers{html}
+
+{anchor:fileQueueCursor-element}
+h3. The _[<fileQueueCursor>|#fileQueueCursor-element]_ Element
+    {html}Pending{html}
+
+{anchor:filteredDestination-element}
+h3. The _[<filteredDestination>|#filteredDestination-element]_ Element
+    {html}Represents a destination which is filtered using some predicate such as a selector
+so that messages are only dispatched to the destination if they match the filter.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | destination | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}The destination to send messages to if they match the filter{html} |
+    | filter | _org.apache.activemq.filter.BooleanExpression_ | {html}{html} |
+    | queue | _java.lang.String_ | {html}Sets the destination property to the given queue name{html} |
+    | selector | _java.lang.String_ | {html}Sets the JMS selector used to filter messages before forwarding them to this destination{html} |
+    | topic | _java.lang.String_ | {html}Sets the destination property to the given topic name{html} |
+
+{anchor:filteredKahaDB-element}
+h3. The _[<filteredKahaDB>|#filteredKahaDB-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adapter | _[org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter|#org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter-types]_ | {html}{html} |
+    | destination | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}{html} |
+    | perDestination | _boolean_ | {html}{html} |
+    | persistenceAdapter | _[org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter|#org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter-types]_ | {html}{html} |
+    | queue | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | tempQueue | _boolean_ | {html}{html} |
+    | tempTopic | _boolean_ | {html}{html} |
+    | topic | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+
+{anchor:fixedCountSubscriptionRecoveryPolicy-element}
+h3. The _[<fixedCountSubscriptionRecoveryPolicy>|#fixedCountSubscriptionRecoveryPolicy-element]_ Element
+    {html}This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+count of last messages.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | broker | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | maximumSize | _int_ | {html}Sets the maximum number of messages that this destination will hold
+around in RAM{html} |
+
+{anchor:fixedSizedSubscriptionRecoveryPolicy-element}
+h3. The _[<fixedSizedSubscriptionRecoveryPolicy>|#fixedSizedSubscriptionRecoveryPolicy-element]_ Element
+    {html}This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+amount of memory available in RAM for message history which is evicted in
+time order.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | broker | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | buffer | _org.apache.activemq.memory.list.MessageList_ | {html}{html} |
+    | maximumSize | _int_ | {html}Sets the maximum amount of RAM in bytes that this buffer can hold in RAM{html} |
+    | useSharedBuffer | _boolean_ | {html}{html} |
+
+{anchor:forcePersistencyModeBroker-element}
+h3. The _[<forcePersistencyModeBroker>|#forcePersistencyModeBroker-element]_ Element
+    {html}A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminConnectionContext | _org.apache.activemq.broker.ConnectionContext_ | {html}{html} |
+    | next | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | persistenceFlag | _boolean_ | {html}{html} |
+
+{anchor:forcePersistencyModeBrokerPlugin-element}
+h3. The _[<forcePersistencyModeBrokerPlugin>|#forcePersistencyModeBrokerPlugin-element]_ Element
+    {html}A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | persistenceFlag | _boolean_ | {html}Sets the persistency mode.{html} |
+
+{anchor:forwardingBridge-element}
+h3. The _[<forwardingBridge>|#forwardingBridge-element]_ Element
+    {html}Forwards all messages from the local broker to the remote broker.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | clientId | _java.lang.String_ | {html}{html} |
+    | destinationFilter | _java.lang.String_ | {html}{html} |
+    | dispatchAsync | _boolean_ | {html}{html} |
+    | localBroker | _org.apache.activemq.transport.Transport_ | {html}{html} |
+    | networkBridgeFailedListener | _org.apache.activemq.network.NetworkBridgeListener_ | {html}{html} |
+    | prefetchSize | _int_ | {html}{html} |
+    | remoteBroker | _org.apache.activemq.transport.Transport_ | {html}{html} |
+    | useCompression | _boolean_ | {html}{html} |
+
+{anchor:hsqldb-jdbc-adapter-element}
+h3. The _[<hsqldb-jdbc-adapter>|#hsqldb-jdbc-adapter-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:imageBasedJDBCAdaptor-element}
+h3. The _[<imageBasedJDBCAdaptor>|#imageBasedJDBCAdaptor-element]_ Element
+    {html}Provides JDBCAdapter since that uses
+IMAGE datatype to hold binary data.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Sybase</li>
+<li>MS SQL</li>
+</ul>{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:inboundQueueBridge-element}
+h3. The _[<inboundQueueBridge>|#inboundQueueBridge-element]_ Element
+    {html}Create an Inbound Queue Bridge.  By default this class uses the sname name for
+both the inbound and outbound queue.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud queue names
+separately.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | consumer | _javax.jms.MessageConsumer_ | {html}{html} |
+    | consumerConnection | _javax.jms.QueueConnection_ | {html}{html} |
+    | consumerQueue | _[javax.jms.Queue|#javax.jms.Queue-types]_ | {html}{html} |
+    | doHandleReplyTo | _boolean_ | {html}{html} |
+    | inboundQueueName | _java.lang.String_ | {html}Sets the queue name used for the inbound queue, if the outbound queue
+name has not been set, then this method uses the same name to configure
+the outbound queue name.{html} |
+    | jmsConnector | _[org.apache.activemq.network.jms.JmsConnector|#org.apache.activemq.network.jms.JmsConnector-types]_ | {html}{html} |
+    | jmsMessageConvertor | _[org.apache.activemq.network.jms.JmsMesageConvertor|#org.apache.activemq.network.jms.JmsMesageConvertor-types]_ | {html}{html} |
+    | localQueueName | _java.lang.String_ | {html}{html} |
+    | producerConnection | _javax.jms.QueueConnection_ | {html}{html} |
+    | producerQueue | _[javax.jms.Queue|#javax.jms.Queue-types]_ | {html}{html} |
+    | selector | _java.lang.String_ | {html}{html} |
+
+{anchor:inboundTopicBridge-element}
+h3. The _[<inboundTopicBridge>|#inboundTopicBridge-element]_ Element
+    {html}Create an Inbound Topic Bridge.  By default this class uses the topic name for
+both the inbound and outbound topic.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud topic names
+separately.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | consumer | _javax.jms.MessageConsumer_ | {html}{html} |
+    | consumerConnection | _javax.jms.TopicConnection_ | {html}{html} |
+    | consumerName | _java.lang.String_ | {html}{html} |
+    | consumerTopic | _[javax.jms.Topic|#javax.jms.Topic-types]_ | {html}{html} |
+    | doHandleReplyTo | _boolean_ | {html}{html} |
+    | inboundTopicName | _java.lang.String_ | {html}Sets the topic name used for the inbound topic, if the outbound topic
+name has not been set, then this method uses the same name to configure
+the outbound topic name.{html} |
+    | jmsConnector | _[org.apache.activemq.network.jms.JmsConnector|#org.apache.activemq.network.jms.JmsConnector-types]_ | {html}{html} |
+    | jmsMessageConvertor | _[org.apache.activemq.network.jms.JmsMesageConvertor|#org.apache.activemq.network.jms.JmsMesageConvertor-types]_ | {html}{html} |
+    | localTopicName | _java.lang.String_ | {html}{html} |
+    | producerConnection | _javax.jms.TopicConnection_ | {html}{html} |
+    | producerTopic | _[javax.jms.Topic|#javax.jms.Topic-types]_ | {html}{html} |
+    | selector | _java.lang.String_ | {html}{html} |
+
+{anchor:individualDeadLetterStrategy-element}
+h3. The _[<individualDeadLetterStrategy>|#individualDeadLetterStrategy-element]_ Element
+    {html}A {@link DeadLetterStrategy} where each destination has its own individual
+DLQ using the subject naming hierarchy.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | destinationPerDurableSubscriber | _boolean_ | {html}sets whether durable topic subscriptions are to get individual dead letter destinations.
+When true, the DLQ is of the form 'topicPrefix.clientId:subscriptionName'
+The default is false.{html} |
+    | enableAudit | _boolean_ | {html}{html} |
+    | processExpired | _boolean_ | {html}{html} |
+    | processNonPersistent | _boolean_ | {html}{html} |
+    | queuePrefix | _java.lang.String_ | {html}Sets the prefix to use for all dead letter queues for queue messages{html} |
+    | queueSuffix | _java.lang.String_ | {html}Sets the suffix to use for all dead letter queues for queue messages{html} |
+    | topicPrefix | _java.lang.String_ | {html}Sets the prefix to use for all dead letter queues for topic messages{html} |
+    | topicSuffix | _java.lang.String_ | {html}Sets the suffix to use for all dead letter queues for topic messages{html} |
+    | useQueueForQueueMessages | _boolean_ | {html}Sets whether a queue or topic should be used for queue messages sent to a
+DLQ. The default is to use a Queue{html} |
+    | useQueueForTopicMessages | _boolean_ | {html}Sets whether a queue or topic should be used for topic messages sent to a
+DLQ. The default is to use a Queue{html} |
+
+{anchor:informixJDBCAdapter-element}
+h3. The _[<informixJDBCAdapter>|#informixJDBCAdapter-element]_ Element
+    {html}JDBC Adapter for Informix database.
+Because Informix database restricts length of composite primary keys, length of 
+<i>container name</i> field and <i>subscription id</i> field must be reduced to 150 characters.
+Therefore be sure not to use longer names for container name and subscription id than 150 characters.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:jDBCIOExceptionHandler-element}
+h3. The _[<jDBCIOExceptionHandler>|#jDBCIOExceptionHandler-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | ignoreAllErrors | _boolean_ | {html}{html} |
+    | ignoreNoSpaceErrors | _boolean_ | {html}{html} |
+    | ignoreSQLExceptions | _boolean_ | {html}{html} |
+    | noSpaceMessage | _java.lang.String_ | {html}{html} |
+    | resumeCheckSleepPeriod | _long_ | {html}{html} |
+    | sqlExceptionMessage | _java.lang.String_ | {html}{html} |
+    | stopStartConnectors | _boolean_ | {html}{html} |
+
+{anchor:jaasAuthenticationPlugin-element}
+h3. The _[<jaasAuthenticationPlugin>|#jaasAuthenticationPlugin-element]_ Element
+    {html}Provides a JAAS based authentication plugin{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | configuration | _java.lang.String_ | {html}Sets the JAAS configuration domain name used{html} |
+    | discoverLoginConfig | _boolean_ | {html}Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
+This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
+is not defined then it is set to the location of the <b>login.config</b> file on the classpath.{html} |
+
+{anchor:jaasCertificateAuthenticationPlugin-element}
+h3. The _[<jaasCertificateAuthenticationPlugin>|#jaasCertificateAuthenticationPlugin-element]_ Element
+    {html}Provides a JAAS based SSL certificate authentication plugin{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | configuration | _java.lang.String_ | {html}Sets the JAAS configuration domain name used{html} |
+    | discoverLoginConfig | _boolean_ | {html}Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
+This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
+is not defined then it is set to the location of the <b>login.config</b> file on the classpath.{html} |
+
+{anchor:jaasDualAuthenticationPlugin-element}
+h3. The _[<jaasDualAuthenticationPlugin>|#jaasDualAuthenticationPlugin-element]_ Element
+    {html}Provides a JAAS based authentication plugin{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | configuration | _java.lang.String_ | {html}Sets the JAAS configuration domain name used{html} |
+    | discoverLoginConfig | _boolean_ | {html}Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
+This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
+is not defined then it is set to the location of the <b>login.config</b> file on the classpath.{html} |
+    | sslConfiguration | _java.lang.String_ | {html}Set the JAAS SSL configuration domain{html} |
+
+{anchor:jdbcPersistenceAdapter-element}
+h3. The _[<jdbcPersistenceAdapter>|#jdbcPersistenceAdapter-element]_ Element
+    {html}A {@link PersistenceAdapter} implementation using JDBC for persistence
+storage.
+
+This persistence adapter will correctly remember prepared XA transactions,
+but it will not keep track of local transaction commits so that operations
+performed against the Message store are done as a single uow.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adapter | _[org.apache.activemq.store.jdbc.JDBCAdapter|#org.apache.activemq.store.jdbc.JDBCAdapter-types]_ | {html}{html} |
+    | auditRecoveryDepth | _int_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | cleanupPeriod | _int_ | {html}Sets the number of milliseconds until the database is attempted to be
+cleaned up for durable topics{html} |
+    | createTablesOnStartup | _boolean_ | {html}Sets whether or not tables are created on startup{html} |
+    | dataDirectory | _java.lang.String_ | {html}{html} |
+    | dataDirectoryFile | _java.io.File_ | {html}{html} |
+    | dataSource | _javax.sql.DataSource_ | {html}{html} |
+    | databaseLocker | _[org.apache.activemq.broker.Locker|#org.apache.activemq.broker.Locker-types]_ | {html}Sets the database locker strategy to use to lock the database on startup{html} |
+    | directory | _java.io.File_ | {html}{html} |
+    | ds | _javax.sql.DataSource_ | {html}{html} |
+    | enableAudit | _boolean_ | {html}{html} |
+    | lockAcquireSleepInterval | _long_ | {html}{html} |
+    | lockDataSource | _javax.sql.DataSource_ | {html}{html} |
+    | lockKeepAlivePeriod | _long_ | {html}{html} |
+    | locker | _[org.apache.activemq.broker.Locker|#org.apache.activemq.broker.Locker-types]_ | {html}{html} |
+    | maxAuditDepth | _int_ | {html}{html} |
+    | maxProducersToAudit | _int_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | scheduledThreadPoolExecutor | _java.util.concurrent.ScheduledThreadPoolExecutor_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | transactionIsolation | _int_ | {html}set the Transaction isolation level to something other that TRANSACTION_READ_UNCOMMITTED
+This allowable dirty isolation level may not be achievable in clustered DB environments
+so a more restrictive and expensive option may be needed like TRANSACTION_REPEATABLE_READ
+see isolation level constants in {@link java.sql.Connection}{html} |
+    | usageManager | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | useDatabaseLock | _boolean_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+    | useLock | _boolean_ | {html}{html} |
+    | wireFormat | _org.apache.activemq.wireformat.WireFormat_ | {html}{html} |
+
+{anchor:jmsQueueConnector-element}
+h3. The _[<jmsQueueConnector>|#jmsQueueConnector-element]_ Element
+    {html}A Bridge to other JMS Queue providers{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}One way to configure the local connection - this is called by The
+BrokerService when the Connector is embedded{html} |
+    | inboundMessageConvertor | _[org.apache.activemq.network.jms.JmsMesageConvertor|#org.apache.activemq.network.jms.JmsMesageConvertor-types]_ | {html}{html} |
+    | inboundQueueBridges | (_[org.apache.activemq.network.jms.InboundQueueBridge|#org.apache.activemq.network.jms.InboundQueueBridge-types]_)\* | {html}{html} |
+    | jndiLocalTemplate | _org.springframework.jndi.JndiTemplate_ | {html}{html} |
+    | jndiOutboundTemplate | _org.springframework.jndi.JndiTemplate_ | {html}{html} |
+    | localClientId | _java.lang.String_ | {html}{html} |
+    | localConnectionFactoryName | _java.lang.String_ | {html}{html} |
+    | localPassword | _java.lang.String_ | {html}{html} |
+    | localQueueConnection | _javax.jms.QueueConnection_ | {html}{html} |
+    | localQueueConnectionFactory | _[javax.jms.QueueConnectionFactory|#javax.jms.QueueConnectionFactory-types]_ | {html}{html} |
+    | localUsername | _java.lang.String_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | outboundClientId | _java.lang.String_ | {html}{html} |
+    | outboundMessageConvertor | _[org.apache.activemq.network.jms.JmsMesageConvertor|#org.apache.activemq.network.jms.JmsMesageConvertor-types]_ | {html}{html} |
+    | outboundPassword | _java.lang.String_ | {html}{html} |
+    | outboundQueueBridges | (_[org.apache.activemq.network.jms.OutboundQueueBridge|#org.apache.activemq.network.jms.OutboundQueueBridge-types]_)\* | {html}{html} |
+    | outboundQueueConnection | _javax.jms.QueueConnection_ | {html}{html} |
+    | outboundQueueConnectionFactory | _[javax.jms.QueueConnectionFactory|#javax.jms.QueueConnectionFactory-types]_ | {html}{html} |
+    | outboundQueueConnectionFactoryName | _java.lang.String_ | {html}{html} |
+    | outboundUsername | _java.lang.String_ | {html}{html} |
+    | preferJndiDestinationLookup | _boolean_ | {html}Sets whether the connector should prefer to first try to find a destination in JNDI before
+using JMS semantics to create a Destination.  By default the connector will first use JMS
+semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
+ordering.{html} |
+    | reconnectionPolicy | _[org.apache.activemq.network.jms.ReconnectionPolicy|#org.apache.activemq.network.jms.ReconnectionPolicy-types]_ | {html}{html} |
+    | replyToDestinationCacheSize | _int_ | {html}{html} |
+
+{anchor:jmsTopicConnector-element}
+h3. The _[<jmsTopicConnector>|#jmsTopicConnector-element]_ Element
+    {html}A Bridge to other JMS Topic providers{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}One way to configure the local connection - this is called by The
+BrokerService when the Connector is embedded{html} |
+    | inboundMessageConvertor | _[org.apache.activemq.network.jms.JmsMesageConvertor|#org.apache.activemq.network.jms.JmsMesageConvertor-types]_ | {html}{html} |
+    | inboundTopicBridges | (_[org.apache.activemq.network.jms.InboundTopicBridge|#org.apache.activemq.network.jms.InboundTopicBridge-types]_)\* | {html}{html} |
+    | jndiLocalTemplate | _org.springframework.jndi.JndiTemplate_ | {html}{html} |
+    | jndiOutboundTemplate | _org.springframework.jndi.JndiTemplate_ | {html}{html} |
+    | localClientId | _java.lang.String_ | {html}{html} |
+    | localConnectionFactoryName | _java.lang.String_ | {html}{html} |
+    | localPassword | _java.lang.String_ | {html}{html} |
+    | localTopicConnection | _javax.jms.TopicConnection_ | {html}{html} |
+    | localTopicConnectionFactory | _[javax.jms.TopicConnectionFactory|#javax.jms.TopicConnectionFactory-types]_ | {html}{html} |
+    | localUsername | _java.lang.String_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | outboundClientId | _java.lang.String_ | {html}{html} |
+    | outboundMessageConvertor | _[org.apache.activemq.network.jms.JmsMesageConvertor|#org.apache.activemq.network.jms.JmsMesageConvertor-types]_ | {html}{html} |
+    | outboundPassword | _java.lang.String_ | {html}{html} |
+    | outboundTopicBridges | (_[org.apache.activemq.network.jms.OutboundTopicBridge|#org.apache.activemq.network.jms.OutboundTopicBridge-types]_)\* | {html}{html} |
+    | outboundTopicConnection | _javax.jms.TopicConnection_ | {html}{html} |
+    | outboundTopicConnectionFactory | _[javax.jms.TopicConnectionFactory|#javax.jms.TopicConnectionFactory-types]_ | {html}{html} |
+    | outboundTopicConnectionFactoryName | _java.lang.String_ | {html}{html} |
+    | outboundUsername | _java.lang.String_ | {html}{html} |
+    | preferJndiDestinationLookup | _boolean_ | {html}Sets whether the connector should prefer to first try to find a destination in JNDI before
+using JMS semantics to create a Destination.  By default the connector will first use JMS
+semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
+ordering.{html} |
+    | reconnectionPolicy | _[org.apache.activemq.network.jms.ReconnectionPolicy|#org.apache.activemq.network.jms.ReconnectionPolicy-types]_ | {html}{html} |
+    | replyToDestinationCacheSize | _int_ | {html}{html} |
+
+{anchor:journalPersistenceAdapter-element}
+h3. The _[<journalPersistenceAdapter>|#journalPersistenceAdapter-element]_ Element
+    {html}An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | directory | _java.io.File_ | {html}{html} |
+    | journal | _org.apache.activeio.journal.Journal_ | {html}{html} |
+    | longTermPersistence | _[org.apache.activemq.store.PersistenceAdapter|#org.apache.activemq.store.PersistenceAdapter-types]_ | {html}{html} |
+    | maxCheckpointMessageAddSize | _int_ | {html}{html} |
+    | maxCheckpointWorkers | _int_ | {html}{html} |
+    | persistenceAdapter | _[org.apache.activemq.store.PersistenceAdapter|#org.apache.activemq.store.PersistenceAdapter-types]_ | {html}{html} |
+    | taskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | usageManager | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:journalPersistenceAdapterFactory-element}
+h3. The _[<journalPersistenceAdapterFactory>|#journalPersistenceAdapterFactory-element]_ Element
+    {html}Factory class that can create PersistenceAdapter objects.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adapter | _[org.apache.activemq.store.jdbc.JDBCAdapter|#org.apache.activemq.store.jdbc.JDBCAdapter-types]_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | createTablesOnStartup | _boolean_ | {html}Sets whether or not tables are created on startup{html} |
+    | dataDirectory | _java.lang.String_ | {html}{html} |
+    | dataDirectoryFile | _java.io.File_ | {html}{html} |
+    | dataSource | _javax.sql.DataSource_ | {html}{html} |
+    | jdbcAdapter | _[org.apache.activemq.store.jdbc.JDBCPersistenceAdapter|#org.apache.activemq.store.jdbc.JDBCPersistenceAdapter-types]_ | {html}{html} |
+    | journal | _org.apache.activeio.journal.Journal_ | {html}{html} |
+    | journalArchiveDirectory | _java.io.File_ | {html}{html} |
+    | journalLogFileSize | _java.lang.String_ | {html}Sets the size of the journal log files
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | journalLogFiles | _int_ | {html}Sets the number of journal log files to use{html} |
+    | journalThreadPriority | _int_ | {html}Sets the thread priority of the journal thread{html} |
+    | lockKeepAlivePeriod | _long_ | {html}{html} |
+    | locker | _[org.apache.activemq.broker.Locker|#org.apache.activemq.broker.Locker-types]_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | taskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | useDatabaseLock | _boolean_ | {html}Sets whether or not an exclusive database lock should be used to enable
+JDBC Master/Slave. Enabled by default.{html} |
+    | useDedicatedTaskRunner | _boolean_ | {html}{html} |
+    | useJournal | _boolean_ | {html}Enables or disables the use of the journal. The default is to use the
+journal{html} |
+    | useLock | _boolean_ | {html}{html} |
+    | useQuickJournal | _boolean_ | {html}Enables or disables the use of quick journal, which keeps messages in the
+journal and just stores a reference to the messages in JDBC. Defaults to
+false so that messages actually reside long term in the JDBC database.{html} |
+
+{anchor:journaledJDBC-element}
+h3. The _[<journaledJDBC>|#journaledJDBC-element]_ Element
+    {html}Creates a default persistence model using the Journal and JDBC{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adapter | _[org.apache.activemq.store.jdbc.JDBCAdapter|#org.apache.activemq.store.jdbc.JDBCAdapter-types]_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | createTablesOnStartup | _boolean_ | {html}Sets whether or not tables are created on startup{html} |
+    | dataDirectory | _java.lang.String_ | {html}{html} |
+    | dataDirectoryFile | _java.io.File_ | {html}{html} |
+    | dataSource | _javax.sql.DataSource_ | {html}{html} |
+    | jdbcAdapter | _[org.apache.activemq.store.jdbc.JDBCPersistenceAdapter|#org.apache.activemq.store.jdbc.JDBCPersistenceAdapter-types]_ | {html}{html} |
+    | journal | _org.apache.activeio.journal.Journal_ | {html}{html} |
+    | journalArchiveDirectory | _java.io.File_ | {html}{html} |
+    | journalLogFileSize | _java.lang.String_ | {html}Sets the size of the journal log files
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | journalLogFiles | _int_ | {html}Sets the number of journal log files to use{html} |
+    | journalThreadPriority | _int_ | {html}Sets the thread priority of the journal thread{html} |
+    | lockKeepAlivePeriod | _long_ | {html}{html} |
+    | locker | _[org.apache.activemq.broker.Locker|#org.apache.activemq.broker.Locker-types]_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | taskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | useDatabaseLock | _boolean_ | {html}Sets whether or not an exclusive database lock should be used to enable
+JDBC Master/Slave. Enabled by default.{html} |
+    | useDedicatedTaskRunner | _boolean_ | {html}{html} |
+    | useJournal | _boolean_ | {html}Enables or disables the use of the journal. The default is to use the
+journal{html} |
+    | useLock | _boolean_ | {html}{html} |
+    | useQuickJournal | _boolean_ | {html}Enables or disables the use of quick journal, which keeps messages in the
+journal and just stores a reference to the messages in JDBC. Defaults to
+false so that messages actually reside long term in the JDBC database.{html} |
+
+{anchor:kahaDB-element}
+h3. The _[<kahaDB>|#kahaDB-element]_ Element
+    {html}An implementation of {@link PersistenceAdapter} designed for use with
+KahaDB - Embedded Lightweight Non-Relational Database{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | archiveCorruptedIndex | _boolean_ | {html}{html} |
+    | archiveDataLogs | _boolean_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | checkForCorruptJournalFiles | _boolean_ | {html}{html} |
+    | checkpointInterval | _long_ | {html}Get the checkpointInterval{html} |
+    | checksumJournalFiles | _boolean_ | {html}{html} |
+    | cleanupInterval | _long_ | {html}Get the cleanupInterval{html} |
+    | concurrentStoreAndDispatchQueues | _boolean_ | {html}{html} |
+    | concurrentStoreAndDispatchTopics | _boolean_ | {html}{html} |
+    | databaseLockedWaitDelay | _int_ | {html}{html} |
+    | directory | _java.io.File_ | {html}Get the directory{html} |
+    | directoryArchive | _java.io.File_ | {html}{html} |
+    | enableIndexDiskSyncs | _boolean_ | {html}{html} |
+    | enableIndexPageCaching | _boolean_ | {html}{html} |
+    | enableIndexRecoveryFile | _boolean_ | {html}{html} |
+    | enableIndexWriteAsync | _boolean_ | {html}Get the enableIndexWriteAsync{html} |
+    | enableJournalDiskSyncs | _boolean_ | {html}Get the enableJournalDiskSyncs{html} |
+    | failoverProducersAuditDepth | _int_ | {html}set the audit window depth for duplicate suppression (should exceed the max transaction
+batch){html} |
+    | forceRecoverIndex | _boolean_ | {html}{html} |
+    | ignoreMissingJournalfiles | _boolean_ | {html}Get the ignoreMissingJournalfiles{html} |
+    | indexCacheSize | _java.lang.String_ | {html}Get the indexCacheSize{html} |
+    | indexLFUEvictionFactor | _float_ | {html}{html} |
+    | indexWriteBatchSize | _java.lang.String_ | {html}Get the indexWriteBatchSize{html} |
+    | journalMaxFileLength | _java.lang.String_ | {html}Get the journalMaxFileLength{html} |
+    | journalMaxWriteBatchSize | _java.lang.String_ | {html}Get the journalMaxWriteBatchSize{html} |
+    | lockKeepAlivePeriod | _long_ | {html}{html} |
+    | locker | _[org.apache.activemq.broker.Locker|#org.apache.activemq.broker.Locker-types]_ | {html}{html} |
+    | maxAsyncJobs | _int_ | {html}{html} |
+    | maxFailoverProducersToTrack | _int_ | {html}Set the max number of producers (LRU cache) to track for duplicate sends{html} |
+    | rewriteOnRedelivery | _boolean_ | {html}When true, persist the redelivery status such that the message redelivery flag can survive a broker failure
+used with org.apache.activemq.ActiveMQConnectionFactory#setTransactedIndividualAck(boolean)  true{html} |
+    | usageManager | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | useIndexLFRUEviction | _boolean_ | {html}{html} |
+    | useLock | _boolean_ | {html}{html} |
+
+{anchor:kahaPersistenceAdapter-element}
+h3. The _[<kahaPersistenceAdapter>|#kahaPersistenceAdapter-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | directory | _java.io.File_ | {html}{html} |
+    | maxDataFileLength | _java.lang.String_ | {html}When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | persistentIndex | _boolean_ | {html}{html} |
+    | size | _java.util.concurrent.atomic.AtomicLong_ | {html}{html} |
+    | usageManager | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+
+{anchor:lDAPAuthorizationMap-element}
+h3. The _[<lDAPAuthorizationMap>|#lDAPAuthorizationMap-element]_ Element
+    {html}An {@link AuthorizationMap} which uses LDAP{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminAttribute | _java.lang.String_ | {html}{html} |
+    | adminBase | _java.lang.String_ | {html}{html} |
+    | advisorySearchBase | _java.lang.String_ | {html}{html} |
+    | authentication | _java.lang.String_ | {html}{html} |
+    | connectionPassword | _java.lang.String_ | {html}{html} |
+    | connectionProtocol | _java.lang.String_ | {html}{html} |
+    | connectionURL | _java.lang.String_ | {html}{html} |
+    | connectionUsername | _java.lang.String_ | {html}{html} |
+    | context | _javax.naming.directory.DirContext_ | {html}{html} |
+    | initialContextFactory | _java.lang.String_ | {html}{html} |
+    | options | _java.util.Map_ | {html}{html} |
+    | queueSearchMatchingFormat | _java.text.MessageFormat_ | {html}{html} |
+    | queueSearchSubtreeBool | _boolean_ | {html}{html} |
+    | readAttribute | _java.lang.String_ | {html}{html} |
+    | readBase | _java.lang.String_ | {html}{html} |
+    | tempSearchBase | _java.lang.String_ | {html}{html} |
+    | topicSearchMatchingFormat | _java.text.MessageFormat_ | {html}{html} |
+    | topicSearchSubtreeBool | _boolean_ | {html}{html} |
+    | useAdvisorySearchBase | _boolean_ | {html}{html} |
+    | writeAttribute | _java.lang.String_ | {html}{html} |
+    | writeBase | _java.lang.String_ | {html}{html} |
+
+{anchor:lastImageSubscriptionRecoveryPolicy-element}
+h3. The _[<lastImageSubscriptionRecoveryPolicy>|#lastImageSubscriptionRecoveryPolicy-element]_ Element
+    {html}This implementation of {@link SubscriptionRecoveryPolicy} will only keep the
+last message.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | broker | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+
+{anchor:ldapNetworkConnector-element}
+h3. The _[<ldapNetworkConnector>|#ldapNetworkConnector-element]_ Element
+    {html}class to create dynamic network connectors listed in an directory
+server using the LDAP v3 protocol as defined in RFC 2251, the
+entries listed in the directory server must implement the ipHost
+and ipService objectClasses as defined in RFC 2307.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | alwaysSyncSend | _boolean_ | {html}{html} |
+    | anonymousAuthentication | _boolean_ | {html}sets LDAP anonymous authentication access credentials{html} |
+    | base | _java.lang.String_ | {html}sets the base LDAP dn used for lookup operations{html} |
+    | bridgeTempDestinations | _boolean_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | brokerURL | _java.lang.String_ | {html}{html} |
+    | conduitSubscriptions | _boolean_ | {html}{html} |
+    | connectionFilter | _org.apache.activemq.network.ConnectionFilter_ | {html}{html} |
+    | consumerPriorityBase | _int_ | {html}{html} |
+    | decreaseNetworkConsumerPriority | _boolean_ | {html}{html} |
+    | destinationFilter | _java.lang.String_ | {html}{html} |
+    | dispatchAsync | _boolean_ | {html}{html} |
+    | duplex | _boolean_ | {html}{html} |
+    | durableDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | dynamicOnly | _boolean_ | {html}{html} |
+    | dynamicallyIncludedDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | excludedDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | localUri | _java.net.URI_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | networkTTL | _int_ | {html}{html} |
+    | objectName | _javax.management.ObjectName_ | {html}{html} |
+    | password | _java.lang.String_ | {html}sets the LDAP password for access credentials{html} |
+    | prefetchSize | _java.lang.String_ | {html}{html} |
+    | searchEventListener | _boolean_ | {html}enables/disable a persistent search to the LDAP server as defined
+in draft-ietf-ldapext-psearch-03.txt (2.16.840.1.113730.3.4.3){html} |
+    | searchFilter | _java.lang.String_ | {html}sets the LDAP search filter as defined in RFC 2254{html} |
+    | searchScope | _java.lang.String_ | {html}sets the LDAP search scope{html} |
+    | staticBridge | _boolean_ | {html}{html} |
+    | staticallyIncludedDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | suppressDuplicateQueueSubscriptions | _boolean_ | {html}{html} |
+    | suppressDuplicateTopicSubscriptions | _boolean_ | {html}{html} |
+    | uri | _java.net.URI_ | {html}returns the next URI from the configured list{html} |
+    | useCompression | _boolean_ | {html}{html} |
+    | user | _java.lang.String_ | {html}sets the LDAP user for access credentials{html} |
+    | userName | _java.lang.String_ | {html}{html} |
+
+{anchor:lease-database-locker-element}
+h3. The _[<lease-database-locker>|#lease-database-locker-element]_ Element
+    {html}Represents an exclusive lease on a database to avoid multiple brokers running
+against the same logical database.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | failIfLocked | _boolean_ | {html}{html} |
+    | leaseHolderId | _java.lang.String_ | {html}{html} |
+    | lockAcquireSleepInterval | _long_ | {html}{html} |
+    | maxAllowableDiffFromDBTime | _int_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | queryTimeout | _int_ | {html}{html} |
+
+{anchor:levelDB-element}
+h3. The _[<levelDB>|#levelDB-element]_ Element
+    {html}An implementation of {@link org.apache.activemq.store.PersistenceAdapter} designed for use with
+LevelDB - Embedded Lightweight Non-Relational Database{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | asyncBufferSize | _int_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | directory | _java.io.File_ | {html}{html} |
+    | failIfLocked | _boolean_ | {html}{html} |
+    | flushDelay | _int_ | {html}{html} |
+    | indexBlockRestartInterval | _int_ | {html}{html} |
+    | indexBlockSize | _int_ | {html}{html} |
+    | indexCacheSize | _long_ | {html}{html} |
+    | indexCompression | _java.lang.String_ | {html}{html} |
+    | indexFactory | _java.lang.String_ | {html}{html} |
+    | indexMaxOpenFiles | _int_ | {html}{html} |
+    | indexWriteBufferSize | _int_ | {html}{html} |
+    | logCompression | _java.lang.String_ | {html}{html} |
+    | logDirectory | _java.io.File_ | {html}{html} |
+    | logSize | _long_ | {html}{html} |
+    | monitorStats | _boolean_ | {html}{html} |
+    | paranoidChecks | _boolean_ | {html}{html} |
+    | sync | _boolean_ | {html}{html} |
+    | usageManager | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | verifyChecksums | _boolean_ | {html}{html} |
+
+{anchor:loggingBrokerPlugin-element}
+h3. The _[<loggingBrokerPlugin>|#loggingBrokerPlugin-element]_ Element
+    {html}A simple Broker intercepter which allows you to enable/disable logging.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminConnectionContext | _org.apache.activemq.broker.ConnectionContext_ | {html}{html} |
+    | logAll | _boolean_ | {html}Logger all Events that go through the Plugin{html} |
+    | logConnectionEvents | _boolean_ | {html}Logger Events that are related to connections{html} |
+    | logConsumerEvents | _boolean_ | {html}Logger Events that are related to Consumers{html} |
+    | logInternalEvents | _boolean_ | {html}Logger Events that are normally internal to the broker{html} |
+    | logMessageEvents | _boolean_ | {html}Logger Events that are related to message processing{html} |
+    | logProducerEvents | _boolean_ | {html}Logger Events that are related to Producers{html} |
+    | logSessionEvents | _boolean_ | {html}Logger Events that are related to sessions{html} |
+    | logTransactionEvents | _boolean_ | {html}Logger Events that are related to transaction processing{html} |
+    | next | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+
+{anchor:mKahaDB-element}
+h3. The _[<mKahaDB>|#mKahaDB-element]_ Element
+    {html}An implementation of {@link org.apache.activemq.store.PersistenceAdapter}  that supports
+distribution of destinations across multiple kahaDB persistence adapters{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | directory | _java.io.File_ | {html}{html} |
+    | entries | (_java.lang.Object_)\* | {html}A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring{html} |
+    | filteredPersistenceAdapters | (_java.lang.Object_)\* | {html}Sets the  FilteredKahaDBPersistenceAdapter entries{html} |
+    | journalMaxFileLength | _java.lang.String_ | {html}Set the max file length of the transaction journal
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can
+be used{html} |
+    | journalWriteBatchSize | _java.lang.String_ | {html}Set the max write batch size of  the transaction journal
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can
+be used{html} |
+    | transactionStore | _org.apache.activemq.store.kahadb.MultiKahaDBTransactionStore_ | {html}{html} |
+    | usageManager | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+
+{anchor:managementContext-element}
+h3. The _[<managementContext>|#managementContext-element]_ Element
+    {html}An abstraction over JMX mbean registration{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | MBeanServer | _javax.management.MBeanServer_ | {html}Get the MBeanServer{html} |
+    | allowRemoteAddressInMBeanNames | _boolean_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}Gets the broker name this context is used by, may be <tt>null</tt>
+if the broker name was not set.{html} |
+    | connectorHost | _java.lang.String_ | {html}Get the connectorHost{html} |
+    | connectorPath | _java.lang.String_ | {html}{html} |
+    | connectorPort | _java.lang.String_ | {html}{html} |
+    | createConnector | _java.lang.String_ | {html}{html} |
+    | createMBeanServer | _boolean_ | {html}{html} |
+    | environment | _java.util.Map_ | {html}{html} |
+    | findTigerMbeanServer | _boolean_ | {html}Enables/disables the searching for the Java 5 platform MBeanServer{html} |
+    | jmxDomainName | _java.lang.String_ | {html}{html} |
+    | rmiServerPort | _java.lang.String_ | {html}{html} |
+    | server | _javax.management.MBeanServer_ | {html}{html} |
+    | useMBeanServer | _boolean_ | {html}{html} |
+
+{anchor:masterConnector-element}
+h3. The _[<masterConnector>|#masterConnector-element]_ Element
+    {html}Connects a Slave Broker to a Master when using <a
+href="http://activemq.apache.org/masterslave.html">Master Slave</a> for High
+Availability of messages.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | failedToStart | _boolean_ | {html}Get the failedToStart{html} |
+    | localURI | _java.net.URI_ | {html}{html} |
+    | password | _java.lang.String_ | {html}{html} |
+    | remoteURI | _java.net.URI_ | {html}{html} |
+    | remoteUri | _java.lang.String_ | {html}{html} |
+    | userName | _java.lang.String_ | {html}{html} |
+
+{anchor:maxdb-jdbc-adapter-element}
+h3. The _[<maxdb-jdbc-adapter>|#maxdb-jdbc-adapter-element]_ Element
+    {html}JDBC Adapter for the MaxDB database.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:memoryPersistenceAdapter-element}
+h3. The _[<memoryPersistenceAdapter>|#memoryPersistenceAdapter-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | createTransactionStore | _boolean_ | {html}{html} |
+    | directory | _java.io.File_ | {html}{html} |
+    | usageManager | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:memoryUsage-element}
+h3. The _[<memoryUsage>|#memoryUsage-element]_ Element
+    {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | executor | _java.util.concurrent.ThreadPoolExecutor_ | {html}{html} |
+    | limit | _java.lang.String_ | {html}Sets the memory limit in bytes. Setting the limit in bytes will set the
+usagePortion to 0 since the UsageManager is not going to be portion based
+off the parent.
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | limiter | _[org.apache.activemq.usage.UsageCapacity|#org.apache.activemq.usage.UsageCapacity-types]_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | parent | _T_ | {html}{html} |
+    | percentUsage | _int_ | {html}{html} |
+    | percentUsageMinDelta | _java.lang.String_ | {html}Sets the minimum number of percentage points the usage has to change
+before a UsageListener event is fired by the manager.{html} |
+    | pollingTime | _int_ | {html}{html} |
+    | portion | _float_ | {html}{html} |
+    | usage | _long_ | {html}{html} |
+    | usagePortion | _float_ | {html}{html} |
+
+{anchor:messageGroupHashBucketFactory-element}
+h3. The _[<messageGroupHashBucketFactory>|#messageGroupHashBucketFactory-element]_ Element
+    {html}A factory to create instances of {@link SimpleMessageGroupMap} when
+implementing the <a
+href="http://activemq.apache.org/message-groups.html">Message
+Groups</a> functionality.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | bucketCount | _int_ | {html}Sets the number of hash buckets to use for the message group
+functionality. This is only applicable to using message groups to
+parallelize processing of a queue while preserving order across an
+individual JMSXGroupID header value. This value sets the number of hash
+buckets that will be used (i.e. the maximum possible concurrency).{html} |
+
+{anchor:mirroredQueue-element}
+h3. The _[<mirroredQueue>|#mirroredQueue-element]_ Element
+    {html}Creates <a href="http://activemq.org/site/mirrored-queues.html">Mirrored
+Queue</a> using a prefix and postfix to define the topic name on which to mirror the queue to.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | copyMessage | _boolean_ | {html}Sets whether a copy of the message will be sent to each destination.
+Defaults to true so that the forward destination is set as the
+destination of the message{html} |
+    | postfix | _java.lang.String_ | {html}Sets any postix used to identify the queue consumers{html} |
+    | prefix | _java.lang.String_ | {html}Sets the prefix wildcard used to identify the queue consumers for a given
+topic{html} |
+
+{anchor:multicastNetworkConnector-element}
+h3. The _[<multicastNetworkConnector>|#multicastNetworkConnector-element]_ Element
+    {html}A network connector which uses some kind of multicast-like transport that
+communicates with potentially many remote brokers over a single logical
+{@link Transport} instance such as when using multicast.
+
+This implementation does not depend on multicast at all; any other group
+based transport could be used.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | alwaysSyncSend | _boolean_ | {html}{html} |
+    | bridge | _[org.apache.activemq.network.DemandForwardingBridgeSupport|#org.apache.activemq.network.DemandForwardingBridgeSupport-types]_ | {html}{html} |
+    | bridgeTempDestinations | _boolean_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | brokerURL | _java.lang.String_ | {html}{html} |
+    | conduitSubscriptions | _boolean_ | {html}{html} |
+    | connectionFilter | _org.apache.activemq.network.ConnectionFilter_ | {html}{html} |
+    | consumerPriorityBase | _int_ | {html}{html} |
+    | decreaseNetworkConsumerPriority | _boolean_ | {html}{html} |
+    | destinationFilter | _java.lang.String_ | {html}{html} |
+    | dispatchAsync | _boolean_ | {html}{html} |
+    | duplex | _boolean_ | {html}{html} |
+    | durableDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | dynamicOnly | _boolean_ | {html}{html} |
+    | dynamicallyIncludedDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | excludedDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | localTransport | _org.apache.activemq.transport.Transport_ | {html}{html} |
+    | localUri | _java.net.URI_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | networkTTL | _int_ | {html}{html} |
+    | objectName | _javax.management.ObjectName_ | {html}{html} |
+    | password | _java.lang.String_ | {html}{html} |
+    | prefetchSize | _java.lang.String_ | {html}{html} |
+    | remoteTransport | _org.apache.activemq.transport.Transport_ | {html}Sets the remote transport implementation{html} |
+    | remoteURI | _java.net.URI_ | {html}Sets the remote transport URI to some group transport like
+<code>multicast://address:port</code>{html} |
+    | staticBridge | _boolean_ | {html}{html} |
+    | staticallyIncludedDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | suppressDuplicateQueueSubscriptions | _boolean_ | {html}{html} |
+    | suppressDuplicateTopicSubscriptions | _boolean_ | {html}{html} |
+    | useCompression | _boolean_ | {html}{html} |
+    | userName | _java.lang.String_ | {html}{html} |
+
+{anchor:multicastTraceBrokerPlugin-element}
+h3. The _[<multicastTraceBrokerPlugin>|#multicastTraceBrokerPlugin-element]_ Element
+    {html}A Broker interceptor which allows you to trace all operations to a Multicast
+socket.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | address | _java.net.SocketAddress_ | {html}{html} |
+    | adminConnectionContext | _org.apache.activemq.broker.ConnectionContext_ | {html}{html} |
+    | broadcast | _boolean_ | {html}{html} |
+    | destination | _java.net.URI_ | {html}{html} |
+    | maxTraceDatagramSize | _int_ | {html}{html} |
+    | next | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | timeToLive | _int_ | {html}{html} |
+    | wireFormat | _org.apache.activemq.wireformat.WireFormat_ | {html}{html} |
+    | wireFormatFactory | _org.apache.activemq.wireformat.WireFormatFactory_ | {html}{html} |
+
+{anchor:mysql-jdbc-adapter-element}
+h3. The _[<mysql-jdbc-adapter>|#mysql-jdbc-adapter-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | engineType | _java.lang.String_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | typeStatement | _java.lang.String_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:networkConnector-element}
+h3. The _[<networkConnector>|#networkConnector-element]_ Element
+    {html}A network connector which uses a discovery agent to detect the remote brokers
+available and setup a connection to each available remote broker{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | alwaysSyncSend | _boolean_ | {html}{html} |
+    | bridgeTempDestinations | _boolean_ | {html}{html} |
+    | brokerName | _java.lang.String_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | brokerURL | _java.lang.String_ | {html}{html} |
+    | conduitSubscriptions | _boolean_ | {html}{html} |
+    | connectionFilter | _org.apache.activemq.network.ConnectionFilter_ | {html}{html} |
+    | consumerPriorityBase | _int_ | {html}{html} |
+    | decreaseNetworkConsumerPriority | _boolean_ | {html}{html} |
+    | destinationFilter | _java.lang.String_ | {html}{html} |
+    | discoveryAgent | _org.apache.activemq.transport.discovery.DiscoveryAgent_ | {html}{html} |
+    | discoveryURI | _java.net.URI_ | {html}{html} |
+    | dispatchAsync | _boolean_ | {html}{html} |
+    | duplex | _boolean_ | {html}{html} |
+    | durableDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | dynamicOnly | _boolean_ | {html}{html} |
+    | dynamicallyIncludedDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | excludedDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | localUri | _java.net.URI_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | networkTTL | _int_ | {html}{html} |
+    | objectName | _javax.management.ObjectName_ | {html}{html} |
+    | password | _java.lang.String_ | {html}{html} |
+    | prefetchSize | _java.lang.String_ | {html}{html} |
+    | staticBridge | _boolean_ | {html}{html} |
+    | staticallyIncludedDestinations | (_java.lang.Object_)\* | {html}{html} |
+    | suppressDuplicateQueueSubscriptions | _boolean_ | {html}{html} |
+    | suppressDuplicateTopicSubscriptions | _boolean_ | {html}{html} |
+    | uri | _java.net.URI_ | {html}{html} |
+    | useCompression | _boolean_ | {html}{html} |
+    | userName | _java.lang.String_ | {html}{html} |
+
+{anchor:noSubscriptionRecoveryPolicy-element}
+h3. The _[<noSubscriptionRecoveryPolicy>|#noSubscriptionRecoveryPolicy-element]_ Element
+    {html}This SubscriptionRecoveryPolicy disable recovery of messages.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | broker | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+
+{anchor:oldestMessageEvictionStrategy-element}
+h3. The _[<oldestMessageEvictionStrategy>|#oldestMessageEvictionStrategy-element]_ Element
+    {html}An eviction strategy which evicts the oldest message first (which is the
+default).{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | evictExpiredMessagesHighWatermark | _int_ | {html}Sets the high water mark on which we will eagerly evict expired messages from RAM{html} |
+
+{anchor:oldestMessageWithLowestPriorityEvictionStrategy-element}
+h3. The _[<oldestMessageWithLowestPriorityEvictionStrategy>|#oldestMessageWithLowestPriorityEvictionStrategy-element]_ Element
+    {html}An eviction strategy which evicts the oldest message with the lowest priority first.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | evictExpiredMessagesHighWatermark | _int_ | {html}Sets the high water mark on which we will eagerly evict expired messages from RAM{html} |
+
+{anchor:oracleBlobJDBCAdapter-element}
+h3. The _[<oracleBlobJDBCAdapter>|#oracleBlobJDBCAdapter-element]_ Element
+    {html}Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:oracleJDBCAdapter-element}
+h3. The _[<oracleJDBCAdapter>|#oracleJDBCAdapter-element]_ Element
+    {html}Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:outboundQueueBridge-element}
+h3. The _[<outboundQueueBridge>|#outboundQueueBridge-element]_ Element
+    {html}Create an Outbound Queue Bridge.  By default the bridge uses the same
+name for both the inbound and outbound queues, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+queue names.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | consumer | _javax.jms.MessageConsumer_ | {html}{html} |
+    | consumerConnection | _javax.jms.QueueConnection_ | {html}{html} |
+    | consumerQueue | _[javax.jms.Queue|#javax.jms.Queue-types]_ | {html}{html} |
+    | doHandleReplyTo | _boolean_ | {html}{html} |
+    | jmsConnector | _[org.apache.activemq.network.jms.JmsConnector|#org.apache.activemq.network.jms.JmsConnector-types]_ | {html}{html} |
+    | jmsMessageConvertor | _[org.apache.activemq.network.jms.JmsMesageConvertor|#org.apache.activemq.network.jms.JmsMesageConvertor-types]_ | {html}{html} |
+    | localQueueName | _java.lang.String_ | {html}{html} |
+    | outboundQueueName | _java.lang.String_ | {html}Sets the name of the outbound queue name.  If the inbound queue name
+has not been set already then this method uses the provided queue name
+to set the inbound topic name as well.{html} |
+    | producerConnection | _javax.jms.QueueConnection_ | {html}{html} |
+    | producerQueue | _[javax.jms.Queue|#javax.jms.Queue-types]_ | {html}{html} |
+    | selector | _java.lang.String_ | {html}{html} |
+
+{anchor:outboundTopicBridge-element}
+h3. The _[<outboundTopicBridge>|#outboundTopicBridge-element]_ Element
+    {html}Create an Outbound Topic Bridge.  By default the bridge uses the same
+name for both the inbound and outbound topics, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+topic names.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | consumer | _javax.jms.MessageConsumer_ | {html}{html} |
+    | consumerConnection | _javax.jms.TopicConnection_ | {html}{html} |
+    | consumerName | _java.lang.String_ | {html}{html} |
+    | consumerTopic | _[javax.jms.Topic|#javax.jms.Topic-types]_ | {html}{html} |
+    | doHandleReplyTo | _boolean_ | {html}{html} |
+    | jmsConnector | _[org.apache.activemq.network.jms.JmsConnector|#org.apache.activemq.network.jms.JmsConnector-types]_ | {html}{html} |
+    | jmsMessageConvertor | _[org.apache.activemq.network.jms.JmsMesageConvertor|#org.apache.activemq.network.jms.JmsMesageConvertor-types]_ | {html}{html} |
+    | localTopicName | _java.lang.String_ | {html}{html} |
+    | outboundTopicName | _java.lang.String_ | {html}Sets the name of the outbound topic name.  If the inbound topic name
+has not been set already then this method uses the provided topic name
+to set the inbound topic name as well.{html} |
+    | producerConnection | _javax.jms.TopicConnection_ | {html}{html} |
+    | producerTopic | _[javax.jms.Topic|#javax.jms.Topic-types]_ | {html}{html} |
+    | selector | _java.lang.String_ | {html}{html} |
+
+{anchor:pListStore-element}
+h3. The _[<pListStore>|#pListStore-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}{html} |
+    | cleanupInterval | _long_ | {html}{html} |
+    | directory | _java.io.File_ | {html}{html} |
+    | enableIndexWriteAsync | _boolean_ | {html}{html} |
+    | failIfDatabaseIsLocked | _boolean_ | {html}{html} |
+    | indexCacheSize | _int_ | {html}{html} |
+    | indexEnablePageCaching | _boolean_ | {html}{html} |
+    | indexPageSize | _int_ | {html}{html} |
+    | indexWriteBatchSize | _int_ | {html}{html} |
+    | journalMaxFileLength | _int_ | {html}{html} |
+    | journalMaxWriteBatchSize | _int_ | {html}{html} |
+    | lazyInit | _boolean_ | {html}{html} |
+
+{anchor:policyEntry-element}
+h3. The _[<policyEntry>|#policyEntry-element]_ Element
+    {html}Represents an entry in a {@link PolicyMap} for assigning policies to a
+specific destination or a hierarchical wildcard area of destinations.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | advisoryForConsumed | _boolean_ | {html}{html} |
+    | advisoryForDelivery | _boolean_ | {html}{html} |
+    | advisoryForDiscardingMessages | _boolean_ | {html}{html} |
+    | advisoryForFastProducers | _boolean_ | {html}{html} |
+    | advisoryForSlowConsumers | _boolean_ | {html}{html} |
+    | advisoryWhenFull | _boolean_ | {html}{html} |
+    | allConsumersExclusiveByDefault | _boolean_ | {html}{html} |
+    | alwaysRetroactive | _boolean_ | {html}{html} |
+    | blockedProducerWarningInterval | _long_ | {html}Set's the interval at which warnings about producers being blocked by
+resource usage will be triggered. Values of 0 or less will disable
+warnings{html} |
+    | consumersBeforeDispatchStarts | _int_ | {html}{html} |
+    | cursorMemoryHighWaterMark | _int_ | {html}{html} |
+    | deadLetterStrategy | _[org.apache.activemq.broker.region.policy.DeadLetterStrategy|#org.apache.activemq.broker.region.policy.DeadLetterStrategy-types]_ | {html}Sets the policy used to determine which dead letter queue destination
+should be used{html} |
+    | destination | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}{html} |
+    | dispatchPolicy | _[org.apache.activemq.broker.region.policy.DispatchPolicy|#org.apache.activemq.broker.region.policy.DispatchPolicy-types]_ | {html}{html} |
+    | doOptimzeMessageStorage | _boolean_ | {html}{html} |
+    | durableTopicPrefetch | _int_ | {html}Get the durableTopicPrefetch{html} |
+    | enableAudit | _boolean_ | {html}{html} |
+    | expireMessagesPeriod | _long_ | {html}{html} |
+    | gcInactiveDestinations | _boolean_ | {html}{html} |
+    | gcWithNetworkConsumers | _boolean_ | {html}{html} |
+    | inactiveTimoutBeforeGC | _long_ | {html}{html} |
+    | lazyDispatch | _boolean_ | {html}{html} |
+    | maxAuditDepth | _int_ | {html}{html} |
+    | maxBrowsePageSize | _int_ | {html}{html} |
+    | maxExpirePageSize | _int_ | {html}{html} |
+    | maxPageSize | _int_ | {html}{html} |
+    | maxProducersToAudit | _int_ | {html}{html} |
+    | maxQueueAuditDepth | _int_ | {html}{html} |
+    | memoryLimit | _java.lang.String_ | {html}When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | messageEvictionStrategy | _[org.apache.activemq.broker.region.policy.MessageEvictionStrategy|#org.apache.activemq.broker.region.policy.MessageEvictionStrategy-types]_ | {html}Sets the eviction strategy used to decide which message to evict when the
+slow consumer needs to discard messages{html} |
+    | messageGroupMapFactory | _[org.apache.activemq.broker.region.group.MessageGroupMapFactory|#org.apache.activemq.broker.region.group.MessageGroupMapFactory-types]_ | {html}Sets the factory used to create new instances of {MessageGroupMap} used
+to implement the <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a>
+functionality.{html} |
+    | minimumMessageSize | _long_ | {html}{html} |
+    | networkBridgeFilterFactory | _[org.apache.activemq.network.NetworkBridgeFilterFactory|#org.apache.activemq.network.NetworkBridgeFilterFactory-types]_ | {html}{html} |
+    | optimizeMessageStoreInFlightLimit | _int_ | {html}{html} |
+    | optimizedDispatch | _boolean_ | {html}{html} |
+    | pendingDurableSubscriberPolicy | _[org.apache.activemq.broker.region.policy.PendingDurableSubscriberMessageStoragePolicy|#org.apache.activemq.broker.region.policy.PendingDurableSubscriberMessageStoragePolicy-types]_ | {html}{html} |
+    | pendingMessageLimitStrategy | _[org.apache.activemq.broker.region.policy.PendingMessageLimitStrategy|#org.apache.activemq.broker.region.policy.PendingMessageLimitStrategy-types]_ | {html}Sets the strategy to calculate the maximum number of messages that are
+allowed to be pending on consumers (in addition to their prefetch sizes).
+Once the limit is reached, non-durable topics can then start discarding
+old messages. This allows us to keep dispatching messages to slow
+consumers while not blocking fast consumers and discarding the messages
+oldest first.{html} |
+    | pendingQueuePolicy | _[org.apache.activemq.broker.region.policy.PendingQueueMessageStoragePolicy|#org.apache.activemq.broker.region.policy.PendingQueueMessageStoragePolicy-types]_ | {html}{html} |
+    | pendingSubscriberPolicy | _[org.apache.activemq.broker.region.policy.PendingSubscriberMessageStoragePolicy|#org.apache.activemq.broker.region.policy.PendingSubscriberMessageStoragePolicy-types]_ | {html}{html} |
+    | prioritizedMessages | _boolean_ | {html}{html} |
+    | producerFlowControl | _boolean_ | {html}{html} |
+    | queue | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | queueBrowserPrefetch | _int_ | {html}Get the queueBrowserPrefetch{html} |
+    | queuePrefetch | _int_ | {html}Get the queuePrefetch{html} |
+    | reduceMemoryFootprint | _boolean_ | {html}{html} |
+    | sendAdvisoryIfNoConsumers | _boolean_ | {html}Sends an advisory message if a non-persistent message is sent and there
+are no active consumers{html} |
+    | slowConsumerStrategy | _[org.apache.activemq.broker.region.policy.SlowConsumerStrategy|#org.apache.activemq.broker.region.policy.SlowConsumerStrategy-types]_ | {html}{html} |
+    | storeUsageHighWaterMark | _int_ | {html}{html} |
+    | strictOrderDispatch | _boolean_ | {html}{html} |
+    | subscriptionRecoveryPolicy | _[org.apache.activemq.broker.region.policy.SubscriptionRecoveryPolicy|#org.apache.activemq.broker.region.policy.SubscriptionRecoveryPolicy-types]_ | {html}{html} |
+    | tempQueue | _boolean_ | {html}{html} |
+    | tempTopic | _boolean_ | {html}{html} |
+    | timeBeforeDispatchStarts | _int_ | {html}{html} |
+    | topic | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | topicPrefetch | _int_ | {html}Get the topicPrefetch{html} |
+    | useCache | _boolean_ | {html}{html} |
+    | useConsumerPriority | _boolean_ | {html}{html} |
+    | usePrefetchExtension | _boolean_ | {html}{html} |
+
+{anchor:policyMap-element}
+h3. The _[<policyMap>|#policyMap-element]_ Element
+    {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | defaultEntry | _[org.apache.activemq.broker.region.policy.PolicyEntry|#org.apache.activemq.broker.region.policy.PolicyEntry-types]_ | {html}{html} |
+    | entries | (_java.lang.Object_)\* | {html}A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring{html} |
+    | policyEntries | (_java.lang.Object_)\* | {html}Sets the individual entries on the policy map{html} |
+
+{anchor:postgresql-jdbc-adapter-element}
+h3. The _[<postgresql-jdbc-adapter>|#postgresql-jdbc-adapter-element]_ Element
+    {html}Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | acksPkName | _java.lang.String_ | {html}{html} |
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:prefetchPolicy-element}
+h3. The _[<prefetchPolicy>|#prefetchPolicy-element]_ Element
+    {html}Defines the prefetch message policies for different types of consumers{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | all | _int_ | {html}{html} |
+    | durableTopicPrefetch | _int_ | {html}{html} |
+    | inputStreamPrefetch | _int_ | {html}{html} |
+    | maximumPendingMessageLimit | _int_ | {html}Sets how many messages a broker will keep around, above the prefetch
+limit, for non-durable topics before starting to discard older messages.{html} |
+    | optimizeDurableTopicPrefetch | _int_ | {html}{html} |
+    | queueBrowserPrefetch | _int_ | {html}{html} |
+    | queuePrefetch | _int_ | {html}{html} |
+    | topicPrefetch | _int_ | {html}{html} |
+
+{anchor:prefetchRatePendingMessageLimitStrategy-element}
+h3. The _[<prefetchRatePendingMessageLimitStrategy>|#prefetchRatePendingMessageLimitStrategy-element]_ Element
+    {html}This PendingMessageLimitStrategy sets the maximum pending message limit value to be
+a multiplier of the prefetch limit of the subscription.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | multiplier | _double_ | {html}Sets the multiplier of the prefetch size which will be used to define the maximum number of pending
+messages for non-durable topics before messages are discarded.{html} |
+
+{anchor:priorityNetworkDispatchPolicy-element}
+h3. The _[<priorityNetworkDispatchPolicy>|#priorityNetworkDispatchPolicy-element]_ Element
+    {html}dispatch policy that ignores lower priority duplicate network consumers,
+used in conjunction with network bridge suppresDuplicateTopicSubscriptions{html}
+
+{anchor:proxyConnector-element}
+h3. The _[<proxyConnector>|#proxyConnector-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | bind | _java.net.URI_ | {html}{html} |
+    | localUri | _java.net.URI_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | proxyToLocalBroker | _boolean_ | {html}{html} |
+    | remote | _java.net.URI_ | {html}{html} |
+    | server | _org.apache.activemq.transport.TransportServer_ | {html}{html} |
+
+{anchor:queryBasedSubscriptionRecoveryPolicy-element}
+h3. The _[<queryBasedSubscriptionRecoveryPolicy>|#queryBasedSubscriptionRecoveryPolicy-element]_ Element
+    {html}This implementation of {@link SubscriptionRecoveryPolicy} will perform a user
+specific query mechanism to load any messages they may have missed.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | broker | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | query | _org.apache.activemq.broker.region.policy.MessageQuery_ | {html}Sets the query strategy to load initial messages{html} |
+
+{anchor:queue-element}
+h3. The _[<queue>|#queue-element]_ Element
+    {html}An ActiveMQ Queue{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | compositeDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | physicalName | _java.lang.String_ | {html}{html} |
+    | properties | _java.util.Properties_ | {html}Get the properties from this instance for storing in JNDI{html} |
+
+{anchor:queueDispatchSelector-element}
+h3. The _[<queueDispatchSelector>|#queueDispatchSelector-element]_ Element
+    {html}Queue dispatch policy that determines if a message can be sent to a subscription{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | destination | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}{html} |
+    | exclusiveConsumer | _org.apache.activemq.broker.region.Subscription_ | {html}{html} |
+
+{anchor:reconnectionPolicy-element}
+h3. The _[<reconnectionPolicy>|#reconnectionPolicy-element]_ Element
+    {html}A policy object that defines how a {@link JmsConnector} deals with
+reconnection of the local and foreign connections.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | backOffMultiplier | _double_ | {html}Gets the multiplier used to grow the delay between connection attempts from the initial
+time to the max set time.  By default this value is set to 2.0.{html} |
+    | initialReconnectDelay | _long_ | {html}Gets the initial delay value used before a reconnection attempt is made.  If the
+use exponential back-off value is set to false then this will be the fixed time
+between connection attempts.  By default this value is set to one second.{html} |
+    | maxInitialConnectAttempts | _int_ | {html}Gets the maximum number of times that the {@link JmsConnector} will try
+to connect on startup to before it marks itself as failed and does not
+try any further connections.{html} |
+    | maxReconnectAttempts | _int_ | {html}Gets the number of time that {@link JmsConnector} will attempt to connect
+or reconnect before giving up.  By default the policy sets this value to
+a negative value meaning try forever.{html} |
+    | maxSendRetries | _int_ | {html}Gets the maximum number of a times a Message send should be retried before
+a JMSExeception is thrown indicating that the operation failed.{html} |
+    | maximumReconnectDelay | _long_ | {html}Gets the maximum delay that is inserted between each attempt to connect
+before another attempt is made.  The default setting for this value is
+30 seconds.{html} |
+    | sendRetyDelay | _long_ | {html}Set the amount of time the DestionationBridge will wait between attempts
+to forward a message.  The default policy limits the minimum time between
+send attempt to one second.{html} |
+    | useExponentialBackOff | _boolean_ | {html}Gets whether the policy uses the set back-off multiplier to grow the time between
+connection attempts.{html} |
+
+{anchor:redeliveryPlugin-element}
+h3. The _[<redeliveryPlugin>|#redeliveryPlugin-element]_ Element
+    {html}Replace regular DLQ handling with redelivery via a resend to the original destination
+after a delay
+A destination matching RedeliveryPolicy controls the quantity and delay for re-sends
+If there is no matching policy or an existing policy limit is exceeded by default
+regular DLQ processing resumes. This is controlled via sendToDlqIfMaxRetriesExceeded
+and fallbackToDeadLetter{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminConnectionContext | _org.apache.activemq.broker.ConnectionContext_ | {html}{html} |
+    | fallbackToDeadLetter | _boolean_ | {html}What to do if there is no matching redelivery policy for a destination.
+when true, the region broker DLQ processing will be used via sendToDeadLetterQueue
+when false, there is no action{html} |
+    | next | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | redeliveryPolicyMap | _[org.apache.activemq.broker.region.policy.RedeliveryPolicyMap|#org.apache.activemq.broker.region.policy.RedeliveryPolicyMap-types]_ | {html}{html} |
+    | sendToDlqIfMaxRetriesExceeded | _boolean_ | {html}What to do if the maxretries on a matching redelivery policy is exceeded.
+when true, the region broker DLQ processing will be used via sendToDeadLetterQueue
+when false, there is no action{html} |
+
+{anchor:redeliveryPolicy-element}
+h3. The _[<redeliveryPolicy>|#redeliveryPolicy-element]_ Element
+    {html}Configuration options for a messageConsumer used to control how messages are re-delivered when they
+are rolled back.
+May be used server side on a per destination basis via the Broker RedeliveryPlugin{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | backOffMultiplier | _double_ | {html}{html} |
+    | collisionAvoidancePercent | _short_ | {html}{html} |
+    | destination | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}{html} |
+    | initialRedeliveryDelay | _long_ | {html}{html} |
+    | maximumRedeliveries | _int_ | {html}{html} |
+    | maximumRedeliveryDelay | _long_ | {html}{html} |
+    | queue | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | redeliveryDelay | _long_ | {html}{html} |
+    | tempQueue | _boolean_ | {html}{html} |
+    | tempTopic | _boolean_ | {html}{html} |
+    | topic | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | useCollisionAvoidance | _boolean_ | {html}{html} |
+    | useExponentialBackOff | _boolean_ | {html}{html} |
+
+{anchor:redeliveryPolicyMap-element}
+h3. The _[<redeliveryPolicyMap>|#redeliveryPolicyMap-element]_ Element
+    {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | defaultEntry | _[org.apache.activemq.RedeliveryPolicy|#org.apache.activemq.RedeliveryPolicy-types]_ | {html}{html} |
+    | entries | (_java.lang.Object_)\* | {html}A helper method to allow the destination map to be populated from a
+dependency injection framework such as Spring{html} |
+    | redeliveryPolicyEntries | (_java.lang.Object_)\* | {html}Sets the individual entries on the redeliveryPolicyMap{html} |
+
+{anchor:roundRobinDispatchPolicy-element}
+h3. The _[<roundRobinDispatchPolicy>|#roundRobinDispatchPolicy-element]_ Element
+    {html}Simple dispatch policy that sends a message to every subscription that
+matches the message.{html}
+
+{anchor:shared-file-locker-element}
+h3. The _[<shared-file-locker>|#shared-file-locker-element]_ Element
+    {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | directory | _java.io.File_ | {html}{html} |
+    | failIfLocked | _boolean_ | {html}{html} |
+    | lockAcquireSleepInterval | _long_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+
+{anchor:sharedDeadLetterStrategy-element}
+h3. The _[<sharedDeadLetterStrategy>|#sharedDeadLetterStrategy-element]_ Element
+    {html}A default implementation of {@link DeadLetterStrategy} which uses
+a constant destination.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | deadLetterQueue | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}{html} |
+    | enableAudit | _boolean_ | {html}{html} |
+    | processExpired | _boolean_ | {html}{html} |
+    | processNonPersistent | _boolean_ | {html}{html} |
+
+{anchor:simpleAuthenticationPlugin-element}
+h3. The _[<simpleAuthenticationPlugin>|#simpleAuthenticationPlugin-element]_ Element
+    {html}Provides a simple authentication plugin{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | anonymousAccessAllowed | _boolean_ | {html}{html} |
+    | anonymousGroup | _java.lang.String_ | {html}{html} |
+    | anonymousUser | _java.lang.String_ | {html}{html} |
+    | userGroups | _java.util.Map_ | {html}Sets the groups a user is in. The key is the user name and the value is a
+Set of groups{html} |
+    | userPasswords | _java.util.Map_ | {html}Sets the map indexed by user name with the value the password{html} |
+    | users | (_java.lang.Object_)\* | {html}Sets individual users for authentication{html} |
+
+{anchor:simpleAuthorizationMap-element}
+h3. The _[<simpleAuthorizationMap>|#simpleAuthorizationMap-element]_ Element
+    {html}An AuthorizationMap which is configured with individual DestinationMaps for
+each operation.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminACLs | _[org.apache.activemq.filter.DestinationMap|#org.apache.activemq.filter.DestinationMap-types]_ | {html}{html} |
+    | readACLs | _[org.apache.activemq.filter.DestinationMap|#org.apache.activemq.filter.DestinationMap-types]_ | {html}{html} |
+    | tempDestinationAuthorizationEntry | _[org.apache.activemq.security.TempDestinationAuthorizationEntry|#org.apache.activemq.security.TempDestinationAuthorizationEntry-types]_ | {html}{html} |
+    | writeACLs | _[org.apache.activemq.filter.DestinationMap|#org.apache.activemq.filter.DestinationMap-types]_ | {html}{html} |
+
+{anchor:simpleDispatchPolicy-element}
+h3. The _[<simpleDispatchPolicy>|#simpleDispatchPolicy-element]_ Element
+    {html}Simple dispatch policy that sends a message to every subscription that
+matches the message.{html}
+
+{anchor:simpleDispatchSelector-element}
+h3. The _[<simpleDispatchSelector>|#simpleDispatchSelector-element]_ Element
+    {html}Simple dispatch policy that determines if a message can be sent to a subscription{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | destination | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}{html} |
+
+{anchor:simpleJmsMessageConvertor-element}
+h3. The _[<simpleJmsMessageConvertor>|#simpleJmsMessageConvertor-element]_ Element
+    {html}Converts Message from one JMS to another{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | connection | _javax.jms.Connection_ | {html}{html} |
+
+{anchor:simpleMessageGroupMapFactory-element}
+h3. The _[<simpleMessageGroupMapFactory>|#simpleMessageGroupMapFactory-element]_ Element
+    {html}A factory to create instances of {@link SimpleMessageGroupMap} when implementing the 
+<a href="http://activemq.apache.org/message-groups.html">Message Groups</a> functionality.{html}
+
+{anchor:sslContext-element}
+h3. The _[<sslContext>|#sslContext-element]_ Element
+    {html}Extends the SslContext so that it's easier to configure from spring.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | SSLContext | _javax.net.ssl.SSLContext_ | {html}{html} |
+    | keyManagers | (_java.lang.Object_)\* | {html}{html} |
+    | keyStore | _java.lang.String_ | {html}{html} |
+    | keyStoreAlgorithm | _java.lang.String_ | {html}{html} |
+    | keyStoreKeyPassword | _java.lang.String_ | {html}{html} |
+    | keyStorePassword | _java.lang.String_ | {html}{html} |
+    | keyStoreType | _java.lang.String_ | {html}{html} |
+    | protocol | _java.lang.String_ | {html}{html} |
+    | provider | _java.lang.String_ | {html}{html} |
+    | secureRandom | _java.security.SecureRandom_ | {html}{html} |
+    | secureRandomAlgorithm | _java.lang.String_ | {html}{html} |
+    | trustManagers | (_java.lang.Object_)\* | {html}{html} |
+    | trustStore | _java.lang.String_ | {html}{html} |
+    | trustStoreAlgorithm | _java.lang.String_ | {html}{html} |
+    | trustStorePassword | _java.lang.String_ | {html}{html} |
+    | trustStoreType | _java.lang.String_ | {html}{html} |
+
+{anchor:statements-element}
+h3. The _[<statements>|#statements-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | addMessageStatement | _java.lang.String_ | {html}{html} |
+    | binaryDataType | _java.lang.String_ | {html}{html} |
+    | clearDurableLastAckInTxStatement | _java.lang.String_ | {html}{html} |
+    | clearXidFlagStatement | _java.lang.String_ | {html}{html} |
+    | containerNameDataType | _java.lang.String_ | {html}{html} |
+    | createDurableSubStatement | _java.lang.String_ | {html}{html} |
+    | createSchemaStatements | (_java.lang.String_)\* | {html}{html} |
+    | currentDateTimeStatement | _java.lang.String_ | {html}{html} |
+    | deleteOldMessagesStatementWithPriority | _java.lang.String_ | {html}{html} |
+    | deleteSubscriptionStatement | _java.lang.String_ | {html}{html} |
+    | destinationMessageCountStatement | _java.lang.String_ | {html}{html} |
+    | dropAckPKAlterStatementEnd | _java.lang.String_ | {html}{html} |
+    | dropSchemaStatements | (_java.lang.String_)\* | {html}{html} |
+    | durableSubAcksTableName | _java.lang.String_ | {html}{html} |
+    | durableSubscriberMessageCountStatement | _java.lang.String_ | {html}{html} |
+    | durableSubscriberMessageCountStatementWithPriority | _java.lang.String_ | {html}{html} |
+    | findAcksPendingOutcomeStatement | _java.lang.String_ | {html}{html} |
+    | findAllDestinationsStatement | _java.lang.String_ | {html}{html} |
+    | findAllDurableSubMessagesStatement | _java.lang.String_ | {html}{html} |
+    | findAllDurableSubsStatement | _java.lang.String_ | {html}{html} |
+    | findAllMessagesStatement | _java.lang.String_ | {html}{html} |
+    | findDurableSubMessagesStatement | _java.lang.String_ | {html}{html} |
+    | findDurableSubStatement | _java.lang.String_ | {html}{html} |
+    | findLastSequenceIdInAcksStatement | _java.lang.String_ | {html}{html} |
+    | findLastSequenceIdInMsgsStatement | _java.lang.String_ | {html}{html} |
+    | findMessageByIdStatement | _java.lang.String_ | {html}{html} |
+    | findMessageSequenceIdStatement | _java.lang.String_ | {html}{html} |
+    | findMessageStatement | _java.lang.String_ | {html}{html} |
+    | findNextMessagesStatement | _java.lang.String_ | {html}{html} |
+    | findOpsPendingOutcomeStatement | _java.lang.String_ | {html}{html} |
+    | findXidByIdStatement | _java.lang.String_ | {html}{html} |
+    | insertDurablePriorityAckStatement | _java.lang.String_ | {html}{html} |
+    | lastAckedDurableSubscriberMessageStatement | _java.lang.String_ | {html}{html} |
+    | lastProducerSequenceIdStatement | _java.lang.String_ | {html}{html} |
+    | leaseObtainStatement | _java.lang.String_ | {html}{html} |
+    | leaseOwnerStatement | _java.lang.String_ | {html}{html} |
+    | leaseUpdateStatement | _java.lang.String_ | {html}{html} |
+    | lockCreateStatement | _java.lang.String_ | {html}{html} |
+    | lockTableName | _java.lang.String_ | {html}{html} |
+    | lockUpdateStatement | _java.lang.String_ | {html}{html} |
+    | longDataType | _java.lang.String_ | {html}{html} |
+    | messageTableName | _java.lang.String_ | {html}{html} |
+    | msgIdDataType | _java.lang.String_ | {html}{html} |
+    | nextDurableSubscriberMessageStatement | _java.lang.String_ | {html}{html} |
+    | removeAllMessagesStatement | _java.lang.String_ | {html}{html} |
+    | removeAllSubscriptionsStatement | _java.lang.String_ | {html}{html} |
+    | removeMessageStatment | _java.lang.String_ | {html}{html} |
+    | selectDurablePriorityAckStatement | _java.lang.String_ | {html}{html} |
+    | sequenceDataType | _java.lang.String_ | {html}{html} |
+    | stringIdDataType | _java.lang.String_ | {html}{html} |
+    | tablePrefix | _java.lang.String_ | {html}{html} |
+    | updateDurableLastAckInTxStatement | _java.lang.String_ | {html}{html} |
+    | updateDurableLastAckStatement | _java.lang.String_ | {html}{html} |
+    | updateDurableLastAckWithPriorityInTxStatement | _java.lang.String_ | {html}{html} |
+    | updateDurableLastAckWithPriorityStatement | _java.lang.String_ | {html}{html} |
+    | updateLastPriorityAckRowOfDurableSubStatement | _java.lang.String_ | {html}{html} |
+    | updateMessageStatement | _java.lang.String_ | {html}{html} |
+    | updateXidFlagStatement | _java.lang.String_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+    | useLockCreateWhereClause | _boolean_ | {html}{html} |
+
+{anchor:statisticsBrokerPlugin-element}
+h3. The _[<statisticsBrokerPlugin>|#statisticsBrokerPlugin-element]_ Element
+    {html}A StatisticsBrokerPlugin
+You can retrieve a Map Message for a Destination - or
+Broker containing statistics as key-value pairs The message must contain a
+replyTo Destination - else its ignored
+To retrieve stats on the broker send a empty message to ActiveMQ.Statistics.Broker (Queue or Topic)
+With a replyTo set to the destination you want the stats returned to.
+To retrieve stats for a destination - e.g. foo - send an empty message to ActiveMQ.Statistics.Destination.foo
+- this works with wildcards to - you get a message for each wildcard match on the replyTo destination.
+The stats message is a MapMessage populated with statistics for the target{html}
+
+{anchor:storeCursor-element}
+h3. The _[<storeCursor>|#storeCursor-element]_ Element
+    {html}Pending messages{html}
+
+{anchor:storeDurableSubscriberCursor-element}
+h3. The _[<storeDurableSubscriberCursor>|#storeDurableSubscriberCursor-element]_ Element
+    {html}Pending messages for a durable{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | immediatePriorityDispatch | _boolean_ | {html}Ensure that new higher priority messages will get an immediate dispatch
+rather than wait for the end of the current cursor batch.
+Useful when there is a large message backlog and intermittent high priority messages.{html} |
+    | useCache | _boolean_ | {html}{html} |
+
+{anchor:storeUsage-element}
+h3. The _[<storeUsage>|#storeUsage-element]_ Element
+    {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | executor | _java.util.concurrent.ThreadPoolExecutor_ | {html}{html} |
+    | limit | _java.lang.String_ | {html}Sets the memory limit in bytes. Setting the limit in bytes will set the
+usagePortion to 0 since the UsageManager is not going to be portion based
+off the parent.
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | limiter | _[org.apache.activemq.usage.UsageCapacity|#org.apache.activemq.usage.UsageCapacity-types]_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | parent | _T_ | {html}{html} |
+    | percentUsage | _int_ | {html}{html} |
+    | percentUsageMinDelta | _java.lang.String_ | {html}Sets the minimum number of percentage points the usage has to change
+before a UsageListener event is fired by the manager.{html} |
+    | pollingTime | _int_ | {html}{html} |
+    | store | _[org.apache.activemq.store.PersistenceAdapter|#org.apache.activemq.store.PersistenceAdapter-types]_ | {html}{html} |
+    | usagePortion | _float_ | {html}{html} |
+
+{anchor:streamJDBCAdapter-element}
+h3. The _[<streamJDBCAdapter>|#streamJDBCAdapter-element]_ Element
+    {html}This JDBCAdapter inserts and extracts BLOB data using the
+setBinaryStream()/getBinaryStream() operations.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Axion</li>
+</ul>{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:strictOrderDispatchPolicy-element}
+h3. The _[<strictOrderDispatchPolicy>|#strictOrderDispatchPolicy-element]_ Element
+    {html}Dispatch policy that causes every subscription to see messages in the same
+order.{html}
+
+{anchor:sybase-jdbc-adapter-element}
+h3. The _[<sybase-jdbc-adapter>|#sybase-jdbc-adapter-element]_ Element
+    {html}A JDBC Adapter for Sybase databases{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:systemUsage-element}
+h3. The _[<systemUsage>|#systemUsage-element]_ Element
+    {html}Holder for Usage instances for memory, store and temp files Main use case is
+manage memory usage.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adapter | _[org.apache.activemq.store.PersistenceAdapter|#org.apache.activemq.store.PersistenceAdapter-types]_ | {html}{html} |
+    | executor | _java.util.concurrent.ThreadPoolExecutor_ | {html}{html} |
+    | memoryUsage | _[org.apache.activemq.usage.MemoryUsage|#org.apache.activemq.usage.MemoryUsage-types]_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | parent | _[org.apache.activemq.usage.SystemUsage|#org.apache.activemq.usage.SystemUsage-types]_ | {html}{html} |
+    | sendFailIfNoSpace | _boolean_ | {html}Sets whether or not a send() should fail if there is no space free. The
+default value is false which means to block the send() method until space
+becomes available{html} |
+    | sendFailIfNoSpaceAfterTimeout | _long_ | {html}{html} |
+    | sendFailIfNoSpaceExplicitySet | _boolean_ | {html}{html} |
+    | storeUsage | _[org.apache.activemq.usage.StoreUsage|#org.apache.activemq.usage.StoreUsage-types]_ | {html}{html} |
+    | tempStore | _[org.apache.activemq.store.kahadb.plist.PListStore|#org.apache.activemq.store.kahadb.plist.PListStore-types]_ | {html}{html} |
+    | tempUsage | _[org.apache.activemq.usage.TempUsage|#org.apache.activemq.usage.TempUsage-types]_ | {html}{html} |
+
+{anchor:taskRunnerFactory-element}
+h3. The _[<taskRunnerFactory>|#taskRunnerFactory-element]_ Element
+    {html}Manages the thread pool for long running tasks. Long running tasks are not
+always active but when they are active, they may need a few iterations of
+processing for them to become idle. The manager ensures that each task is
+processes but that no one task overtakes the system. This is kinda like
+cooperative multitasking.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | daemon | _boolean_ | {html}{html} |
+    | dedicatedTaskRunner | _boolean_ | {html}{html} |
+    | executor | _java.util.concurrent.ExecutorService_ | {html}{html} |
+    | maxIterationsPerRun | _int_ | {html}{html} |
+    | maxThreadPoolSize | _int_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | priority | _int_ | {html}{html} |
+    | rejectedTaskHandler | _java.util.concurrent.RejectedExecutionHandler_ | {html}{html} |
+    | shutdownAwaitTermination | _long_ | {html}{html} |
+
+{anchor:tempDestinationAuthorizationEntry-element}
+h3. The _[<tempDestinationAuthorizationEntry>|#tempDestinationAuthorizationEntry-element]_ Element
+    {html}Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a temporary
+destination{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | admin | _java.lang.String_ | {html}{html} |
+    | adminACLs | (_java.lang.Object_)\* | {html}{html} |
+    | destination | _[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_ | {html}{html} |
+    | groupClass | _java.lang.String_ | {html}{html} |
+    | queue | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | read | _java.lang.String_ | {html}{html} |
+    | readACLs | (_java.lang.Object_)\* | {html}{html} |
+    | tempQueue | _boolean_ | {html}{html} |
+    | tempTopic | _boolean_ | {html}{html} |
+    | topic | _java.lang.String_ | {html}A helper method to set the destination from a configuration file{html} |
+    | write | _java.lang.String_ | {html}{html} |
+    | writeACLs | (_java.lang.Object_)\* | {html}{html} |
+
+{anchor:tempQueue-element}
+h3. The _[<tempQueue>|#tempQueue-element]_ Element
+    {html}An ActiveMQ Temporary Queue Destination{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | compositeDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | connection | _org.apache.activemq.ActiveMQConnection_ | {html}{html} |
+    | connectionId | _java.lang.String_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | physicalName | _java.lang.String_ | {html}{html} |
+    | properties | _java.util.Properties_ | {html}Get the properties from this instance for storing in JNDI{html} |
+    | sequenceId | _long_ | {html}{html} |
+
+{anchor:tempTopic-element}
+h3. The _[<tempTopic>|#tempTopic-element]_ Element
+    {html}An ActiveMQ Temporary Topic Destination{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | compositeDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | connection | _org.apache.activemq.ActiveMQConnection_ | {html}{html} |
+    | connectionId | _java.lang.String_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | physicalName | _java.lang.String_ | {html}{html} |
+    | properties | _java.util.Properties_ | {html}Get the properties from this instance for storing in JNDI{html} |
+    | sequenceId | _long_ | {html}{html} |
+
+{anchor:tempUsage-element}
+h3. The _[<tempUsage>|#tempUsage-element]_ Element
+    {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | executor | _java.util.concurrent.ThreadPoolExecutor_ | {html}{html} |
+    | limit | _java.lang.String_ | {html}Sets the memory limit in bytes. Setting the limit in bytes will set the
+usagePortion to 0 since the UsageManager is not going to be portion based
+off the parent.
+When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used{html} |
+    | limiter | _[org.apache.activemq.usage.UsageCapacity|#org.apache.activemq.usage.UsageCapacity-types]_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | parent | _T_ | {html}{html} |
+    | percentUsage | _int_ | {html}{html} |
+    | percentUsageMinDelta | _java.lang.String_ | {html}Sets the minimum number of percentage points the usage has to change
+before a UsageListener event is fired by the manager.{html} |
+    | pollingTime | _int_ | {html}{html} |
+    | store | _[org.apache.activemq.store.kahadb.plist.PListStore|#org.apache.activemq.store.kahadb.plist.PListStore-types]_ | {html}{html} |
+    | usagePortion | _float_ | {html}{html} |
+
+{anchor:timeStampingBrokerPlugin-element}
+h3. The _[<timeStampingBrokerPlugin>|#timeStampingBrokerPlugin-element]_ Element
+    {html}A Broker interceptor which updates a JMS Client's timestamp on the message
+with a broker timestamp. Useful when the clocks on client machines are known
+to not be correct and you can only trust the time set on the broker machines.
+
+Enabling this plugin will break JMS compliance since the timestamp that the
+producer sees on the messages after as send() will be different from the
+timestamp the consumer will observe when he receives the message. This plugin
+is not enabled in the default ActiveMQ configuration.
+
+2 new attributes have been added which will allow the administrator some override control
+over the expiration time for incoming messages:
+
+Attribute 'zeroExpirationOverride' can be used to apply an expiration
+time to incoming messages with no expiration defined (messages that would never expire)
+
+Attribute 'ttlCeiling' can be used to apply a limit to the expiration time{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminConnectionContext | _org.apache.activemq.broker.ConnectionContext_ | {html}{html} |
+    | futureOnly | _boolean_ | {html}{html} |
+    | next | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | processNetworkMessages | _java.lang.Boolean_ | {html}{html} |
+    | ttlCeiling | _long_ | {html}setter method for ttlCeiling{html} |
+    | zeroExpirationOverride | _long_ | {html}setter method for zeroExpirationOverride{html} |
+
+{anchor:timedSubscriptionRecoveryPolicy-element}
+h3. The _[<timedSubscriptionRecoveryPolicy>|#timedSubscriptionRecoveryPolicy-element]_ Element
+    {html}This implementation of {@link SubscriptionRecoveryPolicy} will keep a timed
+buffer of messages around in memory and use that to recover new
+subscriptions.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | broker | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | recoverDuration | _long_ | {html}{html} |
+
+{anchor:topic-element}
+h3. The _[<topic>|#topic-element]_ Element
+    {html}An ActiveMQ Topic{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | compositeDestinations | (_[org.apache.activemq.command.ActiveMQDestination|#org.apache.activemq.command.ActiveMQDestination-types]_)\* | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | physicalName | _java.lang.String_ | {html}{html} |
+    | properties | _java.util.Properties_ | {html}Get the properties from this instance for storing in JNDI{html} |
+
+{anchor:traceBrokerPathPlugin-element}
+h3. The _[<traceBrokerPathPlugin>|#traceBrokerPathPlugin-element]_ Element
+    {html}The TraceBrokerPathPlugin can be used in a network of Brokers. Each Broker
+that has the plugin configured, will add it's brokerName to the content
+of a JMS Property. If all Brokers have this property enabled, the path the
+message actually took through the network can be seen in the defined property.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | adminConnectionContext | _org.apache.activemq.broker.ConnectionContext_ | {html}{html} |
+    | next | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | stampProperty | _java.lang.String_ | {html}{html} |
+
+{anchor:transact-database-locker-element}
+h3. The _[<transact-database-locker>|#transact-database-locker-element]_ Element
+    {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | exceptionHandler | _org.apache.activemq.util.Handler_ | {html}{html} |
+    | failIfLocked | _boolean_ | {html}{html} |
+    | lockAcquireSleepInterval | _long_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | queryTimeout | _int_ | {html}{html} |
+
+{anchor:transact-jdbc-adapter-element}
+h3. The _[<transact-jdbc-adapter>|#transact-jdbc-adapter-element]_ Element
+    {html}A JDBC Adapter for Transact-SQL based databases such as SQL Server or Sybase{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | batchStatments | _boolean_ | {html}{html} |
+    | maxRows | _int_ | {html}{html} |
+    | statements | _[org.apache.activemq.store.jdbc.Statements|#org.apache.activemq.store.jdbc.Statements-types]_ | {html}{html} |
+    | useExternalMessageReferences | _boolean_ | {html}{html} |
+
+{anchor:transportConnector-element}
+h3. The _[<transportConnector>|#transportConnector-element]_ Element
+    {html}{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | auditNetworkProducers | _boolean_ | {html}Enable a producer audit on network connections, Traps the case of a missing send reply and resend.
+Note: does not work with conduit=false, networked composite destinations or networked virtual topics{html} |
+    | brokerInfo | _org.apache.activemq.command.BrokerInfo_ | {html}{html} |
+    | brokerService | _[org.apache.activemq.broker.BrokerService|#org.apache.activemq.broker.BrokerService-types]_ | {html}This is called by the BrokerService right before it starts the transport.{html} |
+    | disableAsyncDispatch | _boolean_ | {html}{html} |
+    | discoveryAgent | _org.apache.activemq.transport.discovery.DiscoveryAgent_ | {html}{html} |
+    | discoveryUri | _java.net.URI_ | {html}{html} |
+    | enableStatusMonitor | _boolean_ | {html}{html} |
+    | maximumConsumersAllowedPerConnection | _int_ | {html}{html} |
+    | maximumProducersAllowedPerConnection | _int_ | {html}{html} |
+    | messageAuthorizationPolicy | _org.apache.activemq.security.MessageAuthorizationPolicy_ | {html}Sets the policy used to decide if the current connection is authorized to
+consume a given message{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | rebalanceClusterClients | _boolean_ | {html}{html} |
+    | server | _org.apache.activemq.transport.TransportServer_ | {html}{html} |
+    | taskRunnerFactory | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | updateClusterClients | _boolean_ | {html}{html} |
+    | updateClusterClientsOnRemove | _boolean_ | {html}{html} |
+    | updateClusterFilter | _java.lang.String_ | {html}{html} |
+    | uri | _java.net.URI_ | {html}Sets the server transport URI to use if there is not a
+{@link TransportServer} configured via the
+{@link #setServer(TransportServer)} method. This value is used to lazy
+create a {@link TransportServer} instance{html} |
+
+{anchor:udpTraceBrokerPlugin-element}
+h3. The _[<udpTraceBrokerPlugin>|#udpTraceBrokerPlugin-element]_ Element
+    {html}A Broker interceptor which allows you to trace all operations to a UDP
+socket.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | address | _java.net.SocketAddress_ | {html}{html} |
+    | adminConnectionContext | _org.apache.activemq.broker.ConnectionContext_ | {html}{html} |
+    | broadcast | _boolean_ | {html}{html} |
+    | destination | _java.net.URI_ | {html}{html} |
+    | maxTraceDatagramSize | _int_ | {html}{html} |
+    | next | _[org.apache.activemq.broker.Broker|#org.apache.activemq.broker.Broker-types]_ | {html}{html} |
+    | wireFormat | _org.apache.activemq.wireformat.WireFormat_ | {html}{html} |
+    | wireFormatFactory | _org.apache.activemq.wireformat.WireFormatFactory_ | {html}{html} |
+
+{anchor:uniquePropertyMessageEvictionStrategy-element}
+h3. The _[<uniquePropertyMessageEvictionStrategy>|#uniquePropertyMessageEvictionStrategy-element]_ Element
+    {html}An eviction strategy which evicts the oldest message within messages with the same property value{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | evictExpiredMessagesHighWatermark | _int_ | {html}Sets the high water mark on which we will eagerly evict expired messages from RAM{html} |
+    | propertyName | _java.lang.String_ | {html}{html} |
+
+{anchor:usageCapacity-element}
+h3. The _[<usageCapacity>|#usageCapacity-element]_ Element
+    {html}Identify if a limit has been reached{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | limit | _long_ | {html}{html} |
+
+{anchor:virtualDestinationInterceptor-element}
+h3. The _[<virtualDestinationInterceptor>|#virtualDestinationInterceptor-element]_ Element
+    {html}Implements <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual Topics</a>.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | virtualDestinations | (_[org.apache.activemq.broker.region.virtual.VirtualDestination|#org.apache.activemq.broker.region.virtual.VirtualDestination-types]_)\* | {html}{html} |
+
+{anchor:virtualSelectorCacheBrokerPlugin-element}
+h3. The _[<virtualSelectorCacheBrokerPlugin>|#virtualSelectorCacheBrokerPlugin-element]_ Element
+    {html}A plugin which allows the caching of the selector from a subscription queue.
+<p/>
+This stops the build-up of unwanted messages, especially when consumers may
+disconnect from time to time when using virtual destinations.
+<p/>
+This is influenced by code snippets developed by Maciej Rakowicz{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | persistFile | _java.io.File_ | {html}Sets the location of the persistent cache{html} |
+
+{anchor:virtualTopic-element}
+h3. The _[<virtualTopic>|#virtualTopic-element]_ Element
+    {html}Creates <a href="http://activemq.org/site/virtual-destinations.html">Virtual
+Topics</a> using a prefix and postfix. The virtual destination creates a
+wildcard that is then used to look up all active queue subscriptions which
+match.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | local | _boolean_ | {html}{html} |
+    | name | _java.lang.String_ | {html}{html} |
+    | postfix | _java.lang.String_ | {html}Sets any postix used to identify the queue consumers{html} |
+    | prefix | _java.lang.String_ | {html}Sets the prefix wildcard used to identify the queue consumers for a given
+topic{html} |
+    | selectorAware | _boolean_ | {html}Indicates whether the selectors of consumers are used to determine dispatch
+to a virtual destination, when true only messages matching an existing 
+consumer will be dispatched.{html} |
+
+{anchor:vmCursor-element}
+h3. The _[<vmCursor>|#vmCursor-element]_ Element
+    {html}Pending messages held{html}
+
+{anchor:vmDurableCursor-element}
+h3. The _[<vmDurableCursor>|#vmDurableCursor-element]_ Element
+    {html}Pending{html}
+
+{anchor:vmQueueCursor-element}
+h3. The _[<vmQueueCursor>|#vmQueueCursor-element]_ Element
+    {html}Pending messages{html}
+
+{anchor:xaConnectionFactory-element}
+h3. The _[<xaConnectionFactory>|#xaConnectionFactory-element]_ Element
+    {html}A <a href="http://www.springframework.org/">Spring</a> enhanced XA connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html}
+h4. Properties
+    || Property Name || Type || Description ||
+    | alwaysSessionAsync | _boolean_ | {html}If this flag is not set then a separate thread is not used for dispatching messages for each Session in
+the Connection. However, a separate thread is always used if there is more than one session, or the session
+isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
+happens asynchronously.{html} |
+    | alwaysSyncSend | _boolean_ | {html}Set true if always require messages to be sync sent{html} |
+    | auditDepth | _int_ | {html}{html} |
+    | auditMaximumProducerNumber | _int_ | {html}{html} |
+    | beanName | _java.lang.String_ | {html}{html} |
+    | blobTransferPolicy | _org.apache.activemq.blob.BlobTransferPolicy_ | {html}Sets the policy used to describe how out-of-band BLOBs (Binary Large
+OBjects) are transferred from producers to brokers to consumers{html} |
+    | brokerURL | _java.lang.String_ | {html}Sets the <a
+href="http://activemq.apache.org/configuring-transports.html">connection
+URL</a> used to connect to the ActiveMQ broker.{html} |
+    | checkForDuplicates | _boolean_ | {html}{html} |
+    | clientID | _java.lang.String_ | {html}Sets the JMS clientID to use for the created connection. Note that this
+can only be used by one connection at once so generally its a better idea
+to set the clientID on a Connection{html} |
+    | clientIDPrefix | _java.lang.String_ | {html}Sets the prefix used by autogenerated JMS Client ID values which are used
+if the JMS client does not explicitly specify on.{html} |
+    | clientIdGenerator | _org.apache.activemq.util.IdGenerator_ | {html}{html} |
+    | clientInternalExceptionListener | _org.apache.activemq.ClientInternalExceptionListener_ | {html}Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory){html} |
+    | closeTimeout | _int_ | {html}Sets the timeout before a close is considered complete. Normally a
+close() on a connection waits for confirmation from the broker; this
+allows that operation to timeout to save the client hanging if there is
+no broker{html} |
+    | connectionIDPrefix | _java.lang.String_ | {html}Sets the prefix used by connection id generator{html} |
+    | connectionIdGenerator | _org.apache.activemq.util.IdGenerator_ | {html}{html} |
+    | consumerFailoverRedeliveryWaitPeriod | _long_ | {html}{html} |
+    | copyMessageOnSend | _boolean_ | {html}Should a JMS message be copied to a new JMS Message object as part of the
+send() method in JMS. This is enabled by default to be compliant with the
+JMS specification. You can disable it if you do not mutate JMS messages
+after they are sent for a performance boost{html} |
+    | disableTimeStampsByDefault | _boolean_ | {html}Sets whether or not timestamps on messages should be disabled or not. If
+you disable them it adds a small performance boost.{html} |
+    | dispatchAsync | _boolean_ | {html}Enables or disables the default setting of whether or not consumers have
+their messages <a
+href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
+synchronously or asynchronously by the broker</a>. For non-durable
+topics for example we typically dispatch synchronously by default to
+minimize context switches which boost performance. However sometimes its
+better to go slower to ensure that a single blocked consumer socket does
+not block delivery to other consumers.{html} |
+    | exceptionListener | _[javax.jms.ExceptionListener|#javax.jms.ExceptionListener-types]_ | {html}Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
+is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
+an exception listener.
+<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
+on connection (as it will be if more than one connection is subsequently created by this connection factory){html} |
+    | exclusiveConsumer | _boolean_ | {html}Enables or disables whether or not queue consumers should be exclusive or
+not for example to preserve ordering when not using <a
+href="http://activemq.apache.org/message-groups.html">Message Groups</a>{html} |
+    | maxThreadPoolSize | _int_ | {html}{html} |
+    | messagePrioritySupported | _boolean_ | {html}{html} |
+    | nestedMapAndListEnabled | _boolean_ | {html}Enables/disables whether or not Message properties and MapMessage entries
+support <a
+href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
+Structures</a> of Map and List objects{html} |
+    | nonBlockingRedelivery | _boolean_ | {html}When true a MessageConsumer will not stop Message delivery before re-delivering Messages
+from a rolled back transaction.  This implies that message order will not be preserved and
+also will result in the TransactedIndividualAck option to be enabled.{html} |
+    | objectMessageSerializationDefered | _boolean_ | {html}When an object is set on an ObjectMessage, the JMS spec requires the
+object to be serialized by that set method. Enabling this flag causes the
+object to not get serialized. The object may subsequently get serialized
+if the message needs to be sent over a socket or stored to disk.{html} |
+    | optimizeAcknowledge | _boolean_ | {html}{html} |
+    | optimizeAcknowledgeTimeOut | _long_ | {html}The max time in milliseconds between optimized ack batches{html} |
+    | optimizedAckScheduledAckInterval | _long_ | {html}Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
+to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
+will not do any background Message acknowledgment.{html} |
+    | optimizedMessageDispatch | _boolean_ | {html}If this flag is set then an larger prefetch limit is used - only
+applicable for durable topic subscribers.{html} |
+    | password | _java.lang.String_ | {html}Sets the JMS password used for connections created from this factory{html} |
+    | prefetchPolicy | _[org.apache.activemq.ActiveMQPrefetchPolicy|#org.apache.activemq.ActiveMQPrefetchPolicy-types]_ | {html}Sets the <a
+href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
+policy</a> for consumers created by this connection.{html} |
+    | producerWindowSize | _int_ | {html}{html} |
+    | properties | _java.util.Properties_ | {html}Get the properties from this instance for storing in JNDI{html} |
+    | redeliveryPolicy | _[org.apache.activemq.RedeliveryPolicy|#org.apache.activemq.RedeliveryPolicy-types]_ | {html}Sets the global default redelivery policy to be used when a message is delivered
+but the session is rolled back{html} |
+    | redeliveryPolicyMap | _[org.apache.activemq.broker.region.policy.RedeliveryPolicyMap|#org.apache.activemq.broker.region.policy.RedeliveryPolicyMap-types]_ | {html}Sets the global redelivery policy mapping to be used when a message is delivered
+but the session is rolled back{html} |
+    | rejectedTaskHandler | _java.util.concurrent.RejectedExecutionHandler_ | {html}{html} |
+    | sendAcksAsync | _boolean_ | {html}{html} |
+    | sendTimeout | _int_ | {html}{html} |
+    | sessionTaskRunner | _[org.apache.activemq.thread.TaskRunnerFactory|#org.apache.activemq.thread.TaskRunnerFactory-types]_ | {html}{html} |
+    | statsEnabled | _boolean_ | {html}{html} |
+    | transactedIndividualAck | _boolean_ | {html}when true, submit individual transacted acks immediately rather than with transaction completion.
+This allows the acks to represent delivery status which can be persisted on rollback
+Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true{html} |
+    | transformer | _org.apache.activemq.MessageTransformer_ | {html}Sets the transformer used to transform messages before they are sent on
+to the JMS bus or when they are received from the bus but before they are
+delivered to the JMS client{html} |
+    | transportListener | _org.apache.activemq.transport.TransportListener_ | {html}Allows a listener to be configured on the ConnectionFactory so that when this factory is used
+with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
+a transport listener.{html} |
+    | useAsyncSend | _boolean_ | {html}Forces the use of <a
+href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
+adds a massive performance boost; but means that the send() method will
+return immediately whether the message has been sent or not which could
+lead to message loss.{html} |
+    | useBeanNameAsClientIdPrefix | _boolean_ | {html}{html} |
+    | useCompression | _boolean_ | {html}Enables the use of compression of the message bodies{html} |
+    | useDedicatedTaskRunner | _boolean_ | {html}{html} |
+    | useRetroactiveConsumer | _boolean_ | {html}Sets whether or not retroactive consumers are enabled. Retroactive
+consumers allow non-durable topic subscribers to receive old messages
+that were published before the non-durable subscriber started.{html} |
+    | userName | _java.lang.String_ | {html}Sets the JMS userName used by connections created by this factory{html} |
+    | warnAboutUnstartedConnectionTimeout | _long_ | {html}Enables the timeout from a connection creation to when a warning is
+generated if the connection is not properly started via
+{@link Connection#start()} and a message is received by a consumer. It is
+a very common gotcha to forget to <a
+href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
+the connection</a> so this option makes the default case to create a
+warning if the user forgets. To disable the warning just set the value to <
+0 (say -1).{html} |
+    | watchTopicAdvisories | _boolean_ | {html}{html} |
+
+h3. Element Index
+    | _[<abortSlowConsumerStrategy>|#abortSlowConsumerStrategy-element]_ | {html}Abort slow consumers when they reach the configured threshold of slowness, default is slow for 30 seconds{html} |
+    | _[<amqPersistenceAdapter>|#amqPersistenceAdapter-element]_ | {html}An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.{html} |
+    | _[<amqPersistenceAdapterFactory>|#amqPersistenceAdapterFactory-element]_ | {html}An implementation of {@link PersistenceAdapterFactory}{html} |
+    | _[<authenticationUser>|#authenticationUser-element]_ | {html}A helper object used to configure simple authentiaction plugin{html} |
+    | _[<authorizationEntry>|#authorizationEntry-element]_ | {html}Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a specific
+destination or a hierarchical wildcard area of destinations.{html} |
+    | _[<authorizationMap>|#authorizationMap-element]_ | {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies. Each entry in the map represents the authorization ACLs
+for each operation.{html} |
+    | _[<authorizationPlugin>|#authorizationPlugin-element]_ | {html}An authorization plugin where each operation on a destination is checked
+against an authorizationMap{html} |
+    | _[<axionJDBCAdapter>|#axionJDBCAdapter-element]_ | {html}Axion specific Adapter.
+
+Axion does not seem to support ALTER statements or sub-selects.  This means:
+- We cannot auto upgrade the schema was we roll out new versions of ActiveMQ
+- We cannot delete durable sub messages that have be acknowledged by all consumers.{html} |
+    | _[<blobJDBCAdapter>|#blobJDBCAdapter-element]_ | {html}This JDBCAdapter inserts and extracts BLOB data using the getBlob()/setBlob()
+operations. This is a little more involved since to insert a blob you have
+to:
+
+1: insert empty blob. 2: select the blob 3: finally update the blob with data
+value.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html} |
+    | _[<broker>|#broker-element]_ | {html}An ActiveMQ Message Broker. It consists of a number of transport
+connectors, network connectors and a bunch of properties which can be used to
+configure the broker as its lazily created.{html} |
+    | _[<brokerService>|#brokerService-element]_ | {html}Manages the lifecycle of an ActiveMQ Broker. A BrokerService consists of a
+number of transport connectors, network connectors and a bunch of properties
+which can be used to configure the broker as its lazily created.{html} |
+    | _[<bytesJDBCAdapter>|#bytesJDBCAdapter-element]_ | {html}This JDBCAdapter inserts and extracts BLOB data using the
+setBytes()/getBytes() operations. The databases/JDBC drivers that use this
+adapter are:{html} |
+    | _[<cachedLDAPAuthorizationMap>|#cachedLDAPAuthorizationMap-element]_ | {html}A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update authorization
+policy.{html} |
+    | _[<commandAgent>|#commandAgent-element]_ | {html}An agent which listens to commands on a JMS destination{html} |
+    | _[<compositeDemandForwardingBridge>|#compositeDemandForwardingBridge-element]_ | {html}A demand forwarding bridge which works with multicast style transports where
+a single Transport could be communicating with multiple remote brokers{html} |
+    | _[<compositeQueue>|#compositeQueue-element]_ | {html}Represents a virtual queue which forwards to a number of other destinations.{html} |
+    | _[<compositeTopic>|#compositeTopic-element]_ | {html}Represents a virtual topic which forwards to a number of other destinations.{html} |
+    | _[<conditionalNetworkBridgeFilterFactory>|#conditionalNetworkBridgeFilterFactory-element]_ | {html}implement conditional behaviour for queue consumers,
+allows replaying back to origin if no consumers are present on the local broker
+after a configurable delay, irrespective of the networkTTL
+Also allows rate limiting of messages through the network, useful for static includes{html} |
+    | _[<connectionDotFilePlugin>|#connectionDotFilePlugin-element]_ | {html}A <a href="http://www.graphviz.org/">DOT</a> file creator plugin which
+creates a DOT file showing the current connections{html} |
+    | _[<connectionFactory>|#connectionFactory-element]_ | {html}A <a href="http://www.springframework.org/">Spring</a> enhanced connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html} |
+    | _[<constantPendingMessageLimitStrategy>|#constantPendingMessageLimitStrategy-element]_ | {html}This PendingMessageLimitStrategy is configured to a constant value for all subscriptions.{html} |
+    | _[<database-locker>|#database-locker-element]_ | {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<db2JDBCAdapter>|#db2JDBCAdapter-element]_ | {html}{html} |
+    | _[<defaultIOExceptionHandler>|#defaultIOExceptionHandler-element]_ | {html}{html} |
+    | _[<defaultJDBCAdapter>|#defaultJDBCAdapter-element]_ | {html}Implements all the default JDBC operations that are used by the JDBCPersistenceAdapter. <p/> sub-classing is
+encouraged to override the default implementation of methods to account for differences in JDBC Driver
+implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using the getBytes()/setBytes() operations. <p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html} |
+    | _[<defaultNetworkBridgeFilterFactory>|#defaultNetworkBridgeFilterFactory-element]_ | {html}implement default behaviour, filter that will not allow resend to origin
+based on brokerPath and which respects networkTTL{html} |
+    | _[<defaultUsageCapacity>|#defaultUsageCapacity-element]_ | {html}Identify if a limit has been reached{html} |
+    | _[<demandForwardingBridge>|#demandForwardingBridge-element]_ | {html}Forwards messages from the local broker to the remote broker based on demand.{html} |
+    | _[<destinationDotFilePlugin>|#destinationDotFilePlugin-element]_ | {html}A <a href="http://www.graphviz.org/">DOT</a> 
+file creator plugin which creates a DOT file showing the current topic & queue hierarchies.{html} |
+    | _[<destinationEntry>|#destinationEntry-element]_ | {html}A default entry in a DestinationMap which holds a single value.{html} |
+    | _[<destinationPathSeparatorPlugin>|#destinationPathSeparatorPlugin-element]_ | {html}{html} |
+    | _[<discardingDLQBrokerPlugin>|#discardingDLQBrokerPlugin-element]_ | {html}{html} |
+    | _[<fileCursor>|#fileCursor-element]_ | {html}Pending messages{html} |
+    | _[<fileDurableSubscriberCursor>|#fileDurableSubscriberCursor-element]_ | {html}Pending messages for durable subscribers{html} |
+    | _[<fileQueueCursor>|#fileQueueCursor-element]_ | {html}Pending{html} |
+    | _[<filteredDestination>|#filteredDestination-element]_ | {html}Represents a destination which is filtered using some predicate such as a selector
+so that messages are only dispatched to the destination if they match the filter.{html} |
+    | _[<filteredKahaDB>|#filteredKahaDB-element]_ | {html}{html} |
+    | _[<fixedCountSubscriptionRecoveryPolicy>|#fixedCountSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+count of last messages.{html} |
+    | _[<fixedSizedSubscriptionRecoveryPolicy>|#fixedSizedSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
+amount of memory available in RAM for message history which is evicted in
+time order.{html} |
+    | _[<forcePersistencyModeBroker>|#forcePersistencyModeBroker-element]_ | {html}A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.{html} |
+    | _[<forcePersistencyModeBrokerPlugin>|#forcePersistencyModeBrokerPlugin-element]_ | {html}A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 
+
+Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
+messages.{html} |
+    | _[<forwardingBridge>|#forwardingBridge-element]_ | {html}Forwards all messages from the local broker to the remote broker.{html} |
+    | _[<hsqldb-jdbc-adapter>|#hsqldb-jdbc-adapter-element]_ | {html}{html} |
+    | _[<imageBasedJDBCAdaptor>|#imageBasedJDBCAdaptor-element]_ | {html}Provides JDBCAdapter since that uses
+IMAGE datatype to hold binary data.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Sybase</li>
+<li>MS SQL</li>
+</ul>{html} |
+    | _[<inboundQueueBridge>|#inboundQueueBridge-element]_ | {html}Create an Inbound Queue Bridge.  By default this class uses the sname name for
+both the inbound and outbound queue.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud queue names
+separately.{html} |
+    | _[<inboundTopicBridge>|#inboundTopicBridge-element]_ | {html}Create an Inbound Topic Bridge.  By default this class uses the topic name for
+both the inbound and outbound topic.  This behavior can be overridden however
+by using the setter methods to configure both the inbound and outboud topic names
+separately.{html} |
+    | _[<individualDeadLetterStrategy>|#individualDeadLetterStrategy-element]_ | {html}A {@link DeadLetterStrategy} where each destination has its own individual
+DLQ using the subject naming hierarchy.{html} |
+    | _[<informixJDBCAdapter>|#informixJDBCAdapter-element]_ | {html}JDBC Adapter for Informix database.
+Because Informix database restricts length of composite primary keys, length of 
+<i>container name</i> field and <i>subscription id</i> field must be reduced to 150 characters.
+Therefore be sure not to use longer names for container name and subscription id than 150 characters.{html} |
+    | _[<jDBCIOExceptionHandler>|#jDBCIOExceptionHandler-element]_ | {html}{html} |
+    | _[<jaasAuthenticationPlugin>|#jaasAuthenticationPlugin-element]_ | {html}Provides a JAAS based authentication plugin{html} |
+    | _[<jaasCertificateAuthenticationPlugin>|#jaasCertificateAuthenticationPlugin-element]_ | {html}Provides a JAAS based SSL certificate authentication plugin{html} |
+    | _[<jaasDualAuthenticationPlugin>|#jaasDualAuthenticationPlugin-element]_ | {html}Provides a JAAS based authentication plugin{html} |
+    | _[<jdbcPersistenceAdapter>|#jdbcPersistenceAdapter-element]_ | {html}A {@link PersistenceAdapter} implementation using JDBC for persistence
+storage.
+
+This persistence adapter will correctly remember prepared XA transactions,
+but it will not keep track of local transaction commits so that operations
+performed against the Message store are done as a single uow.{html} |
+    | _[<jmsQueueConnector>|#jmsQueueConnector-element]_ | {html}A Bridge to other JMS Queue providers{html} |
+    | _[<jmsTopicConnector>|#jmsTopicConnector-element]_ | {html}A Bridge to other JMS Topic providers{html} |
+    | _[<journalPersistenceAdapter>|#journalPersistenceAdapter-element]_ | {html}An implementation of {@link PersistenceAdapter} designed for use with a
+{@link Journal} and then check pointing asynchronously on a timeout with some
+other long term persistent storage.{html} |
+    | _[<journalPersistenceAdapterFactory>|#journalPersistenceAdapterFactory-element]_ | {html}Factory class that can create PersistenceAdapter objects.{html} |
+    | _[<journaledJDBC>|#journaledJDBC-element]_ | {html}Creates a default persistence model using the Journal and JDBC{html} |
+    | _[<kahaDB>|#kahaDB-element]_ | {html}An implementation of {@link PersistenceAdapter} designed for use with
+KahaDB - Embedded Lightweight Non-Relational Database{html} |
+    | _[<kahaPersistenceAdapter>|#kahaPersistenceAdapter-element]_ | {html}{html} |
+    | _[<lDAPAuthorizationMap>|#lDAPAuthorizationMap-element]_ | {html}An {@link AuthorizationMap} which uses LDAP{html} |
+    | _[<lastImageSubscriptionRecoveryPolicy>|#lastImageSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will only keep the
+last message.{html} |
+    | _[<ldapNetworkConnector>|#ldapNetworkConnector-element]_ | {html}class to create dynamic network connectors listed in an directory
+server using the LDAP v3 protocol as defined in RFC 2251, the
+entries listed in the directory server must implement the ipHost
+and ipService objectClasses as defined in RFC 2307.{html} |
+    | _[<lease-database-locker>|#lease-database-locker-element]_ | {html}Represents an exclusive lease on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<levelDB>|#levelDB-element]_ | {html}An implementation of {@link org.apache.activemq.store.PersistenceAdapter} designed for use with
+LevelDB - Embedded Lightweight Non-Relational Database{html} |
+    | _[<loggingBrokerPlugin>|#loggingBrokerPlugin-element]_ | {html}A simple Broker intercepter which allows you to enable/disable logging.{html} |
+    | _[<mKahaDB>|#mKahaDB-element]_ | {html}An implementation of {@link org.apache.activemq.store.PersistenceAdapter}  that supports
+distribution of destinations across multiple kahaDB persistence adapters{html} |
+    | _[<managementContext>|#managementContext-element]_ | {html}An abstraction over JMX mbean registration{html} |
+    | _[<masterConnector>|#masterConnector-element]_ | {html}Connects a Slave Broker to a Master when using <a
+href="http://activemq.apache.org/masterslave.html">Master Slave</a> for High
+Availability of messages.{html} |
+    | _[<maxdb-jdbc-adapter>|#maxdb-jdbc-adapter-element]_ | {html}JDBC Adapter for the MaxDB database.{html} |
+    | _[<memoryPersistenceAdapter>|#memoryPersistenceAdapter-element]_ | {html}{html} |
+    | _[<memoryUsage>|#memoryUsage-element]_ | {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html} |
+    | _[<messageGroupHashBucketFactory>|#messageGroupHashBucketFactory-element]_ | {html}A factory to create instances of {@link SimpleMessageGroupMap} when
+implementing the <a
+href="http://activemq.apache.org/message-groups.html">Message
+Groups</a> functionality.{html} |
+    | _[<mirroredQueue>|#mirroredQueue-element]_ | {html}Creates <a href="http://activemq.org/site/mirrored-queues.html">Mirrored
+Queue</a> using a prefix and postfix to define the topic name on which to mirror the queue to.{html} |
+    | _[<multicastNetworkConnector>|#multicastNetworkConnector-element]_ | {html}A network connector which uses some kind of multicast-like transport that
+communicates with potentially many remote brokers over a single logical
+{@link Transport} instance such as when using multicast.
+
+This implementation does not depend on multicast at all; any other group
+based transport could be used.{html} |
+    | _[<multicastTraceBrokerPlugin>|#multicastTraceBrokerPlugin-element]_ | {html}A Broker interceptor which allows you to trace all operations to a Multicast
+socket.{html} |
+    | _[<mysql-jdbc-adapter>|#mysql-jdbc-adapter-element]_ | {html}{html} |
+    | _[<networkConnector>|#networkConnector-element]_ | {html}A network connector which uses a discovery agent to detect the remote brokers
+available and setup a connection to each available remote broker{html} |
+    | _[<noSubscriptionRecoveryPolicy>|#noSubscriptionRecoveryPolicy-element]_ | {html}This SubscriptionRecoveryPolicy disable recovery of messages.{html} |
+    | _[<oldestMessageEvictionStrategy>|#oldestMessageEvictionStrategy-element]_ | {html}An eviction strategy which evicts the oldest message first (which is the
+default).{html} |
+    | _[<oldestMessageWithLowestPriorityEvictionStrategy>|#oldestMessageWithLowestPriorityEvictionStrategy-element]_ | {html}An eviction strategy which evicts the oldest message with the lowest priority first.{html} |
+    | _[<oracleBlobJDBCAdapter>|#oracleBlobJDBCAdapter-element]_ | {html}Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html} |
+    | _[<oracleJDBCAdapter>|#oracleJDBCAdapter-element]_ | {html}Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>{html} |
+    | _[<outboundQueueBridge>|#outboundQueueBridge-element]_ | {html}Create an Outbound Queue Bridge.  By default the bridge uses the same
+name for both the inbound and outbound queues, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+queue names.{html} |
+    | _[<outboundTopicBridge>|#outboundTopicBridge-element]_ | {html}Create an Outbound Topic Bridge.  By default the bridge uses the same
+name for both the inbound and outbound topics, however this can be altered
+by using the public setter methods to configure both inbound and outbound
+topic names.{html} |
+    | _[<pListStore>|#pListStore-element]_ | {html}{html} |
+    | _[<policyEntry>|#policyEntry-element]_ | {html}Represents an entry in a {@link PolicyMap} for assigning policies to a
+specific destination or a hierarchical wildcard area of destinations.{html} |
+    | _[<policyMap>|#policyMap-element]_ | {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.{html} |
+    | _[<postgresql-jdbc-adapter>|#postgresql-jdbc-adapter-element]_ | {html}Implements all the default JDBC operations that are used
+by the JDBCPersistenceAdapter.
+<p/>
+Subclassing is encouraged to override the default
+implementation of methods to account for differences
+in JDBC Driver implementations.
+<p/>
+The JDBCAdapter inserts and extracts BLOB data using the
+getBytes()/setBytes() operations.
+<p/>
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li></li>
+</ul>{html} |
+    | _[<prefetchPolicy>|#prefetchPolicy-element]_ | {html}Defines the prefetch message policies for different types of consumers{html} |
+    | _[<prefetchRatePendingMessageLimitStrategy>|#prefetchRatePendingMessageLimitStrategy-element]_ | {html}This PendingMessageLimitStrategy sets the maximum pending message limit value to be
+a multiplier of the prefetch limit of the subscription.{html} |
+    | _[<priorityNetworkDispatchPolicy>|#priorityNetworkDispatchPolicy-element]_ | {html}dispatch policy that ignores lower priority duplicate network consumers,
+used in conjunction with network bridge suppresDuplicateTopicSubscriptions{html} |
+    | _[<proxyConnector>|#proxyConnector-element]_ | {html}{html} |
+    | _[<queryBasedSubscriptionRecoveryPolicy>|#queryBasedSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will perform a user
+specific query mechanism to load any messages they may have missed.{html} |
+    | _[<queue>|#queue-element]_ | {html}An ActiveMQ Queue{html} |
+    | _[<queueDispatchSelector>|#queueDispatchSelector-element]_ | {html}Queue dispatch policy that determines if a message can be sent to a subscription{html} |
+    | _[<reconnectionPolicy>|#reconnectionPolicy-element]_ | {html}A policy object that defines how a {@link JmsConnector} deals with
+reconnection of the local and foreign connections.{html} |
+    | _[<redeliveryPlugin>|#redeliveryPlugin-element]_ | {html}Replace regular DLQ handling with redelivery via a resend to the original destination
+after a delay
+A destination matching RedeliveryPolicy controls the quantity and delay for re-sends
+If there is no matching policy or an existing policy limit is exceeded by default
+regular DLQ processing resumes. This is controlled via sendToDlqIfMaxRetriesExceeded
+and fallbackToDeadLetter{html} |
+    | _[<redeliveryPolicy>|#redeliveryPolicy-element]_ | {html}Configuration options for a messageConsumer used to control how messages are re-delivered when they
+are rolled back.
+May be used server side on a per destination basis via the Broker RedeliveryPlugin{html} |
+    | _[<redeliveryPolicyMap>|#redeliveryPolicyMap-element]_ | {html}Represents a destination based configuration of policies so that individual
+destinations or wildcard hierarchies of destinations can be configured using
+different policies.{html} |
+    | _[<roundRobinDispatchPolicy>|#roundRobinDispatchPolicy-element]_ | {html}Simple dispatch policy that sends a message to every subscription that
+matches the message.{html} |
+    | _[<shared-file-locker>|#shared-file-locker-element]_ | {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<sharedDeadLetterStrategy>|#sharedDeadLetterStrategy-element]_ | {html}A default implementation of {@link DeadLetterStrategy} which uses
+a constant destination.{html} |
+    | _[<simpleAuthenticationPlugin>|#simpleAuthenticationPlugin-element]_ | {html}Provides a simple authentication plugin{html} |
+    | _[<simpleAuthorizationMap>|#simpleAuthorizationMap-element]_ | {html}An AuthorizationMap which is configured with individual DestinationMaps for
+each operation.{html} |
+    | _[<simpleDispatchPolicy>|#simpleDispatchPolicy-element]_ | {html}Simple dispatch policy that sends a message to every subscription that
+matches the message.{html} |
+    | _[<simpleDispatchSelector>|#simpleDispatchSelector-element]_ | {html}Simple dispatch policy that determines if a message can be sent to a subscription{html} |
+    | _[<simpleJmsMessageConvertor>|#simpleJmsMessageConvertor-element]_ | {html}Converts Message from one JMS to another{html} |
+    | _[<simpleMessageGroupMapFactory>|#simpleMessageGroupMapFactory-element]_ | {html}A factory to create instances of {@link SimpleMessageGroupMap} when implementing the 
+<a href="http://activemq.apache.org/message-groups.html">Message Groups</a> functionality.{html} |
+    | _[<sslContext>|#sslContext-element]_ | {html}Extends the SslContext so that it's easier to configure from spring.{html} |
+    | _[<statements>|#statements-element]_ | {html}{html} |
+    | _[<statisticsBrokerPlugin>|#statisticsBrokerPlugin-element]_ | {html}A StatisticsBrokerPlugin
+You can retrieve a Map Message for a Destination - or
+Broker containing statistics as key-value pairs The message must contain a
+replyTo Destination - else its ignored
+To retrieve stats on the broker send a empty message to ActiveMQ.Statistics.Broker (Queue or Topic)
+With a replyTo set to the destination you want the stats returned to.
+To retrieve stats for a destination - e.g. foo - send an empty message to ActiveMQ.Statistics.Destination.foo
+- this works with wildcards to - you get a message for each wildcard match on the replyTo destination.
+The stats message is a MapMessage populated with statistics for the target{html} |
+    | _[<storeCursor>|#storeCursor-element]_ | {html}Pending messages{html} |
+    | _[<storeDurableSubscriberCursor>|#storeDurableSubscriberCursor-element]_ | {html}Pending messages for a durable{html} |
+    | _[<storeUsage>|#storeUsage-element]_ | {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html} |
+    | _[<streamJDBCAdapter>|#streamJDBCAdapter-element]_ | {html}This JDBCAdapter inserts and extracts BLOB data using the
+setBinaryStream()/getBinaryStream() operations.
+
+The databases/JDBC drivers that use this adapter are:
+<ul>
+<li>Axion</li>
+</ul>{html} |
+    | _[<strictOrderDispatchPolicy>|#strictOrderDispatchPolicy-element]_ | {html}Dispatch policy that causes every subscription to see messages in the same
+order.{html} |
+    | _[<sybase-jdbc-adapter>|#sybase-jdbc-adapter-element]_ | {html}A JDBC Adapter for Sybase databases{html} |
+    | _[<systemUsage>|#systemUsage-element]_ | {html}Holder for Usage instances for memory, store and temp files Main use case is
+manage memory usage.{html} |
+    | _[<taskRunnerFactory>|#taskRunnerFactory-element]_ | {html}Manages the thread pool for long running tasks. Long running tasks are not
+always active but when they are active, they may need a few iterations of
+processing for them to become idle. The manager ensures that each task is
+processes but that no one task overtakes the system. This is kinda like
+cooperative multitasking.{html} |
+    | _[<tempDestinationAuthorizationEntry>|#tempDestinationAuthorizationEntry-element]_ | {html}Represents an entry in a {@link DefaultAuthorizationMap} for assigning
+different operations (read, write, admin) of user roles to a temporary
+destination{html} |
+    | _[<tempQueue>|#tempQueue-element]_ | {html}An ActiveMQ Temporary Queue Destination{html} |
+    | _[<tempTopic>|#tempTopic-element]_ | {html}An ActiveMQ Temporary Topic Destination{html} |
+    | _[<tempUsage>|#tempUsage-element]_ | {html}Used to keep track of how much of something is being used so that a
+productive working set usage can be controlled. Main use case is manage
+memory usage.{html} |
+    | _[<timeStampingBrokerPlugin>|#timeStampingBrokerPlugin-element]_ | {html}A Broker interceptor which updates a JMS Client's timestamp on the message
+with a broker timestamp. Useful when the clocks on client machines are known
+to not be correct and you can only trust the time set on the broker machines.
+
+Enabling this plugin will break JMS compliance since the timestamp that the
+producer sees on the messages after as send() will be different from the
+timestamp the consumer will observe when he receives the message. This plugin
+is not enabled in the default ActiveMQ configuration.
+
+2 new attributes have been added which will allow the administrator some override control
+over the expiration time for incoming messages:
+
+Attribute 'zeroExpirationOverride' can be used to apply an expiration
+time to incoming messages with no expiration defined (messages that would never expire)
+
+Attribute 'ttlCeiling' can be used to apply a limit to the expiration time{html} |
+    | _[<timedSubscriptionRecoveryPolicy>|#timedSubscriptionRecoveryPolicy-element]_ | {html}This implementation of {@link SubscriptionRecoveryPolicy} will keep a timed
+buffer of messages around in memory and use that to recover new
+subscriptions.{html} |
+    | _[<topic>|#topic-element]_ | {html}An ActiveMQ Topic{html} |
+    | _[<traceBrokerPathPlugin>|#traceBrokerPathPlugin-element]_ | {html}The TraceBrokerPathPlugin can be used in a network of Brokers. Each Broker
+that has the plugin configured, will add it's brokerName to the content
+of a JMS Property. If all Brokers have this property enabled, the path the
+message actually took through the network can be seen in the defined property.{html} |
+    | _[<transact-database-locker>|#transact-database-locker-element]_ | {html}Represents an exclusive lock on a database to avoid multiple brokers running
+against the same logical database.{html} |
+    | _[<transact-jdbc-adapter>|#transact-jdbc-adapter-element]_ | {html}A JDBC Adapter for Transact-SQL based databases such as SQL Server or Sybase{html} |
+    | _[<transportConnector>|#transportConnector-element]_ | {html}{html} |
+    | _[<udpTraceBrokerPlugin>|#udpTraceBrokerPlugin-element]_ | {html}A Broker interceptor which allows you to trace all operations to a UDP
+socket.{html} |
+    | _[<uniquePropertyMessageEvictionStrategy>|#uniquePropertyMessageEvictionStrategy-element]_ | {html}An eviction strategy which evicts the oldest message within messages with the same property value{html} |
+    | _[<usageCapacity>|#usageCapacity-element]_ | {html}Identify if a limit has been reached{html} |
+    | _[<virtualDestinationInterceptor>|#virtualDestinationInterceptor-element]_ | {html}Implements <a
+href="http://activemq.apache.org/virtual-destinations.html">Virtual Topics</a>.{html} |
+    | _[<virtualSelectorCacheBrokerPlugin>|#virtualSelectorCacheBrokerPlugin-element]_ | {html}A plugin which allows the caching of the selector from a subscription queue.
+<p/>
+This stops the build-up of unwanted messages, especially when consumers may
+disconnect from time to time when using virtual destinations.
+<p/>
+This is influenced by code snippets developed by Maciej Rakowicz{html} |
+    | _[<virtualTopic>|#virtualTopic-element]_ | {html}Creates <a href="http://activemq.org/site/virtual-destinations.html">Virtual
+Topics</a> using a prefix and postfix. The virtual destination creates a
+wildcard that is then used to look up all active queue subscriptions which
+match.{html} |
+    | _[<vmCursor>|#vmCursor-element]_ | {html}Pending messages held{html} |
+    | _[<vmDurableCursor>|#vmDurableCursor-element]_ | {html}Pending{html} |
+    | _[<vmQueueCursor>|#vmQueueCursor-element]_ | {html}Pending messages{html} |
+    | _[<xaConnectionFactory>|#xaConnectionFactory-element]_ | {html}A <a href="http://www.springframework.org/">Spring</a> enhanced XA connection
+factory which will automatically use the Spring bean name as the clientIDPrefix property
+so that connections created have client IDs related to your Spring.xml file for
+easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.{html} |
+
diff --git a/activemq-leveldb/kahadb-vs-leveldb.png b/activemq-leveldb/kahadb-vs-leveldb.png
new file mode 100644
index 000000000..e4d9c5778
Binary files /dev/null and b/activemq-leveldb/kahadb-vs-leveldb.png differ
diff --git a/activemq-leveldb/pom.xml b/activemq-leveldb/pom.xml
new file mode 100644
index 000000000..5464fb676
--- /dev/null
+++ b/activemq-leveldb/pom.xml
@@ -0,0 +1,434 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+  
+  http://www.apache.org/licenses/LICENSE-2.0
+  
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.activemq</groupId>
+    <artifactId>activemq-parent</artifactId>
+    <version>5.7-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>activemq-leveldb</artifactId>
+  <packaging>jar</packaging>
+
+  <name>ActiveMQ :: LevelDB</name>
+  <description>ActiveMQ LevelDB based store</description>
+
+  <dependencies>
+
+    <!-- for scala support -->
+    <dependency>
+      <groupId>org.scala-lang</groupId>
+      <artifactId>scala-library</artifactId>
+      <version>${scala-version}</version>
+      <scope>compile</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.activemq</groupId>
+      <artifactId>activemq-core</artifactId>
+      <version>5.7-SNAPSHOT</version>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.fusesource.hawtbuf</groupId>
+      <artifactId>hawtbuf-proto</artifactId>
+      <version>${hawtbuf-version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.fusesource.hawtdispatch</groupId>
+      <artifactId>hawtdispatch-scala</artifactId>
+      <version>${hawtdispatch-version}</version>
+    </dependency>
+    
+    <dependency>
+      <groupId>org.iq80.leveldb</groupId>
+      <artifactId>leveldb</artifactId>
+      <version>0.2</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.fusesource.leveldbjni</groupId>
+      <artifactId>leveldbjni-osx</artifactId>
+      <version>1.3</version>
+    </dependency>
+    <dependency>
+      <groupId>org.fusesource.leveldbjni</groupId>
+      <artifactId>leveldbjni-linux32</artifactId>
+      <version>1.3</version>
+    </dependency>
+    <dependency>
+      <groupId>org.fusesource.leveldbjni</groupId>
+      <artifactId>leveldbjni-linux64</artifactId>
+      <version>1.3</version>
+    </dependency>
+    <dependency>
+      <groupId>org.fusesource.leveldbjni</groupId>
+      <artifactId>leveldbjni-win32</artifactId>
+      <version>1.3</version>
+    </dependency>
+    <dependency>
+      <groupId>org.fusesource.leveldbjni</groupId>
+      <artifactId>leveldbjni-win64</artifactId>
+      <version>1.3</version>
+    </dependency>
+
+    <!-- For Optional Snappy Compression -->
+    <dependency>
+      <groupId>org.xerial.snappy</groupId>
+      <artifactId>snappy-java</artifactId>
+      <version>1.0.3</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.iq80.snappy</groupId>
+      <artifactId>snappy</artifactId>
+      <version>0.2</version>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>org.codehaus.jackson</groupId>
+      <artifactId>jackson-core-asl</artifactId>
+      <version>${jackson-version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.codehaus.jackson</groupId>
+      <artifactId>jackson-mapper-asl</artifactId>
+      <version>${jackson-version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.hadoop</groupId>
+      <artifactId>hadoop-core</artifactId>
+      <version>${hadoop-version}</version>
+      <exclusions>
+        <!-- hadoop's transative dependencies are such a pig -->
+        <exclusion>
+          <groupId>commons-cli</groupId>
+          <artifactId>commons-cli</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>xmlenc</groupId>
+          <artifactId>xmlenc</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>commons-codec</groupId>
+          <artifactId>commons-codec</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>org.apache.commons</groupId>
+          <artifactId>commons-math</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>commons-net</groupId>
+          <artifactId>commons-net</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>commons-httpclient</groupId>
+          <artifactId>commons-httpclient</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>tomcat</groupId>
+          <artifactId>jasper-runtime</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>tomcat</groupId>
+          <artifactId>jasper-compiler</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>commons-el</groupId>
+          <artifactId>commons-el</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>net.java.dev.jets3t</groupId>
+          <artifactId>jets3t</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>net.sf.kosmosfs</groupId>
+          <artifactId>kfs</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>hsqldb</groupId>
+          <artifactId>hsqldb</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>oro</groupId>
+          <artifactId>oro</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>org.eclipse.jdt</groupId>
+          <artifactId>core</artifactId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+
+    <!-- Testing Dependencies -->    
+    <dependency>
+      <groupId>org.apache.activemq</groupId>
+      <artifactId>activemq-core</artifactId>
+      <version>5.7-SNAPSHOT</version>
+      <type>test-jar</type>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.activemq</groupId>
+      <artifactId>activemq-console</artifactId>
+      <version>5.7-SNAPSHOT</version>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- Hadoop Testing Deps -->
+    <dependency>
+      <groupId>org.apache.hadoop</groupId>
+      <artifactId>hadoop-test</artifactId>
+      <version>${hadoop-version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>commons-lang</groupId>
+      <artifactId>commons-lang</artifactId>
+      <version>2.6</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty</groupId>
+      <artifactId>jetty</artifactId>
+      <version>6.1.26</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty</groupId>
+      <artifactId>jetty-util</artifactId>
+      <version>6.1.26</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>tomcat</groupId>
+      <artifactId>jasper-runtime</artifactId>
+      <version>5.5.12</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>tomcat</groupId>
+      <artifactId>jasper-compiler</artifactId>
+      <version>5.5.12</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty</groupId>
+      <artifactId>jsp-api-2.1</artifactId>
+      <version>6.1.14</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty</groupId>
+      <artifactId>jsp-2.1</artifactId>
+      <version>6.1.14</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.commons</groupId>
+      <artifactId>commons-math</artifactId>
+      <version>2.2</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.scalatest</groupId>
+      <artifactId>scalatest_2.9.1</artifactId>
+      <version>${scalatest-version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+  </dependencies>
+
+  <build>
+
+    <plugins>
+      <plugin>
+        <groupId>org.scala-tools</groupId>
+        <artifactId>maven-scala-plugin</artifactId>
+        <version>${scala-plugin-version}</version>
+        <executions>
+          <execution>
+            <id>compile</id>
+            <goals><goal>compile</goal> </goals>
+            <phase>compile</phase>
+          </execution>
+          <execution>
+            <id>test-compile</id>
+            <goals>
+            <goal>testCompile</goal>
+            </goals>
+            <phase>test-compile</phase>
+          </execution>
+          <execution>
+            <phase>process-resources</phase>
+            <goals>
+            <goal>compile</goal>
+            </goals>
+          </execution>
+        </executions>
+
+        <configuration>
+          <jvmArgs>
+            <jvmArg>-Xmx1024m</jvmArg>
+            <jvmArg>-Xss8m</jvmArg>
+          </jvmArgs>
+          <scalaVersion>${scala-version}</scalaVersion>
+          <args>
+            <arg>-deprecation</arg>
+          </args>
+          <compilerPlugins>
+            <compilerPlugin>
+              <groupId>org.fusesource.jvmassert</groupId>
+              <artifactId>jvmassert</artifactId>
+              <version>1.1</version>
+            </compilerPlugin>
+          </compilerPlugins>
+        </configuration>
+      </plugin>
+
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-surefire-plugin</artifactId>
+
+        <configuration>
+          <!-- we must turn off the use of system class loader so our tests can find stuff - otherwise ScalaSupport compiler can't find stuff -->
+          <useSystemClassLoader>false</useSystemClassLoader>
+          <!--forkMode>pertest</forkMode-->
+          <childDelegation>false</childDelegation>
+          <useFile>true</useFile>
+          <failIfNoTests>false</failIfNoTests>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.fusesource.hawtbuf</groupId>
+        <artifactId>hawtbuf-protoc</artifactId>
+        <version>${hawtbuf-version}</version>
+        <configuration>
+          <type>alt</type>
+        </configuration>
+         <executions>
+          <execution>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.fusesource.mvnplugins</groupId>
+        <artifactId>maven-uberize-plugin</artifactId>
+        <version>1.14</version>
+        <executions>
+          <execution>
+            <id>all</id>
+            <phase>package</phase>
+            <goals><goal>uberize</goal></goals>
+          </execution>
+        </executions>
+        <configuration>
+          <uberArtifactAttached>true</uberArtifactAttached>
+          <uberClassifierName>uber</uberClassifierName>
+          <artifactSet>
+            <includes>
+              <include>org.scala-lang:scala-library</include>
+              <include>org.fusesource.hawtdispatch:hawtdispatch</include>
+              <include>org.fusesource.hawtdispatch:hawtdispatch-scala</include>
+              <include>org.fusesource.hawtbuf:hawtbuf</include>
+              <include>org.fusesource.hawtbuf:hawtbuf-proto</include>
+              
+              <include>org.iq80.leveldb:leveldb-api</include>
+
+              <!--
+              <include>org.iq80.leveldb:leveldb</include>
+              <include>org.xerial.snappy:snappy-java</include>
+              <include>com.google.guava:guava</include>
+              -->
+              <include>org.xerial.snappy:snappy-java</include>
+
+              <include>org.fusesource.leveldbjni:leveldbjni</include>
+              <include>org.fusesource.leveldbjni:leveldbjni-osx</include>
+              <include>org.fusesource.leveldbjni:leveldbjni-linux32</include>
+              <include>org.fusesource.leveldbjni:leveldbjni-linux64</include>
+              <include>org.fusesource.hawtjni:hawtjni-runtime</include>
+
+              <!-- include bits need to access hdfs as a client -->
+              <include>org.apache.hadoop:hadoop-core</include>
+              <include>commons-configuration:commons-configuration</include>
+              <include>org.codehaus.jackson:jackson-mapper-asl</include>
+              <include>org.codehaus.jackson:jackson-core-asl</include> 
+              
+            </includes>
+          </artifactSet>            
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.felix</groupId>
+        <artifactId>maven-bundle-plugin</artifactId>
+        <configuration>
+          <classifier>bundle</classifier>
+          <excludeDependencies />
+          <instructions>
+            <Bundle-SymbolicName>${project.groupId}.${project.artifactId}</Bundle-SymbolicName>
+            <Fragment-Host>org.apache.activemq.activemq-core</Fragment-Host>
+            <Export-Package>
+                org.apache.activemq.leveldb*;version=${project.version};-noimport:=;-split-package:=merge-last,
+            </Export-Package>
+            <Embed-Dependency>*;inline=**;artifactId=
+              hawtjni-runtime|hawtbuf|hawtbuf-proto|hawtdispatch|hawtdispatch-scala|scala-library|
+              leveldb-api|leveldbjni|leveldbjni-osx|leveldbjni-linux32|leveldbjni-linux64|
+              hadoop-core|commons-configuration|jackson-mapper-asl|jackson-core-asl|commons-lang</Embed-Dependency>
+            <Embed-Transitive>true</Embed-Transitive>
+            <Import-Package>*;resolution:=optional</Import-Package>
+          </instructions>
+        </configuration>
+        <executions>
+          <execution>
+            <id>bundle</id>
+            <phase>package</phase>
+            <goals>
+              <goal>bundle</goal>
+            </goals>
+          </execution>
+        </executions>
+        </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-surefire-plugin</artifactId>
+        <configuration>
+          <forkMode>always</forkMode>
+          <excludes>
+            <exclude>**/EnqueueRateScenariosTest.*</exclude>
+          </excludes>          
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>  
+</project>
diff --git a/activemq-leveldb/readme.md b/activemq-leveldb/readme.md
new file mode 100644
index 000000000..2a4d9384b
--- /dev/null
+++ b/activemq-leveldb/readme.md
@@ -0,0 +1,95 @@
+# The LevelDB Store
+
+## Overview
+
+The LevelDB Store is message store implementation that can be used in ActiveMQ messaging servers. 
+
+## LevelDB vs KahaDB
+
+How is the LevelDB Store better than the default KahaDB store:
+
+ * It maitains fewer index entries per message than KahaDB which means it has a higher persistent throughput.
+ * Faster recovery when a broker restarts
+ * Since the broker tends to write and read queue entries sequentially, the LevelDB based index provide a much better performance than the B-Tree based indexes of KahaDB which increases throughput.
+ * Unlike the KahaDB indexes, the LevelDB indexes support concurrent read access which further improves read throughput.
+ * Pauseless data log file garbage collection cycles.
+ * It uses fewer read IO operations to load stored messages.
+ * If a message is copied to multiple queues (Typically happens if your using virtual topics with multiple
+   consumers), then LevelDB will only journal the payload of the message once.  KahaDB will journal it multiple times.
+ * It exposes it's status via JMX for monitoring
+ * Supports replication to get High Availability
+ 
+See the following chart to get an idea on how much better you can expect the LevelDB store to perform vs the KahaDB store:
+
+![kahadb-vs-leveldb.png ](https://raw.github.com/fusesource/fuse-extra/master/fusemq-leveldb/kahadb-vs-leveldb.png)
+
+## How to Use with ActiveMQ
+
+Update the broker configuration file and change `persistenceAdapter` elements 
+settings so that it uses the LevelDB store using the following spring XML 
+configuration example: 
+
+    <persistenceAdapter>
+      <levelDB directory="${activemq.base}/data/leveldb" logSize="107374182"/>
+    </persistenceAdapter>
+
+### Configuration / Property Reference
+
+*TODO*
+
+### JMX Attribute and Operation Reference
+
+*TODO*
+
+## Known Limitations
+
+* XA Transactions not supported yet
+* The store does not do any dup detection of messages.
+
+## Built in High Availability Support
+
+You can also use a High Availability (HA) version of the LevelDB store which 
+works with Hadoop based file systems to achive HA of your stored messages.
+
+**Q:** What are the requirements?
+**A:** An existing Hadoop 1.0.0 cluster
+
+**Q:** How does it work during the normal operating cycle?
+A: It uses HDFS to store a highly available copy of the local leveldb storage files.  As local log files are being written to, it also maintains a mirror copy on HDFS.  If you have sync enabled on the store, a HDFS file sync is performed instead of a local disk sync.  When the index is check pointed, we upload any previously not uploaded leveldb .sst files to HDFS. 
+
+**Q:** What happens when a broker fails and  we startup a new slave to take over?
+**A:** The slave will download from HDFS the log files and the .sst files associated with the latest uploaded index.  Then normal leveldb store recovery kicks in which updates the index using the log files.
+
+**Q:** How do I use the HA version of the LevelDB store?
+**A:** Update your activemq.xml to use a `persistenceAdapter` setting similar to the following:
+
+    <persistenceAdapter>
+      <bean xmlns="http://www.springframework.org/schema/beans" 
+          class="org.apache.activemq.leveldb.HALevelDBStore">
+
+        <!-- File system URL to replicate to -->
+        <property name="dfsUrl" value="hdfs://hadoop-name-node"/> 
+        <!-- Directory in the file system to store the data in -->
+        <property name="dfsDirectory" value="activemq"/>
+
+        <property name="directory" value="${activemq.base}/data/leveldb"/>
+        <property name="logSize" value="107374182"/>
+        <!-- <property name="sync" value="false"/> -->
+      </bean>
+    </persistenceAdapter>
+
+   Notice the implementation class name changes to 'HALevelDBStore'
+   Instead of using a 'dfsUrl' property you can instead also just load an existing Hadoop configuration file if it's available on your system, for example: 
+     <property name="dfsConfig" value="/opt/hadoop-1.0.0/conf/core-site.xml"/> 
+
+**Q:** Who handles starting up the Slave?
+**A:** You do. :) This implementation assumes master startup/elections are performed externally and that 2 brokers are never running against the same HDFS file path.  In practice this means you need something like ZooKeeper to control starting new brokers to take over failed masters. 
+
+**Q:** Can this run against something other than HDFS?
+**A:** It should be able to run with any Hadoop supported file system like CloudStore, S3, MapR, NFS, etc (Well at least in theory, I've only tested against HDFS).
+
+**Q:** Can 'X' performance be optimized?
+**A:** There are  bunch of way to improve the performance of many of the things that current version of the store is doing.  For example, aggregating the .sst files into an archive to make more efficient use of HDFS, concurrent downloading to improve recovery performance.  Lazy downloading of the oldest log files to make recovery faster.  Async HDFS writes to avoid blocking local updates.  Running brokers in a warm 'standy' mode which keep downloading new log updates and applying index updates from the master as they get uploaded to HDFS to get faster failovers.
+
+**Q:** Does the broker fail if HDFS fails?
+**A:** Currently, yes.  But it should be possible to make the master resilient to HDFS failures. 
diff --git a/activemq-core/src/main/java/org/apache/activemq/store/leveldb/LevelDBPersistenceAdapter.java b/activemq-leveldb/src/main/java/org/apache/activemq/store/leveldb/LevelDBPersistenceAdapter.java
similarity index 95%
rename from activemq-core/src/main/java/org/apache/activemq/store/leveldb/LevelDBPersistenceAdapter.java
rename to activemq-leveldb/src/main/java/org/apache/activemq/store/leveldb/LevelDBPersistenceAdapter.java
index bd5c93790..987808e79 100644
--- a/activemq-core/src/main/java/org/apache/activemq/store/leveldb/LevelDBPersistenceAdapter.java
+++ b/activemq-leveldb/src/main/java/org/apache/activemq/store/leveldb/LevelDBPersistenceAdapter.java
@@ -16,7 +16,7 @@
  */
 package org.apache.activemq.store.leveldb;
 
-import org.fusesource.mq.leveldb.LevelDBStore;
+import org.apache.activemq.leveldb.LevelDBStore;
 
 
 /**
diff --git a/activemq-leveldb/src/main/proto/records.proto b/activemq-leveldb/src/main/proto/records.proto
new file mode 100644
index 000000000..d7ec58d35
--- /dev/null
+++ b/activemq-leveldb/src/main/proto/records.proto
@@ -0,0 +1,56 @@
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements.  See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+// 
+package org.apache.activemq.leveldb.record;
+
+option java_multiple_files = true;
+
+//
+// We create a collection record for each
+// transaction, queue, topic.
+//
+message CollectionKey {
+  required int64 key = 1;
+}
+message CollectionRecord {
+  optional int64 key = 1;
+  optional int32 type = 2;
+  optional bytes meta = 3 [java_override_type = "Buffer"];
+}
+
+//
+// We create a entry record for each message, subscription,
+// and subscription position.
+//
+message EntryKey {
+  required int64 collection_key = 1;
+  required bytes entry_key = 2 [java_override_type = "Buffer"];
+}
+message EntryRecord {
+  optional int64 collection_key = 1;
+  optional bytes entry_key = 2 [java_override_type = "Buffer"];
+  optional int64 value_location = 3;
+  optional int32 value_length = 4;
+  optional bytes value = 5 [java_override_type = "Buffer"];
+  optional bytes meta = 6 [java_override_type = "Buffer"];
+}
+
+message SubscriptionRecord {
+  optional int64 topic_key = 1;
+  optional string client_id = 2;
+  optional string subscription_name = 3;
+  optional string selector = 4;
+  optional string destination_name = 5;
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb.scala
new file mode 100644
index 000000000..5774105f8
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb.scala
@@ -0,0 +1,139 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq
+
+import java.nio.ByteBuffer
+import org.fusesource.hawtbuf.Buffer
+import org.xerial.snappy.{Snappy => Xerial}
+import org.iq80.snappy.{Snappy => Iq80}
+
+/**
+ * <p>
+ * A Snappy abstraction which attempts uses the iq80 implementation and falls back
+ * to the xerial Snappy implementation it cannot be loaded.  You can change the
+ * load order by setting the 'leveldb.snappy' system property.  Example:
+ *
+ * <code>
+ * -Dleveldb.snappy=xerial,iq80
+ * </code>
+ *
+ * The system property can also be configured with the name of a class which
+ * implements the Snappy.SPI interface.
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+package object leveldb  {
+
+  final val Snappy = {
+    var attempt:SnappyTrait = null
+    System.getProperty("leveldb.snappy", "iq80,xerial").split(",").foreach { x =>
+      if( attempt==null ) {
+        try {
+            var name = x.trim();
+            name = name.toLowerCase match {
+              case "xerial" => "org.apache.activemq.leveldb.XerialSnappy"
+              case "iq80" => "org.apache.activemq.leveldb.IQ80Snappy"
+              case _ => name
+            }
+            attempt = Thread.currentThread().getContextClassLoader().loadClass(name).newInstance().asInstanceOf[SnappyTrait];
+            attempt.compress("test")
+        } catch {
+          case x =>
+            attempt = null
+        }
+      }
+    }
+    attempt
+  }
+
+
+  trait SnappyTrait {
+    
+    def uncompressed_length(input: Buffer):Int
+    def uncompress(input: Buffer, output:Buffer): Int
+    
+    def max_compressed_length(length: Int): Int
+    def compress(input: Buffer, output: Buffer): Int
+
+    def compress(input: Buffer):Buffer = {
+      val compressed = new Buffer(max_compressed_length(input.length))
+      compressed.length = compress(input, compressed)
+      compressed
+    }
+    
+    def compress(text: String): Buffer = {
+      val uncompressed = new Buffer(text.getBytes("UTF-8"))
+      val compressed = new Buffer(max_compressed_length(uncompressed.length))
+      compressed.length = compress(uncompressed, compressed)
+      return compressed
+    }
+    
+    def uncompress(input: Buffer):Buffer = {
+      val uncompressed = new Buffer(uncompressed_length(input))
+      uncompressed.length = uncompress(input, uncompressed)
+      uncompressed
+    }
+
+    def uncompress(compressed: ByteBuffer, uncompressed: ByteBuffer): Int = {
+      val input = if (compressed.hasArray) {
+        new Buffer(compressed.array, compressed.arrayOffset + compressed.position, compressed.remaining)
+      } else {
+        val t = new Buffer(compressed.remaining)
+        compressed.mark
+        compressed.get(t.data)
+        compressed.reset
+        t
+      }
+
+      val output = if (uncompressed.hasArray) {
+        new Buffer(uncompressed.array, uncompressed.arrayOffset + uncompressed.position, uncompressed.capacity()-uncompressed.position)
+      } else {
+        new Buffer(uncompressed_length(input))
+      }
+
+      output.length = uncompress(input, output)
+
+      if (uncompressed.hasArray) {
+        uncompressed.limit(uncompressed.position + output.length)
+      } else {
+        val p = uncompressed.position
+        uncompressed.limit(uncompressed.capacity)
+        uncompressed.put(output.data, output.offset, output.length)
+        uncompressed.flip.position(p)
+      }
+      return output.length
+    }
+  }
+}
+package leveldb {
+  class XerialSnappy extends SnappyTrait {
+    override def uncompress(compressed: ByteBuffer, uncompressed: ByteBuffer) = Xerial.uncompress(compressed, uncompressed)
+    def uncompressed_length(input: Buffer) = Xerial.uncompressedLength(input.data, input.offset, input.length)
+    def uncompress(input: Buffer, output: Buffer) = Xerial.uncompress(input.data, input.offset, input.length, output.data, output.offset)
+    def max_compressed_length(length: Int) = Xerial.maxCompressedLength(length)
+    def compress(input: Buffer, output: Buffer) = Xerial.compress(input.data, input.offset, input.length, output.data, output.offset)
+    override def compress(text: String) = new Buffer(Xerial.compress(text))
+  }
+
+  class IQ80Snappy extends SnappyTrait {
+    def uncompressed_length(input: Buffer) = Iq80.getUncompressedLength(input.data, input.offset)
+    def uncompress(input: Buffer, output: Buffer): Int = Iq80.uncompress(input.data, input.offset, input.length, output.data, output.offset)
+    def compress(input: Buffer, output: Buffer): Int = Iq80.compress(input.data, input.offset, input.length, output.data, output.offset)
+    def max_compressed_length(length: Int) = Iq80.maxCompressedLength(length)
+  }
+}
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/DBManager.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/DBManager.scala
new file mode 100644
index 000000000..30b134ac4
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/DBManager.scala
@@ -0,0 +1,735 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb
+
+import org.fusesource.hawtdispatch._
+import org.fusesource.hawtdispatch.BaseRetained
+import java.util.concurrent._
+import atomic._
+import org.fusesource.hawtbuf.Buffer
+import org.apache.activemq.store.MessageRecoveryListener
+import java.lang.ref.WeakReference
+import scala.Option._
+import org.fusesource.hawtbuf.Buffer._
+import org.apache.activemq.command._
+import org.apache.activemq.leveldb.record.{SubscriptionRecord, CollectionRecord}
+import util.TimeMetric
+import java.util.HashMap
+import collection.mutable.{HashSet, ListBuffer}
+import org.apache.activemq.thread.DefaultThreadPools
+
+case class MessageRecord(id:MessageId, data:Buffer, syncNeeded:Boolean) {
+  var locator:(Long, Int) = _
+}
+
+case class QueueEntryRecord(id:MessageId, queueKey:Long, queueSeq:Long)
+case class QueueRecord(id:ActiveMQDestination, queue_key:Long)
+case class QueueEntryRange()
+case class SubAckRecord(subKey:Long, ackPosition:Long)
+
+sealed trait UowState {
+  def stage:Int
+}
+// UoW is initial open.
+object UowOpen extends UowState {
+  override def stage = 0
+  override def toString = "UowOpen"
+}
+// UoW is Committed once the broker finished creating it.
+object UowClosed extends UowState {
+  override def stage = 1
+  override def toString = "UowClosed"
+}
+// UOW is delayed until we send it to get flushed.
+object UowDelayed extends UowState {
+  override def stage = 2
+  override def toString = "UowDelayed"
+}
+object UowFlushQueued extends UowState {
+  override def stage = 3
+  override def toString = "UowFlushQueued"
+}
+
+object UowFlushing extends UowState {
+  override def stage = 4
+  override def toString = "UowFlushing"
+}
+// Then it moves on to be flushed. Flushed just
+// means the message has been written to disk
+// and out of memory
+object UowFlushed extends UowState {
+  override def stage = 5
+  override def toString = "UowFlushed"
+}
+
+// Once completed then you know it has been synced to disk.
+object UowCompleted extends UowState {
+  override def stage = 6
+  override def toString = "UowCompleted"
+}
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+case class CountDownFuture(completed:CountDownLatch=new CountDownLatch(1)) extends java.util.concurrent.Future[Object] {
+  def countDown = completed.countDown()
+  def cancel(mayInterruptIfRunning: Boolean) = false
+  def isCancelled = false
+
+  def get() = {
+    completed.await()
+    null
+  }
+
+  def get(p1: Long, p2: TimeUnit) = {
+    if(completed.await(p1, p2)) {
+      null
+    } else {
+      throw new TimeoutException
+    }
+  }
+
+  def isDone = completed.await(0, TimeUnit.SECONDS);
+}
+
+object UowManagerConstants {
+  val QUEUE_COLLECTION_TYPE = 1
+  val TOPIC_COLLECTION_TYPE = 2
+  val TRANSACTION_COLLECTION_TYPE = 3
+  val SUBSCRIPTION_COLLECTION_TYPE = 4
+
+  case class QueueEntryKey(queue:Long, seq:Long)
+  def key(x:QueueEntryRecord) = QueueEntryKey(x.queueKey, x.queueSeq)
+}
+
+import UowManagerConstants._
+
+class DelayableUOW(val manager:DBManager) extends BaseRetained {
+  val countDownFuture = CountDownFuture()
+  var canceled = false;
+
+  val uowId:Int = manager.lastUowId.incrementAndGet()
+  var actions = Map[MessageId, MessageAction]()
+  var subAcks = ListBuffer[SubAckRecord]()
+  var completed = false
+  var disableDelay = false
+  var delayableActions = 0
+
+  private var _state:UowState = UowOpen
+
+  def state = this._state
+  def state_=(next:UowState) {
+    assert(this._state.stage < next.stage)
+    this._state = next
+  }
+
+  def syncNeeded = actions.find( _._2.syncNeeded ).isDefined
+  def size = 100+actions.foldLeft(0L){ case (sum, entry) =>
+    sum + (entry._2.size+100)
+  } + (subAcks.size * 100)
+
+  class MessageAction {
+    var id:MessageId = _
+    var messageRecord: MessageRecord = null
+    var enqueues = ListBuffer[QueueEntryRecord]()
+    var dequeues = ListBuffer[QueueEntryRecord]()
+
+    def uow = DelayableUOW.this
+    def isEmpty() = messageRecord==null && enqueues==Nil && dequeues==Nil
+
+    def cancel() = {
+      uow.rm(id)
+    }
+
+    def syncNeeded = messageRecord!=null && messageRecord.syncNeeded
+    def size = (if(messageRecord!=null) messageRecord.data.length+20 else 0) + ((enqueues.size+dequeues.size)*50)
+    
+    def addToPendingStore() = {
+      var set = manager.pendingStores.get(id)
+      if(set==null) {
+        set = HashSet()
+        manager.pendingStores.put(id, set)
+      }
+      set.add(this)
+    }
+
+    def removeFromPendingStore() = {
+      var set = manager.pendingStores.get(id)
+      if(set!=null) {
+        set.remove(this)
+        if(set.isEmpty) {
+          manager.pendingStores.remove(id)
+        }
+      }
+    }
+    
+  }
+
+  def completeAsap() = this.synchronized { disableDelay=true }
+  def delayable = !disableDelay && delayableActions>0 && manager.flushDelay>=0
+
+  def rm(msg:MessageId) = {
+    actions -= msg
+    if( actions.isEmpty && state.stage < UowFlushing.stage ) {
+      cancel
+    }
+  }
+
+  def cancel = {
+    manager.dispatchQueue.assertExecuting()
+    manager.uowCanceledCounter += 1
+    canceled = true
+    manager.flush_queue.remove(uowId)
+    onCompleted
+  }
+
+  def getAction(id:MessageId) = {
+    actions.get(id) match {
+      case Some(x) => x
+      case None =>
+        val x = new MessageAction
+        x.id = id
+        actions += id->x
+        x
+    }
+  }
+
+  def updateAckPosition(sub:DurableSubscription) = {
+    subAcks += SubAckRecord(sub.subKey, sub.lastAckPosition)
+  }
+
+  def enqueue(queueKey:Long, queueSeq:Long, message:Message, delay_enqueue:Boolean)  = {
+    var delay = delay_enqueue && message.getTransactionId==null
+    if(delay ) {
+      manager.uowEnqueueDelayReqested += 1
+    } else {
+      manager.uowEnqueueNodelayReqested += 1
+    }
+
+    val id = message.getMessageId
+
+
+    val messageRecord = id.getDataLocator match {
+      case null =>
+        var packet = manager.parent.wireFormat.marshal(message)
+        var data = new Buffer(packet.data, packet.offset, packet.length)
+        if( manager.snappyCompressLogs ) {
+          data = Snappy.compress(data)
+        }
+        val record = MessageRecord(id, data, message.isResponseRequired)
+        id.setDataLocator(record)
+        record
+      case record:MessageRecord =>
+        record
+      case x:(Long, Int) =>
+        null
+    }
+
+    val entry = QueueEntryRecord(id, queueKey, queueSeq)
+    assert(id.getEntryLocator == null)
+    id.setEntryLocator((queueKey, queueSeq))
+
+    val a = this.synchronized {
+      if( !delay )
+        disableDelay = true
+
+      val action = getAction(entry.id)
+      action.messageRecord = messageRecord
+      action.enqueues += entry
+      delayableActions += 1
+      action
+    }
+
+    manager.dispatchQueue {
+      manager.cancelable_enqueue_actions.put(key(entry), a)
+      a.addToPendingStore()
+    }
+    countDownFuture
+  }
+
+  def dequeue(queueKey:Long, id:MessageId) = {
+    val (queueKey, queueSeq) = id.getEntryLocator.asInstanceOf[(Long, Long)];
+    val entry = QueueEntryRecord(id, queueKey, queueSeq)
+    this.synchronized {
+      getAction(id).dequeues += entry
+    }
+    countDownFuture
+  }
+
+  def complete_asap = this.synchronized {
+    disableDelay=true
+    if( state eq UowDelayed ) {
+      manager.enqueueFlush(this)
+    }
+  }
+
+  var complete_listeners = ListBuffer[()=>Unit]()
+  def addCompleteListener(func: =>Unit) = {
+    complete_listeners.append( func _ )
+  }
+
+  var asyncCapacityUsed = 0L
+  var disposed_at = 0L
+
+  override def dispose = this.synchronized {
+    state = UowClosed
+    disposed_at = System.nanoTime()
+    if( !syncNeeded ) {
+      val s = size
+      if( manager.asyncCapacityRemaining.addAndGet(-s) > 0 ) {
+        asyncCapacityUsed = s
+        countDownFuture.countDown
+        DefaultThreadPools.getDefaultTaskRunnerFactory.execute(^{
+          complete_listeners.foreach(_())
+        })
+      } else {
+        manager.asyncCapacityRemaining.addAndGet(s)
+      }
+    }
+    //      closeSource.merge(this)
+    manager.dispatchQueue {
+      manager.processClosed(this)
+    }
+  }
+
+  def onCompleted() = this.synchronized {
+    if ( state.stage < UowCompleted.stage ) {
+      state = UowCompleted
+      if( asyncCapacityUsed != 0 ) {
+        manager.asyncCapacityRemaining.addAndGet(asyncCapacityUsed)
+        asyncCapacityUsed = 0
+      } else {
+        manager.uow_complete_latency.add(System.nanoTime() - disposed_at)
+        countDownFuture.countDown
+        DefaultThreadPools.getDefaultTaskRunnerFactory.execute(^{
+          complete_listeners.foreach(_())
+        })
+      }
+
+      for( (id, action) <- actions ) {
+        if( !action.enqueues.isEmpty ) {
+          action.removeFromPendingStore()
+        }
+        for( queueEntry <- action.enqueues ) {
+          manager.cancelable_enqueue_actions.remove(key(queueEntry))
+        }
+      }
+      super.dispose
+    }
+  }
+}
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class DBManager(val parent:LevelDBStore) {
+
+  var lastCollectionKey = new AtomicLong(0)
+  val client:LevelDBClient = parent.createClient
+
+  def writeExecutor = client.writeExecutor
+  def flushDelay = parent.flushDelay
+
+  val dispatchQueue = createQueue(toString)
+//  val aggregator = new AggregatingExecutor(dispatchQueue)
+
+  val asyncCapacityRemaining = new AtomicLong(0L)
+
+  def createUow() = new DelayableUOW(this)
+
+  var uowEnqueueDelayReqested = 0L
+  var uowEnqueueNodelayReqested = 0L
+  var uowClosedCounter = 0L
+  var uowCanceledCounter = 0L
+  var uowStoringCounter = 0L
+  var uowStoredCounter = 0L
+
+  val uow_complete_latency = TimeMetric() 
+
+//  val closeSource = createSource(new ListEventAggregator[DelayableUOW](), dispatchQueue)
+//  closeSource.setEventHandler(^{
+//    closeSource.getData.foreach { uow =>
+//      processClosed(uow)
+//    }
+//  });
+//  closeSource.resume
+
+  var pendingStores = new ConcurrentHashMap[MessageId, HashSet[DelayableUOW#MessageAction]]()
+  
+  var cancelable_enqueue_actions = new HashMap[QueueEntryKey, DelayableUOW#MessageAction]()
+
+  val lastUowId = new AtomicInteger(1)
+
+  def processClosed(uow:DelayableUOW) = {
+    dispatchQueue.assertExecuting()
+    uowClosedCounter += 1
+
+    // Broker could issue a flush_message call before
+    // this stage runs.. which make the stage jump over UowDelayed
+    if( uow.state.stage < UowDelayed.stage ) {
+      uow.state = UowDelayed
+    }
+    if( uow.state.stage < UowFlushing.stage ) {
+      uow.actions.foreach { case (id, action) =>
+
+        // The UoW may have been canceled.
+        if( action.messageRecord!=null && action.enqueues.isEmpty ) {
+          action.removeFromPendingStore() 
+          action.messageRecord = null
+          uow.delayableActions -= 1
+        }
+        if( action.isEmpty ) {
+          action.cancel()
+        }
+
+        // dequeues can cancel out previous enqueues
+        action.dequeues.foreach { entry=>
+          val entry_key = key(entry)
+          val prev_action:DelayableUOW#MessageAction = cancelable_enqueue_actions.remove(entry_key)
+
+          if( prev_action!=null ) {
+            val prev_uow = prev_action.uow
+            prev_uow.synchronized {
+              if( !prev_uow.canceled ) {
+
+                prev_uow.delayableActions -= 1
+
+                // yay we can cancel out a previous enqueue
+                prev_action.enqueues = prev_action.enqueues.filterNot( x=> key(x) == entry_key )
+                if( prev_uow.state.stage >= UowDelayed.stage ) {
+
+                  // if the message is not in any queues.. we can gc it..
+                  if( prev_action.enqueues == Nil && prev_action.messageRecord !=null ) {
+                    prev_action.removeFromPendingStore()
+                    prev_action.messageRecord = null
+                    prev_uow.delayableActions -= 1
+                  }
+
+                  // Cancel the action if it's now empty
+                  if( prev_action.isEmpty ) {
+                    prev_action.cancel()
+                  } else if( !prev_uow.delayable ) {
+                    // flush it if there is no point in delaying anymore
+                    prev_uow.complete_asap
+                  }
+                }
+              }
+            }
+            // since we canceled out the previous enqueue.. now cancel out the action
+            action.dequeues = action.dequeues.filterNot( _ == entry)
+            if( action.isEmpty ) {
+              action.cancel()
+            }
+          }
+        }
+      }
+    }
+
+    if( !uow.canceled && uow.state.stage < UowFlushQueued.stage ) {
+      if( uow.delayable ) {
+        // Let the uow get GCed if its' canceled during the delay window..
+        val ref = new WeakReference[DelayableUOW](uow)
+        scheduleFlush(ref)
+      } else {
+        enqueueFlush(uow)
+      }
+    }
+  }
+
+  private def scheduleFlush(ref: WeakReference[DelayableUOW]) {
+    dispatchQueue.executeAfter(flushDelay, TimeUnit.MILLISECONDS, ^ {
+      val uow = ref.get();
+      if (uow != null) {
+        enqueueFlush(uow)
+      }
+    })
+  }
+
+  val flush_queue = new java.util.LinkedHashMap[Long,  DelayableUOW]()
+
+  def enqueueFlush(uow:DelayableUOW) = {
+    dispatchQueue.assertExecuting()
+    if( uow!=null && !uow.canceled && uow.state.stage < UowFlushQueued.stage ) {
+      uow.state = UowFlushQueued
+      flush_queue.put (uow.uowId, uow)
+      flushSource.merge(1)
+    }
+  }
+
+  val flushSource = createSource(EventAggregators.INTEGER_ADD, dispatchQueue)
+  flushSource.setEventHandler(^{drainFlushes});
+  flushSource.resume
+
+  def drainFlushes:Unit = {
+    dispatchQueue.assertExecuting()
+    if( !started ) {
+      return
+    }
+
+    // Some UOWs may have been canceled.
+    import collection.JavaConversions._
+    val values = flush_queue.values().toSeq.toArray
+    flush_queue.clear()
+
+    val uows = values.flatMap { uow=>
+      if( uow.canceled ) {
+        None
+      } else {
+        // It will not be possible to cancel the UOW anymore..
+        uow.state = UowFlushing
+        uow.actions.foreach { case (_, action) =>
+          action.enqueues.foreach { queue_entry=>
+            val action = cancelable_enqueue_actions.remove(key(queue_entry))
+            assert(action!=null)
+          }
+        }
+        Some(uow)
+      }
+    }
+
+    if( !uows.isEmpty ) {
+      uowStoringCounter += uows.size
+      flushSource.suspend
+      writeExecutor {
+        client.store(uows)
+        flushSource.resume
+        dispatchQueue {
+          uowStoredCounter += uows.size
+          uows.foreach { uow=>
+            uow.onCompleted
+          }
+        }
+      }
+    }
+  }
+
+  var started = false
+  def snappyCompressLogs = parent.snappyCompressLogs
+
+  def start = {
+    asyncCapacityRemaining.set(parent.asyncBufferSize)
+    client.start()
+    dispatchQueue.sync {
+      started = true
+      pollGc
+      if(parent.monitorStats) {
+        monitorStats
+      }
+    }
+  }
+
+  def stop() = {
+    dispatchQueue.sync {
+      started = false
+    }
+    client.stop()
+  }
+
+  def pollGc:Unit = dispatchQueue.after(10, TimeUnit.SECONDS) {
+    if( started ) {
+      val positions = parent.getTopicGCPositions
+      writeExecutor {
+        if( started ) {
+          client.gc(positions)
+          pollGc
+        }
+      }
+    }
+  }
+
+  def monitorStats:Unit = dispatchQueue.after(1, TimeUnit.SECONDS) {
+    if( started ) {
+      println(("committed: %d, canceled: %d, storing: %d, stored: %d, " +
+        "uow complete: %,.3f ms, " +
+        "index write: %,.3f ms, " +
+        "log write: %,.3f ms, log flush: %,.3f ms, log rotate: %,.3f ms"+
+        "add msg: %,.3f ms, add enqueue: %,.3f ms, " +
+        "uowEnqueueDelayReqested: %d, uowEnqueueNodelayReqested: %d "
+        ).format(
+          uowClosedCounter, uowCanceledCounter, uowStoringCounter, uowStoredCounter,
+          uow_complete_latency.reset,
+        client.max_index_write_latency.reset,
+          client.log.max_log_write_latency.reset, client.log.max_log_flush_latency.reset, client.log.max_log_rotate_latency.reset,
+        client.max_write_message_latency.reset, client.max_write_enqueue_latency.reset,
+        uowEnqueueDelayReqested, uowEnqueueNodelayReqested
+      ))
+      uowClosedCounter = 0
+//      uowCanceledCounter = 0
+      uowStoringCounter = 0
+      uowStoredCounter = 0
+      monitorStats
+    }
+  }
+
+  /////////////////////////////////////////////////////////////////////
+  //
+  // Implementation of the Store interface
+  //
+  /////////////////////////////////////////////////////////////////////
+
+  def checkpoint(sync:Boolean) = writeExecutor.sync {
+    client.snapshotIndex(sync)
+  }
+
+  def purge = writeExecutor.sync {
+    client.purge
+    lastCollectionKey.set(1)
+  }
+
+  def getLastQueueEntrySeq(key:Long) = {
+    client.getLastQueueEntrySeq(key)
+  }
+
+  def collectionEmpty(key:Long) = writeExecutor.sync {
+    client.collectionEmpty(key)
+  }
+
+  def collectionSize(key:Long) = {
+    client.collectionSize(key)
+  }
+
+  def collectionIsEmpty(key:Long) = {
+    client.collectionIsEmpty(key)
+  }
+  
+  def cursorMessages(key:Long, listener:MessageRecoveryListener, startPos:Long) = {
+    var nextPos = startPos;
+    client.queueCursor(key, nextPos) { msg =>
+      if( listener.hasSpace ) {
+        listener.recoverMessage(msg)
+        nextPos += 1
+        true
+      } else {
+        false
+      }
+    }
+    nextPos
+  }
+
+  def queuePosition(id: MessageId):Long = {
+    id.getEntryLocator.asInstanceOf[(Long, Long)]._2
+  }
+
+  def createQueueStore(dest:ActiveMQQueue):parent.LevelDBMessageStore = {
+    parent.createQueueMessageStore(dest, createStore(dest, QUEUE_COLLECTION_TYPE))
+  }
+  def destroyQueueStore(key:Long) = writeExecutor.sync {
+      client.removeCollection(key)
+  }
+
+  def getLogAppendPosition = writeExecutor.sync {
+    client.getLogAppendPosition
+  }
+
+  def addSubscription(topic_key:Long, info:SubscriptionInfo):DurableSubscription = {
+    val record = new SubscriptionRecord.Bean
+    record.setTopicKey(topic_key)
+    record.setClientId(info.getClientId)
+    record.setSubscriptionName(info.getSubcriptionName)
+    if( info.getSelector!=null ) {
+      record.setSelector(info.getSelector)
+    }
+    if( info.getDestination!=null ) {
+      record.setDestinationName(info.getDestination.getQualifiedName)
+    }
+    val collection = new CollectionRecord.Bean()
+    collection.setType(SUBSCRIPTION_COLLECTION_TYPE)
+    collection.setKey(lastCollectionKey.incrementAndGet())
+    collection.setMeta(record.freeze().toUnframedBuffer)
+
+    val buffer = collection.freeze()
+    buffer.toFramedBuffer // eager encode the record.
+    writeExecutor.sync {
+      client.addCollection(buffer)
+    }
+    DurableSubscription(collection.getKey, topic_key, info)
+  }
+
+  def removeSubscription(sub:DurableSubscription) = {
+    client.removeCollection(sub.subKey)
+  }
+
+  def createTopicStore(dest:ActiveMQTopic) = {
+    var key = createStore(dest, TOPIC_COLLECTION_TYPE)
+    parent.createTopicMessageStore(dest, key)
+  }
+
+  def createStore(destination:ActiveMQDestination, collectionType:Int) = {
+    val collection = new CollectionRecord.Bean()
+    collection.setType(collectionType)
+    collection.setMeta(utf8(destination.getQualifiedName))
+    collection.setKey(lastCollectionKey.incrementAndGet())
+    val buffer = collection.freeze()
+    buffer.toFramedBuffer // eager encode the record.
+    writeExecutor.sync {
+      client.addCollection(buffer)
+    }
+    collection.getKey
+  }
+  
+  def loadCollections = {
+    val collections = writeExecutor.sync {
+      client.listCollections
+    }
+    var last = 0L
+    collections.foreach { case (key, record) =>
+      last = key
+      record.getType match {
+        case QUEUE_COLLECTION_TYPE =>
+          val dest = ActiveMQDestination.createDestination(record.getMeta.utf8().toString, ActiveMQDestination.QUEUE_TYPE).asInstanceOf[ActiveMQQueue]
+          parent.createQueueMessageStore(dest, key)
+        case TOPIC_COLLECTION_TYPE =>
+          val dest = ActiveMQDestination.createDestination(record.getMeta.utf8().toString, ActiveMQDestination.TOPIC_TYPE).asInstanceOf[ActiveMQTopic]
+          parent.createTopicMessageStore(dest, key)
+        case SUBSCRIPTION_COLLECTION_TYPE =>
+          val sr = SubscriptionRecord.FACTORY.parseUnframed(record.getMeta)
+          val info = new SubscriptionInfo
+          info.setClientId(sr.getClientId)
+          info.setSubcriptionName(sr.getSubscriptionName)
+          if( sr.hasSelector ) {
+            info.setSelector(sr.getSelector)
+          }
+          if(sr.hasDestinationName) {
+            info.setSubscribedDestination(ActiveMQDestination.createDestination(sr.getDestinationName, ActiveMQDestination.TOPIC_TYPE))
+          }
+
+          var sub = DurableSubscription(key, sr.getTopicKey, info)
+          sub.lastAckPosition = client.getAckPosition(key);
+          parent.createSubscription(sub)
+        case _ =>
+      }
+    }
+    lastCollectionKey.set(last)
+  }
+
+
+  def getMessage(x: MessageId):Message = {
+    val id = Option(pendingStores.get(x)).flatMap(_.headOption).map(_.id).getOrElse(x)
+    val locator = id.getDataLocator()
+    val msg = client.getMessage(locator)
+    msg.setMessageId(id)
+    msg
+  }
+
+}
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/HALevelDBClient.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/HALevelDBClient.scala
new file mode 100644
index 000000000..9cb0983f5
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/HALevelDBClient.scala
@@ -0,0 +1,398 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb
+
+import org.apache.activemq.leveldb.util._
+
+import org.fusesource.leveldbjni.internal.Util
+import FileSupport._
+import org.codehaus.jackson.map.ObjectMapper
+import java.io._
+import scala.collection.mutable._
+import scala.collection.immutable.TreeMap
+import org.fusesource.hawtbuf.{ByteArrayOutputStream, Buffer}
+import org.apache.hadoop.fs.{FileSystem, Path}
+
+/**
+ *
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+object JsonCodec {
+
+  final val mapper: ObjectMapper = new ObjectMapper
+
+  def decode[T](buffer: Buffer, clazz: Class[T]): T = {
+    val original = Thread.currentThread.getContextClassLoader
+    Thread.currentThread.setContextClassLoader(this.getClass.getClassLoader)
+    try {
+      return mapper.readValue(buffer.in, clazz)
+    } finally {
+      Thread.currentThread.setContextClassLoader(original)
+    }
+  }
+
+  def decode[T](is: InputStream, clazz : Class[T]): T = {
+    var original: ClassLoader = Thread.currentThread.getContextClassLoader
+    Thread.currentThread.setContextClassLoader(this.getClass.getClassLoader)
+    try {
+      return JsonCodec.mapper.readValue(is, clazz)
+    }
+    finally {
+      Thread.currentThread.setContextClassLoader(original)
+    }
+  }
+
+
+  def encode(value: AnyRef): Buffer = {
+    var baos = new ByteArrayOutputStream
+    mapper.writeValue(baos, value)
+    return baos.toBuffer
+  }
+
+}
+
+/**
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+object HALevelDBClient extends Log {
+
+  val MANIFEST_SUFFIX = ".mf"
+  val LOG_SUFFIX = LevelDBClient.LOG_SUFFIX
+  val INDEX_SUFFIX = LevelDBClient.INDEX_SUFFIX
+
+
+  def create_sequence_path(directory:Path, id:Long, suffix:String) = new Path(directory, ("%016x%s".format(id, suffix)))
+
+  def find_sequence_status(fs:FileSystem, directory:Path, suffix:String) = {
+    TreeMap((fs.listStatus(directory).flatMap { f =>
+      val name = f.getPath.getName
+      if( name.endsWith(suffix) ) {
+        try {
+          val base = name.stripSuffix(suffix)
+          val position = java.lang.Long.parseLong(base, 16);
+          Some(position -> f )
+        } catch {
+          case e:NumberFormatException => None
+        }
+      } else {
+        None
+      }
+    }): _* )
+  }
+
+}
+
+/**
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class HALevelDBClient(val store:HALevelDBStore) extends LevelDBClient(store) {
+  import HALevelDBClient._
+
+  case class Snapshot(current_manifest:String, files:Set[String])
+  var snapshots = TreeMap[Long, Snapshot]()
+
+  // Eventually we will allow warm standby slaves to add references to old
+  // snapshots so that we don't delete them while they are in the process
+  // of downloading the snapshot.
+  var snapshotRefCounters = HashMap[Long, LongCounter]()
+  var indexFileRefCounters = HashMap[String, LongCounter]()
+
+  def dfs = store.dfs
+  def dfsDirectory = new Path(store.dfsDirectory)
+  def dfsBlockSize = store.dfsBlockSize
+  def dfsReplication = store.dfsReplication
+  def remoteIndexPath = new Path(dfsDirectory, "index")
+
+  override def start() = {
+    retry {
+      directory.mkdirs()
+      dfs.mkdirs(dfsDirectory)
+      downloadLogFiles
+      dfs.mkdirs(remoteIndexPath)
+      downloadIndexFiles
+    }
+    super.start()
+    storeTrace("Master takeover by: "+store.containerId, true)
+  }
+
+  override def locked_purge = {
+    super.locked_purge
+    dfs.delete(dfsDirectory, true)
+  }
+
+  override def snapshotIndex(sync: Boolean) = {
+    val previous_snapshot = lastIndexSnapshotPos
+    super.snapshotIndex(sync)
+    // upload the snapshot to the dfs
+    uploadIndexFiles(lastIndexSnapshotPos)
+
+    // Drop the previous snapshot reference..
+    for( counter <- snapshotRefCounters.get(previous_snapshot)) {
+      if( counter.decrementAndGet() <= 0 ) {
+        snapshotRefCounters.remove(previous_snapshot)
+      }
+    }
+    gcSnapshotRefs
+  }
+
+  // downloads missing log files...
+  def downloadLogFiles {
+    val log_files = find_sequence_status(dfs, dfsDirectory, LOG_SUFFIX)
+    val downloads = log_files.flatMap( _ match {
+      case (id, status) =>
+        val target = LevelDBClient.create_sequence_file(directory, id, LOG_SUFFIX)
+        // is it missing or does the size not match?
+        if (!target.exists() || target.length() != status.getLen) {
+          Some((id, status))
+        } else {
+          None
+        }
+    })
+    if( !downloads.isEmpty ) {
+      val total_size = downloads.foldLeft(0L)((a,x)=> a+x._2.getLen)
+      downloads.foreach {
+        case (id, status) =>
+          val target = LevelDBClient.create_sequence_file(directory, id, LOG_SUFFIX)
+          // is it missing or does the size not match?
+          if (!target.exists() || target.length() != status.getLen) {
+            info("Downloading log file: "+status.getPath.getName)
+            using(dfs.open(status.getPath, 32*1024)) { is=>
+              using(new FileOutputStream(target)) { os=>
+                copy(is, os)
+              }
+            }
+          }
+      }
+    }
+  }
+
+  // See if there is a more recent index that can be downloaded.
+  def downloadIndexFiles {
+
+    snapshots = TreeMap()
+    dfs.listStatus(remoteIndexPath).foreach { status =>
+      val name = status.getPath.getName
+      indexFileRefCounters.put(name, new LongCounter())
+      if( name endsWith MANIFEST_SUFFIX ) {
+        info("Getting index snapshot manifest: "+status.getPath.getName)
+        val mf = using(dfs.open(status.getPath)) { is =>
+          JsonCodec.decode(is, classOf[IndexManifestDTO])
+        }
+        import collection.JavaConversions._
+        snapshots += mf.snapshot_id -> Snapshot(mf.current_manifest, Set(mf.files.toSeq:_*))
+      }
+    }
+
+    // Check for invalid snapshots..
+    for( (snapshotid, snapshot) <- snapshots) {
+      val matches = indexFileRefCounters.keySet & snapshot.files
+      if( matches.size != snapshot.files.size ) {
+        var path = create_sequence_path(remoteIndexPath, snapshotid, MANIFEST_SUFFIX)
+        warn("Deleting inconsistent snapshot manifest: "+path.getName)
+        dfs.delete(path, true)
+        snapshots -= snapshotid
+      }
+    }
+
+    // Add a ref to the last snapshot..
+    for( (snapshotid, _) <- snapshots.lastOption ) {
+      snapshotRefCounters.getOrElseUpdate(snapshotid, new LongCounter()).incrementAndGet()
+    }
+    
+    // Increment index file refs..
+    for( key <- snapshotRefCounters.keys; snapshot <- snapshots.get(key); file <- snapshot.files ) {
+      indexFileRefCounters.getOrElseUpdate(file, new LongCounter()).incrementAndGet()
+    }
+
+    // Remove un-referenced index files.
+    for( (name, counter) <- indexFileRefCounters ) {
+      if( counter.get() <= 0 ) {
+        var path = new Path(remoteIndexPath, name)
+        info("Deleting unreferenced index file: "+path.getName)
+        dfs.delete(path, true)
+        indexFileRefCounters.remove(name)
+      }
+    }
+
+    val local_snapshots = Map(LevelDBClient.find_sequence_files(directory, INDEX_SUFFIX).values.flatten { dir =>
+      if( dir.isDirectory ) dir.listFiles() else Array[File]()
+    }.map(x=> (x.getName, x)).toSeq:_*)
+
+    for( (id, snapshot) <- snapshots.lastOption ) {
+
+      // increment the ref..
+      tempIndexFile.recursiveDelete
+      tempIndexFile.mkdirs
+
+      for( file <- snapshot.files ; if !file.endsWith(MANIFEST_SUFFIX) ) {
+        val target = tempIndexFile / file
+
+        // The file might be in a local snapshot already..
+        local_snapshots.get(file) match {
+          case Some(f) =>
+            // had it locally.. link it.
+            Util.link(f, target)
+          case None =>
+            // download..
+            var path = new Path(remoteIndexPath, file)
+            info("Downloading index file: "+path)
+            using(dfs.open(path, 32*1024)) { is=>
+              using(new FileOutputStream(target)) { os=>
+                copy(is, os)
+              }
+            }
+        }
+      }
+
+      val current = tempIndexFile / "CURRENT"
+      current.writeText(snapshot.current_manifest)
+
+      // We got everything ok, now rename.
+      tempIndexFile.renameTo(LevelDBClient.create_sequence_file(directory, id, INDEX_SUFFIX))
+    }
+
+    gcSnapshotRefs
+  }
+
+  def gcSnapshotRefs = {
+    snapshots = snapshots.filter { case (id, snapshot)=>
+      if (snapshotRefCounters.get(id).isDefined) {
+        true
+      } else {
+        for( file <- snapshot.files ) {
+          for( counter <- indexFileRefCounters.get(file) ) {
+            if( counter.decrementAndGet() <= 0 ) {
+              var path = new Path(remoteIndexPath, file)
+              info("Deleteing unreferenced index file: %s", path.getName)
+              dfs.delete(path, true)
+              indexFileRefCounters.remove(file)
+            }
+          }
+        }
+        false
+      }
+    }
+  }
+
+  def uploadIndexFiles(snapshot_id:Long):Unit = {
+
+    val source = LevelDBClient.create_sequence_file(directory, snapshot_id, INDEX_SUFFIX)
+    try {
+
+      // Build the new manifest..
+      val mf = new IndexManifestDTO
+      mf.snapshot_id = snapshot_id
+      mf.current_manifest = (source / "CURRENT").readText()
+      source.listFiles.foreach { file =>
+        val name = file.getName
+        if( name !="LOCK" && name !="CURRENT") {
+          mf.files.add(name)
+        }
+      }
+
+      import collection.JavaConversions._
+      mf.files.foreach { file =>
+        val refs = indexFileRefCounters.getOrElseUpdate(file, new LongCounter())
+        if(refs.get()==0) {
+          // Upload if not not yet on the remote.
+          val target = new Path(remoteIndexPath, file)
+          using(new FileInputStream(source / file)) { is=>
+            using(dfs.create(target, true, 1024*32, dfsReplication.toShort, dfsBlockSize)) { os=>
+              copy(is, os)
+            }
+          }
+        }
+        refs.incrementAndGet()
+      }
+
+      val target = create_sequence_path(remoteIndexPath, mf.snapshot_id, MANIFEST_SUFFIX)
+      mf.files.add(target.getName)
+
+      indexFileRefCounters.getOrElseUpdate(target.getName, new LongCounter()).incrementAndGet()
+      using(dfs.create(target, true, 1024*32, dfsReplication.toShort, dfsBlockSize)) { os=>
+        JsonCodec.mapper.writeValue(os, mf)
+      }
+
+      snapshots += snapshot_id -> Snapshot(mf.current_manifest, Set(mf.files.toSeq:_*))
+      snapshotRefCounters.getOrElseUpdate(snapshot_id, new LongCounter()).incrementAndGet()
+
+    } catch {
+      case e: Exception =>
+        warn(e, "Could not upload the index: " + e)
+    }
+  }
+
+
+
+  // Override the log appender implementation so that it
+  // stores the logs on the local and remote file systems.
+  override def createLog = new RecordLog(directory, LOG_SUFFIX) {
+
+
+    override protected def onDelete(file: File) = {
+      super.onDelete(file)
+      // also delete the file on the dfs.
+      dfs.delete(new Path(dfsDirectory, file.getName), false)
+    }
+
+    override def create_log_appender(position: Long) = {
+      new LogAppender(next_log(position), position) {
+
+        val dfs_path = new Path(dfsDirectory, file.getName)
+        debug("Opening DFS log file for append: "+dfs_path.getName)
+        val dfs_os = dfs.create(dfs_path, true, RecordLog.BUFFER_SIZE, dfsReplication.toShort, dfsBlockSize )
+        debug("Opened")
+
+        override def flush = this.synchronized {
+          if( write_buffer.position() > 0 ) {
+
+            var buffer: Buffer = write_buffer.toBuffer
+            // Write it to DFS..
+            buffer.writeTo(dfs_os.asInstanceOf[OutputStream]);
+
+            // Now write it to the local FS.
+            val byte_buffer = buffer.toByteBuffer
+            val pos = append_offset-byte_buffer.remaining
+            flushed_offset.addAndGet(byte_buffer.remaining)
+            channel.write(byte_buffer, pos)
+            if( byte_buffer.hasRemaining ) {
+              throw new IOException("Short write")
+            }
+
+            write_buffer.reset()
+          }
+        }
+
+        override def force = {
+          dfs_os.sync()
+        }
+
+        override def dispose() = {
+          try {
+            super.dispose()
+          } finally {
+            dfs_os.close()
+          }
+        }
+
+      }
+    }
+  }
+}
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/HALevelDBStore.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/HALevelDBStore.scala
new file mode 100644
index 000000000..afe46f021
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/HALevelDBStore.scala
@@ -0,0 +1,74 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb
+
+import org.apache.hadoop.conf.Configuration
+import org.apache.activemq.util.ServiceStopper
+import org.apache.hadoop.fs.FileSystem
+import scala.reflect.BeanProperty
+import java.net.InetAddress
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class HALevelDBStore extends LevelDBStore {
+
+  @BeanProperty
+  var dfsUrl:String = _
+  @BeanProperty
+  var dfsConfig:String = _
+  @BeanProperty
+  var dfsDirectory:String = _
+  @BeanProperty
+  var dfsBlockSize = 1024*1024*50L
+  @BeanProperty
+  var dfsReplication = 1
+  @BeanProperty
+  var containerId:String = _
+
+  var dfs:FileSystem = _
+
+  override def doStart = {
+    if(dfs==null) {
+      Thread.currentThread().setContextClassLoader(getClass.getClassLoader)
+      val config = new Configuration()
+      config.set("fs.hdfs.impl.disable.cache", "true")
+      config.set("fs.file.impl.disable.cache", "true")
+      Option(dfsConfig).foreach(config.addResource(_))
+      Option(dfsUrl).foreach(config.set("fs.default.name", _))
+      dfsUrl = config.get("fs.default.name")
+      dfs = FileSystem.get(config)
+    }
+    if ( containerId==null ) {
+      containerId = InetAddress.getLocalHost.getHostName
+    }
+    super.doStart
+  }
+
+  override def doStop(stopper: ServiceStopper): Unit = {
+    super.doStop(stopper)
+    if(dfs!=null){
+      dfs.close()
+    }
+  }
+
+  override def createClient = new HALevelDBClient(this)
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/IndexManifestDTO.java b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/IndexManifestDTO.java
new file mode 100644
index 000000000..56b2c96dc
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/IndexManifestDTO.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+@XmlRootElement(name="index_files")
+@XmlAccessorType(XmlAccessType.FIELD)
+public class IndexManifestDTO {
+
+    @XmlAttribute(name = "snapshot_id")
+    public long snapshot_id;
+
+    @XmlAttribute(name = "current_manifest")
+    public String current_manifest;
+
+    @XmlAttribute(name = "file")
+    public Set<String> files = new HashSet<String>();
+
+}
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBClient.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBClient.scala
new file mode 100755
index 000000000..7ae1dc7e7
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBClient.scala
@@ -0,0 +1,1218 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb
+
+import java.{lang=>jl}
+import java.{util=>ju}
+
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import collection.immutable.TreeMap
+import collection.mutable.{HashMap, ListBuffer}
+import org.iq80.leveldb._
+
+import org.fusesource.hawtdispatch._
+import record.{CollectionKey, EntryKey, EntryRecord, CollectionRecord}
+import util._
+import java.util.concurrent._
+import org.fusesource.hawtbuf._
+import java.io.{ObjectInputStream, ObjectOutputStream, File}
+import scala.Option._
+import org.apache.activemq.command.Message
+import org.apache.activemq.util.ByteSequence
+import org.apache.activemq.leveldb.RecordLog.LogInfo
+import java.text.SimpleDateFormat
+import java.util.{Date, Collections}
+
+/**
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+object LevelDBClient extends Log {
+
+  final val STORE_SCHEMA_PREFIX = "activemq_leveldb_store:"
+  final val STORE_SCHEMA_VERSION = 1
+
+  final val THREAD_POOL_STACK_SIZE = System.getProperty("leveldb.thread.stack.size", "" + 1024 * 512).toLong
+  final val THREAD_POOL: ThreadPoolExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue[Runnable], new ThreadFactory {
+    def newThread(r: Runnable): Thread = {
+      var rc: Thread = new Thread(null, r, "LevelDB Store Task", THREAD_POOL_STACK_SIZE)
+      rc.setDaemon(true)
+      return rc
+    }
+  }) {
+    override def shutdown: Unit = {}
+    override def shutdownNow = Collections.emptyList[Runnable]
+  }
+
+  final val DIRTY_INDEX_KEY = bytes(":dirty")
+  final val LOG_REF_INDEX_KEY = bytes(":log-refs")
+  final val COLLECTION_META_KEY = bytes(":collection-meta")
+  final val TRUE = bytes("true")
+  final val FALSE = bytes("false")
+  final val ACK_POSITION = new AsciiBuffer("p")
+
+  final val COLLECTION_PREFIX = 'c'.toByte
+  final val COLLECTION_PREFIX_ARRAY = Array(COLLECTION_PREFIX)
+  final val ENTRY_PREFIX = 'e'.toByte
+  final val ENTRY_PREFIX_ARRAY = Array(ENTRY_PREFIX)
+
+  final val LOG_ADD_COLLECTION      = 1.toByte
+  final val LOG_REMOVE_COLLECTION   = 2.toByte
+  final val LOG_ADD_ENTRY           = 3.toByte
+  final val LOG_REMOVE_ENTRY        = 4.toByte
+  final val LOG_DATA                = 5.toByte
+  final val LOG_TRACE               = 6.toByte
+
+  final val LOG_SUFFIX  = ".log"
+  final val INDEX_SUFFIX  = ".index"
+  
+  implicit def toByteArray(buffer:Buffer) = buffer.toByteArray
+  implicit def toBuffer(buffer:Array[Byte]) = new Buffer(buffer)
+  
+  def encodeCollectionRecord(v: CollectionRecord.Buffer) = v.toUnframedByteArray
+  def decodeCollectionRecord(data: Buffer):CollectionRecord.Buffer = CollectionRecord.FACTORY.parseUnframed(data)
+  def encodeCollectionKeyRecord(v: CollectionKey.Buffer) = v.toUnframedByteArray
+  def decodeCollectionKeyRecord(data: Buffer):CollectionKey.Buffer = CollectionKey.FACTORY.parseUnframed(data)
+
+  def encodeEntryRecord(v: EntryRecord.Buffer) = v.toUnframedBuffer
+  def decodeEntryRecord(data: Buffer):EntryRecord.Buffer = EntryRecord.FACTORY.parseUnframed(data)
+
+  def encodeEntryKeyRecord(v: EntryKey.Buffer) = v.toUnframedByteArray
+  def decodeEntryKeyRecord(data: Buffer):EntryKey.Buffer = EntryKey.FACTORY.parseUnframed(data)
+
+  def encodeLocator(pos:Long, len:Int):Array[Byte] = {
+    val out = new DataByteArrayOutputStream(
+      AbstractVarIntSupport.computeVarLongSize(pos)+
+      AbstractVarIntSupport.computeVarIntSize(len)
+    )
+    out.writeVarLong(pos)
+    out.writeVarInt(len)
+    out.getData
+  }
+  def decodeLocator(bytes:Buffer):(Long,  Int) = {
+    val in = new DataByteArrayInputStream(bytes)
+    (in.readVarLong(), in.readVarInt())
+  }
+  def decodeLocator(bytes:Array[Byte]):(Long,  Int) = {
+    val in = new DataByteArrayInputStream(bytes)
+    (in.readVarLong(), in.readVarInt())
+  }
+
+  def encodeLong(a1:Long) = {
+    val out = new DataByteArrayOutputStream(8)
+    out.writeLong(a1)
+    out.toBuffer
+  }
+
+  def encodeVLong(a1:Long):Array[Byte] = {
+    val out = new DataByteArrayOutputStream(
+      AbstractVarIntSupport.computeVarLongSize(a1)
+    )
+    out.writeVarLong(a1)
+    out.getData
+  }
+
+  def decodeVLong(bytes:Array[Byte]):Long = {
+    val in = new DataByteArrayInputStream(bytes)
+    in.readVarLong()
+  }
+
+  def encodeLongKey(a1:Byte, a2:Long):Array[Byte] = {
+    val out = new DataByteArrayOutputStream(9)
+    out.writeByte(a1.toInt)
+    out.writeLong(a2)
+    out.getData
+  }
+  def decodeLongKey(bytes:Array[Byte]):(Byte, Long) = {
+    val in = new DataByteArrayInputStream(bytes)
+    (in.readByte(), in.readLong())
+  }
+
+  def decodeLong(bytes:Buffer):Long = {
+    val in = new DataByteArrayInputStream(bytes)
+    in.readLong()
+  }
+  def decodeLong(bytes:Array[Byte]):Long = {
+    val in = new DataByteArrayInputStream(bytes)
+    in.readLong()
+  }
+
+  def encodeEntryKey(a1:Byte, a2:Long, a3:Long):Array[Byte] = {
+    val out = new DataByteArrayOutputStream(17)
+    out.writeByte(a1.toInt)
+    out.writeLong(a2)
+    out.writeLong(a3)
+    out.getData
+  }
+
+  def encodeEntryKey(a1:Byte, a2:Long, a3:Buffer):Array[Byte] = {
+    val out = new DataByteArrayOutputStream(9+a3.length)
+    out.writeByte(a1.toInt)
+    out.writeLong(a2)
+    out.write(a3)
+    out.getData
+  }
+  
+  def decodeEntryKey(bytes:Array[Byte]):(Byte, Long, Buffer) = {
+    val in = new DataByteArrayInputStream(bytes)
+    (in.readByte(), in.readLong(), in.readBuffer(in.available()))
+  }
+
+  final class RichDB(val db: DB) {
+
+    val isPureJavaVersion = db.getClass.getName == "org.iq80.leveldb.impl.DbImpl"
+
+    def getProperty(name:String) = db.getProperty(name)
+
+    def getApproximateSizes(ranges:Range*) = db.getApproximateSizes(ranges:_*)
+
+    def get(key:Array[Byte], ro:ReadOptions=new ReadOptions):Option[Array[Byte]] = {
+      Option(db.get(key, ro))
+    }
+
+    def close:Unit = db.close()
+
+    def delete(key:Array[Byte], wo:WriteOptions=new WriteOptions):Unit = {
+      db.delete(key, wo)
+    }
+
+    def put(key:Array[Byte], value:Array[Byte], wo:WriteOptions=new WriteOptions):Unit = {
+      db.put(key, value, wo)
+    }
+    
+    def write[T](wo:WriteOptions=new WriteOptions, max_write_latency:TimeMetric = TimeMetric())(func: WriteBatch=>T):T = {
+      val updates = db.createWriteBatch()
+      try {
+        val rc=Some(func(updates))
+        max_write_latency {
+          db.write(updates, wo)
+        }
+        return rc.get
+      } finally {
+        updates.close();
+      }
+    }
+
+    def store[T](write:WriteBatch, wo:WriteOptions=new WriteOptions) = {
+      db.write(write, wo)
+    }
+
+    def snapshot[T](func: Snapshot=>T):T = {
+      val snapshot = db.getSnapshot
+      try {
+        func(snapshot)
+      } finally {
+        snapshot.close()
+      }
+    }
+
+    def cursorKeys(ro:ReadOptions=new ReadOptions)(func: Array[Byte] => Boolean): Unit = {
+      val iterator = db.iterator(ro)
+      iterator.seekToFirst();
+      try {
+        while( iterator.hasNext && func(iterator.peekNext.getKey) ) {
+          iterator.next()
+        }
+      } finally {
+        iterator.close();
+      }
+    }
+
+    def cursorKeysPrefixed(prefix:Array[Byte], ro:ReadOptions=new ReadOptions)(func: Array[Byte] => Boolean): Unit = {
+      val iterator = db.iterator(ro)
+      iterator.seek(prefix);
+      try {
+        def check(key:Buffer) = {
+          key.startsWith(prefix) && func(key)
+        }
+        while( iterator.hasNext && check(iterator.peekNext.getKey) ) {
+          iterator.next()
+        }
+      } finally {
+        iterator.close();
+      }
+    }
+
+    def cursorPrefixed(prefix:Array[Byte], ro:ReadOptions=new ReadOptions)(func: (Array[Byte],Array[Byte]) => Boolean): Unit = {
+      val iterator = db.iterator(ro)
+      iterator.seek(prefix);
+      try {
+        def check(key:Buffer) = {
+          key.startsWith(prefix) && func(key, iterator.peekNext.getValue)
+        }
+        while( iterator.hasNext && check(iterator.peekNext.getKey) ) {
+          iterator.next()
+        }
+      } finally {
+        iterator.close();
+      }
+    }
+
+    def compare(a1:Array[Byte], a2:Array[Byte]):Int = {
+      new Buffer(a1).compareTo(new Buffer(a2))
+    }
+
+    def cursorRangeKeys(startIncluded:Array[Byte], endExcluded:Array[Byte], ro:ReadOptions=new ReadOptions)(func: Array[Byte] => Boolean): Unit = {
+      val iterator = db.iterator(ro)
+      iterator.seek(startIncluded);
+      try {
+        def check(key:Array[Byte]) = {
+          if ( compare(key,endExcluded) < 0) {
+            func(key)
+          } else {
+            false
+          }
+        }
+        while( iterator.hasNext && check(iterator.peekNext.getKey) ) {
+          iterator.next()
+        }
+      } finally {
+        iterator.close();
+      }
+    }
+
+    def cursorRange(startIncluded:Array[Byte], endExcluded:Array[Byte], ro:ReadOptions=new ReadOptions)(func: (Array[Byte],Array[Byte]) => Boolean): Unit = {
+      val iterator = db.iterator(ro)
+      iterator.seek(startIncluded);
+      try {
+        def check(key:Array[Byte]) = {
+          (compare(key,endExcluded) < 0) && func(key, iterator.peekNext.getValue)
+        }
+        while( iterator.hasNext && check(iterator.peekNext.getKey) ) {
+          iterator.next()
+        }
+      } finally {
+        iterator.close();
+      }
+    }
+
+    def lastKey(prefix:Array[Byte], ro:ReadOptions=new ReadOptions): Option[Array[Byte]] = {
+      val last = new Buffer(prefix).deepCopy().data
+      if ( last.length > 0 ) {
+        val pos = last.length-1
+        last(pos) = (last(pos)+1).toByte
+      }
+
+      if(isPureJavaVersion) {
+        // The pure java version of LevelDB does not support backward iteration.
+        var rc:Option[Array[Byte]] = None
+        cursorRangeKeys(prefix, last) { key=>
+          rc = Some(key)
+          true
+        }
+        rc
+      } else {
+        val iterator = db.iterator(ro)
+        try {
+
+          iterator.seek(last);
+          if ( iterator.hasPrev ) {
+            iterator.prev()
+          } else {
+            iterator.seekToLast()
+          }
+
+          if ( iterator.hasNext ) {
+            val key:Buffer = iterator.peekNext.getKey
+            if(key.startsWith(prefix)) {
+              Some(key)
+            } else {
+              None
+            }
+          } else {
+            None
+          }
+        } finally {
+          iterator.close();
+        }
+      }
+    }
+  }
+
+
+  def bytes(value:String) = value.getBytes("UTF-8")
+
+  import FileSupport._
+  def create_sequence_file(directory:File, id:Long, suffix:String) = directory / ("%016x%s".format(id, suffix))
+
+  def find_sequence_files(directory:File, suffix:String):TreeMap[Long, File] = {
+    TreeMap((directory.listFiles.flatMap { f=>
+      if( f.getName.endsWith(suffix) ) {
+        try {
+          val base = f.getName.stripSuffix(suffix)
+          val position = java.lang.Long.parseLong(base, 16);
+          Some(position -> f)
+        } catch {
+          case e:NumberFormatException => None
+        }
+      } else {
+        None
+      }
+    }): _* )
+  }
+
+  class CollectionMeta extends Serializable {
+    var size = 0L
+    var last_key:Array[Byte] = _
+  }
+}
+
+
+/**
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class LevelDBClient(store: LevelDBStore) {
+
+  import LevelDBClient._
+  import FileSupport._
+
+  val dispatchQueue = createQueue("leveldb")
+
+  /////////////////////////////////////////////////////////////////////
+  //
+  // Helpers
+  //
+  /////////////////////////////////////////////////////////////////////
+
+  def directory = store.directory
+  def logDirectory = Option(store.logDirectory).getOrElse(store.directory)
+
+  /////////////////////////////////////////////////////////////////////
+  //
+  // Public interface used by the DBManager
+  //
+  /////////////////////////////////////////////////////////////////////
+
+  def sync = store.sync;
+  def verifyChecksums = store.verifyChecksums
+
+  var log:RecordLog = _
+
+  var index:RichDB = _
+  var indexOptions:Options = _
+
+  var lastIndexSnapshotPos:Long = _
+  val snapshotRwLock = new ReentrantReadWriteLock(true)
+
+  var factory:DBFactory = _
+  val logRefs = HashMap[Long, LongCounter]()
+  
+  val collectionMeta = HashMap[Long, CollectionMeta]()
+
+  def dirtyIndexFile = directory / ("dirty"+INDEX_SUFFIX)
+  def tempIndexFile = directory / ("temp"+INDEX_SUFFIX)
+  def snapshotIndexFile(id:Long) = create_sequence_file(directory,id, INDEX_SUFFIX)
+
+  def createLog: RecordLog = {
+    new RecordLog(logDirectory, LOG_SUFFIX)
+  }
+
+  var writeExecutor:ExecutorService = _
+
+  def storeTrace(ascii:String, force:Boolean=false) = {
+    val time = new SimpleDateFormat("dd/MMM/yyyy:HH:mm::ss Z").format(new Date)
+    log.appender { appender =>
+      appender.append(LOG_TRACE, new AsciiBuffer("%s: %s".format(time, ascii)))
+      if( force ) {
+        appender.force
+      }
+    }
+  }
+
+  def retry[T](func : =>T):T = RetrySupport.retry(LevelDBClient, store.isStarted, func _)
+
+  def start() = {
+
+    // Lets check store compatibility...
+    directory.mkdirs()
+    val version_file = directory / "store-version.txt"
+    if (version_file.exists()) {
+      val ver = try {
+        var tmp: String = version_file.readText().trim()
+        if (tmp.startsWith(STORE_SCHEMA_PREFIX)) {
+          tmp.stripPrefix(STORE_SCHEMA_PREFIX).toInt
+        } else {
+          -1
+        }
+      } catch {
+        case e => throw new Exception("Unexpected version file format: " + version_file)
+      }
+      ver match {
+        case STORE_SCHEMA_VERSION => // All is good.
+        case _ => throw new Exception("Cannot open the store.  It's schema version is not supported.")
+      }
+    }
+    version_file.writeText(STORE_SCHEMA_PREFIX + STORE_SCHEMA_VERSION)
+
+    writeExecutor = Executors.newFixedThreadPool(1, new ThreadFactory() {
+      def newThread(r: Runnable) = {
+        val rc = new Thread(r, "LevelDB store io write")
+        rc.setDaemon(true)
+        rc
+      }
+    })
+
+    val factoryNames = store.indexFactory
+    factory = factoryNames.split("""(,|\s)+""").map(_.trim()).flatMap { name=>
+      try {
+        Some(this.getClass.getClassLoader.loadClass(name).newInstance().asInstanceOf[DBFactory])
+      } catch {
+        case e:Throwable =>
+          debug(e, "Could not load factory: "+name+" due to: "+e)
+          None
+      }
+    }.headOption.getOrElse(throw new Exception("Could not load any of the index factory classes: "+factoryNames))
+
+    if( factory.getClass.getName == "org.iq80.leveldb.impl.Iq80DBFactory") {
+      warn("Using the pure java LevelDB implementation which is still experimental.  Production users should use the JNI based LevelDB implementation instead.")
+    }
+
+    indexOptions = new Options();
+    indexOptions.createIfMissing(true);
+
+    indexOptions.maxOpenFiles(store.indexMaxOpenFiles)
+    indexOptions.blockRestartInterval(store.indexBlockRestartInterval)
+    indexOptions.paranoidChecks(store.paranoidChecks)
+    indexOptions.writeBufferSize(store.indexWriteBufferSize)
+    indexOptions.blockSize(store.indexBlockSize)
+    indexOptions.compressionType( store.indexCompression.toLowerCase match {
+      case "snappy" => CompressionType.SNAPPY
+      case "none" => CompressionType.NONE
+      case _ => CompressionType.SNAPPY
+    })
+
+    indexOptions.cacheSize(store.indexCacheSize)
+    indexOptions.logger(new Logger() {
+      val LOG = Log(factory.getClass.getName)
+      def log(msg: String) = LOG.debug("index: "+msg.stripSuffix("\n"))
+    })
+
+    log = createLog
+    log.logSize = store.logSize
+    log.on_log_rotate = ()=> {
+      // We snapshot the index every time we rotate the logs.
+      writeExecutor {
+        snapshotIndex(false)
+      }
+    }
+
+    retry {
+      log.open
+    }
+
+    // Find out what was the last snapshot.
+    val snapshots = find_sequence_files(directory, INDEX_SUFFIX)
+    var lastSnapshotIndex = snapshots.lastOption
+    lastIndexSnapshotPos = lastSnapshotIndex.map(_._1).getOrElse(0)
+
+    // Only keep the last snapshot..
+    snapshots.filterNot(_._1 == lastIndexSnapshotPos).foreach( _._2.recursiveDelete )
+    tempIndexFile.recursiveDelete
+
+    retry {
+
+      // Delete the dirty indexes
+      dirtyIndexFile.recursiveDelete
+      dirtyIndexFile.mkdirs()
+
+      lastSnapshotIndex.foreach { case (id, file) =>
+        // Resume log replay from a snapshot of the index..
+        try {
+          file.listFiles.foreach { file =>
+            file.linkTo(dirtyIndexFile / file.getName)
+          }
+        } catch {
+          case e:Exception =>
+            warn(e, "Could not recover snapshot of the index: "+e)
+            lastSnapshotIndex  = None
+        }
+      }
+
+      index = new RichDB(factory.open(dirtyIndexFile, indexOptions));
+      try {
+        loadCounters
+        index.put(DIRTY_INDEX_KEY, TRUE)
+        // Update the index /w what was stored on the logs..
+        var pos = lastIndexSnapshotPos;
+        var last_reported_at = System.currentTimeMillis();
+        var showing_progress = false
+        var last_reported_pos = 0L
+        try {
+          while (pos < log.appender_limit) {
+            val now = System.currentTimeMillis();
+            if( now > last_reported_at+1000 ) {
+              val at = pos-lastIndexSnapshotPos
+              val total = log.appender_limit-lastIndexSnapshotPos
+              val rate = (pos-last_reported_pos)*1000.0 / (now - last_reported_at)
+              val eta = (total-at)/rate
+              val remaining = if(eta > 60*60) {
+                "%.2f hrs".format(eta/(60*60))
+              } else if(eta > 60) {
+                "%.2f mins".format(eta/60)
+              } else {
+                "%.0f secs".format(eta)
+              }
+
+              System.out.print("Replaying recovery log: %f%% done (%,d/%,d bytes) @ %,.2f kb/s, %s remaining.     \r".format(
+                at*100.0/total, at, total, rate/1024, remaining))
+              showing_progress = true;
+              last_reported_at = now
+              last_reported_pos = pos
+            }
+
+
+            log.read(pos).map {
+              case (kind, data, nextPos) =>
+                kind match {
+                  case LOG_ADD_COLLECTION =>
+                    val record= decodeCollectionRecord(data)
+                    index.put(encodeLongKey(COLLECTION_PREFIX, record.getKey), data)
+                    collectionMeta.put(record.getKey, new CollectionMeta)
+
+                  case LOG_REMOVE_COLLECTION =>
+                    val record = decodeCollectionKeyRecord(data)
+                    // Delete the entries in the collection.
+                    index.cursorPrefixed(encodeLongKey(ENTRY_PREFIX, record.getKey), new ReadOptions) { (key, value)=>
+                      val record = decodeEntryRecord(value)
+                      val pos = if ( record.hasValueLocation ) {
+                        Some(record.getValueLocation)
+                      } else {
+                        None
+                      }
+                      pos.foreach(logRefDecrement(_))
+                      index.delete(key)
+                      true
+                    }
+                    index.delete(data)
+                    collectionMeta.remove(record.getKey)
+
+                  case LOG_ADD_ENTRY =>
+                    val record = decodeEntryRecord(data)
+
+                    val index_record = new EntryRecord.Bean()
+                    index_record.setValueLocation(record.getValueLocation)
+                    index_record.setValueLength(record.getValueLength)
+                    val    index_value = encodeEntryRecord(index_record.freeze()).toByteArray
+
+                    index.put(encodeEntryKey(ENTRY_PREFIX, record.getCollectionKey, record.getEntryKey), index_value)
+
+                    if ( record.hasValueLocation ) {
+                      logRefIncrement(record.getValueLocation)
+                    }
+                    collectionIncrementSize(record.getCollectionKey, record.getEntryKey.toByteArray)
+
+                  case LOG_REMOVE_ENTRY =>
+                    val record = decodeEntryRecord(data)
+
+                    // Figure out which log file this message reference is pointing at..
+                    if ( record.hasValueLocation ) {
+                      logRefDecrement(record.getValueLocation)
+                    }
+
+                    index.delete(encodeEntryKey(ENTRY_PREFIX, record.getCollectionKey, record.getEntryKey))
+                    collectionDecrementSize( record.getCollectionKey)
+
+                  case _ => // Skip other records, they don't modify the index.
+
+                }
+                pos = nextPos
+            }
+          }
+        }
+        catch {
+          case e:Throwable => e.printStackTrace()
+        }
+        if(showing_progress) {
+          System.out.print("                                                                       \r");
+        }
+
+      } catch {
+        case e:Throwable =>
+          // replay failed.. good thing we are in a retry block...
+          index.close
+          throw e;
+      }
+    }
+  }
+
+  private def logRefDecrement(pos: Long) {
+    log.log_info(pos).foreach { logInfo =>
+      logRefs.get(logInfo.position).foreach { counter =>
+        if (counter.decrementAndGet() == 0) {
+          logRefs.remove(logInfo.position)
+        }
+      }
+    }
+  }
+
+  private def logRefIncrement(pos: Long) {
+    log.log_info(pos).foreach { logInfo =>
+      logRefs.getOrElseUpdate(logInfo.position, new LongCounter()).incrementAndGet()
+    }
+  }
+
+  private def collectionDecrementSize(key: Long) {
+    collectionMeta.get(key).foreach(_.size -= 1)
+  }
+  private def collectionIncrementSize(key: Long, last_key:Array[Byte]) {
+    collectionMeta.get(key).foreach{ x=> 
+      x.size += 1
+      x.last_key = last_key
+    }
+  }
+
+  private def storeCounters = {
+    def storeMap(key:Array[Byte], map:HashMap[Long, _ <: AnyRef]) {
+      val baos = new ByteArrayOutputStream()
+      val os = new ObjectOutputStream(baos);
+      os.writeInt(map.size);
+      map.foreach {
+        case (k, v) =>
+          os.writeLong(k)
+          os.writeObject(v)
+      }
+      os.close()
+      index.put(key, baos.toByteArray)
+    }
+    storeMap(LOG_REF_INDEX_KEY, logRefs)
+    storeMap(COLLECTION_META_KEY, collectionMeta)
+  }
+
+  private def loadCounters = {
+    def loadMap[T <: AnyRef](key:Array[Byte], map:HashMap[Long, T]) {
+      map.clear()
+      index.get(key, new ReadOptions).foreach { value=>
+        val bais = new ByteArrayInputStream(value)
+        val is = new ObjectInputStream(bais);
+        var remaining = is.readInt()
+        while(remaining > 0 ) {
+          map.put(is.readLong(), is.readObject().asInstanceOf[T])
+          remaining-=1
+        }
+      }
+    }
+    loadMap(LOG_REF_INDEX_KEY, logRefs)
+    loadMap(COLLECTION_META_KEY, collectionMeta)
+  }
+  
+  def stop() = {
+    if( writeExecutor!=null ) {
+      writeExecutor.shutdown
+      writeExecutor.awaitTermination(60, TimeUnit.SECONDS)
+      writeExecutor = null
+
+      // this blocks until all io completes..
+      // Suspend also deletes the index.
+      suspend()
+
+      if (log != null) {
+        log.close
+      }
+      copyDirtyIndexToSnapshot
+      log = null
+    }
+  }
+
+  def usingIndex[T](func: =>T):T = {
+    val lock = snapshotRwLock.readLock();
+    lock.lock()
+    try {
+      func
+    } finally {
+      lock.unlock()
+    }
+  }
+
+  def retryUsingIndex[T](func: =>T):T = retry(usingIndex( func ))
+
+  /**
+   * TODO: expose this via management APIs, handy if you want to
+   * do a file system level snapshot and want the data to be consistent.
+   */
+  def suspend() = {
+    // Make sure we are the only ones accessing the index. since
+    // we will be closing it to create a consistent snapshot.
+    snapshotRwLock.writeLock().lock()
+
+    // Close the index so that it's files are not changed async on us.
+    storeCounters
+    index.put(DIRTY_INDEX_KEY, FALSE, new WriteOptions().sync(true))
+    index.close
+  }
+
+  /**
+   * TODO: expose this via management APIs, handy if you want to
+   * do a file system level snapshot and want the data to be consistent.
+   */
+  def resume() = {
+    // re=open it..
+    retry {
+      index = new RichDB(factory.open(dirtyIndexFile, indexOptions));
+      index.put(DIRTY_INDEX_KEY, TRUE)
+    }
+    snapshotRwLock.writeLock().unlock()
+  }
+
+  def copyDirtyIndexToSnapshot {
+    if( log.appender_limit == lastIndexSnapshotPos  ) {
+      // no need to snapshot again...
+      return
+    }
+
+    // Where we start copying files into.  Delete this on
+    // restart.
+    val tmpDir = tempIndexFile
+    tmpDir.mkdirs()
+
+    try {
+
+      // Hard link all the index files.
+      dirtyIndexFile.listFiles.foreach { file =>
+        file.linkTo(tmpDir / file.getName)
+      }
+
+      // Rename to signal that the snapshot is complete.
+      val newSnapshotIndexPos = log.appender_limit
+      tmpDir.renameTo(snapshotIndexFile(newSnapshotIndexPos))
+      snapshotIndexFile(lastIndexSnapshotPos).recursiveDelete
+      lastIndexSnapshotPos = newSnapshotIndexPos
+
+    } catch {
+      case e: Exception =>
+        // if we could not snapshot for any reason, delete it as we don't
+        // want a partial check point..
+        warn(e, "Could not snapshot the index: " + e)
+        tmpDir.recursiveDelete
+    }
+  }
+
+  def snapshotIndex(sync:Boolean=false):Unit = {
+    suspend()
+    try {
+      if( sync ) {
+        log.current_appender.force
+      }
+      if( log.appender_limit == lastIndexSnapshotPos  ) {
+        // no need to snapshot again...
+        return
+      }
+      copyDirtyIndexToSnapshot
+    } finally {
+      resume()
+    }
+  }
+
+  def purge() = {
+    suspend()
+    try{
+      log.close
+      locked_purge
+    } finally {
+      retry {
+        log.open
+      }
+      resume()
+    }
+  }
+
+  def locked_purge {
+    logDirectory.listFiles.foreach {x =>
+      if (x.getName.endsWith(".log")) {
+        x.delete()
+      }
+    }
+    directory.listFiles.foreach {x =>
+      if (x.getName.endsWith(".index")) {
+        x.recursiveDelete
+      }
+    }
+  }
+
+  def addCollection(record: CollectionRecord.Buffer) = {
+    val key = encodeLongKey(COLLECTION_PREFIX, record.getKey)
+    val value = record.toUnframedBuffer
+    retryUsingIndex {
+      log.appender { appender =>
+        appender.append(LOG_ADD_COLLECTION, value)
+        index.put(key, value.toByteArray)
+      }
+    }
+    collectionMeta.put(record.getKey, new CollectionMeta)
+  }
+
+  def getLogAppendPosition = log.appender_limit
+
+  def listCollections: Seq[(Long, CollectionRecord.Buffer)] = {
+    val rc = ListBuffer[(Long, CollectionRecord.Buffer)]()
+    retryUsingIndex {
+      val ro = new ReadOptions
+      ro.verifyChecksums(verifyChecksums)
+      ro.fillCache(false)
+      index.cursorPrefixed(COLLECTION_PREFIX_ARRAY, ro) { (key, value) =>
+        rc.append(( decodeLongKey(key)._2, CollectionRecord.FACTORY.parseUnframed(value) ))
+        true // to continue cursoring.
+      }
+    }
+    rc
+  }
+
+  def removeCollection(collectionKey: Long) = {
+    val key = encodeLongKey(COLLECTION_PREFIX, collectionKey)
+    val value = encodeVLong(collectionKey)
+    val entryKeyPrefix = encodeLongKey(ENTRY_PREFIX, collectionKey)
+    collectionMeta.remove(collectionKey)
+    retryUsingIndex {
+      log.appender { appender =>
+        appender.append(LOG_REMOVE_COLLECTION, new Buffer(value))
+      }
+
+      val ro = new ReadOptions
+      ro.fillCache(false)
+      ro.verifyChecksums(verifyChecksums)
+      index.cursorPrefixed(entryKeyPrefix, ro) { (key, value)=>
+        val record = decodeEntryRecord(value)
+        val pos = if ( record.hasValueLocation ) {
+          Some(record.getValueLocation)
+        } else {
+          None
+        }
+        pos.foreach(logRefDecrement(_))
+        index.delete(key)
+        true
+      }
+      index.delete(key)
+    }
+  }
+
+  def collectionEmpty(collectionKey: Long) = {
+    val key = encodeLongKey(COLLECTION_PREFIX, collectionKey)
+    val value = encodeVLong(collectionKey)
+    val entryKeyPrefix = encodeLongKey(ENTRY_PREFIX, collectionKey)
+
+    val meta = collectionMeta.getOrElseUpdate(collectionKey, new CollectionMeta)
+    meta.size = 0
+    meta.last_key = null
+    
+    retryUsingIndex {
+      index.get(key).foreach { collectionData =>
+        log.appender { appender =>
+          appender.append(LOG_REMOVE_COLLECTION, new Buffer(value))
+          appender.append(LOG_ADD_COLLECTION, new Buffer(collectionData))
+        }
+
+        val ro = new ReadOptions
+        ro.fillCache(false)
+        ro.verifyChecksums(verifyChecksums)
+        index.cursorPrefixed(entryKeyPrefix, ro) { (key, value)=>
+          val record = decodeEntryRecord(value)
+          val pos = if ( record.hasValueLocation ) {
+            Some(record.getValueLocation)
+          } else {
+            None
+          }
+          pos.foreach(logRefDecrement(_))
+          index.delete(key)
+          true
+        }
+      }
+    }
+  }
+
+  def queueCursor(collectionKey: Long, seq:Long)(func: (Message)=>Boolean) = {
+    collectionCursor(collectionKey, encodeLong(seq)) { (key, value) =>
+      val seq = decodeLong(key)
+      var locator = (value.getValueLocation, value.getValueLength)
+      val msg = getMessage(locator)
+      msg.getMessageId().setEntryLocator((collectionKey, seq))
+      msg.getMessageId().setDataLocator(locator)
+      func(msg)
+    }
+  }
+
+  def getAckPosition(subKey: Long): Long = {
+    retryUsingIndex {
+      index.get(encodeEntryKey(ENTRY_PREFIX, subKey, ACK_POSITION)).map{ value=>
+        val record = decodeEntryRecord(value)
+        record.getValueLocation()
+      }.getOrElse(0L)
+    }
+  }
+
+  def getMessage(locator:AnyRef):Message = {
+    assert(locator!=null)
+    val buffer = locator match {
+      case x:MessageRecord =>
+        // Encoded form is still in memory..
+        Some(x.data)
+      case (pos:Long, len:Int) =>
+        // Load the encoded form from disk.
+        log.read(pos, len).map(new Buffer(_))
+    }
+
+    // Lets decode
+    buffer.map{ x =>
+      var data = if( store.snappyCompressLogs ) {
+        Snappy.uncompress(x)
+      } else {
+        x
+      }
+      store.wireFormat.unmarshal(new ByteSequence(data.data, data.offset, data.length)).asInstanceOf[Message]
+    }.getOrElse(null)
+  }
+
+
+  def collectionCursor(collectionKey: Long, cursorPosition:Buffer)(func: (Buffer, EntryRecord.Buffer)=>Boolean) = {
+    val ro = new ReadOptions
+    ro.fillCache(true)
+    ro.verifyChecksums(verifyChecksums)
+    val start = encodeEntryKey(ENTRY_PREFIX, collectionKey, cursorPosition)
+    val end = encodeLongKey(ENTRY_PREFIX, collectionKey+1)
+    retryUsingIndex {
+      index.cursorRange(start, end, ro) { case (key, value) =>
+        func(key.buffer.moveHead(9), EntryRecord.FACTORY.parseUnframed(value))
+      }
+    }
+  }
+
+  def collectionSize(collectionKey: Long) = {
+    collectionMeta.get(collectionKey).map(_.size).getOrElse(0L)
+  }
+
+  def collectionIsEmpty(collectionKey: Long) = {
+    val entryKeyPrefix = encodeLongKey(ENTRY_PREFIX, collectionKey)
+    var empty = true
+    retryUsingIndex {
+      val ro = new ReadOptions
+      ro.fillCache(false)
+      ro.verifyChecksums(verifyChecksums)
+      index.cursorKeysPrefixed(entryKeyPrefix, ro) { key =>
+        empty = false
+        false
+      }
+    }
+    empty
+  }
+
+  val max_write_message_latency = TimeMetric()
+  val max_write_enqueue_latency = TimeMetric()
+
+  val max_index_write_latency = TimeMetric()
+
+  def store(uows: Array[DelayableUOW]) {
+    retryUsingIndex {
+      log.appender { appender =>
+
+        var syncNeeded = false
+        index.write(new WriteOptions, max_index_write_latency) { batch =>
+
+          var write_message_total = 0L
+          var write_enqueue_total = 0L
+
+          uows.foreach { uow =>
+
+
+            uow.actions.foreach { case (msg, action) =>
+              val messageRecord = action.messageRecord
+              var log_info:LogInfo = null
+              var pos = -1L
+              var dataLocator:(Long, Int) = null
+
+              if (messageRecord != null && messageRecord.locator==null) {
+                val start = System.nanoTime()
+                val p = appender.append(LOG_DATA, messageRecord.data)
+                pos = p._1
+                log_info = p._2
+                dataLocator = (pos, messageRecord.data.length)
+                messageRecord.locator = dataLocator
+                write_message_total += System.nanoTime() - start
+              }
+
+
+              action.dequeues.foreach { entry =>
+                val keyLocation = entry.id.getEntryLocator.asInstanceOf[(Long, Long)]
+                val key = encodeEntryKey(ENTRY_PREFIX, keyLocation._1, keyLocation._2)
+
+                if( dataLocator==null ) {
+                  dataLocator = entry.id.getDataLocator match {
+                    case x:(Long, Int) => x
+                    case x:MessageRecord => x.locator
+                    case _ => throw new RuntimeException("Unexpected locator type")
+                  }
+                }
+
+                val log_record = new EntryRecord.Bean()
+                log_record.setCollectionKey(entry.queueKey)
+                log_record.setEntryKey(new Buffer(key, 9, 8))
+                log_record.setValueLocation(dataLocator._1)
+                appender.append(LOG_REMOVE_ENTRY, encodeEntryRecord(log_record.freeze()))
+
+                batch.delete(key)
+                logRefDecrement(dataLocator._1)
+                collectionDecrementSize(entry.queueKey)
+              }
+
+              action.enqueues.foreach { entry =>
+                
+                if(dataLocator ==null ) {
+                  dataLocator = entry.id.getDataLocator match {
+                    case x:(Long, Int) => x
+                    case x:MessageRecord => x.locator
+                    case _ =>
+                      throw new RuntimeException("Unexpected locator type")
+                  }
+                }
+
+                val start = System.nanoTime()
+
+                val key = encodeEntryKey(ENTRY_PREFIX, entry.queueKey, entry.queueSeq)
+
+                assert(entry.id.getDataLocator()!=null)
+
+                val log_record = new EntryRecord.Bean()
+                log_record.setCollectionKey(entry.queueKey)
+                log_record.setEntryKey(new Buffer(key, 9, 8))
+                log_record.setValueLocation(dataLocator._1)
+                log_record.setValueLength(dataLocator._2)
+                appender.append(LOG_ADD_ENTRY, encodeEntryRecord(log_record.freeze()))
+
+                val index_record = new EntryRecord.Bean()
+                index_record.setValueLocation(dataLocator._1)
+                index_record.setValueLength(dataLocator._2)
+                batch.put(key,  encodeEntryRecord(index_record.freeze()).toByteArray)
+
+                val log_data = encodeEntryRecord(log_record.freeze())
+                val index_data = encodeEntryRecord(index_record.freeze()).toByteArray
+
+                appender.append(LOG_ADD_ENTRY, log_data)
+                batch.put(key, index_data)
+
+                Option(log_info).orElse(log.log_info(dataLocator._1)).foreach { logInfo =>
+                  logRefs.getOrElseUpdate(logInfo.position, new LongCounter()).incrementAndGet()
+                }
+
+                collectionIncrementSize(entry.queueKey, log_record.getEntryKey.toByteArray)
+                write_enqueue_total += System.nanoTime() - start
+              }
+
+            }
+            uow.subAcks.foreach { entry =>
+              val key = encodeEntryKey(ENTRY_PREFIX, entry.subKey, ACK_POSITION)
+              val log_record = new EntryRecord.Bean()
+              log_record.setCollectionKey(entry.subKey)
+              log_record.setEntryKey(ACK_POSITION)
+              log_record.setValueLocation(entry.ackPosition)
+              appender.append(LOG_ADD_ENTRY, encodeEntryRecord(log_record.freeze()))
+
+              val index_record = new EntryRecord.Bean()
+              index_record.setValueLocation(entry.ackPosition)
+              batch.put(key, encodeEntryRecord(log_record.freeze()).toByteArray)
+            }
+
+            if( !syncNeeded && uow.syncNeeded ) {
+              syncNeeded = true
+            }
+          }
+
+          max_write_message_latency.add(write_message_total)
+          max_write_enqueue_latency.add(write_enqueue_total)
+        }
+        if( syncNeeded && sync ) {
+          appender.force
+        }
+      } // end of log.appender { block }
+
+      // now that data is logged.. locate message from the data in the logs
+      uows.foreach { uow =>
+        uow.actions.foreach { case (msg, action) =>
+          val messageRecord = action.messageRecord
+          if (messageRecord != null) {
+            messageRecord.id.setDataLocator(messageRecord.locator)
+          }
+        }
+      }
+    }
+  }
+
+  def getCollectionEntries(collectionKey: Long, firstSeq:Long, lastSeq:Long): Seq[(Buffer, EntryRecord.Buffer)] = {
+    var rc = ListBuffer[(Buffer, EntryRecord.Buffer)]()
+    val ro = new ReadOptions
+    ro.verifyChecksums(verifyChecksums)
+    ro.fillCache(true)
+    retryUsingIndex {
+      index.snapshot { snapshot =>
+        ro.snapshot(snapshot)
+        val start = encodeEntryKey(ENTRY_PREFIX, collectionKey, firstSeq)
+        val end = encodeEntryKey(ENTRY_PREFIX, collectionKey, lastSeq+1)
+        index.cursorRange( start, end, ro ) { (key, value) =>
+          val (_, _, seq) = decodeEntryKey(key)
+          rc.append((seq, EntryRecord.FACTORY.parseUnframed(value)))
+          true
+        }
+      }
+    }
+    rc
+  }
+
+  def getLastQueueEntrySeq(collectionKey: Long): Long = {
+    getLastCollectionEntryKey(collectionKey).map(_.bigEndianEditor().readLong()).getOrElse(0L)
+  }
+
+  def getLastCollectionEntryKey(collectionKey: Long): Option[Buffer] = {
+    collectionMeta.get(collectionKey).flatMap(x=> Option(x.last_key)).map(new Buffer(_))
+  }
+
+  def gc(topicPositions:Seq[(Long, Long)]):Unit = {
+
+    // Delete message refs for topics who's consumers have advanced..
+    if( !topicPositions.isEmpty ) {
+      retryUsingIndex {
+        index.write(new WriteOptions, max_index_write_latency) { batch =>
+          for( (topic, first) <- topicPositions ) {
+            val ro = new ReadOptions
+            ro.fillCache(true)
+            ro.verifyChecksums(verifyChecksums)
+            val start = encodeEntryKey(ENTRY_PREFIX, topic, 0)
+            val end =  encodeEntryKey(ENTRY_PREFIX, topic, first)
+            index.cursorRange(start, end, ro) { case (key, value) =>
+              val entry = EntryRecord.FACTORY.parseUnframed(value)
+              batch.delete(key)
+              logRefDecrement(entry.getValueLocation)
+              true
+            }
+          }
+        }
+      }
+    }
+
+    import collection.JavaConversions._
+    lastIndexSnapshotPos
+    val emptyJournals = log.log_infos.keySet.toSet -- logRefs.keySet
+
+    // We don't want to delete any journals that the index has not snapshot'ed or
+    // the the
+    val deleteLimit = log.log_info(lastIndexSnapshotPos).map(_.position).
+          getOrElse(lastIndexSnapshotPos).min(log.appender_start)
+
+    emptyJournals.foreach { id =>
+      if ( id < deleteLimit ) {
+        log.delete(id)
+      }
+    }
+  }
+
+}
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStore.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStore.scala
new file mode 100644
index 000000000..50473f445
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStore.scala
@@ -0,0 +1,622 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb
+
+import org.apache.activemq.broker.BrokerService
+import org.apache.activemq.broker.BrokerServiceAware
+import org.apache.activemq.broker.ConnectionContext
+import org.apache.activemq.command._
+import org.apache.activemq.openwire.OpenWireFormat
+import org.apache.activemq.usage.SystemUsage
+import java.io.File
+import java.io.IOException
+import java.util.concurrent.ExecutionException
+import java.util.concurrent.Future
+import java.util.concurrent.atomic.AtomicLong
+import reflect.BeanProperty
+import org.apache.activemq.store._
+import java.util._
+import scala.collection.mutable.ListBuffer
+import javax.management.ObjectName
+import org.apache.activemq.broker.jmx.AnnotatedMBean
+import org.apache.activemq.util._
+import org.apache.kahadb.util.LockFile
+import org.apache.activemq.leveldb.util.{RetrySupport, FileSupport, Log}
+
+object LevelDBStore extends Log {
+  
+  val DONE = new CountDownFuture();
+  DONE.countDown
+  
+  def toIOException(e: Throwable): IOException = {
+    if (e.isInstanceOf[ExecutionException]) {
+      var cause: Throwable = (e.asInstanceOf[ExecutionException]).getCause
+      if (cause.isInstanceOf[IOException]) {
+        return cause.asInstanceOf[IOException]
+      }
+    }
+    if (e.isInstanceOf[IOException]) {
+      return e.asInstanceOf[IOException]
+    }
+    return IOExceptionSupport.create(e)
+  }
+
+  def waitOn(future: Future[AnyRef]): Unit = {
+    try {
+      future.get
+    }
+    catch {
+      case e: Throwable => {
+        throw toIOException(e)
+      }
+    }
+  }
+}
+
+case class DurableSubscription(subKey:Long, topicKey:Long, info: SubscriptionInfo) {
+  var lastAckPosition = 0L
+  var cursorPosition = 0L
+}
+
+class LevelDBStoreView(val store:LevelDBStore) extends LevelDBStoreViewMBean {
+  import store._
+
+  def getAsyncBufferSize = asyncBufferSize
+  def getIndexDirectory = directory.getCanonicalPath
+  def getLogDirectory = Option(logDirectory).getOrElse(directory).getCanonicalPath
+  def getIndexBlockRestartInterval = indexBlockRestartInterval
+  def getIndexBlockSize = indexBlockSize
+  def getIndexCacheSize = indexCacheSize
+  def getIndexCompression = indexCompression
+  def getIndexFactory = db.client.factory.getClass.getName
+  def getIndexMaxOpenFiles = indexMaxOpenFiles
+  def getIndexWriteBufferSize = indexWriteBufferSize
+  def getLogSize = logSize
+  def getParanoidChecks = paranoidChecks
+  def getSync = sync
+  def getVerifyChecksums = verifyChecksums
+
+  def getUowClosedCounter = db.uowClosedCounter
+  def getUowCanceledCounter = db.uowCanceledCounter
+  def getUowStoringCounter = db.uowStoringCounter
+  def getUowStoredCounter = db.uowStoredCounter
+
+  def getUowMaxCompleteLatency = db.uow_complete_latency.get
+  def getMaxIndexWriteLatency = db.client.max_index_write_latency.get
+  def getMaxLogWriteLatency = db.client.log.max_log_write_latency.get
+  def getMaxLogFlushLatency = db.client.log.max_log_flush_latency.get
+  def getMaxLogRotateLatency = db.client.log.max_log_rotate_latency.get
+
+  def resetUowMaxCompleteLatency = db.uow_complete_latency.reset
+  def resetMaxIndexWriteLatency = db.client.max_index_write_latency.reset
+  def resetMaxLogWriteLatency = db.client.log.max_log_write_latency.reset
+  def resetMaxLogFlushLatency = db.client.log.max_log_flush_latency.reset
+  def resetMaxLogRotateLatency = db.client.log.max_log_rotate_latency.reset
+
+  def getIndexStats = db.client.index.getProperty("leveldb.stats")
+}
+
+import LevelDBStore._
+
+class LevelDBStore extends ServiceSupport with BrokerServiceAware with PersistenceAdapter with TransactionStore {
+
+  final val wireFormat = new OpenWireFormat
+  final val db = new DBManager(this)
+
+  @BeanProperty
+  var directory: File = null
+  @BeanProperty
+  var logDirectory: File = null
+  
+  @BeanProperty
+  var logSize: Long = 1024 * 1024 * 100
+  @BeanProperty
+  var indexFactory: String = "org.fusesource.leveldbjni.JniDBFactory, org.iq80.leveldb.impl.Iq80DBFactory"
+  @BeanProperty
+  var sync: Boolean = true
+  @BeanProperty
+  var verifyChecksums: Boolean = false
+  @BeanProperty
+  var indexMaxOpenFiles: Int = 1000
+  @BeanProperty
+  var indexBlockRestartInterval: Int = 16
+  @BeanProperty
+  var paranoidChecks: Boolean = false
+  @BeanProperty
+  var indexWriteBufferSize: Int = 1024*1024*6
+  @BeanProperty
+  var indexBlockSize: Int = 4 * 1024
+  @BeanProperty
+  var indexCompression: String = "snappy"
+  @BeanProperty
+  var logCompression: String = "none"
+  @BeanProperty
+  var indexCacheSize: Long = 1024 * 1024 * 256L
+  @BeanProperty
+  var flushDelay = 1000*5
+  @BeanProperty
+  var asyncBufferSize = 1024*1024*4
+  @BeanProperty
+  var monitorStats = false
+  @BeanProperty
+  var failIfLocked = false
+
+  var purgeOnStatup: Boolean = false
+  var brokerService: BrokerService = null
+
+  val queues = collection.mutable.HashMap[ActiveMQQueue, LevelDBStore#LevelDBMessageStore]()
+  val topics = collection.mutable.HashMap[ActiveMQTopic, LevelDBStore#LevelDBTopicMessageStore]()
+  val topicsById = collection.mutable.HashMap[Long, LevelDBStore#LevelDBTopicMessageStore]()
+
+  override def toString: String = {
+    return "LevelDB:[" + directory.getAbsolutePath + "]"
+  }
+
+  def objectName = {
+    var brokerON = brokerService.getBrokerObjectName
+    val broker_name = brokerON.getKeyPropertyList().get("BrokerName")
+    new ObjectName(brokerON.getDomain() + ":" +
+            "BrokerName="+JMXSupport.encodeObjectNamePart(broker_name)+ "," +
+            "Type=LevelDBStore");
+  }
+
+  def retry[T](func : =>T):T = RetrySupport.retry(LevelDBStore, isStarted, func _)
+
+  var lock_file: LockFile = _
+
+  var snappyCompressLogs = false
+
+  def doStart: Unit = {
+    import FileSupport._
+
+    snappyCompressLogs = logCompression.toLowerCase == "snappy" && Snappy != null
+    debug("starting")
+    if ( lock_file==null ) {
+      lock_file = new LockFile(directory / "lock", true)
+    }
+
+    // Expose a JMX bean to expose the status of the store.
+    if(brokerService!=null){
+      try {
+        AnnotatedMBean.registerMBean(brokerService.getManagementContext, new LevelDBStoreView(this), objectName)
+      } catch {
+        case e: Throwable => {
+          warn(e, "LevelDB Store could not be registered in JMX: " + e.getMessage)
+        }
+      }
+    }
+
+    if (failIfLocked) {
+      lock_file.lock()
+    } else {
+      retry {
+        lock_file.lock()
+      }
+    }
+
+    if (purgeOnStatup) {
+      purgeOnStatup = false
+      db.client.locked_purge
+      info("Purged: "+this)
+    }
+
+    db.start
+    db.loadCollections
+    debug("started")
+  }
+
+  def doStop(stopper: ServiceStopper): Unit = {
+    db.stop
+    lock_file.unlock()
+    if(brokerService!=null){
+      brokerService.getManagementContext().unregisterMBean(objectName);
+    }
+    info("Stopped "+this)
+  }
+
+  def setBrokerService(brokerService: BrokerService): Unit = {
+    this.brokerService = brokerService
+  }
+
+  def setBrokerName(brokerName: String): Unit = {
+  }
+
+  def setUsageManager(usageManager: SystemUsage): Unit = {
+  }
+
+  def deleteAllMessages: Unit = {
+    purgeOnStatup = true
+  }
+
+  def getLastMessageBrokerSequenceId: Long = {
+    return 0
+  }
+
+  def createTransactionStore = this
+
+  val transactions = collection.mutable.HashMap[TransactionId, Transaction]()
+  
+  trait TransactionAction {
+    def apply(uow:DelayableUOW):Unit
+  }
+  
+  case class Transaction(id:TransactionId) {
+    val commitActions = ListBuffer[TransactionAction]() 
+    def add(store:LevelDBMessageStore, message: Message, delay:Boolean) = {
+      commitActions += new TransactionAction() {
+        def apply(uow:DelayableUOW) = {
+          store.doAdd(uow, message, delay)
+        }
+      }
+    }
+    def remove(store:LevelDBMessageStore, msgid:MessageId) = {
+      commitActions += new TransactionAction() {
+        def apply(uow:DelayableUOW) = {
+          store.doRemove(uow, msgid)
+        }
+      }
+    }
+    def updateAckPosition(store:LevelDBTopicMessageStore, sub: DurableSubscription, position: Long) = {
+      commitActions += new TransactionAction() {
+        def apply(uow:DelayableUOW) = {
+          store.doUpdateAckPosition(uow, sub, position)
+        }
+      }
+    }
+  }
+  
+  def transaction(txid: TransactionId) = transactions.getOrElseUpdate(txid, Transaction(txid))
+  
+  def commit(txid: TransactionId, wasPrepared: Boolean, preCommit: Runnable, postCommit: Runnable) = {
+    preCommit.run()
+    transactions.remove(txid) match {
+      case None=>
+        println("The transaction does not exist")
+        postCommit.run()
+      case Some(tx)=>
+        withUow { uow =>
+          for( action <- tx.commitActions ) {
+            action(uow)
+          }
+          uow.addCompleteListener( postCommit.run() )
+        }
+    }
+  }
+
+  def rollback(txid: TransactionId) = {
+    transactions.remove(txid) match {
+      case None=>
+        println("The transaction does not exist")
+      case Some(tx)=>
+    }
+  }
+
+  def prepare(tx: TransactionId) = {
+    sys.error("XA transactions not yet supported.")
+  }
+  def recover(listener: TransactionRecoveryListener) = {
+  }
+
+  def createQueueMessageStore(destination: ActiveMQQueue) = {
+    this.synchronized(queues.get(destination)).getOrElse(db.createQueueStore(destination))
+  }
+
+  def createQueueMessageStore(destination: ActiveMQQueue, key: Long):LevelDBMessageStore = {
+    var rc = new LevelDBMessageStore(destination, key)
+    this.synchronized {
+      queues.put(destination, rc)
+    }
+    rc
+  }
+
+  def removeQueueMessageStore(destination: ActiveMQQueue): Unit = this synchronized {
+    queues.remove(destination).foreach { store=>
+      db.destroyQueueStore(store.key)
+    }
+  }
+
+  def createTopicMessageStore(destination: ActiveMQTopic): TopicMessageStore = {
+    this.synchronized(topics.get(destination)).getOrElse(db.createTopicStore(destination))
+  }
+
+  def createTopicMessageStore(destination: ActiveMQTopic, key: Long):LevelDBTopicMessageStore = {
+    var rc = new LevelDBTopicMessageStore(destination, key)
+    this synchronized {
+      topics.put(destination, rc)
+      topicsById.put(key, rc)
+    }
+    rc
+  }
+
+  def removeTopicMessageStore(destination: ActiveMQTopic): Unit = {
+    topics.remove(destination).foreach { store=>
+      store.subscriptions.values.foreach { sub =>
+        db.removeSubscription(sub)
+      }
+      store.subscriptions.clear()
+      db.destroyQueueStore(store.key)
+    }
+  }
+
+  def getLogAppendPosition = db.getLogAppendPosition
+
+  def getDestinations: Set[ActiveMQDestination] = {
+    import collection.JavaConversions._
+    var rc: HashSet[ActiveMQDestination] = new HashSet[ActiveMQDestination]
+    rc.addAll(topics.keys)
+    rc.addAll(queues.keys)
+    return rc
+  }
+
+  def getLastProducerSequenceId(id: ProducerId): Long = {
+    return -1
+  }
+
+  def size: Long = {
+    return 0
+  }
+
+  def checkpoint(sync: Boolean): Unit = db.checkpoint(sync)
+
+  def withUow[T](func:(DelayableUOW)=>T):T = {
+    val uow = db.createUow
+    try {
+      func(uow)
+    } finally {
+      uow.release()
+    }
+  }
+
+  private def subscriptionKey(clientId: String, subscriptionName: String): String = {
+    return clientId + ":" + subscriptionName
+  }
+
+  case class LevelDBMessageStore(dest: ActiveMQDestination, val key: Long) extends AbstractMessageStore(dest) {
+
+    protected val lastSeq: AtomicLong = new AtomicLong(0)
+    protected var cursorPosition: Long = 0
+
+    lastSeq.set(db.getLastQueueEntrySeq(key))
+
+    def doAdd(uow: DelayableUOW, message: Message, delay:Boolean): CountDownFuture = {
+      uow.enqueue(key, lastSeq.incrementAndGet, message, delay)
+    }
+
+
+    override def asyncAddQueueMessage(context: ConnectionContext, message: Message) = asyncAddQueueMessage(context, message, false)
+    override def asyncAddQueueMessage(context: ConnectionContext, message: Message, delay: Boolean): Future[AnyRef] = {
+      if(  message.getTransactionId!=null ) {
+        transaction(message.getTransactionId).add(this, message, delay)
+        DONE
+      } else {
+        withUow { uow=>
+          doAdd(uow, message, delay)
+        }
+      }
+    }
+
+    override def addMessage(context: ConnectionContext, message: Message) = addMessage(context, message, false)
+    override def addMessage(context: ConnectionContext, message: Message, delay: Boolean): Unit = {
+      waitOn(asyncAddQueueMessage(context, message, delay))
+    }
+
+    def doRemove(uow: DelayableUOW, id: MessageId): CountDownFuture = {
+      uow.dequeue(key, id)
+    }
+
+    override def removeAsyncMessage(context: ConnectionContext, ack: MessageAck): Unit = {
+      if(  ack.getTransactionId!=null ) {
+        transaction(ack.getTransactionId).remove(this, ack.getLastMessageId)
+        DONE
+      } else {
+        waitOn(withUow{uow=>
+          doRemove(uow, ack.getLastMessageId)
+        })
+      }
+    }
+
+    def removeMessage(context: ConnectionContext, ack: MessageAck): Unit = {
+      removeAsyncMessage(context, ack)
+    }
+
+    def getMessage(id: MessageId): Message = {
+      var message: Message = db.getMessage(id)
+      if (message == null) {
+        throw new IOException("Message id not found: " + id)
+      }
+      return message
+    }
+
+    def removeAllMessages(context: ConnectionContext): Unit = {
+      db.collectionEmpty(key)
+      cursorPosition = 0
+    }
+
+    def getMessageCount: Int = {
+      return db.collectionSize(key).toInt
+    }
+
+    override def isEmpty: Boolean = {
+      return db.collectionIsEmpty(key)
+    }
+
+    def recover(listener: MessageRecoveryListener): Unit = {
+      cursorPosition = db.cursorMessages(key, listener, 0)
+    }
+
+    def resetBatching: Unit = {
+      cursorPosition = 0
+    }
+
+    def recoverNextMessages(maxReturned: Int, listener: MessageRecoveryListener): Unit = {
+      cursorPosition = db.cursorMessages(key, LimitingRecoveryListener(maxReturned, listener), cursorPosition)
+    }
+
+    override def setBatch(id: MessageId): Unit = {
+      cursorPosition = db.queuePosition(id)
+    }
+
+  }
+
+  case class LimitingRecoveryListener(max: Int, listener: MessageRecoveryListener) extends MessageRecoveryListener {
+    private var recovered: Int = 0
+    def hasSpace = recovered < max && listener.hasSpace
+    def recoverMessage(message: Message) = {
+      recovered += 1;
+      listener.recoverMessage(message)
+    }
+    def recoverMessageReference(ref: MessageId) = {
+      recovered += 1;
+      listener.recoverMessageReference(ref)
+    }
+    def isDuplicate(ref: MessageId) = listener.isDuplicate(ref)
+  }
+  
+
+  //
+  // This gts called when the store is first loading up, it restores
+  // the existing durable subs..
+  def createSubscription(sub:DurableSubscription) = {
+    this.synchronized(topicsById.get(sub.topicKey)) match {
+      case Some(topic) =>
+        topic.synchronized {
+          topic.subscriptions.put((sub.info.getClientId, sub.info.getSubcriptionName), sub)
+        }
+      case None =>
+        // Topic does not exist.. so kill the durable sub..
+        db.removeSubscription(sub)
+    }
+  }
+  
+  
+  def getTopicGCPositions = {
+    import collection.JavaConversions._
+    val topics = this.synchronized {
+      new ArrayList(topicsById.values())
+    }
+    topics.flatMap(_.gcPosition).toSeq
+  }
+
+  class LevelDBTopicMessageStore(dest: ActiveMQDestination, key: Long) extends LevelDBMessageStore(dest, key) with TopicMessageStore {
+    val subscriptions = collection.mutable.HashMap[(String, String), DurableSubscription]()
+    var firstSeq = 0L
+
+    def gcPosition:Option[(Long, Long)] = {
+      var pos = lastSeq.get()
+      subscriptions.synchronized {
+        subscriptions.values.foreach { sub =>
+          if( sub.lastAckPosition < pos ) {
+            pos = sub.lastAckPosition
+          }
+        }
+        if( firstSeq != pos+1) {
+          firstSeq = pos+1
+          Some(key, firstSeq)
+        } else {
+          None
+        }
+      }
+    }
+    
+    def addSubsciption(info: SubscriptionInfo, retroactive: Boolean) = {
+      var sub = db.addSubscription(key, info)
+      subscriptions.synchronized {
+        subscriptions.put((info.getClientId, info.getSubcriptionName), sub)
+      }
+      sub.lastAckPosition = if (retroactive) 0 else lastSeq.get()
+      waitOn(withUow{ uow=>
+        uow.updateAckPosition(sub)
+        uow.countDownFuture
+      })
+    }
+    
+    def getAllSubscriptions: Array[SubscriptionInfo] = subscriptions.synchronized {
+      subscriptions.values.map(_.info).toArray
+    }
+
+    def lookupSubscription(clientId: String, subscriptionName: String): SubscriptionInfo = subscriptions.synchronized {
+      subscriptions.get((clientId, subscriptionName)).map(_.info).getOrElse(null)
+    }
+
+    def deleteSubscription(clientId: String, subscriptionName: String): Unit = {
+      subscriptions.synchronized {
+        subscriptions.remove((clientId, subscriptionName))
+      }.foreach(db.removeSubscription(_))
+    }
+
+    private def lookup(clientId: String, subscriptionName: String): Option[DurableSubscription] = subscriptions.synchronized {
+      subscriptions.get((clientId, subscriptionName))
+    }
+
+    def doUpdateAckPosition(uow: DelayableUOW, sub: DurableSubscription, position: Long) = {
+      sub.lastAckPosition = position
+      uow.updateAckPosition(sub)
+    }
+
+    def acknowledge(context: ConnectionContext, clientId: String, subscriptionName: String, messageId: MessageId, ack: MessageAck): Unit = {
+      lookup(clientId, subscriptionName).foreach { sub =>
+        var position = db.queuePosition(messageId)
+        if(  ack.getTransactionId!=null ) {
+          transaction(ack.getTransactionId).updateAckPosition(this, sub, position)
+          DONE
+        } else {
+          waitOn(withUow{ uow=>
+            doUpdateAckPosition(uow, sub, position)
+            uow.countDownFuture
+          })
+        }
+
+      }
+    }
+    
+    def resetBatching(clientId: String, subscriptionName: String): Unit = {
+      lookup(clientId, subscriptionName).foreach { sub =>
+        sub.cursorPosition = 0
+      }
+    }
+    def recoverSubscription(clientId: String, subscriptionName: String, listener: MessageRecoveryListener): Unit = {
+      lookup(clientId, subscriptionName).foreach { sub =>
+        sub.cursorPosition = db.cursorMessages(key, listener, sub.cursorPosition.max(sub.lastAckPosition+1))
+      }
+    }
+    
+    def recoverNextMessages(clientId: String, subscriptionName: String, maxReturned: Int, listener: MessageRecoveryListener): Unit = {
+      lookup(clientId, subscriptionName).foreach { sub =>
+        sub.cursorPosition = db.cursorMessages(key,  LimitingRecoveryListener(maxReturned, listener), sub.cursorPosition.max(sub.lastAckPosition+1))
+      }
+    }
+    
+    def getMessageCount(clientId: String, subscriptionName: String): Int = {
+      lookup(clientId, subscriptionName) match {
+        case Some(sub) => (lastSeq.get - sub.lastAckPosition).toInt
+        case None => 0
+      }
+    }
+
+  }
+
+  ///////////////////////////////////////////////////////////////////////////
+  // The following methods actually have nothing to do with JMS txs... It's more like
+  // operation batch.. we handle that in the DBManager tho.. 
+  ///////////////////////////////////////////////////////////////////////////
+  def beginTransaction(context: ConnectionContext): Unit = {}
+  def commitTransaction(context: ConnectionContext): Unit = {}
+  def rollbackTransaction(context: ConnectionContext): Unit = {}
+
+  def createClient = new LevelDBClient(this);
+}
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStoreViewMBean.java b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStoreViewMBean.java
new file mode 100644
index 000000000..ad90a1924
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/LevelDBStoreViewMBean.java
@@ -0,0 +1,107 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb;
+
+import org.apache.activemq.broker.jmx.MBeanInfo;
+
+import java.io.File;
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+public interface LevelDBStoreViewMBean {
+
+    @MBeanInfo("The directory holding the store index data.")
+    String getIndexDirectory();
+
+    @MBeanInfo("The directory holding the store log data.")
+    String getLogDirectory();
+
+    @MBeanInfo("The size the log files are allowed to grow to.")
+    long getLogSize();
+
+    @MBeanInfo("The implementation of the LevelDB index being used.")
+    String getIndexFactory();
+
+    @MBeanInfo("Are writes synced to disk.")
+    boolean getSync();
+
+    @MBeanInfo("Is data verified against checksums as it's loaded back from disk.")
+    boolean getVerifyChecksums();
+
+    @MBeanInfo("The maximum number of open files the index will open at one time.")
+    int getIndexMaxOpenFiles();
+
+    @MBeanInfo("Number of keys between restart points for delta encoding of keys in the index")
+    int getIndexBlockRestartInterval();
+
+    @MBeanInfo("Do aggressive checking of store data")
+    boolean getParanoidChecks();
+
+    @MBeanInfo("Amount of data to build up in memory for the index before converting to a sorted on-disk file.")
+    int getIndexWriteBufferSize();
+
+    @MBeanInfo("Approximate size of user data packed per block for the index")
+    int getIndexBlockSize();
+
+    @MBeanInfo("The type of compression to use for the index")
+    String getIndexCompression();
+
+    @MBeanInfo("The size of the cache index")
+    long getIndexCacheSize();
+
+    @MBeanInfo("The maximum amount of async writes to buffer up")
+    int getAsyncBufferSize();
+
+    @MBeanInfo("The number of units of work which have been closed.")
+    long getUowClosedCounter();
+    @MBeanInfo("The number of units of work which have been canceled.")
+    long getUowCanceledCounter();
+    @MBeanInfo("The number of units of work which started getting stored.")
+    long getUowStoringCounter();
+    @MBeanInfo("The number of units of work which completed getting stored")
+    long getUowStoredCounter();
+
+    @MBeanInfo("Gets and resets the maximum time (in ms) a unit of work took to complete.")
+    double resetUowMaxCompleteLatency();
+    @MBeanInfo("Gets and resets the maximum time (in ms) an index write batch took to execute.")
+    double resetMaxIndexWriteLatency();
+    @MBeanInfo("Gets and resets the maximum time (in ms) a log write took to execute (includes the index write latency).")
+    double resetMaxLogWriteLatency();
+    @MBeanInfo("Gets and resets the maximum time (in ms) a log flush took to execute.")
+    double resetMaxLogFlushLatency();
+    @MBeanInfo("Gets and resets the maximum time (in ms) a log rotation took to perform.")
+    double resetMaxLogRotateLatency();
+
+    @MBeanInfo("Gets the maximum time (in ms) a unit of work took to complete.")
+    double getUowMaxCompleteLatency();
+    @MBeanInfo("Gets the maximum time (in ms) an index write batch took to execute.")
+    double getMaxIndexWriteLatency();
+    @MBeanInfo("Gets the maximum time (in ms) a log write took to execute (includes the index write latency).")
+    double getMaxLogWriteLatency();
+    @MBeanInfo("Gets the maximum time (in ms) a log flush took to execute.")
+    double getMaxLogFlushLatency();
+    @MBeanInfo("Gets the maximum time (in ms) a log rotation took to perform.")
+    double getMaxLogRotateLatency();
+
+    @MBeanInfo("Gets the index statistics.")
+    String getIndexStats();
+}
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/RecordLog.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/RecordLog.scala
new file mode 100644
index 000000000..5d92caf98
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/RecordLog.scala
@@ -0,0 +1,518 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb
+
+import java.{lang=>jl}
+import java.{util=>ju}
+
+import java.util.zip.CRC32
+import java.util.Map.Entry
+import java.util.concurrent.atomic.AtomicLong
+import java.io._
+import org.fusesource.hawtbuf.{DataByteArrayInputStream, DataByteArrayOutputStream, Buffer}
+import org.fusesource.hawtdispatch.BaseRetained
+import org.apache.activemq.leveldb.util.FileSupport._
+import org.apache.activemq.util.LRUCache
+import util.TimeMetric._
+import util.{TimeMetric, Log}
+import java.util.TreeMap
+
+object RecordLog extends Log {
+
+  // The log files contain a sequence of variable length log records:
+  // record := header + data
+  //
+  // header :=
+  //   '*'      : int8       // Start of Record Magic
+  //   kind     : int8       // Help identify content type of the data.
+  //   checksum : uint32     // crc32c of the data[]
+  //   length   : uint32     // the length the the data
+
+  val LOG_HEADER_PREFIX = '*'.toByte
+  val UOW_END_RECORD = -1.toByte
+
+  val LOG_HEADER_SIZE = 10
+
+  val BUFFER_SIZE = 1024*512
+  val BYPASS_BUFFER_SIZE = 1024*16
+
+  case class LogInfo(file:File, position:Long, length:Long) {
+    def limit = position+length
+  }
+
+  def encode_long(a1:Long) = {
+    val out = new DataByteArrayOutputStream(8)
+    out.writeLong(a1)
+    out.toBuffer
+  }
+
+  def decode_long(value:Buffer):Long = {
+    val in = new DataByteArrayInputStream(value)
+    in.readLong()
+  }
+
+}
+
+case class RecordLog(directory: File, logSuffix:String) {
+  import RecordLog._
+
+  directory.mkdirs()
+
+  var logSize = 1024 * 1024 * 100L
+  var current_appender:LogAppender = _
+  var verify_checksums = false
+  var sync = false
+
+  val log_infos = new TreeMap[Long, LogInfo]()
+
+  object log_mutex
+
+  def delete(id:Long) = {
+    log_mutex.synchronized {
+      // We can't delete the current appender.
+      if( current_appender.position != id ) {
+        Option(log_infos.get(id)).foreach { info =>
+          onDelete(info.file)
+          log_infos.remove(id)
+        }
+      }
+    }
+  }
+
+  protected def onDelete(file:File) = {
+    file.delete()
+  }
+
+  def checksum(data: Buffer): Int = {
+    val checksum = new CRC32
+    checksum.update(data.data, data.offset, data.length)
+    (checksum.getValue & 0xFFFFFFFF).toInt
+  }
+
+  class LogAppender(file:File, position:Long) extends LogReader(file, position) {
+
+    val info = new LogInfo(file, position, 0)
+
+    override def open = new RandomAccessFile(file, "rw")
+
+    override def dispose() = {
+      force
+      super.dispose()
+    }
+
+    var append_offset = 0L
+    val flushed_offset = new AtomicLong(0)
+
+    def append_position = {
+      position+append_offset
+    }
+
+    // set the file size ahead of time so that we don't have to sync the file
+    // meta-data on every log sync.
+    channel.position(logSize-1)
+    channel.write(new Buffer(1).toByteBuffer)
+    channel.force(true)
+    if( sync ) {
+      channel.position(0)
+    }
+
+    val write_buffer = new DataByteArrayOutputStream(BUFFER_SIZE+LOG_HEADER_SIZE)
+
+    def force = {
+      flush
+      if(sync) {
+        max_log_flush_latency {
+          // only need to update the file metadata if the file size changes..
+          channel.force(append_offset > logSize)
+        }
+      }
+    }
+
+    /**
+     * returns the offset position of the data record.
+     */
+    def append(id:Byte, data: Buffer) = this.synchronized {
+      val record_position = append_position
+      val data_length = data.length
+      val total_length = LOG_HEADER_SIZE + data_length
+
+      if( write_buffer.position() + total_length > BUFFER_SIZE ) {
+        flush
+      }
+
+      val cs: Int = checksum(data)
+//      trace("Writing at: "+record_position+" len: "+data_length+" with checksum: "+cs)
+
+      if( false && total_length > BYPASS_BUFFER_SIZE ) {
+
+        // Write the header and flush..
+        write_buffer.writeByte(LOG_HEADER_PREFIX)
+        write_buffer.writeByte(id)
+        write_buffer.writeInt(cs)
+        write_buffer.writeInt(data_length)
+
+        append_offset += LOG_HEADER_SIZE
+        flush
+
+        // Directly write the data to the channel since it's large.
+        val buffer = data.toByteBuffer
+        val pos = append_offset+LOG_HEADER_SIZE
+        val remaining = buffer.remaining
+        channel.write(buffer, pos)
+        flushed_offset.addAndGet(remaining)
+        if( buffer.hasRemaining ) {
+          throw new IOException("Short write")
+        }
+        append_offset += data_length
+
+      } else {
+        write_buffer.writeByte(LOG_HEADER_PREFIX)
+        write_buffer.writeByte(id)
+        write_buffer.writeInt(cs)
+        write_buffer.writeInt(data_length)
+        write_buffer.write(data.data, data.offset, data_length)
+        append_offset += total_length
+      }
+      (record_position, info)
+    }
+
+    def flush = max_log_flush_latency { this.synchronized {
+      if( write_buffer.position() > 0 ) {
+        val buffer = write_buffer.toBuffer.toByteBuffer
+        val remaining = buffer.remaining
+        val pos = append_offset-remaining
+        channel.write(buffer, pos)
+        flushed_offset.addAndGet(remaining)
+        if( buffer.hasRemaining ) {
+          throw new IOException("Short write")
+        }
+        write_buffer.reset()
+      } }
+    }
+
+    override def check_read_flush(end_offset:Long) = {
+      if( flushed_offset.get() < end_offset )  {
+        flush
+      }
+    }
+
+  }
+
+  case class LogReader(file:File, position:Long) extends BaseRetained {
+
+    def open = new RandomAccessFile(file, "r")
+
+    val fd = open
+    val channel = fd.getChannel
+
+    override def dispose() {
+      fd.close()
+    }
+
+    def check_read_flush(end_offset:Long) = {}
+
+    def read(record_position:Long, length:Int) = {
+      val offset = record_position-position
+      assert(offset >=0 )
+
+      check_read_flush(offset+LOG_HEADER_SIZE+length)
+
+      if(verify_checksums) {
+
+        val record = new Buffer(LOG_HEADER_SIZE+length)
+
+        def record_is_not_changing = {
+          using(open) { fd =>
+            val channel = fd.getChannel
+            val new_record = new Buffer(LOG_HEADER_SIZE+length)
+            channel.read(new_record.toByteBuffer, offset)
+            var same = record == new_record
+            println(same)
+            same
+          }
+        }
+
+        if( channel.read(record.toByteBuffer, offset) != record.length ) {
+          assert( record_is_not_changing )
+          throw new IOException("short record at position: "+record_position+" in file: "+file+", offset: "+offset)
+        }
+
+        val is = new DataByteArrayInputStream(record)
+        val prefix = is.readByte()
+        if( prefix != LOG_HEADER_PREFIX ) {
+          assert(record_is_not_changing)
+          throw new IOException("invalid record at position: "+record_position+" in file: "+file+", offset: "+offset)
+        }
+
+        val id = is.readByte()
+        val expectedChecksum = is.readInt()
+        val expectedLength = is.readInt()
+        val data = is.readBuffer(length)
+
+        // If your reading the whole record we can verify the data checksum
+        if( expectedLength == length ) {
+          if( expectedChecksum != checksum(data) ) {
+            assert(record_is_not_changing)
+            throw new IOException("checksum does not match at position: "+record_position+" in file: "+file+", offset: "+offset)
+          }
+        }
+
+        data
+      } else {
+        val data = new Buffer(length)
+        if( channel.read(data.toByteBuffer, offset+LOG_HEADER_SIZE) != data.length ) {
+          throw new IOException("short record at position: "+record_position+" in file: "+file+", offset: "+offset)
+        }
+        data
+      }
+    }
+
+    def read(record_position:Long) = {
+      val offset = record_position-position
+      val header = new Buffer(LOG_HEADER_SIZE)
+      channel.read(header.toByteBuffer, offset)
+      val is = header.bigEndianEditor();
+      val prefix = is.readByte()
+      if( prefix != LOG_HEADER_PREFIX ) {
+        // Does not look like a record.
+        throw new IOException("invalid record position")
+      }
+      val id = is.readByte()
+      val expectedChecksum = is.readInt()
+      val length = is.readInt()
+      val data = new Buffer(length)
+
+      if( channel.read(data.toByteBuffer, offset+LOG_HEADER_SIZE) != length ) {
+        throw new IOException("short record")
+      }
+
+      if(verify_checksums) {
+        if( expectedChecksum != checksum(data) ) {
+          throw new IOException("checksum does not match")
+        }
+      }
+      (id, data, record_position+LOG_HEADER_SIZE+length)
+    }
+
+    def check(record_position:Long):Option[(Long, Option[Long])] = {
+      var offset = record_position-position
+      val header = new Buffer(LOG_HEADER_SIZE)
+      channel.read(header.toByteBuffer, offset)
+      val is = header.bigEndianEditor();
+      val prefix = is.readByte()
+      if( prefix != LOG_HEADER_PREFIX ) {
+        return None // Does not look like a record.
+      }
+      val kind = is.readByte()
+      val expectedChecksum = is.readInt()
+      val length = is.readInt()
+
+      val chunk = new Buffer(1024*4)
+      val chunkbb = chunk.toByteBuffer
+      offset += LOG_HEADER_SIZE
+
+      // Read the data in in chunks to avoid
+      // OOME if we are checking an invalid record
+      // with a bad record length
+      val checksumer = new CRC32
+      var remaining = length
+      while( remaining > 0 ) {
+        val chunkSize = remaining.min(1024*4);
+        chunkbb.position(0)
+        chunkbb.limit(chunkSize)
+        channel.read(chunkbb, offset)
+        if( chunkbb.hasRemaining ) {
+          return None
+        }
+        checksumer.update(chunk.data, 0, chunkSize)
+        offset += chunkSize
+        remaining -= chunkSize
+      }
+
+      val checksum = ( checksumer.getValue & 0xFFFFFFFF).toInt
+      if( expectedChecksum !=  checksum ) {
+        return None
+      }
+      val uow_start_pos = if(kind == UOW_END_RECORD && length==8) Some(decode_long(chunk)) else None
+      return Some(record_position+LOG_HEADER_SIZE+length, uow_start_pos)
+    }
+
+    def verifyAndGetEndPosition:Long = {
+      var pos = position;
+      var current_uow_start = pos
+      val limit = position+channel.size()
+      while(pos < limit) {
+        check(pos) match {
+          case Some((next, uow_start_pos)) =>
+            uow_start_pos.foreach { uow_start_pos =>
+              if( uow_start_pos == current_uow_start ) {
+                current_uow_start = next
+              } else {
+                return current_uow_start
+              }
+            }
+            pos = next
+          case None =>
+            return current_uow_start
+        }
+      }
+      return current_uow_start
+    }
+  }
+
+  def create_log_appender(position: Long) = {
+    new LogAppender(next_log(position), position)
+  }
+
+  def create_appender(position: Long): Any = {
+    log_mutex.synchronized {
+      if(current_appender!=null) {
+        log_infos.put (position, new LogInfo(current_appender.file, current_appender.position, current_appender.append_offset))
+      }
+      current_appender = create_log_appender(position)
+      log_infos.put(position, new LogInfo(current_appender.file, position, 0))
+    }
+  }
+
+  val max_log_write_latency = TimeMetric()
+  val max_log_flush_latency = TimeMetric()
+  val max_log_rotate_latency = TimeMetric()
+
+  def open = {
+    log_mutex.synchronized {
+      log_infos.clear()
+      LevelDBClient.find_sequence_files(directory, logSuffix).foreach { case (position,file) =>
+        log_infos.put(position, LogInfo(file, position, file.length()))
+      }
+
+      val appendPos = if( log_infos.isEmpty ) {
+        0L
+      } else {
+        val file = log_infos.lastEntry().getValue
+        val r = LogReader(file.file, file.position)
+        try {
+          val actualLength = r.verifyAndGetEndPosition
+          val updated = file.copy(length = actualLength - file.position)
+          log_infos.put(updated.position, updated)
+          if( updated.file.length != file.length ) {
+            // we need to truncate.
+            using(new RandomAccessFile(file.file, "rw")) ( _.setLength(updated.length))
+          }
+          actualLength
+        } finally {
+          r.release()
+        }
+      }
+
+      create_appender(appendPos)
+    }
+  }
+
+  def close = {
+    log_mutex.synchronized {
+      current_appender.release
+    }
+  }
+
+  def appender_limit = current_appender.append_position
+  def appender_start = current_appender.position
+
+  def next_log(position:Long) = LevelDBClient.create_sequence_file(directory, position, logSuffix)
+
+  def appender[T](func: (LogAppender)=>T):T= {
+    val intial_position = current_appender.append_position
+    try {
+      max_log_write_latency {
+        val rc = func(current_appender)
+        if( current_appender.append_position != intial_position ) {
+          // Record a UOW_END_RECORD so that on recovery we only replay full units of work.
+          current_appender.append(UOW_END_RECORD,encode_long(intial_position))
+        }
+        rc
+      }
+    } finally {
+      current_appender.flush
+      max_log_rotate_latency {
+        log_mutex.synchronized {
+          if ( current_appender.append_offset >= logSize ) {
+            current_appender.release()
+            on_log_rotate()
+            create_appender(current_appender.append_position)
+          }
+        }
+      }
+    }
+  }
+
+  var on_log_rotate: ()=>Unit = ()=>{}
+
+  private val reader_cache = new LRUCache[File, LogReader](100) {
+    protected override def onCacheEviction(entry: Entry[File, LogReader]) = {
+      entry.getValue.release()
+    }
+  }
+
+  def log_info(pos:Long) = log_mutex.synchronized { Option(log_infos.floorEntry(pos)).map(_.getValue) }
+
+  private def get_reader[T](record_position:Long)(func: (LogReader)=>T) = {
+
+    val lookup = log_mutex.synchronized {
+      val info = log_info(record_position)
+      info.map { info=>
+        if(info.position == current_appender.position) {
+          current_appender.retain()
+          (info, current_appender)
+        } else {
+          (info, null)
+        }
+      }
+    }
+
+    lookup.map { case (info, appender) =>
+      val reader = if( appender!=null ) {
+        // read from the current appender.
+        appender
+      } else {
+        // Checkout a reader from the cache...
+        reader_cache.synchronized {
+          var reader = reader_cache.get(info.file)
+          if(reader==null) {
+            reader = LogReader(info.file, info.position)
+            reader_cache.put(info.file, reader)
+          }
+          reader.retain()
+          reader
+        }
+      }
+
+      try {
+        func(reader)
+      } finally {
+        reader.release
+      }
+    }
+  }
+
+  def read(pos:Long) = {
+    get_reader(pos)(_.read(pos))
+  }
+  def read(pos:Long, length:Int) = {
+    get_reader(pos)(_.read(pos, length))
+  }
+
+}
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/FileSupport.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/FileSupport.scala
new file mode 100644
index 000000000..a2b9a9e3b
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/FileSupport.scala
@@ -0,0 +1,296 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb.util
+
+import java.io._
+import org.fusesource.hawtdispatch._
+import org.apache.activemq.leveldb.LevelDBClient
+import org.fusesource.leveldbjni.internal.Util
+import org.apache.activemq.leveldb.util.ProcessSupport._
+
+object FileSupport {
+
+  implicit def toRichFile(file:File):RichFile = new RichFile(file)
+
+  val onWindows = System.getProperty("os.name").toLowerCase().startsWith("windows")
+  private var linkStrategy = 0
+  private val LOG = Log(getClass)
+  
+  def link(source:File, target:File):Unit = {
+    linkStrategy match {
+      case 0 =>
+        // We first try to link via a native system call. Fails if
+        // we cannot load the JNI module.
+        try {
+          Util.link(source, target)
+        } catch {
+          case e:IOException => throw e
+          case e:Throwable =>
+            // Fallback.. to a slower impl..
+            LOG.debug("Native link system call not available")
+            linkStrategy = 5
+            link(source, target)
+        }
+
+      // TODO: consider implementing a case which does the native system call using JNA
+
+      case 5 =>
+        // Next we try to do the link by executing an
+        // operating system shell command
+        try {
+          if( onWindows ) {
+            system("fsutil", "hardlink", "create", target.getCanonicalPath, source.getCanonicalPath) match {
+              case(0, _, _) => // Success
+              case (_, out, err) =>
+                // TODO: we might want to look at the out/err to see why it failed
+                // to avoid falling back to the slower strategy.
+                LOG.debug("fsutil OS command not available either")
+                linkStrategy = 10
+                link(source, target)
+            }
+          } else {
+            system("ln", source.getCanonicalPath, target.getCanonicalPath) match {
+              case(0, _, _) => // Success
+              case (_, out, err) => None
+                // TODO: we might want to look at the out/err to see why it failed
+                // to avoid falling back to the slower strategy.
+                LOG.debug("ln OS command not available either")
+                linkStrategy = 2
+                link(source, target)
+            }
+          }
+        } catch {
+          case e:Throwable =>
+        }
+      case _ =>
+        // this final strategy is slow but sure to work.
+        source.copyTo(target)
+    }
+  }
+
+  def systemDir(name:String) = {
+    val baseValue = System.getProperty(name)
+    if( baseValue==null ) {
+      sys.error("The the %s system property is not set.".format(name))
+    }
+    val file = new File(baseValue)
+    if( !file.isDirectory  ) {
+      sys.error("The the %s system property is not set to valid directory path %s".format(name, baseValue))
+    }
+    file
+  }
+
+  case class RichFile(self:File) {
+
+    def / (path:String) = new File(self, path)
+
+    def linkTo(target:File) = link(self, target)
+
+    def copyTo(target:File) = {
+      using(new FileOutputStream(target)){ os=>
+        using(new FileInputStream(self)){ is=>
+          FileSupport.copy(is, os)
+        }
+      }
+    }
+
+    def listFiles:Array[File] = {
+      Option(self.listFiles()).getOrElse(Array())
+    }
+
+    def recursiveList:List[File] = {
+      if( self.isDirectory ) {
+        self :: self.listFiles.toList.flatten( _.recursiveList )
+      } else {
+        self :: Nil
+      }
+    }
+
+    def recursiveDelete: Unit = {
+      if( self.exists ) {
+        if( self.isDirectory ) {
+          self.listFiles.foreach(_.recursiveDelete)
+        }
+        self.delete
+      }
+    }
+
+    def recursiveCopyTo(target: File) : Unit = {
+      if (self.isDirectory) {
+        target.mkdirs
+        self.listFiles.foreach( file=> file.recursiveCopyTo( target / file.getName) )
+      } else {
+        self.copyTo(target)
+      }
+    }
+
+    def readText(charset:String="UTF-8"): String = {
+      using(new FileInputStream(self)) { in =>
+        FileSupport.readText(in, charset)
+      }
+    }
+
+    def readBytes: Array[Byte] = {
+      using(new FileInputStream(self)) { in =>
+        FileSupport.readBytes(in)
+      }
+    }
+
+    def writeBytes(data:Array[Byte]):Unit = {
+      using(new FileOutputStream(self)) { out =>
+        FileSupport.writeBytes(out, data)
+      }
+    }
+
+    def writeText(data:String, charset:String="UTF-8"):Unit = {
+      using(new FileOutputStream(self)) { out =>
+        FileSupport.writeText(out, data, charset)
+      }
+    }
+
+  }
+
+  /**
+   * Returns the number of bytes copied.
+   */
+  def copy(in: InputStream, out: OutputStream): Long = {
+    var bytesCopied: Long = 0
+    val buffer = new Array[Byte](8192)
+    var bytes = in.read(buffer)
+    while (bytes >= 0) {
+      out.write(buffer, 0, bytes)
+      bytesCopied += bytes
+      bytes = in.read(buffer)
+    }
+    bytesCopied
+  }
+
+  def using[R,C <: Closeable](closable: C)(proc: C=>R) = {
+    try {
+      proc(closable)
+    } finally {
+      try { closable.close  }  catch { case ignore =>  }
+    }
+  }
+
+  def readText(in: InputStream, charset:String="UTF-8"): String = {
+    new String(readBytes(in), charset)
+  }
+
+  def readBytes(in: InputStream): Array[Byte] = {
+    val out = new ByteArrayOutputStream()
+    copy(in, out)
+    out.toByteArray
+  }
+
+  def writeText(out: OutputStream, value: String, charset:String="UTF-8"): Unit = {
+    writeBytes(out, value.getBytes(charset))
+  }
+
+  def writeBytes(out: OutputStream, data: Array[Byte]): Unit = {
+    copy(new ByteArrayInputStream(data), out)
+  }
+
+}
+
+object ProcessSupport {
+  import FileSupport._
+
+  implicit def toRichProcessBuilder(self:ProcessBuilder):RichProcessBuilder = new RichProcessBuilder(self)
+
+  case class RichProcessBuilder(self:ProcessBuilder) {
+
+    def start(out:OutputStream=null, err:OutputStream=null, in:InputStream=null) = {
+      self.redirectErrorStream(out == err)
+      val process = self.start
+      if( in!=null ) {
+        LevelDBClient.THREAD_POOL {
+          try {
+            using(process.getOutputStream) { out =>
+              FileSupport.copy(in, out)
+            }
+          } catch {
+            case _ =>
+          }
+        }
+      } else {
+        process.getOutputStream.close
+      }
+
+      if( out!=null ) {
+        LevelDBClient.THREAD_POOL {
+          try {
+            using(process.getInputStream) { in =>
+              FileSupport.copy(in, out)
+            }
+          } catch {
+            case _ =>
+          }
+        }
+      } else {
+        process.getInputStream.close
+      }
+
+      if( err!=null && err!=out ) {
+        LevelDBClient.THREAD_POOL {
+          try {
+            using(process.getErrorStream) { in =>
+              FileSupport.copy(in, err)
+            }
+          } catch {
+            case _ =>
+          }
+        }
+      } else {
+        process.getErrorStream.close
+      }
+      process
+    }
+
+  }
+
+  implicit def toRichProcess(self:Process):RichProcess = new RichProcess(self)
+
+  case class RichProcess(self:Process) {
+    def onExit(func: (Int)=>Unit) = LevelDBClient.THREAD_POOL {
+      self.waitFor
+      func(self.exitValue)
+    }
+  }
+
+  implicit def toProcessBuilder(args:Seq[String]):ProcessBuilder = new ProcessBuilder().command(args : _*)
+
+  def launch(command:String*)(func: (Int, Array[Byte], Array[Byte])=>Unit ):Unit = launch(command)(func)
+  def launch(p:ProcessBuilder, in:InputStream=null)(func: (Int, Array[Byte], Array[Byte]) => Unit):Unit = {
+    val out = new ByteArrayOutputStream
+    val err = new ByteArrayOutputStream
+    p.start(out, err, in).onExit { code=>
+      func(code, out.toByteArray, err.toByteArray)
+    }
+  }
+
+  def system(command:String*):(Int, Array[Byte], Array[Byte]) = system(command)
+  def system(p:ProcessBuilder, in:InputStream=null):(Int, Array[Byte], Array[Byte]) = {
+    val out = new ByteArrayOutputStream
+    val err = new ByteArrayOutputStream
+    val process = p.start(out, err, in)
+    process.waitFor
+    (process.exitValue, out.toByteArray, err.toByteArray)
+  }
+
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/Log.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/Log.scala
new file mode 100644
index 000000000..7827c6767
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/Log.scala
@@ -0,0 +1,180 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb.util
+
+import java.util.concurrent.atomic.AtomicLong
+import org.slf4j.{MDC, Logger, LoggerFactory}
+import java.lang.{Throwable, String}
+
+/**
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+object Log {
+
+  def apply(clazz:Class[_]):Log = apply(clazz.getName.stripSuffix("$"))
+
+  def apply(name:String):Log = new Log {
+    override val log = LoggerFactory.getLogger(name)
+  }
+
+  def apply(value:Logger):Log = new Log {
+    override val log = value
+  }
+
+  val exception_id_generator = new AtomicLong(System.currentTimeMillis)
+  def next_exception_id = exception_id_generator.incrementAndGet.toHexString
+}
+
+/**
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+trait Log {
+  import Log._
+  val log = LoggerFactory.getLogger(getClass.getName.stripSuffix("$"))
+
+  private def with_throwable(e:Throwable)(func: =>Unit) = {
+    if( e!=null ) {
+      val stack_ref = if( log.isDebugEnabled ) {
+        val id = next_exception_id
+        MDC.put("stackref", id.toString);
+        Some(id)
+      } else {
+        None
+      }
+      func
+      stack_ref.foreach { id=>
+        log.debug(e.toString, e)
+        MDC.remove("stackref")
+      }
+    } else {
+      func
+    }
+  }
+
+  private def format(message:String, args:Seq[Any]) = {
+    if( args.isEmpty ) {
+      message
+    } else {
+      message.format(args.map(_.asInstanceOf[AnyRef]) : _*)
+    }
+  }
+
+  def error(m: => String, args:Any*): Unit = {
+    if( log.isErrorEnabled ) {
+      log.error(format(m, args.toSeq))
+    }
+  }
+
+  def error(e: Throwable, m: => String, args:Any*): Unit = {
+    with_throwable(e) {
+      if( log.isErrorEnabled ) {
+        log.error(format(m, args.toSeq))
+      }
+    }
+  }
+
+  def error(e: Throwable): Unit = {
+    with_throwable(e) {
+      if( log.isErrorEnabled ) {
+        log.error(e.getMessage)
+      }
+    }
+  }
+
+  def warn(m: => String, args:Any*): Unit = {
+    if( log.isWarnEnabled ) {
+      log.warn(format(m, args.toSeq))
+    }
+  }
+
+  def warn(e: Throwable, m: => String, args:Any*): Unit = {
+    with_throwable(e) {
+      if( log.isWarnEnabled ) {
+        log.warn(format(m, args.toSeq))
+      }
+    }
+  }
+
+  def warn(e: Throwable): Unit = {
+    with_throwable(e) {
+      if( log.isWarnEnabled ) {
+        log.warn(e.toString)
+      }
+    }
+  }
+
+  def info(m: => String, args:Any*): Unit = {
+    if( log.isInfoEnabled ) {
+      log.info(format(m, args.toSeq))
+    }
+  }
+
+  def info(e: Throwable, m: => String, args:Any*): Unit = {
+    with_throwable(e) {
+      if( log.isInfoEnabled ) {
+        log.info(format(m, args.toSeq))
+      }
+    }
+  }
+
+  def info(e: Throwable): Unit = {
+    with_throwable(e) {
+      if( log.isInfoEnabled ) {
+        log.info(e.toString)
+      }
+    }
+  }
+
+
+  def debug(m: => String, args:Any*): Unit = {
+    if( log.isDebugEnabled ) {
+      log.debug(format(m, args.toSeq))
+    }
+  }
+
+  def debug(e: Throwable, m: => String, args:Any*): Unit = {
+    if( log.isDebugEnabled ) {
+      log.debug(format(m, args.toSeq), e)
+    }
+  }
+
+  def debug(e: Throwable): Unit = {
+    if( log.isDebugEnabled ) {
+      log.debug(e.toString, e)
+    }
+  }
+
+  def trace(m: => String, args:Any*): Unit = {
+    if( log.isTraceEnabled ) {
+      log.trace(format(m, args.toSeq))
+    }
+  }
+
+  def trace(e: Throwable, m: => String, args:Any*): Unit = {
+    if( log.isTraceEnabled ) {
+      log.trace(format(m, args.toSeq), e)
+    }
+  }
+
+  def trace(e: Throwable): Unit = {
+    if( log.isTraceEnabled ) {
+      log.trace(e.toString, e)
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/LongCounter.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/LongCounter.scala
new file mode 100644
index 000000000..e6a5a6f03
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/LongCounter.scala
@@ -0,0 +1,48 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb.util
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class LongCounter(private var value:Long = 0) extends Serializable {
+
+  def clear() = value=0
+  def get() = value
+  def set(value:Long) = this.value = value 
+
+  def incrementAndGet() = addAndGet(1)
+  def decrementAndGet() = addAndGet(-1)
+  def addAndGet(amount:Long) = {
+    value+=amount
+    value
+  }
+
+  def getAndIncrement() = getAndAdd(1)
+  def getAndDecrement() = getAndAdd(-11)
+  def getAndAdd(amount:Long) = {
+    val rc = value
+    value+=amount
+    rc
+  }
+
+  override def toString() = get().toString
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/RetrySupport.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/RetrySupport.scala
new file mode 100644
index 000000000..5d492def6
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/RetrySupport.scala
@@ -0,0 +1,63 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb.util
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+object RetrySupport {
+
+  def retry[T](log:Log, isStarted: ()=>Boolean, func: ()=>T): T = {
+    import log._
+    var error:Throwable = null
+    var rc:Option[T] = None
+
+    // We will loop until the tx succeeds.  Perhaps it's
+    // failing due to a temporary condition like low disk space.
+    while(!rc.isDefined) {
+
+      try {
+        rc = Some(func())
+      } catch {
+        case e:Throwable =>
+          e.printStackTrace()
+          if( error==null ) {
+            warn(e, "DB operation failed. (entering recovery mode)")
+          }
+          error = e
+      }
+
+      if (!rc.isDefined) {
+        // We may need to give up if the store is being stopped.
+        if ( !isStarted() ) {
+          throw error
+        }
+        Thread.sleep(1000)
+      }
+    }
+
+    if( error!=null ) {
+      info("DB recovered from failure.")
+    }
+    rc.get
+  }
+
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/TimeMetric.scala b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/TimeMetric.scala
new file mode 100644
index 000000000..5d4916299
--- /dev/null
+++ b/activemq-leveldb/src/main/scala/org/apache/activemq/leveldb/util/TimeMetric.scala
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb.util
+
+case class TimeMetric() {
+  var max = 0L
+
+  def add(duration:Long) = this.synchronized {
+    max = max.max(duration)
+  }
+
+  def get = {
+    this.synchronized {
+      max
+    } / 1000000.0
+  }
+  def reset = {
+    this.synchronized {
+      val rc = max
+      max  = 0
+      rc
+    } / 1000000.0
+  }
+
+  def apply[T](func: =>T):T = {
+    val start = System.nanoTime()
+    try {
+      func
+    } finally {
+      add(System.nanoTime() - start)
+    }
+  }
+
+}
+
diff --git a/activemq-core/src/main/java/org/apache/activemq/store/leveldb/package.html b/activemq-leveldb/src/main/scala/org/apache/activemq/store/leveldb/package.html
similarity index 100%
rename from activemq-core/src/main/java/org/apache/activemq/store/leveldb/package.html
rename to activemq-leveldb/src/main/scala/org/apache/activemq/store/leveldb/package.html
diff --git a/activemq-core/src/test/java/org/apache/activemq/store/leveldb/LevelDBConfigTest.java b/activemq-leveldb/src/test/java/org/apache/activemq/store/leveldb/LevelDBConfigTest.java
similarity index 100%
rename from activemq-core/src/test/java/org/apache/activemq/store/leveldb/LevelDBConfigTest.java
rename to activemq-leveldb/src/test/java/org/apache/activemq/store/leveldb/LevelDBConfigTest.java
diff --git a/activemq-core/src/test/java/org/apache/activemq/store/leveldb/LevelDBStoreBrokerTest.java b/activemq-leveldb/src/test/java/org/apache/activemq/store/leveldb/LevelDBStoreBrokerTest.java
similarity index 97%
rename from activemq-core/src/test/java/org/apache/activemq/store/leveldb/LevelDBStoreBrokerTest.java
rename to activemq-leveldb/src/test/java/org/apache/activemq/store/leveldb/LevelDBStoreBrokerTest.java
index be6deb99c..156e9ca78 100644
--- a/activemq-core/src/test/java/org/apache/activemq/store/leveldb/LevelDBStoreBrokerTest.java
+++ b/activemq-leveldb/src/test/java/org/apache/activemq/store/leveldb/LevelDBStoreBrokerTest.java
@@ -23,7 +23,7 @@ import org.apache.activemq.broker.BrokerService;
 import org.apache.activemq.broker.BrokerTest;
 import org.apache.activemq.store.kahadb.KahaDBStore;
 import org.apache.activemq.util.IOHelper;
-import org.fusesource.mq.leveldb.LevelDBStore;
+import org.apache.activemq.leveldb.LevelDBStore;
 
 /**
  * Once the wire format is completed we can test against real persistence storage.
diff --git a/activemq-leveldb/src/test/resources/log4j.properties b/activemq-leveldb/src/test/resources/log4j.properties
new file mode 100755
index 000000000..fd5a31bd2
--- /dev/null
+++ b/activemq-leveldb/src/test/resources/log4j.properties
@@ -0,0 +1,36 @@
+# 
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+# 
+#      http://www.apache.org/licenses/LICENSE-2.0
+# 
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# 
+
+#
+# The logging properties used during tests..
+#
+log4j.rootLogger=WARN, console, file
+log4j.logger.org.apache.activemq=INFO
+log4j.logger.org.fusesource=INFO
+
+# Console will only display warnnings
+log4j.appender.console=org.apache.log4j.ConsoleAppender
+log4j.appender.console.layout=org.apache.log4j.PatternLayout
+log4j.appender.console.layout.ConversionPattern=%-5p | %t | %m%n
+log4j.appender.console.threshold=TRACE
+
+# File appender will contain all info messages
+log4j.appender.file=org.apache.log4j.FileAppender
+log4j.appender.file.layout=org.apache.log4j.PatternLayout
+log4j.appender.file.layout.ConversionPattern=%d | %-5p | %m | %c | %t%n
+log4j.appender.file.file=target/test.log
+log4j.appender.file.append=true
diff --git a/activemq-core/src/test/resources/org/apache/activemq/store/leveldb/leveldb.xml b/activemq-leveldb/src/test/resources/org/apache/activemq/store/leveldb/leveldb.xml
similarity index 100%
rename from activemq-core/src/test/resources/org/apache/activemq/store/leveldb/leveldb.xml
rename to activemq-leveldb/src/test/resources/org/apache/activemq/store/leveldb/leveldb.xml
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/ActiveMQScenario.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/ActiveMQScenario.scala
new file mode 100644
index 000000000..e8472ea29
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/ActiveMQScenario.scala
@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.leveldb
+
+import org.apache.activemq.spring.ActiveMQConnectionFactory
+import javax.jms.{Destination, ConnectionFactory}
+import org.apache.activemq.command.{ActiveMQTopic, ActiveMQQueue}
+
+/**
+ * <p>
+ * ActiveMQ implementation of the JMS Scenario class.
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class ActiveMQScenario extends JMSClientScenario {
+
+  override protected def factory:ConnectionFactory = {
+    val rc = new ActiveMQConnectionFactory
+    rc.setBrokerURL(url)
+    rc
+  }
+
+  override protected def destination(i:Int):Destination = destination_type match {
+    case "queue" => new ActiveMQQueue(indexed_destination_name(i))
+    case "topic" => new ActiveMQTopic(indexed_destination_name(i))
+    case _ => error("Unsuported destination type: "+destination_type)
+  }
+
+}
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/EnqueueRateScenariosTest.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/EnqueueRateScenariosTest.scala
new file mode 100644
index 000000000..a311c6556
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/EnqueueRateScenariosTest.scala
@@ -0,0 +1,174 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.leveldb
+
+import junit.framework.TestCase
+import org.apache.activemq.broker._
+import org.apache.activemq.store._
+import java.io.File
+import junit.framework.Assert._
+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics
+import region.policy.{PolicyEntry, PolicyMap}
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class EnqueueRateScenariosTest extends TestCase {
+
+  var broker: BrokerService = null
+
+  override def setUp() {
+    import collection.JavaConversions._
+    broker = new BrokerService
+    broker.setDeleteAllMessagesOnStartup(true)
+    broker.setPersistenceAdapter(createStore)
+    broker.addConnector("tcp://0.0.0.0:0")
+//    val policies = new PolicyMap();
+//    val entry = new PolicyEntry
+//    entry.setQueue(">")
+//    policies.setPolicyEntries(List(entry))
+//    broker.setDestinationPolicy(policies)
+    broker.start
+    broker.waitUntilStarted()
+  }
+
+  override def tearDown() = {
+    if (broker != null) {
+      broker.stop
+      broker.waitUntilStopped
+    }
+  }
+
+  protected def canceledEnqueues() =
+    broker.getPersistenceAdapter.asInstanceOf[LevelDBStore].db.uowCanceledCounter
+
+  protected def enqueueOptimized() =
+    broker.getPersistenceAdapter.asInstanceOf[LevelDBStore].db.uowEnqueueDelayReqested
+
+  protected def enqueueNotOptimized() =
+    broker.getPersistenceAdapter.asInstanceOf[LevelDBStore].db.uowEnqueueNodelayReqested
+
+
+  protected def createStore: PersistenceAdapter = {
+    var store: LevelDBStore = new LevelDBStore
+    store.setDirectory(new File("target/activemq-data/leveldb"))
+    return store
+  }
+
+  def collect_benchmark(scenario:ActiveMQScenario, warmup:Int, samples_count:Int) = {
+    val (cancels, optimized, unoptimized) = scenario.with_load {
+      println("Warming up for %d seconds...".format(warmup))
+      Thread.sleep(warmup*1000)
+      println("Sampling...")
+      scenario.collection_start
+      val cancelStart = canceledEnqueues
+      val enqueueOptimizedStart = enqueueOptimized
+      val enqueueNotOptimizedStart = enqueueNotOptimized
+      for (i <- 0 until samples_count) {
+        Thread.sleep(1000);
+        scenario.collection_sample
+      }
+      (canceledEnqueues-cancelStart, enqueueOptimized-enqueueOptimizedStart, enqueueNotOptimized-enqueueNotOptimizedStart)
+    }
+    println("Done.")
+
+    var samples = scenario.collection_end
+    val error_rates = samples.get("e_custom").get.map(_._2)
+    assertFalse("Errors occured during scenario run: "+error_rates, error_rates.find(_ > 0 ).isDefined )
+
+    val producer_stats = new DescriptiveStatistics();
+    for( producer_rates <- samples.get("p_custom") ) {
+      for( i <- producer_rates ) {
+        producer_stats.addValue(i._2)
+      }
+    }
+
+    val consumer_stats = new DescriptiveStatistics();
+    for( consumer_rates <- samples.get("c_custom") ) {
+      for( i <- consumer_rates ) {
+        consumer_stats.addValue(i._2)
+      }
+    }
+
+    (producer_stats, consumer_stats, cancels*1.0/samples_count, optimized*1.0/samples_count, unoptimized*1.0/samples_count)
+  }
+
+  def benchmark(name:String, warmup:Int=3, samples_count:Int=15, async_send:Boolean=true)(setup:(ActiveMQScenario)=>Unit) = {
+    println("Benchmarking: "+name)
+    var options: String = "?jms.watchTopicAdvisories=false&jms.useAsyncSend="+async_send
+    val url = broker.getTransportConnectors.get(0).getConnectUri + options
+
+    val scenario = new ActiveMQScenario
+    scenario.url = url
+    scenario.display_errors = true
+    scenario.persistent = true
+    scenario.message_size = 1024 * 3
+
+    setup(scenario)
+    val (producer_stats, consumer_stats, cancels, optimized, unoptimized) = collect_benchmark(scenario, warmup, samples_count)
+
+    println("%s: producer avg msg/sec: %,.2f, stddev: %,.2f".format(name, producer_stats.getMean, producer_stats.getStandardDeviation))
+    println("%s: consumer avg msg/sec: %,.2f, stddev: %,.2f".format(name, consumer_stats.getMean, consumer_stats.getStandardDeviation))
+    println("%s: canceled enqueues/sec: %,.2f".format(name,cancels))
+    println("%s: optimized enqueues/sec: %,.2f".format(name,optimized))
+    println("%s: unoptimized enqueues/sec: %,.2f".format(name,unoptimized))
+
+    (producer_stats, consumer_stats, cancels, optimized, unoptimized)
+  }
+
+  def testHighCancelRatio = {
+    val (producer_stats, consumer_stats, cancels, optimized, unoptimized) = benchmark("both_connected_baseline") { scenario=>
+      scenario.producers = 1
+      scenario.consumers = 1
+    }
+    val cancel_ratio = cancels / producer_stats.getMean
+    assertTrue("Expecting more than 80%% of the enqueues get canceled. But only %.2f%% was canceled".format(cancel_ratio*100), cancel_ratio > .80)
+  }
+
+  def testDecoupledProducerRate = {
+
+    // Fill up the queue with messages.. for the benefit of the next benchmark..
+    val from_1_to_0 = benchmark("from_1_to_0", 60) { scenario=>
+      scenario.producers = 1
+      scenario.consumers = 0
+    }
+    val from_1_to_10 = benchmark("from_1_to_10") { scenario=>
+      scenario.producers = 1
+      scenario.consumers = 10
+    }
+    val from_1_to_1 = benchmark("from_1_to_1") { scenario=>
+      scenario.producers = 1
+      scenario.consumers = 1
+    }
+
+    var percent_diff0 = (1.0 - (from_1_to_0._1.getMean / from_1_to_1._1.getMean)).abs * 100
+    var percent_diff1 = (1.0 - (from_1_to_1._1.getMean / from_1_to_10._1.getMean)).abs * 100
+
+    var msg0 = "The 0 vs 1 consumer scenario producer rate was within %.2f%%".format(percent_diff0)
+    var msg1 = "The 1 vs 10 consumer scenario producer rate was within %.2f%%".format(percent_diff1)
+
+    println(msg0)
+    println(msg1)
+
+    assertTrue(msg0, percent_diff0 <= 60)
+    assertTrue(msg1, percent_diff1 <= 20)
+  }
+
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/HALevelDBFastEnqueueTest.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/HALevelDBFastEnqueueTest.scala
new file mode 100644
index 000000000..e2266610f
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/HALevelDBFastEnqueueTest.scala
@@ -0,0 +1,62 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.leveldb
+
+import org.apache.hadoop.fs.FileUtil
+import java.io.File
+import java.util.concurrent.TimeUnit
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class HALevelDBFastEnqueueTest extends LevelDBFastEnqueueTest {
+
+  override def setUp: Unit = {
+    TestingHDFSServer.start
+    super.setUp
+  }
+
+  override def tearDown: Unit = {
+    super.tearDown
+    TestingHDFSServer.stop
+  }
+
+  override protected def createStore: LevelDBStore = {
+    var store: HALevelDBStore = new HALevelDBStore
+    store.setDirectory(dataDirectory)
+    store.setDfsDirectory("target/activemq-data/hdfs-leveldb")
+    return store
+  }
+
+  private def dataDirectory: File = {
+    return new File("target/activemq-data/leveldb")
+  }
+
+  /**
+   * On restart we will also delete the local file system store, so that we test restoring from
+   * HDFS.
+   */
+  override  protected def restartBroker(restartDelay: Int, checkpoint: Int): Unit = {
+    stopBroker
+    FileUtil.fullyDelete(dataDirectory)
+    TimeUnit.MILLISECONDS.sleep(restartDelay)
+    startBroker(false, checkpoint)
+  }
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/HALevelDBStoreTest.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/HALevelDBStoreTest.scala
new file mode 100644
index 000000000..38206495d
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/HALevelDBStoreTest.scala
@@ -0,0 +1,48 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.leveldb
+
+import org.apache.activemq.store.PersistenceAdapter
+import java.io.File
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class HALevelDBStoreTest extends LevelDBStoreTest {
+  override protected def setUp: Unit = {
+    TestingHDFSServer.start
+    super.setUp
+  }
+
+  override protected def tearDown: Unit = {
+    super.tearDown
+    TestingHDFSServer.stop
+  }
+
+  override protected def createPersistenceAdapter(delete: Boolean): PersistenceAdapter = {
+    var store: HALevelDBStore = new HALevelDBStore
+    store.setDirectory(new File("target/activemq-data/haleveldb"))
+    store.setDfsDirectory("localhost")
+    if (delete) {
+      store.deleteAllMessages
+    }
+    return store
+  }
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/IDERunner.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/IDERunner.scala
new file mode 100644
index 000000000..7eeb11052
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/IDERunner.scala
@@ -0,0 +1,26 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb
+
+import org.apache.activemq.console.Main
+
+object IDERunner {
+  def main(args:Array[String]) ={
+    Main.main(args)
+  }
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/JMSClientScenario.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/JMSClientScenario.scala
new file mode 100644
index 000000000..993d145d9
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/JMSClientScenario.scala
@@ -0,0 +1,204 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.leveldb
+
+import java.lang.Thread
+import javax.jms._
+
+/**
+ * <p>
+ * Simulates load on a JMS sever using the JMS messaging API.
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+abstract class JMSClientScenario extends Scenario {
+
+  def createProducer(i:Int) = {
+    new ProducerClient(i)
+  }
+  def createConsumer(i:Int) = {
+    new ConsumerClient(i)
+  }
+
+  protected def destination(i:Int):Destination
+
+  def indexed_destination_name(i:Int) = destination_type match {
+    case "queue" => queue_prefix+destination_name+"-"+(i%destination_count)
+    case "topic" => topic_prefix+destination_name+"-"+(i%destination_count)
+    case _ => error("Unsuported destination type: "+destination_type)
+  }
+
+
+  protected def factory:ConnectionFactory
+
+  def jms_ack_mode = {
+    ack_mode match {
+      case "auto" => Session.AUTO_ACKNOWLEDGE
+      case "client" => Session.CLIENT_ACKNOWLEDGE
+      case "dups_ok" => Session.DUPS_OK_ACKNOWLEDGE
+      case "transacted" => Session.SESSION_TRANSACTED
+      case _ => throw new Exception("Invalid ack mode: "+ack_mode)
+    }
+  }
+
+  trait JMSClient extends Client {
+
+    @volatile
+    var connection:Connection = _
+    var message_counter=0L
+
+    var worker = new Thread() {
+      override def run() {
+        var reconnect_delay = 0
+        while( !done.get ) {
+          try {
+
+            if( reconnect_delay!=0 ) {
+              Thread.sleep(reconnect_delay)
+              reconnect_delay=0
+            }
+            connection = factory.createConnection(user_name, password)
+//            connection.setClientID(name)
+            connection.setExceptionListener(new ExceptionListener {
+              def onException(exception: JMSException) {
+              }
+            })
+            connection.start()
+
+            execute
+
+          } catch {
+            case e:Throwable =>
+              if( !done.get ) {
+                if( display_errors ) {
+                  e.printStackTrace
+                }
+                error_counter.incrementAndGet
+                reconnect_delay = 1000
+              }
+          } finally {
+            dispose
+          }
+        }
+      }
+    }
+
+    def dispose {
+      try {
+        connection.close()
+      } catch {
+        case _ =>
+      }
+    }
+
+    def execute:Unit
+
+    def start = {
+      worker.start
+    }
+
+    def shutdown = {
+      assert(done.get)
+      if ( worker!=null ) {
+        dispose
+        worker.join(1000)
+        while(worker.isAlive ) {
+          println("Worker did not shutdown quickly.. interrupting thread.")
+          worker.interrupt()
+          worker.join(1000)
+        }
+        worker = null
+      }
+    }
+
+    def name:String
+  }
+
+  class ConsumerClient(val id: Int) extends JMSClient {
+    val name: String = "consumer " + id
+
+    def execute {
+      var session = connection.createSession(false, jms_ack_mode)
+      var consumer:MessageConsumer = if( durable ) {
+        session.createDurableSubscriber(destination(id).asInstanceOf[Topic], name, selector, no_local)
+      } else {
+        session.createConsumer(destination(id), selector, no_local)
+      }
+
+      while( !done.get() ) {
+        val msg = consumer.receive(500)
+        if( msg!=null ) {
+          consumer_counter.incrementAndGet()
+          if (consumer_sleep != 0) {
+            Thread.sleep(consumer_sleep)
+          }
+          if(session.getAcknowledgeMode == Session.CLIENT_ACKNOWLEDGE) {
+            msg.acknowledge();
+          }
+        }
+      }
+    }
+
+  }
+
+  class ProducerClient(val id: Int) extends JMSClient {
+
+    val name: String = "producer " + id
+
+    def execute {
+      val session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE)
+      val producer:MessageProducer = session.createProducer(destination(id))
+      producer.setDeliveryMode(if( persistent ) {
+        DeliveryMode.PERSISTENT
+      } else {
+        DeliveryMode.NON_PERSISTENT
+      })
+
+      val msg = session.createTextMessage(body(name))
+      headers_for(id).foreach { case (key, value) =>
+        msg.setStringProperty(key, value)
+      }
+
+      while( !done.get() ) {
+        producer.send(msg)
+        producer_counter.incrementAndGet()
+        if (producer_sleep != 0) {
+          Thread.sleep(producer_sleep)
+        }
+      }
+
+    }
+  }
+
+  def body(name:String) = {
+    val buffer = new StringBuffer(message_size)
+    buffer.append("Message from " + name+"\n")
+    for( i <- buffer.length to message_size ) {
+      buffer.append(('a'+(i%26)).toChar)
+    }
+    var rc = buffer.toString
+    if( rc.length > message_size ) {
+      rc.substring(0, message_size)
+    } else {
+      rc
+    }
+  }
+
+
+
+}
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBFastEnqueueTest.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBFastEnqueueTest.scala
new file mode 100644
index 000000000..d680dd3bb
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBFastEnqueueTest.scala
@@ -0,0 +1,206 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.leveldb
+
+import org.apache.activemq.ActiveMQConnection
+import org.apache.activemq.ActiveMQConnectionFactory
+import org.apache.activemq.broker.BrokerService
+import org.apache.activemq.command.ActiveMQQueue
+import org.apache.activemq.command.ConnectionControl
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import javax.jms._
+import java.io.File
+import java.util.Vector
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.Executors
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.atomic.AtomicLong
+import junit.framework.Assert._
+import org.apache.activemq.leveldb.util.Log
+import junit.framework.TestCase
+
+object LevelDBFastEnqueueTest extends Log
+class LevelDBFastEnqueueTest extends TestCase {
+
+  import LevelDBFastEnqueueTest._
+
+  @Test def testPublishNoConsumer: Unit = {
+    startBroker(true, 10)
+    val sharedCount: AtomicLong = new AtomicLong(toSend)
+    var start: Long = System.currentTimeMillis
+    var executorService: ExecutorService = Executors.newCachedThreadPool
+    var i: Int = 0
+    while (i < parallelProducer) {
+      executorService.execute(new Runnable {
+        def run: Unit = {
+          try {
+            publishMessages(sharedCount, 0)
+          }
+          catch {
+            case e: Exception => {
+              exceptions.add(e)
+            }
+          }
+        }
+      })
+      i += 1
+    }
+    executorService.shutdown
+    executorService.awaitTermination(30, TimeUnit.MINUTES)
+    assertTrue("Producers done in time", executorService.isTerminated)
+    assertTrue("No exceptions: " + exceptions, exceptions.isEmpty)
+    var totalSent: Long = toSend * payloadString.length
+    var duration: Double = System.currentTimeMillis - start
+    info("Duration:                " + duration + "ms")
+    info("Rate:                       " + (toSend * 1000 / duration) + "m/s")
+    info("Total send:             " + totalSent)
+    info("Total journal write: " + store.getLogAppendPosition)
+    info("Journal writes %:    " + store.getLogAppendPosition / totalSent.asInstanceOf[Double] * 100 + "%")
+    stopBroker
+    restartBroker(0, 1200000)
+    consumeMessages(toSend)
+  }
+
+  @Test def testPublishNoConsumerNoCheckpoint: Unit = {
+    toSend = 100
+    startBroker(true, 0)
+    val sharedCount: AtomicLong = new AtomicLong(toSend)
+    var start: Long = System.currentTimeMillis
+    var executorService: ExecutorService = Executors.newCachedThreadPool
+    var i: Int = 0
+    while (i < parallelProducer) {
+      executorService.execute(new Runnable {
+        def run: Unit = {
+          try {
+            publishMessages(sharedCount, 0)
+          }
+          catch {
+            case e: Exception => {
+              exceptions.add(e)
+            }
+          }
+        }
+      })
+      i += 1;
+    }
+    executorService.shutdown
+    executorService.awaitTermination(30, TimeUnit.MINUTES)
+    assertTrue("Producers done in time", executorService.isTerminated)
+    assertTrue("No exceptions: " + exceptions, exceptions.isEmpty)
+    var totalSent: Long = toSend * payloadString.length
+    broker.getAdminView.gc
+    var duration: Double = System.currentTimeMillis - start
+    info("Duration:                " + duration + "ms")
+    info("Rate:                       " + (toSend * 1000 / duration) + "m/s")
+    info("Total send:             " + totalSent)
+    info("Total journal write: " + store.getLogAppendPosition)
+    info("Journal writes %:    " + store.getLogAppendPosition / totalSent.asInstanceOf[Double] * 100 + "%")
+    stopBroker
+    restartBroker(0, 0)
+    consumeMessages(toSend)
+  }
+
+  private def consumeMessages(count: Long): Unit = {
+    var connection: ActiveMQConnection = connectionFactory.createConnection.asInstanceOf[ActiveMQConnection]
+    connection.setWatchTopicAdvisories(false)
+    connection.start
+    var session: Session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE)
+    var consumer: MessageConsumer = session.createConsumer(destination)
+    var i: Int = 0
+    while (i < count) {
+        assertNotNull("got message " + i, consumer.receive(10000))
+        i += 1;
+    }
+    assertNull("none left over", consumer.receive(2000))
+  }
+
+  protected def restartBroker(restartDelay: Int, checkpoint: Int): Unit = {
+    stopBroker
+    TimeUnit.MILLISECONDS.sleep(restartDelay)
+    startBroker(false, checkpoint)
+  }
+
+  override def tearDown() = stopBroker
+
+  def stopBroker: Unit = {
+    if (broker != null) {
+      broker.stop
+      broker.waitUntilStopped
+    }
+  }
+
+  private def publishMessages(count: AtomicLong, expiry: Int): Unit = {
+    var connection: ActiveMQConnection = connectionFactory.createConnection.asInstanceOf[ActiveMQConnection]
+    connection.setWatchTopicAdvisories(false)
+    connection.start
+    var session: Session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE)
+    var producer: MessageProducer = session.createProducer(destination)
+    var start: Long = System.currentTimeMillis
+    var i: Long = 0l
+    var bytes: Array[Byte] = payloadString.getBytes
+    while ((({
+      i = count.getAndDecrement; i
+    })) > 0) {
+      var message: Message = null
+      if (useBytesMessage) {
+        message = session.createBytesMessage
+        (message.asInstanceOf[BytesMessage]).writeBytes(bytes)
+      }
+      else {
+        message = session.createTextMessage(payloadString)
+      }
+      producer.send(message, DeliveryMode.PERSISTENT, 5, expiry)
+      if (i != toSend && i % sampleRate == 0) {
+        var now: Long = System.currentTimeMillis
+        info("Remainder: " + i + ", rate: " + sampleRate * 1000 / (now - start) + "m/s")
+        start = now
+      }
+    }
+    connection.syncSendPacket(new ConnectionControl)
+    connection.close
+  }
+
+  def startBroker(deleteAllMessages: Boolean, checkPointPeriod: Int): Unit = {
+    broker = new BrokerService
+    broker.setDeleteAllMessagesOnStartup(deleteAllMessages)
+    store = createStore
+    broker.setPersistenceAdapter(store)
+    broker.addConnector("tcp://0.0.0.0:0")
+    broker.start
+    var options: String = "?jms.watchTopicAdvisories=false&jms.useAsyncSend=true&jms.alwaysSessionAsync=false&jms.dispatchAsync=false&socketBufferSize=131072&ioBufferSize=16384&wireFormat.tightEncodingEnabled=false&wireFormat.cacheSize=8192"
+    connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors.get(0).getConnectUri + options)
+  }
+
+  protected def createStore: LevelDBStore = {
+    var store: LevelDBStore = new LevelDBStore
+    store.setDirectory(new File("target/activemq-data/leveldb"))
+    return store
+  }
+
+  private[leveldb] var broker: BrokerService = null
+  private[leveldb] var connectionFactory: ActiveMQConnectionFactory = null
+  private[leveldb] var store: LevelDBStore = null
+  private[leveldb] var destination: Destination = new ActiveMQQueue("Test")
+  private[leveldb] var payloadString: String = new String(new Array[Byte](6 * 1024))
+  private[leveldb] var useBytesMessage: Boolean = true
+  private[leveldb] final val parallelProducer: Int = 20
+  private[leveldb] var exceptions: Vector[Exception] = new Vector[Exception]
+  private[leveldb] var toSend: Long = 100000
+  private[leveldb] final val sampleRate: Double = 100000
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBStoreBrokerTest.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBStoreBrokerTest.scala
new file mode 100644
index 000000000..f9d4432b0
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBStoreBrokerTest.scala
@@ -0,0 +1,61 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.leveldb
+
+import org.apache.activemq.broker.BrokerService
+import org.apache.activemq.broker.BrokerTest
+import org.apache.activemq.store.PersistenceAdapter
+import java.io.File
+import junit.framework.{TestSuite, Test}
+
+/**
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+object LevelDBStoreBrokerTest {
+  def suite: Test = {
+    return new TestSuite(classOf[LevelDBStoreBrokerTest])
+  }
+
+  def main(args: Array[String]): Unit = {
+    junit.textui.TestRunner.run(suite)
+  }
+}
+
+class LevelDBStoreBrokerTest extends BrokerTest {
+
+  protected def createPersistenceAdapter(delete: Boolean): PersistenceAdapter = {
+    var store: LevelDBStore = new LevelDBStore
+    store.setDirectory(new File("target/activemq-data/leveldb"))
+    if (delete) {
+      store.deleteAllMessages
+    }
+    return store
+  }
+
+  protected override def createBroker: BrokerService = {
+    var broker: BrokerService = new BrokerService
+    broker.setPersistenceAdapter(createPersistenceAdapter(true))
+    return broker
+  }
+
+  protected def createRestartedBroker: BrokerService = {
+    var broker: BrokerService = new BrokerService
+    broker.setPersistenceAdapter(createPersistenceAdapter(false))
+    return broker
+  }
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBStoreTest.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBStoreTest.scala
new file mode 100644
index 000000000..8d1ac64ca
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/LevelDBStoreTest.scala
@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.leveldb
+
+import org.apache.activemq.store.PersistenceAdapter
+import org.apache.activemq.store.PersistenceAdapterTestSupport
+import java.io.File
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+class LevelDBStoreTest extends PersistenceAdapterTestSupport {
+  override def testStoreCanHandleDupMessages: Unit = {
+  }
+
+  protected def createPersistenceAdapter(delete: Boolean): PersistenceAdapter = {
+    var store: LevelDBStore = new LevelDBStore
+    store.setDirectory(new File("target/activemq-data/haleveldb"))
+    if (delete) {
+      store.deleteAllMessages
+    }
+    return store
+  }
+}
\ No newline at end of file
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/Scenario.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/Scenario.scala
new file mode 100644
index 000000000..a6163b598
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/Scenario.scala
@@ -0,0 +1,331 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.leveldb
+
+import java.util.concurrent.atomic._
+import java.util.concurrent.TimeUnit._
+import scala.collection.mutable.ListBuffer
+
+object Scenario {
+  val MESSAGE_ID:Array[Byte] = "message-id"
+  val NEWLINE = '\n'.toByte
+  val NANOS_PER_SECOND = NANOSECONDS.convert(1, SECONDS)
+  
+  implicit def toBytes(value: String):Array[Byte] = value.getBytes("UTF-8")
+
+  def o[T](value:T):Option[T] = value match {
+    case null => None
+    case x => Some(x)
+  }
+}
+
+trait Scenario {
+  import Scenario._
+
+  var url:String = "tcp://localhost:61616"
+  var user_name:String = _
+  var password:String = _
+
+  private var _producer_sleep: { def apply(): Int; def init(time: Long) } = new { def apply() = 0; def init(time: Long) {}  }
+  def producer_sleep = _producer_sleep()
+  def producer_sleep_= (new_value: Int) = _producer_sleep = new { def apply() = new_value; def init(time: Long) {}  }
+  def producer_sleep_= (new_func: { def apply(): Int; def init(time: Long) }) = _producer_sleep = new_func
+
+  private var _consumer_sleep: { def apply(): Int; def init(time: Long) } = new { def apply() = 0; def init(time: Long) {}  }
+  def consumer_sleep = _consumer_sleep()
+  def consumer_sleep_= (new_value: Int) = _consumer_sleep = new { def apply() = new_value; def init(time: Long) {}  }
+  def consumer_sleep_= (new_func: { def apply(): Int; def init(time: Long) }) = _consumer_sleep = new_func
+
+  var producers = 1
+  var producers_per_sample = 0
+
+  var consumers = 1
+  var consumers_per_sample = 0
+  var sample_interval = 1000
+
+  var message_size = 1024
+  var persistent = false
+
+  var headers = Array[Array[(String,String)]]()
+  var selector:String = null
+  var no_local = false
+  var durable = false
+  var ack_mode = "auto"
+  var messages_per_connection = -1L
+  var display_errors = false
+
+  var destination_type = "queue"
+  private var _destination_name: () => String = () => "load"
+  def destination_name = _destination_name()
+  def destination_name_=(new_name: String) = _destination_name = () => new_name
+  def destination_name_=(new_func: () => String) = _destination_name = new_func
+  var destination_count = 1
+
+  val producer_counter = new AtomicLong()
+  val consumer_counter = new AtomicLong()
+  val error_counter = new AtomicLong()
+  val done = new AtomicBoolean()
+
+  var queue_prefix = ""
+  var topic_prefix = ""
+  var name = "custom"
+
+  var drain_timeout = 2000L
+
+  def run() = {
+    print(toString)
+    println("--------------------------------------")
+    println("     Running: Press ENTER to stop")
+    println("--------------------------------------")
+    println("")
+
+    with_load {
+
+      // start a sampling client...
+      val sample_thread = new Thread() {
+        override def run() = {
+          
+          def print_rate(name: String, periodCount:Long, totalCount:Long, nanos: Long) = {
+
+            val rate_per_second: java.lang.Float = ((1.0f * periodCount / nanos) * NANOS_PER_SECOND)
+            println("%s total: %,d, rate: %,.3f per second".format(name, totalCount, rate_per_second))
+          }
+
+          try {
+            var start = System.nanoTime
+            var total_producer_count = 0L
+            var total_consumer_count = 0L
+            var total_error_count = 0L
+            collection_start
+            while( !done.get ) {
+              Thread.sleep(sample_interval)
+              val end = System.nanoTime
+              collection_sample
+              val samples = collection_end
+              samples.get("p_custom").foreach { case (_, count)::Nil =>
+                total_producer_count += count
+                print_rate("Producer", count, total_producer_count, end - start)
+              case _ =>
+              }
+              samples.get("c_custom").foreach { case (_, count)::Nil =>
+                total_consumer_count += count
+                print_rate("Consumer", count, total_consumer_count, end - start)
+              case _ =>
+              }
+              samples.get("e_custom").foreach { case (_, count)::Nil =>
+                if( count!= 0 ) {
+                  total_error_count += count
+                  print_rate("Error", count, total_error_count, end - start)
+                }
+              case _ =>
+              }
+              start = end
+            }
+          } catch {
+            case e:InterruptedException =>
+          }
+        }
+      }
+      sample_thread.start()
+
+      System.in.read()
+      done.set(true)
+
+      sample_thread.interrupt
+      sample_thread.join
+    }
+
+  }
+
+  override def toString() = {
+    "--------------------------------------\n"+
+    "Scenario Settings\n"+
+    "--------------------------------------\n"+
+    "  destination_type      = "+destination_type+"\n"+
+    "  queue_prefix          = "+queue_prefix+"\n"+
+    "  topic_prefix          = "+topic_prefix+"\n"+
+    "  destination_count     = "+destination_count+"\n" +
+    "  destination_name      = "+destination_name+"\n" +
+    "  sample_interval (ms)  = "+sample_interval+"\n" +
+    "  \n"+
+    "  --- Producer Properties ---\n"+
+    "  producers             = "+producers+"\n"+
+    "  message_size          = "+message_size+"\n"+
+    "  persistent            = "+persistent+"\n"+
+    "  producer_sleep (ms)   = "+producer_sleep+"\n"+
+    "  headers               = "+headers.mkString(", ")+"\n"+
+    "  \n"+
+    "  --- Consumer Properties ---\n"+
+    "  consumers             = "+consumers+"\n"+
+    "  consumer_sleep (ms)   = "+consumer_sleep+"\n"+
+    "  selector              = "+selector+"\n"+
+    "  durable               = "+durable+"\n"+
+    ""
+
+  }
+
+  protected def headers_for(i:Int) = {
+    if ( headers.isEmpty ) {
+      Array[(String, String)]()
+    } else {
+      headers(i%headers.size)
+    }
+  }
+
+  var producer_samples:Option[ListBuffer[(Long,Long)]] = None
+  var consumer_samples:Option[ListBuffer[(Long,Long)]] = None
+  var error_samples = ListBuffer[(Long,Long)]()
+
+  def collection_start: Unit = {
+    producer_counter.set(0)
+    consumer_counter.set(0)
+    error_counter.set(0)
+
+    producer_samples = if (producers > 0 || producers_per_sample>0 ) {
+      Some(ListBuffer[(Long,Long)]())
+    } else {
+      None
+    }
+    consumer_samples = if (consumers > 0 || consumers_per_sample>0 ) {
+      Some(ListBuffer[(Long,Long)]())
+    } else {
+      None
+    }
+  }
+
+  def collection_end: Map[String, scala.List[(Long,Long)]] = {
+    var rc = Map[String, List[(Long,Long)]]()
+    producer_samples.foreach{ samples =>
+      rc += "p_"+name -> samples.toList
+      samples.clear
+    }
+    consumer_samples.foreach{ samples =>
+      rc += "c_"+name -> samples.toList
+      samples.clear
+    }
+    rc += "e_"+name -> error_samples.toList
+    error_samples.clear
+    rc
+  }
+
+  trait Client {
+    def start():Unit
+    def shutdown():Unit
+  }
+
+  var producer_clients = List[Client]()
+  var consumer_clients = List[Client]()
+
+  def with_load[T](func: =>T ):T = {
+    done.set(false)
+
+    _producer_sleep.init(System.currentTimeMillis())
+    _consumer_sleep.init(System.currentTimeMillis())
+
+    for (i <- 0 until producers) {
+      val client = createProducer(i)
+      producer_clients ::= client
+      client.start()
+    }
+
+    for (i <- 0 until consumers) {
+      val client = createConsumer(i)
+      consumer_clients ::= client
+      client.start()
+    }
+
+    try {
+      func
+    } finally {
+      done.set(true)
+      // wait for the threads to finish..
+      for( client <- consumer_clients ) {
+        client.shutdown
+      }
+      consumer_clients = List()
+      for( client <- producer_clients ) {
+        client.shutdown
+      }
+      producer_clients = List()
+    }
+  }
+
+  def drain = {
+    done.set(false)
+    if( destination_type=="queue" || destination_type=="raw_queue" || durable==true ) {
+      print("draining")
+      consumer_counter.set(0)
+      var consumer_clients = List[Client]()
+      for (i <- 0 until destination_count) {
+        val client = createConsumer(i)
+        consumer_clients ::= client
+        client.start()
+      }
+
+      // Keep sleeping until we stop draining messages.
+      var drained = 0L
+      try {
+        Thread.sleep(drain_timeout);
+        def done() = {
+          val c = consumer_counter.getAndSet(0)
+          drained += c
+          c == 0
+        }
+        while( !done ) {
+          print(".")
+          Thread.sleep(drain_timeout);
+        }
+      } finally {
+        done.set(true)
+        for( client <- consumer_clients ) {
+          client.shutdown
+        }
+        println(". (drained %d)".format(drained))
+      }
+    }
+  }
+
+
+  def collection_sample: Unit = {
+
+    val now = System.currentTimeMillis()
+    producer_samples.foreach(_.append((now, producer_counter.getAndSet(0))))
+    consumer_samples.foreach(_.append((now, consumer_counter.getAndSet(0))))
+    error_samples.append((now, error_counter.getAndSet(0)))
+
+    // we might need to increment number the producers..
+    for (i <- 0 until producers_per_sample) {
+      val client = createProducer(producer_clients.length)
+      producer_clients ::= client
+      client.start()
+    }
+
+    // we might need to increment number the consumers..
+    for (i <- 0 until consumers_per_sample) {
+      val client = createConsumer(consumer_clients.length)
+      consumer_clients ::= client
+      client.start()
+    }
+
+  }
+  
+  def createProducer(i:Int):Client
+  def createConsumer(i:Int):Client
+
+}
+
+
diff --git a/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/TestingHDFSServer.scala b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/TestingHDFSServer.scala
new file mode 100644
index 000000000..8acde2185
--- /dev/null
+++ b/activemq-leveldb/src/test/scala/org/apache/activemq/leveldb/TestingHDFSServer.scala
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.leveldb
+
+import org.apache.hadoop.conf.Configuration
+import org.apache.hadoop.fs.FileSystem
+import org.apache.hadoop.hdfs.MiniDFSCluster
+import java.io.IOException
+
+/**
+ * <p>
+ * </p>
+ *
+ * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
+ */
+object TestingHDFSServer {
+  private[leveldb] def start: Unit = {
+    var conf: Configuration = new Configuration
+    cluster = new MiniDFSCluster(conf, 1, true, null)
+    cluster.waitActive
+    fs = cluster.getFileSystem
+  }
+
+  private[leveldb] def stop: Unit = {
+    try {
+      cluster.shutdown
+    }
+    catch {
+      case e: Throwable => {
+        e.printStackTrace
+      }
+    }
+  }
+
+  private[leveldb] var cluster: MiniDFSCluster = null
+  private[leveldb] var fs: FileSystem = null
+}
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index 867398e45..e67b2c755 100755
--- a/pom.xml
+++ b/pom.xml
@@ -64,11 +64,13 @@
     <fusemq-leveldb-version>1.3</fusemq-leveldb-version>
     <ftpserver-version>1.0.6</ftpserver-version>
     <geronimo-version>1.0</geronimo-version>
+    <hadoop-version>1.0.0</hadoop-version>
     <hawtbuf-version>1.9</hawtbuf-version>
     <hawtdispatch-version>1.11</hawtdispatch-version>
     <howl-version>0.1.8</howl-version>
     <hsqldb-version>1.8.0.10</hsqldb-version>
     <httpclient-version>4.2.1</httpclient-version>
+    <jackson-version>1.9.2</jackson-version>
     <jasypt-version>1.9.0</jasypt-version>
     <jdom-version>1.0</jdom-version>
     <jetty-version>7.6.7.v20120910</jetty-version>
@@ -93,6 +95,9 @@
     <rome-version>1.0</rome-version>
     <saxon-version>9.4</saxon-version>
     <saxon-bundle-version>9.4.0.1_2</saxon-bundle-version>
+    <scala-plugin-version>2.15.1</scala-plugin-version>
+    <scala-version>2.9.1</scala-version>
+    <scalatest-version>1.8</scalatest-version>
     <slf4j-version>1.6.6</slf4j-version>
     <spring-version>3.0.7.RELEASE</spring-version>
     <spring-osgi-version>1.2.1</spring-osgi-version>
@@ -198,6 +203,7 @@
     <module>activemq-jaas</module>
     <module>activemq-blueprint</module>
     <module>activemq-karaf</module>
+    <module>activemq-leveldb</module>
     <module>activemq-openwire-generator</module>
     <module>activemq-optional</module>
     <module>activemq-pool</module>
