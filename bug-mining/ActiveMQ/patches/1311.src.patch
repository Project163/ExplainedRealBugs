diff --git a/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java b/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java
index 3e9938c40..705461794 100755
--- a/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java
+++ b/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java
@@ -455,14 +455,6 @@ public class FailoverTransport implements CompositeTransport {
         this.maxCacheSize = maxCacheSize;
     }
 
-    /**
-     * @return Returns true if the command is one sent when a connection is
-     *         being closed.
-     */
-    private boolean isShutdownCommand(Command command) {
-        return (command != null && (command.isShutdownInfo() || command instanceof RemoveInfo));
-    }
-
     public void oneway(Object o) throws IOException {
 
         Command command = (Command) o;
@@ -471,22 +463,22 @@ public class FailoverTransport implements CompositeTransport {
 
             synchronized (reconnectMutex) {
 
-                if (isShutdownCommand(command) && connectedTransport.get() == null) {
+                if (command != null && connectedTransport.get() == null) {
                     if (command.isShutdownInfo()) {
-                        // Skipping send of ShutdownInfo command when not
-                        // connected.
+                        // Skipping send of ShutdownInfo command when not connected.
                         return;
-                    }
-                    if (command instanceof RemoveInfo || command.isMessageAck()) {
-                        // Simulate response to RemoveInfo command or ack (as it
-                        // will be stale)
+                    } else if (command instanceof RemoveInfo || command.isMessageAck()) {
+                        // Simulate response to RemoveInfo command or MessageAck (as it will be stale)
                         stateTracker.track(command);
-                        Response response = new Response();
-                        response.setCorrelationId(command.getCommandId());
-                        myTransportListener.onCommand(response);
+                    	if (command.isResponseRequired()) {
+	                        Response response = new Response();
+	                        response.setCorrelationId(command.getCommandId());
+	                        myTransportListener.onCommand(response);
+                    	}
                         return;
                     }
                 }
+
                 // Keep trying until the message is sent.
                 for (int i = 0; !disposed; i++) {
                     try {
diff --git a/activemq-core/src/test/java/org/apache/activemq/transport/failover/FailoverTransportTest.java b/activemq-core/src/test/java/org/apache/activemq/transport/failover/FailoverTransportTest.java
new file mode 100644
index 000000000..04b3e47e6
--- /dev/null
+++ b/activemq-core/src/test/java/org/apache/activemq/transport/failover/FailoverTransportTest.java
@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.transport.failover;
+
+import java.io.IOException;
+import java.net.URI;
+
+import org.apache.activemq.command.ConnectionId;
+import org.apache.activemq.command.ConnectionInfo;
+import org.apache.activemq.command.MessageAck;
+import org.apache.activemq.command.RemoveInfo;
+import org.apache.activemq.command.ShutdownInfo;
+import org.apache.activemq.state.ConnectionStateTracker;
+import org.apache.activemq.transport.Transport;
+import org.apache.activemq.transport.TransportFactory;
+import org.apache.activemq.transport.TransportListener;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+public class FailoverTransportTest {
+
+    protected Transport transport;
+    protected FailoverTransport failoverTransport;
+    private int commandsReceived;
+
+	@Before
+	public void setUp() throws Exception {
+	}
+
+	@After
+	public void tearDown() throws Exception {
+        if (transport != null) {
+            transport.stop();
+        }
+    }
+
+	@Test(timeout=30000)
+	public void testCommandsIgnoredWhenOffline() throws Exception {
+		this.transport = createTransport();
+
+		assertNotNull(failoverTransport);
+
+		ConnectionStateTracker tracker = failoverTransport.getStateTracker();
+		assertNotNull(tracker);
+
+		ConnectionId id = new ConnectionId("1");
+		ConnectionInfo connection = new ConnectionInfo(id);
+
+		// Track a connection
+		tracker.track(connection);
+
+		try {
+			this.transport.oneway(new RemoveInfo(new ConnectionId("1")));
+		} catch(Exception e) {
+			fail("Should not have failed to remove this known connection");
+		}
+
+		try {
+			this.transport.oneway(new RemoveInfo(new ConnectionId("2")));
+		} catch(Exception e) {
+			fail("Should not have failed to remove this unknown connection");
+		}
+
+		this.transport.oneway(new MessageAck());
+		this.transport.oneway(new ShutdownInfo());
+	}
+
+	@Test(timeout=30000)
+	public void testResponsesSentWhenRequestForIgnoredCommands() throws Exception {
+		this.transport = createTransport();
+		assertNotNull(failoverTransport);
+		MessageAck ack = new MessageAck();
+		assertNotNull("Should have received a Response", this.transport.request(ack));
+		RemoveInfo info = new RemoveInfo(new ConnectionId("2"));
+		assertNotNull("Should have received a Response", this.transport.request(info));
+	}
+
+    protected Transport createTransport() throws Exception {
+    	Transport transport = TransportFactory.connect(
+    			new URI("failover://(tcp://doesNotExist:1234)"));
+        transport.setTransportListener(new TransportListener() {
+
+            public void onCommand(Object command) {
+            	commandsReceived++;
+            }
+
+            public void onException(IOException error) {
+            }
+
+            public void transportInterupted() {
+            }
+
+            public void transportResumed() {
+            }
+        });
+        transport.start();
+
+        this.failoverTransport = transport.narrow(FailoverTransport.class);
+
+        return transport;
+    }
+
+}
