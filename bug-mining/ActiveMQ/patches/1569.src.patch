diff --git a/activemq-core/src/main/java/org/apache/activemq/ActiveMQMessageConsumer.java b/activemq-core/src/main/java/org/apache/activemq/ActiveMQMessageConsumer.java
index 5977c3ba9..6de5b4488 100755
--- a/activemq-core/src/main/java/org/apache/activemq/ActiveMQMessageConsumer.java
+++ b/activemq-core/src/main/java/org/apache/activemq/ActiveMQMessageConsumer.java
@@ -708,6 +708,9 @@ public class ActiveMQMessageConsumer implements MessageAvailableConsumer, StatsC
                     // allow dispatch on this connection to resume
                     session.connection.transportInterruptionProcessingComplete();
                     inProgressClearRequiredFlag.decrementAndGet();
+
+                    // Wake up any blockers and allow them to recheck state.
+                    unconsumedMessages.getMutex().notifyAll();
                 }
             }
         }
diff --git a/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java b/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java
index e6b3f5141..a20e354d7 100755
--- a/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java
+++ b/activemq-core/src/main/java/org/apache/activemq/transport/failover/FailoverTransport.java
@@ -40,6 +40,8 @@ import org.apache.activemq.broker.SslContext;
 import org.apache.activemq.command.Command;
 import org.apache.activemq.command.ConnectionControl;
 import org.apache.activemq.command.ConnectionId;
+import org.apache.activemq.command.MessageDispatch;
+import org.apache.activemq.command.MessagePull;
 import org.apache.activemq.command.RemoveInfo;
 import org.apache.activemq.command.Response;
 import org.apache.activemq.state.ConnectionStateTracker;
@@ -534,6 +536,16 @@ public class FailoverTransport implements CompositeTransport {
                             myTransportListener.onCommand(response);
                         }
                         return;
+                    } else if (command instanceof MessagePull) {
+                        // Simulate response to MessagePull if timed as we can't honor that now.
+                    	MessagePull pullRequest = (MessagePull) command;
+                    	if (pullRequest.getTimeout() != 0) {
+	                        MessageDispatch dispatch = new MessageDispatch();
+	                        dispatch.setConsumerId(pullRequest.getConsumerId());
+	                        dispatch.setDestination(pullRequest.getDestination());
+                            myTransportListener.onCommand(dispatch);
+                        }
+                        return;
                     }
                 }
 
diff --git a/activemq-core/src/test/java/org/apache/activemq/bugs/AMQ3932Test.java b/activemq-core/src/test/java/org/apache/activemq/bugs/AMQ3932Test.java
new file mode 100644
index 000000000..8070d5ee4
--- /dev/null
+++ b/activemq-core/src/test/java/org/apache/activemq/bugs/AMQ3932Test.java
@@ -0,0 +1,157 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.bugs;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.JMSException;
+import javax.jms.MessageConsumer;
+import javax.jms.Session;
+
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.broker.BrokerService;
+import org.apache.activemq.broker.TransportConnector;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mortbay.log.Log;
+
+public class AMQ3932Test {
+
+    private Connection connection;
+    private BrokerService broker;
+
+    @Before
+    public void setUp() throws Exception {
+        broker = new BrokerService();
+        broker.setPersistent(false);
+        broker.setUseJmx(false);
+        TransportConnector tcpConnector = broker.addConnector("tcp://localhost:0");
+        broker.start();
+
+        ConnectionFactory factory = new ActiveMQConnectionFactory(
+                "failover:("+ tcpConnector.getPublishableConnectString() +")?jms.prefetchPolicy.queuePrefetch=0");
+        connection = factory.createConnection();
+        connection.start();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        connection.close();
+
+        if (broker != null) {
+            broker.stop();
+            broker.waitUntilStopped();
+            broker = null;
+        }
+    }
+
+    @Test
+    public void testPlainReceiveBlocks() throws Exception {
+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+        final MessageConsumer consumer = session.createConsumer(session.createQueue(getClass().getName()));
+
+        broker.stop();
+        broker.waitUntilStopped();
+        broker = null;
+
+        final CountDownLatch done = new CountDownLatch(1);
+        final CountDownLatch started = new CountDownLatch(1);
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+
+        executor.execute(new Runnable() {
+            public void run() {
+                try {
+                    started.countDown();
+                    Log.info("Entering into a Sync receive call");
+                    consumer.receive();
+                } catch (JMSException e) {
+                }
+                done.countDown();
+            }
+        });
+
+        assertTrue(started.await(10, TimeUnit.SECONDS));
+        assertFalse(done.await(20, TimeUnit.SECONDS));
+    }
+
+    @Test
+    public void testHungReceiveNoWait() throws Exception {
+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+        final MessageConsumer consumer = session.createConsumer(session.createQueue(getClass().getName()));
+
+        broker.stop();
+        broker.waitUntilStopped();
+        broker = null;
+
+        final CountDownLatch done = new CountDownLatch(1);
+        final CountDownLatch started = new CountDownLatch(1);
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+
+        executor.execute(new Runnable() {
+            public void run() {
+                try {
+                    started.countDown();
+                    Log.info("Entering into a Sync receiveNoWait call");
+                    consumer.receiveNoWait();
+                } catch (JMSException e) {
+                }
+                done.countDown();
+            }
+        });
+
+        assertTrue(started.await(10, TimeUnit.SECONDS));
+        assertTrue(done.await(20, TimeUnit.SECONDS));
+    }
+
+    @Test
+    public void testHungReceiveTimed() throws Exception {
+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+        final MessageConsumer consumer = session.createConsumer(session.createQueue(getClass().getName()));
+
+        broker.stop();
+        broker.waitUntilStopped();
+        broker = null;
+
+        final CountDownLatch done = new CountDownLatch(1);
+        final CountDownLatch started = new CountDownLatch(1);
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+
+        executor.execute(new Runnable() {
+            public void run() {
+                try {
+                    started.countDown();
+                    Log.info("Entering into a timed Sync receive call");
+                    consumer.receive(10);
+                } catch (JMSException e) {
+                }
+                done.countDown();
+            }
+        });
+
+        assertTrue(started.await(10, TimeUnit.SECONDS));
+        assertTrue(done.await(20, TimeUnit.SECONDS));
+    }
+}
\ No newline at end of file
