diff --git a/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/AMQ4563Test.java b/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/AMQ4563Test.java
index 88e0a44c3..099944d0d 100644
--- a/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/AMQ4563Test.java
+++ b/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/AMQ4563Test.java
@@ -39,7 +39,7 @@ import org.junit.Test;
 
 public class AMQ4563Test extends AmqpTestSupport {
 
-    public static final String KAHADB_DIRECTORY = "target/activemq-data/kahadb-amq4563";
+    public static final String KAHADB_DIRECTORY = "./target/activemq-data/kahadb-amq4563";
 
     @Test(timeout = 60000)
     public void testMessagesAreAckedAMQProducer() throws Exception {
@@ -224,7 +224,7 @@ public class AMQ4563Test extends AmqpTestSupport {
     }
 
     @Override
-    protected int getstoreOpenWireVersion() {
+    protected int getStoreOpenWireVersion() {
         return 10;
     }
 }
diff --git a/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/AmqpTestSupport.java b/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/AmqpTestSupport.java
index 6f00ab20f..615376290 100644
--- a/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/AmqpTestSupport.java
+++ b/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/AmqpTestSupport.java
@@ -102,7 +102,7 @@ public class AmqpTestSupport {
             KahaDBStore kaha = new KahaDBStore();
             kaha.setDirectory(new File(KAHADB_DIRECTORY + getTestName()));
             brokerService.setPersistenceAdapter(kaha);
-            brokerService.setStoreOpenWireVersion(getstoreOpenWireVersion());
+            brokerService.setStoreOpenWireVersion(getStoreOpenWireVersion());
         }
         brokerService.setSchedulerSupport(false);
         brokerService.setAdvisorySupport(false);
@@ -188,8 +188,8 @@ public class AmqpTestSupport {
         return true;
     }
 
-    protected int getstoreOpenWireVersion() {
-        return OpenWireFormat.DEFAULT_VERSION;
+    protected int getStoreOpenWireVersion() {
+        return OpenWireFormat.DEFAULT_WIRE_VERSION;
     }
 
     protected boolean isUseOpenWireConnector() {
diff --git a/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/interop/AmqpDurableReceiverTest.java b/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/interop/AmqpDurableReceiverTest.java
index 1b944a983..e2d24959d 100644
--- a/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/interop/AmqpDurableReceiverTest.java
+++ b/activemq-amqp/src/test/java/org/apache/activemq/transport/amqp/interop/AmqpDurableReceiverTest.java
@@ -35,7 +35,6 @@ import org.apache.qpid.proton.amqp.messaging.Source;
 import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
 import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
 import org.apache.qpid.proton.engine.Receiver;
-import org.junit.Ignore;
 import org.junit.Test;
 
 /**
@@ -293,7 +292,6 @@ public class AmqpDurableReceiverTest extends AmqpClientTestSupport {
         connection.close();
     }
 
-    @Ignore("Broker doesn't currently recover noLocal state")
     @Test(timeout = 60000)
     public void testLookupExistingSubscriptionAfterRestartWithSelectorAndNoLocal() throws Exception {
 
diff --git a/activemq-broker/src/main/java/org/apache/activemq/broker/region/Topic.java b/activemq-broker/src/main/java/org/apache/activemq/broker/region/Topic.java
index 21e0c1b65..bda000b69 100755
--- a/activemq-broker/src/main/java/org/apache/activemq/broker/region/Topic.java
+++ b/activemq-broker/src/main/java/org/apache/activemq/broker/region/Topic.java
@@ -39,6 +39,7 @@ import org.apache.activemq.broker.region.policy.SimpleDispatchPolicy;
 import org.apache.activemq.broker.region.policy.SubscriptionRecoveryPolicy;
 import org.apache.activemq.broker.util.InsertionCountList;
 import org.apache.activemq.command.ActiveMQDestination;
+import org.apache.activemq.command.ConsumerInfo;
 import org.apache.activemq.command.ExceptionResponse;
 import org.apache.activemq.command.Message;
 import org.apache.activemq.command.MessageAck;
@@ -209,6 +210,17 @@ public class Topic extends BaseDestination implements Task {
         }
     }
 
+    private boolean hasDurableSubChanged(SubscriptionInfo info1, ConsumerInfo info2) {
+        if (info1.getSelector() != null ^ info2.getSelector() != null) {
+            return true;
+        }
+        if (info1.getSelector() != null && !info1.getSelector().equals(info2.getSelector())) {
+            return true;
+        }
+
+        return false;
+    }
+
     public void activate(ConnectionContext context, final DurableTopicSubscription subscription) throws Exception {
         // synchronize with dispatch method so that no new messages are sent
         // while we are recovering a subscription to avoid out of order messages.
@@ -222,12 +234,10 @@ public class Topic extends BaseDestination implements Task {
             // Recover the durable subscription.
             String clientId = subscription.getSubscriptionKey().getClientId();
             String subscriptionName = subscription.getSubscriptionKey().getSubscriptionName();
-            String selector = subscription.getConsumerInfo().getSelector();
             SubscriptionInfo info = topicStore.lookupSubscription(clientId, subscriptionName);
             if (info != null) {
                 // Check to see if selector changed.
-                String s1 = info.getSelector();
-                if (s1 == null ^ selector == null || (s1 != null && !s1.equals(selector))) {
+                if (hasDurableSubChanged(info, subscription.getConsumerInfo())) {
                     // Need to delete the subscription
                     topicStore.deleteSubscription(clientId, subscriptionName);
                     info = null;
@@ -247,9 +257,10 @@ public class Topic extends BaseDestination implements Task {
             if (info == null) {
                 info = new SubscriptionInfo();
                 info.setClientId(clientId);
-                info.setSelector(selector);
+                info.setSelector(subscription.getConsumerInfo().getSelector());
                 info.setSubscriptionName(subscriptionName);
                 info.setDestination(getActiveMQDestination());
+                info.setNoLocal(subscription.getConsumerInfo().isNoLocal());
                 // This destination is an actual destination id.
                 info.setSubscribedDestination(subscription.getConsumerInfo().getDestination());
                 // This destination might be a pattern
@@ -816,17 +827,6 @@ public class Topic extends BaseDestination implements Task {
         }
     }
 
-    private void rollback(MessageId poisoned) {
-        dispatchLock.readLock().lock();
-        try {
-            for (DurableTopicSubscription durableTopicSubscription : durableSubscribers.values()) {
-                durableTopicSubscription.getPending().rollback(poisoned);
-            }
-        } finally {
-            dispatchLock.readLock().unlock();
-        }
-    }
-
     public Map<SubscriptionKey, DurableTopicSubscription> getDurableTopicSubs() {
         return durableSubscribers;
     }
diff --git a/activemq-broker/src/main/java/org/apache/activemq/broker/region/TopicRegion.java b/activemq-broker/src/main/java/org/apache/activemq/broker/region/TopicRegion.java
index 684ac8889..ca79b2593 100755
--- a/activemq-broker/src/main/java/org/apache/activemq/broker/region/TopicRegion.java
+++ b/activemq-broker/src/main/java/org/apache/activemq/broker/region/TopicRegion.java
@@ -136,7 +136,7 @@ public class TopicRegion extends AbstractRegion {
                     destinationsLock.readLock().lock();
                     try {
                         for (Destination dest : destinations.values()) {
-                            //Account for virtual destinations
+                            // Account for virtual destinations
                             if (dest instanceof Topic){
                                 Topic topic = (Topic)dest;
                                 topic.deleteSubscription(context, key);
@@ -301,6 +301,7 @@ public class TopicRegion extends AbstractRegion {
         rc.setSubscriptionName(info.getSubscriptionName());
         rc.setDestination(info.getSubscribedDestination());
         rc.setConsumerId(createConsumerId());
+        rc.setNoLocal(info.isNoLocal());
         return rc;
     }
 
diff --git a/activemq-client/pom.xml b/activemq-client/pom.xml
index 3809a71ef..a45bfae20 100755
--- a/activemq-client/pom.xml
+++ b/activemq-client/pom.xml
@@ -252,37 +252,37 @@
       </plugin>
     </plugins>
     <pluginManagement>
-    	<plugins>
-    		<!--This plugin's configuration is used to store Eclipse m2e settings only. It has no influence on the Maven build itself.-->
-    		<plugin>
-    			<groupId>org.eclipse.m2e</groupId>
-    			<artifactId>lifecycle-mapping</artifactId>
-    			<version>1.0.0</version>
-    			<configuration>
-    				<lifecycleMappingMetadata>
-    					<pluginExecutions>
-    						<pluginExecution>
-    							<pluginExecutionFilter>
-    								<groupId>org.codehaus.mojo</groupId>
-    								<artifactId>
-    									javacc-maven-plugin
-    								</artifactId>
-    								<versionRange>[2.6,)</versionRange>
-    								<goals>
-    									<goal>javacc</goal>
-    								</goals>
-    							</pluginExecutionFilter>
-    							<action>
+        <plugins>
+            <!--This plugin's configuration is used to store Eclipse m2e settings only. It has no influence on the Maven build itself.-->
+            <plugin>
+                <groupId>org.eclipse.m2e</groupId>
+                <artifactId>lifecycle-mapping</artifactId>
+                <version>1.0.0</version>
+                <configuration>
+                    <lifecycleMappingMetadata>
+                        <pluginExecutions>
+                            <pluginExecution>
+                                <pluginExecutionFilter>
+                                    <groupId>org.codehaus.mojo</groupId>
+                                    <artifactId>
+                                        javacc-maven-plugin
+                                    </artifactId>
+                                    <versionRange>[2.6,)</versionRange>
+                                    <goals>
+                                        <goal>javacc</goal>
+                                    </goals>
+                                </pluginExecutionFilter>
+                                <action>
                                     <execute>
                                       <runOnIncremental>true</runOnIncremental>
                                     </execute>
-    							</action>
-    						</pluginExecution>
-    					</pluginExecutions>
-    				</lifecycleMappingMetadata>
-    			</configuration>
-    		</plugin>
-    	</plugins>
+                                </action>
+                            </pluginExecution>
+                        </pluginExecutions>
+                    </lifecycleMappingMetadata>
+                </configuration>
+            </plugin>
+        </plugins>
     </pluginManagement>
   </build>
 
@@ -308,7 +308,7 @@
               <tasks>
                 <echo>Running OpenWire Generator</echo>
                 <taskdef name="generate" classname="org.apache.activemq.openwire.tool.JavaGeneratorTask" classpathref="maven.compile.classpath" />
-                <generate version="10" basedir="${basedir}" generateTests="false" />
+                <generate version="11" basedir="${basedir}" generateTests="false" />
               </tasks>
             </configuration>
             <dependencies>
diff --git a/activemq-client/src/main/java/org/apache/activemq/command/CommandTypes.java b/activemq-client/src/main/java/org/apache/activemq/command/CommandTypes.java
index 00681fa42..49ed9cbd1 100755
--- a/activemq-client/src/main/java/org/apache/activemq/command/CommandTypes.java
+++ b/activemq-client/src/main/java/org/apache/activemq/command/CommandTypes.java
@@ -18,13 +18,13 @@ package org.apache.activemq.command;
 
 /**
  * Holds the command id constants used by the command objects.
- * 
- * 
+ *
+ *
  */
 public interface CommandTypes {
 
     // What is the latest version of the openwire protocol
-    byte PROTOCOL_VERSION = 10;
+    byte PROTOCOL_VERSION = 11;
 
     // What is the latest version of the openwire protocol used in the stores
     byte PROTOCOL_STORE_VERSION = 6;
diff --git a/activemq-client/src/main/java/org/apache/activemq/command/SubscriptionInfo.java b/activemq-client/src/main/java/org/apache/activemq/command/SubscriptionInfo.java
index 7776b5351..3159e335c 100755
--- a/activemq-client/src/main/java/org/apache/activemq/command/SubscriptionInfo.java
+++ b/activemq-client/src/main/java/org/apache/activemq/command/SubscriptionInfo.java
@@ -20,9 +20,9 @@ import org.apache.activemq.util.IntrospectionSupport;
 
 /**
  * Used to represent a durable subscription.
- * 
+ *
  * @openwire:marshaller code="55"
- * 
+ *
  */
 public class SubscriptionInfo implements DataStructure {
 
@@ -33,6 +33,7 @@ public class SubscriptionInfo implements DataStructure {
     protected String clientId;
     protected String subscriptionName;
     protected String selector;
+    protected boolean noLocal;
 
     public SubscriptionInfo() {}
 
@@ -41,6 +42,7 @@ public class SubscriptionInfo implements DataStructure {
         this.subscriptionName = subscriptionName;
     }
 
+    @Override
     public byte getDataStructureType() {
         return DATA_STRUCTURE_TYPE;
     }
@@ -59,7 +61,7 @@ public class SubscriptionInfo implements DataStructure {
     /**
      * This is the a resolved destination that the subscription is receiving
      * messages from. This will never be a pattern or a composite destination.
-     * 
+     *
      * @openwire:property version=1 cache=true
      */
     public ActiveMQDestination getDestination() {
@@ -103,6 +105,7 @@ public class SubscriptionInfo implements DataStructure {
         this.subscriptionName = subscriptionName;
     }
 
+    @Override
     public boolean isMarshallAware() {
         return false;
     }
@@ -139,10 +142,10 @@ public class SubscriptionInfo implements DataStructure {
      * The destination the client originally subscribed to.. This may not match
      * the {@see getDestination} method if the subscribed destination uses
      * patterns or composites.
-     * 
+     *
      * If the subscribed destinationis not set, this just ruturns the
      * desitination.
-     * 
+     *
      * @openwire:property version=3
      */
     public ActiveMQDestination getSubscribedDestination() {
@@ -156,4 +159,14 @@ public class SubscriptionInfo implements DataStructure {
         this.subscribedDestination = subscribedDestination;
     }
 
+    /**
+     * @openwire:property version=11
+     */
+    public boolean isNoLocal() {
+        return noLocal;
+    }
+
+    public void setNoLocal(boolean noLocal) {
+        this.noLocal = noLocal;
+    }
 }
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQBlobMessageMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQBlobMessageMarshaller.java
new file mode 100644
index 000000000..3f0492fbf
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQBlobMessageMarshaller.java
@@ -0,0 +1,139 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQBlobMessageMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQBlobMessageMarshaller extends ActiveMQMessageMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQBlobMessage.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQBlobMessage();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ActiveMQBlobMessage info = (ActiveMQBlobMessage)o;
+        info.setRemoteBlobUrl(tightUnmarshalString(dataIn, bs));
+        info.setMimeType(tightUnmarshalString(dataIn, bs));
+        info.setDeletedByBroker(bs.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ActiveMQBlobMessage info = (ActiveMQBlobMessage)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getRemoteBlobUrl(), bs);
+        rc += tightMarshalString1(info.getMimeType(), bs);
+        bs.writeBoolean(info.isDeletedByBroker());
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ActiveMQBlobMessage info = (ActiveMQBlobMessage)o;
+        tightMarshalString2(info.getRemoteBlobUrl(), dataOut, bs);
+        tightMarshalString2(info.getMimeType(), dataOut, bs);
+        bs.readBoolean();
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ActiveMQBlobMessage info = (ActiveMQBlobMessage)o;
+        info.setRemoteBlobUrl(looseUnmarshalString(dataIn));
+        info.setMimeType(looseUnmarshalString(dataIn));
+        info.setDeletedByBroker(dataIn.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ActiveMQBlobMessage info = (ActiveMQBlobMessage)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getRemoteBlobUrl(), dataOut);
+        looseMarshalString(info.getMimeType(), dataOut);
+        dataOut.writeBoolean(info.isDeletedByBroker());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQBytesMessageMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQBytesMessageMarshaller.java
new file mode 100644
index 000000000..96fb9e655
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQBytesMessageMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQBytesMessageMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQBytesMessageMarshaller extends ActiveMQMessageMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQBytesMessage.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQBytesMessage();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQDestinationMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQDestinationMarshaller.java
new file mode 100644
index 000000000..aaa4d70f5
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQDestinationMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQDestinationMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public abstract class ActiveMQDestinationMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ActiveMQDestination info = (ActiveMQDestination)o;
+        info.setPhysicalName(tightUnmarshalString(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ActiveMQDestination info = (ActiveMQDestination)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getPhysicalName(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ActiveMQDestination info = (ActiveMQDestination)o;
+        tightMarshalString2(info.getPhysicalName(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ActiveMQDestination info = (ActiveMQDestination)o;
+        info.setPhysicalName(looseUnmarshalString(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ActiveMQDestination info = (ActiveMQDestination)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getPhysicalName(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQMapMessageMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQMapMessageMarshaller.java
new file mode 100644
index 000000000..d5c814b92
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQMapMessageMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQMapMessageMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQMapMessageMarshaller extends ActiveMQMessageMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQMapMessage.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQMapMessage();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQMessageMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQMessageMarshaller.java
new file mode 100644
index 000000000..9fa1d5e4a
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQMessageMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQMessageMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQMessageMarshaller extends MessageMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQMessage.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQMessage();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQObjectMessageMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQObjectMessageMarshaller.java
new file mode 100644
index 000000000..464f5e056
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQObjectMessageMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQObjectMessageMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQObjectMessageMarshaller extends ActiveMQMessageMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQObjectMessage.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQObjectMessage();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQQueueMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQQueueMarshaller.java
new file mode 100644
index 000000000..223589056
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQQueueMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQQueueMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQQueueMarshaller extends ActiveMQDestinationMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQQueue.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQQueue();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQStreamMessageMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQStreamMessageMarshaller.java
new file mode 100644
index 000000000..6094fed41
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQStreamMessageMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQStreamMessageMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQStreamMessageMarshaller extends ActiveMQMessageMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQStreamMessage.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQStreamMessage();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTempDestinationMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTempDestinationMarshaller.java
new file mode 100644
index 000000000..e54e47c5d
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTempDestinationMarshaller.java
@@ -0,0 +1,99 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQTempDestinationMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public abstract class ActiveMQTempDestinationMarshaller extends ActiveMQDestinationMarshaller {
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTempQueueMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTempQueueMarshaller.java
new file mode 100644
index 000000000..3e459949b
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTempQueueMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQTempQueueMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQTempQueueMarshaller extends ActiveMQTempDestinationMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQTempQueue.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQTempQueue();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTempTopicMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTempTopicMarshaller.java
new file mode 100644
index 000000000..ea8a0a64e
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTempTopicMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQTempTopicMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQTempTopicMarshaller extends ActiveMQTempDestinationMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQTempTopic.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQTempTopic();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTextMessageMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTextMessageMarshaller.java
new file mode 100644
index 000000000..d688fcd5a
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTextMessageMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQTextMessageMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQTextMessageMarshaller extends ActiveMQMessageMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQTextMessage.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQTextMessage();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTopicMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTopicMarshaller.java
new file mode 100644
index 000000000..2dd1b0b50
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ActiveMQTopicMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ActiveMQTopicMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ActiveMQTopicMarshaller extends ActiveMQDestinationMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ActiveMQTopic.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ActiveMQTopic();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BaseCommandMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BaseCommandMarshaller.java
new file mode 100644
index 000000000..ff715086e
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BaseCommandMarshaller.java
@@ -0,0 +1,118 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for BaseCommandMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public abstract class BaseCommandMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        BaseCommand info = (BaseCommand)o;
+        info.setCommandId(dataIn.readInt());
+        info.setResponseRequired(bs.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        BaseCommand info = (BaseCommand)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        bs.writeBoolean(info.isResponseRequired());
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        BaseCommand info = (BaseCommand)o;
+        dataOut.writeInt(info.getCommandId());
+        bs.readBoolean();
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        BaseCommand info = (BaseCommand)o;
+        info.setCommandId(dataIn.readInt());
+        info.setResponseRequired(dataIn.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        BaseCommand info = (BaseCommand)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        dataOut.writeInt(info.getCommandId());
+        dataOut.writeBoolean(info.isResponseRequired());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BaseDataStreamMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BaseDataStreamMarshaller.java
new file mode 100644
index 000000000..c61d16fa3
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BaseDataStreamMarshaller.java
@@ -0,0 +1,644 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import org.apache.activemq.command.DataStructure;
+import org.apache.activemq.openwire.BooleanStream;
+import org.apache.activemq.openwire.DataStreamMarshaller;
+import org.apache.activemq.openwire.OpenWireFormat;
+import org.apache.activemq.util.ByteSequence;
+
+public abstract class BaseDataStreamMarshaller implements DataStreamMarshaller {
+
+    public static final Constructor STACK_TRACE_ELEMENT_CONSTRUCTOR;
+
+    static {
+        Constructor constructor = null;
+        try {
+            constructor = StackTraceElement.class.getConstructor(new Class[] {String.class, String.class,
+                                                                              String.class, int.class});
+        } catch (Throwable e) {
+        }
+        STACK_TRACE_ELEMENT_CONSTRUCTOR = constructor;
+    }
+
+    public abstract byte getDataStructureType();
+
+    public abstract DataStructure createObject();
+
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+        return 0;
+    }
+
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs)
+        throws IOException {
+    }
+
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs)
+        throws IOException {
+    }
+
+    public int tightMarshalLong1(OpenWireFormat wireFormat, long o, BooleanStream bs) throws IOException {
+        if (o == 0) {
+            bs.writeBoolean(false);
+            bs.writeBoolean(false);
+            return 0;
+        } else if ((o & 0xFFFFFFFFFFFF0000L) == 0) {
+            bs.writeBoolean(false);
+            bs.writeBoolean(true);
+            return 2;
+        } else if ((o & 0xFFFFFFFF00000000L) == 0) {
+            bs.writeBoolean(true);
+            bs.writeBoolean(false);
+            return 4;
+        } else {
+            bs.writeBoolean(true);
+            bs.writeBoolean(true);
+            return 8;
+        }
+    }
+
+    public void tightMarshalLong2(OpenWireFormat wireFormat, long o, DataOutput dataOut, BooleanStream bs)
+        throws IOException {
+        if (bs.readBoolean()) {
+            if (bs.readBoolean()) {
+                dataOut.writeLong(o);
+            } else {
+                dataOut.writeInt((int)o);
+            }
+        } else {
+            if (bs.readBoolean()) {
+                dataOut.writeShort((int)o);
+            }
+        }
+    }
+
+    public long tightUnmarshalLong(OpenWireFormat wireFormat, DataInput dataIn, BooleanStream bs)
+        throws IOException {
+        if (bs.readBoolean()) {
+            if (bs.readBoolean()) {
+                return dataIn.readLong();
+            } else {
+                return toLong(dataIn.readInt());
+            }
+        } else {
+            if (bs.readBoolean()) {
+                return toLong(dataIn.readShort());
+            } else {
+                return 0;
+            }
+        }
+    }
+
+    protected long toLong(short value) {
+        // lets handle negative values
+        long answer = value;
+        return answer & 0xffffL;
+    }
+
+    protected long toLong(int value) {
+        // lets handle negative values
+        long answer = value;
+        return answer & 0xffffffffL;
+    }
+
+    protected DataStructure tightUnmarsalNestedObject(OpenWireFormat wireFormat, DataInput dataIn,
+                                                      BooleanStream bs) throws IOException {
+        return wireFormat.tightUnmarshalNestedObject(dataIn, bs);
+    }
+
+    protected int tightMarshalNestedObject1(OpenWireFormat wireFormat, DataStructure o, BooleanStream bs)
+        throws IOException {
+        return wireFormat.tightMarshalNestedObject1(o, bs);
+    }
+
+    protected void tightMarshalNestedObject2(OpenWireFormat wireFormat, DataStructure o, DataOutput dataOut,
+                                             BooleanStream bs) throws IOException {
+        wireFormat.tightMarshalNestedObject2(o, dataOut, bs);
+    }
+
+    protected DataStructure tightUnmarsalCachedObject(OpenWireFormat wireFormat, DataInput dataIn,
+                                                      BooleanStream bs) throws IOException {
+        if (wireFormat.isCacheEnabled()) {
+            if (bs.readBoolean()) {
+                short index = dataIn.readShort();
+                DataStructure object = wireFormat.tightUnmarshalNestedObject(dataIn, bs);
+                wireFormat.setInUnmarshallCache(index, object);
+                return object;
+            } else {
+                short index = dataIn.readShort();
+                return wireFormat.getFromUnmarshallCache(index);
+            }
+        } else {
+            return wireFormat.tightUnmarshalNestedObject(dataIn, bs);
+        }
+    }
+
+    protected int tightMarshalCachedObject1(OpenWireFormat wireFormat, DataStructure o, BooleanStream bs)
+        throws IOException {
+        if (wireFormat.isCacheEnabled()) {
+            Short index = wireFormat.getMarshallCacheIndex(o);
+            bs.writeBoolean(index == null);
+            if (index == null) {
+                int rc = wireFormat.tightMarshalNestedObject1(o, bs);
+                wireFormat.addToMarshallCache(o);
+                return 2 + rc;
+            } else {
+                return 2;
+            }
+        } else {
+            return wireFormat.tightMarshalNestedObject1(o, bs);
+        }
+    }
+
+    protected void tightMarshalCachedObject2(OpenWireFormat wireFormat, DataStructure o, DataOutput dataOut,
+                                             BooleanStream bs) throws IOException {
+        if (wireFormat.isCacheEnabled()) {
+            Short index = wireFormat.getMarshallCacheIndex(o);
+            if (bs.readBoolean()) {
+                dataOut.writeShort(index.shortValue());
+                wireFormat.tightMarshalNestedObject2(o, dataOut, bs);
+            } else {
+                dataOut.writeShort(index.shortValue());
+            }
+        } else {
+            wireFormat.tightMarshalNestedObject2(o, dataOut, bs);
+        }
+    }
+
+    protected Throwable tightUnmarsalThrowable(OpenWireFormat wireFormat, DataInput dataIn, BooleanStream bs)
+        throws IOException {
+        if (bs.readBoolean()) {
+            String clazz = tightUnmarshalString(dataIn, bs);
+            String message = tightUnmarshalString(dataIn, bs);
+            Throwable o = createThrowable(clazz, message);
+            if (wireFormat.isStackTraceEnabled()) {
+                if (STACK_TRACE_ELEMENT_CONSTRUCTOR != null) {
+                    StackTraceElement ss[] = new StackTraceElement[dataIn.readShort()];
+                    for (int i = 0; i < ss.length; i++) {
+                        try {
+                            ss[i] = (StackTraceElement)STACK_TRACE_ELEMENT_CONSTRUCTOR
+                                .newInstance(new Object[] {tightUnmarshalString(dataIn, bs),
+                                                           tightUnmarshalString(dataIn, bs),
+                                                           tightUnmarshalString(dataIn, bs),
+                                                           Integer.valueOf(dataIn.readInt())});
+                        } catch (IOException e) {
+                            throw e;
+                        } catch (Throwable e) {
+                        }
+                    }
+                    o.setStackTrace(ss);
+                } else {
+                    short size = dataIn.readShort();
+                    for (int i = 0; i < size; i++) {
+                        tightUnmarshalString(dataIn, bs);
+                        tightUnmarshalString(dataIn, bs);
+                        tightUnmarshalString(dataIn, bs);
+                        dataIn.readInt();
+                    }
+                }
+                o.initCause(tightUnmarsalThrowable(wireFormat, dataIn, bs));
+
+            }
+            return o;
+        } else {
+            return null;
+        }
+    }
+
+    private Throwable createThrowable(String className, String message) {
+        try {
+            Class clazz = Class.forName(className, false, BaseDataStreamMarshaller.class.getClassLoader());
+            Constructor constructor = clazz.getConstructor(new Class[] {String.class});
+            return (Throwable)constructor.newInstance(new Object[] {message});
+        } catch (Throwable e) {
+            return new Throwable(className + ": " + message);
+        }
+    }
+
+    protected int tightMarshalThrowable1(OpenWireFormat wireFormat, Throwable o, BooleanStream bs)
+        throws IOException {
+        if (o == null) {
+            bs.writeBoolean(false);
+            return 0;
+        } else {
+            int rc = 0;
+            bs.writeBoolean(true);
+            rc += tightMarshalString1(o.getClass().getName(), bs);
+            rc += tightMarshalString1(o.getMessage(), bs);
+            if (wireFormat.isStackTraceEnabled()) {
+                rc += 2;
+                StackTraceElement[] stackTrace = o.getStackTrace();
+                for (int i = 0; i < stackTrace.length; i++) {
+                    StackTraceElement element = stackTrace[i];
+                    rc += tightMarshalString1(element.getClassName(), bs);
+                    rc += tightMarshalString1(element.getMethodName(), bs);
+                    rc += tightMarshalString1(element.getFileName(), bs);
+                    rc += 4;
+                }
+                rc += tightMarshalThrowable1(wireFormat, o.getCause(), bs);
+            }
+            return rc;
+        }
+    }
+
+    protected void tightMarshalThrowable2(OpenWireFormat wireFormat, Throwable o, DataOutput dataOut,
+                                          BooleanStream bs) throws IOException {
+        if (bs.readBoolean()) {
+            tightMarshalString2(o.getClass().getName(), dataOut, bs);
+            tightMarshalString2(o.getMessage(), dataOut, bs);
+            if (wireFormat.isStackTraceEnabled()) {
+                StackTraceElement[] stackTrace = o.getStackTrace();
+                dataOut.writeShort(stackTrace.length);
+                for (int i = 0; i < stackTrace.length; i++) {
+                    StackTraceElement element = stackTrace[i];
+                    tightMarshalString2(element.getClassName(), dataOut, bs);
+                    tightMarshalString2(element.getMethodName(), dataOut, bs);
+                    tightMarshalString2(element.getFileName(), dataOut, bs);
+                    dataOut.writeInt(element.getLineNumber());
+                }
+                tightMarshalThrowable2(wireFormat, o.getCause(), dataOut, bs);
+            }
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    protected String tightUnmarshalString(DataInput dataIn, BooleanStream bs) throws IOException {
+        if (bs.readBoolean()) {
+            if (bs.readBoolean()) {
+                int size = dataIn.readShort();
+                byte data[] = new byte[size];
+                dataIn.readFully(data);
+                // Yes deprecated, but we know what we are doing.
+                // This allows us to create a String from a ASCII byte array. (no UTF-8 decoding)
+                return new String(data, 0);
+            } else {
+                return dataIn.readUTF();
+            }
+        } else {
+            return null;
+        }
+    }
+
+    protected int tightMarshalString1(String value, BooleanStream bs) throws IOException {
+        bs.writeBoolean(value != null);
+        if (value != null) {
+
+            int strlen = value.length();
+            int utflen = 0;
+            char[] charr = new char[strlen];
+            int c = 0;
+            boolean isOnlyAscii = true;
+
+            value.getChars(0, strlen, charr, 0);
+
+            for (int i = 0; i < strlen; i++) {
+                c = charr[i];
+                if ((c >= 0x0001) && (c <= 0x007F)) {
+                    utflen++;
+                } else if (c > 0x07FF) {
+                    utflen += 3;
+                    isOnlyAscii = false;
+                } else {
+                    isOnlyAscii = false;
+                    utflen += 2;
+                }
+            }
+
+            if (utflen >= Short.MAX_VALUE) {
+                throw new IOException("Encountered a String value that is too long to encode.");
+            }
+            bs.writeBoolean(isOnlyAscii);
+            return utflen + 2;
+
+        } else {
+            return 0;
+        }
+    }
+
+    protected void tightMarshalString2(String value, DataOutput dataOut, BooleanStream bs) throws IOException {
+        if (bs.readBoolean()) {
+            // If we verified it only holds ascii values
+            if (bs.readBoolean()) {
+                dataOut.writeShort(value.length());
+                dataOut.writeBytes(value);
+            } else {
+                dataOut.writeUTF(value);
+            }
+        }
+    }
+
+    protected int tightMarshalObjectArray1(OpenWireFormat wireFormat, DataStructure[] objects,
+                                           BooleanStream bs) throws IOException {
+        if (objects != null) {
+            int rc = 0;
+            bs.writeBoolean(true);
+            rc += 2;
+            for (int i = 0; i < objects.length; i++) {
+                rc += tightMarshalNestedObject1(wireFormat, objects[i], bs);
+            }
+            return rc;
+        } else {
+            bs.writeBoolean(false);
+            return 0;
+        }
+    }
+
+    protected void tightMarshalObjectArray2(OpenWireFormat wireFormat, DataStructure[] objects,
+                                            DataOutput dataOut, BooleanStream bs) throws IOException {
+        if (bs.readBoolean()) {
+            dataOut.writeShort(objects.length);
+            for (int i = 0; i < objects.length; i++) {
+                tightMarshalNestedObject2(wireFormat, objects[i], dataOut, bs);
+            }
+        }
+    }
+
+    protected int tightMarshalConstByteArray1(byte[] data, BooleanStream bs, int i) throws IOException {
+        return i;
+    }
+
+    protected void tightMarshalConstByteArray2(byte[] data, DataOutput dataOut, BooleanStream bs, int i)
+        throws IOException {
+        dataOut.write(data, 0, i);
+    }
+
+    protected byte[] tightUnmarshalConstByteArray(DataInput dataIn, BooleanStream bs, int i)
+        throws IOException {
+        byte data[] = new byte[i];
+        dataIn.readFully(data);
+        return data;
+    }
+
+    protected int tightMarshalByteArray1(byte[] data, BooleanStream bs) throws IOException {
+        bs.writeBoolean(data != null);
+        if (data != null) {
+            return data.length + 4;
+        } else {
+            return 0;
+        }
+    }
+
+    protected void tightMarshalByteArray2(byte[] data, DataOutput dataOut, BooleanStream bs)
+        throws IOException {
+        if (bs.readBoolean()) {
+            dataOut.writeInt(data.length);
+            dataOut.write(data);
+        }
+    }
+
+    protected byte[] tightUnmarshalByteArray(DataInput dataIn, BooleanStream bs) throws IOException {
+        byte rc[] = null;
+        if (bs.readBoolean()) {
+            int size = dataIn.readInt();
+            rc = new byte[size];
+            dataIn.readFully(rc);
+        }
+        return rc;
+    }
+
+    protected int tightMarshalByteSequence1(ByteSequence data, BooleanStream bs) throws IOException {
+        bs.writeBoolean(data != null);
+        if (data != null) {
+            return data.getLength() + 4;
+        } else {
+            return 0;
+        }
+    }
+
+    protected void tightMarshalByteSequence2(ByteSequence data, DataOutput dataOut, BooleanStream bs)
+        throws IOException {
+        if (bs.readBoolean()) {
+            dataOut.writeInt(data.getLength());
+            dataOut.write(data.getData(), data.getOffset(), data.getLength());
+        }
+    }
+
+    protected ByteSequence tightUnmarshalByteSequence(DataInput dataIn, BooleanStream bs) throws IOException {
+        ByteSequence rc = null;
+        if (bs.readBoolean()) {
+            int size = dataIn.readInt();
+            byte[] t = new byte[size];
+            dataIn.readFully(t);
+            return new ByteSequence(t, 0, size);
+        }
+        return rc;
+    }
+
+    //
+    // The loose marshaling logic
+    //
+
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+    }
+
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+    }
+
+    public void looseMarshalLong(OpenWireFormat wireFormat, long o, DataOutput dataOut) throws IOException {
+        dataOut.writeLong(o);
+    }
+
+    public long looseUnmarshalLong(OpenWireFormat wireFormat, DataInput dataIn) throws IOException {
+        return dataIn.readLong();
+    }
+
+    protected DataStructure looseUnmarsalNestedObject(OpenWireFormat wireFormat, DataInput dataIn)
+        throws IOException {
+        return wireFormat.looseUnmarshalNestedObject(dataIn);
+    }
+
+    protected void looseMarshalNestedObject(OpenWireFormat wireFormat, DataStructure o, DataOutput dataOut)
+        throws IOException {
+        wireFormat.looseMarshalNestedObject(o, dataOut);
+    }
+
+    protected DataStructure looseUnmarsalCachedObject(OpenWireFormat wireFormat, DataInput dataIn)
+        throws IOException {
+        if (wireFormat.isCacheEnabled()) {
+            if (dataIn.readBoolean()) {
+                short index = dataIn.readShort();
+                DataStructure object = wireFormat.looseUnmarshalNestedObject(dataIn);
+                wireFormat.setInUnmarshallCache(index, object);
+                return object;
+            } else {
+                short index = dataIn.readShort();
+                return wireFormat.getFromUnmarshallCache(index);
+            }
+        } else {
+            return wireFormat.looseUnmarshalNestedObject(dataIn);
+        }
+    }
+
+    protected void looseMarshalCachedObject(OpenWireFormat wireFormat, DataStructure o, DataOutput dataOut)
+        throws IOException {
+        if (wireFormat.isCacheEnabled()) {
+            Short index = wireFormat.getMarshallCacheIndex(o);
+            dataOut.writeBoolean(index == null);
+            if (index == null) {
+                index = wireFormat.addToMarshallCache(o);
+                dataOut.writeShort(index.shortValue());
+                wireFormat.looseMarshalNestedObject(o, dataOut);
+            } else {
+                dataOut.writeShort(index.shortValue());
+            }
+        } else {
+            wireFormat.looseMarshalNestedObject(o, dataOut);
+        }
+    }
+
+    protected Throwable looseUnmarsalThrowable(OpenWireFormat wireFormat, DataInput dataIn)
+        throws IOException {
+        if (dataIn.readBoolean()) {
+            String clazz = looseUnmarshalString(dataIn);
+            String message = looseUnmarshalString(dataIn);
+            Throwable o = createThrowable(clazz, message);
+            if (wireFormat.isStackTraceEnabled()) {
+                if (STACK_TRACE_ELEMENT_CONSTRUCTOR != null) {
+                    StackTraceElement ss[] = new StackTraceElement[dataIn.readShort()];
+                    for (int i = 0; i < ss.length; i++) {
+                        try {
+                            ss[i] = (StackTraceElement)STACK_TRACE_ELEMENT_CONSTRUCTOR
+                                .newInstance(new Object[] {looseUnmarshalString(dataIn),
+                                                           looseUnmarshalString(dataIn),
+                                                           looseUnmarshalString(dataIn),
+                                                           Integer.valueOf(dataIn.readInt())});
+                        } catch (IOException e) {
+                            throw e;
+                        } catch (Throwable e) {
+                        }
+                    }
+                    o.setStackTrace(ss);
+                } else {
+                    short size = dataIn.readShort();
+                    for (int i = 0; i < size; i++) {
+                        looseUnmarshalString(dataIn);
+                        looseUnmarshalString(dataIn);
+                        looseUnmarshalString(dataIn);
+                        dataIn.readInt();
+                    }
+                }
+                o.initCause(looseUnmarsalThrowable(wireFormat, dataIn));
+
+            }
+            return o;
+        } else {
+            return null;
+        }
+    }
+
+    protected void looseMarshalThrowable(OpenWireFormat wireFormat, Throwable o, DataOutput dataOut)
+        throws IOException {
+        dataOut.writeBoolean(o != null);
+        if (o != null) {
+            looseMarshalString(o.getClass().getName(), dataOut);
+            looseMarshalString(o.getMessage(), dataOut);
+            if (wireFormat.isStackTraceEnabled()) {
+                StackTraceElement[] stackTrace = o.getStackTrace();
+                dataOut.writeShort(stackTrace.length);
+                for (int i = 0; i < stackTrace.length; i++) {
+                    StackTraceElement element = stackTrace[i];
+                    looseMarshalString(element.getClassName(), dataOut);
+                    looseMarshalString(element.getMethodName(), dataOut);
+                    looseMarshalString(element.getFileName(), dataOut);
+                    dataOut.writeInt(element.getLineNumber());
+                }
+                looseMarshalThrowable(wireFormat, o.getCause(), dataOut);
+            }
+        }
+    }
+
+    protected String looseUnmarshalString(DataInput dataIn) throws IOException {
+        if (dataIn.readBoolean()) {
+            return dataIn.readUTF();
+        } else {
+            return null;
+        }
+    }
+
+    protected void looseMarshalString(String value, DataOutput dataOut) throws IOException {
+        dataOut.writeBoolean(value != null);
+        if (value != null) {
+            dataOut.writeUTF(value);
+        }
+    }
+
+    protected void looseMarshalObjectArray(OpenWireFormat wireFormat, DataStructure[] objects,
+                                           DataOutput dataOut) throws IOException {
+        dataOut.writeBoolean(objects != null);
+        if (objects != null) {
+            dataOut.writeShort(objects.length);
+            for (int i = 0; i < objects.length; i++) {
+                looseMarshalNestedObject(wireFormat, objects[i], dataOut);
+            }
+        }
+    }
+
+    protected void looseMarshalConstByteArray(OpenWireFormat wireFormat, byte[] data, DataOutput dataOut,
+                                              int i) throws IOException {
+        dataOut.write(data, 0, i);
+    }
+
+    protected byte[] looseUnmarshalConstByteArray(DataInput dataIn, int i) throws IOException {
+        byte data[] = new byte[i];
+        dataIn.readFully(data);
+        return data;
+    }
+
+    protected void looseMarshalByteArray(OpenWireFormat wireFormat, byte[] data, DataOutput dataOut)
+        throws IOException {
+        dataOut.writeBoolean(data != null);
+        if (data != null) {
+            dataOut.writeInt(data.length);
+            dataOut.write(data);
+        }
+    }
+
+    protected byte[] looseUnmarshalByteArray(DataInput dataIn) throws IOException {
+        byte rc[] = null;
+        if (dataIn.readBoolean()) {
+            int size = dataIn.readInt();
+            rc = new byte[size];
+            dataIn.readFully(rc);
+        }
+        return rc;
+    }
+
+    protected void looseMarshalByteSequence(OpenWireFormat wireFormat, ByteSequence data, DataOutput dataOut)
+        throws IOException {
+        dataOut.writeBoolean(data != null);
+        if (data != null) {
+            dataOut.writeInt(data.getLength());
+            dataOut.write(data.getData(), data.getOffset(), data.getLength());
+        }
+    }
+
+    protected ByteSequence looseUnmarshalByteSequence(DataInput dataIn) throws IOException {
+        ByteSequence rc = null;
+        if (dataIn.readBoolean()) {
+            int size = dataIn.readInt();
+            byte[] t = new byte[size];
+            dataIn.readFully(t);
+            rc = new ByteSequence(t, 0, size);
+        }
+        return rc;
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BrokerIdMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BrokerIdMarshaller.java
new file mode 100644
index 000000000..ac05dbcb8
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BrokerIdMarshaller.java
@@ -0,0 +1,129 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for BrokerIdMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class BrokerIdMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return BrokerId.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new BrokerId();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        BrokerId info = (BrokerId)o;
+        info.setValue(tightUnmarshalString(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        BrokerId info = (BrokerId)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getValue(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        BrokerId info = (BrokerId)o;
+        tightMarshalString2(info.getValue(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        BrokerId info = (BrokerId)o;
+        info.setValue(looseUnmarshalString(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        BrokerId info = (BrokerId)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getValue(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BrokerInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BrokerInfoMarshaller.java
new file mode 100644
index 000000000..411779290
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/BrokerInfoMarshaller.java
@@ -0,0 +1,206 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for BrokerInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class BrokerInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return BrokerInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new BrokerInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        BrokerInfo info = (BrokerInfo)o;
+        info.setBrokerId((org.apache.activemq.command.BrokerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setBrokerURL(tightUnmarshalString(dataIn, bs));
+
+        if (bs.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerInfo value[] = new org.apache.activemq.command.BrokerInfo[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerInfo) tightUnmarsalNestedObject(wireFormat,dataIn, bs);
+            }
+            info.setPeerBrokerInfos(value);
+        }
+        else {
+            info.setPeerBrokerInfos(null);
+        }
+        info.setBrokerName(tightUnmarshalString(dataIn, bs));
+        info.setSlaveBroker(bs.readBoolean());
+        info.setMasterBroker(bs.readBoolean());
+        info.setFaultTolerantConfiguration(bs.readBoolean());
+        info.setDuplexConnection(bs.readBoolean());
+        info.setNetworkConnection(bs.readBoolean());
+        info.setConnectionId(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setBrokerUploadUrl(tightUnmarshalString(dataIn, bs));
+        info.setNetworkProperties(tightUnmarshalString(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        BrokerInfo info = (BrokerInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getBrokerId(), bs);
+        rc += tightMarshalString1(info.getBrokerURL(), bs);
+        rc += tightMarshalObjectArray1(wireFormat, info.getPeerBrokerInfos(), bs);
+        rc += tightMarshalString1(info.getBrokerName(), bs);
+        bs.writeBoolean(info.isSlaveBroker());
+        bs.writeBoolean(info.isMasterBroker());
+        bs.writeBoolean(info.isFaultTolerantConfiguration());
+        bs.writeBoolean(info.isDuplexConnection());
+        bs.writeBoolean(info.isNetworkConnection());
+        rc+=tightMarshalLong1(wireFormat, info.getConnectionId(), bs);
+        rc += tightMarshalString1(info.getBrokerUploadUrl(), bs);
+        rc += tightMarshalString1(info.getNetworkProperties(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        BrokerInfo info = (BrokerInfo)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getBrokerId(), dataOut, bs);
+        tightMarshalString2(info.getBrokerURL(), dataOut, bs);
+        tightMarshalObjectArray2(wireFormat, info.getPeerBrokerInfos(), dataOut, bs);
+        tightMarshalString2(info.getBrokerName(), dataOut, bs);
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        tightMarshalLong2(wireFormat, info.getConnectionId(), dataOut, bs);
+        tightMarshalString2(info.getBrokerUploadUrl(), dataOut, bs);
+        tightMarshalString2(info.getNetworkProperties(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        BrokerInfo info = (BrokerInfo)o;
+        info.setBrokerId((org.apache.activemq.command.BrokerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setBrokerURL(looseUnmarshalString(dataIn));
+
+        if (dataIn.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerInfo value[] = new org.apache.activemq.command.BrokerInfo[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerInfo) looseUnmarsalNestedObject(wireFormat,dataIn);
+            }
+            info.setPeerBrokerInfos(value);
+        }
+        else {
+            info.setPeerBrokerInfos(null);
+        }
+        info.setBrokerName(looseUnmarshalString(dataIn));
+        info.setSlaveBroker(dataIn.readBoolean());
+        info.setMasterBroker(dataIn.readBoolean());
+        info.setFaultTolerantConfiguration(dataIn.readBoolean());
+        info.setDuplexConnection(dataIn.readBoolean());
+        info.setNetworkConnection(dataIn.readBoolean());
+        info.setConnectionId(looseUnmarshalLong(wireFormat, dataIn));
+        info.setBrokerUploadUrl(looseUnmarshalString(dataIn));
+        info.setNetworkProperties(looseUnmarshalString(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        BrokerInfo info = (BrokerInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getBrokerId(), dataOut);
+        looseMarshalString(info.getBrokerURL(), dataOut);
+        looseMarshalObjectArray(wireFormat, info.getPeerBrokerInfos(), dataOut);
+        looseMarshalString(info.getBrokerName(), dataOut);
+        dataOut.writeBoolean(info.isSlaveBroker());
+        dataOut.writeBoolean(info.isMasterBroker());
+        dataOut.writeBoolean(info.isFaultTolerantConfiguration());
+        dataOut.writeBoolean(info.isDuplexConnection());
+        dataOut.writeBoolean(info.isNetworkConnection());
+        looseMarshalLong(wireFormat, info.getConnectionId(), dataOut);
+        looseMarshalString(info.getBrokerUploadUrl(), dataOut);
+        looseMarshalString(info.getNetworkProperties(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionControlMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionControlMarshaller.java
new file mode 100644
index 000000000..2a5a0cc0c
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionControlMarshaller.java
@@ -0,0 +1,169 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ConnectionControlMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ConnectionControlMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ConnectionControl.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ConnectionControl();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ConnectionControl info = (ConnectionControl)o;
+        info.setClose(bs.readBoolean());
+        info.setExit(bs.readBoolean());
+        info.setFaultTolerant(bs.readBoolean());
+        info.setResume(bs.readBoolean());
+        info.setSuspend(bs.readBoolean());
+        info.setConnectedBrokers(tightUnmarshalString(dataIn, bs));
+        info.setReconnectTo(tightUnmarshalString(dataIn, bs));
+        info.setRebalanceConnection(bs.readBoolean());
+        info.setToken(tightUnmarshalByteArray(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ConnectionControl info = (ConnectionControl)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        bs.writeBoolean(info.isClose());
+        bs.writeBoolean(info.isExit());
+        bs.writeBoolean(info.isFaultTolerant());
+        bs.writeBoolean(info.isResume());
+        bs.writeBoolean(info.isSuspend());
+        rc += tightMarshalString1(info.getConnectedBrokers(), bs);
+        rc += tightMarshalString1(info.getReconnectTo(), bs);
+        bs.writeBoolean(info.isRebalanceConnection());
+        rc += tightMarshalByteArray1(info.getToken(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ConnectionControl info = (ConnectionControl)o;
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        tightMarshalString2(info.getConnectedBrokers(), dataOut, bs);
+        tightMarshalString2(info.getReconnectTo(), dataOut, bs);
+        bs.readBoolean();
+        tightMarshalByteArray2(info.getToken(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ConnectionControl info = (ConnectionControl)o;
+        info.setClose(dataIn.readBoolean());
+        info.setExit(dataIn.readBoolean());
+        info.setFaultTolerant(dataIn.readBoolean());
+        info.setResume(dataIn.readBoolean());
+        info.setSuspend(dataIn.readBoolean());
+        info.setConnectedBrokers(looseUnmarshalString(dataIn));
+        info.setReconnectTo(looseUnmarshalString(dataIn));
+        info.setRebalanceConnection(dataIn.readBoolean());
+        info.setToken(looseUnmarshalByteArray(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ConnectionControl info = (ConnectionControl)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        dataOut.writeBoolean(info.isClose());
+        dataOut.writeBoolean(info.isExit());
+        dataOut.writeBoolean(info.isFaultTolerant());
+        dataOut.writeBoolean(info.isResume());
+        dataOut.writeBoolean(info.isSuspend());
+        looseMarshalString(info.getConnectedBrokers(), dataOut);
+        looseMarshalString(info.getReconnectTo(), dataOut);
+        dataOut.writeBoolean(info.isRebalanceConnection());
+        looseMarshalByteArray(wireFormat, info.getToken(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionErrorMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionErrorMarshaller.java
new file mode 100644
index 000000000..0d50525ee
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionErrorMarshaller.java
@@ -0,0 +1,134 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ConnectionErrorMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ConnectionErrorMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ConnectionError.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ConnectionError();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ConnectionError info = (ConnectionError)o;
+        info.setException((java.lang.Throwable) tightUnmarsalThrowable(wireFormat, dataIn, bs));
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ConnectionError info = (ConnectionError)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalThrowable1(wireFormat, info.getException(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getConnectionId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ConnectionError info = (ConnectionError)o;
+        tightMarshalThrowable2(wireFormat, info.getException(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getConnectionId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ConnectionError info = (ConnectionError)o;
+        info.setException((java.lang.Throwable) looseUnmarsalThrowable(wireFormat, dataIn));
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) looseUnmarsalNestedObject(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ConnectionError info = (ConnectionError)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalThrowable(wireFormat, info.getException(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getConnectionId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionIdMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionIdMarshaller.java
new file mode 100644
index 000000000..3e9116ba3
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionIdMarshaller.java
@@ -0,0 +1,129 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ConnectionIdMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ConnectionIdMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ConnectionId.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ConnectionId();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ConnectionId info = (ConnectionId)o;
+        info.setValue(tightUnmarshalString(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ConnectionId info = (ConnectionId)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getValue(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ConnectionId info = (ConnectionId)o;
+        tightMarshalString2(info.getValue(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ConnectionId info = (ConnectionId)o;
+        info.setValue(looseUnmarshalString(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ConnectionId info = (ConnectionId)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getValue(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionInfoMarshaller.java
new file mode 100644
index 000000000..35b73bcf9
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConnectionInfoMarshaller.java
@@ -0,0 +1,201 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ConnectionInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ConnectionInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ConnectionInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ConnectionInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ConnectionInfo info = (ConnectionInfo)o;
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setClientId(tightUnmarshalString(dataIn, bs));
+        info.setPassword(tightUnmarshalString(dataIn, bs));
+        info.setUserName(tightUnmarshalString(dataIn, bs));
+
+        if (bs.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) tightUnmarsalNestedObject(wireFormat,dataIn, bs);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+        info.setBrokerMasterConnector(bs.readBoolean());
+        info.setManageable(bs.readBoolean());
+        info.setClientMaster(bs.readBoolean());
+        info.setFaultTolerant(bs.readBoolean());
+        info.setFailoverReconnect(bs.readBoolean());
+        info.setClientIp(tightUnmarshalString(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ConnectionInfo info = (ConnectionInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConnectionId(), bs);
+        rc += tightMarshalString1(info.getClientId(), bs);
+        rc += tightMarshalString1(info.getPassword(), bs);
+        rc += tightMarshalString1(info.getUserName(), bs);
+        rc += tightMarshalObjectArray1(wireFormat, info.getBrokerPath(), bs);
+        bs.writeBoolean(info.isBrokerMasterConnector());
+        bs.writeBoolean(info.isManageable());
+        bs.writeBoolean(info.isClientMaster());
+        bs.writeBoolean(info.isFaultTolerant());
+        bs.writeBoolean(info.isFailoverReconnect());
+        rc += tightMarshalString1(info.getClientIp(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ConnectionInfo info = (ConnectionInfo)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConnectionId(), dataOut, bs);
+        tightMarshalString2(info.getClientId(), dataOut, bs);
+        tightMarshalString2(info.getPassword(), dataOut, bs);
+        tightMarshalString2(info.getUserName(), dataOut, bs);
+        tightMarshalObjectArray2(wireFormat, info.getBrokerPath(), dataOut, bs);
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        tightMarshalString2(info.getClientIp(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ConnectionInfo info = (ConnectionInfo)o;
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setClientId(looseUnmarshalString(dataIn));
+        info.setPassword(looseUnmarshalString(dataIn));
+        info.setUserName(looseUnmarshalString(dataIn));
+
+        if (dataIn.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) looseUnmarsalNestedObject(wireFormat,dataIn);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+        info.setBrokerMasterConnector(dataIn.readBoolean());
+        info.setManageable(dataIn.readBoolean());
+        info.setClientMaster(dataIn.readBoolean());
+        info.setFaultTolerant(dataIn.readBoolean());
+        info.setFailoverReconnect(dataIn.readBoolean());
+        info.setClientIp(looseUnmarshalString(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ConnectionInfo info = (ConnectionInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConnectionId(), dataOut);
+        looseMarshalString(info.getClientId(), dataOut);
+        looseMarshalString(info.getPassword(), dataOut);
+        looseMarshalString(info.getUserName(), dataOut);
+        looseMarshalObjectArray(wireFormat, info.getBrokerPath(), dataOut);
+        dataOut.writeBoolean(info.isBrokerMasterConnector());
+        dataOut.writeBoolean(info.isManageable());
+        dataOut.writeBoolean(info.isClientMaster());
+        dataOut.writeBoolean(info.isFaultTolerant());
+        dataOut.writeBoolean(info.isFailoverReconnect());
+        looseMarshalString(info.getClientIp(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConsumerControlMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConsumerControlMarshaller.java
new file mode 100644
index 000000000..3408d1de5
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConsumerControlMarshaller.java
@@ -0,0 +1,158 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ConsumerControlMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ConsumerControlMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ConsumerControl.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ConsumerControl();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ConsumerControl info = (ConsumerControl)o;
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setClose(bs.readBoolean());
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setPrefetch(dataIn.readInt());
+        info.setFlush(bs.readBoolean());
+        info.setStart(bs.readBoolean());
+        info.setStop(bs.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ConsumerControl info = (ConsumerControl)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        bs.writeBoolean(info.isClose());
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getConsumerId(), bs);
+        bs.writeBoolean(info.isFlush());
+        bs.writeBoolean(info.isStart());
+        bs.writeBoolean(info.isStop());
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ConsumerControl info = (ConsumerControl)o;
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        bs.readBoolean();
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getConsumerId(), dataOut, bs);
+        dataOut.writeInt(info.getPrefetch());
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ConsumerControl info = (ConsumerControl)o;
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setClose(dataIn.readBoolean());
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setPrefetch(dataIn.readInt());
+        info.setFlush(dataIn.readBoolean());
+        info.setStart(dataIn.readBoolean());
+        info.setStop(dataIn.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ConsumerControl info = (ConsumerControl)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        dataOut.writeBoolean(info.isClose());
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getConsumerId(), dataOut);
+        dataOut.writeInt(info.getPrefetch());
+        dataOut.writeBoolean(info.isFlush());
+        dataOut.writeBoolean(info.isStart());
+        dataOut.writeBoolean(info.isStop());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConsumerIdMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConsumerIdMarshaller.java
new file mode 100644
index 000000000..d7cae0d52
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConsumerIdMarshaller.java
@@ -0,0 +1,139 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ConsumerIdMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ConsumerIdMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ConsumerId.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ConsumerId();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ConsumerId info = (ConsumerId)o;
+        info.setConnectionId(tightUnmarshalString(dataIn, bs));
+        info.setSessionId(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setValue(tightUnmarshalLong(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ConsumerId info = (ConsumerId)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getConnectionId(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getSessionId(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getValue(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ConsumerId info = (ConsumerId)o;
+        tightMarshalString2(info.getConnectionId(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getSessionId(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getValue(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ConsumerId info = (ConsumerId)o;
+        info.setConnectionId(looseUnmarshalString(dataIn));
+        info.setSessionId(looseUnmarshalLong(wireFormat, dataIn));
+        info.setValue(looseUnmarshalLong(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ConsumerId info = (ConsumerId)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getConnectionId(), dataOut);
+        looseMarshalLong(wireFormat, info.getSessionId(), dataOut);
+        looseMarshalLong(wireFormat, info.getValue(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConsumerInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConsumerInfoMarshaller.java
new file mode 100644
index 000000000..26cf14cdb
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ConsumerInfoMarshaller.java
@@ -0,0 +1,260 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ConsumerInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ConsumerInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ConsumerInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ConsumerInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ConsumerInfo info = (ConsumerInfo)o;
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setBrowser(bs.readBoolean());
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setPrefetchSize(dataIn.readInt());
+        info.setMaximumPendingMessageLimit(dataIn.readInt());
+        info.setDispatchAsync(bs.readBoolean());
+        info.setSelector(tightUnmarshalString(dataIn, bs));
+        info.setClientId(tightUnmarshalString(dataIn, bs));
+        info.setSubscriptionName(tightUnmarshalString(dataIn, bs));
+        info.setNoLocal(bs.readBoolean());
+        info.setExclusive(bs.readBoolean());
+        info.setRetroactive(bs.readBoolean());
+        info.setPriority(dataIn.readByte());
+
+        if (bs.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) tightUnmarsalNestedObject(wireFormat,dataIn, bs);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+        info.setAdditionalPredicate((org.apache.activemq.filter.BooleanExpression) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setNetworkSubscription(bs.readBoolean());
+        info.setOptimizedAcknowledge(bs.readBoolean());
+        info.setNoRangeAcks(bs.readBoolean());
+
+        if (bs.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.ConsumerId value[] = new org.apache.activemq.command.ConsumerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.ConsumerId) tightUnmarsalNestedObject(wireFormat,dataIn, bs);
+            }
+            info.setNetworkConsumerPath(value);
+        }
+        else {
+            info.setNetworkConsumerPath(null);
+        }
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ConsumerInfo info = (ConsumerInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConsumerId(), bs);
+        bs.writeBoolean(info.isBrowser());
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        bs.writeBoolean(info.isDispatchAsync());
+        rc += tightMarshalString1(info.getSelector(), bs);
+        rc += tightMarshalString1(info.getClientId(), bs);
+        rc += tightMarshalString1(info.getSubscriptionName(), bs);
+        bs.writeBoolean(info.isNoLocal());
+        bs.writeBoolean(info.isExclusive());
+        bs.writeBoolean(info.isRetroactive());
+        rc += tightMarshalObjectArray1(wireFormat, info.getBrokerPath(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getAdditionalPredicate(), bs);
+        bs.writeBoolean(info.isNetworkSubscription());
+        bs.writeBoolean(info.isOptimizedAcknowledge());
+        bs.writeBoolean(info.isNoRangeAcks());
+        rc += tightMarshalObjectArray1(wireFormat, info.getNetworkConsumerPath(), bs);
+
+        return rc + 9;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ConsumerInfo info = (ConsumerInfo)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConsumerId(), dataOut, bs);
+        bs.readBoolean();
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        dataOut.writeInt(info.getPrefetchSize());
+        dataOut.writeInt(info.getMaximumPendingMessageLimit());
+        bs.readBoolean();
+        tightMarshalString2(info.getSelector(), dataOut, bs);
+        tightMarshalString2(info.getClientId(), dataOut, bs);
+        tightMarshalString2(info.getSubscriptionName(), dataOut, bs);
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        dataOut.writeByte(info.getPriority());
+        tightMarshalObjectArray2(wireFormat, info.getBrokerPath(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getAdditionalPredicate(), dataOut, bs);
+        bs.readBoolean();
+        bs.readBoolean();
+        bs.readBoolean();
+        tightMarshalObjectArray2(wireFormat, info.getNetworkConsumerPath(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ConsumerInfo info = (ConsumerInfo)o;
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setBrowser(dataIn.readBoolean());
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setPrefetchSize(dataIn.readInt());
+        info.setMaximumPendingMessageLimit(dataIn.readInt());
+        info.setDispatchAsync(dataIn.readBoolean());
+        info.setSelector(looseUnmarshalString(dataIn));
+        info.setClientId(looseUnmarshalString(dataIn));
+        info.setSubscriptionName(looseUnmarshalString(dataIn));
+        info.setNoLocal(dataIn.readBoolean());
+        info.setExclusive(dataIn.readBoolean());
+        info.setRetroactive(dataIn.readBoolean());
+        info.setPriority(dataIn.readByte());
+
+        if (dataIn.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) looseUnmarsalNestedObject(wireFormat,dataIn);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+        info.setAdditionalPredicate((org.apache.activemq.filter.BooleanExpression) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setNetworkSubscription(dataIn.readBoolean());
+        info.setOptimizedAcknowledge(dataIn.readBoolean());
+        info.setNoRangeAcks(dataIn.readBoolean());
+
+        if (dataIn.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.ConsumerId value[] = new org.apache.activemq.command.ConsumerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.ConsumerId) looseUnmarsalNestedObject(wireFormat,dataIn);
+            }
+            info.setNetworkConsumerPath(value);
+        }
+        else {
+            info.setNetworkConsumerPath(null);
+        }
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ConsumerInfo info = (ConsumerInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConsumerId(), dataOut);
+        dataOut.writeBoolean(info.isBrowser());
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        dataOut.writeInt(info.getPrefetchSize());
+        dataOut.writeInt(info.getMaximumPendingMessageLimit());
+        dataOut.writeBoolean(info.isDispatchAsync());
+        looseMarshalString(info.getSelector(), dataOut);
+        looseMarshalString(info.getClientId(), dataOut);
+        looseMarshalString(info.getSubscriptionName(), dataOut);
+        dataOut.writeBoolean(info.isNoLocal());
+        dataOut.writeBoolean(info.isExclusive());
+        dataOut.writeBoolean(info.isRetroactive());
+        dataOut.writeByte(info.getPriority());
+        looseMarshalObjectArray(wireFormat, info.getBrokerPath(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getAdditionalPredicate(), dataOut);
+        dataOut.writeBoolean(info.isNetworkSubscription());
+        dataOut.writeBoolean(info.isOptimizedAcknowledge());
+        dataOut.writeBoolean(info.isNoRangeAcks());
+        looseMarshalObjectArray(wireFormat, info.getNetworkConsumerPath(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ControlCommandMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ControlCommandMarshaller.java
new file mode 100644
index 000000000..b811995cd
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ControlCommandMarshaller.java
@@ -0,0 +1,129 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ControlCommandMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ControlCommandMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ControlCommand.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ControlCommand();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ControlCommand info = (ControlCommand)o;
+        info.setCommand(tightUnmarshalString(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ControlCommand info = (ControlCommand)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getCommand(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ControlCommand info = (ControlCommand)o;
+        tightMarshalString2(info.getCommand(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ControlCommand info = (ControlCommand)o;
+        info.setCommand(looseUnmarshalString(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ControlCommand info = (ControlCommand)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getCommand(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DataArrayResponseMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DataArrayResponseMarshaller.java
new file mode 100644
index 000000000..867b8bbe4
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DataArrayResponseMarshaller.java
@@ -0,0 +1,151 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for DataArrayResponseMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class DataArrayResponseMarshaller extends ResponseMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return DataArrayResponse.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new DataArrayResponse();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        DataArrayResponse info = (DataArrayResponse)o;
+
+        if (bs.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.DataStructure value[] = new org.apache.activemq.command.DataStructure[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.DataStructure) tightUnmarsalNestedObject(wireFormat,dataIn, bs);
+            }
+            info.setData(value);
+        }
+        else {
+            info.setData(null);
+        }
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        DataArrayResponse info = (DataArrayResponse)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalObjectArray1(wireFormat, info.getData(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        DataArrayResponse info = (DataArrayResponse)o;
+        tightMarshalObjectArray2(wireFormat, info.getData(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        DataArrayResponse info = (DataArrayResponse)o;
+
+        if (dataIn.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.DataStructure value[] = new org.apache.activemq.command.DataStructure[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.DataStructure) looseUnmarsalNestedObject(wireFormat,dataIn);
+            }
+            info.setData(value);
+        }
+        else {
+            info.setData(null);
+        }
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        DataArrayResponse info = (DataArrayResponse)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalObjectArray(wireFormat, info.getData(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DataResponseMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DataResponseMarshaller.java
new file mode 100644
index 000000000..b62d53798
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DataResponseMarshaller.java
@@ -0,0 +1,129 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for DataResponseMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class DataResponseMarshaller extends ResponseMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return DataResponse.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new DataResponse();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        DataResponse info = (DataResponse)o;
+        info.setData((org.apache.activemq.command.DataStructure) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        DataResponse info = (DataResponse)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getData(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        DataResponse info = (DataResponse)o;
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getData(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        DataResponse info = (DataResponse)o;
+        info.setData((org.apache.activemq.command.DataStructure) looseUnmarsalNestedObject(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        DataResponse info = (DataResponse)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getData(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DestinationInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DestinationInfoMarshaller.java
new file mode 100644
index 000000000..81686767f
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DestinationInfoMarshaller.java
@@ -0,0 +1,170 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for DestinationInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class DestinationInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return DestinationInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new DestinationInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        DestinationInfo info = (DestinationInfo)o;
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setOperationType(dataIn.readByte());
+        info.setTimeout(tightUnmarshalLong(wireFormat, dataIn, bs));
+
+        if (bs.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) tightUnmarsalNestedObject(wireFormat,dataIn, bs);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        DestinationInfo info = (DestinationInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConnectionId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getTimeout(), bs);
+        rc += tightMarshalObjectArray1(wireFormat, info.getBrokerPath(), bs);
+
+        return rc + 1;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        DestinationInfo info = (DestinationInfo)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConnectionId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        dataOut.writeByte(info.getOperationType());
+        tightMarshalLong2(wireFormat, info.getTimeout(), dataOut, bs);
+        tightMarshalObjectArray2(wireFormat, info.getBrokerPath(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        DestinationInfo info = (DestinationInfo)o;
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setOperationType(dataIn.readByte());
+        info.setTimeout(looseUnmarshalLong(wireFormat, dataIn));
+
+        if (dataIn.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) looseUnmarsalNestedObject(wireFormat,dataIn);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        DestinationInfo info = (DestinationInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConnectionId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        dataOut.writeByte(info.getOperationType());
+        looseMarshalLong(wireFormat, info.getTimeout(), dataOut);
+        looseMarshalObjectArray(wireFormat, info.getBrokerPath(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DiscoveryEventMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DiscoveryEventMarshaller.java
new file mode 100644
index 000000000..167a53226
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/DiscoveryEventMarshaller.java
@@ -0,0 +1,134 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for DiscoveryEventMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class DiscoveryEventMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return DiscoveryEvent.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new DiscoveryEvent();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        DiscoveryEvent info = (DiscoveryEvent)o;
+        info.setServiceName(tightUnmarshalString(dataIn, bs));
+        info.setBrokerName(tightUnmarshalString(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        DiscoveryEvent info = (DiscoveryEvent)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getServiceName(), bs);
+        rc += tightMarshalString1(info.getBrokerName(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        DiscoveryEvent info = (DiscoveryEvent)o;
+        tightMarshalString2(info.getServiceName(), dataOut, bs);
+        tightMarshalString2(info.getBrokerName(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        DiscoveryEvent info = (DiscoveryEvent)o;
+        info.setServiceName(looseUnmarshalString(dataIn));
+        info.setBrokerName(looseUnmarshalString(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        DiscoveryEvent info = (DiscoveryEvent)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getServiceName(), dataOut);
+        looseMarshalString(info.getBrokerName(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ExceptionResponseMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ExceptionResponseMarshaller.java
new file mode 100644
index 000000000..2a5f6f7a1
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ExceptionResponseMarshaller.java
@@ -0,0 +1,129 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ExceptionResponseMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ExceptionResponseMarshaller extends ResponseMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ExceptionResponse.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ExceptionResponse();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ExceptionResponse info = (ExceptionResponse)o;
+        info.setException((java.lang.Throwable) tightUnmarsalThrowable(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ExceptionResponse info = (ExceptionResponse)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalThrowable1(wireFormat, info.getException(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ExceptionResponse info = (ExceptionResponse)o;
+        tightMarshalThrowable2(wireFormat, info.getException(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ExceptionResponse info = (ExceptionResponse)o;
+        info.setException((java.lang.Throwable) looseUnmarsalThrowable(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ExceptionResponse info = (ExceptionResponse)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalThrowable(wireFormat, info.getException(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/FlushCommandMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/FlushCommandMarshaller.java
new file mode 100644
index 000000000..0dffa30f8
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/FlushCommandMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for FlushCommandMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class FlushCommandMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return FlushCommand.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new FlushCommand();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/IntegerResponseMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/IntegerResponseMarshaller.java
new file mode 100644
index 000000000..419b6d14e
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/IntegerResponseMarshaller.java
@@ -0,0 +1,128 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for IntegerResponseMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class IntegerResponseMarshaller extends ResponseMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return IntegerResponse.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new IntegerResponse();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        IntegerResponse info = (IntegerResponse)o;
+        info.setResult(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        IntegerResponse info = (IntegerResponse)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        IntegerResponse info = (IntegerResponse)o;
+        dataOut.writeInt(info.getResult());
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        IntegerResponse info = (IntegerResponse)o;
+        info.setResult(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        IntegerResponse info = (IntegerResponse)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        dataOut.writeInt(info.getResult());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalQueueAckMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalQueueAckMarshaller.java
new file mode 100644
index 000000000..d2e5397db
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalQueueAckMarshaller.java
@@ -0,0 +1,134 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for JournalQueueAckMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class JournalQueueAckMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return JournalQueueAck.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new JournalQueueAck();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        JournalQueueAck info = (JournalQueueAck)o;
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setMessageAck((org.apache.activemq.command.MessageAck) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        JournalQueueAck info = (JournalQueueAck)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getMessageAck(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        JournalQueueAck info = (JournalQueueAck)o;
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getMessageAck(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        JournalQueueAck info = (JournalQueueAck)o;
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setMessageAck((org.apache.activemq.command.MessageAck) looseUnmarsalNestedObject(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        JournalQueueAck info = (JournalQueueAck)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getMessageAck(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalTopicAckMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalTopicAckMarshaller.java
new file mode 100644
index 000000000..d0bab04cf
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalTopicAckMarshaller.java
@@ -0,0 +1,154 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for JournalTopicAckMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class JournalTopicAckMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return JournalTopicAck.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new JournalTopicAck();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        JournalTopicAck info = (JournalTopicAck)o;
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setMessageId((org.apache.activemq.command.MessageId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setMessageSequenceId(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setSubscritionName(tightUnmarshalString(dataIn, bs));
+        info.setClientId(tightUnmarshalString(dataIn, bs));
+        info.setTransactionId((org.apache.activemq.command.TransactionId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        JournalTopicAck info = (JournalTopicAck)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getMessageId(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getMessageSequenceId(), bs);
+        rc += tightMarshalString1(info.getSubscritionName(), bs);
+        rc += tightMarshalString1(info.getClientId(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getTransactionId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        JournalTopicAck info = (JournalTopicAck)o;
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getMessageId(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getMessageSequenceId(), dataOut, bs);
+        tightMarshalString2(info.getSubscritionName(), dataOut, bs);
+        tightMarshalString2(info.getClientId(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getTransactionId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        JournalTopicAck info = (JournalTopicAck)o;
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setMessageId((org.apache.activemq.command.MessageId) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setMessageSequenceId(looseUnmarshalLong(wireFormat, dataIn));
+        info.setSubscritionName(looseUnmarshalString(dataIn));
+        info.setClientId(looseUnmarshalString(dataIn));
+        info.setTransactionId((org.apache.activemq.command.TransactionId) looseUnmarsalNestedObject(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        JournalTopicAck info = (JournalTopicAck)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getMessageId(), dataOut);
+        looseMarshalLong(wireFormat, info.getMessageSequenceId(), dataOut);
+        looseMarshalString(info.getSubscritionName(), dataOut);
+        looseMarshalString(info.getClientId(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getTransactionId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalTraceMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalTraceMarshaller.java
new file mode 100644
index 000000000..542c1423c
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalTraceMarshaller.java
@@ -0,0 +1,129 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for JournalTraceMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class JournalTraceMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return JournalTrace.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new JournalTrace();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        JournalTrace info = (JournalTrace)o;
+        info.setMessage(tightUnmarshalString(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        JournalTrace info = (JournalTrace)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getMessage(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        JournalTrace info = (JournalTrace)o;
+        tightMarshalString2(info.getMessage(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        JournalTrace info = (JournalTrace)o;
+        info.setMessage(looseUnmarshalString(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        JournalTrace info = (JournalTrace)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getMessage(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalTransactionMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalTransactionMarshaller.java
new file mode 100644
index 000000000..9435a2b17
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/JournalTransactionMarshaller.java
@@ -0,0 +1,138 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for JournalTransactionMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class JournalTransactionMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return JournalTransaction.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new JournalTransaction();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        JournalTransaction info = (JournalTransaction)o;
+        info.setTransactionId((org.apache.activemq.command.TransactionId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setType(dataIn.readByte());
+        info.setWasPrepared(bs.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        JournalTransaction info = (JournalTransaction)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getTransactionId(), bs);
+        bs.writeBoolean(info.getWasPrepared());
+
+        return rc + 1;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        JournalTransaction info = (JournalTransaction)o;
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getTransactionId(), dataOut, bs);
+        dataOut.writeByte(info.getType());
+        bs.readBoolean();
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        JournalTransaction info = (JournalTransaction)o;
+        info.setTransactionId((org.apache.activemq.command.TransactionId) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setType(dataIn.readByte());
+        info.setWasPrepared(dataIn.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        JournalTransaction info = (JournalTransaction)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getTransactionId(), dataOut);
+        dataOut.writeByte(info.getType());
+        dataOut.writeBoolean(info.getWasPrepared());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/KeepAliveInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/KeepAliveInfoMarshaller.java
new file mode 100644
index 000000000..a5db7fc24
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/KeepAliveInfoMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for KeepAliveInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class KeepAliveInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return KeepAliveInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new KeepAliveInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/LastPartialCommandMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/LastPartialCommandMarshaller.java
new file mode 100644
index 000000000..14232ba56
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/LastPartialCommandMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for LastPartialCommandMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class LastPartialCommandMarshaller extends PartialCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return LastPartialCommand.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new LastPartialCommand();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/LocalTransactionIdMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/LocalTransactionIdMarshaller.java
new file mode 100644
index 000000000..d3c0f82e3
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/LocalTransactionIdMarshaller.java
@@ -0,0 +1,134 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for LocalTransactionIdMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class LocalTransactionIdMarshaller extends TransactionIdMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return LocalTransactionId.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new LocalTransactionId();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        LocalTransactionId info = (LocalTransactionId)o;
+        info.setValue(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        LocalTransactionId info = (LocalTransactionId)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc+=tightMarshalLong1(wireFormat, info.getValue(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConnectionId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        LocalTransactionId info = (LocalTransactionId)o;
+        tightMarshalLong2(wireFormat, info.getValue(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConnectionId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        LocalTransactionId info = (LocalTransactionId)o;
+        info.setValue(looseUnmarshalLong(wireFormat, dataIn));
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        LocalTransactionId info = (LocalTransactionId)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalLong(wireFormat, info.getValue(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConnectionId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MarshallerFactory.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MarshallerFactory.java
new file mode 100644
index 000000000..4ff72b701
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MarshallerFactory.java
@@ -0,0 +1,109 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import org.apache.activemq.openwire.DataStreamMarshaller;
+import org.apache.activemq.openwire.OpenWireFormat;
+
+/**
+ * MarshallerFactory for Open Wire Format.
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class MarshallerFactory {
+
+    /**
+     * Creates a Map of command type -> Marshallers
+     */
+    static final private DataStreamMarshaller marshaller[] = new DataStreamMarshaller[256];
+    static {
+
+        add(new ActiveMQBlobMessageMarshaller());
+        add(new ActiveMQBytesMessageMarshaller());
+        add(new ActiveMQMapMessageMarshaller());
+        add(new ActiveMQMessageMarshaller());
+        add(new ActiveMQObjectMessageMarshaller());
+        add(new ActiveMQQueueMarshaller());
+        add(new ActiveMQStreamMessageMarshaller());
+        add(new ActiveMQTempQueueMarshaller());
+        add(new ActiveMQTempTopicMarshaller());
+        add(new ActiveMQTextMessageMarshaller());
+        add(new ActiveMQTopicMarshaller());
+        add(new BrokerIdMarshaller());
+        add(new BrokerInfoMarshaller());
+        add(new ConnectionControlMarshaller());
+        add(new ConnectionErrorMarshaller());
+        add(new ConnectionIdMarshaller());
+        add(new ConnectionInfoMarshaller());
+        add(new ConsumerControlMarshaller());
+        add(new ConsumerIdMarshaller());
+        add(new ConsumerInfoMarshaller());
+        add(new ControlCommandMarshaller());
+        add(new DataArrayResponseMarshaller());
+        add(new DataResponseMarshaller());
+        add(new DestinationInfoMarshaller());
+        add(new DiscoveryEventMarshaller());
+        add(new ExceptionResponseMarshaller());
+        add(new FlushCommandMarshaller());
+        add(new IntegerResponseMarshaller());
+        add(new JournalQueueAckMarshaller());
+        add(new JournalTopicAckMarshaller());
+        add(new JournalTraceMarshaller());
+        add(new JournalTransactionMarshaller());
+        add(new KeepAliveInfoMarshaller());
+        add(new LastPartialCommandMarshaller());
+        add(new LocalTransactionIdMarshaller());
+        add(new MessageAckMarshaller());
+        add(new MessageDispatchMarshaller());
+        add(new MessageDispatchNotificationMarshaller());
+        add(new MessageIdMarshaller());
+        add(new MessagePullMarshaller());
+        add(new NetworkBridgeFilterMarshaller());
+        add(new PartialCommandMarshaller());
+        add(new ProducerAckMarshaller());
+        add(new ProducerIdMarshaller());
+        add(new ProducerInfoMarshaller());
+        add(new RemoveInfoMarshaller());
+        add(new RemoveSubscriptionInfoMarshaller());
+        add(new ReplayCommandMarshaller());
+        add(new ResponseMarshaller());
+        add(new SessionIdMarshaller());
+        add(new SessionInfoMarshaller());
+        add(new ShutdownInfoMarshaller());
+        add(new SubscriptionInfoMarshaller());
+        add(new TransactionInfoMarshaller());
+        add(new WireFormatInfoMarshaller());
+        add(new XATransactionIdMarshaller());
+
+    }
+
+    static private void add(DataStreamMarshaller dsm) {
+        marshaller[dsm.getDataStructureType()] = dsm;
+    }
+    
+    static public DataStreamMarshaller[] createMarshallerMap(OpenWireFormat wireFormat) {
+        return marshaller;
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageAckMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageAckMarshaller.java
new file mode 100644
index 000000000..49339333c
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageAckMarshaller.java
@@ -0,0 +1,162 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for MessageAckMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class MessageAckMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return MessageAck.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new MessageAck();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        MessageAck info = (MessageAck)o;
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setTransactionId((org.apache.activemq.command.TransactionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setAckType(dataIn.readByte());
+        info.setFirstMessageId((org.apache.activemq.command.MessageId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setLastMessageId((org.apache.activemq.command.MessageId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setMessageCount(dataIn.readInt());
+        info.setPoisonCause((java.lang.Throwable) tightUnmarsalThrowable(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        MessageAck info = (MessageAck)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getTransactionId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConsumerId(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getFirstMessageId(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getLastMessageId(), bs);
+        rc += tightMarshalThrowable1(wireFormat, info.getPoisonCause(), bs);
+
+        return rc + 5;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        MessageAck info = (MessageAck)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getTransactionId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConsumerId(), dataOut, bs);
+        dataOut.writeByte(info.getAckType());
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getFirstMessageId(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getLastMessageId(), dataOut, bs);
+        dataOut.writeInt(info.getMessageCount());
+        tightMarshalThrowable2(wireFormat, info.getPoisonCause(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        MessageAck info = (MessageAck)o;
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setTransactionId((org.apache.activemq.command.TransactionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setAckType(dataIn.readByte());
+        info.setFirstMessageId((org.apache.activemq.command.MessageId) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setLastMessageId((org.apache.activemq.command.MessageId) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setMessageCount(dataIn.readInt());
+        info.setPoisonCause((java.lang.Throwable) looseUnmarsalThrowable(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        MessageAck info = (MessageAck)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getTransactionId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConsumerId(), dataOut);
+        dataOut.writeByte(info.getAckType());
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getFirstMessageId(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getLastMessageId(), dataOut);
+        dataOut.writeInt(info.getMessageCount());
+        looseMarshalThrowable(wireFormat, info.getPoisonCause(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageDispatchMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageDispatchMarshaller.java
new file mode 100644
index 000000000..d9ac54ff0
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageDispatchMarshaller.java
@@ -0,0 +1,143 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for MessageDispatchMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class MessageDispatchMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return MessageDispatch.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new MessageDispatch();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        MessageDispatch info = (MessageDispatch)o;
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setMessage((org.apache.activemq.command.Message) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setRedeliveryCounter(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        MessageDispatch info = (MessageDispatch)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConsumerId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getMessage(), bs);
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        MessageDispatch info = (MessageDispatch)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConsumerId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getMessage(), dataOut, bs);
+        dataOut.writeInt(info.getRedeliveryCounter());
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        MessageDispatch info = (MessageDispatch)o;
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setMessage((org.apache.activemq.command.Message) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setRedeliveryCounter(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        MessageDispatch info = (MessageDispatch)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConsumerId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getMessage(), dataOut);
+        dataOut.writeInt(info.getRedeliveryCounter());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageDispatchNotificationMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageDispatchNotificationMarshaller.java
new file mode 100644
index 000000000..d37a213e7
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageDispatchNotificationMarshaller.java
@@ -0,0 +1,144 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for MessageDispatchNotificationMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class MessageDispatchNotificationMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return MessageDispatchNotification.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new MessageDispatchNotification();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        MessageDispatchNotification info = (MessageDispatchNotification)o;
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setDeliverySequenceId(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setMessageId((org.apache.activemq.command.MessageId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        MessageDispatchNotification info = (MessageDispatchNotification)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConsumerId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getDeliverySequenceId(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getMessageId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        MessageDispatchNotification info = (MessageDispatchNotification)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConsumerId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getDeliverySequenceId(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getMessageId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        MessageDispatchNotification info = (MessageDispatchNotification)o;
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setDeliverySequenceId(looseUnmarshalLong(wireFormat, dataIn));
+        info.setMessageId((org.apache.activemq.command.MessageId) looseUnmarsalNestedObject(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        MessageDispatchNotification info = (MessageDispatchNotification)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConsumerId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        looseMarshalLong(wireFormat, info.getDeliverySequenceId(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getMessageId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageIdMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageIdMarshaller.java
new file mode 100644
index 000000000..7d51527fa
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageIdMarshaller.java
@@ -0,0 +1,144 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for MessageIdMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class MessageIdMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return MessageId.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new MessageId();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        MessageId info = (MessageId)o;
+        info.setTextView(tightUnmarshalString(dataIn, bs));
+        info.setProducerId((org.apache.activemq.command.ProducerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setProducerSequenceId(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setBrokerSequenceId(tightUnmarshalLong(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        MessageId info = (MessageId)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getTextView(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getProducerId(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getProducerSequenceId(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getBrokerSequenceId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        MessageId info = (MessageId)o;
+        tightMarshalString2(info.getTextView(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getProducerId(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getProducerSequenceId(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getBrokerSequenceId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        MessageId info = (MessageId)o;
+        info.setTextView(looseUnmarshalString(dataIn));
+        info.setProducerId((org.apache.activemq.command.ProducerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setProducerSequenceId(looseUnmarshalLong(wireFormat, dataIn));
+        info.setBrokerSequenceId(looseUnmarshalLong(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        MessageId info = (MessageId)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getTextView(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getProducerId(), dataOut);
+        looseMarshalLong(wireFormat, info.getProducerSequenceId(), dataOut);
+        looseMarshalLong(wireFormat, info.getBrokerSequenceId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageMarshaller.java
new file mode 100644
index 000000000..54a99423d
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessageMarshaller.java
@@ -0,0 +1,316 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for MessageMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public abstract class MessageMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        Message info = (Message)o;
+
+        info.beforeUnmarshall(wireFormat);
+        
+        info.setProducerId((org.apache.activemq.command.ProducerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setTransactionId((org.apache.activemq.command.TransactionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setOriginalDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setMessageId((org.apache.activemq.command.MessageId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setOriginalTransactionId((org.apache.activemq.command.TransactionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setGroupID(tightUnmarshalString(dataIn, bs));
+        info.setGroupSequence(dataIn.readInt());
+        info.setCorrelationId(tightUnmarshalString(dataIn, bs));
+        info.setPersistent(bs.readBoolean());
+        info.setExpiration(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setPriority(dataIn.readByte());
+        info.setReplyTo((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setTimestamp(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setType(tightUnmarshalString(dataIn, bs));
+        info.setContent(tightUnmarshalByteSequence(dataIn, bs));
+        info.setMarshalledProperties(tightUnmarshalByteSequence(dataIn, bs));
+        info.setDataStructure((org.apache.activemq.command.DataStructure) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setTargetConsumerId((org.apache.activemq.command.ConsumerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setCompressed(bs.readBoolean());
+        info.setRedeliveryCounter(dataIn.readInt());
+
+        if (bs.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) tightUnmarsalNestedObject(wireFormat,dataIn, bs);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+        info.setArrival(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setUserID(tightUnmarshalString(dataIn, bs));
+        info.setRecievedByDFBridge(bs.readBoolean());
+        info.setDroppable(bs.readBoolean());
+
+        if (bs.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) tightUnmarsalNestedObject(wireFormat,dataIn, bs);
+            }
+            info.setCluster(value);
+        }
+        else {
+            info.setCluster(null);
+        }
+        info.setBrokerInTime(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setBrokerOutTime(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setJMSXGroupFirstForConsumer(bs.readBoolean());
+
+        info.afterUnmarshall(wireFormat);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        Message info = (Message)o;
+
+        info.beforeMarshall(wireFormat);
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getProducerId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getTransactionId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getOriginalDestination(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getMessageId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getOriginalTransactionId(), bs);
+        rc += tightMarshalString1(info.getGroupID(), bs);
+        rc += tightMarshalString1(info.getCorrelationId(), bs);
+        bs.writeBoolean(info.isPersistent());
+        rc+=tightMarshalLong1(wireFormat, info.getExpiration(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getReplyTo(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getTimestamp(), bs);
+        rc += tightMarshalString1(info.getType(), bs);
+        rc += tightMarshalByteSequence1(info.getContent(), bs);
+        rc += tightMarshalByteSequence1(info.getMarshalledProperties(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getDataStructure(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getTargetConsumerId(), bs);
+        bs.writeBoolean(info.isCompressed());
+        rc += tightMarshalObjectArray1(wireFormat, info.getBrokerPath(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getArrival(), bs);
+        rc += tightMarshalString1(info.getUserID(), bs);
+        bs.writeBoolean(info.isRecievedByDFBridge());
+        bs.writeBoolean(info.isDroppable());
+        rc += tightMarshalObjectArray1(wireFormat, info.getCluster(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getBrokerInTime(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getBrokerOutTime(), bs);
+        bs.writeBoolean(info.isJMSXGroupFirstForConsumer());
+
+        return rc + 9;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        Message info = (Message)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getProducerId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getTransactionId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getOriginalDestination(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getMessageId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getOriginalTransactionId(), dataOut, bs);
+        tightMarshalString2(info.getGroupID(), dataOut, bs);
+        dataOut.writeInt(info.getGroupSequence());
+        tightMarshalString2(info.getCorrelationId(), dataOut, bs);
+        bs.readBoolean();
+        tightMarshalLong2(wireFormat, info.getExpiration(), dataOut, bs);
+        dataOut.writeByte(info.getPriority());
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getReplyTo(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getTimestamp(), dataOut, bs);
+        tightMarshalString2(info.getType(), dataOut, bs);
+        tightMarshalByteSequence2(info.getContent(), dataOut, bs);
+        tightMarshalByteSequence2(info.getMarshalledProperties(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getDataStructure(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getTargetConsumerId(), dataOut, bs);
+        bs.readBoolean();
+        dataOut.writeInt(info.getRedeliveryCounter());
+        tightMarshalObjectArray2(wireFormat, info.getBrokerPath(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getArrival(), dataOut, bs);
+        tightMarshalString2(info.getUserID(), dataOut, bs);
+        bs.readBoolean();
+        bs.readBoolean();
+        tightMarshalObjectArray2(wireFormat, info.getCluster(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getBrokerInTime(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getBrokerOutTime(), dataOut, bs);
+        bs.readBoolean();
+
+        info.afterMarshall(wireFormat);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        Message info = (Message)o;
+
+        info.beforeUnmarshall(wireFormat);
+        
+        info.setProducerId((org.apache.activemq.command.ProducerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setTransactionId((org.apache.activemq.command.TransactionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setOriginalDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setMessageId((org.apache.activemq.command.MessageId) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setOriginalTransactionId((org.apache.activemq.command.TransactionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setGroupID(looseUnmarshalString(dataIn));
+        info.setGroupSequence(dataIn.readInt());
+        info.setCorrelationId(looseUnmarshalString(dataIn));
+        info.setPersistent(dataIn.readBoolean());
+        info.setExpiration(looseUnmarshalLong(wireFormat, dataIn));
+        info.setPriority(dataIn.readByte());
+        info.setReplyTo((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setTimestamp(looseUnmarshalLong(wireFormat, dataIn));
+        info.setType(looseUnmarshalString(dataIn));
+        info.setContent(looseUnmarshalByteSequence(dataIn));
+        info.setMarshalledProperties(looseUnmarshalByteSequence(dataIn));
+        info.setDataStructure((org.apache.activemq.command.DataStructure) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setTargetConsumerId((org.apache.activemq.command.ConsumerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setCompressed(dataIn.readBoolean());
+        info.setRedeliveryCounter(dataIn.readInt());
+
+        if (dataIn.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) looseUnmarsalNestedObject(wireFormat,dataIn);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+        info.setArrival(looseUnmarshalLong(wireFormat, dataIn));
+        info.setUserID(looseUnmarshalString(dataIn));
+        info.setRecievedByDFBridge(dataIn.readBoolean());
+        info.setDroppable(dataIn.readBoolean());
+
+        if (dataIn.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) looseUnmarsalNestedObject(wireFormat,dataIn);
+            }
+            info.setCluster(value);
+        }
+        else {
+            info.setCluster(null);
+        }
+        info.setBrokerInTime(looseUnmarshalLong(wireFormat, dataIn));
+        info.setBrokerOutTime(looseUnmarshalLong(wireFormat, dataIn));
+        info.setJMSXGroupFirstForConsumer(dataIn.readBoolean());
+
+        info.afterUnmarshall(wireFormat);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        Message info = (Message)o;
+
+        info.beforeMarshall(wireFormat);
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getProducerId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getTransactionId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getOriginalDestination(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getMessageId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getOriginalTransactionId(), dataOut);
+        looseMarshalString(info.getGroupID(), dataOut);
+        dataOut.writeInt(info.getGroupSequence());
+        looseMarshalString(info.getCorrelationId(), dataOut);
+        dataOut.writeBoolean(info.isPersistent());
+        looseMarshalLong(wireFormat, info.getExpiration(), dataOut);
+        dataOut.writeByte(info.getPriority());
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getReplyTo(), dataOut);
+        looseMarshalLong(wireFormat, info.getTimestamp(), dataOut);
+        looseMarshalString(info.getType(), dataOut);
+        looseMarshalByteSequence(wireFormat, info.getContent(), dataOut);
+        looseMarshalByteSequence(wireFormat, info.getMarshalledProperties(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getDataStructure(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getTargetConsumerId(), dataOut);
+        dataOut.writeBoolean(info.isCompressed());
+        dataOut.writeInt(info.getRedeliveryCounter());
+        looseMarshalObjectArray(wireFormat, info.getBrokerPath(), dataOut);
+        looseMarshalLong(wireFormat, info.getArrival(), dataOut);
+        looseMarshalString(info.getUserID(), dataOut);
+        dataOut.writeBoolean(info.isRecievedByDFBridge());
+        dataOut.writeBoolean(info.isDroppable());
+        looseMarshalObjectArray(wireFormat, info.getCluster(), dataOut);
+        looseMarshalLong(wireFormat, info.getBrokerInTime(), dataOut);
+        looseMarshalLong(wireFormat, info.getBrokerOutTime(), dataOut);
+        dataOut.writeBoolean(info.isJMSXGroupFirstForConsumer());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessagePullMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessagePullMarshaller.java
new file mode 100644
index 000000000..3ef1cb5d8
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/MessagePullMarshaller.java
@@ -0,0 +1,149 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for MessagePullMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class MessagePullMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return MessagePull.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new MessagePull();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        MessagePull info = (MessagePull)o;
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setTimeout(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setCorrelationId(tightUnmarshalString(dataIn, bs));
+        info.setMessageId((org.apache.activemq.command.MessageId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        MessagePull info = (MessagePull)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConsumerId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getTimeout(), bs);
+        rc += tightMarshalString1(info.getCorrelationId(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getMessageId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        MessagePull info = (MessagePull)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConsumerId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getTimeout(), dataOut, bs);
+        tightMarshalString2(info.getCorrelationId(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getMessageId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        MessagePull info = (MessagePull)o;
+        info.setConsumerId((org.apache.activemq.command.ConsumerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setTimeout(looseUnmarshalLong(wireFormat, dataIn));
+        info.setCorrelationId(looseUnmarshalString(dataIn));
+        info.setMessageId((org.apache.activemq.command.MessageId) looseUnmarsalNestedObject(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        MessagePull info = (MessagePull)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConsumerId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        looseMarshalLong(wireFormat, info.getTimeout(), dataOut);
+        looseMarshalString(info.getCorrelationId(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getMessageId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/NetworkBridgeFilterMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/NetworkBridgeFilterMarshaller.java
new file mode 100644
index 000000000..a326d5971
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/NetworkBridgeFilterMarshaller.java
@@ -0,0 +1,137 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for NetworkBridgeFilterMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class NetworkBridgeFilterMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return NetworkBridgeFilter.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new NetworkBridgeFilter();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        NetworkBridgeFilter info = (NetworkBridgeFilter)o;
+        info.setNetworkBrokerId((org.apache.activemq.command.BrokerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setMessageTTL(dataIn.readInt());
+        info.setConsumerTTL(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        NetworkBridgeFilter info = (NetworkBridgeFilter)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getNetworkBrokerId(), bs);
+
+        return rc + 8;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        NetworkBridgeFilter info = (NetworkBridgeFilter)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getNetworkBrokerId(), dataOut, bs);
+        dataOut.writeInt(info.getMessageTTL());
+        dataOut.writeInt(info.getConsumerTTL());
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        NetworkBridgeFilter info = (NetworkBridgeFilter)o;
+        info.setNetworkBrokerId((org.apache.activemq.command.BrokerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setMessageTTL(dataIn.readInt());
+        info.setConsumerTTL(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        NetworkBridgeFilter info = (NetworkBridgeFilter)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getNetworkBrokerId(), dataOut);
+        dataOut.writeInt(info.getMessageTTL());
+        dataOut.writeInt(info.getConsumerTTL());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/PartialCommandMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/PartialCommandMarshaller.java
new file mode 100644
index 000000000..db480e1ba
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/PartialCommandMarshaller.java
@@ -0,0 +1,133 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for PartialCommandMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class PartialCommandMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return PartialCommand.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new PartialCommand();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        PartialCommand info = (PartialCommand)o;
+        info.setCommandId(dataIn.readInt());
+        info.setData(tightUnmarshalByteArray(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        PartialCommand info = (PartialCommand)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalByteArray1(info.getData(), bs);
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        PartialCommand info = (PartialCommand)o;
+        dataOut.writeInt(info.getCommandId());
+        tightMarshalByteArray2(info.getData(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        PartialCommand info = (PartialCommand)o;
+        info.setCommandId(dataIn.readInt());
+        info.setData(looseUnmarshalByteArray(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        PartialCommand info = (PartialCommand)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        dataOut.writeInt(info.getCommandId());
+        looseMarshalByteArray(wireFormat, info.getData(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ProducerAckMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ProducerAckMarshaller.java
new file mode 100644
index 000000000..f65370ae5
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ProducerAckMarshaller.java
@@ -0,0 +1,133 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ProducerAckMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ProducerAckMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ProducerAck.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ProducerAck();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ProducerAck info = (ProducerAck)o;
+        info.setProducerId((org.apache.activemq.command.ProducerId) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setSize(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ProducerAck info = (ProducerAck)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getProducerId(), bs);
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ProducerAck info = (ProducerAck)o;
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getProducerId(), dataOut, bs);
+        dataOut.writeInt(info.getSize());
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ProducerAck info = (ProducerAck)o;
+        info.setProducerId((org.apache.activemq.command.ProducerId) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setSize(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ProducerAck info = (ProducerAck)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getProducerId(), dataOut);
+        dataOut.writeInt(info.getSize());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ProducerIdMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ProducerIdMarshaller.java
new file mode 100644
index 000000000..61299d484
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ProducerIdMarshaller.java
@@ -0,0 +1,139 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ProducerIdMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ProducerIdMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ProducerId.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ProducerId();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ProducerId info = (ProducerId)o;
+        info.setConnectionId(tightUnmarshalString(dataIn, bs));
+        info.setValue(tightUnmarshalLong(wireFormat, dataIn, bs));
+        info.setSessionId(tightUnmarshalLong(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ProducerId info = (ProducerId)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getConnectionId(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getValue(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getSessionId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ProducerId info = (ProducerId)o;
+        tightMarshalString2(info.getConnectionId(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getValue(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getSessionId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ProducerId info = (ProducerId)o;
+        info.setConnectionId(looseUnmarshalString(dataIn));
+        info.setValue(looseUnmarshalLong(wireFormat, dataIn));
+        info.setSessionId(looseUnmarshalLong(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ProducerId info = (ProducerId)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getConnectionId(), dataOut);
+        looseMarshalLong(wireFormat, info.getValue(), dataOut);
+        looseMarshalLong(wireFormat, info.getSessionId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ProducerInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ProducerInfoMarshaller.java
new file mode 100644
index 000000000..792cde9cf
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ProducerInfoMarshaller.java
@@ -0,0 +1,170 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ProducerInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ProducerInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ProducerInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ProducerInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ProducerInfo info = (ProducerInfo)o;
+        info.setProducerId((org.apache.activemq.command.ProducerId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+
+        if (bs.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) tightUnmarsalNestedObject(wireFormat,dataIn, bs);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+        info.setDispatchAsync(bs.readBoolean());
+        info.setWindowSize(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ProducerInfo info = (ProducerInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getProducerId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc += tightMarshalObjectArray1(wireFormat, info.getBrokerPath(), bs);
+        bs.writeBoolean(info.isDispatchAsync());
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ProducerInfo info = (ProducerInfo)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getProducerId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        tightMarshalObjectArray2(wireFormat, info.getBrokerPath(), dataOut, bs);
+        bs.readBoolean();
+        dataOut.writeInt(info.getWindowSize());
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ProducerInfo info = (ProducerInfo)o;
+        info.setProducerId((org.apache.activemq.command.ProducerId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+
+        if (dataIn.readBoolean()) {
+            short size = dataIn.readShort();
+            org.apache.activemq.command.BrokerId value[] = new org.apache.activemq.command.BrokerId[size];
+            for( int i=0; i < size; i++ ) {
+                value[i] = (org.apache.activemq.command.BrokerId) looseUnmarsalNestedObject(wireFormat,dataIn);
+            }
+            info.setBrokerPath(value);
+        }
+        else {
+            info.setBrokerPath(null);
+        }
+        info.setDispatchAsync(dataIn.readBoolean());
+        info.setWindowSize(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ProducerInfo info = (ProducerInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getProducerId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        looseMarshalObjectArray(wireFormat, info.getBrokerPath(), dataOut);
+        dataOut.writeBoolean(info.isDispatchAsync());
+        dataOut.writeInt(info.getWindowSize());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/RemoveInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/RemoveInfoMarshaller.java
new file mode 100644
index 000000000..61c9e4526
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/RemoveInfoMarshaller.java
@@ -0,0 +1,134 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for RemoveInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class RemoveInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return RemoveInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new RemoveInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        RemoveInfo info = (RemoveInfo)o;
+        info.setObjectId((org.apache.activemq.command.DataStructure) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setLastDeliveredSequenceId(tightUnmarshalLong(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        RemoveInfo info = (RemoveInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getObjectId(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getLastDeliveredSequenceId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        RemoveInfo info = (RemoveInfo)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getObjectId(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getLastDeliveredSequenceId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        RemoveInfo info = (RemoveInfo)o;
+        info.setObjectId((org.apache.activemq.command.DataStructure) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setLastDeliveredSequenceId(looseUnmarshalLong(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        RemoveInfo info = (RemoveInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getObjectId(), dataOut);
+        looseMarshalLong(wireFormat, info.getLastDeliveredSequenceId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/RemoveSubscriptionInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/RemoveSubscriptionInfoMarshaller.java
new file mode 100644
index 000000000..9d2dfda3b
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/RemoveSubscriptionInfoMarshaller.java
@@ -0,0 +1,139 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for RemoveSubscriptionInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class RemoveSubscriptionInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return RemoveSubscriptionInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new RemoveSubscriptionInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        RemoveSubscriptionInfo info = (RemoveSubscriptionInfo)o;
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setSubcriptionName(tightUnmarshalString(dataIn, bs));
+        info.setClientId(tightUnmarshalString(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        RemoveSubscriptionInfo info = (RemoveSubscriptionInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConnectionId(), bs);
+        rc += tightMarshalString1(info.getSubcriptionName(), bs);
+        rc += tightMarshalString1(info.getClientId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        RemoveSubscriptionInfo info = (RemoveSubscriptionInfo)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConnectionId(), dataOut, bs);
+        tightMarshalString2(info.getSubcriptionName(), dataOut, bs);
+        tightMarshalString2(info.getClientId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        RemoveSubscriptionInfo info = (RemoveSubscriptionInfo)o;
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setSubcriptionName(looseUnmarshalString(dataIn));
+        info.setClientId(looseUnmarshalString(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        RemoveSubscriptionInfo info = (RemoveSubscriptionInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConnectionId(), dataOut);
+        looseMarshalString(info.getSubcriptionName(), dataOut);
+        looseMarshalString(info.getClientId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ReplayCommandMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ReplayCommandMarshaller.java
new file mode 100644
index 000000000..ccde4f8a5
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ReplayCommandMarshaller.java
@@ -0,0 +1,132 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ReplayCommandMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ReplayCommandMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ReplayCommand.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ReplayCommand();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        ReplayCommand info = (ReplayCommand)o;
+        info.setFirstNakNumber(dataIn.readInt());
+        info.setLastNakNumber(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        ReplayCommand info = (ReplayCommand)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 8;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        ReplayCommand info = (ReplayCommand)o;
+        dataOut.writeInt(info.getFirstNakNumber());
+        dataOut.writeInt(info.getLastNakNumber());
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        ReplayCommand info = (ReplayCommand)o;
+        info.setFirstNakNumber(dataIn.readInt());
+        info.setLastNakNumber(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        ReplayCommand info = (ReplayCommand)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        dataOut.writeInt(info.getFirstNakNumber());
+        dataOut.writeInt(info.getLastNakNumber());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ResponseMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ResponseMarshaller.java
new file mode 100644
index 000000000..10c8ba61e
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ResponseMarshaller.java
@@ -0,0 +1,128 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ResponseMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ResponseMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return Response.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new Response();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        Response info = (Response)o;
+        info.setCorrelationId(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        Response info = (Response)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        Response info = (Response)o;
+        dataOut.writeInt(info.getCorrelationId());
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        Response info = (Response)o;
+        info.setCorrelationId(dataIn.readInt());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        Response info = (Response)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        dataOut.writeInt(info.getCorrelationId());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/SessionIdMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/SessionIdMarshaller.java
new file mode 100644
index 000000000..6ecaaa916
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/SessionIdMarshaller.java
@@ -0,0 +1,134 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for SessionIdMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class SessionIdMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return SessionId.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new SessionId();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        SessionId info = (SessionId)o;
+        info.setConnectionId(tightUnmarshalString(dataIn, bs));
+        info.setValue(tightUnmarshalLong(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        SessionId info = (SessionId)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getConnectionId(), bs);
+        rc+=tightMarshalLong1(wireFormat, info.getValue(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        SessionId info = (SessionId)o;
+        tightMarshalString2(info.getConnectionId(), dataOut, bs);
+        tightMarshalLong2(wireFormat, info.getValue(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        SessionId info = (SessionId)o;
+        info.setConnectionId(looseUnmarshalString(dataIn));
+        info.setValue(looseUnmarshalLong(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        SessionId info = (SessionId)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getConnectionId(), dataOut);
+        looseMarshalLong(wireFormat, info.getValue(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/SessionInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/SessionInfoMarshaller.java
new file mode 100644
index 000000000..9aa56d1e2
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/SessionInfoMarshaller.java
@@ -0,0 +1,129 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for SessionInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class SessionInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return SessionInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new SessionInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        SessionInfo info = (SessionInfo)o;
+        info.setSessionId((org.apache.activemq.command.SessionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        SessionInfo info = (SessionInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getSessionId(), bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        SessionInfo info = (SessionInfo)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getSessionId(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        SessionInfo info = (SessionInfo)o;
+        info.setSessionId((org.apache.activemq.command.SessionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        SessionInfo info = (SessionInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getSessionId(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ShutdownInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ShutdownInfoMarshaller.java
new file mode 100644
index 000000000..fb2494dcc
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/ShutdownInfoMarshaller.java
@@ -0,0 +1,114 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for ShutdownInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class ShutdownInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return ShutdownInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new ShutdownInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/SubscriptionInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/SubscriptionInfoMarshaller.java
new file mode 100644
index 000000000..0cf9a3edf
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/SubscriptionInfoMarshaller.java
@@ -0,0 +1,154 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for SubscriptionInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class SubscriptionInfoMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return SubscriptionInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new SubscriptionInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        SubscriptionInfo info = (SubscriptionInfo)o;
+        info.setClientId(tightUnmarshalString(dataIn, bs));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setSelector(tightUnmarshalString(dataIn, bs));
+        info.setSubcriptionName(tightUnmarshalString(dataIn, bs));
+        info.setSubscribedDestination((org.apache.activemq.command.ActiveMQDestination) tightUnmarsalNestedObject(wireFormat, dataIn, bs));
+        info.setNoLocal(bs.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        SubscriptionInfo info = (SubscriptionInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalString1(info.getClientId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getDestination(), bs);
+        rc += tightMarshalString1(info.getSelector(), bs);
+        rc += tightMarshalString1(info.getSubcriptionName(), bs);
+        rc += tightMarshalNestedObject1(wireFormat, (DataStructure)info.getSubscribedDestination(), bs);
+        bs.writeBoolean(info.isNoLocal());
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        SubscriptionInfo info = (SubscriptionInfo)o;
+        tightMarshalString2(info.getClientId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getDestination(), dataOut, bs);
+        tightMarshalString2(info.getSelector(), dataOut, bs);
+        tightMarshalString2(info.getSubcriptionName(), dataOut, bs);
+        tightMarshalNestedObject2(wireFormat, (DataStructure)info.getSubscribedDestination(), dataOut, bs);
+        bs.readBoolean();
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        SubscriptionInfo info = (SubscriptionInfo)o;
+        info.setClientId(looseUnmarshalString(dataIn));
+        info.setDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setSelector(looseUnmarshalString(dataIn));
+        info.setSubcriptionName(looseUnmarshalString(dataIn));
+        info.setSubscribedDestination((org.apache.activemq.command.ActiveMQDestination) looseUnmarsalNestedObject(wireFormat, dataIn));
+        info.setNoLocal(dataIn.readBoolean());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        SubscriptionInfo info = (SubscriptionInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalString(info.getClientId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);
+        looseMarshalString(info.getSelector(), dataOut);
+        looseMarshalString(info.getSubcriptionName(), dataOut);
+        looseMarshalNestedObject(wireFormat, (DataStructure)info.getSubscribedDestination(), dataOut);
+        dataOut.writeBoolean(info.isNoLocal());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/TransactionIdMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/TransactionIdMarshaller.java
new file mode 100644
index 000000000..9613b076a
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/TransactionIdMarshaller.java
@@ -0,0 +1,99 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for TransactionIdMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public abstract class TransactionIdMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+
+        return rc + 0;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        super.looseMarshal(wireFormat, o, dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/TransactionInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/TransactionInfoMarshaller.java
new file mode 100644
index 000000000..c762ad9d8
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/TransactionInfoMarshaller.java
@@ -0,0 +1,138 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for TransactionInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class TransactionInfoMarshaller extends BaseCommandMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return TransactionInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new TransactionInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        TransactionInfo info = (TransactionInfo)o;
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setTransactionId((org.apache.activemq.command.TransactionId) tightUnmarsalCachedObject(wireFormat, dataIn, bs));
+        info.setType(dataIn.readByte());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        TransactionInfo info = (TransactionInfo)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getConnectionId(), bs);
+        rc += tightMarshalCachedObject1(wireFormat, (DataStructure)info.getTransactionId(), bs);
+
+        return rc + 1;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        TransactionInfo info = (TransactionInfo)o;
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getConnectionId(), dataOut, bs);
+        tightMarshalCachedObject2(wireFormat, (DataStructure)info.getTransactionId(), dataOut, bs);
+        dataOut.writeByte(info.getType());
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        TransactionInfo info = (TransactionInfo)o;
+        info.setConnectionId((org.apache.activemq.command.ConnectionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setTransactionId((org.apache.activemq.command.TransactionId) looseUnmarsalCachedObject(wireFormat, dataIn));
+        info.setType(dataIn.readByte());
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        TransactionInfo info = (TransactionInfo)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getConnectionId(), dataOut);
+        looseMarshalCachedObject(wireFormat, (DataStructure)info.getTransactionId(), dataOut);
+        dataOut.writeByte(info.getType());
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/WireFormatInfoMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/WireFormatInfoMarshaller.java
new file mode 100644
index 000000000..ef5e569fd
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/WireFormatInfoMarshaller.java
@@ -0,0 +1,154 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for WireFormatInfoMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class WireFormatInfoMarshaller extends BaseDataStreamMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return WireFormatInfo.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new WireFormatInfo();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        WireFormatInfo info = (WireFormatInfo)o;
+
+        info.beforeUnmarshall(wireFormat);
+        
+        info.setMagic(tightUnmarshalConstByteArray(dataIn, bs, 8));
+        info.setVersion(dataIn.readInt());
+        info.setMarshalledProperties(tightUnmarshalByteSequence(dataIn, bs));
+
+        info.afterUnmarshall(wireFormat);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        WireFormatInfo info = (WireFormatInfo)o;
+
+        info.beforeMarshall(wireFormat);
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalConstByteArray1(info.getMagic(), bs, 8);
+        rc += tightMarshalByteSequence1(info.getMarshalledProperties(), bs);
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        WireFormatInfo info = (WireFormatInfo)o;
+        tightMarshalConstByteArray2(info.getMagic(), dataOut, bs, 8);
+        dataOut.writeInt(info.getVersion());
+        tightMarshalByteSequence2(info.getMarshalledProperties(), dataOut, bs);
+
+        info.afterMarshall(wireFormat);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        WireFormatInfo info = (WireFormatInfo)o;
+
+        info.beforeUnmarshall(wireFormat);
+        
+        info.setMagic(looseUnmarshalConstByteArray(dataIn, 8));
+        info.setVersion(dataIn.readInt());
+        info.setMarshalledProperties(looseUnmarshalByteSequence(dataIn));
+
+        info.afterUnmarshall(wireFormat);
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        WireFormatInfo info = (WireFormatInfo)o;
+
+        info.beforeMarshall(wireFormat);
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        looseMarshalConstByteArray(wireFormat, info.getMagic(), dataOut, 8);
+        dataOut.writeInt(info.getVersion());
+        looseMarshalByteSequence(wireFormat, info.getMarshalledProperties(), dataOut);
+
+    }
+}
diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v11/XATransactionIdMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/XATransactionIdMarshaller.java
new file mode 100644
index 000000000..ee4b5ecd3
--- /dev/null
+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v11/XATransactionIdMarshaller.java
@@ -0,0 +1,138 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.openwire.v11;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.activemq.openwire.*;
+import org.apache.activemq.command.*;
+
+
+
+/**
+ * Marshalling code for Open Wire Format for XATransactionIdMarshaller
+ *
+ *
+ * NOTE!: This file is auto generated - do not modify!
+ *        if you need to make a change, please see the modify the groovy scripts in the
+ *        under src/gram/script and then use maven openwire:generate to regenerate 
+ *        this file.
+ *
+ * 
+ */
+public class XATransactionIdMarshaller extends TransactionIdMarshaller {
+
+    /**
+     * Return the type of Data Structure we marshal
+     * @return short representation of the type data structure
+     */
+    public byte getDataStructureType() {
+        return XATransactionId.DATA_STRUCTURE_TYPE;
+    }
+    
+    /**
+     * @return a new object instance
+     */
+    public DataStructure createObject() {
+        return new XATransactionId();
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void tightUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn, BooleanStream bs) throws IOException {
+        super.tightUnmarshal(wireFormat, o, dataIn, bs);
+
+        XATransactionId info = (XATransactionId)o;
+        info.setFormatId(dataIn.readInt());
+        info.setGlobalTransactionId(tightUnmarshalByteArray(dataIn, bs));
+        info.setBranchQualifier(tightUnmarshalByteArray(dataIn, bs));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public int tightMarshal1(OpenWireFormat wireFormat, Object o, BooleanStream bs) throws IOException {
+
+        XATransactionId info = (XATransactionId)o;
+
+        int rc = super.tightMarshal1(wireFormat, o, bs);
+        rc += tightMarshalByteArray1(info.getGlobalTransactionId(), bs);
+        rc += tightMarshalByteArray1(info.getBranchQualifier(), bs);
+
+        return rc + 4;
+    }
+
+    /**
+     * Write a object instance to data output stream
+     *
+     * @param o the instance to be marshaled
+     * @param dataOut the output stream
+     * @throws IOException thrown if an error occurs
+     */
+    public void tightMarshal2(OpenWireFormat wireFormat, Object o, DataOutput dataOut, BooleanStream bs) throws IOException {
+        super.tightMarshal2(wireFormat, o, dataOut, bs);
+
+        XATransactionId info = (XATransactionId)o;
+        dataOut.writeInt(info.getFormatId());
+        tightMarshalByteArray2(info.getGlobalTransactionId(), dataOut, bs);
+        tightMarshalByteArray2(info.getBranchQualifier(), dataOut, bs);
+
+    }
+
+    /**
+     * Un-marshal an object instance from the data input stream
+     *
+     * @param o the object to un-marshal
+     * @param dataIn the data input stream to build the object from
+     * @throws IOException
+     */
+    public void looseUnmarshal(OpenWireFormat wireFormat, Object o, DataInput dataIn) throws IOException {
+        super.looseUnmarshal(wireFormat, o, dataIn);
+
+        XATransactionId info = (XATransactionId)o;
+        info.setFormatId(dataIn.readInt());
+        info.setGlobalTransactionId(looseUnmarshalByteArray(dataIn));
+        info.setBranchQualifier(looseUnmarshalByteArray(dataIn));
+
+    }
+
+
+    /**
+     * Write the booleans that this object uses to a BooleanStream
+     */
+    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {
+
+        XATransactionId info = (XATransactionId)o;
+
+        super.looseMarshal(wireFormat, o, dataOut);
+        dataOut.writeInt(info.getFormatId());
+        looseMarshalByteArray(wireFormat, info.getGlobalTransactionId(), dataOut);
+        looseMarshalByteArray(wireFormat, info.getBranchQualifier(), dataOut);
+
+    }
+}
diff --git a/activemq-console/src/main/java/org/apache/activemq/console/command/store/StoreExporter.java b/activemq-console/src/main/java/org/apache/activemq/console/command/store/StoreExporter.java
index e9a5efec0..2bb47a7c4 100644
--- a/activemq-console/src/main/java/org/apache/activemq/console/command/store/StoreExporter.java
+++ b/activemq-console/src/main/java/org/apache/activemq/console/command/store/StoreExporter.java
@@ -43,11 +43,12 @@ import org.apache.activemq.store.MessageStore;
 import org.apache.activemq.store.PersistenceAdapter;
 import org.apache.activemq.store.TopicMessageStore;
 import org.apache.activemq.store.TransactionRecoveryListener;
-import com.fasterxml.jackson.databind.ObjectMapper;
 import org.fusesource.hawtbuf.AsciiBuffer;
 import org.fusesource.hawtbuf.DataByteArrayOutputStream;
 import org.fusesource.hawtbuf.UTF8Buffer;
 
+import com.fasterxml.jackson.databind.ObjectMapper;
+
 /**
  * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
  */
@@ -189,6 +190,7 @@ public class StoreExporter {
                     if (sub.getSelector() != null) {
                         jsonMap.put("selector", sub.getSelector());
                     }
+                    jsonMap.put("noLocal", sub.isNoLocal());
                     String json = mapper.writeValueAsString(jsonMap);
                     System.out.println(json);
 
diff --git a/activemq-openwire-generator/pom.xml b/activemq-openwire-generator/pom.xml
index 5d0c04f41..027627583 100644
--- a/activemq-openwire-generator/pom.xml
+++ b/activemq-openwire-generator/pom.xml
@@ -56,14 +56,14 @@
       <activation>
         <property>
           <name>java.vendor</name>
-          <value>Sun Microsystems Inc.</value>
+          <value>Oracle Corporation</value>
         </property>
       </activation>
       <dependencies>
         <dependency>
           <groupId>com.sun</groupId>
           <artifactId>tools</artifactId>
-          <version>1.4.2</version>
+          <version>1.5</version>
           <scope>system</scope>
           <systemPath>${java.home}/../lib/tools.jar</systemPath>
         </dependency>
diff --git a/activemq-unit-tests/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java b/activemq-unit-tests/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java
index a5233ee14..416987a19 100644
--- a/activemq-unit-tests/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java
+++ b/activemq-unit-tests/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java
@@ -59,6 +59,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -74,11 +75,11 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
 
     private final TestSupport.PersistenceAdapterChoice persistenceAdapterChoice;
 
-    @Parameterized.Parameters
+    @Parameters(name="{0}")
     public static Collection<TestSupport.PersistenceAdapterChoice[]> getTestParameters() {
-        TestSupport.PersistenceAdapterChoice[] kahaDb = {TestSupport.PersistenceAdapterChoice.KahaDB};
-        TestSupport.PersistenceAdapterChoice[] levelDb = {TestSupport.PersistenceAdapterChoice.LevelDB};
-        TestSupport.PersistenceAdapterChoice[] mem = {TestSupport.PersistenceAdapterChoice.MEM};
+        TestSupport.PersistenceAdapterChoice[] kahaDb = { TestSupport.PersistenceAdapterChoice.KahaDB };
+        TestSupport.PersistenceAdapterChoice[] levelDb = { TestSupport.PersistenceAdapterChoice.LevelDB };
+        TestSupport.PersistenceAdapterChoice[] mem = { TestSupport.PersistenceAdapterChoice.MEM };
         List<TestSupport.PersistenceAdapterChoice[]> choices = new ArrayList<TestSupport.PersistenceAdapterChoice[]>();
         choices.add(kahaDb);
         choices.add(levelDb);
@@ -102,8 +103,8 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
 
         // preload the durable consumers
         double[] inactiveConsumerStats = produceMessages(destination, 500, 10, session, producer, null);
-        LOG.info("With inactive consumers: ave: " + inactiveConsumerStats[1]
-                + ", max: " + inactiveConsumerStats[0] + ", multiplier: " + (inactiveConsumerStats[0]/inactiveConsumerStats[1]));
+        LOG.info("With inactive consumers: ave: " + inactiveConsumerStats[1] + ", max: " + inactiveConsumerStats[0] + ", multiplier: "
+            + (inactiveConsumerStats[0] / inactiveConsumerStats[1]));
 
         // periodically start a durable sub that has a backlog
         final int consumersToActivate = 5;
@@ -137,9 +138,10 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
 
         double[] statsWithActive = produceMessages(destination, 500, 10, session, producer, addConsumerSignal);
 
-        LOG.info(" with concurrent activate, ave: " + statsWithActive[1] + ", max: " + statsWithActive[0] + ", multiplier: " + (statsWithActive[0]/ statsWithActive[1]));
+        LOG.info(" with concurrent activate, ave: " + statsWithActive[1] + ", max: " + statsWithActive[0] + ", multiplier: "
+            + (statsWithActive[0] / statsWithActive[1]));
 
-        while(consumers.size() < consumersToActivate) {
+        while (consumers.size() < consumersToActivate) {
             TimeUnit.SECONDS.sleep(2);
         }
 
@@ -149,24 +151,18 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
             timeToFirstAccumulator += time;
             LOG.info("Time to first " + time);
         }
-        LOG.info("Ave time to first message =" + timeToFirstAccumulator/consumers.size());
+        LOG.info("Ave time to first message =" + timeToFirstAccumulator / consumers.size());
 
         for (TimedMessageListener listener : consumers.values()) {
             LOG.info("Ave batch receipt time: " + listener.waitForReceivedLimit(10000) + " max receipt: " + listener.maxReceiptTime);
         }
 
-        //assertTrue("max (" + statsWithActive[0] + ") within reasonable multiplier of ave (" + statsWithActive[1] + ")",
-        //        statsWithActive[0] < 5 * statsWithActive[1]);
-
         // compare no active to active
-        LOG.info("Ave send time with active: " + statsWithActive[1]
-                + " as multiplier of ave with none active: " + inactiveConsumerStats[1]
-                + ", multiplier=" + (statsWithActive[1]/inactiveConsumerStats[1]));
-
-        assertTrue("Ave send time with active: " + statsWithActive[1]
-                + " within reasonable multpler of ave with none active: " + inactiveConsumerStats[1]
-                + ", multiplier " + (statsWithActive[1]/inactiveConsumerStats[1]),
-                statsWithActive[1] < 15 * inactiveConsumerStats[1]);
+        LOG.info("Ave send time with active: " + statsWithActive[1] + " as multiplier of ave with none active: " + inactiveConsumerStats[1] + ", multiplier="
+            + (statsWithActive[1] / inactiveConsumerStats[1]));
+
+        assertTrue("Ave send time with active: " + statsWithActive[1] + " within reasonable multpler of ave with none active: " + inactiveConsumerStats[1]
+            + ", multiplier " + (statsWithActive[1] / inactiveConsumerStats[1]), statsWithActive[1] < 15 * inactiveConsumerStats[1]);
     }
 
     public void x_testSendWithInactiveAndActiveConsumers() throws Exception {
@@ -189,12 +185,11 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
 
         double[] withConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);
 
-        LOG.info("With consumer: " + withConsumerStats[1] + " , with noConsumer: " + noConsumerStats[1]
-                + ", multiplier: " + (withConsumerStats[1]/noConsumerStats[1]));
+        LOG.info("With consumer: " + withConsumerStats[1] + " , with noConsumer: " + noConsumerStats[1] + ", multiplier: "
+            + (withConsumerStats[1] / noConsumerStats[1]));
         final int reasonableMultiplier = 15; // not so reasonable but improving
-        assertTrue("max X times as slow with consumer: " + withConsumerStats[1] + ", with no Consumer: "
-                + noConsumerStats[1] + ", multiplier: " + (withConsumerStats[1]/noConsumerStats[1]),
-                withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);
+        assertTrue("max X times as slow with consumer: " + withConsumerStats[1] + ", with no Consumer: " + noConsumerStats[1] + ", multiplier: "
+            + (withConsumerStats[1] / noConsumerStats[1]), withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);
 
         final int toReceive = toSend * numIterations * consumerCount * 2;
         Wait.waitFor(new Wait.Condition() {
@@ -217,7 +212,7 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
     private void startInactiveConsumers(ConnectionFactory factory, Destination destination) throws Exception {
         // create off line consumers
         startConsumers(factory, destination);
-        for (Connection connection: connections) {
+        for (Connection connection : connections) {
             connection.close();
         }
         connections.clear();
@@ -240,7 +235,7 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
         conn.start();
 
         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
-        final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic)dest, name);
+        final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic) dest, name);
 
         return consumer;
     }
@@ -249,22 +244,18 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
      * @return max and ave send time
      * @throws Exception
      */
-    private double[] produceMessages(Destination destination,
-                                     final int toSend,
-                                     final int numIterations,
-                                     Session session,
-                                     MessageProducer producer,
-                                     Object addConsumerSignal) throws Exception {
+    private double[] produceMessages(Destination destination, final int toSend, final int numIterations, Session session, MessageProducer producer,
+        Object addConsumerSignal) throws Exception {
         long start;
         long count = 0;
         double batchMax = 0, max = 0, sum = 0;
-        for (int i=0; i<numIterations; i++) {
+        for (int i = 0; i < numIterations; i++) {
             start = System.currentTimeMillis();
-            for (int j=0; j < toSend; j++) {
+            for (int j = 0; j < toSend; j++) {
                 long singleSendstart = System.currentTimeMillis();
                 TextMessage msg = createTextMessage(session, "" + j);
                 // rotate
-                int priority = ((int)count%10);
+                int priority = ((int) count % 10);
                 producer.send(msg, DeliveryMode.PERSISTENT, priority, 0);
                 max = Math.max(max, (System.currentTimeMillis() - singleSendstart));
                 if (++count % 500 == 0) {
@@ -274,7 +265,8 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
                             LOG.info("Signalled add consumer");
                         }
                     }
-                };
+                }
+                ;
                 if (count % 5000 == 0) {
                     LOG.info("Sent " + count + ", singleSendMax:" + max);
                 }
@@ -283,12 +275,11 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
             long duration = System.currentTimeMillis() - start;
             batchMax = Math.max(batchMax, duration);
             sum += duration;
-            LOG.info("Iteration " + i + ", sent " + toSend + ", time: "
-                    + duration + ", batchMax:" + batchMax + ", singleSendMax:" + max);
+            LOG.info("Iteration " + i + ", sent " + toSend + ", time: " + duration + ", batchMax:" + batchMax + ", singleSendMax:" + max);
         }
 
         LOG.info("Sent: " + toSend * numIterations + ", batchMax: " + batchMax + " singleSendMax: " + max);
-        return new double[]{batchMax, sum/numIterations};
+        return new double[] { batchMax, sum / numIterations };
     }
 
     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
@@ -344,8 +335,7 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
         policy.setPrioritizedMessages(true);
         policy.setMaxPageSize(500);
 
-        StorePendingDurableSubscriberMessageStoragePolicy durableSubPending =
-                new StorePendingDurableSubscriberMessageStoragePolicy();
+        StorePendingDurableSubscriberMessageStoragePolicy durableSubPending = new StorePendingDurableSubscriberMessageStoragePolicy();
         durableSubPending.setImmediatePriorityDispatch(true);
         durableSubPending.setUseCache(true);
         policy.setPendingDurableSubscriberPolicy(durableSubPending);
@@ -354,45 +344,14 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
         policyMap.setDefaultEntry(policy);
         brokerService.setDestinationPolicy(policyMap);
 
-//        if (false) {
-//            // external mysql works a lot faster
-//            //
-//            JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
-//            BasicDataSource ds = new BasicDataSource();
-//            com.mysql.jdbc.Driver d = new com.mysql.jdbc.Driver();
-//            ds.setDriverClassName("com.mysql.jdbc.Driver");
-//            ds.setUrl("jdbc:mysql://localhost/activemq?relaxAutoCommit=true");
-//            ds.setMaxActive(200);
-//            ds.setUsername("root");
-//            ds.setPassword("");
-//            ds.setPoolPreparedStatements(true);
-//            jdbc.setDataSource(ds);
-//            brokerService.setPersistenceAdapter(jdbc);
-
-            /* add mysql bits to the pom in the testing dependencies
-                    <dependency>
-                        <groupId>mysql</groupId>
-                        <artifactId>mysql-connector-java</artifactId>
-                        <version>5.1.10</version>
-                        <scope>test</scope>
-                    </dependency>
-                    <dependency>
-                        <groupId>commons-dbcp</groupId>
-                        <artifactId>commons-dbcp</artifactId>
-                        <version>1.2.2</version>
-                        <scope>test</scope>
-                    </dependency>
-             */
-//        } else {
-            setPersistenceAdapter(brokerService, persistenceAdapterChoice);
-//        }
+        setPersistenceAdapter(brokerService, persistenceAdapterChoice);
+
         return brokerService;
     }
 
     @Override
     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
-        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
-            broker.getTransportConnectors().get(0).getPublishableConnectString());
+        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString());
         ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
         prefetchPolicy.setAll(1);
         factory.setPrefetchPolicy(prefetchPolicy);
@@ -420,9 +379,10 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
             int priority = 0;
             try {
                 priority = message.getJMSPriority();
-            } catch (JMSException ignored) {}
+            } catch (JMSException ignored) {
+            }
             if (!messageLists.containsKey(priority)) {
-                MessageIdList perPriorityList =  new MessageIdList();
+                MessageIdList perPriorityList = new MessageIdList();
                 perPriorityList.setParent(allMessagesList);
                 messageLists.put(priority, perPriorityList);
             }
@@ -433,7 +393,7 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
                 LOG.info("First receipt in " + firstReceipt + "ms");
             } else if (count.get() % batchSize == 0) {
                 LOG.info("Consumed " + count.get() + " in " + batchReceiptAccumulator + "ms" + ", priority:" + priority);
-                batchReceiptAccumulator=0;
+                batchReceiptAccumulator = 0;
             }
             maxReceiptTime = Math.max(maxReceiptTime, duration);
             receiptAccumulator += duration;
@@ -451,7 +411,7 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
         }
 
         public long waitForReceivedLimit(long limit) throws Exception {
-            final long expiry = System.currentTimeMillis() + 30*60*1000;
+            final long expiry = System.currentTimeMillis() + 30 * 60 * 1000;
             while (count.get() < limit) {
                 if (System.currentTimeMillis() > expiry) {
                     throw new RuntimeException("Expired waiting for X messages, " + limit);
@@ -464,7 +424,7 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
                 }
 
             }
-            return receiptAccumulator/(limit/batchSize);
+            return receiptAccumulator / (limit / batchSize);
         }
 
         private String findFirstMissingMessage() {
@@ -476,9 +436,9 @@ public class ConcurrentProducerDurableConsumerTest extends TestSupport {
                     if (previous == null) {
                         previous = current.copy();
                     } else {
-                        if (current.getProducerSequenceId() - 1 != previous.getProducerSequenceId() &&
-                            current.getProducerSequenceId() - 10 !=  previous.getProducerSequenceId()) {
-                                return "Missing next after: " + previous + ", got: " + current;
+                        if (current.getProducerSequenceId() - 1 != previous.getProducerSequenceId()
+                            && current.getProducerSequenceId() - 10 != previous.getProducerSequenceId()) {
+                            return "Missing next after: " + previous + ", got: " + current;
                         } else {
                             previous = current.copy();
                         }
diff --git a/activemq-unit-tests/src/test/java/org/apache/activemq/usecases/DurableSubscriptionWithNoLocalTest.java b/activemq-unit-tests/src/test/java/org/apache/activemq/usecases/DurableSubscriptionWithNoLocalTest.java
new file mode 100644
index 000000000..4ecf81195
--- /dev/null
+++ b/activemq-unit-tests/src/test/java/org/apache/activemq/usecases/DurableSubscriptionWithNoLocalTest.java
@@ -0,0 +1,345 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.usecases;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+import java.io.File;
+
+import javax.jms.Session;
+import javax.jms.Topic;
+import javax.jms.TopicConnection;
+import javax.jms.TopicPublisher;
+import javax.jms.TopicSession;
+import javax.jms.TopicSubscriber;
+
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.broker.BrokerService;
+import org.apache.activemq.broker.TransportConnector;
+import org.apache.activemq.command.CommandTypes;
+import org.apache.activemq.store.kahadb.KahaDBStore;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Test for spec compliance for durable subscriptions that change the noLocal flag.
+ */
+public class DurableSubscriptionWithNoLocalTest {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DurableSubscriptionWithNoLocalTest.class);
+
+    private final int MSG_COUNT = 10;
+    private final String KAHADB_DIRECTORY = "target/activemq-data/";
+
+    @Rule public TestName name = new TestName();
+
+    private BrokerService brokerService;
+    private String connectionUri;
+    private ActiveMQConnectionFactory factory;
+
+    @Before
+    public void setUp() throws Exception {
+        createBroker(true);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        brokerService.stop();
+        brokerService.waitUntilStopped();
+    }
+
+    @Ignore("Requires Broker be able to remove and recreate on noLocal change")
+    @Test(timeout = 60000)
+    public void testDurableSubWithNoLocalChange() throws Exception {
+        TopicConnection connection = factory.createTopicConnection();
+
+        connection.setClientID(getClientId());
+        connection.start();
+
+        TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
+        Topic topic = session.createTopic(getDestinationName());
+        TopicPublisher publisher = session.createPublisher(topic);
+
+        LOG.debug("Create DurableSubscriber with noLocal = true");
+        TopicSubscriber subscriber = session.createSubscriber(topic);
+        TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.info("Attempting to receive messages from non-durable subscriber");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            assertNotNull(subscriber.receive(500));
+        }
+
+        LOG.info("Attempting to receive messages from (noLocal=true) subscriber");
+        assertNull(durableSub.receive(500));
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.debug("Close DurableSubscriber with noLocal=true");
+        durableSub.close();
+
+        LOG.debug("Create DurableSubscriber with noLocal=false");
+        durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);
+
+        LOG.info("Attempting to receive messages from reconnected (noLocal=false) subscription");
+        assertNull(durableSub.receive(500));
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.info("Attempting to receive messages from (noLocal=false) durable subscriber");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            assertNotNull(durableSub.receive(500));
+        }
+
+        // Should be empty now
+        assertNull(durableSub.receive(100));
+    }
+
+    @Ignore("Requires Broker be able to remove and recreate on noLocal change")
+    @Test(timeout = 60000)
+    public void testInvertedDurableSubWithNoLocalChange() throws Exception {
+        TopicConnection connection = factory.createTopicConnection();
+
+        connection.setClientID(getClientId());
+        connection.start();
+
+        TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
+        Topic topic = session.createTopic(getDestinationName());
+        TopicPublisher publisher = session.createPublisher(topic);
+
+        LOG.debug("Create DurableSubscriber with noLocal = true");
+        TopicSubscriber subscriber = session.createSubscriber(topic);
+        TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.info("Attempting to receive messages from non-durable subscriber");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            assertNotNull(subscriber.receive(500));
+        }
+
+        LOG.info("Attempting to receive messages from (noLocal=false) durable subscriber");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            assertNotNull(durableSub.receive(500));
+        }
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.debug("Close DurableSubscriber with noLocal=true");
+        durableSub.close();
+
+        LOG.debug("Create DurableSubscriber with noLocal=false");
+        durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);
+
+        LOG.info("Attempting to receive messages from reconnected (noLocal=true) subscription");
+        assertNull(durableSub.receive(500));
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.info("Attempting to receive messages from reconnected (noLocal=true) subscription");
+        assertNull(durableSub.receive(500));
+
+        // Should be empty now
+        assertNull(durableSub.receive(100));
+    }
+
+    @Test(timeout = 60000)
+    public void testDurableSubWithNoLocalChangeAfterRestart() throws Exception {
+        TopicConnection connection = factory.createTopicConnection();
+
+        connection.setClientID(getClientId());
+        connection.start();
+
+        TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
+        Topic topic = session.createTopic(getDestinationName());
+        TopicPublisher publisher = session.createPublisher(topic);
+
+        LOG.debug("Create DurableSubscriber with noLocal = true");
+        TopicSubscriber subscriber = session.createSubscriber(topic);
+        TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.info("Attempting to receive messages from non-durable subscriber");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            assertNotNull(subscriber.receive(500));
+        }
+
+        LOG.info("Attempting to receive messages from (noLocal=true) subscriber");
+        assertNull(durableSub.receive(500));
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        tearDown();
+        createBroker(false);
+
+        connection = factory.createTopicConnection();
+        connection.setClientID(getClientId());
+        connection.start();
+
+        session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
+        topic = session.createTopic(getDestinationName());
+        publisher = session.createPublisher(topic);
+
+        LOG.debug("Create DurableSubscriber with noLocal=false");
+        durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);
+
+        LOG.info("Attempting to receive messages from reconnected (noLocal=false) subscription");
+        assertNull(durableSub.receive(500));
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.info("Attempting to receive messages from (noLocal=false) durable subscriber");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            assertNotNull(durableSub.receive(500));
+        }
+
+        // Should be empty now
+        assertNull(durableSub.receive(100));
+    }
+
+    @Ignore("Requires Broker be able to remove and recreate on noLocal change")
+    @Test(timeout = 60000)
+    public void testInvertedDurableSubWithNoLocalChangeAfterRestart() throws Exception {
+        TopicConnection connection = factory.createTopicConnection();
+
+        connection.setClientID(getClientId());
+        connection.start();
+
+        TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
+        Topic topic = session.createTopic(getDestinationName());
+        TopicPublisher publisher = session.createPublisher(topic);
+
+        LOG.debug("Create DurableSubscriber with noLocal = true");
+        TopicSubscriber subscriber = session.createSubscriber(topic);
+        TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.info("Attempting to receive messages from non-durable subscriber");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            assertNotNull(subscriber.receive(500));
+        }
+
+        LOG.info("Attempting to receive messages from (noLocal=false) durable subscriber");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            assertNotNull(durableSub.receive(500));
+        }
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        tearDown();
+        createBroker(false);
+
+        connection = factory.createTopicConnection();
+        connection.setClientID(getClientId());
+        connection.start();
+
+        session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
+        topic = session.createTopic(getDestinationName());
+        publisher = session.createPublisher(topic);
+
+        LOG.debug("Create DurableSubscriber with noLocal=true");
+        durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);
+
+        LOG.info("Attempting to receive messages from (noLocal=true) subscriber");
+        assertNull(durableSub.receive(500));
+
+        LOG.debug("Sending " + MSG_COUNT + " messages to topic");
+        for (int i = 0; i < MSG_COUNT; i++) {
+            publisher.publish(session.createMessage());
+        }
+
+        LOG.info("Attempting to receive messages from (noLocal=true) subscriber");
+        assertNull(durableSub.receive(500));
+
+        // Should be empty now
+        assertNull(durableSub.receive(100));
+    }
+
+    private void createBroker(boolean deleteAllMessages) throws Exception {
+        KahaDBStore kaha = new KahaDBStore();
+        kaha.setDirectory(new File(KAHADB_DIRECTORY + "-" + name.getMethodName()));
+
+        brokerService = new BrokerService();
+        brokerService.setPersistent(true);
+        brokerService.setPersistenceAdapter(kaha);
+        brokerService.setStoreOpenWireVersion(CommandTypes.PROTOCOL_VERSION);
+        brokerService.setUseJmx(false);
+        brokerService.setDeleteAllMessagesOnStartup(deleteAllMessages);
+        TransportConnector connector = brokerService.addConnector("tcp://0.0.0.0:0");
+
+        brokerService.start();
+        brokerService.waitUntilStarted();
+
+        connectionUri = connector.getPublishableConnectString();
+        factory = new ActiveMQConnectionFactory(connectionUri);
+    }
+
+    private String getDestinationName() {
+        return name.getMethodName();
+    }
+
+    private String getClientId() {
+        return name.getMethodName() + "-Client";
+    }
+
+    private String getSubscriptionName() {
+        return name.getMethodName() + "-Subscription";
+    }
+}
