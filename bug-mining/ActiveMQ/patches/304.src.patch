diff --git a/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionPoolImpl.java b/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionPoolImpl.java
index 5798c9387..dae5af9d2 100755
--- a/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionPoolImpl.java
+++ b/activemq-ra/src/main/java/org/apache/activemq/ra/ServerSessionPoolImpl.java
@@ -20,6 +20,8 @@ import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 import javax.jms.JMSException;
 import javax.jms.ServerSession;
@@ -45,9 +47,10 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
     private final ActiveMQEndpointWorker activeMQAsfEndpointWorker;
     private final int maxSessions;
 
-    private List<ServerSessionImpl> idleSessions = new ArrayList<ServerSessionImpl>();
-    private List<ServerSessionImpl> activeSessions = new ArrayList<ServerSessionImpl>();
-    private AtomicBoolean closing = new AtomicBoolean(false);
+    private final List<ServerSessionImpl> idleSessions = new ArrayList<ServerSessionImpl>();
+    private final List<ServerSessionImpl> activeSessions = new ArrayList<ServerSessionImpl>();
+    private final Lock sessionLock = new ReentrantLock();
+    private final AtomicBoolean closing = new AtomicBoolean(false);
 
     public ServerSessionPoolImpl(ActiveMQEndpointWorker activeMQAsfEndpointWorker, int maxSessions) {
         this.activeMQAsfEndpointWorker = activeMQAsfEndpointWorker;
@@ -100,48 +103,32 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
         if (closing.get()) {
             throw new JMSException("Session Pool Shutting Down.");
         }
-
         ServerSessionImpl ss = null;
-        synchronized (idleSessions) {
-            if (idleSessions.size() > 0) {
-                ss = idleSessions.remove(idleSessions.size() - 1);
-            }
+        sessionLock.lock();
+        try {
+            ss = getExistingServerSession(false);
+        } finally {
+            sessionLock.unlock();
         }
         if (ss != null) {
-            synchronized (activeSessions) {
-                activeSessions.add(ss);
-            }
-            if (LOG.isDebugEnabled()) {
-                LOG.debug("Using idle session: " + ss);
-            }
             return ss;
         }
-
-        synchronized (activeSessions) {
-            // Are we at the upper limit?
-            if (activeSessions.size() >= maxSessions) {
-                // then reuse the already created sessions..
-                // This is going to queue up messages into a session for
-                // processing.
-                return getExistingServerSession();
-            }
-        }
-
         ss = createServerSessionImpl();
-        // We may not be able to create a session due to the container
-        // restricting us.
-        if (ss == null) {
-            synchronized (activeSessions) {
-                if (activeSessions.isEmpty()) {
-                    throw new JMSException(
-                            "Endpoint factory did not allow creation any endpoints.");
+        sessionLock.lock();
+        try {
+            // We may not be able to create a session due to the container
+            // restricting us.
+            if (ss == null) {
+                if (activeSessions.isEmpty() && idleSessions.isEmpty()) {
+                    throw new JMSException("Endpoint factory did not allow creation of any endpoints.");
                 }
-            }
 
-            return getExistingServerSession();
-        }
-        synchronized (activeSessions) {
-            activeSessions.add(ss);
+                ss = getExistingServerSession(true);
+            } else {
+                activeSessions.add(ss);
+            }
+        } finally {
+            sessionLock.unlock();
         }
         if (LOG.isDebugEnabled()) {
             LOG.debug("Created a new session: " + ss);
@@ -151,36 +138,39 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
     }
 
     /**
-     * @param messageDispatch
-     *            the message to dispatch
-     * @throws JMSException
+     * Must be called with sessionLock held.
+     * Returns an idle session if one exists or an active session if no more
+     * sessions can be created.  Sessions can not be created if force is true
+     * or activeSessions >= maxSessions.
+     * @param force do not check activeSessions >= maxSessions, return an active connection anyway.
+     * @return an already existing session.
      */
-    private void dispatchToSession(MessageDispatch messageDispatch)
-            throws JMSException {
-
-        ServerSession serverSession = getServerSession();
-        Session s = serverSession.getSession();
-        ActiveMQSession session = null;
-        if (s instanceof ActiveMQSession) {
-            session = (ActiveMQSession) s;
-        } else if (s instanceof ActiveMQQueueSession) {
-            session = (ActiveMQSession) s;
-        } else if (s instanceof ActiveMQTopicSession) {
-            session = (ActiveMQSession) s;
-        } else {
-            activeMQAsfEndpointWorker.connection
-                    .onAsyncException(new JMSException(
-                            "Session pool provided an invalid session type: "
-                                    + s.getClass()));
+    private ServerSessionImpl getExistingServerSession(boolean force) {
+        ServerSessionImpl ss = null;
+        if (idleSessions.size() > 0) {
+            ss = idleSessions.remove(idleSessions.size() - 1);
         }
-        session.dispatch(messageDispatch);
-        serverSession.start();
+        if (ss != null) {
+            activeSessions.add(ss);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Using idle session: " + ss);
+            }
+        } else if (force || activeSessions.size() >= maxSessions) {
+            // If we are at the upper limit
+            // then reuse the already created sessions..
+            // This is going to queue up messages into a session for
+            // processing.
+            ss = getExistingActiveServerSession();
+        }
+        return ss;
     }
 
     /**
+     * Must be called with sessionLock held.
+     * Returns the first session from activeSessions, shifting it to last.
      * @return session
      */
-    private ServerSession getExistingServerSession() {
+    private ServerSessionImpl getExistingActiveServerSession() {
         ServerSessionImpl ss = null;
         if (!activeSessions.isEmpty()) {
             if (activeSessions.size() > 1) {
@@ -201,11 +191,12 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
         if (LOG.isDebugEnabled()) {
             LOG.debug("Session returned to pool: " + ss);
         }
-        synchronized(activeSessions) {
+        sessionLock.lock();
+        try {
             activeSessions.remove(ss);
-        }
-        synchronized(idleSessions) {
             idleSessions.add(ss);
+        } finally {
+            sessionLock.unlock();
         }
         synchronized (closing) {
             closing.notify();
@@ -213,8 +204,11 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
     }
 
     public void removeFromPool(ServerSessionImpl ss) {
-        synchronized(activeSessions) {
+        sessionLock.lock();
+        try {
             activeSessions.remove(ss);
+        } finally {
+            sessionLock.unlock();
         }
         try {
             ActiveMQSession session = (ActiveMQSession)ss.getSession();
@@ -231,15 +225,42 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
         }
     }
 
+    /**
+     * @param messageDispatch
+     *            the message to dispatch
+     * @throws JMSException
+     */
+    private void dispatchToSession(MessageDispatch messageDispatch)
+            throws JMSException {
+
+        ServerSession serverSession = getServerSession();
+        Session s = serverSession.getSession();
+        ActiveMQSession session = null;
+        if (s instanceof ActiveMQSession) {
+            session = (ActiveMQSession) s;
+        } else if (s instanceof ActiveMQQueueSession) {
+            session = (ActiveMQSession) s;
+        } else if (s instanceof ActiveMQTopicSession) {
+            session = (ActiveMQSession) s;
+        } else {
+            activeMQAsfEndpointWorker.connection
+                    .onAsyncException(new JMSException(
+                            "Session pool provided an invalid session type: "
+                                    + s.getClass()));
+        }
+        session.dispatch(messageDispatch);
+        serverSession.start();
+    }
+
     public void close() {
         closing.set(true);
-        closeIdleSessions();
+        int activeCount = closeIdleSessions();
         // we may have to wait erroneously 250ms if an
         // active session is removed during our wait and we
         // are not notified
-        while (getActiveSessionSize() > 0) {
+        while (activeCount > 0) {
             if (LOG.isDebugEnabled()) {
-                LOG.debug("Active Sessions = " + getActiveSessionSize());
+                LOG.debug("Active Sessions = " + activeCount);
             }
             try {
                 synchronized (closing) {
@@ -249,18 +270,21 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
                 Thread.currentThread().interrupt();
                 return;
             }
-            closeIdleSessions();
+            activeCount = closeIdleSessions();
         }
     }
-    
 
-    private void closeIdleSessions() {
-        synchronized(idleSessions) {
-            for (Iterator<ServerSessionImpl> iter = idleSessions.iterator(); iter.hasNext();) {
-                ServerSessionImpl ss = iter.next();
+
+    private int closeIdleSessions() {
+        sessionLock.lock();
+        try {
+            for (ServerSessionImpl ss : idleSessions) {
                 ss.close();
             }
             idleSessions.clear();
+            return activeSessions.size();
+        } finally {
+            sessionLock.unlock();
         }
     }
 
@@ -270,18 +294,12 @@ public class ServerSessionPoolImpl implements ServerSessionPool {
     public boolean isClosing() {
         return closing.get();
     }
-    
+
     /**
      * @param closing The closing to set.
      */
     public void setClosing(boolean closing) {
         this.closing.set(closing);
     }
-    
-    private int getActiveSessionSize() {
-        synchronized(activeSessions) {
-            return activeSessions.size();
-        }
-    }
 
 }
