<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 06:36:00 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[AMQ-6067] OutOfMemoryError when expiring big amount of topic messages</title>
                <link>https://issues.apache.org/jira/browse/AMQ-6067</link>
                <project id="12311210" key="AMQ">ActiveMQ Classic</project>
                    <description>&lt;p&gt;There is a problem in&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;org.apache.activemq.broker.region.Topic.expireMessagesTask
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;When there are big amount of topic messages that are going to be expired, this &lt;tt&gt;expireMessagesTask&lt;/tt&gt; loads all of the messages to memory. This causes&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;2015-11-24 11:05:46.359 WARN  [ActiveMQ Broker[JmsEngineActivemqBroker] Scheduler] [Topic] Failed to browse Topic: test-topic
java.lang.OutOfMemoryError: Java heap space
	at oracle.sql.BLOB.getBytes(BLOB.java:204)
	at oracle.jdbc.driver.T4CBlobAccessor.getBytes(T4CBlobAccessor.java:464)
	at oracle.jdbc.driver.OracleResultSetImpl.getBytes(OracleResultSetImpl.java:676)
	at org.apache.commons.dbcp.DelegatingResultSet.getBytes(DelegatingResultSet.java:203)
	at org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.getBinaryData(DefaultJDBCAdapter.java:80)
	at org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doRecover(DefaultJDBCAdapter.java:418)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:309)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:183)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)
	at org.springframework.aop.interceptor.AbstractTraceInterceptor.invoke(AbstractTraceInterceptor.java:113)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)
	at $Proxy14.doRecover(Unknown Source)
	at org.apache.activemq.store.jdbc.JDBCMessageStore.recover(JDBCMessageStore.java:236)
	at org.apache.activemq.store.ProxyTopicMessageStore.recover(ProxyTopicMessageStore.java:62)
	at org.apache.activemq.broker.region.Topic.doBrowse(Topic.java:594)
	at org.apache.activemq.broker.region.Topic.access$100(Topic.java:65)
	at org.apache.activemq.broker.region.Topic$6.run(Topic.java:733)
	at org.apache.activemq.thread.SchedulerTimerTask.run(SchedulerTimerTask.java:33)
	at java.util.TimerThread.mainLoop(Timer.java:512)
	at java.util.TimerThread.run(Timer.java:462)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The problem happens when using JDBC persistency with ActiveMQ 5.10.0. After a short look to source code, the same problem could be also with 5.12.1.&lt;/p&gt;

&lt;p&gt;Test case:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;run ActiveMQ broker with JDBC persistency&lt;/li&gt;
	&lt;li&gt;create subscription to a topic, but do not receive the messages&lt;/li&gt;
	&lt;li&gt;send enough number of messages with short TimeToLive&lt;/li&gt;
	&lt;li&gt;when expireMessagesTask is scheduled, it tries to load all of the messages and causes the OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It would be fine if&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;org.apache.activemq.store.jdbc.JDBCMessageStore.recover(MessageRecoveryListener)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;will be updated like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void recover(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; MessageRecoveryListener listener) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
  &lt;span class=&quot;code-comment&quot;&gt;// Get all the Message ids out of the database.
&lt;/span&gt;  TransactionContext c = persistenceAdapter.getTransactionContext();
  &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
    c = persistenceAdapter.getTransactionContext();
    adapter.doRecover(c, destination, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; JDBCMessageRecoveryListener() {
      &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; recoverMessage(&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; sequenceId, &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] data) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (listener.hasSpace()) {
          Message msg = (Message)wireFormat.unmarshal(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ByteSequence(data));
          msg.getMessageId().setBrokerSequenceId(sequenceId);
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; listener.recoverMessage(msg);
        } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
          logger.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Recovery limit of the messages has exceeded.&quot;&lt;/span&gt;);
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
        }                    
      }

      &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; recoverMessageReference(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; reference) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (listener.hasSpace()) {
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; listener.recoverMessageReference(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MessageId(reference));
        } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
          logger.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Recovery limit of the message references has exceeded.&quot;&lt;/span&gt;);
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
        }
      }
    });
  } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (SQLException e) {
    JDBCPersistenceAdapter.log(&lt;span class=&quot;code-quote&quot;&gt;&quot;JDBC Failure: &quot;&lt;/span&gt;, e);
    &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; IOExceptionSupport.create(&lt;span class=&quot;code-quote&quot;&gt;&quot;Failed to recover container. Reason: &quot;&lt;/span&gt; + e, e);
  } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
    c.close();
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But I am not sure if this limitation is the best way, because there will be some messages that should be expired, but need to wait. So better solution might be to do this job in more separated transactions.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12916971">AMQ-6067</key>
            <summary>OutOfMemoryError when expiring big amount of topic messages</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="cshannon">Christopher L. Shannon</assignee>
                                    <reporter username="phavran">Petr Havr&#225;nek</reporter>
                        <labels>
                            <label>durable</label>
                            <label>durable_subscription</label>
                            <label>expiration</label>
                            <label>jdbc</label>
                            <label>timeToLive,</label>
                    </labels>
                <created>Mon, 30 Nov 2015 14:42:12 +0000</created>
                <updated>Fri, 26 Aug 2016 18:35:13 +0000</updated>
                            <resolved>Fri, 26 Aug 2016 18:34:12 +0000</resolved>
                                    <version>5.10.0</version>
                                    <fixVersion>5.14.1</fixVersion>
                    <fixVersion>5.15.0</fixVersion>
                                    <component>JDBC</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="15032054" author="gtully" created="Mon, 30 Nov 2015 16:41:29 +0000"  >&lt;p&gt;ideally we would be able to have a store cursor that would walk the messages in the store independent of the dispatch/prefetch cursors. In the meantime, the intent is that the destination memory limit or the MaxExpirePageSize (which ever is smaller) should limit a browse for expiry.&lt;br/&gt;
The logic in Queue.java does a loop paging in messages to reach the memory limit in maxPagesize chunks, that same logic could be applied to durable subs.&lt;br/&gt;
In any event, the limit needs to be checked via the hasSpace callback from the recover call so that fix looks sensible.&lt;/p&gt;</comment>
                            <comment id="15032071" author="gtully" created="Mon, 30 Nov 2015 16:57:26 +0000"  >&lt;p&gt;the follow up to &lt;a href=&quot;https://issues.apache.org/jira/browse/AMQ-3362&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/AMQ-3362&lt;/a&gt; introduced a fix and test for this.&lt;br/&gt;
Maybe that test can be tweaked to reproduce again, not sure from where the regression arrived.&lt;/p&gt;</comment>
                            <comment id="15365519" author="itsganu@gmail.com" created="Thu, 7 Jul 2016 02:55:07 +0000"  >&lt;p&gt;We still see this problem with 5.13.2, The outofmemory happens whenever I set the expiremessages other than 0. When I set to 0 and run the test  no OOO and also GC activity looks good.&lt;/p&gt;

&lt;p&gt;The other problem we see the durable topics does not seem to be getting cleaned up from active_msgs even if I set expiremessages to 60000 or 90000.&lt;/p&gt;</comment>
                            <comment id="15385691" author="smrui" created="Wed, 20 Jul 2016 11:13:44 +0000"  >&lt;p&gt;We also observed similar message &lt;/p&gt;

&lt;p&gt;2016-07-20 09:19:20,084 | WARN  | Failed to browse Topic: cemp | org.apache.activemq.broker.region.Topic | ActiveMQ Broker&lt;span class=&quot;error&quot;&gt;&amp;#91;localhost&amp;#93;&lt;/span&gt; Scheduler&lt;br/&gt;
java.lang.OutOfMemoryError: Java heap space&lt;/p&gt;

&lt;p&gt;Active MQ version: 5.13.3&lt;/p&gt;

&lt;p&gt;Could someone please check this issue, this has become big pain now&lt;br/&gt;
Every time we have to restart to over come this issue, the number of messages is quite huge and we&apos;re planning to send the records in chunk but not sure if that can solve this issue&lt;/p&gt;</comment>
                            <comment id="15407533" author="cszczotka" created="Thu, 4 Aug 2016 10:30:03 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
I see under debugger that for version 5.13.2 in org.apache.activemq.broker.region.Topic the expireMessagesTask does not check max expire page size which is passed as a parameter to the doBrowse method:&lt;/p&gt;

&lt;p&gt;private final Runnable expireMessagesTask = new Runnable() {&lt;br/&gt;
    @Override&lt;br/&gt;
    public void run() &lt;/p&gt;
{
        List&amp;lt;Message&amp;gt; browsedMessages = new InsertionCountList&amp;lt;Message&amp;gt;();
        doBrowse(browsedMessages, getMaxExpirePageSize());
    }
&lt;p&gt;};&lt;/p&gt;


&lt;p&gt;In my case I have default settings for max expire page size eq 400. In doBrowse method are collected all messages belongs to topic into browseList and never is checked max ( or called hasSpace internal method):&lt;/p&gt;

&lt;p&gt;private void doBrowse(final List&amp;lt;Message&amp;gt; browseList, final int max) {&lt;br/&gt;
    try {&lt;br/&gt;
        if (topicStore != null) {&lt;br/&gt;
            final List&amp;lt;Message&amp;gt; toExpire = new ArrayList&amp;lt;Message&amp;gt;();&lt;br/&gt;
            topicStore.recover(new MessageRecoveryListener() {&lt;br/&gt;
                @Override&lt;br/&gt;
                public boolean recoverMessage(Message message) throws Exception {&lt;br/&gt;
                    if (message.isExpired()) &lt;/p&gt;
{
                        toExpire.add(message);
                    }
&lt;p&gt;                    browseList.add(message);&lt;br/&gt;
                    return true;&lt;br/&gt;
                }&lt;/p&gt;

&lt;p&gt;                @Override&lt;br/&gt;
                public boolean recoverMessageReference(MessageId messageReference) throws Exception &lt;/p&gt;
{
                    return true;
                }

&lt;p&gt;                @Override&lt;br/&gt;
                public boolean hasSpace() &lt;/p&gt;
{
                    return browseList.size() &amp;lt; max;
                }

&lt;p&gt;                @Override&lt;br/&gt;
                public boolean isDuplicate(MessageId id) &lt;/p&gt;
{
                    return false;
                }
&lt;p&gt;            });&lt;br/&gt;
            final ConnectionContext connectionContext = createConnectionContext();&lt;br/&gt;
   ...&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;In other words if you have 1 000 000 messages under ACTIVEMQ_MSGS table for same topic all messages will be collected into memory ( browseList) and this can cause OutOfMemoryError.&lt;/p&gt;</comment>
                            <comment id="15407558" author="gtully" created="Thu, 4 Aug 2016 10:45:41 +0000"  >&lt;p&gt;Thank you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cszczotka&quot; class=&quot;user-hover&quot; rel=&quot;cszczotka&quot;&gt;cszczotka&lt;/a&gt;, that is indeed a bug, seems only return from recoverMessage is checked by the store.&lt;br/&gt;
maybe &lt;a href=&quot;https://github.com/apache/activemq/blob/e2b4ca2c59a316be91cf391c758a10e518dd3a1f/activemq-unit-tests/src/test/java/org/apache/activemq/usecases/ExpiredMessagesWithNoConsumerTest.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/activemq/blob/e2b4ca2c59a316be91cf391c758a10e518dd3a1f/activemq-unit-tests/src/test/java/org/apache/activemq/usecases/ExpiredMessagesWithNoConsumerTest.java&lt;/a&gt; can provide some inspiration for a unit test to capture this use case and the fix into the future.&lt;/p&gt;</comment>
                            <comment id="15411746" author="cszczotka" created="Mon, 8 Aug 2016 12:42:24 +0000"  >&lt;p&gt;Question is how we can mitigate this memory issue for system where is running amq 5.13.2. I  can  try to increase &#8211;Xmx, make smaller expireMessagesPeriods so we will expire messages more frequently. Do you see other options ?&lt;/p&gt;</comment>
                            <comment id="15411794" author="christopher.l.shannon" created="Mon, 8 Aug 2016 13:19:00 +0000"  >&lt;p&gt;Not much can be done to truly fix it without a patch.  In the recover method of DefaultJDBCAdapter there needs to be a hasSpace() check done in the recovery loop so it can abort early if memory is full just like KahaDB does.  The proposed fix posted above does exactly this check and looks good to me so it can probably be targeted for a 5.14.1 release.&lt;/p&gt;

&lt;p&gt;In the meantime, as you pointed out you can try things like more memory and smaller expire messages period to give yourself a better chance of not running out of memory.&lt;/p&gt;</comment>
                            <comment id="15413093" author="cszczotka" created="Tue, 9 Aug 2016 07:19:30 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
I see another issue in amq 5.13.2 related with topic message expiration.   I have one producer which send me messages to MyTopic and one durable subscriber/consumer. Messages are stored in DB and after 30 seconds amq broker trying to expire these messages ( I have configuration entry for this: &amp;lt;amq:policyEntry topic=&quot;MyTopic.&amp;gt;&quot; expireMessagesPeriod=&quot;30000&quot;&amp;gt; ). I&#8217;m getting NullPointerException from AdvisoryBroker and messages are never expired and remain in activemq_msgs table.&lt;/p&gt;

&lt;p&gt;java.lang.NullPointerException&lt;br/&gt;
	at org.apache.activemq.advisory.AdvisoryBroker.messageExpired(AdvisoryBroker.java:430)&lt;br/&gt;
	at org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:313)&lt;br/&gt;
	at org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:313)&lt;br/&gt;
	at org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:313)&lt;br/&gt;
	at org.apache.activemq.broker.MutableBrokerFilter.messageExpired(MutableBrokerFilter.java:325)&lt;br/&gt;
	at org.apache.activemq.broker.region.Topic.messageExpired(Topic.java:776)&lt;br/&gt;
	at org.apache.activemq.broker.region.Topic.doBrowse(Topic.java:660)&lt;/p&gt;

&lt;p&gt;It is logged on console as WARN:&lt;/p&gt;

&lt;p&gt;09:25:30.274 [ActiveMQ Broker&lt;span class=&quot;error&quot;&gt;&amp;#91;my-broker&amp;#93;&lt;/span&gt; Scheduler] WARN  org.apache.activemq.advisory.AdvisoryBroker - Failed to fire expired advisory, reason: java.lang.NullPointerException&lt;/p&gt;



&lt;p&gt;Under debugger I see that in org.apache.activemq.advisory.AdvisoryBroker.messageExpired  baseDestination is null and call baseDestination.getActiveMQDestination() generates NPE&lt;/p&gt;

&lt;p&gt;@Override&lt;br/&gt;
public void messageExpired(ConnectionContext context, MessageReference messageReference, Subscription subscription) {&lt;br/&gt;
    super.messageExpired(context, messageReference, subscription);&lt;br/&gt;
    try {&lt;br/&gt;
        if (!messageReference.isAdvisory()) {&lt;br/&gt;
            BaseDestination baseDestination = (BaseDestination) messageReference.getMessage().getRegionDestination();&lt;br/&gt;
            ActiveMQTopic topic = AdvisorySupport.getExpiredMessageTopic(baseDestination.getActiveMQDestination());&lt;/p&gt;

&lt;p&gt; Below is code how messages are produced:&lt;/p&gt;

&lt;p&gt;public static class Producer implements Runnable {&lt;br/&gt;
    public void run() {&lt;br/&gt;
        try {&lt;br/&gt;
            ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(BROKER_ULR);&lt;br/&gt;
            Connection connection = connectionFactory.createConnection();&lt;br/&gt;
            connection.start();&lt;br/&gt;
            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);&lt;br/&gt;
            Topic destination = session.createTopic(&quot;MyTopic&quot;);&lt;/p&gt;

&lt;p&gt;            MessageProducer producer = session.createProducer(destination);&lt;br/&gt;
            producer.setDeliveryMode(DeliveryMode.PERSISTENT);&lt;br/&gt;
            producer.setTimeToLive(30000);&lt;/p&gt;

&lt;p&gt;            for(int i =0; i &amp;lt; 10; i ++) &lt;/p&gt;
{
                String text = &quot;Message number &quot; + i +  &quot;  From: &quot; + Thread.currentThread().getName();
                TextMessage message = session.createTextMessage(text);
                message.setJMSDestination(destination);
                producer.send(destination, message);

                Thread.sleep(10000);
            }
&lt;p&gt;            // Clean up&lt;br/&gt;
            session.close();&lt;br/&gt;
            connection.close();&lt;br/&gt;
        }&lt;br/&gt;
        catch (Exception e) &lt;/p&gt;
{
            System.out.println(&quot;Caught: &quot; + e);
            e.printStackTrace();
        }
&lt;p&gt;    }&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;Under debugger I see that setter method setRegionDestination (org.apache.activemq.command.Message ) is called in org.apache.activemq.broker.region.Topic class before message is send:&lt;/p&gt;

&lt;p&gt;@Override&lt;br/&gt;
public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {&lt;br/&gt;
    final ConnectionContext context = producerExchange.getConnectionContext();&lt;/p&gt;

&lt;p&gt;    final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();&lt;br/&gt;
    producerExchange.incrementSend();&lt;br/&gt;
    final boolean sendProducerAck = !message.isResponseRequired() &amp;amp;&amp;amp; producerInfo.getWindowSize() &amp;gt; 0&lt;br/&gt;
            &amp;amp;&amp;amp; !context.isInRecoveryMode();&lt;/p&gt;

&lt;p&gt;    message.setRegionDestination(this);&lt;/p&gt;

&lt;p&gt;I don&#8217;t see call this setRegionDestination method when message is loaded from db into memory.&lt;/p&gt;

&lt;p&gt;Do you have any idea what can be wrong ? Is it issue in my messages (something is missing)  or it is another bug in amq code ?&lt;/p&gt;
</comment>
                            <comment id="15439460" author="jira-bot" created="Fri, 26 Aug 2016 17:50:10 +0000"  >&lt;p&gt;Commit b9fad53fc650a9026391bef0fd74aea1bea7ec1b in activemq&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cshannon&quot; class=&quot;user-hover&quot; rel=&quot;cshannon&quot;&gt;cshannon&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=b9fad53&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=b9fad53&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AMQ-6067&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/AMQ-6067&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The JDBCMessageStore now checks hasSpace() when running a message&lt;br/&gt;
recovery listener to prevent going past the max configured page size&lt;/p&gt;</comment>
                            <comment id="15439467" author="jira-bot" created="Fri, 26 Aug 2016 17:55:24 +0000"  >&lt;p&gt;Commit a99edb81757899a58d22c54a59294f7d86949659 in activemq&apos;s branch refs/heads/activemq-5.14.x from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cshannon&quot; class=&quot;user-hover&quot; rel=&quot;cshannon&quot;&gt;cshannon&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=a99edb8&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=a99edb8&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AMQ-6067&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/AMQ-6067&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The JDBCMessageStore now checks hasSpace() when running a message&lt;br/&gt;
recovery listener to prevent going past the max configured page size&lt;/p&gt;

&lt;p&gt;(cherry picked from commit b9fad53fc650a9026391bef0fd74aea1bea7ec1b)&lt;/p&gt;</comment>
                            <comment id="15439534" author="christopher.l.shannon" created="Fri, 26 Aug 2016 18:34:14 +0000"  >&lt;p&gt;Patch and test applied to master and 5.14.x.&lt;/p&gt;</comment>
                            <comment id="15439538" author="christopher.l.shannon" created="Fri, 26 Aug 2016 18:34:44 +0000"  >&lt;p&gt;You should create a new Jira for this issue so it can be tracked separately.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 12 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2p2gv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>