<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 06:03:03 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[AMQ-4938] Queue Messages lost after read timeout on REST API.</title>
                <link>https://issues.apache.org/jira/browse/AMQ-4938</link>
                <project id="12311210" key="AMQ">ActiveMQ Classic</project>
                    <description>&lt;p&gt;I have been trying to send/receive messages via a Queue using the &lt;a href=&quot;http://activemq.apache.org/rest.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;REST API&lt;/a&gt;. While testing I found that some messages got lost after a consuming request times out when no message is available.&lt;/p&gt;

&lt;p&gt;Here is a transcript of the test case I used:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;#
# OK: send first, consume later
#
$ curl -d &lt;span class=&quot;code-quote&quot;&gt;&quot;body=message&quot;&lt;/span&gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&quot;&lt;/span&gt;
&lt;/span&gt;Message sent

$ wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID&amp;amp;readTimeout=1000&quot;&lt;/span&gt;
&lt;/span&gt;message

#
# OK: start consuming, then send (within timeout)
#
$ wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID&amp;amp;readTimeout=5000&quot;&lt;/span&gt;&amp;amp;
&lt;/span&gt;[1] 5172

$ curl -d &lt;span class=&quot;code-quote&quot;&gt;&quot;body=message&quot;&lt;/span&gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&quot;&lt;/span&gt;
&lt;/span&gt;messageMessage sent[1]+  Fertig                  wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID&amp;amp;readTimeout=5000&quot;&lt;/span&gt;
&lt;/span&gt;
#
# NOK: start consuming, wait &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; timeout, then send and consume again
#
$ wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID&amp;amp;readTimeout=5000&quot;&lt;/span&gt;
&lt;/span&gt;
$ curl -d &lt;span class=&quot;code-quote&quot;&gt;&quot;body=message&quot;&lt;/span&gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&quot;&lt;/span&gt;
&lt;/span&gt;Message sent

$ wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID&amp;amp;readTimeout=5000&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The last &lt;b&gt;wget&lt;/b&gt; returns after the given read timeout without any message. When looking at the managament console, the message has been consumed.&lt;/p&gt;

&lt;p&gt;I tested this with 5.8.0 on linux as well as with 5.8.0, 5.9.0 and a freshly built 5.10.0 on windows.&lt;/p&gt;</description>
                <environment>&lt;p&gt;Win32, Linux&lt;/p&gt;</environment>
        <key id="12684816">AMQ-4938</key>
            <summary>Queue Messages lost after read timeout on REST API.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="tabish">Timothy A. Bish</assignee>
                                    <reporter username="psedi">Peter Eisenlohr</reporter>
                        <labels>
                    </labels>
                <created>Sun, 15 Dec 2013 16:00:35 +0000</created>
                <updated>Wed, 2 Apr 2014 22:06:53 +0000</updated>
                            <resolved>Thu, 16 Jan 2014 15:20:45 +0000</resolved>
                                    <version>5.8.0</version>
                    <version>5.9.0</version>
                    <version>5.10.0</version>
                                    <fixVersion>5.9.1</fixVersion>
                    <fixVersion>5.10.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="13851021" author="psedi" created="Tue, 17 Dec 2013 22:38:51 +0000"  >&lt;p&gt;After enabling DEBUG logging, I found the following output after &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;starting the server clean&lt;/li&gt;
	&lt;li&gt;wget --no-http-keep-alive -q -O - &quot;http://localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID&amp;amp;readTimeout=1000&quot;&lt;/li&gt;
	&lt;li&gt;curl -d &quot;body=message&quot; &quot;http://localhost:8161/api/message/TEST?type=queue&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;2013-12-17 23:28:52,121 | DEBUG | Async client internal exception occurred with no exception listener registered: java.lang.IllegalStateException: IDLE,initial | org.apache.activemq.ActiveMQConnection | ActiveMQ Session Task-1
java.lang.IllegalStateException: IDLE,initial
        at org.eclipse.jetty.server.AsyncContinuation.dispatch(AsyncContinuation.java:408)
        at org.eclipse.jetty.server.AsyncContinuation.resume(AsyncContinuation.java:815)
        at org.apache.activemq.web.MessageServlet$Listener.onMessageAvailable(MessageServlet.java:395)
        at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1383)
        at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:131)
        at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:202)
        at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:129)
        at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:47)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:724)
2013-12-17 23:28:52,121 | DEBUG | Sent! to destination: queue:&lt;span class=&quot;code-comment&quot;&gt;//TEST message: ActiveMQTextMessage {commandId = 0, responseRequired = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, messageId = ID:turtle-52404-1387319318754-3:2:1:1:1, originalDestination = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, originalTransactionId = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, producerId = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, destination = queue://TEST, transactionId = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, expiration = 0, timestamp = 1387319332114, arrival = 0, brokerInTime = 0, brokerOutTime = 0, correlationId = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, replyTo = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, persistent = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;, type = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, priority = 5, groupID = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, groupSequence = 0, targetConsumerId = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, compressed = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, userID = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, content = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, marshalledProperties = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, dataStructure = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, redeliveryCounter = 0, size = 0, properties = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, readOnlyProperties = f&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looks to me that the consuming session from the first wget is still there, in IDLE state &amp;#8211; but still is able to consume the message. Hope this helps &amp;#8211; I can&apos;t do any further testing or even debugging without a deeper understanding of ActiveMQ&apos;s internal workings.&lt;/p&gt;</comment>
                            <comment id="13851033" author="psedi" created="Tue, 17 Dec 2013 22:46:20 +0000"  >&lt;p&gt;Another thing: Setting the prefetch size to 1 as suggested in &lt;a href=&quot;http://activemq.apache.org/rest.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Apache ActiveMQ &#8482; &amp;#8211; REST&lt;/a&gt; didn&apos;t help. There&apos;s just one consumer here anyway, I guess.&lt;/p&gt;</comment>
                            <comment id="13868673" author="artnaseef" created="Sat, 11 Jan 2014 05:59:15 +0000"  >&lt;p&gt;It also seems that sending multiple messages after the timed-out consumption, only the first of those messages is lost.&lt;/p&gt;

&lt;p&gt;Here&apos;s debug output from the rest servlet (org.apache.activemq.web.MessageServlet).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;get with no messages on queue&lt;/b&gt;&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;DEBUG | Getting local client [GETID]
DEBUG | Receiving message(s) from: queue://TEST with timeout: 1000
DEBUG | Received 0 message(s)
DEBUG | Getting local client [GETID]
DEBUG | Receiving message(s) from: queue://TEST with timeout: 1000
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;b&gt;send 3 messages, get 3 times&lt;/b&gt;&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;DEBUG | Sending message to: queue://TEST with text: message
DEBUG | Sending message to: queue://TEST with text: message
DEBUG | Sending message to: queue://TEST with text: message
DEBUG | Getting local client [GETID]
DEBUG | Receiving message(s) from: queue://TEST with timeout: 1000
DEBUG | Received 1 message(s)
DEBUG | Getting local client [GETID]
DEBUG | Receiving message(s) from: queue://TEST with timeout: 1000
DEBUG | Received 1 message(s)
DEBUG | Getting local client [GETID]
DEBUG | Receiving message(s) from: queue://TEST with timeout: 1000
DEBUG | Received 0 message(s)
DEBUG | Getting local client [GETID]
DEBUG | Receiving message(s) from: queue://TEST with timeout: 1000
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note only 2 messages were received.&lt;/p&gt;</comment>
                            <comment id="13868674" author="artnaseef" created="Sat, 11 Jan 2014 06:08:40 +0000"  >&lt;p&gt;Watching the stats using the web console, the stats update as follows:&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; stat &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; on normal send &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; on send after get timed out &lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; Dequeue Counter &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; no change &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; +1 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; Message count waiting acknowledge &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; +1 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; no change &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; Dispatched Counter &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; +1 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; +1 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; Enqueue Counter &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; +1 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; +1 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;So, it appears the consumer is acknowledging the message immediately.&lt;/p&gt;</comment>
                            <comment id="13868939" author="artnaseef" created="Sun, 12 Jan 2014 03:33:59 +0000"  >&lt;p&gt;Attached is a patch that eliminates the erroneous consumption; the problem is that the continuation defined for the web request times out, but the availableMessageListener for the consumer is never updated with that fact.  So, when the next message comes in, the listener consumes it with the intent that the continuation of the web request will receive it.&lt;/p&gt;

&lt;p&gt;I&apos;m going to review this code more carefully for race conditions.  I&apos;m convinced there are races on the use of MessageConsumer&apos;s if more than one web request comes in for the same consumer (e.g. using the same clientId).  There may be more, including in this patch.&lt;/p&gt;</comment>
                            <comment id="13869116" author="psedi" created="Sun, 12 Jan 2014 19:03:18 +0000"  >&lt;p&gt;Thank you very much for the fix, I can confirm it works with the above test case. With just one client, no messages are lost.&lt;/p&gt;

&lt;p&gt;Here&apos;s another test case involving two distinct client IDs, but no actual race:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;#
# Two clients with IDs &lt;span class=&quot;code-quote&quot;&gt;&quot;GETID-1&quot;&lt;/span&gt; and &lt;span class=&quot;code-quote&quot;&gt;&quot;GETID-2&quot;&lt;/span&gt;... both timeout since there are no messages yet
#
wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID-1&amp;amp;readTimeout=1000&quot;&lt;/span&gt;
&lt;/span&gt;wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID-2&amp;amp;readTimeout=1000&quot;&lt;/span&gt;
&lt;/span&gt;
# Send a message:
curl -d &lt;span class=&quot;code-quote&quot;&gt;&quot;body=$((++i))&quot;&lt;/span&gt; http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue; echo &lt;span class=&quot;code-quote&quot;&gt;&quot;: $i&quot;&lt;/span&gt;
&lt;/span&gt;Message sent

#
# Receive using first client ID, OK
#
wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID-1&amp;amp;readTimeout=1000&quot;&lt;/span&gt;
&lt;/span&gt;1

#
# Send a message again:
#
curl -d &lt;span class=&quot;code-quote&quot;&gt;&quot;body=$((++i))&quot;&lt;/span&gt; http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue; echo &lt;span class=&quot;code-quote&quot;&gt;&quot;: $i&quot;&lt;/span&gt;
&lt;/span&gt;Message sent

#
# Receive using first client ID, no response, not OK
#
wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID-1&amp;amp;readTimeout=1000&quot;&lt;/span&gt;
&lt;/span&gt;
# ... but with client ID 2:
wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID-2&amp;amp;readTimeout=1000&quot;&lt;/span&gt;
&lt;/span&gt;2
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Seems like round-robin still happens even after a client disconnected because of the read timeout. Hope this helps.&lt;/p&gt;</comment>
                            <comment id="13869180" author="artnaseef" created="Sun, 12 Jan 2014 23:10:01 +0000"  >&lt;p&gt;That&apos;s what I would expect with a prefecth &amp;gt; 0 because even prefetch = 1 means a single message will be dispatched, or pushed, to the client &quot;proactively&quot; - i.e. without any call to the receive method.&lt;/p&gt;

&lt;p&gt;Let me look at how prefetch works in the REST client.&lt;/p&gt;</comment>
                            <comment id="13869194" author="artnaseef" created="Sun, 12 Jan 2014 23:34:53 +0000"  >&lt;p&gt;OK, so bad news - prefetch = 0 leads to web requests that don&apos;t appear to timeout.&lt;/p&gt;

&lt;p&gt;Prefetch = 1 works as I expected - one of the two clients gets a single message preloaded.  Also tested with prefeth = 2 and it works as expected.&lt;/p&gt;</comment>
                            <comment id="13869912" author="psedi" created="Mon, 13 Jan 2014 20:10:28 +0000"  >&lt;p&gt;So each new client ID creates a new subscription, which remains even after the client disconnects or timeouts and will be dispatched messages if prefetch &amp;gt; 0. Tested this with 3 clients (and without readTimeout), and all messages were distributed equally. Nice.&lt;/p&gt;

&lt;p&gt;Unfortunatelly, it&apos;s still pretty easy to provoke message loss when using an (admitedly unreasonable) low read Timeout. But what may happen, timing-wise, in an artifical test scenario may eventually happen in production even with natural timeouts. And avoiding message loss is paramount, IMHO.&lt;/p&gt;

&lt;p&gt;So here&apos;s another one:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;#
# start receiving messages in background with readTimeout=1, clientId &lt;span class=&quot;code-quote&quot;&gt;&quot;GETID-1&quot;&lt;/span&gt;
#
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID-1&amp;amp;readTimeout=1&quot;&lt;/span&gt;; done&amp;amp;
&lt;/span&gt;[1] 6040

#
# send some messages -- output is done by background receiver -- no message loss
#
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; ((i=1; i&amp;lt;100; i++)); &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; curl -d &lt;span class=&quot;code-quote&quot;&gt;&quot;body=$i.&quot;&lt;/span&gt; http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue; done
&lt;/span&gt;1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23.24.25.26.27.28.29.30.31.32.33.34.35.36.37.38.39.40.41.42.43.44.45.46.47.48.49.50.51.52.53.54.55.56.57.58.59.60.61.62.63.64.65.66.67.68.69.70.71.72.73.74.75.76.77.78.79.80.81.82.83.84.85.86.87.88.89.90.91.92.93.94.95.96.97.98.99.

#
# create another subscription with clientId &lt;span class=&quot;code-quote&quot;&gt;&quot;GETID-2&quot;&lt;/span&gt; (no messages read)
#
wget --no-http-keep-alive -q -O - &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID-2&amp;amp;readTimeout=1&quot;&lt;/span&gt;
&lt;/span&gt;
#
# &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; sending messages again -- expect to see every other message, but lots of message loss
#
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; ((i=1; i&amp;lt;100; i++)); &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; curl -d &lt;span class=&quot;code-quote&quot;&gt;&quot;body=$i.&quot;&lt;/span&gt; http:&lt;span class=&quot;code-comment&quot;&gt;//localhost:8161/api/message/TEST?type=queue -so /dev/&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;; done
&lt;/span&gt;1.3.7.11.15.23.27.33.39.45.49.53.57.59.61.65.69.75.83.87.89.91.93.97.

# don&apos;t forget to stop background job
kill %1
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Maybe it&apos;s just some timing issue which just becomes critical when there are two instead of just one subscription. But still, with a server-side timeout, the server should be able to tell if a message was completely delivered to a client or not, despite the timeout.&lt;/p&gt;</comment>
                            <comment id="13870271" author="artnaseef" created="Tue, 14 Jan 2014 01:37:23 +0000"  >&lt;p&gt;There are several possible desirable outcomes with REST and JMS.  Unfortunately, they are vastly different in their methodology - REST is based on synchronous request/reply and JMS is based on asynchronous passing of messages to consumers.&lt;/p&gt;

&lt;p&gt;Consider load balancing in a scenario mixing REST and JMS clients.  The current model, using prefetch to push messages, provides semantics that are more &quot;fair&quot; to the REST client by allowing messages to cache in the internal consumer for that client, just as they do for JMS clients.&lt;/p&gt;

&lt;p&gt;With that said, there is no analogous REST scenario for automatically releasing messages when the connection closes because REST always closes the connection after a single message while JMS holds it open indefinitely.&lt;/p&gt;

&lt;p&gt;For more advanced use-cases, perhaps camel would be a good tool to intelligently bridge the REST/JMS gap.&lt;/p&gt;

&lt;p&gt;BTW, the messages stored in the consumer for REST clients aren&apos;t truly lost.  They will sit indefinitely, but once the broker restarts, they will be returned to the broker.  This is actually bad for many reasons since it really means an idle consumer - very bad for JMS in general and activemq in particular.&lt;/p&gt;

&lt;p&gt;Perhaps we need a REST call that will force close a consumer, or a REST call that intentionally performs a one-shot message receive (i.e. automatically closes the consumer after the call).  Honestly, I&apos;d prefer to put my effort elsewhere since, as mentioned above, REST for JMS is not a great fit.&lt;/p&gt;

&lt;p&gt;Hope this helps.  Let me know your thoughts.&lt;/p&gt;</comment>
                            <comment id="13870368" author="artnaseef" created="Tue, 14 Jan 2014 04:12:47 +0000"  >&lt;p&gt;That&apos;s a great test case.  There is a race condition when a request takes more than 10ms (the minimum timeout) to complete.  It races with the availability of the message.&lt;/p&gt;

&lt;p&gt;I&apos;m working on a fix.&lt;/p&gt;</comment>
                            <comment id="13870940" author="artnaseef" created="Tue, 14 Jan 2014 17:33:59 +0000"  >&lt;p&gt;Attaching a more complete patch that:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;eliminates a race condition in which the servlet receives a message during a continuation at the same time the continuation times-out leading to a lost message&lt;/li&gt;
	&lt;li&gt;eliminates another race condition in which a client may block longer than necessary when a message arrives immediately after the initial receive call fails to return a message&lt;/li&gt;
	&lt;li&gt;prevents concurrent use of a consumer by throwing an exception on a request to use a consumer when that consumer is already active in another request.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There is still a possible message-loss scenario that can&apos;t be fixed without a rework of the protocol with the client.  Once the servlet receives the message and attempts to send it back to the client, if the client loses the connection to the server, that message is lost.  The only 100% reliable solution to that is to push message acknowledgement down to the client, which opens more potential issues.&lt;/p&gt;</comment>
                            <comment id="13871119" author="artnaseef" created="Tue, 14 Jan 2014 20:42:37 +0000"  >&lt;p&gt;That patch also adds a URL-encoded parameter, oneShot, that when true, will close the consumer on completion of the request.  Like this:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;curl --no-keepalive -o message \
	&quot;http://localhost:8161/api/message/TEST?type=queue&amp;amp;clientId=GETID1&amp;amp;readTimeout=1000&amp;amp;oneShot=true&quot;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13871194" author="psedi" created="Tue, 14 Jan 2014 21:18:14 +0000"  >&lt;p&gt;Thank you for your explanations. I&apos;m content with the prefetch scenario, as long as every message can be reliably consumed using a known set of subscriptions. With the oneShot parameter, semantics are more intuitive though, as there are no lingering subscriptions.&lt;/p&gt;

&lt;p&gt;Back to testing: With the second patch, the &quot;low-timeout multiple receivers&quot; testcase as well as the original testcase work perfectly. Even with prefetch=0 there is no message loss. With two concurrent receivers and no prefetch, messages are not distributed equally, but that is as expected. &quot;oneShot&quot; works, too &amp;#8211; even with multiple aggressively polling receivers.&lt;/p&gt;

&lt;p&gt;Great work, thank you very much!&lt;/p&gt;</comment>
                            <comment id="13873487" author="tabish121" created="Thu, 16 Jan 2014 15:20:45 +0000"  >&lt;p&gt;Patch applied with some minor code cleanup.  &lt;/p&gt;</comment>
                            <comment id="13874391" author="artnaseef" created="Fri, 17 Jan 2014 03:51:17 +0000"  >&lt;p&gt;Great!  Thanks Timothy.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12622526" name="AMQ-4938.patch" size="2343" author="artnaseef" created="Sun, 12 Jan 2014 03:33:59 +0000"/>
                            <attachment id="12622894" name="AMQ-4938B.patch" size="10916" author="artnaseef" created="Tue, 14 Jan 2014 17:33:59 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>363888</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 44 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1qq2f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>364194</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>