<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 05:55:33 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[AMQ-3965] Expired msgs not getting acked to broker causing consumer to fill up its prefetch and not getting more msgs.</title>
                <link>https://issues.apache.org/jira/browse/AMQ-3965</link>
                <project id="12311210" key="AMQ">ActiveMQ Classic</project>
                    <description>
&lt;p&gt;It is possible to get a consumer stalled and not receiving any more messages when using optimizeAcknowledge.&lt;br/&gt;
Let me illustrate in an example (JUnit test attached).&lt;/p&gt;

&lt;p&gt;Suppose a consumer with optimizeAcknowledge and a prefetch of 100 msgs.&lt;br/&gt;
The broker&apos;s queue contains 105 msg. The first 45 msgs have a very low expiry time, the remaining don&apos;t expiry. &lt;/p&gt;

&lt;p&gt;So the first 100 msgs get dispatched to the consumer (due to prefetch=100). Out of these the first 45 msgs do not get dispatched to consumer code because their expiry has elapsed by the time that are handled in the client. &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;ActiveMQMessageConsumer.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void dispatch(MessageDispatch md) {
        MessageListener listener = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.messageListener.get();
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            [...]
            &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (unconsumedMessages.getMutex()) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!unconsumedMessages.isClosed()) {
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.info.isBrowser() || !session.connection.isDuplicate(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, md.getMessage())) {
                        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (listener != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; unconsumedMessages.isRunning()) {
                            ActiveMQMessage message = createActiveMQMessage(md);
                            beforeMessageIsConsumed(md);
                            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                                &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; expired = message.isExpired();
                                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!expired) {
                                    listener.onMessage(message);
                                }
                                afterMessageIsConsumed(md, expired);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;listener.onMessage() above is not called as the msg has expired. &lt;br/&gt;
However it will calls into afterMessagesIsConsumed()&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;ActiveMQMessageConsumer.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void afterMessageIsConsumed(MessageDispatch md, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; messageExpired) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; JMSException {
      [...]  
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (messageExpired) {
            &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (deliveredMessages) {
                deliveredMessages.remove(md);
            }
            stats.getExpiredMessageCount().increment();
            ackLater(md, MessageAck.DELIVERED_ACK_TYPE);

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and will remove the expired msg from the deliveredMessages list. It then calls into ackLater(). &lt;br/&gt;
However ackLater() only fires an ack back to the broker when the number of unsent acks has reached 50% of the prefetch value.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;ActiveMQMessageConsumer.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void ackLater(MessageDispatch md, &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; ackType) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; JMSException {
    [...]
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((0.5 * info.getPrefetchSize()) &amp;lt;= (deliveredCounter - additionalWindowSize)) {
            session.sendAck(pendingAck);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;        

&lt;p&gt;In our example it has not reached that mark (only 45 expired msgs, i.e. 45%). &lt;br/&gt;
So the first 45 msgs, which expired before being dispatched, did not cause an ack being sent to the broker.&lt;/p&gt;

&lt;p&gt;Now the next 55 messages get processed. These don&apos;t have an expiry so they get dispatched to consumer code. &lt;br/&gt;
After dispatching each msg to the registered application code, we call into afterMessageIsConsumed() but this time executing a different branch as the msgs are not expired&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;ActiveMQMessageConsumer.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void afterMessageIsConsumed(MessageDispatch md, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; messageExpired) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; JMSException {
    [...]
    &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isAutoAcknowledgeEach()) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (deliveryingAcknowledgements.compareAndSet(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;)) {
                    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (deliveredMessages) {
                        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!deliveredMessages.isEmpty()) {
                            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (optimizeAcknowledge) {
                                ackCounter++;
                                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (ackCounter &amp;gt;= (info.getPrefetchSize() * .65) || (optimizeAcknowledgeTimeOut &amp;gt; 0 &amp;amp;&amp;amp; &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis() &amp;gt;= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {
                                    MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
                                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (ack != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                                        deliveredMessages.clear();
                                        ackCounter = 0;
                                        session.sendAck(ack);
                                        optimizeAckTimestamp = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
                                    }
                                }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with optimizeAcknowledge=true we only send an ack back to the broker if either optimizeAcknowledgeTimeOut has elapsed or the ackCounter has reached 65% of the prefetch (100). &lt;br/&gt;
The timeout will not have kicked in. The ackCounter will be at 55 after processing the last of 100 prefetched messages which is less than 65% of 100. So with the last prefetched msg being processed, it will not generate an ack back to the broker. &lt;br/&gt;
As a result, the client has processed all prefetched message and will not get any new messages dispatched from the broker. The broker has another 5 msgs on the queue but since it never received an ack from the client, it won&apos;t dispatch any further messages. &lt;/p&gt;

&lt;p&gt;The client is stalled. &lt;/p&gt;
</description>
                <environment></environment>
        <key id="12602250">AMQ-3965</key>
            <summary>Expired msgs not getting acked to broker causing consumer to fill up its prefetch and not getting more msgs.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="tmielke">Torsten Mielke</assignee>
                                    <reporter username="tmielke">Torsten Mielke</reporter>
                        <labels>
                            <label>optimizeDispatch</label>
                    </labels>
                <created>Wed, 8 Aug 2012 15:07:12 +0000</created>
                <updated>Mon, 13 Aug 2012 07:09:22 +0000</updated>
                            <resolved>Mon, 13 Aug 2012 07:09:22 +0000</resolved>
                                    <version>5.6.0</version>
                                    <fixVersion>5.7.0</fixVersion>
                                    <component>JMS client</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="13431146" author="tmielke" created="Wed, 8 Aug 2012 15:07:43 +0000"  >&lt;p&gt;A possible fix for this may be to no hold back acks for expired messages (as currently done by calling ackLater()) but to ack any expired messages&lt;br/&gt;
straight away.&lt;br/&gt;
This however will cause more acks to be written back to the broker, but only in case of expired messages.&lt;/p&gt;

&lt;p&gt;Perhaps there is a better solution that has less of an overhead? &lt;/p&gt;</comment>
                            <comment id="13431151" author="tmielke" created="Wed, 8 Aug 2012 15:13:37 +0000"  >&lt;p&gt;Attaching testcase as mvn project. &lt;br/&gt;
The testclasss can also be copied into activemq-core/src/test/java/org/apache/activemq/bugs &lt;/p&gt;</comment>
                            <comment id="13431382" author="tabish121" created="Wed, 8 Aug 2012 21:01:35 +0000"  >&lt;p&gt;Updated the test so that the async case is more stable on fast hardware, was a bit flaky on my fast Linux box.  Added a sync test case to show that both paths suffer the same problem and also to verify the async case was suffering timing issues. &lt;/p&gt;</comment>
                            <comment id="13431395" author="tabish121" created="Wed, 8 Aug 2012 21:17:22 +0000"  >&lt;p&gt;it looks like at the very least we need to check the pendingAcks when we go into the optimize ack case as it doesn&apos;t use the deliveredCounter like the rest of the code that uses ackLater so unlike ackLater it doesn&apos;t see the pending count of expired messages.&lt;/p&gt;</comment>
                            <comment id="13431945" author="tmielke" created="Thu, 9 Aug 2012 16:13:45 +0000"  >&lt;p&gt;We thought that the following fix could do the job &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;ActiveMQMessageConsumer.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; 
&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void afterMessageIsConsumed(MessageDispatch md, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; messageExpired) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; JMSException {
[...]
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (messageExpired) {
            &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (deliveredMessages) {
                deliveredMessages.remove(md);
            }
            stats.getExpiredMessageCount().increment();
            ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
        } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
            stats.onMessage();
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (session.getTransacted()) {
                &lt;span class=&quot;code-comment&quot;&gt;// Do nothing.
&lt;/span&gt;            } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isAutoAcknowledgeEach()) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (deliveryingAcknowledgements.compareAndSet(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;)) {
                    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (deliveredMessages) {
                        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!deliveredMessages.isEmpty()) {
                            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (optimizeAcknowledge) {
                            	ackCounter++;
                            	
                            	&lt;span class=&quot;code-comment&quot;&gt;// AMQ-3965 - &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; alone does not fix it.
&lt;/span&gt;                                &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; threshold = (&lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt;) info.getPrefetchSize() * (&lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt;) 0.65;
                            	&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (pendingAck != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (ackCounter + deliveredCounter) &amp;gt;= (threshold)) {
                                    session.sendAck(pendingAck);
                                    pendingAck = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
                                    deliveredCounter = 0;
                            	}
                                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (ackCounter &amp;gt;= (threshold) || (optimizeAcknowledgeTimeOut &amp;gt; 0 &amp;amp;&amp;amp; &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis() &amp;gt;= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {
                                    MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
                                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (ack != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                                        deliveredMessages.clear();
                                        ackCounter = 0;
                                        session.sendAck(ack);
                                        optimizeAckTimestamp = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
                                    }
                                }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; 

&lt;p&gt;but that extra code &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; 
&lt;span class=&quot;code-comment&quot;&gt;// AMQ-3965 - &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; alone does not fix it.
&lt;/span&gt;&lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; threshold = (&lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt;) info.getPrefetchSize() * (&lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt;) 0.65;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (optimizeAcknowledge &amp;amp;&amp;amp; pendingAck != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (ackCounter + deliveredCounter) &amp;gt;= (threshold)) {
  session.sendAck(pendingAck);
  pendingAck = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
  deliveredCounter = 0;
} 

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; alone is not enough. Let me explain why: &lt;/p&gt;

&lt;p&gt;Suppose a prefetch of 100. Consumer receives 56 normal msgs. So ackCounter is at 56, no ack sent back to broker yet. It then receives 44 msgs that expire on consumer before dispatch. So deliveredCounter=44 and ackCounter=56. In afterMessageIsConsumed() it does not go into the proposed code for the expired msgs, only for normal msgs. So for the last 44 expired msgs there is no trigger fired to sent an ack to the broker. The result is a hanging consumer that does not receive any more msgs. Problem not fixed. &lt;/p&gt;</comment>
                            <comment id="13432167" author="tabish121" created="Thu, 9 Aug 2012 21:25:11 +0000"  >&lt;p&gt;So far I haven&apos;t hit on any more elagant solution than to also check use the ackCounter in ackLater like so:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;        &lt;span class=&quot;code-comment&quot;&gt;// NOTE: I bumped &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; to 0.65, its currently 0.5 &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; some reason.
&lt;/span&gt;        &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; threshold = 0.65f * info.getPrefetchSize();
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (threshold &amp;lt;= ((ackCounter + deliveredCounter) - additionalWindowSize)) {
            session.sendAck(pendingAck);
            pendingAck=&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
            deliveredCounter = 0;
            additionalWindowSize = 0;
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This of course can lead to the scenario where you start acking every single expired message that arrives if the numbers are right, but without a lot of code changes I haven&apos;t seen another way to deal with this.  Eventually when some non-expired messages come in and the ackCounter gets high enough to send ack for the consumed messages things would settle down again.&lt;/p&gt;</comment>
                            <comment id="13432683" author="tmielke" created="Fri, 10 Aug 2012 10:18:18 +0000"  >&lt;p&gt;Proposing the following fix: &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;ActiveMQMessageConsumer.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void ackLater(MessageDispatch md, &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; ackType) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; JMSException {
[...]
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((0.5 * info.getPrefetchSize()) &amp;lt;= (deliveredCounter + ackCounter - additionalWindowSize)) {
      session.sendAck(pendingAck);
      pendingAck=&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
      deliveredCounter = 0;
      additionalWindowSize = 0;
    }

[...]

&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void afterMessageIsConsumed(MessageDispatch md, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; messageExpired) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; JMSException {
[...]
&lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (deliveredMessages) {
                        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!deliveredMessages.isEmpty()) {
                            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (optimizeAcknowledge) {
                                ackCounter++;
                                
                                &lt;span class=&quot;code-comment&quot;&gt;// AMQ-3956 evaluate both expired and normal msgs as 
&lt;/span&gt;                                &lt;span class=&quot;code-comment&quot;&gt;// otherwise consumer may get stalled
&lt;/span&gt;                                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (ackCounter + deliveredCounter &amp;gt;= (info.getPrefetchSize() * .65) || (optimizeAcknowledgeTimeOut &amp;gt; 0 &amp;amp;&amp;amp; &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis() &amp;gt;= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {
                                    MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);
                                	&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (ack != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                                        deliveredMessages.clear();
                                        ackCounter = 0;
                                        session.sendAck(ack);
                                        optimizeAckTimestamp = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
                                    }
                                	&lt;span class=&quot;code-comment&quot;&gt;// AMQ-3956 - as further optimization send 
&lt;/span&gt;                                    &lt;span class=&quot;code-comment&quot;&gt;// ack &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; expired msgs when there are any.
&lt;/span&gt;                                    &lt;span class=&quot;code-comment&quot;&gt;// This resets the deliveredCounter to 0 so that
&lt;/span&gt;                                	&lt;span class=&quot;code-comment&quot;&gt;// we won&apos;t sent standard acks with every msg just
&lt;/span&gt;                                	&lt;span class=&quot;code-comment&quot;&gt;// because the deliveredCounter just below 
&lt;/span&gt;                                	&lt;span class=&quot;code-comment&quot;&gt;// 0.5 * prefetch as used in ackLater()
&lt;/span&gt;                                	&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (pendingAck != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; deliveredCounter &amp;gt; 0) {
                                    	session.sendAck(pendingAck);
                                        pendingAck = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
                                        deliveredCounter = 0;
                                    }
                                }
                            }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Essentially, both methods ackLater() and afterMessageIsConsumed() now evaluate ackCounter + deliveredCounter. &lt;br/&gt;
This will avoid getting a stalled consumer and fixes the bug.&lt;/p&gt;

&lt;p&gt;However an additional optimization is necessary for the following case:&lt;br/&gt;
Suppose a prefetch=100. &lt;br/&gt;
Consumer receives 49 msgs that expire before being dispatched. So deliveredCounter=49, ackCounter=0. No ack is sent as threshold is below 50. &lt;br/&gt;
Next, consumer only processes non-expired msgs. As deliveredCounter=49, it will dispatch 17 msg and then send a standard ack. Because after&lt;br/&gt;
the 17th msg, deliveredCounter=49, ackCounter=17, so that exceeds 0.65*prefetch and hence a standard ack is sent. The ack resets the ackCounter but not the deliveredCounter, which remains at 49. &lt;br/&gt;
So we would process only another 17 non-expired msgs before we would send the next standard ack to the broker. The problem is that the deliveredCounter does not change unless we receive another expired msg. If we only receive non-expired msgs going further, then deliveredCounter never gets reset to 0 and we ack after every 17 msgs instead of after 0.65*prefetch=65 msg.&lt;br/&gt;
To avoid this situation, I propose to send a deliveredAck right after the standard Ack. This would reset the deliveredCounter to 0 and we can process the next 65 non-expired msgs without having to send back an ack (as opposed to processing only 17 msg before sending an ack).&lt;br/&gt;
If there is no expired msgs to be acked, then no deliveredAck is being sent. So this should only trigger in the case where some expired msgs have accumulated but have not being acked yet. &lt;/p&gt;</comment>
                            <comment id="13432688" author="tmielke" created="Fri, 10 Aug 2012 10:31:22 +0000"  >&lt;p&gt;Attaching possible patch plus JUnit test. &lt;br/&gt;
Would ask for review and if accepted I can commit the code to trunk. &lt;/p&gt;</comment>
                            <comment id="13432709" author="gtully" created="Fri, 10 Aug 2012 11:52:12 +0000"  >&lt;p&gt;@Torsten that patch&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; looks good to me.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;https://issues.apache.org/jira/secure/attachment/12540464/AMQ-3956.patch&lt;/p&gt;</comment>
                            <comment id="13432722" author="tabish121" created="Fri, 10 Aug 2012 12:35:36 +0000"  >&lt;p&gt;Looks good, think you should go ahead and apply it. &lt;/p&gt;</comment>
                            <comment id="13432963" author="tmielke" created="Mon, 13 Aug 2012 07:09:22 +0000"  >&lt;p&gt;Resolved by this &lt;a href=&quot;https://fisheye6.atlassian.com/changelog/activemq?cs=1371722&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;commit&lt;/a&gt;.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12540464" name="AMQ-3956.patch" size="11505" author="tmielke" created="Fri, 10 Aug 2012 10:31:22 +0000"/>
                            <attachment id="12539923" name="OptimizeAcknowledgeWithExpiredMsgsTest.java" size="8082" author="tabish" created="Wed, 8 Aug 2012 21:01:35 +0000"/>
                            <attachment id="12539875" name="testcase.tgz" size="4379" author="tmielke" created="Wed, 8 Aug 2012 15:13:37 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>246257</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 15 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i07jc7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>41900</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>