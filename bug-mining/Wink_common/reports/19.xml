<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 22:28:39 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[WINK-47] honor media type wildcards</title>
                <link>https://issues.apache.org/jira/browse/WINK-47</link>
                <project id="12310940" key="WINK">Wink</project>
                    <description>&lt;p&gt;This issue probably needs discussion, as it may be a spec interpretation issue.  Please reference JAX-RS javadoc for javax.ws.rs.ext.Providers.getContextResolver here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jackson.codehaus.org/javadoc/jax-rs/1.0/javax/ws/rs/ext/Providers.html#getContextResolver(java.lang.Class,%20javax.ws.rs.core.MediaType&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://jackson.codehaus.org/javadoc/jax-rs/1.0/javax/ws/rs/ext/Providers.html#getContextResolver(java.lang.Class,%20javax.ws.rs.core.MediaType&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Currently, the implementation does not use the &apos;*&apos; character in a passed-in media type as a wildcard.  Rather, it matches exactly by just allowing the LinkedHashMap.get to it&apos;s object compare.  Attached is a patch with tests that demonstrate the proposed function, and a fix that supports it.  All existing and new tests in wink-common and wink-server passed for me with this change.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12429641">WINK-47</key>
            <summary>honor media type wildcards</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="elman">Michael Elman</assignee>
                                    <reporter username="rott">Michael Rheinheimer</reporter>
                        <labels>
                    </labels>
                <created>Mon, 6 Jul 2009 20:36:25 +0000</created>
                <updated>Fri, 17 Jul 2009 09:10:26 +0000</updated>
                            <resolved>Sun, 12 Jul 2009 07:30:44 +0000</resolved>
                                    <version>0.1</version>
                                    <fixVersion>0.1</fixVersion>
                                    <component>Common</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                                <comments>
                            <comment id="12727781" author="rott" created="Mon, 6 Jul 2009 20:55:55 +0000"  >&lt;p&gt;I didn&apos;t explain very well.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  The code path I&apos;m talking about here is the path that does media type matching to find the context resolver.  Because the inbound media type parameter that is passed into getContextResolver is treated as a hard-coded string (&apos;*&apos; wildcards are not treated as wildcards), the matching is iffy.  For example, if I have a Provider class annotated as such:&lt;/p&gt;

&lt;p&gt;    @Provider&lt;br/&gt;
    @Produces(MediaType.APPLICATION_FORM_URLENCODED)&lt;/p&gt;

&lt;p&gt;And then call &lt;/p&gt;

&lt;p&gt;    providers.getContextResolver(MyClass.class, new MediaType(&quot;&lt;b&gt;&quot;, &quot;&lt;/b&gt;&quot;));&lt;/p&gt;

&lt;p&gt;No match will be found.&lt;/p&gt;</comment>
                            <comment id="12728058" author="elman" created="Tue, 7 Jul 2009 12:20:43 +0000"  >&lt;p&gt;Hi Mike,&lt;br/&gt;
I looked at your patch, it&apos;s a bit problematic. In the GreedyLinkedHashMap you override only get method with a special functionality. The problem with this solution that GreedyLinkedHashMap  may behave differently, when other Map methods are used. For example, what happens if keySet().contains() is invoked?&lt;br/&gt;
May be currently these methods are not used, but in the future any trivial change in code will cause a problem.&lt;br/&gt;
I prefer to think about a different solution, may be we&apos;ll need to change the MediaTypeMap implementation totally.&lt;/p&gt;

&lt;p&gt;I promise to think about it, and everyone else is welcome to join &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12728061" author="nickgallardo" created="Tue, 7 Jul 2009 12:31:20 +0000"  >&lt;p&gt;I actually spent some time last night thinking about this one myself.  What confused me was, if it&apos;s broken for ContextResolvers, shouldn&apos;t it be broken for everything else that uses the MediaTypeMap (MessageBodyReaders and Writers for example)?&lt;/p&gt;

&lt;p&gt;The other thing that confused me was that I &lt;b&gt;thought&lt;/b&gt; the wildcard support would already be handled given that we&apos;re using the MediaType.equals() to do the comparison.  The implementation for that method DOES account for wildcards in generic types vs. sub types.  I must be missing something here though.&lt;/p&gt;</comment>
                            <comment id="12728065" author="elman" created="Tue, 7 Jul 2009 12:38:20 +0000"  >&lt;p&gt;Yep, it&apos;s broken for everything (except ExceptionMapper that are not dependent on MediaType)&lt;/p&gt;

&lt;p&gt;I think you&apos;re confusing equals() with isCompatible(). Equals means that the MedaiType has exact match including the parameters.&lt;br/&gt;
isCompatible means that the two types are compatible. E.g.  &lt;b&gt;/&lt;/b&gt; is compatible to everything, image/* is compatible with image/jpeg, image/png, etc.&lt;/p&gt;</comment>
                            <comment id="12728096" author="rott" created="Tue, 7 Jul 2009 13:36:06 +0000"  >&lt;p&gt;Good points Michael and Nick.&lt;/p&gt;

&lt;p&gt;The good news is that this new GreedyLinkedHashMap is a small private nested class inside another small private nested class, so the changes are containable.&lt;/p&gt;

&lt;p&gt;I&apos;ll be glad to expand the rest of the GreedyLinkedHashMap to provide the proper LinkedHashMap overrides and expand the unittest to cover it.  It sounds like I hit on the right solution, but that it was just incomplete.  That sound right?&lt;/p&gt;

&lt;p&gt;Perhaps another solution is to not override the &apos;get&apos;, but instead just provide another method like &apos;getByRegex&apos; or &apos;getCompatible&apos;.  That way the intent is clear and we don&apos;t have to worry about overriding all the other LinkedHashMap methods.  Given the narrow scope of these classes, I might be leaning this way.  Your thoughts?&lt;/p&gt;</comment>
                            <comment id="12728204" author="nickgallardo" created="Tue, 7 Jul 2009 17:31:38 +0000"  >&lt;p&gt;Michael E., you&apos;re right.  isCompatible is more appropriate.  So, couldn&apos;t we just use that do the the check?  If I understand the code path correctly, looks like that would need to happen in MediaTypeMap.getProvidersByMediaType().&lt;/p&gt;

&lt;p&gt;If I get a chance, I&apos;ll try to poke around with that later today.&lt;/p&gt;
</comment>
                            <comment id="12728342" author="rott" created="Tue, 7 Jul 2009 20:16:46 +0000"  >&lt;p&gt;Ok, I re-worked the solution to no longer use regular expressions, or override the LinkeHashMap.get method.  Instead, I now iterate through the entries in the map, use MediaType.isCompatible to compare the mediaType param with the keys in the map, and collect the data in order per JAX-RS 4.3.1.  Please review the patch_02.txt and see what you think.&lt;/p&gt;

&lt;p&gt;NOTE:  I did have to change two existing test methods &amp;#8211; please be sure to see the changes and agree or disagree with my reasoning in the code comments.&lt;/p&gt;

&lt;p&gt;I like this kind of dialog for these types of issues.  Good teamwork.  Thanks!&lt;/p&gt;</comment>
                            <comment id="12728552" author="elman" created="Wed, 8 Jul 2009 08:08:15 +0000"  >&lt;p&gt;Ok, I thought about it and to tell you the truth I&apos;m kinda confused about the scenario.&lt;br/&gt;
For the context resolvers the spec states the following:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Get a context resolver for a particular type of context and media type. The set of resolvers is first filtered by &lt;b&gt;comparing the supplied value of mediaType with the value of each resolver&apos;s Produces&lt;/b&gt;, ensuring the generic type of the context resolver is assignable to the supplied value of contextType, and eliminating those that do not match. If only one resolver matches the criteria then it is returned. If more than one resolver matches then the list of matching resolvers is ordered with those with the best matching values of Produces (x/y &amp;gt; x/* &amp;gt; &lt;b&gt;/&lt;/b&gt;) sorted first. A proxy is returned that delegates calls to ContextResolver.getContext(java.lang.Class) to each matching context resolver in order and returns the first non-null value it obtains or null if all matching context resolvers return null. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The spec states &quot;comparing&quot; for Media Types, it doesn&apos;t states that stars means pattern comparison like Mike did in his first patch, and it doesn&apos;t states &quot;compatible&quot;, so I would believe that using isCompatible is incorrect.&lt;/p&gt;

&lt;p&gt;So actually I believe that the current behavior is the correct one, but to emphasize this I&apos;ll try to give the problematic use cases. Let&apos;s consider we want to support patterns:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;@Produces(&lt;span class=&quot;code-quote&quot;&gt;&quot;text/*&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;ProviderA

@Produces(&lt;span class=&quot;code-quote&quot;&gt;&quot;text/plain&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;ProviderB&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;which provider will be returned for &quot;text/*&quot;?&lt;br/&gt;
ProviderA gives an exact match, but ProviderB will be returned...&lt;/p&gt;

&lt;p&gt;Another question: should we support patterns like &quot;text/plain*&quot;?&lt;/p&gt;

&lt;p&gt;In addition, I have check how the JAX-RS RI (Jersey) behaves on the Mike&apos;s unit test, and it also fails.&lt;/p&gt;

&lt;p&gt;So in general, I think we should decide if the whole scenario is valid before trying to solve it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12728726" author="rott" created="Wed, 8 Jul 2009 14:42:24 +0000"  >&lt;p&gt;Hi Michael.  I understand your concerns.  In fact, the spec at 4.3.1 and the javadoc for Providers.getContextResolver makes no mention of treating * as a wildcard.  If we were to treat it as such when passed into getContextResolver, and a future JAX-RS spec clarification came out saying it should be a literal string match, then our implementation and all of the customers relying on this behavior would incur some cost.  It&apos;s easier to loosen the algorithm than tighten it.&lt;/p&gt;

&lt;p&gt;So, I agree that we should explore the scenario for validity.&lt;/p&gt;</comment>
                            <comment id="12728737" author="bluk" created="Wed, 8 Jul 2009 15:19:28 +0000"  >&lt;p&gt;I haven&apos;t had any caffeine this morning but I think the scenario for this wasn&apos;t really about the ContextResolvers but more about the Providers.getMessageBodyWriter(...., MediaType mt).  It could be that someone calling the providers just wants to see if there was a writer for a Class&amp;lt;?&amp;gt; type, Type genericType for any media type.  It just so happened that if the interpretation of getMessageBodyWriter() were taken that way, then getContextResolvers() would have followed the same behavior.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;@GET
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void getSomething(@Context Providers p, @Context ServletContext s, @Context HttpHeaders headers) {
   &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o = &lt;span class=&quot;code-comment&quot;&gt;// some object
&lt;/span&gt;   MediaType acceptMT =    &lt;span class=&quot;code-comment&quot;&gt;// get the Accept header media type and it happens to be */*
&lt;/span&gt;   MessageBodyWriter mbw = p.getMessageBodyWriter(o.getClass(), o.getClass(), &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Annotation[0] { }, acceptMT);
   &lt;span class=&quot;code-comment&quot;&gt;// get the servlet context and set Content-Type to be acceptMT (&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; it was wildcard i would hope they would just &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;)
&lt;/span&gt;   &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (mbw != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) writeTo...., etc.
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;b&gt;In the end&lt;/b&gt;, I don&apos;t think this is something to really worry about given comments in this JIRA.&lt;/p&gt;

&lt;p&gt;I would be curious if anyone&apos;s interpretation is asking for the MediaType &quot;widening&quot; though (i.e. first do a specific text/plain match, then do a text/&lt;b&gt;, then do */&lt;/b&gt;).  I prefer the current behavior, but if it&apos;s really a literal match for the MediaTypes passed into the Providers interface, then that makes things a bit easier.  I could see the application developer being forced to do the type widening on their own.&lt;/p&gt;

&lt;p&gt;Regarding:&lt;br/&gt;
&amp;gt; Another question: should we support patterns like &quot;text/plain*&quot;?&lt;/p&gt;

&lt;p&gt;That&apos;s an interesting point and I think we should open another JIRA for it.&lt;/p&gt;</comment>
                            <comment id="12728753" author="bluk" created="Wed, 8 Jul 2009 15:39:40 +0000"  >&lt;p&gt;&amp;gt;I would be curious if anyone&apos;s interpretation is asking for the MediaType &quot;widening&quot; though (i.e. first do a specific text/plain match, then do a text/, then do */).&lt;/p&gt;

&lt;p&gt;Thinking about the @Produces/@Consumes sorting rules, I would guess that the current behavior is correct for the type widening.&lt;/p&gt;</comment>
                            <comment id="12729033" author="nickgallardo" created="Thu, 9 Jul 2009 03:51:12 +0000"  >&lt;p&gt;More comments from the peanut gallery here (hopefully it submits this time without timing out).&lt;/p&gt;

&lt;p&gt;To the issue of support &quot;text/plain*&quot;, I don&apos;t think that should be supported.  My interpretation of wildcards is that they are for the entire type or subtype.  Not substrings within that.  &lt;/p&gt;
</comment>
                            <comment id="12729045" author="nickgallardo" created="Thu, 9 Jul 2009 04:16:37 +0000"  >&lt;p&gt;To the broader issue of wildcard support, maybe it&apos;s a combination of the equals() and isCompatible() that need to be accounted for.  I&apos;ll go back to Michael&apos;s example.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;@Produces(&lt;span class=&quot;code-quote&quot;&gt;&quot;text/*&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;ProviderA

@Produces(&lt;span class=&quot;code-quote&quot;&gt;&quot;text/plain&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;ProviderB&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Given these two providers, let&apos;s consider two scenarios.&lt;/p&gt;

&lt;p&gt;1. Client sends &quot;text/plain&quot;&lt;/p&gt;

&lt;p&gt;In this scenario, although both providers are technically a match, the spec states that we should map to the most specific one.  The behavior remains unchanged with what we have today.  When you&apos;re building the list of possible providers though, you could first check for equals().  If that works, breakout immediately because you have the most specific match (provided that there are no wildcards in the inbound mediatype).  If the equals() fails, check the isCompatible() to see if it at least matches based on the wildcard.  &lt;/p&gt;

&lt;p&gt;Either way, once we found the exact match for &quot;text/plain&quot;, we just return that and be done with it.&lt;/p&gt;

&lt;p&gt;2. Client sends &quot;text/*&quot;&lt;/p&gt;

&lt;p&gt;This is what I think Mike was getting at originally.  Since we may not have a specific provider for &quot;text/*&quot;, everything that starts with &quot;text/&quot; is a candidate.  That means both ProviderA and ProviderB show up in the list.  To Michael&apos;s question about which one is then selected, I think it&apos;s ProviderB aka &quot;text/plain&quot;.  &lt;/p&gt;

&lt;p&gt;Not go chapter-and-verse, but take a look at section 3.8 of JAX-RS.  I&apos;m interpreting step 5 to be where both are added to the list, because they&apos;re compatible.  Step 7 is where &quot;text/plain&quot; is put ahead of &quot;text/*&quot;, and the rest just plays out.&lt;/p&gt;

&lt;p&gt;At least, that&apos;s my interpretation.  Dustin brought up the fact that some of this is also discussed in the Accept headers section of the HTTP spec, here: &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12729051" author="elman" created="Thu, 9 Jul 2009 05:16:27 +0000"  >&lt;p&gt;I have a feeling that we are messing two issues into the same thread:&lt;br/&gt;
&lt;b&gt;Issue 1&lt;/b&gt;: Looking for a provider in the ProvidersRegistry using javax.ws.rs.ext.Providers context.&lt;br/&gt;
&lt;b&gt;Issue 2&lt;/b&gt;: Selecting the right method and then the correct media type for the response, based on client&apos;s Accept header.&lt;/p&gt;

&lt;p&gt;Please, pay attention that these are different issues and they are defined in two different places in spec:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Issue 1 in javadocs of javax.ws.rs.ext.Providers&lt;/li&gt;
	&lt;li&gt;Issue 2 the spec at 3.7.2.3 (b) and  3.8&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In the previous comments I was always talking about the Issue 1 only and I thought that this what &lt;a href=&quot;https://issues.apache.org/jira/browse/WINK-47&quot; title=&quot;honor media type wildcards&quot; class=&quot;issue-link&quot; data-issue-key=&quot;WINK-47&quot;&gt;&lt;del&gt;WINK-47&lt;/del&gt;&lt;/a&gt; is talking about.&lt;/p&gt;

&lt;p&gt;But I think that Nick&apos;s latest comment mainly refers to Issue 2 and not to Issue 1.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Talking about Issue 2:&lt;/b&gt; &lt;tt&gt;isCompatible()&lt;/tt&gt; is used for selecting the correct resource method. After the correct method was selected and invoked the algorithm from 3.8 is applied. The result of the algorithm is &lt;b&gt;a concrete type&lt;/b&gt; or an exception. This concrete type is used to search for a Provider in the ProvidersRegistry  (described in spec 4.2.2 and 4.2.3). It&apos;s important to pay attention that a &lt;b&gt;a concrete type&lt;/b&gt; is used at this point, so equals() should behave well enough.&lt;/p&gt;</comment>
                            <comment id="12729491" author="rott" created="Fri, 10 Jul 2009 01:54:43 +0000"  >&lt;p&gt;Yes, this Jira is specific to Issue 1.  The more I think about it, the more I think that the * character in the MediaType passed to the ProvidersRegistry.getContextResolver should be treated as a wildcard.  I think forcing it to be a string literal match would probably go against the general understanding of *.  I think that&apos;s why Nick pointed out the Accept-header section of the html spec; just to indicate that it is discussed as a wildcard.  The JAX-RS spec does not explicitly say it should be treated as a wildcard, but I think this usage has been so pervasive, I can&apos;t imagine the JAX-RS spec authors intended that * be matched as a string literal.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;

&lt;p&gt;How do we come to a consensus on this?  I don&apos;t want to pollute the mailing list with &quot;vote&quot; emails for a Jira, but if that&apos;s the right process, we can go that way.  My informal vote is for patch_02.txt as the fix.&lt;/p&gt;</comment>
                            <comment id="12730051" author="elman" created="Sun, 12 Jul 2009 06:52:49 +0000"  >&lt;p&gt;I&apos;ve asked the question about this issue at the &lt;a href=&quot;https://jsr311.dev.java.net/servlets/BrowseList?listName=users&amp;amp;by=thread&amp;amp;from=1876125&amp;amp;to=1876125&amp;amp;first=1&amp;amp;count=8&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;users@jsr311&lt;/a&gt; mailing list, and it seems that isCompatible() should be used, when calling from the javax.ws.rs.ext.Providers context.&lt;/p&gt;

&lt;p&gt;About the possible implementation: I think the implementation should be split into two:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;The search for a concrete type&lt;/li&gt;
	&lt;li&gt;The search for a type containing wildcard.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The first implementation is called from the Wink&apos;s runtime (see Issue 2 in my previous comment), and it&apos;s more efficient.&lt;br/&gt;
The second implementation may be invoked only by the user and it will run over all providers using isCompatible method, so it would be less efficient then the first one, but... the user can only blame himself.&lt;/p&gt;</comment>
                            <comment id="12730052" author="elman" created="Sun, 12 Jul 2009 07:30:44 +0000"  >&lt;p&gt;Ok, I&apos;ve submitted a fix. &lt;br/&gt;
The functionality has changed for the searches that include wildcards, so one unit test needed a fix.&lt;br/&gt;
I&apos;ve also submitted the unit test from the first Mike&apos;s patch.&lt;/p&gt;

&lt;p&gt;Hope everyone is happy now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12730057" author="hudson" created="Sun, 12 Jul 2009 08:30:53 +0000"  >&lt;p&gt;Integrated in Wink-Trunk-JDK15 #23 (See &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Wink-Trunk-JDK15/23/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://hudson.zones.apache.org/hudson/job/Wink-Trunk-JDK15/23/&lt;/a&gt;)&lt;br/&gt;
    Added support for searching providers using Wildcards. See []&lt;/p&gt;</comment>
                            <comment id="12730344" author="nickgallardo" created="Mon, 13 Jul 2009 13:37:07 +0000"  >&lt;p&gt;Sorry for the late comment here, but thanks Michael.&lt;/p&gt;

&lt;p&gt;&quot;The first implementation is called from the Wink&apos;s runtime (see Issue 2 in my previous comment), and it&apos;s more efficient.&lt;br/&gt;
The second implementation may be invoked only by the user and it will run over all providers using isCompatible method, so it would be less efficient then the first one, but... the user can only blame himself.&quot;&lt;/p&gt;

&lt;p&gt;I think that&apos;s the best solution.  No need to interrupt the main path.&lt;/p&gt;</comment>
                            <comment id="12732425" author="rott" created="Fri, 17 Jul 2009 09:10:26 +0000"  >&lt;p&gt;Thanks for all the good communication on this issue!&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12430057">WINK-70</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12430264">WINK-82</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12412652" name="patch.txt" size="6367" author="rott" created="Mon, 6 Jul 2009 20:39:22 +0000"/>
                            <attachment id="12412782" name="patch_02.txt" size="7282" author="rott" created="Tue, 7 Jul 2009 20:16:46 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[no_permission]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38640</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            16 years, 19 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310041" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Patch Info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10042"><![CDATA[Patch Available]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1gh4v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>304369</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>