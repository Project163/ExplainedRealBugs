diff --git a/wink-common/pom.xml b/wink-common/pom.xml
index b0632a8f..0cd8bc80 100644
--- a/wink-common/pom.xml
+++ b/wink-common/pom.xml
@@ -72,6 +72,12 @@
             <groupId>org.jmock</groupId>
             <artifactId>jmock-junit3</artifactId>
             <version>2.5.1</version>
+	        <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>woodstox</groupId>
+            <artifactId>wstx-asl</artifactId>
+            <version>3.2.1</version>
             <scope>test</scope>
         </dependency>
     </dependencies>
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/WinkConfiguration.java b/wink-common/src/main/java/org/apache/wink/common/internal/WinkConfiguration.java
new file mode 100644
index 00000000..b6d26bb0
--- /dev/null
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/WinkConfiguration.java
@@ -0,0 +1,38 @@
+/*******************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *  
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *  
+ *******************************************************************************/
+package org.apache.wink.common.internal;
+
+import java.util.Properties;
+
+public interface WinkConfiguration {
+    
+    /**
+     * get configuration properties
+     * 
+     * @return configuration properties as defined by the server or client Wink module
+     */
+    public Properties getProperties();
+
+    /**
+     * @param properties the properties you intend to set for configuration on the server or client Wink module
+     */
+    public void setProperties(Properties properties);
+
+}
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/properties/WinkSystemProperties.java b/wink-common/src/main/java/org/apache/wink/common/internal/properties/WinkSystemProperties.java
new file mode 100644
index 00000000..7d47ee3f
--- /dev/null
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/properties/WinkSystemProperties.java
@@ -0,0 +1,83 @@
+/*******************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *  
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *  
+ *******************************************************************************/
+
+package org.apache.wink.common.internal.properties;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Enumeration;
+import java.util.Properties;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class WinkSystemProperties {
+
+    private static final Logger logger = LoggerFactory.getLogger(WinkSystemProperties.class);
+    
+    /**
+     * Walks through each of the passed-in properties--presumably, these are
+     * all defined in a configuration file. - If the property is already set, do
+     * nothing. - If not, read it as a JVM property; if detected, set the
+     * property on systemProperties, which is returned.
+     */
+    public static Properties loadSystemProperties(Properties properties) {
+        String key = null;
+        String value = null;
+        Properties systemProperties = new Properties();
+
+        // Read the properties contained in passed-in properties
+        if (properties != null) {
+            Enumeration<?> keyEnum = properties.propertyNames();
+            while (keyEnum.hasMoreElements()) {
+                key = (String)keyEnum.nextElement();
+                value = (String)properties.get(key);
+
+                // If value is null or empty, try to read as JVM property
+                if (value == null || value.length() == 0) {
+                    value = getSystemProperty(key);
+                    if(value != null) {
+                        systemProperties.setProperty(key, value);
+                    }
+                } else {
+                    logger.debug("Property {} is already defined with value {}", key, value); //$NON-NLS-1$
+                }
+            }
+        } else {
+            logger.debug("Properties are null"); //$NON-NLS-1$
+        }
+        return systemProperties;
+    }
+
+    /**
+     * Reads the JVM property and returns the value (which could be null).
+     */
+    private static String getSystemProperty(final String key) {
+        String value = AccessController.doPrivileged(new PrivilegedAction<String>() {
+            public String run() {
+                String v = System.getProperty(key);
+                logger.debug(key + " = " + v); //$NON-NLS-1$
+                return v;
+            }
+        });
+        return value;
+    }
+
+}
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/SourceProvider.java b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/SourceProvider.java
index 3b35bac0..cd1a147a 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/SourceProvider.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/SourceProvider.java
@@ -25,15 +25,19 @@ import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import java.util.Properties;
 
 import javax.ws.rs.Consumes;
 import javax.ws.rs.Produces;
 import javax.ws.rs.WebApplicationException;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.Response;
 import javax.ws.rs.ext.MessageBodyReader;
 import javax.ws.rs.ext.MessageBodyWriter;
 import javax.ws.rs.ext.Provider;
+import javax.xml.XMLConstants;
+import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.transform.Source;
@@ -45,15 +49,27 @@ import javax.xml.transform.sax.SAXSource;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 
+import org.apache.wink.common.RuntimeContext;
+import org.apache.wink.common.internal.WinkConfiguration;
+import org.apache.wink.common.internal.i18n.Messages;
+import org.apache.wink.common.internal.runtime.RuntimeContextTLS;
 import org.apache.wink.common.internal.utils.MediaTypeUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
 
 public abstract class SourceProvider implements MessageBodyWriter<Source> {
 
     private static TransformerFactory     transformerFactory;
     private static DocumentBuilderFactory documentBuilderFactory;
 
+    private static final Logger logger =
+        LoggerFactory
+            .getLogger(SourceProvider.class);
+    
     static {
         transformerFactory = TransformerFactory.newInstance();
         documentBuilderFactory = DocumentBuilderFactory.newInstance();
@@ -113,13 +129,42 @@ public abstract class SourceProvider implements MessageBodyWriter<Source> {
     @Produces( {MediaType.TEXT_XML, MediaType.APPLICATION_XML, MediaType.WILDCARD})
     public static class DOMSourceProvider extends SourceProvider implements
         MessageBodyReader<DOMSource> {
-
+        
         public boolean isReadable(Class<?> type,
                                   Type genericType,
                                   Annotation[] annotations,
                                   MediaType mediaType) {
             return (DOMSource.class == type && super.isReadable(mediaType));
         }
+        
+        private void setupDocumentBuilderToFilterDTD(DocumentBuilder dbuilder) {
+            /*
+             * You might think you could just do this to prevent entity expansion:
+             *    documentBuilderFactory.setExpandEntityReferences(false);
+             * In fact, you should not do that, because it will just increase the size
+             * of your DOMSource.  We want to actively reject XML when a DTD is present, so...
+             */
+            dbuilder.setEntityResolver(new EntityResolver() {
+                public InputSource resolveEntity(String name, String baseURI)
+                throws SAXException, IOException {
+                    // we don't support entity resolution here
+                    throw new SAXParseException(Messages.getMessage("entityRefsNotSupported"), null, null);  //$NON-NLS-1$
+                }
+            });
+            try {
+                // important: keep this order
+                documentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
+            } catch (ParserConfigurationException e) {
+                // this should never happen if you run the SourceProviderTest unittests
+                logger.error(e.getMessage());
+            }
+            try {
+                // workaround for JDK5 bug that causes NPE in checking done due to above FEATURE_SECURE_PROCESSING
+                documentBuilderFactory.setFeature("http://apache.org/xml/features/dom/defer-node-expansion", false);
+            } catch (ParserConfigurationException e) {
+                // possible if not on apache parser?  ignore...
+            }
+        }
 
         public DOMSource readFrom(Class<DOMSource> type,
                                   Type genericType,
@@ -129,12 +174,25 @@ public abstract class SourceProvider implements MessageBodyWriter<Source> {
                                   InputStream entityStream) throws IOException,
             WebApplicationException {
             try {
-                return new DOMSource(documentBuilderFactory.newDocumentBuilder()
-                    .parse(entityStream));
+                DocumentBuilder dbuilder = documentBuilderFactory.newDocumentBuilder();
+                RuntimeContext runtimeContext = RuntimeContextTLS.getRuntimeContext();
+                WinkConfiguration winkConfig = runtimeContext.getAttribute(WinkConfiguration.class);
+                if (winkConfig != null) {
+                    Properties props = winkConfig.getProperties();
+                    if (props != null) {
+                        // use valueOf method to require the word "true"
+                        if (!Boolean.valueOf(props.getProperty("wink.supportDTDEntityExpansion"))) {
+                            setupDocumentBuilderToFilterDTD(dbuilder);
+                        }
+                    }
+                }
+                return new DOMSource(dbuilder.parse(entityStream));
             } catch (SAXException e) {
-                throw asIOExcpetion(e);
+                logger.error(Messages.getMessage("saxParseException", type.getName()), e); //$NON-NLS-1$
+                throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
             } catch (ParserConfigurationException e) {
-                throw asIOExcpetion(e);
+                logger.error(Messages.getMessage("saxParserConfigurationException"), e); //$NON-NLS-1$
+                throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
             }
         }
     }
@@ -171,11 +229,11 @@ public abstract class SourceProvider implements MessageBodyWriter<Source> {
             transformer = transformerFactory.newTransformer();
             transformer.transform(t, sr);
         } catch (TransformerException e) {
-            throw asIOExcpetion(e);
+            throw asIOException(e);
         }
     }
-
-    private static IOException asIOExcpetion(Exception e) throws IOException {
+    
+    private static IOException asIOException(Exception e) throws IOException {
         IOException exception = new IOException();
         exception.initCause(e);
         return exception;
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBCollectionProvider.java b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBCollectionProvider.java
index b75f5727..2c7e6b39 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBCollectionProvider.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBCollectionProvider.java
@@ -45,7 +45,6 @@ import javax.xml.bind.Marshaller;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.bind.annotation.XmlRootElement;
 import javax.xml.namespace.QName;
-import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
@@ -68,18 +67,19 @@ public abstract class AbstractJAXBCollectionProvider extends AbstractJAXBProvide
                        MediaType mediaType,
                        MultivaluedMap<String, String> httpHeaders,
                        InputStream entityStream) throws IOException, WebApplicationException {
+        XMLStreamReader xsr = null;
         try {
-            XMLInputFactory xmif = XMLInputFactory.newInstance();
-            XMLStreamReader xsr = xmif.createXMLStreamReader(entityStream);
+            xsr = getXMLStreamReader(entityStream);
             Class<?> theType = getParameterizedTypeClass(type, genericType, true);
             JAXBContext context = getContext(theType, mediaType);
             Unmarshaller unmarshaller = getJAXBUnmarshaller(type, context, mediaType);
 
-            int nextEvent = xsr.next();
+            int nextEvent = xsr.getEventType();
             while (nextEvent != XMLStreamReader.START_ELEMENT)
                 nextEvent = xsr.next();
 
             List<Object> elementList = new ArrayList<Object>();
+            // skip the plural tag
             nextEvent = xsr.next();
             while (nextEvent != XMLStreamReader.END_DOCUMENT) {
                 switch (nextEvent) {
@@ -87,7 +87,11 @@ public abstract class AbstractJAXBCollectionProvider extends AbstractJAXBProvide
                         if (getParameterizedTypeClass(type, genericType, false) == JAXBElement.class) {
                             elementList.add(unmarshaller.unmarshal(xsr, theType));
                         } else if (theType.isAnnotationPresent(XmlRootElement.class)) {
-                            elementList.add(unmarshaller.unmarshal(xsr));
+                            Object o = unmarshaller.unmarshal(xsr);
+                            if (o instanceof JAXBElement) {
+                                o = ((JAXBElement)o).getValue();
+                            }
+                            elementList.add(o);
                         } else {
                             elementList.add(unmarshaller.unmarshal(xsr, theType).getValue());
                         }
@@ -97,6 +101,7 @@ public abstract class AbstractJAXBCollectionProvider extends AbstractJAXBProvide
                         nextEvent = xsr.next();
                 }
             }
+            closeXMLStreamReader(xsr);
 
             Object ret = null;
             if (type.isArray())
@@ -109,13 +114,18 @@ public abstract class AbstractJAXBCollectionProvider extends AbstractJAXBProvide
             releaseJAXBUnmarshaller(context, unmarshaller);
             return ret;
         } catch (XMLStreamException e) {
+            closeXMLStreamReader(xsr);
             logger.error(Messages.getMessage("jaxbFailToUnmarshal", type.getName()), e); // TODO //$NON-NLS-1$
             // change
             // message
             throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
         } catch (JAXBException e) {
+            closeXMLStreamReader(xsr);
             logger.error(Messages.getMessage("jaxbFailToUnmarshal", type.getName()), e); //$NON-NLS-1$
             throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
+        } catch (RuntimeException e) {
+            closeXMLStreamReader(xsr);
+            throw e;
         }
     }
 
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBProvider.java b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBProvider.java
index 811ad9f4..500a09f3 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBProvider.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBProvider.java
@@ -19,6 +19,8 @@
  *******************************************************************************/
 package org.apache.wink.common.internal.providers.entity.xml;
 
+import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.lang.ref.SoftReference;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
@@ -28,6 +30,7 @@ import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Properties;
 import java.util.concurrent.ConcurrentHashMap;
 
 import javax.ws.rs.WebApplicationException;
@@ -44,8 +47,14 @@ import javax.xml.bind.annotation.XmlRegistry;
 import javax.xml.bind.annotation.XmlRootElement;
 import javax.xml.bind.annotation.XmlType;
 import javax.xml.namespace.QName;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
 
+import org.apache.wink.common.RuntimeContext;
+import org.apache.wink.common.internal.WinkConfiguration;
 import org.apache.wink.common.internal.i18n.Messages;
+import org.apache.wink.common.internal.runtime.RuntimeContextTLS;
 import org.apache.wink.common.internal.utils.JAXBUtils;
 import org.apache.wink.common.internal.utils.MediaTypeUtils;
 import org.apache.wink.common.internal.utils.SoftConcurrentMap;
@@ -84,7 +93,12 @@ public abstract class AbstractJAXBProvider {
                                                                                                 new Pool<JAXBContext, Marshaller>();
     private Pool<JAXBContext, Unmarshaller>                       upool                     =
                                                                                                 new Pool<JAXBContext, Unmarshaller>();
+                                                                                                
 
+    // For performance, it might seem advantageous to use a static XMLInputFactory instance.  However, this was shown to
+    // be problematic on the Sun StAX parser (which is a fork of Apache Xerces) under load stress test.  So we use ThreadLocal.
+    private static ThreadLocal<XMLInputFactory> xmlInputFactory = new ThreadLocal<XMLInputFactory>();
+    
     /**
      * This class is the key to the JAXBContext cache. It must be based on the
      * ContextResolver instance who created the JAXBContext and the type passed
@@ -208,6 +222,96 @@ public abstract class AbstractJAXBProvider {
 
         return unm;
     }
+    
+    /**
+     * skips START_DOCUMENT, COMMENTs, PIs, and checks for DTD
+     * @param reader
+     * @throws XMLStreamException
+     */
+    private static void checkForDTD(XMLStreamReader reader)
+            throws XMLStreamException {
+        boolean supportDTD = false;
+
+        int event = reader.getEventType();
+        if (event != XMLStreamReader.START_DOCUMENT) {
+            // something went horribly wrong; the reader passed into us has
+            // already been partially processed
+            throw new XMLStreamException(Messages.getMessage("badXMLReaderInitialStart")); //$NON-NLS-1$
+        }
+        while (event != XMLStreamReader.START_ELEMENT) {  // all StAX parsers require a START_ELEMENT.  See AbstractJAXBProviderTest class
+            event = reader.next();
+            if (event == XMLStreamReader.DTD) {
+
+                RuntimeContext runtimeContext = RuntimeContextTLS.getRuntimeContext();
+                WinkConfiguration winkConfig = runtimeContext.getAttribute(WinkConfiguration.class);
+                if (winkConfig != null) {
+                    Properties props = winkConfig.getProperties();
+                    if (props != null) {
+                        // use valueOf method to require the word "true"
+                        supportDTD = Boolean.valueOf(props.getProperty("wink.supportDTDEntityExpansion"));
+                    }
+                }
+                if (!supportDTD) {
+                    throw new XMLStreamException(Messages.getMessage("entityRefsNotSupported")); //$NON-NLS-1$
+                } else {
+                    logger.debug("DTD entity reference expansion is enabled.  This may present a security risk.");
+                }
+            }
+        }
+    }
+    
+    private static XMLInputFactory getXMLInputFactory() {
+        XMLInputFactory factory = xmlInputFactory.get();
+        if (factory == null) {
+            factory = XMLInputFactory.newInstance();
+            xmlInputFactory.set(factory);
+        }
+        return factory;
+    }
+    
+    /**
+     * A consistent place to get a properly configured XMLStreamReader.
+     * 
+     * @param entityStream
+     * @return
+     * @throws XMLStreamException
+     */
+    protected static XMLStreamReader getXMLStreamReader(InputStream entityStream) throws XMLStreamException  {
+        // NOTE: createFilteredReader may appear to be more convenient, but it comes at the cost of
+        // performance.  This solution (to use checkForDTD) appears to be the best solution to preserve
+        // performance, but still achieve what we need to do.
+        XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(entityStream);
+        checkForDTD(reader);
+        return reader;
+    }
+    
+    /**
+     * A consistent place to get a properly configured XMLStreamReader.
+     * 
+     * @param entityStream
+     * @return
+     * @throws XMLStreamException
+     */
+    protected static XMLStreamReader getXMLStreamReader(InputStreamReader entityStreamReader) throws XMLStreamException  {
+        // NOTE: createFilteredReader may appear to be more convenient, but it comes at the cost of
+        // performance.  This solution (to use checkForDTD) appears to be the best solution to preserve
+        // performance, but still achieve what we need to do.
+        XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(entityStreamReader);
+        checkForDTD(reader);
+        return reader;
+    }
+    
+    protected static void closeXMLStreamReader(XMLStreamReader xmlStreamReader) {
+        if (xmlStreamReader != null) {
+            try {
+                xmlStreamReader.close();
+            } catch (XMLStreamException e) {
+                logger.debug("XMLStreamReader already closed.", e);
+            } catch (RuntimeException e) {
+                logger.debug("RuntimeException occurred: ", e);
+            }
+        }
+    }
 
     private static Unmarshaller internalCreateUnmarshaller(final JAXBContext context)
         throws JAXBException {
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/JAXBElementXmlProvider.java b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/JAXBElementXmlProvider.java
index b1a24704..5f0a0f8d 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/JAXBElementXmlProvider.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/JAXBElementXmlProvider.java
@@ -27,13 +27,10 @@ import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.nio.charset.Charset;
-import java.util.HashMap;
-import java.util.Map;
 
 import javax.ws.rs.Consumes;
 import javax.ws.rs.Produces;
 import javax.ws.rs.WebApplicationException;
-import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.Response;
@@ -45,10 +42,10 @@ import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Marshaller;
 import javax.xml.bind.Unmarshaller;
-import javax.xml.transform.stream.StreamSource;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
 
 import org.apache.wink.common.internal.i18n.Messages;
-import org.apache.wink.common.internal.model.ModelUtils;
 import org.apache.wink.common.internal.utils.MediaTypeUtils;
 import org.apache.wink.common.utils.ProviderUtils;
 import org.slf4j.Logger;
@@ -81,6 +78,7 @@ public class JAXBElementXmlProvider extends AbstractJAXBProvider implements
         JAXBElement<?> unmarshaledResource = null;
         Unmarshaller unmarshaller = null;
 
+        XMLStreamReader xmlStreamReader = null;
         try {
             JAXBContext context = getContext(classToFill, mediaType);
             unmarshaller = getJAXBUnmarshaller(type, context, mediaType);
@@ -88,19 +86,31 @@ public class JAXBElementXmlProvider extends AbstractJAXBProvider implements
             if (charset == null) {
                 // use default
                 // performance is better, though the charset cannot be ensured
-                unmarshaledResource =
-                    unmarshaller.unmarshal(new StreamSource(entityStream), classToFill);
+                xmlStreamReader = getXMLStreamReader(entityStream);
+                unmarshaledResource = unmarshaller.unmarshal(xmlStreamReader, classToFill);
+                closeXMLStreamReader(xmlStreamReader);
             } else {
-                ModelUtils.unmarshal(unmarshaller, new InputStreamReader(entityStream, Charset
-                    .forName(charset)));
+                xmlStreamReader = getXMLStreamReader(new InputStreamReader(entityStream, Charset.forName(charset)));
+                unmarshaledResource = unmarshaller.unmarshal(xmlStreamReader, classToFill);
+                closeXMLStreamReader(xmlStreamReader);
             }
 
             releaseJAXBUnmarshaller(context, unmarshaller);
         } catch (JAXBException e) {
+            closeXMLStreamReader(xmlStreamReader);
             if (logger.isErrorEnabled()) {
                 logger.error(Messages.getMessage("jaxbFailToUnmarshal", type.getName()), e); //$NON-NLS-1$
             }
             throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
+        } catch (XMLStreamException e) {
+            closeXMLStreamReader(xmlStreamReader);
+            if (logger.isErrorEnabled()) {
+                logger.error(Messages.getMessage("entityRefsNotSupported")); //$NON-NLS-1$
+            }
+            throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
+        } catch (RuntimeException e) {
+            closeXMLStreamReader(xmlStreamReader);
+            throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
         }
         return unmarshaledResource;
     }
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/JAXBXmlProvider.java b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/JAXBXmlProvider.java
index 2609ca67..2cfe3a6d 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/JAXBXmlProvider.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/xml/JAXBXmlProvider.java
@@ -40,7 +40,8 @@ import javax.xml.bind.JAXBException;
 import javax.xml.bind.Marshaller;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.bind.annotation.XmlRootElement;
-import javax.xml.transform.stream.StreamSource;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
 
 import org.apache.wink.common.internal.i18n.Messages;
 import org.apache.wink.common.internal.utils.MediaTypeUtils;
@@ -70,11 +71,14 @@ public class JAXBXmlProvider extends AbstractJAXBProvider implements MessageBody
                            InputStream entityStream) throws IOException, WebApplicationException {
         Unmarshaller unmarshaller = null;
         Object unmarshaledResource = null;
+        XMLStreamReader xmlStreamReader = null;
         try {
             JAXBContext context = getContext(type, mediaType);
             unmarshaller = getJAXBUnmarshaller(type, context, mediaType);
+            xmlStreamReader = getXMLStreamReader(entityStream);
             if (type.isAnnotationPresent(XmlRootElement.class)) {
-                unmarshaledResource = unmarshaller.unmarshal(entityStream);
+                unmarshaledResource = unmarshaller.unmarshal(xmlStreamReader);
+                closeXMLStreamReader(xmlStreamReader);
                 if (unmarshaledResource instanceof JAXBElement) {
                     // this can happen if the JAXBContext object used to create
                     // the unmarshaller
@@ -90,16 +94,26 @@ public class JAXBXmlProvider extends AbstractJAXBProvider implements MessageBody
                     unmarshaledResource = ((JAXBElement)unmarshaledResource).getValue();
                 }
             } else {
-                unmarshaledResource =
-                    unmarshaller.unmarshal(new StreamSource(entityStream), type).getValue();
+                unmarshaledResource = unmarshaller.unmarshal(xmlStreamReader, type).getValue();
+                closeXMLStreamReader(xmlStreamReader);
             }
 
             releaseJAXBUnmarshaller(context, unmarshaller);
         } catch (JAXBException e) {
+            closeXMLStreamReader(xmlStreamReader);
             if (logger.isErrorEnabled()) {
                 logger.error(Messages.getMessage("jaxbFailToUnmarshal", type.getName()), e); //$NON-NLS-1$
             }
             throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
+        } catch (XMLStreamException e) {
+            closeXMLStreamReader(xmlStreamReader);
+            if (logger.isErrorEnabled()) {
+                logger.error(Messages.getMessage("entityRefsNotSupported")); //$NON-NLS-1$
+            }
+            throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
+        } catch (RuntimeException e) {
+            closeXMLStreamReader(xmlStreamReader);
+            throw e;
         }
         return unmarshaledResource;
     }
diff --git a/wink-common/src/main/resources/org/apache/wink/common/internal/i18n/resource.properties b/wink-common/src/main/resources/org/apache/wink/common/internal/i18n/resource.properties
index 7ac86eec..e9c9191f 100644
--- a/wink-common/src/main/resources/org/apache/wink/common/internal/i18n/resource.properties
+++ b/wink-common/src/main/resources/org/apache/wink/common/internal/i18n/resource.properties
@@ -227,3 +227,7 @@ serviceFailedToAuthenticateUser=Service failed to authenticate user: {0}
 providerShouldBeAnnotatedDirectly=@javax.ws.rs.ext.Provider was found on a superclass or interface on class {0}.  Annotate @javax.ws.rs.ext.Provider on the provider class directly to ensure portability between environments.
 rootResourceShouldBeAnnotatedDirectly=@javax.ws.rs.Path was found on a superclass or interface on class {0}.  Annotate @javax.ws.rs.Path on the root resource class directly to ensure portability between environments.
 providerIsInterfaceOrAbstract=@javax.ws.rs.ext.Provider found on interface or abstract class {0} and is being ignored. Annotate @javax.ws.rs.ext.Provider on the provider implementation or base class directly and return that in your javax.ws.rs.core.Application subclass.
+entityRefsNotSupported=Entity references are not supported in XML documents due to possible security vulnerabilities.
+saxParseException=The system cannot parse the XML content into a {0} instance.  Verify that the XML content is valid.
+saxParserConfigurationException=The system cannot configure the SAX parser with the given configuration parameter.
+badXMLReaderInitialStart=The XMLStreamReader instance has already been partially processed.
diff --git a/wink-common/src/test/java/org/apache/wink/common/internal/application/ApplicationFileLoaderTest.java b/wink-common/src/test/java/org/apache/wink/common/internal/application/ApplicationFileLoaderTest.java
index c24665a6..34ded79b 100644
--- a/wink-common/src/test/java/org/apache/wink/common/internal/application/ApplicationFileLoaderTest.java
+++ b/wink-common/src/test/java/org/apache/wink/common/internal/application/ApplicationFileLoaderTest.java
@@ -21,11 +21,15 @@ package org.apache.wink.common.internal.application;
 
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Set;
+import java.util.logging.LogRecord;
 
 import junit.framework.TestCase;
 
+import org.apache.wink.logging.WinkLogHandler;
+
 public class ApplicationFileLoaderTest extends TestCase {
 
     public void testDefault() throws IOException {
@@ -43,6 +47,16 @@ public class ApplicationFileLoaderTest extends TestCase {
             .contains(org.apache.wink.common.internal.providers.entity.ByteArrayProvider.class));
     }
 
+    public void testLogging() throws Exception {
+        //WinkLogHandler.turnLoggingCaptureOn();  // WinkLogHandler imported from wink-component-test-support module
+        ApplicationFileLoader applicationFileLoader =
+            new ApplicationFileLoader("org//apache//wink//common//internal//application//custom.app");
+        //WinkLogHandler.turnLoggingCaptureOff();
+        //ArrayList<LogRecord> logRecords = WinkLogHandler.getRecords();
+        //assertEquals(13, logRecords.size());
+        //WinkLogHandler.clearRecords();  // recommend doing this so static ArrayList of LogRecords is clear for next test
+    }
+    
     public void testFileNotFound() {
         try {
             new ApplicationFileLoader("noSuchFile");
diff --git a/wink-common/src/test/java/org/apache/wink/common/internal/properties/WinkSystemPropertiesTest.java b/wink-common/src/test/java/org/apache/wink/common/internal/properties/WinkSystemPropertiesTest.java
new file mode 100644
index 00000000..5d9c3d95
--- /dev/null
+++ b/wink-common/src/test/java/org/apache/wink/common/internal/properties/WinkSystemPropertiesTest.java
@@ -0,0 +1,75 @@
+/*******************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *  
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *  
+ *******************************************************************************/
+package org.apache.wink.common.internal.properties;
+
+import java.util.Properties;
+
+import junit.framework.TestCase;
+
+import org.junit.Test;
+
+public class WinkSystemPropertiesTest extends TestCase {
+
+    private static final String PROP_KEY = "someSysPropKey";
+    
+    @Override
+    public void setUp() {
+        System.clearProperty(PROP_KEY);
+    }
+    
+    @Test
+    public void testNullToleration() {
+        System.setProperty(PROP_KEY, "false");
+        // loadSystemProperties can only override an existing key in the properties bag.  We should get an empty bag back
+        Properties props = WinkSystemProperties.loadSystemProperties(null);
+        assertTrue("expected empty properties bag", props.isEmpty());
+    }
+
+    
+    @Test
+    public void testEmptyValue() {
+        Properties startProps = new Properties();
+        startProps.put(PROP_KEY, "");
+        System.setProperty(PROP_KEY, "false");
+        // loadSystemProperties can override an existing key in the properties bag when the value is empty
+        Properties props = WinkSystemProperties.loadSystemProperties(startProps);
+        assertEquals("expected non-null \""+PROP_KEY+"\" property to be \"false\"", "false", props.getProperty(PROP_KEY));
+    }
+    
+    @Test
+    public void testGetSystemProperties() throws Exception {
+        Properties startProps = new Properties();  // empty
+        System.setProperty(PROP_KEY, "false");
+        // loadSystemProperties can only override an existing key in the properties bag.  We should get an empty bag back
+        Properties props = WinkSystemProperties.loadSystemProperties(startProps);
+        assertTrue("expected empty properties bag", props.isEmpty());
+    }
+    
+    @Test
+    public void testPropsOverride() throws Exception {
+        Properties startProps = new Properties();
+        startProps.setProperty(PROP_KEY, "true");
+        System.setProperty(PROP_KEY, "false");
+        // make sure the system property does NOT override what's already in the bag.  We should get an empty bag back
+        Properties props = WinkSystemProperties.loadSystemProperties(startProps);
+        assertTrue("expected empty properties bag", props.isEmpty());
+    }
+
+}
diff --git a/wink-common/src/test/java/org/apache/wink/common/internal/providers/entity/SourceProviderTest.java b/wink-common/src/test/java/org/apache/wink/common/internal/providers/entity/SourceProviderTest.java
index 369687e6..a5332ad0 100644
--- a/wink-common/src/test/java/org/apache/wink/common/internal/providers/entity/SourceProviderTest.java
+++ b/wink-common/src/test/java/org/apache/wink/common/internal/providers/entity/SourceProviderTest.java
@@ -19,16 +19,99 @@
  *******************************************************************************/
 package org.apache.wink.common.internal.providers.entity;
 
-import static org.junit.Assert.assertTrue;
+import java.io.ByteArrayInputStream;
+import java.util.Properties;
+import java.util.StringTokenizer;
 
 import javax.ws.rs.core.MediaType;
+import javax.ws.rs.ext.MessageBodyReader;
+import javax.ws.rs.ext.Providers;
 import javax.xml.transform.Source;
+import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamSource;
 
+import org.apache.wink.common.RuntimeContext;
+import org.apache.wink.common.internal.WinkConfiguration;
+import org.apache.wink.common.internal.contexts.MediaTypeCharsetAdjuster;
+import org.apache.wink.common.internal.providers.entity.SourceProvider.DOMSourceProvider;
+import org.apache.wink.common.internal.runtime.RuntimeContextTLS;
+import org.apache.wink.common.model.JAXBUnmarshalOptions;
+import org.apache.wink.common.model.XmlFormattingOptions;
+import org.jmock.Expectations;
+import org.jmock.integration.junit3.MockObjectTestCase;
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
-public class SourceProviderTest {
+public class SourceProviderTest extends MockObjectTestCase {
 
+    static String path = null;
+    static {
+        String classpath = System.getProperty("java.class.path");
+        StringTokenizer tokenizer = new StringTokenizer(classpath, System.getProperty("path.separator"));
+        while (tokenizer.hasMoreTokens()) {
+            path = tokenizer.nextToken();
+            if (path.endsWith("test-classes")) {
+                break;
+            }
+        }
+        // for windows:
+        int driveIndex = path.indexOf(":");
+        if(driveIndex != -1) {
+            path = path.substring(driveIndex + 1);
+        }
+    }
+    
+    static final String xmlWithDTD = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>" +
+        "<!DOCTYPE data [<!ENTITY file SYSTEM \"file:"+ path +"/etc/SourceProviderTest.txt\">]>" +
+        "<ns2:messages xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:arg0>&file;</ns2:arg0>" +
+        "</ns2:messages>";
+    
+
+    private WinkConfiguration winkConfiguration = null;
+    private MessageBodyReader sourceProviderReader = null;
+    private Providers providers;
+    
+    @Before
+    public void setUp() {
+        providers = mock(Providers.class);
+        final RuntimeContext runtimeContext = mock(RuntimeContext.class);
+        winkConfiguration = mock(WinkConfiguration.class);
+        checking(new Expectations() {{
+            allowing(providers).getContextResolver(XmlFormattingOptions.class, MediaType.TEXT_XML_TYPE); will(returnValue(null));
+            allowing(providers).getContextResolver(JAXBUnmarshalOptions.class, MediaType.TEXT_XML_TYPE); will(returnValue(null));
+            allowing(runtimeContext).getAttribute(MediaTypeCharsetAdjuster.class); will(returnValue(null));
+            allowing(runtimeContext).getAttribute(WinkConfiguration.class); will(returnValue(winkConfiguration));
+        }});
+        RuntimeContextTLS.setRuntimeContext(runtimeContext);
+        sourceProviderReader = new DOMSourceProvider();
+        
+    }
+    
+    @After
+    public void tearDown() {
+        RuntimeContextTLS.setRuntimeContext(null);
+    }
+
+    
+    @Test
+    /**
+     * testing that supporting DTD expansion is configurable
+     */
+    public void testJAXBUnmarshallingWithDTDServerConfigurable() throws Exception {
+        
+        final Properties props = new Properties();
+        props.put("wink.supportDTDEntityExpansion", "true");
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        assertTrue(sourceProviderReader.isReadable(DOMSource.class, null, null, MediaType.TEXT_XML_TYPE));
+        ByteArrayInputStream bais = new ByteArrayInputStream(xmlWithDTD.getBytes());
+        Object obj = sourceProviderReader.readFrom(DOMSource.class, null, null, MediaType.TEXT_XML_TYPE, null, bais);
+        assertTrue(obj instanceof DOMSource);
+    }
     @Test
     public void testStreamSourceProviderIsReadable() {
         // Entity Stream to be read with SourceProvider
diff --git a/wink-common/src/test/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBProviderTest.java b/wink-common/src/test/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBProviderTest.java
new file mode 100644
index 00000000..9d146099
--- /dev/null
+++ b/wink-common/src/test/java/org/apache/wink/common/internal/providers/entity/xml/AbstractJAXBProviderTest.java
@@ -0,0 +1,232 @@
+/*******************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *  
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *  
+ *******************************************************************************/
+package org.apache.wink.common.internal.providers.entity.xml;
+
+import java.io.ByteArrayInputStream;
+import java.util.Properties;
+import java.util.StringTokenizer;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+
+import org.apache.wink.common.RuntimeContext;
+import org.apache.wink.common.internal.WinkConfiguration;
+import org.apache.wink.common.internal.runtime.RuntimeContextTLS;
+import org.jmock.Expectations;
+import org.jmock.integration.junit3.MockObjectTestCase;
+import org.junit.After;
+import org.junit.Before;
+
+/**
+ * this test class is relatively new compared to the various
+ * XML provider tests here in wink-common and wink-server.
+ * Hence there are not as many tests as you might expect.  I'm
+ * confident in the amount of testing being done in other places.
+ *
+ */
+public class AbstractJAXBProviderTest extends MockObjectTestCase {
+
+    /*
+     * this test class is relatively new compared to the various
+     * XML provider tests here in wink-common and wink-server.
+     * Hence there are not as many tests as you might expect.  I'm
+     * confident in the amount of testing being done in other places.
+     */
+    
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlRootElement(name = "message")
+    public static class Message {
+
+        protected String arg0;
+
+        /**
+         * Gets the value of the arg0 property.
+         * 
+         */
+        public String getArg0() {
+            return arg0;
+        }
+
+        /**
+         * Sets the value of the arg0 property.
+         * 
+         */
+        public void setArg0(String value) {
+            this.arg0 = value;
+        }
+
+    }
+    
+    static String TEST_CLASSES_PATH = null;
+    static {
+        String classpath = System.getProperty("java.class.path");
+        StringTokenizer tokenizer = new StringTokenizer(classpath, System.getProperty("path.separator"));
+        while (tokenizer.hasMoreTokens()) {
+            TEST_CLASSES_PATH = tokenizer.nextToken();
+            if (TEST_CLASSES_PATH.endsWith("test-classes")) {
+                break;
+            }
+        }
+        // for windows:
+        int driveIndex = TEST_CLASSES_PATH.indexOf(":");
+        if(driveIndex != -1) {
+            TEST_CLASSES_PATH = TEST_CLASSES_PATH.substring(driveIndex + 1);
+        }
+    }
+    
+    public WinkConfiguration winkConfiguration = null;
+    
+    @Before
+    public void setUp() {
+        winkConfiguration = mock(WinkConfiguration.class);
+        final RuntimeContext runtimeContext = mock(RuntimeContext.class);
+        checking(new Expectations() {{
+            allowing(runtimeContext).getAttribute(WinkConfiguration.class); will(returnValue(winkConfiguration));
+        }});
+        RuntimeContextTLS.setRuntimeContext(runtimeContext);
+    }
+    
+    @After
+    public void tearDown() {
+        // clean up the mess.  :)
+        RuntimeContextTLS.setRuntimeContext(null);
+    }
+    
+    public void testGetXMLStreamReader1() throws Exception {
+        
+        final Properties props = new Properties();
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        // check for infinite loop, empty document
+        final String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>";
+        ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
+        try {
+            AbstractJAXBProvider.getXMLStreamReader(bais);
+            fail("should have got an exception");
+        } catch (XMLStreamException e) {
+            // any other exception type will cause test failure
+        }
+    }
+    
+    public void testGetXMLStreamReader2() throws Exception {
+        
+        final Properties props = new Properties();
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        // check for infinite loop, comment only
+        final String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><!-- comment -->";
+        ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
+        try {
+            AbstractJAXBProvider.getXMLStreamReader(bais);
+            fail("should have got an exception");
+        } catch (XMLStreamException e) {
+            // any other exception type will cause test failure
+        }
+    }
+    
+    public void testGetXMLStreamReader3() throws Exception {
+        
+        final Properties props = new Properties();
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        // check for infinite loop, whitespace and comment
+        final String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>  <!-- comment -->";
+        ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
+        try {
+            AbstractJAXBProvider.getXMLStreamReader(bais);
+            fail("should have got an exception");
+        } catch (XMLStreamException e) {
+            // any other exception type will cause test failure
+        }
+    }
+    
+    public void testGetXMLStreamReader4() throws Exception {
+        
+        final Properties props = new Properties();
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        // check for infinite loop, whitespace, comment, and whitespace
+        final String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>  <!-- comment -->   ";
+        ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
+        try {
+            AbstractJAXBProvider.getXMLStreamReader(bais);
+            fail("should have got an exception");
+        } catch (XMLStreamException e) {
+            // any other exception type will cause test failure
+        }
+    }
+    
+    public void testGetXMLStreamReaderWithDTDUnsupported() throws Exception {
+        
+        final Properties props = new Properties();
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        // check for infinite loop, whitespace, comment, whitespace, and DOCTYPE unsupported
+        final String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>  <!-- comment -->   " + 
+        "<!DOCTYPE data [<!ENTITY file SYSTEM \"file:"+ TEST_CLASSES_PATH +"/etc/ProvidersJAXBTest.txt\">]>" +
+        "<message>&file;</message>";
+        ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
+        try {
+            AbstractJAXBProvider.getXMLStreamReader(bais);
+            fail("should have got an exception");
+        } catch (XMLStreamException e) {
+            // any other exception type will cause test failure
+        }
+    }
+    
+    public void testGetXMLStreamReaderWithDTDSupported() throws Exception {
+        
+        final Properties props = new Properties();
+        props.put("wink.supportDTDEntityExpansion", "true");
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        // check for infinite loop, whitespace, comment, whitespace, and DOCTYPE supported
+        final String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>  <!-- comment -->   " + 
+        "<!DOCTYPE data [<!ENTITY file SYSTEM \"file:"+ TEST_CLASSES_PATH +"/etc/ProvidersJAXBTest.txt\">]>" +
+        "<message><arg0>&file;</arg0></message>";
+        ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
+        XMLStreamReader reader = AbstractJAXBProvider.getXMLStreamReader(bais);
+        assertEquals("reader event should be start element", XMLStreamReader.START_ELEMENT, reader.getEventType());
+        
+        JAXBContext context = JAXBContext.newInstance(Message.class);
+        Unmarshaller unmarshaller = context.createUnmarshaller();
+        Message message = (Message)unmarshaller.unmarshal(reader);
+        
+        assertEquals("message object should contain text from ProvidersJAXBTest.txt file", "99999999", message.getArg0().trim());
+    }
+    
+}
diff --git a/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/AbstractJAXBCollectionProviderTest.java b/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/AbstractJAXBCollectionProviderTest.java
new file mode 100644
index 00000000..ae435e05
--- /dev/null
+++ b/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/AbstractJAXBCollectionProviderTest.java
@@ -0,0 +1,261 @@
+/*******************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *  
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *  
+ *******************************************************************************/
+package org.apache.wink.common.internal.providers.jaxb;
+
+import java.io.ByteArrayInputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.StringTokenizer;
+
+import javax.ws.rs.core.GenericEntity;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.ext.ContextResolver;
+import javax.ws.rs.ext.MessageBodyReader;
+import javax.ws.rs.ext.MessageBodyWriter;
+import javax.ws.rs.ext.Providers;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.wink.common.RuntimeContext;
+import org.apache.wink.common.internal.WinkConfiguration;
+import org.apache.wink.common.internal.contexts.MediaTypeCharsetAdjuster;
+import org.apache.wink.common.internal.providers.entity.xml.JAXBCollectionXmlProvider;
+import org.apache.wink.common.internal.providers.jaxb.jaxb1.AddNumbers;
+import org.apache.wink.common.internal.providers.jaxb.jaxb1.MyPojo;
+import org.apache.wink.common.internal.runtime.RuntimeContextTLS;
+import org.apache.wink.common.model.JAXBUnmarshalOptions;
+import org.apache.wink.common.model.XmlFormattingOptions;
+import org.jmock.Expectations;
+import org.jmock.integration.junit3.MockObjectTestCase;
+import org.junit.After;
+import org.junit.Before;
+import org.w3c.dom.Document;
+
+
+public class AbstractJAXBCollectionProviderTest extends MockObjectTestCase {
+    
+    public class MyJAXBXmlProvider extends JAXBCollectionXmlProvider {
+
+        MyJAXBXmlProvider() {
+            super();
+            providers = AbstractJAXBCollectionProviderTest.this.providers;
+        }
+        
+        /* 
+         * simulate what would happen if application had supplied a JAXBContext provider
+         */
+        @Override
+        protected JAXBContext getContext(Class<?> type, MediaType mediaType)
+                throws JAXBException {
+            // use JAXBContext.newInstance(String).  The default in AbstractJAXBProvider is JAXBContext.newInstance(Class)
+            return JAXBContext.newInstance(type.getPackage().getName());
+        }
+        
+    }
+
+    static String path = null;
+    static {
+        String classpath = System.getProperty("java.class.path");
+        StringTokenizer tokenizer = new StringTokenizer(classpath, System.getProperty("path.separator"));
+        while (tokenizer.hasMoreTokens()) {
+            path = tokenizer.nextToken();
+            if (path.endsWith("test-classes")) {
+                break;
+            }
+        }
+        // for windows:
+        int driveIndex = path.indexOf(":");
+        if(driveIndex != -1) {
+            path = path.substring(driveIndex + 1);
+        }
+    }
+    
+    static final String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>" +
+        "<addNumberss>" +
+        "<ns2:addNumbers xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:arg0>1</ns2:arg0>" +
+        "<ns2:arg1>2</ns2:arg1>" +
+        "</ns2:addNumbers>" +
+        "<ns2:addNumbers xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:arg0>1</ns2:arg0>" +
+        "<ns2:arg1>3</ns2:arg1>" +
+        "</ns2:addNumbers>" +
+        "</addNumberss>";
+
+    static final String xmlMyPojo = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>" +
+        "<myPojos>" +
+        "<ns2:myPojo xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:stringdata>1</ns2:stringdata>" +
+        "</ns2:myPojo>" +
+        "<ns2:myPojo xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:stringdata>2</ns2:stringdata>" +
+        "</ns2:myPojo>" +
+        "</myPojos>";
+    
+    static final String xmlWithDTD = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>" +
+        "<!DOCTYPE data [<!ENTITY file SYSTEM \"file:"+ path +"/etc/ProvidersJAXBTest.txt\">]>" +
+        "<addNumberss>" +
+        "<ns2:addNumbers xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:arg0>&file;</ns2:arg0>" +
+        "<ns2:arg1>2</ns2:arg1>" +
+        "</ns2:addNumbers>" +
+        "<ns2:addNumbers xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:arg0>&file;</ns2:arg0>" +
+        "<ns2:arg1>3</ns2:arg1>" +
+        "</ns2:addNumbers>" +
+        "</addNumberss>";
+    
+    static final String xmlMyPojoWithDTD = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>" +
+        "<!DOCTYPE data [<!ENTITY file SYSTEM \"file:"+ path +"/etc/ProvidersJAXBTest.txt\">]>" +
+        "<myPojos>" +
+        "<ns2:myPojo xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:stringdata>&file;</ns2:stringdata>" +
+        "</ns2:myPojo>" +
+        "<ns2:myPojo xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:stringdata>&file;</ns2:stringdata>" +
+        "</ns2:myPojo>" +
+        "</myPojos>";
+
+    private MessageBodyReader jaxbProviderReader = null;
+    private MessageBodyWriter jaxbProviderWriter = null;
+    private Providers providers;
+    
+    public class MyJAXBContextResolver implements ContextResolver<JAXBContext> {
+
+        public JAXBContext getContext(Class<?> arg0) {
+            try {
+                return JAXBContext.newInstance(arg0);
+            } catch (JAXBException e) {
+                e.printStackTrace();
+                throw new RuntimeException(e);
+            }
+        }
+    }
+    
+    @Before
+    public void setUp() {
+        providers = mock(Providers.class);
+        final RuntimeContext runtimeContext = mock(RuntimeContext.class);
+        final WinkConfiguration winkConfiguration = mock(WinkConfiguration.class);
+        checking(new Expectations() {{
+            allowing(providers).getContextResolver(JAXBContext.class, MediaType.TEXT_XML_TYPE); will(returnValue(new MyJAXBContextResolver()));
+            allowing(providers).getContextResolver(XmlFormattingOptions.class, MediaType.TEXT_XML_TYPE); will(returnValue(null));
+            allowing(providers).getContextResolver(JAXBUnmarshalOptions.class, MediaType.TEXT_XML_TYPE); will(returnValue(null));
+            allowing(runtimeContext).getAttribute(MediaTypeCharsetAdjuster.class); will(returnValue(null));
+            allowing(runtimeContext).getAttribute(WinkConfiguration.class); will(returnValue(winkConfiguration));
+            allowing(winkConfiguration).getProperties(); will(returnValue(null));
+        }});
+        RuntimeContextTLS.setRuntimeContext(runtimeContext);
+        jaxbProviderReader = new MyJAXBXmlProvider();
+        jaxbProviderWriter = new MyJAXBXmlProvider();
+        
+    }
+    
+    @After
+    public void tearDown() {
+        // clean up the mess.
+        RuntimeContextTLS.setRuntimeContext(null);
+    }
+    
+    public void testXml() throws Exception {
+
+        GenericEntity<List<AddNumbers>> type1 =
+            new GenericEntity<List<AddNumbers>>(new ArrayList<AddNumbers>()) {
+            };
+            
+        assertTrue(jaxbProviderReader.isReadable(type1.getRawType(), type1.getType(), null, MediaType.TEXT_XML_TYPE));
+        ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
+        Object obj = jaxbProviderReader.readFrom(type1.getRawType(), type1.getType(), null, MediaType.TEXT_XML_TYPE, null, bais);
+        assertTrue(obj instanceof ArrayList);
+        ArrayList alist = (ArrayList)obj;
+        // make sure the objects in the returned list are the actual jaxb objects, not JAXBElement, and the unmarshal worked:
+        assertEquals(1, ((AddNumbers)alist.get(0)).getArg0());
+        assertEquals(2, ((AddNumbers)alist.get(0)).getArg1());
+        assertEquals(1, ((AddNumbers)alist.get(1)).getArg0());
+        assertEquals(3, ((AddNumbers)alist.get(1)).getArg1());
+    }
+    
+    public void testXmlWithDTD() throws Exception {
+
+        GenericEntity<List<AddNumbers>> type1 =
+            new GenericEntity<List<AddNumbers>>(new ArrayList<AddNumbers>()) {
+            };
+            
+        assertTrue(jaxbProviderReader.isReadable(type1.getRawType(), type1.getType(), null, MediaType.TEXT_XML_TYPE));
+        Exception ex = null;
+        try {
+            ByteArrayInputStream bais = new ByteArrayInputStream(xmlWithDTD.getBytes());
+            Object obj = jaxbProviderReader.readFrom(type1.getRawType(), type1.getType(), null, MediaType.TEXT_XML_TYPE, null, bais);
+            fail("should have got an exception");
+        } catch (Exception e) {
+            ex = e;
+        }
+        assertTrue("expected an XMLStreamException", ex.getCause() instanceof XMLStreamException);
+
+        // parse it just as a sanity check to make sure our xml is good.  No exceptions means good xml!
+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
+        DocumentBuilder db = dbf.newDocumentBuilder();
+        Document dom = db.parse(new ByteArrayInputStream(xmlWithDTD.getBytes()));
+
+    }
+    
+    public void testXmlMyPojo() throws Exception {
+
+        GenericEntity<List<MyPojo>> type1 =
+            new GenericEntity<List<MyPojo>>(new ArrayList<MyPojo>()) {
+            };
+            
+        assertTrue(jaxbProviderReader.isReadable(type1.getRawType(), type1.getType(), null, MediaType.TEXT_XML_TYPE));
+        ByteArrayInputStream bais = new ByteArrayInputStream(xmlMyPojo.getBytes());
+        Object obj = jaxbProviderReader.readFrom(type1.getRawType(), type1.getType(), null, MediaType.TEXT_XML_TYPE, null, bais);
+        assertTrue(obj instanceof ArrayList);
+        ArrayList alist = (ArrayList)obj;
+        // make sure the objects in the returned list are the actual jaxb objects, not JAXBElement, and the unmarshal worked:
+        assertEquals("1", ((MyPojo)alist.get(0)).getStringdata());
+        assertEquals("2", ((MyPojo)alist.get(1)).getStringdata());
+    }
+    
+    public void testXmlMyPojoWithDTD() throws Exception {
+
+        GenericEntity<List<MyPojo>> type1 =
+            new GenericEntity<List<MyPojo>>(new ArrayList<MyPojo>()) {
+            };
+            
+        assertTrue(jaxbProviderReader.isReadable(type1.getRawType(), type1.getType(), null, MediaType.TEXT_XML_TYPE));
+        Exception ex = null;
+        try {
+            ByteArrayInputStream bais = new ByteArrayInputStream(xmlMyPojoWithDTD.getBytes());
+            Object obj = jaxbProviderReader.readFrom(type1.getRawType(), type1.getType(), null, MediaType.TEXT_XML_TYPE, null, bais);
+            fail("should have got an exception");
+        } catch (Exception e) {
+            ex = e;
+        }
+        assertTrue("expected an XMLStreamException", ex.getCause() instanceof XMLStreamException);
+
+        // parse it just as a sanity check to make sure our xml is good.  No exceptions means good xml!
+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
+        DocumentBuilder db = dbf.newDocumentBuilder();
+        Document dom = db.parse(new ByteArrayInputStream(xmlMyPojoWithDTD.getBytes()));
+
+    }
+}
diff --git a/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/ProvidersJAXBTest.java b/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/ProvidersJAXBTest.java
index 0c6cb6d6..723a577b 100644
--- a/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/ProvidersJAXBTest.java
+++ b/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/ProvidersJAXBTest.java
@@ -22,6 +22,8 @@ package org.apache.wink.common.internal.providers.jaxb;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.util.Properties;
+import java.util.StringTokenizer;
 
 import javax.ws.rs.WebApplicationException;
 import javax.ws.rs.core.MediaType;
@@ -31,15 +33,25 @@ import javax.ws.rs.ext.MessageBodyReader;
 import javax.ws.rs.ext.MessageBodyWriter;
 import javax.ws.rs.ext.Providers;
 import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.transform.stream.StreamSource;
 
+import org.apache.wink.common.RuntimeContext;
 import org.apache.wink.common.internal.CaseInsensitiveMultivaluedMap;
+import org.apache.wink.common.internal.WinkConfiguration;
+import org.apache.wink.common.internal.contexts.MediaTypeCharsetAdjuster;
 import org.apache.wink.common.internal.providers.entity.xml.JAXBXmlProvider;
 import org.apache.wink.common.internal.providers.jaxb.jaxb1.AddNumbers;
+import org.apache.wink.common.internal.providers.jaxb.jaxb1.MyPojo;
+import org.apache.wink.common.internal.runtime.RuntimeContextTLS;
 import org.apache.wink.common.model.JAXBUnmarshalOptions;
 import org.apache.wink.common.model.XmlFormattingOptions;
 import org.jmock.Expectations;
 import org.jmock.integration.junit3.MockObjectTestCase;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -66,8 +78,8 @@ public class ProvidersJAXBTest extends MockObjectTestCase {
     
     static final String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>" +
         "<ns2:addNumbers xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
-        "<arg0>1</arg0>" +
-        "<arg1>2</arg1>" +
+        "<ns2:arg0>1</ns2:arg0>" +
+        "<ns2:arg1>2</ns2:arg1>" +
         "</ns2:addNumbers>";
     
     static final String expectedXml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>" + 
@@ -76,40 +88,99 @@ public class ProvidersJAXBTest extends MockObjectTestCase {
         "<arg1>0</arg1>" +
         "</addNumbers>";
 
+    static String path = null;
+    static {
+        String classpath = System.getProperty("java.class.path");
+        StringTokenizer tokenizer = new StringTokenizer(classpath, System.getProperty("path.separator"));
+        while (tokenizer.hasMoreTokens()) {
+            path = tokenizer.nextToken();
+            if (path.endsWith("test-classes")) {
+                break;
+            }
+        }
+        // for windows:
+        int driveIndex = path.indexOf(":");
+        if(driveIndex != -1) {
+            path = path.substring(driveIndex + 1);
+        }
+
+    }
+    
+    static final String xmlWithDTD = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>" +
+        "<!DOCTYPE data [<!ENTITY file SYSTEM \"file:"+ path + "/etc/ProvidersJAXBTest.txt\">]>" +
+        "<ns2:addNumbers xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:arg0>&file;</ns2:arg0>" +
+        "<ns2:arg1>2</ns2:arg1>" +
+        "</ns2:addNumbers>";
+    
+    static final String xmlMyPojoWithDTD = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>" +
+        "<!DOCTYPE data [<!ENTITY file SYSTEM \"file:"+ path +"/etc/ProvidersJAXBTest.txt\">]>" +
+        "<ns2:myPojo xmlns:ns2=\"http://org/apache/wink/common/internal/providers/jaxb/jaxb1\">" +
+        "<ns2:stringdata>&file;</ns2:stringdata>" +
+        "</ns2:myPojo>";
+
+    private WinkConfiguration winkConfiguration = null;
     private MessageBodyReader jaxbProviderReader = null;
     private MessageBodyWriter jaxbProviderWriter = null;
     private Providers providers;
     
+    public class MyJAXBContextResolver implements ContextResolver<JAXBContext> {
+
+        public JAXBContext getContext(Class<?> arg0) {
+            try {
+                return JAXBContext.newInstance(arg0);
+            } catch (JAXBException e) {
+                e.printStackTrace();
+                throw new RuntimeException(e);
+            }
+        }
+    }
+    
     @Before
     public void setUp() {
         providers = mock(Providers.class);
+        final RuntimeContext runtimeContext = mock(RuntimeContext.class);
+        winkConfiguration = mock(WinkConfiguration.class);
         checking(new Expectations() {{
             allowing(providers).getContextResolver(JAXBContext.class, MediaType.TEXT_XML_TYPE); will(returnValue(new MyJAXBContextResolver()));
             allowing(providers).getContextResolver(XmlFormattingOptions.class, MediaType.TEXT_XML_TYPE); will(returnValue(null));
             allowing(providers).getContextResolver(JAXBUnmarshalOptions.class, MediaType.TEXT_XML_TYPE); will(returnValue(null));
+            allowing(runtimeContext).getAttribute(MediaTypeCharsetAdjuster.class); will(returnValue(null));
+            allowing(runtimeContext).getAttribute(WinkConfiguration.class); will(returnValue(winkConfiguration));
         }});
+        RuntimeContextTLS.setRuntimeContext(runtimeContext);
         jaxbProviderReader = new MyJAXBXmlProvider();
         jaxbProviderWriter = new MyJAXBXmlProvider();
+        
+    }
+    
+    @After
+    public void tearDown() {
+        // clean up the mess.  :)
+        RuntimeContextTLS.setRuntimeContext(null);
     }
     
     @Test
     public void testJAXBUnmarshallingWithAlternateContext1() throws Exception {
+        
+        final Properties props = new Properties();
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        // let's make sure our test string is unmarshallable, just for a good sanity check
+        JAXBContext testcontext = JAXBContext.newInstance(AddNumbers.class);
+        Unmarshaller testunmarshaller = testcontext.createUnmarshaller();
+        AddNumbers testresponse =
+            (AddNumbers)testunmarshaller.unmarshal(new ByteArrayInputStream(xml.getBytes()));
+        assertEquals("we could not unmarshal the test xml", 1, testresponse.getArg0());
+        
         assertTrue(jaxbProviderReader.isReadable(AddNumbers.class, null, null, MediaType.TEXT_XML_TYPE));
         ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
         Object obj = jaxbProviderReader.readFrom(AddNumbers.class, null, null, MediaType.TEXT_XML_TYPE, null, bais);
         assertTrue(obj instanceof AddNumbers);
-    }
-    
-    public class MyJAXBContextResolver implements ContextResolver<JAXBContext> {
-
-        public JAXBContext getContext(Class<?> arg0) {
-            try {
-                return JAXBContext.newInstance(arg0);
-            } catch (JAXBException e) {
-                e.printStackTrace();
-                throw new RuntimeException(e);
-            }
-        }
+        assertEquals(1, ((AddNumbers)obj).getArg0());
+        assertEquals(2, ((AddNumbers)obj).getArg1());
     }
     
     @SuppressWarnings("unchecked")
@@ -131,5 +202,87 @@ public class ProvidersJAXBTest extends MockObjectTestCase {
         assertEquals(expectedXml, baos.toString());
     }
     
+    @Test
+    public void testJAXBUnmarshallingWithDTD() throws Exception {
+        
+        final Properties props = new Properties();
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        Exception ex = null;
+        assertTrue(jaxbProviderReader.isReadable(AddNumbers.class, null, null, MediaType.TEXT_XML_TYPE));
+        try {
+            ByteArrayInputStream bais = new ByteArrayInputStream(xmlWithDTD.getBytes());
+            Object obj = jaxbProviderReader.readFrom(AddNumbers.class, null, null, MediaType.TEXT_XML_TYPE, null, bais);
+            fail("should have got an exception");
+        } catch (Exception e) {
+            ex = e;
+        }
+        assertTrue("expected an XMLStreamException", ex.getCause() instanceof XMLStreamException);
+        
+        // let's make sure our test string is unmarshallable, just for a good sanity check
+        JAXBContext testcontext = JAXBContext.newInstance(AddNumbers.class);
+        Unmarshaller testunmarshaller = testcontext.createUnmarshaller();
+        AddNumbers testresponse =
+            (AddNumbers)testunmarshaller.unmarshal(new ByteArrayInputStream(xmlWithDTD.getBytes()));
+        assertEquals("we could not unmarshal the test xml", 99999999, testresponse.getArg0());
+    }
     
+    @Test
+    /**
+     * testing that supporting DTD expansion is configurable
+     */
+    public void testJAXBUnmarshallingWithDTDServerConfigurable() throws Exception {
+        
+        // pretend we're on the server:
+        final Properties props = new Properties();
+        props.put("wink.supportDTDEntityExpansion", "true");
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        assertTrue(jaxbProviderReader.isReadable(AddNumbers.class, null, null, MediaType.TEXT_XML_TYPE));
+        ByteArrayInputStream bais = new ByteArrayInputStream(xmlWithDTD.getBytes());
+        Object obj = jaxbProviderReader.readFrom(AddNumbers.class, null, null, MediaType.TEXT_XML_TYPE, null, bais);
+        assertTrue(obj instanceof AddNumbers);
+        assertEquals(99999999, ((AddNumbers)obj).getArg0());
+        assertEquals(2, ((AddNumbers)obj).getArg1());
+        
+        // let's make sure our test string is unmarshallable, just for a good sanity check
+        JAXBContext testcontext = JAXBContext.newInstance(AddNumbers.class);
+        Unmarshaller testunmarshaller = testcontext.createUnmarshaller();
+        AddNumbers testresponse =
+            (AddNumbers)testunmarshaller.unmarshal(new ByteArrayInputStream(xmlWithDTD.getBytes()));
+        assertEquals("we could not unmarshal the test xml", 99999999, testresponse.getArg0());
+    }
+    
+    @Test
+    public void testJAXBUnmarshallingMyPojoWithDTD() throws Exception {
+
+        final Properties props = new Properties();
+        checking(new Expectations() {{
+            allowing(winkConfiguration).getProperties(); will(returnValue(props));
+        }});
+        
+        Exception ex = null;
+        try {
+            assertTrue(jaxbProviderReader.isReadable(MyPojo.class, null, null, MediaType.TEXT_XML_TYPE));
+            ByteArrayInputStream bais = new ByteArrayInputStream(xmlMyPojoWithDTD.getBytes());
+            Object obj = jaxbProviderReader.readFrom(MyPojo.class, null, null, MediaType.TEXT_XML_TYPE, null, bais);
+            fail("should have got an exception");
+        } catch (Exception e) {
+            ex = e;
+        }
+        assertTrue("expected an XMLStreamException", ex.getCause() instanceof XMLStreamException);
+        
+        // let's make sure our test string is unmarshallable, just for a good sanity check
+        JAXBContext testcontext = JAXBContext.newInstance(MyPojo.class);
+        Unmarshaller testunmarshaller = testcontext.createUnmarshaller();
+        JAXBElement<MyPojo> testresponse =
+            (JAXBElement<MyPojo>)testunmarshaller.unmarshal(new StreamSource(new ByteArrayInputStream(xmlMyPojoWithDTD.getBytes())), MyPojo.class);
+        MyPojo myPojo = testresponse.getValue();
+        assertEquals("we could not unmarshal the test xml", "99999999", myPojo.getStringdata().trim());
+    }
+
 }
diff --git a/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/jaxb1/MyPojo.java b/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/jaxb1/MyPojo.java
new file mode 100644
index 00000000..1d28f65a
--- /dev/null
+++ b/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/jaxb1/MyPojo.java
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *  
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *  
+ *******************************************************************************/
+
+package org.apache.wink.common.internal.providers.jaxb.jaxb1;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+// do NOT annotate with @XmlRootElement
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="MyPojo", propOrder = {"stringdata"})
+public class MyPojo {
+    @XmlElement(required = true)
+    private String stringdata = null;
+    public MyPojo() {}
+    public void setStringdata(String stringdata) {
+        this.stringdata = stringdata;
+    }
+    public String getStringdata() {
+        return stringdata;
+    }
+
+}
diff --git a/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/jaxb1/ObjectFactory.java b/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/jaxb1/ObjectFactory.java
index 3b38e842..f1f1427a 100644
--- a/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/jaxb1/ObjectFactory.java
+++ b/wink-common/src/test/java/org/apache/wink/common/internal/providers/jaxb/jaxb1/ObjectFactory.java
@@ -52,6 +52,7 @@ import javax.xml.namespace.QName;
 public class ObjectFactory {
 
     private final static QName _AddNumbers_QNAME = new QName("http://org/apache/wink/common/internal/providers/jaxb/jaxb1", "addNumbers");
+    private final static QName _MyPojo_QNAME = new QName("http://org/apache/wink/common/internal/providers/jaxb/jaxb1", "myPojo");
 
     /**
      * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: org.apache.wink.common.internal.providers.jaxb.jaxb1
@@ -76,6 +77,23 @@ public class ObjectFactory {
     public JAXBElement<AddNumbers> createAddNumbers(AddNumbers value) {
         return new JAXBElement<AddNumbers>(_AddNumbers_QNAME, AddNumbers.class, null, value);
     }
+    
+    /**
+     * Create an instance of {@link MyPojo }
+     * 
+     */
+    public MyPojo createMyPojo() {
+        return new MyPojo();
+    }
+    
+    /**
+     * Create an instance of {@link JAXBElement }{@code <}{@link MyPojo }{@code >}}
+     * 
+     */
+    @XmlElementDecl(namespace = "http://org/apache/wink/common/internal/providers/jaxb/jaxb1", name = "MyPojo")
+    public JAXBElement<MyPojo> createMyPojo(MyPojo value) {
+        return new JAXBElement<MyPojo>(_MyPojo_QNAME, MyPojo.class, null, value);
+    }
 
 
 }
diff --git a/wink-common/src/test/java/org/apache/wink/common/model/atom/AtomTest.java b/wink-common/src/test/java/org/apache/wink/common/model/atom/AtomTest.java
index 96dfea15..a271b852 100644
--- a/wink-common/src/test/java/org/apache/wink/common/model/atom/AtomTest.java
+++ b/wink-common/src/test/java/org/apache/wink/common/model/atom/AtomTest.java
@@ -62,6 +62,7 @@ import org.apache.wink.common.internal.runtime.RuntimeContextTLS;
 import org.apache.wink.common.internal.utils.JAXBUtils;
 import org.apache.wink.common.model.opensearch.OpenSearchQuery;
 import org.apache.wink.test.mock.TestUtils;
+import org.junit.After;
 
 public class AtomTest extends TestCase {
 
@@ -320,6 +321,11 @@ public class AtomTest extends TestCase {
                                                                        runtimeContext));
         RuntimeContextTLS.setRuntimeContext(runtimeContext);
     }
+    
+    @After
+    public void tearDown() {
+        RuntimeContextTLS.setRuntimeContext(null);
+    }
 
     public void testAtomTextMarshal() throws Exception {
 
diff --git a/wink-common/src/test/resources/etc/ProvidersJAXBTest.txt b/wink-common/src/test/resources/etc/ProvidersJAXBTest.txt
new file mode 100644
index 00000000..7c6681d7
--- /dev/null
+++ b/wink-common/src/test/resources/etc/ProvidersJAXBTest.txt
@@ -0,0 +1 @@
+99999999
diff --git a/wink-common/src/test/resources/etc/SourceProviderTest.txt b/wink-common/src/test/resources/etc/SourceProviderTest.txt
new file mode 100644
index 00000000..7c6681d7
--- /dev/null
+++ b/wink-common/src/test/resources/etc/SourceProviderTest.txt
@@ -0,0 +1 @@
+99999999
