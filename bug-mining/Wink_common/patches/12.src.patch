diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/AssetProvider.java b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/AssetProvider.java
index 6e316551..91554b41 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/AssetProvider.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/providers/entity/AssetProvider.java
@@ -147,7 +147,7 @@ public class AssetProvider implements MessageBodyReader<Object>, MessageBodyWrit
     }
 
     private RuntimeContext getRuntimeContext() {
-        return (RuntimeContext)RuntimeContextTLS.getRuntimeContext();
+        return RuntimeContextTLS.getRuntimeContext();
     }
 
     @SuppressWarnings("unchecked")
@@ -294,7 +294,7 @@ public class AssetProvider implements MessageBodyReader<Object>, MessageBodyWrit
             Annotation[][] parameterAnnotations = method.getParameterAnnotations();
             Type[] paramTypes = method.getGenericParameterTypes();
             for (int pos = 0, limit = paramTypes.length; pos < limit; pos++) {
-                Injectable fp = InjectableFactory.getInstance().create(paramTypes[pos], parameterAnnotations[pos], method);
+                Injectable fp = InjectableFactory.getInstance().create(paramTypes[pos], parameterAnnotations[pos], method, false);
                 formalParameters.add(fp);
             }
         }
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/registry/InjectableFactory.java b/wink-common/src/main/java/org/apache/wink/common/internal/registry/InjectableFactory.java
index 3ab1dcb1..55344c51 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/registry/InjectableFactory.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/registry/InjectableFactory.java
@@ -17,7 +17,6 @@
  *  under the License.
  *  
  *******************************************************************************/
- 
 
 package org.apache.wink.common.internal.registry;
 
@@ -40,28 +39,28 @@ import javax.ws.rs.core.Context;
 import org.apache.wink.common.internal.runtime.RuntimeContext;
 import org.apache.wink.common.internal.utils.GenericsUtils;
 
-
 public class InjectableFactory {
-    
+
     private static InjectableFactory instance = new InjectableFactory();
-    
+
     public static InjectableFactory getInstance() {
         return instance;
     }
-    
+
     public static void setInstance(InjectableFactory instance) {
         InjectableFactory.instance = instance;
     }
-    
+
     /**
      * Instantiates a list of formal parameters into an Object array
      * 
      * @param runtimeContext
      * @param formalParameters
      * @return
-     * @throws IOException 
+     * @throws IOException
      */
-    public Object[] instantiate(List<Injectable> formalParameters, RuntimeContext runtimeContext) throws IOException {
+    public Object[] instantiate(List<Injectable> formalParameters, RuntimeContext runtimeContext)
+        throws IOException {
         Object[] result = new Object[formalParameters.size()];
         for (int pos = 0; pos < result.length; pos++) {
             Injectable fp = formalParameters.get(pos);
@@ -70,7 +69,8 @@ public class InjectableFactory {
         return result;
     }
 
-    public Injectable create(Type genericType, Annotation[] annotations, Member member) {
+    public Injectable create(Type genericType, Annotation[] annotations, Member member,
+        boolean enclosingEncoded) {
         Class<?> classType = GenericsUtils.getClassType(genericType);
 
         MatrixParam matrix = null;
@@ -87,50 +87,52 @@ public class InjectableFactory {
         int annotationsCounter = 0;
         for (int i = 0; i < annotations.length; ++i) {
             if (annotations[i].annotationType().equals(MatrixParam.class)) {
-                matrix = (MatrixParam)annotations[i];
+                matrix = (MatrixParam) annotations[i];
                 ++annotationsCounter;
             } else if (annotations[i].annotationType().equals(PathParam.class)) {
-                path = (PathParam)annotations[i];
+                path = (PathParam) annotations[i];
                 ++annotationsCounter;
             } else if (annotations[i].annotationType().equals(QueryParam.class)) {
-                query = (QueryParam)annotations[i];
+                query = (QueryParam) annotations[i];
                 ++annotationsCounter;
             } else if (annotations[i].annotationType().equals(HeaderParam.class)) {
-                header = (HeaderParam)annotations[i];
+                header = (HeaderParam) annotations[i];
                 ++annotationsCounter;
             } else if (annotations[i].annotationType().equals(CookieParam.class)) {
-                cookie = (CookieParam)annotations[i];
+                cookie = (CookieParam) annotations[i];
                 ++annotationsCounter;
             } else if (annotations[i].annotationType().equals(FormParam.class)) {
-                form = (FormParam)annotations[i];
+                form = (FormParam) annotations[i];
                 ++annotationsCounter;
             } else if (annotations[i].annotationType().equals(Context.class)) {
-                context = (Context)annotations[i];
+                context = (Context) annotations[i];
                 ++annotationsCounter;
             } else if (annotations[i].annotationType().equals(Encoded.class)) {
-                encodedAnn = (Encoded)annotations[i];
+                encodedAnn = (Encoded) annotations[i];
             } else if (annotations[i].annotationType().equals(DefaultValue.class)) {
-                defaultValueAnn = (DefaultValue)annotations[i];
+                defaultValueAnn = (DefaultValue) annotations[i];
             }
         }
 
         if (annotationsCounter > 1) {
-            throw new IllegalStateException("Conflicting parameter annotations for " + member.getName());
+            throw new IllegalStateException("Conflicting parameter annotations for "
+                + member.getName());
         }
 
         if (matrix != null) {
-            injectable = createMatrixParam(matrix.value(), classType, genericType, annotations, member);
+            injectable = createMatrixParam(matrix.value(), classType, genericType, annotations,
+                member);
         } else if (path != null) {
             injectable = createPathParam(path.value(), classType, genericType, annotations, member);
         } else if (query != null) {
             injectable = createQueryParam(query.value(), classType, genericType, annotations,
-                    member);
+                member);
         } else if (header != null) {
             injectable = createHeaderParam(header.value(), classType, genericType, annotations,
-                    member);
+                member);
         } else if (cookie != null) {
             injectable = createCookieParam(cookie.value(), classType, genericType, annotations,
-                    member);
+                member);
         } else if (form != null) {
             injectable = createFormParam(form.value(), classType, genericType, annotations, member);
         } else if (context != null) {
@@ -140,8 +142,8 @@ public class InjectableFactory {
         }
 
         if (injectable instanceof BoundInjectable) {
-            BoundInjectable binding = (BoundInjectable)injectable;
-            if (encodedAnn != null) {
+            BoundInjectable binding = (BoundInjectable) injectable;
+            if (enclosingEncoded || encodedAnn != null) {
                 binding.setEncoded(true);
             }
             if (defaultValueAnn != null) {
@@ -151,7 +153,7 @@ public class InjectableFactory {
 
         return injectable;
     }
-    
+
     private static class NullInjectable extends Injectable {
 
         protected NullInjectable(ParamType paramType) {
@@ -163,13 +165,12 @@ public class InjectableFactory {
             return null;
         }
     }
-    
 
-    
     /**
-     * Used for injecting a field or parameter of JAX-RS resource with a context, as defined by the
-     * JAX-RS spec. First searches for a ContextResolver to get the context to inject, and if non is
-     * found, then tries one of the built-in types of context
+     * Used for injecting a field or parameter of JAX-RS resource with a
+     * context, as defined by the JAX-RS spec. First searches for a
+     * ContextResolver to get the context to inject, and if non is found, then
+     * tries one of the built-in types of context
      */
     public static class ContextParam extends Injectable {
 
@@ -185,44 +186,43 @@ public class InjectableFactory {
             return contextAccessor.getContext(getType(), runtimeContext);
         }
     }
- 
-    public Injectable createContextParam(Class<?> classType, Annotation[] annotations,
-            Member member) {
+
+    public Injectable createContextParam(Class<?> classType, Annotation[] annotations, Member member) {
         return new ContextParam(classType, annotations, member);
     }
 
-    public Injectable createMatrixParam(String value, Class<?> classType, Type genericType, Annotation[] annotations,
-            Member member) {
+    public Injectable createMatrixParam(String value, Class<?> classType, Type genericType,
+        Annotation[] annotations, Member member) {
         return new NullInjectable(Injectable.ParamType.MATRIX);
     }
 
-    public Injectable createPathParam(String value, Class<?> classType, Type genericType, Annotation[] annotations,
-            Member member) {
+    public Injectable createPathParam(String value, Class<?> classType, Type genericType,
+        Annotation[] annotations, Member member) {
         return new NullInjectable(Injectable.ParamType.PATH);
     }
-    
-    public Injectable createQueryParam(String value, Class<?> classType, Type genericType, Annotation[] annotations,
-            Member member) {
+
+    public Injectable createQueryParam(String value, Class<?> classType, Type genericType,
+        Annotation[] annotations, Member member) {
         return new NullInjectable(Injectable.ParamType.QUERY);
     }
-    
-    public Injectable createHeaderParam(String value, Class<?> classType, Type genericType, Annotation[] annotations,
-            Member member) {
+
+    public Injectable createHeaderParam(String value, Class<?> classType, Type genericType,
+        Annotation[] annotations, Member member) {
         return new NullInjectable(Injectable.ParamType.HEADER);
     }
 
-    public Injectable createCookieParam(String value, Class<?> classType, Type genericType, Annotation[] annotations,
-            Member member) {
+    public Injectable createCookieParam(String value, Class<?> classType, Type genericType,
+        Annotation[] annotations, Member member) {
         return new NullInjectable(Injectable.ParamType.COOKIE);
     }
 
-    public Injectable createFormParam(String value, Class<?> classType, Type genericType, Annotation[] annotations,
-            Member member) {
+    public Injectable createFormParam(String value, Class<?> classType, Type genericType,
+        Annotation[] annotations, Member member) {
         return new NullInjectable(Injectable.ParamType.FORM);
     }
-    
-    public Injectable createEntityParam(Class<?> classType, Type genericType, Annotation[] annotations,
-            Member member) {
+
+    public Injectable createEntityParam(Class<?> classType, Type genericType,
+        Annotation[] annotations, Member member) {
         return new NullInjectable(Injectable.ParamType.ENTITY);
     }
 
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/AbstractMetadata.java b/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/AbstractMetadata.java
index d334c10e..b0d0b70d 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/AbstractMetadata.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/AbstractMetadata.java
@@ -34,6 +34,7 @@ public abstract class AbstractMetadata {
     private List<String>   paths;
     private Set<MediaType> consumes;
     private Set<MediaType> produces;
+    private boolean        encoded = false;
 
     public AbstractMetadata() {
         paths = new ArrayList<String>();
@@ -82,4 +83,12 @@ public abstract class AbstractMetadata {
             + (paths != null ? "paths=" + paths + ", " : "")
             + (produces != null ? "produces=" + produces : "") + "]";
     }
+
+    public void setEncoded(boolean encoded) {
+        this.encoded = encoded;
+    }
+
+    public boolean isEncoded() {
+        return encoded;
+    }
 }
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/AbstractMetadataCollector.java b/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/AbstractMetadataCollector.java
index 5a476e18..e334c185 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/AbstractMetadataCollector.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/AbstractMetadataCollector.java
@@ -30,15 +30,16 @@ import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.List;
 
+import javax.ws.rs.Encoded;
+
 import org.apache.wink.common.internal.registry.Injectable;
 import org.apache.wink.common.internal.registry.InjectableFactory;
 
-
 /**
  * Collects common class meta data of JAX-RS Resources and Providers
  */
 public abstract class AbstractMetadataCollector {
-    
+
     private final ClassMetadata metadata;
 
     public AbstractMetadataCollector(Class<?> clazz) {
@@ -55,6 +56,8 @@ public abstract class AbstractMetadataCollector {
     protected final void parseFields() {
         Class<?> resourceClass = metadata.getResourceClass();
 
+        List<Injectable> injectableFields = metadata.getInjectableFields();
+
         // add fields
         while (resourceClass != Object.class) {
             for (Field field : resourceClass.getDeclaredFields()) {
@@ -62,7 +65,7 @@ public abstract class AbstractMetadataCollector {
                 Injectable injectable = parseAccessibleObject(field, fieldType);
 
                 if (injectable != null) {
-                    metadata.getInjectableFields().add(injectable);
+                    injectableFields.add(injectable);
                 }
             }
             resourceClass = resourceClass.getSuperclass();
@@ -80,7 +83,7 @@ public abstract class AbstractMetadataCollector {
                 Type genericReturnType = writeMethod.getParameterTypes()[0];
                 Injectable injectable = parseAccessibleObject(writeMethod, genericReturnType);
                 if (injectable != null) {
-                    metadata.getInjectableFields().add(injectable);
+                    injectableFields.add(injectable);
                 }
             }
         }
@@ -102,13 +105,15 @@ public abstract class AbstractMetadataCollector {
         ConstructorMetadata constructorMetadata = new ConstructorMetadata();
         List<Injectable> formalParameters = new ArrayList<Injectable>();
         Class<?> resourceClass = metadata.getResourceClass();
-        
+
         L1: for (Constructor<?> constructor : resourceClass.getDeclaredConstructors()) {
             int modifiers = constructor.getModifiers();
             if (!Modifier.isPublic(modifiers)) {
                 continue;
             }
-            
+
+            constructorMetadata.setEncoded(constructor.getAnnotation(Encoded.class) != null);
+
             // gather all formal parameters
             formalParameters.clear();
 
@@ -121,8 +126,9 @@ public abstract class AbstractMetadataCollector {
             //            boolean isValidConstructor = true;
             // gather all formal parameters as list of injectable data
             for (int pos = 0, limit = paramTypes.length; pos < limit; pos++) {
-                Injectable fp = InjectableFactory.getInstance().create(paramTypes[pos], parameterAnnotations[pos],
-                    constructor);
+                Injectable fp = InjectableFactory.getInstance().create(paramTypes[pos],
+                    parameterAnnotations[pos], constructor,
+                    getMetadata().isEncoded() || constructorMetadata.isEncoded());
 
                 if (!isConstructorParameterValid(fp)) {
                     continue L1;
@@ -148,10 +154,17 @@ public abstract class AbstractMetadataCollector {
         // error if we haven't found a valid constructor 
         if (constructorMetadata.getConstructor() == null) {
             throw new IllegalStateException("No valid constrcutor found for resource "
-                + getMetadata().getResourceClass().getCanonicalName());
+                + metadata.getResourceClass().getCanonicalName());
+        }
+
+        metadata.setConstructor(constructorMetadata);
+    }
+
+    protected void parseEncoded(Class<?> cls) {
+        Encoded encoded = cls.getAnnotation(Encoded.class);
+        if (encoded != null) {
+            metadata.setEncoded(true);
         }
-        
-        getMetadata().setConstructor(constructorMetadata);
     }
 
     public ClassMetadata getMetadata() {
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/ConstructorMetadata.java b/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/ConstructorMetadata.java
index 92f31800..f0b827cb 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/ConstructorMetadata.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/ConstructorMetadata.java
@@ -17,7 +17,6 @@
  *  under the License.
  *  
  *******************************************************************************/
- 
 
 package org.apache.wink.common.internal.registry.metadata;
 
@@ -27,11 +26,11 @@ import java.util.List;
 
 import org.apache.wink.common.internal.registry.Injectable;
 
-
 public class ConstructorMetadata {
 
-    private Constructor<?>             constructor;
+    private Constructor<?>         constructor;
     private final List<Injectable> formalParameters;
+    private boolean                encoded = false;
 
     public ConstructorMetadata() {
         constructor = null;
@@ -50,4 +49,12 @@ public class ConstructorMetadata {
         return formalParameters;
     }
 
+    public void setEncoded(boolean encoded) {
+        this.encoded = encoded;
+    }
+
+    public boolean isEncoded() {
+        return encoded;
+    }
+
 }
diff --git a/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/ResourceMetadataCollector.java b/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/ResourceMetadataCollector.java
index 4829132d..00f66abb 100644
--- a/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/ResourceMetadataCollector.java
+++ b/wink-common/src/main/java/org/apache/wink/common/internal/registry/metadata/ResourceMetadataCollector.java
@@ -17,7 +17,6 @@
  *  under the License.
  *  
  *******************************************************************************/
- 
 
 package org.apache.wink.common.internal.registry.metadata;
 
@@ -31,6 +30,7 @@ import java.lang.reflect.Type;
 import java.util.Set;
 
 import javax.ws.rs.Consumes;
+import javax.ws.rs.Encoded;
 import javax.ws.rs.HttpMethod;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
@@ -44,12 +44,11 @@ import org.apache.wink.common.annotations.Workspace;
 import org.apache.wink.common.internal.registry.Injectable;
 import org.apache.wink.common.internal.registry.InjectableFactory;
 
-
 /**
  * Collects ClassMetadata from JAX-RS Resource classes
  */
 public class ResourceMetadataCollector extends AbstractMetadataCollector {
-    
+
     private static final Logger logger = LoggerFactory.getLogger(ResourceMetadataCollector.class);
 
     private ResourceMetadataCollector(Class<?> clazz) {
@@ -79,7 +78,8 @@ public class ResourceMetadataCollector extends AbstractMetadataCollector {
 
     @Override
     protected final Injectable parseAccessibleObject(AccessibleObject field, Type fieldType) {
-        Injectable injectable = InjectableFactory.getInstance().create(fieldType, field.getAnnotations(), (Member) field);
+        Injectable injectable = InjectableFactory.getInstance().create(fieldType,
+            field.getAnnotations(), (Member) field, getMetadata().isEncoded());
         if (injectable.getParamType() == Injectable.ParamType.ENTITY) {
             // EntityParam should be ignored for fields (see JSR-311 3.2)
             return null;
@@ -104,28 +104,13 @@ public class ResourceMetadataCollector extends AbstractMetadataCollector {
             getMetadata().getParents().add(parent.value());
         }
 
+        parseEncoded(cls);
+
         // if the class contained any annotations, we can to stop
         if (workspacePresent || pathPresent || consumesPresent || producesPresent) {
             return true;
         }
 
-        //        // Do we want to allow searching for class annotations in superclass??? 
-        //       
-        //        // parse superclass
-        //        Class<?> superclass = cls.getSuperclass();
-        //        if (superclass != null) {
-        //            return parseClass(superclass);
-        //        }
-        //         
-        //        // parse all interfaces
-        //        Class<?>[] interfaces = cls.getInterfaces();
-        //        for (Class<?> interfaceClass : interfaces) {
-        //            // stop with the first interface that has annotations
-        //            if (parseClass(interfaceClass)) {
-        //                return true;
-        //            }
-        //        }
-
         // no annotations
         return false;
     }
@@ -167,16 +152,22 @@ public class ResourceMetadataCollector extends AbstractMetadataCollector {
                     } else {
                         // sub-resource locator
                         // verify that the method does not take an entity parameter
-                        String methodName = String.format("%s.%s", declaringClass.getName(), method.getName());
+                        String methodName = String.format("%s.%s", declaringClass.getName(),
+                            method.getName());
                         for (Injectable id : methodMetadata.getFormalParameters()) {
                             if (id.getParamType() == Injectable.ParamType.ENTITY) {
-                                logger.warn("Sub-Resource locator {} contains an illegal entity parameter. The locator will be ignored.", methodName);
+                                logger.warn(
+                                    "Sub-Resource locator {} contains an illegal entity parameter. The locator will be ignored.",
+                                    methodName);
                                 continue F1;
                             }
                         }
                         // log a warning if the locator has a Produces or Consumes annotation
-                        if (!methodMetadata.getConsumes().isEmpty() || !methodMetadata.getProduces().isEmpty()) {
-                            logger.warn("Sub-Resource locator {} is annotated with Consumes/Produces. These annotations are ignored for sub-resource locators", methodName);
+                        if (!methodMetadata.getConsumes().isEmpty()
+                            || !methodMetadata.getProduces().isEmpty()) {
+                            logger.warn(
+                                "Sub-Resource locator {} is annotated with Consumes/Produces. These annotations are ignored for sub-resource locators",
+                                methodName);
                         }
                         getMetadata().getSubResourceLocators().add(methodMetadata);
                     }
@@ -223,6 +214,11 @@ public class ResourceMetadataCollector extends AbstractMetadataCollector {
             metadata.addProduces(MediaType.valueOf(mediaType));
         }
 
+        if (method.getAnnotation(Encoded.class) != null) {
+            metadata.setEncoded(true);
+            hasAnnotation = true;
+        }
+
         // if the method has not annotation at all,
         // then it may override a method in a superclass or interface that has annotations, 
         // so try looking at the overridden method annotations
@@ -333,22 +329,25 @@ public class ResourceMetadataCollector extends AbstractMetadataCollector {
         return null;
     }
 
-    private void parseMethodParameters(Method method, MethodMetadata metadata) {
+    private void parseMethodParameters(Method method, MethodMetadata methodMetadata) {
         Annotation[][] parameterAnnotations = method.getParameterAnnotations();
         Type[] paramTypes = method.getGenericParameterTypes();
         boolean entityParamExists = false;
         for (int pos = 0, limit = paramTypes.length; pos < limit; pos++) {
-            Injectable fp = InjectableFactory.getInstance().create(paramTypes[pos], parameterAnnotations[pos],
-                method);
+            Injectable fp = InjectableFactory.getInstance().create(paramTypes[pos],
+                parameterAnnotations[pos], method,
+                getMetadata().isEncoded() || methodMetadata.isEncoded());
             if (fp.getParamType() == Injectable.ParamType.ENTITY) {
                 if (entityParamExists) {
                     // we are allowed to have only one entity parameter
-                    String methodName = method.getDeclaringClass().getName() + "."+ method.getName();
-                    throw new IllegalStateException("Resource method " + methodName + " has more than one entity parameter");
+                    String methodName = method.getDeclaringClass().getName() + "."
+                        + method.getName();
+                    throw new IllegalStateException("Resource method " + methodName
+                        + " has more than one entity parameter");
                 }
                 entityParamExists = true;
             }
-            metadata.getFormalParameters().add(fp);
+            methodMetadata.getFormalParameters().add(fp);
         }
     }
 
