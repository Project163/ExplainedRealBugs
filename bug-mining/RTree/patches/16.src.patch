diff --git a/pom.xml b/pom.xml
index 0030032..9e41669 100644
--- a/pom.xml
+++ b/pom.xml
@@ -93,12 +93,6 @@
             <artifactId>rxjava</artifactId>
             <version>1.1.1</version>
         </dependency>
-        <!--  required for RTree.nearest only -->
-        <dependency>
-            <groupId>com.google.guava</groupId>
-            <artifactId>guava</artifactId>
-            <version>18.0</version>
-        </dependency>
         <dependency>
             <groupId>com.vividsolutions</groupId>
             <artifactId>jts-core</artifactId>
diff --git a/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java b/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java
index 47fab81..0e0dea3 100644
--- a/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java
+++ b/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java
@@ -2,7 +2,7 @@ package com.github.davidmoten.rx.operators;
 
 import java.util.Comparator;
 
-import com.google.common.collect.MinMaxPriorityQueue;
+import com.github.davidmoten.util.BoundedPriorityQueue;
 
 import rx.Observable.Operator;
 import rx.Subscriber;
@@ -19,8 +19,7 @@ public final class OperatorBoundedPriorityQueue<T> implements Operator<T, T> {
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super T> child) {
-        final MinMaxPriorityQueue<T> q = MinMaxPriorityQueue.orderedBy(comparator)
-                .maximumSize(maximumSize).create();
+        final BoundedPriorityQueue<T> q = new BoundedPriorityQueue<T>(maximumSize, comparator);
         return new Subscriber<T>(child) {
 
             @Override
@@ -30,18 +29,16 @@ public final class OperatorBoundedPriorityQueue<T> implements Operator<T, T> {
 
             @Override
             public void onCompleted() {
-                while (true) {
-                    T t = q.poll();
-                    if (t == null)
-                        break;
-                    else if (!isUnsubscribed())
-                        child.onNext(t);
-                    else
+                for (T t : q.asOrderedList()) {
+                    if (isUnsubscribed()) {
                         return;
+                    } else {
+                        child.onNext(t);
+                    }
+                }
+                if (!isUnsubscribed()) {
+                    child.onCompleted();
                 }
-                if (isUnsubscribed())
-                    return;
-                child.onCompleted();
             }
 
             @Override
diff --git a/src/main/java/com/github/davidmoten/util/BoundedPriorityQueue.java b/src/main/java/com/github/davidmoten/util/BoundedPriorityQueue.java
new file mode 100644
index 0000000..fee1f7c
--- /dev/null
+++ b/src/main/java/com/github/davidmoten/util/BoundedPriorityQueue.java
@@ -0,0 +1,93 @@
+package com.github.davidmoten.util;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+
+public final class BoundedPriorityQueue<T> {
+
+    private final PriorityQueue<T> queue; /* backing data structure */
+    private final Comparator<? super T> comparator;
+    private final int maxSize;
+
+    /**
+     * Constructs a {@link BoundedPriorityQueue} with the specified
+     * {@code maxSize} and {@code comparator}.
+     *
+     * @param maxSize
+     *            - The maximum size the queue can reach, must be a positive
+     *            integer.
+     * @param comparator
+     *            - The comparator to be used to compare the elements in the
+     *            queue, must be non-null.
+     */
+    public BoundedPriorityQueue(final int maxSize, final Comparator<? super T> comparator) {
+        if (maxSize <= 0) {
+            throw new IllegalArgumentException(
+                    "maxSize = " + maxSize + "; expected a positive integer.");
+        }
+        if (comparator == null) {
+            throw new NullPointerException("Comparator is null.");
+        }
+        this.queue = new PriorityQueue<T>(reverse(comparator));
+        this.comparator = comparator;
+        this.maxSize = maxSize;
+    }
+
+    private static <T> Comparator<T> reverse(final Comparator<T> comparator) {
+        return new Comparator<T>() {
+
+            @Override
+            public int compare(T o1, T o2) {
+                return -comparator.compare(o1, o2);
+            }
+        };
+    }
+
+    public static <T> BoundedPriorityQueue<T> create(final int maxSize,
+            final Comparator<? super T> comparator) {
+        return new BoundedPriorityQueue<T>(maxSize, comparator);
+    }
+
+    /**
+     * Adds an element to the queue. If the queue contains {@code maxSize}
+     * elements, {@code e} will be compared to the lowest element in the queue
+     * using {@code comparator}. If {@code e} is greater than or equal to the
+     * lowest element, that element will be removed and {@code e} will be added
+     * instead. Otherwise, the queue will not be modified and {@code e} will not
+     * be added.
+     *
+     * @param t
+     *            - Element to be added, must be non-null.
+     */
+    public void add(final T t) {
+        if (t == null) {
+            throw new NullPointerException("cannot add null to the queue");
+        }
+        if (queue.size() >= maxSize) {
+            final T maxElement = queue.peek();
+            if (comparator.compare(maxElement, t) < 1) {
+                return;
+            } else {
+                queue.poll();
+            }
+        }
+        queue.add(t);
+    }
+
+    /**
+     * @return Returns a sorted view of the queue as a
+     *         {@link Collections#unmodifiableList(java.util.List)}
+     *         unmodifiableList.
+     */
+    public List<T> asList() {
+        return Collections.unmodifiableList(new ArrayList<T>(queue));
+    }
+
+    public List<T> asOrderedList() {
+        ArrayList<T> list = new ArrayList<T>(queue);
+        Collections.sort(list, comparator);
+        return list;
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java
index 2c46afe..d48c3d1 100644
--- a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java
+++ b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java
@@ -438,6 +438,7 @@ public class RTreeTest {
         List<Entry<Object, Rectangle>> list = tree.nearest(r(9), 10, 2).toList().toBlocking()
                 .single();
         assertEquals(2, list.size());
+        System.out.println(list);
         assertEquals(10, list.get(0).geometry().mbr().x1(), PRECISION);
         assertEquals(11, list.get(1).geometry().mbr().x1(), PRECISION);
 
diff --git a/src/test/java/com/github/davidmoten/util/BoundedPriorityQueueTest.java b/src/test/java/com/github/davidmoten/util/BoundedPriorityQueueTest.java
new file mode 100644
index 0000000..747088c
--- /dev/null
+++ b/src/test/java/com/github/davidmoten/util/BoundedPriorityQueueTest.java
@@ -0,0 +1,88 @@
+package com.github.davidmoten.util;
+
+import static com.github.davidmoten.util.BoundedPriorityQueue.create;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.util.Comparator;
+
+import org.junit.Test;
+
+import com.github.davidmoten.guavamini.Lists;
+
+public class BoundedPriorityQueueTest {
+
+    private static final Comparator<Integer> comparator = new Comparator<Integer>() {
+
+        @Override
+        public int compare(Integer o1, Integer o2) {
+            return o1.compareTo(o2);
+        }
+    };
+
+    @Test
+    public void emptyQueueAsListIsEmpty() {
+        BoundedPriorityQueue<Integer> q = create(2, comparator);
+        assertTrue(q.asOrderedList().isEmpty());
+    }
+
+    @Test
+    public void singleItemReturnsSingleItem() {
+        BoundedPriorityQueue<Integer> q = create(2, comparator);
+        q.add(1);
+        assertEquals(Lists.newArrayList(1), q.asOrderedList());
+    }
+
+    @Test
+    public void twoItemsReturnsSingleItemWhenMaxIsOne() {
+        BoundedPriorityQueue<Integer> q = create(1, comparator);
+        q.add(1);
+        q.add(2);
+        assertEquals(Lists.newArrayList(1), q.asOrderedList());
+    }
+
+    @Test
+    public void twoItemsReturnsSingleItemWhenMaxIsOneInputOrderFlipped() {
+        BoundedPriorityQueue<Integer> q = create(1, comparator);
+        q.add(2);
+        q.add(1);
+        assertEquals(Lists.newArrayList(1), q.asOrderedList());
+    }
+
+    @Test
+    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderFlipped() {
+        BoundedPriorityQueue<Integer> q = create(2, comparator);
+        q.add(3);
+        q.add(2);
+        q.add(1);
+        assertEquals(Lists.newArrayList(1, 2), q.asOrderedList());
+    }
+
+    @Test
+    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderIncreasing() {
+        BoundedPriorityQueue<Integer> q = create(2, comparator);
+        q.add(1);
+        q.add(2);
+        q.add(3);
+        assertEquals(Lists.newArrayList(1, 2), q.asOrderedList());
+    }
+
+    @Test
+    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed() {
+        BoundedPriorityQueue<Integer> q = create(2, comparator);
+        q.add(3);
+        q.add(1);
+        q.add(2);
+        assertEquals(Lists.newArrayList(1, 2), q.asOrderedList());
+    }
+
+    @Test
+    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed2() {
+        BoundedPriorityQueue<Integer> q = create(2, comparator);
+        q.add(1);
+        q.add(3);
+        q.add(2);
+        assertEquals(Lists.newArrayList(1, 2), q.asOrderedList());
+    }
+
+}
