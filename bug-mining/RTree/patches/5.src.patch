diff --git a/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java b/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java
index 5112f80..245c24d 100644
--- a/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java
+++ b/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java
@@ -25,10 +25,14 @@ public final class OperatorBoundedPriorityQueue<T> implements Operator<T, T> {
 
             @Override
             public void onCompleted() {
-                for (T t : q) {
-                    if (isUnsubscribed())
+                while (true) {
+                    T t = q.poll();
+                    if (t == null)
+                        break;
+                    else if (!isUnsubscribed())
+                        child.onNext(t);
+                    else
                         return;
-                    child.onNext(t);
                 }
                 if (isUnsubscribed())
                     return;
diff --git a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java
index 7c1eb57..0fd9de7 100644
--- a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java
+++ b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java
@@ -467,6 +467,46 @@ public class RTreeTest {
         assertEquals(value, list.get(0).value());
     }
 
+    @Test
+    public void testNearestReturnsInOrder() {
+        Object value = new Object();
+        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1))
+                .add(value, point(2, 2)).add(value, point(3, 3)).add(value, point(4, 4));
+        List<Entry<Object, Geometry>> list = tree.nearest(point(0, 0), 10, 10).toList()
+                .toBlocking().single();
+        System.out.println(list);
+        assertEquals(4, list.size());
+        assertEquals(point(1, 1), list.get(0).geometry());
+        assertEquals(point(2, 2), list.get(1).geometry());
+        assertEquals(point(3, 3), list.get(2).geometry());
+        assertEquals(point(4, 4), list.get(3).geometry());
+    }
+
+    @Test
+    public void testNearestHonoursUnsubscribeJustBeforeCompletion() {
+        Object value = new Object();
+        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));
+        final AtomicBoolean completeCalled = new AtomicBoolean(false);
+        tree.nearest(point(0, 0), 10, 10).subscribe(new Subscriber<Object>() {
+
+            @Override
+            public void onCompleted() {
+                completeCalled.set(true);
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onNext(Object t) {
+                unsubscribe();
+            }
+        });
+        assertFalse(completeCalled.get());
+    }
+
     @Test
     public void testVisualizer() {
         List<Entry<Object, Geometry>> entries = createRandomEntries(1000);
