diff --git a/src/main/java/com/github/davidmoten/util/BoundedPriorityQueue.java b/src/main/java/com/github/davidmoten/util/BoundedPriorityQueue.java
new file mode 100644
index 0000000..24747ec
--- /dev/null
+++ b/src/main/java/com/github/davidmoten/util/BoundedPriorityQueue.java
@@ -0,0 +1,79 @@
+package com.github.davidmoten.util;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.PriorityQueue;
+
+public final class BoundedPriorityQueue<T> {
+
+    private final PriorityQueue<T> queue; /* backing data structure */
+    private final Comparator<? super T> comparator;
+    private final int maxSize;
+
+    /**
+     * Constructs a {@link BoundedPriorityQueue} with the specified
+     * {@code maxSize} and {@code comparator}.
+     *
+     * @param maxSize
+     *            - The maximum size the queue can reach, must be a positive
+     *            integer.
+     * @param comparator
+     *            - The comparator to be used to compare the elements in the
+     *            queue, must be non-null.
+     */
+    public BoundedPriorityQueue(final int maxSize, final Comparator<? super T> comparator) {
+        if (maxSize <= 0) {
+            throw new IllegalArgumentException(
+                    "maxSize = " + maxSize + "; expected a positive integer.");
+        }
+        if (comparator == null) {
+            throw new NullPointerException("Comparator is null.");
+        }
+        this.queue = new PriorityQueue<T>(comparator);
+        this.comparator = queue.comparator();
+        this.maxSize = maxSize;
+    }
+
+    /**
+     * Adds an element to the queue. If the queue contains {@code maxSize}
+     * elements, {@code e} will be compared to the lowest element in the queue
+     * using {@code comparator}. If {@code e} is greater than or equal to the
+     * lowest element, that element will be removed and {@code e} will be added
+     * instead. Otherwise, the queue will not be modified and {@code e} will not
+     * be added.
+     *
+     * @param t
+     *            - Element to be added, must be non-null.
+     */
+    public void add(final T t) {
+        if (t == null) {
+            throw new NullPointerException("e is null.");
+        }
+        if (maxSize <= queue.size()) {
+            final T firstElement = queue.peek();
+            if (comparator.compare(t, firstElement) < 1) {
+                return;
+            } else {
+                queue.poll();
+            }
+        }
+        queue.add(t);
+    }
+
+    /**
+     * @return Returns a sorted view of the queue as a
+     *         {@link Collections#unmodifiableList(java.util.List)}
+     *         unmodifiableList.
+     */
+    public List<T> asList() {
+        return Collections.unmodifiableList(new ArrayList<T>(queue));
+    }
+    
+    public List<T> asOrderedList() {
+        ArrayList<T> list = new ArrayList<T>(queue);
+        Collections.sort(list, comparator);
+        return list;
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java b/src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java
index 9007840..51b8398 100644
--- a/src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java
+++ b/src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java
@@ -238,6 +238,11 @@ public class BenchmarksRTree {
     public void rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010() {
         deleteAll(starTreeM10);
     }
+    
+    @Benchmark
+    public void searchNearestGreek() {
+        searchNearestGreek(starTreeM4);
+    }
 
     private void deleteAll(RTree<Object, Point> tree) {
         tree.delete(entries.get(1000), true);
@@ -252,6 +257,10 @@ public class BenchmarksRTree {
         // should return 22 results
         tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).subscribe();
     }
+    
+    private void searchNearestGreek(RTree<Object, Point> tree) {
+        tree.nearest(Point.create(40.0,27.0), 50, 300).subscribe();
+    }
 
     private void searchGreekWithBackpressure(RTree<Object, Point> tree) {
         // should return 22 results
