<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 20:46:04 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[NIFI-2519] TestListenSMTP ValidEmail fails during parallel build</title>
                <link>https://issues.apache.org/jira/browse/NIFI-2519</link>
                <project id="12316020" key="NIFI">Apache NiFi</project>
                    <description>&lt;p&gt;While running a full NiFi parallel build received the following. So there is some test issue at least that is impacting build stability.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; &amp;#8212; maven-compiler-plugin:3.2:testCompile (default-testCompile) @ nifi-email-processors &amp;#8212;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; Changes detected - recompiling the module!&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; Compiling 4 source files to /home/travis/build/apache/nifi/nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/target/test-classes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;WARNING&amp;#93;&lt;/span&gt; /home/travis/build/apache/nifi/nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/test/java/org/apache/nifi/processors/email/TestListenSMTP.java:&lt;span class=&quot;error&quot;&gt;&amp;#91;122,24&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;deprecation&amp;#93;&lt;/span&gt; stop() in Thread has been deprecated&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;WARNING&amp;#93;&lt;/span&gt; /home/travis/build/apache/nifi/nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/test/java/org/apache/nifi/processors/email/TestListenSMTP.java:&lt;span class=&quot;error&quot;&gt;&amp;#91;186,24&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;deprecation&amp;#93;&lt;/span&gt; stop() in Thread has been deprecated&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;WARNING&amp;#93;&lt;/span&gt; /home/travis/build/apache/nifi/nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/test/java/org/apache/nifi/processors/email/TestListenSMTP.java:&lt;span class=&quot;error&quot;&gt;&amp;#91;307,24&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;deprecation&amp;#93;&lt;/span&gt; stop() in Thread has been deprecated&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; &amp;#8212; maven-compiler-plugin:3.2:testCompile (groovy-tests) @ nifi-email-processors &amp;#8212;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; Changes detected - recompiling the module!&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; Nothing to compile - all classes are up to date&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; &amp;#8212; maven-surefire-plugin:2.18:test (default-test) @ nifi-email-processors &amp;#8212;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; Surefire report directory: /home/travis/build/apache/nifi/nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/target/surefire-reports&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; Using configured provider org.apache.maven.surefire.junit4.JUnit4Provider&lt;/p&gt;

&lt;p&gt;-------------------------------------------------------&lt;br/&gt;
 T E S T S&lt;br/&gt;
-------------------------------------------------------&lt;br/&gt;
Running org.apache.nifi.processors.email.TestListenSMTP&lt;br/&gt;
Tests run: 4, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 1.473 sec &amp;lt;&amp;lt;&amp;lt; FAILURE! - in org.apache.nifi.processors.email.TestListenSMTP&lt;br/&gt;
ValidEmail(org.apache.nifi.processors.email.TestListenSMTP)  Time elapsed: 0.038 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!&lt;br/&gt;
java.lang.AssertionError: Sending email failed&lt;br/&gt;
	at org.junit.Assert.fail(Assert.java:88)&lt;br/&gt;
	at org.junit.Assert.assertTrue(Assert.java:41)&lt;br/&gt;
	at org.junit.Assert.assertFalse(Assert.java:64)&lt;br/&gt;
	at org.apache.nifi.processors.email.TestListenSMTP.ValidEmail(TestListenSMTP.java:188)&lt;/p&gt;

&lt;p&gt;Running org.apache.nifi.processors.email.TestExtractEmailAttachments&lt;br/&gt;
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.1 sec - in org.apache.nifi.processors.email.TestExtractEmailAttachments&lt;br/&gt;
Running org.apache.nifi.processors.email.TestExtractEmailHeaders&lt;br/&gt;
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.029 sec - in org.apache.nifi.processors.email.TestExtractEmailHeaders&lt;/p&gt;

&lt;p&gt;Results :&lt;/p&gt;

&lt;p&gt;Failed tests: &lt;br/&gt;
  TestListenSMTP.ValidEmail:188 Sending email failed&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12995762">NIFI-2519</key>
            <summary>TestListenSMTP ValidEmail fails during parallel build</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="joewitt">Joe Witt</assignee>
                                    <reporter username="joewitt">Joe Witt</reporter>
                        <labels>
                    </labels>
                <created>Mon, 8 Aug 2016 21:20:50 +0000</created>
                <updated>Wed, 17 Aug 2016 19:16:56 +0000</updated>
                            <resolved>Wed, 17 Aug 2016 19:16:55 +0000</resolved>
                                                    <fixVersion>1.0.0</fixVersion>
                                    <component>Extensions</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="15415337" author="githubbot" created="Wed, 10 Aug 2016 14:20:54 +0000"  >&lt;p&gt;GitHub user olegz opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/olegz/nifi&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/olegz/nifi&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #827&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 3b12c5d62b3ca0f8a968612d87bac86442cdbd00&lt;br/&gt;
Author: Oleg Zhurakousky &amp;lt;oleg@suitcase.io&amp;gt;&lt;br/&gt;
Date:   2016-08-10T14:19:17Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;</comment>
                            <comment id="15415354" author="joewitt" created="Wed, 10 Aug 2016 14:29:32 +0000"  >&lt;p&gt;thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt; will dig into it.  Looks like a series of good improvements to the processor and will help test reliability&lt;/p&gt;</comment>
                            <comment id="15416008" author="joewitt" created="Wed, 10 Aug 2016 21:01:31 +0000"  >&lt;p&gt;btw &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt; can you address these&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; &amp;#8212; maven-checkstyle-plugin:2.15:check (check-style) @ nifi-email-processors &amp;#8212;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;WARNING&amp;#93;&lt;/span&gt; src/main/java/org/apache/nifi/processors/email/ListenSMTP.java&lt;span class=&quot;error&quot;&gt;&amp;#91;220&amp;#93;&lt;/span&gt; (javadoc) NonEmptyAtclauseDescription: At-clause should have a non-empty description.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;WARNING&amp;#93;&lt;/span&gt; src/main/java/org/apache/nifi/processors/email/ListenSMTP.java&lt;span class=&quot;error&quot;&gt;&amp;#91;221&amp;#93;&lt;/span&gt; (javadoc) NonEmptyAtclauseDescription: At-clause should have a non-empty description.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; ------------------------------------------------------------------------&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;INFO&amp;#93;&lt;/span&gt; Reactor Summary:&lt;/p&gt;</comment>
                            <comment id="15416073" author="joewitt" created="Wed, 10 Aug 2016 21:46:36 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt; Looks like some healthy changes to stabilize the processor and importantly the tests as well which were making the build brittle.  I think we&apos;ll need to account for the attributes that &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trixpan&quot; class=&quot;user-hover&quot; rel=&quot;trixpan&quot;&gt;trixpan&lt;/a&gt; had been nicely extracting.  I think the other processors that now exist can be used after ListenSMTP instead to capture those attributes if needed but perhaps there are generic attributes we can grab that aren&apos;t protocol specific?&lt;/p&gt;</comment>
                            <comment id="15416080" author="joewitt" created="Wed, 10 Aug 2016 21:50:08 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt; I think listening port should default to 25, no?&lt;/p&gt;</comment>
                            <comment id="15416104" author="joewitt" created="Wed, 10 Aug 2016 22:03:56 +0000"  >&lt;p&gt;When stopping the processor it appears to never stop.  Is in a perpetual STOPPING state.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&quot;org.subethamail.smtp.server.Session-/127.0.0.1:65454&quot; Id=111 TIMED_WAITING  on java.util.concurrent.SynchronousQueue$TransferStack@12848e3d&lt;br/&gt;
        at sun.misc.Unsafe.park(Native Method)&lt;br/&gt;
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)&lt;br/&gt;
        at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:460)&lt;br/&gt;
        at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:362)&lt;br/&gt;
        at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:941)&lt;br/&gt;
        at org.apache.nifi.processors.email.SmtpConsumer.data(SmtpConsumer.java:102)&lt;br/&gt;
        at org.subethamail.smtp.command.DataCommand.execute(DataCommand.java:64)&lt;br/&gt;
        at org.subethamail.smtp.server.RequireTLSCommandWrapper.execute(RequireTLSCommandWrapper.java:30)&lt;br/&gt;
        at org.subethamail.smtp.server.CommandHandler.handleCommand(CommandHandler.java:99)&lt;br/&gt;
        at org.subethamail.smtp.server.Session.runCommandLoop(Session.java:244)&lt;br/&gt;
        at org.subethamail.smtp.server.Session.run(Session.java:145)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:745)&lt;br/&gt;
        Number of Locked Synchronizers: 1&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;java.util.concurrent.ThreadPoolExecutor$Worker@20ef6ef5&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&quot;StandardProcessScheduler Thread-3&quot; Id=95 TIMED_WAITING  on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@6c38b73c&lt;br/&gt;
        at sun.misc.Unsafe.park(Native Method)&lt;br/&gt;
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.awaitTermination(ThreadPoolExecutor.java:1465)&lt;br/&gt;
        at org.subethamail.smtp.server.ServerThread.shutdownSessions(ServerThread.java:239)&lt;br/&gt;
        at org.subethamail.smtp.server.ServerThread.shutdown(ServerThread.java:190)&lt;br/&gt;
        at org.subethamail.smtp.server.SMTPServer.stop(SMTPServer.java:310)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;waiting on org.subethamail.smtp.server.SMTPServer@5afb3f38&lt;br/&gt;
        at org.apache.nifi.processors.email.ListenSMTP.close(ListenSMTP.java:198)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:497)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.invokeMethodsWithAnnotations(ReflectionUtils.java:137)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.invokeMethodsWithAnnotations(ReflectionUtils.java:125)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.quietlyInvokeMethodsWithAnnotations(ReflectionUtils.java:233)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.quietlyInvokeMethodsWithAnnotation(ReflectionUtils.java:85)&lt;br/&gt;
        at org.apache.nifi.controller.StandardProcessorNode$2.run(StandardProcessorNode.java:1326)&lt;br/&gt;
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)&lt;br/&gt;
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)&lt;br/&gt;
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)&lt;br/&gt;
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:745)&lt;br/&gt;
        Number of Locked Synchronizers: 1&lt;/li&gt;
	&lt;li&gt;java.util.concurrent.ThreadPoolExecutor$Worker@5299b36&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</comment>
                            <comment id="15416335" author="githubbot" created="Thu, 11 Aug 2016 01:34:07 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74359964&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74359964&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -13,89 +13,52 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
    -*/&lt;br/&gt;
    + */&lt;br/&gt;
     package org.apache.nifi.processors.email;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -import javax.net.ssl.SSLContext;&lt;br/&gt;
    -import javax.net.ssl.SSLSocket;&lt;br/&gt;
    -import javax.net.ssl.SSLSocketFactory;&lt;br/&gt;
     import java.io.IOException;&lt;br/&gt;
    -import java.io.InputStream;&lt;br/&gt;
    +import java.io.OutputStream;&lt;br/&gt;
     import java.net.InetSocketAddress;&lt;br/&gt;
     import java.net.Socket;&lt;br/&gt;
     import java.util.ArrayList;&lt;br/&gt;
    -import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    -import java.util.HashMap;&lt;br/&gt;
     import java.util.HashSet;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    -import java.util.Map;&lt;br/&gt;
     import java.util.Set;&lt;br/&gt;
    -import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;
     import java.util.concurrent.TimeUnit;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnUnscheduled;&lt;br/&gt;
    -import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    -import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicInteger;&lt;/p&gt;

&lt;p&gt;    -import org.apache.nifi.annotation.lifecycle.OnScheduled;&lt;br/&gt;
    -import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    -import org.apache.nifi.processor.AbstractProcessor;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessorInitializationContext;&lt;br/&gt;
    -import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    -import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
    +import javax.net.ssl.SSLContext;&lt;br/&gt;
    +import javax.net.ssl.SSLSocket;&lt;br/&gt;
    +import javax.net.ssl.SSLSocketFactory;&lt;/p&gt;

&lt;p&gt;    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.InputRequirement;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttribute;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttributes;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.CapabilityDescription;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.Tags;&lt;br/&gt;
    +import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    +import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    +import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.AbstractSessionFactoryProcessor;&lt;br/&gt;
    +import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.Relationship;&lt;br/&gt;
     import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationContext;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationResult;&lt;br/&gt;
    -import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.io.OutputStreamCallback;&lt;br/&gt;
    +import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
     import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.event.SmtpEvent;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPResultCode;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPMessageHandlerFactory;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;/p&gt;

&lt;p&gt;     @Tags(&lt;/p&gt;
{&quot;listen&quot;, &quot;email&quot;, &quot;smtp&quot;}
&lt;p&gt;)&lt;br/&gt;
     @InputRequirement(InputRequirement.Requirement.INPUT_FORBIDDEN)&lt;br/&gt;
    -@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;allowing nifi to listen for incoming email. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Note this server does not perform any email validation. If direct exposure to the internet is sought,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;it may be a better idea to use the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
    -@WritesAttributes(
{
    -        @WritesAttribute(attribute = &quot;mime.type&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.serial&quot;, description = &quot;The serial numbers for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.principal&quot;, description = &quot;The principal for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.from&quot;, description = &quot;The value used during MAIL FROM (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.to&quot;, description = &quot;The value used during RCPT TO (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.src&quot;, description = &quot;The source IP of the SMTP connection&quot;)}
&lt;p&gt;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Attributes were in there for a reason: They allow you to understand the connection (where it came from, what certificates where used, etc) and record this information for posterior use. &lt;/p&gt;

&lt;p&gt;    I would not remove this functionality&lt;/p&gt;</comment>
                            <comment id="15416356" author="trixpan" created="Thu, 11 Aug 2016 01:54:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=joewitt&quot; class=&quot;user-hover&quot; rel=&quot;joewitt&quot;&gt;joewitt&lt;/a&gt; port 25 would require NiFi to be running as root.&lt;/p&gt;</comment>
                            <comment id="15416360" author="githubbot" created="Thu, 11 Aug 2016 01:59:01 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74361191&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74361191&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Without this SubEtha seems to default to localhost&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    $ telnet 10.0.2.15 2525&lt;br/&gt;
    Trying 10.0.2.15...&lt;br/&gt;
    Connected to 10.0.2.15.&lt;br/&gt;
    Escape character is &apos;^]&apos;.&lt;br/&gt;
    220 localhost ESMTP Apache NiFi&lt;/p&gt;

&lt;p&gt;    ```&lt;/p&gt;</comment>
                            <comment id="15416366" author="githubbot" created="Thu, 11 Aug 2016 02:04:08 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74361483&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74361483&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    True, so my question is whatever it defaults to is based on the network settings of your machine. Exposing it means I can set it to any name, so I am wondering why would this be important?&lt;br/&gt;
    Don&apos;t get me wrong, putting it back is trivial, but I am looking for justification.&lt;/p&gt;</comment>
                            <comment id="15416371" author="githubbot" created="Thu, 11 Aug 2016 02:06:01 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74361570&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74361570&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Although harmless, this should not be a valid configuration:&lt;/p&gt;

&lt;p&gt;    !&lt;span class=&quot;error&quot;&gt;&amp;#91;image&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://cloud.githubusercontent.com/assets/3108527/17576962/e5e0414a-5fbb-11e6-9050-9234dc1fe7d1.png&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://cloud.githubusercontent.com/assets/3108527/17576962/e5e0414a-5fbb-11e6-9050-9234dc1fe7d1.png&lt;/a&gt;)&lt;/p&gt;
</comment>
                            <comment id="15416375" author="githubbot" created="Thu, 11 Aug 2016 02:09:48 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74361725&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74361725&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -13,89 +13,52 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
    -*/&lt;br/&gt;
    + */&lt;br/&gt;
     package org.apache.nifi.processors.email;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -import javax.net.ssl.SSLContext;&lt;br/&gt;
    -import javax.net.ssl.SSLSocket;&lt;br/&gt;
    -import javax.net.ssl.SSLSocketFactory;&lt;br/&gt;
     import java.io.IOException;&lt;br/&gt;
    -import java.io.InputStream;&lt;br/&gt;
    +import java.io.OutputStream;&lt;br/&gt;
     import java.net.InetSocketAddress;&lt;br/&gt;
     import java.net.Socket;&lt;br/&gt;
     import java.util.ArrayList;&lt;br/&gt;
    -import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    -import java.util.HashMap;&lt;br/&gt;
     import java.util.HashSet;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    -import java.util.Map;&lt;br/&gt;
     import java.util.Set;&lt;br/&gt;
    -import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;
     import java.util.concurrent.TimeUnit;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnUnscheduled;&lt;br/&gt;
    -import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    -import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicInteger;&lt;/p&gt;

&lt;p&gt;    -import org.apache.nifi.annotation.lifecycle.OnScheduled;&lt;br/&gt;
    -import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    -import org.apache.nifi.processor.AbstractProcessor;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessorInitializationContext;&lt;br/&gt;
    -import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    -import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
    +import javax.net.ssl.SSLContext;&lt;br/&gt;
    +import javax.net.ssl.SSLSocket;&lt;br/&gt;
    +import javax.net.ssl.SSLSocketFactory;&lt;/p&gt;

&lt;p&gt;    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.InputRequirement;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttribute;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttributes;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.CapabilityDescription;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.Tags;&lt;br/&gt;
    +import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    +import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    +import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.AbstractSessionFactoryProcessor;&lt;br/&gt;
    +import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.Relationship;&lt;br/&gt;
     import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationContext;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationResult;&lt;br/&gt;
    -import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.io.OutputStreamCallback;&lt;br/&gt;
    +import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
     import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.event.SmtpEvent;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPResultCode;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPMessageHandlerFactory;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;/p&gt;

&lt;p&gt;     @Tags(&lt;/p&gt;
{&quot;listen&quot;, &quot;email&quot;, &quot;smtp&quot;}
&lt;p&gt;)&lt;br/&gt;
     @InputRequirement(InputRequirement.Requirement.INPUT_FORBIDDEN)&lt;br/&gt;
    -@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;allowing nifi to listen for incoming email. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Note this server does not perform any email validation. If direct exposure to the internet is sought,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;it may be a better idea to use the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
    -@WritesAttributes(
{
    -        @WritesAttribute(attribute = &quot;mime.type&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.serial&quot;, description = &quot;The serial numbers for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.principal&quot;, description = &quot;The principal for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.from&quot;, description = &quot;The value used during MAIL FROM (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.to&quot;, description = &quot;The value used during RCPT TO (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.src&quot;, description = &quot;The source IP of the SMTP connection&quot;)}
&lt;p&gt;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The reason why we removed them is to align then with how IMAP/POP3 works. Basically the email is written as raw bytes to the content of the Flow File. We can easily have ParseEmailProcessor downstream in the future which is configurable to extract whatever attributes you want. Remember the conversation we all had on the dev list about doing one thing but doing it well. . .? This would be one example. This processor&apos;s job IMHO is to receive email and send it downstream. There could be variety of use cases for extracting attributes, parsing content, searching etc., and we should not munge them into a single processor.&lt;/p&gt;</comment>
                            <comment id="15416377" author="githubbot" created="Thu, 11 Aug 2016 02:11:42 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74361819&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74361819&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I believe you are talking about customValidate() you had there before. I think it was an oversight on my end. Will put it back &lt;/p&gt;</comment>
                            <comment id="15416381" author="githubbot" created="Thu, 11 Aug 2016 02:13:45 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74361899&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74361899&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected Collection&amp;lt;ValidationResult&amp;gt; customValidate(final ValidationContext validationContext) {&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;ValidationResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +    static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;br/&gt;
    +            .name(&quot;success&quot;)&lt;br/&gt;
    +            .description(&quot;All new messages will be routed as FlowFiles to this relationship&quot;)&lt;br/&gt;
    +            .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final String clientAuth = validationContext.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = validationContext.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +    private final static List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (sslContextService != null &amp;amp;&amp;amp; StringUtils.isBlank(clientAuth)) 
{
    -            results.add(new ValidationResult.Builder()
    -                    .explanation(&quot;Client Auth must be provided when using TLS/SSL&quot;)
    -                    .valid(false).subject(&quot;Client Auth&quot;).build());
    -        }
&lt;p&gt;    +    private final static Set&amp;lt;Relationship&amp;gt; relationships;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return results;&lt;br/&gt;
    +    static 
{
    +        List&amp;lt;PropertyDescriptor&amp;gt; _propertyDescriptors = new ArrayList&amp;lt;&amp;gt;();
    +        _propertyDescriptors.add(SMTP_PORT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_CONNECTIONS);
    +        _propertyDescriptors.add(SMTP_TIMEOUT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_MSG_SIZE);
    +        _propertyDescriptors.add(SSL_CONTEXT_SERVICE);
    +        _propertyDescriptors.add(CLIENT_AUTH);
    +        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);
     
    +        Set&amp;lt;Relationship&amp;gt; _relationships = new HashSet&amp;lt;&amp;gt;();
    +        _relationships.add(REL_SUCCESS);
    +        relationships = Collections.unmodifiableSet(_relationships);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    private volatile SMTPServer smtp;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;success&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;Extraction was successful&quot;)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    +    private volatile SmtpConsumer smtpConsumer;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private Set&amp;lt;Relationship&amp;gt; relationships;&lt;/li&gt;
	&lt;li&gt;private List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
	&lt;li&gt;private volatile LinkedBlockingQueue&amp;lt;SmtpEvent&amp;gt; incomingMessages;&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public void onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) throws ProcessException {&lt;br/&gt;
    +        ProcessSession processSession = sessionFactory.createSession();&lt;br/&gt;
    +        if (this.smtp == null) 
{
    +            this.setupSmtpIfNecessary(context, processSession);
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        if (this.smtpConsumer.hasMessage()) {&lt;br/&gt;
    +            try {&lt;br/&gt;
    +                /*&lt;br/&gt;
    +                 * Will consume incoming message directly from the wire and into&lt;br/&gt;
    +                 * FlowFile/Content repository before exiting. This essentially&lt;br/&gt;
    +                 * limits any potential data loss by allowing SMTPServer thread&lt;br/&gt;
    +                 * to actually commit NiFi session if all good. However in the&lt;br/&gt;
    +                 * event of exception, such exception will be propagated back to&lt;br/&gt;
    +                 * the email sender via &quot;undeliverable message&quot; allowing such&lt;br/&gt;
    +                 * user to re-send the message&lt;br/&gt;
    +                 */&lt;br/&gt;
    +                this.smtpConsumer.consumeUsing((inputDataStream) -&amp;gt; {&lt;br/&gt;
    +                    FlowFile flowFile = processSession.create();&lt;br/&gt;
    +                    AtomicInteger size = new AtomicInteger();&lt;br/&gt;
    +                    flowFile = processSession.write(flowFile, new OutputStreamCallback() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                        @Override    +                        public void process(final OutputStream out) throws IOException {
    +                            size.set(IOUtils.copy(inputDataStream, out));
    +                        }    +                    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +                    processSession.getProvenanceReporter().receive(flowFile, &quot;smtp://&quot;&lt;br/&gt;
    +                            + ListenSMTP.this.smtp.getHostName() + &quot;:&quot; + ListenSMTP.this.smtp.getPort() + &quot;/&quot;);&lt;br/&gt;
    +                    processSession.transfer(flowFile, REL_SUCCESS);&lt;br/&gt;
    +                    processSession.commit();&lt;br/&gt;
    +                    return size.get();&lt;br/&gt;
    +                });&lt;br/&gt;
    +            } catch (Exception e) &lt;/p&gt;
{
    +                this.getLogger().error(&quot;Failed while listenning for messages.&quot;, e);
    +                processSession.rollback();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            context.yield();
    +        }
&lt;p&gt;    +    }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private volatile SMTPServer server;&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean initialized = new AtomicBoolean(false);&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean stopping = new AtomicBoolean(false);&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @OnStopped&lt;br/&gt;
    +    public void close() 
{
    +        this.getLogger().info(&quot;Stopping SMTPServer&quot;);
    +        this.smtp.stop();
    +        this.smtp = null;
    +        this.getLogger().info(&quot;SMTPServer stopped&quot;);
    +    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
         @Override&lt;br/&gt;
         public Set&amp;lt;Relationship&amp;gt; getRelationships() &lt;/p&gt;
{
             return relationships;
         }

&lt;p&gt;    +    /**&lt;br/&gt;
    +    *&lt;br/&gt;
    +    */&lt;br/&gt;
         @Override&lt;br/&gt;
         protected List&amp;lt;PropertyDescriptor&amp;gt; getSupportedPropertyDescriptors() &lt;/p&gt;
{
             return propertyDescriptors;
         }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected void init(final ProcessorInitializationContext context) 
{
    -        final Set&amp;lt;Relationship&amp;gt; relationships = new HashSet&amp;lt;&amp;gt;();
    -        relationships.add(REL_SUCCESS);
    -        this.relationships = Collections.unmodifiableSet(relationships);
    -
    -        final List&amp;lt;PropertyDescriptor&amp;gt; props = new ArrayList&amp;lt;&amp;gt;();
    -        props.add(SMTP_PORT);
    -        props.add(SMTP_HOSTNAME);
    -        props.add(SMTP_MAXIMUM_CONNECTIONS);
    -        props.add(SMTP_TIMEOUT);
    -        props.add(SMTP_MAXIMUM_MSG_SIZE);
    -        props.add(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE);
    -        props.add(SSL_CONTEXT_SERVICE);
    -        props.add(CLIENT_AUTH);
    -        this.propertyDescriptors = Collections.unmodifiableList(props);
    -
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Upon Schedule, reset the initialized state to false&lt;/li&gt;
	&lt;li&gt;@OnScheduled&lt;/li&gt;
	&lt;li&gt;public void onScheduled(ProcessContext context) 
{
    -        initialized.set(false);
    -        stopping.set(false);
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected synchronized void initializeSMTPServer(final ProcessContext context) throws Exception {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// check if we are already running or if it is stopping&lt;/li&gt;
	&lt;li&gt;if (initialized.get() &amp;amp;&amp;amp; server.isRunning() || stopping.get() ) 
{
    -            return;
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;incomingMessages = new LinkedBlockingQueue&amp;lt;&amp;gt;(context.getProperty(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE).asInteger());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;String clientAuth = null;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// If an SSLContextService was provided then create an SSLContext to pass down to the server&lt;/li&gt;
	&lt;li&gt;SSLContext sslContext = null;&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;/li&gt;
	&lt;li&gt;if (sslContextService != null) {&lt;/li&gt;
	&lt;li&gt;clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private synchronized void setupSmtpIfNecessary(ProcessContext context, ProcessSession processSession) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +        if (this.smtp == null) {
    +            SmtpConsumer consumer = new SmtpConsumer();
    +            SMTPServer smtpServer = this.createServerInstance(context, consumer);
    +            smtpServer.setSoftwareName(&quot;Apache NiFi&quot;);
    +            smtpServer.setPort(context.getProperty(SMTP_PORT).asInteger());
    +            smtpServer.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());
    +            smtpServer.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());
    +
    +            this.smtpConsumer = consumer;
    +            this.smtp = smtpServer;
    +            this.smtp.start();
             }    +    }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SSLContext finalSslContext = sslContext;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SMTPMessageHandlerFactory smtpMessageHandlerFactory = new SMTPMessageHandlerFactory(incomingMessages, getLogger());&lt;/li&gt;
	&lt;li&gt;final SMTPServer server = new SMTPServer(smtpMessageHandlerFactory) {&lt;br/&gt;
    -&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private SMTPServer createServerInstance(ProcessContext context, SmtpConsumer consumer) {&lt;br/&gt;
    +        SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +        SMTPServer smtpServer = sslContextService == null ? new SMTPServer(consumer) : new SMTPServer(consumer) {&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public SSLSocket createSSLSocket(Socket socket) throws IOException {&lt;br/&gt;
                     InetSocketAddress remoteAddress = (InetSocketAddress) socket.getRemoteSocketAddress();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocketFactory socketFactory = finalSslContext.getSocketFactory();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocket s = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(), socket.getPort(), true));&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;s.setUseClientMode(false);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// For some reason the createSSLContext above is not enough to enforce&lt;/li&gt;
	&lt;li&gt;// client side auth&lt;/li&gt;
	&lt;li&gt;// If client auth is required...&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) {&lt;/li&gt;
	&lt;li&gt;s.setNeedClientAuth(true);&lt;br/&gt;
    +                String clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;br/&gt;
    +                SSLContext sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +                SSLSocketFactory socketFactory = sslContext.getSocketFactory();&lt;br/&gt;
    +                SSLSocket sslSocket = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(),socket.getPort(), true));&lt;br/&gt;
    +                sslSocket.setUseClientMode(false);&lt;br/&gt;
    +&lt;br/&gt;
    +                if (SSLContextService.ClientAuth.REQUIRED.toString().equals(clientAuth)) 
{
    +                    this.setRequireTLS(true);
    +                    sslSocket.setNeedClientAuth(true);
                     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return s;&lt;br/&gt;
    +                return sslSocket;&lt;br/&gt;
                 }&lt;br/&gt;
             };&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set some parameters to our server&lt;/li&gt;
	&lt;li&gt;server.setSoftwareName(&quot;Apache NiFi&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set the Server options based on properties&lt;/li&gt;
	&lt;li&gt;server.setPort(context.getProperty(SMTP_PORT).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setHostName(context.getProperty(SMTP_HOSTNAME).getValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxConnections(context.getProperty(SMTP_MAXIMUM_CONNECTIONS).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Check if TLS should be enabled&lt;br/&gt;
             if (sslContextService != null) 
{
    -            server.setEnableTLS(true);
    -        }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;server.setHideTLS(true);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @olegz TLS should be hidden when not enabled so to prevent situations where the client will not like the `454 TLS not supported` message ListenSMTP returns when it is disabled.&lt;/p&gt;

&lt;p&gt;    This is required to prevent this:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    $ telnet 0 2525&lt;br/&gt;
    Trying 0.0.0.0...&lt;br/&gt;
    Connected to 0.&lt;br/&gt;
    Escape character is &apos;^]&apos;.&lt;br/&gt;
    220 localhost ESMTP Apache NiFi&lt;br/&gt;
    help&lt;br/&gt;
    214-Apache NiFi on localhost&lt;br/&gt;
    214-Topics:&lt;br/&gt;
    214-     HELP&lt;br/&gt;
    214-     HELO&lt;br/&gt;
    214-     RCPT&lt;br/&gt;
    214-     MAIL&lt;br/&gt;
    214-     DATA&lt;br/&gt;
    214-     AUTH&lt;br/&gt;
    214-     EHLO&lt;br/&gt;
    214-     NOOP&lt;br/&gt;
    214-     RSET&lt;br/&gt;
    214-     VRFY&lt;br/&gt;
    214-     QUIT&lt;br/&gt;
    214-     STARTTLS&lt;br/&gt;
    214-For more info use &quot;HELP &amp;lt;topic&amp;gt;&quot;.&lt;br/&gt;
    214 End of HELP info&lt;br/&gt;
    STARTTLS&lt;br/&gt;
    454 TLS not supported&lt;br/&gt;
    quit&lt;br/&gt;
    221 Bye&lt;br/&gt;
    Connection closed by foreign host.&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    vs&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    $ time openssl s_client -starttls smtp -crlf -connect 127.0.0.1:2525&lt;br/&gt;
    CONNECTED(00000003)&lt;br/&gt;
    didn&apos;t found starttls in server response, try anyway...&lt;br/&gt;
    140406973187912:error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol:s23_clnt.c:769:&lt;br/&gt;
    &amp;#8212;&lt;br/&gt;
    no peer certificate available&lt;br/&gt;
    &amp;#8212;&lt;br/&gt;
    No client certificate CA names sent&lt;br/&gt;
    &amp;#8212;&lt;br/&gt;
    SSL handshake has read 119 bytes and written 282 bytes&lt;br/&gt;
    &amp;#8212;&lt;br/&gt;
    New, (NONE), Cipher is (NONE)&lt;br/&gt;
    Secure Renegotiation IS NOT supported&lt;br/&gt;
    Compression: NONE&lt;br/&gt;
    Expansion: NONE&lt;br/&gt;
    &amp;#8212;&lt;/p&gt;

&lt;p&gt;    real    1m0.086s&lt;br/&gt;
    user    0m0.023s&lt;br/&gt;
    sys     0m0.003s&lt;/p&gt;

&lt;p&gt;    ```&lt;/p&gt;</comment>
                            <comment id="15416383" author="githubbot" created="Thu, 11 Aug 2016 02:15:19 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74361967&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74361967&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected Collection&amp;lt;ValidationResult&amp;gt; customValidate(final ValidationContext validationContext) {&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;ValidationResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +    static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;br/&gt;
    +            .name(&quot;success&quot;)&lt;br/&gt;
    +            .description(&quot;All new messages will be routed as FlowFiles to this relationship&quot;)&lt;br/&gt;
    +            .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final String clientAuth = validationContext.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = validationContext.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +    private final static List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (sslContextService != null &amp;amp;&amp;amp; StringUtils.isBlank(clientAuth)) 
{
    -            results.add(new ValidationResult.Builder()
    -                    .explanation(&quot;Client Auth must be provided when using TLS/SSL&quot;)
    -                    .valid(false).subject(&quot;Client Auth&quot;).build());
    -        }
&lt;p&gt;    +    private final static Set&amp;lt;Relationship&amp;gt; relationships;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return results;&lt;br/&gt;
    +    static 
{
    +        List&amp;lt;PropertyDescriptor&amp;gt; _propertyDescriptors = new ArrayList&amp;lt;&amp;gt;();
    +        _propertyDescriptors.add(SMTP_PORT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_CONNECTIONS);
    +        _propertyDescriptors.add(SMTP_TIMEOUT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_MSG_SIZE);
    +        _propertyDescriptors.add(SSL_CONTEXT_SERVICE);
    +        _propertyDescriptors.add(CLIENT_AUTH);
    +        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);
     
    +        Set&amp;lt;Relationship&amp;gt; _relationships = new HashSet&amp;lt;&amp;gt;();
    +        _relationships.add(REL_SUCCESS);
    +        relationships = Collections.unmodifiableSet(_relationships);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    private volatile SMTPServer smtp;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;success&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;Extraction was successful&quot;)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    +    private volatile SmtpConsumer smtpConsumer;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private Set&amp;lt;Relationship&amp;gt; relationships;&lt;/li&gt;
	&lt;li&gt;private List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
	&lt;li&gt;private volatile LinkedBlockingQueue&amp;lt;SmtpEvent&amp;gt; incomingMessages;&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public void onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) throws ProcessException {&lt;br/&gt;
    +        ProcessSession processSession = sessionFactory.createSession();&lt;br/&gt;
    +        if (this.smtp == null) 
{
    +            this.setupSmtpIfNecessary(context, processSession);
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        if (this.smtpConsumer.hasMessage()) {&lt;br/&gt;
    +            try {&lt;br/&gt;
    +                /*&lt;br/&gt;
    +                 * Will consume incoming message directly from the wire and into&lt;br/&gt;
    +                 * FlowFile/Content repository before exiting. This essentially&lt;br/&gt;
    +                 * limits any potential data loss by allowing SMTPServer thread&lt;br/&gt;
    +                 * to actually commit NiFi session if all good. However in the&lt;br/&gt;
    +                 * event of exception, such exception will be propagated back to&lt;br/&gt;
    +                 * the email sender via &quot;undeliverable message&quot; allowing such&lt;br/&gt;
    +                 * user to re-send the message&lt;br/&gt;
    +                 */&lt;br/&gt;
    +                this.smtpConsumer.consumeUsing((inputDataStream) -&amp;gt; {&lt;br/&gt;
    +                    FlowFile flowFile = processSession.create();&lt;br/&gt;
    +                    AtomicInteger size = new AtomicInteger();&lt;br/&gt;
    +                    flowFile = processSession.write(flowFile, new OutputStreamCallback() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                        @Override    +                        public void process(final OutputStream out) throws IOException {
    +                            size.set(IOUtils.copy(inputDataStream, out));
    +                        }    +                    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +                    processSession.getProvenanceReporter().receive(flowFile, &quot;smtp://&quot;&lt;br/&gt;
    +                            + ListenSMTP.this.smtp.getHostName() + &quot;:&quot; + ListenSMTP.this.smtp.getPort() + &quot;/&quot;);&lt;br/&gt;
    +                    processSession.transfer(flowFile, REL_SUCCESS);&lt;br/&gt;
    +                    processSession.commit();&lt;br/&gt;
    +                    return size.get();&lt;br/&gt;
    +                });&lt;br/&gt;
    +            } catch (Exception e) &lt;/p&gt;
{
    +                this.getLogger().error(&quot;Failed while listenning for messages.&quot;, e);
    +                processSession.rollback();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            context.yield();
    +        }
&lt;p&gt;    +    }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private volatile SMTPServer server;&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean initialized = new AtomicBoolean(false);&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean stopping = new AtomicBoolean(false);&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @OnStopped&lt;br/&gt;
    +    public void close() 
{
    +        this.getLogger().info(&quot;Stopping SMTPServer&quot;);
    +        this.smtp.stop();
    +        this.smtp = null;
    +        this.getLogger().info(&quot;SMTPServer stopped&quot;);
    +    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
         @Override&lt;br/&gt;
         public Set&amp;lt;Relationship&amp;gt; getRelationships() &lt;/p&gt;
{
             return relationships;
         }

&lt;p&gt;    +    /**&lt;br/&gt;
    +    *&lt;br/&gt;
    +    */&lt;br/&gt;
         @Override&lt;br/&gt;
         protected List&amp;lt;PropertyDescriptor&amp;gt; getSupportedPropertyDescriptors() &lt;/p&gt;
{
             return propertyDescriptors;
         }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected void init(final ProcessorInitializationContext context) 
{
    -        final Set&amp;lt;Relationship&amp;gt; relationships = new HashSet&amp;lt;&amp;gt;();
    -        relationships.add(REL_SUCCESS);
    -        this.relationships = Collections.unmodifiableSet(relationships);
    -
    -        final List&amp;lt;PropertyDescriptor&amp;gt; props = new ArrayList&amp;lt;&amp;gt;();
    -        props.add(SMTP_PORT);
    -        props.add(SMTP_HOSTNAME);
    -        props.add(SMTP_MAXIMUM_CONNECTIONS);
    -        props.add(SMTP_TIMEOUT);
    -        props.add(SMTP_MAXIMUM_MSG_SIZE);
    -        props.add(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE);
    -        props.add(SSL_CONTEXT_SERVICE);
    -        props.add(CLIENT_AUTH);
    -        this.propertyDescriptors = Collections.unmodifiableList(props);
    -
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Upon Schedule, reset the initialized state to false&lt;/li&gt;
	&lt;li&gt;@OnScheduled&lt;/li&gt;
	&lt;li&gt;public void onScheduled(ProcessContext context) 
{
    -        initialized.set(false);
    -        stopping.set(false);
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected synchronized void initializeSMTPServer(final ProcessContext context) throws Exception {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// check if we are already running or if it is stopping&lt;/li&gt;
	&lt;li&gt;if (initialized.get() &amp;amp;&amp;amp; server.isRunning() || stopping.get() ) 
{
    -            return;
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;incomingMessages = new LinkedBlockingQueue&amp;lt;&amp;gt;(context.getProperty(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE).asInteger());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;String clientAuth = null;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// If an SSLContextService was provided then create an SSLContext to pass down to the server&lt;/li&gt;
	&lt;li&gt;SSLContext sslContext = null;&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;/li&gt;
	&lt;li&gt;if (sslContextService != null) {&lt;/li&gt;
	&lt;li&gt;clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private synchronized void setupSmtpIfNecessary(ProcessContext context, ProcessSession processSession) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +        if (this.smtp == null) {
    +            SmtpConsumer consumer = new SmtpConsumer();
    +            SMTPServer smtpServer = this.createServerInstance(context, consumer);
    +            smtpServer.setSoftwareName(&quot;Apache NiFi&quot;);
    +            smtpServer.setPort(context.getProperty(SMTP_PORT).asInteger());
    +            smtpServer.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());
    +            smtpServer.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());
    +
    +            this.smtpConsumer = consumer;
    +            this.smtp = smtpServer;
    +            this.smtp.start();
             }    +    }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SSLContext finalSslContext = sslContext;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SMTPMessageHandlerFactory smtpMessageHandlerFactory = new SMTPMessageHandlerFactory(incomingMessages, getLogger());&lt;/li&gt;
	&lt;li&gt;final SMTPServer server = new SMTPServer(smtpMessageHandlerFactory) {&lt;br/&gt;
    -&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private SMTPServer createServerInstance(ProcessContext context, SmtpConsumer consumer) {&lt;br/&gt;
    +        SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +        SMTPServer smtpServer = sslContextService == null ? new SMTPServer(consumer) : new SMTPServer(consumer) {&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public SSLSocket createSSLSocket(Socket socket) throws IOException {&lt;br/&gt;
                     InetSocketAddress remoteAddress = (InetSocketAddress) socket.getRemoteSocketAddress();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocketFactory socketFactory = finalSslContext.getSocketFactory();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocket s = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(), socket.getPort(), true));&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;s.setUseClientMode(false);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// For some reason the createSSLContext above is not enough to enforce&lt;/li&gt;
	&lt;li&gt;// client side auth&lt;/li&gt;
	&lt;li&gt;// If client auth is required...&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) {&lt;/li&gt;
	&lt;li&gt;s.setNeedClientAuth(true);&lt;br/&gt;
    +                String clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;br/&gt;
    +                SSLContext sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +                SSLSocketFactory socketFactory = sslContext.getSocketFactory();&lt;br/&gt;
    +                SSLSocket sslSocket = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(),socket.getPort(), true));&lt;br/&gt;
    +                sslSocket.setUseClientMode(false);&lt;br/&gt;
    +&lt;br/&gt;
    +                if (SSLContextService.ClientAuth.REQUIRED.toString().equals(clientAuth)) 
{
    +                    this.setRequireTLS(true);
    +                    sslSocket.setNeedClientAuth(true);
                     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return s;&lt;br/&gt;
    +                return sslSocket;&lt;br/&gt;
                 }&lt;br/&gt;
             };&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set some parameters to our server&lt;/li&gt;
	&lt;li&gt;server.setSoftwareName(&quot;Apache NiFi&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set the Server options based on properties&lt;/li&gt;
	&lt;li&gt;server.setPort(context.getProperty(SMTP_PORT).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setHostName(context.getProperty(SMTP_HOSTNAME).getValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxConnections(context.getProperty(SMTP_MAXIMUM_CONNECTIONS).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Check if TLS should be enabled&lt;br/&gt;
             if (sslContextService != null) 
{
    -            server.setEnableTLS(true);
    -        }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;server.setHideTLS(true);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Fair enough. Thanks for heads up.&lt;/p&gt;</comment>
                            <comment id="15416384" author="githubbot" created="Thu, 11 Aug 2016 02:16:23 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362012&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362012&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected Collection&amp;lt;ValidationResult&amp;gt; customValidate(final ValidationContext validationContext) {&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;ValidationResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +    static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;br/&gt;
    +            .name(&quot;success&quot;)&lt;br/&gt;
    +            .description(&quot;All new messages will be routed as FlowFiles to this relationship&quot;)&lt;br/&gt;
    +            .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final String clientAuth = validationContext.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = validationContext.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +    private final static List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (sslContextService != null &amp;amp;&amp;amp; StringUtils.isBlank(clientAuth)) 
{
    -            results.add(new ValidationResult.Builder()
    -                    .explanation(&quot;Client Auth must be provided when using TLS/SSL&quot;)
    -                    .valid(false).subject(&quot;Client Auth&quot;).build());
    -        }
&lt;p&gt;    +    private final static Set&amp;lt;Relationship&amp;gt; relationships;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return results;&lt;br/&gt;
    +    static 
{
    +        List&amp;lt;PropertyDescriptor&amp;gt; _propertyDescriptors = new ArrayList&amp;lt;&amp;gt;();
    +        _propertyDescriptors.add(SMTP_PORT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_CONNECTIONS);
    +        _propertyDescriptors.add(SMTP_TIMEOUT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_MSG_SIZE);
    +        _propertyDescriptors.add(SSL_CONTEXT_SERVICE);
    +        _propertyDescriptors.add(CLIENT_AUTH);
    +        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);
     
    +        Set&amp;lt;Relationship&amp;gt; _relationships = new HashSet&amp;lt;&amp;gt;();
    +        _relationships.add(REL_SUCCESS);
    +        relationships = Collections.unmodifiableSet(_relationships);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    private volatile SMTPServer smtp;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;success&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;Extraction was successful&quot;)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    +    private volatile SmtpConsumer smtpConsumer;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private Set&amp;lt;Relationship&amp;gt; relationships;&lt;/li&gt;
	&lt;li&gt;private List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
	&lt;li&gt;private volatile LinkedBlockingQueue&amp;lt;SmtpEvent&amp;gt; incomingMessages;&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public void onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) throws ProcessException {&lt;br/&gt;
    +        ProcessSession processSession = sessionFactory.createSession();&lt;br/&gt;
    +        if (this.smtp == null) 
{
    +            this.setupSmtpIfNecessary(context, processSession);
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        if (this.smtpConsumer.hasMessage()) {&lt;br/&gt;
    +            try {&lt;br/&gt;
    +                /*&lt;br/&gt;
    +                 * Will consume incoming message directly from the wire and into&lt;br/&gt;
    +                 * FlowFile/Content repository before exiting. This essentially&lt;br/&gt;
    +                 * limits any potential data loss by allowing SMTPServer thread&lt;br/&gt;
    +                 * to actually commit NiFi session if all good. However in the&lt;br/&gt;
    +                 * event of exception, such exception will be propagated back to&lt;br/&gt;
    +                 * the email sender via &quot;undeliverable message&quot; allowing such&lt;br/&gt;
    +                 * user to re-send the message&lt;br/&gt;
    +                 */&lt;br/&gt;
    +                this.smtpConsumer.consumeUsing((inputDataStream) -&amp;gt; {&lt;br/&gt;
    +                    FlowFile flowFile = processSession.create();&lt;br/&gt;
    +                    AtomicInteger size = new AtomicInteger();&lt;br/&gt;
    +                    flowFile = processSession.write(flowFile, new OutputStreamCallback() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                        @Override    +                        public void process(final OutputStream out) throws IOException {
    +                            size.set(IOUtils.copy(inputDataStream, out));
    +                        }    +                    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +                    processSession.getProvenanceReporter().receive(flowFile, &quot;smtp://&quot;&lt;br/&gt;
    +                            + ListenSMTP.this.smtp.getHostName() + &quot;:&quot; + ListenSMTP.this.smtp.getPort() + &quot;/&quot;);&lt;br/&gt;
    +                    processSession.transfer(flowFile, REL_SUCCESS);&lt;br/&gt;
    +                    processSession.commit();&lt;br/&gt;
    +                    return size.get();&lt;br/&gt;
    +                });&lt;br/&gt;
    +            } catch (Exception e) &lt;/p&gt;
{
    +                this.getLogger().error(&quot;Failed while listenning for messages.&quot;, e);
    +                processSession.rollback();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            context.yield();
    +        }
&lt;p&gt;    +    }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private volatile SMTPServer server;&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean initialized = new AtomicBoolean(false);&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean stopping = new AtomicBoolean(false);&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @OnStopped&lt;br/&gt;
    +    public void close() 
{
    +        this.getLogger().info(&quot;Stopping SMTPServer&quot;);
    +        this.smtp.stop();
    +        this.smtp = null;
    +        this.getLogger().info(&quot;SMTPServer stopped&quot;);
    +    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
         @Override&lt;br/&gt;
         public Set&amp;lt;Relationship&amp;gt; getRelationships() &lt;/p&gt;
{
             return relationships;
         }

&lt;p&gt;    +    /**&lt;br/&gt;
    +    *&lt;br/&gt;
    +    */&lt;br/&gt;
         @Override&lt;br/&gt;
         protected List&amp;lt;PropertyDescriptor&amp;gt; getSupportedPropertyDescriptors() &lt;/p&gt;
{
             return propertyDescriptors;
         }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected void init(final ProcessorInitializationContext context) 
{
    -        final Set&amp;lt;Relationship&amp;gt; relationships = new HashSet&amp;lt;&amp;gt;();
    -        relationships.add(REL_SUCCESS);
    -        this.relationships = Collections.unmodifiableSet(relationships);
    -
    -        final List&amp;lt;PropertyDescriptor&amp;gt; props = new ArrayList&amp;lt;&amp;gt;();
    -        props.add(SMTP_PORT);
    -        props.add(SMTP_HOSTNAME);
    -        props.add(SMTP_MAXIMUM_CONNECTIONS);
    -        props.add(SMTP_TIMEOUT);
    -        props.add(SMTP_MAXIMUM_MSG_SIZE);
    -        props.add(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE);
    -        props.add(SSL_CONTEXT_SERVICE);
    -        props.add(CLIENT_AUTH);
    -        this.propertyDescriptors = Collections.unmodifiableList(props);
    -
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Upon Schedule, reset the initialized state to false&lt;/li&gt;
	&lt;li&gt;@OnScheduled&lt;/li&gt;
	&lt;li&gt;public void onScheduled(ProcessContext context) 
{
    -        initialized.set(false);
    -        stopping.set(false);
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected synchronized void initializeSMTPServer(final ProcessContext context) throws Exception {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// check if we are already running or if it is stopping&lt;/li&gt;
	&lt;li&gt;if (initialized.get() &amp;amp;&amp;amp; server.isRunning() || stopping.get() ) 
{
    -            return;
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;incomingMessages = new LinkedBlockingQueue&amp;lt;&amp;gt;(context.getProperty(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE).asInteger());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;String clientAuth = null;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// If an SSLContextService was provided then create an SSLContext to pass down to the server&lt;/li&gt;
	&lt;li&gt;SSLContext sslContext = null;&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;/li&gt;
	&lt;li&gt;if (sslContextService != null) {&lt;/li&gt;
	&lt;li&gt;clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private synchronized void setupSmtpIfNecessary(ProcessContext context, ProcessSession processSession) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +        if (this.smtp == null) {
    +            SmtpConsumer consumer = new SmtpConsumer();
    +            SMTPServer smtpServer = this.createServerInstance(context, consumer);
    +            smtpServer.setSoftwareName(&quot;Apache NiFi&quot;);
    +            smtpServer.setPort(context.getProperty(SMTP_PORT).asInteger());
    +            smtpServer.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());
    +            smtpServer.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());
    +
    +            this.smtpConsumer = consumer;
    +            this.smtp = smtpServer;
    +            this.smtp.start();
             }    +    }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SSLContext finalSslContext = sslContext;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SMTPMessageHandlerFactory smtpMessageHandlerFactory = new SMTPMessageHandlerFactory(incomingMessages, getLogger());&lt;/li&gt;
	&lt;li&gt;final SMTPServer server = new SMTPServer(smtpMessageHandlerFactory) {&lt;br/&gt;
    -&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private SMTPServer createServerInstance(ProcessContext context, SmtpConsumer consumer) {&lt;br/&gt;
    +        SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +        SMTPServer smtpServer = sslContextService == null ? new SMTPServer(consumer) : new SMTPServer(consumer) {&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public SSLSocket createSSLSocket(Socket socket) throws IOException {&lt;br/&gt;
                     InetSocketAddress remoteAddress = (InetSocketAddress) socket.getRemoteSocketAddress();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocketFactory socketFactory = finalSslContext.getSocketFactory();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocket s = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(), socket.getPort(), true));&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;s.setUseClientMode(false);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// For some reason the createSSLContext above is not enough to enforce&lt;/li&gt;
	&lt;li&gt;// client side auth&lt;/li&gt;
	&lt;li&gt;// If client auth is required...&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) {&lt;/li&gt;
	&lt;li&gt;s.setNeedClientAuth(true);&lt;br/&gt;
    +                String clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;br/&gt;
    +                SSLContext sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +                SSLSocketFactory socketFactory = sslContext.getSocketFactory();&lt;br/&gt;
    +                SSLSocket sslSocket = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(),socket.getPort(), true));&lt;br/&gt;
    +                sslSocket.setUseClientMode(false);&lt;br/&gt;
    +&lt;br/&gt;
    +                if (SSLContextService.ClientAuth.REQUIRED.toString().equals(clientAuth)) 
{
    +                    this.setRequireTLS(true);
    +                    sslSocket.setNeedClientAuth(true);
                     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return s;&lt;br/&gt;
    +                return sslSocket;&lt;br/&gt;
                 }&lt;br/&gt;
             };&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set some parameters to our server&lt;/li&gt;
	&lt;li&gt;server.setSoftwareName(&quot;Apache NiFi&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set the Server options based on properties&lt;/li&gt;
	&lt;li&gt;server.setPort(context.getProperty(SMTP_PORT).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setHostName(context.getProperty(SMTP_HOSTNAME).getValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxConnections(context.getProperty(SMTP_MAXIMUM_CONNECTIONS).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Check if TLS should be enabled&lt;br/&gt;
             if (sslContextService != null) 
{
    -            server.setEnableTLS(true);
    -        }
&lt;p&gt; else &lt;/p&gt;
{
    -            server.setHideTLS(true);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Set TLS to required in case CLIENT_AUTH = required&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) 
{
    -            server.setRequireTLS(true);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;this.server = server;&lt;/li&gt;
	&lt;li&gt;server.start();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Server started and listening on port &quot; + server.getPort());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;initialized.set(true);&lt;/li&gt;
	&lt;li&gt;stopping.set(false);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@OnUnscheduled&lt;/li&gt;
	&lt;li&gt;public void startShutdown() throws Exception {&lt;/li&gt;
	&lt;li&gt;if (server != null) {&lt;/li&gt;
	&lt;li&gt;stopping.set(true);&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Shutting down processor P{}&quot;, new Object[]
{server});&lt;br/&gt;
    -            server.stop();&lt;br/&gt;
    -            getLogger().info(&quot;Shut down {}&quot;, new Object[]{server}
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@OnStopped&lt;/li&gt;
	&lt;li&gt;public void completeShutdown() throws Exception {&lt;/li&gt;
	&lt;li&gt;if (server != null) {&lt;/li&gt;
	&lt;li&gt;if (!server.isRunning() &amp;amp;&amp;amp; stopping.get() ) 
{
    -                stopping.set(false);
    -            }&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Completed shut down {}&quot;, new Object[]
{server}
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void onTrigger(ProcessContext context, ProcessSession session) throws ProcessException {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;try 
{
    -            initializeSMTPServer(context);
    -        }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    -            context.yield();
    -            throw new ProcessException(&quot;Failed to initialize the SMTP server&quot;, e);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;while (!incomingMessages.isEmpty()) {&lt;/li&gt;
	&lt;li&gt;SmtpEvent message = incomingMessages.poll();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (message == null) 
{
    -                return;
    -            }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;synchronized (message) {&lt;/li&gt;
	&lt;li&gt;if (resultCodeSetAndIsError(message)) 
{
    -                    SMTPResultCode resultCode = SMTPResultCode.fromCode(message.getReturnCode());
    -                    getLogger().warn(&quot;Message failed before onTrigger processing message was: &quot; + resultCode.getLogMessage());
    -                    continue;
    -                }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;FlowFile flowfile = session.create();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (message.getMessageData() != null) {&lt;/li&gt;
	&lt;li&gt;flowfile = session.write(flowfile, out -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;InputStream inputStream = message.getMessageData();&lt;/li&gt;
	&lt;li&gt;byte [] buffer = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;1024&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;int rd;&lt;/li&gt;
	&lt;li&gt;long totalBytesRead =0;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;while ((rd = inputStream.read(buffer, 0, buffer.length)) != -1 ) {&lt;/li&gt;
	&lt;li&gt;totalBytesRead += rd;&lt;/li&gt;
	&lt;li&gt;if (totalBytesRead &amp;gt; server.getMaxMessageSize() ) 
{
    -                                    message.setReturnCode(500);
    -                                    message.setProcessed();
    -                                    break;
    -                                }&lt;/li&gt;
	&lt;li&gt;out.write(buffer, 0, rd);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;out.flush();&lt;/li&gt;
	&lt;li&gt;});&lt;/li&gt;
	&lt;li&gt;} else 
{
    -                        getLogger().debug(&quot;Message body was null&quot;);
    -                        message.setReturnCode(SMTPResultCode.UNKNOWN_ERROR_CODE.getCode());
    -                        message.setProcessed();
    -                    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (!message.getProcessed()) {&lt;/li&gt;
	&lt;li&gt;HashMap&amp;lt;String, String&amp;gt; attributes = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;// Gather message attributes&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_HELO, message.getHelo());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_SRC_IP, message.getHelo());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_FROM, message.getFrom());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_TO, message.getTo());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; details = message.getCertifcateDetails();&lt;/li&gt;
	&lt;li&gt;int c = 0;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Add a selection of each X509 certificates to the already gathered attributes&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;for (Map&amp;lt;String, String&amp;gt; detail : details) {&lt;/li&gt;
	&lt;li&gt;attributes.put(&quot;smtp.certificate.&quot; + c + &quot;.serial&quot;, detail.getOrDefault(&quot;SerialNumber&quot;, null));&lt;/li&gt;
	&lt;li&gt;attributes.put(&quot;smtp.certificate.&quot; + c + &quot;.subjectName&quot;, detail.getOrDefault(&quot;SubjectName&quot;, null));
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    this information cannot be safely derived by downstream processors and IMNSHO we should keep record of as part of chain of information of the data flow.&lt;/p&gt;</comment>
                            <comment id="15416393" author="githubbot" created="Thu, 11 Aug 2016 02:25:37 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362397&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362397&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -13,89 +13,52 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
    -*/&lt;br/&gt;
    + */&lt;br/&gt;
     package org.apache.nifi.processors.email;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -import javax.net.ssl.SSLContext;&lt;br/&gt;
    -import javax.net.ssl.SSLSocket;&lt;br/&gt;
    -import javax.net.ssl.SSLSocketFactory;&lt;br/&gt;
     import java.io.IOException;&lt;br/&gt;
    -import java.io.InputStream;&lt;br/&gt;
    +import java.io.OutputStream;&lt;br/&gt;
     import java.net.InetSocketAddress;&lt;br/&gt;
     import java.net.Socket;&lt;br/&gt;
     import java.util.ArrayList;&lt;br/&gt;
    -import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    -import java.util.HashMap;&lt;br/&gt;
     import java.util.HashSet;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    -import java.util.Map;&lt;br/&gt;
     import java.util.Set;&lt;br/&gt;
    -import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;
     import java.util.concurrent.TimeUnit;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnUnscheduled;&lt;br/&gt;
    -import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    -import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicInteger;&lt;/p&gt;

&lt;p&gt;    -import org.apache.nifi.annotation.lifecycle.OnScheduled;&lt;br/&gt;
    -import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    -import org.apache.nifi.processor.AbstractProcessor;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessorInitializationContext;&lt;br/&gt;
    -import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    -import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
    +import javax.net.ssl.SSLContext;&lt;br/&gt;
    +import javax.net.ssl.SSLSocket;&lt;br/&gt;
    +import javax.net.ssl.SSLSocketFactory;&lt;/p&gt;

&lt;p&gt;    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.InputRequirement;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttribute;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttributes;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.CapabilityDescription;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.Tags;&lt;br/&gt;
    +import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    +import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    +import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.AbstractSessionFactoryProcessor;&lt;br/&gt;
    +import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.Relationship;&lt;br/&gt;
     import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationContext;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationResult;&lt;br/&gt;
    -import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.io.OutputStreamCallback;&lt;br/&gt;
    +import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
     import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.event.SmtpEvent;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPResultCode;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPMessageHandlerFactory;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;/p&gt;

&lt;p&gt;     @Tags(&lt;/p&gt;
{&quot;listen&quot;, &quot;email&quot;, &quot;smtp&quot;}
&lt;p&gt;)&lt;br/&gt;
     @InputRequirement(InputRequirement.Requirement.INPUT_FORBIDDEN)&lt;br/&gt;
    -@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;allowing nifi to listen for incoming email. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Note this server does not perform any email validation. If direct exposure to the internet is sought,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;it may be a better idea to use the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
    -@WritesAttributes(
{
    -        @WritesAttribute(attribute = &quot;mime.type&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.serial&quot;, description = &quot;The serial numbers for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.principal&quot;, description = &quot;The principal for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.from&quot;, description = &quot;The value used during MAIL FROM (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.to&quot;, description = &quot;The value used during RCPT TO (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.src&quot;, description = &quot;The source IP of the SMTP connection&quot;)}
&lt;p&gt;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @olegz &lt;/p&gt;

&lt;p&gt;    I remember that conversation, however this information cannot be derived from downstream events as they are not part of the message but part of the SMTP conversation.&lt;/p&gt;

&lt;p&gt;    I works like this:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    $ telnet 0 2525&lt;br/&gt;
    Trying 0.0.0.0...&lt;br/&gt;
    Connected to 0.&lt;br/&gt;
    Escape character is &apos;^]&apos;.&lt;br/&gt;
    220 localhost ESMTP Apache NiFi&lt;br/&gt;
    helo .&lt;br/&gt;
    250 localhost&lt;br/&gt;
    mail from: aaa@aaa.com&lt;br/&gt;
    250 Ok&lt;br/&gt;
    rcpt to: bbb@bbb.com&lt;br/&gt;
    250 Ok&lt;br/&gt;
    data&lt;br/&gt;
    354 End data with &amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;.&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;br/&gt;
    From: olegz@nowhere.com&lt;br/&gt;
    To: sowhat@nowhere.com&lt;br/&gt;
    Subject: Some relevant data was missed in here&lt;br/&gt;
    Don&apos;t you think?&lt;br/&gt;
    .&lt;br/&gt;
    250 Ok&lt;br/&gt;
    quit&lt;br/&gt;
    221 Bye&lt;br/&gt;
    Connection closed by foreign host.&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    Results in:&lt;/p&gt;

&lt;p&gt;    !&lt;span class=&quot;error&quot;&gt;&amp;#91;image&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://cloud.githubusercontent.com/assets/3108527/17577223/7dd8281c-5fbe-11e6-8f6c-c5dfe075cd17.png&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://cloud.githubusercontent.com/assets/3108527/17577223/7dd8281c-5fbe-11e6-8f6c-c5dfe075cd17.png&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    Received: from . (localhost &lt;span class=&quot;error&quot;&gt;&amp;#91;127.0.0.1&amp;#93;&lt;/span&gt;)&lt;br/&gt;
            by localhost&lt;br/&gt;
            with SMTP (Apache NiFi) id IRPNED6Q&lt;br/&gt;
            for bbb@bbb.com;&lt;br/&gt;
            Thu, 11 Aug 2016 11:30:51 +1000 (AEST)&lt;br/&gt;
    From: olegz@nowhere.com&lt;br/&gt;
    To: sowhat@nowhere.com&lt;br/&gt;
    Subject: Some relevant data was missed in here&lt;br/&gt;
    Don&apos;t you think?&lt;br/&gt;
    ```&lt;/p&gt;
</comment>
                            <comment id="15416394" author="githubbot" created="Thu, 11 Aug 2016 02:26:03 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362408&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362408&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected Collection&amp;lt;ValidationResult&amp;gt; customValidate(final ValidationContext validationContext) {&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;ValidationResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +    static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;br/&gt;
    +            .name(&quot;success&quot;)&lt;br/&gt;
    +            .description(&quot;All new messages will be routed as FlowFiles to this relationship&quot;)&lt;br/&gt;
    +            .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final String clientAuth = validationContext.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = validationContext.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +    private final static List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (sslContextService != null &amp;amp;&amp;amp; StringUtils.isBlank(clientAuth)) 
{
    -            results.add(new ValidationResult.Builder()
    -                    .explanation(&quot;Client Auth must be provided when using TLS/SSL&quot;)
    -                    .valid(false).subject(&quot;Client Auth&quot;).build());
    -        }
&lt;p&gt;    +    private final static Set&amp;lt;Relationship&amp;gt; relationships;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return results;&lt;br/&gt;
    +    static 
{
    +        List&amp;lt;PropertyDescriptor&amp;gt; _propertyDescriptors = new ArrayList&amp;lt;&amp;gt;();
    +        _propertyDescriptors.add(SMTP_PORT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_CONNECTIONS);
    +        _propertyDescriptors.add(SMTP_TIMEOUT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_MSG_SIZE);
    +        _propertyDescriptors.add(SSL_CONTEXT_SERVICE);
    +        _propertyDescriptors.add(CLIENT_AUTH);
    +        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);
     
    +        Set&amp;lt;Relationship&amp;gt; _relationships = new HashSet&amp;lt;&amp;gt;();
    +        _relationships.add(REL_SUCCESS);
    +        relationships = Collections.unmodifiableSet(_relationships);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    private volatile SMTPServer smtp;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;success&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;Extraction was successful&quot;)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    +    private volatile SmtpConsumer smtpConsumer;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private Set&amp;lt;Relationship&amp;gt; relationships;&lt;/li&gt;
	&lt;li&gt;private List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
	&lt;li&gt;private volatile LinkedBlockingQueue&amp;lt;SmtpEvent&amp;gt; incomingMessages;&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public void onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) throws ProcessException {&lt;br/&gt;
    +        ProcessSession processSession = sessionFactory.createSession();&lt;br/&gt;
    +        if (this.smtp == null) 
{
    +            this.setupSmtpIfNecessary(context, processSession);
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        if (this.smtpConsumer.hasMessage()) {&lt;br/&gt;
    +            try {&lt;br/&gt;
    +                /*&lt;br/&gt;
    +                 * Will consume incoming message directly from the wire and into&lt;br/&gt;
    +                 * FlowFile/Content repository before exiting. This essentially&lt;br/&gt;
    +                 * limits any potential data loss by allowing SMTPServer thread&lt;br/&gt;
    +                 * to actually commit NiFi session if all good. However in the&lt;br/&gt;
    +                 * event of exception, such exception will be propagated back to&lt;br/&gt;
    +                 * the email sender via &quot;undeliverable message&quot; allowing such&lt;br/&gt;
    +                 * user to re-send the message&lt;br/&gt;
    +                 */&lt;br/&gt;
    +                this.smtpConsumer.consumeUsing((inputDataStream) -&amp;gt; {&lt;br/&gt;
    +                    FlowFile flowFile = processSession.create();&lt;br/&gt;
    +                    AtomicInteger size = new AtomicInteger();&lt;br/&gt;
    +                    flowFile = processSession.write(flowFile, new OutputStreamCallback() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                        @Override    +                        public void process(final OutputStream out) throws IOException {
    +                            size.set(IOUtils.copy(inputDataStream, out));
    +                        }    +                    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +                    processSession.getProvenanceReporter().receive(flowFile, &quot;smtp://&quot;&lt;br/&gt;
    +                            + ListenSMTP.this.smtp.getHostName() + &quot;:&quot; + ListenSMTP.this.smtp.getPort() + &quot;/&quot;);&lt;br/&gt;
    +                    processSession.transfer(flowFile, REL_SUCCESS);&lt;br/&gt;
    +                    processSession.commit();&lt;br/&gt;
    +                    return size.get();&lt;br/&gt;
    +                });&lt;br/&gt;
    +            } catch (Exception e) &lt;/p&gt;
{
    +                this.getLogger().error(&quot;Failed while listenning for messages.&quot;, e);
    +                processSession.rollback();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            context.yield();
    +        }
&lt;p&gt;    +    }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private volatile SMTPServer server;&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean initialized = new AtomicBoolean(false);&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean stopping = new AtomicBoolean(false);&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @OnStopped&lt;br/&gt;
    +    public void close() 
{
    +        this.getLogger().info(&quot;Stopping SMTPServer&quot;);
    +        this.smtp.stop();
    +        this.smtp = null;
    +        this.getLogger().info(&quot;SMTPServer stopped&quot;);
    +    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
         @Override&lt;br/&gt;
         public Set&amp;lt;Relationship&amp;gt; getRelationships() &lt;/p&gt;
{
             return relationships;
         }

&lt;p&gt;    +    /**&lt;br/&gt;
    +    *&lt;br/&gt;
    +    */&lt;br/&gt;
         @Override&lt;br/&gt;
         protected List&amp;lt;PropertyDescriptor&amp;gt; getSupportedPropertyDescriptors() &lt;/p&gt;
{
             return propertyDescriptors;
         }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected void init(final ProcessorInitializationContext context) 
{
    -        final Set&amp;lt;Relationship&amp;gt; relationships = new HashSet&amp;lt;&amp;gt;();
    -        relationships.add(REL_SUCCESS);
    -        this.relationships = Collections.unmodifiableSet(relationships);
    -
    -        final List&amp;lt;PropertyDescriptor&amp;gt; props = new ArrayList&amp;lt;&amp;gt;();
    -        props.add(SMTP_PORT);
    -        props.add(SMTP_HOSTNAME);
    -        props.add(SMTP_MAXIMUM_CONNECTIONS);
    -        props.add(SMTP_TIMEOUT);
    -        props.add(SMTP_MAXIMUM_MSG_SIZE);
    -        props.add(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE);
    -        props.add(SSL_CONTEXT_SERVICE);
    -        props.add(CLIENT_AUTH);
    -        this.propertyDescriptors = Collections.unmodifiableList(props);
    -
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Upon Schedule, reset the initialized state to false&lt;/li&gt;
	&lt;li&gt;@OnScheduled&lt;/li&gt;
	&lt;li&gt;public void onScheduled(ProcessContext context) 
{
    -        initialized.set(false);
    -        stopping.set(false);
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected synchronized void initializeSMTPServer(final ProcessContext context) throws Exception {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// check if we are already running or if it is stopping&lt;/li&gt;
	&lt;li&gt;if (initialized.get() &amp;amp;&amp;amp; server.isRunning() || stopping.get() ) 
{
    -            return;
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;incomingMessages = new LinkedBlockingQueue&amp;lt;&amp;gt;(context.getProperty(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE).asInteger());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;String clientAuth = null;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// If an SSLContextService was provided then create an SSLContext to pass down to the server&lt;/li&gt;
	&lt;li&gt;SSLContext sslContext = null;&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;/li&gt;
	&lt;li&gt;if (sslContextService != null) {&lt;/li&gt;
	&lt;li&gt;clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private synchronized void setupSmtpIfNecessary(ProcessContext context, ProcessSession processSession) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +        if (this.smtp == null) {
    +            SmtpConsumer consumer = new SmtpConsumer();
    +            SMTPServer smtpServer = this.createServerInstance(context, consumer);
    +            smtpServer.setSoftwareName(&quot;Apache NiFi&quot;);
    +            smtpServer.setPort(context.getProperty(SMTP_PORT).asInteger());
    +            smtpServer.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());
    +            smtpServer.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());
    +
    +            this.smtpConsumer = consumer;
    +            this.smtp = smtpServer;
    +            this.smtp.start();
             }    +    }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SSLContext finalSslContext = sslContext;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SMTPMessageHandlerFactory smtpMessageHandlerFactory = new SMTPMessageHandlerFactory(incomingMessages, getLogger());&lt;/li&gt;
	&lt;li&gt;final SMTPServer server = new SMTPServer(smtpMessageHandlerFactory) {&lt;br/&gt;
    -&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private SMTPServer createServerInstance(ProcessContext context, SmtpConsumer consumer) {&lt;br/&gt;
    +        SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +        SMTPServer smtpServer = sslContextService == null ? new SMTPServer(consumer) : new SMTPServer(consumer) {&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public SSLSocket createSSLSocket(Socket socket) throws IOException {&lt;br/&gt;
                     InetSocketAddress remoteAddress = (InetSocketAddress) socket.getRemoteSocketAddress();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocketFactory socketFactory = finalSslContext.getSocketFactory();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocket s = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(), socket.getPort(), true));&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;s.setUseClientMode(false);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// For some reason the createSSLContext above is not enough to enforce&lt;/li&gt;
	&lt;li&gt;// client side auth&lt;/li&gt;
	&lt;li&gt;// If client auth is required...&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) {&lt;/li&gt;
	&lt;li&gt;s.setNeedClientAuth(true);&lt;br/&gt;
    +                String clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;br/&gt;
    +                SSLContext sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +                SSLSocketFactory socketFactory = sslContext.getSocketFactory();&lt;br/&gt;
    +                SSLSocket sslSocket = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(),socket.getPort(), true));&lt;br/&gt;
    +                sslSocket.setUseClientMode(false);&lt;br/&gt;
    +&lt;br/&gt;
    +                if (SSLContextService.ClientAuth.REQUIRED.toString().equals(clientAuth)) 
{
    +                    this.setRequireTLS(true);
    +                    sslSocket.setNeedClientAuth(true);
                     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return s;&lt;br/&gt;
    +                return sslSocket;&lt;br/&gt;
                 }&lt;br/&gt;
             };&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set some parameters to our server&lt;/li&gt;
	&lt;li&gt;server.setSoftwareName(&quot;Apache NiFi&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set the Server options based on properties&lt;/li&gt;
	&lt;li&gt;server.setPort(context.getProperty(SMTP_PORT).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setHostName(context.getProperty(SMTP_HOSTNAME).getValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxConnections(context.getProperty(SMTP_MAXIMUM_CONNECTIONS).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Check if TLS should be enabled&lt;br/&gt;
             if (sslContextService != null) 
{
    -            server.setEnableTLS(true);
    -        }
&lt;p&gt; else &lt;/p&gt;
{
    -            server.setHideTLS(true);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Set TLS to required in case CLIENT_AUTH = required&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) 
{
    -            server.setRequireTLS(true);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;this.server = server;&lt;/li&gt;
	&lt;li&gt;server.start();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Server started and listening on port &quot; + server.getPort());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;initialized.set(true);&lt;/li&gt;
	&lt;li&gt;stopping.set(false);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@OnUnscheduled&lt;/li&gt;
	&lt;li&gt;public void startShutdown() throws Exception {&lt;/li&gt;
	&lt;li&gt;if (server != null) {&lt;/li&gt;
	&lt;li&gt;stopping.set(true);&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Shutting down processor P{}&quot;, new Object[]
{server});&lt;br/&gt;
    -            server.stop();&lt;br/&gt;
    -            getLogger().info(&quot;Shut down {}&quot;, new Object[]{server}
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@OnStopped&lt;/li&gt;
	&lt;li&gt;public void completeShutdown() throws Exception {&lt;/li&gt;
	&lt;li&gt;if (server != null) {&lt;/li&gt;
	&lt;li&gt;if (!server.isRunning() &amp;amp;&amp;amp; stopping.get() ) 
{
    -                stopping.set(false);
    -            }&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Completed shut down {}&quot;, new Object[]
{server}
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void onTrigger(ProcessContext context, ProcessSession session) throws ProcessException {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;try 
{
    -            initializeSMTPServer(context);
    -        }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    -            context.yield();
    -            throw new ProcessException(&quot;Failed to initialize the SMTP server&quot;, e);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;while (!incomingMessages.isEmpty()) {&lt;/li&gt;
	&lt;li&gt;SmtpEvent message = incomingMessages.poll();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (message == null) 
{
    -                return;
    -            }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;synchronized (message) {&lt;/li&gt;
	&lt;li&gt;if (resultCodeSetAndIsError(message)) 
{
    -                    SMTPResultCode resultCode = SMTPResultCode.fromCode(message.getReturnCode());
    -                    getLogger().warn(&quot;Message failed before onTrigger processing message was: &quot; + resultCode.getLogMessage());
    -                    continue;
    -                }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;FlowFile flowfile = session.create();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (message.getMessageData() != null) {&lt;/li&gt;
	&lt;li&gt;flowfile = session.write(flowfile, out -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;InputStream inputStream = message.getMessageData();&lt;/li&gt;
	&lt;li&gt;byte [] buffer = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;1024&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;int rd;&lt;/li&gt;
	&lt;li&gt;long totalBytesRead =0;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;while ((rd = inputStream.read(buffer, 0, buffer.length)) != -1 ) {&lt;/li&gt;
	&lt;li&gt;totalBytesRead += rd;&lt;/li&gt;
	&lt;li&gt;if (totalBytesRead &amp;gt; server.getMaxMessageSize() ) 
{
    -                                    message.setReturnCode(500);
    -                                    message.setProcessed();
    -                                    break;
    -                                }&lt;/li&gt;
	&lt;li&gt;out.write(buffer, 0, rd);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;out.flush();&lt;/li&gt;
	&lt;li&gt;});&lt;/li&gt;
	&lt;li&gt;} else 
{
    -                        getLogger().debug(&quot;Message body was null&quot;);
    -                        message.setReturnCode(SMTPResultCode.UNKNOWN_ERROR_CODE.getCode());
    -                        message.setProcessed();
    -                    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (!message.getProcessed()) {&lt;/li&gt;
	&lt;li&gt;HashMap&amp;lt;String, String&amp;gt; attributes = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;// Gather message attributes&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_HELO, message.getHelo());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_SRC_IP, message.getHelo());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_FROM, message.getFrom());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_TO, message.getTo());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; details = message.getCertifcateDetails();&lt;/li&gt;
	&lt;li&gt;int c = 0;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Add a selection of each X509 certificates to the already gathered attributes&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;for (Map&amp;lt;String, String&amp;gt; detail : details) {&lt;/li&gt;
	&lt;li&gt;attributes.put(&quot;smtp.certificate.&quot; + c + &quot;.serial&quot;, detail.getOrDefault(&quot;SerialNumber&quot;, null));&lt;/li&gt;
	&lt;li&gt;attributes.put(&quot;smtp.certificate.&quot; + c + &quot;.subjectName&quot;, detail.getOrDefault(&quot;SubjectName&quot;, null));
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Not necessarily against it, but could you elaborate some more on the problem we are trying to solve here primarily from practical standpoint?&lt;br/&gt;
    Just so you understand, as initial implementation of the processor (any processor) the idea is to keep it as simple as we can, to provide basic functionality that is usable yet may require some improvements and additional features. Those are very easy to add. However keep in mind that removing features is practically impossible as it always results in breaking backward compatibility, so unless it is essential I would rather defer it to he future until we have a solid and practical use case rather then stick it in there &quot;just in case&quot; and then finding an issue with that in the future and face the difficult decision of backward compatibility especially when dealing with file attributes. &lt;/p&gt;
</comment>
                            <comment id="15416396" author="githubbot" created="Thu, 11 Aug 2016 02:29:15 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362552&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362552&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -13,89 +13,52 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
    -*/&lt;br/&gt;
    + */&lt;br/&gt;
     package org.apache.nifi.processors.email;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -import javax.net.ssl.SSLContext;&lt;br/&gt;
    -import javax.net.ssl.SSLSocket;&lt;br/&gt;
    -import javax.net.ssl.SSLSocketFactory;&lt;br/&gt;
     import java.io.IOException;&lt;br/&gt;
    -import java.io.InputStream;&lt;br/&gt;
    +import java.io.OutputStream;&lt;br/&gt;
     import java.net.InetSocketAddress;&lt;br/&gt;
     import java.net.Socket;&lt;br/&gt;
     import java.util.ArrayList;&lt;br/&gt;
    -import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    -import java.util.HashMap;&lt;br/&gt;
     import java.util.HashSet;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    -import java.util.Map;&lt;br/&gt;
     import java.util.Set;&lt;br/&gt;
    -import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;
     import java.util.concurrent.TimeUnit;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnUnscheduled;&lt;br/&gt;
    -import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    -import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicInteger;&lt;/p&gt;

&lt;p&gt;    -import org.apache.nifi.annotation.lifecycle.OnScheduled;&lt;br/&gt;
    -import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    -import org.apache.nifi.processor.AbstractProcessor;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessorInitializationContext;&lt;br/&gt;
    -import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    -import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
    +import javax.net.ssl.SSLContext;&lt;br/&gt;
    +import javax.net.ssl.SSLSocket;&lt;br/&gt;
    +import javax.net.ssl.SSLSocketFactory;&lt;/p&gt;

&lt;p&gt;    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.InputRequirement;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttribute;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttributes;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.CapabilityDescription;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.Tags;&lt;br/&gt;
    +import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    +import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    +import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.AbstractSessionFactoryProcessor;&lt;br/&gt;
    +import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.Relationship;&lt;br/&gt;
     import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationContext;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationResult;&lt;br/&gt;
    -import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.io.OutputStreamCallback;&lt;br/&gt;
    +import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
     import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.event.SmtpEvent;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPResultCode;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPMessageHandlerFactory;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;/p&gt;

&lt;p&gt;     @Tags(&lt;/p&gt;
{&quot;listen&quot;, &quot;email&quot;, &quot;smtp&quot;}
&lt;p&gt;)&lt;br/&gt;
     @InputRequirement(InputRequirement.Requirement.INPUT_FORBIDDEN)&lt;br/&gt;
    -@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;allowing nifi to listen for incoming email. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Note this server does not perform any email validation. If direct exposure to the internet is sought,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;it may be a better idea to use the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
    -@WritesAttributes(
{
    -        @WritesAttribute(attribute = &quot;mime.type&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.serial&quot;, description = &quot;The serial numbers for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.principal&quot;, description = &quot;The principal for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.from&quot;, description = &quot;The value used during MAIL FROM (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.to&quot;, description = &quot;The value used during RCPT TO (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.src&quot;, description = &quot;The source IP of the SMTP connection&quot;)}
&lt;p&gt;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As I just mentioned in the previous moment, adding things in the future is possible, removing is not. So I&apos;d like to know (outside of &quot;just in case&quot;) practical implication of those attributes to justify having them now. Also, the to/from/and few others can be derived from message.  &lt;/p&gt;</comment>
                            <comment id="15416398" author="githubbot" created="Thu, 11 Aug 2016 02:30:38 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362612&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362612&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -13,89 +13,52 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
    -*/&lt;br/&gt;
    + */&lt;br/&gt;
     package org.apache.nifi.processors.email;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -import javax.net.ssl.SSLContext;&lt;br/&gt;
    -import javax.net.ssl.SSLSocket;&lt;br/&gt;
    -import javax.net.ssl.SSLSocketFactory;&lt;br/&gt;
     import java.io.IOException;&lt;br/&gt;
    -import java.io.InputStream;&lt;br/&gt;
    +import java.io.OutputStream;&lt;br/&gt;
     import java.net.InetSocketAddress;&lt;br/&gt;
     import java.net.Socket;&lt;br/&gt;
     import java.util.ArrayList;&lt;br/&gt;
    -import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    -import java.util.HashMap;&lt;br/&gt;
     import java.util.HashSet;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    -import java.util.Map;&lt;br/&gt;
     import java.util.Set;&lt;br/&gt;
    -import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;
     import java.util.concurrent.TimeUnit;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnUnscheduled;&lt;br/&gt;
    -import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    -import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicInteger;&lt;/p&gt;

&lt;p&gt;    -import org.apache.nifi.annotation.lifecycle.OnScheduled;&lt;br/&gt;
    -import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    -import org.apache.nifi.processor.AbstractProcessor;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessorInitializationContext;&lt;br/&gt;
    -import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    -import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
    +import javax.net.ssl.SSLContext;&lt;br/&gt;
    +import javax.net.ssl.SSLSocket;&lt;br/&gt;
    +import javax.net.ssl.SSLSocketFactory;&lt;/p&gt;

&lt;p&gt;    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.InputRequirement;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttribute;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttributes;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.CapabilityDescription;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.Tags;&lt;br/&gt;
    +import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    +import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    +import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.AbstractSessionFactoryProcessor;&lt;br/&gt;
    +import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.Relationship;&lt;br/&gt;
     import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationContext;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationResult;&lt;br/&gt;
    -import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.io.OutputStreamCallback;&lt;br/&gt;
    +import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
     import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.event.SmtpEvent;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPResultCode;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPMessageHandlerFactory;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;/p&gt;

&lt;p&gt;     @Tags(&lt;/p&gt;
{&quot;listen&quot;, &quot;email&quot;, &quot;smtp&quot;}
&lt;p&gt;)&lt;br/&gt;
     @InputRequirement(InputRequirement.Requirement.INPUT_FORBIDDEN)&lt;br/&gt;
    -@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;allowing nifi to listen for incoming email. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Note this server does not perform any email validation. If direct exposure to the internet is sought,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;it may be a better idea to use the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
    -@WritesAttributes(
{
    -        @WritesAttribute(attribute = &quot;mime.type&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.serial&quot;, description = &quot;The serial numbers for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.principal&quot;, description = &quot;The principal for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.from&quot;, description = &quot;The value used during MAIL FROM (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.to&quot;, description = &quot;The value used during RCPT TO (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.src&quot;, description = &quot;The source IP of the SMTP connection&quot;)}
&lt;p&gt;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    See how the original MAIL FROM data is fully lost while the rest now needs to be processed via RegEx to the detriment of the user?&lt;/p&gt;

&lt;p&gt;    RFC-2822 clearly distinguishes the nature of both sets of data, reason while nearly every single SMTP server will provide you with the option of logging the details provided during the SMTP exchange (envelope), while mail parsers will usually look into the Headers of the message (EmailExtractHeaders does that) &lt;/p&gt;

&lt;p&gt;    &amp;gt; &lt;br/&gt;
    &amp;gt;       MAIL FROM:&amp;lt;&amp;gt;&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt;    As discussed in section 2.4.1, a relay SMTP has no need to inspect or&lt;br/&gt;
    &amp;gt;    act upon the headers or body of the message data and MUST NOT do so&lt;br/&gt;
    &amp;gt;    except to add its own &quot;Received:&quot; header (section 4.4) and,&lt;br/&gt;
    &amp;gt;    optionally, to attempt to detect looping in the mail system (see&lt;br/&gt;
    &amp;gt;    section 6.2).&lt;br/&gt;
    &amp;gt; &lt;/p&gt;</comment>
                            <comment id="15416402" author="githubbot" created="Thu, 11 Aug 2016 02:32:00 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362680&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362680&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Because I may have a system using AWS&apos;s weird naming structures but look to display a fancy name like mx.trixpanmailservices.com&lt;/p&gt;

</comment>
                            <comment id="15416403" author="githubbot" created="Thu, 11 Aug 2016 02:32:37 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362705&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362705&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Sorry not used to post comments. But yes, custom validator. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15416409" author="githubbot" created="Thu, 11 Aug 2016 02:36:22 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362870&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362870&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -13,89 +13,52 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
    -*/&lt;br/&gt;
    + */&lt;br/&gt;
     package org.apache.nifi.processors.email;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -import javax.net.ssl.SSLContext;&lt;br/&gt;
    -import javax.net.ssl.SSLSocket;&lt;br/&gt;
    -import javax.net.ssl.SSLSocketFactory;&lt;br/&gt;
     import java.io.IOException;&lt;br/&gt;
    -import java.io.InputStream;&lt;br/&gt;
    +import java.io.OutputStream;&lt;br/&gt;
     import java.net.InetSocketAddress;&lt;br/&gt;
     import java.net.Socket;&lt;br/&gt;
     import java.util.ArrayList;&lt;br/&gt;
    -import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    -import java.util.HashMap;&lt;br/&gt;
     import java.util.HashSet;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    -import java.util.Map;&lt;br/&gt;
     import java.util.Set;&lt;br/&gt;
    -import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;
     import java.util.concurrent.TimeUnit;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnUnscheduled;&lt;br/&gt;
    -import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    -import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicInteger;&lt;/p&gt;

&lt;p&gt;    -import org.apache.nifi.annotation.lifecycle.OnScheduled;&lt;br/&gt;
    -import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    -import org.apache.nifi.processor.AbstractProcessor;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessorInitializationContext;&lt;br/&gt;
    -import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    -import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
    +import javax.net.ssl.SSLContext;&lt;br/&gt;
    +import javax.net.ssl.SSLSocket;&lt;br/&gt;
    +import javax.net.ssl.SSLSocketFactory;&lt;/p&gt;

&lt;p&gt;    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.InputRequirement;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttribute;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttributes;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.CapabilityDescription;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.Tags;&lt;br/&gt;
    +import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    +import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    +import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.AbstractSessionFactoryProcessor;&lt;br/&gt;
    +import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.Relationship;&lt;br/&gt;
     import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationContext;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationResult;&lt;br/&gt;
    -import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.io.OutputStreamCallback;&lt;br/&gt;
    +import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
     import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.event.SmtpEvent;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPResultCode;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPMessageHandlerFactory;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;/p&gt;

&lt;p&gt;     @Tags(&lt;/p&gt;
{&quot;listen&quot;, &quot;email&quot;, &quot;smtp&quot;}
&lt;p&gt;)&lt;br/&gt;
     @InputRequirement(InputRequirement.Requirement.INPUT_FORBIDDEN)&lt;br/&gt;
    -@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;allowing nifi to listen for incoming email. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Note this server does not perform any email validation. If direct exposure to the internet is sought,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;it may be a better idea to use the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
    -@WritesAttributes(
{
    -        @WritesAttribute(attribute = &quot;mime.type&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.serial&quot;, description = &quot;The serial numbers for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.principal&quot;, description = &quot;The principal for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.from&quot;, description = &quot;The value used during MAIL FROM (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.to&quot;, description = &quot;The value used during RCPT TO (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.src&quot;, description = &quot;The source IP of the SMTP connection&quot;)}
&lt;p&gt;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Again, I am not against it, but outside of &quot;nice to have&quot; i don&apos;t see practical justification for it. &lt;br/&gt;
    Remember, the idea here is not to implement a fully capable SMTP server, if so we would need a separate project just for that. The idea is to have a simple network listener that is capable of speaking SMTP. For anything more complex use an existing/external/secure/managed/monitored Email server and connect to it via IMAP/POP3 etc. &lt;/p&gt;</comment>
                            <comment id="15416410" author="githubbot" created="Thu, 11 Aug 2016 02:37:40 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Perhaps I am not fully in line with that due to not fully understanding it, but if it&apos;s only used for &quot;display&quot; I am ok with putting it back in. Please confirm&lt;/p&gt;</comment>
                            <comment id="15416411" author="githubbot" created="Thu, 11 Aug 2016 02:38:02 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362947&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362947&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Will put it back&lt;/p&gt;</comment>
                            <comment id="15416413" author="githubbot" created="Thu, 11 Aug 2016 02:38:11 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362949&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362949&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -13,89 +13,52 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
    -*/&lt;br/&gt;
    + */&lt;br/&gt;
     package org.apache.nifi.processors.email;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -import javax.net.ssl.SSLContext;&lt;br/&gt;
    -import javax.net.ssl.SSLSocket;&lt;br/&gt;
    -import javax.net.ssl.SSLSocketFactory;&lt;br/&gt;
     import java.io.IOException;&lt;br/&gt;
    -import java.io.InputStream;&lt;br/&gt;
    +import java.io.OutputStream;&lt;br/&gt;
     import java.net.InetSocketAddress;&lt;br/&gt;
     import java.net.Socket;&lt;br/&gt;
     import java.util.ArrayList;&lt;br/&gt;
    -import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    -import java.util.HashMap;&lt;br/&gt;
     import java.util.HashSet;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    -import java.util.Map;&lt;br/&gt;
     import java.util.Set;&lt;br/&gt;
    -import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;
     import java.util.concurrent.TimeUnit;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnUnscheduled;&lt;br/&gt;
    -import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    -import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicInteger;&lt;/p&gt;

&lt;p&gt;    -import org.apache.nifi.annotation.lifecycle.OnScheduled;&lt;br/&gt;
    -import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    -import org.apache.nifi.processor.AbstractProcessor;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessorInitializationContext;&lt;br/&gt;
    -import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    -import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
    +import javax.net.ssl.SSLContext;&lt;br/&gt;
    +import javax.net.ssl.SSLSocket;&lt;br/&gt;
    +import javax.net.ssl.SSLSocketFactory;&lt;/p&gt;

&lt;p&gt;    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.InputRequirement;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttribute;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttributes;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.CapabilityDescription;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.Tags;&lt;br/&gt;
    +import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    +import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    +import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.AbstractSessionFactoryProcessor;&lt;br/&gt;
    +import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.Relationship;&lt;br/&gt;
     import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationContext;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationResult;&lt;br/&gt;
    -import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.io.OutputStreamCallback;&lt;br/&gt;
    +import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
     import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.event.SmtpEvent;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPResultCode;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPMessageHandlerFactory;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;/p&gt;

&lt;p&gt;     @Tags(&lt;/p&gt;
{&quot;listen&quot;, &quot;email&quot;, &quot;smtp&quot;}
&lt;p&gt;)&lt;br/&gt;
     @InputRequirement(InputRequirement.Requirement.INPUT_FORBIDDEN)&lt;br/&gt;
    -@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;allowing nifi to listen for incoming email. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Note this server does not perform any email validation. If direct exposure to the internet is sought,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;it may be a better idea to use the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
    -@WritesAttributes(
{
    -        @WritesAttribute(attribute = &quot;mime.type&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.serial&quot;, description = &quot;The serial numbers for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.principal&quot;, description = &quot;The principal for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.from&quot;, description = &quot;The value used during MAIL FROM (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.to&quot;, description = &quot;The value used during RCPT TO (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.src&quot;, description = &quot;The source IP of the SMTP connection&quot;)}
&lt;p&gt;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @olegz: Yes, there a concrete reason, we already use it together with QueryDNS to implement RBL on NiFi. &lt;/p&gt;

&lt;p&gt;    ListenSMTP -&amp;gt; (with from IP) -&amp;gt; QueryDNS does DNS lookup to RBL -&amp;gt; RouteonAttribute&lt;/p&gt;</comment>
                            <comment id="15416418" author="githubbot" created="Thu, 11 Aug 2016 02:43:49 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74363178&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74363178&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @olegz yes it is just for display. It essentially was put in place to prevent servers from exposing names that the dataflow creator may prefer to omit. &lt;/p&gt;

&lt;p&gt;    There are other use cases tho:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Load balanced SMTP instances&lt;/li&gt;
	&lt;li&gt;Shared TLS certificates (where TLS validation is used from the sending MTA side)&lt;/li&gt;
	&lt;li&gt;&quot;Please don&apos;t share my internal hostnames&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    and so on&lt;/p&gt;</comment>
                            <comment id="15416420" author="githubbot" created="Thu, 11 Aug 2016 02:44:50 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74363226&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74363226&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Got it&lt;/p&gt;</comment>
                            <comment id="15416426" author="githubbot" created="Thu, 11 Aug 2016 02:50:04 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74363458&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74363458&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected Collection&amp;lt;ValidationResult&amp;gt; customValidate(final ValidationContext validationContext) {&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;ValidationResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +    static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;br/&gt;
    +            .name(&quot;success&quot;)&lt;br/&gt;
    +            .description(&quot;All new messages will be routed as FlowFiles to this relationship&quot;)&lt;br/&gt;
    +            .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final String clientAuth = validationContext.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = validationContext.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +    private final static List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (sslContextService != null &amp;amp;&amp;amp; StringUtils.isBlank(clientAuth)) 
{
    -            results.add(new ValidationResult.Builder()
    -                    .explanation(&quot;Client Auth must be provided when using TLS/SSL&quot;)
    -                    .valid(false).subject(&quot;Client Auth&quot;).build());
    -        }
&lt;p&gt;    +    private final static Set&amp;lt;Relationship&amp;gt; relationships;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return results;&lt;br/&gt;
    +    static 
{
    +        List&amp;lt;PropertyDescriptor&amp;gt; _propertyDescriptors = new ArrayList&amp;lt;&amp;gt;();
    +        _propertyDescriptors.add(SMTP_PORT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_CONNECTIONS);
    +        _propertyDescriptors.add(SMTP_TIMEOUT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_MSG_SIZE);
    +        _propertyDescriptors.add(SSL_CONTEXT_SERVICE);
    +        _propertyDescriptors.add(CLIENT_AUTH);
    +        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);
     
    +        Set&amp;lt;Relationship&amp;gt; _relationships = new HashSet&amp;lt;&amp;gt;();
    +        _relationships.add(REL_SUCCESS);
    +        relationships = Collections.unmodifiableSet(_relationships);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    private volatile SMTPServer smtp;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;success&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;Extraction was successful&quot;)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    +    private volatile SmtpConsumer smtpConsumer;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private Set&amp;lt;Relationship&amp;gt; relationships;&lt;/li&gt;
	&lt;li&gt;private List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
	&lt;li&gt;private volatile LinkedBlockingQueue&amp;lt;SmtpEvent&amp;gt; incomingMessages;&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public void onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) throws ProcessException {&lt;br/&gt;
    +        ProcessSession processSession = sessionFactory.createSession();&lt;br/&gt;
    +        if (this.smtp == null) 
{
    +            this.setupSmtpIfNecessary(context, processSession);
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        if (this.smtpConsumer.hasMessage()) {&lt;br/&gt;
    +            try {&lt;br/&gt;
    +                /*&lt;br/&gt;
    +                 * Will consume incoming message directly from the wire and into&lt;br/&gt;
    +                 * FlowFile/Content repository before exiting. This essentially&lt;br/&gt;
    +                 * limits any potential data loss by allowing SMTPServer thread&lt;br/&gt;
    +                 * to actually commit NiFi session if all good. However in the&lt;br/&gt;
    +                 * event of exception, such exception will be propagated back to&lt;br/&gt;
    +                 * the email sender via &quot;undeliverable message&quot; allowing such&lt;br/&gt;
    +                 * user to re-send the message&lt;br/&gt;
    +                 */&lt;br/&gt;
    +                this.smtpConsumer.consumeUsing((inputDataStream) -&amp;gt; {&lt;br/&gt;
    +                    FlowFile flowFile = processSession.create();&lt;br/&gt;
    +                    AtomicInteger size = new AtomicInteger();&lt;br/&gt;
    +                    flowFile = processSession.write(flowFile, new OutputStreamCallback() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                        @Override    +                        public void process(final OutputStream out) throws IOException {
    +                            size.set(IOUtils.copy(inputDataStream, out));
    +                        }    +                    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +                    processSession.getProvenanceReporter().receive(flowFile, &quot;smtp://&quot;&lt;br/&gt;
    +                            + ListenSMTP.this.smtp.getHostName() + &quot;:&quot; + ListenSMTP.this.smtp.getPort() + &quot;/&quot;);&lt;br/&gt;
    +                    processSession.transfer(flowFile, REL_SUCCESS);&lt;br/&gt;
    +                    processSession.commit();&lt;br/&gt;
    +                    return size.get();&lt;br/&gt;
    +                });&lt;br/&gt;
    +            } catch (Exception e) &lt;/p&gt;
{
    +                this.getLogger().error(&quot;Failed while listenning for messages.&quot;, e);
    +                processSession.rollback();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            context.yield();
    +        }
&lt;p&gt;    +    }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private volatile SMTPServer server;&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean initialized = new AtomicBoolean(false);&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean stopping = new AtomicBoolean(false);&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @OnStopped&lt;br/&gt;
    +    public void close() 
{
    +        this.getLogger().info(&quot;Stopping SMTPServer&quot;);
    +        this.smtp.stop();
    +        this.smtp = null;
    +        this.getLogger().info(&quot;SMTPServer stopped&quot;);
    +    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
         @Override&lt;br/&gt;
         public Set&amp;lt;Relationship&amp;gt; getRelationships() &lt;/p&gt;
{
             return relationships;
         }

&lt;p&gt;    +    /**&lt;br/&gt;
    +    *&lt;br/&gt;
    +    */&lt;br/&gt;
         @Override&lt;br/&gt;
         protected List&amp;lt;PropertyDescriptor&amp;gt; getSupportedPropertyDescriptors() &lt;/p&gt;
{
             return propertyDescriptors;
         }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected void init(final ProcessorInitializationContext context) 
{
    -        final Set&amp;lt;Relationship&amp;gt; relationships = new HashSet&amp;lt;&amp;gt;();
    -        relationships.add(REL_SUCCESS);
    -        this.relationships = Collections.unmodifiableSet(relationships);
    -
    -        final List&amp;lt;PropertyDescriptor&amp;gt; props = new ArrayList&amp;lt;&amp;gt;();
    -        props.add(SMTP_PORT);
    -        props.add(SMTP_HOSTNAME);
    -        props.add(SMTP_MAXIMUM_CONNECTIONS);
    -        props.add(SMTP_TIMEOUT);
    -        props.add(SMTP_MAXIMUM_MSG_SIZE);
    -        props.add(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE);
    -        props.add(SSL_CONTEXT_SERVICE);
    -        props.add(CLIENT_AUTH);
    -        this.propertyDescriptors = Collections.unmodifiableList(props);
    -
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Upon Schedule, reset the initialized state to false&lt;/li&gt;
	&lt;li&gt;@OnScheduled&lt;/li&gt;
	&lt;li&gt;public void onScheduled(ProcessContext context) 
{
    -        initialized.set(false);
    -        stopping.set(false);
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected synchronized void initializeSMTPServer(final ProcessContext context) throws Exception {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// check if we are already running or if it is stopping&lt;/li&gt;
	&lt;li&gt;if (initialized.get() &amp;amp;&amp;amp; server.isRunning() || stopping.get() ) 
{
    -            return;
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;incomingMessages = new LinkedBlockingQueue&amp;lt;&amp;gt;(context.getProperty(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE).asInteger());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;String clientAuth = null;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// If an SSLContextService was provided then create an SSLContext to pass down to the server&lt;/li&gt;
	&lt;li&gt;SSLContext sslContext = null;&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;/li&gt;
	&lt;li&gt;if (sslContextService != null) {&lt;/li&gt;
	&lt;li&gt;clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private synchronized void setupSmtpIfNecessary(ProcessContext context, ProcessSession processSession) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +        if (this.smtp == null) {
    +            SmtpConsumer consumer = new SmtpConsumer();
    +            SMTPServer smtpServer = this.createServerInstance(context, consumer);
    +            smtpServer.setSoftwareName(&quot;Apache NiFi&quot;);
    +            smtpServer.setPort(context.getProperty(SMTP_PORT).asInteger());
    +            smtpServer.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());
    +            smtpServer.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());
    +
    +            this.smtpConsumer = consumer;
    +            this.smtp = smtpServer;
    +            this.smtp.start();
             }    +    }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SSLContext finalSslContext = sslContext;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SMTPMessageHandlerFactory smtpMessageHandlerFactory = new SMTPMessageHandlerFactory(incomingMessages, getLogger());&lt;/li&gt;
	&lt;li&gt;final SMTPServer server = new SMTPServer(smtpMessageHandlerFactory) {&lt;br/&gt;
    -&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private SMTPServer createServerInstance(ProcessContext context, SmtpConsumer consumer) {&lt;br/&gt;
    +        SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +        SMTPServer smtpServer = sslContextService == null ? new SMTPServer(consumer) : new SMTPServer(consumer) {&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public SSLSocket createSSLSocket(Socket socket) throws IOException {&lt;br/&gt;
                     InetSocketAddress remoteAddress = (InetSocketAddress) socket.getRemoteSocketAddress();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocketFactory socketFactory = finalSslContext.getSocketFactory();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocket s = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(), socket.getPort(), true));&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;s.setUseClientMode(false);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// For some reason the createSSLContext above is not enough to enforce&lt;/li&gt;
	&lt;li&gt;// client side auth&lt;/li&gt;
	&lt;li&gt;// If client auth is required...&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) {&lt;/li&gt;
	&lt;li&gt;s.setNeedClientAuth(true);&lt;br/&gt;
    +                String clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;br/&gt;
    +                SSLContext sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +                SSLSocketFactory socketFactory = sslContext.getSocketFactory();&lt;br/&gt;
    +                SSLSocket sslSocket = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(),socket.getPort(), true));&lt;br/&gt;
    +                sslSocket.setUseClientMode(false);&lt;br/&gt;
    +&lt;br/&gt;
    +                if (SSLContextService.ClientAuth.REQUIRED.toString().equals(clientAuth)) 
{
    +                    this.setRequireTLS(true);
    +                    sslSocket.setNeedClientAuth(true);
                     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return s;&lt;br/&gt;
    +                return sslSocket;&lt;br/&gt;
                 }&lt;br/&gt;
             };&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set some parameters to our server&lt;/li&gt;
	&lt;li&gt;server.setSoftwareName(&quot;Apache NiFi&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set the Server options based on properties&lt;/li&gt;
	&lt;li&gt;server.setPort(context.getProperty(SMTP_PORT).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setHostName(context.getProperty(SMTP_HOSTNAME).getValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxConnections(context.getProperty(SMTP_MAXIMUM_CONNECTIONS).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Check if TLS should be enabled&lt;br/&gt;
             if (sslContextService != null) 
{
    -            server.setEnableTLS(true);
    -        }
&lt;p&gt; else &lt;/p&gt;
{
    -            server.setHideTLS(true);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Set TLS to required in case CLIENT_AUTH = required&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) 
{
    -            server.setRequireTLS(true);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;this.server = server;&lt;/li&gt;
	&lt;li&gt;server.start();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Server started and listening on port &quot; + server.getPort());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;initialized.set(true);&lt;/li&gt;
	&lt;li&gt;stopping.set(false);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@OnUnscheduled&lt;/li&gt;
	&lt;li&gt;public void startShutdown() throws Exception {&lt;/li&gt;
	&lt;li&gt;if (server != null) {&lt;/li&gt;
	&lt;li&gt;stopping.set(true);&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Shutting down processor P{}&quot;, new Object[]
{server});&lt;br/&gt;
    -            server.stop();&lt;br/&gt;
    -            getLogger().info(&quot;Shut down {}&quot;, new Object[]{server}
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@OnStopped&lt;/li&gt;
	&lt;li&gt;public void completeShutdown() throws Exception {&lt;/li&gt;
	&lt;li&gt;if (server != null) {&lt;/li&gt;
	&lt;li&gt;if (!server.isRunning() &amp;amp;&amp;amp; stopping.get() ) 
{
    -                stopping.set(false);
    -            }&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Completed shut down {}&quot;, new Object[]
{server}
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void onTrigger(ProcessContext context, ProcessSession session) throws ProcessException {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;try 
{
    -            initializeSMTPServer(context);
    -        }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    -            context.yield();
    -            throw new ProcessException(&quot;Failed to initialize the SMTP server&quot;, e);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;while (!incomingMessages.isEmpty()) {&lt;/li&gt;
	&lt;li&gt;SmtpEvent message = incomingMessages.poll();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (message == null) 
{
    -                return;
    -            }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;synchronized (message) {&lt;/li&gt;
	&lt;li&gt;if (resultCodeSetAndIsError(message)) 
{
    -                    SMTPResultCode resultCode = SMTPResultCode.fromCode(message.getReturnCode());
    -                    getLogger().warn(&quot;Message failed before onTrigger processing message was: &quot; + resultCode.getLogMessage());
    -                    continue;
    -                }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;FlowFile flowfile = session.create();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (message.getMessageData() != null) {&lt;/li&gt;
	&lt;li&gt;flowfile = session.write(flowfile, out -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;InputStream inputStream = message.getMessageData();&lt;/li&gt;
	&lt;li&gt;byte [] buffer = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;1024&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;int rd;&lt;/li&gt;
	&lt;li&gt;long totalBytesRead =0;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;while ((rd = inputStream.read(buffer, 0, buffer.length)) != -1 ) {&lt;/li&gt;
	&lt;li&gt;totalBytesRead += rd;&lt;/li&gt;
	&lt;li&gt;if (totalBytesRead &amp;gt; server.getMaxMessageSize() ) 
{
    -                                    message.setReturnCode(500);
    -                                    message.setProcessed();
    -                                    break;
    -                                }&lt;/li&gt;
	&lt;li&gt;out.write(buffer, 0, rd);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;out.flush();&lt;/li&gt;
	&lt;li&gt;});&lt;/li&gt;
	&lt;li&gt;} else 
{
    -                        getLogger().debug(&quot;Message body was null&quot;);
    -                        message.setReturnCode(SMTPResultCode.UNKNOWN_ERROR_CODE.getCode());
    -                        message.setProcessed();
    -                    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (!message.getProcessed()) {&lt;/li&gt;
	&lt;li&gt;HashMap&amp;lt;String, String&amp;gt; attributes = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;// Gather message attributes&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_HELO, message.getHelo());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_SRC_IP, message.getHelo());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_FROM, message.getFrom());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_TO, message.getTo());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; details = message.getCertifcateDetails();&lt;/li&gt;
	&lt;li&gt;int c = 0;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Add a selection of each X509 certificates to the already gathered attributes&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;for (Map&amp;lt;String, String&amp;gt; detail : details) {&lt;/li&gt;
	&lt;li&gt;attributes.put(&quot;smtp.certificate.&quot; + c + &quot;.serial&quot;, detail.getOrDefault(&quot;SerialNumber&quot;, null));&lt;/li&gt;
	&lt;li&gt;attributes.put(&quot;smtp.certificate.&quot; + c + &quot;.subjectName&quot;, detail.getOrDefault(&quot;SubjectName&quot;, null));
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It boils down to chain of custody. &lt;/p&gt;

&lt;p&gt;    Imagine Joe Blogs and Luo Cipher both work for ACME corp and are issued certificated to send messages to my NiFi instance using TLS and requiring client Auth.&lt;/p&gt;

&lt;p&gt;    Since both are authorised, you want to distinguish from your authorised users who sent a particular email to NiFi, hence you store the subjectName used to send the message.&lt;/p&gt;

&lt;p&gt;    This by the way is the same approach used around NiFi&lt;/p&gt;

&lt;p&gt;    !&lt;span class=&quot;error&quot;&gt;&amp;#91;image&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://cloud.githubusercontent.com/assets/3108527/17577508/ec07a332-5fc1-11e6-8d1a-50bb29edc9e2.png&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://cloud.githubusercontent.com/assets/3108527/17577508/ec07a332-5fc1-11e6-8d1a-50bb29edc9e2.png&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://nifi.apache.org/docs/nifi-docs/components/org.apache.nifi.processors.standard.HandleHttpRequest/index.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://nifi.apache.org/docs/nifi-docs/components/org.apache.nifi.processors.standard.HandleHttpRequest/index.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15416429" author="githubbot" created="Thu, 11 Aug 2016 02:51:32 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74363521&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74363521&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected Collection&amp;lt;ValidationResult&amp;gt; customValidate(final ValidationContext validationContext) {&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;ValidationResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +    static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;br/&gt;
    +            .name(&quot;success&quot;)&lt;br/&gt;
    +            .description(&quot;All new messages will be routed as FlowFiles to this relationship&quot;)&lt;br/&gt;
    +            .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final String clientAuth = validationContext.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = validationContext.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +    private final static List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (sslContextService != null &amp;amp;&amp;amp; StringUtils.isBlank(clientAuth)) 
{
    -            results.add(new ValidationResult.Builder()
    -                    .explanation(&quot;Client Auth must be provided when using TLS/SSL&quot;)
    -                    .valid(false).subject(&quot;Client Auth&quot;).build());
    -        }
&lt;p&gt;    +    private final static Set&amp;lt;Relationship&amp;gt; relationships;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return results;&lt;br/&gt;
    +    static 
{
    +        List&amp;lt;PropertyDescriptor&amp;gt; _propertyDescriptors = new ArrayList&amp;lt;&amp;gt;();
    +        _propertyDescriptors.add(SMTP_PORT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_CONNECTIONS);
    +        _propertyDescriptors.add(SMTP_TIMEOUT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_MSG_SIZE);
    +        _propertyDescriptors.add(SSL_CONTEXT_SERVICE);
    +        _propertyDescriptors.add(CLIENT_AUTH);
    +        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);
     
    +        Set&amp;lt;Relationship&amp;gt; _relationships = new HashSet&amp;lt;&amp;gt;();
    +        _relationships.add(REL_SUCCESS);
    +        relationships = Collections.unmodifiableSet(_relationships);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    private volatile SMTPServer smtp;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;success&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;Extraction was successful&quot;)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    +    private volatile SmtpConsumer smtpConsumer;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private Set&amp;lt;Relationship&amp;gt; relationships;&lt;/li&gt;
	&lt;li&gt;private List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
	&lt;li&gt;private volatile LinkedBlockingQueue&amp;lt;SmtpEvent&amp;gt; incomingMessages;&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public void onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) throws ProcessException {&lt;br/&gt;
    +        ProcessSession processSession = sessionFactory.createSession();&lt;br/&gt;
    +        if (this.smtp == null) 
{
    +            this.setupSmtpIfNecessary(context, processSession);
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        if (this.smtpConsumer.hasMessage()) {&lt;br/&gt;
    +            try {&lt;br/&gt;
    +                /*&lt;br/&gt;
    +                 * Will consume incoming message directly from the wire and into&lt;br/&gt;
    +                 * FlowFile/Content repository before exiting. This essentially&lt;br/&gt;
    +                 * limits any potential data loss by allowing SMTPServer thread&lt;br/&gt;
    +                 * to actually commit NiFi session if all good. However in the&lt;br/&gt;
    +                 * event of exception, such exception will be propagated back to&lt;br/&gt;
    +                 * the email sender via &quot;undeliverable message&quot; allowing such&lt;br/&gt;
    +                 * user to re-send the message&lt;br/&gt;
    +                 */&lt;br/&gt;
    +                this.smtpConsumer.consumeUsing((inputDataStream) -&amp;gt; {&lt;br/&gt;
    +                    FlowFile flowFile = processSession.create();&lt;br/&gt;
    +                    AtomicInteger size = new AtomicInteger();&lt;br/&gt;
    +                    flowFile = processSession.write(flowFile, new OutputStreamCallback() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                        @Override    +                        public void process(final OutputStream out) throws IOException {
    +                            size.set(IOUtils.copy(inputDataStream, out));
    +                        }    +                    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +                    processSession.getProvenanceReporter().receive(flowFile, &quot;smtp://&quot;&lt;br/&gt;
    +                            + ListenSMTP.this.smtp.getHostName() + &quot;:&quot; + ListenSMTP.this.smtp.getPort() + &quot;/&quot;);&lt;br/&gt;
    +                    processSession.transfer(flowFile, REL_SUCCESS);&lt;br/&gt;
    +                    processSession.commit();&lt;br/&gt;
    +                    return size.get();&lt;br/&gt;
    +                });&lt;br/&gt;
    +            } catch (Exception e) &lt;/p&gt;
{
    +                this.getLogger().error(&quot;Failed while listenning for messages.&quot;, e);
    +                processSession.rollback();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            context.yield();
    +        }
&lt;p&gt;    +    }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private volatile SMTPServer server;&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean initialized = new AtomicBoolean(false);&lt;/li&gt;
	&lt;li&gt;private AtomicBoolean stopping = new AtomicBoolean(false);&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @OnStopped&lt;br/&gt;
    +    public void close() 
{
    +        this.getLogger().info(&quot;Stopping SMTPServer&quot;);
    +        this.smtp.stop();
    +        this.smtp = null;
    +        this.getLogger().info(&quot;SMTPServer stopped&quot;);
    +    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
         @Override&lt;br/&gt;
         public Set&amp;lt;Relationship&amp;gt; getRelationships() &lt;/p&gt;
{
             return relationships;
         }

&lt;p&gt;    +    /**&lt;br/&gt;
    +    *&lt;br/&gt;
    +    */&lt;br/&gt;
         @Override&lt;br/&gt;
         protected List&amp;lt;PropertyDescriptor&amp;gt; getSupportedPropertyDescriptors() &lt;/p&gt;
{
             return propertyDescriptors;
         }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected void init(final ProcessorInitializationContext context) 
{
    -        final Set&amp;lt;Relationship&amp;gt; relationships = new HashSet&amp;lt;&amp;gt;();
    -        relationships.add(REL_SUCCESS);
    -        this.relationships = Collections.unmodifiableSet(relationships);
    -
    -        final List&amp;lt;PropertyDescriptor&amp;gt; props = new ArrayList&amp;lt;&amp;gt;();
    -        props.add(SMTP_PORT);
    -        props.add(SMTP_HOSTNAME);
    -        props.add(SMTP_MAXIMUM_CONNECTIONS);
    -        props.add(SMTP_TIMEOUT);
    -        props.add(SMTP_MAXIMUM_MSG_SIZE);
    -        props.add(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE);
    -        props.add(SSL_CONTEXT_SERVICE);
    -        props.add(CLIENT_AUTH);
    -        this.propertyDescriptors = Collections.unmodifiableList(props);
    -
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Upon Schedule, reset the initialized state to false&lt;/li&gt;
	&lt;li&gt;@OnScheduled&lt;/li&gt;
	&lt;li&gt;public void onScheduled(ProcessContext context) 
{
    -        initialized.set(false);
    -        stopping.set(false);
    -    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected synchronized void initializeSMTPServer(final ProcessContext context) throws Exception {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// check if we are already running or if it is stopping&lt;/li&gt;
	&lt;li&gt;if (initialized.get() &amp;amp;&amp;amp; server.isRunning() || stopping.get() ) 
{
    -            return;
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;incomingMessages = new LinkedBlockingQueue&amp;lt;&amp;gt;(context.getProperty(SMTP_MAXIMUM_INCOMING_MESSAGE_QUEUE).asInteger());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;String clientAuth = null;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// If an SSLContextService was provided then create an SSLContext to pass down to the server&lt;/li&gt;
	&lt;li&gt;SSLContext sslContext = null;&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;/li&gt;
	&lt;li&gt;if (sslContextService != null) {&lt;/li&gt;
	&lt;li&gt;clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private synchronized void setupSmtpIfNecessary(ProcessContext context, ProcessSession processSession) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +        if (this.smtp == null) {
    +            SmtpConsumer consumer = new SmtpConsumer();
    +            SMTPServer smtpServer = this.createServerInstance(context, consumer);
    +            smtpServer.setSoftwareName(&quot;Apache NiFi&quot;);
    +            smtpServer.setPort(context.getProperty(SMTP_PORT).asInteger());
    +            smtpServer.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());
    +            smtpServer.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());
    +
    +            this.smtpConsumer = consumer;
    +            this.smtp = smtpServer;
    +            this.smtp.start();
             }    +    }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SSLContext finalSslContext = sslContext;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SMTPMessageHandlerFactory smtpMessageHandlerFactory = new SMTPMessageHandlerFactory(incomingMessages, getLogger());&lt;/li&gt;
	&lt;li&gt;final SMTPServer server = new SMTPServer(smtpMessageHandlerFactory) {&lt;br/&gt;
    -&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private SMTPServer createServerInstance(ProcessContext context, SmtpConsumer consumer) {&lt;br/&gt;
    +        SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +        SMTPServer smtpServer = sslContextService == null ? new SMTPServer(consumer) : new SMTPServer(consumer) {&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public SSLSocket createSSLSocket(Socket socket) throws IOException {&lt;br/&gt;
                     InetSocketAddress remoteAddress = (InetSocketAddress) socket.getRemoteSocketAddress();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocketFactory socketFactory = finalSslContext.getSocketFactory();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;SSLSocket s = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(), socket.getPort(), true));&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;s.setUseClientMode(false);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// For some reason the createSSLContext above is not enough to enforce&lt;/li&gt;
	&lt;li&gt;// client side auth&lt;/li&gt;
	&lt;li&gt;// If client auth is required...&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) {&lt;/li&gt;
	&lt;li&gt;s.setNeedClientAuth(true);&lt;br/&gt;
    +                String clientAuth = context.getProperty(CLIENT_AUTH).getValue();&lt;br/&gt;
    +                SSLContext sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.valueOf(clientAuth));&lt;br/&gt;
    +                SSLSocketFactory socketFactory = sslContext.getSocketFactory();&lt;br/&gt;
    +                SSLSocket sslSocket = (SSLSocket) (socketFactory.createSocket(socket, remoteAddress.getHostName(),socket.getPort(), true));&lt;br/&gt;
    +                sslSocket.setUseClientMode(false);&lt;br/&gt;
    +&lt;br/&gt;
    +                if (SSLContextService.ClientAuth.REQUIRED.toString().equals(clientAuth)) 
{
    +                    this.setRequireTLS(true);
    +                    sslSocket.setNeedClientAuth(true);
                     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return s;&lt;br/&gt;
    +                return sslSocket;&lt;br/&gt;
                 }&lt;br/&gt;
             };&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set some parameters to our server&lt;/li&gt;
	&lt;li&gt;server.setSoftwareName(&quot;Apache NiFi&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Set the Server options based on properties&lt;/li&gt;
	&lt;li&gt;server.setPort(context.getProperty(SMTP_PORT).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setHostName(context.getProperty(SMTP_HOSTNAME).getValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxMessageSize(context.getProperty(SMTP_MAXIMUM_MSG_SIZE).asDataSize(DataUnit.B).intValue());&lt;/li&gt;
	&lt;li&gt;server.setMaxConnections(context.getProperty(SMTP_MAXIMUM_CONNECTIONS).asInteger());&lt;/li&gt;
	&lt;li&gt;server.setConnectionTimeout(context.getProperty(SMTP_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue());&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Check if TLS should be enabled&lt;br/&gt;
             if (sslContextService != null) 
{
    -            server.setEnableTLS(true);
    -        }
&lt;p&gt; else &lt;/p&gt;
{
    -            server.setHideTLS(true);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Set TLS to required in case CLIENT_AUTH = required&lt;/li&gt;
	&lt;li&gt;if (SSLContextService.ClientAuth.REQUIRED.toString().equals(context.getProperty(CLIENT_AUTH).getValue())) 
{
    -            server.setRequireTLS(true);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;this.server = server;&lt;/li&gt;
	&lt;li&gt;server.start();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Server started and listening on port &quot; + server.getPort());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;initialized.set(true);&lt;/li&gt;
	&lt;li&gt;stopping.set(false);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@OnUnscheduled&lt;/li&gt;
	&lt;li&gt;public void startShutdown() throws Exception {&lt;/li&gt;
	&lt;li&gt;if (server != null) {&lt;/li&gt;
	&lt;li&gt;stopping.set(true);&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Shutting down processor P{}&quot;, new Object[]
{server});&lt;br/&gt;
    -            server.stop();&lt;br/&gt;
    -            getLogger().info(&quot;Shut down {}&quot;, new Object[]{server}
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@OnStopped&lt;/li&gt;
	&lt;li&gt;public void completeShutdown() throws Exception {&lt;/li&gt;
	&lt;li&gt;if (server != null) {&lt;/li&gt;
	&lt;li&gt;if (!server.isRunning() &amp;amp;&amp;amp; stopping.get() ) 
{
    -                stopping.set(false);
    -            }&lt;/li&gt;
	&lt;li&gt;getLogger().info(&quot;Completed shut down {}&quot;, new Object[]
{server}
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void onTrigger(ProcessContext context, ProcessSession session) throws ProcessException {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;try 
{
    -            initializeSMTPServer(context);
    -        }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    -            context.yield();
    -            throw new ProcessException(&quot;Failed to initialize the SMTP server&quot;, e);
    -        }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;while (!incomingMessages.isEmpty()) {&lt;/li&gt;
	&lt;li&gt;SmtpEvent message = incomingMessages.poll();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (message == null) 
{
    -                return;
    -            }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;synchronized (message) {&lt;/li&gt;
	&lt;li&gt;if (resultCodeSetAndIsError(message)) 
{
    -                    SMTPResultCode resultCode = SMTPResultCode.fromCode(message.getReturnCode());
    -                    getLogger().warn(&quot;Message failed before onTrigger processing message was: &quot; + resultCode.getLogMessage());
    -                    continue;
    -                }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;FlowFile flowfile = session.create();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (message.getMessageData() != null) {&lt;/li&gt;
	&lt;li&gt;flowfile = session.write(flowfile, out -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;InputStream inputStream = message.getMessageData();&lt;/li&gt;
	&lt;li&gt;byte [] buffer = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;1024&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;int rd;&lt;/li&gt;
	&lt;li&gt;long totalBytesRead =0;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;while ((rd = inputStream.read(buffer, 0, buffer.length)) != -1 ) {&lt;/li&gt;
	&lt;li&gt;totalBytesRead += rd;&lt;/li&gt;
	&lt;li&gt;if (totalBytesRead &amp;gt; server.getMaxMessageSize() ) 
{
    -                                    message.setReturnCode(500);
    -                                    message.setProcessed();
    -                                    break;
    -                                }&lt;/li&gt;
	&lt;li&gt;out.write(buffer, 0, rd);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;out.flush();&lt;/li&gt;
	&lt;li&gt;});&lt;/li&gt;
	&lt;li&gt;} else 
{
    -                        getLogger().debug(&quot;Message body was null&quot;);
    -                        message.setReturnCode(SMTPResultCode.UNKNOWN_ERROR_CODE.getCode());
    -                        message.setProcessed();
    -                    }
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (!message.getProcessed()) {&lt;/li&gt;
	&lt;li&gt;HashMap&amp;lt;String, String&amp;gt; attributes = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;// Gather message attributes&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_HELO, message.getHelo());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_SRC_IP, message.getHelo());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_FROM, message.getFrom());&lt;/li&gt;
	&lt;li&gt;attributes.put(SMTP_TO, message.getTo());&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; details = message.getCertifcateDetails();&lt;/li&gt;
	&lt;li&gt;int c = 0;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Add a selection of each X509 certificates to the already gathered attributes&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;for (Map&amp;lt;String, String&amp;gt; detail : details) {&lt;/li&gt;
	&lt;li&gt;attributes.put(&quot;smtp.certificate.&quot; + c + &quot;.serial&quot;, detail.getOrDefault(&quot;SerialNumber&quot;, null));&lt;/li&gt;
	&lt;li&gt;attributes.put(&quot;smtp.certificate.&quot; + c + &quot;.subjectName&quot;, detail.getOrDefault(&quot;SubjectName&quot;, null));
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Fair enough!&lt;/p&gt;</comment>
                            <comment id="15416437" author="githubbot" created="Thu, 11 Aug 2016 02:59:56 +0000"  >&lt;p&gt;Github user trixpan commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @olegz - Tested the processor and other than the view that attributes should not be removed (as they are useful for many auditing and downstream applications) and a few remarks on SubEthaSMTP intricacies  I am amazed by the refactoring. &lt;/p&gt;

&lt;p&gt;    Truly awesome work in here.&lt;/p&gt;</comment>
                            <comment id="15416445" author="githubbot" created="Thu, 11 Aug 2016 03:03:33 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74364045&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74364045&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/test/java/org/apache/nifi/processors/email/TestListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -13,307 +13,174 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
    -*/&lt;br/&gt;
    + */&lt;br/&gt;
     package org.apache.nifi.processors.email;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +import static org.junit.Assert.assertTrue;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.CountDownLatch;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.ScheduledExecutorService;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
     import org.apache.commons.mail.Email;&lt;br/&gt;
     import org.apache.commons.mail.EmailException;&lt;br/&gt;
     import org.apache.commons.mail.SimpleEmail;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.remote.io.socket.NetworkUtils;&lt;br/&gt;
    +import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
     import org.apache.nifi.ssl.StandardSSLContextService;&lt;br/&gt;
    -import org.apache.nifi.util.MockFlowFile;&lt;br/&gt;
     import org.apache.nifi.util.TestRunner;&lt;br/&gt;
     import org.apache.nifi.util.TestRunners;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.junit.Assert;&lt;br/&gt;
    +import org.junit.After;&lt;br/&gt;
    +import org.junit.Before;&lt;br/&gt;
     import org.junit.Test;&lt;/p&gt;

&lt;p&gt;    -import java.util.List;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
     public class TestListenSMTP {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test(timeout=15000)&lt;/li&gt;
	&lt;li&gt;public void ValidEmailTls() throws Exception {&lt;/li&gt;
	&lt;li&gt;boolean[] failed = 
{false};&lt;br/&gt;
    -        ListenSMTP listenSmtp = new ListenSMTP();&lt;br/&gt;
    -        final TestRunner runner = TestRunners.newTestRunner(listenSmtp);&lt;br/&gt;
    -&lt;br/&gt;
    -        runner.setProperty(ListenSMTP.SMTP_PORT, &quot;0&quot;);&lt;br/&gt;
    -        runner.setProperty(ListenSMTP.SMTP_HOSTNAME, &quot;bermudatriangle&quot;);&lt;br/&gt;
    -        runner.setProperty(ListenSMTP.SMTP_MAXIMUM_CONNECTIONS, &quot;3&quot;);&lt;br/&gt;
    -        runner.setProperty(ListenSMTP.SMTP_TIMEOUT, &quot;10 seconds&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -        // Setup the SSL Context&lt;br/&gt;
    -        final SSLContextService sslContextService = new StandardSSLContextService();&lt;br/&gt;
    -        runner.addControllerService(&quot;ssl-context&quot;, sslContextService);&lt;br/&gt;
    -        runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE, &quot;src/test/resources/localhost-ts.jks&quot;);&lt;br/&gt;
    -        runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_PASSWORD, &quot;localtest&quot;);&lt;br/&gt;
    -        runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_TYPE, &quot;JKS&quot;);&lt;br/&gt;
    -        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE, &quot;src/test/resources/localhost-ks.jks&quot;);&lt;br/&gt;
    -        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_PASSWORD, &quot;localtest&quot;);&lt;br/&gt;
    -        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_TYPE, &quot;JKS&quot;);&lt;br/&gt;
    -        runner.enableControllerService(sslContextService);&lt;br/&gt;
    -&lt;br/&gt;
    -        // and add the SSL context to the runner&lt;br/&gt;
    -        runner.setProperty(ListenSMTP.SSL_CONTEXT_SERVICE, &quot;ssl-context&quot;);&lt;br/&gt;
    -        runner.setProperty(ListenSMTP.CLIENT_AUTH, SSLContextService.ClientAuth.NONE.name());&lt;br/&gt;
    -&lt;br/&gt;
    +    private ScheduledExecutorService executor;&lt;br/&gt;
     &lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @Before&lt;br/&gt;
    +    public void before() {
    +        this.executor = Executors.newScheduledThreadPool(2);
    +    }&lt;br/&gt;
     &lt;br/&gt;
    -        final ProcessSessionFactory processSessionFactory = runner.getProcessSessionFactory();&lt;br/&gt;
    -        final ProcessContext context = runner.getProcessContext();&lt;br/&gt;
    -&lt;br/&gt;
    -        // NOTE: This test routine uses  the same strategy used by TestListenAndPutSyslog&lt;br/&gt;
    -        // where listenSmtp method calls are used to allow the processor to be started using&lt;br/&gt;
    -        // port &quot;0&quot; without triggering a violation of PORT_VALIDATOR&lt;br/&gt;
    -&lt;br/&gt;
    -        listenSmtp.onScheduled(context);&lt;br/&gt;
    -        listenSmtp.initializeSMTPServer(context);&lt;br/&gt;
    -&lt;br/&gt;
    -        final int port = listenSmtp.getPort();&lt;br/&gt;
    -&lt;br/&gt;
    -        try {&lt;br/&gt;
    -            final Thread clientThread = new Thread(new Runnable() {&lt;br/&gt;
    -                @Override&lt;br/&gt;
    -                public void run() {&lt;br/&gt;
    -                    try {
    -
    -
    -                        System.setProperty(&quot;mail.smtp.ssl.trust&quot;, &quot;*&quot;);
    -                        System.setProperty(&quot;javax.net.ssl.keyStore&quot;, &quot;src/test/resources/localhost-ks.jks&quot;);
    -                        System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, &quot;localtest&quot;);
    -
    -                        Email email = new SimpleEmail();
    -
    -                        email.setHostName(&quot;127.0.0.1&quot;);
    -                        email.setSmtpPort(port);
    -
    -                        // Enable STARTTLS but ignore the cert
    -                        email.setStartTLSEnabled(true);
    -                        email.setStartTLSRequired(true);
    -                        email.setSSLCheckServerIdentity(false);
    -
    -                        email.setFrom(&quot;alice@nifi.apache.org&quot;);
    -                        email.setSubject(&quot;This is a test&quot;);
    -                        email.setMsg(&quot;Test test test chocolate&quot;);
    -                        email.addTo(&quot;bob@nifi.apache.org&quot;);
    -
    -                        email.send();
    -                    } catch (final Throwable t) {
    -                        failed[0] = true;
    -                    }&lt;br/&gt;
    -                }&lt;br/&gt;
    -            });&lt;br/&gt;
    -            clientThread.start();&lt;br/&gt;
    -&lt;br/&gt;
    -            while (runner.getFlowFilesForRelationship(ListenSMTP.REL_SUCCESS).isEmpty()) {
    -                // process the request.
    -                listenSmtp.onTrigger(context, processSessionFactory);
    -            }&lt;br/&gt;
    -&lt;br/&gt;
    -                // Checks if client experienced Exception&lt;br/&gt;
    -                Assert.assertFalse(&quot;Client experienced exception&quot;, failed&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    -&lt;br/&gt;
    -            runner.assertTransferCount(ListenSMTP.REL_SUCCESS, 1);&lt;br/&gt;
    -            clientThread.stop();&lt;br/&gt;
    -&lt;br/&gt;
    -            Assert.assertFalse(&quot;Sending email failed&quot;, failed&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    -&lt;br/&gt;
    -            runner.assertQueueEmpty();&lt;br/&gt;
    -            final List&amp;lt;MockFlowFile&amp;gt; splits = runner.getFlowFilesForRelationship(ListenSMTP.REL_SUCCESS);&lt;br/&gt;
    -            splits.get(0).assertAttributeEquals(&quot;smtp.from&quot;, &quot;alice@nifi.apache.org&quot;);&lt;br/&gt;
    -            splits.get(0).assertAttributeEquals(&quot;smtp.to&quot;, &quot;bob@nifi.apache.org&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -            Thread.sleep(100);&lt;br/&gt;
    -        } finally {
    -            // shut down the server
    -            listenSmtp.startShutdown();
    -        }&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @After&lt;br/&gt;
    +    public void after() {
    +        this.executor.shutdown();
         }&lt;br/&gt;
     &lt;br/&gt;
    -    @Test(timeout=15000)&lt;br/&gt;
    -    public void ValidEmail() throws Exception, EmailException {&lt;br/&gt;
    -        final boolean[] failed = {false}
&lt;p&gt;;&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;ListenSMTP listenSmtp = new ListenSMTP();&lt;/li&gt;
	&lt;li&gt;final TestRunner runner = TestRunners.newTestRunner(listenSmtp);&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @Test&lt;br/&gt;
    +    public void validateSuccessfulInteraction() throws Exception, EmailException {&lt;br/&gt;
    +        int port = NetworkUtils.availablePort();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;runner.setProperty(ListenSMTP.SMTP_PORT, &quot;0&quot;);&lt;/li&gt;
	&lt;li&gt;runner.setProperty(ListenSMTP.SMTP_HOSTNAME, &quot;bermudatriangle&quot;);&lt;br/&gt;
    +        TestRunner runner = TestRunners.newTestRunner(ListenSMTP.class);&lt;br/&gt;
    +        runner.setProperty(ListenSMTP.SMTP_PORT, String.valueOf(port));&lt;br/&gt;
             runner.setProperty(ListenSMTP.SMTP_MAXIMUM_CONNECTIONS, &quot;3&quot;);&lt;br/&gt;
             runner.setProperty(ListenSMTP.SMTP_TIMEOUT, &quot;10 seconds&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final ProcessSessionFactory processSessionFactory = runner.getProcessSessionFactory();&lt;/li&gt;
	&lt;li&gt;final ProcessContext context = runner.getProcessContext();&lt;br/&gt;
    +        runner.assertValid();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// NOTE: This test routine uses  the same strategy used by TestListenAndPutSyslog&lt;/li&gt;
	&lt;li&gt;// where listenSmtp method calls are used to allow the processor to be started using&lt;/li&gt;
	&lt;li&gt;// port &quot;0&quot; without triggering a violation of PORT_VALIDATOR&lt;/li&gt;
	&lt;li&gt;listenSmtp.onScheduled(context);&lt;/li&gt;
	&lt;li&gt;listenSmtp.initializeSMTPServer(context);&lt;br/&gt;
    +        int messageCount = 5;&lt;br/&gt;
    +        CountDownLatch latch = new CountDownLatch(messageCount);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final int port = listenSmtp.getPort();&lt;br/&gt;
    +        this.executor.scheduleAtFixedRate(new Runnable() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +            @Override    +            public void run() {
    +                runner.run(1, false);
    +            }    +        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;, 0, 500, TimeUnit.MILLISECONDS);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;final Thread clientThread = new Thread(new Runnable() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void run() {&lt;br/&gt;
    +        this.executor.schedule(new Runnable() {&lt;br/&gt;
    +            @Override&lt;br/&gt;
    +            public void run() {&lt;br/&gt;
    +                for (int i = 0; i &amp;lt; messageCount; i++) {&lt;br/&gt;
                         try {&lt;br/&gt;
                             Email email = new SimpleEmail();&lt;/li&gt;
	&lt;li&gt;email.setHostName(&quot;127.0.0.1&quot;);&lt;br/&gt;
    +                        email.setHostName(&quot;localhost&quot;);&lt;br/&gt;
                             email.setSmtpPort(port);&lt;/li&gt;
	&lt;li&gt;email.setStartTLSEnabled(false);&lt;br/&gt;
                             email.setFrom(&quot;alice@nifi.apache.org&quot;);&lt;br/&gt;
                             email.setSubject(&quot;This is a test&quot;);&lt;/li&gt;
	&lt;li&gt;email.setMsg(&quot;Test test test chocolate&quot;);&lt;br/&gt;
    +                        email.setMsg(&quot;MSG-&quot; + i);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    /joke on&lt;br/&gt;
    NOOOOOOOOOO!!!! What have you done!??!! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/search?utf8=%E2%9C%93&amp;amp;q=chocolate&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/search?utf8=%E2%9C%93&amp;amp;q=chocolate&lt;/a&gt;&lt;br/&gt;
    /joke off&lt;/p&gt;

</comment>
                            <comment id="15417145" author="githubbot" created="Thu, 11 Aug 2016 12:40:41 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74414087&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74414087&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -13,89 +13,52 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
    -*/&lt;br/&gt;
    + */&lt;br/&gt;
     package org.apache.nifi.processors.email;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -import javax.net.ssl.SSLContext;&lt;br/&gt;
    -import javax.net.ssl.SSLSocket;&lt;br/&gt;
    -import javax.net.ssl.SSLSocketFactory;&lt;br/&gt;
     import java.io.IOException;&lt;br/&gt;
    -import java.io.InputStream;&lt;br/&gt;
    +import java.io.OutputStream;&lt;br/&gt;
     import java.net.InetSocketAddress;&lt;br/&gt;
     import java.net.Socket;&lt;br/&gt;
     import java.util.ArrayList;&lt;br/&gt;
    -import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    -import java.util.HashMap;&lt;br/&gt;
     import java.util.HashSet;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    -import java.util.Map;&lt;br/&gt;
     import java.util.Set;&lt;br/&gt;
    -import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;
     import java.util.concurrent.TimeUnit;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnUnscheduled;&lt;br/&gt;
    -import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    -import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicInteger;&lt;/p&gt;

&lt;p&gt;    -import org.apache.nifi.annotation.lifecycle.OnScheduled;&lt;br/&gt;
    -import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    -import org.apache.nifi.processor.AbstractProcessor;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessorInitializationContext;&lt;br/&gt;
    -import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    -import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
    +import javax.net.ssl.SSLContext;&lt;br/&gt;
    +import javax.net.ssl.SSLSocket;&lt;br/&gt;
    +import javax.net.ssl.SSLSocketFactory;&lt;/p&gt;

&lt;p&gt;    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.InputRequirement;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttribute;&lt;br/&gt;
    -import org.apache.nifi.annotation.behavior.WritesAttributes;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.CapabilityDescription;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.Tags;&lt;br/&gt;
    +import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    +import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    +import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.AbstractSessionFactoryProcessor;&lt;br/&gt;
    +import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
     import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.Relationship;&lt;br/&gt;
     import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationContext;&lt;br/&gt;
    -import org.apache.nifi.components.ValidationResult;&lt;br/&gt;
    -import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.io.OutputStreamCallback;&lt;br/&gt;
    +import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
     import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.event.SmtpEvent;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPResultCode;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPMessageHandlerFactory;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;/p&gt;

&lt;p&gt;     @Tags(&lt;/p&gt;
{&quot;listen&quot;, &quot;email&quot;, &quot;smtp&quot;}
&lt;p&gt;)&lt;br/&gt;
     @InputRequirement(InputRequirement.Requirement.INPUT_FORBIDDEN)&lt;br/&gt;
    -@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;allowing nifi to listen for incoming email. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Note this server does not perform any email validation. If direct exposure to the internet is sought,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;it may be a better idea to use the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
    -@WritesAttributes(
{
    -        @WritesAttribute(attribute = &quot;mime.type&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.serial&quot;, description = &quot;The serial numbers for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.principal&quot;, description = &quot;The principal for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.from&quot;, description = &quot;The value used during MAIL FROM (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.to&quot;, description = &quot;The value used during RCPT TO (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.src&quot;, description = &quot;The source IP of the SMTP connection&quot;)}
&lt;p&gt;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I understand you may not want to add those in IMAP and POP but they are intrinsically different processors:&lt;/p&gt;

&lt;p&gt;    Listeners get connections from outside entities which may be outside the control of the DFM, Getters (in theory) will only establish connections to targets defined by the DFM.&lt;/p&gt;

&lt;p&gt;    It is therefore critical for the chain of custody of a flow (an inbound email may a medical record...) we record information through the ingestion of the data to its delivery. Attributes help with that.&lt;/p&gt;

&lt;p&gt;    Note that this isn&apos;t something particular to this processor, it is a pattern used all across NiFi. &lt;/p&gt;

&lt;p&gt;    HandleHttpRequest records TLS client details and things like:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    http.remote.host	The hostname of the requestor&lt;br/&gt;
    http.remote.addr	The hostname:port combination of the requestor&lt;br/&gt;
    http.remote.user	The username of the requestor&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    ListenRELP&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    relp.sender	The sending host of the messages.&lt;br/&gt;
    relp.port	The sending port the messages were received over.&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    ListenTCP &amp;amp; ListenUDP&lt;br/&gt;
    ```&lt;br/&gt;
    tcp.sender	The sending host of the messages.&lt;br/&gt;
    udp.sender	The sending host of the messages.&lt;/p&gt;

&lt;p&gt;    ```&lt;/p&gt;

&lt;p&gt;    ListenSyslog records both the Hostname and the Sender.&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    syslog.hostname	The hostname of the Syslog message.&lt;br/&gt;
    syslog.sender	The hostname of the Syslog server that sent the message.&lt;/p&gt;

&lt;p&gt;    ```&lt;/p&gt;

&lt;p&gt;    You may not be fully aware but the sender of a syslog message is the server IP, while the hostname is a field of the syslog message. Think of sender as MAIL FROM envelope while hostname is the &quot;From&quot; of a message.&lt;/p&gt;

&lt;p&gt;    Why is this recorded? &lt;/p&gt;

&lt;p&gt;    Because the sender may just be forwarding messages on behalf of a certain host and you want to know that. Otherwise evilmachine.com may send messages on behalf of clueless.org and you would never know.&lt;/p&gt;

&lt;p&gt;    Add that to the fact @bbende allowed for decoupled processing (ParseSyslog) and you find a pattern where Listeners record &quot;wire&quot; level details and parsers deal with payload content. Hence ListenSMTP (ingest and record envelope data) -&amp;gt; ExtractEmailAttributes (deals exclusively with Header data) -&amp;gt; ExtractAttachments (deals only with attachments) -&amp;gt; ExtractTNEFAttachments (handles attachments that happen to be TNEF files)&lt;/p&gt;

&lt;p&gt;    Hope this helps to clarify.&lt;/p&gt;</comment>
                            <comment id="15417151" author="githubbot" created="Thu, 11 Aug 2016 12:43:52 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74414544&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74414544&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -166,317 +108,158 @@&lt;br/&gt;
                 .identifiesControllerService(SSLContextService.class)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor CLIENT_AUTH = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;CLIENT_AUTH&quot;)&lt;br/&gt;
                 .displayName(&quot;Client Auth&quot;)&lt;br/&gt;
                 .description(&quot;The client authentication policy to use for the SSL Context. Only used if an SSL Context Service is provided.&quot;)&lt;br/&gt;
                 .required(false)&lt;br/&gt;
                 .allowableValues(SSLContextService.ClientAuth.NONE.toString(), SSLContextService.ClientAuth.REQUIRED.toString())&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;protected Collection&amp;lt;ValidationResult&amp;gt; customValidate(final ValidationContext validationContext) {&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;ValidationResult&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +    static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;br/&gt;
    +            .name(&quot;success&quot;)&lt;br/&gt;
    +            .description(&quot;All new messages will be routed as FlowFiles to this relationship&quot;)&lt;br/&gt;
    +            .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final String clientAuth = validationContext.getProperty(CLIENT_AUTH).getValue();&lt;/li&gt;
	&lt;li&gt;final SSLContextService sslContextService = validationContext.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);&lt;br/&gt;
    +    private final static List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (sslContextService != null &amp;amp;&amp;amp; StringUtils.isBlank(clientAuth)) 
{
    -            results.add(new ValidationResult.Builder()
    -                    .explanation(&quot;Client Auth must be provided when using TLS/SSL&quot;)
    -                    .valid(false).subject(&quot;Client Auth&quot;).build());
    -        }
&lt;p&gt;    +    private final static Set&amp;lt;Relationship&amp;gt; relationships;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return results;&lt;br/&gt;
    +    static 
{
    +        List&amp;lt;PropertyDescriptor&amp;gt; _propertyDescriptors = new ArrayList&amp;lt;&amp;gt;();
    +        _propertyDescriptors.add(SMTP_PORT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_CONNECTIONS);
    +        _propertyDescriptors.add(SMTP_TIMEOUT);
    +        _propertyDescriptors.add(SMTP_MAXIMUM_MSG_SIZE);
    +        _propertyDescriptors.add(SSL_CONTEXT_SERVICE);
    +        _propertyDescriptors.add(CLIENT_AUTH);
    +        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);
     
    +        Set&amp;lt;Relationship&amp;gt; _relationships = new HashSet&amp;lt;&amp;gt;();
    +        _relationships.add(REL_SUCCESS);
    +        relationships = Collections.unmodifiableSet(_relationships);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    private volatile SMTPServer smtp;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static final Relationship REL_SUCCESS = new Relationship.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;success&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;Extraction was successful&quot;)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    +    private volatile SmtpConsumer smtpConsumer;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private Set&amp;lt;Relationship&amp;gt; relationships;&lt;/li&gt;
	&lt;li&gt;private List&amp;lt;PropertyDescriptor&amp;gt; propertyDescriptors;&lt;/li&gt;
	&lt;li&gt;private volatile LinkedBlockingQueue&amp;lt;SmtpEvent&amp;gt; incomingMessages;&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     *&lt;br/&gt;
    +     */&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public void onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) throws ProcessException {&lt;br/&gt;
    +        ProcessSession processSession = sessionFactory.createSession();&lt;br/&gt;
    +        if (this.smtp == null) 
{
    +            this.setupSmtpIfNecessary(context, processSession);
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        if (this.smtpConsumer.hasMessage()) {&lt;br/&gt;
    +            try {&lt;br/&gt;
    +                /*&lt;br/&gt;
    +                 * Will consume incoming message directly from the wire and into&lt;br/&gt;
    +                 * FlowFile/Content repository before exiting. This essentially&lt;br/&gt;
    +                 * limits any potential data loss by allowing SMTPServer thread&lt;br/&gt;
    +                 * to actually commit NiFi session if all good. However in the&lt;br/&gt;
    +                 * event of exception, such exception will be propagated back to&lt;br/&gt;
    +                 * the email sender via &quot;undeliverable message&quot; allowing such&lt;br/&gt;
    +                 * user to re-send the message&lt;br/&gt;
    +                 */&lt;br/&gt;
    +                this.smtpConsumer.consumeUsing((inputDataStream) -&amp;gt; {&lt;br/&gt;
    +                    FlowFile flowFile = processSession.create();&lt;br/&gt;
    +                    AtomicInteger size = new AtomicInteger();&lt;br/&gt;
    +                    flowFile = processSession.write(flowFile, new OutputStreamCallback() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                        @Override    +                        public void process(final OutputStream out) throws IOException {
    +                            size.set(IOUtils.copy(inputDataStream, out));
    +                        }    +                    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +                    processSession.getProvenanceReporter().receive(flowFile, &quot;smtp://&quot;&lt;br/&gt;
    +                            + ListenSMTP.this.smtp.getHostName() + &quot;:&quot; + ListenSMTP.this.smtp.getPort() + &quot;/&quot;);&lt;br/&gt;
    +                    processSession.transfer(flowFile, REL_SUCCESS);&lt;br/&gt;
    +                    processSession.commit();&lt;br/&gt;
    +                    return size.get();&lt;br/&gt;
    +                });&lt;br/&gt;
    +            } catch (Exception e) {&lt;br/&gt;
    +                this.getLogger().error(&quot;Failed while listenning for messages.&quot;, e);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    typo&lt;/p&gt;</comment>
                            <comment id="15417168" author="githubbot" created="Thu, 11 Aug 2016 12:56:35 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74416389&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74416389&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -135,29 +89,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Is SMTP_MAXIMUM_SIZE being enforced? I&apos;ve set it to 512 B and ended up with a message of 1KB?&lt;/p&gt;

&lt;p&gt;    Note that setMaxMessageSize has no effective role in dropping messages, instead all it does is to configure the EHLO response:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    $ telnet 0 2525&lt;br/&gt;
    Trying 0.0.0.0...&lt;br/&gt;
    Connected to 0.&lt;br/&gt;
    Escape character is &apos;^]&apos;.&lt;br/&gt;
    220 localhost ESMTP Apache NiFi&lt;br/&gt;
    EHLO .&lt;br/&gt;
    250-localhost&lt;br/&gt;
    250-8BITMIME&lt;br/&gt;
    250-SIZE 512&lt;br/&gt;
    250 Ok&lt;/p&gt;

&lt;p&gt;    ```&lt;/p&gt;</comment>
                            <comment id="15417177" author="githubbot" created="Thu, 11 Aug 2016 13:01:10 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74417054&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74417054&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -135,29 +89,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I was just propagating property value to it&apos;s corresponding property in SMTPServer, so IMO if server doesn&apos;t care why should we? Note that with the refactoring we never write a message into memory so even if you try to send TB it will be successful.&lt;br/&gt;
    If on the other hand we are to provide some type of enforcement on the NiFi side , then we should completely disassociate this property from SMTPServer or have some other property to eliminate the confusion. &lt;/p&gt;</comment>
                            <comment id="15417198" author="githubbot" created="Thu, 11 Aug 2016 13:09:26 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74418332&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74418332&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;SMTP_MAXIMUM_CONNECTIONS&quot;)&lt;br/&gt;
                 .displayName(&quot;Maximum number of SMTP connection&quot;)&lt;br/&gt;
                 .description(&quot;The maximum number of simultaneous SMTP connections.&quot;)&lt;br/&gt;
                 .required(true)&lt;br/&gt;
    +            .defaultValue(&quot;1&quot;)&lt;br/&gt;
                 .expressionLanguageSupported(false)&lt;br/&gt;
                 .addValidator(StandardValidators.INTEGER_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Is SMTP_TIMEOUT being enforced at the DATA stage?&lt;/p&gt;

&lt;p&gt;    The server seems to hang around the data stage with the connection open no matter how long the client idles for.&lt;/p&gt;

&lt;p&gt;    Typing . and quit do not work&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    $ time telnet 0 2525&lt;br/&gt;
    Trying 0.0.0.0...&lt;br/&gt;
    Connected to 0.&lt;br/&gt;
    Escape character is &apos;^]&apos;.&lt;br/&gt;
    220 localhost ESMTP Apache NiFi&lt;br/&gt;
    helo .&lt;br/&gt;
    250 localhost&lt;br/&gt;
    mail from: x&lt;br/&gt;
    250 Ok&lt;br/&gt;
    rcpt to: a&lt;br/&gt;
    250 Ok&lt;br/&gt;
    data&lt;br/&gt;
    354 End data with &amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;.&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;br/&gt;
    Hmmmm....&lt;/p&gt;

&lt;p&gt;    .&lt;br/&gt;
    ^]&lt;br/&gt;
    telnet&amp;gt; quit&lt;br/&gt;
    Connection closed.&lt;/p&gt;

&lt;p&gt;    real    1m24.348s&lt;br/&gt;
    user    0m0.000s&lt;br/&gt;
    sys     0m0.002s&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="15417199" author="githubbot" created="Thu, 11 Aug 2016 13:10:55 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74418537&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74418537&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;SMTP_MAXIMUM_CONNECTIONS&quot;)&lt;br/&gt;
                 .displayName(&quot;Maximum number of SMTP connection&quot;)&lt;br/&gt;
                 .description(&quot;The maximum number of simultaneous SMTP connections.&quot;)&lt;br/&gt;
                 .required(true)&lt;br/&gt;
    +            .defaultValue(&quot;1&quot;)&lt;br/&gt;
                 .expressionLanguageSupported(false)&lt;br/&gt;
                 .addValidator(StandardValidators.INTEGER_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Same as above. The property is simply propagated to the underlying API&lt;/p&gt;</comment>
                            <comment id="15417221" author="githubbot" created="Thu, 11 Aug 2016 13:25:52 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74420800&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74420800&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -135,29 +89,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I imagine you write straight to disk? If so we should enforce this somehow. It would be sort of concerning to have a client filling up your disk with a single message? &lt;/p&gt;</comment>
                            <comment id="15417235" author="githubbot" created="Thu, 11 Aug 2016 13:31:12 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74421721&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74421721&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;SMTP_MAXIMUM_CONNECTIONS&quot;)&lt;br/&gt;
                 .displayName(&quot;Maximum number of SMTP connection&quot;)&lt;br/&gt;
                 .description(&quot;The maximum number of simultaneous SMTP connections.&quot;)&lt;br/&gt;
                 .required(true)&lt;br/&gt;
    +            .defaultValue(&quot;1&quot;)&lt;br/&gt;
                 .expressionLanguageSupported(false)&lt;br/&gt;
                 .addValidator(StandardValidators.INTEGER_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It will cause clients to hang around indefinitely &lt;/p&gt;

&lt;p&gt;    Subethasmtp is a weird API. I don&apos;t truly understand the reason why it was coded like that but it transfers good chunks of the smtp conversation to the developer making use of it.&lt;/p&gt;</comment>
                            <comment id="15417238" author="githubbot" created="Thu, 11 Aug 2016 13:31:47 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74421827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74421827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -135,29 +89,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes it goes straight to disc via the Function that is passed to the SmtpConsumer. &lt;br/&gt;
    As far as enforcing data size we can address it in the future if that is a problem. For example we don&apos;t have the same enforcement in PutFile and other processors unless memory is involved which in this case it isn&apos;t. &lt;br/&gt;
    Also, in all honesty I can&apos;t see someone using ListenSMTP or email in general to send large data or to move data. There are better more suitable protocols for it.&lt;/p&gt;</comment>
                            <comment id="15417247" author="githubbot" created="Thu, 11 Aug 2016 13:35:55 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74422525&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74422525&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;SMTP_MAXIMUM_CONNECTIONS&quot;)&lt;br/&gt;
                 .displayName(&quot;Maximum number of SMTP connection&quot;)&lt;br/&gt;
                 .description(&quot;The maximum number of simultaneous SMTP connections.&quot;)&lt;br/&gt;
                 .required(true)&lt;br/&gt;
    +            .defaultValue(&quot;1&quot;)&lt;br/&gt;
                 .expressionLanguageSupported(false)&lt;br/&gt;
                 .addValidator(StandardValidators.INTEGER_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I am not sure hat you&apos;re saying. If Subethasmtp is inadequate API, then we have to scrap it and use something different. But once again, let&apos;s keep in mind that the job of this processor is to simply open up a socket with attached application layer capable of speaking SMTP. That is all. For anything else use commercial server and attache to it via available mail protocols.  &lt;/p&gt;</comment>
                            <comment id="15417259" author="githubbot" created="Thu, 11 Aug 2016 13:40:31 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74423248&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74423248&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -135,29 +89,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @olegz I see where you come from but put file is controlled by the DFM, ListenSMTP is an exposed service&lt;/p&gt;

&lt;p&gt;    True, we don&apos;t do it everywhere but it is present on GetFile as well as other processors crossing administrative domains (DFM &amp;lt;&amp;gt; FS) and so it goes&lt;/p&gt;
</comment>
                            <comment id="15417274" author="githubbot" created="Thu, 11 Aug 2016 13:50:50 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74425136&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74425136&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;SMTP_MAXIMUM_CONNECTIONS&quot;)&lt;br/&gt;
                 .displayName(&quot;Maximum number of SMTP connection&quot;)&lt;br/&gt;
                 .description(&quot;The maximum number of simultaneous SMTP connections.&quot;)&lt;br/&gt;
                 .required(true)&lt;br/&gt;
    +            .defaultValue(&quot;1&quot;)&lt;br/&gt;
                 .expressionLanguageSupported(false)&lt;br/&gt;
                 .addValidator(StandardValidators.INTEGER_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If you are intending to speak SMTP tgan you need to follow the relevant RFC, this means a connecting MTA should be actively informed of a time out otherwise it will indefinitely hang connected as you do not return a 4XX code nor an ok,  instead we just leave the  connection for dead. This means all clients will have to wait for their own timeouts before disconnecting &lt;/p&gt;</comment>
                            <comment id="15417280" author="githubbot" created="Thu, 11 Aug 2016 13:53:55 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74425691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74425691&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;SMTP_MAXIMUM_CONNECTIONS&quot;)&lt;br/&gt;
                 .displayName(&quot;Maximum number of SMTP connection&quot;)&lt;br/&gt;
                 .description(&quot;The maximum number of simultaneous SMTP connections.&quot;)&lt;br/&gt;
                 .required(true)&lt;br/&gt;
    +            .defaultValue(&quot;1&quot;)&lt;br/&gt;
                 .expressionLanguageSupported(false)&lt;br/&gt;
                 .addValidator(StandardValidators.INTEGER_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I have no intention to speak SMTP. I am relying on the underlying API to do that and if it&apos;s inadequate, then let&apos;s look for a better API.&lt;/p&gt;</comment>
                            <comment id="15417282" author="githubbot" created="Thu, 11 Aug 2016 13:54:50 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74425869&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74425869&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -135,29 +89,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_MSG_SIZE = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    We can definitely look at this as an improvement in the future&lt;/p&gt;</comment>
                            <comment id="15417290" author="githubbot" created="Thu, 11 Aug 2016 14:01:26 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74427203&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74427203&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +69,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
                 .name(&quot;SMTP_MAXIMUM_CONNECTIONS&quot;)&lt;br/&gt;
                 .displayName(&quot;Maximum number of SMTP connection&quot;)&lt;br/&gt;
                 .description(&quot;The maximum number of simultaneous SMTP connections.&quot;)&lt;br/&gt;
                 .required(true)&lt;br/&gt;
    +            .defaultValue(&quot;1&quot;)&lt;br/&gt;
                 .expressionLanguageSupported(false)&lt;br/&gt;
                 .addValidator(StandardValidators.INTEGER_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_TIMEOUT = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Agree with that. &lt;/p&gt;</comment>
                            <comment id="15417410" author="githubbot" created="Thu, 11 Aug 2016 15:20:25 +0000"  >&lt;p&gt;Github user joewitt commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    based on @olegz and @trixpan comments about port 25 i agree we should leave it unset.&lt;/p&gt;</comment>
                            <comment id="15417418" author="githubbot" created="Thu, 11 Aug 2016 15:25:01 +0000"  >&lt;p&gt;Github user trixpan commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @olegz You are clearly confusing envelope (the data exchanged within an SMTP session) with header information (the data added to the body of the message after the DATA command). &lt;/p&gt;

&lt;p&gt;    They don&apos;t need to match. &lt;/p&gt;

&lt;p&gt;    MAIL FROM is an envelope detail it is NOT added to a message. Please refer back to this comment:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74362397&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74362397&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Note how although MAIL FROM was set to aaa@aaa.com this information never makes into the resulting flowfile. &lt;/p&gt;

&lt;p&gt;    The RCPT TO input makes to it but requires a multiline regex to parse it and that regex will be quite brittle as resolution will require a IPv4 / IPv6 match, variable domains and so it goes.&lt;/p&gt;</comment>
                            <comment id="15417469" author="githubbot" created="Thu, 11 Aug 2016 15:46:51 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    i see now. Putting it in&lt;/p&gt;</comment>
                            <comment id="15417479" author="githubbot" created="Thu, 11 Aug 2016 15:55:33 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74449761&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74449761&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -31,101 +30,75 @@&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
     import java.util.Map;&lt;br/&gt;
     import java.util.Set;&lt;br/&gt;
    -import java.util.concurrent.LinkedBlockingQueue;&lt;br/&gt;
     import java.util.concurrent.TimeUnit;&lt;br/&gt;
    -import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    -import org.apache.nifi.annotation.lifecycle.OnUnscheduled;&lt;br/&gt;
    -import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    -import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicInteger;&lt;/p&gt;

&lt;p&gt;    -import org.apache.nifi.annotation.lifecycle.OnScheduled;&lt;br/&gt;
    -import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
    -import org.apache.nifi.processor.AbstractProcessor;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessorInitializationContext;&lt;br/&gt;
    -import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    -import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
    +import javax.net.ssl.SSLContext;&lt;br/&gt;
    +import javax.net.ssl.SSLSocket;&lt;br/&gt;
    +import javax.net.ssl.SSLSocketFactory;&lt;/p&gt;

&lt;p&gt;    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.InputRequirement;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.WritesAttribute;&lt;br/&gt;
     import org.apache.nifi.annotation.behavior.WritesAttributes;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.CapabilityDescription;&lt;br/&gt;
     import org.apache.nifi.annotation.documentation.Tags;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
    -import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    -import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    +import org.apache.nifi.annotation.lifecycle.OnStopped;&lt;br/&gt;
    +import org.apache.nifi.components.PropertyDescriptor;&lt;br/&gt;
     import org.apache.nifi.components.ValidationContext;&lt;br/&gt;
     import org.apache.nifi.components.ValidationResult;&lt;br/&gt;
     import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.processor.AbstractSessionFactoryProcessor;&lt;br/&gt;
    +import org.apache.nifi.processor.DataUnit;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessContext;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.Relationship;&lt;br/&gt;
    +import org.apache.nifi.processor.exception.ProcessException;&lt;br/&gt;
    +import org.apache.nifi.processor.io.OutputStreamCallback;&lt;br/&gt;
    +import org.apache.nifi.processor.util.StandardValidators;&lt;br/&gt;
     import org.apache.nifi.ssl.SSLContextService;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.event.SmtpEvent;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPResultCode;&lt;br/&gt;
    -import org.apache.nifi.processors.email.smtp.handler.SMTPMessageHandlerFactory;&lt;br/&gt;
    +import org.springframework.util.StringUtils;&lt;br/&gt;
    +import org.subethamail.smtp.MessageContext;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;/p&gt;

&lt;p&gt;     @Tags(&lt;/p&gt;
{&quot;listen&quot;, &quot;email&quot;, &quot;smtp&quot;}
&lt;p&gt;)&lt;br/&gt;
     @InputRequirement(InputRequirement.Requirement.INPUT_FORBIDDEN)&lt;br/&gt;
    -@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;allowing nifi to listen for incoming email. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Note this server does not perform any email validation. If direct exposure to the internet is sought,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot;it may be a better idea to use the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
    +@CapabilityDescription(&quot;This processor implements a lightweight SMTP server to an arbitrary port, &quot;&lt;br/&gt;
    +        + &quot;allowing nifi to listen for incoming email. Note this server does not perform any email &quot;&lt;br/&gt;
    +        + &quot;validation. If direct exposure to the internet is sought, it may be a better idea to use &quot;&lt;br/&gt;
    +        + &quot;the combination of NiFi and an industrial scale MTA (e.g. Postfix)&quot;)&lt;br/&gt;
     @WritesAttributes(
{
    -        @WritesAttribute(attribute = &quot;mime.type&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.serial&quot;, description = &quot;The serial numbers for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.certificates.*.principal&quot;, description = &quot;The principal for each of the &quot; +
    -                &quot;certificates used by an TLS peer&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.from&quot;, description = &quot;The value used during MAIL FROM (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.to&quot;, description = &quot;The value used during RCPT TO (i.e. envelope)&quot;),
    -        @WritesAttribute(attribute = &quot;smtp.src&quot;, description = &quot;The source IP of the SMTP connection&quot;)}
&lt;p&gt;)&lt;br/&gt;
    -&lt;br/&gt;
    -public class ListenSMTP extends AbstractProcessor {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static final String SMTP_HELO = &quot;smtp.helo&quot;;&lt;/li&gt;
	&lt;li&gt;public static final String SMTP_FROM = &quot;smtp.from&quot;;&lt;/li&gt;
	&lt;li&gt;public static final String SMTP_TO = &quot;smtp.to&quot;;&lt;/li&gt;
	&lt;li&gt;public static final String MIME_TYPE = &quot;message/rfc822&quot;;&lt;/li&gt;
	&lt;li&gt;public static final String SMTP_SRC_IP = &quot;smtp.src&quot;;&lt;br/&gt;
    -&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_PORT = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    @WritesAttribute(attribute = &quot;smtp.helo&quot;, description = &quot;The value used during HELO&quot;),
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @olegz My apologies but I missed the mime type completely...&lt;/p&gt;

&lt;p&gt;    The original description is wrong but in any case:&lt;/p&gt;

&lt;p&gt;    This is NOT the mime type of the attachments (these are extracted by ExtractEmailAttachments) &lt;br/&gt;
    Instead this was set with a non variable value &quot;message/rfc822&quot; (This is the standard mime type of a text file containing an email message (which is what this Listener produces)).&lt;/p&gt;

&lt;p&gt;    As with previous the addition of mime.type follows the pattern used everywhere around as seen here:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/search?utf8=%E2%9C%93&amp;amp;q=%40WritesAttribute%28attribute+%3D+%22mime.type%22&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/search?utf8=%E2%9C%93&amp;amp;q=%40WritesAttribute%28attribute+%3D+%22mime.type%22&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;    Apologies for noting this earlier.&lt;/p&gt;
</comment>
                            <comment id="15417490" author="githubbot" created="Thu, 11 Aug 2016 16:00:12 +0000"  >&lt;p&gt;Github user joewitt commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @trixpan and @olegz great discussion going here.  I just ask you find a good &apos;this is right for first iteration&apos; then let&apos;s get it in the hands of users and get more feedback to improve on.  We can absolutely add and make this more full over time.  But it must first be super stable and tests super reliable.&lt;/p&gt;</comment>
                            <comment id="15417502" author="githubbot" created="Thu, 11 Aug 2016 16:09:14 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Ok @joewitt @trixpan latest comments are addressed in the latest commit. Please review&lt;/p&gt;</comment>
                            <comment id="15417537" author="githubbot" created="Thu, 11 Aug 2016 16:36:46 +0000"  >&lt;p&gt;Github user trixpan commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @joewitt, @olegz code is a great improvement to the previous code.&lt;/p&gt;

&lt;p&gt;    I do think the the removal of the maximum message size and timeout checks should be addressed as soon as possible:&lt;/p&gt;

&lt;p&gt;    I base my opinion solely on the fact their absence will cause issues to the clients sending emails/flows via this interface. &lt;/p&gt;

&lt;p&gt;    As the processor currently lacks the ability to provide the appropriate SMTP reply codes back to the connecting clients, both ListenSMTP and connecting MTAs will waste resource every time a a connection times out (I am not 100% sure how the size issue will unfold). &lt;/p&gt;

&lt;p&gt;    Postfix documentation describes this scenario:&lt;/p&gt;

&lt;p&gt;    &amp;gt; smtp_data_done_timeout (default: 600s)&lt;br/&gt;
    &amp;gt; The Postfix SMTP client time limit for sending the SMTP &quot;.&quot;, and for receiving the remote SMTP server response.&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; When no response is received within the deadline, a warning is logged that the mail may be delivered multiple times.&lt;/p&gt;

&lt;p&gt;    Note the whooping 600s before postfix gives up and disconnect.&lt;/p&gt;

&lt;p&gt;    Having said that, I am happy to defer this decision to the wider group.&lt;/p&gt;</comment>
                            <comment id="15417540" author="githubbot" created="Thu, 11 Aug 2016 16:38:08 +0000"  >&lt;p&gt;Github user trixpan commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @olegz is this expected?&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    2016-08-12 01:23:59,420 ERROR &lt;span class=&quot;error&quot;&gt;&amp;#91;Timer-Driven Process Thread-6&amp;#93;&lt;/span&gt; o.a.nifi.processors.email.ListenSMTP&lt;br/&gt;
    org.apache.nifi.processor.exception.ProcessException: IOException thrown from ListenSMTP&lt;span class=&quot;error&quot;&gt;&amp;#91;id=771e0608-0156-1000-832a-7f44efc04123&amp;#93;&lt;/span&gt;: java.net.SocketTimeoutException: Read timed out&lt;br/&gt;
            at org.apache.nifi.controller.repository.StandardProcessSession.write(StandardProcessSession.java:2138) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-framework-core-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.nifi.processors.email.ListenSMTP.lambda$onTrigger$0(ListenSMTP.java:202) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-email-processors-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.nifi.processors.email.SmtpConsumer.consumeUsing(SmtpConsumer.java:104) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-email-processors-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.nifi.processors.email.ListenSMTP.onTrigger(ListenSMTP.java:199) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-email-processors-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.nifi.controller.StandardProcessorNode.onTrigger(StandardProcessorNode.java:1060) &lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-framework-core-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.nifi.controller.tasks.ContinuallyRunProcessorTask.call(ContinuallyRunProcessorTask.java:136) &lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-framework-core-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.nifi.controller.tasks.ContinuallyRunProcessorTask.call(ContinuallyRunProcessorTask.java:47) &lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-framework-core-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.nifi.controller.scheduling.TimerDrivenSchedulingAgent$1.run(TimerDrivenSchedulingAgent.java:127) &lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-framework-core-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.lang.Thread.run(Thread.java:745) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
    Caused by: java.net.SocketTimeoutException: Read timed out&lt;br/&gt;
            at java.net.SocketInputStream.socketRead0(Native Method) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.net.SocketInputStream.read(SocketInputStream.java:170) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.net.SocketInputStream.read(SocketInputStream.java:141) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.io.BufferedInputStream.fill(BufferedInputStream.java:246) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.io.BufferedInputStream.read(BufferedInputStream.java:265) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.io.DotTerminatedInputStream.readWrappedStream(DotTerminatedInputStream.java:109) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;subethasmtp-3.1.7.jar:June 16 2012&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.io.DotTerminatedInputStream.read(DotTerminatedInputStream.java:75) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;subethasmtp-3.1.7.jar:June 16 2012&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.io.DotUnstuffingInputStream.read(DotUnstuffingInputStream.java:47) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;subethasmtp-3.1.7.jar:June 16 2012&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.io.DotUnstuffingInputStream.read(DotUnstuffingInputStream.java:76) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;subethasmtp-3.1.7.jar:June 16 2012&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.io.FilterInputStream.read(FilterInputStream.java:133) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.io.ReceivedHeaderStream.read(ReceivedHeaderStream.java:131) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;subethasmtp-3.1.7.jar:June 16 2012&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.io.ReceivedHeaderStream.read(ReceivedHeaderStream.java:146) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;subethasmtp-3.1.7.jar:June 16 2012&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.commons.io.IOUtils.copyLarge(IOUtils.java:2146) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;commons-io-2.5.jar:2.5&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.commons.io.IOUtils.copy(IOUtils.java:2102) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;commons-io-2.5.jar:2.5&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.commons.io.IOUtils.copyLarge(IOUtils.java:2123) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;commons-io-2.5.jar:2.5&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.commons.io.IOUtils.copy(IOUtils.java:2078) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;commons-io-2.5.jar:2.5&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.nifi.processors.email.ListenSMTP$1.process(ListenSMTP.java:205) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-email-processors-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.apache.nifi.controller.repository.StandardProcessSession.write(StandardProcessSession.java:2123) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;nifi-framework-core-1.0.0-SNAPSHOT.jar:1.0.0-SNAPSHOT&amp;#93;&lt;/span&gt;&lt;br/&gt;
            ... 14 common frames omitted&lt;/p&gt;

&lt;p&gt;    ```&lt;/p&gt;</comment>
                            <comment id="15417547" author="githubbot" created="Thu, 11 Aug 2016 16:41:03 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @trixpan could you please describe scenario that triggered the above exception?&lt;/p&gt;
</comment>
                            <comment id="15417560" author="githubbot" created="Thu, 11 Aug 2016 16:45:49 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @trixpan i think you&apos;ve closed client while it was in he middle of reading InputStream. If that&apos;s the case then yes the stack trace above is exactly what one would expect.&lt;/p&gt;</comment>
                            <comment id="15417568" author="githubbot" created="Thu, 11 Aug 2016 16:49:33 +0000"  >&lt;p&gt;Github user trixpan commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    1. Start ListenSMTP port 2525 with 1 maximum connection, 10 seconds of timeout&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    $ telnet 0 2525&lt;br/&gt;
    Trying 0.0.0.0...&lt;br/&gt;
    Connected to 0.&lt;br/&gt;
    Escape character is &apos;^]&apos;.&lt;br/&gt;
    220 localhost ESMTP Apache NiFi&lt;br/&gt;
    helo .&lt;br/&gt;
    250 localhost&lt;br/&gt;
    mail from: x&lt;br/&gt;
    250 Ok&lt;br/&gt;
    rcpt to: x&lt;br/&gt;
    250 Ok&lt;br/&gt;
    data&lt;br/&gt;
    354 End data with &amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;.&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;br/&gt;
    ```&lt;/p&gt;


&lt;p&gt;    wait for longer than timeout&lt;/p&gt;</comment>
                            <comment id="15417581" author="githubbot" created="Thu, 11 Aug 2016 16:57:18 +0000"  >&lt;p&gt;Github user trixpan commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Stopping the processor with an agent connected also seems to throw an exception (not sure if expected)&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    2016-08-12 01:42:06,593 INFO &lt;span class=&quot;error&quot;&gt;&amp;#91;StandardProcessScheduler Thread-7&amp;#93;&lt;/span&gt; org.subethamail.smtp.server.SMTPServer SMTP server *:2525 stopping&lt;br/&gt;
    2016-08-12 01:42:06,594 INFO &lt;span class=&quot;error&quot;&gt;&amp;#91;org.subethamail.smtp.server.ServerThread *:2525&amp;#93;&lt;/span&gt; org.subethamail.smtp.server.ServerThread SMTP server *:2525 stopped&lt;br/&gt;
    2016-08-12 01:42:06,596 ERROR &lt;span class=&quot;error&quot;&gt;&amp;#91;org.subethamail.smtp.server.Session-/127.0.0.1:38072&amp;#93;&lt;/span&gt; org.subethamail.smtp.server.Session Unexpected error in the SMTP handler thread&lt;br/&gt;
    java.lang.IllegalStateException: NIFI Consumer was stopped before message was successfully consumed by NiFi&lt;br/&gt;
            at org.apache.nifi.processors.email.SmtpConsumer.data(SmtpConsumer.java:125) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.command.DataCommand.execute(DataCommand.java:64) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.server.RequireTLSCommandWrapper.execute(RequireTLSCommandWrapper.java:30) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.server.CommandHandler.handleCommand(CommandHandler.java:99) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.server.Session.runCommandLoop(Session.java:244) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.server.Session.run(Session.java:145) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.lang.Thread.run(Thread.java:745) &lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
    2016-08-12 01:42:06,597 ERROR &lt;span class=&quot;error&quot;&gt;&amp;#91;pool-33-thread-1&amp;#93;&lt;/span&gt; org.apache.nifi.NiFi An Unknown Error Occurred in Thread Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;pool-33-thread-1,5,main&amp;#93;&lt;/span&gt;: java.lang.IllegalStateException: NIFI Consumer was stopped before message was successfully consumed by NiFi&lt;br/&gt;
    2016-08-12 01:42:06,599 ERROR &lt;span class=&quot;error&quot;&gt;&amp;#91;pool-33-thread-1&amp;#93;&lt;/span&gt; org.apache.nifi.NiFi&lt;br/&gt;
    java.lang.IllegalStateException: NIFI Consumer was stopped before message was successfully consumed by NiFi&lt;br/&gt;
            at org.apache.nifi.processors.email.SmtpConsumer.data(SmtpConsumer.java:125) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.command.DataCommand.execute(DataCommand.java:64) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.server.RequireTLSCommandWrapper.execute(RequireTLSCommandWrapper.java:30) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.server.CommandHandler.handleCommand(CommandHandler.java:99) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.server.Session.runCommandLoop(Session.java:244) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at org.subethamail.smtp.server.Session.run(Session.java:145) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:na&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;br/&gt;
            at java.lang.Thread.run(Thread.java:745) ~&lt;span class=&quot;error&quot;&gt;&amp;#91;na:1.8.0_91&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    ```&lt;/p&gt;</comment>
                            <comment id="15417586" author="githubbot" created="Thu, 11 Aug 2016 16:58:51 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    The above is actually correct and is exactly what we were aiming for. No data loss. There is actually new test that validates for that exact message. So all is good. User is notified that something went wrong and can resend the message&lt;/p&gt;</comment>
                            <comment id="15417590" author="githubbot" created="Thu, 11 Aug 2016 17:01:33 +0000"  >&lt;p&gt;Github user trixpan commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @olegz have you pushed the notification recently? I got just an abrupt termination&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    $ telnet 0 2525&lt;br/&gt;
    Trying 0.0.0.0...&lt;br/&gt;
    Connected to 0.&lt;br/&gt;
    Escape character is &apos;^]&apos;.&lt;br/&gt;
    220 localhost ESMTP Apache NiFi&lt;br/&gt;
    helo .&lt;br/&gt;
    250 localhost&lt;br/&gt;
    mail from: x&lt;br/&gt;
    250 Ok&lt;br/&gt;
    rcpt to: y&lt;br/&gt;
    250 Ok&lt;br/&gt;
    data&lt;br/&gt;
    354 End data with &amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;.&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;br/&gt;
    waiting for server to get bored&lt;br/&gt;
    Connection closed by foreign host.&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    Note the connection close as soon I stop the server&lt;/p&gt;</comment>
                            <comment id="15417597" author="githubbot" created="Thu, 11 Aug 2016 17:05:13 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @trixpan just confirmed, the &quot;Read timed out&quot; exception is the correct behavior, but I will wrap it into a nicer log message. But just to confirm the behavior is expected&lt;/p&gt;</comment>
                            <comment id="15417604" author="githubbot" created="Thu, 11 Aug 2016 17:07:57 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @trixpan what notification? The exception is thrown by the SMTPServer&apos;s thread without ever sending any type of ack about successful consumption of the message so abrupt termination especially with message such as &apos;closed by foreign host&apos; simply means server is done and your message was not successfully delivered.&lt;/p&gt;</comment>
                            <comment id="15417610" author="githubbot" created="Thu, 11 Aug 2016 17:15:22 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @trixpan with regard to &quot;Read timeout&quot; I&apos;ve just added better exception handling to notify user &lt;a href=&quot;https://github.com/apache/nifi/pull/827/commits/406b37b249e487f73bae5a260bd5aed05d320192#diff-be7be540c5e3dfb436cea96d2073e28fR216&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827/commits/406b37b249e487f73bae5a260bd5aed05d320192#diff-be7be540c5e3dfb436cea96d2073e28fR216&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15417612" author="githubbot" created="Thu, 11 Aug 2016 17:16:48 +0000"  >&lt;p&gt;Github user trixpan commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @olegz thanks for the clarification.&lt;/p&gt;

&lt;p&gt;    Just so that we are on the same page, I am not concerned about the DFM in this case.&lt;/p&gt;

&lt;p&gt;    What I mean by notification is the following: &lt;/p&gt;

&lt;p&gt;    SMTP allows you to convey messages back to the client (These messages are called reply codes).&lt;/p&gt;

&lt;p&gt;    You can send a 5XX reply back and the server will not retry&lt;/p&gt;

&lt;p&gt;    Or you can send a 4XX and the server will retry after a few minutes.&lt;/p&gt;

&lt;p&gt;    Send nothing and reaction will depend on who is sending.&lt;/p&gt;

&lt;p&gt;    Here&apos;s a list:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://www.greenend.org.uk/rjk/tech/smtpreplies.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.greenend.org.uk/rjk/tech/smtpreplies.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    This is why this was in here:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/blob/master/nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/smtp/handler/SMTPResultCode.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/blob/master/nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/smtp/handler/SMTPResultCode.java&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15417625" author="githubbot" created="Thu, 11 Aug 2016 17:21:06 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I understand that and these are all good suggestions to improve in the future, but as Joe pointed out let&apos;s first settle on &quot;this is right for first iteration&quot; - meaning that one can interact with it and get message exchange going without message loss. Then  let&apos;s give it some miles and see how it is used/applied in the workforce and then improve based on requirements at that time. &lt;/p&gt;</comment>
                            <comment id="15418074" author="githubbot" created="Thu, 11 Aug 2016 22:43:27 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @joewitt @trixpan Just pushed one more commit (un-squashed) with some minor polishing and few additional tests to validate that SmtpConsumer does not produce deadlocks due to its synchronous nature while connecting two threads (SMTPServer and NiFi).&lt;br/&gt;
    Let me know when I should squash it.&lt;/p&gt;</comment>
                            <comment id="15418175" author="githubbot" created="Fri, 12 Aug 2016 00:26:15 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74527077&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74527077&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +90,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @olegz is SMTP_MAXIMUM_CONNECTIONS being enforced at all? &lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    $ date &amp;amp;&amp;amp; telnet 0 2525&lt;br/&gt;
    Fri Aug 12 09:02:31 AEST 2016&lt;br/&gt;
    Trying 0.0.0.0...&lt;br/&gt;
    Connected to 0.&lt;br/&gt;
    Escape character is &apos;^]&apos;.&lt;br/&gt;
    220 localhost ESMTP Apache NiFi&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    $ date &amp;amp;&amp;amp; telnet 0 2525&lt;br/&gt;
    Fri Aug 12 09:02:30 AEST 2016&lt;br/&gt;
    Trying 0.0.0.0...&lt;br/&gt;
    Connected to 0.&lt;br/&gt;
    Escape character is &apos;^]&apos;.&lt;br/&gt;
    220 localhost ESMTP Apache NiFi&lt;/p&gt;

&lt;p&gt;    I did this test and it doesn&apos;t seem to be:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    $ date  &amp;amp;&amp;amp; netstat -an| grep 2525 | pcregrep &quot;2525\s+ES&quot;&lt;br/&gt;
    Fri Aug 12 09:02:33 AEST 2016&lt;br/&gt;
    tcp        0      0 0.0.0.0:2525                0.0.0.0:*                   LISTEN&lt;br/&gt;
    tcp        0      0 127.0.0.1:38840             127.0.0.1:2525              ESTABLISHED&lt;br/&gt;
    tcp        0      0 127.0.0.1:38842             127.0.0.1:2525              ESTABLISHED&lt;br/&gt;
    ```&lt;/p&gt;

</comment>
                            <comment id="15418176" author="githubbot" created="Fri, 12 Aug 2016 00:27:13 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74527137&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74527137&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +90,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It is propagated to the target API&lt;/p&gt;</comment>
                            <comment id="15418178" author="githubbot" created="Fri, 12 Aug 2016 00:28:09 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74527190&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74527190&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +90,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @olegz I imagined so. Not working as expected though (not sure why to be honest).&lt;/p&gt;</comment>
                            <comment id="15418184" author="githubbot" created="Fri, 12 Aug 2016 00:35:01 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827#discussion_r74527655&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827#discussion_r74527655&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/ListenSMTP.java &amp;#8212;&lt;br/&gt;
    @@ -106,26 +90,17 @@&lt;br/&gt;
                 .addValidator(StandardValidators.PORT_VALIDATOR)&lt;br/&gt;
                 .build();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_HOSTNAME = new PropertyDescriptor.Builder()&lt;/li&gt;
	&lt;li&gt;.name(&quot;SMTP_HOSTNAME&quot;)&lt;/li&gt;
	&lt;li&gt;.displayName(&quot;SMTP hostname&quot;)&lt;/li&gt;
	&lt;li&gt;.description(&quot;The hostname to be embedded into the banner displayed when an &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;SMTP client connects to the processor TCP port .&quot;)&lt;/li&gt;
	&lt;li&gt;.required(true)&lt;/li&gt;
	&lt;li&gt;.expressionLanguageSupported(false)&lt;/li&gt;
	&lt;li&gt;.addValidator(StandardValidators.NON_EMPTY_VALIDATOR)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;protected static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()&lt;br/&gt;
    +    static final PropertyDescriptor SMTP_MAXIMUM_CONNECTIONS = new PropertyDescriptor.Builder()
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @olegz If we cannot enforce Size, Timeout and Max Connections perhaps its time to consider changing the SMTP server API used here? &lt;/p&gt;</comment>
                            <comment id="15418197" author="joewitt" created="Fri, 12 Aug 2016 00:53:27 +0000"  >&lt;p&gt;sounds like timeouts are sorted.&lt;/p&gt;

&lt;p&gt;We can easily protect from bad acting clients sending arbitrarily large data by just killing the connection if they exceed a max size and we know precisely how much we&apos;re writing to the repo.  So that we should definitely do.&lt;/p&gt;

&lt;p&gt;And yes if the client can make arbitrary number of connections and exhaust resources we should address that as well.&lt;/p&gt;

&lt;p&gt;I&apos;ll take a look at both as I dig through the PR more fully.&lt;/p&gt;</comment>
                            <comment id="15418261" author="joewitt" created="Fri, 12 Aug 2016 02:15:11 +0000"  >&lt;p&gt;Regarding message size: Looks like we need to do it ourselves.  The size being sent is just a advertising sort of thing.  &lt;br/&gt;
  &lt;a href=&quot;https://github.com/voodoodyne/subethasmtp/blob/3.1.7/src/main/java/org/subethamail/smtp/server/SMTPServer.java#L106-L113&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/voodoodyne/subethasmtp/blob/3.1.7/src/main/java/org/subethamail/smtp/server/SMTPServer.java#L106-L113&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Regarding max connections&lt;br/&gt;
  We do have the property but we&apos;re never setting it on the subethasmtp api.&lt;/p&gt;

&lt;p&gt;Will provide a patch to address these two remaining items shortly.&lt;/p&gt;</comment>
                            <comment id="15418361" author="joewitt" created="Fri, 12 Aug 2016 04:43:20 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
Patch that fixes max connections and enforces max data size is attached.&lt;/p&gt;

&lt;p&gt;Also, got in a &apos;STOPPING&apos; state again.  Thread dump results related to SMTP included&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&quot;org.subethamail.smtp.server.Session-/127.0.0.1:61707&quot; Id=88 TIMED_WAITING  on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@26e92b1f&lt;br/&gt;
        at sun.misc.Unsafe.park(Native Method)&lt;br/&gt;
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)&lt;br/&gt;
        at java.util.concurrent.ArrayBlockingQueue.offer(ArrayBlockingQueue.java:379)&lt;br/&gt;
        at org.apache.nifi.processors.email.SmtpConsumer.data(SmtpConsumer.java:134)&lt;br/&gt;
        at org.subethamail.smtp.command.DataCommand.execute(DataCommand.java:64)&lt;br/&gt;
        at org.subethamail.smtp.server.RequireTLSCommandWrapper.execute(RequireTLSCommandWrapper.java:30)&lt;br/&gt;
        at org.subethamail.smtp.server.CommandHandler.handleCommand(CommandHandler.java:99)&lt;br/&gt;
        at org.subethamail.smtp.server.Session.runCommandLoop(Session.java:244)&lt;br/&gt;
        at org.subethamail.smtp.server.Session.run(Session.java:145)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:745)&lt;br/&gt;
        Number of Locked Synchronizers: 1&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;java.util.concurrent.ThreadPoolExecutor$Worker@508e2f01&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;&quot;StandardProcessScheduler Thread-2&quot; Id=62 TIMED_WAITING  on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@499006ab&lt;br/&gt;
        at sun.misc.Unsafe.park(Native Method)&lt;br/&gt;
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.awaitTermination(ThreadPoolExecutor.java:1465)&lt;br/&gt;
        at org.subethamail.smtp.server.ServerThread.shutdownSessions(ServerThread.java:239)&lt;br/&gt;
        at org.subethamail.smtp.server.ServerThread.shutdown(ServerThread.java:190)&lt;br/&gt;
        at org.subethamail.smtp.server.SMTPServer.stop(SMTPServer.java:310)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;waiting on org.apache.nifi.processors.email.ListenSMTP$ConsumerAwareSmtpServer@4bd2366c&lt;br/&gt;
        at org.apache.nifi.processors.email.ListenSMTP$ConsumerAwareSmtpServer.stop(ListenSMTP.java:355)&lt;/li&gt;
	&lt;li&gt;waiting on org.apache.nifi.processors.email.ListenSMTP$ConsumerAwareSmtpServer@4bd2366c&lt;br/&gt;
        at org.apache.nifi.processors.email.ListenSMTP.stop(ListenSMTP.java:228)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:497)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.invokeMethodsWithAnnotations(ReflectionUtils.java:137)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.invokeMethodsWithAnnotations(ReflectionUtils.java:125)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.quietlyInvokeMethodsWithAnnotations(ReflectionUtils.java:233)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.quietlyInvokeMethodsWithAnnotation(ReflectionUtils.java:85)&lt;br/&gt;
        at org.apache.nifi.controller.StandardProcessorNode$2.run(StandardProcessorNode.java:1326)&lt;br/&gt;
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)&lt;br/&gt;
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)&lt;br/&gt;
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)&lt;br/&gt;
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:745)&lt;br/&gt;
        Number of Locked Synchronizers: 1&lt;/li&gt;
	&lt;li&gt;java.util.concurrent.ThreadPoolExecutor$Worker@75caecf7&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Also&lt;/p&gt;

&lt;p&gt;1) There is no LICENSE and NOTICE information present in the nifi-email-nar.  There definitely should be.  There are numerous jars from Spring and others that must be accounted for and if necessary needs to be rolled up to nifi-assembly as well.&lt;/p&gt;

&lt;p&gt;2) Default throughput is pretty poor due to the yield call happening whenever there is no data.  The processor call to check for a message should do some short term polling/blocking of say 10-20ms rather than immediately return and yield.  This would give far more performance as evidenced by the gains in lowering yield to 10ms.&lt;/p&gt;

&lt;p&gt;With the blocking fixed and items #1 and #2 addressed I think we&apos;re there.&lt;/p&gt;

&lt;p&gt;Have a nice flow with this processor listenign to emails being fed to it at a decent clip, then doing ExtractEmailHEader and ExtractEmail Attachment.  Works great.&lt;/p&gt;</comment>
                            <comment id="15419251" author="githubbot" created="Fri, 12 Aug 2016 18:21:19 +0000"  >&lt;p&gt;Github user joewitt commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    the new PR uses instance array for buffer.  This will be a problem under multiple threads.&lt;/p&gt;

&lt;p&gt;    the references in LICENSE to JOpt Simple and JLines..is this copy and paste or are those really in the build?&lt;/p&gt;</comment>
                            <comment id="15419474" author="joewitt" created="Fri, 12 Aug 2016 21:01:41 +0000"  >&lt;p&gt;Deadlock still there...&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&quot;StandardProcessScheduler Thread-5&quot; Id=156 TIMED_WAITING  on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@3cd8b9a6&lt;br/&gt;
        at sun.misc.Unsafe.park(Native Method)&lt;br/&gt;
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.awaitTermination(ThreadPoolExecutor.java:1465)&lt;br/&gt;
        at org.subethamail.smtp.server.ServerThread.shutdownSessions(ServerThread.java:239)&lt;br/&gt;
        at org.subethamail.smtp.server.ServerThread.shutdown(ServerThread.java:190)&lt;br/&gt;
        at org.subethamail.smtp.server.SMTPServer.stop(SMTPServer.java:310)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;waiting on org.apache.nifi.processors.email.ListenSMTP$ConsumerAwareSmtpServer@1c3fa4a6&lt;br/&gt;
        at org.apache.nifi.processors.email.ListenSMTP$ConsumerAwareSmtpServer.stop(ListenSMTP.java:376)&lt;/li&gt;
	&lt;li&gt;waiting on org.apache.nifi.processors.email.ListenSMTP$ConsumerAwareSmtpServer@1c3fa4a6&lt;br/&gt;
        at org.apache.nifi.processors.email.ListenSMTP.stop(ListenSMTP.java:230)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:497)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.invokeMethodsWithAnnotations(ReflectionUtils.java:137)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.invokeMethodsWithAnnotations(ReflectionUtils.java:125)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.quietlyInvokeMethodsWithAnnotations(ReflectionUtils.java:233)&lt;br/&gt;
        at org.apache.nifi.util.ReflectionUtils.quietlyInvokeMethodsWithAnnotation(ReflectionUtils.java:85)&lt;br/&gt;
        at org.apache.nifi.controller.StandardProcessorNode$2.run(StandardProcessorNode.java:1326)&lt;br/&gt;
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)&lt;br/&gt;
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)&lt;br/&gt;
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)&lt;br/&gt;
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:745)&lt;br/&gt;
        Number of Locked Synchronizers: 1&lt;/li&gt;
	&lt;li&gt;java.util.concurrent.ThreadPoolExecutor$Worker@246d3a7b&lt;/li&gt;
&lt;/ul&gt;




&lt;p&gt;&quot;org.subethamail.smtp.server.Session-/127.0.0.1:62163&quot; Id=207 TIMED_WAITING  on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@3d3d0835&lt;br/&gt;
        at sun.misc.Unsafe.park(Native Method)&lt;br/&gt;
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)&lt;br/&gt;
        at java.util.concurrent.ArrayBlockingQueue.offer(ArrayBlockingQueue.java:379)&lt;br/&gt;
        at org.apache.nifi.processors.email.SmtpConsumer.data(SmtpConsumer.java:147)&lt;br/&gt;
        at org.subethamail.smtp.command.DataCommand.execute(DataCommand.java:64)&lt;br/&gt;
        at org.subethamail.smtp.server.RequireTLSCommandWrapper.execute(RequireTLSCommandWrapper.java:30)&lt;br/&gt;
        at org.subethamail.smtp.server.CommandHandler.handleCommand(CommandHandler.java:99)&lt;br/&gt;
        at org.subethamail.smtp.server.Session.runCommandLoop(Session.java:244)&lt;br/&gt;
        at org.subethamail.smtp.server.Session.run(Session.java:145)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:745)&lt;br/&gt;
        Number of Locked Synchronizers: 1&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;java.util.concurrent.ThreadPoolExecutor$Worker@6151d941&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;


&lt;p&gt;Also, got corrupted emails through this.  Started up multiple threads on PutEmail and on ListenSMTP.  Noticed it was slower than single threaded and then it started having corrupt messages on occassion.&lt;/p&gt;</comment>
                            <comment id="15419512" author="joewitt" created="Fri, 12 Aug 2016 21:28:37 +0000"  >&lt;p&gt;the source of the livelock is clear and I believe resolved. Will have a patch for that soon.  Basically the &apos;data&apos; method was checking if stopped but then in an offer call forever so if stopped after the initial check but while waiting for space to be available (which it never would be since consumers were stopped) it will just sit there.  The solution appears as simple as stop indefinite offer but rather offer in a loop and check if we should give up in the loop due to stoppage.&lt;/p&gt;</comment>
                            <comment id="15420223" author="githubbot" created="Sun, 14 Aug 2016 05:41:07 +0000"  >&lt;p&gt;GitHub user joewitt opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/856&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/856&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; aligned processor to leverage the subethasmtp threading model &lt;/p&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/joewitt/incubator-nifi&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/joewitt/incubator-nifi&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/856.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/856.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #856&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit c4d750993b46e72506d7e19a5c5591ad1dc3f3b9&lt;br/&gt;
Author: Oleg Zhurakousky &amp;lt;oleg@suitcase.io&amp;gt;&lt;br/&gt;
Date:   2016-08-10T14:19:17Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added default for SMTP_MAXIMUM_CONNECTIONS&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed PR comments, polishing&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed intermittent deadlock on processor stop and added test for it&lt;/li&gt;
	&lt;li&gt;the attributes that can not be extracted from the message but available via MessageContext are written into the outgoing FlowFile&lt;/li&gt;
	&lt;li&gt;other minor fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed lates PR comments&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added better messaging when server closes the connection&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; some polishing and additional tests to validate deadlocks&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; address latest PR comments&lt;br/&gt;
    fixed deadlock condition for when the consumer is stopped while server is distributing messages&lt;br/&gt;
    fixed MAX message size issue ensuring it is validated&lt;br/&gt;
    set max connections to SMTPServer&lt;br/&gt;
    polished pom&lt;br/&gt;
    added L&amp;amp;N&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; PR comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed LICENSE&lt;/li&gt;
	&lt;li&gt;Added usage of LimitingInputStream&lt;/li&gt;
	&lt;li&gt;simplified SmtpConsumer by removing hasMessage operation&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;commit b7e65001471e83103ebfdfc85b4bdf0fa90820fa&lt;br/&gt;
Author: joewitt &amp;lt;joewitt@apache.org&amp;gt;&lt;br/&gt;
Date:   2016-08-14T05:10:47Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; aligned threading model with subethastmp&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15420227" author="joewitt" created="Sun, 14 Aug 2016 05:45:41 +0000"  >&lt;p&gt;Created a new PR based on Oleg&apos;s previous PR.  After tweaking and removing issues blocking proper processor stopping there were data corruption issues still present during testing.  Further evaluation revealed it was due to improper use of the subethasmtp API specifically as it relates to the MessageHandler which is something they expect to create for each message but that our implementation was creating as a single instance for the processor.  Also noticed that the recipient method was just overwriting previous recipient so changed that to accept multiple calls and write out all specified recipients.&lt;/p&gt;

&lt;p&gt;So, taking a step back and in looking through this discussion thread and thinking about it the requirements are:&lt;/p&gt;

&lt;p&gt;SubethaSMTP has its own threading and lifecycle model.  It has a message handler with start/stop methods we can connect to.&lt;br/&gt;
NiFi has its own threading and lifecycle model.&lt;br/&gt;
We want to ensure that unless we capture and commit data we return exceptions to the user.  This ensures no data loss but could mean duplication.  This is ok.&lt;br/&gt;
We want to ensure data is streamed from the client directly to disk.&lt;br/&gt;
We want to ensure the client cannot send arbitrarily large data.&lt;br/&gt;
We want to ensure Subethasmtp doesn&apos;t open too many connections.&lt;br/&gt;
We want to ensure when the processor is stopped it will kill all the subethasmtp threads.&lt;br/&gt;
We want to capture all the flow file metadata we can about the client ip, host, certificates, etc..&lt;br/&gt;
We should be able to give the message hanlder the process session factory and let it handle the lifecycle of nifi directly.&lt;br/&gt;
We don&apos;t need to make NiFi threads in addition to their threads.  Let&apos;s just use their model.&lt;/p&gt;

&lt;p&gt;So implemented PR 856.&lt;/p&gt;

&lt;p&gt;Unit tests cover normal non secure and TLS based transfers and excessive message size.&lt;br/&gt;
Tested excessive sized message. Works.&lt;br/&gt;
Tested manual mailing with intentional timeouts during DATA and other commands.  Works.&lt;br/&gt;
Tested killing sender and killing ListenSMTP.  Behaved as expected and well.&lt;br/&gt;
Tested with more senders than ListenSMTP could handle.  It rejected excess requests.&lt;br/&gt;
Tested at full rate.  Seems reasonable.&lt;br/&gt;
Tested and can no longer reproduce threading issues.&lt;/p&gt;</comment>
                            <comment id="15420249" author="githubbot" created="Sun, 14 Aug 2016 07:09:10 +0000"  >&lt;p&gt;Github user trixpan commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/856&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/856&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    :+1:&lt;/p&gt;

&lt;p&gt;    Tested manually and also forced some exceptions. ListenSMTP seems to handle errors very well, example:&lt;/p&gt;

&lt;p&gt;    Place breakpoint on &lt;/p&gt;

&lt;p&gt;    `processSession.getProvenanceReporter().receive(flowFile, &quot;smtp://&quot; + host + &quot;:&quot; + port + &quot;/&quot;, watch.getDuration(TimeUnit.MILLISECONDS));&lt;br/&gt;
    `&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    220 bermudatriangle ESMTP Apache NiFi SMTP&lt;br/&gt;
    helo ,&lt;br/&gt;
    250 bermudatriangle&lt;br/&gt;
    mail from: x&lt;br/&gt;
    250 Ok&lt;br/&gt;
    rcpt to: y&lt;br/&gt;
    250 Ok&lt;br/&gt;
    data&lt;br/&gt;
    354 End data with &amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;.&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;br/&gt;
    a&lt;br/&gt;
    .&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    evaluate flowFile so that is null. Let process continue. Following message is returned.&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    421 4.3.0 Mail system failure, closing transmission channel&lt;br/&gt;
    Connection closed by foreign host.&lt;br/&gt;
    ```&lt;/p&gt;
</comment>
                            <comment id="15420303" author="githubbot" created="Sun, 14 Aug 2016 11:26:19 +0000"  >&lt;p&gt;Github user trixpan commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/856#discussion_r74700141&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/856#discussion_r74700141&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/smtp/SmtpConsumer.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,161 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + *  Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + *  contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + *  this work for additional information regarding copyright ownership.&lt;br/&gt;
    + *  The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + *  (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + *  the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + *  Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + *  See the License for the specific language governing permissions and&lt;br/&gt;
    + *  limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.nifi.processors.email.smtp;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.InputStream;&lt;br/&gt;
    +import java.io.OutputStream;&lt;br/&gt;
    +import java.security.cert.Certificate;&lt;br/&gt;
    +import java.security.cert.X509Certificate;&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.HashMap;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import java.util.Map;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +import org.apache.commons.io.IOUtils;&lt;br/&gt;
    +import org.apache.nifi.flowfile.FlowFile;&lt;br/&gt;
    +import org.apache.nifi.flowfile.attributes.CoreAttributes;&lt;br/&gt;
    +import org.apache.nifi.logging.ComponentLog;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSession;&lt;br/&gt;
    +import org.apache.nifi.processor.ProcessSessionFactory;&lt;br/&gt;
    +import org.apache.nifi.processor.exception.FlowFileAccessException;&lt;br/&gt;
    +import org.apache.nifi.processors.email.ListenSMTP;&lt;br/&gt;
    +import org.apache.nifi.stream.io.LimitingInputStream;&lt;br/&gt;
    +import org.apache.nifi.util.StopWatch;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.subethamail.smtp.MessageContext;&lt;br/&gt;
    +import org.subethamail.smtp.MessageHandler;&lt;br/&gt;
    +import org.subethamail.smtp.RejectException;&lt;br/&gt;
    +import org.subethamail.smtp.TooMuchDataException;&lt;br/&gt;
    +import org.subethamail.smtp.server.SMTPServer;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * A simple consumer that provides a bridge between &apos;push&apos; message distribution&lt;br/&gt;
    + * provided by &lt;/p&gt;
{@link SMTPServer}
&lt;p&gt; and NiFi polling scheduler mechanism.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class SmtpConsumer implements MessageHandler {&lt;br/&gt;
    +&lt;br/&gt;
    +    private String from = null;&lt;br/&gt;
    +    private final List&amp;lt;String&amp;gt; recipientList = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +    private final MessageContext context;&lt;br/&gt;
    +    private final ProcessSessionFactory sessionFactory;&lt;br/&gt;
    +    private final int port;&lt;br/&gt;
    +    private final int maxMessageSize;&lt;br/&gt;
    +    private final ComponentLog log;&lt;br/&gt;
    +    private final String host;&lt;br/&gt;
    +&lt;br/&gt;
    +    public SmtpConsumer(&lt;br/&gt;
    +            final MessageContext context,&lt;br/&gt;
    +            final ProcessSessionFactory sessionFactory,&lt;br/&gt;
    +            final int port,&lt;br/&gt;
    +            final String host,&lt;br/&gt;
    +            final ComponentLog log,&lt;br/&gt;
    +            final int maxMessageSize&lt;br/&gt;
    +    ) {&lt;br/&gt;
    +        this.context = context;&lt;br/&gt;
    +        this.sessionFactory = sessionFactory;&lt;br/&gt;
    +        this.port = port;&lt;br/&gt;
    +        if (host == null || host.trim().isEmpty()) &lt;/p&gt;
{
    +            this.host = context.getSMTPServer().getHostName();
    +        }
&lt;p&gt; else &lt;/p&gt;
{
    +            this.host = host;
    +        }
&lt;p&gt;    +        this.log = log;&lt;br/&gt;
    +        this.maxMessageSize = maxMessageSize;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    String getFrom() &lt;/p&gt;
{
    +        return from;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    List&amp;lt;String&amp;gt; getRecipients() &lt;/p&gt;
{
    +        return Collections.unmodifiableList(recipientList);
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public void data(final InputStream data) throws RejectException, TooMuchDataException, IOException {&lt;br/&gt;
    +        final ProcessSession processSession = sessionFactory.createSession();&lt;br/&gt;
    +        final StopWatch watch = new StopWatch();&lt;br/&gt;
    +        watch.start();&lt;br/&gt;
    +        try {&lt;br/&gt;
    +            FlowFile flowFile = processSession.create();&lt;br/&gt;
    +            final AtomicBoolean limitExceeded = new AtomicBoolean(false);&lt;br/&gt;
    +            flowFile = processSession.write(flowFile, (OutputStream out) -&amp;gt; {&lt;br/&gt;
    +                final LimitingInputStream lis = new LimitingInputStream(data, maxMessageSize);&lt;br/&gt;
    +                IOUtils.copy(lis, out);&lt;br/&gt;
    +                if (lis.hasReachedLimit()) &lt;/p&gt;
{
    +                    limitExceeded.set(true);
    +                }
&lt;p&gt;    +            });&lt;br/&gt;
    +            if (limitExceeded.get()) &lt;/p&gt;
{
    +                throw new TooMuchDataException(&quot;Maximum message size limit reached - client must send smaller messages&quot;);
    +            }
&lt;p&gt;    +            flowFile = processSession.putAllAttributes(flowFile, extractMessageAttributes());&lt;br/&gt;
    +            watch.stop();&lt;br/&gt;
    +            processSession.getProvenanceReporter().receive(flowFile, &quot;smtp://&quot; + host + &quot;:&quot; + port + &quot;/&quot;, watch.getDuration(TimeUnit.MILLISECONDS));&lt;br/&gt;
    +            processSession.transfer(flowFile, ListenSMTP.REL_SUCCESS);&lt;br/&gt;
    +            processSession.commit();&lt;br/&gt;
    +        } catch (FlowFileAccessException | IllegalStateException | RejectException | IOException ex) &lt;/p&gt;
{
    +            log.error(&quot;Unable to fully process input due to &quot; + ex.getMessage(), ex);
    +            throw ex;
    +        }
&lt;p&gt; finally {&lt;br/&gt;
    +            processSession.rollback(); //make sure this happens no matter what - is safe&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    @joewitt fascinating refactor. &lt;/p&gt;

&lt;p&gt;    Would you mind explaining why the rollback is used and why it doesn&apos;t affect the commit above?&lt;/p&gt;</comment>
                            <comment id="15420321" author="githubbot" created="Sun, 14 Aug 2016 13:01:42 +0000"  >&lt;p&gt;Github user olegz commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/856&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/856&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    +1&lt;/p&gt;</comment>
                            <comment id="15420323" author="githubbot" created="Sun, 14 Aug 2016 13:08:09 +0000"  >&lt;p&gt;Github user olegz closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/827&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/827&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15420407" author="jira-bot" created="Sun, 14 Aug 2016 17:32:33 +0000"  >&lt;p&gt;Commit 48fa76ecfff410b09a0b97fd70468e028066e990 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added default for SMTP_MAXIMUM_CONNECTIONS&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed PR comments, polishing&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed intermittent deadlock on processor stop and added test for it&lt;/li&gt;
	&lt;li&gt;the attributes that can not be extracted from the message but available via MessageContext are written into the outgoing FlowFile&lt;/li&gt;
	&lt;li&gt;other minor fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed lates PR comments&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added better messaging when server closes the connection&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; some polishing and additional tests to validate deadlocks&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; address latest PR comments&lt;br/&gt;
fixed deadlock condition for when the consumer is stopped while server is distributing messages&lt;br/&gt;
fixed MAX message size issue ensuring it is validated&lt;br/&gt;
set max connections to SMTPServer&lt;br/&gt;
polished pom&lt;br/&gt;
added L&amp;amp;N&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; PR comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed LICENSE&lt;/li&gt;
	&lt;li&gt;Added usage of LimitingInputStream&lt;/li&gt;
	&lt;li&gt;simplified SmtpConsumer by removing hasMessage operation&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15420408" author="jira-bot" created="Sun, 14 Aug 2016 17:32:35 +0000"  >&lt;p&gt;Commit 48fa76ecfff410b09a0b97fd70468e028066e990 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added default for SMTP_MAXIMUM_CONNECTIONS&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed PR comments, polishing&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed intermittent deadlock on processor stop and added test for it&lt;/li&gt;
	&lt;li&gt;the attributes that can not be extracted from the message but available via MessageContext are written into the outgoing FlowFile&lt;/li&gt;
	&lt;li&gt;other minor fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed lates PR comments&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added better messaging when server closes the connection&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; some polishing and additional tests to validate deadlocks&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; address latest PR comments&lt;br/&gt;
fixed deadlock condition for when the consumer is stopped while server is distributing messages&lt;br/&gt;
fixed MAX message size issue ensuring it is validated&lt;br/&gt;
set max connections to SMTPServer&lt;br/&gt;
polished pom&lt;br/&gt;
added L&amp;amp;N&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; PR comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed LICENSE&lt;/li&gt;
	&lt;li&gt;Added usage of LimitingInputStream&lt;/li&gt;
	&lt;li&gt;simplified SmtpConsumer by removing hasMessage operation&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15420409" author="jira-bot" created="Sun, 14 Aug 2016 17:32:37 +0000"  >&lt;p&gt;Commit 48fa76ecfff410b09a0b97fd70468e028066e990 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added default for SMTP_MAXIMUM_CONNECTIONS&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed PR comments, polishing&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed intermittent deadlock on processor stop and added test for it&lt;/li&gt;
	&lt;li&gt;the attributes that can not be extracted from the message but available via MessageContext are written into the outgoing FlowFile&lt;/li&gt;
	&lt;li&gt;other minor fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed lates PR comments&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added better messaging when server closes the connection&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; some polishing and additional tests to validate deadlocks&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; address latest PR comments&lt;br/&gt;
fixed deadlock condition for when the consumer is stopped while server is distributing messages&lt;br/&gt;
fixed MAX message size issue ensuring it is validated&lt;br/&gt;
set max connections to SMTPServer&lt;br/&gt;
polished pom&lt;br/&gt;
added L&amp;amp;N&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; PR comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed LICENSE&lt;/li&gt;
	&lt;li&gt;Added usage of LimitingInputStream&lt;/li&gt;
	&lt;li&gt;simplified SmtpConsumer by removing hasMessage operation&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15420410" author="jira-bot" created="Sun, 14 Aug 2016 17:32:38 +0000"  >&lt;p&gt;Commit 48fa76ecfff410b09a0b97fd70468e028066e990 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added default for SMTP_MAXIMUM_CONNECTIONS&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed PR comments, polishing&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed intermittent deadlock on processor stop and added test for it&lt;/li&gt;
	&lt;li&gt;the attributes that can not be extracted from the message but available via MessageContext are written into the outgoing FlowFile&lt;/li&gt;
	&lt;li&gt;other minor fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed lates PR comments&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added better messaging when server closes the connection&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; some polishing and additional tests to validate deadlocks&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; address latest PR comments&lt;br/&gt;
fixed deadlock condition for when the consumer is stopped while server is distributing messages&lt;br/&gt;
fixed MAX message size issue ensuring it is validated&lt;br/&gt;
set max connections to SMTPServer&lt;br/&gt;
polished pom&lt;br/&gt;
added L&amp;amp;N&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; PR comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed LICENSE&lt;/li&gt;
	&lt;li&gt;Added usage of LimitingInputStream&lt;/li&gt;
	&lt;li&gt;simplified SmtpConsumer by removing hasMessage operation&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15420411" author="jira-bot" created="Sun, 14 Aug 2016 17:32:40 +0000"  >&lt;p&gt;Commit 48fa76ecfff410b09a0b97fd70468e028066e990 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added default for SMTP_MAXIMUM_CONNECTIONS&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed PR comments, polishing&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed intermittent deadlock on processor stop and added test for it&lt;/li&gt;
	&lt;li&gt;the attributes that can not be extracted from the message but available via MessageContext are written into the outgoing FlowFile&lt;/li&gt;
	&lt;li&gt;other minor fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed lates PR comments&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added better messaging when server closes the connection&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; some polishing and additional tests to validate deadlocks&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; address latest PR comments&lt;br/&gt;
fixed deadlock condition for when the consumer is stopped while server is distributing messages&lt;br/&gt;
fixed MAX message size issue ensuring it is validated&lt;br/&gt;
set max connections to SMTPServer&lt;br/&gt;
polished pom&lt;br/&gt;
added L&amp;amp;N&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; PR comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed LICENSE&lt;/li&gt;
	&lt;li&gt;Added usage of LimitingInputStream&lt;/li&gt;
	&lt;li&gt;simplified SmtpConsumer by removing hasMessage operation&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15420412" author="jira-bot" created="Sun, 14 Aug 2016 17:32:41 +0000"  >&lt;p&gt;Commit 48fa76ecfff410b09a0b97fd70468e028066e990 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added default for SMTP_MAXIMUM_CONNECTIONS&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed PR comments, polishing&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed intermittent deadlock on processor stop and added test for it&lt;/li&gt;
	&lt;li&gt;the attributes that can not be extracted from the message but available via MessageContext are written into the outgoing FlowFile&lt;/li&gt;
	&lt;li&gt;other minor fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed lates PR comments&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added better messaging when server closes the connection&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; some polishing and additional tests to validate deadlocks&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; address latest PR comments&lt;br/&gt;
fixed deadlock condition for when the consumer is stopped while server is distributing messages&lt;br/&gt;
fixed MAX message size issue ensuring it is validated&lt;br/&gt;
set max connections to SMTPServer&lt;br/&gt;
polished pom&lt;br/&gt;
added L&amp;amp;N&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; PR comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed LICENSE&lt;/li&gt;
	&lt;li&gt;Added usage of LimitingInputStream&lt;/li&gt;
	&lt;li&gt;simplified SmtpConsumer by removing hasMessage operation&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15420413" author="jira-bot" created="Sun, 14 Aug 2016 17:32:43 +0000"  >&lt;p&gt;Commit 48fa76ecfff410b09a0b97fd70468e028066e990 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added default for SMTP_MAXIMUM_CONNECTIONS&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed PR comments, polishing&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed intermittent deadlock on processor stop and added test for it&lt;/li&gt;
	&lt;li&gt;the attributes that can not be extracted from the message but available via MessageContext are written into the outgoing FlowFile&lt;/li&gt;
	&lt;li&gt;other minor fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed lates PR comments&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added better messaging when server closes the connection&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; some polishing and additional tests to validate deadlocks&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; address latest PR comments&lt;br/&gt;
fixed deadlock condition for when the consumer is stopped while server is distributing messages&lt;br/&gt;
fixed MAX message size issue ensuring it is validated&lt;br/&gt;
set max connections to SMTPServer&lt;br/&gt;
polished pom&lt;br/&gt;
added L&amp;amp;N&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; PR comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed LICENSE&lt;/li&gt;
	&lt;li&gt;Added usage of LimitingInputStream&lt;/li&gt;
	&lt;li&gt;simplified SmtpConsumer by removing hasMessage operation&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15420414" author="jira-bot" created="Sun, 14 Aug 2016 17:32:44 +0000"  >&lt;p&gt;Commit 48fa76ecfff410b09a0b97fd70468e028066e990 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=48fa76e&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; Fixed and refactored ListenSMTP processor&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed message queueing which could result in data loss&lt;/li&gt;
	&lt;li&gt;Fixed life-cycle issues that coudl put processor in an unstable state&lt;/li&gt;
	&lt;li&gt;Fixed PropertyDescriptor translation for Time units and Byte sizes&lt;/li&gt;
	&lt;li&gt;Fixed broken tests&lt;/li&gt;
	&lt;li&gt;Added additional tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added default for SMTP_MAXIMUM_CONNECTIONS&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed PR comments, polishing&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed intermittent deadlock on processor stop and added test for it&lt;/li&gt;
	&lt;li&gt;the attributes that can not be extracted from the message but available via MessageContext are written into the outgoing FlowFile&lt;/li&gt;
	&lt;li&gt;other minor fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; addressed lates PR comments&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; added better messaging when server closes the connection&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; some polishing and additional tests to validate deadlocks&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; address latest PR comments&lt;br/&gt;
fixed deadlock condition for when the consumer is stopped while server is distributing messages&lt;br/&gt;
fixed MAX message size issue ensuring it is validated&lt;br/&gt;
set max connections to SMTPServer&lt;br/&gt;
polished pom&lt;br/&gt;
added L&amp;amp;N&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; PR comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed LICENSE&lt;/li&gt;
	&lt;li&gt;Added usage of LimitingInputStream&lt;/li&gt;
	&lt;li&gt;simplified SmtpConsumer by removing hasMessage operation&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15420415" author="jira-bot" created="Sun, 14 Aug 2016 17:32:46 +0000"  >&lt;p&gt;Commit d3b96dcac1d18c2da3d5cab2238e5de0936f63c6 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=joewitt&quot; class=&quot;user-hover&quot; rel=&quot;joewitt&quot;&gt;joewitt&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=d3b96dc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=d3b96dc&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; This closes #856. aligned threading model with subethastmp&lt;/p&gt;</comment>
                            <comment id="15420416" author="githubbot" created="Sun, 14 Aug 2016 17:32:49 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/856&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/856&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15420417" author="joewitt" created="Sun, 14 Aug 2016 17:35:37 +0000"  >&lt;p&gt;Ended up having a chat discussion with Andre on this question.  The idea is that in a process session rollback can be safely called after commit and is then basically a no op.  The ProcessSession API says this.  But, if commit hasn&apos;t happened it will indeed roll back.  So the pattern of &lt;br/&gt;
createsesssion&lt;br/&gt;
try{&lt;br/&gt;
do stuff&lt;br/&gt;
commit&lt;br/&gt;
finally{&lt;br/&gt;
rollback&lt;br/&gt;
}&lt;br/&gt;
Is clean and ensures we will handle the session appropriately one way or another.&lt;/p&gt;</comment>
                            <comment id="15422048" author="trixpan" created="Tue, 16 Aug 2016 02:06:50 +0000"  >&lt;p&gt;--&lt;del&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=joewitt&quot; class=&quot;user-hover&quot; rel=&quot;joewitt&quot;&gt;joewitt&lt;/a&gt; I was migrating some real workloads from my dev version to the new master and noted that &lt;tt&gt;smtp.src&lt;/tt&gt; is not being written to the flowfile.&lt;/del&gt;--&lt;/p&gt;

&lt;p&gt; Forget it. Wrong branch. &lt;/p&gt;</comment>
                            <comment id="15422093" author="trixpan" created="Tue, 16 Aug 2016 02:46:15 +0000"  >&lt;p&gt;So it turns out to be master still has the issue:&lt;/p&gt;

&lt;p&gt;Code writes &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;attributes.put(&lt;span class=&quot;code-quote&quot;&gt;&quot;smtp.remote.addr&quot;&lt;/span&gt;, context.getRemoteAddress().toString());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Resulting on the data to be present but under a different name.&lt;/p&gt;

&lt;p&gt;Pushed a small PR to:&lt;/p&gt;

&lt;p&gt;1. rename attribute.put&lt;br/&gt;
2. remove the leading &lt;tt&gt;/&lt;/tt&gt; as it is a Java &lt;tt&gt;toString()&lt;/tt&gt; thing more than a proper IP notation.&lt;br/&gt;
3. reword property description property (as recording source IP and port is good practice) &lt;/p&gt;
</comment>
                            <comment id="15422095" author="githubbot" created="Tue, 16 Aug 2016 02:50:01 +0000"  >&lt;p&gt;GitHub user trixpan opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; - ListenSMTP addresses mismatch between smtp.src attribute &#8230;&lt;/p&gt;

&lt;p&gt;    &#8230;documentation and attribute.put&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/trixpan/nifi&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/trixpan/nifi&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/871.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/871.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #871&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 47e4ca973c4d13be8452d09e67dd04d3493e4022&lt;br/&gt;
Author: Andre F de Miranda &amp;lt;trixpan@users.noreply.github.com&amp;gt;&lt;br/&gt;
Date:   2016-08-15T23:13:39Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; - ListenSMTP addresses mismatch between smtp.src attribute documentation and attribute.put&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15422097" author="joewitt" created="Tue, 16 Aug 2016 02:53:12 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trixpan&quot; class=&quot;user-hover&quot; rel=&quot;trixpan&quot;&gt;trixpan&lt;/a&gt; please avoid putting a PR against a closed ticket.  Could easily get missed/lost.  Best to make a new JIRA or reopen.  I&apos;ve just reopened this one since the PR is already there&lt;/p&gt;</comment>
                            <comment id="15425128" author="githubbot" created="Wed, 17 Aug 2016 18:32:17 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/871#discussion_r75180197&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/871#discussion_r75180197&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/smtp/SmtpConsumer.java &amp;#8212;&lt;br/&gt;
    @@ -149,7 +149,7 @@ public void done() {&lt;br/&gt;
             }&lt;/p&gt;

&lt;p&gt;             attributes.put(&quot;smtp.helo&quot;, context.getHelo());&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;attributes.put(&quot;smtp.remote.addr&quot;, context.getRemoteAddress().toString());&lt;br/&gt;
    +        attributes.put(&quot;smtp.src&quot;, context.getRemoteAddress().toString().substring(1));
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Not sure why we need ```substring(1)``` here? Both ```toString()``` and ```substring(..)``` can cause exceptions (i.e., NPE and IndexArrayOutOfBound). &lt;br/&gt;
    I&apos;ll put a null check and remove ```substring```. Basically if at some point any formatting would be required for the address we have processors that  could do that down stream.&lt;/p&gt;</comment>
                            <comment id="15425172" author="githubbot" created="Wed, 17 Aug 2016 18:56:22 +0000"  >&lt;p&gt;Github user olegz commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/871#discussion_r75184556&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/871#discussion_r75184556&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: nifi-nar-bundles/nifi-email-bundle/nifi-email-processors/src/main/java/org/apache/nifi/processors/email/smtp/SmtpConsumer.java &amp;#8212;&lt;br/&gt;
    @@ -149,7 +149,7 @@ public void done() {&lt;br/&gt;
             }&lt;/p&gt;

&lt;p&gt;             attributes.put(&quot;smtp.helo&quot;, context.getHelo());&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;attributes.put(&quot;smtp.remote.addr&quot;, context.getRemoteAddress().toString());&lt;br/&gt;
    +        attributes.put(&quot;smtp.src&quot;, context.getRemoteAddress().toString().substring(1));
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Changing this part to &lt;br/&gt;
    ```&lt;br/&gt;
    SocketAddress address = context.getRemoteAddress();&lt;br/&gt;
            if (address != null) &lt;/p&gt;
{
                // will extract and format source address if available
                String strAddress = address instanceof InetSocketAddress
                        ? ((InetSocketAddress) address).getHostString() + &quot;:&quot; + ((InetSocketAddress) address).getPort()
                        : context.getRemoteAddress().toString();
                attributes.put(&quot;smtp.src&quot;, strAddress);
            }
&lt;p&gt;    ```&lt;br/&gt;
    . . . and merging after it.&lt;/p&gt;</comment>
                            <comment id="15425199" author="jira-bot" created="Wed, 17 Aug 2016 19:16:07 +0000"  >&lt;p&gt;Commit e7288af859d00d6a4d12631d73a92404e31ba7f4 in nifi&apos;s branch refs/heads/master from Andre F de Miranda&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=e7288af&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=e7288af&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; - ListenSMTP addresses mismatch between smtp.src attribute documentation and attribute.put&lt;/p&gt;</comment>
                            <comment id="15425200" author="jira-bot" created="Wed, 17 Aug 2016 19:16:10 +0000"  >&lt;p&gt;Commit a0fab15eb747426dd4be8cae5378715dd80f6d55 in nifi&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ozhurakousky&quot; class=&quot;user-hover&quot; rel=&quot;ozhurakousky&quot;&gt;ozhurakousky&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=a0fab15&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=nifi.git;h=a0fab15&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/NIFI-2519&quot; title=&quot;TestListenSMTP ValidEmail fails during parallel build&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NIFI-2519&quot;&gt;&lt;del&gt;NIFI-2519&lt;/del&gt;&lt;/a&gt; polishing remote address formatting to avoid NPE and other potential exceptions.&lt;/p&gt;

&lt;p&gt;This closes #871&lt;/p&gt;</comment>
                            <comment id="15425201" author="githubbot" created="Wed, 17 Aug 2016 19:16:24 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/nifi/pull/871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/nifi/pull/871&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12823405" name="0001-NIFI-2519-fixed-max-connections-and-max-size-enforce.patch" size="25177" author="joewitt" created="Fri, 12 Aug 2016 05:03:33 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 13 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3221z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>