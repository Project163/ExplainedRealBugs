{"url":"https://api.github.com/repos/assertj/assertj/issues/3165","repository_url":"https://api.github.com/repos/assertj/assertj","labels_url":"https://api.github.com/repos/assertj/assertj/issues/3165/labels{/name}","comments_url":"https://api.github.com/repos/assertj/assertj/issues/3165/comments","events_url":"https://api.github.com/repos/assertj/assertj/issues/3165/events","html_url":"https://github.com/assertj/assertj/issues/3165","id":1877281541,"node_id":"I_kwDOAIX3Vs5v5QsF","number":3165,"title":"RecursiveComparisonAssert: improvement for comparing field with different types in actual and expected objects.","user":{"login":"pcuriel","id":1854183,"node_id":"MDQ6VXNlcjE4NTQxODM=","avatar_url":"https://avatars.githubusercontent.com/u/1854183?v=4","gravatar_id":"","url":"https://api.github.com/users/pcuriel","html_url":"https://github.com/pcuriel","followers_url":"https://api.github.com/users/pcuriel/followers","following_url":"https://api.github.com/users/pcuriel/following{/other_user}","gists_url":"https://api.github.com/users/pcuriel/gists{/gist_id}","starred_url":"https://api.github.com/users/pcuriel/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/pcuriel/subscriptions","organizations_url":"https://api.github.com/users/pcuriel/orgs","repos_url":"https://api.github.com/users/pcuriel/repos","events_url":"https://api.github.com/users/pcuriel/events{/privacy}","received_events_url":"https://api.github.com/users/pcuriel/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":734184708,"node_id":"MDU6TGFiZWw3MzQxODQ3MDg=","url":"https://api.github.com/repos/assertj/assertj/labels/theme:%20recursive%20comparison","name":"theme: recursive comparison","color":"FEF2C0","default":false,"description":"An issue related to the recursive comparison"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":6,"created_at":"2023-09-01T11:50:01Z","updated_at":"2025-07-05T21:44:24Z","closed_at":"2025-07-05T21:44:24Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"When using RecursiveComparisonAssert to compare objects of different Classes (e.g., Foo and FooDto), we may have the same fields but with different types (e.g., LocalTime and String).\r\n\r\nIn these cases, comparison will fail by default.\r\n\r\nWe can use withEqualsForType, withComparatorForType, withEqualsForFields and withComparatorForFields methods to customize comparison. \r\n\r\nFor instance, given:\r\n```java\r\nclass Foo {\r\n  LocalTime time;\r\n}\r\n\r\nclass FooDto {\r\n  String time;\r\n}\r\n```\r\n\r\nWe can do any of these:\r\n```java\r\nassertThat(foo)\r\n  .usingRecursiveComparison()\r\n  .withEqualsForType((BiPredicate<LocalTime, Object>) (time, timeStr) -> time.equals(LocalTime.parse((String) timeStr)), LocalTime.class)\r\n  .isEqualTo(fooDto);\r\n\r\nassertThat(foo)\r\n  .usingRecursiveComparison()\r\n  .withComparatorForType((Comparator<Object>) (time, timeStr) -> ((LocalTime) time).compareTo(LocalTime.parse((String) timeStr)), LocalTime.class)\r\n  .isEqualTo(fooDto);\r\n\r\nAssertions.assertThat(foo)\r\n  .usingRecursiveComparison()\r\n  .withEqualsForFields((time, timeStr) -> time.equals(LocalTime.parse((String) timeStr)), \"time\")\r\n  // Also working as:\r\n  // .withEqualsForFields((BiPredicate<LocalTime, String>) (time, timeStr) -> time.equals(LocalTime.parse(timeStr)), \"time\")\r\n  .isEqualTo(fooDto);\r\n\r\nassertThat(foo)\r\n  .usingRecursiveComparison()\r\n  .withComparatorForFields((time, timeStr) -> ((LocalTime) time).compareTo(LocalTime.parse((String) timeStr)), \"time\")\r\n  .isEqualTo(fooDto);\r\n```\r\n\r\nThe \"ForFields\" methods just require casting the values (or the BiPredicate in the withEquals case), so they look OK.\r\n\r\nHowever, the \"ForType\" methods look to hacky, requiring an ugly double casting. I addition, while registering a withComparatorForType using LocalTime may work well (to assert Foo against FooDto), registering it using String (to assert FooDto against Foo) will most likely break equality tests for other fields in the class.\r\n\r\nTo solve these issues, would it be feasible to add two-type versions of these methods?\r\n```java\r\npublic <T, U> SELF withEqualsForTypes(BiPredicate<? super T, ? super U> equals, Class<T> typeInActual, Class<U> typeInExpected)\r\n\r\n// BiComparator should also be defined\r\npublic <T, U> SELF withComparatorForType(BiComparator<? super T, ? super U> comparator, Class<T> typeInActual, Class<U> typeInExpected)\r\n```","closed_by":{"login":"joel-costigliola","id":382613,"node_id":"MDQ6VXNlcjM4MjYxMw==","avatar_url":"https://avatars.githubusercontent.com/u/382613?v=4","gravatar_id":"","url":"https://api.github.com/users/joel-costigliola","html_url":"https://github.com/joel-costigliola","followers_url":"https://api.github.com/users/joel-costigliola/followers","following_url":"https://api.github.com/users/joel-costigliola/following{/other_user}","gists_url":"https://api.github.com/users/joel-costigliola/gists{/gist_id}","starred_url":"https://api.github.com/users/joel-costigliola/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/joel-costigliola/subscriptions","organizations_url":"https://api.github.com/users/joel-costigliola/orgs","repos_url":"https://api.github.com/users/joel-costigliola/repos","events_url":"https://api.github.com/users/joel-costigliola/events{/privacy}","received_events_url":"https://api.github.com/users/joel-costigliola/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/assertj/assertj/issues/3165/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/assertj/assertj/issues/3165/timeline","performed_via_github_app":null,"state_reason":"completed"}