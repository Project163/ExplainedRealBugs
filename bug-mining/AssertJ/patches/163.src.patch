diff --git a/src/main/java/org/assertj/core/internal/Diff.java b/src/main/java/org/assertj/core/internal/Diff.java
index 0314d8a92..4993385b1 100644
--- a/src/main/java/org/assertj/core/internal/Diff.java
+++ b/src/main/java/org/assertj/core/internal/Diff.java
@@ -12,24 +12,22 @@
  */
 package org.assertj.core.internal;
 
-import static java.lang.String.format;
-import static java.util.Collections.unmodifiableList;
-import static org.assertj.core.util.Closeables.closeQuietly;
-import static org.assertj.core.util.Objects.areEqual;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.StringReader;
+import org.assertj.core.util.VisibleForTesting;
+import org.assertj.core.util.diff.Delta;
+import org.assertj.core.util.diff.DiffUtils;
+import org.assertj.core.util.diff.Patch;
+import org.assertj.core.util.diff.StringUtils;
+
+import java.io.*;
 import java.nio.charset.Charset;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.stream.Collectors;
 
-import org.assertj.core.util.VisibleForTesting;
+import static java.util.Collections.unmodifiableList;
+import static org.assertj.core.util.Closeables.closeQuietly;
 
 
 /**
@@ -105,23 +103,33 @@ public class Diff {
   }
 
   private List<String> diff(BufferedReader actual, BufferedReader expected) throws IOException {
-    List<String> diffs = new ArrayList<>();
-    int lineNumber = 1;
-    while (true) {
-      String actualLine = actual.readLine();
-      String expectedLine = expected.readLine();
-      if (actualLine == null || expectedLine == null) {
-        if (expectedLine != null) diffs.add(output(lineNumber, EOF, expectedLine));
-        if (actualLine != null) diffs.add(output(lineNumber, actualLine, EOF));
-        return diffs;
-      } else if (!areEqual(actualLine, expectedLine)) {
-        diffs.add(output(lineNumber, actualLine, expectedLine));
-      }
-      lineNumber += 1;
-    }
+    List<String> actualLines = linesFromBufferedReader(actual);
+    List<String> expectedLines = linesFromBufferedReader(expected);
+
+    Patch<String> patch = DiffUtils.diff(actualLines, expectedLines);
+
+    return patch.getDeltas().stream().map(d -> output(d)).collect(Collectors.toList());
+  }
+
+  private String output(Delta<String> delta) {
+    int line = delta.getRevised().getPosition() + 1;
+    String expected = endOfFileOrJoinList(delta.getRevised().getLines());
+    String actual = endOfFileOrJoinList(delta.getOriginal().getLines());
+    return String.format("line:<%d>, expected:<%s> but was:<%s>", line, expected, actual);
   }
 
-  private String output(int lineNumber, String actual, String expected) {
-    return format("line:<%d>, expected:<%s> but was:<%s>", lineNumber, expected, actual);
+  private String endOfFileOrJoinList(List<String> lines) {
+    return lines.isEmpty() ? "EOF" : StringUtils.join(lines, "\n");
+  }
+
+  private List<String> linesFromBufferedReader(BufferedReader reader) throws IOException {
+    String line;
+    List<String> lines = new ArrayList<>();
+
+    while ((line = reader.readLine()) != null)
+    {
+      lines.add(line);
+    }
+    return lines;
   }
 }
diff --git a/src/main/java/org/assertj/core/util/diff/ChangeDelta.java b/src/main/java/org/assertj/core/util/diff/ChangeDelta.java
new file mode 100644
index 000000000..24d6131ce
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/ChangeDelta.java
@@ -0,0 +1,78 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+import java.util.List;
+
+/**
+ * Describes the change-delta between original and revised texts.
+ * 
+ * @author <a href="dm.naumenko@gmail.com">Dmitry Naumenko</a>
+ * @param <T></T> The type of the compared elements in the 'lines'.
+ */
+public class ChangeDelta<T> extends Delta<T> {
+    
+    /**
+     * Creates a change delta with the two given chunks.
+     * @param original The original chunk. Must not be {@code null}.
+     * @param revised The original chunk. Must not be {@code null}.
+     */
+    public ChangeDelta(Chunk<T> original, Chunk<T> revised) {
+    	super(original, revised);
+    }
+    
+    /**
+     * {@inheritDoc}
+     * 
+     * @throws PatchFailedException
+     */
+    @Override
+    public void applyTo(List<T> target) throws PatchFailedException {
+        verify(target);
+        int position = getOriginal().getPosition();
+        int size = getOriginal().size();
+        for (int i = 0; i < size; i++) {
+            target.remove(position);
+        }
+        int i = 0;
+        for (T line : getRevised().getLines()) {
+            target.add(position + i, line);
+            i++;
+        }
+    }
+    
+    /**
+     * {@inheritDoc}
+     */
+    public void verify(List<T> target) throws PatchFailedException {
+        getOriginal().verify(target);
+        if (getOriginal().getPosition() > target.size()) {
+            throw new PatchFailedException("Incorrect patch for delta: "
+                    + "delta original position > target size");
+        }
+    }
+    
+    @Override
+    public String toString() {
+        return "[ChangeDelta, position: " + getOriginal().getPosition() + ", lines: "
+                + getOriginal().getLines() + " to " + getRevised().getLines() + "]";
+    }
+
+    @Override
+    public TYPE getType() {
+        return Delta.TYPE.CHANGE;
+    }
+}
diff --git a/src/main/java/org/assertj/core/util/diff/Chunk.java b/src/main/java/org/assertj/core/util/diff/Chunk.java
new file mode 100644
index 000000000..8bae04705
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/Chunk.java
@@ -0,0 +1,156 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Holds the information about the part of text involved in the diff process
+ * 
+ * <p>
+ * Text is represented as <code>Object[]</code> because the diff engine is
+ * capable of handling more than plain ascci. In fact, arrays or lists of any
+ * type that implements {@link Object#hashCode hashCode()} and
+ * {@link Object#equals equals()} correctly can be subject to
+ * differencing using this library.
+ * </p>
+ * 
+ * @author <a href="dm.naumenko@gmail.com>Dmitry Naumenko</a>
+ * @param <T> The type of the compared elements in the 'lines'.
+ */
+public class Chunk<T> {
+
+    private final int position;
+    private List<T> lines;
+    
+    /**
+     * Creates a chunk and saves a copy of affected lines
+     * 
+     * @param position
+     *            the start position
+     * @param lines
+     *            the affected lines
+     */
+    public Chunk(int position, List<T> lines) {
+        this.position = position;
+        this.lines = lines;
+    }
+    
+    /**
+     * Creates a chunk and saves a copy of affected lines
+     * 
+     * @param position
+     *            the start position
+     * @param lines
+     *            the affected lines
+     */
+    public Chunk(int position, T[] lines) {
+        this.position = position;
+        this.lines = Arrays.asList(lines);
+    }
+    
+    /**
+     * Verifies that this chunk's saved text matches the corresponding text in
+     * the given sequence.
+     * 
+     * @param target
+     *            the sequence to verify against.
+     */
+    public void verify(List<T> target) throws PatchFailedException {
+        if (last() > target.size()) {
+            throw new PatchFailedException("Incorrect Chunk: the position of chunk > target size");
+        }
+        for (int i = 0; i < size(); i++) {
+            if (!target.get(position + i).equals(lines.get(i))) {
+                throw new PatchFailedException(
+                        "Incorrect Chunk: the chunk content doesn't match the target");
+            }
+        }
+    }
+    
+    /**
+     * @return the start position of chunk in the text
+     */
+    public int getPosition() {
+        return position;
+    }
+
+    public void setLines(List<T> lines) {
+        this.lines = lines;
+    }
+
+    /**
+     * @return the affected lines
+     */
+    public List<T> getLines() {
+        return lines;
+    }
+
+    public int size() {
+        return lines.size();
+    }
+    
+    /**
+     * Returns the index of the last line of the chunk.
+     */
+    public int last() {
+        return getPosition() + size() - 1;
+    }
+    
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.lang.Object#hashCode()
+     */
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((lines == null) ? 0 : lines.hashCode());
+        result = prime * result + position;
+        result = prime * result + size();
+        return result;
+    }
+    
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        Chunk other = (Chunk) obj;
+        if (lines == null) {
+            if (other.lines != null)
+                return false;
+        } else if (!lines.equals(other.lines))
+            return false;
+        return position == other.position;
+    }
+    
+    @Override
+    public String toString() {
+        return "[position: " + position + ", size: " + size() + ", lines: " + lines + "]";
+    }
+    
+}
diff --git a/src/main/java/org/assertj/core/util/diff/DeleteDelta.java b/src/main/java/org/assertj/core/util/diff/DeleteDelta.java
new file mode 100644
index 000000000..d9eb3286b
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/DeleteDelta.java
@@ -0,0 +1,70 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+import java.util.List;
+
+/**
+ * Describes the delete-delta between original and revised texts.
+ * 
+ * @author <a href="dm.naumenko@gmail.com">Dmitry Naumenko</a>
+ * @param <T> The type of the compared elements in the 'lines'.
+ */
+public class DeleteDelta<T> extends Delta<T> {
+
+	/**
+	 * Creates a change delta with the two given chunks.
+	 *
+	 * @param original
+	 *            The original chunk. Must not be {@code null}.
+	 * @param revised
+	 *            The original chunk. Must not be {@code null}.
+	 */
+    public DeleteDelta(Chunk<T> original, Chunk<T> revised) {
+        super(original, revised);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @throws PatchFailedException
+     */
+    @Override
+    public void applyTo(List<T> target) throws PatchFailedException {
+        verify(target);
+        int position = getOriginal().getPosition();
+        int size = getOriginal().size();
+        for (int i = 0; i < size; i++) {
+            target.remove(position);
+        }
+    }
+
+    @Override
+    public TYPE getType() {
+        return Delta.TYPE.DELETE;
+    }
+    
+    @Override
+    public void verify(List<T> target) throws PatchFailedException {
+        getOriginal().verify(target);
+    }
+    
+    @Override
+    public String toString() {
+        return "[DeleteDelta, position: " + getOriginal().getPosition() + ", lines: "
+                + getOriginal().getLines() + "]";
+    }
+}
diff --git a/src/main/java/org/assertj/core/util/diff/Delta.java b/src/main/java/org/assertj/core/util/diff/Delta.java
new file mode 100644
index 000000000..144d69dc3
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/Delta.java
@@ -0,0 +1,145 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+import java.util.List;
+
+/**
+ * Describes the delta between original and revised texts.
+ * 
+ * @author <a href="dm.naumenko@gmail.com">Dmitry Naumenko</a>
+ * @param <T> The type of the compared elements in the 'lines'.
+ */
+public abstract class Delta<T> {
+	
+	/** The original chunk. */
+    private Chunk<T> original;
+    
+    /** The revised chunk. */
+    private Chunk<T> revised;
+    
+    /**
+     * Specifies the type of the delta.
+     *
+     */
+    public enum TYPE {
+    	/** A change in the original. */
+        CHANGE, 
+        /** A delete from the original. */
+        DELETE, 
+        /** An insert into the original. */
+        INSERT
+    }
+    
+    /**
+     * Construct the delta for original and revised chunks
+     * 
+     * @param original Chunk describing the original text. Must not be {@code null}.
+     * @param revised Chunk describing the revised text. Must not be {@code null}.
+     */
+    public Delta(Chunk<T> original, Chunk<T> revised) {
+    	if (original == null) {
+    		throw new IllegalArgumentException("original must not be null");
+    	}
+    	if (revised == null) {
+    		throw new IllegalArgumentException("revised must not be null");
+    	}
+        this.original = original;
+        this.revised = revised;
+    }
+    
+    /**
+     * Verifies that this delta can be used to patch the given text.
+     * 
+     * @param target the text to patch.
+     * @throws PatchFailedException if the patch cannot be applied.
+     */
+    public abstract void verify(List<T> target) throws PatchFailedException;
+    
+    /**
+     * Applies this delta as the patch for a given target
+     * 
+     * @param target the given target
+     * @throws PatchFailedException
+     */
+    public abstract void applyTo(List<T> target) throws PatchFailedException;
+
+    /**
+     * Returns the type of delta
+     * @return the type enum
+     */
+    public abstract TYPE getType();
+    
+    /**
+     * @return The Chunk describing the original text.
+     */
+    public Chunk<T> getOriginal() {
+        return original;
+    }
+    
+    /**
+     * @param original The Chunk describing the original text to set.
+     */
+    public void setOriginal(Chunk<T> original) {
+        this.original = original;
+    }
+    
+    /**
+     * @return The Chunk describing the revised text.
+     */
+    public Chunk<T> getRevised() {
+        return revised;
+    }
+    
+    /**
+     * @param revised The Chunk describing the revised text to set.
+     */
+    public void setRevised(Chunk<T> revised) {
+        this.revised = revised;
+    }
+    
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((original == null) ? 0 : original.hashCode());
+        result = prime * result + ((revised == null) ? 0 : revised.hashCode());
+        return result;
+    }
+    
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        Delta other = (Delta) obj;
+        if (original == null) {
+            if (other.original != null)
+                return false;
+        } else if (!original.equals(other.original))
+            return false;
+        if (revised == null) {
+            if (other.revised != null)
+                return false;
+        } else if (!revised.equals(other.revised))
+            return false;
+        return true;
+    }
+    
+}
diff --git a/src/main/java/org/assertj/core/util/diff/DeltaComparator.java b/src/main/java/org/assertj/core/util/diff/DeltaComparator.java
new file mode 100644
index 000000000..910ba7bf8
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/DeltaComparator.java
@@ -0,0 +1,26 @@
+package org.assertj.core.util.diff;
+
+import java.io.Serializable;
+import java.util.Comparator;
+
+/**
+ * @author mksenzov
+ */
+public class DeltaComparator implements Comparator<Delta<?>>, Serializable {
+    private static final long serialVersionUID = 1L;
+    public static final Comparator<Delta<?>> INSTANCE = new DeltaComparator();
+
+    private DeltaComparator() {
+    }
+
+    public int compare(final Delta<?> a, final Delta<?> b) {
+        final int posA = a.getOriginal().getPosition();
+        final int posB = b.getOriginal().getPosition();
+        if (posA > posB) {
+            return 1;
+        } else if (posA < posB) {
+            return -1;
+        }
+        return 0;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/util/diff/DiffAlgorithm.java b/src/main/java/org/assertj/core/util/diff/DiffAlgorithm.java
new file mode 100644
index 000000000..e7eeba0f1
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/DiffAlgorithm.java
@@ -0,0 +1,47 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+import java.util.List;
+
+/**
+ * The general interface for computing diffs between two lists of elements of type T. 
+ * 
+ * @author <a href="dm.naumenko@gmail.com">Dmitry Naumenko</a>
+ * @param <T> The type of the compared elements in the 'lines'.
+ */
+public interface DiffAlgorithm<T> {
+    
+    /**
+     * Computes the difference between the original sequence and the revised
+     * sequence and returns it as a {@link Patch} object.
+     * 
+     * @param original The original sequence. Must not be {@code null}.
+     * @param revised The revised sequence. Must not be {@code null}.
+     * @return The patch representing the diff of the given sequences. Never {@code null}.
+     */
+    Patch<T> diff(T[] original, T[] revised);
+    
+    /**
+     * Computes the difference between the original sequence and the revised
+     * sequence and returns it as a {@link Patch} object.
+     * 
+     * @param original The original sequence. Must not be {@code null}.
+     * @param revised The revised sequence. Must not be {@code null}.
+     * @return The patch representing the diff of the given sequences. Never {@code null}.
+     */
+    Patch<T> diff(List<T> original, List<T> revised);
+}
diff --git a/src/main/java/org/assertj/core/util/diff/DiffUtils.java b/src/main/java/org/assertj/core/util/diff/DiffUtils.java
new file mode 100644
index 000000000..cbd446cc7
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/DiffUtils.java
@@ -0,0 +1,379 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+import org.assertj.core.util.diff.myers.Equalizer;
+import org.assertj.core.util.diff.myers.MyersDiff;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * Implements the difference and patching engine
+ * 
+ * @author <a href="dm.naumenko@gmail.com">Dmitry Naumenko</a>
+ * @version 0.4.1
+ */
+public class DiffUtils {
+
+	private static Pattern unifiedDiffChunkRe = Pattern
+			.compile("^@@\\s+-(?:(\\d+)(?:,(\\d+))?)\\s+\\+(?:(\\d+)(?:,(\\d+))?)\\s+@@$");
+
+	/**
+	 * Computes the difference between the original and revised list of elements
+	 * with default diff algorithm
+	 * 
+	 * @param original
+	 *            The original text. Must not be {@code null}.
+	 * @param revised
+	 *            The revised text. Must not be {@code null}.
+	 * @return The patch describing the difference between the original and
+	 *         revised sequences. Never {@code null}.
+	 */
+	public static <T> Patch<T> diff(List<T> original, List<T> revised) {
+		return DiffUtils.diff(original, revised, new MyersDiff<>());
+	}
+
+	/**
+	 * Computes the difference between the original and revised list of elements
+	 * with default diff algorithm
+	 *
+	 * @param original
+	 *            The original text. Must not be {@code null}.
+	 * @param revised
+	 *            The revised text. Must not be {@code null}.
+	 *
+	 * @param equalizer
+	 *            the equalizer object to replace the default compare algorithm
+	 *            (Object.equals). If {@code null} the default equalizer of the
+	 *            default algorithm is used..
+	 * @return The patch describing the difference between the original and
+	 *         revised sequences. Never {@code null}.
+	 */
+	public static <T> Patch<T> diff(List<T> original, List<T> revised,
+			Equalizer<T> equalizer) {
+		if (equalizer != null) {
+			return DiffUtils.diff(original, revised, new MyersDiff<>(equalizer));
+		}
+		return DiffUtils.diff(original, revised, new MyersDiff<>());
+	}
+
+	/**
+	 * Computes the difference between the original and revised list of elements
+	 * with default diff algorithm
+	 *
+	 * @param original
+	 *            The original text. Must not be {@code null}.
+	 * @param revised
+	 *            The revised text. Must not be {@code null}.
+	 * @param algorithm
+	 *            The diff algorithm. Must not be {@code null}.
+	 * @return The patch describing the difference between the original and
+	 *         revised sequences. Never {@code null}.
+	 */
+	public static <T> Patch<T> diff(List<T> original, List<T> revised,
+			DiffAlgorithm<T> algorithm) {
+		if (original == null) {
+			throw new IllegalArgumentException("original must not be null");
+		}
+		if (revised == null) {
+			throw new IllegalArgumentException("revised must not be null");
+		}
+		if (algorithm == null) {
+			throw new IllegalArgumentException("algorithm must not be null");
+		}
+		return algorithm.diff(original, revised);
+	}
+
+	/**
+	 * Patch the original text with given patch
+	 *
+	 * @param original
+	 *            the original text
+	 * @param patch
+	 *            the given patch
+	 * @return the revised text
+	 * @throws PatchFailedException
+	 *             if can't apply patch
+	 */
+	public static <T> List<T> patch(List<T> original, Patch<T> patch)
+			throws PatchFailedException {
+		return patch.applyTo(original);
+	}
+
+	/**
+	 * Parse the given text in unified format and creates the list of deltas for
+	 * it.
+	 *
+	 * @param diff
+	 *            the text in unified format
+	 * @return the patch with deltas.
+	 */
+	public static Patch<String> parseUnifiedDiff(List<String> diff) {
+		boolean inPrelude = true;
+		List<String[]> rawChunk = new ArrayList<>();
+		Patch<String> patch = new Patch<>();
+
+		int old_ln = 0, new_ln = 0;
+		String tag;
+		String rest;
+		for (String line : diff) {
+			// Skip leading lines until after we've seen one starting with '+++'
+			if (inPrelude) {
+				if (line.startsWith("+++")) {
+					inPrelude = false;
+				}
+				continue;
+			}
+			Matcher m = unifiedDiffChunkRe.matcher(line);
+			if (m.find()) {
+				// Process the lines in the previous chunk
+				if (rawChunk.size() != 0) {
+					List<String> oldChunkLines = new ArrayList<>();
+					List<String> newChunkLines = new ArrayList<>();
+
+					for (String[] raw_line : rawChunk) {
+						tag = raw_line[0];
+						rest = raw_line[1];
+						if (tag.equals(" ") || tag.equals("-")) {
+							oldChunkLines.add(rest);
+						}
+						if (tag.equals(" ") || tag.equals("+")) {
+							newChunkLines.add(rest);
+						}
+					}
+					patch.addDelta(new ChangeDelta<>(new Chunk<>(
+							old_ln - 1, oldChunkLines), new Chunk<>(
+							new_ln - 1, newChunkLines)));
+					rawChunk.clear();
+				}
+				// Parse the @@ header
+				old_ln = m.group(1) == null ? 1 : Integer.parseInt(m.group(1));
+				new_ln = m.group(3) == null ? 1 : Integer.parseInt(m.group(3));
+
+				if (old_ln == 0) {
+					old_ln += 1;
+				}
+				if (new_ln == 0) {
+					new_ln += 1;
+				}
+			} else {
+				if (line.length() > 0) {
+					tag = line.substring(0, 1);
+					rest = line.substring(1);
+					if (tag.equals(" ") || tag.equals("+") || tag.equals("-")) {
+						rawChunk.add(new String[] { tag, rest });
+					}
+				} else {
+					rawChunk.add(new String[] { " ", "" });
+				}
+			}
+		}
+
+		// Process the lines in the last chunk
+		if (rawChunk.size() != 0) {
+			List<String> oldChunkLines = new ArrayList<>();
+			List<String> newChunkLines = new ArrayList<>();
+
+			for (String[] raw_line : rawChunk) {
+				tag = raw_line[0];
+				rest = raw_line[1];
+				if (tag.equals(" ") || tag.equals("-")) {
+					oldChunkLines.add(rest);
+				}
+				if (tag.equals(" ") || tag.equals("+")) {
+					newChunkLines.add(rest);
+				}
+			}
+
+			patch.addDelta(new ChangeDelta<>(new Chunk<>(
+					old_ln - 1, oldChunkLines), new Chunk<>(new_ln - 1,
+					newChunkLines)));
+			rawChunk.clear();
+		}
+
+		return patch;
+	}
+
+	/**
+	 * generateUnifiedDiff takes a Patch and some other arguments, returning the
+	 * Unified Diff format text representing the Patch.
+	 * 
+	 * @param original Filename of the original (unrevised file)
+	 * @param revised Filename of the revised file
+	 * @param originalLines Lines of the original file
+	 * @param patch Patch created by the diff() function
+	 * @param contextSize number of lines of context output around each difference
+	 *                    in the file.
+	 * @return List of strings representing the Unified Diff representation of
+	 *         the Patch argument.
+	 * @author Bill James (tankerbay@gmail.com)
+	 */
+	public static List<String> generateUnifiedDiff(String original,
+			String revised, List<String> originalLines, Patch<String> patch,
+			int contextSize) {
+		if (!patch.getDeltas().isEmpty()) {
+			List<String> ret = new ArrayList<>();
+			ret.add("--- " + original);
+			ret.add("+++ " + revised);
+
+			List<Delta<String>> patchDeltas = new ArrayList<>(
+					patch.getDeltas());
+
+			// code outside the if block also works for single-delta issues.
+			// current list of Delta's to process
+			List<Delta<String>> deltas = new ArrayList<>();
+			Delta<String> delta = patchDeltas.get(0);
+			deltas.add(delta); // add the first Delta to the current set
+			// if there's more than 1 Delta, we may need to output them together
+			if (patchDeltas.size() > 1) {
+				for (int i = 1; i < patchDeltas.size(); i++) {
+					// store the current position of the first Delta
+					int position = delta.getOriginal().getPosition();
+
+					// Check if the next Delta is too close to the current
+					// position.
+					// And if it is, add it to the current set
+					Delta<String> nextDelta = patchDeltas.get(i);
+					if ((position + delta.getOriginal().size() + contextSize) >= (nextDelta
+							.getOriginal().getPosition() - contextSize)) {
+						deltas.add(nextDelta);
+					} else {
+						// if it isn't, output the current set,
+						// then create a new set and add the current Delta to
+						// it.
+						List<String> curBlock = processDeltas(originalLines,
+								deltas, contextSize);
+						ret.addAll(curBlock);
+						deltas.clear();
+						deltas.add(nextDelta);
+					}
+					delta = nextDelta;
+				}
+
+			}
+			// don't forget to process the last set of Deltas
+			List<String> curBlock = processDeltas(originalLines, deltas,
+					contextSize);
+			ret.addAll(curBlock);
+			return ret;
+		}
+		return new ArrayList<>();
+	}
+
+	/**
+	 * processDeltas takes a list of Deltas and outputs them together in a
+	 * single block of Unified-Diff-format text.
+	 * 
+	 * @param origLines the lines of the original file
+	 * @param deltas the Deltas to be output as a single block
+	 * @param contextSize the number of lines of context to place around block
+	 * @author Bill James (tankerbay@gmail.com)
+	 */
+	private static List<String> processDeltas(List<String> origLines,
+			List<Delta<String>> deltas, int contextSize) {
+		List<String> buffer = new ArrayList<>();
+		int origTotal = 0; // counter for total lines output from Original
+		int revTotal = 0; // counter for total lines output from Original
+		int line;
+
+		Delta<String> curDelta = deltas.get(0);
+
+		// NOTE: +1 to overcome the 0-offset Position
+		int origStart = curDelta.getOriginal().getPosition() + 1 - contextSize;
+		if (origStart < 1) {
+			origStart = 1;
+		}
+
+		int revStart = curDelta.getRevised().getPosition() + 1 - contextSize;
+		if (revStart < 1) {
+			revStart = 1;
+		}
+
+		// find the start of the wrapper context code
+		int contextStart = curDelta.getOriginal().getPosition() - contextSize;
+		if (contextStart < 0) {
+			contextStart = 0; // clamp to the start of the file
+		}
+
+		// output the context before the first Delta
+		for (line = contextStart; line < curDelta.getOriginal().getPosition(); line++) { //
+			buffer.add(" " + origLines.get(line));
+			origTotal++;
+			revTotal++;
+		}
+
+		// output the first Delta
+		buffer.addAll(getDeltaText(curDelta));
+		origTotal += curDelta.getOriginal().getLines().size();
+		revTotal += curDelta.getRevised().getLines().size();
+
+		int deltaIndex = 1;
+		while (deltaIndex < deltas.size()) { // for each of the other Deltas
+			Delta<String> nextDelta = deltas.get(deltaIndex);
+			int intermediateStart = curDelta.getOriginal().getPosition()
+					+ curDelta.getOriginal().getLines().size();
+			for (line = intermediateStart; line < nextDelta.getOriginal()
+					.getPosition(); line++) {
+				// output the code between the last Delta and this one
+				buffer.add(" " + origLines.get(line));
+				origTotal++;
+				revTotal++;
+			}
+			buffer.addAll(getDeltaText(nextDelta)); // output the Delta
+			origTotal += nextDelta.getOriginal().getLines().size();
+			revTotal += nextDelta.getRevised().getLines().size();
+			curDelta = nextDelta;
+			deltaIndex++;
+		}
+
+		// Now output the post-Delta context code, clamping the end of the file
+		contextStart = curDelta.getOriginal().getPosition()
+				+ curDelta.getOriginal().getLines().size();
+		for (line = contextStart; (line < (contextStart + contextSize))
+				&& (line < origLines.size()); line++) {
+			buffer.add(" " + origLines.get(line));
+			origTotal++;
+			revTotal++;
+		}
+
+		// Create and insert the block header, conforming to the Unified Diff
+		// standard
+		String header = "@@ -" + origStart + "," + origTotal + " +" + revStart + "," + revTotal + " @@";
+		buffer.add(0, header);
+
+		return buffer;
+	}
+
+	/**
+	 * getDeltaText returns the lines to be added to the Unified Diff text from
+	 * the Delta parameter
+	 * 
+	 * @param delta the Delta to output
+	 * @return list of String lines of code.
+	 * @author Bill James (tankerbay@gmail.com)
+	 */
+	private static List<String> getDeltaText(Delta<String> delta) {
+		List<String> buffer = new ArrayList<>();
+		delta.getOriginal().getLines().stream().map(l -> buffer.add("-" + l)).collect(Collectors.toList());
+		delta.getRevised().getLines().stream().map(l -> buffer.add("+" + l)).collect(Collectors.toList());
+		return buffer;
+	}
+
+}
diff --git a/src/main/java/org/assertj/core/util/diff/InsertDelta.java b/src/main/java/org/assertj/core/util/diff/InsertDelta.java
new file mode 100644
index 000000000..c8edf3eee
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/InsertDelta.java
@@ -0,0 +1,74 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+import java.util.List;
+
+/**
+ * Describes the add-delta between original and revised texts.
+ * 
+ * @author <a href="dm.naumenko@gmail.com">Dmitry Naumenko</a>
+ * @param <T>
+ *            The type of the compared elements in the 'lines'.
+ */
+public class InsertDelta<T> extends Delta<T> {
+
+	/**
+	 * Creates an insert delta with the two given chunks.
+	 *
+	 * @param original
+	 *            The original chunk. Must not be {@code null}.
+	 * @param revised
+	 *            The original chunk. Must not be {@code null}.
+	 */
+	public InsertDelta(Chunk<T> original, Chunk<T> revised) {
+		super(original, revised);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 *
+	 * @throws PatchFailedException
+	 */
+	@Override
+	public void applyTo(List<T> target) throws PatchFailedException {
+		verify(target);
+		int position = this.getOriginal().getPosition();
+		List<T> lines = this.getRevised().getLines();
+		for (int i = 0; i < lines.size(); i++) {
+			target.add(position + i, lines.get(i));
+		}
+	}
+
+	@Override
+	public void verify(List<T> target) throws PatchFailedException {
+		if (getOriginal().getPosition() > target.size()) {
+			throw new PatchFailedException("Incorrect patch for delta: "
+					+ "delta original position > target size");
+		}
+
+	}
+
+	public TYPE getType() {
+		return Delta.TYPE.INSERT;
+	}
+
+	@Override
+	public String toString() {
+		return "[InsertDelta, position: " + getOriginal().getPosition()
+				+ ", lines: " + getRevised().getLines() + "]";
+	}
+}
diff --git a/src/main/java/org/assertj/core/util/diff/Patch.java b/src/main/java/org/assertj/core/util/diff/Patch.java
new file mode 100644
index 000000000..628e29116
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/Patch.java
@@ -0,0 +1,63 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.ListIterator;
+
+/**
+ * Describes the patch holding all deltas between the original and revised texts.
+ * 
+ * @author <a href="dm.naumenko@gmail.com">Dmitry Naumenko</a>
+ * @param <T> The type of the compared elements in the 'lines'.
+ */
+public class Patch<T> {
+    private List<Delta<T>> deltas = new LinkedList<>();
+
+    /**
+     * Apply this patch to the given target
+     * @return the patched text
+     * @throws PatchFailedException if can't apply patch
+     */
+    public List<T> applyTo(List<T> target) throws PatchFailedException {
+        List<T> result = new LinkedList<>(target);
+        ListIterator<Delta<T>> it = getDeltas().listIterator(deltas.size());
+        while (it.hasPrevious()) {
+            Delta<T> delta = it.previous();
+            delta.applyTo(result);
+        }
+        return result;
+    }
+    
+    /**
+     * Add the given delta to this patch
+     * @param delta the given delta
+     */
+    public void addDelta(Delta<T> delta) {
+      deltas.add(delta);
+    }
+
+    /**
+     * Get the list of computed deltas
+     * @return the deltas
+     */
+    public List<Delta<T>> getDeltas() {
+        Collections.sort(deltas, DeltaComparator.INSTANCE);
+        return deltas;
+    }
+}
diff --git a/src/main/java/org/assertj/core/util/diff/PatchFailedException.java b/src/main/java/org/assertj/core/util/diff/PatchFailedException.java
new file mode 100644
index 000000000..19ecaced9
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/PatchFailedException.java
@@ -0,0 +1,33 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+/**
+ * Thrown whenever a delta cannot be applied as a patch to a given text.
+ *
+ * @author <a href="mailto:juanco@suigeneris.org">Juanco Anez</a>
+ */
+public class PatchFailedException extends Exception {
+    
+    private static final long serialVersionUID = 1L;
+    
+    public PatchFailedException() {
+    }
+    
+    public PatchFailedException(String msg) {
+        super(msg);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/util/diff/StringUtils.java b/src/main/java/org/assertj/core/util/diff/StringUtils.java
new file mode 100644
index 000000000..ab5e14de1
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/StringUtils.java
@@ -0,0 +1,89 @@
+/*
+   Copyright 2010 Dmitry Naumenko (dm.naumenko@gmail.com)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ */
+package org.assertj.core.util.diff;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.stream.Collectors;
+
+public class StringUtils {
+    
+    public static <T> String join(final Iterable<T> objs, final String delimiter) {
+        Iterator<T> iter = objs.iterator();
+        if (!iter.hasNext()) {
+            return "";
+        }
+        StringBuilder buffer = new StringBuilder(String.valueOf(iter.next()));
+        while (iter.hasNext()) {
+            buffer.append(delimiter).append(String.valueOf(iter.next()));
+        }
+        return buffer.toString();
+    }
+    
+    /**
+     * Replaces all tabs with 4 spaces.
+     * @param str The string.
+     * @return the string with tabs replaced.
+     */
+    public static String expandTabs(String str) {
+        return str.replace("\t", "    ");
+    }
+    
+    /**
+     * Replaces all opening an closing tags with <code>&lt;</code> or <code>&gt;</code>.
+     * @param str The string.
+     * @return the string with < and > html escaped.
+     */
+    public static String htmlEntites(String str) {
+        return str.replace("<", "&lt;").replace(">", "&gt;");
+    }
+    
+    public static String normalize(String str) {
+        return expandTabs(htmlEntites(str));
+    }
+    
+    public static List<String> normalize(List<String> list) {
+        return list.stream()
+                .map(StringUtils::normalize)
+                .collect(Collectors.toList());
+    }
+    
+    public static List<String> wrapText(List<String> list, int columnWidth) {
+        return list.stream()
+                .map(l -> wrapText(l, columnWidth))
+                .collect(Collectors.toList());
+    }
+    
+    /**
+     * Wrap the text with the given column width 
+     * @param line the text
+     * @param columnWidth the given column
+     * @return the wrapped text
+     */
+    public static String wrapText(String line, int columnWidth) {
+        int length = line.length();
+        int delimiter = "<br>".length();
+        int widthIndex = columnWidth;
+        
+        for (int count = 0; length > widthIndex; count++) {
+            line = line.subSequence(0, widthIndex + delimiter * count) + "<br>"
+                    + line.substring(widthIndex + delimiter * count);
+            widthIndex += columnWidth;
+        }
+        
+        return line;
+    }
+}
diff --git a/src/main/java/org/assertj/core/util/diff/myers/DiffNode.java b/src/main/java/org/assertj/core/util/diff/myers/DiffNode.java
new file mode 100644
index 000000000..dbadb2f6d
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/myers/DiffNode.java
@@ -0,0 +1,43 @@
+package org.assertj.core.util.diff.myers;
+
+/**
+ * A diffnode in a diffpath.
+ * <p>
+ * A DiffNode and its previous node mark a delta between
+ * two input sequences, that is, two differing subsequences
+ * between (possibly zero length) matching sequences.
+ *
+ * {@link DiffNode DiffNodes} and {@link Snake Snakes} allow for compression
+ * of diffpaths, as each snake is represented by a single {@link Snake Snake}
+ * node and each contiguous series of insertions and deletions is represented
+ * by a single {@link DiffNode DiffNodes}.
+ *
+ * @author <a href="mailto:juanco@suigeneris.org">Juanco Anez</a>
+ *
+ */
+public final class DiffNode extends PathNode {
+    /**
+     * Constructs a DiffNode.
+     * <p>
+     * DiffNodes are compressed. That means that
+     * the path pointed to by the <code>prev</code> parameter
+     * will be followed using {@link PathNode#previousSnake}
+     * until a non-diff node is found.
+     *
+     * @param i the position in the original sequence
+     * @param j the position in the revised sequence
+     * @param prev the previous node in the path.
+     */
+    public DiffNode(int i, int j, PathNode prev) {
+        super(i, j, (prev == null ? null : prev.previousSnake()));
+    }
+    
+    /**
+     * {@inheritDoc}
+     * @return false, always
+     */
+    public boolean isSnake() {
+        return false;
+    }
+    
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/util/diff/myers/DifferentiationFailedException.java b/src/main/java/org/assertj/core/util/diff/myers/DifferentiationFailedException.java
new file mode 100644
index 000000000..844b4e757
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/myers/DifferentiationFailedException.java
@@ -0,0 +1,76 @@
+/*
+ * ====================================================================
+ *
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 1999-2003 The Apache Software Foundation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution, if
+ *    any, must include the following acknowledgement:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgement may appear in the software itself,
+ *    if and wherever such third-party acknowledgements normally appear.
+ *
+ * 4. The names "The Jakarta Project", "Commons", and "Apache Software
+ *    Foundation" must not be used to endorse or promote products derived
+ *    from this software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.assertj.core.util.diff.myers;
+
+import org.assertj.core.util.diff.DiffAlgorithm;
+
+/**
+ * Thrown whenever the differencing engine cannot produce the differences
+ * between two revisions of ta text.
+ *
+ * @author <a href="mailto:juanco@suigeneris.org">Juanco Anez</a>
+ * @see MyersDiff
+ * @see DiffAlgorithm
+ */
+public class DifferentiationFailedException extends Exception {
+    private static final long serialVersionUID = 1L;
+    
+    public DifferentiationFailedException(String msg) {
+        super(msg);
+    }
+}
diff --git a/src/main/java/org/assertj/core/util/diff/myers/Equalizer.java b/src/main/java/org/assertj/core/util/diff/myers/Equalizer.java
new file mode 100644
index 000000000..c6c55137c
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/myers/Equalizer.java
@@ -0,0 +1,17 @@
+package org.assertj.core.util.diff.myers;
+
+/**
+ * Specifies when two compared elements in the Myers algorithm are equal.
+ * 
+ * @param <T> The type of the compared elements in the 'lines'.
+ */
+public interface Equalizer<T> {
+	
+	/**
+	 * Indicates if two elements are equal according to the diff mechanism.
+	 * @param original The original element. Must not be {@code null}.
+	 * @param revised The revised element. Must not be {@code null}.
+	 * @return Returns true if the elements are equal.
+	 */
+	boolean equals(T original, T revised);
+}
diff --git a/src/main/java/org/assertj/core/util/diff/myers/MyersDiff.java b/src/main/java/org/assertj/core/util/diff/myers/MyersDiff.java
new file mode 100644
index 000000000..0d3e7d835
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/myers/MyersDiff.java
@@ -0,0 +1,265 @@
+/*
+ * ====================================================================
+ *
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution, if
+ *    any, must include the following acknowledgement:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgement may appear in the software itself,
+ *    if and wherever such third-party acknowledgements normally appear.
+ *
+ * 4. The names "The Jakarta Project", "Commons", and "Apache Software
+ *    Foundation" must not be used to endorse or promote products derived
+ *    from this software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.assertj.core.util.diff.myers;
+
+import org.assertj.core.util.diff.*;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A clean-room implementation of <a href="http://www.cs.arizona.edu/people/gene/">
+ * Eugene Myers</a> differencing algorithm.
+ *
+ * <p> See the paper at <a href="http://www.cs.arizona.edu/people/gene/PAPERS/diff.ps">
+ * http://www.cs.arizona.edu/people/gene/PAPERS/diff.ps</a></p>
+ *
+ * @author <a href="mailto:juanco@suigeneris.org">Juanco Anez</a>
+ * @param <T> The type of the compared elements in the 'lines'.
+ */
+public class MyersDiff<T> implements DiffAlgorithm<T> {
+    /** The equalizer. */
+    private final Equalizer<T> equalizer;
+
+
+    /**
+     * Constructs an instance of the Myers differencing algorithm.
+     */
+    public MyersDiff() {
+        /**	Default equalizer. */
+        equalizer = T::equals;
+    }
+
+    /**
+     * Constructs an instance of the Myers differencing algorithm.
+     * @param equalizer Must not be {@code null}.
+     */
+    public MyersDiff(final Equalizer<T> equalizer) {
+    	if (equalizer == null) {
+    		throw new IllegalArgumentException("equalizer must not be null");
+    	}
+        this.equalizer = equalizer;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @return Returns an empty diff if get the error while procession the difference.
+     */
+    public Patch<T> diff(final T[] original, final T[] revised) {
+        return diff(Arrays.asList(original), Arrays.asList(revised));
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Return empty diff if get the error while procession the difference.
+     */
+    public Patch<T> diff(final List<T> original, final List<T> revised) {
+    	if (original == null) {
+    		throw new IllegalArgumentException("original list must not be null");
+    	}
+    	if (revised == null) {
+    		throw new IllegalArgumentException("revised list must not be null");
+    	}
+        PathNode path;
+        try {
+            path = buildPath(original, revised);
+            return buildRevision(path, original, revised);
+        } catch (DifferentiationFailedException e) {
+            e.printStackTrace();
+        }
+        return new Patch<>();
+    }
+
+    /**
+     * Computes the minimum diffpath that expresses de differences
+     * between the original and revised sequences, according
+     * to Gene Myers differencing algorithm.
+     *
+     * @param orig The original sequence.
+     * @param rev The revised sequence.
+     * @return A minimum {@link PathNode Path} accross the differences graph.
+     * @throws DifferentiationFailedException if a diff path could not be found.
+     */
+    public PathNode buildPath(final List<T> orig, final List<T> rev)
+            throws DifferentiationFailedException {
+        if (orig == null)
+            throw new IllegalArgumentException("original sequence is null");
+        if (rev == null)
+            throw new IllegalArgumentException("revised sequence is null");
+
+        // these are local constants
+        final int N = orig.size();
+        final int M = rev.size();
+
+        final int MAX = N + M + 1;
+        final int size = 1 + 2 * MAX;
+        final int middle = size / 2;
+        final PathNode diagonal[] = new PathNode[size];
+
+        diagonal[middle + 1] = new Snake(0, -1, null);
+        for (int d = 0; d < MAX; d++) {
+            for (int k = -d; k <= d; k += 2) {
+                final int kmiddle = middle + k;
+                final int kplus = kmiddle + 1;
+                final int kminus = kmiddle - 1;
+                PathNode prev;
+
+                int i;
+                if ((k == -d) || (k != d && diagonal[kminus].i < diagonal[kplus].i)) {
+                    i = diagonal[kplus].i;
+                    prev = diagonal[kplus];
+                } else {
+                    i = diagonal[kminus].i + 1;
+                    prev = diagonal[kminus];
+                }
+
+                diagonal[kminus] = null; // no longer used
+
+                int j = i - k;
+
+                PathNode node = new DiffNode(i, j, prev);
+
+                // orig and rev are zero-based
+                // but the algorithm is one-based
+                // that's why there's no +1 when indexing the sequences
+                while (i < N && j < M && equals(orig.get(i), rev.get(j))) {
+                    i++;
+                    j++;
+                }
+                if (i > node.i)
+                    node = new Snake(i, j, node);
+
+                diagonal[kmiddle] = node;
+
+                if (i >= N && j >= M) {
+                    return diagonal[kmiddle];
+                }
+            }
+            diagonal[middle + d - 1] = null;
+
+        }
+        // According to Myers, this cannot happen
+        throw new DifferentiationFailedException("could not find a diff path");
+    }
+
+    private boolean equals(T orig, T rev) {
+        return equalizer.equals(orig, rev);
+    }
+
+    /**
+     * Constructs a {@link Patch} from a difference path.
+     *
+     * @param path The path.
+     * @param orig The original sequence.
+     * @param rev The revised sequence.
+     * @return A {@link Patch} script corresponding to the path.
+     */
+    public Patch<T> buildRevision(PathNode path, List<T> orig, List<T> rev) {
+        if (path == null)
+            throw new IllegalArgumentException("path is null");
+        if (orig == null)
+            throw new IllegalArgumentException("original sequence is null");
+        if (rev == null)
+            throw new IllegalArgumentException("revised sequence is null");
+
+        Patch<T> patch = new Patch<>();
+        if (path.isSnake())
+            path = path.prev;
+        while (path != null && path.prev != null && path.prev.j >= 0) {
+            if (path.isSnake())
+                throw new IllegalStateException("bad diffpath: found snake when looking for diff");
+            int i = path.i;
+            int j = path.j;
+
+            path = path.prev;
+            int ianchor = path.i;
+            int janchor = path.j;
+
+            Chunk<T> original = new Chunk<>(ianchor, copyOfRange(orig, ianchor, i));
+            Chunk<T> revised = new Chunk<>(janchor, copyOfRange(rev, janchor, j));
+            Delta<T> delta;
+            if (original.size() == 0 && revised.size() != 0) {
+                delta = new InsertDelta<>(original, revised);
+            } else if (original.size() > 0 && revised.size() == 0) {
+                delta = new DeleteDelta<>(original, revised);
+            } else {
+                delta = new ChangeDelta<>(original, revised);
+            }
+
+            patch.addDelta(delta);
+            if (path.isSnake())
+                path = path.prev;
+        }
+        return patch;
+    }
+
+    /**
+     * Creates a new list containing the elements returned by {@link List#subList(int, int)}.
+     * @param original The original sequence. Must not be {@code null}.
+     * @param fromIndex low endpoint (inclusive) of the subList.
+     * @param to high endpoint (exclusive) of the subList.
+     * @return A new list of the specified range within the original list.
+
+     */
+    private List<T> copyOfRange( final List<T> original, final int fromIndex, final int to ) {
+        return new ArrayList<>( original.subList( fromIndex, to ) );
+    }
+}
diff --git a/src/main/java/org/assertj/core/util/diff/myers/PathNode.java b/src/main/java/org/assertj/core/util/diff/myers/PathNode.java
new file mode 100644
index 000000000..7b6d7400e
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/myers/PathNode.java
@@ -0,0 +1,139 @@
+/*
+ * ====================================================================
+ *
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 1999-2003 The Apache Software Foundation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution, if
+ *    any, must include the following acknowledgement:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgement may appear in the software itself,
+ *    if and wherever such third-party acknowledgements normally appear.
+ *
+ * 4. The names "The Jakarta Project", "Commons", and "Apache Software
+ *    Foundation" must not be used to endorse or promote products derived
+ *    from this software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.assertj.core.util.diff.myers;
+
+/**
+ * A node in a diffpath.
+ *
+ * @author <a href="mailto:juanco@suigeneris.org">Juanco Anez</a>
+ *
+ * @see DiffNode
+ * @see Snake
+ *
+ */
+public abstract class PathNode {
+    /** Position in the original sequence. */
+    public final int i;
+    /** Position in the revised sequence. */
+    public final int j;
+    /** The previous node in the path. */
+    public final PathNode prev;
+
+    /**
+     * Concatenates a new path node with an existing diffpath.
+     * @param i The position in the original sequence for the new node.
+     * @param j The position in the revised sequence for the new node.
+     * @param prev The previous node in the path.
+     */
+    public PathNode(int i, int j, PathNode prev) {
+        this.i = i;
+        this.j = j;
+        this.prev = prev;
+    }
+
+    /**
+     * Is this node a {@link Snake Snake node}?
+     * @return true if this is a {@link Snake Snake node}
+     */
+    public abstract boolean isSnake();
+
+    /**
+     * Is this a bootstrap node?
+     * <p>
+     * In bottstrap nodes one of the two corrdinates is
+     * less than zero.
+     * @return tru if this is a bootstrap node.
+     */
+    public boolean isBootstrap() {
+        return i < 0 || j < 0;
+    }
+
+    /**
+     * Skips sequences of {@link DiffNode DiffNodes} until a
+     * {@link Snake} or bootstrap node is found, or the end
+     * of the path is reached.
+     * @return The next first {@link Snake} or bootstrap node in the path, or
+     * <code>null</code>
+     * if none found.
+     */
+    public final PathNode previousSnake() {
+        if (isBootstrap())
+            return null;
+        if (!isSnake() && prev != null)
+            return prev.previousSnake();
+        return this;
+    }
+    
+    /**
+     * {@inheritDoc}
+     */
+    public String toString() {
+        StringBuilder buf = new StringBuilder("[");
+        PathNode node = this;
+        while (node != null) {
+            buf.append("(");
+            buf.append(Integer.toString(node.i));
+            buf.append(",");
+            buf.append(Integer.toString(node.j));
+            buf.append(")");
+            node = node.prev;
+        }
+        buf.append("]");
+        return buf.toString();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/util/diff/myers/Snake.java b/src/main/java/org/assertj/core/util/diff/myers/Snake.java
new file mode 100644
index 000000000..13f245645
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/diff/myers/Snake.java
@@ -0,0 +1,92 @@
+/*
+ * ====================================================================
+ *
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 1999-2003 The Apache Software Foundation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution, if
+ *    any, must include the following acknowledgement:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgement may appear in the software itself,
+ *    if and wherever such third-party acknowledgements normally appear.
+ *
+ * 4. The names "The Jakarta Project", "Commons", and "Apache Software
+ *    Foundation" must not be used to endorse or promote products derived
+ *    from this software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.assertj.core.util.diff.myers;
+
+/**
+ *  Represents a snake in a diffpath.
+ * <p>
+ *
+ * {@link DiffNode DiffNodes} and {@link Snake Snakes} allow for compression
+ * of diffpaths, as each snake is represented by a single {@link Snake Snake}
+ * node and each contiguous series of insertions and deletions is represented
+ * by a single {@link DiffNode DiffNodes}.
+ *
+ * @author <a href="mailto:juanco@suigeneris.org">Juanco Anez</a>
+ *
+ */
+public final class Snake extends PathNode {
+    /**
+     * Constructs a snake node.
+     *
+     * @param i the position in the original sequence
+     * @param j the position in the revised sequence
+     * @param prev the previous node in the path.
+     */
+    public Snake(int i, int j, PathNode prev) {
+        super(i, j, prev);
+    }
+    
+    /**
+     * {@inheritDoc}
+     * @return true always
+     */
+    public boolean isSnake() {
+        return true;
+    }
+    
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/files/Diff_diff_File_Test.java b/src/test/java/org/assertj/core/internal/files/Diff_diff_File_Test.java
index e734bfe2a..5c31dcdf3 100644
--- a/src/test/java/org/assertj/core/internal/files/Diff_diff_File_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Diff_diff_File_Test.java
@@ -71,9 +71,18 @@ public class Diff_diff_File_Test {
     writer.write(actual, "line_0", "line_1");
     writer.write(expected, "line0", "line1");
     List<String> diffs = diff.diff(actual, expected);
+    assertThat(diffs).hasSize(1);
+    assertThat(diffs.get(0)).isEqualTo("line:<1>, expected:<line0\nline1> but was:<line_0\nline_1>");
+  }
+
+  @Test
+  public void should_return_multiple_diffs_if_files_contain_multiple_differences() throws IOException {
+    writer.write(actual, "line_0", "line1", "line_2");
+    writer.write(expected, "line0", "line1", "line2");
+    List<String> diffs = diff.diff(actual, expected);
     assertThat(diffs).hasSize(2);
     assertThat(diffs.get(0)).isEqualTo("line:<1>, expected:<line0> but was:<line_0>");
-    assertThat(diffs.get(1)).isEqualTo("line:<2>, expected:<line1> but was:<line_1>");
+    assertThat(diffs.get(1)).isEqualTo("line:<3>, expected:<line2> but was:<line_2>");
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/internal/inputstreams/Diff_diff_InputStream_Test.java b/src/test/java/org/assertj/core/internal/inputstreams/Diff_diff_InputStream_Test.java
index 734a55823..90a4d6af6 100644
--- a/src/test/java/org/assertj/core/internal/inputstreams/Diff_diff_InputStream_Test.java
+++ b/src/test/java/org/assertj/core/internal/inputstreams/Diff_diff_InputStream_Test.java
@@ -64,9 +64,18 @@ public class Diff_diff_InputStream_Test {
     actual = stream("base", "line_0", "line_1");
     expected = stream("base", "line0", "line1");
     List<String> diffs = diff.diff(actual, expected);
+    assertThat(diffs).hasSize(1);
+    assertThat(diffs.get(0)).isEqualTo("line:<2>, expected:<line0\nline1> but was:<line_0\nline_1>");
+  }
+
+  @Test
+  public void should_return_multiple_diffs_if_inputstreams_contain_multiple_differences() throws IOException {
+    actual = stream("base", "line_0", "line1", "line_2");
+    expected = stream("base", "line0", "line1", "line2");
+    List<String> diffs = diff.diff(actual, expected);
     assertThat(diffs).hasSize(2);
     assertThat(diffs.get(0)).isEqualTo("line:<2>, expected:<line0> but was:<line_0>");
-    assertThat(diffs.get(1)).isEqualTo("line:<3>, expected:<line1> but was:<line_1>");
+    assertThat(diffs.get(1)).isEqualTo("line:<4>, expected:<line2> but was:<line_2>");
   }
 
   @Test
@@ -86,4 +95,13 @@ public class Diff_diff_InputStream_Test {
     assertThat(diffs).hasSize(1);
     assertThat(diffs.get(0)).isEqualTo("line:<3>, expected:<EOF> but was:<line_1>");
   }
+
+  @Test
+  public void should_return_single_diff_line_for_new_line_at_start() throws IOException {
+    actual = stream("", "line_0", "line_1", "line_2");
+    expected = stream("line_0", "line_1", "line_2");
+    List<String> diffs = diff.diff(actual, expected);
+    assertThat(diffs).hasSize(1);
+    assertThat(diffs.get(0)).isEqualTo("line:<1>, expected:<EOF> but was:<>");
+  }
 }
diff --git a/src/test/java/org/assertj/core/util/diff/ChangeDeltaTest.java b/src/test/java/org/assertj/core/util/diff/ChangeDeltaTest.java
new file mode 100644
index 000000000..a32700773
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/diff/ChangeDeltaTest.java
@@ -0,0 +1,38 @@
+package org.assertj.core.util.diff;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class ChangeDeltaTest {
+
+  @Test
+  public void testGetType() throws Exception {
+    // given
+    Chunk<String> chunk = new Chunk<>(1, new ArrayList<>());
+    Delta<String> delta = new ChangeDelta<>(chunk, chunk);
+
+    // when
+    Delta.TYPE type = delta.getType();
+
+    // then
+    assertThat(type).isEqualTo(Delta.TYPE.CHANGE);
+  }
+
+  @Test
+  public void testToString() throws Exception {
+    // given
+    Chunk<String> chunk1 = new Chunk<>(1, new ArrayList<>());
+    Chunk<String> chunk2 = new Chunk<>(2, Arrays.asList("line1", "line2"));
+    Delta<String> delta = new ChangeDelta<>(chunk1, chunk2);
+
+    // when
+    String desc = delta.toString();
+
+    // then
+    assertThat(desc).isEqualTo("[ChangeDelta, position: 1, lines: [] to [line1, line2]]");
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/util/diff/DeleteDeltaTest.java b/src/test/java/org/assertj/core/util/diff/DeleteDeltaTest.java
new file mode 100644
index 000000000..8a98eeb63
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/diff/DeleteDeltaTest.java
@@ -0,0 +1,38 @@
+package org.assertj.core.util.diff;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class DeleteDeltaTest {
+
+  @Test
+  public void testGetType() throws Exception {
+    // given
+    Chunk<String> chunk = new Chunk<>(1, new ArrayList<>());
+    Delta<String> delta = new DeleteDelta<>(chunk, chunk);
+
+    // when
+    Delta.TYPE type = delta.getType();
+
+    // then
+    assertThat(type).isEqualTo(Delta.TYPE.DELETE);
+  }
+
+  @Test
+  public void testToString() throws Exception {
+    // given
+    Chunk<String> chunk1 = new Chunk<>(1, Arrays.asList("line1", "line2"));
+    Chunk<String> chunk2 = new Chunk<>(2, new ArrayList<>());
+    Delta<String> delta = new DeleteDelta<>(chunk1, chunk2);
+
+    // when
+    String desc = delta.toString();
+
+    // then
+    assertThat(desc).isEqualTo("[DeleteDelta, position: 1, lines: [line1, line2]]");
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/util/diff/DiffTest.java b/src/test/java/org/assertj/core/util/diff/DiffTest.java
new file mode 100644
index 000000000..a493e7d7a
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/diff/DiffTest.java
@@ -0,0 +1,58 @@
+package org.assertj.core.util.diff;
+
+import junit.framework.TestCase;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+public class DiffTest extends TestCase {
+
+    public void testDiff_Insert() {
+        final Patch<String> patch = DiffUtils.diff(Arrays.asList("hhh"), Arrays.asList("hhh", "jjj", "kkk"));
+        assertNotNull(patch);
+        assertEquals(1, patch.getDeltas().size());
+        final Delta<String> delta = patch.getDeltas().get(0);
+        assertEquals(InsertDelta.class, delta.getClass());
+        assertEquals(new Chunk<String>(1, Collections.<String> emptyList()), delta.getOriginal());
+        assertEquals(new Chunk<String>(1, Arrays.asList("jjj", "kkk")), delta.getRevised());
+    }
+
+    public void testDiff_Delete() {
+        final Patch<String> patch = DiffUtils.diff(Arrays.asList("ddd", "fff", "ggg"), Arrays.asList("ggg"));
+        assertNotNull(patch);
+        assertEquals(1, patch.getDeltas().size());
+        final Delta<String> delta = patch.getDeltas().get(0);
+        assertEquals(DeleteDelta.class, delta.getClass());
+        assertEquals(new Chunk<String>(0, Arrays.asList("ddd", "fff")), delta.getOriginal());
+        assertEquals(new Chunk<String>(0, Collections.<String> emptyList()), delta.getRevised());
+    }
+
+    public void testDiff_Change() {
+        final List<String> changeTest_from = Arrays.asList("aaa", "bbb", "ccc");
+        final List<String> changeTest_to = Arrays.asList("aaa", "zzz", "ccc");
+
+        final Patch<String> patch = DiffUtils.diff(changeTest_from, changeTest_to);
+        assertNotNull(patch);
+        assertEquals(1, patch.getDeltas().size());
+        final Delta<String> delta = patch.getDeltas().get(0);
+        assertEquals(ChangeDelta.class, delta.getClass());
+        assertEquals(new Chunk<String>(1, Arrays.asList("bbb")), delta.getOriginal());
+        assertEquals(new Chunk<String>(1, Arrays.asList("zzz")), delta.getRevised());
+    }
+
+    public void testDiff_EmptyList() {
+        final Patch<String> patch = DiffUtils.diff(new ArrayList<String>(), new ArrayList<String>());
+        assertNotNull(patch);
+        assertEquals(0, patch.getDeltas().size());
+    }
+
+    public void testDiff_EmptyListWithNonEmpty() {
+        final Patch<String> patch = DiffUtils.diff(new ArrayList<String>(), Arrays.asList("aaa"));
+        assertNotNull(patch);
+        assertEquals(1, patch.getDeltas().size());
+        final Delta<String> delta = patch.getDeltas().get(0);
+        assertEquals(InsertDelta.class, delta.getClass());
+    }
+}
diff --git a/src/test/java/org/assertj/core/util/diff/GenerateUnifiedDiffTest.java b/src/test/java/org/assertj/core/util/diff/GenerateUnifiedDiffTest.java
new file mode 100644
index 000000000..e22783181
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/diff/GenerateUnifiedDiffTest.java
@@ -0,0 +1,133 @@
+package org.assertj.core.util.diff;
+
+import junit.framework.TestCase;
+
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+
+public class GenerateUnifiedDiffTest extends TestCase {
+
+
+    public List<String> fileToLines(String filename) {
+        List<String> lines = new LinkedList<String>();
+        String line = "";
+        BufferedReader in = null;
+        try {
+            in = new BufferedReader(new FileReader(filename));
+            while ((line = in.readLine()) != null) {
+                lines.add(line);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            fail(e.getMessage());
+        } finally {
+			if (in != null) {
+				try {
+					in.close();
+				} catch (IOException e) {
+					// ignore ... any errors should already have been
+					// reported via an IOException from the final flush.
+				}
+			}
+		}
+        return lines;
+    }
+
+    public void testGenerateUnified() {
+        List<String> origLines = fileToLines(TestConstants.MOCK_FOLDER + "original.txt");
+        List<String> revLines = fileToLines(TestConstants.MOCK_FOLDER + "revised.txt");
+
+        verify(origLines, revLines, "original.txt", "revised.txt");
+    }
+
+    public void testGenerateUnifiedWithOneDelta() {
+        List<String> origLines = fileToLines(TestConstants.MOCK_FOLDER + "one_delta_test_original.txt");
+        List<String> revLines = fileToLines(TestConstants.MOCK_FOLDER + "one_delta_test_revised.txt");
+
+        verify(origLines, revLines, "one_delta_test_original.txt", "one_delta_test_revised.txt");
+    }
+
+    public void testGenerateUnifiedDiffWithoutAnyDeltas() {
+        List<String> test = Arrays.asList("abc");
+        Patch<String> patch = DiffUtils.diff(test, test);
+        DiffUtils.generateUnifiedDiff("abc", "abc", test, patch, 0);
+    }
+
+    public void testDiff_Issue10() {
+        final List<String> baseLines = fileToLines(TestConstants.MOCK_FOLDER + "issue10_base.txt");
+        final List<String> patchLines = fileToLines(TestConstants.MOCK_FOLDER + "issue10_patch.txt");
+        final Patch<String> p = DiffUtils.parseUnifiedDiff(patchLines);
+        try {
+            DiffUtils.patch(baseLines, p);
+        } catch (PatchFailedException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    /**
+     * Issue 12
+     */
+    public void testPatchWithNoDeltas() {
+        final List<String> lines1 = fileToLines(TestConstants.MOCK_FOLDER + "issue11_1.txt");
+        final List<String> lines2 = fileToLines(TestConstants.MOCK_FOLDER + "issue11_2.txt");
+        verify(lines1, lines2, "issue11_1.txt", "issue11_2.txt");
+    }
+
+    public void testDiff5() {
+        final List<String> lines1 = fileToLines(TestConstants.MOCK_FOLDER + "5A.txt");
+        final List<String> lines2 = fileToLines(TestConstants.MOCK_FOLDER + "5B.txt");
+        verify(lines1, lines2, "5A.txt", "5B.txt");
+    }
+
+    /**
+     * Issue 19
+     */
+    public void testDiffWithHeaderLineInText() {
+        List<String> original = new ArrayList<String>();
+        List<String> revised  = new ArrayList<String>();
+
+        original.add("test line1");
+        original.add("test line2");
+        original.add("test line 4");
+        original.add("test line 5");
+
+        revised.add("test line1");
+        revised.add("test line2");
+        revised.add("@@ -2,6 +2,7 @@");
+        revised.add("test line 4");
+        revised.add("test line 5");
+
+        Patch<String> patch = DiffUtils.diff(original, revised);
+        List<String> udiff = DiffUtils.generateUnifiedDiff("original", "revised",
+                original, patch, 10);
+        DiffUtils.parseUnifiedDiff(udiff);
+    }
+
+    private void verify(List<String> origLines, List<String> revLines,
+            String originalFile, String revisedFile) {
+        Patch<String> patch = DiffUtils.diff(origLines, revLines);
+        List<String> unifiedDiff = DiffUtils.generateUnifiedDiff(originalFile, revisedFile,
+                origLines, patch, 10);
+
+        Patch<String> fromUnifiedPatch = DiffUtils.parseUnifiedDiff(unifiedDiff);
+        List<String> patchedLines;
+        try {
+            patchedLines = (List<String>) fromUnifiedPatch.applyTo(origLines);
+            assertTrue(revLines.size() == patchedLines.size());
+            for (int i = 0; i < revLines.size(); i++) {
+                String l1 = revLines.get(i);
+                String l2 = patchedLines.get(i);
+                if (!l1.equals(l2)) {
+                    fail("Line " + (i + 1) + " of the patched file did not match the revised original");
+                }
+            }
+        } catch (PatchFailedException e) {
+            fail(e.getMessage());
+        }
+    }
+}
diff --git a/src/test/java/org/assertj/core/util/diff/InsertDeltaTest.java b/src/test/java/org/assertj/core/util/diff/InsertDeltaTest.java
new file mode 100644
index 000000000..e8925f4bb
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/diff/InsertDeltaTest.java
@@ -0,0 +1,38 @@
+package org.assertj.core.util.diff;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class InsertDeltaTest {
+
+  @Test
+  public void testGetType() throws Exception {
+    // given
+    Chunk<String> chunk = new Chunk<>(1, new ArrayList<>());
+    Delta<String> delta = new InsertDelta<>(chunk, chunk);
+
+    // when
+    Delta.TYPE type = delta.getType();
+
+    // then
+    assertThat(type).isEqualTo(Delta.TYPE.INSERT);
+  }
+
+  @Test
+  public void testToString() throws Exception {
+    // given
+    Chunk<String> chunk1 = new Chunk<>(1, new ArrayList<>());
+    Chunk<String> chunk2 = new Chunk<>(2, Arrays.asList("line1", "line2"));
+    Delta<String> delta = new InsertDelta<>(chunk1, chunk2);
+
+    // when
+    String desc = delta.toString();
+
+    // then
+    assertThat(desc).isEqualTo("[InsertDelta, position: 1, lines: [line1, line2]]");
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/util/diff/PatchTest.java b/src/test/java/org/assertj/core/util/diff/PatchTest.java
new file mode 100644
index 000000000..57be5b5fd
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/diff/PatchTest.java
@@ -0,0 +1,45 @@
+package org.assertj.core.util.diff;
+
+import junit.framework.TestCase;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class PatchTest extends TestCase {
+
+    public void testPatch_Insert()  {
+        final List<String> insertTest_from = Arrays.asList("hhh");
+        final List<String> insertTest_to = Arrays.asList("hhh", "jjj", "kkk", "lll");
+
+        final Patch<String> patch = DiffUtils.diff(insertTest_from, insertTest_to);
+        try {
+            assertEquals(insertTest_to, DiffUtils.patch(insertTest_from, patch));
+        } catch (PatchFailedException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    public void testPatch_Delete() {
+        final List<String> deleteTest_from = Arrays.asList("ddd", "fff", "ggg", "hhh");
+        final List<String> deleteTest_to = Arrays.asList("ggg");
+
+        final Patch<String> patch = DiffUtils.diff(deleteTest_from, deleteTest_to);
+        try {
+            assertEquals(deleteTest_to, DiffUtils.patch(deleteTest_from, patch));
+        } catch (PatchFailedException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    public void testPatch_Change() {
+        final List<String> changeTest_from = Arrays.asList("aaa", "bbb", "ccc", "ddd");
+        final List<String> changeTest_to = Arrays.asList("aaa", "bxb", "cxc", "ddd");
+
+        final Patch<String> patch = DiffUtils.diff(changeTest_from, changeTest_to);
+        try {
+            assertEquals(changeTest_to, DiffUtils.patch(changeTest_from, patch));
+        } catch (PatchFailedException e) {
+            fail(e.getMessage());
+        }
+    }
+}
diff --git a/src/test/java/org/assertj/core/util/diff/TestConstants.java b/src/test/java/org/assertj/core/util/diff/TestConstants.java
new file mode 100644
index 000000000..d25b4173a
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/diff/TestConstants.java
@@ -0,0 +1,25 @@
+package org.assertj.core.util.diff;
+
+import java.io.File;
+
+/**
+ * Test constants
+ * @author simon.mittermueller@gmail.com
+ *
+ */
+public final class TestConstants {
+
+	private TestConstants() {
+		// prevent construction.
+	}
+	
+	/** File separator. */
+	public static final String FS = File.separator;
+	
+	/** The base resource path. */
+	public static String BASE_FOLDER_RESOURCES = "src" + FS + "test" + FS + "resources";
+	
+	/** The base folder containing the test files. Ends with {@link #FS}. */
+	public static final String MOCK_FOLDER = BASE_FOLDER_RESOURCES + FS + "diffs" + FS;
+	
+}
diff --git a/src/test/resources/diffs/5A.txt b/src/test/resources/diffs/5A.txt
new file mode 100644
index 000000000..69eafd8b4
--- /dev/null
+++ b/src/test/resources/diffs/5A.txt
@@ -0,0 +1,372 @@
+#!/bin/sh
+#
+# Copyright (c) 2006 Johannes E. Schindelin
+#
+
+test_description='Test special whitespace in diff engine.
+
+'
+. ./test-lib.sh
+. ../diff-lib.sh
+
+# Ray Lehtiniemi's example
+
+cat << EOF > x
+do {
+   nothing;
+} while (0);
+EOF
+
+git update-index --add x
+
+cat << EOF > x
+do
+{
+   nothing;
+}
+while (0);
+EOF
+
+cat << EOF > expect
+diff --git a/x b/x
+index adf3937..6edc172 100644
+--- a/x
++++ b/x
+@@ -1,3 +1,5 @@
+-do {
++do
++{
+    nothing;
+-} while (0);
++}
++while (0);
+EOF
+
+git diff > out
+test_expect_success "Ray's example without options" 'test_cmp expect out'
+
+git diff -w > out
+test_expect_success "Ray's example with -w" 'test_cmp expect out'
+
+git diff -b > out
+test_expect_success "Ray's example with -b" 'test_cmp expect out'
+
+tr 'Q' '\015' << EOF > x
+whitespace at beginning
+whitespace change
+whitespace in the middle
+whitespace at end
+unchanged line
+CR at endQ
+EOF
+
+git update-index x
+
+tr '_' ' ' << EOF > x
+                whitespace at beginning
+whitespace          change
+white space in the middle
+whitespace at end__
+unchanged line
+CR at end
+EOF
+
+tr 'Q_' '\015 ' << EOF > expect
+diff --git a/x b/x
+index d99af23..8b32fb5 100644
+--- a/x
++++ b/x
+@@ -1,6 +1,6 @@
+-whitespace at beginning
+-whitespace change
+-whitespace in the middle
+-whitespace at end
++             whitespace at beginning
++whitespace       change
++white space in the middle
++whitespace at end__
+unchanged line
+-CR at endQ
++CR at end
+EOF
+git diff > out
+test_expect_success 'another test, without options' 'test_cmp expect out'
+
+cat << EOF > expect
+diff --git a/x b/x
+index d99af23..8b32fb5 100644
+EOF
+git diff -w > out
+test_expect_success 'another test, with -w' 'test_cmp expect out'
+
+tr 'Q' '\015' << EOF > expect
+diff --git a/x b/x
+index d99af23..8b32fb5 100644
+--- a/x
++++ b/x
+@@ -1,6 +1,6 @@
+-whitespace at beginning
++             whitespace at beginning
+whitespace change
+-whitespace in the middle
++white space in the middle
+whitespace at end
+unchanged line
+CR at endQ
+EOF
+git diff -b > out
+test_expect_success 'another test, with -b' 'test_cmp expect out'
+
+test_expect_success 'check mixed spaces and tabs in indent' '
+
+                # This is indented with SP HT SP.
+                echo "    foo();" > x &&
+                git diff --check | grep "space before tab in indent"
+
+'
+
+test_expect_success 'check mixed tabs and spaces in indent' '
+
+                # This is indented with HT SP HT.
+                echo "                  foo();" > x &&
+                git diff --check | grep "space before tab in indent"
+
+'
+
+test_expect_success 'check with no whitespace errors' '
+
+                git commit -m "snapshot" &&
+                echo "foo();" > x &&
+                git diff --check
+
+'
+
+test_expect_success 'check with trailing whitespace' '
+
+                echo "foo(); " > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'check with space before tab in indent' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success '--check and --exit-code are not exclusive' '
+
+                git checkout x &&
+                git diff --check --exit-code
+
+'
+
+test_expect_success '--check and --quiet are not exclusive' '
+
+                git diff --check --quiet
+
+'
+
+test_expect_success 'check staged with no whitespace errors' '
+
+                echo "foo();" > x &&
+                git add x &&
+                git diff --cached --check
+
+'
+
+test_expect_success 'check staged with trailing whitespace' '
+
+                echo "foo(); " > x &&
+                git add x &&
+                test_must_fail git diff --cached --check
+
+'
+
+test_expect_success 'check staged with space before tab in indent' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                git add x &&
+                test_must_fail git diff --cached --check
+
+'
+
+test_expect_success 'check with no whitespace errors (diff-index)' '
+
+                echo "foo();" > x &&
+                git add x &&
+                git diff-index --check HEAD
+
+'
+
+test_expect_success 'check with trailing whitespace (diff-index)' '
+
+                echo "foo(); " > x &&
+                git add x &&
+                test_must_fail git diff-index --check HEAD
+
+'
+
+test_expect_success 'check with space before tab in indent (diff-index)' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                git add x &&
+                test_must_fail git diff-index --check HEAD
+
+'
+
+test_expect_success 'check staged with no whitespace errors (diff-index)' '
+
+                echo "foo();" > x &&
+                git add x &&
+                git diff-index --cached --check HEAD
+
+'
+
+test_expect_success 'check staged with trailing whitespace (diff-index)' '
+
+                echo "foo(); " > x &&
+                git add x &&
+                test_must_fail git diff-index --cached --check HEAD
+
+'
+
+test_expect_success 'check staged with space before tab in indent (diff-index)' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                git add x &&
+                test_must_fail git diff-index --cached --check HEAD
+
+'
+
+test_expect_success 'check with no whitespace errors (diff-tree)' '
+
+                echo "foo();" > x &&
+                git commit -m "new commit" x &&
+                git diff-tree --check HEAD^ HEAD
+
+'
+
+test_expect_success 'check with trailing whitespace (diff-tree)' '
+
+                echo "foo(); " > x &&
+                git commit -m "another commit" x &&
+                test_must_fail git diff-tree --check HEAD^ HEAD
+
+'
+
+test_expect_success 'check with space before tab in indent (diff-tree)' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                git commit -m "yet another" x &&
+                test_must_fail git diff-tree --check HEAD^ HEAD
+
+'
+
+test_expect_success 'check trailing whitespace (trailing-space: off)' '
+
+                git config core.whitespace "-trailing-space" &&
+                echo "foo ();   " > x &&
+                git diff --check
+
+'
+
+test_expect_success 'check trailing whitespace (trailing-space: on)' '
+
+                git config core.whitespace "trailing-space" &&
+                echo "foo ();   " > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'check space before tab in indent (space-before-tab: off)' '
+
+                # indent contains space followed by HT
+                git config core.whitespace "-space-before-tab" &&
+                echo "   foo ();" > x &&
+                git diff --check
+
+'
+
+test_expect_success 'check space before tab in indent (space-before-tab: on)' '
+
+                # indent contains space followed by HT
+                git config core.whitespace "space-before-tab" &&
+                echo "   foo ();   " > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'check spaces as indentation (indent-with-non-tab: off)' '
+
+                git config core.whitespace "-indent-with-non-tab"
+                echo "        foo ();" > x &&
+                git diff --check
+
+'
+
+test_expect_success 'check spaces as indentation (indent-with-non-tab: on)' '
+
+                git config core.whitespace "indent-with-non-tab" &&
+                echo "        foo ();" > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'check tabs and spaces as indentation (indent-with-non-tab: on)' '
+
+                git config core.whitespace "indent-with-non-tab" &&
+                echo "                   foo ();" > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'line numbers in --check output are correct' '
+
+                echo "" > x &&
+                echo "foo(); " >> x &&
+                git diff --check | grep "x:2:"
+
+'
+
+test_expect_success 'checkdiff detects trailing blank lines' '
+                echo "foo();" >x &&
+                echo "" >>x &&
+                git diff --check | grep "ends with blank"
+'
+
+test_expect_success 'checkdiff allows new blank lines' '
+                git checkout x &&
+                mv x y &&
+                (
+                                echo "/* This is new */" &&
+                                echo "" &&
+                                cat y
+                ) >x &&
+                git diff --check
+'
+
+test_expect_success 'combined diff with autocrlf conversion' '
+
+                git reset --hard &&
+                echo >x hello &&
+                git commit -m "one side" x &&
+                git checkout HEAD^ &&
+                echo >x goodbye &&
+                git commit -m "the other side" x &&
+                git config core.autocrlf true &&
+                test_must_fail git merge master &&
+
+                git diff | sed -e "1,/^@@@/d" >actual &&
+                ! grep "^-" actual
+
+'
+
+test_done
+
diff --git a/src/test/resources/diffs/5B.txt b/src/test/resources/diffs/5B.txt
new file mode 100644
index 000000000..112cff5af
--- /dev/null
+++ b/src/test/resources/diffs/5B.txt
@@ -0,0 +1,381 @@
+#!/bin/sh
+#
+# Copyright (c) 2006 Johannes E. Schindelin
+#
+
+test_description='Test special whitespace in diff engine.
+
+'
+. ./test-lib.sh
+. ../diff-lib.sh
+
+# Ray Lehtiniemi's example
+
+cat << EOF > x
+do {
+   nothing;
+} while (0);
+EOF
+
+git update-index --add x
+
+cat << EOF > x
+do
+{
+   nothing;
+}
+while (0);
+EOF
+
+cat << EOF > expect
+diff --git a/x b/x
+index adf3937..6edc172 100644
+--- a/x
++++ b/x
+@@ -1,3 +1,5 @@
+-do {
++do
++{
+    nothing;
+-} while (0);
++}
++while (0);
+EOF
+
+git diff > out
+test_expect_success "Ray's example without options" 'test_cmp expect out'
+
+git diff -w > out
+test_expect_success "Ray's example with -w" 'test_cmp expect out'
+
+git diff -b > out
+test_expect_success "Ray's example with -b" 'test_cmp expect out'
+
+tr 'Q' '\015' << EOF > x
+whitespace at beginning
+whitespace change
+whitespace in the middle
+whitespace at end
+unchanged line
+CR at endQ
+EOF
+
+git update-index x
+
+tr '_' ' ' << EOF > x
+                whitespace at beginning
+whitespace          change
+white space in the middle
+whitespace at end__
+unchanged line
+CR at end
+EOF
+
+tr 'Q_' '\015 ' << EOF > expect
+diff --git a/x b/x
+index d99af23..8b32fb5 100644
+--- a/x
++++ b/x
+@@ -1,6 +1,6 @@
+-whitespace at beginning
+-whitespace change
+-whitespace in the middle
+-whitespace at end
++             whitespace at beginning
++whitespace       change
++white space in the middle
++whitespace at end__
+unchanged line
+-CR at endQ
++CR at end
+EOF
+git diff > out
+test_expect_success 'another test, without options' 'test_cmp expect out'
+
+cat << EOF > expect
+diff --git a/x b/x
+index d99af23..8b32fb5 100644
+EOF
+git diff -w > out
+test_expect_success 'another test, with -w' 'test_cmp expect out'
+
+tr 'Q' '\015' << EOF > expect
+diff --git a/x b/x
+index d99af23..8b32fb5 100644
+--- a/x
++++ b/x
+@@ -1,6 +1,6 @@
+-whitespace at beginning
++             whitespace at beginning
+whitespace change
+-whitespace in the middle
++white space in the middle
+whitespace at end
+unchanged line
+CR at endQ
+git diff -b --ignore-space-at-eol > out
+test_expect_failure 'another test, with -b --ignore-space-at-eol' 'test_cmp expect out'
+
+tr 'Q' '\015' << EOF > expect
+diff --git a/x b/x
+index d99af23..8b32fb5 100644
+--- a/x
++++ b/x
+EOF
+git diff -b > out
+test_expect_success 'another test, with -b' 'test_cmp expect out'
+
+test_expect_success 'check mixed spaces and tabs in indent' '
+
+                # This is indented with SP HT SP.
+                echo "    foo();" > x &&
+                git diff --check | grep "space before tab in indent"
+
+'
+
+test_expect_success 'check mixed tabs and spaces in indent' '
+
+                # This is indented with HT SP HT.
+                echo "                  foo();" > x &&
+                git diff --check | grep "space before tab in indent"
+
+'
+
+test_expect_success 'check with no whitespace errors' '
+
+                git commit -m "snapshot" &&
+                echo "foo();" > x &&
+                git diff --check
+
+'
+
+test_expect_success 'check with trailing whitespace' '
+
+                echo "foo(); " > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'check with space before tab in indent' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success '--check and --exit-code are not exclusive' '
+
+                git checkout x &&
+                git diff --check --exit-code
+
+'
+
+test_expect_success '--check and --quiet are not exclusive' '
+
+                git diff --check --quiet
+
+'
+
+test_expect_success 'check staged with no whitespace errors' '
+
+                echo "foo();" > x &&
+                git add x &&
+                git diff --cached --check
+
+'
+
+test_expect_success 'check staged with trailing whitespace' '
+
+                echo "foo(); " > x &&
+                git add x &&
+                test_must_fail git diff --cached --check
+
+'
+
+test_expect_success 'check staged with space before tab in indent' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                git add x &&
+                test_must_fail git diff --cached --check
+
+'
+
+test_expect_success 'check with no whitespace errors (diff-index)' '
+
+                echo "foo();" > x &&
+                git add x &&
+                git diff-index --check HEAD
+
+'
+
+test_expect_success 'check with trailing whitespace (diff-index)' '
+
+                echo "foo(); " > x &&
+                git add x &&
+                test_must_fail git diff-index --check HEAD
+
+'
+
+test_expect_success 'check with space before tab in indent (diff-index)' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                git add x &&
+                test_must_fail git diff-index --check HEAD
+
+'
+
+test_expect_success 'check staged with no whitespace errors (diff-index)' '
+
+                echo "foo();" > x &&
+                git add x &&
+                git diff-index --cached --check HEAD
+
+'
+
+test_expect_success 'check staged with trailing whitespace (diff-index)' '
+
+                echo "foo(); " > x &&
+                git add x &&
+                test_must_fail git diff-index --cached --check HEAD
+
+'
+
+test_expect_success 'check staged with space before tab in indent (diff-index)' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                git add x &&
+                test_must_fail git diff-index --cached --check HEAD
+
+'
+
+test_expect_success 'check with no whitespace errors (diff-tree)' '
+
+                echo "foo();" > x &&
+                git commit -m "new commit" x &&
+                git diff-tree --check HEAD^ HEAD
+
+'
+
+test_expect_success 'check with trailing whitespace (diff-tree)' '
+
+                echo "foo(); " > x &&
+                git commit -m "another commit" x &&
+                test_must_fail git diff-tree --check HEAD^ HEAD
+
+'
+
+test_expect_success 'check with space before tab in indent (diff-tree)' '
+
+                # indent has space followed by hard tab
+                echo "   foo();" > x &&
+                git commit -m "yet another" x &&
+                test_must_fail git diff-tree --check HEAD^ HEAD
+
+'
+
+test_expect_success 'check trailing whitespace (trailing-space: off)' '
+
+                git config core.whitespace "-trailing-space" &&
+                echo "foo ();   " > x &&
+                git diff --check
+
+'
+
+test_expect_success 'check trailing whitespace (trailing-space: on)' '
+
+                git config core.whitespace "trailing-space" &&
+                echo "foo ();   " > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'check space before tab in indent (space-before-tab: off)' '
+
+                # indent contains space followed by HT
+                git config core.whitespace "-space-before-tab" &&
+                echo "   foo ();" > x &&
+                git diff --check
+
+'
+
+test_expect_success 'check space before tab in indent (space-before-tab: on)' '
+
+                # indent contains space followed by HT
+                git config core.whitespace "space-before-tab" &&
+                echo "   foo ();   " > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'check spaces as indentation (indent-with-non-tab: off)' '
+
+                git config core.whitespace "-indent-with-non-tab"
+                echo "        foo ();" > x &&
+                git diff --check
+
+'
+
+test_expect_success 'check spaces as indentation (indent-with-non-tab: on)' '
+
+                git config core.whitespace "indent-with-non-tab" &&
+                echo "        foo ();" > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'check tabs and spaces as indentation (indent-with-non-tab: on)' '
+
+                git config core.whitespace "indent-with-non-tab" &&
+                echo "                   foo ();" > x &&
+                test_must_fail git diff --check
+
+'
+
+test_expect_success 'line numbers in --check output are correct' '
+
+                echo "" > x &&
+                echo "foo(); " >> x &&
+                git diff --check | grep "x:2:"
+
+'
+
+test_expect_success 'checkdiff detects trailing blank lines' '
+                echo "foo();" >x &&
+                echo "" >>x &&
+                git diff --check | grep "ends with blank"
+'
+
+test_expect_success 'checkdiff allows new blank lines' '
+                git checkout x &&
+                mv x y &&
+                (
+                                echo "/* This is new */" &&
+                                echo "" &&
+                                cat y
+                ) >x &&
+                git diff --check
+'
+
+test_expect_success 'combined diff with autocrlf conversion' '
+
+                git reset --hard &&
+                echo >x hello &&
+                git commit -m "one side" x &&
+                git checkout HEAD^ &&
+                echo >x goodbye &&
+                git commit -m "the other side" x &&
+                git config core.autocrlf true &&
+                test_must_fail git merge master &&
+
+                git diff | sed -e "1,/^@@@/d" >actual &&
+                ! grep "^-" actual
+
+'
+
+test_done
+
+
diff --git a/src/test/resources/diffs/issue10_base.txt b/src/test/resources/diffs/issue10_base.txt
new file mode 100644
index 000000000..c0a2b2146
--- /dev/null
+++ b/src/test/resources/diffs/issue10_base.txt
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="Python" name="Python">
+      <configuration sdkName="Python 2.7 (C:/Python27/python.exe)" />
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/resources" isTestSource="false" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" name="Python 2.7 (C:/Python27/python.exe) interpreter library" level="application" />
+    <orderEntry type="module-library">
+      <library>
+        <CLASSES>
+          <root url="jar://$MODULE_DIR$/lib/commons-io-1.4.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
+    <orderEntry type="module-library">
+      <library>
+        <CLASSES>
+          <root url="jar://$MODULE_DIR$/lib/java-diff-utils-1.2.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
+    <orderEntry type="module-library">
+      <library>
+        <CLASSES>
+          <root url="jar://$MODULE_DIR$/lib/jython.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
+  </component>
+</module>
+
diff --git a/src/test/resources/diffs/issue10_patch.txt b/src/test/resources/diffs/issue10_patch.txt
new file mode 100644
index 000000000..736fdddf0
--- /dev/null
+++ b/src/test/resources/diffs/issue10_patch.txt
@@ -0,0 +1,10 @@
+--- /bonobo/bonobo.iml
++++ /bonobo/bonobo.iml
+@@ -41,6 +40,7 @@
+         <SOURCES />
+       </library>
+     </orderEntry>
++    <orderEntry type="library" name="Python 2.6.6 (/usr/bin/python2.6) interpreter library" level="application" />
+   </component>
+ </module>
+
diff --git a/src/test/resources/diffs/issue11_1.txt b/src/test/resources/diffs/issue11_1.txt
new file mode 100644
index 000000000..29c06f765
--- /dev/null
+++ b/src/test/resources/diffs/issue11_1.txt
@@ -0,0 +1 @@
+svn: '77954' path not found
diff --git a/src/test/resources/diffs/issue11_2.txt b/src/test/resources/diffs/issue11_2.txt
new file mode 100644
index 000000000..29c06f765
--- /dev/null
+++ b/src/test/resources/diffs/issue11_2.txt
@@ -0,0 +1 @@
+svn: '77954' path not found
diff --git a/src/test/resources/diffs/one_delta_test_original.txt b/src/test/resources/diffs/one_delta_test_original.txt
new file mode 100644
index 000000000..5d5433030
--- /dev/null
+++ b/src/test/resources/diffs/one_delta_test_original.txt
@@ -0,0 +1,54 @@
+<p>Esta &eacute; uma obra Online.</p>
+<p>&nbsp;</p>
+<p><strong>Este texto &eacute; negrito</strong></p>
+<p><em>Este texto &eacute; it&aacute;lico</em></p>
+<p><span style="text-decoration:underline;">Este texto est&aacute; sublinhado</span></p>
+<p><span style="text-decoration: line-through;">Este texto est&aacute; riscado</span></p>
+<p style="text-align: center;">Este texto est&aacute; centralizado</p>
+<p style="text-align: right;">Este texto est&aacute; alinhado a direita</p>
+<ol>
+<li>Este texto est&aacute; em uma lista num&eacute;rica<ol>
+<li>Este texto est&aacute; identado</li>
+</ol></li>
+</ol>
+<p><a title="uol" href="http://www.uol.com.br" target="_blank">Este
+aqui &eacute; um link</a></p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>,
+<p>&nbsp;</p>
+<p>P&aacute;gina 1</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>P&aacute;gina 2</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>&nbsp;</p>
+<p>P&aacute;gina 3</p>
+<p>&nbsp;</p>
\ No newline at end of file
diff --git a/src/test/resources/diffs/one_delta_test_revised.txt b/src/test/resources/diffs/one_delta_test_revised.txt
new file mode 100644
index 000000000..9197a7388
--- /dev/null
+++ b/src/test/resources/diffs/one_delta_test_revised.txt
@@ -0,0 +1,11 @@
+<p>Revis&atilde;o 3</p><p>&nbsp;</p><p>Esta &eacute; uma obra
+Online.</p><p>&nbsp;</p><p><strong>Este texto &eacute;
+negrit</strong></p><p>Este texto &eacute; it&aacute;lico/p><p><span
+style="text-decoration: undeline;">Este texto est&aacute;
+sublinhado</span></p><p>Este texto est&aacute; riscado agora n&atilde;o
+est&aacute; mais</p>p style="text-align: left;">Este texto est&aacute;
+centralizado nem este</p><p style="text-align: right;">Este texto
+est&aacute; alinhado a direita</p><ol><li>Este texto est&aacute; em uma
+lista num&eacute;rica</li></ol><p><a title="uol"
+href="http://www.uol.com.br" target="_blank">Este aqui &eacute; um
+link</a></p>
\ No newline at end of file
diff --git a/src/test/resources/diffs/original.txt b/src/test/resources/diffs/original.txt
new file mode 100644
index 000000000..479dca0d2
--- /dev/null
+++ b/src/test/resources/diffs/original.txt
@@ -0,0 +1,174 @@
+/*
+    Copyright 2009 Dmitry Naumenko (dm.naumenko@gmail.com)
+    
+    This file is part of Java Diff Utills Library.
+
+    Java Diff Utills Library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Java Diff Utills Library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Java Diff Utills Library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+package difflib;
+
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import difflib.myers.*;
+
+/**
+ * Implements the difference and patching engine
+ * 
+ * @author <a href="dm.naumenko@gmail.com">Dmitry Naumenko</a>
+ * @version 0.4.1
+ */
+public class DiffUtils {
+	private static DiffAlgorithm defaultDiffAlgorithm = new MyersDiff();
+	private static Pattern unifiedDiffChunkRe = 
+		Pattern.compile("@@\\s+-(?:(\\d+)(?:,(\\d+))?)\\s+\\+(?:(\\d+)(?:,(\\d+))?)\\s+@@");
+	
+	/**
+	 * Compute the difference between the original and revised texts with default diff algorithm 
+	 * 
+	 * @param original the original text
+	 * @param revised the revised text
+	 * @return the patch describing the difference between the original and revised texts 
+	 */
+	public static Patch diff(List<?> original, List<?> revised) {
+		return DiffUtils.diff(original, revised, defaultDiffAlgorithm);
+	}
+	
+	/**
+	 * Compute the difference between the original and revised texts with given diff algorithm 
+	 * 
+	 * @param original the original text
+	 * @param revised the revised text
+	 * @param algorithm the given algorithm
+	 * @return the patch describing the difference between the original and revised texts
+	 */
+	public static Patch diff(List<?> original, List<?> revised, DiffAlgorithm algorithm) {
+		return algorithm.diff(original, revised);
+	}
+	
+	/**
+	 * Patch the original text with given patch
+	 * 
+	 * @param original the original text
+	 * @param patch the given patch
+	 * @return the revised text
+	 * @throws PatchFailedException if can't apply patch
+	 */
+	public static List<?> patch(List<?> original, Patch patch) throws PatchFailedException {
+		return patch.applyTo(original);
+	}
+	
+	/**
+	 * Unpatch the revised text for a given patch
+	 * 
+	 * @param revised the revised text
+	 * @param patch the given patch
+	 * @return the original text
+	 */
+	public static List<?> unpatch(List<?> revised, Patch patch) {
+		return patch.restore(revised);
+	}
+	
+	/**
+	 * Parse the given text in unified format and creates the list of deltas for it.
+	 * 
+	 * @param diff the text in unified format 
+	 * @return the patch with deltas.
+	 */
+	public static Patch parseUnifiedDiff(List<String> diff) {
+		boolean inPrelude = true;
+		List<Object[]> rawChunk = new ArrayList<Object[]>();
+		Patch patch = new Patch();
+		
+		int old_ln = 0, old_n = 0, new_ln = 0, new_n = 0;
+		String tag = "", rest = "";
+		for (String line: diff) {
+			// Skip leading lines until after we've seen one starting with '+++'
+			if (inPrelude) {
+				if (line.startsWith("+++")) {
+					inPrelude = false;
+				}
+				continue;
+			}
+			Matcher m = unifiedDiffChunkRe.matcher(line);
+			if (m.find()) {
+				// Process the lines in the previous chunk
+				if (rawChunk.size() != 0) {
+					List<String> oldChunkLines = new ArrayList<String>();
+					List<String> newChunkLines = new ArrayList<String>();
+					
+					for (Object[] raw_line: rawChunk) {
+						tag = (String)raw_line[0];
+						rest = (String)raw_line[1];
+						if (tag.equals(" ") || tag.equals("-")) {
+							oldChunkLines.add(rest);
+						}
+						if (tag.equals(" ") || tag.equals("+")) {
+							newChunkLines.add(rest);
+						}
+					}
+					patch.addDelta(new ChangeDelta(new Chunk(old_ln - 1, old_n, oldChunkLines),  
+							new Chunk(new_ln - 1, new_n, newChunkLines)));
+					rawChunk.clear();
+				}
+				// Parse the @@ header
+				old_ln = m.group(1) == null ? 1 : Integer.parseInt(m.group(1));
+				old_n  = m.group(2) == null ? 1 : Integer.parseInt(m.group(2));
+				new_ln = m.group(3) == null ? 1 : Integer.parseInt(m.group(3));
+				new_n  = m.group(4) == null ? 1 : Integer.parseInt(m.group(4));
+				old_ln = Integer.parseInt(m.group(1));
+				
+				if (old_ln == 0) {
+					old_ln += 1; 
+				}
+				if (new_ln == 0) {
+					new_ln += 1;
+				}
+			} else {
+				if (line.length() > 0) {
+					tag  = line.substring(0, 1);
+					rest = line.substring(1);
+					if (tag.equals(" ") || tag.equals("+") || tag.equals("-")) {
+						rawChunk.add(new Object[] {tag, rest});
+					}
+				}
+			}
+		}
+		
+		// Process the lines in the last chunk
+		if (rawChunk.size() != 0) {
+			List<String> oldChunkLines = new ArrayList<String>();
+			List<String> newChunkLines = new ArrayList<String>();
+			
+			for (Object[] raw_line: rawChunk) {
+				tag = (String)raw_line[0];
+				rest = (String)raw_line[1];
+				if (tag.equals(" ") || tag.equals("-")) {
+					oldChunkLines.add(rest);
+				} 
+				if (tag.equals(" ") || tag.equals("+")) {
+					newChunkLines.add(rest);
+				}
+			}
+			
+			patch.addDelta(new ChangeDelta(new Chunk(old_ln - 1, old_n, oldChunkLines),  
+					new Chunk(new_ln - 1, new_n, newChunkLines)));
+			rawChunk.clear();
+		}
+		
+		return patch;
+	}
+	
+}
diff --git a/src/test/resources/diffs/revised.txt b/src/test/resources/diffs/revised.txt
new file mode 100644
index 000000000..3c19df3e5
--- /dev/null
+++ b/src/test/resources/diffs/revised.txt
@@ -0,0 +1,308 @@
+/*
+    Copyright 2009 Dmitry Naumenko (dm.naumenko@gmail.com)
+    
+    This file is part of Java Diff Utils Library.
+
+    Java Diff Utils Library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Java Diff Utils Library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Java Diff Utils Library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+package difflib;
+
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import difflib.myers.*;
+
+/**
+ * Implements the difference and patching engine
+ * 
+ * @author <a href="dm.naumenko@gmail.com">Dmitry Naumenko</a>
+ * @version 0.4.1
+ */
+public class DiffUtils {
+	private static DiffAlgorithm defaultDiffAlgorithm = new MyersDiff();
+	private static Pattern unifiedDiffChunkRe = 
+		Pattern.compile("@@\\s+-(?:(\\d+)(?:,(\\d+))?)\\s+\\+(?:(\\d+)(?:,(\\d+))?)\\s+@@");
+	
+	/**
+	 * Compute the difference between the original and revised texts with default diff algorithm 
+	 * 
+	 * @param original the original text
+	 * @param revised the revised text
+	 * @return the patch describing the difference between the original and revised texts 
+	 */
+	public static Patch diff(List<?> original, List<?> revised) {
+		return DiffUtils.diff(original, revised, defaultDiffAlgorithm);
+	}
+	
+	/**
+	 * Compute the difference between the original and revised texts with given diff algorithm 
+	 * 
+	 * @param original the original text
+	 * @param revised the revised text
+	 * @param algorithm the given algorithm
+	 * @return the patch describing the difference between the original and revised texts
+	 */
+	public static Patch diff(List<?> original, List<?> revised, DiffAlgorithm algorithm) {
+		return algorithm.diff(original, revised);
+	}
+	
+	/**
+	 * Patch the original text with given patch
+	 * 
+	 * @param original the original text
+	 * @param patch the given patch
+	 * @return the revised text
+	 * @throws PatchFailedException if can't apply patch
+	 */
+	public static List<?> patch(List<?> original, Patch patch) throws PatchFailedException {
+		return patch.applyTo(original);
+	}
+	
+	/**
+	 * Unpatch the revised text for a given patch
+	 * 
+	 * @param revised the revised text
+	 * @param patch the given patch
+	 * @return the original text
+	 */
+	public static List<?> unpatch(List<?> revised, Patch patch) {
+		return patch.restore(revised); // bla-bla-bla
+	}
+	
+	/**
+	 * Parse the given text in unified format and creates the list of deltas for it.
+	 * 
+	 * @param diff the text in unified format 
+	 * @return the patch with deltas.
+	 */
+	public static Patch parseUnifiedDiff(List<String> diff) {
+		boolean inPrelude = true;
+		List<Object[]> rawChunk = new ArrayList<Object[]>();
+		Patch patch = new Patch();
+		
+		int old_ln = 0, old_n = 0, new_ln = 0, new_n = 0;
+		String tag = "", rest = "";
+		for (String line: diff) {
+			// Skip leading lines until after we've seen one starting with '+++'
+			if (inPrelude) {
+				if (line.startsWith("+++")) {
+					inPrelude = false;
+				}
+				continue;
+			}
+			Matcher m = unifiedDiffChunkRe.matcher(line);
+			if (m.find()) {
+				// Process the lines in the previous chunk
+				if (rawChunk.size() != 0) {
+					List<String> oldChunkLines = new ArrayList<String>();
+					List<String> newChunkLines = new ArrayList<String>();
+					
+					for (Object[] raw_line: rawChunk) {
+						tag = (String)raw_line[0];
+						rest = (String)raw_line[1];
+						if (tag.equals(" ") || tag.equals("-")) {
+							oldChunkLines.add(rest);
+						}
+						if (tag.equals(" ") || tag.equals("+")) {
+							newChunkLines.add(rest);
+						}
+					}
+					patch.addDelta(new ChangeDelta(new Chunk(old_ln - 1, old_n, oldChunkLines),  
+							new Chunk(new_ln - 1, new_n, newChunkLines)));
+					rawChunk.clear();
+				}
+				// Parse the @@ header
+				old_ln = m.group(1) == null ? 1 : Integer.parseInt(m.group(1));
+				old_n  = m.group(2) == null ? 1 : Integer.parseInt(m.group(2));
+				new_ln = m.group(3) == null ? 1 : Integer.parseInt(m.group(3));
+				new_n  = m.group(4) == null ? 1 : Integer.parseInt(m.group(4));
+				old_ln = Integer.parseInt(m.group(1));
+				
+				if (old_ln == 0) {
+					old_ln += 1; 
+				}
+				if (new_ln == 0) {
+					new_ln += 1;
+				}
+			} else {
+				if (line.length() > 0) {
+					tag  = line.substring(0, 1);
+					rest = line.substring(1);
+					if (tag.equals(" ") || tag.equals("+") || tag.equals("-")) {
+						rawChunk.add(new Object[] {tag, rest});
+					}
+				}
+			}
+		}
+		
+		// Process the lines in the last chunk
+		if (rawChunk.size() != 0) {
+			List<String> oldChunkLines = new ArrayList<String>();
+			List<String> newChunkLines = new ArrayList<String>();
+			
+			for (Object[] raw_line: rawChunk)
+            {
+				tag = (String)raw_line[0];
+				rest = (String)raw_line[1];
+				if (tag.equals(" ") || tag.equals("-"))
+                {
+					oldChunkLines.add(rest);
+				} 
+				if (tag.equals(" ") || tag.equals("+"))
+                {
+					newChunkLines.add(rest);
+				}
+			}
+			
+			patch.addDelta(new ChangeDelta(new Chunk(old_ln - 1, old_n, oldChunkLines),  
+					new Chunk(new_ln - 1, new_n, newChunkLines)));
+			rawChunk.clear();
+		}
+		
+		return patch;
+	}
+
+	/**
+	 * generateUnifiedDiff takes a Patch and some other arguments, returning the Unified Diff format text representing the Patch.
+	 * @author Bill James (tankerbay@gmail.com)
+	 * 
+	 * @param fname1 - Filename of the original (unrevised file)
+	 * @param fname2 - Filename of the revised file
+	 * @param originalLines - Lines of the original file
+	 * @param patch - Patch created by the diff() function
+	 * @param contextSize - number of lines of context output around each difference in the file.
+	 * @return List of strings representing the Unified Diff representation of the Patch argument.
+	 */
+	public static List<String> generateUnifiedDiff(String fname1, String fname2, List<String> originalLines, Patch patch, int contextSize ) {
+		List<String> ret = new ArrayList<String>();
+		ret.add( "--- " + fname1 );
+		ret.add( "+++ " + fname2 );
+		
+        List<Delta> cur = new ArrayList<Delta>();   // current list of Delta's to process
+        int deltact = patch.getDeltas().size();
+        // if there's more than 1 Delta, we may need to output them together
+        if ( deltact > 1 ) {
+          Delta curDelta = patch.getDelta(0);
+          cur.add( curDelta );   									// add the first Delta to the current set
+          for ( int i = 1; i < deltact; i++ ) {
+        	int curpos = curDelta.getOriginal().getPosition();   		// store the current position of the first Delta  
+            Delta nextDelta = patch.getDelta(i);						// Check if the next Delta is too close to the current position
+            if ( (curpos + curDelta.getOriginal().getSize() + contextSize) >= ( nextDelta.getOriginal().getPosition()-contextSize ) ) {
+              cur.add( nextDelta );  								// if it is, add it to the current set
+            } else {
+              List<String> curBlock = processDeltas( originalLines, cur, contextSize );
+              ret.addAll( curBlock );							// if it isn't, output the current set, then create a new 
+              cur.clear();											// set and add the current Delta to it.
+              cur.add( nextDelta );
+            }
+            curDelta = nextDelta;
+          }
+          List<String> curBlock = processDeltas( originalLines, cur, contextSize );  // don't forget to process the last set of Deltas
+          ret.addAll( curBlock );
+        }
+
+		return ret;
+	}
+
+   /**
+     * processDeltas takes a list of Deltas and outputs them together in a single block of Unified-Diff-format text.
+	 * @author Bill James (tankerbay@gmail.com)
+	 * 
+     * @param origLines - the lines of the original file
+     * @param deltas    - the Deltas to be output as a single block
+     * @param contextSize - the number of lines of context to place around block
+     * @return
+     */
+      private static List<String> processDeltas( List<String> origLines, List<Delta> deltas, int contextSize ) {
+        List<String> buffer = new ArrayList<String>();
+        int origTotal = 0;   // counter for total lines output from Original
+        int revTotal = 0;    // counter for total lines output from Original
+        int line;
+
+        Delta curDelta = deltas.get(0);  // start with the first Delta
+        int origStart = curDelta.getOriginal().getPosition()+1 - contextSize;  	// note the +1 to overcome the 0-offset Position
+        if ( origStart < 1 ) origStart = 1;                                    	// clamp to the start of the file
+        int revStart = curDelta.getRevised().getPosition()+1 - contextSize;    	// note the +1 to overcome the 0-offset Position
+        if ( revStart < 1 ) revStart = 1;										// clamp to the start of the file
+        int contextStart = curDelta.getOriginal().getPosition() - contextSize;	// find the start of the wrapper context code
+        if ( contextStart < 0 ) contextStart = 0;								// clamp to the start of the file
+        for ( line = contextStart; line < curDelta.getOriginal().getPosition(); line++ ) {  // output the context before the first Delta
+          buffer.add( " " + origLines.get( line ) );
+          origTotal++;
+          revTotal++;
+        }
+        buffer.addAll( getDeltaText( curDelta ) );           					// output the first Delta
+        origTotal += curDelta.getOriginal().getLines().size();
+        revTotal += curDelta.getRevised().getLines().size();
+
+        int deltaIndex = 1;
+        while ( deltaIndex < deltas.size() ) { 									// for each of the other Deltas
+           Delta nextDelta = deltas.get( deltaIndex );
+           int intermediateStart = curDelta.getOriginal().getPosition() + curDelta.getOriginal().getLines().size();
+           for ( line = intermediateStart; line < nextDelta.getOriginal().getPosition(); line++ ) {
+              buffer.add( " " + origLines.get( line ) );						// output the code between the last Delta and this one
+              origTotal++;
+              revTotal++;
+           }
+           buffer.addAll( getDeltaText( nextDelta ) );							// output the Delta
+           origTotal += nextDelta.getOriginal().getLines().size();
+           revTotal += nextDelta.getRevised().getLines().size();
+           curDelta = nextDelta;
+           deltaIndex++;														// increment the iterator
+        }
+
+        // Now output the post-Delta context code, clamping the end of the file
+        contextStart = curDelta.getOriginal().getPosition() + curDelta.getOriginal().getLines().size();
+        for ( line = contextStart; ( line < (contextStart + contextSize )) && ( line < origLines.size() ); line++ ) {
+          buffer.add( " " + origLines.get( line ) );
+          origTotal++;
+          revTotal++;
+        }
+
+        // Create and insert the block header, conforming to the Unified Diff standard
+        StringBuffer header = new StringBuffer();
+        header.append( "@@ -" );
+        header.append( origStart );
+        header.append( "," );
+        header.append( origTotal );
+        header.append( " +" );
+        header.append( revStart );
+        header.append( "," );
+        header.append( revTotal );
+        header.append( " @@" );
+        buffer.add( 0, header.toString() );
+
+        return buffer;
+      }
+
+      /**
+       * getDeltaText returns the lines to be added to the Unified Diff text from the Delta parameter
+       * @author Bill James (tankerbay@gmail.com)
+       * 
+       * @param delta - the Delta to output
+       * @return list of String lines of code.
+       */
+      private static List<String> getDeltaText( Delta delta ) {
+        List<String> buffer = new ArrayList<String>();
+        for ( Object line: delta.getOriginal().getLines() ) {
+          buffer.add( "-" + line );
+        }
+        for ( Object line: delta.getRevised().getLines() ) {
+          buffer.add( "+" + line );
+        }
+        return buffer;
+      }
+	
+}
