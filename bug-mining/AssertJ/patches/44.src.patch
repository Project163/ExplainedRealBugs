diff --git a/src/main/java/org/assertj/core/api/AbstractDateAssert.java b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
index b7e4da469..096aceaa5 100644
--- a/src/main/java/org/assertj/core/api/AbstractDateAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
@@ -1,7 +1,13 @@
 package org.assertj.core.api;
 
+import static org.assertj.core.util.Dates.newIsoDateFormat;
+import static org.assertj.core.util.Dates.newIsoDateTimeFormat;
+import static org.assertj.core.util.Dates.newIsoDateTimeWithMsFormat;
+import static org.assertj.core.util.ToString.toStringOf;
+
 import java.text.DateFormat;
 import java.text.ParseException;
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
@@ -11,7 +17,6 @@ import java.util.concurrent.TimeUnit;
 
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.Dates;
-import org.assertj.core.internal.Failures;
 import org.assertj.core.util.VisibleForTesting;
 
 /**
@@ -32,12 +37,17 @@ import org.assertj.core.util.VisibleForTesting;
  */
 public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extends AbstractAssert<S, Date> {
 
+  /**
+   * the default DateFormat used to parse any String date representation.
+   */
+  private static final DateFormat[] defaultDateFormats = {newIsoDateTimeWithMsFormat(), newIsoDateTimeFormat(),
+                                                           newIsoDateFormat()};
   /**
    * Used in String based Date assertions - like {@link #isAfter(String)} - to convert input date represented as string
    * to Date.<br> The format used can be overridden by invoking {@link #withDateFormat(DateFormat)}
    */
   @VisibleForTesting
-  static DateFormat dateFormat = org.assertj.core.util.Dates.newIsoDateFormat();
+  static DateFormat customDateFormat = null;
   @VisibleForTesting
   Dates dates = Dates.instance();
 
@@ -1373,7 +1383,7 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
    * assertions in the test suite (i.e. not only the current assertions) since custom DateFormat is stored in a static
    * field.
    * <p/>
-   * To revert to default format simply call {@link #withIsoDateFormat()}.
+   * To revert to default formats simply call {@link #withDefaultDateFormats()}.
    *
    * @param userCustomDateFormat the new Date format used for String based Date assertions.
    * @return this assertion object.
@@ -1384,8 +1394,25 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * For String based Date assertions like {@link #isBefore(String)}, given String is expected to follow the default
-   * Date format, that is ISO 8601 format : "yyyy-MM-dd".
+   * For String based Date assertions like {@link #isBefore(String)}, given String is expected to follow one of the
+   * default Date formats: [yyyy-MM-dd'T'HH:mm:ss.SSS, yyyy-MM-dd'T'HH:mm:ss, yyyy-MM-dd]
+   * <p/>
+   * With this method, user can specify its own date format, replacing the current date format for all future Date
+   * assertions in the test suite (i.e. not only the current assertions) since custom DateFormat is stored in a static
+   * field.
+   * <p/>
+   * To revert to default format simply call {@link #withDefaultDateFormats()}.
+   *
+   * @param userCustomDateFormatPattern the new Date format string pattern used for String based Date assertions.
+   * @return this assertion object.
+   */
+  public S withDateFormat(String userCustomDateFormatPattern) {
+    return withDateFormat(new SimpleDateFormat(userCustomDateFormatPattern));
+  }
+
+  /**
+   * For String based Date assertions like {@link #isBefore(String)}, given String is expected to follow one of the
+   * default Date formats: [yyyy-MM-dd'T'HH:mm:ss.SSS, yyyy-MM-dd'T'HH:mm:ss, yyyy-MM-dd]
    * <p/>
    * With this method, user can specify its own date format, replacing the current date format for all future Date
    * assertions in the test suite (i.e. not only the current assertions) since custom DateFormat is stored in a static
@@ -1399,7 +1426,24 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   public static void useDateFormat(DateFormat userCustomDateFormat) {
     if (userCustomDateFormat == null)
       throw new NullPointerException("The given date format should not be null");
-    dateFormat = userCustomDateFormat;
+    customDateFormat = userCustomDateFormat;
+  }
+
+  /**
+   * For String based Date assertions like {@link #isBefore(String)}, given String is expected to follow one of the
+   * default Date formats: [yyyy-MM-dd'T'HH:mm:ss.SSS, yyyy-MM-dd'T'HH:mm:ss, yyyy-MM-dd]
+   * <p/>
+   * With this method, user can specify its own date format, replacing the current date format for all future Date
+   * assertions in the test suite (i.e. not only the current assertions) since custom DateFormat is stored in a static
+   * field.
+   * <p/>
+   * To revert to default format simply call {@link #useIsoDateFormat()} (static method) or {@link
+   * #withIsoDateFormat()}.
+   *
+   * @param userCustomDateFormatPattern the new Date format pattern used for String based Date assertions.
+   */
+  public static void useDateFormat(String userCustomDateFormatPattern) {
+    useDateFormat(new SimpleDateFormat(userCustomDateFormatPattern));
   }
 
   /**
@@ -1412,30 +1456,94 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
     return myself;
   }
 
+  /**
+   * Use the defaults date formats to parse string as date.
+   * <p/>
+   * Defaults date format are:
+   * <ul>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss</code></li>
+   *   <li><code>yyyy-MM-dd</code></li>
+   * </ul>
+   * <p/>
+   * Example of valid string date representations:
+   * <ul>
+   *   <li><code>2003-04-26T03:01:02.999</code></li>
+   *   <li><code>2003-04-26T13:01:02</code></li>
+   *   <li><code>2003-04-26</code></li>
+   * </ul>
+   *
+   * @return this assertion
+   */
+  public S withDefaultDateFormats() {
+    useDefaultDateFormats();
+    return myself;
+  }
+
   /**
    * Use ISO 8601 date format ("yyyy-MM-dd") for String based Date assertions.
    */
   public static void useIsoDateFormat() {
-    dateFormat = org.assertj.core.util.Dates.newIsoDateFormat();
+    customDateFormat = newIsoDateFormat();
   }
 
   /**
-   * Utility method to parse a Date with {@link #dateFormat}, note that it is thread safe.<br> Returns <code>null</code>
-   * if dateAsString parameter is <code>null</code>.
+   * Use the defaults date formats to parse string as date.
+   * <p/>
+   * Defaults date format are:
+   * <ul>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss</code></li>
+   *   <li><code>yyyy-MM-dd</code></li>
+   * </ul>
+   * <p/>
+   * Example of valid string date representations:
+   * <ul>
+   *   <li><code>2003-04-26T03:01:02.999</code></li>
+   *   <li><code>2003-04-26T13:01:02</code></li>
+   *   <li><code>2003-04-26</code></li>
+   * </ul>
+   */
+  public static void useDefaultDateFormats() {
+    customDateFormat = null;
+  }
+
+  /**
+   * Utility method to parse a Date with either {@link #defaultDateFormats} or {@link #customDateFormat} if the latter
+   * has been set, note that it is thread safe. <p/> Returns <code>null</code> if dateAsString parameter is
+   * <code>null</code>.
    *
-   * @param dateAsString the string to parse as a Date with {@link #dateFormat}
+   * @param dateAsString the string to parse as a Date with {@link #customDateFormat}
    * @return the corresponding Date, null if dateAsString parameter is null.
    * @throws AssertionError if the string can't be parsed as a Date
    */
-  private static Date parse(String dateAsString) {
+  @VisibleForTesting
+  static Date parse(String dateAsString) {
     if (dateAsString == null) return null;
-    try {
-      // synchronized is used because SimpleDateFormat which is not thread safe (sigh).
-      synchronized (dateFormat) {
-        return dateFormat.parse(dateAsString);
+    // use synchronized block because SimpleDateFormat which is not thread safe (sigh).
+    // parse with date format specified by user
+    if (customDateFormat != null) {
+      synchronized (customDateFormat) {
+        try {
+          return customDateFormat.parse(dateAsString);
+        } catch (ParseException e) {
+          throw new AssertionError("Failed to parse " + dateAsString + " with date format: "
+                                     + toStringOf(customDateFormat));
+        }
+      }
+    }
+    // user has not set any specific date format, let's try our defaults ones.
+    synchronized (defaultDateFormats) {
+      for (DateFormat defaultDateFormat : defaultDateFormats) {
+        try {
+          return defaultDateFormat.parse(dateAsString);
+        } catch (ParseException e) {
+          // ignore and try next date format
+        }
       }
-    } catch (ParseException e) {
-      throw Failures.instance().failure("Failed to parse " + dateAsString + " with date format " + dateFormat);
+      // no suitable date format
+      throw new AssertionError("Failed to parse " + dateAsString + " with any of these date formats: "
+                                 + toStringOf(defaultDateFormats));
     }
   }
 
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index bc2b3ac2c..a04a1bc43 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -786,14 +786,18 @@ public class Assertions {
 
   /**
    * For String based Date assertions like {@link AbstractDateAssert#isBefore(String)}, given String is expected to
-   * follow the default Date format, that is ISO 8601 format : "yyyy-MM-dd".
-   * <p/>
+   * follow one of the default Date format:
+   * <ul>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss</code></li>
+   *   <li><code>yyyy-MM-dd</code></li>
+   * </ul>
    * With this method, user can specify its own date format, replacing the current date format for all future Date
    * assertions in the test suite (i.e. not only the current assertions) since custom DateFormat is stored in a static
    * field.
    * <p/>
-   * To revert to default format simply call {@link #useIsoDateFormat()} (static method) or {@link
-   * AbstractDateAssert#withIsoDateFormat()}.
+   * To revert to default format simply call {@link #useDefaultDateFormats()} (static method) or {@link
+   * org.assertj.core.api.AbstractDateAssert#withDefaultDateFormats()}.
    *
    * @param userCustomDateFormat the new Date format used for String based Date assertions.
    */
@@ -801,6 +805,27 @@ public class Assertions {
     AbstractDateAssert.useDateFormat(userCustomDateFormat);
   }
 
+  /**
+   * For String based Date assertions like {@link AbstractDateAssert#isBefore(String)}, given String is expected to
+   * follow one of the default Date format:
+   * <ul>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss</code></li>
+   *   <li><code>yyyy-MM-dd</code></li>
+   * </ul>
+   * With this method, user can specify its own date format, replacing the current date format for all future Date
+   * assertions in the test suite (i.e. not only the current assertions) since custom DateFormat is stored in a static
+   * field.
+   * <p/>
+   * To revert to default format simply call {@link #useDefaultDateFormats()} (static method) or {@link
+   * org.assertj.core.api.AbstractDateAssert#withDefaultDateFormats()}.
+   *
+   * @param userCustomDateFormatPattern the new Date format pattern used for String based Date assertions.
+   */
+  public static void useDateFormat(final String userCustomDateFormatPattern) {
+    AbstractDateAssert.useDateFormat(userCustomDateFormatPattern);
+  }
+
   /**
    * Use ISO 8601 date format ("yyyy-MM-dd") for String based Date assertions.
    */
@@ -816,12 +841,33 @@ public class Assertions {
   }
 
   /**
-   * Use ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code>
+   * Use ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T03:01:02.999</code>
    */
   public static void useIsoDateTimeWithMsFormat() {
     AbstractDateAssert.useDateFormat(Dates.newIsoDateTimeWithMsFormat());
   }
 
+  /**
+   * Use the defaults date formats to parse string as date.
+   * <p/>
+   * Defaults date format are:
+   * <ul>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
+   *   <li><code>yyyy-MM-dd'T'HH:mm:ss</code></li>
+   *   <li><code>yyyy-MM-dd</code></li>
+   * </ul>
+   * <p/>
+   * Example of valid string date representations:
+   * <ul>
+   *   <li><code>2003-04-26T03:01:02.999</code></li>
+   *   <li><code>2003-04-26T13:01:02</code></li>
+   *   <li><code>2003-04-26</code></li>
+   * </ul>
+   */
+  public static void useDefaultDateFormats() {
+    AbstractDateAssert.useDefaultDateFormats();
+  }
+
   /**
    * Creates a new </code>{@link Assertions}</code>.
    */
diff --git a/src/main/java/org/assertj/core/util/Dates.java b/src/main/java/org/assertj/core/util/Dates.java
index 21deb86eb..a662ce035 100644
--- a/src/main/java/org/assertj/core/util/Dates.java
+++ b/src/main/java/org/assertj/core/util/Dates.java
@@ -34,9 +34,13 @@ import java.util.Date;
  */
 public class Dates {
 
-  /** ISO 8601 date format (yyyy-MM-dd), example : <code>2003-04-23</code> */
+  /**
+   * ISO 8601 date format (yyyy-MM-dd), example : <code>2003-04-23</code>
+   */
   private static final DateFormat ISO_DATE_FORMAT = newIsoDateFormat();
-  /** ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code> */
+  /**
+   * ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code>
+   */
   private static final DateFormat ISO_DATE_TIME_FORMAT = newIsoDateTimeFormat();
   /**
    * ISO 8601 date-time format with millisecond (yyyy-MM-dd'T'HH:mm:ss.SSS), example :
@@ -44,12 +48,16 @@ public class Dates {
    */
   private static final DateFormat ISO_DATE_TIME_FORMAT_WITH_MS = newIsoDateTimeWithMsFormat();
 
-  /** ISO 8601 date format (yyyy-MM-dd), example : <code>2003-04-23</code> */
+  /**
+   * ISO 8601 date format (yyyy-MM-dd), example : <code>2003-04-23</code>
+   */
   public static DateFormat newIsoDateFormat() {
     return new SimpleDateFormat("yyyy-MM-dd");
   }
 
-  /** ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code> */
+  /**
+   * ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code>
+   */
   public static DateFormat newIsoDateTimeFormat() {
     return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
   }
diff --git a/src/main/java/org/assertj/core/util/ToString.java b/src/main/java/org/assertj/core/util/ToString.java
index 7009e61cd..62b6380c1 100644
--- a/src/main/java/org/assertj/core/util/ToString.java
+++ b/src/main/java/org/assertj/core/util/ToString.java
@@ -18,6 +18,8 @@ import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.Strings.quote;
 
 import java.io.File;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
 import java.util.*;
 
 /**
@@ -70,6 +72,9 @@ public final class ToString {
     if (o instanceof Comparator) {
       return toStringOf((Comparator<?>) o);
     }
+    if (o instanceof SimpleDateFormat) {
+      return toStringOf((SimpleDateFormat) o);
+    }
     return o == null ? null : o.toString();
   }
 
@@ -110,5 +115,9 @@ public final class ToString {
     return Maps.format(m);
   }
 
+  private static String toStringOf(SimpleDateFormat dateFormat) {
+    return dateFormat.toPattern();
+  }
+
   private ToString() {}
 }
diff --git a/src/test/java/org/assertj/core/api/DateAssertBaseTest.java b/src/test/java/org/assertj/core/api/DateAssertBaseTest.java
index ffb27898b..3fbbec4ac 100644
--- a/src/test/java/org/assertj/core/api/DateAssertBaseTest.java
+++ b/src/test/java/org/assertj/core/api/DateAssertBaseTest.java
@@ -5,7 +5,6 @@ import static org.mockito.Mockito.mock;
 import java.text.DateFormat;
 import java.util.Date;
 
-import org.assertj.core.api.DateAssert;
 import org.assertj.core.internal.Dates;
 import org.assertj.core.internal.Objects;
 import org.junit.Before;
@@ -32,8 +31,8 @@ public abstract class DateAssertBaseTest {
     assertions.objects = objects;
   }
   
-  protected DateFormat dateFormat() {
-    return DateAssert.dateFormat;
+  protected Date parse(String dateAsString) {
+    return DateAssert.parse(dateAsString);
   }
 
   protected AssertionInfo getInfo(DateAssert someAssertions) {
diff --git a/src/test/java/org/assertj/core/api/date/AbstractDateAssertWithDateArg_Test.java b/src/test/java/org/assertj/core/api/date/AbstractDateAssertWithDateArg_Test.java
index c2bda854d..b627374d4 100644
--- a/src/test/java/org/assertj/core/api/date/AbstractDateAssertWithDateArg_Test.java
+++ b/src/test/java/org/assertj/core/api/date/AbstractDateAssertWithDateArg_Test.java
@@ -12,37 +12,33 @@ import org.assertj.core.api.DateAssert;
 import org.assertj.core.api.DateAssertBaseTest;
 import org.assertj.core.internal.Dates;
 import org.assertj.core.test.ExpectedException;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
 /**
- * 
  * Abstract class that factorize DateAssert tests with a date arg (either Date or String based).
- * <p>
- * For the most part, date assertion tests are (whatever the concrete date assertion method invoked is) :
- * <ul>
- * <li>successfull assertion test with a date</li>
- * <li>successfull assertion test with a date as string following default date format</li>
- * <li>successfull assertion test with a date as string following custom date format</li>
- * <li>failed assertion test when date as string does not follow the expected date format</li>
- * <li>checking that DateAssert instance used for assertions is returned to allow fluent assertions chaining</li>
- * </ul>
- * 
+ * <p/>
+ * For the most part, date assertion tests are (whatever the concrete date assertion method invoked is) : <ul>
+ * <li>successfull assertion test with a date</li> <li>successfull assertion test with a date as string following
+ * default date format</li> <li>successfull assertion test with a date as string following custom date format</li>
+ * <li>failed assertion test when date as string does not follow the expected date format</li> <li>checking that
+ * DateAssert instance used for assertions is returned to allow fluent assertions chaining</li> </ul>
+ * <p/>
  * Subclasses are expected to define the invoked assertion method.
- * 
+ *
  * @author Joel Costigliola
- * 
  */
 public abstract class AbstractDateAssertWithDateArg_Test extends DateAssertBaseTest {
 
+  @Rule
+  public ExpectedException thrown = none();
   protected Date otherDate;
   protected String dateAsStringWithDefaultFormat;
   protected String dateAsStringWithCustomFormat;
   protected String dateAsStringWithBadFormat;
   protected SimpleDateFormat customDateFormat;
-  @Rule
-  public ExpectedException thrown = none();
 
   @Override
   @Before
@@ -64,20 +60,21 @@ public abstract class AbstractDateAssertWithDateArg_Test extends DateAssertBaseT
   @Test
   public void should_verify_assertion_with_date_arg_string_with_default_format() throws ParseException {
     assertionInvocationWithStringArg(dateAsStringWithDefaultFormat);
-    verifyAssertionInvocation(dateFormat().parse(dateAsStringWithDefaultFormat));
+    verifyAssertionInvocation(parse(dateAsStringWithDefaultFormat));
   }
 
   @Test
   public void should_verify_assertion_with_date_arg_string_following_custom_format() throws ParseException {
     assertions.withDateFormat(customDateFormat);
     assertionInvocationWithStringArg(dateAsStringWithCustomFormat);
-    verifyAssertionInvocation(dateFormat().parse(dateAsStringWithCustomFormat));
-    assertions.withIsoDateFormat();
+    verifyAssertionInvocation(parse(dateAsStringWithCustomFormat));
+    assertions.withDefaultDateFormats();
   }
 
   @Test
   public void should_fail_because_date_string_representation_does_not_follow_expected_format() {
-    thrown.expectAssertionError("Failed to parse " + dateAsStringWithBadFormat + " with date format " + dateFormat());
+    thrown.expectAssertionError("Failed to parse " + dateAsStringWithBadFormat + " with any of these date formats: " +
+                                  "[yyyy-MM-dd'T'HH:mm:ss.SSS, yyyy-MM-dd'T'HH:mm:ss, yyyy-MM-dd]");
     assertionInvocationWithStringArg(dateAsStringWithBadFormat);
   }
 
@@ -89,20 +86,18 @@ public abstract class AbstractDateAssertWithDateArg_Test extends DateAssertBaseT
 
   /**
    * Overrides to invoke the {@link DateAssert} assertion method under test with the {@link #otherDate} attribute.
-   * <p>
-   * example with <code>isBefore</code> date assertion:<br>
-   * <code>assertions.isBefore(otherDate);</code>
-   * 
+   * <p/>
+   * example with <code>isBefore</code> date assertion:<br> <code>assertions.isBefore(otherDate);</code>
+   *
    * @return the DateAssert instance called
    */
   protected abstract DateAssert assertionInvocationWithDateArg();
 
   /**
    * Overrides to invoke the {@link DateAssert} assertion method under test with the given date as String.
-   * <p>
-   * example with <code>isBefore</code> date assertion:<br>
-   * <code>assertions.isBefore(date);</code>
-   * 
+   * <p/>
+   * example with <code>isBefore</code> date assertion:<br> <code>assertions.isBefore(date);</code>
+   *
    * @param dateAsString a date in String based format
    * @return the DateAssert instance called
    */
@@ -110,10 +105,10 @@ public abstract class AbstractDateAssertWithDateArg_Test extends DateAssertBaseT
 
   /**
    * Overrides to verify that the {@link Dates} assertion method was invoked with the given date.
-   * <p>
-   * example with <code>isBefore</code> date assertion:<br>
-   * <code>verify(dates).assertIsBefore(getInfo(assertions), getActual(assertions), date);</code>
-   * 
+   * <p/>
+   * example with <code>isBefore</code> date assertion:<br> <code>verify(dates).assertIsBefore(getInfo(assertions),
+   * getActual(assertions), date);</code>
+   *
    * @param date the given date (not the actual date !)
    */
   protected abstract void verifyAssertionInvocation(Date date);
diff --git a/src/test/java/org/assertj/core/api/date/DateAssert_with_string_based_date_representation_Test.java b/src/test/java/org/assertj/core/api/date/DateAssert_with_string_based_date_representation_Test.java
new file mode 100644
index 000000000..4e18f4ee3
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/date/DateAssert_with_string_based_date_representation_Test.java
@@ -0,0 +1,121 @@
+/*
+ * Created on Nov 29, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+ * with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
+ * on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
+ * language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.api.date;
+
+import static org.assertj.core.api.Assertions.*;
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Dates.parseDatetime;
+import static org.assertj.core.util.Dates.parseDatetimeWithMs;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+import org.junit.Rule;
+import org.junit.Test;
+
+import org.assertj.core.api.Assertions;
+import org.assertj.core.api.DateAssertBaseTest;
+import org.assertj.core.test.ExpectedException;
+import org.assertj.core.util.Dates;
+
+/**
+ * Tests the default date format used when using date assertions with date represented as string.
+ *
+ * @author Joel Costigliola
+ */
+public class DateAssert_with_string_based_date_representation_Test extends DateAssertBaseTest {
+
+  @Rule
+  public ExpectedException thrown = none();
+
+  @Test
+  public void date_assertion_using_default_date_string_representation() {
+    // datetime with ms is supported
+    final Date date1timeWithMS = parseDatetimeWithMs("2003-04-26T03:01:02.999");
+    assertThat(date1timeWithMS).isEqualTo("2003-04-26T03:01:02.999");
+    // datetime without ms is supported
+    final Date datetime = parseDatetime("2003-04-26T03:01:02");
+    assertThat(datetime).isEqualTo("2003-04-26T03:01:02.000");
+    assertThat(datetime).isEqualTo("2003-04-26T03:01:02");
+    // date is supported
+    final Date date = Dates.parse("2003-04-26");
+    assertThat(date).isEqualTo("2003-04-26");
+    assertThat(date).isEqualTo("2003-04-26T00:00:00");
+    assertThat(date).isEqualTo("2003-04-26T00:00:00.000");
+  }
+
+  @Test
+  public void should_fail_if_given_date_string_representation_cant_be_parsed_with_default_date_formats() {
+    final String dateAsString = "2003/04/26";
+    thrown.expectAssertionError("Failed to parse " + dateAsString + " with any of these date formats: " +
+                                  "[yyyy-MM-dd'T'HH:mm:ss.SSS, yyyy-MM-dd'T'HH:mm:ss, yyyy-MM-dd]");
+    assertThat(new Date()).isEqualTo(dateAsString);
+  }
+
+  @Test
+  public void date_assertion_using_custom_date_string_representation() {
+    final Date date = Dates.parse("2003-04-26");
+    assertThat(date).withDateFormat("yyyy/MM/dd").isEqualTo("2003/04/26");
+  }
+
+  @Test
+  public void should_fail_if_given_date_string_representation_cant_be_parsed_with_custom_date_formats() {
+    thrown.expectAssertionError("Failed to parse 2003-04-26 with date format: yyyy/MM/dd");
+    final Date date = Dates.parse("2003-04-26");
+    assertThat(date).withDateFormat("yyyy/MM/dd").isEqualTo("2003-04-26");
+  }
+
+  @Test
+  public void date_assertion_using_custom_date_string_representation_then_switching_back_to_defaults_date_formats() {
+    final Date date = Dates.parse("2003-04-26");
+    // chained assertions
+    assertThat(date)
+      .withDateFormat("yyyy/MM/dd").isEqualTo("2003/04/26")
+      .withDefaultDateFormats().isEqualTo("2003-04-26");
+    // new assertions
+    assertThat(date).withDateFormat("yyyy/MM/dd").isEqualTo("2003/04/26");
+    assertThat(date).withDefaultDateFormats().isEqualTo("2003-04-26");
+  }
+
+  @Test
+  public void use_different_date_format_fromAssertions_entry_point() {
+    final Date date = Dates.parse("2003-04-26");
+
+    Assertions.useDateFormat("yyyy/MM/dd");
+    assertThat(date).isEqualTo("2003/04/26");
+    Assertions.useDateFormat(new SimpleDateFormat("yyyy/MM/dd"));
+    assertThat(date).isEqualTo("2003/04/26");
+
+    Assertions.useDefaultDateFormats();
+    assertThat(date).isEqualTo("2003-04-26");
+    assertThat(date).isEqualTo("2003-04-26T00:00:00");
+    assertThat(date).isEqualTo("2003-04-26T00:00:00.000");
+
+    Assertions.useIsoDateFormat();
+    assertThat(date).isEqualTo("2003-04-26");
+
+    Assertions.useIsoDateTimeFormat();
+    assertThat(date).isEqualTo("2003-04-26T00:00:00");
+
+    Assertions.useIsoDateTimeWithMsFormat();
+    assertThat(date).isEqualTo("2003-04-26T00:00:00.000");
+    // switch back to defaults to avoid side effects on other tests (I know, they should be independent).
+    Assertions.useDefaultDateFormats();
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/dates/Dates_assertIsBefore_Test.java b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsBefore_Test.java
index 3399e4b4c..5ec264179 100644
--- a/src/test/java/org/assertj/core/internal/dates/Dates_assertIsBefore_Test.java
+++ b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsBefore_Test.java
@@ -19,16 +19,15 @@ import static org.assertj.core.test.ErrorMessages.dateToCompareActualWithIsNull;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
-
 import static org.mockito.Mockito.verify;
 
 import java.util.Date;
 
+import org.junit.Test;
+
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.Dates;
 import org.assertj.core.internal.DatesBaseTest;
-import org.junit.Test;
 
 
 /**
