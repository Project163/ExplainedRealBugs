diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 7771b6e1f..436b47803 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -20,6 +20,7 @@ import java.util.HashSet;
 import java.util.List;
 
 import org.assertj.core.groups.FieldsOrPropertiesExtractor;
+import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.Iterables;
 import org.assertj.core.util.VisibleForTesting;
@@ -44,8 +45,7 @@ import org.assertj.core.util.introspection.IntrospectionError;
  * @author Mikhail Mazursky
  */
 public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S, A, T>, A extends Iterable<T>, T>
-    extends AbstractAssert<S, A>
-    implements ObjectEnumerableAssert<S, T> {
+    extends AbstractAssert<S, A> implements ObjectEnumerableAssert<S, T> {
 
   @VisibleForTesting
   Iterables iterables = Iterables.instance();
@@ -280,14 +280,14 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * Extract the values of given field or property from the Iterable's elements under test into a new Iterable, this new
    * Iterable becoming the Iterable under test.
    * <p>
-   * It allows you to test a field/property of the the Iterable's elements instead of testing the elements themselves,
+   * It allows you to test a property/field of the the Iterable's elements instead of testing the elements themselves,
    * it can be sometimes much less work !
    * <p>
    * Let's take an example to make things clearer :
    * 
    * <pre>
    * // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
-   * // they can be public field or properties, both works when extracting their values.
+   * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
    * 
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
@@ -305,30 +305,95 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
    *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
    *         
-   * // you can extract nested field/property like the name of Race :
+   * // you can extract nested property/field like the name of Race :
    * 
    * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;)
    *           .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
    *           .doesNotContain(&quot;Orc&quot;);
    * </pre>
    * 
-   * A field with the given name is looked for first, if it is not accessible (ie. does not exist or is not public),
-   * then a property with the given name is looked for.
+   * A property with the given name is looked for first, if it does'nt exist then a field with the given name is looked
+   * for, if no field accessible (ie. does not exist or is not public) an IntrospectionError is thrown.
    * <p>
-   * It only works if all objects have the field or all objects have the property with the given name, i.e. it won't
-   * work if half of the objects have the field and the other the property.
+   * It only works if <b>all</b> objects have the field or all objects have the property with the given name, i.e. it
+   * won't work if half of the objects have the field and the other the property.
    * <p>
-   * Note that the order of extracted field/property values is consistent with the iteration order of the Iterable under
+   * Note that the order of extracted property/field values is consistent with the iteration order of the Iterable under
    * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions of the extracted values
    * order.
    * 
-   * @param fieldOrProperty the field/property to extract from the Iterable under test
-   * @return a new assertion object whose object under test is the list of extracted field/property values.
+   * @param propertyOrField the property/field to extract from the Iterable under test
+   * @return a new assertion object whose object under test is the list of extracted property/field values.
    * @throws IntrospectionError if no field or property exists with the given name (or field exists but is not public)
+   *           in one of the initial Iterable's element.
    */
-  public ListAssert<Object> extracting(String fieldOrProperty) {
-    List<Object> values = FieldsOrPropertiesExtractor.extract(fieldOrProperty, actual);
+  public ListAssert<Object> extracting(String propertyOrField) {
+    List<Object> values = FieldsOrPropertiesExtractor.extract(propertyOrField, actual);
     return new ListAssert<Object>(values);
   }
 
+  /**
+   * Extract the values of given fields/properties from the Iterable's elements under test into a new Iterable composed
+   * of Tuple (a simple data structure), this new Iterable becoming the Iterable under test.
+   * <p>
+   * It allows you to test fields/properties of the the Iterable's elements instead of testing the elements themselves,
+   * it can be sometimes much less work !
+   * <p>
+   * The Tuple data corresponds to the extracted values of the given fields/properties, for instance if you ask to
+   * extract "id", "name" and "email" then each Tuple data will be composed of id, name and email extracted from the
+   * element of the initial Iterable (the Tuple's data order is the same as the given fields/properties order).
+   * <p>
+   * Let's take an example to make things clearer :
+   * 
+   * <pre>
+   * // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
+   * // they can be public field or properties, both can be extracted.
+   * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
+   * 
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Legolas&quot;, 1000, ELF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Pippin&quot;, 28, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
+   * 
+   * // let's verify 'name' and 'age' of some TolkienCharacter in fellowshipOfTheRing :
+   * 
+   * assertThat(fellowshipOfTheRing).extracting("name", "age")
+   *                                .contains(tuple("Boromir", 37),
+   *                                          tuple("Sam", 38),
+   *                                          tuple("Legolas", 1000));
+   * 
+   * 
+   * // extract 'name', 'age' and Race name values.
+   * 
+   * assertThat(fellowshipOfTheRing).extracting("name", "age", "race.name")
+   *                                .contains(tuple("Boromir", 37, "Man"),
+   *                                          tuple("Sam", 38, "Hobbit"),
+   *                                          tuple("Legolas", 1000, "Elf"));
+   * </pre>
+   * 
+   * A property with the given name is looked for first, if it does'nt exist then a field with the given name is looked
+   * for, if no field accessible (ie. does not exist or is not public) an IntrospectionError is thrown.
+   * <p>
+   * It only works if <b>all</b> objects have the field or all objects have the property with the given name, i.e. it
+   * won't work if half of the objects have the field and the other the property.
+   * <p>
+   * Note that the order of extracted property/field values is consistent with the iteration order of the Iterable under
+   * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions of the extracted values
+   * order.
+   * 
+   * @param propertiesOrFields the properties/fields to extract from the initial Iterable under test
+   * @return a new assertion object whose object under test is the list of Tuple with extracted properties/fields values
+   *         as data.
+   * @throws IntrospectionError if one of the given name does not match a field or property (or field exists but is not
+   *           public) in one of the initial Iterable's element.
+   */
+  public ListAssert<Tuple> extracting(String... propertiesOrFields) {
+    List<Tuple> values = FieldsOrPropertiesExtractor.extract(actual, propertiesOrFields);
+    return new ListAssert<Tuple>(values);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 48155f764..6fc3923d1 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -1,14 +1,14 @@
 /*
  * Created on Sep 30, 2010
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2010-2011 the original author or authors.
  */
@@ -32,23 +32,24 @@ import org.assertj.core.data.Index;
 import org.assertj.core.data.MapEntry;
 import org.assertj.core.data.Offset;
 import org.assertj.core.groups.Properties;
+import org.assertj.core.groups.Tuple;
 import org.assertj.core.util.Files;
 import org.assertj.core.util.FilesException;
 
-
 /**
- * Entry point for assertion methods for different data types. Each method in this class is a static factory for the type-specific
- * assertion objects. The purpose of this class is to make test code more readable.
+ * Entry point for assertion methods for different data types. Each method in this class is a static factory for the
+ * type-specific assertion objects. The purpose of this class is to make test code more readable.
  * <p>
  * For example:
  * 
  * <pre>
  * int removed = employees.removeFired();
  * {@link Assertions#assertThat(int) assertThat}(removed).{@link IntegerAssert#isZero isZero}();
- *
+ * 
  * List&lt;Employee&gt; newEmployees = employees.hired(TODAY);
  * {@link Assertions#assertThat(Iterable) assertThat}(newEmployees).{@link IterableAssert#hasSize(int) hasSize}(6);
  * </pre>
+ * 
  * </p>
  * 
  * @author Alex Ruiz
@@ -59,12 +60,13 @@ import org.assertj.core.util.FilesException;
  * @author Matthieu Baechler
  * @author Mikhail Mazursky
  * @author Nicolas Fran√ßois
- * @author Julien Meddah 
+ * @author Julien Meddah
  */
 public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link BigDecimalAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -74,6 +76,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link BooleanAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -83,6 +86,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link BooleanAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -92,6 +96,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link BooleanArrayAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -101,6 +106,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ByteAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -110,6 +116,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ByteAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -119,6 +126,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ByteArrayAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -128,6 +136,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link CharacterAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -137,6 +146,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link CharArrayAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -146,6 +156,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link CharacterAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -155,6 +166,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link IterableAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -175,6 +187,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link DoubleAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -184,6 +197,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link DoubleAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -193,6 +207,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link DoubleArrayAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -202,6 +217,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link FileAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -211,6 +227,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link InputStreamAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -220,6 +237,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link FloatAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -229,6 +247,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link FloatAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -238,6 +257,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link FloatArrayAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -247,6 +267,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link IntegerAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -256,6 +277,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link IntArrayAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -265,6 +287,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link IntegerAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -274,6 +297,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ListAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -283,6 +307,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link LongAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -292,6 +317,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link LongAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -301,6 +327,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link LongArrayAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -310,6 +337,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ObjectAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -319,6 +347,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ObjectArrayAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -328,6 +357,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link MapAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -337,6 +367,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ShortAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -346,6 +377,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ShortAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -355,6 +387,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ShortArrayAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -364,6 +397,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link StringAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -373,6 +407,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link DateAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -382,6 +417,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ThrowableAssert}</code>.
+   * 
    * @param actual the actual value.
    * @return the created assertion Throwable.
    */
@@ -394,32 +430,32 @@ public class Assertions {
   // -------------------------------------------------------------------------------------------------
 
   /**
-   * Only delegate to {@link Fail#setRemoveFestRelatedElementsFromStackTrace(boolean)} so that Assertions offers a full feature
-   * entry point to all Fest Assert features (but you can use {@link Fail} if you prefer).
+   * Only delegate to {@link Fail#setRemoveFestRelatedElementsFromStackTrace(boolean)} so that Assertions offers a full
+   * feature entry point to all Fest Assert features (but you can use {@link Fail} if you prefer).
    */
   public static void setRemoveFestRelatedElementsFromStackTrace(boolean removeFestRelatedElementsFromStackTrace) {
     Fail.setRemoveFestRelatedElementsFromStackTrace(removeFestRelatedElementsFromStackTrace);
   }
 
   /**
-   * Only delegate to {@link Fail#fail(String)} so that Assertions offers a full feature entry point to all Fest Assert features
-   * (but you can use Fail if you prefer).
+   * Only delegate to {@link Fail#fail(String)} so that Assertions offers a full feature entry point to all Fest Assert
+   * features (but you can use Fail if you prefer).
    */
   public static void fail(String failureMessage) {
     Fail.fail(failureMessage);
   }
 
   /**
-   * Only delegate to {@link Fail#fail(String, Throwable)} so that Assertions offers a full feature entry point to all Fest Assert
-   * features (but you can use Fail if you prefer).
+   * Only delegate to {@link Fail#fail(String, Throwable)} so that Assertions offers a full feature entry point to all
+   * Fest Assert features (but you can use Fail if you prefer).
    */
   public static void fail(String failureMessage, Throwable realCause) {
     Fail.fail(failureMessage, realCause);
   }
 
   /**
-   * Only delegate to {@link Fail#failBecauseExceptionWasNotThrown(Class)} so that Assertions offers a full feature entry point to
-   * all Fest Assert features (but you can use Fail if you prefer).
+   * Only delegate to {@link Fail#failBecauseExceptionWasNotThrown(Class)} so that Assertions offers a full feature
+   * entry point to all Fest Assert features (but you can use Fail if you prefer).
    */
   public static void failBecauseExceptionWasNotThrown(Class<? extends Exception> exceptionClass) {
     Fail.failBecauseExceptionWasNotThrown(exceptionClass);
@@ -430,26 +466,27 @@ public class Assertions {
   // ------------------------------------------------------------------------------------------------------
 
   /**
-   * Only delegate to {@link Properties#extractProperty(String)} so that Assertions offers a full feature entry point to all Fest
-   * Assert features (but you can use {@link Properties} if you prefer).
+   * Only delegate to {@link Properties#extractProperty(String)} so that Assertions offers a full feature entry point to
+   * all Fest Assert features (but you can use {@link Properties} if you prefer).
    * <p>
    * Typical usage is to chain <code>extractProperty</code> with <code>from</code> method, see examples below :
    * 
    * <pre>
    * // extract simple property values having a java standard type (here String)
-   * assertThat(extractProperty("name", String.class).from(fellowshipOfTheRing))
-   *           .contains("Boromir", "Gandalf", "Frodo", "Legolas")
-   *           .doesNotContain("Sauron", "Elrond");
-   *                                                              
+   * assertThat(extractProperty(&quot;name&quot;, String.class).from(fellowshipOfTheRing))
+   *                                                                            .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;,
+   *                                                                                      &quot;Legolas&quot;)
+   *                                                                            .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
+   * 
    * // extracting property works also with user's types (here Race)
-   * assertThat(extractProperty("race", String.class).from(fellowshipOfTheRing))
-   *           .contains(HOBBIT, ELF)
-   *           .doesNotContain(ORC);
+   * assertThat(extractProperty(&quot;race&quot;, String.class).from(fellowshipOfTheRing))
+   *                                                                            .contains(HOBBIT, ELF)
+   *                                                                            .doesNotContain(ORC);
    * 
    * // extract nested property on Race
-   * assertThat(extractProperty("race.name", String.class).from(fellowshipOfTheRing))
-   *           .contains("Hobbit", "Elf")
-   *           .doesNotContain("Orc");
+   * assertThat(extractProperty(&quot;race.name&quot;, String.class).from(fellowshipOfTheRing))
+   *                                                                                 .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
+   *                                                                                 .doesNotContain(&quot;Orc&quot;);
    * </pre>
    */
   public static <T> Properties<T> extractProperty(String propertyName, Class<T> propertyType) {
@@ -457,37 +494,48 @@ public class Assertions {
   }
 
   /**
-   * Only delegate to {@link Properties#extractProperty(String)} so that Assertions offers a full feature entry point to all Fest
-   * Assert features (but you can use {@link Properties} if you prefer).
+   * Only delegate to {@link Properties#extractProperty(String)} so that Assertions offers a full feature entry point to
+   * all Fest Assert features (but you can use {@link Properties} if you prefer).
    * <p>
    * Typical usage is to chain <code>extractProperty</code> with <code>from</code> method, see examples below :
    * 
    * <pre>
-   * // extract simple property values, as no type has been defined the extracted property will be considered as Object 
-   * // to define the real property type (here String) use extractProperty("name", String.class) instead. 
-   * assertThat(extractProperty("name").from(fellowshipOfTheRing))
-   *           .contains("Boromir", "Gandalf", "Frodo", "Legolas")
-   *           .doesNotContain("Sauron", "Elrond");
-   *                                                              
+   * // extract simple property values, as no type has been defined the extracted property will be considered as Object
+   * // to define the real property type (here String) use extractProperty(&quot;name&quot;, String.class) instead.
+   * assertThat(extractProperty(&quot;name&quot;).from(fellowshipOfTheRing))
+   *                                                              .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;, &quot;Legolas&quot;)
+   *                                                              .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
+   * 
    * // extracting property works also with user's types (here Race), even though it will be considered as Object
-   * // to define the real property type (here String) use extractProperty("name", Race.class) instead. 
-   * assertThat(extractProperty("race").from(fellowshipOfTheRing)).contains(HOBBIT, ELF).doesNotContain(ORC);
+   * // to define the real property type (here String) use extractProperty(&quot;name&quot;, Race.class) instead.
+   * assertThat(extractProperty(&quot;race&quot;).from(fellowshipOfTheRing)).contains(HOBBIT, ELF).doesNotContain(ORC);
    * 
    * // extract nested property on Race
-   * assertThat(extractProperty("race.name").from(fellowshipOfTheRing)).contains("Hobbit", "Elf").doesNotContain("Orc");
+   * assertThat(extractProperty(&quot;race.name&quot;).from(fellowshipOfTheRing)).contains(&quot;Hobbit&quot;, &quot;Elf&quot;).doesNotContain(&quot;Orc&quot;);
    * </pre>
    */
   public static Properties<Object> extractProperty(String propertyName) {
     return Properties.extractProperty(propertyName);
   }
 
+  /**
+   * Utility method to build nicely a {@link Tuple} when working with {@link IterableAssert#extracting(String...)} or
+   * {@link ObjectArrayAssert#extracting(String...)}
+   * 
+   * @param values the values stored in the {@link Tuple}
+   * @return the built {@link Tuple}
+   */
+  public static Tuple tuple(Object... values) {
+    return Tuple.tuple(values);
+  }
+
   // ------------------------------------------------------------------------------------------------------
   // Data utility methods : not assertions but here to have a single entry point to all Fest Assert features.
   // ------------------------------------------------------------------------------------------------------
 
   /**
-   * Only delegate to {@link MapEntry#entry(Object, Object)} so that Assertions offers a full feature entry point to all Fest
-   * Assert features (but you can use {@link MapEntry} if you prefer).
+   * Only delegate to {@link MapEntry#entry(Object, Object)} so that Assertions offers a full feature entry point to all
+   * Fest Assert features (but you can use {@link MapEntry} if you prefer).
    * <p>
    * Typical usage is to call <code>entry</code> in MapAssert <code>contains</code> assertion, see examples below :
    * 
@@ -500,13 +548,13 @@ public class Assertions {
   }
 
   /**
-   * Only delegate to {@link Index#atIndex(int)} so that Assertions offers a full feature entry point to all Fest Assert features
-   * (but you can use {@link Index} if you prefer).
+   * Only delegate to {@link Index#atIndex(int)} so that Assertions offers a full feature entry point to all Fest Assert
+   * features (but you can use {@link Index} if you prefer).
    * <p>
    * Typical usage :
    * 
    * <pre>
-   * List<Ring> elvesRings = newArrayList(vilya, nenya, narya);
+   * List&lt;Ring&gt; elvesRings = newArrayList(vilya, nenya, narya);
    * assertThat(elvesRings).contains(vilya, atIndex(0)).contains(nenya, atIndex(1)).contains(narya, atIndex(2));
    * </pre>
    */
@@ -515,8 +563,8 @@ public class Assertions {
   }
 
   /**
-   * Only delegate to {@link Offset#offset(Double)} so that Assertions offers a full feature entry point to all Fest Assert
-   * features (but you can use {@link Offset} if you prefer).
+   * Only delegate to {@link Offset#offset(Double)} so that Assertions offers a full feature entry point to all Fest
+   * Assert features (but you can use {@link Offset} if you prefer).
    * <p>
    * Typical usage :
    * 
@@ -529,8 +577,8 @@ public class Assertions {
   }
 
   /**
-   * Only delegate to {@link Offset#offset(Float)} so that Assertions offers a full feature entry point to all Fest Assert
-   * features (but you can use {@link Offset} if you prefer).
+   * Only delegate to {@link Offset#offset(Float)} so that Assertions offers a full feature entry point to all Fest
+   * Assert features (but you can use {@link Offset} if you prefer).
    * <p>
    * Typical usage :
    * 
@@ -548,6 +596,7 @@ public class Assertions {
 
   /**
    * Creates a new <code>{@link AllOf}</code>
+   * 
    * @param <T> the type of object the given condition accept.
    * @param conditions the conditions to evaluate.
    * @return the created {@code AnyOf}.
@@ -560,6 +609,7 @@ public class Assertions {
 
   /**
    * Creates a new <code>{@link AllOf}</code>
+   * 
    * @param <T> the type of object the given condition accept.
    * @param conditions the conditions to evaluate.
    * @return the created {@code AnyOf}.
@@ -571,13 +621,13 @@ public class Assertions {
   }
 
   /**
-   * Only delegate to {@link AnyOf#anyOf(Condition...)} so that Assertions offers a full feature entry point to all Fest Assert
-   * features (but you can use {@link AnyOf} if you prefer).
+   * Only delegate to {@link AnyOf#anyOf(Condition...)} so that Assertions offers a full feature entry point to all Fest
+   * Assert features (but you can use {@link AnyOf} if you prefer).
    * <p>
    * Typical usage (<code>jedi</code> and <code>sith</code> are {@link Condition}) :
    * 
    * <pre>
-   * assertThat("Vader").is(anyOf(jedi, sith));
+   * assertThat(&quot;Vader&quot;).is(anyOf(jedi, sith));
    * </pre>
    */
   public static <T> Condition<T> anyOf(Condition<? super T>... conditions) {
@@ -586,6 +636,7 @@ public class Assertions {
 
   /**
    * Creates a new <code>{@link AnyOf}</code>
+   * 
    * @param <T> the type of object the given condition accept.
    * @param conditions the conditions to evaluate.
    * @return the created {@code AnyOf}.
@@ -621,42 +672,48 @@ public class Assertions {
   // --------------------------------------------------------------------------------------------------
 
   /**
-   * Only delegate to {@link Filters#filter(Object[])} so that Assertions offers a full feature entry point to all Fest Assert
-   * features (but you can use {@link Filters} if you prefer).
+   * Only delegate to {@link Filters#filter(Object[])} so that Assertions offers a full feature entry point to all Fest
+   * Assert features (but you can use {@link Filters} if you prefer).
    * <p>
    * Note that the given array is not modified, the filters are performed on an {@link Iterable} copy of the array.
    * <p>
    * Typical usage with {@link Condition} :
    * 
    * <pre>
-   * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose);</pre>
+   * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose);
+   * </pre>
+   * 
    * and with filter language based on java bean property :
    * 
    * <pre>
-   * assertThat(filter(players).with("pointsPerGame").greaterThan(20)
-   *                           .and("assistsPerGame").greaterThan(7)
-   *                           .get()).containsOnly(james, rose);</pre>
+   * assertThat(filter(players).with(&quot;pointsPerGame&quot;).greaterThan(20)
+   *                           .and(&quot;assistsPerGame&quot;).greaterThan(7)
+   *                           .get()).containsOnly(james, rose);
+   * </pre>
    */
   public static <E> Filters<E> filter(E[] array) {
     return Filters.filter(array);
   }
 
   /**
-   * Only delegate to {@link Filters#filter(Object[])} so that Assertions offers a full feature entry point to all Fest Assert
-   * features (but you can use {@link Filters} if you prefer).
+   * Only delegate to {@link Filters#filter(Object[])} so that Assertions offers a full feature entry point to all Fest
+   * Assert features (but you can use {@link Filters} if you prefer).
    * <p>
    * Note that the given {@link Iterable} is not modified, the filters are performed on a copy.
    * <p>
    * Typical usage with {@link Condition} :
    * 
    * <pre>
-   * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose);</pre>
+   * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose);
+   * </pre>
+   * 
    * and with filter language based on java bean property :
    * 
    * <pre>
-   * assertThat(filter(players).with("pointsPerGame").greaterThan(20)
-   *                           .and("assistsPerGame").greaterThan(7)
-   *                           .get()).containsOnly(james, rose);</pre>
+   * assertThat(filter(players).with(&quot;pointsPerGame&quot;).greaterThan(20)
+   *                           .and(&quot;assistsPerGame&quot;).greaterThan(7)
+   *                           .get()).containsOnly(james, rose);
+   * </pre>
    */
   public static <E> Filters<E> filter(Iterable<E> iterableToFilter) {
     return Filters.filter(iterableToFilter);
@@ -669,9 +726,10 @@ public class Assertions {
   /**
    * Loads the text content of a file, so that it can be passed to {@link #assertThat(String)}.
    * <p>
-   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative with
-   * {@link #assertThat(File)}.
+   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative
+   * with {@link #assertThat(File)}.
    * </p>
+   * 
    * @param file the file.
    * @param charset the character set to use.
    * @return the content of the file.
@@ -685,9 +743,10 @@ public class Assertions {
   /**
    * Loads the text content of a file, so that it can be passed to {@link #assertThat(String)}.
    * <p>
-   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative with
-   * {@link #assertThat(File)}.
+   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative
+   * with {@link #assertThat(File)}.
    * </p>
+   * 
    * @param file the file.
    * @param charsetName the name of the character set to use.
    * @return the content of the file.
@@ -699,11 +758,13 @@ public class Assertions {
   }
 
   /**
-   * Loads the text content of a file with the default character set, so that it can be passed to {@link #assertThat(String)}.
+   * Loads the text content of a file with the default character set, so that it can be passed to
+   * {@link #assertThat(String)}.
    * <p>
-   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative with
-   * {@link #assertThat(File)}.
+   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative
+   * with {@link #assertThat(File)}.
    * </p>
+   * 
    * @param file the file.
    * @return the content of the file.
    * @throws FilesException if an I/O exception occurs.
@@ -713,5 +774,6 @@ public class Assertions {
   }
 
   /** Creates a new </code>{@link Assertions}</code>. */
-  protected Assertions() {}
+  protected Assertions() {
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/ObjectArrayAssert.java b/src/main/java/org/assertj/core/api/ObjectArrayAssert.java
index 624b5e1d6..5f5bfc7fc 100644
--- a/src/main/java/org/assertj/core/api/ObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/ObjectArrayAssert.java
@@ -18,6 +18,7 @@ import java.util.Comparator;
 
 import org.assertj.core.data.Index;
 import org.assertj.core.groups.FieldsOrPropertiesExtractor;
+import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.ObjectArrays;
 import org.assertj.core.util.VisibleForTesting;
@@ -329,4 +330,11 @@ public class ObjectArrayAssert<T> extends AbstractAssert<ObjectArrayAssert<T>, T
     Object[] values = FieldsOrPropertiesExtractor.extract(fieldOrProperty, actual);
     return new ObjectArrayAssert<Object>(values);
   }
+  
+  // TODO : write javadoc !
+  public ObjectArrayAssert<Tuple> extracting(String... fieldsOrProperties) {
+    Tuple[] values = FieldsOrPropertiesExtractor.extract(actual, fieldsOrProperties);
+    return new ObjectArrayAssert<Tuple>(values);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/groups/FieldsOrPropertiesExtractor.java b/src/main/java/org/assertj/core/groups/FieldsOrPropertiesExtractor.java
index b4498669f..f4fb6654b 100644
--- a/src/main/java/org/assertj/core/groups/FieldsOrPropertiesExtractor.java
+++ b/src/main/java/org/assertj/core/groups/FieldsOrPropertiesExtractor.java
@@ -1,6 +1,8 @@
 package org.assertj.core.groups;
 
 import static java.lang.String.format;
+import static org.assertj.core.groups.Tuple.buildTuples;
+import static org.assertj.core.util.Lists.newArrayList;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -33,33 +35,65 @@ public class FieldsOrPropertiesExtractor {
     List<Object> extractedValues = extract(fieldOrPropertyName, newArrayList);
     return extractedValues.toArray();
   }
-  
+
+  /**
+   * Call {@link #extract(Iterable, String)} after converting objects to an iterable.
+   * <p>
+   * Behavior is described in javadoc {@link AbstractIterableAssert#extracting(String...)}
+   */
+  public static Tuple[] extract(Object[] objects, String... fieldsOrPropertiesNames) {
+    ArrayList<Object> newArrayList = Lists.newArrayList(objects);
+    List<Tuple> extractedValues = extract(newArrayList, fieldsOrPropertiesNames);
+    return extractedValues.toArray(new Tuple[0]);
+  }
+
   /**
    * Behavior is described in {@link AbstractIterableAssert#extracting(String)}
    */
-  public static List<Object> extract(String fieldOrPropertyName, Iterable<?> objects) {
-    if (fieldOrPropertyName == null)
+  public static List<Object> extract(String propertyOrFieldName, Iterable<?> objects) {
+    if (propertyOrFieldName == null)
       throw new IllegalArgumentException("The name of the field/property to read should not be null");
-    if (fieldOrPropertyName.length() == 0)
+    if (propertyOrFieldName.length() == 0)
       throw new IllegalArgumentException("The name of the field/property to read should not be empty");
     if (objects == null)
       throw new IllegalArgumentException("The objects to extract field/property from should not be null");
 
-    // first try to get given field values from objects, then try properties
+    // first try to get given property values from objects, then try properties
     try {
-      return FieldSupport.instance().fieldValues(fieldOrPropertyName, objects);
+      return PropertySupport.instance().propertyValues(propertyOrFieldName, objects);
     } catch (IntrospectionError fieldIntrospectionError) {
-      // no luck with fields, let's try properties
+      // no luck with properties, let's try fields
       try {
-        return PropertySupport.instance().propertyValues(fieldOrPropertyName, objects);
+        return FieldSupport.instance().fieldValues(propertyOrFieldName, objects);
       } catch (IntrospectionError propertyIntrospectionError) {
         // no field nor property found with given name, it is considered as an error
-        String message = format("\nCan't find any field or property with name '%s'.\nError when introspecting fields was :\n- %s \nError when introspecting properties was :\n- %s",
-                                fieldOrPropertyName, fieldIntrospectionError.getMessage(),
-                                propertyIntrospectionError.getMessage());
+        String message = format(
+            "\nCan't find any field or property with name '%s'.\nError when introspecting fields was :\n- %s \nError when introspecting properties was :\n- %s",
+            propertyOrFieldName, fieldIntrospectionError.getMessage(), propertyIntrospectionError.getMessage());
         throw new IntrospectionError(message);
       }
     }
   }
 
+  /**
+   * Behavior is described in {@link AbstractIterableAssert#extracting(String...)}
+   */
+  public static List<Tuple> extract(Iterable<?> objects, String... fieldsOrPropertiesNames) {
+    if (fieldsOrPropertiesNames == null)
+      throw new IllegalArgumentException("The names of the fields/properties to read should not be null");
+    if (fieldsOrPropertiesNames.length == 0)
+      throw new IllegalArgumentException("The names of the fields/properties to read should not be empty");
+    if (objects == null)
+      throw new IllegalArgumentException("The objects to extract fields/properties from should not be null");
+    // convert objects to a list to ensure consistent iteration order in extracteds fields/properties
+    List<Object> objectsAsList = newArrayList(objects);
+    List<Tuple> extractedTuples = buildTuples(objectsAsList.size());
+    for (String fieldOrPropertyName : fieldsOrPropertiesNames) {
+      List<Object> extractValues = extract(fieldOrPropertyName, objectsAsList);
+      for (int i = 0; i < objectsAsList.size(); i++) {
+        extractedTuples.get(i).addData(extractValues.get(i));
+      }
+    }
+    return extractedTuples;
+  }
 }
diff --git a/src/main/java/org/assertj/core/groups/Tuple.java b/src/main/java/org/assertj/core/groups/Tuple.java
new file mode 100644
index 000000000..3e610a81c
--- /dev/null
+++ b/src/main/java/org/assertj/core/groups/Tuple.java
@@ -0,0 +1,63 @@
+package org.assertj.core.groups;
+
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.util.Collections;
+
+public class Tuple {
+
+  private static final String END = ")";
+  private static final String START = "(";
+  private List<Object> datas = newArrayList();
+
+  public Tuple(Object... values) {
+    for (Object value : values) {
+      datas.add(value);
+    }
+  }
+
+  public void addData(Object data) {
+    datas.add(data);
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + ((datas == null) ? 0 : datas.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (obj == null) return false;
+    if (getClass() != obj.getClass()) return false;
+    Tuple other = (Tuple) obj;
+    if (datas == null) {
+      if (other.datas != null) return false;
+    } else if (!datas.equals(other.datas)) return false;
+    return true;
+  }
+
+  @Override
+  public String toString() {
+    return Collections.format(datas, START, END);
+  }
+
+  public static List<Tuple> buildTuples(int n) {
+    List<Tuple> tuples = new ArrayList<Tuple>(n);
+    for (int i = 0; i < n; i++) {
+      tuples.add(new Tuple());
+    }
+    return tuples;
+  }
+
+  public static Tuple tuple(Object... values) {
+    return new Tuple(values);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/util/Collections.java b/src/main/java/org/assertj/core/util/Collections.java
index cdc07d5b6..1a8055c71 100644
--- a/src/main/java/org/assertj/core/util/Collections.java
+++ b/src/main/java/org/assertj/core/util/Collections.java
@@ -33,6 +33,9 @@ import java.util.Set;
  * @author Joel Costigliola
  */
 public final class Collections {
+  private static final String DEFAULT_END = "]";
+  private static final String DEFAULT_START = "[";
+
   /**
    * Returns any duplicate elements from the given {@code Collection}.
    * 
@@ -75,25 +78,36 @@ public final class Collections {
    * @return the {@code String} representation of the given {@code Collection}.
    */
   public static String format(Collection<?> c) {
+    return format(c, DEFAULT_START, DEFAULT_END);
+  }
+
+  /**
+   * Returns the {@code String} representation of the given {@code Collection}, or {@code null} if the given
+   * {@code Collection} is {@code null}.
+   * 
+   * @param c the {@code Collection} to format.
+   * @return the {@code String} representation of the given {@code Collection}.
+   */
+  public static String format(Collection<?> c, String start, String end) {
     if (c == null) {
       return null;
     }
     Iterator<?> i = c.iterator();
     if (!i.hasNext()) {
-      return "[]";
+      return start + end;
     }
     StringBuilder b = new StringBuilder();
-    b.append('[');
+    b.append(start);
     for (;;) {
       Object e = i.next();
       b.append(e == c ? "(this Collection)" : toStringOf(e));
       if (!i.hasNext()) {
-        return b.append(']').toString();
+        return b.append(end).toString();
       }
       b.append(", ");
     }
   }
-
+  
   /**
    * Returns all the non-{@code null} elements in the given {@link Collection}.
    * 
diff --git a/src/test/java/org/assertj/core/api/Assertions_tuple_Test.java b/src/test/java/org/assertj/core/api/Assertions_tuple_Test.java
new file mode 100644
index 000000000..aa4ab4e29
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/Assertions_tuple_Test.java
@@ -0,0 +1,17 @@
+package org.assertj.core.api;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.junit.Test;
+
+import org.assertj.core.groups.Tuple;
+
+public class Assertions_tuple_Test {
+
+  @Test
+  public void should_create_tuple() {
+    Tuple tuple = Assertions.tuple("Yoda", 800, "Jedi");
+    assertThat(tuple).isEqualTo(new Tuple("Yoda", 800, "Jedi"));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
index e0fa80541..8b8743a50 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
@@ -1,20 +1,21 @@
 /*
  * Created on Sep 30, 2010
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2010-2011 the original author or authors.
  */
 package org.assertj.core.api.iterable;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.tuple;
 import static org.assertj.core.test.ExpectedException.none;
 import static org.assertj.core.util.Lists.newArrayList;
 
@@ -28,9 +29,9 @@ import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
 import org.assertj.core.util.introspection.IntrospectionError;
 
-
 /**
- * Tests for <code>{@link AbstractIterableAssert#extracting(String)}</code>.
+ * Tests for <code>{@link AbstractIterableAssert#extracting(String)}</code> and
+ * <code>{@link AbstractIterableAssert#extracting(String...)}</code>.
  * 
  * @author Joel Costigliola
  */
@@ -50,26 +51,38 @@ public class IterableAssert_extracting_Test {
   @Rule
   public ExpectedException thrown = none();
 
-
   @Test
   public void should_allow_assertions_on_property_values_extracted_from_given_iterable() throws Exception {
     assertThat(employees).extracting("age").containsOnly(800, 26);
   }
-  
+
   @Test
   public void should_allow_assertions_on_field_values_extracted_from_given_iterable() throws Exception {
-    // basic types
+    // extract field
     assertThat(employees).extracting("id").containsOnly(1L, 2L);
-    // object
+    // extract pure property
+    assertThat(employees).extracting("adult").containsOnly(true, true);
+    // extract field that is also a property
     assertThat(employees).extracting("name").containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
     // nested property
     assertThat(employees).extracting("name.first").containsOnly("Yoda", "Luke");
   }
-  
+
   @Test
   public void should_throw_error_if_no_property_nor_field_with_given_name_can_be_extracted() throws Exception {
     thrown.expect(IntrospectionError.class);
     assertThat(employees).extracting("unknown");
   }
 
+  @Test
+  public void should_allow_assertions_on_multiple_extracted_values_from_given_iterable() throws Exception {
+    assertThat(employees).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+  }
+  
+  @Test
+  public void should_throw_error_if_one_property_or_field_can_not_be_extracted() throws Exception {
+    thrown.expect(IntrospectionError.class);
+    assertThat(employees).extracting("unknown", "age", "id").containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+  }
+  
 }
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java
index 686ddfbdb..396e4ea33 100644
--- a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java
@@ -15,6 +15,7 @@
 package org.assertj.core.api.objectarray;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.tuple;
 import static org.assertj.core.test.ExpectedException.none;
 import static org.assertj.core.util.Arrays.array;
 
@@ -71,4 +72,16 @@ public class ObjectArrayAssert_extracting_Test {
     assertThat(employees).extracting("unknown");
   }
 
+  @Test
+  public void should_allow_assertions_on_multiple_extracted_values_from_given_iterable() throws Exception {
+    assertThat(employees).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+  }
+  
+  @Test
+  public void should_throw_error_if_one_property_or_field_can_not_be_extracted() throws Exception {
+    thrown.expect(IntrospectionError.class);
+    assertThat(employees).extracting("unknown", "age", "id").containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+  }
+  
+  
 }
diff --git a/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java
index 4bdd6c1af..47af704a4 100644
--- a/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java
+++ b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java
@@ -59,6 +59,12 @@ public class FieldsOrPropertiesExtractor_extract_test {
     assertThat(extractedValues).containsOnly(800, 26);
   }
   
+  @Test
+  public void should_extract_pure_property_values() {
+    List<Object> extractedValues = extract("adult", employees);
+    assertThat(extractedValues).containsOnly(true);
+  }
+  
   @Test
   public void should_throw_error_when_no_property_nor_public_field_match_given_name() {
     thrown.expect(IntrospectionError.class);
@@ -68,7 +74,7 @@ public class FieldsOrPropertiesExtractor_extract_test {
   @Test
   public void should_throw_exception_when_given_name_is_null() {
     thrown.expectIllegalArgumentException("The name of the field/property to read should not be null");
-    extract(null, employees);
+    extract((String)null, employees);
   }
   
   @Test
diff --git a/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_tuples_test.java b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_tuples_test.java
new file mode 100644
index 000000000..a1d67a866
--- /dev/null
+++ b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_tuples_test.java
@@ -0,0 +1,82 @@
+/*
+ * Created on Jul 27, 2012
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2011 the original author or authors.
+ */
+package org.assertj.core.groups;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.groups.FieldsOrPropertiesExtractor.extract;
+import static org.assertj.core.groups.Tuple.tuple;
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.ExpectedException;
+import org.assertj.core.test.Name;
+import org.assertj.core.util.introspection.IntrospectionError;
+
+public class FieldsOrPropertiesExtractor_extract_tuples_test {
+  
+  @Rule
+  public ExpectedException thrown = none();
+  
+  private static Employee yoda;
+  private static Employee luke;
+  private static List<Employee> employees;
+
+  @BeforeClass
+  public static void setUpOnce() {
+    yoda = new Employee(1L, new Name("Yoda"), 800);
+    luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
+    employees = newArrayList(yoda, luke);
+  }
+
+  @Test
+  public void should_extract_tuples_from_fields_or_properties() {
+    List<Tuple> extractedValues = extract(employees, "id", "age");
+    assertThat(extractedValues).containsOnly(tuple(1L, 800), tuple(2L, 26));
+  }
+  
+  @Test
+  public void should_extract_tuples_with_consistent_iteration_order() {
+    Set<Employee> employeeSet =  new HashSet<Employee>(employees);
+    List<Tuple> extractedValues = extract(employeeSet, "id", "name.first", "age");
+    assertThat(extractedValues).containsOnly(tuple(1L, "Yoda", 800), tuple(2L,"Luke", 26));
+  }
+  
+  @Test
+  public void should_throw_error_when_no_property_nor_public_field_match_one_of_given_names() {
+    thrown.expect(IntrospectionError.class);
+    extract(employees, "id", "age", "unknown");
+  }
+  
+  @Test
+  public void should_throw_exception_when_given_name_is_null() {
+    thrown.expectIllegalArgumentException("The names of the fields/properties to read should not be null");
+    extract(employees, (String[])null);
+  }
+  
+  @Test
+  public void should_throw_exception_when_given_name_is_empty() {
+    thrown.expectIllegalArgumentException("The names of the fields/properties to read should not be empty");
+    extract(employees, new String[0]);
+  }
+}
diff --git a/src/test/java/org/assertj/core/groups/Properties_from_with_Collection_Test.java b/src/test/java/org/assertj/core/groups/Properties_from_with_Collection_Test.java
index 0544367ac..18cc29fd3 100644
--- a/src/test/java/org/assertj/core/groups/Properties_from_with_Collection_Test.java
+++ b/src/test/java/org/assertj/core/groups/Properties_from_with_Collection_Test.java
@@ -45,21 +45,21 @@ public class Properties_from_with_Collection_Test {
 
   private PropertySupport propertySupport;
   private String propertyName;
-  private Properties<Long> properties;
+  private Properties<Integer> properties;
 
   @Before
   public void setUp() {
     propertySupport = mock(PropertySupport.class);
-    propertyName = "id";
-    properties = new Properties<Long>(propertyName, Long.class);
+    propertyName = "age";
+    properties = new Properties<Integer>(propertyName, Integer.class);
     properties.propertySupport = propertySupport;
   }
 
   @Test
   public void should_return_values_of_property() {
-    List<Long> ids = new ArrayList<Long>();
-    ids.add(yoda.getId());
-    when(propertySupport.propertyValues(propertyName, Long.class, employees)).thenReturn(ids);
-    assertSame(ids, properties.from(employees));
+    List<Integer> ages = newArrayList();
+    ages.add(yoda.getAge());
+    when(propertySupport.propertyValues(propertyName, Integer.class, employees)).thenReturn(ages);
+    assertSame(ages, properties.from(employees));
   }
 }
diff --git a/src/test/java/org/assertj/core/groups/Properties_from_with_array_Test.java b/src/test/java/org/assertj/core/groups/Properties_from_with_array_Test.java
index 3aca3eea0..8000e62bd 100644
--- a/src/test/java/org/assertj/core/groups/Properties_from_with_array_Test.java
+++ b/src/test/java/org/assertj/core/groups/Properties_from_with_array_Test.java
@@ -17,6 +17,8 @@ package org.assertj.core.groups;
 import static junit.framework.Assert.assertSame;
 import static org.assertj.core.util.ArrayWrapperList.wrap;
 import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.Lists.newArrayList;
+
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -46,21 +48,21 @@ public class Properties_from_with_array_Test {
 
   private PropertySupport propertySupport;
   private String propertyName;
-  private Properties<Long> properties;
+  private Properties<Integer> properties;
 
   @Before
   public void setUp() {
     propertySupport = mock(PropertySupport.class);
-    propertyName = "id";
-    properties = new Properties<Long>(propertyName, Long.class);
+    propertyName = "age";
+    properties = new Properties<Integer>(propertyName, Integer.class);
     properties.propertySupport = propertySupport;
   }
 
   @Test
   public void should_return_values_of_property() {
-    List<Long> ids = new ArrayList<Long>();
-    ids.add(yoda.getId());
-    when(propertySupport.propertyValues(propertyName, Long.class, wrap(employees))).thenReturn(ids);
-    assertSame(ids, properties.from(employees));
+    List<Integer> ages = newArrayList();
+    ages.add(yoda.getAge());
+    when(propertySupport.propertyValues(propertyName, Integer.class, wrap(employees))).thenReturn(ages);
+    assertSame(ages, properties.from(employees));
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
index 24a844af1..5412c07ee 100644
--- a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
+++ b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
@@ -61,40 +61,40 @@ public class PropertySupport_propertyValues_Test {
 
   @Test
   public void should_return_empty_List_if_given_Iterable_is_null() {
-    Iterable<Long> ids = propertySupport.propertyValues("ids", Long.class, null);
-    assertEquals(emptyList(), ids);
+    Iterable<Integer> ages = propertySupport.propertyValues("ages", Integer.class, null);
+    assertEquals(emptyList(), ages);
   }
 
   @Test
   public void should_return_empty_List_if_given_Iterable_is_empty() {
-    Iterable<Long> ids = propertySupport.propertyValues("ids", Long.class, emptySet());
-    assertEquals(emptyList(), ids);
+    Iterable<Integer> ages = propertySupport.propertyValues("ages", Integer.class, emptySet());
+    assertEquals(emptyList(), ages);
   }
 
   @Test
   public void should_return_empty_List_if_given_Iterable_contains_only_nulls() {
-    Iterable<Long> ids = propertySupport.propertyValues("ids", Long.class, newArrayList(null, null));
-    assertEquals(emptyList(), ids);
+    Iterable<Integer> ages = propertySupport.propertyValues("ages", Integer.class, newArrayList(null, null));
+    assertEquals(emptyList(), ages);
   }
 
   @Test
   public void should_remove_null_values_from_given_Iterable() {
     List<Employee> anotherList = newArrayList(yoda, null, luke, null);
-    Iterable<Long> ids = propertySupport.propertyValues("id", Long.class, anotherList);
-    assertEquals(newArrayList(6000L, 8000L), ids);
+    Iterable<Integer> ages = propertySupport.propertyValues("age", Integer.class, anotherList);
+    assertEquals(newArrayList(800, 26), ages);
   }
 
   @Test
   public void should_return_values_of_simple_property() {
-    Iterable<Long> ids = propertySupport.propertyValues("id", Long.class, employees);
-    assertEquals(newArrayList(6000L, 8000L), ids);
+    Iterable<Integer> ages = propertySupport.propertyValues("age", Integer.class, employees);
+    assertEquals(newArrayList(800, 26), ages);
   }
 
   @Test
   public void should_return_values_of_simple_property_as_objects() {
-    Iterable<Long> ids = propertySupport.propertyValues("id", Long.class, employees);
-    Iterable<Object> idsAsObjects = propertySupport.propertyValues("id", employees);
-    assertEquals(idsAsObjects, ids);
+    Iterable<Integer> ages = propertySupport.propertyValues("age", Integer.class, employees);
+    Iterable<Object> agesAsObjects = propertySupport.propertyValues("age", employees);
+    assertEquals(agesAsObjects, ages);
     Iterable<String> firstNames = propertySupport.propertyValues("name.first", String.class, employees);
     Iterable<Object> firstNamesAsObjects = propertySupport.propertyValues("name.first", employees);
     assertEquals(firstNamesAsObjects, firstNames);
@@ -109,12 +109,12 @@ public class PropertySupport_propertyValues_Test {
   @Test
   public void should_throw_error_if_property_not_found() {
     thrown.expect(IntrospectionError.class);
-    propertySupport.propertyValues("id.", Long.class, employees);
+    propertySupport.propertyValues("foo", Integer.class, employees);
   }
 
   @Test
   public void should_extract_property() {
-    Long id = propertySupport.propertyValue("id", Long.class, yoda);
-    assertEquals(Long.valueOf(6000L), id);
+    Integer age = propertySupport.propertyValue("age", Integer.class, yoda);
+    assertEquals(Integer.valueOf(800), age);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
index 23096c641..b60247d42 100644
--- a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
+++ b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
@@ -62,14 +62,14 @@ public class PropertySupport_propertyValues_with_mocks_Test {
   @Test
   public void should_throw_error_if_PropertyDescriptor_cannot_invoke_read_method() throws Exception {
     RuntimeException thrownOnPurpose = new RuntimeException("Thrown on purpose");
-    PropertyDescriptor real = getProperty("id", yoda);
+    PropertyDescriptor real = getProperty("age", yoda);
     when(descriptor.invokeReadMethod(real, yoda)).thenThrow(thrownOnPurpose);
     try {
-      propertySupport.propertyValues("id", Long.class, employees);
+      propertySupport.propertyValues("age", Long.class, employees);
       fail("expecting an IntrospectionError to be thrown");
     } catch (IntrospectionError expected) {
       assertSame(thrownOnPurpose, expected.getCause());
-      String msg = String.format("Unable to obtain the value of the property <'id'> from <%s>", yoda.toString());
+      String msg = String.format("Unable to obtain the value of the property <'age'> from <%s>", yoda.toString());
       assertEquals(msg, expected.getMessage());
     }
   }
diff --git a/src/test/java/org/assertj/core/test/Employee.java b/src/test/java/org/assertj/core/test/Employee.java
index b660b40b5..564952d02 100644
--- a/src/test/java/org/assertj/core/test/Employee.java
+++ b/src/test/java/org/assertj/core/test/Employee.java
@@ -22,29 +22,21 @@ import static java.lang.String.format;
  */
 public class Employee {
 
-  // intentionnaly public to test field retrieval
-  // getter have been created to test property retrieval
+  // intentionnaly public to test retrieval of a public field that is not a property
   public long id;
+  // name is both a public field and a property 
   public Name name;
-  // keep private to test we are able to read property but not field
+  // keep private to test we are able to read property that is not a public field
   private int age;
 
   public Employee() {}
 
   public Employee(long id, Name name, int age) {
-    setId(id);
+    this.id = id;
     setName(name);
     setAge(age);
   }
 
-  public long getId() {
-    return id;
-  }
-
-  public void setId(long id) {
-    this.id = id;
-  }
-
   public Name getName() {
     return name;
   }
@@ -60,6 +52,11 @@ public class Employee {
   public void setAge(int age) {
     this.age = age;
   }
+  
+  // pure property not backed by a field
+  public boolean isAdult() {
+    return age > 18;
+  }
 
   @Override
   public String toString() {
