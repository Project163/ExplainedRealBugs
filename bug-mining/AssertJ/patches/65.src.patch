diff --git a/src/main/java/org/assertj/core/internal/PropertySupport.java b/src/main/java/org/assertj/core/internal/PropertySupport.java
index f75d1770a..0086ee97d 100644
--- a/src/main/java/org/assertj/core/internal/PropertySupport.java
+++ b/src/main/java/org/assertj/core/internal/PropertySupport.java
@@ -17,7 +17,6 @@ package org.assertj.core.internal;
 import static java.lang.String.format;
 import static java.util.Collections.*;
 import static org.assertj.core.util.Iterables.isNullOrEmpty;
-import static org.assertj.core.util.Iterables.nonNullElementsIn;
 import static org.assertj.core.util.introspection.Introspection.getProperty;
 
 import java.beans.PropertyDescriptor;
@@ -67,18 +66,16 @@ public class PropertySupport {
    * @throws IntrospectionError if an element in the given {@code Iterable} does not have a property with a matching name.
    */
   public <T> List<T> propertyValues(String propertyName, Class<T> clazz, Iterable<?> target) {
-    // ignore null elements as we can't extract a property from a null object
-    Iterable<?> cleanedUp = nonNullElementsIn(target);
-    if (isNullOrEmpty(cleanedUp)) {
+    if (isNullOrEmpty(target)) {
       return emptyList();
     }
     if (isNestedProperty(propertyName)) {
       String firstPropertyName = popPropertyNameFrom(propertyName);
-      Iterable<Object> propertyValues = propertyValues(firstPropertyName, Object.class, cleanedUp);
+      Iterable<Object> propertyValues = propertyValues(firstPropertyName, Object.class, target);
       // extract next sub-property values until reaching the last sub-property
       return propertyValues(nextPropertyNameFrom(propertyName), clazz, propertyValues);
     }
-    return simplePropertyValues(propertyName, clazz, cleanedUp);
+    return simplePropertyValues(propertyName, clazz, target);
   }
 
   /**
@@ -98,7 +95,7 @@ public class PropertySupport {
   private <T> List<T> simplePropertyValues(String propertyName, Class<T> clazz, Iterable<?> target) {
     List<T> propertyValues = new ArrayList<T>();
     for (Object e : target) {
-      propertyValues.add(propertyValue(propertyName, clazz, e));
+      propertyValues.add(e == null ? null : propertyValue(propertyName, clazz, e));
     }
     return unmodifiableList(propertyValues);
   }
diff --git a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
index 676dfa806..9d636b4a5 100644
--- a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
+++ b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
@@ -78,18 +78,15 @@ public class FieldSupport {
    * @throws IntrospectionError if an element in the given {@code Iterable} does not have a field with a matching name.
    */
   public <T> List<T> fieldValues(String fieldName, Class<T> fieldClass, Iterable<?> target) {
-    // ignore null elements as we can't extract a field from a null object
-    Iterable<?> cleanedUp = nonNullElementsIn(target);
-    if (isNullOrEmpty(cleanedUp)) {
-      return emptyList();
-    }
+    if (isNullOrEmpty(target)) return emptyList();
+    
     if (isNestedField(fieldName)) {
       String firstFieldName = popFieldNameFrom(fieldName);
-      Iterable<Object> fieldValues = fieldValues(firstFieldName, Object.class, cleanedUp);
+      Iterable<Object> fieldValues = fieldValues(firstFieldName, Object.class, target);
       // extract next sub-field values until reaching the last sub-field
       return fieldValues(nextFieldNameFrom(fieldName), fieldClass, fieldValues);
     }
-    return simpleFieldValues(fieldName, fieldClass, cleanedUp);
+    return simpleFieldValues(fieldName, fieldClass, target);
   }
 
   public List<Object> fieldValues(String fieldName, Iterable<?>  target) {
@@ -116,7 +113,7 @@ public class FieldSupport {
   private <T> List<T> simpleFieldValues(String fieldName, Class<T> clazz, Iterable<?> target) {
     List<T> fieldValues = new ArrayList<T>();
     for (Object e : target) {
-      fieldValues.add(fieldValue(fieldName, clazz, e));
+      fieldValues.add(e == null ? null : fieldValue(fieldName, clazz, e));
     }
     return unmodifiableList(fieldValues);
   }
diff --git a/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java
index 8c9e68548..c3d14c299 100644
--- a/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java
+++ b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java
@@ -22,38 +22,63 @@ import static org.assertj.core.util.Lists.newArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import org.junit.BeforeClass;
-import org.junit.Rule;
-import org.junit.Test;
-
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
 import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
 
 public class FieldsOrPropertiesExtractor_extract_test {
   
   @Rule
   public ExpectedException thrown = none();
   
-  private static Employee yoda;
-  private static Employee luke;
-  private static List<Employee> employees;
+  private Employee yoda;
+  private Employee luke;
+  private List<Employee> employees;
 
-  
-  @BeforeClass
-  public static void setUpOnce() {
+  @Before
+  public void setUpOnce() {
     yoda = new Employee(1L, new Name("Yoda"), 800);
+    yoda.surname = new Name("Master", "Jedi");
     luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
     employees = newArrayList(yoda, luke);
   }
 
   @Test
-  public void should_extract_field_values_even_if_property_exist() {
+  public void should_extract_field_values_in_absence_of_properties() {
     List<Object> extractedValues = extract("id", employees);
     assertThat(extractedValues).containsOnly(1L, 2L);
   }
   
+  @Test
+  public void should_extract_null_valuesfor_null_property_values() {
+    yoda.setName(null);
+    List<Object> extractedValues = extract("name", employees);
+    assertThat(extractedValues).containsOnly(null, new Name("Luke", "Skywalker"));
+  }
+  
+  @Test
+  public void should_extract_null_values_for_null_nested_property_values() {
+    yoda.setName(null);
+    List<Object> extractedValues = extract("name.first", employees);
+    assertThat(extractedValues).containsOnly(null, "Luke");
+  }
+  
+  @Test
+  public void should_extract_null_valuesfor_null_field_values() {
+    List<Object> extractedValues = extract("surname", employees);
+    assertThat(extractedValues).containsOnly(new Name("Master", "Jedi"), null);
+  }
+  
+  @Test
+  public void should_extract_null_values_for_null_nested_field_values() {
+    List<Object> extractedValues = extract("surname.first", employees);
+    assertThat(extractedValues).containsOnly("Master", null);
+  }
+  
   @Test
   public void should_extract_property_values_when_no_public_field_match_given_name() {
     List<Object> extractedValues = extract("age", employees);
diff --git a/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_tuples_test.java b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_tuples_test.java
index a1d67a866..ab5cdaf98 100644
--- a/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_tuples_test.java
+++ b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_tuples_test.java
@@ -1,14 +1,14 @@
 /*
  * Created on Jul 27, 2012
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2011 the original author or authors.
  */
@@ -24,27 +24,27 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
-import org.junit.BeforeClass;
-import org.junit.Rule;
-import org.junit.Test;
-
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
 import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
 
 public class FieldsOrPropertiesExtractor_extract_tuples_test {
-  
+
   @Rule
   public ExpectedException thrown = none();
-  
-  private static Employee yoda;
-  private static Employee luke;
-  private static List<Employee> employees;
 
-  @BeforeClass
-  public static void setUpOnce() {
+  private Employee yoda;
+  private Employee luke;
+  private List<Employee> employees;
+
+  @Before
+  public void setUpOnce() {
     yoda = new Employee(1L, new Name("Yoda"), 800);
+    yoda.surname = new Name("Master", "Jedi");
     luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
     employees = newArrayList(yoda, luke);
   }
@@ -54,26 +54,34 @@ public class FieldsOrPropertiesExtractor_extract_tuples_test {
     List<Tuple> extractedValues = extract(employees, "id", "age");
     assertThat(extractedValues).containsOnly(tuple(1L, 800), tuple(2L, 26));
   }
-  
+
   @Test
   public void should_extract_tuples_with_consistent_iteration_order() {
-    Set<Employee> employeeSet =  new HashSet<Employee>(employees);
+    Set<Employee> employeeSet = new HashSet<Employee>(employees);
     List<Tuple> extractedValues = extract(employeeSet, "id", "name.first", "age");
-    assertThat(extractedValues).containsOnly(tuple(1L, "Yoda", 800), tuple(2L,"Luke", 26));
+    assertThat(extractedValues).containsOnly(tuple(1L, "Yoda", 800), tuple(2L, "Luke", 26));
   }
-  
+
+  @Test
+  public void should_extract_tuples_with_null_value_for_null_nested_field_or_property() {
+    luke.setName(null);
+    assertThat(extract(employees, "id", "name.first", "age")).containsOnly(tuple(1L, "Yoda", 800), tuple(2L, null, 26));
+    assertThat(extract(employees, "name.first")).containsOnly(tuple("Yoda"), tuple((String)null));
+    assertThat(extract(employees, "id", "surname.first")).containsOnly(tuple(1L, "Master"), tuple(2L, null));
+  }
+
   @Test
   public void should_throw_error_when_no_property_nor_public_field_match_one_of_given_names() {
     thrown.expect(IntrospectionError.class);
     extract(employees, "id", "age", "unknown");
   }
-  
+
   @Test
   public void should_throw_exception_when_given_name_is_null() {
     thrown.expectIllegalArgumentException("The names of the fields/properties to read should not be null");
-    extract(employees, (String[])null);
+    extract(employees, (String[]) null);
   }
-  
+
   @Test
   public void should_throw_exception_when_given_name_is_empty() {
     thrown.expectIllegalArgumentException("The names of the fields/properties to read should not be empty");
diff --git a/src/test/java/org/assertj/core/groups/Properties_extractProperty_Test.java b/src/test/java/org/assertj/core/groups/Properties_extractProperty_Test.java
index 893abdddb..22e6a766d 100644
--- a/src/test/java/org/assertj/core/groups/Properties_extractProperty_Test.java
+++ b/src/test/java/org/assertj/core/groups/Properties_extractProperty_Test.java
@@ -14,13 +14,12 @@
  */
 package org.assertj.core.groups;
 
-import static junit.framework.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.ExpectedException.none;
 
-
-import org.assertj.core.groups.Properties;
 import org.assertj.core.test.ExpectedException;
-import org.junit.*;
+import org.junit.Rule;
+import org.junit.Test;
 
 /**
  * Tests for <code>{@link Properties#extractProperty(String, Class)}</code>.
@@ -36,7 +35,7 @@ public class Properties_extractProperty_Test {
   @Test
   public void should_create_a_new_Properties() {
     Properties<Object> properties = Properties.extractProperty("id", Object.class);
-    assertEquals("id", properties.propertyName);
+    assertThat(properties.propertyName).isEqualTo("id");
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
index e96b876f8..923091bc9 100644
--- a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
+++ b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
@@ -1,38 +1,36 @@
 /*
  * Created on Feb 22, 2011
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2011 the original author or authors.
  */
 package org.assertj.core.internal;
 
-import static java.util.Collections.emptyList;
 import static java.util.Collections.emptySet;
 import static junit.framework.Assert.assertEquals;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.ExpectedException.none;
 import static org.assertj.core.util.Lists.newArrayList;
 
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
-import org.junit.BeforeClass;
-import org.junit.Rule;
-import org.junit.Test;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
 import org.assertj.core.test.VehicleFactory;
 import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
 
 /**
  * Tests for <code>{@link PropertySupport#propertyValues(String, Collection)}</code>.
@@ -44,17 +42,15 @@ import org.assertj.core.util.introspection.IntrospectionError;
  */
 public class PropertySupport_propertyValues_Test {
 
-  private static Employee yoda;
-  private static Employee luke;
-  private static Iterable<Employee> employees;
-  private static PropertySupport propertySupport;
+  private Employee yoda;
+  private Employee luke;
+  private Iterable<Employee> employees;
 
-  @BeforeClass
-  public static void setUpOnce() {
+  @Before
+  public void setUpOnce() {
     yoda = new Employee(6000L, new Name("Yoda"), 800);
     luke = new Employee(8000L, new Name("Luke", "Skywalker"), 26);
     employees = newArrayList(yoda, luke);
-    propertySupport = new PropertySupport();
   }
 
   @Rule
@@ -62,74 +58,72 @@ public class PropertySupport_propertyValues_Test {
 
   @Test
   public void should_return_empty_List_if_given_Iterable_is_null() {
-    Iterable<Integer> ages = propertySupport.propertyValues("ages", Integer.class, null);
-    assertEquals(emptyList(), ages);
+    Iterable<Integer> ages = PropertySupport.instance().propertyValues("ages", Integer.class, null);
+    assertThat(ages).isEmpty();
   }
 
   @Test
   public void should_return_empty_List_if_given_Iterable_is_empty() {
-    Iterable<Integer> ages = propertySupport.propertyValues("ages", Integer.class, emptySet());
-    assertEquals(emptyList(), ages);
+    Iterable<Integer> ages = PropertySupport.instance().propertyValues("ages", Integer.class, emptySet());
+    assertThat(ages).isEmpty();
   }
 
   @Test
-  public void should_return_empty_List_if_given_Iterable_contains_only_nulls() {
-    Iterable<Integer> ages = propertySupport.propertyValues("ages", Integer.class, newArrayList(null, null));
-    assertEquals(emptyList(), ages);
-  }
-
-  @Test
-  public void should_remove_null_values_from_given_Iterable() {
-    List<Employee> anotherList = newArrayList(yoda, null, luke, null);
-    Iterable<Integer> ages = propertySupport.propertyValues("age", Integer.class, anotherList);
-    assertEquals(newArrayList(800, 26), ages);
+  public void should_return_null_elements_for_null_property_value() {
+    List<Employee> list = newArrayList(null, null);
+    Iterable<Integer> ages = PropertySupport.instance().propertyValues("ages", Integer.class, list);
+    assertThat(ages).containsExactly(null, null);
+    
+    list = newArrayList(yoda, luke, null, null);
+    ages = PropertySupport.instance().propertyValues("age", Integer.class, list);
+    assertThat(ages).containsExactly(800, 26,null, null);
   }
 
   @Test
   public void should_return_values_of_simple_property() {
-    Iterable<Integer> ages = propertySupport.propertyValues("age", Integer.class, employees);
-    assertEquals(newArrayList(800, 26), ages);
+    Iterable<Integer> ages = PropertySupport.instance().propertyValues("age", Integer.class, employees);
+    assertThat(ages).containsExactly(800, 26);
   }
 
   @Test
   public void should_return_values_of_simple_property_as_objects() {
-    Iterable<Integer> ages = propertySupport.propertyValues("age", Integer.class, employees);
-    Iterable<Object> agesAsObjects = propertySupport.propertyValues("age", employees);
+    Iterable<Integer> ages = PropertySupport.instance().propertyValues("age", Integer.class, employees);
+    Iterable<Object> agesAsObjects = PropertySupport.instance().propertyValues("age", employees);
     assertEquals(agesAsObjects, ages);
-    Iterable<String> firstNames = propertySupport.propertyValues("name.first", String.class, employees);
-    Iterable<Object> firstNamesAsObjects = propertySupport.propertyValues("name.first", employees);
+    Iterable<String> firstNames = PropertySupport.instance().propertyValues("name.first", String.class, employees);
+    Iterable<Object> firstNamesAsObjects = PropertySupport.instance().propertyValues("name.first", employees);
     assertEquals(firstNamesAsObjects, firstNames);
   }
-  
+
   @Test
   public void should_return_values_of_nested_property() {
-    Iterable<String> firstNames = propertySupport.propertyValues("name.first", String.class, employees);
-    assertEquals(newArrayList("Yoda", "Luke"), firstNames);
+    Iterable<String> firstNames = PropertySupport.instance().propertyValues("name.first", String.class, employees);
+    assertThat(firstNames).containsExactly("Yoda", "Luke");
   }
 
   @Test
   public void should_throw_error_if_property_not_found() {
     thrown.expect(IntrospectionError.class);
-    propertySupport.propertyValues("foo", Integer.class, employees);
+    PropertySupport.instance().propertyValues("foo", Integer.class, employees);
   }
 
   @Test
   public void should_extract_property() {
-    Integer age = propertySupport.propertyValue("age", Integer.class, yoda);
-    assertEquals(Integer.valueOf(800), age);
+    Integer age = PropertySupport.instance().propertyValue("age", Integer.class, yoda);
+    assertThat(age).isEqualTo(800);
   }
-  
+
   @Test
   public void should_return_properties_of_inner_class() {
     VehicleFactory vehicleFactory = new VehicleFactory();
-    List<String> names = propertySupport.propertyValues("name", String.class, vehicleFactory.getVehicles());
-    assertEquals(Arrays.asList("Toyota", "Honda", "Audi"), names);
+    List<String> names = PropertySupport.instance().propertyValues("name", String.class, vehicleFactory.getVehicles());
+    assertThat(names).containsExactly("Toyota", "Honda", "Audi");
   }
-  
+
   @Test
   public void should_return_property_from_superclass() {
-    assertThat(propertySupport.propertyValues("class", Class.class, employees)).containsExactly(Employee.class,
-                                                                                                Employee.class);
+    assertThat(PropertySupport.instance().propertyValues("class", Class.class, employees)).containsExactly(Employee.class,
+                                                                                                           Employee.class);
   }
-  
+
 }
diff --git a/src/test/java/org/assertj/core/test/Employee.java b/src/test/java/org/assertj/core/test/Employee.java
index bfa5ca6c3..7fedc9080 100644
--- a/src/test/java/org/assertj/core/test/Employee.java
+++ b/src/test/java/org/assertj/core/test/Employee.java
@@ -24,8 +24,10 @@ public class Employee {
 
   // intentionally public to test retrieval of a public field that is not a property
   public long id;
-  // name is both a public field and a property 
+  // name is both a public field and a property => will be accessed as a property by extracting code
   public Name name;
+  // surname is only a public field
+  public Name surname;
   // keep private to test we are able to read property that is not a public field
   private int age;
 
@@ -44,7 +46,7 @@ public class Employee {
   public void setName(Name name) {
     this.name = name;
   }
-
+  
   public int getAge() {
     return age;
   }
diff --git a/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
index 60ca1c1b8..ad7a1bb8f 100644
--- a/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
@@ -17,20 +17,18 @@ package org.assertj.core.util.introspection;
 import static java.util.Collections.emptyList;
 import static java.util.Collections.emptySet;
 import static junit.framework.Assert.assertEquals;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.ExpectedException.none;
 import static org.assertj.core.util.Lists.newArrayList;
 
 import java.util.List;
 
-import org.junit.BeforeClass;
-import org.junit.Rule;
-import org.junit.Test;
-
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
 
 /**
  * Tests for <code>{@link FieldSupport#fieldValues(String, Class, Iterable)}</code>.
@@ -39,17 +37,15 @@ import org.assertj.core.test.Name;
  */
 public class FieldSupport_fieldValues_Test {
 
-  private static Employee yoda;
-  private static Employee luke;
-  private static List<Employee> employees;
-  private static FieldSupport fieldSupport;
+  private Employee yoda;
+  private Employee luke;
+  private List<Employee> employees;
 
-  @BeforeClass
-  public static void setUpOnce() {
+  @Before
+  public void setUpOnce() {
     yoda = new Employee(1L, new Name("Yoda"), 800);
     luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
     employees = newArrayList(yoda, luke);
-    fieldSupport = new FieldSupport();
   }
 
   @Rule
@@ -57,38 +53,36 @@ public class FieldSupport_fieldValues_Test {
 
   @Test
   public void should_return_empty_List_if_given_Iterable_is_null() {
-    Iterable<Long> ids = fieldSupport.fieldValues("ids", Long.class, (Iterable<Long>) null);
+    Iterable<Long> ids = FieldSupport.instance().fieldValues("ids", Long.class, (Iterable<Long>) null);
     assertEquals(emptyList(), ids);
   }
 
   @Test
   public void should_return_empty_List_if_given_Iterable_is_empty() {
-    Iterable<Long> ids = fieldSupport.fieldValues("ids", Long.class, emptySet());
+    Iterable<Long> ids = FieldSupport.instance().fieldValues("ids", Long.class, emptySet());
     assertEquals(emptyList(), ids);
   }
 
   @Test
-  public void should_return_empty_List_if_given_Iterable_contains_only_nulls() {
-    Iterable<Long> ids = fieldSupport.fieldValues("ids", Long.class, newArrayList(null, null));
-    assertEquals(emptyList(), ids);
-  }
-
-  @Test
-  public void should_remove_null_values_from_given_Iterable() {
-    List<Employee> anotherList = newArrayList(yoda, null, luke, null);
-    Iterable<Long> ids = fieldSupport.fieldValues("id", Long.class, anotherList);
-    assertEquals(newArrayList(1L, 2L), ids);
+  public void should_return_null_elements_for_null_field_value() {
+    List<Employee> list = newArrayList(null, null);
+    Iterable<Long> ages = FieldSupport.instance().fieldValues("id", Long.class, list);
+    assertThat(ages).containsExactly(null, null);
+
+    list = newArrayList(yoda, luke, null, null);
+    ages = FieldSupport.instance().fieldValues("id", Long.class, list);
+    assertThat(ages).containsExactly(1L, 2L, null, null);
   }
 
   @Test
   public void should_return_values_of_simple_field() {
-    Iterable<Long> ids = fieldSupport.fieldValues("id", Long.class, employees);
+    Iterable<Long> ids = FieldSupport.instance().fieldValues("id", Long.class, employees);
     assertEquals(newArrayList(1L, 2L), ids);
   }
 
   @Test
   public void should_return_values_of_nested_field() {
-    Iterable<String> firstNames = fieldSupport.fieldValues("name.first", String.class, employees);
+    Iterable<String> firstNames = FieldSupport.instance().fieldValues("name.first", String.class, employees);
     assertEquals(newArrayList("Yoda", "Luke"), firstNames);
   }
 
@@ -96,12 +90,12 @@ public class FieldSupport_fieldValues_Test {
   public void should_throw_error_if_field_not_found() {
     thrown.expect(IntrospectionError.class,
                   "Unable to obtain the value of the field <'id.'> from <Employee[id=1, name=Name[first='Yoda', last='null'], age=800]>");
-    fieldSupport.fieldValues("id.", Long.class, employees);
+    FieldSupport.instance().fieldValues("id.", Long.class, employees);
   }
 
   @Test
   public void should_return_values_of_private_field() {
-    List<Integer> ages = fieldSupport.fieldValues("age", Integer.class, employees);
+    List<Integer> ages = FieldSupport.instance().fieldValues("age", Integer.class, employees);
     assertEquals(newArrayList(800, 26), ages);
   }
 
@@ -110,8 +104,8 @@ public class FieldSupport_fieldValues_Test {
     FieldSupport.setAllowExtractingPrivateFields(false);
     try {
       thrown.expect(IntrospectionError.class,
-              "Unable to obtain the value of the field <'age'> from <Employee[id=1, name=Name[first='Yoda', last='null'], age=800]>, check that field is public.");
-      fieldSupport.fieldValues("age", Integer.class, employees);
+                    "Unable to obtain the value of the field <'age'> from <Employee[id=1, name=Name[first='Yoda', last='null'], age=800]>, check that field is public.");
+      FieldSupport.instance().fieldValues("age", Integer.class, employees);
     } finally { // back to default value
       FieldSupport.setAllowExtractingPrivateFields(true);
     }
@@ -119,14 +113,15 @@ public class FieldSupport_fieldValues_Test {
 
   @Test
   public void should_extract_field() {
-    Long id = fieldSupport.fieldValue("id", Long.class, yoda);
+    Long id = FieldSupport.instance().fieldValue("id", Long.class, yoda);
     assertEquals(Long.valueOf(1L), id);
   }
 
   @Test
   public void should_handle_array_as_iterable() {
-    List<Long> fieldValuesFromIterable = fieldSupport.fieldValues("id", Long.class, employees);
-    List<Long> fieldValuesFromArray = fieldSupport.fieldValues("id", Long.class, employees.toArray(new Employee[0]));
+    List<Long> fieldValuesFromIterable = FieldSupport.instance().fieldValues("id", Long.class, employees);
+    List<Long> fieldValuesFromArray = FieldSupport.instance().fieldValues("id", Long.class,
+                                                                          employees.toArray(new Employee[0]));
     assertThat(fieldValuesFromArray).isEqualTo(fieldValuesFromIterable);
   }
 }
