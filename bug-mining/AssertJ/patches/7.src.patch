diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index bae4e433e..111bf0624 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -1,14 +1,14 @@
 /*
  * Created on Nov 18, 2010
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2010-2011 the original author or authors.
  */
@@ -16,16 +16,21 @@ package org.assertj.core.api;
 
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.HashSet;
+import java.util.List;
 
-import org.assertj.core.internal.*;
+import org.assertj.core.groups.Properties;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.Iterables;
 import org.assertj.core.util.VisibleForTesting;
 
-
 /**
  * Base class for implementations of <code>{@link ObjectEnumerableAssert}</code> whose actual value type is
  * <code>{@link Collection}</code>.
- * @param <S> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/anMa4g" target="_blank">Emulating
- *          'self types' using Java Generics to simplify fluent API implementation</a>&quot; for more details.
+ * 
+ * @param <S> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/anMa4g"
+ *          target="_blank">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>&quot;
+ *          for more details.
  * @param <A> the type of the "actual" value.
  * @param <T> the type of elements of the "actual" value.
  * 
@@ -37,8 +42,9 @@ import org.assertj.core.util.VisibleForTesting;
  * @author Nicolas Fran√ßois
  * @author Mikhail Mazursky
  */
-public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S, A, T>, A extends Iterable<T>, T> extends
-    AbstractAssert<S, A> implements ObjectEnumerableAssert<S, T> {
+public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S, A, T>, A extends Iterable<T>, T>
+    extends AbstractAssert<S, A>
+    implements ObjectEnumerableAssert<S, T> {
 
   @VisibleForTesting
   Iterables iterables = Iterables.instance();
@@ -101,6 +107,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
 
   /**
    * Verifies that all the elements of the actual {@code Iterable} are present in the given {@code Iterable}.
+   * 
    * @param values the {@code Iterable} that should contain all actual elements.
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Iterable} is {@code null}.
@@ -267,4 +274,50 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
     this.iterables = Iterables.instance();
     return myself;
   }
+
+  /**
+   * Extract the values of given property from the Iterable under test into a new Iterable, this new Iterable is now the
+   * Iterable under test.
+   * <p>
+   * It allows you to test a property of a collection instead of testing the collection elements.
+   * <p>
+   * Let's take an example to make things clearer.
+   * 
+   * <pre>
+   * // Create a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
+   * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
+   * 
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Legolas&quot;, 1000, ELF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Pippin&quot;, 28, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN));
+   * 
+   * // let's verify the names of TolkienCharacter's name in fellowshipOfTheRing :
+   * 
+   * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;)
+   *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
+   *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
+   *         
+   * // you can extract nested property like the name of Race :
+   * 
+   * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;)
+   *           .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
+   *           .doesNotContain(&quot;Orc&quot;);
+   * </pre>
+   * 
+   * Note that the order of extracted property values is consistent with the iteration order of the Iterable under test,
+   * for example if it's a {@link HashSet}, you can't make any assumptions of the extracted values order.
+   * 
+   * @param property the property to extract from the Iterable under test
+   * @return a new assertion object whose object under test is the list of extracted property values.
+   */
+  public ListAssert<Object> extracting(String property) {
+    List<Object> values = Properties.extractProperty(property).from(actual);
+    return new ListAssert<Object>(values);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/groups/Properties.java b/src/main/java/org/assertj/core/groups/Properties.java
index cd738ab61..c30ecaf9e 100644
--- a/src/main/java/org/assertj/core/groups/Properties.java
+++ b/src/main/java/org/assertj/core/groups/Properties.java
@@ -16,6 +16,8 @@ package org.assertj.core.groups;
 
 import static org.assertj.core.util.ArrayWrapperList.wrap;
 
+import java.util.List;
+
 import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.util.IntrospectionError;
 import org.assertj.core.util.VisibleForTesting;
@@ -103,7 +105,7 @@ public class Properties<T> {
    * @return the values of the previously specified property extracted from the given {@code Iterable}.
    * @throws IntrospectionError if an element in the given {@code Iterable} does not have a property with a matching name.
    */
-  public Iterable<T> from(Iterable<?> c) {
+  public List<T> from(Iterable<?> c) {
     return propertySupport.propertyValues(propertyName, propertyType, c);
   }
 
@@ -114,7 +116,7 @@ public class Properties<T> {
    * @return the values of the previously specified property extracted from the given array.
    * @throws IntrospectionError if an element in the given array does not have a property with a matching name.
    */
-  public Iterable<T> from(Object[] array) {
+  public List<T> from(Object[] array) {
     return propertySupport.propertyValues(propertyName, propertyType, wrap(array));
   }
 }
diff --git a/src/main/java/org/assertj/core/internal/PropertySupport.java b/src/main/java/org/assertj/core/internal/PropertySupport.java
index 7fb0512bb..6755c3bbe 100644
--- a/src/main/java/org/assertj/core/internal/PropertySupport.java
+++ b/src/main/java/org/assertj/core/internal/PropertySupport.java
@@ -66,7 +66,7 @@ public class PropertySupport {
    * @return an {@code Iterable} containing the values of the given property name, from the elements of the given {@code Iterable}.
    * @throws IntrospectionError if an element in the given {@code Iterable} does not have a property with a matching name.
    */
-  public <T> Iterable<T> propertyValues(String propertyName, Class<T> clazz, Iterable<?> target) {
+  public <T> List<T> propertyValues(String propertyName, Class<T> clazz, Iterable<?> target) {
     // ignore null elements as we can't extract a property from a null object
     Iterable<?> cleanedUp = nonNullElementsIn(target);
     if (isNullOrEmpty(cleanedUp)) {
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
new file mode 100644
index 000000000..79c493b33
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
@@ -0,0 +1,70 @@
+/*
+ * Created on Sep 30, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+
+import org.assertj.core.api.AbstractIterableAssert;
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.ExpectedException;
+import org.assertj.core.test.Name;
+
+
+/**
+ * Tests for <code>{@link AbstractIterableAssert#extracting(String)}</code>.
+ * 
+ * @author Joel Costigliola
+ */
+public class IterableAssert_extracting_Test {
+
+  private static Employee yoda;
+  private static Employee luke;
+  private static Iterable<Employee> employees;
+
+  @BeforeClass
+  public static void setUpOnce() {
+    yoda = new Employee(1L, new Name("Yoda"), 800);
+    luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
+    employees = newArrayList(yoda, luke);
+  }
+
+  @Rule
+  public ExpectedException thrown = none();
+
+
+  @Test
+  public void should_allow_assertions_on_property_values_extracted_from_given_iterable() throws Exception {
+    // test various property types
+    // basic types
+    assertThat(employees).extracting("id").containsOnly(1L, 2L);
+    assertThat(employees).extracting("age").containsOnly(800, 26);
+    // object
+    assertThat(employees).extracting("name").containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+    // nested property
+    assertThat(employees).extracting("name.first").containsOnly("Yoda", "Luke");
+  }
+  
+  @Test
+  public void should_throw_IAE_if_property_can_not_be_extracted() throws Exception {
+    
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/test/Name.java b/src/test/java/org/assertj/core/test/Name.java
index e585d0316..483f8ae88 100644
--- a/src/test/java/org/assertj/core/test/Name.java
+++ b/src/test/java/org/assertj/core/test/Name.java
@@ -54,4 +54,30 @@ public class Name {
   public String toString() {
     return String.format("%s[first='%s', last='%s']", getClass().getSimpleName(), first, last);
   }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + ((first == null) ? 0 : first.hashCode());
+    result = prime * result + ((last == null) ? 0 : last.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (obj == null) return false;
+    if (getClass() != obj.getClass()) return false;
+    Name other = (Name) obj;
+    if (first == null) {
+      if (other.first != null) return false;
+    } else if (!first.equals(other.first)) return false;
+    if (last == null) {
+      if (other.last != null) return false;
+    } else if (!last.equals(other.last)) return false;
+    return true;
+  }
+  
+  
 }
