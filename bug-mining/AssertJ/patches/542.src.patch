diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractAssert.java
index 16e442c74..d9222928b 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractAssert.java
@@ -58,11 +58,10 @@ import org.assertj.core.util.VisibleForTesting;
 /**
  * Base class for all assertions.
  *
- * @param <SELF> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/1IZIRcY"
- *          target="_blank">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>&quot;
- *          for more details.
+ * @param <SELF>   the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/1IZIRcY"
+ *                 target="_blank">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>&quot;
+ *                 for more details.
  * @param <ACTUAL> the type of the "actual" value.
- *
  * @author Alex Ruiz
  * @author Joel Costigliola
  * @author Mikhail Mazursky
@@ -133,7 +132,7 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * normally and respond appropriately.
    *
    * @param errorMessage the error message to format
-   * @param arguments the arguments referenced by the format specifiers in the errorMessage string.
+   * @param arguments    the arguments referenced by the format specifiers in the errorMessage string.
    * @see #failWithActualExpectedAndMessage(Object, Object, String, Object...)
    * @see #failure(String, Object...)
    */
@@ -165,10 +164,10 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * }</code></pre>
    *
    * @param errorMessage the error message to format
-   * @param arguments the arguments referenced by the format specifiers in the errorMessage string.
+   * @param arguments    the arguments referenced by the format specifiers in the errorMessage string.
+   * @return The generated assertion error.
    * @see #failureWithActualExpected(Object, Object, String, Object...)
    * @see #failWithMessage(String, Object...)
-   * @return The generated assertion error.
    */
   protected AssertionError failure(String errorMessage, Object... arguments) {
     AssertionError assertionError = Failures.instance().failureIfErrorMessageIsOverridden(info);
@@ -192,10 +191,10 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * preferable to using this wrapper method, as the compiler and other code analysis tools will be able to tell that the
    * statement will never return normally and respond appropriately.
    *
-   * @param actual the actual object that was found during the test
-   * @param expected the object that was expected
+   * @param actual             the actual object that was found during the test
+   * @param expected           the object that was expected
    * @param errorMessageFormat the error message to format
-   * @param arguments the arguments referenced by the format specifiers in the errorMessage string.
+   * @param arguments          the arguments referenced by the format specifiers in the errorMessage string.
    * @see #failWithMessage(String, Object...)
    * @see #failureWithActualExpected(Object, Object, String, Object...)
    */
@@ -230,10 +229,10 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    *   return this;
    * }</code></pre>
    *
-   * @param actual the actual object that was found during the test
-   * @param expected the object that was expected
+   * @param actual             the actual object that was found during the test
+   * @param expected           the object that was expected
    * @param errorMessageFormat the error message to format
-   * @param arguments the arguments referenced by the format specifiers in the errorMessage string.
+   * @param arguments          the arguments referenced by the format specifiers in the errorMessage string.
    * @return The generated assertion error.
    * @see #failure(String, Object...)
    * @see #failWithActualExpectedAndMessage(Object, Object, String, Object...)
@@ -309,7 +308,7 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    *   &lt;"µµµ"&gt;
    * to contain:
    *   &lt;"μμμ"&gt;</code></pre>
-   *
+   * <p>
    * With Hexadecimal message:
    * <pre><code class='java'> assertThat("µµµ").inHexadecimal().contains("μμμ");
    *
@@ -345,7 +344,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   @CheckReturnValue
   public SELF describedAs(Description description) {
@@ -360,7 +361,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     if (!descriptionText.isEmpty()) System.out.println(descriptionText);
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isEqualTo(Object expected) {
     if (actual instanceof AbstractAssert<?, ?> && throwUnsupportedExceptionOnEquals) {
@@ -372,7 +375,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNotEqualTo(Object other) {
     if (actual instanceof AbstractAssert<?, ?> && throwUnsupportedExceptionOnEquals) {
@@ -384,97 +389,125 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public void isNull() {
     objects.assertNull(info, actual);
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNotNull() {
     objects.assertNotNull(info, actual);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isSameAs(Object expected) {
     objects.assertSame(info, actual, expected);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNotSameAs(Object other) {
     objects.assertNotSame(info, actual, other);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isIn(Object... values) {
     objects.assertIsIn(info, actual, values);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNotIn(Object... values) {
     objects.assertIsNotIn(info, actual, values);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isIn(Iterable<?> values) {
     objects.assertIsIn(info, actual, values);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNotIn(Iterable<?> values) {
     objects.assertIsNotIn(info, actual, values);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF is(Condition<? super ACTUAL> condition) {
     conditions.assertIs(info, actual, condition);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNot(Condition<? super ACTUAL> condition) {
     conditions.assertIsNot(info, actual, condition);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF has(Condition<? super ACTUAL> condition) {
     conditions.assertHas(info, actual, condition);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF doesNotHave(Condition<? super ACTUAL> condition) {
     conditions.assertDoesNotHave(info, actual, condition);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF satisfies(Condition<? super ACTUAL> condition) {
     conditions.assertSatisfies(info, actual, condition);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @SuppressWarnings("unchecked")
   @Override
   @CheckReturnValue
@@ -484,14 +517,18 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return (ASSERT) instanceOfAssertFactory.createAssert(actual).withAssertionState(myself);
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isInstanceOf(Class<?> type) {
     objects.assertIsInstanceOf(info, actual, type);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @SuppressWarnings("unchecked")
   @Override
   public <T> SELF isInstanceOfSatisfying(Class<T> type, Consumer<T> requirements) {
@@ -501,91 +538,117 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isInstanceOfAny(Class<?>... types) {
     objects.assertIsInstanceOfAny(info, actual, types);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNotInstanceOf(Class<?> type) {
     objects.assertIsNotInstanceOf(info, actual, type);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNotInstanceOfAny(Class<?>... types) {
     objects.assertIsNotInstanceOfAny(info, actual, types);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF hasSameClassAs(Object other) {
     objects.assertHasSameClassAs(info, actual, other);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF hasToString(String expectedToString) {
     objects.assertHasToString(info, actual, expectedToString);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF hasToString(String expectedStringTemplate, Object... args) {
     requireNonNull(expectedStringTemplate, "The expectedStringTemplate must not be null");
     return hasToString(format(expectedStringTemplate, args));
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF doesNotHaveToString(String otherToString) {
     objects.assertDoesNotHaveToString(info, actual, otherToString);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF doesNotHaveToString(String expectedStringTemplate, Object... args) {
     requireNonNull(expectedStringTemplate, "The expectedStringTemplate must not be null");
     return doesNotHaveToString(format(expectedStringTemplate, args));
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF doesNotHaveSameClassAs(Object other) {
     objects.assertDoesNotHaveSameClassAs(info, actual, other);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isExactlyInstanceOf(Class<?> type) {
     objects.assertIsExactlyInstanceOf(info, actual, type);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNotExactlyInstanceOf(Class<?> type) {
     objects.assertIsNotExactlyInstanceOf(info, actual, type);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isOfAnyClassIn(Class<?>... types) {
     objects.assertIsOfAnyClassIn(info, actual, types);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF isNotOfAnyClassIn(Class<?>... types) {
     objects.assertIsNotOfAnyClassIn(info, actual, types);
@@ -593,8 +656,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
   }
 
   /**
-   *  {@inheritDoc}
-   *  @deprecated use {@link #asInstanceOf(InstanceOfAssertFactory) asInstanceOf(InstanceOfAssertFactories.LIST)} instead
+   * {@inheritDoc}
+   *
+   * @deprecated use {@link #asInstanceOf(InstanceOfAssertFactory) asInstanceOf(InstanceOfAssertFactories.LIST)} instead
    */
   @Deprecated
   @Override
@@ -603,12 +667,14 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return asInstanceOf(InstanceOfAssertFactories.LIST);
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   @CheckReturnValue
   public AbstractStringAssert<?> asString() {
     objects.assertNotNull(info, actual);
-    return Assertions.assertThat(actual.toString());
+    return Assertions.assertThat(actual.toString()).withAssertionState(myself);
   }
 
   /**
@@ -635,7 +701,7 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    *                              .isTrue();</code></pre>
    *
    * @param newErrorMessage the error message that will replace the default one provided by Assertj.
-   * @param args the args used to fill error message as in {@link String#format(String, Object...)}.
+   * @param args            the args used to fill error message as in {@link String#format(String, Object...)}.
    * @return this assertion object.
    */
   @CheckReturnValue
@@ -674,8 +740,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * Example:
    * <pre><code class='java'>assertThat(player.isRookie()).withFailMessage(&quot;Expecting Player &lt;%s&gt; to be a rookie but was not.&quot;, player)
    *                              .isTrue();</code></pre>
+   *
    * @param newErrorMessage the error message that will replace the default one provided by Assertj.
-   * @param args the args used to fill error message as in {@link String#format(String, Object...)}.
+   * @param args            the args used to fill error message as in {@link String#format(String, Object...)}.
    * @return this assertion object.
    */
   @CheckReturnValue
@@ -694,6 +761,7 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * Example:
    * <pre><code class='java'>assertThat(player.isRookie()).withFailMessage(() -&gt; &quot;Expecting Player to be a rookie but was not.&quot;)
    *                              .isTrue();</code></pre>
+   *
    * @param supplier the supplier supplies error message that will replace the default one provided by Assertj.
    * @return this assertion object.
    */
@@ -702,14 +770,18 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return overridingErrorMessage(supplier);
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   @CheckReturnValue
   public SELF usingComparator(Comparator<? super ACTUAL> customComparator) {
     return usingComparator(customComparator, null);
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   @CheckReturnValue
   public SELF usingComparator(Comparator<? super ACTUAL> customComparator, String customComparatorDescription) {
@@ -718,21 +790,27 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   @CheckReturnValue
   public SELF usingEquals(BiPredicate<? super ACTUAL, ? super ACTUAL> predicate) {
     return usingEquals(predicate, null);
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   @CheckReturnValue
   public SELF usingEquals(BiPredicate<? super ACTUAL, ? super ACTUAL> predicate, String customEqualsDescription) {
     return usingComparator((o1, o2) -> predicate.test(o1, o2) ? 0 : -1, customEqualsDescription);
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   @CheckReturnValue
   public SELF usingDefaultComparator() {
@@ -741,7 +819,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   @CheckReturnValue
   public SELF withThreadDumpOnError() {
@@ -749,7 +829,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   @CheckReturnValue
   public SELF withRepresentation(Representation representation) {
@@ -760,9 +842,8 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
   /**
    * {@inheritDoc}
    *
-   * @deprecated use {@link #isEqualTo} instead
-   *
    * @throws UnsupportedOperationException if this method is called.
+   * @deprecated use {@link #isEqualTo} instead
    */
   @Override
   @Deprecated
@@ -791,7 +872,7 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    *
    * @param predicate the {@link Predicate} to match
    * @return {@code this} assertion object.
-   * @throws AssertionError if {@code actual} does not match the given {@link Predicate}.
+   * @throws AssertionError       if {@code actual} does not match the given {@link Predicate}.
    * @throws NullPointerException if given {@link Predicate} is null.
    */
   public SELF matches(Predicate<? super ACTUAL> predicate) {
@@ -805,16 +886,16 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * <p>
    * Example:
    * <pre><code class='java'> assertThat(player).matches(p -&gt; p.isRookie(), "is rookie");</code></pre>
-   *
+   * <p>
    * The error message contains the predicate description, in our example, it is:
    * <pre><code class='java'> Expecting:
    *   &lt;player&gt;
    * to match 'is rookie' predicate.</code></pre>
    *
-   * @param predicate the {@link Predicate} to match
+   * @param predicate            the {@link Predicate} to match
    * @param predicateDescription a description of the {@link Predicate} used in the error message
    * @return {@code this} assertion object.
-   * @throws AssertionError if {@code actual} does not match the given {@link Predicate}.
+   * @throws AssertionError       if {@code actual} does not match the given {@link Predicate}.
    * @throws NullPointerException if given {@link Predicate} is null.
    * @throws NullPointerException if given predicateDescription is null.
    */
@@ -831,7 +912,7 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    *
    * @param predicate the {@link Predicate} not to match
    * @return {@code this} assertion object.
-   * @throws AssertionError if {@code actual} matches the given {@link Predicate}.
+   * @throws AssertionError       if {@code actual} matches the given {@link Predicate}.
    * @throws NullPointerException if given {@link Predicate} is null.
    */
   public SELF doesNotMatch(Predicate<? super ACTUAL> predicate) {
@@ -846,17 +927,17 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * Example:
    *
    * <pre><code class='java'> assertThat(player).doesNotMatch(p -&gt; p.isRookie(), "is rookie");</code></pre>
-   *
+   * <p>
    * The error message contains the predicate description, in our example, it is:
    *
    * <pre><code class='java'> Expecting:
    *   &lt;player&gt;
    * not to match 'is rookie' predicate.</code></pre>
    *
-   * @param predicate the {@link Predicate} not to match
+   * @param predicate            the {@link Predicate} not to match
    * @param predicateDescription a description of the {@link Predicate} used in the error message
    * @return {@code this} assertion object.
-   * @throws AssertionError if {@code actual} matches the given {@link Predicate}.
+   * @throws AssertionError       if {@code actual} matches the given {@link Predicate}.
    * @throws NullPointerException if given {@link Predicate} is null.
    * @throws NullPointerException if given predicateDescription is null.
    */
@@ -897,7 +978,6 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    *
    * @param requirements to assert on the actual object - must not be null.
    * @return this assertion object.
-   *
    * @throws NullPointerException if any given Consumer is null
    */
   @SafeVarargs
@@ -932,10 +1012,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    *
    * @param assertions the group of assertions to run against the object under test - must not be null.
    * @return this assertion object.
-   *
    * @throws IllegalArgumentException if any given assertions group is null
-   * @throws RuntimeException rethrown as is by the given {@link ThrowingConsumer} or wrapping any {@link Throwable}.
-   * @throws AssertionError rethrown as is by the given {@link ThrowingConsumer}
+   * @throws RuntimeException         rethrown as is by the given {@link ThrowingConsumer} or wrapping any {@link Throwable}.
+   * @throws AssertionError           rethrown as is by the given {@link ThrowingConsumer}
    * @since 3.21.0
    */
   @SafeVarargs
@@ -992,7 +1071,6 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    *
    * @param assertions the group of assertions to run against the object under test - must not be null.
    * @return this assertion object.
-   *
    * @throws IllegalArgumentException if any given assertions group is null
    * @since 3.12.0
    */
@@ -1027,10 +1105,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    *
    * @param assertions the group of assertions to run against the object under test - must not be null.
    * @return this assertion object.
-   *
    * @throws IllegalArgumentException if any given assertions group is null
-   * @throws RuntimeException rethrown as is by the given {@link ThrowingConsumer} or wrapping any {@link Throwable}.
-   * @throws AssertionError rethrown as is by the given {@link ThrowingConsumer}
+   * @throws RuntimeException         rethrown as is by the given {@link ThrowingConsumer} or wrapping any {@link Throwable}.
+   * @throws AssertionError           rethrown as is by the given {@link ThrowingConsumer}
    * @since 3.21.0
    */
   @SafeVarargs
@@ -1086,14 +1163,18 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     AbstractAssert.descriptionConsumer = descriptionConsumer;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF hasSameHashCodeAs(Object other) {
     objects.assertHasSameHashCodeAs(info, actual, other);
     return myself;
   }
 
-  /** {@inheritDoc} */
+  /**
+   * {@inheritDoc}
+   */
   @Override
   public SELF doesNotHaveSameHashCodeAs(Object other) {
     objects.assertDoesNotHaveSameHashCodeAs(info, actual, other);
@@ -1105,7 +1186,7 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * <p>
    * this method avoids code duplication when features like extracting/asList need to create a new list assertions.
    *
-   * @param <E> the type of elements.
+   * @param <E>       the type of elements.
    * @param newActual new list under test
    * @return a new {@link AbstractListAssert}.
    */
@@ -1165,10 +1246,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * @param assertFactory   the factory for the creation of the new {@code Assert}
    * @return the new {@code Assert} instance
    * @throws AssertionError if {@code actual} is {@code null}
-   *
-   * @since 3.16.0
    * @see AbstractObjectAssert#extracting(String)
    * @see AbstractObjectAssert#extracting(String, InstanceOfAssertFactory)
+   * @since 3.16.0
    */
   @SuppressWarnings("unchecked")
   @CheckReturnValue
@@ -1193,10 +1273,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * @param assertFactory the factory for the creation of the new {@code Assert}
    * @return the new {@code Assert} instance
    * @throws AssertionError if {@code actual} is {@code null}
-   *
-   * @since 3.16.0
    * @see AbstractObjectAssert#extracting(Function)
    * @see AbstractObjectAssert#extracting(Function, InstanceOfAssertFactory)
+   * @since 3.16.0
    */
   @SuppressWarnings("unchecked")
   @CheckReturnValue
@@ -1213,10 +1292,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * Returns true if actual and other are equal according to the current comparison strategy.
    *
    * @param actual the object to compare to other
-   * @param other the object to compare to actual
+   * @param other  the object to compare to actual
    * @return true if actual and other are equal according to the underlying comparison strategy.
    * @since 3.23.0
-   *
    * @deprecated {@link ComparisonStrategy} will become part of the public API in the next major release and this method
    * will be removed.
    */
@@ -1236,9 +1314,9 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * <p>
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = TolkienCharacter.of("Frodo", 33, HOBBIT);
-   * 
+   *
    * String newActual = assertThat(frodo).extracting(TolkienCharacter::getName).actual();
-   * 
+   *
    * // newActual == frodo.getName()
    * assertThat(newActual).isSameAs(frodo.name);</code></pre>
    *
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_asList_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_asList_Test.java
index efe89bea6..0abbf9846 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_asList_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_asList_Test.java
@@ -12,13 +12,13 @@
  */
 package org.assertj.tests.core.api;
 
-import static java.lang.String.format;
-import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 
 import java.util.List;
+
 import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
@@ -26,33 +26,40 @@ class Assertions_assertThat_asList_Test {
 
   @Test
   void should_pass_list_asserts_on_list_objects_with_asList() {
-    Object listAsObject = asList(1, 2, 3);
-    assertThat(listAsObject).asList().isSorted();
+    // GIVEN
+    Object listAsObject = list(1, 2, 3);
+    // WHEN/THEN
+    then(listAsObject).asList().isSorted();
   }
 
   @Test
   void should_pass_list_asserts_on_list_strings_with_asList() {
-    List<String> listAsObject = asList("a", "b", "c");
-    assertThat(listAsObject).asList().isSorted()
-                            .last().isEqualTo("c");
+    // GIVEN
+    List<String> listAsObject = list("a", "b", "c");
+    // WHEN/THEN
+    then(listAsObject).asList()
+                      .isSorted()
+                      .last().isEqualTo("c");
   }
 
   @Test
   void should_fail_list_asserts_on_non_list_objects_even_with_asList() {
+    // GIVEN
     Object nonList = new Object();
-
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(nonList).asList().isSorted())
-                                                   .withMessageContaining(format("an instance of:%n  java.util.List%nbut was instance of:%n  java.lang.Object"));
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(nonList).asList().isSorted());
+    // THEN
+    then(error).hasMessageContainingAll("an instance of", "java.util.List", "but was instance of", "java.lang.Object");
   }
 
   @Test
   void should_keep_existing_description_set_before_calling_asList() {
     // GIVEN
-    Object listAsObject = asList(1, 2, 3);
+    Object listAsObject = list(1, 2, 3);
     // WHEN
-    Throwable error = catchThrowable(() -> assertThat(listAsObject).as("oops").asList().isEmpty());
+    AssertionError error = expectAssertionError(() -> assertThat(listAsObject).as("oops").asList().isEmpty());
     // THEN
-    assertThat(error).hasMessageContaining("oops");
+    then(error).hasMessageContaining("oops");
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_asString_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_asString_Test.java
index 3d38337cd..b504825af 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_asString_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_asString_Test.java
@@ -13,39 +13,43 @@
 package org.assertj.tests.core.api;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 
 import org.junit.jupiter.api.Test;
 
-/**
- * Tests for Assert.asString() methods
- */
 class Assertions_assertThat_asString_Test {
 
   @Test
-  void should_pass_string_asserts_on_string_objects_with_asString() {
+  void should_allow_string_assertions() {
+    // GIVEN
     Object stringAsObject = "hello world";
-    assertThat(stringAsObject).asString().contains("hello");
+    // WHEN/THEN
+    then(stringAsObject).asString()
+                        .startsWith("hello")
+                        .endsWith("world");
   }
 
   @Test
-  void should_pass_string_asserts_on_non_string_objects_with_asString() {
+  void should_allow_string_assertions_on_object_string_representation() {
+    // GIVEN
     Object nonString = new Object();
-    assertThat(nonString).asString().isEqualTo(nonString.toString());
+    // WHEN/THEN
+    then(nonString).asString().startsWith(nonString.toString());
   }
 
   @Test
-  void should_fail_string_asserts_on_non_string_objects_with_asString() {
-    Object nonString = new Object();
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(nonString).asString()
-                                                                                          .contains("probably not this"));
+  void should_fail_if_actual_is_null() {
+    expectAssertionError(() -> assertThat((Object) null).asString().isEqualTo("never gonna happen"));
   }
 
   @Test
-  void should_fail_if_actual_is_null_with_asString() {
-    Object nullObject = null;
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(nullObject).asString()
-                                                                                           .isEqualTo("never gonna happen"));
+  public void should_keep_existing_description_set_before_calling_asString() {
+    // GIVEN
+    String description = "My description";
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat("foo").as(description).asString().isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining(description);
   }
-
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inBinary_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inBinary_Test.java
index f3c78b1fa..afa2ab7a7 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inBinary_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inBinary_Test.java
@@ -131,4 +131,14 @@ class Assertions_assertThat_inBinary_Test {
                                                          "\"['0b00000000_01100001', '0b00000000_00110110']\""));
   }
 
+  @Test
+  public void should_keep_existing_description_set_before_calling_inBinary() {
+    // GIVEN
+    String description = "My description";
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat("ab").as(description).inBinary().isNull());
+    // THEN
+    then(assertionError).hasMessageContaining(description);
+  }
+
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inHexadecimal_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inHexadecimal_Test.java
index 17de4d2bc..60c2fcefe 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inHexadecimal_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inHexadecimal_Test.java
@@ -14,10 +14,12 @@ package org.assertj.tests.core.api;
 
 import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.tests.core.testkit.ErrorMessagesForTest.shouldBeEqualMessage;
+import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 
 import java.util.List;
+
 import org.junit.jupiter.api.Test;
 
 /**
@@ -27,147 +29,185 @@ class Assertions_assertThat_inHexadecimal_Test {
 
   @Test
   void should_assert_byte_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat((byte) 2).inHexadecimal()
-                                                                                         .isEqualTo((byte) 3))
-                                                   .withMessage(shouldBeEqualMessage("0x02", "0x03"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat((byte) 2).inHexadecimal().isEqualTo((byte) 3));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("0x02", "0x03"));
 
   }
 
   @Test
   void should_assert_signed_byte_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat((byte) -2).inHexadecimal()
-                                                                                          .isEqualTo((byte) 3))
-                                                   .withMessage(shouldBeEqualMessage("0xFE", "0x03"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat((byte) -2).inHexadecimal().isEqualTo((byte) 3));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("0xFE", "0x03"));
   }
 
   @Test
   void should_assert_bytes_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(new byte[] { 2, 3 }).inHexadecimal()
-                                                                                                    .isEqualTo(new byte[] { 1 }))
-                                                   .withMessage(shouldBeEqualMessage("[0x02, 0x03]", "[0x01]"));
-  }
-
-  @Test
-  void should_assert_bytes_contains_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(new byte[] { 2, 3 }).inHexadecimal()
-                                                                                                    .contains(new byte[] { 1 }))
-                                                   .withMessage(format("%nExpecting byte[]:%n" +
-                                                                       "  [0x02, 0x03]%n"
-                                                                       + "to contain:%n" +
-                                                                       "  [0x01]%n" +
-                                                                       "but could not find the following byte(s):%n" +
-                                                                       "  [0x01]%n"));
+    // GIVEN
+    byte[] actual = { 2, 3 };
+    byte expected = 1;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).inHexadecimal().contains(expected));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting byte[]:%n" +
+                                           "  [0x02, 0x03]%n" +
+                                           "to contain:%n" +
+                                           "  [0x01]%n" +
+                                           "but could not find the following byte(s):%n" +
+                                           "  [0x01]%n"));
   }
 
   @Test
   void should_assert_short_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat((short) 2).inHexadecimal()
-                                                                                          .isEqualTo((short) 3))
-                                                   .withMessage(shouldBeEqualMessage("0x0002", "0x0003"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat((short) 2).inHexadecimal().isEqualTo((short) 3));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("0x0002", "0x0003"));
   }
 
   @Test
   void should_assert_signed_short_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat((short) -2).inHexadecimal()
-                                                                                           .isEqualTo((short) 3))
-                                                   .withMessage(shouldBeEqualMessage("0xFFFE", "0x0003"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat((short) -2).inHexadecimal().isEqualTo((short) 3));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("0xFFFE", "0x0003"));
   }
 
   @Test
   void should_assert_shorts_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(new short[] { (short) 1,
-        (short) 2 }).inHexadecimal().isEqualTo(new short[] { (short) 3 }))
-                                                   .withMessage(shouldBeEqualMessage("[0x0001, 0x0002]",
-                                                                                     "[0x0003]"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(new short[] { (short) 1,
+        (short) 2 }).inHexadecimal().isEqualTo(new short[] { (short) 3 }));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("[0x0001, 0x0002]", "[0x0003]"));
   }
 
   @Test
   void should_assert_integer_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(2).inHexadecimal().isEqualTo(3))
-                                                   .withMessage(shouldBeEqualMessage("0x0000_0002", "0x0000_0003"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(2).inHexadecimal().isEqualTo(3));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("0x0000_0002", "0x0000_0003"));
   }
 
   @Test
   void should_assert_integers_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(new int[] { 1, 2 }).inHexadecimal()
-                                                                                                   .isEqualTo(new int[] { 2 }))
-                                                   .withMessage(shouldBeEqualMessage("[0x0000_0001, 0x0000_0002]",
-                                                                                     "[0x0000_0002]"));
+    // GIVEN
+    int[] actual = { 1, 2 };
+    int[] expected = { 2 };
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).inHexadecimal().isEqualTo(expected));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("[0x0000_0001, 0x0000_0002]", "[0x0000_0002]"));
   }
 
   @Test
   void should_assert_long_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(Long.MAX_VALUE).inHexadecimal()
-                                                                                               .isEqualTo(Long.MIN_VALUE))
-                                                   .withMessage(shouldBeEqualMessage("0x7FFF_FFFF_FFFF_FFFF",
-                                                                                     "0x8000_0000_0000_0000"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(Long.MAX_VALUE).inHexadecimal()
+                                                                                         .isEqualTo(Long.MIN_VALUE));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("0x7FFF_FFFF_FFFF_FFFF", "0x8000_0000_0000_0000"));
   }
 
   @Test
   void should_assert_signed_long_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(-2L).inHexadecimal().isEqualTo(2L))
-                                                   .withMessage(shouldBeEqualMessage("0xFFFF_FFFF_FFFF_FFFE",
-                                                                                     "0x0000_0000_0000_0002"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(-2L).inHexadecimal().isEqualTo(2L));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("0xFFFF_FFFF_FFFF_FFFE", "0x0000_0000_0000_0002"));
   }
 
   @Test
   void should_assert_longs_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(new long[] { -1L,
-        2L }).inHexadecimal().isEqualTo(new long[] { 3L }))
-                                                   .withMessage(shouldBeEqualMessage("[0xFFFF_FFFF_FFFF_FFFF, 0x0000_0000_0000_0002]",
-                                                                                     "[0x0000_0000_0000_0003]"));
+    // GIVEN
+    long[] actual = { -1L, 2L };
+    long[] expected = { 3L };
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).inHexadecimal().isEqualTo(expected));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("[0xFFFF_FFFF_FFFF_FFFF, 0x0000_0000_0000_0002]",
+                                                         "[0x0000_0000_0000_0003]"));
   }
 
   @Test
   void should_assert_float_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(4.3f).inHexadecimal().isEqualTo(2.3f))
-                                                   .withMessage(shouldBeEqualMessage("0x4089_999A", "0x4013_3333"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(4.3f).inHexadecimal().isEqualTo(2.3f));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("0x4089_999A", "0x4013_3333"));
   }
 
   @Test
   void should_assert_floats_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(new float[] { 4.3f, -2f }).inHexadecimal()
-                                                                                                          .isEqualTo(new float[] {
-                                                                                                              4.1f }))
-                                                   .withMessage(shouldBeEqualMessage("[0x4089_999A, 0xC000_0000]",
-                                                                                     "[0x4083_3333]"));
+    // GIVEN
+    float[] actual = { 4.3f, -2f };
+    float[] expected = { 4.1f };
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).inHexadecimal().isEqualTo(expected));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("[0x4089_999A, 0xC000_0000]", "[0x4083_3333]"));
   }
 
   @Test
   void should_assert_double_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(4.3d).inHexadecimal().isEqualTo(2.3d))
-                                                   .withMessage(shouldBeEqualMessage("0x4011_3333_3333_3333",
-                                                                                     "0x4002_6666_6666_6666"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(4.3d).inHexadecimal().isEqualTo(2.3d));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("0x4011_3333_3333_3333", "0x4002_6666_6666_6666"));
   }
 
   @Test
   void should_assert_doubles_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(new double[] { 1d, 2d }).inHexadecimal()
-                                                                                                        .isEqualTo(new double[] {
-                                                                                                            3d }))
-                                                   .withMessage(shouldBeEqualMessage("[0x3FF0_0000_0000_0000, 0x4000_0000_0000_0000]",
-                                                                                     "[0x4008_0000_0000_0000]"));
+    // GIVEN
+    double[] actual = { 1d, 2d };
+    double[] expected = { 3d };
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).inHexadecimal().isEqualTo(expected));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("[0x3FF0_0000_0000_0000, 0x4000_0000_0000_0000]",
+                                                         "[0x4008_0000_0000_0000]"));
   }
 
   @Test
   void should_assert_collections_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(List.of(1, 2)).inHexadecimal()
-                                                                                              .isEqualTo(List.of(3)))
-                                                   .withMessage(shouldBeEqualMessage("[0x0000_0001, 0x0000_0002]",
-                                                                                     "[0x0000_0003]"));
+    // GIVEN
+    List<Integer> actual = List.of(1, 2);
+    List<Integer> expected = List.of(3);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).inHexadecimal().isEqualTo(expected));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("[0x0000_0001, 0x0000_0002]", "[0x0000_0003]"));
   }
 
   @Test
   void should_assert_Character_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat('a').inHexadecimal().isEqualTo('b'))
-                                                   .withMessage(shouldBeEqualMessage("'0x0061'", "'0x0062'"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat('a').inHexadecimal().isEqualTo('b'));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("'0x0061'", "'0x0062'"));
   }
 
   @Test
   void should_assert_String_in_hexadecimal() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat("a6c").inHexadecimal().isEqualTo("abc"))
-                                                   .withMessage(shouldBeEqualMessage("\"['0x0061', '0x0036', '0x0063']\"",
-                                                                                     "\"['0x0061', '0x0062', '0x0063']\""));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat("a6c").inHexadecimal().isEqualTo("abc"));
+    // THEN
+    then(assertionError).hasMessage(shouldBeEqualMessage("\"['0x0061', '0x0036', '0x0063']\"",
+                                                         "\"['0x0061', '0x0062', '0x0063']\""));
+  }
+
+  @Test
+  public void should_keep_existing_description_set_before_calling_inHexadecimal() {
+    // GIVEN
+    String description = "My description";
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat("ab").as(description).inHexadecimal().isNull());
+    // THEN
+    then(assertionError).hasMessageContaining(description);
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inUnicode_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inUnicode_Test.java
index 7e2eda597..bbcd8226b 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inUnicode_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_assertThat_inUnicode_Test.java
@@ -12,13 +12,13 @@
  */
 package org.assertj.tests.core.api;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.tests.core.testkit.ErrorMessagesForTest.shouldBeEqualMessage;
 import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 
+import org.junit.jupiter.api.Test;
+
 /**
  * Tests for {@link org.assertj.core.presentation.UnicodeRepresentation#toStringOf(Object)}.
  *
@@ -60,4 +60,15 @@ class Assertions_assertThat_inUnicode_Test {
     // THEN
     then(assertionError).hasMessage(shouldBeEqualMessage("[a, 6, c]", "[a, b, \\u00f3]"));
   }
+
+  @Test
+  public void should_keep_existing_description_set_before_calling_inUnicode() {
+    // GIVEN
+    String description = "My description";
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat("ab").as(description).inUnicode().isNull());
+    // THEN
+    then(assertionError).hasMessageContaining(description);
+  }
+
 }
