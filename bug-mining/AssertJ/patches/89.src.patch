diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 3fb551b02..2f3e3033e 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -317,7 +317,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
 	iterables.assertAreAtLeast(info, actual, times, condition);
 	return myself;
   }
-  
+
   /**
    * {@inheritDoc}
    */
@@ -501,7 +501,9 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * </code></pre>
    * <p/>
    * A property with the given name is looked for first, if it doesn't exist then a field with the given name is looked
-   * for, if no field accessible (ie. does not exist or is not public) an IntrospectionError is thrown.
+   * for, if the field does not exist an {@link IntrospectionError} is thrown, by default private fields are read but
+   * you can change this with {@link Assertions#setAllowComparingPrivateFields(boolean)}, trying to read a private field
+   * when it's not allowed leads to an {@link IntrospectionError}.
    * <p/>
    * It only works if <b>all</b> objects have the field or all objects have the property with the given name, i.e. it
    * won't work if half of the objects have the field and the other the property.
@@ -509,8 +511,45 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * Note that the order of extracted property/field values is consistent with the iteration order of the Iterable under
    * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions on the extracted values
    * order.
+   * <hr>
+   * <p/>
+   * Extracting also support maps, that is, instead of extracting values from an Object, it extract maps values
+   * corresponding to the given keys.
+   * <p/>
+   * Example:
+   * 
+   * <pre><code class='java'>
+   * Employee yoda = new Employee(1L, new Name("Yoda"), 800);
+   * Employee luke = new Employee(2L, new Name("Luke"), 22);
+   * Employee han = new Employee(3L, new Name("Han"), 31);
+   * 
+   * // build two maps
+   * Map&lt;String, Employee&gt; map1 = new HashMap&lt;&gt;();
+   * map1.put("key1", yoda);
+   * map1.put("key2", luke);
+   * 
+   * Map&lt;String, Employee&gt; map2 = new HashMap&lt;&gt;();
+   * map2.put("key1", yoda);
+   * map2.put("key2", han);
+   * 
+   * // instead of a list of objects, we have a list of maps 
+   * List&lt;Map&lt;String, Employee&gt;&gt; maps = asList(map1, map2);
+   * 
+   * // extracting a property in that case = get values from maps using property as a key
+   * assertThat(maps).extracting("key2").containsExactly(luke, han);
+   * assertThat(maps).extracting("key1").containsExactly(yoda, yoda);
+   * 
+   * // type safe version
+   * assertThat(maps).extracting(key2, Employee.class).containsExactly(luke, han); 
+   * 
+   * // it works with several keys, extracted values being wrapped in a Tuple
+   * assertThat(maps).extracting("key1", "key2").containsExactly(tuple(yoda, luke), tuple(yoda, han));
+   * 
+   * // unknown keys leads to null (map behavior)
+   * assertThat(maps).extracting("bad key").containsExactly(null, null);
+   * </code></pre>
    *
-   * @param propertyOrField the property/field to extract from the Iterable under test
+   * @param propertyOrField the property/field to extract from the elements of the Iterable under test
    * @return a new assertion object whose object under test is the list of extracted property/field values.
    * @throws IntrospectionError if no field or property exists with the given name (or field exists but is not public)
    *           in one of the initial Iterable's element.
@@ -655,7 +694,9 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * </code></pre>
    * 
    * A property with the given name is looked for first, if it doesn't exist then a field with the given name is looked
-   * for, if no field accessible (ie. does not exist or is not public) an IntrospectionError is thrown.
+   * for, if the field does not exist an {@link IntrospectionError} is thrown, by default private fields are read but
+   * you can change this with {@link Assertions#setAllowComparingPrivateFields(boolean)}, trying to read a private field
+   * when it's not allowed leads to an {@link IntrospectionError}.
    * <p/>
    * It only works if <b>all</b> objects have the field or all objects have the property with the given name, i.e. it
    * won't work if half of the objects have the field and the other the property.
@@ -663,6 +704,43 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * Note that the order of extracted property/field values is consistent with the iteration order of the Iterable under
    * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions on the extracted values
    * order.
+   * <hr>
+   * <p/>
+   * Extracting also support maps, that is, instead of extracting values from an Object, it extract maps values
+   * corresponding to the given keys.
+   * <p/>
+   * Example:
+   * 
+   * <pre><code class='java'>
+   * Employee yoda = new Employee(1L, new Name("Yoda"), 800);
+   * Employee luke = new Employee(2L, new Name("Luke"), 22);
+   * Employee han = new Employee(3L, new Name("Han"), 31);
+   * 
+   * // build two maps
+   * Map&lt;String, Employee&gt; map1 = new HashMap&lt;&gt;();
+   * map1.put("key1", yoda);
+   * map1.put("key2", luke);
+   * 
+   * Map&lt;String, Employee&gt; map2 = new HashMap&lt;&gt;();
+   * map2.put("key1", yoda);
+   * map2.put("key2", han);
+   * 
+   * // instead of a list of objects, we have a list of maps 
+   * List&lt;Map&lt;String, Employee&gt;&gt; maps = asList(map1, map2);
+   * 
+   * // extracting a property in that case = get values from maps using property as a key
+   * assertThat(maps).extracting(key2, Employee.class).containsExactly(luke, han); 
+   * 
+   * // non type safe version
+   * assertThat(maps).extracting("key2").containsExactly(luke, han);
+   * assertThat(maps).extracting("key1").containsExactly(yoda, yoda);
+   * 
+   * // it works with several keys, extracted values being wrapped in a Tuple
+   * assertThat(maps).extracting("key1", "key2").containsExactly(tuple(yoda, luke), tuple(yoda, han));
+   * 
+   * // unknown keys leads to null (map behavior)
+   * assertThat(maps).extracting("bad key").containsExactly(null, null);
+   * </code></pre>
    *
    * @param propertyOrField the property/field to extract from the Iterable under test
    * @param extractingType type to return
@@ -719,8 +797,10 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *                                          tuple(&quot;Legolas&quot;, 1000, &quot;Elf&quot;));
    * </code></pre>
    * 
-   * A property with the given name is looked for first, if it does'nt exist then a field with the given name is looked
-   * for, if no field accessible (ie. does not exist or is not public) an IntrospectionError is thrown.
+   * A property with the given name is looked for first, if it doesn't exist then a field with the given name is looked
+   * for, if the field does not exist an {@link IntrospectionError} is thrown, by default private fields are read but
+   * you can change this with {@link Assertions#setAllowComparingPrivateFields(boolean)}, trying to read a private field
+   * when it's not allowed leads to an {@link IntrospectionError}.
    * <p/>
    * It only works if <b>all</b> objects have the field or all objects have the property with the given name, i.e. it
    * won't work if half of the objects have the field and the other the property.
@@ -728,8 +808,42 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * Note that the order of extracted property/field values is consistent with the iteration order of the Iterable under
    * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions on the extracted values
    * order.
+   * <hr>
+   * <p/>
+   * Extracting also support maps, that is, instead of extracting values from an Object, it extract maps values
+   * corresponding to the given keys.
+   * <p/>
+   * Example:
+   * 
+   * <pre><code class='java'>
+   * Employee yoda = new Employee(1L, new Name("Yoda"), 800);
+   * Employee luke = new Employee(2L, new Name("Luke"), 22);
+   * Employee han = new Employee(3L, new Name("Han"), 31);
+   * 
+   * // build two maps
+   * Map&lt;String, Employee&gt; map1 = new HashMap&lt;&gt;();
+   * map1.put("key1", yoda);
+   * map1.put("key2", luke);
+   * 
+   * Map&lt;String, Employee&gt; map2 = new HashMap&lt;&gt;();
+   * map2.put("key1", yoda);
+   * map2.put("key2", han);
+   * 
+   * // instead of a list of objects, we have a list of maps 
+   * List&lt;Map&lt;String, Employee&gt;&gt; maps = asList(map1, map2);
+   * 
+   * // extracting a property in that case = get values from maps using property as a key
+   * assertThat(maps).extracting("key2").containsExactly(luke, han);
+   * assertThat(maps).extracting("key1").containsExactly(yoda, yoda);
+   * 
+   * // it works with several keys, extracted values being wrapped in a Tuple
+   * assertThat(maps).extracting("key1", "key2").containsExactly(tuple(yoda, luke), tuple(yoda, han));
+   * 
+   * // unknown keys leads to null (map behavior)
+   * assertThat(maps).extracting("bad key").containsExactly(null, null);
+   * </code></pre>
    *
-   * @param propertiesOrFields the properties/fields to extract from the initial Iterable under test
+   * @param propertiesOrFields the properties/fields to extract from the elements of the Iterable under test
    * @return a new assertion object whose object under test is the list of Tuple with extracted properties/fields values
    *         as data.
    * @throws IntrospectionError if one of the given name does not match a field or property (or field exists but is not
@@ -952,8 +1066,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * <p/>
    * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
    * (e.g. public) or fields with an accessible getter.<br/>
-   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other field
-   * using its <code>equals</code> method.
+   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
+   * field using its <code>equals</code> method.
    * </p>
    * Example:
    *
diff --git a/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java b/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
index 0266df29f..7775cc6a4 100644
--- a/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
+++ b/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
@@ -19,37 +19,45 @@ import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.util.introspection.FieldSupport;
 import org.assertj.core.util.introspection.IntrospectionError;
 
+import java.util.Map;
+
 class ByNameSingleExtractor<T> implements Extractor<T, Object> {
   private final String propertyOrFieldName;
 
   ByNameSingleExtractor(String propertyOrFieldName) {
-    this.propertyOrFieldName = propertyOrFieldName;
+	this.propertyOrFieldName = propertyOrFieldName;
   }
 
   @Override
   public Object extract(T input) {
-    if (propertyOrFieldName == null)
-      throw new IllegalArgumentException("The name of the field/property to read should not be null");
-    if (propertyOrFieldName.length() == 0)
-      throw new IllegalArgumentException("The name of the field/property to read should not be empty");
-    if (input == null)
-      throw new IllegalArgumentException("The object to extract field/property from should not be null");
-
-    // first try to get given property values from objects, then try properties
-    try {
-      return PropertySupport.instance().propertyValueOf(propertyOrFieldName, Object.class, input);
-    } catch (IntrospectionError fieldIntrospectionError) {
-      // no luck with properties, let's try fields
-      try {
-        return FieldSupport.extraction().fieldValue(propertyOrFieldName, Object.class, input);
-      } catch (IntrospectionError propertyIntrospectionError) {
-        // no field nor property found with given name, it is considered as an error
-        String message = format(
-            "\nCan't find any field or property with name '%s'.\nError when introspecting fields was :\n- %s \nError when introspecting properties was :\n- %s",
-            propertyOrFieldName, fieldIntrospectionError.getMessage(), propertyIntrospectionError.getMessage());
-        throw new IntrospectionError(message);
-      }
-    }
+	if (propertyOrFieldName == null)
+	  throw new IllegalArgumentException("The name of the field/property to read should not be null");
+	if (propertyOrFieldName.length() == 0)
+	  throw new IllegalArgumentException("The name of the field/property to read should not be empty");
+	if (input == null)
+	  throw new IllegalArgumentException("The object to extract field/property from should not be null");
+
+	// if input is a map, use propertyOrFieldName as a key
+	if (input instanceof Map) {
+	  Map<?, ?> map = (Map<?, ?>) input;
+	  return map.get(propertyOrFieldName);
+	}
+
+	// first try to get given property values from objects, then try properties
+	try {
+	  return PropertySupport.instance().propertyValueOf(propertyOrFieldName, Object.class, input);
+	} catch (IntrospectionError fieldIntrospectionError) {
+	  // no luck with properties, let's try fields
+	  try {
+		return FieldSupport.extraction().fieldValue(propertyOrFieldName, Object.class, input);
+	  } catch (IntrospectionError propertyIntrospectionError) {
+		// no field nor property found with given name, it is considered as an error
+		String message = format("\nCan't find any field or property with name '%s'.\nError when introspecting fields was :\n- %s \nError when introspecting properties was :\n- %s",
+		                        propertyOrFieldName, fieldIntrospectionError.getMessage(),
+		                        propertyIntrospectionError.getMessage());
+		throw new IntrospectionError(message);
+	  }
+	}
   }
 
 }
diff --git a/src/test/java/org/assertj/core/extractor/ByNameMultipleExtractorTest.java b/src/test/java/org/assertj/core/extractor/ByNameMultipleExtractorTest.java
index 4c267eed6..df374afd6 100644
--- a/src/test/java/org/assertj/core/extractor/ByNameMultipleExtractorTest.java
+++ b/src/test/java/org/assertj/core/extractor/ByNameMultipleExtractorTest.java
@@ -12,9 +12,14 @@
  */
 package org.assertj.core.extractor;
 
+import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.*;
 import static org.assertj.core.test.ExpectedException.*;
 
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
 import org.assertj.core.api.iterable.Extractor;
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.test.Employee;
@@ -24,56 +29,74 @@ import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.Rule;
 import org.junit.Test;
 
-
 public class ByNameMultipleExtractorTest {
-  
+
   @Rule
   public ExpectedException thrown = none();
-  
+
   private Employee yoda = new Employee(1L, new Name("Yoda"), 800);
-  
+
   @Test
   public void should_extract_tuples_from_fields_or_properties() {
-    Extractor<Employee, Tuple> extractor = new ByNameMultipleExtractor<Employee>("id", "age");
-    
-    Tuple extractedValue = extractor.extract(yoda);
-    assertThat(extractedValue).isEqualTo(tuple(1L, 800));
+	Extractor<Employee, Tuple> extractor = new ByNameMultipleExtractor<Employee>("id", "age");
+
+	Tuple extractedValue = extractor.extract(yoda);
+	assertThat(extractedValue).isEqualTo(tuple(1L, 800));
   }
-  
+
   @Test
   public void should_extract_tuples_with_consistent_iteration_order() {
-    Extractor<Employee, Tuple> extractor = new ByNameMultipleExtractor<Employee>("id", "name.first", "age");
+	Extractor<Employee, Tuple> extractor = new ByNameMultipleExtractor<Employee>("id", "name.first", "age");
 
-    Tuple extractedValues = extractor.extract(yoda);
-    assertThat(extractedValues).isEqualTo(tuple(1L, "Yoda", 800));
+	Tuple extractedValues = extractor.extract(yoda);
+	assertThat(extractedValues).isEqualTo(tuple(1L, "Yoda", 800));
   }
-  
+
   @Test
   public void should_throw_error_when_no_property_nor_public_field_match_one_of_given_names() {
-    thrown.expect(IntrospectionError.class);
-    
-    new ByNameMultipleExtractor<Employee>("id", "name.first", "unknown").extract(yoda);
+	thrown.expect(IntrospectionError.class);
+
+	new ByNameMultipleExtractor<Employee>("id", "name.first", "unknown").extract(yoda);
   }
-  
+
   @Test
   public void should_throw_exception_when_given_name_is_null() {
-    thrown.expectIllegalArgumentException("The names of the fields/properties to read should not be null");
+	thrown.expectIllegalArgumentException("The names of the fields/properties to read should not be null");
 
-    new ByNameMultipleExtractor<Employee>((String[]) null).extract(yoda);
+	new ByNameMultipleExtractor<Employee>((String[]) null).extract(yoda);
   }
-  
+
   @Test
   public void should_throw_exception_when_given_name_is_empty() {
-    thrown.expectIllegalArgumentException("The names of the fields/properties to read should not be empty");
+	thrown.expectIllegalArgumentException("The names of the fields/properties to read should not be empty");
 
-    new ByNameMultipleExtractor<Employee>(new String[0]).extract(yoda);
+	new ByNameMultipleExtractor<Employee>(new String[0]).extract(yoda);
   }
-  
+
   @Test
   public void should_throw_exception_when_no_object_is_given() throws Exception {
-    thrown.expectIllegalArgumentException("The object to extract fields/properties from should not be null");
-    
-    new ByNameMultipleExtractor<Employee>("id", "name.first", "age").extract(null);
+	thrown.expectIllegalArgumentException("The object to extract fields/properties from should not be null");
+
+	new ByNameMultipleExtractor<Employee>("id", "name.first", "age").extract(null);
+  }
+
+  @Test
+  public void should_extract_multiple_values_from_maps_by_keys() {
+	String key1 = "key1";
+	String key2 = "key2";
+	Map<String, Employee> map1 = new HashMap<>();
+	map1.put(key1, yoda);
+	Employee luke = new Employee(2L, new Name("Luke"), 22);
+	map1.put(key2, luke);
+
+	Map<String, Employee> map2 = new HashMap<>();
+	map2.put(key1, yoda);
+	Employee han = new Employee(3L, new Name("Han"), 31);
+	map2.put(key2, han);
+
+	List<Map<String, Employee>> maps = asList(map1, map2);
+	assertThat(maps).extracting(key1, key2, "bad key").containsExactly(tuple(yoda, luke, null),
+	                                                                   tuple(yoda, han, null));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/extractor/ByNameSingleExtractorTest.java b/src/test/java/org/assertj/core/extractor/ByNameSingleExtractorTest.java
index 051b8dc5f..2712ce48f 100644
--- a/src/test/java/org/assertj/core/extractor/ByNameSingleExtractorTest.java
+++ b/src/test/java/org/assertj/core/extractor/ByNameSingleExtractorTest.java
@@ -12,7 +12,12 @@
  */
 package org.assertj.core.extractor;
 
-import static org.assertj.core.api.Assertions.*;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
@@ -22,127 +27,145 @@ import org.junit.Rule;
 import org.junit.Test;
 
 public class ByNameSingleExtractorTest {
-  private static final Employee yoda = new Employee(1L, new Name("Yoda"), 800);;
+  private static final Employee yoda = new Employee(1L, new Name("Yoda"), 800);
 
   @Rule
   public ExpectedException thrown = ExpectedException.none();
 
   @Test
   public void should_extract_field_values_even_if_property_exist() {
-    Object extractedValues = idExtractor().extract(yoda);
+	Object extractedValues = idExtractor().extract(yoda);
 
-    assertThat(extractedValues).isEqualTo(1L);
+	assertThat(extractedValues).isEqualTo(1L);
   }
 
   @Test
   public void should_extract_property_values_when_no_public_field_match_given_name() {
-    Object extractedValues = ageExtractor().extract(yoda);
+	Object extractedValues = ageExtractor().extract(yoda);
 
-    assertThat(extractedValues).isEqualTo(800);
+	assertThat(extractedValues).isEqualTo(800);
   }
 
   @Test
   public void should_extract_pure_property_values() {
-    Object extractedValues = adultExtractor().extract(yoda);
+	Object extractedValues = adultExtractor().extract(yoda);
 
-    assertThat(extractedValues).isEqualTo(true);
+	assertThat(extractedValues).isEqualTo(true);
   }
 
   @Test
   public void should_throw_error_when_no_property_nor_public_field_match_given_name() {
-    thrown.expect(IntrospectionError.class);
+	thrown.expect(IntrospectionError.class);
 
-    new ByNameSingleExtractor<Employee>("unknown").extract(yoda);
+	new ByNameSingleExtractor<Employee>("unknown").extract(yoda);
   }
 
   @Test
   public void should_throw_exception_when_given_name_is_null() {
-    thrown.expectIllegalArgumentException("The name of the field/property to read should not be null");
+	thrown.expectIllegalArgumentException("The name of the field/property to read should not be null");
 
-    new ByNameSingleExtractor<Employee>(null).extract(yoda);
+	new ByNameSingleExtractor<Employee>(null).extract(yoda);
   }
 
   @Test
   public void should_throw_exception_when_given_name_is_empty() {
-    thrown.expectIllegalArgumentException("The name of the field/property to read should not be empty");
+	thrown.expectIllegalArgumentException("The name of the field/property to read should not be empty");
 
-    new ByNameSingleExtractor<Employee>("").extract(yoda);
+	new ByNameSingleExtractor<Employee>("").extract(yoda);
   }
 
   @Test
   public void should_fallback_to_field_if_exception_has_been_thrown_on_property_access() throws Exception {
-    Object extractedValue = nameExtractor().extract(employeeWithBrokenName("Name"));
+	Object extractedValue = nameExtractor().extract(employeeWithBrokenName("Name"));
 
-    assertThat(extractedValue).isEqualTo(new Name("Name"));
+	assertThat(extractedValue).isEqualTo(new Name("Name"));
   }
 
   @Test
   public void should_prefer_properties_over_fields() throws Exception {
-    Object extractedValue = nameExtractor().extract(employeeWithOverridenName("Overriden Name"));
+	Object extractedValue = nameExtractor().extract(employeeWithOverridenName("Overriden Name"));
 
-    assertThat(extractedValue).isEqualTo(new Name("Overriden Name"));
+	assertThat(extractedValue).isEqualTo(new Name("Overriden Name"));
   }
 
   @Test
   public void should_throw_exception_if_property_cannot_be_extracted_due_to_runtime_exception_during_property_access()
-      throws Exception {
-    thrown.expect(IntrospectionError.class);
+	  throws Exception {
+	thrown.expect(IntrospectionError.class);
 
-    Employee employee = brokenEmployee();
-    adultExtractor().extract(employee);
+	Employee employee = brokenEmployee();
+	adultExtractor().extract(employee);
   }
 
   @Test
   public void should_throw_exception_if_no_object_is_given() throws Exception {
-    thrown.expect(IllegalArgumentException.class);
+	thrown.expect(IllegalArgumentException.class);
 
-    idExtractor().extract(null);
+	idExtractor().extract(null);
   }
 
-  private Employee employeeWithBrokenName(String name) {
-    return new Employee(1L, new Name(name), 0) {
+  @Test
+  public void should_extract_single_value_from_maps_by_key() {
+	String key1 = "key1";
+	String key2 = "key2";
+	Map<String, Employee> map1 = new HashMap<>();
+	map1.put(key1, yoda);
+	Employee luke = new Employee(2L, new Name("Luke"), 22);
+	map1.put(key2, luke);
+
+	Map<String, Employee> map2 = new HashMap<>();
+	map2.put(key1, yoda);
+	Employee han = new Employee(3L, new Name("Han"), 31);
+	map2.put(key2, han);
+
+	List<Map<String, Employee>> maps = asList(map1, map2);
+	assertThat(maps).extracting(key2).containsExactly(luke, han);
+	assertThat(maps).extracting(key2, Employee.class).containsExactly(luke, han);
+	assertThat(maps).extracting(key1).containsExactly(yoda, yoda);
+	assertThat(maps).extracting("bad key").containsExactly(null, null);
+  }
 
-      @Override
-      public Name getName() {
-        throw new IllegalStateException();
-      }
-    };
+  private Employee employeeWithBrokenName(String name) {
+	return new Employee(1L, new Name(name), 0) {
+	  @Override
+	  public Name getName() {
+		throw new IllegalStateException();
+	  }
+	};
   }
 
   private Employee employeeWithOverridenName(final String overridenName) {
-    return new Employee(1L, new Name("Name"), 0) {
-
-      @Override
-      public Name getName() {
-        return new Name(overridenName);
-      }
-    };
+	return new Employee(1L, new Name("Name"), 0) {
+	  @Override
+	  public Name getName() {
+		return new Name(overridenName);
+	  }
+	};
   }
 
   private Employee brokenEmployee() {
-    return new Employee() {
-
-      @Override
-      public boolean isAdult() {
-        throw new IllegalStateException();
-      }
-    };
+	return new Employee() {
+	  @Override
+	  public boolean isAdult() {
+		throw new IllegalStateException();
+	  }
+	};
   }
 
   private ByNameSingleExtractor<Employee> idExtractor() {
-    return new ByNameSingleExtractor<Employee>("id");
+	return new ByNameSingleExtractor<Employee>("id");
   }
 
   private ByNameSingleExtractor<Employee> ageExtractor() {
-    return new ByNameSingleExtractor<Employee>("age");
+	return new ByNameSingleExtractor<Employee>("age");
   }
 
   private ByNameSingleExtractor<Employee> adultExtractor() {
-    return new ByNameSingleExtractor<Employee>("adult");
+	return new ByNameSingleExtractor<Employee>("adult");
   }
 
   private ByNameSingleExtractor<Employee> nameExtractor() {
-    return new ByNameSingleExtractor<Employee>("name");
+	return new ByNameSingleExtractor<Employee>("name");
   }
 
 }
