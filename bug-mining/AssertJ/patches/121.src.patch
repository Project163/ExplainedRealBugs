diff --git a/src/main/java/org/assertj/core/api/AbstractDateAssert.java b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
index 159855656..e880cf7ab 100644
--- a/src/main/java/org/assertj/core/api/AbstractDateAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
@@ -2344,6 +2344,46 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
     return withDateFormat(new SimpleDateFormat(userCustomDateFormatPattern));
   }
 
+  /**
+   * Instead of using default strict date/time parsing, it is possible to use lenient parsing mode for default date
+   * formats parser to interpret inputs that do not precisely match supported date formats (lenient parsing).
+   * <p/>
+   * With strict parsing, inputs must match exactly date/time format.
+   *
+   * <p>
+   * Example:
+   * </p>
+   *
+   * <pre><code class='java'>
+   * final Date date = Dates.parse("2001-02-03");
+   * final Date dateTime = parseDatetime("2001-02-03T04:05:06");
+   * final Date dateTimeWithMs = parseDatetimeWithMs("2001-02-03T04:05:06.700");
+   *
+   * AbstractDateAssert.setLenientDateParsing(true);
+   *
+   * // assertions will pass
+   * assertThat(date).isEqualTo("2001-01-34");
+   * assertThat(date).isEqualTo("2001-02-02T24:00:00");
+   * assertThat(date).isEqualTo("2001-02-04T-24:00:00.000");
+   * assertThat(dateTime).isEqualTo("2001-02-03T04:05:05.1000");
+   * assertThat(dateTime).isEqualTo("2001-02-03T04:04:66");
+   * assertThat(dateTimeWithMs).isEqualTo("2001-02-03T04:05:07.-300");
+   *
+   * // assertions will fail
+   * assertThat(date).hasSameTimeAs("2001-02-04"); // different date
+   * assertThat(dateTime).hasSameTimeAs("2001-02-03 04:05:06"); // leniency does not help here
+   * </code></pre>
+   *
+   * To revert to default strict date parsing, call {@code setLenientDateParsing(false)}.
+   *
+   * @param value whether lenient parsing mode should be enabled or not
+   */
+  public static void setLenientDateParsing(boolean value) {
+    for (DateFormat defaultDateFormat : DEFAULT_DATE_FORMATS) {
+      defaultDateFormat.setLenient(value);
+    }
+  }
+
   /**
    * Add the given date format to the ones used to parse date String in String based Date assertions like
    * {@link #isEqualTo(String)}.
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 07ba0ac13..99f8af124 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -88,7 +88,7 @@ public class Assertions {
    * @return the created assertion object.
    */
   public static AbstractUriAssert<?> assertThat(URI actual) {
-      return new UriAssert(actual);
+    return new UriAssert(actual);
   }
 
   /**
@@ -101,7 +101,7 @@ public class Assertions {
     return new UrlAssert(actual);
   }
 
-    /**
+  /**
    * Creates a new instance of <code>{@link BooleanAssert}</code>.
    *
    * @param actual the actual value.
@@ -935,7 +935,7 @@ public class Assertions {
   public static Offset<Byte> within(Byte value) {
     return Offset.offset(value);
   }
-  
+
   /**
    * Assertions entry point for Integer {@link Offset} to use with isCloseTo assertions.
    * <p/>
@@ -949,7 +949,7 @@ public class Assertions {
   public static Offset<Integer> within(Integer value) {
     return Offset.offset(value);
   }
-  
+
   /**
    * Assertions entry point for Short {@link Offset} to use with isCloseTo assertions.
    * <p/>
@@ -963,7 +963,7 @@ public class Assertions {
   public static Offset<Short> within(Short value) {
     return Offset.offset(value);
   }
-  
+
   /**
    * Assertions entry point for Long {@link Offset} to use with isCloseTo assertions.
    * <p/>
@@ -977,7 +977,7 @@ public class Assertions {
   public static Offset<Long> within(Long value) {
     return Offset.offset(value);
   }
-  
+
   // ------------------------------------------------------------------------------------------------------
   // Condition methods : not assertions but here to have a single entry point to all AssertJ features.
   // ------------------------------------------------------------------------------------------------------
@@ -1214,6 +1214,44 @@ public class Assertions {
   // Date formatting methods : not assertions but here to have a single entry point to all AssertJ features.
   // --------------------------------------------------------------------------------------------------
 
+  /**
+   * Instead of using default strict date/time parsing, it is possible to use lenient parsing mode for default date
+   * formats parser to interpret inputs that do not precisely match supported date formats (lenient parsing).
+   * <p/>
+   * With strict parsing, inputs must match exactly date/time format.
+   *
+   * <p>
+   * Example:
+   * </p>
+   * 
+   * <pre><code class='java'>
+   * final Date date = Dates.parse("2001-02-03");
+   * final Date dateTime = parseDatetime("2001-02-03T04:05:06");
+   * final Date dateTimeWithMs = parseDatetimeWithMs("2001-02-03T04:05:06.700");
+   *
+   * Assertions.setLenientDateParsing(true);
+   *
+   * // assertions will pass
+   * assertThat(date).isEqualTo("2001-01-34");
+   * assertThat(date).isEqualTo("2001-02-02T24:00:00");
+   * assertThat(date).isEqualTo("2001-02-04T-24:00:00.000");
+   * assertThat(dateTime).isEqualTo("2001-02-03T04:05:05.1000");
+   * assertThat(dateTime).isEqualTo("2001-02-03T04:04:66");
+   * assertThat(dateTimeWithMs).isEqualTo("2001-02-03T04:05:07.-300");
+   *
+   * // assertions will fail
+   * assertThat(date).hasSameTimeAs("2001-02-04"); // different date
+   * assertThat(dateTime).hasSameTimeAs("2001-02-03 04:05:06"); // leniency does not help here
+   * </code></pre>
+   *
+   * To revert to default strict date parsing, call {@code setLenientDateParsing(false)}.
+   *
+   * @param value whether lenient parsing mode should be enabled or not
+   */
+  public static void setLenientDateParsing(boolean value) {
+    AbstractDateAssert.setLenientDateParsing(value);
+  }
+
   /**
    * Add the given date format to the ones used to parse date String in String based Date assertions like
    * {@link org.assertj.core.api.AbstractDateAssert#isEqualTo(String)}.
@@ -1235,7 +1273,7 @@ public class Assertions {
    * {@link org.assertj.core.api.AbstractDateAssert#withDefaultDateFormatsOnly()}.
    * <p/>
    * Code examples:
-   * 
+   *
    * <pre><code class='java'>
    * Date date = ... // set to 2003 April the 26th
    * assertThat(date).isEqualTo("2003-04-26");
@@ -1338,6 +1376,5 @@ public class Assertions {
   /**
    * Creates a new </code>{@link Assertions}</code>.
    */
-  protected Assertions() {
-  }
+  protected Assertions() {}
 }
diff --git a/src/main/java/org/assertj/core/util/Dates.java b/src/main/java/org/assertj/core/util/Dates.java
index 23c71d23c..32866608a 100644
--- a/src/main/java/org/assertj/core/util/Dates.java
+++ b/src/main/java/org/assertj/core/util/Dates.java
@@ -51,14 +51,14 @@ public class Dates {
    * ISO 8601 date format (yyyy-MM-dd), example : <code>2003-04-23</code>
    */
   public static DateFormat newIsoDateFormat() {
-    return new SimpleDateFormat("yyyy-MM-dd");
+    return strictDateFormatForPattern("yyyy-MM-dd");
   }
 
   /**
    * ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code>
    */
   public static DateFormat newIsoDateTimeFormat() {
-    return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
+    return strictDateFormatForPattern("yyyy-MM-dd'T'HH:mm:ss");
   }
 
   /**
@@ -66,7 +66,7 @@ public class Dates {
    * <code>2003-04-26T03:01:02.999</code>
    */
   public static DateFormat newIsoDateTimeWithMsFormat() {
-    return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
+    return strictDateFormatForPattern("yyyy-MM-dd'T'HH:mm:ss.SSS");
   }
 
   /**
@@ -74,7 +74,13 @@ public class Dates {
    * <code>2003-04-26 03:01:02.999</code>
    */
   public static DateFormat newTimestampDateFormat() {
-    return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
+    return strictDateFormatForPattern("yyyy-MM-dd HH:mm:ss.SSS");
+  }
+
+  private static DateFormat strictDateFormatForPattern(String pattern) {
+    DateFormat dateFormat = new SimpleDateFormat(pattern);
+    dateFormat.setLenient(false);
+    return dateFormat;
   }
 
   /**
diff --git a/src/test/java/org/assertj/core/api/date/DateAssert_setLenientDateParsing.java b/src/test/java/org/assertj/core/api/date/DateAssert_setLenientDateParsing.java
new file mode 100644
index 000000000..919903420
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/date/DateAssert_setLenientDateParsing.java
@@ -0,0 +1,102 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.date;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.Assertions.setLenientDateParsing;
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Dates.parseDatetime;
+import static org.assertj.core.util.Dates.parseDatetimeWithMs;
+
+import java.util.Date;
+
+import org.assertj.core.api.DateAssertBaseTest;
+import org.assertj.core.test.ExpectedException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+/**
+ * Tests the lenient mode of date parsing used in date assertions with date represented as {@link String}.
+ *
+ * @author Michal Kordas
+ */
+public class DateAssert_setLenientDateParsing extends DateAssertBaseTest {
+  @Rule
+  public ExpectedException thrown = none();
+
+  @Override
+  @Before
+  public void setUp() {
+    super.setUp();
+    setLenientDateParsing(true);
+  }
+
+  @Test
+  public void should_parse_date_leniently() {
+    final Date date = parse("2001-02-03");
+    assertThat(date).isEqualTo("2001-01-34");
+    assertThat(date).isEqualTo("2001-02-02T24:00:00");
+    assertThat(date).isEqualTo("2001-02-04T-24:00:00.000");
+  }
+
+  @Test
+  public void should_parse_date_time_leniently() {
+    final Date dateTime = parseDatetime("2001-02-03T04:05:06");
+    assertThat(dateTime).isEqualTo("2001-02-03T04:05:05.1000");
+    assertThat(dateTime).isEqualTo("2001-02-03T04:04:66");
+  }
+
+  @Test
+  public void should_parse_date_time_with_milliseconds_leniently() {
+    final Date dateTimeWithMs = parseDatetimeWithMs("2001-02-03T04:05:06.700");
+    assertThat(dateTimeWithMs).isEqualTo("2001-02-03T04:05:07.-300");
+  }
+
+  @Test
+  public void should_parse_date_time_leniently_using_custom_date_string_representation() {
+    final Date date = parse("2001-02-03");
+    assertThat(date).withDateFormat("yyyy/MM/dd").isEqualTo("2001/01/34");
+  }
+
+  @Test
+  public void should_fail_if_given_date_string_representation_cant_be_parsed() {
+    final String dateAsString = "2001/02/03";
+    thrown.expect(AssertionError.class);
+    assertThat(new Date()).isEqualTo(dateAsString);
+  }
+
+  @Test
+  public void should_fail_if_date_can_be_parsed_leniently_but_lenient_mode_is_disabled() {
+    final Date date = parse("2001-02-03");
+
+    setLenientDateParsing(false);
+    try {
+      assertThat(date).isEqualTo("2001-01-34");
+      failBecauseExceptionWasNotThrown(AssertionError.class);
+    } catch (AssertionError error) {
+      assertThat(error).hasMessageContaining("Failed to parse");
+    } finally {
+      setLenientDateParsing(true);
+    }
+  }
+
+  @Override
+  @After
+  public void tearDown() {
+    super.tearDown();
+    setLenientDateParsing(false);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/dates/Dates_assertIsBetween_Test.java b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsBetween_Test.java
index 89411b2f5..98c444542 100644
--- a/src/test/java/org/assertj/core/internal/dates/Dates_assertIsBetween_Test.java
+++ b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsBetween_Test.java
@@ -13,12 +13,11 @@
 package org.assertj.core.internal.dates;
 
 import static org.assertj.core.error.ShouldBeBetween.shouldBeBetween;
-import static org.assertj.core.test.ErrorMessages.*;
+import static org.assertj.core.test.ErrorMessages.endDateToCompareActualWithIsNull;
+import static org.assertj.core.test.ErrorMessages.startDateToCompareActualWithIsNull;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
-
 import static org.mockito.Mockito.verify;
 
 import java.util.Date;
@@ -161,7 +160,7 @@ public class Dates_assertIsBetween_Test extends DatesBaseTest {
   public void should_fail_if_actual_is_equals_to_start_of_given_period_and_start_is_not_included_in_given_period_according_to_custom_comparison_strategy() {
     AssertionInfo info = someInfo();
     actual = parseDate("2011-09-01");
-    Date start = parseDate("2011-09-31"); // = 2011-09-01 according to comparison strategy
+    Date start = parseDate("2011-09-30"); // = 2011-09-01 according to comparison strategy
     Date end = parseDate("2011-10-30");
     boolean inclusiveStart = false;
     boolean inclusiveEnd = true;
