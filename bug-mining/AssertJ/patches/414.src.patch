diff --git a/src/main/java/org/assertj/core/api/AbstractAssert.java b/src/main/java/org/assertj/core/api/AbstractAssert.java
index c133a6180..e1d164ba5 100644
--- a/src/main/java/org/assertj/core/api/AbstractAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractAssert.java
@@ -82,13 +82,15 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
   protected final ACTUAL actual;
   protected final SELF myself;
 
+  @VisibleForTesting
   // = ConfigurationProvider.CONFIGURATION_PROVIDER.representation(); ?
-  private static Representation customRepresentation = null;
+  static Representation customRepresentation = null;
 
   @VisibleForTesting
   AssertionErrorCreator assertionErrorCreator;
 
-  private static boolean printAssertionsDescription;
+  @VisibleForTesting
+  static boolean printAssertionsDescription;
 
   private static Consumer<Description> descriptionConsumer;
 
diff --git a/src/main/java/org/assertj/core/api/AbstractDateAssert.java b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
index 88233e375..5d66cdf71 100644
--- a/src/main/java/org/assertj/core/api/AbstractDateAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
@@ -72,12 +72,13 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
   /**
    * the default DateFormat used to parse any String date representation.
    */
-  private static final List<DateFormat> DEFAULT_DATE_FORMATS = list(newIsoDateTimeWithMsAndIsoTimeZoneFormat(),
-                                                                    newIsoDateTimeWithMsFormat(),
-                                                                    newTimestampDateFormat(),
-                                                                    newIsoDateTimeWithIsoTimeZoneFormat(),
-                                                                    newIsoDateTimeFormat(),
-                                                                    newIsoDateFormat());
+  @VisibleForTesting
+  static final List<DateFormat> DEFAULT_DATE_FORMATS = list(newIsoDateTimeWithMsAndIsoTimeZoneFormat(),
+                                                            newIsoDateTimeWithMsFormat(),
+                                                            newTimestampDateFormat(),
+                                                            newIsoDateTimeWithIsoTimeZoneFormat(),
+                                                            newIsoDateTimeFormat(),
+                                                            newIsoDateFormat());
 
   private static final String DATE_FORMAT_PATTERN_SHOULD_NOT_BE_NULL = "Given date format pattern should not be null";
   private static final String DATE_FORMAT_SHOULD_NOT_BE_NULL = "Given date format should not be null";
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 4b68049fa..de67895c6 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -1519,7 +1519,6 @@ public class Assertions implements InstanceOfAssertFactories {
    * @return nothing, it's just to be used in doSomething(optional.orElse(() -&gt; failBecauseExceptionWasNotThrown(IOException.class)));.
    * @throws AssertionError with a message explaining that a {@link Throwable} of given class was expected to be thrown but had
    *           not been.
-   *
    */
   @CanIgnoreReturnValue
   public static <T> T failBecauseExceptionWasNotThrown(Class<? extends Throwable> throwableClass) {
diff --git a/src/main/java/org/assertj/core/api/BDDAssertions.java b/src/main/java/org/assertj/core/api/BDDAssertions.java
index 44d75e47e..585e81277 100644
--- a/src/main/java/org/assertj/core/api/BDDAssertions.java
+++ b/src/main/java/org/assertj/core/api/BDDAssertions.java
@@ -15,11 +15,14 @@ package org.assertj.core.api;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.UncheckedIOException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.URI;
 import java.net.URL;
+import java.nio.charset.Charset;
 import java.nio.file.Path;
+import java.text.DateFormat;
 import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDate;
@@ -29,6 +32,7 @@ import java.time.OffsetDateTime;
 import java.time.OffsetTime;
 import java.time.Period;
 import java.time.ZonedDateTime;
+import java.time.temporal.TemporalUnit;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -56,6 +60,7 @@ import java.util.concurrent.atomic.AtomicStampedReference;
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Consumer;
 import java.util.function.DoublePredicate;
+import java.util.function.Function;
 import java.util.function.IntPredicate;
 import java.util.function.LongPredicate;
 import java.util.function.Predicate;
@@ -65,6 +70,28 @@ import java.util.stream.LongStream;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.assertj.core.api.filter.FilterOperator;
+import org.assertj.core.api.filter.InFilter;
+import org.assertj.core.api.filter.NotFilter;
+import org.assertj.core.api.filter.NotInFilter;
+import org.assertj.core.condition.AllOf;
+import org.assertj.core.condition.AnyOf;
+import org.assertj.core.condition.DoesNotHave;
+import org.assertj.core.condition.Not;
+import org.assertj.core.configuration.Configuration;
+import org.assertj.core.data.Index;
+import org.assertj.core.data.MapEntry;
+import org.assertj.core.data.Offset;
+import org.assertj.core.data.Percentage;
+import org.assertj.core.data.TemporalUnitOffset;
+import org.assertj.core.description.Description;
+import org.assertj.core.groups.Properties;
+import org.assertj.core.groups.Tuple;
+import org.assertj.core.presentation.BinaryRepresentation;
+import org.assertj.core.presentation.HexadecimalRepresentation;
+import org.assertj.core.presentation.Representation;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.assertj.core.presentation.UnicodeRepresentation;
 import org.assertj.core.util.CanIgnoreReturnValue;
 import org.assertj.core.util.CheckReturnValue;
 
@@ -1629,6 +1656,78 @@ public class BDDAssertions extends Assertions {
     return assertThat(actual);
   }
 
+  /**
+   * Allows catching a {@link Throwable} more easily when used with Java 8 lambdas.
+   * <p>
+   * This caught {@link Throwable} can then be asserted.
+   * <p>
+   * If you need to assert on the real type of Throwable caught (e.g. IOException), use {@link #catchThrowableOfType(ThrowableAssert.ThrowingCallable, Class)}.
+   * <p>
+   * Example:
+   * <pre><code class='java'>{@literal @}Test
+   * public void testException() {
+   *   // when
+   *   Throwable thrown = catchThrowable(() -&gt; { throw new Exception("boom!"); });
+   *
+   *   // then
+   *   assertThat(thrown).isInstanceOf(Exception.class)
+   *                     .hasMessageContaining("boom");
+   * } </code></pre>
+   *
+   * @param shouldRaiseThrowable The lambda with the code that should raise the exception.
+   * @return The captured exception or <code>null</code> if none was raised by the callable.
+   * @see #catchThrowableOfType(ThrowableAssert.ThrowingCallable, Class)
+   *
+   * @since 3.20.0
+   */
+  public static Throwable catchThrowable(ThrowingCallable shouldRaiseThrowable) {
+    return AssertionsForClassTypes.catchThrowable(shouldRaiseThrowable);
+  }
+
+  /**
+   * Allows catching a {@link Throwable} of a specific type.
+   * <p>
+   * A call is made to {@code catchThrowable(ThrowingCallable)}, if no exception is thrown it returns null
+   * otherwise it checks that the caught {@link Throwable} has the specified type and casts it making it convenient to perform subtype-specific assertions on it.
+   * <p>
+   * Example:
+   * <pre><code class='java'> class TextException extends Exception {
+   *   int line;
+   *   int column;
+   *
+   *   public TextException(String msg, int line, int column) {
+   *     super(msg);
+   *     this.line = line;
+   *     this.column = column;
+   *   }
+   * }
+   *
+   * TextException textException = catchThrowableOfType(() -&gt; { throw new TextException("boom!", 1, 5); },
+   *                                                    TextException.class);
+   * // assertions succeed
+   * assertThat(textException).hasMessage("boom!");
+   * assertThat(textException.line).isEqualTo(1);
+   * assertThat(textException.column).isEqualTo(5);
+   *
+   * // succeeds as catchThrowableOfType returns null when the code does not thrown any exceptions
+   * assertThat(catchThrowableOfType(() -&gt; {}, Exception.class)).isNull();
+   *
+   * // fails as TextException is not a RuntimeException
+   * catchThrowableOfType(() -&gt; { throw new TextException("boom!", 1, 5); }, RuntimeException.class);</code></pre>
+   *
+   * @param <THROWABLE> the {@link Throwable} type.
+   * @param shouldRaiseThrowable The lambda with the code that should raise the exception.
+   * @param type The type of exception that the code is expected to raise.
+   * @return The captured exception or <code>null</code> if none was raised by the callable.
+   * @see #catchThrowable(ThrowableAssert.ThrowingCallable)
+   *
+   * @since 3.20.0
+   */
+  public static <THROWABLE extends Throwable> THROWABLE catchThrowableOfType(ThrowingCallable shouldRaiseThrowable,
+                                                                             Class<THROWABLE> type) {
+    return AssertionsForClassTypes.catchThrowableOfType(shouldRaiseThrowable, type);
+  }
+
   /**
    * Entry point to check that an exception of type T is thrown by a given {@code throwingCallable}
    * which allows to chain assertions on the thrown exception.
@@ -1699,4 +1798,1485 @@ public class BDDAssertions extends Assertions {
     return assertThatIllegalStateException();
   }
 
+  // -------------------------------------------------------------------------------------------------
+  // fail methods : not assertions but here to have a single entry point to all AssertJ features.
+  // -------------------------------------------------------------------------------------------------
+
+  /**
+   * Sets whether we remove elements related to AssertJ from assertion error stack trace.
+   * <p>
+   * Default is {@value org.assertj.core.configuration.Configuration#REMOVE_ASSERTJ_RELATED_ELEMENTS_FROM_STACK_TRACE}.
+   *
+   * @param removeAssertJRelatedElementsFromStackTrace flag.
+   *
+   * @since 3.20.0
+   */
+  public static void setRemoveAssertJRelatedElementsFromStackTrace(boolean removeAssertJRelatedElementsFromStackTrace) {
+    Assertions.setRemoveAssertJRelatedElementsFromStackTrace(removeAssertJRelatedElementsFromStackTrace);
+  }
+
+  /**
+   * Throws an {@link AssertionError} with the given message.
+   *
+   * @param <T> dummy return value type
+   * @param failureMessage error message.
+   * @return nothing, it's just to be used in {@code doSomething(optional.orElse(() -> fail("boom")));}.
+   * @throws AssertionError with the given message.
+   *
+   * @since 3.20.0
+   */
+  @CanIgnoreReturnValue
+  public static <T> T fail(String failureMessage) {
+    return Assertions.fail(failureMessage);
+  }
+
+  /**
+   * Throws an {@link AssertionError} with the given message built as {@link String#format(String, Object...)}.
+   *
+   * @param <T> dummy return value type
+   * @param failureMessage error message.
+   * @param args Arguments referenced by the format specifiers in the format string.
+   * @return nothing, it's just to be used in doSomething(optional.orElse(() -&gt; fail("b%s", ""oom)));.
+   * @throws AssertionError with the given built message.
+   *
+   * @since 3.20.0
+   */
+  @CanIgnoreReturnValue
+  public static <T> T fail(String failureMessage, Object... args) {
+    return Assertions.fail(failureMessage, args);
+  }
+
+  /**
+   * Throws an {@link AssertionError} with the given message and with the {@link Throwable} that caused the failure.
+   * @param <T> dummy return value type
+   * @param failureMessage the description of the failed assertion. It can be {@code null}.
+   * @param realCause cause of the error.
+   * @return nothing, it's just to be used in doSomething(optional.orElse(() -&gt; fail("boom", cause)));.
+   * @throws AssertionError with the given message and with the {@link Throwable} that caused the failure.
+   *
+   * @since 3.20.0
+   */
+  @CanIgnoreReturnValue
+  public static <T> T fail(String failureMessage, Throwable realCause) {
+    return Assertions.fail(failureMessage, realCause);
+  }
+
+  /**
+   * Throws an {@link AssertionError} with a message explaining that a {@link Throwable} of given class was expected to be thrown
+   * but had not been.
+   * @param <T> dummy return value type
+   * @param throwableClass the Throwable class that was expected to be thrown.
+   * @return nothing, it's just to be used in doSomething(optional.orElse(() -&gt; shouldHaveThrown(IOException.class)));.
+   * @throws AssertionError with a message explaining that a {@link Throwable} of given class was expected to be thrown but had
+   *           not been.
+   *
+   * @since 3.20.0
+   */
+  @CanIgnoreReturnValue
+  public static <T> T shouldHaveThrown(Class<? extends Throwable> throwableClass) {
+    return Assertions.shouldHaveThrown(throwableClass);
+  }
+
+  /**
+   * In error messages, sets the threshold when iterable/array formatting will be on one line (if their String description
+   * length &lt;= this parameter) or it will be formatted with one element per line.
+   * <p>
+   * The default value for maxLengthForSingleLineDescription is {@value Configuration#MAX_LENGTH_FOR_SINGLE_LINE_DESCRIPTION}.
+   * <p>
+   * The following array will be formatted on one line as its length &lt;= 80:
+   * <pre><code class='java'> String[] greatBooks = array("A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice");
+   * // formatted as:
+   * ["A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice"]</code></pre>
+   * whereas this array is formatted on multiple lines (one element per line)
+   *
+   * <pre><code class='java'> String[] greatBooks = array("A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice", "Guards! Guards! (Discworld)");
+   * // formatted as:
+   * ["A Game of Thrones",
+   *  "The Lord of the Rings",
+   *  "Assassin's Apprentice",
+   *  "Guards! Guards! (Discworld)"]</code></pre>
+   *
+   * @param maxLengthForSingleLineDescription the maximum length for an iterable/array to be displayed on one line
+   *
+   * @since 3.20.0
+   */
+  public static void setMaxLengthForSingleLineDescription(int maxLengthForSingleLineDescription) {
+    Assertions.setMaxLengthForSingleLineDescription(maxLengthForSingleLineDescription);
+  }
+
+  /**
+   * Sets the maximum number of elements to display in error messages for iterables, arrays and map .
+   * <p>
+   * Example with a value of {@code 4}.
+   * <p>
+   * The following array will be formatted entirely as it's length is &lt;= 4:
+   * <pre><code class='java'> String[] greatBooks = array("A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice");
+   * // formatted as:
+   * ["A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice"]</code></pre>
+   *
+   * whereas for this 6 elements array, only the first and last two elements are displayed (4 in total):
+   * <pre><code class='java'> String[] greatBooks = array("A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice", "Guards! Guards!", "The Lies of Locke Lamora", "Aux Ombres d’Abyme");
+   * // formatted as:
+   * ["A Game of Thrones", "The Lord of the Rings", ... "The Lies of Locke Lamora", "Aux Ombres d’Abyme"]</code></pre>
+   *
+   * @param maxElementsForPrinting the maximum elements that would be printed for iterables, arrays and maps.
+   *
+   * @since 3.20.0
+   */
+  public static void setMaxElementsForPrinting(int maxElementsForPrinting) {
+    Assertions.setMaxElementsForPrinting(maxElementsForPrinting);
+  }
+
+  /**
+   * Enable/disable printing assertions description to the console (disabled by default).
+   * <p>
+   * The printed assertions description include all the successful assertions description and respectively the first failed one for standard assertions and all failed ones for soft assertions.
+   * <p>
+   * If you want to process the description differently, create a {@link Consumer Consumer&lt;Description&gt;} and register it with {@link #setDescriptionConsumer(Consumer)}.
+   *
+   * @param printAssertionsDescription whether to print assertions description.
+   *
+   * @since 3.20.0
+   */
+  public static void setPrintAssertionsDescription(boolean printAssertionsDescription) {
+    Assertions.setPrintAssertionsDescription(printAssertionsDescription);
+  }
+
+  /**
+   * All assertions description will be consumed by the given {@link Consumer Consumer&lt;Description&gt;} allowing for example to record them in a file.
+   * <p>
+   * The consumed descriptions include all the successful assertions description and respectively the first failed one for standard assertions and all failed ones for soft assertions.
+   * <p>
+   * To unset the descriptionConsumer, call {@code setDescriptionConsumer(null);}
+   *
+   * @param descriptionConsumer the {@link Description} consumer
+   *
+   * @since 3.20.0
+   */
+  public static void setDescriptionConsumer(Consumer<Description> descriptionConsumer) {
+    Assertions.setDescriptionConsumer(descriptionConsumer);
+  }
+
+  /**
+   * Sets how many stacktrace elements are included in {@link Throwable} representation (by default this set to 3).
+   * <p>
+   * Examples:
+   * <pre><code class='java'>  static class Test1 {
+   *
+   *   static void boom() {
+   *     Test2.boom2();
+   *   }
+   *
+   *   static class Test2 {
+   *     static void boom2() {
+   *       throw new RuntimeException();
+   *     }
+   *   }
+   * }</code></pre>
+   *
+   * {@code Test1.boom()} exception should be represented like this in error messages:
+   * <pre><code class='text'> java.lang.RuntimeException
+   *  at org.assertj.core.presentation.Test1$Test2.boom2(StandardRepresentation_throwable_format_Test.java:35)
+   *  at org.assertj.core.presentation.Test1.boom(StandardRepresentation_throwable_format_Test.java:40);java.lang.RuntimeException
+   *  at org.assertj.core.presentation.Test1.lambda$1(StandardRepresentation_throwable_format_Test.java:63)org.assertj.core.util.Throwables_Description_Test$test1$test2.exception_layer_2(Throwables_Description_Test.java:24)
+   *  ...(69 remaining lines not displayed - this can be changed with Assertions.setMaxStackTraceElementsDisplayed)org.assertj.core.util.Throwables_Description_Test$test1.exception_layer_1(Throwables_Description_Test.java:30)</code></pre>
+   *
+   * @param maxStackTraceElementsDisplayed  the maximum number of lines for a stacktrace to be displayed on one throw.
+   * @see Configuration
+   *
+   * @since 3.20.0
+   */
+  public static void setMaxStackTraceElementsDisplayed(int maxStackTraceElementsDisplayed) {
+    Assertions.setMaxStackTraceElementsDisplayed(maxStackTraceElementsDisplayed);
+  }
+
+  // ------------------------------------------------------------------------------------------------------
+  // properties methods : not assertions but here to have a single entry point to all AssertJ features.
+  // ------------------------------------------------------------------------------------------------------
+
+  /**
+   * Only delegate to {@link Properties#extractProperty(String)} so that Assertions offers a full feature entry point
+   * to
+   * all AssertJ features (but you can use {@link Properties} if you prefer).
+   * <p>
+   * Typical usage is to chain <code>extractProperty</code> with <code>from</code> method, see examples below :
+   *
+   * <pre><code class='java'> // extract simple property values having a java standard type (here String)
+   * assertThat(extractProperty(&quot;name&quot;, String.class).from(fellowshipOfTheRing))
+   *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;, &quot;Legolas&quot;)
+   *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
+   *
+   * // extracting property works also with user's types (here Race)
+   * assertThat(extractProperty(&quot;race&quot;, String.class).from(fellowshipOfTheRing))
+   *           .contains(HOBBIT, ELF).doesNotContain(ORC);
+   *
+   * // extract nested property on Race
+   * assertThat(extractProperty(&quot;race.name&quot;, String.class).from(fellowshipOfTheRing))
+   *           .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
+   *           .doesNotContain(&quot;Orc&quot;);</code></pre>
+   * @param <T> the type of value to extract.
+   * @param propertyName the name of the property to be read from the elements of a {@code Iterable}. It may be a nested
+   *          property (e.g. "address.street.number").
+   * @param propertyType the type of property to extract
+   * @return the created {@code Properties}.
+   * @throws NullPointerException if the given property name is {@code null}.
+   * @throws IllegalArgumentException if the given property name is empty.
+   *
+   * @since 3.20.0
+   */
+  public static <T> Properties<T> extractProperty(String propertyName, Class<T> propertyType) {
+    return Assertions.extractProperty(propertyName, propertyType);
+  }
+
+  /**
+   * Only delegate to {@link Properties#extractProperty(String)} so that Assertions offers a full feature entry point
+   * to
+   * all AssertJ features (but you can use {@link Properties} if you prefer).
+   * <p>
+   * Typical usage is to chain <code>extractProperty</code> with <code>from</code> method, see examples below :
+   *
+   * <pre><code class='java'> // extract simple property values, as no type has been defined the extracted property will be considered as Object
+   * // to define the real property type (here String) use extractProperty(&quot;name&quot;, String.class) instead.
+   * assertThat(extractProperty(&quot;name&quot;).from(fellowshipOfTheRing))
+   *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;, &quot;Legolas&quot;)
+   *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
+   *
+   * // extracting property works also with user's types (here Race), even though it will be considered as Object
+   * // to define the real property type (here String) use extractProperty(&quot;name&quot;, Race.class) instead.
+   * assertThat(extractProperty(&quot;race&quot;).from(fellowshipOfTheRing)).contains(HOBBIT, ELF).doesNotContain(ORC);
+   *
+   * // extract nested property on Race
+   * assertThat(extractProperty(&quot;race.name&quot;).from(fellowshipOfTheRing)).contains(&quot;Hobbit&quot;, &quot;Elf&quot;).doesNotContain(&quot;Orc&quot;); </code></pre>
+   *
+   * @param propertyName the name of the property to be read from the elements of a {@code Iterable}. It may be a nested
+   *          property (e.g. "address.street.number").
+   * @throws NullPointerException if the given property name is {@code null}.
+   * @throws IllegalArgumentException if the given property name is empty.
+   * @return the created {@code Properties}.
+   *
+   * @since 3.20.0
+   */
+  public static Properties<Object> extractProperty(String propertyName) {
+    return Assertions.extractProperty(propertyName);
+  }
+
+  /**
+   * Utility method to build nicely a {@link Tuple} when working with {@link IterableAssert#extracting(String...)} or
+   * {@link ObjectArrayAssert#extracting(String...)}
+   *
+   * @param values the values stored in the {@link Tuple}
+   * @return the built {@link Tuple}
+   *
+   * @since 3.20.0
+   */
+  public static Tuple tuple(Object... values) {
+    return Assertions.tuple(values);
+  }
+
+  /**
+   * Globally sets whether
+   * <code>{@link org.assertj.core.api.AbstractIterableAssert#extracting(String) IterableAssert#extracting(String)}</code>
+   * and
+   * <code>{@link org.assertj.core.api.AbstractObjectArrayAssert#extracting(String) ObjectArrayAssert#extracting(String)}</code>
+   * should be allowed to extract private fields, if not and they try it fails with exception.
+   *
+   * @param allowExtractingPrivateFields allow private fields extraction. Default is {@value org.assertj.core.configuration.Configuration#ALLOW_EXTRACTING_PRIVATE_FIELDS}.
+   *
+   * @since 3.20.0
+   */
+  public static void setAllowExtractingPrivateFields(boolean allowExtractingPrivateFields) {
+    Assertions.setAllowExtractingPrivateFields(allowExtractingPrivateFields);
+  }
+
+  /**
+   * Globally sets whether the use of private fields is allowed for comparison.
+   * The following (incomplete) list of methods will be impacted by this change :
+   * <ul>
+   * <li>
+   * <code>{@link org.assertj.core.api.AbstractIterableAssert#usingElementComparatorOnFields(java.lang.String...)}</code>
+   * </li>
+   * <li><code>{@link org.assertj.core.api.AbstractObjectAssert#isEqualToComparingFieldByField(Object)}</code></li>
+   * </ul>
+   *
+   * If the value is <code>false</code> and these methods try to compare private fields, it will fail with an exception.
+   *
+   * @param allowComparingPrivateFields allow private fields comparison. Default is {@value org.assertj.core.configuration.Configuration#ALLOW_COMPARING_PRIVATE_FIELDS}.
+   *
+   * @since 3.20.0
+   */
+  public static void setAllowComparingPrivateFields(boolean allowComparingPrivateFields) {
+    Assertions.setAllowComparingPrivateFields(allowComparingPrivateFields);
+  }
+
+  /**
+   * Globally sets whether the extractor considers bare-named property methods like {@code String name()}.
+   * Defaults to enabled.
+   * @param barenamePropertyMethods whether bare-named property methods are found
+   *
+   * @since 3.20.0
+   */
+  public static void setExtractBareNamePropertyMethods(boolean barenamePropertyMethods) {
+    Assertions.setExtractBareNamePropertyMethods(barenamePropertyMethods);
+  }
+
+  // ------------------------------------------------------------------------------------------------------
+  // Data utility methods : not assertions but here to have a single entry point to all AssertJ features.
+  // ------------------------------------------------------------------------------------------------------
+
+  /**
+   * Only delegate to {@link MapEntry#entry(Object, Object)} so that Assertions offers a full feature entry point to
+   * all
+   * AssertJ features (but you can use {@link MapEntry} if you prefer).
+   * <p>
+   * Typical usage is to call <code>entry</code> in MapAssert <code>contains</code> assertion, see examples below :
+   *
+   * <pre><code class='java'> Map&lt;Ring, TolkienCharacter&gt; ringBearers = ... // init omitted
+   *
+   * assertThat(ringBearers).contains(entry(oneRing, frodo), entry(nenya, galadriel));</code></pre>
+   * @param <K> the type of keys in the map.
+   * @param <V> the type of values in the map.
+   * @param key the key of the entry to create.
+   * @param value the value of the entry to create.
+   * @return the created {@code MapEntry}.
+   *
+   * @since 3.20.0
+   */
+  public static <K, V> MapEntry<K, V> entry(K key, V value) {
+    return Assertions.entry(key, value);
+  }
+
+  /**
+   * Only delegate to {@link Index#atIndex(int)} so that Assertions offers a full feature entry point to all AssertJ
+   * features (but you can use {@link Index} if you prefer).
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> List&lt;Ring&gt; elvesRings = newArrayList(vilya, nenya, narya);
+   * assertThat(elvesRings).contains(vilya, atIndex(0)).contains(nenya, atIndex(1)).contains(narya, atIndex(2));</code></pre>
+   *
+   * @param index the value of the index.
+   * @return the created {@code Index}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Index atIndex(int index) {
+    return Assertions.atIndex(index);
+  }
+
+  /**
+   * Builds an {@link Offset} to use with {@code isCloseTo} assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(0.1).isCloseTo(0.0, within(0.1));</code></pre>
+   * @param value the allowed offset
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Double> within(Double value) {
+    return Assertions.offset(value);
+  }
+
+  /**
+   * Builds an {@link Offset} to use with real number assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(0.1).isEqualTo(0.0, withPrecision(0.1));</code></pre>
+   * @param value the required precision
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Double> withPrecision(Double value) {
+    return Assertions.offset(value);
+  }
+
+  /**
+   * Builds an {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(8.2f).isCloseTo(8.0f, within(0.2f));</code></pre>
+   *
+   * @param value the allowed offset
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Float> within(Float value) {
+    return Assertions.offset(value);
+  }
+
+  /**
+   * Builds an {@link Offset} to use with real number assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(0.2f).isEqualTo(0.0f, withPrecision(0.2f));</code></pre>
+   * @param value the required precision
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Float> withPrecision(Float value) {
+    return Assertions.offset(value);
+  }
+
+  /**
+   * Assertions entry point for BigDecimal {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(BigDecimal.TEN).isCloseTo(new BigDecimal("10.5"), within(BigDecimal.ONE));</code></pre>
+   *
+   * @param value the allowed offset
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<BigDecimal> within(BigDecimal value) {
+    return Assertions.within(value);
+  }
+
+  /**
+   * Assertions entry point for BigInteger {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(BigInteger.TEN).isCloseTo(new BigInteger("11"), within(new BigInteger("2")));</code></pre>
+   *
+   * @since 2.7.0 / 3.7.0
+   * @param value the allowed offset
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<BigInteger> within(BigInteger value) {
+    return Assertions.within(value);
+  }
+
+  /**
+   * Assertions entry point for Byte {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat((byte) 10).isCloseTo((byte) 11, within((byte) 1));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Byte> within(Byte value) {
+    return Assertions.within(value);
+  }
+
+  /**
+   * Assertions entry point for Integer {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(10).isCloseTo(11, within(1));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Integer> within(Integer value) {
+    return Assertions.within(value);
+  }
+
+  /**
+   * Assertions entry point for Short {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(10).isCloseTo(11, within(1));</code></pre>
+   *
+   * @param value the allowed offset
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Short> within(Short value) {
+    return Assertions.within(value);
+  }
+
+  /**
+   * Assertions entry point for Long {@link Offset} to use with {@link AbstractLongAssert#isCloseTo(long, Offset) isCloseTo} assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(5l).isCloseTo(7l, within(2l));</code></pre>
+   *
+   * @param value the allowed offset
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Long> within(Long value) {
+    return Assertions.within(value);
+  }
+
+  /**
+   * Assertions entry point for {@link TemporalUnitOffset} with  with less than or equal condition
+   * to use with isCloseTo temporal assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> LocalTime _07_10 = LocalTime.of(7, 10);
+   * LocalTime _07_12 = LocalTime.of(7, 12);
+   * assertThat(_07_10).isCloseTo(_07_12, within(5, ChronoUnit.MINUTES));</code></pre>
+   *
+   * @param value the allowed offset
+   * @param unit the {@link TemporalUnit} of the offset
+   * @return the created {@code Offset}.
+   *
+   * @since 3.20.0
+   */
+  public static TemporalUnitOffset within(long value, TemporalUnit unit) {
+    return Assertions.within(value, unit);
+  }
+
+  /**
+   * Syntactic sugar method to use with {@link AbstractDurationAssert#isCloseTo(Duration, Duration)} assertion.
+   * <p>
+   * Example:
+   * <pre><code class='java'> assertThat(Duration.ofMinutes(2)).isCloseTo(Duration.ofMinutes(3), withMarginOf(Duration.ofMinutes(1)));</code></pre>
+   *
+   * @param allowedDifference the allowed difference {@link Duration}.
+   * @return the given value.
+   *
+   * @since 3.20.0
+   */
+  public static Duration withMarginOf(Duration allowedDifference) {
+    return Assertions.withMarginOf(allowedDifference);
+  }
+
+  /**
+   * Assertions entry point for Double {@link org.assertj.core.data.Percentage} to use with isCloseTo assertions for
+   * percentages.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(11.0).isCloseTo(10.0, withinPercentage(10.0));</code></pre>
+   *
+   * @param value the required precision percentage
+   * @return the created {@code Percentage}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Percentage withinPercentage(Double value) {
+    return Assertions.withinPercentage(value);
+  }
+
+  /**
+   * Assertions entry point for Integer {@link org.assertj.core.data.Percentage} to use with isCloseTo assertions for
+   * percentages.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(11).isCloseTo(10, withinPercentage(10));</code></pre>
+   *
+   * @param value the required precision percentage
+   * @return the created {@code Percentage}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Percentage withinPercentage(Integer value) {
+    return Assertions.withinPercentage(value);
+  }
+
+  /**
+   * Assertions entry point for Long {@link org.assertj.core.data.Percentage} to use with isCloseTo assertions for
+   * percentages.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(11L).isCloseTo(10L, withinPercentage(10L));</code></pre>
+   *
+   * @param value the required precision percentage
+   * @return the created {@code Percentage}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Percentage withinPercentage(Long value) {
+    return Assertions.withinPercentage(value);
+  }
+
+  /**
+   * Build a {@link Offset#strictOffset(Number) <b>strict</b> Offset} to use with {@link AbstractDoubleAssert#isCloseTo(double, Offset)} and {@link AbstractDoubleAssert#isNotCloseTo(double, Offset)} assertions.
+   * <p>
+   * A strict offset implies a strict comparison which means that {@code isCloseTo} will fail when <i>abs(actual - expected) == offset</i>.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> // assertion succeeds
+   * assertThat(8.1).isCloseTo(8.0, byLessThan(0.2));
+   *
+   * // assertions fail
+   * assertThat(8.1).isCloseTo(8.0, byLessThan(0.1)); // strict comparison!
+   * assertThat(8.1).isCloseTo(8.0, byLessThan(0.01));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Double> byLessThan(Double value) {
+    return Assertions.byLessThan(value);
+  }
+
+  /**
+   * Alias for {@link #offset(Float)} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(8.2f).isCloseTo(8.0f, byLessThan(0.5f));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Float> byLessThan(Float value) {
+    return Assertions.byLessThan(value);
+  }
+
+  /**
+   * Assertions entry point for BigDecimal {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(BigDecimal.TEN).isCloseTo(new BigDecimal("10.5"), byLessThan(BigDecimal.ONE));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<BigDecimal> byLessThan(BigDecimal value) {
+    return Assertions.byLessThan(value);
+  }
+
+  /**
+   * Assertions entry point for BigInteger {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(BigInteger.TEN).isCloseTo(new BigInteger("11"), byLessThan(new BigInteger("2")));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<BigInteger> byLessThan(BigInteger value) {
+    return Assertions.byLessThan(value);
+  }
+
+  /**
+   * Assertions entry point for Byte {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat((byte) 10).isCloseTo((byte) 11, byLessThan((byte) 2));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Byte> byLessThan(Byte value) {
+    return Assertions.byLessThan(value);
+  }
+
+  /**
+   * Assertions entry point for Long {@link Offset} to use with strict {@link AbstractIntegerAssert#isCloseTo(int, Offset) isCloseTo} assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(10).isCloseTo(12, byLessThan(1));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Integer> byLessThan(Integer value) {
+    return Assertions.byLessThan(value);
+  }
+
+  /**
+   * Assertions entry point for Short {@link Offset} to use with isCloseTo assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat((short) 10).isCloseTo((short) 11, byLessThan((short) 2));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Short> byLessThan(Short value) {
+    return Assertions.byLessThan(value);
+  }
+
+  /**
+   * Assertions entry point for Long {@link Offset} to use with strict {@link AbstractLongAssert#isCloseTo(long, Offset) isCloseTo} assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> assertThat(5l).isCloseTo(7l, byLessThan(3l));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   *
+   * @since 3.20.0
+   */
+  public static Offset<Long> byLessThan(Long value) {
+    return Assertions.byLessThan(value);
+  }
+
+  /**
+   * Assertions entry point for {@link TemporalUnitOffset} with strict less than condition
+   * to use with {@code isCloseTo} temporal assertions.
+   * <p>
+   * Typical usage :
+   * <pre><code class='java'> LocalTime _07_10 = LocalTime.of(7, 10);
+   * LocalTime _07_12 = LocalTime.of(7, 12);
+   * assertThat(_07_10).isCloseTo(_07_12, byLessThan(5, ChronoUnit.MINUTES));</code></pre>
+   *
+   * @param value the value of the offset.
+   * @param unit the {@link TemporalUnit} of the offset.
+   * @return the created {@code Offset}.
+   *
+   * @since 3.20.0
+   */
+  public static TemporalUnitOffset byLessThan(long value, TemporalUnit unit) {
+    return Assertions.byLessThan(value, unit);
+  }
+
+  /**
+   * A syntax sugar to write fluent assertion using {@link ObjectAssert#returns(Object, Function)}.
+   * <p>
+   * Example:
+   * <pre><code class="java"> Jedi yoda = new Jedi("Yoda", "Green");
+   * assertThat(yoda).returns("Yoda", from(Jedi::getName))
+   *                 .returns(2.4, from(Jedi::getHeight))
+   *                 .returns(150, from(Jedi::getWeight)); </code></pre>
+   *
+   * @param extractor A function to extract test subject's property
+   * @param <F> Type of test subject
+   * @param <T> Type of the property under the assertion
+   * @return same instance of {@code extractor}
+   *
+   * @since 3.20.0
+   */
+  public static <F, T> Function<F, T> from(Function<F, T> extractor) {
+    return Assertions.from(extractor);
+  }
+
+  /**
+   * A syntax sugar to write fluent assertion with methods having an {@link InstanceOfAssertFactory} parameter.
+   * <p>
+   * Example:
+   * <pre><code class="java"> Jedi yoda = new Jedi("Yoda", "Green");
+   * assertThat(yoda).extracting(Jedi::getName, as(InstanceOfAssertFactories.STRING))
+   *                 .startsWith("Yo");</code></pre>
+   *
+   * @param assertFactory the factory which verifies the type and creates the new {@code Assert}
+   * @param <T>           the type to use for the cast.
+   * @param <ASSERT>      the type of the resulting {@code Assert}
+   * @return same instance of {@code assertFactory}
+   *
+   * @since 3.20.0
+   * @see AbstractObjectAssert#extracting(String, InstanceOfAssertFactory)
+   * @see AbstractObjectAssert#extracting(Function, InstanceOfAssertFactory)
+   * @see AbstractMapAssert#extractingByKey(Object, InstanceOfAssertFactory)
+   * @see AbstractOptionalAssert#get(InstanceOfAssertFactory)
+   * @see AbstractIterableAssert#first(InstanceOfAssertFactory)
+   * @see AbstractIterableAssert#last(InstanceOfAssertFactory)
+   * @see AbstractIterableAssert#element(int, InstanceOfAssertFactory)
+   *
+   * @since 3.20.0
+   */
+  public static <T, ASSERT extends AbstractAssert<?, ?>> InstanceOfAssertFactory<T, ASSERT> as(InstanceOfAssertFactory<T, ASSERT> assertFactory) {
+    return Assertions.as(assertFactory);
+  }
+  // ------------------------------------------------------------------------------------------------------
+  // Condition methods : not assertions but here to have a single entry point to all AssertJ features.
+  // ------------------------------------------------------------------------------------------------------
+
+  /**
+   * Creates a new <code>{@link AllOf}</code>
+   *
+   * @param <T> the type of object the given condition accept.
+   * @param conditions the conditions to evaluate.
+   * @return the created {@code AllOf}.
+   * @throws NullPointerException if the given array is {@code null}.
+   * @throws NullPointerException if any of the elements in the given array is {@code null}.
+   *
+   * @since 3.20.0
+   */
+  @SafeVarargs
+  public static <T> Condition<T> allOf(Condition<? super T>... conditions) {
+    return Assertions.allOf(conditions);
+  }
+
+  /**
+   * Creates a new <code>{@link AllOf}</code>
+   *
+   * @param <T> the type of object the given condition accept.
+   * @param conditions the conditions to evaluate.
+   * @return the created {@code AllOf}.
+   * @throws NullPointerException if the given iterable is {@code null}.
+   * @throws NullPointerException if any of the elements in the given iterable is {@code null}.
+   *
+   * @since 3.20.0
+   */
+  public static <T> Condition<T> allOf(Iterable<? extends Condition<? super T>> conditions) {
+    return Assertions.allOf(conditions);
+  }
+
+  /**
+   * Only delegate to {@link AnyOf#anyOf(Condition...)} so that Assertions offers a full feature entry point to all
+   * AssertJ features (but you can use {@link AnyOf} if you prefer).
+   * <p>
+   * Typical usage (<code>jedi</code> and <code>sith</code> are {@link Condition}) :
+   *
+   * <pre><code class='java'> assertThat(&quot;Vader&quot;).is(anyOf(jedi, sith));</code></pre>
+   *
+   * @param <T> the type of object the given condition accept.
+   * @param conditions the conditions to evaluate.
+   * @return the created {@code AnyOf}.
+   *
+   * @since 3.20.0
+   */
+  @SafeVarargs
+  public static <T> Condition<T> anyOf(Condition<? super T>... conditions) {
+    return Assertions.anyOf(conditions);
+  }
+
+  /**
+   * Creates a new <code>{@link AnyOf}</code>
+   *
+   * @param <T> the type of object the given condition accept.
+   * @param conditions the conditions to evaluate.
+   * @return the created {@code AnyOf}.
+   * @throws NullPointerException if the given iterable is {@code null}.
+   * @throws NullPointerException if any of the elements in the given iterable is {@code null}.
+   *
+   * @since 3.20.0
+   */
+  public static <T> Condition<T> anyOf(Iterable<? extends Condition<? super T>> conditions) {
+    return Assertions.anyOf(conditions);
+  }
+
+  /**
+   * Creates a new <code>{@link DoesNotHave}</code>.
+   *
+   * @param <T> the type of object the given condition accept.
+   * @param condition the condition to inverse.
+   * @return The DoesNotHave condition created.
+   *
+   * @since 3.20.0
+   */
+  public static <T> DoesNotHave<T> doesNotHave(Condition<? super T> condition) {
+    return Assertions.doesNotHave(condition);
+  }
+
+  /**
+   * Creates a new <code>{@link Not}</code>.
+   *
+   * @param <T> the type of object the given condition accept.
+   * @param condition the condition to inverse.
+   * @return The Not condition created.
+   *
+   * @since 3.20.0
+   */
+  public static <T> Not<T> not(Condition<? super T> condition) {
+    return Assertions.not(condition);
+  }
+
+  // --------------------------------------------------------------------------------------------------
+  // Filter methods : not assertions but here to have a single entry point to all AssertJ features.
+  // --------------------------------------------------------------------------------------------------
+
+  /**
+   * Create a {@link FilterOperator} to use in {@link AbstractIterableAssert#filteredOn(String, FilterOperator)
+   * filteredOn(String, FilterOperation)} to express a filter keeping all Iterable elements whose property/field
+   * value matches one of the given values.
+   * <p>
+   * As often, an example helps:
+   * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   *
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   *
+   * assertThat(employees).filteredOn("age", in(800, 26))
+   *                      .containsOnly(yoda, obiwan, luke);</code></pre>
+   *
+   * @param values values to match (one match is sufficient)
+   * @return the created "in" filter
+   *
+   * @since 3.20.0
+   */
+  public static InFilter in(Object... values) {
+    return Assertions.in(values);
+  }
+
+  /**
+   * Create a {@link FilterOperator} to use in {@link AbstractIterableAssert#filteredOn(String, FilterOperator)
+   * filteredOn(String, FilterOperation)} to express a filter keeping all Iterable elements whose property/field
+   * value matches does not match any of the given values.
+   * <p>
+   * As often, an example helps:
+   * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   *
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   *
+   * assertThat(employees).filteredOn("age", notIn(800, 50))
+   *                      .containsOnly(luke);</code></pre>
+   *
+   * @param valuesNotToMatch values not to match (none of the values must match)
+   * @return the created "not in" filter
+   *
+   * @since 3.20.0
+   */
+  public static NotInFilter notIn(Object... valuesNotToMatch) {
+    return Assertions.notIn(valuesNotToMatch);
+  }
+
+  /**
+   * Create a {@link FilterOperator} to use in {@link AbstractIterableAssert#filteredOn(String, FilterOperator)
+   * filteredOn(String, FilterOperation)} to express a filter keeping all Iterable elements whose property/field
+   * value matches does not match the given value.
+   * <p>
+   * As often, an example helps:
+   * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   *
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   *
+   * assertThat(employees).filteredOn("age", not(800))
+   *                      .containsOnly(luke, noname);</code></pre>
+   *
+   * @param valueNotToMatch the value not to match
+   * @return the created "not" filter
+   *
+   * @since 3.20.0
+   */
+  public static NotFilter not(Object valueNotToMatch) {
+    return Assertions.not(valueNotToMatch);
+  }
+
+  // --------------------------------------------------------------------------------------------------
+  // File methods : not assertions but here to have a single entry point to all AssertJ features.
+  // --------------------------------------------------------------------------------------------------
+
+  /**
+   * Loads the text content of a file, so that it can be passed to {@link #assertThat(String)}.
+   * <p>
+   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative
+   * with {@link #assertThat(File)}.
+   * </p>
+   *
+   * @param file the file.
+   * @param charset the character set to use.
+   * @return the content of the file.
+   * @throws NullPointerException if the given charset is {@code null}.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static String contentOf(File file, Charset charset) {
+    return Assertions.contentOf(file, charset);
+  }
+
+  /**
+   * Loads the text content of a file, so that it can be passed to {@link #assertThat(String)}.
+   * <p>
+   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative
+   * with {@link #assertThat(File)}.
+   * </p>
+   *
+   * @param file the file.
+   * @param charsetName the name of the character set to use.
+   * @return the content of the file.
+   * @throws IllegalArgumentException if the given character set is not supported on this platform.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static String contentOf(File file, String charsetName) {
+    return Assertions.contentOf(file, charsetName);
+  }
+
+  /**
+   * Loads the text content of a file with the default character set, so that it can be passed to
+   * {@link #assertThat(String)}.
+   * <p>
+   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative
+   * with {@link #assertThat(File)}.
+   * </p>
+   *
+   * @param file the file.
+   * @return the content of the file.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static String contentOf(File file) {
+    return Assertions.contentOf(file, Charset.defaultCharset());
+  }
+
+  /**
+   * Loads the text content of a file into a list of strings with the default charset, each string corresponding to a
+   * line.
+   * The line endings are either \n, \r or \r\n.
+   *
+   * @param file the file.
+   * @return the content of the file.
+   * @throws NullPointerException if the given charset is {@code null}.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static List<String> linesOf(File file) {
+    return Assertions.linesOf(file, Charset.defaultCharset());
+  }
+
+  /**
+   * Loads the text content of a file into a list of strings, each string corresponding to a line.
+   * The line endings are either \n, \r or \r\n.
+   *
+   * @param file the file.
+   * @param charset the character set to use.
+   * @return the content of the file.
+   * @throws NullPointerException if the given charset is {@code null}.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static List<String> linesOf(File file, Charset charset) {
+    return Assertions.linesOf(file, charset);
+  }
+
+  /**
+   * Loads the text content of a file into a list of strings, each string corresponding to a line. The line endings are
+   * either \n, \r or \r\n.
+   *
+   * @param file the file.
+   * @param charsetName the name of the character set to use.
+   * @return the content of the file.
+   * @throws NullPointerException if the given charset is {@code null}.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static List<String> linesOf(File file, String charsetName) {
+    return Assertions.linesOf(file, charsetName);
+  }
+
+  // --------------------------------------------------------------------------------------------------
+  // URL/Resource methods : not assertions but here to have a single entry point to all AssertJ features.
+  // --------------------------------------------------------------------------------------------------
+
+  /**
+   * Loads the text content of a URL, so that it can be passed to {@link #assertThat(String)}.
+   * <p>
+   * Note that this will load the entire contents in memory.
+   * </p>
+   *
+   * @param url the URL.
+   * @param charset the character set to use.
+   * @return the content of the URL.
+   * @throws NullPointerException if the given charset is {@code null}.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static String contentOf(URL url, Charset charset) {
+    return Assertions.contentOf(url, charset);
+  }
+
+  /**
+   * Loads the text content of a URL, so that it can be passed to {@link #assertThat(String)}.
+   * <p>
+   * Note that this will load the entire contents in memory.
+   * </p>
+   *
+   * @param url the URL.
+   * @param charsetName the name of the character set to use.
+   * @return the content of the URL.
+   * @throws IllegalArgumentException if the given character set is not supported on this platform.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static String contentOf(URL url, String charsetName) {
+    return Assertions.contentOf(url, charsetName);
+  }
+
+  /**
+   * Loads the text content of a URL with the default character set, so that it can be passed to
+   * {@link #assertThat(String)}.
+   * <p>
+   * Note that this will load the entire file in memory; for larger files.
+   * </p>
+   *
+   * @param url the URL.
+   * @return the content of the file.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static String contentOf(URL url) {
+    return Assertions.contentOf(url, Charset.defaultCharset());
+  }
+
+  /**
+   * Loads the text content of a URL into a list of strings with the default charset, each string corresponding to a
+   * line.
+   * The line endings are either \n, \r or \r\n.
+   *
+   * @param url the URL.
+   * @return the content of the file.
+   * @throws NullPointerException if the given charset is {@code null}.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static List<String> linesOf(URL url) {
+    return Assertions.linesOf(url, Charset.defaultCharset());
+  }
+
+  /**
+   * Loads the text content of a URL into a list of strings, each string corresponding to a line.
+   * The line endings are either \n, \r or \r\n.
+   *
+   * @param url the URL.
+   * @param charset the character set to use.
+   * @return the content of the file.
+   * @throws NullPointerException if the given charset is {@code null}.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static List<String> linesOf(URL url, Charset charset) {
+    return Assertions.linesOf(url, charset);
+  }
+
+  /**
+   * Loads the text content of a URL into a list of strings, each string corresponding to a line. The line endings are
+   * either \n, \r or \r\n.
+   *
+   * @param url the URL.
+   * @param charsetName the name of the character set to use.
+   * @return the content of the file.
+   * @throws NullPointerException if the given charset is {@code null}.
+   * @throws UncheckedIOException if an I/O exception occurs.
+   *
+   * @since 3.20.0
+   */
+  public static List<String> linesOf(URL url, String charsetName) {
+    return Assertions.linesOf(url, charsetName);
+  }
+
+  // --------------------------------------------------------------------------------------------------
+  // Date formatting methods : not assertions but here to have a single entry point to all AssertJ features.
+  // --------------------------------------------------------------------------------------------------
+
+  /**
+   * Instead of using default strict date/time parsing, it is possible to use lenient parsing mode for default date
+   * formats parser to interpret inputs that do not precisely match supported date formats (lenient parsing).
+   * <p>
+   * With strict parsing, inputs must match exactly date/time format.
+   *
+   * <p>
+   * Example:
+   * <pre><code class='java'> final Date date = Dates.parse("2001-02-03");
+   * final Date dateTime = parseDatetime("2001-02-03T04:05:06");
+   * final Date dateTimeWithMs = parseDatetimeWithMs("2001-02-03T04:05:06.700");
+   *
+   * Assertions.setLenientDateParsing(true);
+   *
+   * // assertions will pass
+   * assertThat(date).isEqualTo("2001-01-34");
+   * assertThat(date).isEqualTo("2001-02-02T24:00:00");
+   * assertThat(date).isEqualTo("2001-02-04T-24:00:00.000");
+   * assertThat(dateTime).isEqualTo("2001-02-03T04:05:05.1000");
+   * assertThat(dateTime).isEqualTo("2001-02-03T04:04:66");
+   * assertThat(dateTimeWithMs).isEqualTo("2001-02-03T04:05:07.-300");
+   *
+   * // assertions will fail
+   * assertThat(date).hasSameTimeAs("2001-02-04"); // different date
+   * assertThat(dateTime).hasSameTimeAs("2001-02-03 04:05:06"); // leniency does not help here</code></pre>
+   *
+   * To revert to default strict date parsing, call {@code setLenientDateParsing(false)}.
+   *
+   * @param value whether lenient parsing mode should be enabled or not
+   *
+   * @since 3.20.0
+   */
+  public static void setLenientDateParsing(boolean value) {
+    Assertions.setLenientDateParsing(value);
+  }
+
+  /**
+   * Add the given date format to the ones used to parse date String in String based Date assertions like
+   * {@link org.assertj.core.api.AbstractDateAssert#isEqualTo(String)}.
+   * <p>
+   * User date formats are used before default ones in the order they have been registered (first registered, first
+   * used).
+   * <p>
+   * AssertJ is gonna use any date formats registered with one of these methods :
+   * <ul>
+   * <li>{@link org.assertj.core.api.AbstractDateAssert#withDateFormat(String)}</li>
+   * <li>{@link org.assertj.core.api.AbstractDateAssert#withDateFormat(java.text.DateFormat)}</li>
+   * <li>{@link #registerCustomDateFormat(java.text.DateFormat)}</li>
+   * <li>{@link #registerCustomDateFormat(String)}</li>
+   * </ul>
+   * <p>
+   * Beware that AssertJ will use the newly registered format for <b>all remaining Date assertions in the test suite</b>
+   * <p>
+   * To revert to default formats only, call {@link #useDefaultDateFormatsOnly()} or
+   * {@link org.assertj.core.api.AbstractDateAssert#withDefaultDateFormatsOnly()}.
+   * <p>
+   * Code examples:
+   * <pre><code class='java'> Date date = ... // set to 2003 April the 26th
+   * assertThat(date).isEqualTo("2003-04-26");
+   *
+   * try {
+   *   // date with a custom format : failure since the default formats don't match.
+   *   assertThat(date).isEqualTo("2003/04/26");
+   * } catch (AssertionError e) {
+   *   assertThat(e).hasMessage("Failed to parse 2003/04/26 with any of these date formats: " +
+   *                            "[yyyy-MM-dd'T'HH:mm:ss.SSSX, yyyy-MM-dd'T'HH:mm:ss.SSS, " +
+   *                            "yyyy-MM-dd'T'HH:mm:ssX, " +
+   *                            "yyyy-MM-dd'T'HH:mm:ss, yyyy-MM-dd]");
+   * }
+   *
+   * // registering a custom date format to make the assertion pass
+   * registerCustomDateFormat(new SimpleDateFormat("yyyy/MM/dd")); // registerCustomDateFormat("yyyy/MM/dd") would work to.
+   * assertThat(date).isEqualTo("2003/04/26");
+   *
+   * // the default formats are still available and should work
+   * assertThat(date).isEqualTo("2003-04-26");</code></pre>
+   *
+   * @param userCustomDateFormat the new Date format used for String based Date assertions.
+   *
+   * @since 3.20.0
+   */
+  public static void registerCustomDateFormat(DateFormat userCustomDateFormat) {
+    Assertions.registerCustomDateFormat(userCustomDateFormat);
+  }
+
+  /**
+   * Add the given date format to the ones used to parse date String in String based Date assertions like
+   * {@link org.assertj.core.api.AbstractDateAssert#isEqualTo(String)}.
+   * <p>
+   * User date formats are used before default ones in the order they have been registered (first registered, first
+   * used).
+   * <p>
+   * AssertJ is gonna use any date formats registered with one of these methods :
+   * <ul>
+   * <li>{@link org.assertj.core.api.AbstractDateAssert#withDateFormat(String)}</li>
+   * <li>{@link org.assertj.core.api.AbstractDateAssert#withDateFormat(java.text.DateFormat)}</li>
+   * <li>{@link #registerCustomDateFormat(java.text.DateFormat)}</li>
+   * <li>{@link #registerCustomDateFormat(String)}</li>
+   * </ul>
+   * <p>
+   * Beware that AssertJ will use the newly registered format for <b>all remaining Date assertions in the test suite</b>.
+   * <p>
+   * To revert to default formats only, call {@link #useDefaultDateFormatsOnly()} or
+   * {@link org.assertj.core.api.AbstractDateAssert#withDefaultDateFormatsOnly()}.
+   * <p>
+   * Code examples:
+   * <pre><code class='java'> Date date = ... // set to 2003 April the 26th
+   * assertThat(date).isEqualTo("2003-04-26");
+   *
+   * try {
+   *   // date with a custom format : failure since the default formats don't match.
+   *   assertThat(date).isEqualTo("2003/04/26");
+   * } catch (AssertionError e) {
+   *   assertThat(e).hasMessage("Failed to parse 2003/04/26 with any of these date formats: " +
+   *                            "[yyyy-MM-dd'T'HH:mm:ss.SSSX, yyyy-MM-dd'T'HH:mm:ss.SSS, " +
+   *                            "yyyy-MM-dd'T'HH:mm:ssX, " +
+   *                            "yyyy-MM-dd'T'HH:mm:ss, yyyy-MM-dd]");
+   * }
+   *
+   * // registering a custom date format to make the assertion pass
+   * registerCustomDateFormat("yyyy/MM/dd");
+   * assertThat(date).isEqualTo("2003/04/26");
+   *
+   * // the default formats are still available and should work
+   * assertThat(date).isEqualTo("2003-04-26");</code></pre>
+   *
+   * @param userCustomDateFormatPattern the new Date format pattern used for String based Date assertions.
+   *
+   * @since 3.20.0
+   */
+  public static void registerCustomDateFormat(String userCustomDateFormatPattern) {
+    Assertions.registerCustomDateFormat(userCustomDateFormatPattern);
+  }
+
+  /**
+   * Remove all registered custom date formats =&gt; use only the defaults date formats to parse string as date.
+   * <p>
+   * Beware that the default formats are expressed in the current local timezone.
+   * <p>
+   * Defaults date format are:
+   * <ul>
+   * <li><code>yyyy-MM-dd HH:mm:ss.SSSX</code></li>
+   * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
+   * <li><code>yyyy-MM-dd HH:mm:ss.SSS</code> (for {@link java.sql.Timestamp} String representation support)</li>
+   * <li><code>yyyy-MM-dd'T'HH:mm:ssX</code></li>
+   * <li><code>yyyy-MM-dd'T'HH:mm:ss</code></li>
+   * <li><code>yyyy-MM-dd</code></li>
+   * </ul>
+   * <p>
+   * Example of valid string date representations:
+   * <ul>
+   * <li><code>2003-04-26T03:01:02.999</code></li>
+   * <li><code>2003-04-26 03:01:02.999</code></li>
+   * <li><code>2003-04-26T13:01:02</code></li>
+   * <li><code>2003-04-26</code></li>
+   * </ul>
+   *
+   * @since 3.20.0
+   */
+  public static void useDefaultDateFormatsOnly() {
+    Assertions.useDefaultDateFormatsOnly();
+  }
+
+  /**
+   * Register a {@link Representation} that will be used in all following assertions.
+   * <p>
+   * {@link Representation} are used to format types in assertions error messages.
+   * <p>
+   * An alternative way of using a different representation is to register one as a service,
+   * this approach is described in {@link Representation}, it requires more work than this method
+   * but has the advantage of not having to do anything in your tests and it would be applied to all the tests globally
+   * <p>
+   * Example :
+   * <pre><code class='java'> private class Example {}
+   *
+   * private class CustomRepresentation extends StandardRepresentation {
+   *
+   *   // override needed to hook specific formatting
+   *   {@literal @}Override
+   *   public String toStringOf(Object o) {
+   *     if (o instanceof Example) return "Example";
+   *     // fallback to default formatting.
+   *     return super.toStringOf(o);
+   *   }
+   *
+   *   // change String representation
+   *   {@literal @}Override
+   *   protected String toStringOf(String s) {
+   *     return "$" + s + "$";
+   *   }
+   * }
+   *
+   * Assertions.useRepresentation(new CustomRepresentation());
+   *
+   * // this assertion fails ...
+   * assertThat(new Example()).isNull();
+   * // ... with error :
+   * // "expected:&lt;[null]&gt; but was:&lt;[Example]&gt;"
+   *
+   * // this one fails ...
+   * assertThat("foo").startsWith("bar");
+   * // ... with error :
+   * // Expecting:
+   * //   &lt;$foo$&gt;
+   * // to start with:
+   * //   &lt;$bar$&gt;</code></pre>
+   *
+   * @param customRepresentation the {@link Representation} to use
+   *
+   * @since 3.20.0
+   */
+  public static void useRepresentation(Representation customRepresentation) {
+    Assertions.useRepresentation(customRepresentation);
+  }
+
+  /**
+   * Assertions error messages uses a {@link Representation} to format the different types involved, using this method
+   * you can control the formatting of a given type by providing a specific formatter.
+   *
+   *
+   * <p>
+   * Registering a formatter makes it available for all AssertJ {@link Representation}:
+   * <ul>
+   * <li>{@link StandardRepresentation}</li>
+   * <li>{@link UnicodeRepresentation}</li>
+   * <li>{@link HexadecimalRepresentation}</li>
+   * <li>{@link BinaryRepresentation}</li>
+   * </ul>
+   * <p>
+   * Example :
+   * <pre><code class='java'> // without specific formatter
+   * assertThat(STANDARD_REPRESENTATION.toStringOf(123L)).isEqualTo("123L");
+   *
+   * // register a formatter for Long
+   * Assertions.registerFormatterForType(Long.class, value -&gt; "$" + value + "$");
+   *
+   * // now Long will be formatted between in $$ in error message.
+   * assertThat(STANDARD_REPRESENTATION.toStringOf(longNumber)).isEqualTo("$123$");
+   *
+   * // fails with error : expected:&lt;$456$&gt; but was:&lt;$123$&gt;
+   * assertThat(123L).isEqualTo(456L);</code></pre>
+   *
+   * @param <T> the type of format.
+   * @param type the class of the type to format
+   * @param formatter the formatter {@link Function}
+   *
+   * @since 3.5.0
+   */
+  public static <T> void registerFormatterForType(Class<T> type, Function<T, String> formatter) {
+    Assertions.registerFormatterForType(type, formatter);
+  }
+
+  /**
+   * Fallback to use {@link StandardRepresentation} to revert the effect of calling {@link #useRepresentation(Representation)}.
+   *
+   * @since 3.20.0
+   */
+  public static void useDefaultRepresentation() {
+    Assertions.useDefaultRepresentation();
+  }
 }
diff --git a/src/main/java/org/assertj/core/configuration/Configuration.java b/src/main/java/org/assertj/core/configuration/Configuration.java
index 40b727325..b81e0e44d 100644
--- a/src/main/java/org/assertj/core/configuration/Configuration.java
+++ b/src/main/java/org/assertj/core/configuration/Configuration.java
@@ -23,6 +23,7 @@ import java.util.List;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
 
+import org.assertj.core.api.AbstractDateAssert;
 import org.assertj.core.api.Assertions;
 import org.assertj.core.description.Description;
 import org.assertj.core.presentation.Representation;
@@ -337,6 +338,9 @@ public class Configuration {
     Assertions.setDescriptionConsumer(descriptionConsumer());
     Assertions.setPrintAssertionsDescription(printAssertionsDescription());
     Assertions.setMaxStackTraceElementsDisplayed(maxStackTraceElementsDisplayed());
+    // reset the default date formats otherwise a custom config would register them and when another config is applied it would
+    // add to the previous config date formats
+    AbstractDateAssert.useDefaultDateFormatsOnly();
     additionalDateFormats().forEach(Assertions::registerCustomDateFormat);
   }
 
diff --git a/src/main/java/org/assertj/core/data/Offset.java b/src/main/java/org/assertj/core/data/Offset.java
index 61f85c133..b3cb8346c 100644
--- a/src/main/java/org/assertj/core/data/Offset.java
+++ b/src/main/java/org/assertj/core/data/Offset.java
@@ -12,6 +12,8 @@
  */
 package org.assertj.core.data;
 
+import static java.lang.String.format;
+import static java.util.Objects.hash;
 import static java.util.Objects.requireNonNull;
 import static org.assertj.core.util.Preconditions.checkArgument;
 
@@ -29,7 +31,7 @@ public final class Offset<T extends Number> {
 
   public final T value;
   /**
-   * When |actual-expected|=offset and strict is true the assertThat(actual).isCloseTo(expected, offset); assertion will fail. 
+   * When |actual-expected|=offset and strict is true the assertThat(actual).isCloseTo(expected, offset); assertion will fail.
    */
   public final boolean strict;
 
@@ -94,12 +96,12 @@ public final class Offset<T extends Number> {
 
   @Override
   public int hashCode() {
-    return Objects.hash(value, strict);
+    return hash(value, strict);
   }
 
   @Override
   public String toString() {
-    return String.format("%s[value=%s]", getClass().getSimpleName(), value);
+    return format("%s%s[value=%s]", strict ? "strict " : "", getClass().getSimpleName(), value);
   }
 
 }
diff --git a/src/main/java/org/assertj/core/data/TemporalUnitOffset.java b/src/main/java/org/assertj/core/data/TemporalUnitOffset.java
index 6a96ea379..234a63554 100644
--- a/src/main/java/org/assertj/core/data/TemporalUnitOffset.java
+++ b/src/main/java/org/assertj/core/data/TemporalUnitOffset.java
@@ -20,6 +20,7 @@ import static org.assertj.core.util.Preconditions.checkArgument;
 import java.time.Duration;
 import java.time.temporal.Temporal;
 import java.time.temporal.TemporalUnit;
+import java.util.Objects;
 
 /**
  * Base class for {@link TemporalOffset} on basis of {@link TemporalUnit}.
@@ -86,4 +87,18 @@ public abstract class TemporalUnitOffset implements TemporalOffset<Temporal> {
     return unit;
   }
 
+  @Override
+  public int hashCode() {
+    return Objects.hash(value);
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (obj == null) return false;
+    if (getClass() != obj.getClass()) return false;
+    TemporalUnitOffset other = (TemporalUnitOffset) obj;
+    return value == other.value;
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/util/introspection/Introspection.java b/src/main/java/org/assertj/core/util/introspection/Introspection.java
index 17a68745d..3ee5092ad 100644
--- a/src/main/java/org/assertj/core/util/introspection/Introspection.java
+++ b/src/main/java/org/assertj/core/util/introspection/Introspection.java
@@ -81,7 +81,7 @@ public final class Introspection {
   }
 
   @VisibleForTesting
-  public static boolean canIntrospectExtractBareNamePropertyMethods() {
+  public static boolean canExtractBareNamePropertyMethods() {
     return bareNamePropertyMethods;
   }
 
diff --git a/src/test/java/org/assertj/core/api/Assertions_fail_Test.java b/src/test/java/org/assertj/core/api/Assertions_fail_Test.java
deleted file mode 100644
index 757568cf2..000000000
--- a/src/test/java/org/assertj/core/api/Assertions_fail_Test.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- * Copyright 2012-2021 the original author or authors.
- */
-package org.assertj.core.api;
-
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.fail;
-
-import java.util.Optional;
-
-import org.junit.jupiter.api.Test;
-
-class Assertions_fail_Test {
-
-  @Test
-  void should_include_message_when_failing() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> fail("Failed :("))
-                                                   .withMessage("Failed :(");
-  }
-
-  @Test
-  void should_include_message_with_parameters_when_failing() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> fail("Failed %s", ":("))
-                                                   .withMessage("Failed :(");
-  }
-
-  @Test
-  void should_include_message_with_cause_when_failing() {
-    String message = "Some Throwable";
-    Throwable cause = new Throwable();
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> fail(message, cause))
-                                                   .withMessage(message).withCause(cause);
-  }
-
-  @Test
-  void should_return_a_value_to_allow_using_optional_orElseGet() {
-    // GIVEN
-    Optional<Integer> empty = Optional.empty();
-    // THEN
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doSomethingWithInt(empty.orElseGet(() -> fail("Failed :("))))
-                                                   .withMessage("Failed :(");
-  }
-
-  private void doSomethingWithInt(@SuppressWarnings("unused") int parameter) {
-    // just to illustrate the previous test
-  }
-}
diff --git a/src/test/java/org/assertj/core/api/Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test.java b/src/test/java/org/assertj/core/api/Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test.java
index 493c5b5ab..31bc82d95 100644
--- a/src/test/java/org/assertj/core/api/Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test.java
@@ -15,8 +15,10 @@ package org.assertj.core.api;
 import static java.util.Arrays.stream;
 import static java.util.stream.Collectors.toSet;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.Lists.list;
 
 import java.lang.reflect.Method;
+import java.util.List;
 import java.util.Set;
 
 import org.junit.jupiter.api.Test;
@@ -28,60 +30,81 @@ class Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test extends BaseAss
 
   @Test
   void standard_assertions_and_bdd_assertions_should_have_the_same_assertions_methods() {
-    Method[] assertThatMethods = findMethodsWithName(Assertions.class, "assertThat");
-    Method[] thenMethods = findMethodsWithName(BDDAssertions.class, "then");
+    Method[] assertThat_Assertions_methods = findMethodsWithName(Assertions.class, "assertThat");
+    Method[] then_Assertions_methods = findMethodsWithName(BDDAssertions.class, "then");
 
-    assertThat(thenMethods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_METHOD_NAME)
-                           .containsExactlyInAnyOrder(assertThatMethods);
+    assertThat(then_Assertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_METHOD_NAME)
+                                       .containsExactlyInAnyOrder(assertThat_Assertions_methods);
   }
 
   @Test
   void standard_assertions_and_with_assertions_should_have_the_same_assertions_methods() {
-    Method[] assertionsMethods = findMethodsWithName(Assertions.class, "assertThat");
-    Method[] withAssertionsMethods = findMethodsWithName(WithAssertions.class, "assertThat");
+    Method[] assertThat_Assertions_methods = findMethodsWithName(Assertions.class, "assertThat");
+    Method[] assertThat_WithAssertions_methods = findMethodsWithName(WithAssertions.class, "assertThat");
 
-    assertThat(withAssertionsMethods).usingElementComparator(IGNORING_DECLARING_CLASS_ONLY)
-                                     .containsExactlyInAnyOrder(assertionsMethods);
+    assertThat(assertThat_WithAssertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_ONLY)
+                                                 .containsExactlyInAnyOrder(assertThat_Assertions_methods);
   }
 
   @Test
   void standard_assertions_and_with_assertions_should_have_the_same_non_assertions_methods() {
 
-    Set<Method> nonAssertionsMethods = nonAssertionsMethodsOf(Assertions.class.getDeclaredMethods());
-    Set<Method> nonWithAssertionsMethods = nonAssertionsMethodsOf(WithAssertions.class.getDeclaredMethods());
+    Set<Method> non_assertThat_Assertions_methods = non_assertThat_methodsOf(Assertions.class.getDeclaredMethods());
+    Set<Method> non_assertThat_WithAssertions_methods = non_assertThat_methodsOf(WithAssertions.class.getDeclaredMethods());
 
-    assertThat(nonWithAssertionsMethods).usingElementComparator(IGNORING_DECLARING_CLASS_ONLY)
-                                        .containsExactlyInAnyOrderElementsOf(nonAssertionsMethods);
+    assertThat(non_assertThat_WithAssertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_ONLY)
+                                                     .containsExactlyInAnyOrderElementsOf(non_assertThat_Assertions_methods);
+  }
+
+  @Test
+  void standard_assertions_and_bdd_assertions_should_have_the_same_non_assertions_methods() {
+
+    List<String> methodsToIgnore = list("failBecauseExceptionWasNotThrown", "filter", "offset");
+    Set<Method> non_assertThat_methods = non_assertThat_methodsOf(Assertions.class.getDeclaredMethods());
+    non_assertThat_methods = removeMethods(non_assertThat_methods, methodsToIgnore);
+    Set<Method> non_then_methods = non_then_methodsOf(BDDAssertions.class.getDeclaredMethods());
+    non_then_methods = removeMethods(non_then_methods, methodsToIgnore);
+
+    assertThat(non_then_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_METHOD_NAME)
+                                .containsExactlyInAnyOrderElementsOf(non_assertThat_methods);
+  }
+
+  private static Set<Method> removeMethods(Set<Method> methods, List<String> methodsToRemove) {
+    return methods.stream()
+                  .filter(method -> !methodsToRemove.contains(method.getName()))
+                  .collect(toSet());
   }
 
   @Test
   void standard_assertions_and_soft_assertions_should_have_the_same_assertions_methods() {
     // Until the SpecialIgnoredReturnTypes like AssertProvider, XXXNavigableXXXAssert are implemented for
     // the soft assertions we need to ignore them
-    Method[] assertThatMethods = findMethodsWithName(Assertions.class, "assertThat", SPECIAL_IGNORED_RETURN_TYPES);
-    Method[] assertThatSoftMethods = findMethodsWithName(StandardSoftAssertionsProvider.class, "assertThat");
+    Method[] assertThat_Assertions_methods = findMethodsWithName(Assertions.class, "assertThat", SPECIAL_IGNORED_RETURN_TYPES);
+    Method[] assertThat_SoftAssertions_methods = findMethodsWithName(StandardSoftAssertionsProvider.class, "assertThat");
 
     // ignore the return type of soft assertions until they have the same as the Assertions
-    assertThat(assertThatMethods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_RETURN_TYPE)
-                                 .containsExactlyInAnyOrder(assertThatSoftMethods);
-
+    assertThat(assertThat_Assertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_RETURN_TYPE)
+                                             .containsExactlyInAnyOrder(assertThat_SoftAssertions_methods);
   }
 
   @Test
   void bdd_assertions_and_bdd_soft_assertions_should_have_the_same_assertions_methods() {
     // Until the SpecialIgnoredReturnTypes like AssertProvider, XXXNavigableXXXAssert are implemented for
     // the soft assertions we need to ignore them
-    Method[] thenMethods = findMethodsWithName(BDDAssertions.class, "then", SPECIAL_IGNORED_RETURN_TYPES);
-    Method[] thenSoftMethods = findMethodsWithName(BDDSoftAssertionsProvider.class, "then");
+    Method[] then_Assertions_methods = findMethodsWithName(BDDAssertions.class, "then", SPECIAL_IGNORED_RETURN_TYPES);
+    Method[] then_BDDSoftAssertions_methods = findMethodsWithName(BDDSoftAssertionsProvider.class, "then");
 
     // ignore the return type of soft assertions until they have the same as the Assertions
-    assertThat(thenMethods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_RETURN_TYPE)
-                           .containsExactlyInAnyOrder(thenSoftMethods);
+    assertThat(then_Assertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_RETURN_TYPE)
+                                       .containsExactlyInAnyOrder(then_BDDSoftAssertions_methods);
+  }
 
+  private static Set<Method> non_assertThat_methodsOf(Method[] declaredMethods) {
+    return stream(declaredMethods).filter(method -> !method.getName().startsWith("assert")).collect(toSet());
   }
 
-  private static Set<Method> nonAssertionsMethodsOf(Method[] declaredMethods) {
-    return stream(declaredMethods).filter(method -> !method.getName().equals("assertThat")).collect(toSet());
+  private static Set<Method> non_then_methodsOf(Method[] declaredMethods) {
+    return stream(declaredMethods).filter(method -> !method.getName().startsWith("then")).collect(toSet());
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/Assertions_tuple_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertionsBaseTest.java
similarity index 66%
rename from src/test/java/org/assertj/core/api/Assertions_tuple_Test.java
rename to src/test/java/org/assertj/core/api/EntryPointAssertionsBaseTest.java
index 5b5dd36b4..7a31c1d78 100644
--- a/src/test/java/org/assertj/core/api/Assertions_tuple_Test.java
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertionsBaseTest.java
@@ -12,17 +12,11 @@
  */
 package org.assertj.core.api;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Answers.CALLS_REAL_METHODS;
+import static org.mockito.Mockito.mock;
 
-import org.assertj.core.groups.Tuple;
-import org.junit.jupiter.api.Test;
+public class EntryPointAssertionsBaseTest {
 
-class Assertions_tuple_Test {
-
-  @Test
-  void should_create_tuple() {
-    Tuple tuple = Assertions.tuple("Yoda", 800, "Jedi");
-    assertThat(tuple).isEqualTo(new Tuple("Yoda", 800, "Jedi"));
-  }
+  protected static final WithAssertions withAssertions = mock(WithAssertions.class, CALLS_REAL_METHODS);
 
 }
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_allOf_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_allOf_Test.java
new file mode 100644
index 000000000..f40b90ed9
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_allOf_Test.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.Assertions.as;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.InstanceOfAssertFactories.ITERABLE;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.Collection;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.condition.AllOf;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions allOf method")
+class EntryPointAssertions_allOf_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("allOfWithArrayFactories")
+  <T> void should_create_allOf_condition_from_condition_array(Function<Condition<T>[], Condition<T>> allOfFactory) {
+    // GIVEN
+    Condition<T> condition1 = new TestCondition<>("condition 1");
+    Condition<T> condition2 = new TestCondition<>("condition 2");
+    // WHEN
+    Condition<T> allOfCondition = allOfFactory.apply(array(condition1, condition2));
+    // THEN
+    then(allOfCondition).isInstanceOf(AllOf.class)
+                        .extracting("conditions", as(ITERABLE))
+                        .containsExactly(condition1, condition2);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Stream<Function<Condition<T>[], Condition<T>>> allOfWithArrayFactories() {
+    return Stream.of(Assertions::allOf, BDDAssertions::allOf, withAssertions::allOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("allOfWithCollectionFactories")
+  <T> void should_create_allOf_condition_from_condition_collection(Function<Collection<Condition<T>>, Condition<T>> allOfFactory) {
+    // GIVEN
+    Condition<T> condition1 = new TestCondition<>("condition 1");
+    Condition<T> condition2 = new TestCondition<>("condition 2");
+    // WHEN
+    Condition<T> allOfCondition = allOfFactory.apply(list(condition1, condition2));
+    // THEN
+    then(allOfCondition).isInstanceOf(AllOf.class)
+                        .extracting("conditions", as(ITERABLE))
+                        .containsExactly(condition1, condition2);
+  }
+
+  private static <T> Stream<Function<Collection<Condition<T>>, Condition<T>>> allOfWithCollectionFactories() {
+    return Stream.of(Assertions::allOf, BDDAssertions::allOf, withAssertions::allOf);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_anyOf_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_anyOf_Test.java
new file mode 100644
index 000000000..b3c18ecff
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_anyOf_Test.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.Assertions.as;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.InstanceOfAssertFactories.ITERABLE;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.Collection;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.condition.AnyOf;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions anyOf method")
+class EntryPointAssertions_anyOf_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("anyOfWithArrayFactories")
+  <T> void should_create_anyOf_condition_from_condition_array(Function<Condition<T>[], Condition<T>> anyOfFactory) {
+    // GIVEN
+    Condition<T> condition1 = new TestCondition<>("condition 1");
+    Condition<T> condition2 = new TestCondition<>("condition 2");
+    // WHEN
+    Condition<T> anyOfCondition = anyOfFactory.apply(array(condition1, condition2));
+    // THEN
+    then(anyOfCondition).isInstanceOf(AnyOf.class)
+                        .extracting("conditions", as(ITERABLE))
+                        .containsExactly(condition1, condition2);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Stream<Function<Condition<T>[], Condition<T>>> anyOfWithArrayFactories() {
+    return Stream.of(Assertions::anyOf, BDDAssertions::anyOf, withAssertions::anyOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("anyOfWithCollectionFactories")
+  <T> void should_create_anyOf_condition_from_condition_collection(Function<Collection<Condition<T>>, Condition<T>> anyOfFactory) {
+    // GIVEN
+    Condition<T> condition1 = new TestCondition<>("condition 1");
+    Condition<T> condition2 = new TestCondition<>("condition 2");
+    // WHEN
+    Condition<T> anyOfCondition = anyOfFactory.apply(list(condition1, condition2));
+    // THEN
+    then(anyOfCondition).isInstanceOf(AnyOf.class)
+                        .extracting("conditions", as(ITERABLE))
+                        .containsExactly(condition1, condition2);
+  }
+
+  private static <T> Stream<Function<Collection<Condition<T>>, Condition<T>>> anyOfWithCollectionFactories() {
+    return Stream.of(Assertions::anyOf, BDDAssertions::anyOf, withAssertions::anyOf);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/Assertions_as_with_InstanceOfAssertFactory_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_as_with_InstanceOfAssertFactory_Test.java
similarity index 50%
rename from src/test/java/org/assertj/core/api/Assertions_as_with_InstanceOfAssertFactory_Test.java
rename to src/test/java/org/assertj/core/api/EntryPointAssertions_as_with_InstanceOfAssertFactory_Test.java
index 60c7c89e0..4e32f629c 100644
--- a/src/test/java/org/assertj/core/api/Assertions_as_with_InstanceOfAssertFactory_Test.java
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_as_with_InstanceOfAssertFactory_Test.java
@@ -15,23 +15,34 @@ package org.assertj.core.api;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.mockito.Mockito.mock;
 
-import org.junit.jupiter.api.Test;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests for <code>{@link Assertions#as(InstanceOfAssertFactory)}</code>.
  *
  * @author Stefano Cordio
  */
-class Assertions_as_with_InstanceOfAssertFactory_Test {
+@DisplayName("EntryPoint assertions as(InstanceOfAssertFactory) method")
+class EntryPointAssertions_as_with_InstanceOfAssertFactory_Test extends EntryPointAssertionsBaseTest {
 
-  @Test
-  void should_return_the_given_assert_factory() {
+  @ParameterizedTest
+  @MethodSource("asInstanceOfAssertFactoryFactories")
+  void should_return_the_given_assert_factory(Function<InstanceOfAssertFactory<?, AbstractAssert<?, ?>>, InstanceOfAssertFactory<?, AbstractAssert<?, ?>>> asInstanceOfAssertFactory) {
     // GIVEN
     InstanceOfAssertFactory<?, AbstractAssert<?, ?>> assertFactory = mock(InstanceOfAssertFactory.class);
     // WHEN
-    InstanceOfAssertFactory<?, AbstractAssert<?, ?>> result = Assertions.as(assertFactory);
+    InstanceOfAssertFactory<?, AbstractAssert<?, ?>> result = asInstanceOfAssertFactory.apply(assertFactory);
     // THEN
     then(result).isSameAs(assertFactory);
   }
 
+  private static Stream<Function<InstanceOfAssertFactory<?, AbstractAssert<?, ?>>, InstanceOfAssertFactory<?, AbstractAssert<?, ?>>>> asInstanceOfAssertFactoryFactories() {
+    return Stream.of(Assertions::as, BDDAssertions::as, withAssertions::as);
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_atIndex_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_atIndex_Test.java
new file mode 100644
index 000000000..014213e95
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_atIndex_Test.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.data.Index;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions atIndex method")
+class EntryPointAssertions_atIndex_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("indexFactories")
+  void should_create_index(Function<Integer, Index> indexFactory) {
+    // GIVEN
+    int indexValue = 1;
+    // WHEN
+    Index index = indexFactory.apply(indexValue);
+    // THEN
+    then(index).isEqualTo(Index.atIndex(indexValue));
+  }
+
+  private static Stream<Function<Integer, Index>> indexFactories() {
+    return Stream.of(Assertions::atIndex, BDDAssertions::atIndex, withAssertions::atIndex);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_byLessThan_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_byLessThan_Test.java
new file mode 100644
index 000000000..60bf436b5
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_byLessThan_Test.java
@@ -0,0 +1,171 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.Offset.strictOffset;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.time.temporal.ChronoUnit;
+import java.time.temporal.TemporalUnit;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.data.Offset;
+import org.assertj.core.data.TemporalUnitLessThanOffset;
+import org.assertj.core.data.TemporalUnitOffset;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions byLessThan method")
+class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("bigDecimalOffsetFactories")
+  void should_create_BigDecimal_strictOffset(Function<BigDecimal, Offset<BigDecimal>> offsetFactory) {
+    // GIVEN
+    BigDecimal offsetValue = BigDecimal.ONE;
+    // WHEN
+    Offset<BigDecimal> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(strictOffset(offsetValue));
+  }
+
+  private static Stream<Function<BigDecimal, Offset<BigDecimal>>> bigDecimalOffsetFactories() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+
+  @ParameterizedTest
+  @MethodSource("bigIntegerOffsetFactories")
+  void should_create_BigInteger_strictOffset(Function<BigInteger, Offset<BigInteger>> offsetFactory) {
+    // GIVEN
+    BigInteger offsetValue = BigInteger.ONE;
+    // WHEN
+    Offset<BigInteger> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(strictOffset(offsetValue));
+  }
+
+  private static Stream<Function<BigInteger, Offset<BigInteger>>> bigIntegerOffsetFactories() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+
+  @ParameterizedTest
+  @MethodSource("byteOffsetFactories")
+  void should_create_Byte_strictOffset(Function<Byte, Offset<Byte>> offsetFactory) {
+    // GIVEN
+    Byte offsetValue = Byte.MAX_VALUE;
+    // WHEN
+    Offset<Byte> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(strictOffset(offsetValue));
+  }
+
+  private static Stream<Function<Byte, Offset<Byte>>> byteOffsetFactories() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+
+  @ParameterizedTest
+  @MethodSource("doubleOffsetFactories")
+  void should_create_Double_strictOffset(Function<Double, Offset<Double>> offsetFactory) {
+    // GIVEN
+    Double offsetValue = Double.MAX_VALUE;
+    // WHEN
+    Offset<Double> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(strictOffset(offsetValue));
+  }
+
+  private static Stream<Function<Double, Offset<Double>>> doubleOffsetFactories() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+
+  @ParameterizedTest
+  @MethodSource("floatOffsetFactories")
+  void should_create_Float_strictOffset(Function<Float, Offset<Float>> offsetFactory) {
+    // GIVEN
+    Float offsetValue = Float.MAX_VALUE;
+    // WHEN
+    Offset<Float> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(strictOffset(offsetValue));
+  }
+
+  private static Stream<Function<Float, Offset<Float>>> floatOffsetFactories() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+
+  @ParameterizedTest
+  @MethodSource("integerOffsetFactories")
+  void should_create_Integer_strictOffset(Function<Integer, Offset<Integer>> offsetFactory) {
+    // GIVEN
+    Integer offsetValue = Integer.MAX_VALUE;
+    // WHEN
+    Offset<Integer> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(strictOffset(offsetValue));
+  }
+
+  private static Stream<Function<Integer, Offset<Integer>>> integerOffsetFactories() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+
+  @ParameterizedTest
+  @MethodSource("longOffsetFactories")
+  void should_create_Long_strictOffset(Function<Long, Offset<Long>> offsetFactory) {
+    // GIVEN
+    Long offsetValue = Long.MAX_VALUE;
+    // WHEN
+    Offset<Long> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(strictOffset(offsetValue));
+  }
+
+  private static Stream<Function<Long, Offset<Long>>> longOffsetFactories() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+
+  @ParameterizedTest
+  @MethodSource("temporalOffsetFactories")
+  void should_create_temporal_strictOffset(BiFunction<Long, TemporalUnit, TemporalUnitOffset> offsetFactory) {
+    // GIVEN
+    Long value = Long.MAX_VALUE;
+    TemporalUnit temporalUnit = ChronoUnit.MINUTES;
+    // WHEN
+    TemporalUnitOffset index = offsetFactory.apply(value, temporalUnit);
+    // THEN
+    then(index).isEqualTo(new TemporalUnitLessThanOffset(value, temporalUnit));
+  }
+
+  private static Stream<BiFunction<Long, TemporalUnit, TemporalUnitOffset>> temporalOffsetFactories() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+
+  @ParameterizedTest
+  @MethodSource("shortOffsetFactories")
+  void should_create_Short_strictOffset(Function<Short, Offset<Short>> offsetFactory) {
+    // GIVEN
+    Short offsetValue = Short.MAX_VALUE;
+    // WHEN
+    Offset<Short> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(strictOffset(offsetValue));
+  }
+
+  private static Stream<Function<Short, Offset<Short>>> shortOffsetFactories() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_catchThrowableOfType_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_catchThrowableOfType_Test.java
new file mode 100644
index 000000000..6422e48d8
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_catchThrowableOfType_Test.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.BiFunction;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class EntryPointAssertions_catchThrowableOfType_Test extends EntryPointAssertionsBaseTest {
+
+  private static final RuntimeException RUNTIME_EXCEPTION = new RuntimeException();
+
+  @ParameterizedTest
+  @MethodSource("catchThrowableOfTypes")
+  void should_catch_throwable_of_type(BiFunction<ThrowingCallable, Class<RuntimeException>, RuntimeException> catchThrowableOfType) {
+    // GIVEN
+    ThrowingCallable throwingCallable = () -> {
+      throw RUNTIME_EXCEPTION;
+    };
+    // WHEN
+    RuntimeException throwable = catchThrowableOfType.apply(throwingCallable, RuntimeException.class);
+    // THEN
+    then(throwable).isSameAs(RUNTIME_EXCEPTION);
+  }
+
+  private static Stream<BiFunction<ThrowingCallable, Class<RuntimeException>, RuntimeException>> catchThrowableOfTypes() {
+    return Stream.of(Assertions::catchThrowableOfType, BDDAssertions::catchThrowableOfType, withAssertions::catchThrowableOfType);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_catchThrowable_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_catchThrowable_Test.java
new file mode 100644
index 000000000..7ddad44c3
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_catchThrowable_Test.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions catchThrowable method")
+class EntryPointAssertions_catchThrowable_Test extends EntryPointAssertionsBaseTest {
+
+  private static final RuntimeException RUNTIME_EXCEPTION = new RuntimeException();
+
+  @ParameterizedTest
+  @MethodSource("catchThrowables")
+  void should_catch_throwables(Function<ThrowingCallable, Throwable> catchThrowable) {
+    // GIVEN
+    ThrowingCallable throwingCallable = () -> {
+      throw RUNTIME_EXCEPTION;
+    };
+    // WHEN
+    Throwable throwable = catchThrowable.apply(throwingCallable);
+    // THEN
+    then(throwable).isSameAs(RUNTIME_EXCEPTION);
+  }
+
+  private static Stream<Function<ThrowingCallable, Throwable>> catchThrowables() {
+    return Stream.of(Assertions::catchThrowable, BDDAssertions::catchThrowable, withAssertions::catchThrowable);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_contentOf_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_contentOf_Test.java
new file mode 100644
index 000000000..7f75a83f7
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_contentOf_Test.java
@@ -0,0 +1,122 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.io.File;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions contentOf method")
+class EntryPointAssertions_contentOf_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("fileContentOfWithCharsetFunctions")
+  void should_read_file_content_with_charset(BiFunction<File, Charset, String> contentOfWithCharsetFunction) {
+    // GIVEN
+    File sampleFile = new File("src/test/resources/utf8.txt");
+    // WHEN
+    String content = contentOfWithCharsetFunction.apply(sampleFile, UTF_8);
+    // THEN
+    then(content).isEqualTo("A text file encoded in UTF-8, with diacritics:\né à");
+  }
+
+  private static Stream<BiFunction<File, Charset, String>> fileContentOfWithCharsetFunctions() {
+    return Stream.of(Assertions::contentOf, BDDAssertions::contentOf, withAssertions::contentOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("fileContentOfWithCharsetAsStringFunctions")
+  void should_read_file_content_with_charset_as_string(BiFunction<File, String, String> contentOfWithCharsetFunction) {
+    // GIVEN
+    File sampleFile = new File("src/test/resources/utf8.txt");
+    // WHEN
+    String content = contentOfWithCharsetFunction.apply(sampleFile, "UTF8");
+    // THEN
+    then(content).isEqualTo("A text file encoded in UTF-8, with diacritics:\né à");
+  }
+
+  private static Stream<BiFunction<File, String, String>> fileContentOfWithCharsetAsStringFunctions() {
+    return Stream.of(Assertions::contentOf, BDDAssertions::contentOf, withAssertions::contentOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("fileContentOfWithDefaultCharsetFunctions")
+  void should_read_file_content_with_default_charset(Function<File, String> contentOfWithDefaultCharsetFunction) {
+    // GIVEN
+    File sampleFile = new File("src/test/resources/ascii.txt");
+    // WHEN
+    String content = contentOfWithDefaultCharsetFunction.apply(sampleFile);
+    // THEN
+    then(content).isEqualTo("abc");
+  }
+
+  private static Stream<Function<File, String>> fileContentOfWithDefaultCharsetFunctions() {
+    return Stream.of(Assertions::contentOf, BDDAssertions::contentOf, withAssertions::contentOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("urlContentOfWithCharsetFunctions")
+  void should_read_url_content_with_charset(BiFunction<URL, Charset, String> contentOfWithCharsetFunction) {
+    // GIVEN
+    URL sampleUrl = ClassLoader.getSystemResource("utf8.txt");
+    // WHEN
+    String content = contentOfWithCharsetFunction.apply(sampleUrl, UTF_8);
+    // THEN
+    then(content).isEqualTo("A text file encoded in UTF-8, with diacritics:\né à");
+  }
+
+  private static Stream<BiFunction<URL, Charset, String>> urlContentOfWithCharsetFunctions() {
+    return Stream.of(Assertions::contentOf, BDDAssertions::contentOf, withAssertions::contentOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("urlContentOfWithCharsetAsStringFunctions")
+  void should_read_url_content_with_charset_as_string(BiFunction<URL, String, String> contentOfWithCharsetFunction) {
+    // GIVEN
+    URL sampleUrl = ClassLoader.getSystemResource("utf8.txt");
+    // WHEN
+    String content = contentOfWithCharsetFunction.apply(sampleUrl, "UTF8");
+    // THEN
+    then(content).isEqualTo("A text file encoded in UTF-8, with diacritics:\né à");
+  }
+
+  private static Stream<BiFunction<URL, String, String>> urlContentOfWithCharsetAsStringFunctions() {
+    return Stream.of(Assertions::contentOf, BDDAssertions::contentOf, withAssertions::contentOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("urlContentOfWithDefaultCharsetFunctions")
+  void should_read_URL_content_with_default_charset(Function<URL, String> contentOfWithDefaultCharsetFunction) {
+    // GIVEN
+    URL sampleUrl = ClassLoader.getSystemResource("ascii.txt");
+    // WHEN
+    String content = contentOfWithDefaultCharsetFunction.apply(sampleUrl);
+    // THEN
+    then(content).isEqualTo("abc");
+  }
+
+  private static Stream<Function<URL, String>> urlContentOfWithDefaultCharsetFunctions() {
+    return Stream.of(Assertions::contentOf, BDDAssertions::contentOf, withAssertions::contentOf);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_doesNotHave_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_doesNotHave_Test.java
new file mode 100644
index 000000000..9e910ddff
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_doesNotHave_Test.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.condition.DoesNotHave;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions doesNotHave method")
+class EntryPointAssertions_doesNotHave_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("doesNotHaveFactories")
+  <T> void should_create_allOf_condition_from_condition_array(Function<Condition<T>, DoesNotHave<T>> doesNotHaveFactory) {
+    // GIVEN
+    Condition<T> condition = new TestCondition<>("condition");
+    // WHEN
+    DoesNotHave<T> doesNotHave = doesNotHaveFactory.apply(condition);
+    // THEN
+    then(doesNotHave).extracting("condition")
+                     .isEqualTo(condition);
+
+  }
+
+  private static <T> Stream<Function<Condition<T>, DoesNotHave<T>>> doesNotHaveFactories() {
+    return Stream.of(Assertions::doesNotHave, BDDAssertions::doesNotHave, withAssertions::doesNotHave);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_entry_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_entry_Test.java
new file mode 100644
index 000000000..99c9f5ed2
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_entry_Test.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.MapEntry.entry;
+
+import java.util.function.BiFunction;
+import java.util.stream.Stream;
+
+import org.assertj.core.data.MapEntry;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions entry method")
+class EntryPointAssertions_entry_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("entryFactories")
+  void should_create_entry(BiFunction<String, String, MapEntry<String, String>> entryFactory) {
+    // GIVEN
+    String key = "key";
+    String value = "value";
+    // WHEN
+    MapEntry<String, String> entry = entryFactory.apply(key, value);
+    // THEN
+    then(entry).isEqualTo(entry(key, value));
+  }
+
+  private static <K, V> Stream<BiFunction<K, V, MapEntry<K, V>>> entryFactories() {
+    return Stream.of(Assertions::entry, BDDAssertions::entry, withAssertions::entry);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_extractProperties_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_extractProperties_Test.java
new file mode 100644
index 000000000..ef05cf76f
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_extractProperties_Test.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.groups.Properties;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions extractProperty method")
+class EntryPointAssertions_extractProperties_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("extractPropertiesFunctions")
+  void should_create_Properties(Function<String, Properties<Object>> extractPropertiesFunction) {
+    // GIVEN
+    String property = "name";
+    // WHEN
+    Properties<Object> properties = extractPropertiesFunction.apply(property);
+    // THEN
+    then(properties).extracting("propertyName")
+                    .isEqualTo(property);
+  }
+
+  private static Stream<Function<String, Properties<Object>>> extractPropertiesFunctions() {
+    return Stream.of(Assertions::extractProperty, BDDAssertions::extractProperty, withAssertions::extractProperty);
+  }
+
+  @ParameterizedTest
+  @MethodSource("extractTypedPropertiesFunctions")
+  void should_create_strongly_typed_Properties(BiFunction<String, Class<String>, Properties<String>> extractTypedPropertiesFunction) {
+    // GIVEN
+    String property = "name";
+    // WHEN
+    Properties<String> properties = extractTypedPropertiesFunction.apply(property, String.class);
+    // THEN
+    then(properties).extracting("propertyName")
+                    .isEqualTo(property);
+  }
+
+  private static Stream<BiFunction<String, Class<String>, Properties<String>>> extractTypedPropertiesFunctions() {
+    return Stream.of(Assertions::extractProperty, BDDAssertions::extractProperty, withAssertions::extractProperty);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_fail_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_fail_Test.java
new file mode 100644
index 000000000..9a53d08d9
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_fail_Test.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.Optional;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions fail method")
+class EntryPointAssertions_fail_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("failFunctions")
+  <T> void should_fail_with_given_message(Function<String, T> failFunction) {
+    // GIVEN
+    String message = "boom!";
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> failFunction.apply(message));
+    // THEN
+    then(assertionError).hasMessage(message);
+  }
+
+  private static <T> Stream<Function<String, T>> failFunctions() {
+    return Stream.of(Assertions::fail, BDDAssertions::fail, withAssertions::fail);
+  }
+
+  @ParameterizedTest
+  @MethodSource("failWithParamFunctions")
+  <T> void should_fail_with_given_message_formatted_with_arguments(BiFunction<String, Object[], T> failWithParamFunction) {
+    // GIVEN
+    String message = "%sm!";
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> failWithParamFunction.apply(message, array("boo")));
+    // THEN
+    then(assertionError).hasMessage("boom!");
+  }
+
+  private static <T> Stream<BiFunction<String, Object[], T>> failWithParamFunctions() {
+    return Stream.of(Assertions::fail, BDDAssertions::fail, withAssertions::fail);
+  }
+
+  @ParameterizedTest
+  @MethodSource("failWithCauseFunctions")
+  <T> void should_fail_with_given_message_with_cause(BiFunction<String, Throwable, T> failWithCauseFunction) {
+    // GIVEN
+    String message = "boom!";
+    Throwable cause = new NullPointerException();
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> failWithCauseFunction.apply(message, cause));
+    // THEN
+    then(assertionError).hasMessage("boom!")
+                        .hasCause(cause);
+  }
+
+  private static <T> Stream<BiFunction<String, Throwable, T>> failWithCauseFunctions() {
+    return Stream.of(Assertions::fail, BDDAssertions::fail, withAssertions::fail);
+  }
+
+  @ParameterizedTest
+  @MethodSource("failFunctions")
+  void should_return_a_value_to_allow_using_optional_orElseGet(Function<String, Integer> failFunction) {
+    // GIVEN
+    String message = "boom!";
+    Optional<Integer> empty = Optional.empty();
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> doSomethingWithInt(empty.orElseGet(() -> failFunction.apply(message))));
+    // THEN
+    then(assertionError).hasMessage("boom!");
+  }
+
+  private void doSomethingWithInt(@SuppressWarnings("unused") int parameter) {
+    // just to illustrate the previous test
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_from_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_from_Test.java
new file mode 100644
index 000000000..c2f1b358e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_from_Test.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions from method")
+class EntryPointAssertions_from_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("fromFunctions")
+  void should_return_same_function(Function<Function<Object, Object>, Function<Object, Object>> fromFunction) {
+    // GIVEN
+    Function<Object, Object> identity = t -> t;
+    // WHEN
+    Function<Object, Object> fromResult = fromFunction.apply(identity);
+    // THEN
+    then(fromResult).isSameAs(identity);
+  }
+
+  private static <F, T> Stream<Function<Function<F, T>, Function<F, T>>> fromFunctions() {
+    return Stream.of(Assertions::from, BDDAssertions::from, withAssertions::from);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_in_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_in_Test.java
new file mode 100644
index 000000000..ce20e289c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_in_Test.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.filter.InFilter;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions in filter method")
+class EntryPointAssertions_in_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("inFunctions")
+  void should_create_allOf_condition_from_condition_array(Function<Object[], InFilter> inFunction) {
+    // GIVEN
+    String[] names = { "joe", "jack" };
+    // WHEN
+    InFilter inFilter = inFunction.apply(names);
+    // THEN
+    then(inFilter).extracting("filterParameter")
+                  .isEqualTo(names);
+  }
+
+  private static Stream<Function<Object[], InFilter>> inFunctions() {
+    return Stream.of(Assertions::in, BDDAssertions::in, withAssertions::in);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_linesOf_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_linesOf_Test.java
new file mode 100644
index 000000000..ac2c27525
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_linesOf_Test.java
@@ -0,0 +1,123 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.io.File;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.List;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions linesOf method")
+class EntryPointAssertionsOf_linesOf_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("fileLinesOfWithCharsetFunctions")
+  void should_read_file_lines_with_charset(BiFunction<File, Charset, List<String>> linesOfWithCharsetFunction) {
+    // GIVEN
+    File sampleFile = new File("src/test/resources/utf8.txt");
+    // WHEN
+    List<String> lines = linesOfWithCharsetFunction.apply(sampleFile, UTF_8);
+    // THEN
+    then(lines).containsExactly("A text file encoded in UTF-8, with diacritics:", "é à");
+  }
+
+  private static Stream<BiFunction<File, Charset, List<String>>> fileLinesOfWithCharsetFunctions() {
+    return Stream.of(Assertions::linesOf, BDDAssertions::linesOf, withAssertions::linesOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("fileLinesOfWithCharsetAsStringFunctions")
+  void should_read_file_lines_with_charset_as_string(BiFunction<File, String, List<String>> linesOfWithCharsetFunction) {
+    // GIVEN
+    File sampleFile = new File("src/test/resources/utf8.txt");
+    // WHEN
+    List<String> lines = linesOfWithCharsetFunction.apply(sampleFile, "UTF8");
+    // THEN
+    then(lines).containsExactly("A text file encoded in UTF-8, with diacritics:", "é à");
+  }
+
+  private static Stream<BiFunction<File, String, List<String>>> fileLinesOfWithCharsetAsStringFunctions() {
+    return Stream.of(Assertions::linesOf, BDDAssertions::linesOf, withAssertions::linesOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("fileLinesOfWithDefaultCharsetFunctions")
+  void should_read_file_lines_with_default_charset(Function<File, List<String>> linesOfWithDefaultCharsetFunction) {
+    // GIVEN
+    File sampleFile = new File("src/test/resources/ascii.txt");
+    // WHEN
+    List<String> lines = linesOfWithDefaultCharsetFunction.apply(sampleFile);
+    // THEN
+    then(lines).containsExactly("abc");
+  }
+
+  private static Stream<Function<File, List<String>>> fileLinesOfWithDefaultCharsetFunctions() {
+    return Stream.of(Assertions::linesOf, BDDAssertions::linesOf, withAssertions::linesOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("urlLinesOfWithCharsetFunctions")
+  void should_read_url_lines_with_charset(BiFunction<URL, Charset, List<String>> linesOfWithCharsetFunction) {
+    // GIVEN
+    URL sampleUrl = ClassLoader.getSystemResource("utf8.txt");
+    // WHEN
+    List<String> lines = linesOfWithCharsetFunction.apply(sampleUrl, UTF_8);
+    // THEN
+    then(lines).containsExactly("A text file encoded in UTF-8, with diacritics:", "é à");
+  }
+
+  private static Stream<BiFunction<URL, Charset, List<String>>> urlLinesOfWithCharsetFunctions() {
+    return Stream.of(Assertions::linesOf, BDDAssertions::linesOf, withAssertions::linesOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("urlLinesOfWithCharsetAsStringFunctions")
+  void should_read_url_lines_with_charset_as_string(BiFunction<URL, String, List<String>> linesOfWithCharsetFunction) {
+    // GIVEN
+    URL sampleUrl = ClassLoader.getSystemResource("utf8.txt");
+    // WHEN
+    List<String> lines = linesOfWithCharsetFunction.apply(sampleUrl, "UTF8");
+    // THEN
+    then(lines).containsExactly("A text file encoded in UTF-8, with diacritics:", "é à");
+  }
+
+  private static Stream<BiFunction<URL, String, List<String>>> urlLinesOfWithCharsetAsStringFunctions() {
+    return Stream.of(Assertions::linesOf, BDDAssertions::linesOf, withAssertions::linesOf);
+  }
+
+  @ParameterizedTest
+  @MethodSource("urlLinesOfWithDefaultCharsetFunctions")
+  void should_read_URL_lines_with_default_charset(Function<URL, List<String>> linesOfWithDefaultCharsetFunction) {
+    // GIVEN
+    URL sampleUrl = ClassLoader.getSystemResource("ascii.txt");
+    // WHEN
+    List<String> lines = linesOfWithDefaultCharsetFunction.apply(sampleUrl);
+    // THEN
+    then(lines).containsExactly("abc");
+  }
+
+  private static Stream<Function<URL, List<String>>> urlLinesOfWithDefaultCharsetFunctions() {
+    return Stream.of(Assertions::linesOf, BDDAssertions::linesOf, withAssertions::linesOf);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_notCondition_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_notCondition_Test.java
new file mode 100644
index 000000000..51bc7132c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_notCondition_Test.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.condition.Not;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions not condition method")
+class EntryPointAssertions_notCondition_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("notFactories")
+  <T> void should_create_allOf_condition_from_condition_array(Function<Condition<T>, Not<T>> notFactory) {
+    // GIVEN
+    Condition<T> condition = new TestCondition<>("condition");
+    // WHEN
+    Not<T> not = notFactory.apply(condition);
+    // THEN
+    then(not).extracting("condition")
+             .isEqualTo(condition);
+
+  }
+
+  private static <T> Stream<Function<Condition<T>, Not<T>>> notFactories() {
+    return Stream.of(Assertions::not, BDDAssertions::not, withAssertions::not);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_notIn_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_notIn_Test.java
new file mode 100644
index 000000000..01524839f
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_notIn_Test.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.filter.NotInFilter;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions notIn filter method")
+class EntryPointAssertions_notIn_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("notInFunctions")
+  void should_create_allOf_condition_from_condition_array(Function<Object[], NotInFilter> notInFunction) {
+    // GIVEN
+    String[] names = { "joe", "jack" };
+    // WHEN
+    NotInFilter notInFilter = notInFunction.apply(names);
+    // THEN
+    then(notInFilter).extracting("filterParameter")
+                     .isEqualTo(names);
+  }
+
+  private static Stream<Function<Object[], NotInFilter>> notInFunctions() {
+    return Stream.of(Assertions::notIn, BDDAssertions::notIn, withAssertions::notIn);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_not_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_not_Test.java
new file mode 100644
index 000000000..06e788281
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_not_Test.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.filter.NotFilter;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions not filter method")
+class EntryPointAssertions_not_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("notFunctions")
+  void should_create_allOf_condition_from_condition_array(Function<Object, NotFilter> notFunction) {
+    // GIVEN
+    String name = "joe";
+    // WHEN
+    NotFilter notFilter = notFunction.apply(name);
+    // THEN
+    then(notFilter).extracting("filterParameter")
+                   .isEqualTo(name);
+  }
+
+  private static Stream<Function<Object, NotFilter>> notFunctions() {
+    return Stream.of(Assertions::not, BDDAssertions::not, withAssertions::not);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_registerDateFormat_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_registerDateFormat_Test.java
new file mode 100644
index 000000000..c7f059ba6
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_registerDateFormat_Test.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions registerCustomDateFormat method")
+class EntryPointAssertions_registerDateFormat_Test extends EntryPointAssertionsBaseTest {
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    AbstractDateAssert.useDefaultDateFormatsOnly();
+  }
+
+  @ParameterizedTest
+  @MethodSource("registerCustomDateFormatFunctions")
+  void should_register_DateFormat(Consumer<DateFormat> registerCustomDateFormatFunction) {
+    // GIVEN
+    DateFormat dateFormat = new SimpleDateFormat();
+    // WHEN
+    registerCustomDateFormatFunction.accept(dateFormat);
+    // THEN
+    then(AbstractDateAssert.userDateFormats.get()).hasSize(1);
+  }
+
+  private static Stream<Consumer<DateFormat>> registerCustomDateFormatFunctions() {
+    return Stream.of(Assertions::registerCustomDateFormat,
+                     BDDAssertions::registerCustomDateFormat,
+                     withAssertions::registerCustomDateFormat);
+  }
+
+  @ParameterizedTest
+  @MethodSource("registerCustomDateFormatAsStringFunctions")
+  void should_register_DateFormat_as_string(Consumer<String> registerCustomDateFormatFunction) {
+    // GIVEN
+    String dateFormatAsString = "yyyyddMM";
+    // WHEN
+    registerCustomDateFormatFunction.accept(dateFormatAsString);
+    // THEN
+    then(AbstractDateAssert.userDateFormats.get()).hasSize(1);
+  }
+
+  private static Stream<Consumer<String>> registerCustomDateFormatAsStringFunctions() {
+    return Stream.of(Assertions::registerCustomDateFormat,
+                     BDDAssertions::registerCustomDateFormat,
+                     withAssertions::registerCustomDateFormat);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_registerFormatterForType_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_registerFormatterForType_Test.java
new file mode 100644
index 000000000..9fa84479c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_registerFormatterForType_Test.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions registerFormatterForType method")
+class EntryPointAssertions_registerFormatterForType_Test extends EntryPointAssertionsBaseTest {
+
+  @AfterEach
+  void afterEachTest() {
+    StandardRepresentation.removeAllRegisteredFormatters();
+  }
+
+  @ParameterizedTest
+  @MethodSource("registerFormatterForTypeFunctions")
+  void should_register_DateFormat(BiConsumer<Class<Long>, Function<Long, String>> registerFormatterForTypeFunction) {
+    // WHEN
+    registerFormatterForTypeFunction.accept(Long.class, l -> format("%s long", l));
+    // THEN
+    then(StandardRepresentation.STANDARD_REPRESENTATION.toStringOf(3L)).isEqualTo("3 long");
+  }
+
+  private static <T> Stream<BiConsumer<Class<T>, Function<T, String>>> registerFormatterForTypeFunctions() {
+    return Stream.of(Assertions::registerFormatterForType,
+                     BDDAssertions::registerFormatterForType,
+                     withAssertions::registerFormatterForType);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_setAllowComparingPrivateFields_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_setAllowComparingPrivateFields_Test.java
new file mode 100644
index 000000000..f97915adf
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_setAllowComparingPrivateFields_Test.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.assertj.core.util.introspection.FieldSupport;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions setAllowComparingPrivateFields method")
+class EntryPointAssertions_setAllowComparingPrivateFields_Test extends EntryPointAssertionsBaseTest {
+
+  private static final boolean DEFAULT_ALLOW_COMPARING_PRIVATE_FIELDS = FieldSupport.comparison().isAllowedToUsePrivateFields();
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    FieldSupport.comparison().setAllowUsingPrivateFields(DEFAULT_ALLOW_COMPARING_PRIVATE_FIELDS);
+  }
+
+  @ParameterizedTest
+  @MethodSource("setAllowComparingPrivateFieldsFunctions")
+  void should_set_allowComparingPrivateFields_value(Consumer<Boolean> setAllowComparingPrivateFieldsFunction) {
+    // GIVEN
+    boolean allowComparingPrivateFields = !DEFAULT_ALLOW_COMPARING_PRIVATE_FIELDS;
+    // WHEN
+    setAllowComparingPrivateFieldsFunction.accept(allowComparingPrivateFields);
+    // THEN
+    then(FieldSupport.comparison().isAllowedToUsePrivateFields()).isEqualTo(allowComparingPrivateFields);
+  }
+
+  private static Stream<Consumer<Boolean>> setAllowComparingPrivateFieldsFunctions() {
+    return Stream.of(Assertions::setAllowComparingPrivateFields,
+                     BDDAssertions::setAllowComparingPrivateFields,
+                     withAssertions::setAllowComparingPrivateFields);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_setAllowExtractingPrivateFields_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_setAllowExtractingPrivateFields_Test.java
new file mode 100644
index 000000000..c48b65a90
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_setAllowExtractingPrivateFields_Test.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.assertj.core.util.introspection.FieldSupport;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions setAllowExtractingPrivateFields method")
+class EntryPointAssertions_setAllowExtractingPrivateFields_Test extends EntryPointAssertionsBaseTest {
+
+  private static final boolean DEFAULT_ALLOW_EXTRACTING_PRIVATE_FIELDS = FieldSupport.comparison().isAllowedToUsePrivateFields();
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    FieldSupport.extraction().setAllowUsingPrivateFields(DEFAULT_ALLOW_EXTRACTING_PRIVATE_FIELDS);
+  }
+
+  @ParameterizedTest
+  @MethodSource("setAllowExtractingPrivateFieldsFunctions")
+  void should_set_allowComparingPrivateFields_value(Consumer<Boolean> setAllowExtractingPrivateFieldsFunction) {
+    // GIVEN
+    boolean allowComparingPrivateFields = !DEFAULT_ALLOW_EXTRACTING_PRIVATE_FIELDS;
+    // WHEN
+    setAllowExtractingPrivateFieldsFunction.accept(allowComparingPrivateFields);
+    // THEN
+    then(FieldSupport.extraction().isAllowedToUsePrivateFields()).isEqualTo(allowComparingPrivateFields);
+  }
+
+  private static Stream<Consumer<Boolean>> setAllowExtractingPrivateFieldsFunctions() {
+    return Stream.of(Assertions::setAllowExtractingPrivateFields,
+                     BDDAssertions::setAllowExtractingPrivateFields,
+                     withAssertions::setAllowExtractingPrivateFields);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_setExtractBareNamePropertyMethods_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_setExtractBareNamePropertyMethods_Test.java
new file mode 100644
index 000000000..6b2eb9dca
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_setExtractBareNamePropertyMethods_Test.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.assertj.core.util.introspection.Introspection;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions setExtractBareNamePropertyMethods method")
+class EntryPointAssertions_setExtractBareNamePropertyMethods_Test extends EntryPointAssertionsBaseTest {
+
+  private static final boolean DEFAULT_EXTRACTING_BARE_NAME_PROPERTY_METHODS = Introspection.canExtractBareNamePropertyMethods();
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    Introspection.setExtractBareNamePropertyMethods(DEFAULT_EXTRACTING_BARE_NAME_PROPERTY_METHODS);
+  }
+
+  @ParameterizedTest
+  @MethodSource("setAllowExtractingBareNamePropertyMethodsFunctions")
+  void should_set_allowComparingPrivateFields_value(Consumer<Boolean> setAllowExtractingBareNamePropertyMethodsFunction) {
+    // GIVEN
+    boolean extractBareNamePropertyMethods = !DEFAULT_EXTRACTING_BARE_NAME_PROPERTY_METHODS;
+    // WHEN
+    setAllowExtractingBareNamePropertyMethodsFunction.accept(extractBareNamePropertyMethods);
+    // THEN
+    then(Introspection.canExtractBareNamePropertyMethods()).isEqualTo(extractBareNamePropertyMethods);
+  }
+
+  private static Stream<Consumer<Boolean>> setAllowExtractingBareNamePropertyMethodsFunctions() {
+    return Stream.of(Assertions::setExtractBareNamePropertyMethods,
+                     BDDAssertions::setExtractBareNamePropertyMethods,
+                     withAssertions::setExtractBareNamePropertyMethods);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_setLenientDateParsing_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_setLenientDateParsing_Test.java
new file mode 100644
index 000000000..2b80538fa
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_setLenientDateParsing_Test.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.text.DateFormat;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions setLenientDateParsing method")
+class EntryPointAssertions_setLenientDateParsing_Test extends EntryPointAssertionsBaseTest {
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    AbstractDateAssert.setLenientDateParsing(false);
+  }
+
+  @ParameterizedTest
+  @MethodSource("setLenientDateParsingFunctions")
+  void should_setLenientDateParsing(Consumer<Boolean> setLenientDateParsingFunction) {
+    // WHEN
+    setLenientDateParsingFunction.accept(true);
+    // THEN
+    then(AbstractDateAssert.DEFAULT_DATE_FORMATS).allMatch(DateFormat::isLenient);
+  }
+
+  private static Stream<Consumer<Boolean>> setLenientDateParsingFunctions() {
+    return Stream.of(Assertions::setLenientDateParsing,
+                     BDDAssertions::setLenientDateParsing,
+                     withAssertions::setLenientDateParsing);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_setMaxElementsForPrinting_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_setMaxElementsForPrinting_Test.java
new file mode 100644
index 000000000..a124e9f09
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_setMaxElementsForPrinting_Test.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions setMaxElementsForPrinting method")
+class EntryPointAssertions_setMaxElementsForPrinting_Test extends EntryPointAssertionsBaseTest {
+
+  private static final int DEFAULT_MAX_ELEMENTS_FOR_PRINTING = StandardRepresentation.getMaxElementsForPrinting();
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    StandardRepresentation.setMaxElementsForPrinting(DEFAULT_MAX_ELEMENTS_FOR_PRINTING);
+  }
+
+  @ParameterizedTest
+  @MethodSource("setMaxElementsForPrintingFunctions")
+  void should_set_maxElementsForPrinting_value(Consumer<Integer> setMaxElementsForPrintingFunction) {
+    // GIVEN
+    int maxElementsForPrinting = DEFAULT_MAX_ELEMENTS_FOR_PRINTING + 1;
+    // WHEN
+    setMaxElementsForPrintingFunction.accept(maxElementsForPrinting);
+    // THEN
+    then(StandardRepresentation.getMaxElementsForPrinting()).isEqualTo(maxElementsForPrinting);
+  }
+
+  private static Stream<Consumer<Integer>> setMaxElementsForPrintingFunctions() {
+    return Stream.of(Assertions::setMaxElementsForPrinting,
+                     BDDAssertions::setMaxElementsForPrinting,
+                     withAssertions::setMaxElementsForPrinting);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_setMaxLengthForSingleLineDescription_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_setMaxLengthForSingleLineDescription_Test.java
new file mode 100644
index 000000000..bb5607ae6
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_setMaxLengthForSingleLineDescription_Test.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class EntryPointAssertions_setMaxLengthForSingleLineDescription_Test extends EntryPointAssertionsBaseTest {
+
+  private static final int DEFAULT_MAX_LENGTH_FOR_SINGLE_LINE = StandardRepresentation.getMaxLengthForSingleLineDescription();
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    StandardRepresentation.setMaxLengthForSingleLineDescription(DEFAULT_MAX_LENGTH_FOR_SINGLE_LINE);
+  }
+
+  @ParameterizedTest
+  @MethodSource("setMaxLengthForSingleLineDescriptionFunctions")
+  void should_set_maxLengthForSingleLineDescription_value(Consumer<Integer> setMaxLengthForSingleLineDescriptionFunction) {
+    // GIVEN
+    int maxLengthForSingleLineDescription = DEFAULT_MAX_LENGTH_FOR_SINGLE_LINE + 1;
+    // WHEN
+    setMaxLengthForSingleLineDescriptionFunction.accept(maxLengthForSingleLineDescription);
+    // THEN
+    then(StandardRepresentation.getMaxLengthForSingleLineDescription()).isEqualTo(maxLengthForSingleLineDescription);
+  }
+
+  private static Stream<Consumer<Integer>> setMaxLengthForSingleLineDescriptionFunctions() {
+    return Stream.of(Assertions::setMaxLengthForSingleLineDescription,
+                     BDDAssertions::setMaxLengthForSingleLineDescription,
+                     withAssertions::setMaxLengthForSingleLineDescription);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_setMaxStackTraceElementsDisplayed_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_setMaxStackTraceElementsDisplayed_Test.java
new file mode 100644
index 000000000..6c9b97c67
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_setMaxStackTraceElementsDisplayed_Test.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions setMaxStackTraceElementsDisplayed method")
+class EntryPointAssertions_setMaxStackTraceElementsDisplayed_Test extends EntryPointAssertionsBaseTest {
+
+  private static final int DEFAULT_MAX_STACK_TRACE_ELEMENTS_DISPLAYED = StandardRepresentation.getMaxStackTraceElementsDisplayed();
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    StandardRepresentation.setMaxStackTraceElementsDisplayed(DEFAULT_MAX_STACK_TRACE_ELEMENTS_DISPLAYED);
+  }
+
+  @ParameterizedTest
+  @MethodSource("setMaxStackTraceElementsDisplayedFunctions")
+  void should_set_maxStackTraceElementsDisplayed_value(Consumer<Integer> setMaxStackTraceElementsDisplayedFunction) {
+    // GIVEN
+    int maxStackTraceElementsDisplayed = DEFAULT_MAX_STACK_TRACE_ELEMENTS_DISPLAYED + 1;
+    // WHEN
+    setMaxStackTraceElementsDisplayedFunction.accept(maxStackTraceElementsDisplayed);
+    // THEN
+    then(StandardRepresentation.getMaxStackTraceElementsDisplayed()).isEqualTo(maxStackTraceElementsDisplayed);
+  }
+
+  private static Stream<Consumer<Integer>> setMaxStackTraceElementsDisplayedFunctions() {
+    return Stream.of(Assertions::setMaxStackTraceElementsDisplayed,
+                     BDDAssertions::setMaxStackTraceElementsDisplayed,
+                     withAssertions::setMaxStackTraceElementsDisplayed);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_setPrintAssertionsDescription_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_setPrintAssertionsDescription_Test.java
new file mode 100644
index 000000000..c80984554
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_setPrintAssertionsDescription_Test.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions setPrintAssertionsDescription method")
+class EntryPointAssertions_setPrintAssertionsDescription_Test extends EntryPointAssertionsBaseTest {
+
+  private static final boolean DEFAULT_EXTRACTING_BARE_NAME_PROPERTY_METHODS = AbstractAssert.printAssertionsDescription;
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    AbstractAssert.printAssertionsDescription = DEFAULT_EXTRACTING_BARE_NAME_PROPERTY_METHODS;
+  }
+
+  @ParameterizedTest
+  @MethodSource("setPrintAssertionsDescriptionMethodsFunctions")
+  void should_set_printAssertionsDescription_value(Consumer<Boolean> setPrintAssertionsDescriptionMethodsFunction) {
+    // GIVEN
+    boolean printAssertionsDescription = !DEFAULT_EXTRACTING_BARE_NAME_PROPERTY_METHODS;
+    // WHEN
+    setPrintAssertionsDescriptionMethodsFunction.accept(printAssertionsDescription);
+    // THEN
+    then(AbstractAssert.printAssertionsDescription).isEqualTo(printAssertionsDescription);
+  }
+
+  private static Stream<Consumer<Boolean>> setPrintAssertionsDescriptionMethodsFunctions() {
+    return Stream.of(Assertions::setPrintAssertionsDescription,
+                     BDDAssertions::setPrintAssertionsDescription,
+                     WithAssertions::setPrintAssertionsDescription);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_setRemoveAssertJRelatedElementsFromStackTrace_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_setRemoveAssertJRelatedElementsFromStackTrace_Test.java
new file mode 100644
index 000000000..7b2df8154
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_setRemoveAssertJRelatedElementsFromStackTrace_Test.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.assertj.core.internal.Failures;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions setRemoveAssertJRelatedElementsFromStackTrace method")
+class EntryPointAssertions_setRemoveAssertJRelatedElementsFromStackTrace_Test extends EntryPointAssertionsBaseTest {
+
+  private static final Failures FAILURES = Failures.instance();
+  private static final boolean DEFAULT_REMOVE_ASSERTJ_FROM_STACK_TRACE = FAILURES.isRemoveAssertJRelatedElementsFromStackTrace();
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    FAILURES.setRemoveAssertJRelatedElementsFromStackTrace(DEFAULT_REMOVE_ASSERTJ_FROM_STACK_TRACE);
+  }
+
+  @ParameterizedTest
+  @MethodSource("setRemoveAssertJRelatedElementsFromStackTraceMethodsFunctions")
+  void should_set_removeAssertJRelatedElementsFromStackTrace_value(Consumer<Boolean> setRemoveAssertJRelatedElementsFromStackTraceMethodsFunction) {
+    // GIVEN
+    boolean removeAssertJRelatedElementsFromStackTrace = !DEFAULT_REMOVE_ASSERTJ_FROM_STACK_TRACE;
+    // WHEN
+    setRemoveAssertJRelatedElementsFromStackTraceMethodsFunction.accept(removeAssertJRelatedElementsFromStackTrace);
+    // THEN
+    then(FAILURES.isRemoveAssertJRelatedElementsFromStackTrace()).isEqualTo(removeAssertJRelatedElementsFromStackTrace);
+  }
+
+  private static Stream<Consumer<Boolean>> setRemoveAssertJRelatedElementsFromStackTraceMethodsFunctions() {
+    return Stream.of(Assertions::setRemoveAssertJRelatedElementsFromStackTrace,
+                     BDDAssertions::setRemoveAssertJRelatedElementsFromStackTrace,
+                     withAssertions::setRemoveAssertJRelatedElementsFromStackTrace);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_shouldHaveThrown_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_shouldHaveThrown_Test.java
new file mode 100644
index 000000000..c1cb45b2d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_shouldHaveThrown_Test.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPointAssertions shouldHaveThrown")
+class EntryPointAssertions_shouldHaveThrown_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("shouldHaveThrownFunction")
+  <T> void should_throw_an_AssertionError_with_message_indicating_the_expected_excepion(Function<Class<? extends Throwable>, T> shouldHaveThrownFunction) {
+    // GIVEN
+    Class<? extends Throwable> throwableClass = NullPointerException.class;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> shouldHaveThrownFunction.apply(throwableClass));
+    // THEN
+    then(assertionError).hasMessage("NullPointerException should have been thrown");
+  }
+
+  private static <T> Stream<Function<Class<? extends Throwable>, T>> shouldHaveThrownFunction() {
+    return Stream.of(Assertions::shouldHaveThrown, BDDAssertions::shouldHaveThrown, withAssertions::shouldHaveThrown);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_tuple_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_tuple_Test.java
new file mode 100644
index 000000000..4721c76ba
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_tuple_Test.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.groups.Tuple;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions tuple method")
+class EntryPointAssertions_tuple_Test extends EntryPointAssertionsBaseTest {
+
+  private static final int AGE = 800;
+  private static final String JEDI = "Jedi";
+  private static final String YODA = "Yoda";
+
+  @ParameterizedTest
+  @MethodSource("tupleFactories")
+  void should_create_tuple(Function<Object[], Tuple> tupleFactory) {
+    // GIVEN
+    Object[] values = { YODA, AGE, JEDI };
+    // WHEN
+    Tuple result = tupleFactory.apply(values);
+    // THEN
+    then(result).isEqualTo(new Tuple(YODA, AGE, JEDI));
+  }
+
+  private static Stream<Function<Object[], Tuple>> tupleFactories() {
+    return Stream.of(Assertions::tuple, BDDAssertions::tuple, withAssertions::tuple);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_useDefaultDateFormatsOnly_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_useDefaultDateFormatsOnly_Test.java
new file mode 100644
index 000000000..4908b9858
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_useDefaultDateFormatsOnly_Test.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.apache.commons.lang3.tuple.Pair;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions useDefaultDateFormatsOnly method")
+class EntryPointAssertions_useDefaultDateFormatsOnly_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("useDefaultDateFormatsOnlyFunctions")
+  void should_set_default_DefaultDateFormatsOnly(Pair<Consumer<String>, Runnable> params) {
+    // GIVEN
+    params.getLeft().accept("yyyyddMM");
+    then(AbstractDateAssert.userDateFormats.get()).hasSize(1);
+    // WHEN
+    params.getRight().run();
+    // THEN
+    then(AbstractDateAssert.userDateFormats.get()).isEmpty();
+  }
+
+  private static Stream<Pair<Consumer<String>, Runnable>> useDefaultDateFormatsOnlyFunctions() {
+    return Stream.of(Pair.of(Assertions::registerCustomDateFormat, () -> Assertions.useDefaultDateFormatsOnly()),
+                     Pair.of(BDDAssertions::registerCustomDateFormat, () -> BDDAssertions.useDefaultDateFormatsOnly()),
+                     Pair.of(withAssertions::registerCustomDateFormat, () -> withAssertions.useDefaultDateFormatsOnly()));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_useDefaultRepresentation_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_useDefaultRepresentation_Test.java
new file mode 100644
index 000000000..98d21555a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_useDefaultRepresentation_Test.java
@@ -0,0 +1,58 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION_PROVIDER;
+import static org.assertj.core.presentation.HexadecimalRepresentation.HEXA_REPRESENTATION;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.apache.commons.lang3.tuple.Pair;
+import org.assertj.core.presentation.Representation;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions useDefaultRepresentation method")
+class EntryPointAssertions_useDefaultRepresentation_Test extends EntryPointAssertionsBaseTest {
+
+  private static final Representation DEFAULT_CUSTOM_REPRESENTATION = AbstractAssert.customRepresentation;
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    AbstractAssert.customRepresentation = DEFAULT_CUSTOM_REPRESENTATION;
+  }
+
+  @ParameterizedTest
+  @MethodSource("useRepresentationFunctions")
+  void should_set_default_Representation(Pair<Consumer<Representation>, Runnable> params) {
+    // GIVEN
+    params.getLeft().accept(HEXA_REPRESENTATION);
+    // WHEN
+    params.getRight().run();
+    // THEN
+    // TODO we don't go back to null representation, but shoud we?
+    then(AbstractAssert.customRepresentation).isEqualTo(CONFIGURATION_PROVIDER.representation());
+  }
+
+  private static Stream<Pair<Consumer<Representation>, Runnable>> useRepresentationFunctions() {
+    return Stream.of(Pair.of(Assertions::useRepresentation, () -> Assertions.useDefaultRepresentation()),
+                     Pair.of(BDDAssertions::useRepresentation, () -> BDDAssertions.useDefaultRepresentation()),
+                     Pair.of(withAssertions::useRepresentation, () -> withAssertions.useDefaultRepresentation()));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_useRepresentation_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_useRepresentation_Test.java
new file mode 100644
index 000000000..7d186d4c8
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_useRepresentation_Test.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.HexadecimalRepresentation.HEXA_REPRESENTATION;
+
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import org.assertj.core.presentation.Representation;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions useRepresentation method")
+class EntryPointAssertions_useRepresentation_Test extends EntryPointAssertionsBaseTest {
+
+  private static final Representation DEFAULT_CUSTOM_REPRESENTATION = AbstractAssert.customRepresentation;
+
+  @AfterEach
+  void afterEachTest() {
+    // reset to the default value to avoid side effects on the other tests
+    AbstractAssert.customRepresentation = DEFAULT_CUSTOM_REPRESENTATION;
+  }
+
+  @ParameterizedTest
+  @MethodSource("useRepresentationFunctions")
+  void should_set_customRepresentation_value(Consumer<Representation> useRepresentationFunction) {
+    // GIVEN
+    Representation customRepresentation = HEXA_REPRESENTATION;
+    // WHEN
+    useRepresentationFunction.accept(customRepresentation);
+    // THEN
+    then(AbstractAssert.customRepresentation).isEqualTo(customRepresentation);
+  }
+
+  private static Stream<Consumer<Representation>> useRepresentationFunctions() {
+    return Stream.of(Assertions::useRepresentation,
+                     BDDAssertions::useRepresentation,
+                     withAssertions::useRepresentation);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_withMarginOf_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_withMarginOf_Test.java
new file mode 100644
index 000000000..a682a3d67
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_withMarginOf_Test.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.time.Duration;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions withMarginOf method")
+class EntryPointAssertions_withMarginOf_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("durationProviders")
+  void should_return_same_Duration(Function<Duration, Duration> durationFactory) {
+    // GIVEN
+    Duration duration = Duration.ofHours(1);
+    // WHEN
+    Duration result = durationFactory.apply(duration);
+    // THEN
+    then(result).isSameAs(duration);
+  }
+
+  private static Stream<Function<Duration, Duration>> durationProviders() {
+    return Stream.of(Assertions::withMarginOf, BDDAssertions::withMarginOf, withAssertions::withMarginOf);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_withPrecision_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_withPrecision_Test.java
new file mode 100644
index 000000000..69b015d54
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_withPrecision_Test.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.Offset.offset;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.data.Offset;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions withPrecision method")
+class EntryPointAssertions_withPrecision_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("doubleOffsetFactories")
+  void should_create_Double_offset(Function<Double, Offset<Double>> withinFactory) {
+    // GIVEN
+    Double offsetValue = Double.MAX_VALUE;
+    // WHEN
+    Offset<Double> index = withinFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<Double, Offset<Double>>> doubleOffsetFactories() {
+    return Stream.of(Assertions::withPrecision, BDDAssertions::withPrecision, withAssertions::withPrecision);
+  }
+
+  @ParameterizedTest
+  @MethodSource("floatOffsetFactories")
+  void should_create_Float_offset(Function<Float, Offset<Float>> withinFactory) {
+    // GIVEN
+    Float offsetValue = Float.MAX_VALUE;
+    // WHEN
+    Offset<Float> index = withinFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<Float, Offset<Float>>> floatOffsetFactories() {
+    return Stream.of(Assertions::withPrecision, BDDAssertions::withPrecision, withAssertions::withPrecision);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_withinPercentage_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_withinPercentage_Test.java
new file mode 100644
index 000000000..560bdef86
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_withinPercentage_Test.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.Percentage.withPercentage;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.data.Percentage;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions withinPercentage method")
+class EntryPointAssertions_withinPercentage_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("doublePercentageFactories")
+  void should_create_Double_offset(Function<Double, Percentage> percentageFactory) {
+    // GIVEN
+    Double value = 90.0;
+    // WHEN
+    Percentage percentage = percentageFactory.apply(value);
+    // THEN
+    then(percentage).isEqualTo(withPercentage(value));
+  }
+
+  private static Stream<Function<Double, Percentage>> doublePercentageFactories() {
+    return Stream.of(Assertions::withinPercentage, BDDAssertions::withinPercentage, withAssertions::withinPercentage);
+  }
+
+  @ParameterizedTest
+  @MethodSource("integerPercentageFactories")
+  void should_create_Integer_offset(Function<Integer, Percentage> percentageFactory) {
+    // GIVEN
+    Integer value = 90;
+    // WHEN
+    Percentage percentage = percentageFactory.apply(value);
+    // THEN
+    then(percentage).isEqualTo(withPercentage(value));
+  }
+
+  private static Stream<Function<Integer, Percentage>> integerPercentageFactories() {
+    return Stream.of(Assertions::withinPercentage, BDDAssertions::withinPercentage, withAssertions::withinPercentage);
+  }
+
+  @ParameterizedTest
+  @MethodSource("longPercentageFactories")
+  void should_create_Long_offset(Function<Long, Percentage> percentageFactory) {
+    // GIVEN
+    Long value = 90L;
+    // WHEN
+    Percentage percentage = percentageFactory.apply(value);
+    // THEN
+    then(percentage).isEqualTo(withPercentage(value));
+  }
+
+  private static Stream<Function<Long, Percentage>> longPercentageFactories() {
+    return Stream.of(Assertions::withinPercentage, BDDAssertions::withinPercentage, withAssertions::withinPercentage);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/EntryPointAssertions_within_Test.java b/src/test/java/org/assertj/core/api/EntryPointAssertions_within_Test.java
new file mode 100644
index 000000000..bce5a699d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/EntryPointAssertions_within_Test.java
@@ -0,0 +1,171 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.Offset.offset;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.time.temporal.ChronoUnit;
+import java.time.temporal.TemporalUnit;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.data.Offset;
+import org.assertj.core.data.TemporalUnitOffset;
+import org.assertj.core.data.TemporalUnitWithinOffset;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayName("EntryPoint assertions within method")
+class EntryPointAssertions_within_Test extends EntryPointAssertionsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource("bigDecimalOffsetFactories")
+  void should_create_BigDecimal_offset(Function<BigDecimal, Offset<BigDecimal>> offsetFactory) {
+    // GIVEN
+    BigDecimal offsetValue = BigDecimal.ONE;
+    // WHEN
+    Offset<BigDecimal> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<BigDecimal, Offset<BigDecimal>>> bigDecimalOffsetFactories() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+
+  @ParameterizedTest
+  @MethodSource("bigIntegerOffsetFactories")
+  void should_create_BigInteger_offset(Function<BigInteger, Offset<BigInteger>> offsetFactory) {
+    // GIVEN
+    BigInteger offsetValue = BigInteger.ONE;
+    // WHEN
+    Offset<BigInteger> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<BigInteger, Offset<BigInteger>>> bigIntegerOffsetFactories() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+
+  @ParameterizedTest
+  @MethodSource("byteOffsetFactories")
+  void should_create_Byte_offset(Function<Byte, Offset<Byte>> offsetFactory) {
+    // GIVEN
+    Byte offsetValue = Byte.MAX_VALUE;
+    // WHEN
+    Offset<Byte> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<Byte, Offset<Byte>>> byteOffsetFactories() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+
+  @ParameterizedTest
+  @MethodSource("doubleOffsetFactories")
+  void should_create_Double_offset(Function<Double, Offset<Double>> offsetFactory) {
+    // GIVEN
+    Double offsetValue = Double.MAX_VALUE;
+    // WHEN
+    Offset<Double> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<Double, Offset<Double>>> doubleOffsetFactories() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+
+  @ParameterizedTest
+  @MethodSource("floatOffsetFactories")
+  void should_create_Float_offset(Function<Float, Offset<Float>> offsetFactory) {
+    // GIVEN
+    Float offsetValue = Float.MAX_VALUE;
+    // WHEN
+    Offset<Float> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<Float, Offset<Float>>> floatOffsetFactories() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+
+  @ParameterizedTest
+  @MethodSource("integerOffsetFactories")
+  void should_create_Integer_offset(Function<Integer, Offset<Integer>> offsetFactory) {
+    // GIVEN
+    Integer offsetValue = Integer.MAX_VALUE;
+    // WHEN
+    Offset<Integer> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<Integer, Offset<Integer>>> integerOffsetFactories() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+
+  @ParameterizedTest
+  @MethodSource("longOffsetFactories")
+  void should_create_Long_offset(Function<Long, Offset<Long>> offsetFactory) {
+    // GIVEN
+    Long offsetValue = Long.MAX_VALUE;
+    // WHEN
+    Offset<Long> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<Long, Offset<Long>>> longOffsetFactories() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+
+  @ParameterizedTest
+  @MethodSource("temporalOffsetFactories")
+  void should_create_temporal_offset(BiFunction<Long, TemporalUnit, TemporalUnitOffset> offsetFactory) {
+    // GIVEN
+    Long value = Long.MAX_VALUE;
+    TemporalUnit temporalUnit = ChronoUnit.MINUTES;
+    // WHEN
+    TemporalUnitOffset index = offsetFactory.apply(value, temporalUnit);
+    // THEN
+    then(index).isEqualTo(new TemporalUnitWithinOffset(value, temporalUnit));
+  }
+
+  private static Stream<BiFunction<Long, TemporalUnit, TemporalUnitOffset>> temporalOffsetFactories() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+
+  @ParameterizedTest
+  @MethodSource("shortOffsetFactories")
+  void should_create_Short_offset(Function<Short, Offset<Short>> offsetFactory) {
+    // GIVEN
+    Short offsetValue = Short.MAX_VALUE;
+    // WHEN
+    Offset<Short> index = offsetFactory.apply(offsetValue);
+    // THEN
+    then(index).isEqualTo(offset(offsetValue));
+  }
+
+  private static Stream<Function<Short, Offset<Short>>> shortOffsetFactories() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+}
diff --git a/src/test/java/org/assertj/core/configuration/Configuration_apply_Test.java b/src/test/java/org/assertj/core/configuration/Configuration_apply_Test.java
index d95070642..99d28056f 100644
--- a/src/test/java/org/assertj/core/configuration/Configuration_apply_Test.java
+++ b/src/test/java/org/assertj/core/configuration/Configuration_apply_Test.java
@@ -13,6 +13,7 @@
 package org.assertj.core.configuration;
 
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -35,12 +36,12 @@ class Configuration_apply_Test {
     // THEN
     then(FieldSupport.extraction().isAllowedToUsePrivateFields()).isEqualTo(configuration.extractingPrivateFieldsEnabled());
     then(FieldSupport.comparison().isAllowedToUsePrivateFields()).isEqualTo(configuration.comparingPrivateFieldsEnabled());
-    then(Introspection.canIntrospectExtractBareNamePropertyMethods()).isEqualTo(configuration.bareNamePropertyExtractionEnabled());
+    then(Introspection.canExtractBareNamePropertyMethods()).isEqualTo(configuration.bareNamePropertyExtractionEnabled());
     then(configuration.hasCustomRepresentation()).isTrue();
     // a bit dodgy but since our custom representation inherits StandardRepresentation, changing maxElementsForPrinting amd
     // maxLengthForSingleLineDescription will be effective.
     then(StandardRepresentation.getMaxElementsForPrinting()).isEqualTo(configuration.maxElementsForPrinting());
-    then(StandardRepresentation.getMaxStackTraceElementsDisplayed ()).isEqualTo(configuration.maxStackTraceElementsDisplayed ());
+    then(StandardRepresentation.getMaxStackTraceElementsDisplayed()).isEqualTo(configuration.maxStackTraceElementsDisplayed());
     then(StandardRepresentation.getMaxLengthForSingleLineDescription()).isEqualTo(configuration.maxLengthForSingleLineDescription());
     boolean removeAssertJRelatedElementsFromStackTrace = Failures.instance().isRemoveAssertJRelatedElementsFromStackTrace();
     then(removeAssertJRelatedElementsFromStackTrace).isEqualTo(configuration.removeAssertJRelatedElementsFromStackTraceEnabled());
@@ -55,6 +56,19 @@ class Configuration_apply_Test {
               .isEqualTo("2001|02|03");
   }
 
+  @Test
+  void should_reset_date_formats() throws Exception {
+    // GIVEN
+    Configuration configuration = new NonDefaultConfiguration();
+    // WHEN
+    configuration.apply();
+    Configuration.DEFAULT_CONFIGURATION.apply();
+    // THEN
+    then(Configuration.DEFAULT_CONFIGURATION.additionalDateFormats()).isEmpty();
+    Date date = new SimpleDateFormat("yyyy-MM-dd").parse("2001-02-03");
+    expectAssertionError(() -> then(date).isEqualTo("2001_02_03"));
+  }
+
   @AfterEach
   public void afterEach() {
     // revert whatever we did in the other tests
diff --git a/src/test/java/org/assertj/core/data/Offset_Test.java b/src/test/java/org/assertj/core/data/Offset_Test.java
index 1af942d44..c72bab34b 100644
--- a/src/test/java/org/assertj/core/data/Offset_Test.java
+++ b/src/test/java/org/assertj/core/data/Offset_Test.java
@@ -103,4 +103,14 @@ class Offset_Test {
     then(result).isEqualTo("Offset[value=0.0]");
   }
 
+  @Test
+  void toString_should_describe_strict_offset() {
+    // GIVEN
+    Offset<Number> underTest = Offset.strictOffset(1.0);
+    // WHEN
+    String result = underTest.toString();
+    // THEN
+    then(result).isEqualTo("strict Offset[value=1.0]");
+  }
+
 }
diff --git a/src/test/resources/ascii.txt b/src/test/resources/ascii.txt
new file mode 100644
index 000000000..f2ba8f84a
--- /dev/null
+++ b/src/test/resources/ascii.txt
@@ -0,0 +1 @@
+abc
\ No newline at end of file
