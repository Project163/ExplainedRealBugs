diff --git a/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java b/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java
index 84500c6a2..8e3ad6aea 100644
--- a/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java
@@ -28,18 +28,18 @@ public abstract class AbstractComparisonStrategy implements ComparisonStrategy {
 
   @Override
   public Iterable<?> duplicatesFrom(Iterable<?> iterable) {
-	if (isNullOrEmpty(iterable)) return EMPTY_SET;
+    if (isNullOrEmpty(iterable)) return EMPTY_SET;
 
-	Set<Object> duplicates = newSetUsingComparisonStrategy();
-	Set<Object> noDuplicates = newSetUsingComparisonStrategy();
-	for (Object element : iterable) {
-	  if (noDuplicates.contains(element)) {
-		duplicates.add(element);
-	  } else {
-		noDuplicates.add(element);
-	  }
-	}
-	return duplicates;
+    Set<Object> duplicates = newSetUsingComparisonStrategy();
+    Set<Object> noDuplicates = newSetUsingComparisonStrategy();
+    for (Object element : iterable) {
+      if (noDuplicates.contains(element)) {
+        duplicates.add(element);
+      } else {
+        noDuplicates.add(element);
+      }
+    }
+    return duplicates;
   }
 
   /**
@@ -51,44 +51,33 @@ public abstract class AbstractComparisonStrategy implements ComparisonStrategy {
 
   @Override
   public boolean arrayContains(Object array, Object value) {
-	for (int i = 0; i < getLength(array); i++) {
-	  Object element = Array.get(array, i);
-	  if (areEqual(element, value)) {
-		return true;
-	  }
-	}
-	return false;
+    for (int i = 0; i < getLength(array); i++) {
+      Object element = Array.get(array, i);
+      if (areEqual(element, value)) return true;
+    }
+    return false;
   }
 
   @Override
   public boolean isLessThan(Object actual, Object other) {
-	if (areEqual(actual, other)) {
-	  return false;
-	}
-	return !isGreaterThan(actual, other);
+    return !areEqual(actual, other) && !isGreaterThan(actual, other);
   }
 
   @Override
   public boolean isLessThanOrEqualTo(Object actual, Object other) {
-	if (areEqual(actual, other)) {
-	  return true;
-	}
-	return isLessThan(actual, other);
+    return areEqual(actual, other) || isLessThan(actual, other);
   }
 
   @Override
   public boolean isGreaterThanOrEqualTo(Object actual, Object other) {
-	if (areEqual(actual, other)) {
-	  return true;
-	}
-	return isGreaterThan(actual, other);
+    return areEqual(actual, other) || isGreaterThan(actual, other);
   }
 
   public abstract String asText();
-  
+
   @Override
   public boolean isStandard() {
     return false;
   }
-  
+
 }
diff --git a/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java b/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java
index c87fa55bb..2f51bafad 100644
--- a/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java
@@ -40,7 +40,7 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
    * @param comparator the comparison strategy to use.
    */
   public ComparatorBasedComparisonStrategy(@SuppressWarnings("rawtypes") Comparator comparator) {
-	this.comparator = comparator;
+    this.comparator = comparator;
   }
 
   /**
@@ -54,15 +54,15 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   @Override
   @SuppressWarnings("unchecked")
   public boolean iterableContains(Iterable<?> iterable, Object value) {
-	if (isNullOrEmpty(iterable)) return false;
-	for (Object element : iterable) {
-	  // avoid comparison when objects are the same or both null
-	  if (element == value) return true;
-	  // both objects are not null => if one is then the other is not => compare next element with value
-	  if (value == null || element == null) continue;
-	  if (comparator.compare(element, value) == 0) return true;
-	}
-	return false;
+    if (isNullOrEmpty(iterable)) return false;
+    for (Object element : iterable) {
+      // avoid comparison when objects are the same or both null
+      if (element == value) return true;
+      // both objects are not null => if one is then the other is not => compare next element with value
+      if (value == null || element == null) continue;
+      if (comparator.compare(element, value) == 0) return true;
+    }
+    return false;
   }
 
   /**
@@ -76,13 +76,13 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   @Override
   @SuppressWarnings("unchecked")
   public void iterableRemoves(Iterable<?> iterable, Object value) {
-	if (iterable == null) return;
-	Iterator<?> iterator = iterable.iterator();
-	while (iterator.hasNext()) {
-	  if (comparator.compare(iterator.next(), value) == 0) {
-		iterator.remove();
-	  }
-	}
+    if (iterable == null) return;
+    Iterator<?> iterator = iterable.iterator();
+    while (iterator.hasNext()) {
+      if (comparator.compare(iterator.next(), value) == 0) {
+        iterator.remove();
+      }
+    }
   }
 
   @Override
@@ -109,11 +109,9 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   @Override
   @SuppressWarnings("unchecked")
   public boolean areEqual(Object actual, Object other) {
-	if (actual == null) return other == null;
-	// actual is not null
-	if (other == null) return false;
-	// neither actual nor other are null
-	return comparator.compare(actual, other) == 0;
+    // we don't check actual or expected for null, this should be done by the comparator, the rationale being that a
+    // comparator might consider null to be equals to some special value (like blank String and null)
+    return comparator.compare(actual, other) == 0;
   }
 
   /**
@@ -126,19 +124,18 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   // overridden to write javadoc.
   @Override
   public Iterable<?> duplicatesFrom(Iterable<?> iterable) {
-	return super.duplicatesFrom(iterable);
+    return super.duplicatesFrom(iterable);
   }
 
   @SuppressWarnings("unchecked")
   @Override
   protected Set<Object> newSetUsingComparisonStrategy() {
-	return new TreeSet<>(comparator);
+    return new TreeSet<>(comparator);
   }
 
   @Override
   public String asText() {
     return "when comparing values using " + CONFIGURATION_PROVIDER.representation().toStringOf(comparator);
-	// return "according to " + this;
   }
 
   @Override
@@ -147,44 +144,44 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   }
 
   public Comparator<?> getComparator() {
-	return comparator;
+    return comparator;
   }
 
   @Override
   @SuppressWarnings("unchecked")
   public boolean stringStartsWith(String string, String prefix) {
-	if (string.length() < prefix.length()) return false;
-	String stringPrefix = string.substring(0, prefix.length());
-	return comparator.compare(stringPrefix, prefix) == 0;
+    if (string.length() < prefix.length()) return false;
+    String stringPrefix = string.substring(0, prefix.length());
+    return comparator.compare(stringPrefix, prefix) == 0;
   }
 
   @Override
   @SuppressWarnings("unchecked")
   public boolean stringEndsWith(String string, String suffix) {
-	if (string.length() < suffix.length()) return false;
-	String stringSuffix = string.substring(string.length() - suffix.length());
-	return comparator.compare(stringSuffix, suffix) == 0;
+    if (string.length() < suffix.length()) return false;
+    String stringSuffix = string.substring(string.length() - suffix.length());
+    return comparator.compare(stringSuffix, suffix) == 0;
   }
 
   @Override
   public boolean stringContains(String string, String sequence) {
-	int sequenceLength = sequence.length();
-	for (int i = 0; i < string.length(); i++) {
-	  String subString = string.substring(i);
-	  if (subString.length() < sequenceLength) return false;
-	  if (stringStartsWith(subString, sequence)) return true;
-	}
-	return false;
+    int sequenceLength = sequence.length();
+    for (int i = 0; i < string.length(); i++) {
+      String subString = string.substring(i);
+      if (subString.length() < sequenceLength) return false;
+      if (stringStartsWith(subString, sequence)) return true;
+    }
+    return false;
   }
 
   @Override
   @SuppressWarnings("unchecked")
   public boolean isGreaterThan(Object actual, Object other) {
-	return comparator.compare(actual, other) > 0;
+    return comparator.compare(actual, other) > 0;
   }
 
   @Override
   public boolean isStandard() {
-	return false;
+    return false;
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertEqual_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertEqual_Test.java
index 9375f3063..326da7d99 100644
--- a/src/test/java/org/assertj/core/internal/objects/Objects_assertEqual_Test.java
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertEqual_Test.java
@@ -13,15 +13,21 @@
 package org.assertj.core.internal.objects;
 
 import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.mockito.Mockito.verify;
 
 import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.Objects;
 import org.assertj.core.internal.ObjectsBaseTest;
-import org.assertj.core.presentation.StandardRepresentation;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import com.tngtech.java.junit.dataprovider.DataProvider;
+import com.tngtech.java.junit.dataprovider.DataProviderRunner;
 
 /**
  * Tests for <code>{@link Objects#assertEqual(AssertionInfo, Object, Object)}</code>.
@@ -29,8 +35,11 @@ import org.junit.Test;
  * @author Alex Ruiz
  * @author Joel Costigliola
  */
+@RunWith(DataProviderRunner.class)
 public class Objects_assertEqual_Test extends ObjectsBaseTest {
 
+  private static final Objects OBJECTS_WITH_ALWAY_EQUALS_COMPARATOR = new Objects(new ComparatorBasedComparisonStrategy(ALWAY_EQUALS));
+
   @Test
   public void should_pass_if_objects_are_equal() {
     objects.assertEqual(someInfo(), "Yoda", "Yoda");
@@ -53,20 +62,29 @@ public class Objects_assertEqual_Test extends ObjectsBaseTest {
     objectsWithCustomComparisonStrategy.assertEqual(someInfo(), "Yoda", "YODA");
   }
 
+  @Test
+  @DataProvider({
+      "foo, bar",
+      "null, foo",
+      "null, bar",
+      "null, null"
+  })
+  public void should_not_check_actual_or_expected_before_applying_a_custom_comparator(String actual, String expected) {
+    OBJECTS_WITH_ALWAY_EQUALS_COMPARATOR.assertEqual(someInfo(), actual, expected);
+  }
+
   @Test
   public void should_fail_if_objects_are_not_equal_according_to_custom_comparison_strategy() {
     AssertionInfo info = someInfo();
     try {
       objectsWithCustomComparisonStrategy.assertEqual(info, "Luke", "Yoda");
     } catch (AssertionError e) {
-      verify(failures).failure(info, shouldBeEqual("Luke", "Yoda", customComparisonStrategy,
-          new StandardRepresentation()));
+      verify(failures).failure(info, shouldBeEqual("Luke", "Yoda", customComparisonStrategy, STANDARD_REPRESENTATION));
       return;
     }
     failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
-
   @Test
   public void should_fail_with_my_exception_if_compared_with_null() {
     try {
diff --git a/src/test/java/org/assertj/core/util/CaseInsensitiveStringComparator.java b/src/test/java/org/assertj/core/util/CaseInsensitiveStringComparator.java
index cdab6554e..dc04eb559 100644
--- a/src/test/java/org/assertj/core/util/CaseInsensitiveStringComparator.java
+++ b/src/test/java/org/assertj/core/util/CaseInsensitiveStringComparator.java
@@ -20,7 +20,9 @@ public class CaseInsensitiveStringComparator implements Comparator<String> {
 
   @Override
   public int compare(String s1, String s2) {
-
+    if (s1 == null && s2 == null) return 0;
+    if (s1 == null) return -1;
+    if (s2 == null) return 1;
     return s1.toLowerCase().compareTo(s2.toLowerCase());
   }
 }
\ No newline at end of file
