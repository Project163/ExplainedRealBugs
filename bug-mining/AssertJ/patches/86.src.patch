diff --git a/src/main/java/org/assertj/core/api/AbstractLocalDateTimeAssert.java b/src/main/java/org/assertj/core/api/AbstractLocalDateTimeAssert.java
new file mode 100644
index 000000000..110d735f0
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/AbstractLocalDateTimeAssert.java
@@ -0,0 +1,629 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.error.ShouldBeAfter.shouldBeAfter;
+import static org.assertj.core.error.ShouldBeAfterOrEqualsTo.shouldBeAfterOrEqualsTo;
+import static org.assertj.core.error.ShouldBeBefore.shouldBeBefore;
+import static org.assertj.core.error.ShouldBeBeforeOrEqualsTo.shouldBeBeforeOrEqualsTo;
+import static org.assertj.core.error.ShouldBeEqualIgnoringHours.shouldBeEqualIgnoringHours;
+import static org.assertj.core.error.ShouldBeEqualIgnoringMinutes.shouldBeEqualIgnoringMinutes;
+import static org.assertj.core.error.ShouldBeEqualIgnoringNanos.shouldBeEqualIgnoringNanos;
+import static org.assertj.core.error.ShouldBeEqualIgnoringSeconds.shouldBeEqualIgnoringSeconds;
+
+import java.time.LocalDateTime;
+
+import org.assertj.core.internal.Failures;
+import org.assertj.core.internal.Objects;
+
+/**
+ * Assertions for {@link LocalDateTime} type from new Date &amp; Time API introduced in Java 8.
+ * 
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public abstract class AbstractLocalDateTimeAssert<S extends AbstractLocalDateTimeAssert<S>> extends AbstractAssert<S, LocalDateTime> {
+
+  public static final String NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE = "The LocalDateTime to compare actual with should not be null";
+
+  /**
+   * Creates a new <code>{@link org.assertj.core.api.AbstractLocalDateTimeAssert}</code>.
+   * 
+   * @param selfType the "self type"
+   * @param actual the actual value to verify
+   */
+  protected AbstractLocalDateTimeAssert(LocalDateTime actual, Class<?> selfType) {
+	super(actual, selfType);
+  }
+  
+  // visible for test
+  protected LocalDateTime getActual() {
+	return actual;
+  }
+
+  /**
+   * Verifies that the actual {@code LocalDateTime} is <b>strictly</b> before the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalDateTime.parse("2000-01-01T23:59:59")).isBefore(LocalDateTime.parse("2000-01-02T00:00:00"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not strictly before the given one.
+   */
+  public S isBefore(LocalDateTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateTimeParameterIsNotNull(other);
+	if (!actual.isBefore(other)) {
+	  throw Failures.instance().failure(info, shouldBeBefore(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isBefore(LocalDateTime)} but the {@link LocalDateTime} is built from given String, which
+   * must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"
+   * >ISO LocalDateTime format</a> to allow calling {@link LocalDateTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(LocalDateTime.parse("2000-01-01T23:59:59")).isBefore("2000-01-02T00:00:00");
+   * </code></pre>
+   * 
+   * @param localDateTimeAsString String representing a {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDateTime}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not strictly before the {@link LocalDateTime} built
+   *           from given String.
+   */
+  public S isBefore(String localDateTimeAsString) {
+	assertLocalDateTimeAsStringParameterIsNotNull(localDateTimeAsString);
+	return isBefore(LocalDateTime.parse(localDateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code LocalDateTime} is before or equals to the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalDateTime.parse("2000-01-01T23:59:59"))
+   *           .isBeforeOrEqualTo(LocalDateTime.parse("2000-01-01T23:59:59"))
+   *           .isBeforeOrEqualTo(LocalDateTime.parse("2000-01-02T00:00:00"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not before or equals to the given one.
+   */
+  public S isBeforeOrEqualTo(LocalDateTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateTimeParameterIsNotNull(other);
+	if (actual.isAfter(other)) {
+	  throw Failures.instance().failure(info, shouldBeBeforeOrEqualsTo(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isBeforeOrEqualTo(LocalDateTime)} but the {@link LocalDateTime} is built from given
+   * String, which must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"
+   * >ISO LocalDateTime format</a> to allow calling {@link LocalDateTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String in comparison to avoid conversion
+   * assertThat(LocalDateTime.parse("2000-01-01T23:59:59"))
+   *            .isBeforeOrEqualTo("2000-01-01T23:59:59")
+   *            .isBeforeOrEqualTo("2000-01-02T00:00:00");
+   * </code></pre>
+   * 
+   * @param localDateTimeAsString String representing a {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDateTime}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not before or equals to the {@link LocalDateTime}
+   *           built from given String.
+   */
+  public S isBeforeOrEqualTo(String localDateTimeAsString) {
+	assertLocalDateTimeAsStringParameterIsNotNull(localDateTimeAsString);
+	return isBeforeOrEqualTo(LocalDateTime.parse(localDateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code LocalDateTime} is after or equals to the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalDateTime.parse("2000-01-01T00:00:00"))
+   *            .isAfterOrEqualTo(LocalDateTime.parse("2000-01-01T00:00:00"))
+   *            .isAfterOrEqualTo(LocalDateTime.parse("1999-12-31T23:59:59"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not after or equals to the given one.
+   */
+  public S isAfterOrEqualTo(LocalDateTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateTimeParameterIsNotNull(other);
+	if (actual.isBefore(other)) {
+	  throw Failures.instance().failure(info, shouldBeAfterOrEqualsTo(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isAfterOrEqualTo(LocalDateTime)} but the {@link LocalDateTime} is built from given
+   * String, which must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"
+   * >ISO LocalDateTime format</a> to allow calling {@link LocalDateTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String in comparison to avoid conversion
+   * assertThat(LocalDateTime.parse("2000-01-01T00:00:00"))
+   *            .isAfterOrEqualTo("2000-01-01T00:00:00")
+   *            .isAfterOrEqualTo("1999-12-31T23:59:59");
+   * </code></pre>
+   * 
+   * @param localDateTimeAsString String representing a {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDateTime}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not after or equals to the {@link LocalDateTime}
+   *           built from given String.
+   */
+  public S isAfterOrEqualTo(String localDateTimeAsString) {
+	assertLocalDateTimeAsStringParameterIsNotNull(localDateTimeAsString);
+	return isAfterOrEqualTo(LocalDateTime.parse(localDateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code LocalDateTime} is <b>strictly</b> after the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalDateTime.parse("2000-01-01T00:00:00")).isAfter(LocalDateTime.parse("1999-12-31T23:59:59"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not strictly after the given one.
+   */
+  public S isAfter(LocalDateTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateTimeParameterIsNotNull(other);
+	if (!actual.isAfter(other)) {
+	  throw Failures.instance().failure(info, shouldBeAfter(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isAfter(LocalDateTime)} but the {@link LocalDateTime} is built from given a String that
+   * must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"
+   * >ISO LocalDateTime format</a> to allow calling {@link LocalDateTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String in comparison to avoid conversion
+   * assertThat(LocalDateTime.parse("2000-01-01T00:00:00")).isAfter("1999-12-31T23:59:59");
+   * </code></pre>
+   * 
+   * @param localDateTimeAsString String representing a {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDateTime}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not strictly after the {@link LocalDateTime} built
+   *           from given String.
+   */
+  public S isAfter(String localDateTimeAsString) {
+	assertLocalDateTimeAsStringParameterIsNotNull(localDateTimeAsString);
+	return isAfter(LocalDateTime.parse(localDateTimeAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isEqualTo(Object)} (where Object is expected to be {@link LocalDateTime}) but here you
+   * pass {@link LocalDateTime} String representation that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"
+   * >ISO LocalDateTime format</a> to allow calling {@link LocalDateTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(LocalDateTime.parse("2000-01-01T00:00:00")).isEqualTo("2000-01-01T00:00:00");
+   * </code></pre>
+   * 
+   * @param dateTimeAsString String representing a {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDateTime}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not equal to the {@link LocalDateTime} built from
+   *           given String.
+   */
+  public S isEqualTo(String dateTimeAsString) {
+	assertLocalDateTimeAsStringParameterIsNotNull(dateTimeAsString);
+	return isEqualTo(LocalDateTime.parse(dateTimeAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isNotEqualTo(Object)} (where Object is expected to be {@link LocalDateTime}) but here you
+   * pass {@link LocalDateTime} String representation that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"
+   * >ISO LocalDateTime format</a> to allow calling {@link LocalDateTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(LocalDateTime.parse("2000-01-01T00:00:00")).isNotEqualTo("2000-01-15T00:00:00");
+   * </code></pre>
+   * 
+   * @param dateTimeAsString String representing a {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDateTime}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is equal to the {@link LocalDateTime} built from given
+   *           String.
+   */
+  public S isNotEqualTo(String dateTimeAsString) {
+	assertLocalDateTimeAsStringParameterIsNotNull(dateTimeAsString);
+	return isNotEqualTo(LocalDateTime.parse(dateTimeAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isIn(Object...)} (where Objects are expected to be {@link LocalDateTime}) but here you
+   * pass {@link LocalDateTime} String representations that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"
+   * >ISO LocalDateTime format</a> to allow calling {@link LocalDateTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String based representation of LocalDateTime
+   * assertThat(LocalDateTime.parse("2000-01-01T00:00:00")).isIn("1999-12-31T00:00:00", "2000-01-01T00:00:00");
+   * </code></pre>
+   * 
+   * @param dateTimesAsString String array representing {@link LocalDateTime}s.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDateTime}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is not in the {@link LocalDateTime}s built from given
+   *           Strings.
+   */
+  public S isIn(String... dateTimesAsString) {
+	checkIsNotNullAndNotEmpty(dateTimesAsString);
+	return isIn(convertToLocalDateTimeArray(dateTimesAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isNotIn(Object...)} (where Objects are expected to be {@link LocalDateTime}) but here you
+   * pass {@link LocalDateTime} String representations that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"
+   * >ISO LocalDateTime format</a> to allow calling {@link LocalDateTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String based representation of LocalDateTime
+   * assertThat(LocalDateTime.parse("2000-01-01T00:00:00")).isNotIn("1999-12-31T00:00:00", "2000-01-02T00:00:00");
+   * </code></pre>
+   * 
+   * @param dateTimesAsString Array of String representing a {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDateTime}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is in the {@link LocalDateTime}s built from given
+   *           Strings.
+   */
+  public S isNotIn(String... dateTimesAsString) {
+	checkIsNotNullAndNotEmpty(dateTimesAsString);
+	return isNotIn(convertToLocalDateTimeArray(dateTimesAsString));
+  }
+
+  private static Object[] convertToLocalDateTimeArray(String... dateTimesAsString) {
+	LocalDateTime[] dates = new LocalDateTime[dateTimesAsString.length];
+	for (int i = 0; i < dateTimesAsString.length; i++) {
+	  dates[i] = LocalDateTime.parse(dateTimesAsString[i]);
+	}
+	return dates;
+  }
+
+  private void checkIsNotNullAndNotEmpty(Object[] values) {
+	if (values == null) {
+	  throw new IllegalArgumentException("The given LocalDateTime array should not be null");
+	}
+	if (values.length == 0) {
+	  throw new IllegalArgumentException("The given LocalDateTime array should not be empty");
+	}
+  }
+
+  /**
+   * Check that the {@link LocalDateTime} string representation to compare actual {@link LocalDateTime} to is not null,
+   * otherwise throws a {@link IllegalArgumentException} with an explicit message
+   * 
+   * @param localDateTimeAsString String representing the {@link LocalDateTime} to compare actual with
+   * @throws IllegalArgumentException with an explicit message if the given {@link String} is null
+   */
+  private static void assertLocalDateTimeAsStringParameterIsNotNull(String localDateTimeAsString) {
+	if (localDateTimeAsString == null) {
+	  throw new IllegalArgumentException(
+		                                 "The String representing the LocalDateTime to compare actual with should not be null");
+	}
+  }
+
+  /**
+   * Check that the {@link LocalDateTime} to compare actual {@link LocalDateTime} to is not null, in that case throws a
+   * {@link IllegalArgumentException} with an explicit message
+   * 
+   * @param other the {@link LocalDateTime} to check
+   * @throws IllegalArgumentException with an explicit message if the given {@link LocalDateTime} is null
+   */
+  private static void assertLocalDateTimeParameterIsNotNull(LocalDateTime other) {
+	if (other == null) {
+	  throw new IllegalArgumentException("The LocalDateTime to compare actual with should not be null");
+	}
+  }
+
+  /**
+   * Verifies that actual and given {@code LocalDateTime} have same year, month, day, hour, minute and second fields,
+   * (nanosecond fields are ignored in comparison).
+   * <p>
+   * Assertion can fail with localDateTimes in same chronological nanosecond time window, e.g :
+   * <p>
+   * 2000-01-01T00:00:<b>01.000000000</b> and 2000-01-01T00:00:<b>00.999999999</b>.
+   * <p>
+   * Assertion fails as second fields differ even if time difference is only 1ns.
+   * <p>
+   * Code example :
+   * 
+   * <pre><code class='java'>
+   * // successfull assertions
+   * LocalDateTime localDateTime1 = LocalDateTime.of(2000, 1, 1, 0, 0, 1, 0);
+   * LocalDateTime localDateTime2 = LocalDateTime.of(2000, 1, 1, 0, 0, 1, 456);
+   * assertThat(localDateTime1).isEqualToIgnoringNanos(localDateTime2);
+   * 
+   * // failing assertions (even if time difference is only 1ms)
+   * LocalDateTime localDateTimeA = LocalDateTime.of(2000, 1, 1, 0, 0, 1, 0);
+   * LocalDateTime localDateTimeB = LocalDateTime.of(2000, 1, 1, 0, 0, 0, 999999999);
+   * assertThat(localDateTimeA).isEqualToIgnoringNanos(localDateTimeB);
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is are not equal with nanoseconds ignored.
+   */
+  public S isEqualToIgnoringNanos(LocalDateTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateTimeParameterIsNotNull(other);
+	if (!areEqualIgnoringNanos(actual, other)) {
+	  throw Failures.instance().failure(info, shouldBeEqualIgnoringNanos(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Verifies that actual and given {@link LocalDateTime} have same year, month, day, hour and minute fields (second and
+   * nanosecond fields are ignored in comparison).
+   * <p>
+   * Assertion can fail with LocalDateTimes in same chronological second time window, e.g :
+   * <p>
+   * 2000-01-01T00:<b>01:00</b>.000 and 2000-01-01T00:<b>00:59</b>.000.
+   * <p>
+   * Assertion fails as minute fields differ even if time difference is only 1s.
+   * <p>
+   * Code example :
+   * 
+   * <pre><code class='java'>
+   * // successful assertions
+   * LocalDateTime localDateTime1 = LocalDateTime.of(2000, 1, 1, 23, 50, 0, 0);
+   * LocalDateTime localDateTime2 = LocalDateTime.of(2000, 1, 1, 23, 50, 10, 456);
+   * assertThat(localDateTime1).isEqualToIgnoringSeconds(localDateTime2);
+   * 
+   * // failing assertions (even if time difference is only 1ms)
+   * LocalDateTime localDateTimeA = LocalDateTime.of(2000, 1, 1, 23, 50, 00, 000);
+   * LocalDateTime localDateTimeB = LocalDateTime.of(2000, 1, 1, 23, 49, 59, 999);
+   * assertThat(localDateTimeA).isEqualToIgnoringSeconds(localDateTimeB);
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is are not equal with second and nanosecond fields
+   *           ignored.
+   */
+  public S isEqualToIgnoringSeconds(LocalDateTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateTimeParameterIsNotNull(other);
+	if (!areEqualIgnoringSeconds(actual, other)) {
+	  throw Failures.instance().failure(info, shouldBeEqualIgnoringSeconds(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Verifies that actual and given {@code LocalDateTime} have same year, month, day and hour fields (minute, second and
+   * nanosecond fields are ignored in comparison).
+   * <p>
+   * Assertion can fail with localDateTimes in same chronological second time window, e.g :
+   * <p>
+   * 2000-01-01T<b>01:00</b>:00.000 and 2000-01-01T<b>00:59:59</b>.000.
+   * <p>
+   * Time difference is only 1s but hour fields differ.
+   * <p>
+   * Code example :
+   * 
+   * <pre><code class='java'>
+   * // successful assertions
+   * LocalDateTime localDateTime1 = LocalDateTime.of(2000, 1, 1, 23, 50, 0, 0);
+   * LocalDateTime localDateTime2 = LocalDateTime.of(2000, 1, 1, 23, 00, 2, 7);
+   * assertThat(localDateTime1).isEqualToIgnoringMinutes(localDateTime2);
+   * 
+   * // failing assertions (even if time difference is only 1ms)
+   * LocalDateTime localDateTimeA = LocalDateTime.of(2000, 1, 1, 01, 00, 00, 000);
+   * LocalDateTime localDateTimeB = LocalDateTime.of(2000, 1, 1, 00, 59, 59, 999);
+   * assertThat(localDateTimeA).isEqualToIgnoringMinutes(localDateTimeB);
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is are not equal ignoring minute, second and nanosecond
+   *           fields.
+   */
+  public S isEqualToIgnoringMinutes(LocalDateTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateTimeParameterIsNotNull(other);
+	if (!areEqualIgnoringMinutes(actual, other)) {
+	  throw Failures.instance().failure(info, shouldBeEqualIgnoringMinutes(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Verifies that actual and given {@code LocalDateTime} have same year, month and day fields (hour, minute, second and
+   * nanosecond fields are ignored in comparison).
+   * <p>
+   * Assertion can fail with localDateTimes in same chronological minute time window, e.g :
+   * <p>
+   * 2000-01-<b>01T23:59</b>:00.000 and 2000-01-02T<b>00:00</b>:00.000.
+   * <p>
+   * Time difference is only 1min but day fields differ.
+   * <p>
+   * Code example :
+   * 
+   * <pre><code class='java'>
+   * // successfull assertions
+   * LocalDateTime localDateTime1 = LocalDateTime.of(2000, 1, 1, 23, 59, 59, 999);
+   * LocalDateTime localDateTime2 = LocalDateTime.of(2000, 1, 1, 00, 00, 00, 000);
+   * assertThat(localDateTime1).isEqualToIgnoringHours(localDateTime2);
+   * 
+   * // failing assertions (even if time difference is only 1ms)
+   * LocalDateTime localDateTimeA = LocalDateTime.of(2000, 1, 2, 00, 00, 00, 000);
+   * LocalDateTime localDateTimeB = LocalDateTime.of(2000, 1, 1, 23, 59, 59, 999);
+   * assertThat(localDateTimeA).isEqualToIgnoringHours(localDateTimeB);
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDateTime} is are not equal with second and nanosecond fields
+   *           ignored.
+   */
+  public S isEqualToIgnoringHours(LocalDateTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateTimeParameterIsNotNull(other);
+	if (!haveSameYearMonthAndDayOfMonth(actual, other)) {
+	  throw Failures.instance().failure(info, shouldBeEqualIgnoringHours(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, month and day of month, hour, minute and second, false
+   * otherwise.
+   * 
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, month and day of month, hour, minute and second, false
+   *         otherwise.
+   */
+  private static boolean areEqualIgnoringNanos(LocalDateTime actual, LocalDateTime other) {
+	return areEqualIgnoringSeconds(actual, other) && actual.getSecond() == other.getSecond();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, month, day of month, hour and minute, false otherwise.
+   * 
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, month, day of month, hour and minute, false otherwise.
+   */
+  private static boolean areEqualIgnoringSeconds(LocalDateTime actual, LocalDateTime other) {
+	return areEqualIgnoringMinutes(actual, other) && actual.getMinute() == other.getMinute();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, month, day of month and hour, false otherwise.
+   * 
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, month, day of month and hour, false otherwise.
+   */
+  private static boolean areEqualIgnoringMinutes(LocalDateTime actual, LocalDateTime other) {
+	return haveSameYearMonthAndDayOfMonth(actual, other) && actual.getHour() == other.getHour();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, month and day of month, false otherwise.
+   * 
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, month and day of month, false otherwise
+   */
+  private static boolean haveSameYearMonthAndDayOfMonth(LocalDateTime actual, LocalDateTime other) {
+	return haveSameYearAndMonth(actual, other) && actual.getDayOfMonth() == other.getDayOfMonth();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year and month, false otherwise.
+   * 
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year and month, false otherwise
+   */
+  private static boolean haveSameYearAndMonth(LocalDateTime actual, LocalDateTime other) {
+	return haveSameYear(actual, other) && actual.getMonth() == other.getMonth();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, false otherwise.
+   * 
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, false otherwise
+   */
+  private static boolean haveSameYear(LocalDateTime actual, LocalDateTime other) {
+	return actual.getYear() == other.getYear();
+  }
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/api/AbstractZonedDateTimeAssert.java b/src/main/java/org/assertj/core/api/AbstractZonedDateTimeAssert.java
new file mode 100644
index 000000000..e869d469d
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/AbstractZonedDateTimeAssert.java
@@ -0,0 +1,742 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.error.ShouldBeAfter.shouldBeAfter;
+import static org.assertj.core.error.ShouldBeAfterOrEqualsTo.shouldBeAfterOrEqualsTo;
+import static org.assertj.core.error.ShouldBeBefore.shouldBeBefore;
+import static org.assertj.core.error.ShouldBeBeforeOrEqualsTo.shouldBeBeforeOrEqualsTo;
+import static org.assertj.core.error.ShouldBeEqualIgnoringHours.shouldBeEqualIgnoringHours;
+import static org.assertj.core.error.ShouldBeEqualIgnoringMinutes.shouldBeEqualIgnoringMinutes;
+import static org.assertj.core.error.ShouldBeEqualIgnoringNanos.shouldBeEqualIgnoringNanos;
+import static org.assertj.core.error.ShouldBeEqualIgnoringSeconds.shouldBeEqualIgnoringSeconds;
+
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
+
+import org.assertj.core.internal.Failures;
+import org.assertj.core.internal.Objects;
+
+public abstract class AbstractZonedDateTimeAssert<S extends AbstractZonedDateTimeAssert<S>> extends AbstractAssert<S, ZonedDateTime> {
+
+  public static final String NULL_DATE_TIME_PARAMETER_MESSAGE = "The ZonedDateTime to compare actual with should not be null";
+
+  /**
+   * Check that the {@link ZonedDateTime} to compare actual {@link ZonedDateTime} to is not null, otherwise throws a
+   * {@link IllegalArgumentException} with an explicit message
+   *
+   * @param dateTime the {@link ZonedDateTime} to check
+   * @throws IllegalArgumentException with an explicit message if the given {@link ZonedDateTime} is null
+   */
+  private static void assertDateTimeParameterIsNotNull(ZonedDateTime dateTime) {
+    if (dateTime == null) {
+      throw new IllegalArgumentException(NULL_DATE_TIME_PARAMETER_MESSAGE);
+    }
+  }
+
+  protected ZonedDateTime getActual() {
+    return actual;
+  }
+
+  /**
+   * Verifies that the actual {@code ZonedDateTime} is <b>strictly</b> before the given one.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * assertThat(ZonedDateTime.parse("2000-01-01T23:59:59Z")).isBefore(ZonedDateTime.parse("2000-01-02T00:00:00Z"));
+   * </code></pre>
+   *
+   * @param other the given {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not strictly before the given one.
+   */
+  public S isBefore(ZonedDateTime other) {
+    Objects.instance().assertNotNull(info, actual);
+    assertDateTimeParameterIsNotNull(other);
+    if (!actual.isBefore(other)) {
+      throw Failures.instance().failure(info, shouldBeBefore(actual, other));
+    }
+    return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isBefore(ZonedDateTime)} but the {@link ZonedDateTime} is built from given String, which
+   * must follow <a
+   * href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME"
+   * >ISO date-time format</a> to allow calling {@link ZonedDateTime#parse(CharSequence, DateTimeFormatter)} method.
+   * <p>
+   * Note that the {@link ZonedDateTime} created from the given String is built in the {@link java.time.ZoneId} of the
+   * {@link ZonedDateTime} to check..
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(ZonedDateTime.parse("2000-01-01T23:59:59Z")).isBefore("2000-01-02T00:00:00Z");
+   * </code></pre>
+   *
+   * @param dateTimeAsString String representing a {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link ZonedDateTime}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not strictly before the {@link ZonedDateTime} built
+   *           from given String.
+   */
+  public S isBefore(String dateTimeAsString) {
+    assertDateTimeAsStringParameterIsNotNull(dateTimeAsString);
+    return isBefore(parseStringAsIsoDateTimeAndMoveToZoneSameActual(dateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code ZonedDateTime} is before or equals to the given one.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * assertThat(ZonedDateTime.parse("2000-01-01T23:59:59Z"))
+   *                                       .isBeforeOrEqualTo(ZonedDateTime.parse("2000-01-01T23:59:59Z"))
+   *                                       .isBeforeOrEqualTo(ZonedDateTime.parse("2000-01-02T00:00:00Z"));
+   * </code></pre>
+   *
+   * @param other the given {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZoneDateTime} is not before or equals to the given one.
+   */
+  public S isBeforeOrEqualTo(ZonedDateTime other) {
+    Objects.instance().assertNotNull(info, actual);
+    assertDateTimeParameterIsNotNull(other);
+    if (actual.isAfter(other)) {
+      throw Failures.instance().failure(info, shouldBeBeforeOrEqualsTo(actual, other));
+    }
+    return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isBeforeOrEqualTo(ZonedDateTime)} but the {@link ZonedDateTime} is built from given
+   * String, which must follow <a
+   * href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME"
+   * >ISO date-time format</a> to allow calling {@link ZonedDateTime#parse(CharSequence, DateTimeFormatter)} method.
+   * <p>
+   * Note that the {@link ZonedDateTime} created from the given String is built in the {@link java.time.ZoneId} of the
+   * {@link ZonedDateTime} to check..
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // use String in comparison to avoid conversion
+   * assertThat(ZonedDateTime.parse("2000-01-01T23:59:59Z"))
+   *                                       .isBeforeOrEqualTo("2000-01-01T23:59:59Z")
+   *                                       .isBeforeOrEqualTo("2000-01-02T00:00:00Z");
+   * </code></pre>
+   *
+   * @param dateTimeAsString String representing a {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link ZonedDateTime}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not before or equals to the {@link ZonedDateTime}
+   *           built from given String.
+   */
+  public S isBeforeOrEqualTo(String dateTimeAsString) {
+    assertDateTimeAsStringParameterIsNotNull(dateTimeAsString);
+    return isBeforeOrEqualTo(parseStringAsIsoDateTimeAndMoveToZoneSameActual(dateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code ZonedDateTime} is after or equals to the given one.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z"))
+   *                                       .isAfterOrEqualTo(ZonedDateTime.parse("2000-01-01T00:00:00Z"))
+   *                                       .isAfterOrEqualTo(ZonedDateTime.parse("1999-12-31T23:59:59Z"));
+   * </code></pre>
+   *
+   * @param other the given {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not after or equals to the given one.
+   */
+  public S isAfterOrEqualTo(ZonedDateTime other) {
+    Objects.instance().assertNotNull(info, actual);
+    assertDateTimeParameterIsNotNull(other);
+    if (actual.isBefore(other)) {
+      throw Failures.instance().failure(info, shouldBeAfterOrEqualsTo(actual, other));
+    }
+    return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isAfterOrEqualTo(ZonedDateTime)} but the {@link ZonedDateTime} is built from given
+   * String, which must follow <a
+   * href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME"
+   * >ISO date-time format</a> to allow calling {@link ZonedDateTime#parse(CharSequence, DateTimeFormatter)} method.
+   * <p>
+   * Note that the {@link ZonedDateTime} created from the given String is built in the {@link java.time.ZoneId} of the
+   * {@link ZonedDateTime} to check.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // use String in comparison to avoid conversion
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z"))
+   *                                       .isAfterOrEqualTo("2000-01-01T00:00:00Z")
+   *                                       .isAfterOrEqualTo("1999-12-31T23:59:59Z");
+   * </code></pre>
+   *
+   * @param dateTimeAsString String representing a {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link ZonedDateTime}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not after or equals to the {@link ZonedDateTime}
+   *           built from given String.
+   */
+  public S isAfterOrEqualTo(String dateTimeAsString) {
+    assertDateTimeAsStringParameterIsNotNull(dateTimeAsString);
+    return isAfterOrEqualTo(parseStringAsIsoDateTimeAndMoveToZoneSameActual(dateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code ZonedDateTime} is <b>strictly</b> after the given one.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z")).isAfter(ZonedDateTime.parse("1999-12-31T23:59:59Z"));
+   * </code></pre>
+   *
+   * @param other the given {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not strictly after the given one.
+   */
+  public S isAfter(ZonedDateTime other) {
+    Objects.instance().assertNotNull(info, actual);
+    assertDateTimeParameterIsNotNull(other);
+    if (!actual.isAfter(other)) {
+      throw Failures.instance().failure(info, shouldBeAfter(actual, other));
+    }
+    return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isAfter(ZonedDateTime)} but the {@link ZonedDateTime} is built from given String, which
+   * must follow <a
+   * href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME"
+   * >ISO date-time format</a> to allow calling {@link ZonedDateTime#parse(CharSequence, DateTimeFormatter)} method.
+   * <p>
+   * Note that the {@link ZonedDateTime} created from the given String is built in the {@link java.time.ZoneId} of the
+   * {@link ZonedDateTime} to check.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // use String in comparison to avoid conversion
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z")).isAfter("1999-12-31T23:59:59Z");
+   * </code></pre>
+   *
+   * @param dateTimeAsString String representing a {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link ZonedDateTime}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not strictly after the {@link ZonedDateTime} built
+   *           from given String.
+   */
+  public S isAfter(String dateTimeAsString) {
+    assertDateTimeAsStringParameterIsNotNull(dateTimeAsString);
+    return isAfter(parseStringAsIsoDateTimeAndMoveToZoneSameActual(dateTimeAsString));
+  }
+
+  /**
+   * Verifies that actual and given {@code ZonedDateTime} have same year, month, day, hour, minute and second fields,
+   * (nanosecond fields are ignored in comparison).
+   * <p>
+   * Note that given {@link ZonedDateTime} is converted in the actual's {@link java.time.ZoneId} before comparison.
+   * <p>
+   * Assertion can fail with dateTimes in same chronological nanosecond time window, e.g :
+   * <p>
+   * 2000-01-01T00:00:<b>01.000000000</b> and 2000-01-01T00:00:<b>00.999999999</b>.
+   * <p>
+   * Assertion fails as second fields differ even if time difference is only 1ns.
+   * <p>
+   * Code example :
+   *
+   * <pre><code class='java'>
+   * // successfull assertions
+   * ZonedDateTime dateTime1 = ZonedDateTime.of(2000, 1, 1, 0, 0, 1, 0);
+   * ZonedDateTime dateTime2 = ZonedDateTime.of(2000, 1, 1, 0, 0, 1, 456);
+   * assertThat(dateTime1).isEqualToIgnoringNanos(dateTime2);
+   *
+   * // failing assertions (even if time difference is only 1ms)
+   * ZonedDateTime dateTimeA = ZonedDateTime.of(2000, 1, 1, 0, 0, 1, 0);
+   * ZonedDateTime dateTimeB = ZonedDateTime.of(2000, 1, 1, 0, 0, 0, 999999999);
+   * assertThat(dateTimeA).isEqualToIgnoringNanos(dateTimeB);
+   * </code></pre>
+   *
+   * @param other the given {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is are not equal with nanoseconds ignored.
+   */
+  public S isEqualToIgnoringNanos(ZonedDateTime other) {
+    Objects.instance().assertNotNull(info, actual);
+    assertDateTimeParameterIsNotNull(other);
+    if (!areEqualIgnoringNanos(actual, other.withZoneSameInstant(actual.getZone()))) {
+      throw Failures.instance().failure(info, shouldBeEqualIgnoringNanos(actual, other));
+    }
+    return myself;
+  }
+
+  /**
+   * Verifies that actual and given {@link ZonedDateTime} have same year, month, day, hour and minute fields (second and
+   * nanosecond fields are ignored in comparison).
+   * <p>
+   * Note that given {@link ZonedDateTime} is converted in the actual's {@link java.time.ZoneId} before comparison.
+   * <p>
+   * Assertion can fail with ZonedDateTimes in same chronological second time window, e.g :
+   * <p>
+   * 2000-01-01T00:<b>01:00</b>.000 and 2000-01-01T00:<b>00:59</b>.000.
+   * <p>
+   * Assertion fails as minute fields differ even if time difference is only 1ns.
+   * <p>
+   * Code example :
+   *
+   * <pre><code class='java'>
+   * // successfull assertions
+   * ZonedDateTime dateTime1 = ZonedDateTime.of(2000, 1, 1, 23, 50, 0, 0);
+   * ZonedDateTime dateTime2 = ZonedDateTime.of(2000, 1, 1, 23, 50, 10, 456);
+   * assertThat(dateTime1).isEqualToIgnoringSeconds(dateTime2);
+   *
+   * // failing assertions (even if time difference is only 1ns)
+   * ZonedDateTime dateTimeA = ZonedDateTime.of(2000, 1, 1, 23, 50, 00, 0);
+   * ZonedDateTime dateTimeB = ZonedDateTime.of(2000, 1, 1, 23, 49, 59, 999999999);
+   * assertThat(dateTimeA).isEqualToIgnoringSeconds(dateTimeB);
+   * </code></pre>
+   *
+   * @param other the given {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is are not equal with second and nanosecond fields
+   *           ignored.
+   */
+  public S isEqualToIgnoringSeconds(ZonedDateTime other) {
+    Objects.instance().assertNotNull(info, actual);
+    assertDateTimeParameterIsNotNull(other);
+    if (!areEqualIgnoringSeconds(actual, other.withZoneSameInstant(actual.getZone()))) {
+      throw Failures.instance().failure(info, shouldBeEqualIgnoringSeconds(actual, other));
+    }
+    return myself;
+  }
+
+  /**
+   * Verifies that actual and given {@code ZonedDateTime} have same year, month, day and hour fields (minute, second and
+   * nanosecond fields are ignored in comparison).
+   * <p>
+   * Note that given {@link ZonedDateTime} is converted in the actual's {@link java.time.ZoneId} before comparison.
+   * <p>
+   * Assertion can fail with dateTimes in same chronological second time window, e.g :
+   * <p>
+   * 2000-01-01T<b>01:00</b>:00.000 and 2000-01-01T<b>00:59:59</b>.000.
+   * <p>
+   * Time difference is only 1s but hour fields differ.
+   * <p>
+   * Code example :
+   *
+   * <pre><code class='java'>
+   * // successfull assertions
+   * ZonedDateTime dateTime1 = ZonedDateTime.of(2000, 1, 1, 23, 50, 0, 0);
+   * ZonedDateTime dateTime2 = ZonedDateTime.of(2000, 1, 1, 23, 00, 2, 7);
+   * assertThat(dateTime1).isEqualToIgnoringMinutes(dateTime2);
+   *
+   * // failing assertions (even if time difference is only 1ms)
+   * ZonedDateTime dateTimeA = ZonedDateTime.of(2000, 1, 1, 01, 00, 00, 000);
+   * ZonedDateTime dateTimeB = ZonedDateTime.of(2000, 1, 1, 00, 59, 59, 999);
+   * assertThat(dateTimeA).isEqualToIgnoringMinutes(dateTimeB);
+   * </code></pre>
+   *
+   * @param other the given {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is are not equal ignoring minute, second and nanosecond
+   *           fields.
+   */
+  public S isEqualToIgnoringMinutes(ZonedDateTime other) {
+    Objects.instance().assertNotNull(info, actual);
+    assertDateTimeParameterIsNotNull(other);
+    if (!areEqualIgnoringMinutes(actual, other.withZoneSameInstant(actual.getZone()))) {
+      throw Failures.instance().failure(info, shouldBeEqualIgnoringMinutes(actual, other));
+    }
+    return myself;
+  }
+
+  /**
+   * Verifies that actual and given {@code ZonedDateTime} have same year, month and day fields (hour, minute, second and
+   * nanosecond fields are ignored in comparison).
+   * <p>
+   * Note that given {@link ZonedDateTime} is converted in the actual's {@link java.time.ZoneId} before comparison.
+   * <p>
+   * Assertion can fail with dateTimes in same chronological minute time window, e.g :
+   * <p>
+   * 2000-01-<b>01T23:59</b>:00.000 and 2000-01-02T<b>00:00</b>:00.000.
+   * <p>
+   * Time difference is only 1min but day fields differ.
+   * <p>
+   * Code example :
+   *
+   * <pre><code class='java'>
+   * // successfull assertions
+   * ZonedDateTime dateTime1 = ZonedDateTime.of(2000, 1, 1, 23, 59, 59, 999);
+   * ZonedDateTime dateTime2 = ZonedDateTime.of(2000, 1, 1, 00, 00, 00, 000);
+   * assertThat(dateTime1).isEqualToIgnoringHours(dateTime2);
+   *
+   * // failing assertions (even if time difference is only 1ms)
+   * ZonedDateTime dateTimeA = ZonedDateTime.of(2000, 1, 2, 00, 00, 00, 000);
+   * ZonedDateTime dateTimeB = ZonedDateTime.of(2000, 1, 1, 23, 59, 59, 999);
+   * assertThat(dateTimeA).isEqualToIgnoringHours(dateTimeB);
+   * </code></pre>
+   *
+   * @param other the given {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is are not equal with second and nanosecond fields
+   *           ignored.
+   */
+  public S isEqualToIgnoringHours(ZonedDateTime other) {
+    Objects.instance().assertNotNull(info, actual);
+    assertDateTimeParameterIsNotNull(other);
+    if (!haveSameYearMonthAndDayOfMonth(actual, other.withZoneSameInstant(actual.getZone()))) {
+      throw Failures.instance().failure(info, shouldBeEqualIgnoringHours(actual, other));
+    }
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual {@link ZonedDateTime} is equal to the given one <b>in the actual's
+   * {@link java.time.ZoneId}</b>.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z")).isEqualTo(ZonedDateTime.parse("2000-01-01T00:00:00Z"));
+   * </code></pre>
+   *
+   * @param expected the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not equal to the {@link ZonedDateTime} in the actual
+   *           ZonedDateTime's java.time.ZoneId.
+   */
+  public S isEqualTo(ZonedDateTime expected) {
+    return super.isEqualTo(expected.withZoneSameInstant(actual.getZone()));
+  }
+
+  /**
+   * Same assertion as {@link #isEqualTo(ZonedDateTime)} but the {@link ZonedDateTime} is built from given String,
+   * which must follow <a
+   * href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME"
+   * >ISO date-time format</a> to allow calling {@link ZonedDateTime#parse(CharSequence, DateTimeFormatter)} method.
+   * <p>
+   * Note that the {@link ZonedDateTime} created from the given String is built in the {@link java.time.ZoneId} of the
+   * {@link ZonedDateTime} to check.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z")).isEqualTo("2000-01-01T00:00:00Z");
+   * </code></pre>
+   *
+   * @param dateTimeAsString String representing a {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link ZonedDateTime}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not equal to the {@link ZonedDateTime} built from
+   *           given String.
+   */
+  public S isEqualTo(String dateTimeAsString) {
+    assertDateTimeAsStringParameterIsNotNull(dateTimeAsString);
+    return super.isEqualTo(parseStringAsIsoDateTimeAndMoveToZoneSameActual(dateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual value is not equal to the given one <b>in the actual ZonedDateTime's java.time.ZoneId</b>.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z")).isNotEqualTo(ZonedDateTime.parse("2000-01-15T00:00:00Z"));
+   * </code></pre>
+   *
+   * @param expected the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is equal to the {@link ZonedDateTime} in the actual
+   *           ZonedDateTime's java.time.ZoneId.
+   */
+  public S isNotEqualTo(ZonedDateTime expected) {
+    return super.isNotEqualTo(expected.withZoneSameInstant(actual.getZone()));
+  }
+
+  /**
+   * Same assertion as {@link #isNotEqualTo(ZonedDateTime)} but the {@link ZonedDateTime} is built from given String,
+   * which must follow <a
+   * href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME"
+   * >ISO date-time format</a> to allow calling {@link ZonedDateTime#parse(CharSequence, DateTimeFormatter)} method.
+   * <p>
+   * Note that the {@link ZonedDateTime} created from the given String is built in the {@link java.time.ZoneId} of the
+   * {@link ZonedDateTime} to check.. {@link ZonedDateTime}.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z")).isNotEqualTo("2000-01-15T00:00:00Z");
+   * </code></pre>
+   *
+   * @param dateTimeAsString String representing a {@link ZonedDateTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link ZonedDateTime}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is equal to the {@link ZonedDateTime} built from given
+   *           String.
+   */
+  public S isNotEqualTo(String dateTimeAsString) {
+    assertDateTimeAsStringParameterIsNotNull(dateTimeAsString);
+    return super.isNotEqualTo(parseStringAsIsoDateTimeAndMoveToZoneSameActual(dateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@link ZonedDateTime} is equal to one of the given {@link ZonedDateTime} <b>in the actual
+   * ZonedDateTime's {@link java.time.ZoneId}</b>.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z"))
+   *           .isIn(ZonedDateTime.parse("1999-12-31T23:59:59Z"), ZonedDateTime.parse("2000-01-01T00:00:00Z"));
+   * </code></pre>
+   *
+   * @param expected the given {@link ZonedDateTime}s to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not in the given {@link ZonedDateTime}s.
+   */
+  public S isIn(ZonedDateTime... expected) {
+    return isIn((Object[]) changeToActualTimeZone(expected));
+  }
+
+  /**
+   * Same assertion as {@link #isIn(ZonedDateTime...)} but the {@link ZonedDateTime} are built from given String, which
+   * must follow <a
+   * href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME"
+   * >ISO date-time format</a> to allow calling {@link ZonedDateTime#parse(CharSequence, DateTimeFormatter)} method.
+   * <p>
+   * Note that the {@link ZonedDateTime}s created from the given Strings are built in the {@link java.time.ZoneId} of
+   * the {@link ZonedDateTime} to check..
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // use String based representation of LocalDateTime
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z")).isIn("1999-12-31T23:59:59Z", "2000-01-01T00:00:00Z");
+   * </code></pre>
+   *
+   * @param dateTimesAsString String array representing {@link ZonedDateTime}s.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link ZonedDateTime}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not in the {@link ZonedDateTime}s built from given
+   *           Strings.
+   */
+  public S isIn(String... dateTimesAsString) {
+    checkIsNotNullAndNotEmpty(dateTimesAsString);
+    return isIn(convertToDateTimeArray(dateTimesAsString));
+  }
+
+  /**
+   * Verifies that the actual {@link ZonedDateTime} is equal to one of the given {@link ZonedDateTime} <b>in the actual
+   * ZonedDateTime's {@link java.time.ZoneId}</b>.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z"))
+   *          .isNotIn(ZonedDateTime.parse("1999-12-31T23:59:59Z"), ZonedDateTime.parse("2000-01-02T00:00:00Z"));
+   * </code></pre>
+   *
+   * @param expected the given {@link ZonedDateTime}s to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not in the given {@link ZonedDateTime}s.
+   */
+  public S isNotIn(ZonedDateTime... expected) {
+    return this.isNotIn((Object[]) changeToActualTimeZone(expected));
+  }
+
+  /**
+   * Same assertion as {@link #isNotIn(ZonedDateTime...)} but the {@link ZonedDateTime} is built from given String,
+   * which must follow <a
+   * href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME"
+   * >ISO date-time format</a> to allow calling {@link ZonedDateTime#parse(CharSequence, DateTimeFormatter)} method.
+   * <p>
+   * Note that the {@link ZonedDateTime}s created from the given Strings are built in the {@link java.time.ZoneId} of
+   * the {@link ZonedDateTime} to check..
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // use String based representation of ZonedDateTime
+   * assertThat(ZonedDateTime.parse("2000-01-01T00:00:00Z")).isNotIn("1999-12-31T23:59:59Z", "2000-01-02T00:00:00Z");
+   * </code></pre>
+   *
+   * @param dateTimesAsString String array representing {@link ZonedDateTime}s.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link ZonedDateTime}.
+   * @throws AssertionError if the actual {@code ZonedDateTime} is not equal to the {@link ZonedDateTime} built from
+   *            given String.
+   */
+  public S isNotIn(String... dateTimesAsString) {
+    checkIsNotNullAndNotEmpty(dateTimesAsString);
+    return isNotIn(convertToDateTimeArray(dateTimesAsString));
+  }
+
+  private ZonedDateTime[] convertToDateTimeArray(String... dateTimesAsString) {
+    ZonedDateTime[] dates = new ZonedDateTime[dateTimesAsString.length];
+    for (int i = 0; i < dateTimesAsString.length; i++) {
+      // building the ZonedDateTime in actual's ZoneId
+      dates[i] = parseStringAsIsoDateTimeAndMoveToZoneSameActual(dateTimesAsString[i]);
+    }
+    return dates;
+  }
+
+  private ZonedDateTime[] changeToActualTimeZone(ZonedDateTime... dateTimes) {
+    ZonedDateTime[] dates = new ZonedDateTime[dateTimes.length];
+    for (int i = 0; i < dateTimes.length; i++) {
+      // building the ZonedDateTime in actual's ZoneId
+      dates[i] = dateTimes[i].withZoneSameInstant(actual.getZone());
+    }
+    return dates;
+  }
+
+  private void checkIsNotNullAndNotEmpty(Object[] values) {
+    if (values == null) {
+      throw new IllegalArgumentException("The given ZonedDateTime array should not be null");
+    }
+    if (values.length == 0) {
+      throw new IllegalArgumentException("The given ZonedDateTime array should not be empty");
+    }
+  }
+
+  private ZonedDateTime parseStringAsIsoDateTimeAndMoveToZoneSameActual(String dateTimeAsString) {
+    ZonedDateTime parsedDateTime = ZonedDateTime.parse(dateTimeAsString, DateTimeFormatter.ISO_DATE_TIME);
+    return parsedDateTime.withZoneSameInstant(actual.getZone());
+  }
+
+  /**
+   * Check that the {@link ZonedDateTime} string representation to compare actual {@link ZonedDateTime} to is not null,
+   * otherwise throws a {@link IllegalArgumentException} with an explicit message
+   *
+   * @param dateTimeAsString String representing the ZonedDateTime to compare actual with
+   * @throws IllegalArgumentException with an explicit message if the given {@link String} is null
+   */
+  private static void assertDateTimeAsStringParameterIsNotNull(String dateTimeAsString) {
+    if (dateTimeAsString == null) {
+      throw new IllegalArgumentException(
+          "The String representing the ZonedDateTime to compare actual with should not be null");
+    }
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, month and day of month, hour, minute and second, false
+   * otherwise.
+   *
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, month and day of month, hour, minute and second, false
+   *         otherwise.
+   */
+  private static boolean areEqualIgnoringNanos(ZonedDateTime actual, ZonedDateTime other) {
+    return areEqualIgnoringSeconds(actual, other) && actual.getSecond() == other.getSecond();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, month, day of month, hour and minute, false otherwise.
+   *
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, month, day of month, hour and minute, false otherwise.
+   */
+  private static boolean areEqualIgnoringSeconds(ZonedDateTime actual, ZonedDateTime other) {
+    return areEqualIgnoringMinutes(actual, other) && actual.getMinute() == other.getMinute();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, month, day of month and hour, false otherwise.
+   *
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, month, day of month and hour, false otherwise.
+   */
+  private static boolean areEqualIgnoringMinutes(ZonedDateTime actual, ZonedDateTime other) {
+    return haveSameYearMonthAndDayOfMonth(actual, other) && actual.getHour() == other.getHour();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, month and day of month, false otherwise.
+   *
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, month and day of month, false otherwise
+   */
+  private static boolean haveSameYearMonthAndDayOfMonth(ZonedDateTime actual, ZonedDateTime other) {
+    return haveSameYearAndMonth(actual, other) && actual.getDayOfMonth() == other.getDayOfMonth();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year and month, false otherwise.
+   *
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year and month, false otherwise
+   */
+  private static boolean haveSameYearAndMonth(ZonedDateTime actual, ZonedDateTime other) {
+    return haveSameYear(actual, other) && actual.getMonth() == other.getMonth();
+  }
+
+  /**
+   * Returns true if both datetime are in the same year, false otherwise.
+   *
+   * @param actual the actual datetime. expected not be null
+   * @param other the other datetime. expected not be null
+   * @return true if both datetime are in the same year, false otherwise
+   */
+  private static boolean haveSameYear(ZonedDateTime actual, ZonedDateTime other) {
+    return actual.getYear() == other.getYear();
+  }
+
+  AbstractZonedDateTimeAssert(ZonedDateTime actual, Class<?> selfType) {
+	super(actual, selfType);
+  }
+  
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 170233a3c..1dd0927c7 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -17,6 +17,8 @@ import java.io.InputStream;
 import java.math.BigDecimal;
 import java.nio.charset.Charset;
 import java.text.DateFormat;
+import java.time.LocalDateTime;
+import java.time.ZonedDateTime;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -527,6 +529,26 @@ public class Assertions {
 	return new DateAssert(actual);
   }
 
+  /**
+   * Creates a new instance of <code>{@link ZonedDateTimeAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static AbstractZonedDateTimeAssert<?> assertThat(ZonedDateTime date) {
+    return new ZonedDateTimeAssert(date);
+  }
+
+  /**
+   * Creates a new instance of <code>{@link LocalDateTimeAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static AbstractLocalDateTimeAssert<?> assertThat(LocalDateTime localDateTime) {
+    return new LocalDateTimeAssert(localDateTime);
+  }
+  
   /**
    * Creates a new instance of <code>{@link ThrowableAssert}</code>.
    *
diff --git a/src/main/java/org/assertj/core/api/LocalDateTimeAssert.java b/src/main/java/org/assertj/core/api/LocalDateTimeAssert.java
new file mode 100644
index 000000000..d494a0a23
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/LocalDateTimeAssert.java
@@ -0,0 +1,28 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import java.time.LocalDateTime;
+
+public class LocalDateTimeAssert extends AbstractLocalDateTimeAssert<LocalDateTimeAssert> {
+
+  /**
+   * Creates a new <code>{@link LocalDateTimeAssert}</code>.
+   *
+   * @param selfType the "self type"
+   * @param actual the actual value to verify
+   */
+  protected LocalDateTimeAssert(LocalDateTime actual) {
+    super(actual, LocalDateTimeAssert.class);
+  }
+}
diff --git a/src/main/java/org/assertj/core/api/WithAssertions.java b/src/main/java/org/assertj/core/api/WithAssertions.java
index 06d51259f..23f0761c3 100644
--- a/src/main/java/org/assertj/core/api/WithAssertions.java
+++ b/src/main/java/org/assertj/core/api/WithAssertions.java
@@ -335,7 +335,7 @@ public interface WithAssertions {
   }
 
   /**
-   * Delegate call to {@link org.assertj.core8.api.Assertions#assertThat(int)}
+   * Delegate call to {@link org.assertj.core.api.Assertions#assertThat(int)}
    */
   default public AbstractIntegerAssert<?> assertThat(final int actual) {
 	return Assertions.assertThat(actual);
@@ -539,21 +539,21 @@ public interface WithAssertions {
 
   // TODO : uncomment once Java 8 classes are all integrated in the branch
   // /**
-  // * Delegate call to {@link org.assertj.core8.api.Assertions#assertThat(ZonedDateTime)}
+  // * Delegate call to {@link org.assertj.core.api.Assertions#assertThat(ZonedDateTime)}
   // */
   // default public ZonedDateTimeAssert assertThat(final ZonedDateTime actual) {
   // return Assertions.assertThat(actual);
   // }
   //
   // /**
-  // * Delegate call to {@link org.assertj.core8.api.Assertions#assertThat(Optional)}
+  // * Delegate call to {@link org.assertj.core.api.Assertions#assertThat(Optional)}
   // */
   // default public <T> OptionalAssert<T> assertThat(final Optional<T> optional) {
   // return Assertions.assertThat(optional);
   // }
   //
   // /**
-  // * Delegate call to {@link org.assertj.core8.api.Assertions#assertThat(LocalDateTime)}
+  // * Delegate call to {@link org.assertj.core.api.Assertions#assertThat(LocalDateTime)}
   // */
   // default public LocalDateTimeAssert assertThat(final LocalDateTime localDateTime) {
   // return Assertions.assertThat(localDateTime);
diff --git a/src/main/java/org/assertj/core/api/ZonedDateTimeAssert.java b/src/main/java/org/assertj/core/api/ZonedDateTimeAssert.java
new file mode 100644
index 000000000..4bc7ed394
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/ZonedDateTimeAssert.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import java.time.ZonedDateTime;
+
+/**
+ * Assertions for {@link ZonedDateTime} type from new Date &amp; Time API introduced in Java 8.
+ *
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public class ZonedDateTimeAssert extends AbstractZonedDateTimeAssert<ZonedDateTimeAssert> {
+
+  /**
+   * Creates a new <code>{@link ZonedDateTimeAssert}</code>.
+   *
+   * @param selfType the "self type"
+   * @param actual the actual value to verify
+   */
+  protected ZonedDateTimeAssert(ZonedDateTime actual) {
+    super(actual, ZonedDateTimeAssert.class);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeAfter.java b/src/main/java/org/assertj/core/error/ShouldBeAfter.java
index 13d7c4d02..d4cd0267c 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeAfter.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeAfter.java
@@ -33,7 +33,7 @@ public class ShouldBeAfter extends BasicErrorMessageFactory {
    * @param comparisonStrategy the {@link ComparisonStrategy} used to evaluate assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
-  public static ErrorMessageFactory shouldBeAfter(Date actual, Date other, ComparisonStrategy comparisonStrategy) {
+  public static ErrorMessageFactory shouldBeAfter(Object actual, Object other, ComparisonStrategy comparisonStrategy) {
     return new ShouldBeAfter(actual, other, comparisonStrategy);
   }
 
@@ -43,7 +43,7 @@ public class ShouldBeAfter extends BasicErrorMessageFactory {
    * @param other the value used in the failed assertion to compare the actual value to.
    * @return the created {@code ErrorMessageFactory}.
    */
-  public static ErrorMessageFactory shouldBeAfter(Date actual, Date other) {
+  public static ErrorMessageFactory shouldBeAfter(Object actual, Object other) {
     return new ShouldBeAfter(actual, other, StandardComparisonStrategy.instance());
   }
 
@@ -58,7 +58,7 @@ public class ShouldBeAfter extends BasicErrorMessageFactory {
     return new ShouldBeAfter(actual, januaryTheFirstOfGivenYear, StandardComparisonStrategy.instance());
   }
 
-  private ShouldBeAfter(Date actual, Date other, ComparisonStrategy comparisonStrategy) {
-    super("\nExpecting:\n <%s>\nto be strictly after:\n <%s>%s", actual, other, comparisonStrategy);
+  private ShouldBeAfter(Object actual, Object other, ComparisonStrategy comparisonStrategy) {
+    super("\nExpecting:\n  <%s>\nto be strictly after:\n  <%s>%s", actual, other, comparisonStrategy);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeAfterOrEqualsTo.java b/src/main/java/org/assertj/core/error/ShouldBeAfterOrEqualsTo.java
index 206c162d8..76c5ceace 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeAfterOrEqualsTo.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeAfterOrEqualsTo.java
@@ -16,9 +16,9 @@ import java.util.Date;
 
 import org.assertj.core.internal.*;
 
-
 /**
- * Creates an error message indicating that an assertion that verifies that a {@link Date} is after or equals to another one
+ * Creates an error message indicating that an assertion that verifies that a {@link Date} is after or equals to another
+ * one
  * failed.
  * 
  * @author Joel Costigliola
@@ -27,26 +27,29 @@ public class ShouldBeAfterOrEqualsTo extends BasicErrorMessageFactory {
 
   /**
    * Creates a new </code>{@link ShouldBeAfterOrEqualsTo}</code>.
+   * 
    * @param actual the actual value in the failed assertion.
    * @param other the value used in the failed assertion to compare the actual value to.
    * @param comparisonStrategy the {@link ComparisonStrategy} used to evaluate assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
-  public static ErrorMessageFactory shouldBeAfterOrEqualsTo(Date actual, Date other, ComparisonStrategy comparisonStrategy) {
-    return new ShouldBeAfterOrEqualsTo(actual, other, comparisonStrategy);
+  public static ErrorMessageFactory shouldBeAfterOrEqualsTo(Object actual, Object other,
+	                                                        ComparisonStrategy comparisonStrategy) {
+	return new ShouldBeAfterOrEqualsTo(actual, other, comparisonStrategy);
   }
 
   /**
    * Creates a new </code>{@link ShouldBeAfterOrEqualsTo}</code>.
+   * 
    * @param actual the actual value in the failed assertion.
    * @param other the value used in the failed assertion to compare the actual value to.
    * @return the created {@code ErrorMessageFactory}.
    */
-  public static ErrorMessageFactory shouldBeAfterOrEqualsTo(Date actual, Date other) {
-    return new ShouldBeAfterOrEqualsTo(actual, other, StandardComparisonStrategy.instance());
+  public static ErrorMessageFactory shouldBeAfterOrEqualsTo(Object actual, Object other) {
+	return new ShouldBeAfterOrEqualsTo(actual, other, StandardComparisonStrategy.instance());
   }
 
-  private ShouldBeAfterOrEqualsTo(Date actual, Date other, ComparisonStrategy comparisonStrategy) {
-    super("\nExpecting:\n <%s>\nto be after or equals to:\n <%s>%s", actual, other, comparisonStrategy);
+  private ShouldBeAfterOrEqualsTo(Object actual, Object other, ComparisonStrategy comparisonStrategy) {
+	super("\nExpecting:\n  <%s>\nto be after or equals to:\n  <%s>%s", actual, other, comparisonStrategy);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeBefore.java b/src/main/java/org/assertj/core/error/ShouldBeBefore.java
index 9c1228592..765816641 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeBefore.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeBefore.java
@@ -12,13 +12,12 @@
  */
 package org.assertj.core.error;
 
-import java.util.Date;
-
-import org.assertj.core.internal.*;
+import org.assertj.core.internal.ComparisonStrategy;
+import org.assertj.core.internal.StandardComparisonStrategy;
 
 
 /**
- * Creates an error message indicating that an assertion that verifies that a {@link Date} is before another one failed.
+ * Creates an error message indicating that an assertion that verifies that a {@link Object} is before another one failed.
  * 
  * @author Joel Costigliola
  */
@@ -31,7 +30,7 @@ public class ShouldBeBefore extends BasicErrorMessageFactory {
    * @param comparisonStrategy the {@link ComparisonStrategy} used to evaluate assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
-  public static ErrorMessageFactory shouldBeBefore(Date actual, Date other, ComparisonStrategy comparisonStrategy) {
+  public static ErrorMessageFactory shouldBeBefore(Object actual, Object other, ComparisonStrategy comparisonStrategy) {
     return new ShouldBeBefore(actual, other, comparisonStrategy);
   }
 
@@ -41,11 +40,11 @@ public class ShouldBeBefore extends BasicErrorMessageFactory {
    * @param other the value used in the failed assertion to compare the actual value to.
    * @return the created {@code ErrorMessageFactory}.
    */
-  public static ErrorMessageFactory shouldBeBefore(Date actual, Date other) {
+  public static ErrorMessageFactory shouldBeBefore(Object actual, Object other) {
     return new ShouldBeBefore(actual, other, StandardComparisonStrategy.instance());
   }
 
-  private ShouldBeBefore(Date actual, Date other, ComparisonStrategy comparisonStrategy) {
-    super("\nExpecting:\n <%s>\nto be strictly before:\n <%s>%s", actual, other, comparisonStrategy);
+  private ShouldBeBefore(Object actual, Object other, ComparisonStrategy comparisonStrategy) {
+    super("\nExpecting:\n  <%s>\nto be strictly before:\n  <%s>%s", actual, other, comparisonStrategy);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeBeforeOrEqualsTo.java b/src/main/java/org/assertj/core/error/ShouldBeBeforeOrEqualsTo.java
index b379b6739..662347d80 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeBeforeOrEqualsTo.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeBeforeOrEqualsTo.java
@@ -12,13 +12,12 @@
  */
 package org.assertj.core.error;
 
-import java.util.Date;
-
-import org.assertj.core.internal.*;
+import org.assertj.core.internal.ComparisonStrategy;
+import org.assertj.core.internal.StandardComparisonStrategy;
 
 
 /**
- * Creates an error message indicating that an assertion that verifies that a {@link Date} is before or equals to another one
+ * Creates an error message indicating that an assertion that verifies that a {@link Object} is before or equals to another one
  * failed.
  * 
  * @author Joel Costigliola
@@ -32,7 +31,7 @@ public class ShouldBeBeforeOrEqualsTo extends BasicErrorMessageFactory {
    * @param comparisonStrategy the {@link ComparisonStrategy} used to evaluate assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
-  public static ErrorMessageFactory shouldBeBeforeOrEqualsTo(Date actual, Date other, ComparisonStrategy comparisonStrategy) {
+  public static ErrorMessageFactory shouldBeBeforeOrEqualsTo(Object actual, Object other, ComparisonStrategy comparisonStrategy) {
     return new ShouldBeBeforeOrEqualsTo(actual, other, comparisonStrategy);
   }
 
@@ -42,11 +41,11 @@ public class ShouldBeBeforeOrEqualsTo extends BasicErrorMessageFactory {
    * @param other the value used in the failed assertion to compare the actual value to.
    * @return the created {@code ErrorMessageFactory}.
    */
-  public static ErrorMessageFactory shouldBeBeforeOrEqualsTo(Date actual, Date other) {
+  public static ErrorMessageFactory shouldBeBeforeOrEqualsTo(Object actual, Object other) {
     return new ShouldBeBeforeOrEqualsTo(actual, other, StandardComparisonStrategy.instance());
   }
 
-  private ShouldBeBeforeOrEqualsTo(Date actual, Date other, ComparisonStrategy comparisonStrategy) {
-    super("\nExpecting:\n <%s>\nto be before or equals to:\n <%s>%s", actual, other, comparisonStrategy);
+  private ShouldBeBeforeOrEqualsTo(Object actual, Object other, ComparisonStrategy comparisonStrategy) {
+    super("\nExpecting:\n  <%s>\nto be before or equals to:\n  <%s>%s", actual, other, comparisonStrategy);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringHours.java b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringHours.java
new file mode 100644
index 000000000..0d4464feb
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringHours.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.error.BasicErrorMessageFactory;
+import org.assertj.core.error.ErrorMessageFactory;
+
+import java.time.ZonedDateTime;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that two {@link ZonedDateTime} have same year,
+ * month, and day fields failed.
+ * 
+ * @author Joel Costigliola
+ */
+public class ShouldBeEqualIgnoringHours extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link ShouldBeEqualIgnoringHours}</code>.
+   * 
+   * @param actual the actual value in the failed assertion.
+   * @param other the value used in the failed assertion to compare the actual value to.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeEqualIgnoringHours(Object actual, Object other) {
+    return new ShouldBeEqualIgnoringHours(actual, other);
+  }
+
+  private ShouldBeEqualIgnoringHours(Object actual, Object other) {
+    super("\nExpecting:\n  <%s>\nto have same year, month and day as:\n  <%s>\nbut had not.", actual, other);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringMinutes.java b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringMinutes.java
new file mode 100644
index 000000000..bd65eac55
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringMinutes.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.error.BasicErrorMessageFactory;
+import org.assertj.core.error.ErrorMessageFactory;
+
+import java.time.ZonedDateTime;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that two {@link ZonedDateTime} have same year,
+ * month, day and hour fields failed.
+ * 
+ * @author Joel Costigliola
+ */
+public class ShouldBeEqualIgnoringMinutes extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link ShouldBeEqualIgnoringMinutes}</code>.
+   * 
+   * @param actual the actual value in the failed assertion.
+   * @param other the value used in the failed assertion to compare the actual value to.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeEqualIgnoringMinutes(Object actual, Object other) {
+    return new ShouldBeEqualIgnoringMinutes(actual, other);
+  }
+
+  private ShouldBeEqualIgnoringMinutes(Object actual, Object other) {
+    super("\nExpecting:\n  <%s>\nto have same year, month, day and hour as:\n  <%s>\nbut had not.", actual, other);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringNanos.java b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringNanos.java
new file mode 100644
index 000000000..568c2d3f2
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringNanos.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.error.BasicErrorMessageFactory;
+import org.assertj.core.error.ErrorMessageFactory;
+
+import java.time.ZonedDateTime;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that two {@link ZonedDateTime} have same year,
+ * month, day, hour, minute and second failed.
+ * 
+ * @author Joel Costigliola
+ */
+public class ShouldBeEqualIgnoringNanos extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link ShouldBeEqualIgnoringNanos}</code>.
+   * 
+   * @param actual the actual value in the failed assertion.
+   * @param other the value used in the failed assertion to compare the actual value to.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeEqualIgnoringNanos(Object actual, Object other) {
+    return new ShouldBeEqualIgnoringNanos(actual, other);
+  }
+
+  private ShouldBeEqualIgnoringNanos(Object actual, Object other) {
+    super("\nExpecting:\n  <%s>\nto have same year, month, day, hour, minute and second as:\n  <%s>\nbut had not.",
+        actual, other);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringSeconds.java b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringSeconds.java
new file mode 100644
index 000000000..707d8a52f
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringSeconds.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.error.BasicErrorMessageFactory;
+import org.assertj.core.error.ErrorMessageFactory;
+
+import java.time.ZonedDateTime;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that two {@link ZonedDateTime} have same year,
+ * month, day, hour and minute failed.
+ * 
+ * @author Joel Costigliola
+ */
+public class ShouldBeEqualIgnoringSeconds extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link ShouldBeEqualIgnoringSeconds}</code>.
+   * 
+   * @param actual the actual value in the failed assertion.
+   * @param other the value used in the failed assertion to compare the actual value to.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeEqualIgnoringSeconds(Object actual, Object other) {
+    return new ShouldBeEqualIgnoringSeconds(actual, other);
+  }
+
+  private ShouldBeEqualIgnoringSeconds(Object actual, Object other) {
+    super("\nExpecting:\n  <%s>\nto have same year, month, day, hour and minute as:\n  <%s>\nbut had not.", actual,
+        other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_LocalDateTime_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_LocalDateTime_Test.java
new file mode 100644
index 000000000..4336bde11
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_LocalDateTime_Test.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.time.LocalDateTime;
+
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Assertions#assertThat(LocalDateTime)}</code>.
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public class Assertions_assertThat_with_LocalDateTime_Test {
+
+  @Test
+  public void should_create_Assert() {
+    AbstractLocalDateTimeAssert<?> assertions = Assertions.assertThat(LocalDateTime.now());
+    assertThat(assertions).isNotNull();
+  }
+
+  @Test
+  public void should_pass_actual() {
+    LocalDateTime localDateTime = LocalDateTime.now();
+    AbstractLocalDateTimeAssert<?> assertions = Assertions.assertThat(localDateTime);
+    assertThat(assertions.getActual()).isSameAs(localDateTime);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_ZonedDateTime_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_ZonedDateTime_Test.java
new file mode 100644
index 000000000..490b01715
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_ZonedDateTime_Test.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Assertions#assertThat(ZonedDateTime)}</code>.
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public class Assertions_assertThat_with_ZonedDateTime_Test {
+
+  @Test
+  public void should_create_Assert() {
+    AbstractZonedDateTimeAssert<?> assertions = Assertions.assertThat(ZonedDateTime.now());
+    assertThat(assertions).isNotNull();
+  }
+
+  @Test
+  public void should_pass_actual() {
+    ZonedDateTime dateTime = ZonedDateTime.now();
+    AbstractZonedDateTimeAssert<?>  assertions = Assertions.assertThat(dateTime);
+    assertThat(assertions.getActual()).isSameAs(dateTime);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/DateTimeBaseTest.java b/src/test/java/org/assertj/core/api/DateTimeBaseTest.java
new file mode 100644
index 000000000..6a2258502
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/DateTimeBaseTest.java
@@ -0,0 +1,39 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.junit.rules.ExpectedException.none;
+
+import org.junit.Assert;
+import org.junit.Rule;
+import org.junit.rules.ExpectedException;
+
+public class DateTimeBaseTest {
+
+  @Rule
+  public ExpectedException thrown = none();
+
+  protected void expectException(Class<? extends Throwable> type, String message) {
+    thrown.expect(type);
+    thrown.expectMessage(message);
+  }
+  
+  protected void expectIllegalArgumentException(String message) {
+    expectException(IllegalArgumentException.class, message);
+  }
+
+  public void failBecauseExpectedAssertionErrorWasNotThrown() {
+    Assert.fail("Assertion error expected");
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/ZonedDateTimeAssertBaseTest.java b/src/test/java/org/assertj/core/api/ZonedDateTimeAssertBaseTest.java
new file mode 100644
index 000000000..3c03c350c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/ZonedDateTimeAssertBaseTest.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import org.junit.experimental.theories.DataPoint;
+
+import java.time.ZonedDateTime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.junit.Assume.assumeTrue;
+
+/**
+ * 
+ * Base test class for {@link ZonedDateTimeAssert} tests.
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ *
+ */
+public class ZonedDateTimeAssertBaseTest extends DateTimeBaseTest {
+
+  @DataPoint
+  public static ZonedDateTime dateTime1 = ZonedDateTime.of(2000, 12, 14, 0, 0, 0, 0, UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime2 = ZonedDateTime.of(2000, 12, 13, 23, 59, 59, 999999999, UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime3 = ZonedDateTime.of(2000, 12, 14, 0, 0, 0, 1, UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime4 = ZonedDateTime.of(2000, 12, 14, 22, 15, 15, 875, UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime5 = ZonedDateTime.of(2000, 12, 14, 22, 15, 15, 874, UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime6 = ZonedDateTime.of(2000, 12, 14, 22, 15, 15, 876, UTC);
+
+  protected static void testAssumptions(ZonedDateTime reference, ZonedDateTime dateBefore, ZonedDateTime dateAfter) {
+    assumeTrue(dateBefore.isBefore(reference));
+    assumeTrue(dateAfter.isAfter(reference));
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssertBaseTest.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssertBaseTest.java
new file mode 100644
index 000000000..7c8496d65
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssertBaseTest.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.junit.Assume.assumeTrue;
+
+import java.time.LocalDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.assertj.core.api.AbstractLocalDateTimeAssert;
+import org.junit.experimental.theories.DataPoint;
+
+
+/**
+ * 
+ * Base test class for {@link AbstractLocalDateTimeAssert} tests.
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public class LocalDateTimeAssertBaseTest extends DateTimeBaseTest {
+
+  @DataPoint
+  public static LocalDateTime localDateTime1 = LocalDateTime.of(2000, 12, 14, 0, 0);
+  @DataPoint
+  public static LocalDateTime localDateTime2 = LocalDateTime.of(2000, 12, 13, 23, 59, 59, 999);
+  @DataPoint
+  public static LocalDateTime localDateTime3 = LocalDateTime.of(2000, 12, 14, 0, 0, 0, 1);
+  @DataPoint
+  public static LocalDateTime localDateTime4 = LocalDateTime.of(2000, 12, 14, 22, 15, 15, 875);
+  @DataPoint
+  public static LocalDateTime localDateTime5 = LocalDateTime.of(2000, 12, 14, 22, 15, 15, 874);
+  @DataPoint
+  public static LocalDateTime localDateTime6 = LocalDateTime.of(2000, 12, 14, 22, 15, 15, 876);
+
+  protected static void testAssumptions(LocalDateTime reference, LocalDateTime dateBefore, LocalDateTime dateAfter) {
+    assumeTrue(dateBefore.isBefore(reference));
+    assumeTrue(dateAfter.isAfter(reference));
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isAfterOrEqualTo_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isAfterOrEqualTo_Test.java
new file mode 100644
index 000000000..6473f4c25
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isAfterOrEqualTo_Test.java
@@ -0,0 +1,94 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDateTime;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateTimeAssert_isAfterOrEqualTo_Test extends LocalDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isAfterOrEqual_assertion(LocalDateTime referenceDate, LocalDateTime dateBefore,
+      LocalDateTime dateAfter) {
+    // GIVEN
+    testAssumptions(referenceDate, dateBefore, dateAfter);
+    // WHEN
+    assertThat(dateAfter).isAfterOrEqualTo(referenceDate);
+    assertThat(referenceDate).isAfterOrEqualTo(referenceDate);
+    // THEN
+    verify_that_isAfterOrEqual_assertion_fails_and_throws_AssertionError(dateBefore, referenceDate);
+  }
+
+  @Test
+  public void test_isAfterOrEqual_assertion_error_message() {
+    try {
+      assertThat(LocalDateTime.of(2000, 1, 5, 3, 0, 5)).isAfterOrEqualTo(LocalDateTime.of(2012, 1, 1, 3, 3, 3));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n  <2000-01-05T03:00:05>\nto be after or equals to:\n  <2012-01-01T03:03:03>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDateTime actual = null;
+    assertThat(actual).isAfterOrEqualTo(LocalDateTime.now());
+  }
+
+  @Test
+  public void should_fail_if_dateTime_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The LocalDateTime to compare actual with should not be null");
+    assertThat(LocalDateTime.now()).isAfterOrEqualTo((LocalDateTime) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isAfterOrEqualTo((String) null);
+  }
+
+  private static void verify_that_isAfterOrEqual_assertion_fails_and_throws_AssertionError(LocalDateTime dateToCheck,
+      LocalDateTime reference) {
+    try {
+      assertThat(dateToCheck).isAfterOrEqualTo(reference);
+    } catch (AssertionError e) {
+      // AssertionError was expected, test same assertion with String based parameter
+      try {
+        assertThat(dateToCheck).isAfterOrEqualTo(reference.toString());
+      } catch (AssertionError e2) {
+        // AssertionError was expected (again)
+        return;
+      }
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isAfter_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isAfter_Test.java
new file mode 100644
index 000000000..80c3c93c9
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isAfter_Test.java
@@ -0,0 +1,96 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDateTime;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateTimeAssert_isAfter_Test extends LocalDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isAfter_assertion(LocalDateTime referenceDate, LocalDateTime dateBefore, LocalDateTime dateAfter) {
+    // GIVEN
+    testAssumptions(referenceDate, dateBefore, dateAfter);
+    // WHEN
+    assertThat(dateAfter).isAfter(referenceDate);
+    assertThat(dateAfter).isAfter(referenceDate.toString());
+    // THEN
+    verify_that_isAfter_assertion_fails_and_throws_AssertionError(referenceDate, referenceDate);
+    verify_that_isAfter_assertion_fails_and_throws_AssertionError(dateBefore, referenceDate);
+  }
+
+  @Test
+  public void test_isAfter_assertion_error_message() {
+    try {
+      assertThat(LocalDateTime.of(2000, 1, 5, 3, 0, 5)).isAfter(LocalDateTime.of(2012, 1, 1, 3, 3, 3));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n  <2000-01-05T03:00:05>\nto be strictly after:\n  <2012-01-01T03:03:03>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDateTime actual = null;
+    assertThat(actual).isAfter(LocalDateTime.now());
+  }
+
+  @Test
+  public void should_fail_if_dateTime_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The LocalDateTime to compare actual with should not be null");
+    assertThat(LocalDateTime.now()).isAfter((LocalDateTime) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isAfter((String) null);
+  }
+
+
+  private static void verify_that_isAfter_assertion_fails_and_throws_AssertionError(LocalDateTime dateToCheck,
+      LocalDateTime reference) {
+    try {
+      assertThat(dateToCheck).isAfter(reference);
+    } catch (AssertionError e) {
+      // AssertionError was expected, test same assertion with String based parameter
+      try {
+        assertThat(dateToCheck).isAfter(reference.toString());
+      } catch (AssertionError e2) {
+        // AssertionError was expected (again)
+        return;
+      }
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isBeforeOrEqualTo_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isBeforeOrEqualTo_Test.java
new file mode 100644
index 000000000..5c94126a1
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isBeforeOrEqualTo_Test.java
@@ -0,0 +1,94 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDateTime;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateTimeAssert_isBeforeOrEqualTo_Test extends LocalDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isBeforeOrEqual_assertion(LocalDateTime referenceDate, LocalDateTime dateBefore,
+      LocalDateTime dateAfter) {
+    // GIVEN
+    testAssumptions(referenceDate, dateBefore, dateAfter);
+    // WHEN
+    assertThat(dateBefore).isBeforeOrEqualTo(referenceDate);
+    assertThat(referenceDate).isBeforeOrEqualTo(referenceDate);
+    // THEN
+    verify_that_isBeforeOrEqual_assertion_fails_and_throws_AssertionError(dateAfter, referenceDate);
+  }
+
+  @Test
+  public void test_isBeforeOrEqual_assertion_error_message() {
+    try {
+      assertThat(LocalDateTime.of(2000, 1, 5, 3, 0, 5)).isBeforeOrEqualTo(LocalDateTime.of(1998, 1, 1, 3, 3, 3));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n  <2000-01-05T03:00:05>\nto be before or equals to:\n  <1998-01-01T03:03:03>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDateTime actual = null;
+    assertThat(actual).isBeforeOrEqualTo(LocalDateTime.now());
+  }
+
+  @Test
+  public void should_fail_if_dateTime_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The LocalDateTime to compare actual with should not be null");
+    assertThat(LocalDateTime.now()).isBeforeOrEqualTo((LocalDateTime) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isBeforeOrEqualTo((String) null);
+  }
+
+  private static void verify_that_isBeforeOrEqual_assertion_fails_and_throws_AssertionError(LocalDateTime dateToCheck,
+      LocalDateTime reference) {
+    try {
+      assertThat(dateToCheck).isBeforeOrEqualTo(reference);
+    } catch (AssertionError e) {
+      // AssertionError was expected, test same assertion with String based parameter
+      try {
+        assertThat(dateToCheck).isBeforeOrEqualTo(reference.toString());
+      } catch (AssertionError e2) {
+        // AssertionError was expected (again)
+        return;
+      }
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isBefore_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isBefore_Test.java
new file mode 100644
index 000000000..2c90194d7
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isBefore_Test.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDateTime;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateTimeAssert_isBefore_Test extends LocalDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isBefore_assertion(LocalDateTime referenceDate, LocalDateTime dateBefore, LocalDateTime dateAfter) {
+    // GIVEN
+    testAssumptions(referenceDate, dateBefore, dateAfter);
+    // WHEN
+    assertThat(dateBefore).isBefore(referenceDate);
+    // THEN
+    verify_that_isBefore_assertion_fails_and_throws_AssertionError(referenceDate, referenceDate);
+    verify_that_isBefore_assertion_fails_and_throws_AssertionError(dateAfter, referenceDate);
+  }
+
+  @Test
+  public void test_isBefore_assertion_error_message() {
+    try {
+      assertThat(LocalDateTime.of(2000, 1, 5, 3, 0, 5)).isBefore(LocalDateTime.of(1998, 1, 1, 3, 3, 3));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n  <2000-01-05T03:00:05>\nto be strictly before:\n  <1998-01-01T03:03:03>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDateTime actual = null;
+    assertThat(actual).isBefore(LocalDateTime.now());
+  }
+
+  @Test
+  public void should_fail_if_dateTime_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The LocalDateTime to compare actual with should not be null");
+    assertThat(LocalDateTime.now()).isBefore((LocalDateTime) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isBefore((String) null);
+  }
+
+  private static void verify_that_isBefore_assertion_fails_and_throws_AssertionError(LocalDateTime dateToTest,
+      LocalDateTime reference) {
+    try {
+      assertThat(dateToTest).isBefore(reference);
+    } catch (AssertionError e) {
+      // AssertionError was expected, test same assertion with String based parameter
+      try {
+        assertThat(dateToTest).isBefore(reference.toString());
+      } catch (AssertionError e2) {
+        // AssertionError was expected (again)
+        return;
+      }
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringHours_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringHours_Test.java
new file mode 100644
index 000000000..a074df3b0
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringHours_Test.java
@@ -0,0 +1,72 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.AbstractLocalDateTimeAssert.NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.junit.Test;
+
+public class LocalDateTimeAssert_isEqualToIgnoringHours_Test extends DateTimeBaseTest {
+
+  private final LocalDateTime refLocalDateTime = LocalDateTime.of(2000, 1, 2, 0, 0, 0, 0);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_hour_fields() {
+    assertThat(refLocalDateTime).isEqualToIgnoringHours(refLocalDateTime.plusHours(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_localdatetime_with_hour_ignored() {
+    try {
+      assertThat(refLocalDateTime).isEqualToIgnoringHours(refLocalDateTime.minusHours(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-02T00:00>\nto have same year, month and day as:\n  <2000-01-01T23:00>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_hours_fields_are_different_even_if_time_difference_is_less_than_a_hour() {
+    try {
+      assertThat(refLocalDateTime).isEqualToIgnoringHours(refLocalDateTime.minusNanos(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-02T00:00>\nto have same year, month and day as:\n  <2000-01-01T23:59:59.999999999>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDateTime actual = null;
+    assertThat(actual).isEqualToIgnoringHours(LocalDateTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_localdatetime_is_null() {
+    expectIllegalArgumentException(NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE);
+    assertThat(refLocalDateTime).isEqualToIgnoringHours(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringMinutes_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringMinutes_Test.java
new file mode 100644
index 000000000..94922f514
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringMinutes_Test.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.AbstractLocalDateTimeAssert.NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.junit.Test;
+
+
+public class LocalDateTimeAssert_isEqualToIgnoringMinutes_Test extends DateTimeBaseTest {
+
+  private final LocalDateTime refLocalDateTime = LocalDateTime.of(2000, 1, 1, 23, 0, 0, 0);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_minute_fields() {
+    assertThat(refLocalDateTime).isEqualToIgnoringMinutes(refLocalDateTime.plusMinutes(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_localdatetime_with_minute_ignored() {
+    try {
+      assertThat(refLocalDateTime).isEqualToIgnoringMinutes(refLocalDateTime.minusMinutes(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T23:00>\nto have same year, month, day and hour as:\n  <2000-01-01T22:59>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_minutes_fields_are_different_even_if_time_difference_is_less_than_a_minute() {
+    try {
+      assertThat(refLocalDateTime).isEqualToIgnoringMinutes(refLocalDateTime.minusNanos(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T23:00>\nto have same year, month, day and hour as:\n  <2000-01-01T22:59:59.999999999>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDateTime actual = null;
+    assertThat(actual).isEqualToIgnoringMinutes(LocalDateTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_localdatetime_is_null() {
+    expectIllegalArgumentException(NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE);
+    assertThat(refLocalDateTime).isEqualToIgnoringMinutes(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
new file mode 100644
index 000000000..88a1a21d7
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
@@ -0,0 +1,74 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.AbstractLocalDateTimeAssert.NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.junit.Test;
+
+
+public class LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test extends DateTimeBaseTest {
+
+  private final LocalDateTime refLocalDateTime = LocalDateTime.of(2000, 1, 1, 0, 0, 1, 0);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_nanosecond_fields() {
+    assertThat(refLocalDateTime).isEqualToIgnoringNanos(refLocalDateTime.withNano(55));
+    assertThat(refLocalDateTime).isEqualToIgnoringNanos(refLocalDateTime.plusNanos(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_localdatetime_with_nanoseconds_ignored() {
+    try {
+      assertThat(refLocalDateTime).isEqualToIgnoringNanos(refLocalDateTime.plusSeconds(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T00:00:01>\nto have same year, month, day, hour, minute and second as:\n  <2000-01-01T00:00:02>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
+    try {
+      assertThat(refLocalDateTime).isEqualToIgnoringNanos(refLocalDateTime.minusNanos(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T00:00:01>\nto have same year, month, day, hour, minute and second as:\n  <2000-01-01T00:00:00.999999999>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDateTime actual = null;
+    assertThat(actual).isEqualToIgnoringNanos(LocalDateTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_localdatetime_is_null() {
+    expectIllegalArgumentException(NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE);
+    assertThat(refLocalDateTime).isEqualToIgnoringNanos(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringSeconds_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringSeconds_Test.java
new file mode 100644
index 000000000..04ed453df
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringSeconds_Test.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.AbstractLocalDateTimeAssert.NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.junit.Test;
+
+
+public class LocalDateTimeAssert_isEqualToIgnoringSeconds_Test extends DateTimeBaseTest {
+
+  private final LocalDateTime refLocalDateTime = LocalDateTime.of(2000, 1, 1, 23, 51, 0, 0);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_second_fields() {
+    assertThat(refLocalDateTime).isEqualToIgnoringSeconds(refLocalDateTime.plusSeconds(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_localdatetime_with_second_ignored() {
+    try {
+      assertThat(refLocalDateTime).isEqualToIgnoringSeconds(refLocalDateTime.plusMinutes(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T23:51>\nto have same year, month, day, hour and minute as:\n  <2000-01-01T23:52>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
+    try {
+      assertThat(refLocalDateTime).isEqualToIgnoringSeconds(refLocalDateTime.minusNanos(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T23:51>\nto have same year, month, day, hour and minute as:\n  <2000-01-01T23:50:59.999999999>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDateTime actual = null;
+    assertThat(actual).isEqualToIgnoringSeconds(LocalDateTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_localdatetime_is_null() {
+    expectIllegalArgumentException(NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE);
+    assertThat(refLocalDateTime).isEqualToIgnoringSeconds(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualTo_Test.java
new file mode 100644
index 000000000..fcfe1f77b
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualTo_Test.java
@@ -0,0 +1,70 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link java.time.ZonedDateTime} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateTimeAssert_isEqualTo_Test extends LocalDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isEqualTo_assertion(LocalDateTime referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isEqualTo(referenceDate.toString());
+    // THEN
+    verify_that_isEqualTo_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isEqualTo_assertion_error_message() {
+    try {
+      assertThat(LocalDateTime.of(2000, 1, 5, 3, 0, 5)).isEqualTo(LocalDateTime.of(2012, 1, 1, 3, 3, 3).toString());
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("expected:<20[12-01-01T03:03:03]> but was:<20[00-01-05T03:00:05]>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the LocalDateTime to compare actual with should not be null");
+    assertThat(LocalDateTime.now()).isEqualTo((String) null);
+  }
+
+  private static void verify_that_isEqualTo_assertion_fails_and_throws_AssertionError(LocalDateTime reference) {
+    try {
+      assertThat(reference).isEqualTo(reference.plusDays(1).toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isIn_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isIn_Test.java
new file mode 100644
index 000000000..22fde0a88
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isIn_Test.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link LocalDateTime} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateTimeAssert_isIn_Test extends LocalDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isIn_assertion(LocalDateTime referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isIn(referenceDate.toString(), referenceDate.plusDays(1).toString());
+    // THEN
+    verify_that_isIn_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isIn_assertion_error_message() {
+    try {
+      assertThat(LocalDateTime.of(2000, 1, 5, 3, 0, 5)).isIn(LocalDateTime.of(2012, 1, 1, 3, 3, 3).toString());
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n <2000-01-05T03:00:05>\nto be in:\n <[2012-01-01T03:03:03]>\n");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dateTimes_as_string_array_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The given LocalDateTime array should not be null");
+    assertThat(LocalDateTime.now()).isIn((String[]) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTimes_as_string_array_parameter_is_empty() {
+    expectException(IllegalArgumentException.class, "The given LocalDateTime array should not be empty");
+    assertThat(LocalDateTime.now()).isIn(new String[0]);
+  }
+
+  private static void verify_that_isIn_assertion_fails_and_throws_AssertionError(LocalDateTime reference) {
+    try {
+      assertThat(reference).isIn(reference.plusDays(1).toString(), reference.plusDays(2).toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isNotEqualTo_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isNotEqualTo_Test.java
new file mode 100644
index 000000000..d8014d81d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isNotEqualTo_Test.java
@@ -0,0 +1,71 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link LocalDateTime} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateTimeAssert_isNotEqualTo_Test extends LocalDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isNotEqualTo_assertion(LocalDateTime referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isNotEqualTo(referenceDate.plusDays(1).toString());
+    // THEN
+    verify_that_isNotEqualTo_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isNotEqualTo_assertion_error_message() {
+    try {
+      assertThat(LocalDateTime.of(2000, 1, 5, 3, 0, 5))
+          .isNotEqualTo(LocalDateTime.of(2000, 1, 5, 3, 0, 5).toString());
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n <2000-01-05T03:00:05>\nnot to be equal to:\n <2000-01-05T03:00:05>\n");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the LocalDateTime to compare actual with should not be null");
+    assertThat(LocalDateTime.now()).isNotEqualTo((String) null);
+  }
+
+  private static void verify_that_isNotEqualTo_assertion_fails_and_throws_AssertionError(LocalDateTime reference) {
+    try {
+      assertThat(reference).isNotEqualTo(reference.toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isNotIn_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isNotIn_Test.java
new file mode 100644
index 000000000..7a45cf817
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isNotIn_Test.java
@@ -0,0 +1,78 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link LocalDateTime} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateTimeAssert_isNotIn_Test extends LocalDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isNotIn_assertion(LocalDateTime referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isNotIn(referenceDate.plusDays(1).toString(), referenceDate.plusDays(2).toString());
+    // THEN
+    verify_that_isNotIn_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isNotIn_assertion_error_message() {
+    try {
+      assertThat(LocalDateTime.of(2000, 1, 5, 3, 0, 5)).isNotIn(LocalDateTime.of(2000, 1, 5, 3, 0, 5).toString(),
+          LocalDateTime.of(2012, 1, 1, 3, 3, 3).toString());
+    } catch (AssertionError e) {
+      assertThat(e)
+          .hasMessage(
+              "\nExpecting:\n <2000-01-05T03:00:05>\nnot to be in:\n <[2000-01-05T03:00:05, 2012-01-01T03:03:03]>\n");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dateTimes_as_string_array_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The given LocalDateTime array should not be null");
+    assertThat(LocalDateTime.now()).isNotIn((String[]) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTimes_as_string_array_parameter_is_empty() {
+    expectException(IllegalArgumentException.class, "The given LocalDateTime array should not be empty");
+    assertThat(LocalDateTime.now()).isNotIn(new String[0]);
+  }
+
+  private static void verify_that_isNotIn_assertion_fails_and_throws_AssertionError(LocalDateTime reference) {
+    try {
+      assertThat(reference).isNotIn(reference.toString(), reference.plusDays(1).toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssertBaseTest.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssertBaseTest.java
new file mode 100644
index 000000000..976c9234e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssertBaseTest.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static org.junit.Assume.assumeTrue;
+
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.junit.experimental.theories.DataPoint;
+
+
+/**
+ * Base test class for {@link org.assertj.core.api.ZonedDateTimeAssert} tests.
+ * 
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public class ZonedDateTimeAssertBaseTest extends DateTimeBaseTest {
+
+  @DataPoint
+  public static ZonedDateTime dateTime1 = ZonedDateTime.of(2000, 12, 14, 0, 0, 0, 0, ZoneOffset.UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime2 = ZonedDateTime.of(2000, 12, 13, 23, 59, 59, 999, ZoneOffset.UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime3 = ZonedDateTime.of(2000, 12, 14, 0, 0, 0, 1, ZoneOffset.UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime4 = ZonedDateTime.of(2000, 12, 14, 22, 15, 15, 875, ZoneOffset.UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime5 = ZonedDateTime.of(2000, 12, 14, 22, 15, 15, 874, ZoneOffset.UTC);
+  @DataPoint
+  public static ZonedDateTime dateTime6 = ZonedDateTime.of(2000, 12, 14, 22, 15, 15, 876, ZoneOffset.UTC);
+
+  protected static void testAssumptions(ZonedDateTime reference, ZonedDateTime dateBefore, ZonedDateTime dateAfter) {
+    assumeTrue(dateBefore.isBefore(reference));
+    assumeTrue(dateAfter.isAfter(reference));
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isAfterOrEqualTo_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isAfterOrEqualTo_Test.java
new file mode 100644
index 000000000..8bf73478f
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isAfterOrEqualTo_Test.java
@@ -0,0 +1,108 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class ZonedDateTimeAssert_isAfterOrEqualTo_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isAfterOrEqual_assertion(ZonedDateTime referenceDate, ZonedDateTime dateBefore, ZonedDateTime dateAfter) {
+    // GIVEN
+    testAssumptions(referenceDate, dateBefore, dateAfter);
+    // WHEN
+    assertThat(dateAfter).isAfterOrEqualTo(referenceDate);
+    assertThat(dateAfter).isAfterOrEqualTo(referenceDate.toString());
+    assertThat(referenceDate).isAfterOrEqualTo(referenceDate);
+    assertThat(referenceDate).isAfterOrEqualTo(referenceDate.toString());
+    // THEN
+    verify_that_isAfterOrEqual_assertion_fails_and_throws_AssertionError(dateBefore, referenceDate);
+  }
+
+  @Test
+  public void isAfterOrEqualTo_should_compare_datetimes_in_actual_timezone() {
+    ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, UTC);
+    ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
+    ZonedDateTime cestDateTime1 = ZonedDateTime.of(2013, 6, 10, 2, 0, 0, 0, cestTimeZone);
+    ZonedDateTime cestDateTime2 = ZonedDateTime.of(2013, 6, 10, 1, 0, 0, 0, cestTimeZone);
+    // utcDateTime = cestDateTime1
+    assertThat(utcDateTime).as("in UTC time zone").isAfterOrEqualTo(cestDateTime1);
+    // utcDateTime > cestDateTime2
+    assertThat(utcDateTime).as("in UTC time zone").isAfterOrEqualTo(cestDateTime2);
+  }
+
+  @Test
+  public void test_isAfterOrEqual_assertion_error_message() {
+    try {
+      assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC)).isAfterOrEqualTo(ZonedDateTime.of(2012, 1, 1, 3, 3, 3, 0, UTC));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n  <2000-01-05T03:00:05Z>\nto be after or equals to:\n  <2012-01-01T03:03:03Z>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    ZonedDateTime actual = null;
+    assertThat(actual).isAfterOrEqualTo(ZonedDateTime.now());
+  }
+
+  @Test
+  public void should_fail_if_dateTime_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isAfterOrEqualTo((ZonedDateTime) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+                    "The String representing the ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isAfterOrEqualTo((String) null);
+  }
+
+  private static void verify_that_isAfterOrEqual_assertion_fails_and_throws_AssertionError(ZonedDateTime dateToCheck,
+      ZonedDateTime reference) {
+    try {
+      assertThat(dateToCheck).isAfterOrEqualTo(reference);
+    } catch (AssertionError e) {
+      // AssertionError was expected, test same assertion with String based parameter
+      try {
+        assertThat(dateToCheck).isAfterOrEqualTo(reference.toString());
+      } catch (AssertionError e2) {
+        // AssertionError was expected (again)
+        return;
+      }
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isAfter_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isAfter_Test.java
new file mode 100644
index 000000000..58bbd9e32
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isAfter_Test.java
@@ -0,0 +1,112 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class ZonedDateTimeAssert_isAfter_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isAfter_assertion(ZonedDateTime referenceDate, ZonedDateTime dateBefore, ZonedDateTime dateAfter) {
+    // GIVEN
+    testAssumptions(referenceDate, dateBefore, dateAfter);
+    // WHEN
+    assertThat(dateAfter).isAfter(referenceDate);
+    assertThat(dateAfter).isAfter(referenceDate.format(DateTimeFormatter.ISO_DATE_TIME));
+    // THEN
+    verify_that_isAfter_assertion_fails_and_throws_AssertionError(referenceDate, referenceDate);
+    verify_that_isAfter_assertion_fails_and_throws_AssertionError(dateBefore, referenceDate);
+  }
+
+  @Test
+  public void isAfter_should_compare_datetimes_in_actual_timezone() {
+    ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, UTC);
+    ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
+    ZonedDateTime cestDateTime = ZonedDateTime.of(2013, 6, 10, 1, 0, 0, 0, cestTimeZone);
+    // utcDateTime > cestDateTime
+    assertThat(utcDateTime).as("in UTC time zone").isAfter(cestDateTime);
+    try {
+      ZonedDateTime equalsCestDateTime = ZonedDateTime.of(2013, 6, 10, 2, 0, 0, 0, cestTimeZone);
+      assertThat(utcDateTime).as("in UTC time zone").isAfter(equalsCestDateTime);
+    } catch (AssertionError e) {
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void test_isAfter_assertion_error_message() {
+    try {
+      assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC)).isAfter(ZonedDateTime.of(2012, 1, 1, 3, 3, 3, 0, UTC));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n  <2000-01-05T03:00:05Z>\nto be strictly after:\n  <2012-01-01T03:03:03Z>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    ZonedDateTime actual = null;
+    assertThat(actual).isAfter(ZonedDateTime.now());
+  }
+
+  @Test
+  public void should_fail_if_dateTime_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isAfter((ZonedDateTime) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+                    "The String representing the ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isAfter((String) null);
+  }
+
+  private static void verify_that_isAfter_assertion_fails_and_throws_AssertionError(ZonedDateTime dateToCheck,
+      ZonedDateTime reference) {
+    try {
+      assertThat(dateToCheck).isAfter(reference);
+    } catch (AssertionError e) {
+      // AssertionError was expected, test same assertion with String based parameter
+      try {
+        assertThat(dateToCheck).isAfter(reference.toString());
+      } catch (AssertionError e2) {
+        // AssertionError was expected (again)
+        return;
+      }
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isBeforeOrEqualTo_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isBeforeOrEqualTo_Test.java
new file mode 100644
index 000000000..083d8a41a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isBeforeOrEqualTo_Test.java
@@ -0,0 +1,115 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.ZoneId;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class ZonedDateTimeAssert_isBeforeOrEqualTo_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isBeforeOrEqual_assertion(ZonedDateTime referenceDate, ZonedDateTime dateBefore,
+	                                         ZonedDateTime dateAfter) {
+	// GIVEN
+	testAssumptions(referenceDate, dateBefore, dateAfter);
+	// WHEN
+	assertThat(dateBefore).isBeforeOrEqualTo(referenceDate);
+	assertThat(dateBefore).isBeforeOrEqualTo(referenceDate.toString());
+	assertThat(referenceDate).isBeforeOrEqualTo(referenceDate);
+	assertThat(referenceDate).isBeforeOrEqualTo(referenceDate.toString());
+	// THEN
+	verify_that_isBeforeOrEqual_assertion_fails_and_throws_AssertionError(dateAfter, referenceDate);
+  }
+
+  @Test
+  public void isBeforeOrEqualTo_should_compare_datetimes_in_actual_timezone() {
+	ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, ZoneOffset.UTC);
+	ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
+	ZonedDateTime cestDateTime1 = ZonedDateTime.of(2013, 6, 10, 2, 0, 0, 0, cestTimeZone);
+	ZonedDateTime cestDateTime2 = ZonedDateTime.of(2013, 6, 10, 3, 0, 0, 0, cestTimeZone);
+	// utcDateTime = cestDateTime1
+	assertThat(utcDateTime).as("in UTC time zone").isBeforeOrEqualTo(cestDateTime1);
+	// utcDateTime < cestDateTime2
+	assertThat(utcDateTime).as("in UTC time zone").isBeforeOrEqualTo(cestDateTime2);
+  }
+
+  @Test
+  public void test_isBeforeOrEqual_assertion_error_message() {
+	try {
+	  assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC)).isBeforeOrEqualTo(ZonedDateTime.of(1998, 1, 1, 3, 3, 3,
+		                                                                                           0, UTC));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       "  <2000-01-05T03:00:05Z>\n" +
+		                       "to be before or equals to:\n" +
+		                       "  <1998-01-01T03:03:03Z>");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	ZonedDateTime actual = null;
+	assertThat(actual).isBeforeOrEqualTo(ZonedDateTime.now());
+  }
+
+  @Test
+  public void should_fail_if_dateTime_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The ZonedDateTime to compare actual with should not be null");
+	assertThat(ZonedDateTime.now()).isBeforeOrEqualTo((ZonedDateTime) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+	expectException(IllegalArgumentException.class,
+	                "The String representing the ZonedDateTime to compare actual with should not be null");
+	assertThat(ZonedDateTime.now()).isBeforeOrEqualTo((String) null);
+  }
+
+  private static void verify_that_isBeforeOrEqual_assertion_fails_and_throws_AssertionError(ZonedDateTime dateToCheck,
+	                                                                                        ZonedDateTime reference) {
+	try {
+	  assertThat(dateToCheck).isBeforeOrEqualTo(reference);
+	} catch (AssertionError e) {
+	  // AssertionError was expected, test same assertion with String based parameter
+	  try {
+		assertThat(dateToCheck).isBeforeOrEqualTo(reference.toString());
+	  } catch (AssertionError e2) {
+		// AssertionError was expected (again)
+		return;
+	  }
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isBefore_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isBefore_Test.java
new file mode 100644
index 000000000..be080893e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isBefore_Test.java
@@ -0,0 +1,112 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class ZonedDateTimeAssert_isBefore_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isBefore_assertion(ZonedDateTime referenceDate, ZonedDateTime dateBefore, ZonedDateTime dateAfter) {
+    // GIVEN
+    testAssumptions(referenceDate, dateBefore, dateAfter);
+    // WHEN
+    assertThat(dateBefore).isBefore(referenceDate);
+    assertThat(dateBefore).isBefore(referenceDate.toString());
+    // THEN
+    verify_that_isBefore_assertion_fails_and_throws_AssertionError(referenceDate, referenceDate);
+    verify_that_isBefore_assertion_fails_and_throws_AssertionError(dateAfter, referenceDate);
+  }
+
+  @Test
+  public void isBefore_should_compare_datetimes_in_actual_timezone() {
+    ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, UTC);
+    ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
+    ZonedDateTime cestDateTime2 = ZonedDateTime.of(2013, 6, 10, 3, 0, 0, 0, cestTimeZone);
+    //  utcDateTime < cestDateTime2  
+    assertThat(utcDateTime).as("in UTC time zone").isBefore(cestDateTime2);
+    // utcDateTime = cestDateTime1
+    try {
+        ZonedDateTime cestDateTime1 = ZonedDateTime.of(2013, 6, 10, 2, 0, 0, 0, cestTimeZone);
+      assertThat(utcDateTime).as("in UTC time zone").isBefore(cestDateTime1);
+    } catch (AssertionError e) {
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void test_isBefore_assertion_error_message() {
+    try {
+      assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 0, 0, UTC)).isBefore(ZonedDateTime.of(1998, 1, 1, 3, 3, 0, 0, UTC));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n  <2000-01-05T03:00Z>\nto be strictly before:\n  <1998-01-01T03:03Z>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    ZonedDateTime actual = null;
+    assertThat(actual).isBefore(ZonedDateTime.now());
+  }
+
+  @Test
+  public void should_fail_if_dateTime_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isBefore((ZonedDateTime) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isBefore((String) null);
+  }
+
+  private static void verify_that_isBefore_assertion_fails_and_throws_AssertionError(ZonedDateTime dateToTest,
+      ZonedDateTime reference) {
+    try {
+      assertThat(dateToTest).isBefore(reference);
+    } catch (AssertionError e) {
+      // AssertionError was expected, test same assertion with String based parameter
+      try {
+        assertThat(dateToTest).isBefore(reference.toString());
+      } catch (AssertionError e2) {
+        // AssertionError was expected (again)
+        return;
+      }
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringHours_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringHours_Test.java
new file mode 100644
index 000000000..c5ada3862
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringHours_Test.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.api.ZonedDateTimeAssert.NULL_DATE_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.junit.Test;
+
+
+public class ZonedDateTimeAssert_isEqualToIgnoringHours_Test extends DateTimeBaseTest {
+
+  private final ZonedDateTime refDatetime = ZonedDateTime.of(2000, 1, 2, 0, 0, 0, 0, UTC);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_hours() {
+    assertThat(refDatetime).isEqualToIgnoringHours(refDatetime.plusHours(1));
+  }
+  
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_hours_in_different_timezone() {
+      ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, UTC);
+    ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
+    // utcDateTime = new DateTime(2013, 6, 10, 2, 0, cestTimeZone)  
+    assertThat(utcDateTime).isEqualToIgnoringHours(ZonedDateTime.of(2013, 6, 10, 5, 0, 0, 0, cestTimeZone));
+    // new DateTime(2013, 6, 11, 1, 0, cestTimeZone) =  DateTime(2013, 6, 10, 23, 0, DateTimeZone.UTC)
+    assertThat(utcDateTime).isEqualToIgnoringHours(ZonedDateTime.of(2013, 6, 11, 1, 0, 0, 0, cestTimeZone));
+    try {
+      // DateTime(2013, 6, 10, 0, 0, cestTimeZone) =  DateTime(2013, 6, 9, 22, 0, DateTimeZone.UTC) 
+      assertThat(utcDateTime).isEqualToIgnoringHours(ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, cestTimeZone));
+    } catch (AssertionError e) {
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_datetime_with_hours_ignored() {
+    try {
+      assertThat(refDatetime).isEqualToIgnoringHours(refDatetime.minusHours(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-02T00:00Z>\nto have same year, month and day as:\n  <2000-01-01T23:00Z>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_hours_fields_are_different_even_if_time_difference_is_less_than_a_hour() {
+    try {
+      assertThat(refDatetime).isEqualToIgnoringHours(refDatetime.minusNanos(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-02T00:00Z>\nto have same year, month and day as:\n  <2000-01-01T23:59:59.999999999Z>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    ZonedDateTime actual = null;
+    assertThat(actual).isEqualToIgnoringHours(ZonedDateTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_datetime_is_null() {
+    expectIllegalArgumentException(NULL_DATE_TIME_PARAMETER_MESSAGE);
+    assertThat(refDatetime).isEqualToIgnoringHours(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test.java
new file mode 100644
index 000000000..622e1ed3a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test.java
@@ -0,0 +1,74 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.ZonedDateTimeAssert.NULL_DATE_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.ZonedDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.junit.Test;
+
+
+public class ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test extends DateTimeBaseTest {
+
+  private final ZonedDateTime refDatetime = ZonedDateTime.of(2000, 1, 1, 23, 0, 0, 0, UTC);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_minute_fields() {
+    assertThat(refDatetime).isEqualToIgnoringMinutes(refDatetime.plusMinutes(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_datetime_with_minute_ignored() {
+    try {
+      assertThat(refDatetime).isEqualToIgnoringMinutes(refDatetime.minusMinutes(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T23:00Z>\nto have same year, month, day and hour as:\n  <2000-01-01T22:59Z>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_minutes_fields_are_different_even_if_time_difference_is_less_than_a_minute() {
+    try {
+      assertThat(refDatetime).isEqualToIgnoringMinutes(refDatetime.minusNanos(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T23:00Z>\nto have same year, month, day and hour as:\n  <2000-01-01T22:59:59.999999999Z>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    ZonedDateTime actual = null;
+    assertThat(actual).isEqualToIgnoringMinutes(ZonedDateTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_datetime_is_null() {
+    expectIllegalArgumentException(NULL_DATE_TIME_PARAMETER_MESSAGE);
+    assertThat(refDatetime).isEqualToIgnoringMinutes(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
new file mode 100644
index 000000000..25696da91
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
@@ -0,0 +1,74 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.ZonedDateTimeAssert.NULL_DATE_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.ZonedDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.junit.Test;
+
+public class ZonedDateTimeAssert_isEqualToIgnoringNanoseconds_Test extends DateTimeBaseTest {
+
+  private final ZonedDateTime refDatetime = ZonedDateTime.of(2000, 1, 1, 0, 0, 1, 0, UTC);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_nanosecond_fields() {
+    assertThat(refDatetime).isEqualToIgnoringNanos(refDatetime.withNano(55));
+    assertThat(refDatetime).isEqualToIgnoringNanos(refDatetime.plusNanos(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_datetime_with_nanoseconds_ignored() {
+    try {
+      assertThat(refDatetime).isEqualToIgnoringNanos(refDatetime.plusSeconds(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T00:00:01Z>\nto have same year, month, day, hour, minute and second as:\n  <2000-01-01T00:00:02Z>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
+    try {
+      assertThat(refDatetime).isEqualToIgnoringNanos(refDatetime.minusNanos(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T00:00:01Z>\nto have same year, month, day, hour, minute and second as:\n  <2000-01-01T00:00:00.999999999Z>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    ZonedDateTime actual = null;
+    assertThat(actual).isEqualToIgnoringNanos(ZonedDateTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_datetime_is_null() {
+    expectIllegalArgumentException(NULL_DATE_TIME_PARAMETER_MESSAGE);
+    assertThat(refDatetime).isEqualToIgnoringNanos(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test.java
new file mode 100644
index 000000000..c78e126cc
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test.java
@@ -0,0 +1,74 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.ZonedDateTimeAssert.NULL_DATE_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.ZonedDateTime;
+
+import org.assertj.core.api.DateTimeBaseTest;
+import org.junit.Test;
+
+
+public class ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test extends DateTimeBaseTest {
+
+  private final ZonedDateTime refDatetime = ZonedDateTime.of(2000, 1, 1, 23, 51, 0, 0, UTC);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_second_fields() {
+    assertThat(refDatetime).isEqualToIgnoringSeconds(refDatetime.plusSeconds(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_datetime_with_second_ignored() {
+    try {
+      assertThat(refDatetime).isEqualToIgnoringSeconds(refDatetime.plusMinutes(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T23:51Z>\nto have same year, month, day, hour and minute as:\n  <2000-01-01T23:52Z>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
+    try {
+      assertThat(refDatetime).isEqualToIgnoringSeconds(refDatetime.minusNanos(1));
+    } catch (AssertionError e) {
+      assertThat(e.getMessage())
+          .isEqualTo(
+              "\nExpecting:\n  <2000-01-01T23:51Z>\nto have same year, month, day, hour and minute as:\n  <2000-01-01T23:50:59.999999999Z>\nbut had not.");
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    ZonedDateTime actual = null;
+    assertThat(actual).isEqualToIgnoringSeconds(ZonedDateTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_datetime_is_null() {
+    expectIllegalArgumentException(NULL_DATE_TIME_PARAMETER_MESSAGE);
+    assertThat(refDatetime).isEqualToIgnoringSeconds(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualTo_Test.java
new file mode 100644
index 000000000..996fe0aa0
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualTo_Test.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+
+/**
+ * Tests specific to {@link org.assertj.core.api.ZonedDateTimeAssert#isEqualTo(ZonedDateTime)} that can't be
+ * done in {@link org.assertj.core.api.AbstractAssert#isEqualTo(Object)} tests.
+ *
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public class ZonedDateTimeAssert_isEqualTo_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Test
+  public void isEqualTo_should_compare_datetimes_in_actual_timezone() {
+    ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, UTC);
+    ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
+    ZonedDateTime cestDateTime = ZonedDateTime.of(2013, 6, 10, 2, 0, 0, 0, cestTimeZone);
+    // datetime are equals in same timezone
+    assertThat(utcDateTime).as("in UTC time zone").isEqualTo(cestDateTime);
+    assertThat(cestDateTime).as("in CEST time zone").isEqualTo(utcDateTime);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualTo_errors_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualTo_errors_Test.java
new file mode 100644
index 000000000..f8a6af799
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualTo_errors_Test.java
@@ -0,0 +1,71 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link ZonedDateTime} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class ZonedDateTimeAssert_isEqualTo_errors_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isEqualTo_assertion(ZonedDateTime referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isEqualTo(referenceDate.toString());
+    // THEN
+    verify_that_isEqualTo_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isEqualTo_assertion_error_message() {
+    try {
+      assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC)).isEqualTo(ZonedDateTime.of(2012, 1, 1, 3, 3, 3, 0, UTC).toString());
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("expected:<20[12-01-01T03:03:03]Z> but was:<20[00-01-05T03:00:05]Z>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isEqualTo((String) null);
+  }
+
+  private static void verify_that_isEqualTo_assertion_fails_and_throws_AssertionError(ZonedDateTime reference) {
+    try {
+      assertThat(reference).isEqualTo(reference.plusNanos(1).toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_Test.java
new file mode 100644
index 000000000..ca043c190
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_Test.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.time.ZoneId;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+
+/**
+ * Tests specific to {@link org.assertj.core.api.ZonedDateTimeAssert#isIn(ZonedDateTime...)} that can't be done
+ * in {@link org.assertj.core.api.AbstractAssert#isIn(Object...)} tests.
+ *
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public class ZonedDateTimeAssert_isIn_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Test
+  public void isIn_should_compare_datetimes_in_actual_timezone() {
+    ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, ZoneOffset.UTC);
+    ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
+    ZonedDateTime cestDateTime = ZonedDateTime.of(2013, 6, 10, 2, 0, 0, 0, cestTimeZone);
+    // cestDateTime and utcDateTime are equals in same timezone
+    assertThat(utcDateTime).isIn(cestDateTime, ZonedDateTime.now());
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_errors_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_errors_Test.java
new file mode 100644
index 000000000..a6e022f7d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_errors_Test.java
@@ -0,0 +1,78 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link ZonedDateTime} are already defined in assertj-core)
+ *
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class ZonedDateTimeAssert_isIn_errors_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isIn_assertion(ZonedDateTime referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isIn(referenceDate.toString(), referenceDate.plusNanos(1).toString());
+    // THEN
+    verify_that_isIn_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isIn_assertion_error_message() {
+    try {
+      assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC))
+          .isIn(ZonedDateTime.of(2012, 1, 1, 3, 3, 3, 0, UTC).toString());
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage(
+          "\nExpecting:\n <2000-01-05T03:00:05Z>\nto be in:\n <[2012-01-01T03:03:03Z]>\n");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dateTimes_as_string_array_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The given ZonedDateTime array should not be null");
+    assertThat(ZonedDateTime.now()).isIn((String[]) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTimes_as_string_array_parameter_is_empty() {
+    expectException(IllegalArgumentException.class, "The given ZonedDateTime array should not be empty");
+    assertThat(ZonedDateTime.now()).isIn(new String[0]);
+  }
+
+  private static void verify_that_isIn_assertion_fails_and_throws_AssertionError(ZonedDateTime reference) {
+    try {
+      assertThat(reference).isIn(reference.plusNanos(1).toString(), reference.plusNanos(2).toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotEqualTo_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotEqualTo_Test.java
new file mode 100644
index 000000000..a37db4e74
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotEqualTo_Test.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.time.ZoneId;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+
+/**
+ * Tests specific to {@link org.assertj.core.api.ZonedDateTimeAssert#isNotEqualTo(ZonedDateTime)} that can't be
+ * done in {@link org.assertj.core.api.AbstractAssert#isNotEqualTo(Object)} tests.
+ *
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public class ZonedDateTimeAssert_isNotEqualTo_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Test
+  public void isNotEqualTo_should_compare_datetimes_in_actual_timezone() {
+    ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 2, 0, 0, 0, ZoneOffset.UTC);
+    ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
+    ZonedDateTime cestDateTime = ZonedDateTime.of(2013, 6, 10, 2, 0, 0, 0, cestTimeZone);
+    // datetime are not equals because they are in different timezone
+    assertThat(utcDateTime).as("in UTC time zone").isNotEqualTo(cestDateTime);
+    assertThat(cestDateTime).as("in CEST time zone").isNotEqualTo(utcDateTime);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotEqualTo_errors_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotEqualTo_errors_Test.java
new file mode 100644
index 000000000..18999b1ce
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotEqualTo_errors_Test.java
@@ -0,0 +1,72 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link ZonedDateTime} are already defined in assertj-core)
+ *
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class ZonedDateTimeAssert_isNotEqualTo_errors_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isNotEqualTo_assertion(ZonedDateTime referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isNotEqualTo(referenceDate.plusNanos(1).toString());
+    // THEN
+    verify_that_isNotEqualTo_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isNotEqualTo_assertion_error_message() {
+    try {
+      ZonedDateTime date = ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC);
+      assertThat(date).isNotEqualTo(date.toString());
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n <2000-01-05T03:00:05Z>\nnot to be equal to:\n <2000-01-05T03:00:05Z>\n");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dateTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the ZonedDateTime to compare actual with should not be null");
+    assertThat(ZonedDateTime.now()).isNotEqualTo((String) null);
+  }
+
+  private static void verify_that_isNotEqualTo_assertion_fails_and_throws_AssertionError(ZonedDateTime reference) {
+    try {
+      assertThat(reference).isNotEqualTo(reference.toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_Test.java
new file mode 100644
index 000000000..d77cf2f98
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_Test.java
@@ -0,0 +1,40 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.time.ZoneId;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+
+/**
+ * Tests specific to {@link org.assertj.core.api.ZonedDateTimeAssert#isNotIn(ZonedDateTime...)} that can't be
+ * done in {@link org.assertj.core.api.AbstractAssert#isNotIn(Object...)} tests.
+ *
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+public class ZonedDateTimeAssert_isNotIn_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Test
+  public void isNotIn_should_compare_datetimes_in_actual_timezone() {
+    ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, ZoneOffset.UTC);
+    ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
+    ZonedDateTime cestDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, cestTimeZone);
+    // cestDateTime and utcDateTime are not equals in same timezone
+    assertThat(utcDateTime).isNotIn(cestDateTime, ZonedDateTime.now());
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java
new file mode 100644
index 000000000..521ca7389
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java
@@ -0,0 +1,81 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.zoneddatetime;
+
+import static java.time.ZoneOffset.UTC;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.ZonedDateTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link ZonedDateTime} are already defined in assertj-core)
+ *
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class ZonedDateTimeAssert_isNotIn_errors_Test extends ZonedDateTimeAssertBaseTest {
+
+  @Theory
+  public void test_isNotIn_assertion(ZonedDateTime referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isNotIn(referenceDate.plusNanos(1).toString(), referenceDate.plusNanos(2).toString());
+    // THEN
+    verify_that_isNotIn_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isNotIn_assertion_error_message() {
+    try {
+      assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC)).isNotIn(
+          ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC).toString(),
+          ZonedDateTime.of(2012, 1, 1, 3, 3, 3, 0, UTC).toString());
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage(
+          "\nExpecting:\n <2000-01-05T03:00:05Z>\nnot to be in:\n"
+              + " <[2000-01-05T03:00:05Z, 2012-01-01T03:03:03Z]>\n"
+      );
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dateTimes_as_string_array_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The given ZonedDateTime array should not be null");
+    assertThat(ZonedDateTime.now()).isNotIn((String[]) null);
+  }
+
+  @Test
+  public void should_fail_if_dateTimes_as_string_array_parameter_is_empty() {
+    expectException(IllegalArgumentException.class, "The given ZonedDateTime array should not be empty");
+    assertThat(ZonedDateTime.now()).isNotIn(new String[0]);
+  }
+
+  private static void verify_that_isNotIn_assertion_fails_and_throws_AssertionError(ZonedDateTime reference) {
+    try {
+      assertThat(reference).isNotIn(reference.toString(), reference.plusNanos(1).toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeAfterOrEqualsTo_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeAfterOrEqualsTo_create_Test.java
index fd3d2c128..d35e181fa 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeAfterOrEqualsTo_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeAfterOrEqualsTo_create_Test.java
@@ -41,6 +41,6 @@ public class ShouldBeAfterOrEqualsTo_create_Test {
   @Test
   public void should_create_error_message() {
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <2011-01-01T00:00:00>\nto be after or equals to:\n <2012-01-01T00:00:00>", message);
+    assertEquals("[Test] \nExpecting:\n  <2011-01-01T00:00:00>\nto be after or equals to:\n  <2012-01-01T00:00:00>", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeAfter_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeAfter_create_Test.java
index 3097308d1..490419853 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeAfter_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeAfter_create_Test.java
@@ -41,6 +41,6 @@ public class ShouldBeAfter_create_Test {
   @Test
   public void should_create_error_message() {
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <2011-01-01T00:00:00>\nto be strictly after:\n <2012-01-01T00:00:00>", message);
+    assertEquals("[Test] \nExpecting:\n  <2011-01-01T00:00:00>\nto be strictly after:\n  <2012-01-01T00:00:00>", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeBeforeOrEqualsTo_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeBeforeOrEqualsTo_create_Test.java
index 1618b039b..4f16049de 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeBeforeOrEqualsTo_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeBeforeOrEqualsTo_create_Test.java
@@ -41,6 +41,6 @@ public class ShouldBeBeforeOrEqualsTo_create_Test {
   @Test
   public void should_create_error_message() {
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <2011-01-01T00:00:00>\nto be before or equals to:\n <2012-01-01T00:00:00>", message);
+    assertEquals("[Test] \nExpecting:\n  <2011-01-01T00:00:00>\nto be before or equals to:\n  <2012-01-01T00:00:00>", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeBefore_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeBefore_create_Test.java
index c018c5d86..2ce552be4 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeBefore_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeBefore_create_Test.java
@@ -41,6 +41,6 @@ public class ShouldBeBefore_create_Test {
   @Test
   public void should_create_error_message() {
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <2011-01-01T00:00:00>\nto be strictly before:\n <2012-01-01T00:00:00>", message);
+    assertEquals("[Test] \nExpecting:\n  <2011-01-01T00:00:00>\nto be strictly before:\n  <2012-01-01T00:00:00>", message);
   }
 }
