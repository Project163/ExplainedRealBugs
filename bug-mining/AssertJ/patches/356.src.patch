diff --git a/src/main/java/org/assertj/core/api/AbstractFileAssert.java b/src/main/java/org/assertj/core/api/AbstractFileAssert.java
index c509a3cfe..3beee2b3e 100644
--- a/src/main/java/org/assertj/core/api/AbstractFileAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractFileAssert.java
@@ -939,6 +939,94 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
     return myself;
   }
 
+  /**
+   * Verify that the actual {@code File} directory or any of its subdirectories (recursively) contains at least one file
+   * matching the given {@code String} interpreted as a path matcher (as per {@link FileSystem#getPathMatcher(String)}).
+   * <p>
+   * That methods performs the same assertion as {@link #isDirectoryContaining(String syntaxAndPattern)}  but recursively.
+   * <p>
+   * Note that the actual {@link File} must exist and be a directory.
+   * <p>
+   * Examples given the following directory structure:
+   * <pre><code class="text"> root
+   * |—— foo
+   * |    |—— foobar
+   * |         |—— foo-file-1.ext
+   * |—— foo-file-2.ext</code>
+   * </pre>
+   *
+   * <pre><code class="java"> File root = new File("root");
+   *
+   * // The following assertions succeed:
+   * assertThat(root).isDirectoryRecursivelyContaining("glob:**foo")
+   *                 .isDirectoryRecursivelyContaining("glob:**ooba*")
+   *                 .isDirectoryRecursivelyContaining("glob:**file-1.ext")
+   *                 .isDirectoryRecursivelyContaining("regex:.*file-2.*")
+   *                 .isDirectoryRecursivelyContaining("glob:**.{ext,dummy}");
+   *
+   * // The following assertions fail:
+   * assertThat(root).isDirectoryRecursivelyContaining("glob:**fooba");
+   * assertThat(root).isDirectoryRecursivelyContaining("glob:**.bin");
+   * assertThat(root).isDirectoryRecursivelyContaining("glob:**.{java,class}"); </code></pre>
+   *
+   * @param syntaxAndPattern the syntax and pattern for {@link java.nio.file.PathMatcher} as described in {@link FileSystem#getPathMatcher(String)}.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given syntaxAndPattern is {@code null}.
+   * @throws AssertionError       if actual is {@code null}.
+   * @throws AssertionError       if actual does not exist.
+   * @throws AssertionError       if actual is not a directory.
+   * @throws AssertionError       if actual does not contain recursively any files matching the given path matcher.
+   * @see FileSystem#getPathMatcher(String)
+   * @since 3.16.0
+   */
+  public SELF isDirectoryRecursivelyContaining(String syntaxAndPattern) {
+    files.assertIsDirectoryRecursivelyContaining(info, actual, syntaxAndPattern);
+    return myself;
+  }
+
+  /**
+   * Verify that the actual {@code File} directory or any of its subdirectories (recursively) contains at least one file
+   * matching the given {@code Predicate<File>}.
+   * <p>
+   * That methods performs the same assertion as {@link #isDirectoryContaining(Predicate filter)}  but recursively.
+   * <p>
+   * Note that the actual {@link File} must exist and be a directory.
+   * <p>
+   * Examples given the following directory structure:
+   * <pre><code class="text"> root
+   * |—— foo
+   * |    |—— foobar
+   * |         |—— foo-file-1.ext
+   * |—— foo-file-2.ext</code>
+   * </pre>
+   *
+   * Here are some assertions examples:
+   * <pre><code class="java"> File root = new File("root");
+   *
+   * // The following assertions succeed:
+   * assertThat(root).isDirectoryRecursivelyContaining(file -&gt; file.getName().startsWith("foo-file-1"))
+   *                 .isDirectoryRecursivelyContaining(file -&gt; file.getName().endsWith("file-2.ext"))
+   *                 .isDirectoryRecursivelyContaining(file -&gt; file.getName().equals("foo"))
+   *                 .isDirectoryRecursivelyContaining(file -&gt; file.getParentFile().getName().equals("foo"))
+   *
+   * // The following assertions fail:
+   * assertThat(root).isDirectoryRecursivelyContaining(file -&gt; file.getName().equals("foo-file-1"))
+   * assertThat(root).isDirectoryRecursivelyContaining(file -&gt; file.getName().equals("foo/foobar")); </code></pre>
+   *
+   * @param filter the filter for files located inside {@code actual}'s directory.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given filter is {@code null}.
+   * @throws AssertionError       if actual is {@code null}.
+   * @throws AssertionError       if actual does not exist.
+   * @throws AssertionError       if actual is not a directory.
+   * @throws AssertionError       if actual does not contain recursively any files matching the given predicate.
+   * @since 3.16.0
+   */
+  public SELF isDirectoryRecursivelyContaining(Predicate<File> filter) {
+    files.assertIsDirectoryRecursivelyContaining(info, actual, filter);
+    return myself;
+  }
+
   /**
    * Verify that the actual {@code File} is a directory that does not contain any files matching the given {@code Predicate<File>}.
    * <p>
diff --git a/src/main/java/org/assertj/core/error/ShouldContainRecursively.java b/src/main/java/org/assertj/core/error/ShouldContainRecursively.java
new file mode 100644
index 000000000..26e212ef6
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldContainRecursively.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.util.Strings.escapePercent;
+
+import java.io.File;
+import java.util.List;
+
+/**
+ * Creates an error message indicating that an assertion that verifies a group of elements contains recursively a given set of values failed.
+ *
+ * @author David Haccoun
+ * @author Joel Costigliola
+ */
+public class ShouldContainRecursively extends BasicErrorMessageFactory {
+
+  public static ErrorMessageFactory directoryShouldContainRecursively(File actual, List<String> directoryContent,
+                                                                      String filterDescription) {
+    return new ShouldContainRecursively(actual, directoryContent, filterDescription);
+  }
+
+  private ShouldContainRecursively(Object actual, List<String> directoryContent, String filterDescription) {
+    // not passing directoryContent and filterDescription as parameter to avoid AssertJ default String formatting
+    super("%nExpecting directory or any of its subdirectories(recursively):%n" +
+          "  <%s>%n" +
+          "to contain at least one file matching " + escapePercent(filterDescription) + " but there was none.%n" +
+          "The directory content was:%n  " + escapePercent(directoryContent.toString()),
+          actual);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/internal/Files.java b/src/main/java/org/assertj/core/internal/Files.java
index 515ad36e8..6926f736b 100644
--- a/src/main/java/org/assertj/core/internal/Files.java
+++ b/src/main/java/org/assertj/core/internal/Files.java
@@ -14,6 +14,7 @@ package org.assertj.core.internal;
 
 import static java.lang.String.format;
 import static java.nio.file.Files.readAllBytes;
+import static java.util.Comparator.comparing;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toList;
 import static org.assertj.core.error.ShouldBeAbsolutePath.shouldBeAbsolutePath;
@@ -25,6 +26,7 @@ import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
 import static org.assertj.core.error.ShouldBeRelativePath.shouldBeRelativePath;
 import static org.assertj.core.error.ShouldBeWritable.shouldBeWritable;
 import static org.assertj.core.error.ShouldContain.directoryShouldContain;
+import static org.assertj.core.error.ShouldContainRecursively.directoryShouldContainRecursively;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldHaveBinaryContent.shouldHaveBinaryContent;
 import static org.assertj.core.error.ShouldHaveContent.shouldHaveContent;
@@ -48,11 +50,13 @@ import java.io.InputStream;
 import java.io.UncheckedIOException;
 import java.nio.charset.Charset;
 import java.nio.charset.MalformedInputException;
+import java.nio.file.Path;
 import java.nio.file.PathMatcher;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.List;
 import java.util.function.Predicate;
+import java.util.stream.Stream;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.util.VisibleForTesting;
@@ -475,9 +479,21 @@ public class Files {
   }
 
   public void assertIsDirectoryContaining(AssertionInfo info, File actual, String syntaxAndPattern) {
-    requireNonNull(syntaxAndPattern, "The syntax and pattern to build PathMatcher should not be null");
-    Predicate<File> pathMatcher = pathMatcher(info, actual, syntaxAndPattern);
-    assertIsDirectoryContaining(info, actual, pathMatcher, format("the '%s' pattern", syntaxAndPattern));
+    requireNonNull(syntaxAndPattern, "The syntax and pattern should not be null");
+    Predicate<File> fileMatcher = fileMatcher(info, actual, syntaxAndPattern);
+    assertIsDirectoryContaining(info, actual, fileMatcher, format("the '%s' pattern", syntaxAndPattern));
+  }
+
+  public void assertIsDirectoryRecursivelyContaining(AssertionInfo info, File actual, String syntaxAndPattern) {
+    requireNonNull(syntaxAndPattern, "The syntax and pattern should not be null");
+    Predicate<File> fileMatcher = fileMatcher(info, actual, syntaxAndPattern);
+    assertIsDirectoryRecursivelyContaining(info, actual, fileMatcher,
+                                           format("the '%s' pattern", syntaxAndPattern));
+  }
+
+  public void assertIsDirectoryRecursivelyContaining(AssertionInfo info, File actual, Predicate<File> filter) {
+    requireNonNull(filter, "The files filter should not be null");
+    assertIsDirectoryRecursivelyContaining(info, actual, filter, "the given filter");
   }
 
   public void assertIsDirectoryNotContaining(AssertionInfo info, File actual, Predicate<File> filter) {
@@ -486,9 +502,9 @@ public class Files {
   }
 
   public void assertIsDirectoryNotContaining(AssertionInfo info, File actual, String syntaxAndPattern) {
-    requireNonNull(syntaxAndPattern, "The syntax and pattern to build PathMatcher should not be null");
-    Predicate<File> pathMatcher = pathMatcher(info, actual, syntaxAndPattern);
-    assertIsDirectoryNotContaining(info, actual, pathMatcher, format("the '%s' pattern", syntaxAndPattern));
+    requireNonNull(syntaxAndPattern, "The syntax and pattern should not be null");
+    Predicate<File> fileMatcher = fileMatcher(info, actual, syntaxAndPattern);
+    assertIsDirectoryNotContaining(info, actual, fileMatcher, format("the '%s' pattern", syntaxAndPattern));
   }
 
   public static List<String> toFileNames(List<File> files) {
@@ -497,6 +513,12 @@ public class Files {
                 .collect(toList());
   }
 
+  public static List<String> toAbsolutePaths(List<File> files) {
+    return files.stream()
+                .map(File::getAbsolutePath)
+                .collect(toList());
+  }
+
   // non public section
 
   private List<File> filterDirectory(AssertionInfo info, File actual, Predicate<File> filter) {
@@ -529,7 +551,46 @@ public class Files {
     return toFileNames(directoryContent(info, actual));
   }
 
-  private Predicate<File> pathMatcher(AssertionInfo info, File actual, String syntaxAndPattern) {
+  // BEGIN - recursively assertion private methods
+  private boolean isDirectoryRecursivelyContaining(AssertionInfo info, File actual, Predicate<File> filter) {
+    assertIsDirectory(info, actual);
+    try (Stream<File> fileStream = createRecursiveStreamOfFile(actual)) {
+      return fileStream.anyMatch(filter);
+    }
+  }
+
+  private List<File> directoryRecursiveContent(File actual) {
+    try (Stream<File> fileStream = createRecursiveStreamOfFile(actual)) {
+      return fileStream.sorted(comparing(File::getAbsolutePath))
+                       .collect(toList());
+    }
+  }
+
+  private Stream<File> createRecursiveStreamOfFile(File directory) {
+    Path path = directory.toPath();
+    try {
+      return java.nio.file.Files.walk(path)
+                                .filter(p -> !p.equals(path))
+                                .map(Path::toFile);
+    } catch (IOException e) {
+      throw new UncheckedIOException(format("Unable to walk recursively the directory :<%s>", path), e);
+    }
+  }
+
+  private void assertIsDirectoryRecursivelyContaining(AssertionInfo info, File actual, Predicate<File> filter,
+                                                      String filterPresentation) {
+    if (!isDirectoryRecursivelyContaining(info, actual, filter)) {
+      throw failures.failure(info, directoryShouldContainRecursively(actual, directoryRecursiveContentDescription(actual),
+                                                                     filterPresentation));
+    }
+  }
+
+  private List<String> directoryRecursiveContentDescription(File actual) {
+    return toAbsolutePaths(directoryRecursiveContent(actual));
+  }
+  // END - recursively assertion private methods
+
+  private static Predicate<File> fileMatcher(AssertionInfo info, File actual, String syntaxAndPattern) {
     assertNotNull(info, actual);
     PathMatcher pathMatcher = actual.toPath().getFileSystem().getPathMatcher(syntaxAndPattern);
     return file -> pathMatcher.matches(file.toPath());
diff --git a/src/main/java/org/assertj/core/internal/Paths.java b/src/main/java/org/assertj/core/internal/Paths.java
index 72ad563bb..863355059 100644
--- a/src/main/java/org/assertj/core/internal/Paths.java
+++ b/src/main/java/org/assertj/core/internal/Paths.java
@@ -366,7 +366,7 @@ public class Paths {
   }
 
   public void assertIsDirectoryContaining(AssertionInfo info, Path actual, String syntaxAndPattern) {
-    requireNonNull(syntaxAndPattern, "The syntax and pattern to build PathMatcher should not be null");
+    requireNonNull(syntaxAndPattern, "The syntax and pattern should not be null");
     PathMatcher pathMatcher = pathMatcher(info, actual, syntaxAndPattern);
     assertIsDirectoryContaining(info, actual, pathMatcher::matches, format("the '%s' pattern", syntaxAndPattern));
   }
@@ -377,7 +377,7 @@ public class Paths {
   }
 
   public void assertIsDirectoryNotContaining(AssertionInfo info, Path actual, String syntaxAndPattern) {
-    requireNonNull(syntaxAndPattern, "The syntax and pattern to build PathMatcher should not be null");
+    requireNonNull(syntaxAndPattern, "The syntax and pattern should not be null");
     PathMatcher pathMatcher = pathMatcher(info, actual, syntaxAndPattern);
     assertIsDirectoryNotContaining(info, actual, pathMatcher::matches, format("the '%s' pattern", syntaxAndPattern));
   }
diff --git a/src/test/java/org/assertj/core/api/file/FileAssert_isDirectoryRecursivelyContaining_Predicate_Test.java b/src/test/java/org/assertj/core/api/file/FileAssert_isDirectoryRecursivelyContaining_Predicate_Test.java
new file mode 100644
index 000000000..10d640f65
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/file/FileAssert_isDirectoryRecursivelyContaining_Predicate_Test.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.file;
+
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.util.function.Predicate;
+
+import org.assertj.core.api.FileAssert;
+import org.assertj.core.api.FileAssertBaseTest;
+
+/**
+ * Tests for <code>{@link FileAssert#isDirectoryRecursivelyContaining(Predicate)}</code>
+ *
+ * @author David Haccoun
+ */
+public class FileAssert_isDirectoryRecursivelyContaining_Predicate_Test extends FileAssertBaseTest {
+
+  private final Predicate<File> anyFilter = path -> true;
+
+  @Override
+  protected FileAssert invoke_api_method() {
+    return assertions.isDirectoryRecursivelyContaining(anyFilter);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(files).assertIsDirectoryRecursivelyContaining(getInfo(assertions), getActual(assertions), anyFilter);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/file/FileAssert_isDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/api/file/FileAssert_isDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
new file mode 100644
index 000000000..be2d4aec4
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/file/FileAssert_isDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.file;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.FileAssert;
+import org.assertj.core.api.FileAssertBaseTest;
+
+/**
+ * Tests for <code>{@link FileAssert#isDirectoryRecursivelyContaining(String)}</code>
+ *
+ * @author David Haccoun
+ */
+public class FileAssert_isDirectoryRecursivelyContaining_SyntaxAndPattern_Test extends FileAssertBaseTest {
+
+  private final String syntaxAndPattern = "glob:*.java";
+
+  @Override
+  protected FileAssert invoke_api_method() {
+    return assertions.isDirectoryRecursivelyContaining(syntaxAndPattern);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(files).assertIsDirectoryRecursivelyContaining(getInfo(assertions), getActual(assertions), syntaxAndPattern);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/FilesBaseTest.java b/src/test/java/org/assertj/core/internal/FilesBaseTest.java
index f2777d94f..9f0c3fdbc 100644
--- a/src/test/java/org/assertj/core/internal/FilesBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/FilesBaseTest.java
@@ -25,6 +25,7 @@ import java.io.File;
 import java.io.FileFilter;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.UncheckedIOException;
 import java.nio.file.FileSystem;
 import java.nio.file.Path;
 import java.util.LinkedHashMap;
@@ -106,7 +107,7 @@ public class FilesBaseTest {
     try {
       given(nioFilesWrapper.newInputStream(path.toPath())).willReturn(new ByteArrayInputStream(new byte[0]));
     } catch (IOException e) {
-      assertThat(e).describedAs("Should not happen").isNull();
+      throw new UncheckedIOException("error during nioFilesWrapper mock recording", e);
     }
     return path;
   }
diff --git a/src/test/java/org/assertj/core/internal/FilesSimpleBaseTest.java b/src/test/java/org/assertj/core/internal/FilesSimpleBaseTest.java
new file mode 100644
index 000000000..2c51a69d4
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/FilesSimpleBaseTest.java
@@ -0,0 +1,79 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static java.util.Arrays.stream;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.mockito.Mockito.spy;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.nio.file.Path;
+
+import org.assertj.core.api.AssertionInfo;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.io.TempDir;
+
+/**
+ * New base class for testing <code>{@link Files}</code>.
+ * <p>That is a lighter alternative to {@link FilesBaseTest}.<br>
+ * Contrary to {@link FilesBaseTest}, {@link FilesSimpleBaseTest}  doesn't try to abstract and mock the filesystem API.
+ * <br>
+ * Please update that javadoc if the philosophy of that simple base test class evolves
+ *
+ * @author David Haccoun
+ */
+public abstract class FilesSimpleBaseTest {
+
+  protected static final AssertionInfo INFO = someInfo();
+
+  protected Path tempDir;
+  protected File tempDirAsFile;
+
+  protected Files files;
+  protected Failures failures;
+
+  @BeforeEach
+  public void setUp(@TempDir Path tempDir) {
+    this.tempDir = tempDir;
+    tempDirAsFile = tempDir.toFile();
+    failures = spy(new Failures());
+    files = new Files();
+    files.failures = failures;
+  }
+
+  public Path createDirectory(Path parent, String name, String... files) {
+    Path directory = parent.resolve(name);
+    try {
+      java.nio.file.Files.createDirectory(directory);
+      stream(files).forEach(f -> createFile(directory, f));
+    } catch (IOException e) {
+      throw new UncheckedIOException("error during fixture directory creation", e);
+    }
+    return directory;
+  }
+
+  public Path createDirectoryWithDefaultParent(String name, String... files) {
+    return createDirectory(tempDir, name, files);
+  }
+
+  private void createFile(Path directory, String f) {
+    try {
+      java.nio.file.Files.createFile(directory.resolve(f));
+    } catch (IOException e) {
+      throw new UncheckedIOException("error during fixture file creation", e);
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
index 8e5e3c3e4..70edfd346 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
@@ -100,7 +100,7 @@ public class Files_assertIsDirectoryContaining_SyntaxAndPattern_Test extends Fil
     String pathMatcherPattern = null;
     // THEN
     assertThatNullPointerException().isThrownBy(() -> files.assertIsDirectoryContaining(INFO, null, pathMatcherPattern))
-                                    .withMessage("The syntax and pattern to build PathMatcher should not be null");
+                                    .withMessage("The syntax and pattern should not be null");
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
index f165cf3f8..d83b87446 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
@@ -75,7 +75,7 @@ public class Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends
     String pathMatcherPattern = null;
     // THEN
     assertThatNullPointerException().isThrownBy(() -> files.assertIsDirectoryNotContaining(INFO, null, pathMatcherPattern))
-                                    .withMessage("The syntax and pattern to build PathMatcher should not be null");
+                                    .withMessage("The syntax and pattern should not be null");
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_Predicate_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_Predicate_Test.java
new file mode 100644
index 000000000..8a1e4bee0
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_Predicate_Test.java
@@ -0,0 +1,134 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal.files;
+
+import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
+import static org.assertj.core.error.ShouldContainRecursively.directoryShouldContainRecursively;
+import static org.assertj.core.internal.Files.toAbsolutePaths;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Lists.emptyList;
+import static org.assertj.core.util.Lists.list;
+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Files;
+import org.assertj.core.internal.FilesSimpleBaseTest;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests for <code>{@link Files#assertIsDirectoryRecursivelyContaining(AssertionInfo, File, java.util.function.Predicate)}</code>
+ *
+ * @author David Haccoun
+ */
+public class Files_assertIsDirectoryRecursivelyContaining_Predicate_Test extends FilesSimpleBaseTest {
+
+  private static final String THE_GIVEN_FILTER_DESCRIPTION = "the given filter";
+
+  @TestInstance(PER_CLASS)
+  @Nested
+  class Actual_matches {
+
+    @BeforeEach
+    void createFixturePaths() {
+      // @format:off
+      // The layout:
+      //  root
+      //  |—— foo
+      //  |    |—— foobar
+      //  |         |—— foobar1.data
+      //  |         |—— foobar2.json
+      //  |—— foo2.data
+      // @format:on
+      Path rootDir = createDirectoryWithDefaultParent("root", "foo2.data");
+      Path fooDir = createDirectory(rootDir, "foo");
+      createDirectory(fooDir, "foobar", "foobar1.data", "foobar2.json");
+    }
+
+    @ParameterizedTest
+    @MethodSource("foundMatchProvider")
+    void should_pass_if_actual_contains_any_files_matching_the_given_predicate(Predicate<File> predicate) {
+      files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, predicate);
+    }
+
+    private Stream<Predicate<File>> foundMatchProvider() {
+      return Stream.of(f -> f.getName().contains("bar2"), // one match
+                       f -> f.getName().equals("foobar2.json"), // one match
+                       f -> f.getName().contains("foobar"), // some matches
+                       f -> f.getParentFile().getName().equals("foobar"), // some matches
+                       f -> f.getName().contains("foo")); // all matches
+    }
+
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_exist() {
+    // GIVEN
+    File notExistingFile = new File("foo/bar/doesnt-exist-file");
+    Predicate<File> anyPredicate = f -> true;
+    // WHEN
+    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, notExistingFile, anyPredicate));
+    // THEN
+    verify(failures).failure(INFO, shouldBeDirectory(notExistingFile));
+  }
+
+  @Test
+  void should_fail_if_actual_exists_but_is_not_a_directory() throws IOException {
+    // GIVEN
+    File existingFile = java.nio.file.Files.createFile(tempDir.resolve("FooFile.txt")).toFile();
+    Predicate<File> anyPredicate = f -> true;
+    // WHEN
+    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, existingFile, anyPredicate));
+    // THEN
+    verify(failures).failure(INFO, shouldBeDirectory(existingFile));
+  }
+
+  @Test
+  void should_fail_if_actual_is_empty() {
+    // GIVEN
+    Predicate<File> alwaysTrue = f -> true;
+    // WHEN
+    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, alwaysTrue));
+    // THEN
+    verify(failures).failure(INFO, directoryShouldContainRecursively(tempDirAsFile, emptyList(), THE_GIVEN_FILTER_DESCRIPTION));
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_any_files_matching_the_given_pathMatcherPattern() {
+    // GIVEN
+    Path fooDir = createDirectory(tempDir, "foo", "foo2.data");
+    createDirectory(fooDir, "foo3");
+    // WHEN
+    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile,
+                                                                            f -> f.getName().equals("foo2")));
+    // THEN
+    verify(failures).failure(INFO, directoryShouldContainRecursively(tempDirAsFile,
+                                                                     toAbsolutePaths(list(new File(tempDirAsFile, "foo"),
+                                                                                          new File(tempDirAsFile,
+                                                                                                   "foo/foo2.data"),
+                                                                                          new File(tempDirAsFile, "foo/foo3"))),
+                                                                     THE_GIVEN_FILTER_DESCRIPTION));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
new file mode 100644
index 000000000..0d9defdaf
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
@@ -0,0 +1,140 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal.files;
+
+import static java.lang.String.format;
+import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
+import static org.assertj.core.error.ShouldContainRecursively.directoryShouldContainRecursively;
+import static org.assertj.core.internal.Files.toAbsolutePaths;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Lists.emptyList;
+import static org.assertj.core.util.Lists.list;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Files;
+import org.assertj.core.internal.FilesSimpleBaseTest;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+/**
+ * Tests for <code>{@link Files#assertIsDirectoryRecursivelyContaining(AssertionInfo, File, String)}</code>
+ *
+ * @author David Haccoun
+ */
+public class Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test extends FilesSimpleBaseTest {
+
+  private static final String TXT_EXTENSION_PATTERN = "regex:.+\\.txt";
+  private static final String TXT_EXTENSION_PATTERN_DESCRIPTION = format("the '%s' pattern",
+                                                                         TXT_EXTENSION_PATTERN);
+
+  @ParameterizedTest
+  @ValueSource(strings = { "regex:.+oo2\\.data", "regex:.+\\.json", "regex:.+bar2\\.json" })
+  void should_pass_if_actual_contains_one_file_matching_the_given_pathMatcherPattern(String pattern) {
+    // GIVEN
+    createDefaultFixturePaths();
+    // WHEN-THEN
+    files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, pattern);
+  }
+
+  @ParameterizedTest
+  @ValueSource(strings = { "regex:.+\\.data", "regex:.+foobar.*", "regex:.+root.+foo.*" })
+  void should_pass_if_actual_contains_some_files_matching_the_given_pathMatcherPattern(String pattern) {
+    // GIVEN
+    createDefaultFixturePaths();
+    // WHEN-THEN
+    files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, pattern);
+  }
+
+  private void createDefaultFixturePaths() {
+    // @format:off
+    // The layout :
+    // root
+    // |—— foo
+    // |    |—— foobar
+    // |         |—— foobar1.data
+    // |         |—— foobar2.json
+    // |—— foo2.data
+    // @format:on
+    Path rootDir = createDirectoryWithDefaultParent("root", "foo2.data");
+    Path fooDir = createDirectory(rootDir, "foo");
+    createDirectory(fooDir, "foobar", "foobar1.data", "foobar2.json");
+  }
+
+  @Test
+  void should_pass_if_all_actual_files_matching_the_given_pathMatcherPattern() {
+    // GIVEN
+    Path fooDir = createDirectory(tempDir, "foo", "foo2.data");
+    createDirectory(fooDir, "foo3");
+    // WHEN-THEN
+    files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, "regex:.*foo.*|.*tmp");
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_exist() {
+    // GIVEN
+    File notExistingFile = new File("foo/bar/doesnt-exist-file");
+    // WHEN
+    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, notExistingFile,
+                                                                            TXT_EXTENSION_PATTERN));
+    // THEN
+    verify(failures).failure(INFO, shouldBeDirectory(notExistingFile));
+  }
+
+  @Test
+  void should_fail_if_actual_exists_but_is_not_a_directory() throws IOException {
+    // GIVEN
+    File existingFile = java.nio.file.Files.createFile(tempDir.resolve("FooFile.txt")).toFile();
+    // WHEN
+    expectAssertionError(
+                         () -> files.assertIsDirectoryRecursivelyContaining(INFO, existingFile, TXT_EXTENSION_PATTERN));
+    // THEN
+    verify(failures).failure(INFO, shouldBeDirectory(existingFile));
+  }
+
+  @Test
+  void should_fail_if_actual_is_empty() {
+    // WHEN
+    expectAssertionError(
+                         () -> files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, TXT_EXTENSION_PATTERN));
+    // THEN
+    verify(failures)
+                    .failure(INFO,
+                             directoryShouldContainRecursively(tempDirAsFile, emptyList(), TXT_EXTENSION_PATTERN_DESCRIPTION));
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_any_files_matching_the_given_pathMatcherPattern() {
+    // GIVEN
+    Path fooDir = createDirectory(tempDir, "foo", "foo2.data");
+    createDirectory(fooDir, "foo3");
+    // WHEN
+    expectAssertionError(
+                         () -> files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, TXT_EXTENSION_PATTERN));
+    // THEN
+    verify(failures)
+                    .failure(INFO,
+                             directoryShouldContainRecursively(tempDirAsFile, toAbsolutePaths(list(new File(tempDirAsFile, "foo"),
+                                                                                                   new File(tempDirAsFile,
+                                                                                                            "foo/foo2.data"),
+                                                                                                   new File(tempDirAsFile,
+                                                                                                            "foo/foo3"))),
+                                                               TXT_EXTENSION_PATTERN_DESCRIPTION));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
index d873a652f..eb57a3bd6 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
@@ -95,7 +95,7 @@ public class Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test extends Moc
     String filter = null;
     // THEN
     assertThatNullPointerException().isThrownBy(() -> paths.assertIsDirectoryContaining(INFO, null, filter))
-                                    .withMessage("The syntax and pattern to build PathMatcher should not be null");
+                                    .withMessage("The syntax and pattern should not be null");
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
index f0f27e822..e1c8b29ba 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
@@ -77,7 +77,7 @@ public class Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends
     String pattern = null;
     // THEN
     assertThatNullPointerException().isThrownBy(() -> paths.assertIsDirectoryNotContaining(INFO, null, pattern))
-                                    .withMessage("The syntax and pattern to build PathMatcher should not be null");
+                                    .withMessage("The syntax and pattern should not be null");
   }
 
   @Test
