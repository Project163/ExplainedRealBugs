diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 8a5b42ec6..3d5e5aa03 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -31,6 +31,7 @@ import org.assertj.core.api.filter.FilterOperator;
 import org.assertj.core.api.filter.Filters;
 import org.assertj.core.api.iterable.Extractor;
 import org.assertj.core.condition.Not;
+import org.assertj.core.description.Description;
 import org.assertj.core.groups.FieldsOrPropertiesExtractor;
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.CommonErrors;
@@ -1347,4 +1348,171 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
     return (S) new ListAssert<>(newArrayList(filteredIterable));
   }
 
+  // override methods to avoid compilation error when chaining an AbstractAssert method with a AbstractIterableAssert
+  // one on raw types.
+
+  @Override
+  public S as(String description, Object... args) {
+    return super.as(description, args);
+  }
+
+  @Override
+  public S as(Description description) {
+    return super.as(description);
+  }
+
+  @Override
+  public S describedAs(Description description) {
+    return super.describedAs(description);
+  }
+
+  @Override
+  public S describedAs(String description, Object... args) {
+    return super.describedAs(description, args);
+  }
+
+  @Override
+  public S doesNotHave(Condition<? super A> condition) {
+    return super.doesNotHave(condition);
+  }
+
+  @Override
+  public S doesNotHaveSameClassAs(Object other) {
+    return super.doesNotHaveSameClassAs(other);
+  }
+
+  @Override
+  public S has(Condition<? super A> condition) {
+    return super.has(condition);
+  }
+
+  @Override
+  public S hasSameClassAs(Object other) {
+    return super.hasSameClassAs(other);
+  }
+
+  @Override
+  public S hasToString(String expectedToString) {
+    return super.hasToString(expectedToString);
+  }
+
+  @Override
+  public S is(Condition<? super A> condition) {
+    return super.is(condition);
+  }
+
+  @Override
+  public S isEqualTo(Object expected) {
+    return super.isEqualTo(expected);
+  }
+
+  @Override
+  public S isExactlyInstanceOf(Class<?> type) {
+    return super.isExactlyInstanceOf(type);
+  }
+
+  @Override
+  public S isIn(Iterable<?> values) {
+    return super.isIn(values);
+  }
+
+  @Override
+  public S isIn(Object... values) {
+    return super.isIn(values);
+  }
+
+  @Override
+  public S isInstanceOf(Class<?> type) {
+    return super.isInstanceOf(type);
+  }
+
+  @Override
+  public S isInstanceOfAny(Class<?>... types) {
+    return super.isInstanceOfAny(types);
+  }
+
+  @Override
+  public S isNot(Condition<? super A> condition) {
+    return super.isNot(condition);
+  }
+
+  @Override
+  public S isNotEqualTo(Object other) {
+    return super.isNotEqualTo(other);
+  }
+
+  @Override
+  public S isNotExactlyInstanceOf(Class<?> type) {
+    return super.isNotExactlyInstanceOf(type);
+  }
+
+  @Override
+  public S isNotIn(Iterable<?> values) {
+    return super.isNotIn(values);
+  }
+
+  @Override
+  public S isNotIn(Object... values) {
+    return super.isNotIn(values);
+  }
+
+  @Override
+  public S isNotInstanceOf(Class<?> type) {
+    return super.isNotInstanceOf(type);
+  }
+
+  @Override
+  public S isNotInstanceOfAny(Class<?>... types) {
+    return super.isNotInstanceOfAny(types);
+  }
+
+  @Override
+  public S isNotOfAnyClassIn(Class<?>... types) {
+    return super.isNotOfAnyClassIn(types);
+  }
+
+  @Override
+  public S isNotNull() {
+    return super.isNotNull();
+  }
+
+  @Override
+  public S isNotSameAs(Object other) {
+    return super.isNotSameAs(other);
+  }
+
+  @Override
+  public S isOfAnyClassIn(Class<?>... types) {
+    return super.isOfAnyClassIn(types);
+  }
+
+  @Override
+  public S isSameAs(Object expected) {
+    return super.isSameAs(expected);
+  }
+
+  @Override
+  public S overridingErrorMessage(String newErrorMessage, Object... args) {
+    return super.overridingErrorMessage(newErrorMessage, args);
+  }
+
+  @Override
+  public S usingDefaultComparator() {
+    return super.usingDefaultComparator();
+  }
+
+  @Override
+  public S usingComparator(Comparator<? super A> customComparator) {
+    return super.usingComparator(customComparator);
+  }
+
+  @Override
+  public S withFailMessage(String newErrorMessage, Object... args) {
+    return super.withFailMessage(newErrorMessage, args);
+  }
+
+  @Override
+  public S withThreadDumpOnError() {
+    return super.withThreadDumpOnError();
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/AbstractListAssert.java b/src/main/java/org/assertj/core/api/AbstractListAssert.java
index dfcbb61de..3df1cf51b 100644
--- a/src/main/java/org/assertj/core/api/AbstractListAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractListAssert.java
@@ -16,10 +16,10 @@ import java.util.Comparator;
 import java.util.List;
 
 import org.assertj.core.data.Index;
+import org.assertj.core.description.Description;
 import org.assertj.core.internal.*;
 import org.assertj.core.util.VisibleForTesting;
 
-
 /**
  * Base class for all implementations of assertions for {@link List}s.
  * @param <S> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/1IZIRcY"
@@ -33,128 +33,298 @@ import org.assertj.core.util.VisibleForTesting;
  * @author Joel Costigliola
  * @author Mikhail Mazursky
  */
-public abstract class AbstractListAssert<S extends AbstractListAssert<S, A, T>, A extends List<? extends T>, T> extends AbstractIterableAssert<S, A, T> implements
-		IndexedObjectEnumerableAssert<S, T> {
-
-	@VisibleForTesting
-	Lists lists = Lists.instance();
-
-	protected AbstractListAssert(A actual, Class<?> selfType) {
-		super(actual, selfType);
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S contains(T value, Index index) {
-		lists.assertContains(info, actual, value, index);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S doesNotContain(T value, Index index) {
-		lists.assertDoesNotContain(info, actual, value, index);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual object at the given index in the actual group satisfies the given condition.
-	 * @param condition the given condition.
-	 * @param index the index where the object should be stored in the actual group.
-	 * @return this assertion object.
-	 * @throws AssertionError if the given {@code List} is {@code null} or empty.
-	 * @throws NullPointerException if the given {@code Index} is {@code null}.
-	 * @throws IndexOutOfBoundsException if the value of the given {@code Index} is equal to or greater than the size of the given
-	 *           {@code List}.
-	 * @throws NullPointerException if the given {@code Condition} is {@code null}.
-	 * @throws AssertionError if the value in the given {@code List} at the given index does not satisfy the given {@code Condition}
-	 *           .
-	 */
-	public S has(Condition<? super T> condition, Index index) {
-		lists.assertHas(info, actual, condition, index);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual object at the given index in the actual group satisfies the given condition.
-	 * @param condition the given condition.
-	 * @param index the index where the object should be stored in the actual group.
-	 * @return this assertion object.
-	 * @throws AssertionError if the given {@code List} is {@code null} or empty.
-	 * @throws NullPointerException if the given {@code Index} is {@code null}.
-	 * @throws IndexOutOfBoundsException if the value of the given {@code Index} is equal to or greater than the size of the given
-	 *           {@code List}.
-	 * @throws NullPointerException if the given {@code Condition} is {@code null}.
-	 * @throws AssertionError if the value in the given {@code List} at the given index does not satisfy the given {@code Condition}
-	 *           .
-	 */
-	public S is(Condition<? super T> condition, Index index) {
-		lists.assertIs(info, actual, condition, index);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual list is sorted into ascending order according to the natural ordering of its elements.
-	 * <p>
-	 * All list elements must implement the {@link Comparable} interface and must be mutually comparable (that is, e1.compareTo(e2)
-	 * must not throw a ClassCastException for any elements e1 and e2 in the list), examples :
-	 * <ul>
-	 * <li>a list composed of {"a1", "a2", "a3"} is ok because the element type (String) is Comparable</li>
-	 * <li>a list composed of Rectangle {r1, r2, r3} is <b>NOT ok</b> because Rectangle is not Comparable</li>
-	 * <li>a list composed of {True, "abc", False} is <b>NOT ok</b> because elements are not mutually comparable</li>
-	 * </ul>
-	 * Empty lists are considered sorted.</br> Unique element lists are considered sorted unless the element type is not Comparable.
-	 *
-	 * @return {@code this} assertion object.
-	 *
-	 * @throws AssertionError if the actual list is not sorted into ascending order according to the natural ordering of its
-	 *           elements.
-	 * @throws AssertionError if the actual list is <code>null</code>.
-	 * @throws AssertionError if the actual list element type does not implement {@link Comparable}.
-	 * @throws AssertionError if the actual list elements are not mutually {@link Comparable}.
-	 */
-	public S isSorted() {
-		lists.assertIsSorted(info, actual);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual list is sorted according to the given comparator.</br> Empty lists are considered sorted whatever
-	 * the comparator is.</br> One element lists are considered sorted if element is compatible with comparator.
-	 *
-	 * @param comparator the {@link Comparator} used to compare list elements
-	 *
-	 * @return {@code this} assertion object.
-	 *
-	 * @throws AssertionError if the actual list is not sorted according to the given comparator.
-	 * @throws AssertionError if the actual list is <code>null</code>.
-	 * @throws NullPointerException if the given comparator is <code>null</code>.
-	 * @throws AssertionError if the actual list elements are not mutually comparable according to given Comparator.
-	 */
-	public S isSortedAccordingTo(Comparator<? super T> comparator) {
-		lists.assertIsSortedAccordingToComparator(info, actual, comparator);
-		return myself;
-	}
-
-	@Override
-	public S usingElementComparator(Comparator<? super T> customComparator) {
-		super.usingElementComparator(customComparator);
-		lists = new Lists(new ComparatorBasedComparisonStrategy(customComparator));
-		return myself;
-	}
-
-    @Override
-	public S usingDefaultElementComparator() {
-		super.usingDefaultElementComparator();
-		lists = Lists.instance();
-		return myself;
-	}
-
-    // can't really honor basic assertion consistently with this comparisonStrategy
-    @Override
-    protected S usingComparisonStrategy(ComparisonStrategy comparisonStrategy) {
-        super.usingComparisonStrategy(comparisonStrategy);
-        lists = new Lists(comparisonStrategy);
-        return myself;
-    }
+public abstract class AbstractListAssert<S extends AbstractListAssert<S, A, T>, A extends List<? extends T>, T>
+    extends AbstractIterableAssert<S, A, T> implements
+    IndexedObjectEnumerableAssert<S, T> {
+
+  @VisibleForTesting
+  Lists lists = Lists.instance();
+
+  protected AbstractListAssert(A actual, Class<?> selfType) {
+    super(actual, selfType);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S contains(T value, Index index) {
+    lists.assertContains(info, actual, value, index);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S doesNotContain(T value, Index index) {
+    lists.assertDoesNotContain(info, actual, value, index);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual object at the given index in the actual group satisfies the given condition.
+   * @param condition the given condition.
+   * @param index the index where the object should be stored in the actual group.
+   * @return this assertion object.
+   * @throws AssertionError if the given {@code List} is {@code null} or empty.
+   * @throws NullPointerException if the given {@code Index} is {@code null}.
+   * @throws IndexOutOfBoundsException if the value of the given {@code Index} is equal to or greater than the size of the given
+   *           {@code List}.
+   * @throws NullPointerException if the given {@code Condition} is {@code null}.
+   * @throws AssertionError if the value in the given {@code List} at the given index does not satisfy the given {@code Condition}
+   *           .
+   */
+  public S has(Condition<? super T> condition, Index index) {
+    lists.assertHas(info, actual, condition, index);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual object at the given index in the actual group satisfies the given condition.
+   * @param condition the given condition.
+   * @param index the index where the object should be stored in the actual group.
+   * @return this assertion object.
+   * @throws AssertionError if the given {@code List} is {@code null} or empty.
+   * @throws NullPointerException if the given {@code Index} is {@code null}.
+   * @throws IndexOutOfBoundsException if the value of the given {@code Index} is equal to or greater than the size of the given
+   *           {@code List}.
+   * @throws NullPointerException if the given {@code Condition} is {@code null}.
+   * @throws AssertionError if the value in the given {@code List} at the given index does not satisfy the given {@code Condition}
+   *           .
+   */
+  public S is(Condition<? super T> condition, Index index) {
+    lists.assertIs(info, actual, condition, index);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual list is sorted into ascending order according to the natural ordering of its elements.
+   * <p>
+   * All list elements must implement the {@link Comparable} interface and must be mutually comparable (that is, e1.compareTo(e2)
+   * must not throw a ClassCastException for any elements e1 and e2 in the list), examples :
+   * <ul>
+   * <li>a list composed of {"a1", "a2", "a3"} is ok because the element type (String) is Comparable</li>
+   * <li>a list composed of Rectangle {r1, r2, r3} is <b>NOT ok</b> because Rectangle is not Comparable</li>
+   * <li>a list composed of {True, "abc", False} is <b>NOT ok</b> because elements are not mutually comparable</li>
+   * </ul>
+   * Empty lists are considered sorted.</br> Unique element lists are considered sorted unless the element type is not Comparable.
+   *
+   * @return {@code this} assertion object.
+   *
+   * @throws AssertionError if the actual list is not sorted into ascending order according to the natural ordering of its
+   *           elements.
+   * @throws AssertionError if the actual list is <code>null</code>.
+   * @throws AssertionError if the actual list element type does not implement {@link Comparable}.
+   * @throws AssertionError if the actual list elements are not mutually {@link Comparable}.
+   */
+  public S isSorted() {
+    lists.assertIsSorted(info, actual);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual list is sorted according to the given comparator.</br> Empty lists are considered sorted whatever
+   * the comparator is.</br> One element lists are considered sorted if element is compatible with comparator.
+   *
+   * @param comparator the {@link Comparator} used to compare list elements
+   *
+   * @return {@code this} assertion object.
+   *
+   * @throws AssertionError if the actual list is not sorted according to the given comparator.
+   * @throws AssertionError if the actual list is <code>null</code>.
+   * @throws NullPointerException if the given comparator is <code>null</code>.
+   * @throws AssertionError if the actual list elements are not mutually comparable according to given Comparator.
+   */
+  public S isSortedAccordingTo(Comparator<? super T> comparator) {
+    lists.assertIsSortedAccordingToComparator(info, actual, comparator);
+    return myself;
+  }
+
+  @Override
+  public S usingElementComparator(Comparator<? super T> customComparator) {
+    super.usingElementComparator(customComparator);
+    lists = new Lists(new ComparatorBasedComparisonStrategy(customComparator));
+    return myself;
+  }
+
+  @Override
+  public S usingDefaultElementComparator() {
+    super.usingDefaultElementComparator();
+    lists = Lists.instance();
+    return myself;
+  }
+
+  // can't really honor basic assertion consistently with this comparisonStrategy
+  @Override
+  protected S usingComparisonStrategy(ComparisonStrategy comparisonStrategy) {
+    super.usingComparisonStrategy(comparisonStrategy);
+    lists = new Lists(comparisonStrategy);
+    return myself;
+  }
+
+  // override methods to avoid compilation error when chaining an AbstractAssert method with a AbstractListAssert one on
+  // raw types :(
+
+  @Override
+  public S as(String description, Object... args) {
+    return super.as(description, args);
+  }
+
+  @Override
+  public S as(Description description) {
+    return super.as(description);
+  }
+
+  @Override
+  public S describedAs(Description description) {
+    return super.describedAs(description);
+  }
+
+  @Override
+  public S describedAs(String description, Object... args) {
+    return super.describedAs(description, args);
+  }
+
+  @Override
+  public S doesNotHave(Condition<? super A> condition) {
+    return super.doesNotHave(condition);
+  }
+
+  @Override
+  public S doesNotHaveSameClassAs(Object other) {
+    return super.doesNotHaveSameClassAs(other);
+  }
+
+  @Override
+  public S has(Condition<? super A> condition) {
+    return super.has(condition);
+  }
+
+  @Override
+  public S hasSameClassAs(Object other) {
+    return super.hasSameClassAs(other);
+  }
+
+  @Override
+  public S hasToString(String expectedToString) {
+    return super.hasToString(expectedToString);
+  }
+
+  @Override
+  public S is(Condition<? super A> condition) {
+    return super.is(condition);
+  }
+
+  @Override
+  public S isEqualTo(Object expected) {
+    return super.isEqualTo(expected);
+  }
+
+  @Override
+  public S isExactlyInstanceOf(Class<?> type) {
+    return super.isExactlyInstanceOf(type);
+  }
+
+  @Override
+  public S isIn(Iterable<?> values) {
+    return super.isIn(values);
+  }
+
+  @Override
+  public S isIn(Object... values) {
+    return super.isIn(values);
+  }
+
+  @Override
+  public S isInstanceOf(Class<?> type) {
+    return super.isInstanceOf(type);
+  }
+
+  @Override
+  public S isInstanceOfAny(Class<?>... types) {
+    return super.isInstanceOfAny(types);
+  }
+
+  @Override
+  public S isNot(Condition<? super A> condition) {
+    return super.isNot(condition);
+  }
+
+  @Override
+  public S isNotEqualTo(Object other) {
+    return super.isNotEqualTo(other);
+  }
+
+  @Override
+  public S isNotExactlyInstanceOf(Class<?> type) {
+    return super.isNotExactlyInstanceOf(type);
+  }
+
+  @Override
+  public S isNotIn(Iterable<?> values) {
+    return super.isNotIn(values);
+  }
+
+  @Override
+  public S isNotIn(Object... values) {
+    return super.isNotIn(values);
+  }
+
+  @Override
+  public S isNotInstanceOf(Class<?> type) {
+    return super.isNotInstanceOf(type);
+  }
+
+  @Override
+  public S isNotInstanceOfAny(Class<?>... types) {
+    return super.isNotInstanceOfAny(types);
+  }
+
+  @Override
+  public S isNotOfAnyClassIn(Class<?>... types) {
+    return super.isNotOfAnyClassIn(types);
+  }
+
+  @Override
+  public S isNotNull() {
+    return super.isNotNull();
+  }
+
+  @Override
+  public S isNotSameAs(Object other) {
+    return super.isNotSameAs(other);
+  }
+
+  @Override
+  public S isOfAnyClassIn(Class<?>... types) {
+    return super.isOfAnyClassIn(types);
+  }
+
+  @Override
+  public S isSameAs(Object expected) {
+    return super.isSameAs(expected);
+  }
+
+  @Override
+  public S overridingErrorMessage(String newErrorMessage, Object... args) {
+    return super.overridingErrorMessage(newErrorMessage, args);
+  }
+
+  @Override
+  public S usingDefaultComparator() {
+    return super.usingDefaultComparator();
+  }
+
+  @Override
+  public S usingComparator(Comparator<? super A> customComparator) {
+    return super.usingComparator(customComparator);
+  }
+
+  @Override
+  public S withFailMessage(String newErrorMessage, Object... args) {
+    return super.withFailMessage(newErrorMessage, args);
+  }
+
+  @Override
+  public S withThreadDumpOnError() {
+    return super.withThreadDumpOnError();
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/AbstractMapAssert.java b/src/main/java/org/assertj/core/api/AbstractMapAssert.java
index f664cc03a..4ab81517e 100644
--- a/src/main/java/org/assertj/core/api/AbstractMapAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractMapAssert.java
@@ -18,6 +18,7 @@ import static org.assertj.core.util.Arrays.array;
 import java.util.Comparator;
 import java.util.Map;
 
+import org.assertj.core.description.Description;
 import org.assertj.core.internal.Maps;
 import org.assertj.core.util.VisibleForTesting;
 
@@ -257,7 +258,7 @@ public abstract class AbstractMapAssert<S extends AbstractMapAssert<S, A, K, V>,
     maps.assertContains(info, actual, entries);
     return myself;
   }
-  
+
   /**
    * Verifies that the actual map contains all entries of the given map, in any order.
    * <p>
@@ -288,7 +289,7 @@ public abstract class AbstractMapAssert<S extends AbstractMapAssert<S, A, K, V>,
    */
   public S containsAllEntriesOf(Map<? extends K, ? extends V> other) {
     @SuppressWarnings("unchecked")
-    Map.Entry<? extends K, ? extends V> [] entries = other.entrySet().toArray(new Map.Entry[other.size()]);
+    Map.Entry<? extends K, ? extends V>[] entries = other.entrySet().toArray(new Map.Entry[other.size()]);
     maps.assertContains(info, actual, entries);
     return myself;
   }
@@ -426,7 +427,7 @@ public abstract class AbstractMapAssert<S extends AbstractMapAssert<S, A, K, V>,
    * @throws AssertionError if the actual map does not contain the given key.
    * @throws IllegalArgumentException if the given argument is an empty array.
    */
-  
+
   public S containsKeys(@SuppressWarnings("unchecked") K... keys) {
     maps.assertContainsKeys(info, actual, keys);
     return myself;
@@ -504,7 +505,7 @@ public abstract class AbstractMapAssert<S extends AbstractMapAssert<S, A, K, V>,
    *           of the given keys, or the actual map contains more entries than the given ones.
    * @throws IllegalArgumentException if the given argument is an empty array.
    */
-  
+
   public S containsOnlyKeys(@SuppressWarnings("unchecked") K... keys) {
     maps.assertContainsOnlyKeys(info, actual, keys);
     return myself;
@@ -556,7 +557,7 @@ public abstract class AbstractMapAssert<S extends AbstractMapAssert<S, A, K, V>,
    * @throws AssertionError if the actual map is {@code null}.
    * @throws AssertionError if the actual map does not contain the given values.
    */
-  
+
   public S containsValues(@SuppressWarnings("unchecked") V... values) {
     maps.assertContainsValues(info, actual, values);
     return myself;
@@ -672,4 +673,172 @@ public abstract class AbstractMapAssert<S extends AbstractMapAssert<S, A, K, V>,
   public S usingDefaultElementComparator() {
     throw new UnsupportedOperationException("custom element Comparator is not supported for MapEntry comparison");
   }
+
+  // override methods to avoid compilation error when chaining an AbstractAssert method with a AbstractMapAssert one
+  // this is pretty sad, a better fix for that would be welcome
+
+  @Override
+  public S as(String description, Object... args) {
+    return super.as(description, args);
+  }
+
+  @Override
+  public S as(Description description) {
+    return super.as(description);
+  }
+
+  @Override
+  public S describedAs(Description description) {
+    return super.describedAs(description);
+  }
+
+  @Override
+  public S describedAs(String description, Object... args) {
+    return super.describedAs(description, args);
+  }
+
+  @Override
+  public S doesNotHave(Condition<? super A> condition) {
+    return super.doesNotHave(condition);
+  }
+
+  @Override
+  public S doesNotHaveSameClassAs(Object other) {
+    return super.doesNotHaveSameClassAs(other);
+  }
+
+  @Override
+  public S has(Condition<? super A> condition) {
+    return super.has(condition);
+  }
+
+  @Override
+  public S hasSameClassAs(Object other) {
+    return super.hasSameClassAs(other);
+  }
+
+  @Override
+  public S hasToString(String expectedToString) {
+    return super.hasToString(expectedToString);
+  }
+
+  @Override
+  public S is(Condition<? super A> condition) {
+    return super.is(condition);
+  }
+
+  @Override
+  public S isEqualTo(Object expected) {
+    return super.isEqualTo(expected);
+  }
+
+  @Override
+  public S isExactlyInstanceOf(Class<?> type) {
+    return super.isExactlyInstanceOf(type);
+  }
+
+  @Override
+  public S isIn(Iterable<?> values) {
+    return super.isIn(values);
+  }
+
+  @Override
+  public S isIn(Object... values) {
+    return super.isIn(values);
+  }
+
+  @Override
+  public S isInstanceOf(Class<?> type) {
+    return super.isInstanceOf(type);
+  }
+
+  @Override
+  public S isInstanceOfAny(Class<?>... types) {
+    return super.isInstanceOfAny(types);
+  }
+
+  @Override
+  public S isNot(Condition<? super A> condition) {
+    return super.isNot(condition);
+  }
+
+  @Override
+  public S isNotEqualTo(Object other) {
+    return super.isNotEqualTo(other);
+  }
+
+  @Override
+  public S isNotExactlyInstanceOf(Class<?> type) {
+    return super.isNotExactlyInstanceOf(type);
+  }
+
+  @Override
+  public S isNotIn(Iterable<?> values) {
+    return super.isNotIn(values);
+  }
+
+  @Override
+  public S isNotIn(Object... values) {
+    return super.isNotIn(values);
+  }
+
+  @Override
+  public S isNotInstanceOf(Class<?> type) {
+    return super.isNotInstanceOf(type);
+  }
+
+  @Override
+  public S isNotInstanceOfAny(Class<?>... types) {
+    return super.isNotInstanceOfAny(types);
+  }
+
+  @Override
+  public S isNotOfAnyClassIn(Class<?>... types) {
+    return super.isNotOfAnyClassIn(types);
+  }
+
+  @Override
+  public S isNotNull() {
+    return super.isNotNull();
+  }
+
+  @Override
+  public S isNotSameAs(Object other) {
+    return super.isNotSameAs(other);
+  }
+
+  @Override
+  public S isOfAnyClassIn(Class<?>... types) {
+    return super.isOfAnyClassIn(types);
+  }
+
+  @Override
+  public S isSameAs(Object expected) {
+    return super.isSameAs(expected);
+  }
+  
+  @Override
+  public S overridingErrorMessage(String newErrorMessage, Object... args) {
+    return super.overridingErrorMessage(newErrorMessage, args);
+  }
+
+  @Override
+  public S usingDefaultComparator() {
+    return super.usingDefaultComparator();
+  }
+
+  @Override
+  public S usingComparator(Comparator<? super A> customComparator) {
+    return super.usingComparator(customComparator);
+  }
+
+  @Override
+  public S withFailMessage(String newErrorMessage, Object... args) {
+    return super.withFailMessage(newErrorMessage, args);
+  }
+  
+  @Override
+  public S withThreadDumpOnError() {
+    return super.withThreadDumpOnError();
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/MapAssert.java b/src/main/java/org/assertj/core/api/MapAssert.java
index 6583753dc..93b15a493 100644
--- a/src/main/java/org/assertj/core/api/MapAssert.java
+++ b/src/main/java/org/assertj/core/api/MapAssert.java
@@ -31,7 +31,7 @@ public class MapAssert<K, V> extends AbstractMapAssert<MapAssert<K, V>, Map<K, V
   protected MapAssert(Map<K, V> actual) {
     super(actual, MapAssert.class);
   }
-
+  
   // override methods to annotate them with @SafeVarargs, we unfortunately can't do that in AbstractMapAssert as it is
   // used in soft assertions which need to be able to proxy method - @SafeVarargs requiring method to be final prevents
   // using proxies.
diff --git a/src/test/java/org/assertj/core/api/iterable/SetAssert_raw_set_assertions_chained_after_superclass_method_Test.java b/src/test/java/org/assertj/core/api/iterable/SetAssert_raw_set_assertions_chained_after_superclass_method_Test.java
new file mode 100644
index 000000000..ad419a646
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/SetAssert_raw_set_assertions_chained_after_superclass_method_Test.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.atIndex;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.Map;
+
+import org.assertj.core.description.Description;
+import org.assertj.core.description.EmptyTextDescription;
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class SetAssert_raw_set_assertions_chained_after_superclass_method_Test {
+
+  @SuppressWarnings({ "unchecked", "rawtypes" })
+  @Ignore
+  @Test
+  public void raw_set_assertions_mixed_with_inherited_methods() {
+    Description description = EmptyTextDescription.emptyText();
+
+    Set set = new java.util.HashSet<>();
+    set.add("Key1");
+    set.add("Key2");
+
+    assertThat(set).as("desc")
+                    .containsOnly("Key1", "Key2");
+
+    // try all base assertions followed by set specific ones using generics
+    assertThat(set).as("desc")
+                    .usingDefaultComparator()
+                    .as(description)
+                    .describedAs(description)
+                    .describedAs("describedAs")
+                    .has(null)
+                    .hasSameClassAs(set)
+                    .hasToString(set.toString())
+                    .is(null)
+                    .isEqualTo(set)
+                    .isExactlyInstanceOf(Map.class)
+                    .isIn(new HashSet<>())
+                    .isIn(Map.class)
+                    .isInstanceOf(Map.class)
+                    .isInstanceOfAny(Map.class, String.class)
+                    .isNot(null)
+                    .isNotEqualTo(null)
+                    .isNotEmpty()
+                    .isNotExactlyInstanceOf(String.class)
+                    .isNotIn(new HashSet<>())
+                    .isNotIn(Map.class)
+                    .isNotInstanceOf(Map.class)
+                    .isNotInstanceOfAny(Map.class, String.class)
+                    .isNotNull()
+                    .isNotOfAnyClassIn(Map.class, String.class)
+                    .isNotSameAs(null)
+                    .isOfAnyClassIn(Map.class, String.class)
+                    .isSameAs("")
+                    .overridingErrorMessage("")
+                    .withFailMessage("")
+                    .withThreadDumpOnError()
+                    .usingDefaultComparator()
+                    .contains("Key1", atIndex(0));
+  }
+
+  @SuppressWarnings({ "unchecked", "rawtypes" })
+  @Test
+  public void test_bug_485() {
+    // https://github.com/joel-costigliola/assertj-core/issues/485
+    Set set = new java.util.HashSet<>();
+    set.add("Key1");
+    set.add("Key2");
+
+    assertThat(set).as("")
+                    .contains("Key1", "Key2");
+
+    assertThat(set).as("")
+                    .containsOnly("Key1", "Key2");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/list/ListAssert_raw_list_assertions_chained_after_superclass_method_Test.java b/src/test/java/org/assertj/core/api/list/ListAssert_raw_list_assertions_chained_after_superclass_method_Test.java
new file mode 100644
index 000000000..f23ae458e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/list/ListAssert_raw_list_assertions_chained_after_superclass_method_Test.java
@@ -0,0 +1,96 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.list;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.atIndex;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import org.assertj.core.description.Description;
+import org.assertj.core.description.EmptyTextDescription;
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class ListAssert_raw_list_assertions_chained_after_superclass_method_Test {
+
+  @SuppressWarnings({ "unchecked", "rawtypes" })
+  @Ignore
+  @Test
+  public void raw_list_assertions_mixed_with_inherited_methods() {
+    Description description = EmptyTextDescription.emptyText();
+
+    List list = new java.util.ArrayList<>();
+    list.add("Key1");
+    list.add("Key2");
+
+    assertThat(list).as("desc")
+                    .containsOnly("Key1", "Key2");
+
+    // try all base assertions followed by list specific ones using generics
+    assertThat(list).as("desc")
+                    .usingDefaultComparator()
+                    .isSorted()
+                    .as(description)
+                    .isSorted()
+                    .describedAs(description)
+                    .describedAs("describedAs")
+                    .has(null)
+                    .hasSameClassAs(list)
+                    .hasToString(list.toString())
+                    .is(null)
+                    .isEqualTo(list)
+                    .isExactlyInstanceOf(Map.class)
+                    .isIn(new ArrayList<>())
+                    .isIn(Map.class)
+                    .isInstanceOf(Map.class)
+                    .isInstanceOfAny(Map.class, String.class)
+                    .isNot(null)
+                    .isNotEqualTo(null)
+                    .isNotEmpty()
+                    .isNotExactlyInstanceOf(String.class)
+                    .isNotIn(new ArrayList<>())
+                    .isNotIn(Map.class)
+                    .isNotInstanceOf(Map.class)
+                    .isNotInstanceOfAny(Map.class, String.class)
+                    .isNotNull()
+                    .isNotOfAnyClassIn(Map.class, String.class)
+                    .isNotSameAs(null)
+                    .isOfAnyClassIn(Map.class, String.class)
+                    .isSameAs("")
+                    .overridingErrorMessage("")
+                    .withFailMessage("")
+                    .withThreadDumpOnError()
+                    .usingDefaultComparator()
+                    .contains("Key1", atIndex(0));
+  }
+
+  @SuppressWarnings({ "unchecked", "rawtypes" })
+  @Test
+  public void test_bug_485() {
+    // https://github.com/joel-costigliola/assertj-core/issues/485
+    List list = new java.util.ArrayList<>();
+    list.add("Key1");
+    list.add("Key2");
+
+    assertThat(list).as("")
+                    .isSorted()
+                    .contains("Key1", "Key2");
+
+    assertThat(list).as("")
+                    .containsOnly("Key1", "Key2");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/map/MapAssert_raw_map_assertions_chained_after_base_assertions_Test.java b/src/test/java/org/assertj/core/api/map/MapAssert_raw_map_assertions_chained_after_base_assertions_Test.java
new file mode 100644
index 000000000..3ae427e2e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/map/MapAssert_raw_map_assertions_chained_after_base_assertions_Test.java
@@ -0,0 +1,85 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.map;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.ArrayList;
+import java.util.Map;
+
+import org.assertj.core.description.Description;
+import org.assertj.core.description.EmptyTextDescription;
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class MapAssert_raw_map_assertions_chained_after_base_assertions_Test {
+
+  @SuppressWarnings({ "unchecked", "rawtypes" })
+  @Ignore
+  @Test
+  public void raw_map_mixing_assertions_from_AbstractAssert_and_AbstractMapAssert() {
+    Description description = EmptyTextDescription.emptyText();
+
+    Map map1 = new java.util.HashMap();
+    map1.put("Key1", "Value1");
+    map1.put("Key2", "Value2");
+
+    // try all base assertions followed by map specific ones using generics
+    assertThat(map1).as("desc")
+                    .containsOnlyKeys("Key1", "Key2")
+                    .as(description)
+                    .containsOnlyKeys("Key1", "Key2")
+                    .describedAs(description)
+                    .describedAs("describedAs")
+                    .has(null)
+                    .hasSameClassAs(map1)
+                    .hasToString(map1.toString())
+                    .is(null)
+                    .isEqualTo(map1)
+                    .isExactlyInstanceOf(Map.class)
+                    .isIn(new ArrayList<>())
+                    .isIn(Map.class)
+                    .isInstanceOf(Map.class)
+                    .isInstanceOfAny(Map.class, String.class)
+                    .isNot(null)
+                    .isNotEqualTo(null)
+                    .isNotEmpty()
+                    .isNotExactlyInstanceOf(String.class)
+                    .isNotIn(new ArrayList<>())
+                    .isNotIn(Map.class)
+                    .isNotInstanceOf(Map.class)
+                    .isNotInstanceOfAny(Map.class, String.class)
+                    .isNotNull()
+                    .isNotOfAnyClassIn(Map.class, String.class)
+                    .isNotSameAs(null)
+                    .isOfAnyClassIn(Map.class, String.class)
+                    .isSameAs("")
+                    .overridingErrorMessage("")
+                    .withFailMessage("")
+                    .withThreadDumpOnError()
+                    .usingDefaultComparator()
+                    .containsOnlyKeys("Key1", "Key2");
+  }
+
+  @SuppressWarnings({ "unchecked", "rawtypes" })
+  @Test
+  public void test_bug_485() {
+    // https://github.com/joel-costigliola/assertj-core/issues/485
+    Map map1 = new java.util.HashMap<>();
+    map1.put("Key1", "Value1");
+    map1.put("Key2", "Value2");
+
+    assertThat(map1).as("").containsOnlyKeys("Key1", "Key2");
+  }
+
+}
