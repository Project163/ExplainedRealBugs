diff --git a/assertj-core/src/main/java/org/assertj/core/error/ShouldBeEqual.java b/assertj-core/src/main/java/org/assertj/core/error/ShouldBeEqual.java
index 1a8cbea90..24605b326 100644
--- a/assertj-core/src/main/java/org/assertj/core/error/ShouldBeEqual.java
+++ b/assertj-core/src/main/java/org/assertj/core/error/ShouldBeEqual.java
@@ -17,6 +17,7 @@ import static java.util.Objects.deepEquals;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Objects.HASH_CODE_PRIME;
 import static org.assertj.core.util.Objects.hashCodeFor;
+import static org.assertj.core.util.introspection.ClassUtils.haveSameClassNameInDifferentPackages;
 
 import java.util.Objects;
 
@@ -47,6 +48,7 @@ public class ShouldBeEqual {
                                                                                    Object.class);
   protected final Object actual;
   protected final Object expected;
+  protected final boolean haveSameClassNameInDifferentPackages;
   protected final MessageFormatter messageFormatter = MessageFormatter.instance();
   protected final ComparisonStrategy comparisonStrategy;
   private final Representation representation;
@@ -84,6 +86,7 @@ public class ShouldBeEqual {
     this.expected = expected;
     this.comparisonStrategy = comparisonStrategy;
     this.representation = representation;
+    this.haveSameClassNameInDifferentPackages = haveSameClassNameInDifferentPackages(actual, expected);
   }
 
   /**
@@ -220,11 +223,11 @@ public class ShouldBeEqual {
   }
 
   protected String detailedActual() {
-    return representation.unambiguousToStringOf(actual);
+    return representation.unambiguousToStringOf(actual, haveSameClassNameInDifferentPackages);
   }
 
   protected String detailedExpected() {
-    return representation.unambiguousToStringOf(expected);
+    return representation.unambiguousToStringOf(expected, haveSameClassNameInDifferentPackages);
   }
 
   @Override
diff --git a/assertj-core/src/main/java/org/assertj/core/internal/UnambiguousRepresentation.java b/assertj-core/src/main/java/org/assertj/core/internal/UnambiguousRepresentation.java
index c0fa540aa..0d0a469dc 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/UnambiguousRepresentation.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/UnambiguousRepresentation.java
@@ -12,6 +12,8 @@
  */
 package org.assertj.core.internal;
 
+import static org.assertj.core.util.introspection.ClassUtils.haveSameClassNameInDifferentPackages;
+
 import java.util.Objects;
 
 import org.assertj.core.presentation.Representation;
@@ -19,7 +21,7 @@ import org.assertj.core.presentation.Representation;
 /**
  * Utility class around {@link Representation} to provide the {@link Representation#toStringOf(Object) toStringOf}
  * representations of {@code actual} and {@code expected} when they are different, and their
- * {@link Representation#unambiguousToStringOf(Object) unambiguousToStringOf} representations if not.
+ * {@link Representation#unambiguousToStringOf(Object, boolean) unambiguousToStringOf} representations if not.
  */
 public class UnambiguousRepresentation {
 
@@ -32,17 +34,19 @@ public class UnambiguousRepresentation {
     String expectedRepresentation = representation.toStringOf(expected);
 
     boolean sameRepresentation = Objects.equals(actualRepresentation, expectedRepresentation);
+    boolean sameClassNameInDifferentPackages = haveSameClassNameInDifferentPackages(actual, expected);
     this.actual = sameRepresentation
-        ? representation.unambiguousToStringOf(actual)
+        ? representation.unambiguousToStringOf(actual, sameClassNameInDifferentPackages)
         : actualRepresentation;
     this.expected = sameRepresentation
-        ? representation.unambiguousToStringOf(expected)
+        ? representation.unambiguousToStringOf(expected, sameClassNameInDifferentPackages)
         : expectedRepresentation;
   }
 
   /**
    * Provide a representation of {@code actual} guaranteed to be different
    * from {@link #getExpected()}.
+   *
    * @return a suitable representation of the {@code actual} object given at
    * construction time.
    */
@@ -53,6 +57,7 @@ public class UnambiguousRepresentation {
   /**
    * Provide a representation of {@code expected} guaranteed to be different
    * from {@link #getActual()}.
+   *
    * @return a suitable representation of the {@code expected} object given at
    * construction time.
    */
diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/CompositeRepresentation.java b/assertj-core/src/main/java/org/assertj/core/presentation/CompositeRepresentation.java
index 5bfd1a565..828c49889 100644
--- a/assertj-core/src/main/java/org/assertj/core/presentation/CompositeRepresentation.java
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/CompositeRepresentation.java
@@ -41,13 +41,13 @@ public class CompositeRepresentation implements Representation {
   }
 
   @Override
-  public String unambiguousToStringOf(Object object) {
+  public String unambiguousToStringOf(Object object, boolean withPackageName) {
     // don't create streams for performance reasons and because this code is simple enough (even not as elegant as with stream)
     for (Representation representation : representations) {
-      String value = representation.unambiguousToStringOf(object);
+      String value = representation.unambiguousToStringOf(object, withPackageName);
       if (value != null) return value;
     }
-    return STANDARD_REPRESENTATION.unambiguousToStringOf(object);
+    return STANDARD_REPRESENTATION.unambiguousToStringOf(object, withPackageName);
   }
 
   @Override
diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/Representation.java b/assertj-core/src/main/java/org/assertj/core/presentation/Representation.java
index a38da4710..2162a41f8 100644
--- a/assertj-core/src/main/java/org/assertj/core/presentation/Representation.java
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/Representation.java
@@ -20,35 +20,35 @@ import org.assertj.core.configuration.Configuration;
 /**
  * Controls the formatting (String representation) of types in assertion error messages.
  * <p>
- * There are several ways to replace the {@link StandardRepresentation} as the default {@link Representation}:  
+ * There are several ways to replace the {@link StandardRepresentation} as the default {@link Representation}:
  * <ul>
  * <li>call {@link Assertions#useRepresentation(Representation)}, from this point all assertions will use the given representation.</li>
  * <li>use a {@link Configuration} overriding the default representation specified with {@link Configuration#representation()} as explained <a href="https://assertj.github.io/doc/#automatic-configuration-discovery">here</a>.</li>
  * <li>register a representation as a service discovered at program startup.</li>
  * </ul>
  * <p>
- * The advantage of registering a representation (or a  configuration overriding the default representation) is that you don't need to do anything in your tests, 
- * the java runtime will discover it and AssertJ will use it but it requires a bit more work than a simple call to {@link Assertions#useRepresentation(Representation)}.  
+ * The advantage of registering a representation (or a  configuration overriding the default representation) is that you don't need to do anything in your tests,
+ * the java runtime will discover it and AssertJ will use it but it requires a bit more work than a simple call to {@link Assertions#useRepresentation(Representation)}.
  * <p>
- * Note that a {@link Configuration} overriding the default representation takes precedence over any registered representation. 
+ * Note that a {@link Configuration} overriding the default representation takes precedence over any registered representation.
  * <p>
  * To register a {@link Representation}, you need to do several things:
  * <ul>
  * <li>create a file named {@code org.assertj.core.presentation.Representation} file in META-INF/services directory</li>
- * <li>put the fully qualified class name of your {@link Representation} in it</li>   
+ * <li>put the fully qualified class name of your {@link Representation} in it</li>
  * <li>make sure {@code META-INF/services/org.assertj.core.presentation.Representation} is in the runtime classpath, usually putting it in {@code src/test/resources} is enough</li>
  * </ul>
  * <p>
  * The <a href="https://github.com/assertj/assertj-examples/tree/main/assertions-examples">assertj-examples</a> project provides a working example of registering a custom representation.
  * <p>
- * Registering a representation has been introduced in AssertJ 2.9.0/3.9.0.  
+ * Registering a representation has been introduced in AssertJ 2.9.0/3.9.0.
  * <p>
- * Since 3.22.0, AssertJ can load multiples representations from the classpath, the idea behind is that different domain-specific libraries would be able to 
- * independently register representations for their respective domain. AssertJ aggregate them in a {@link CompositeRepresentation} which loops over 
- * the different representations and use the first non null representation value of the variable to display. If multiples representations overlap the highest priority one wins (see {@link #getPriority()}).   
+ * Since 3.22.0, AssertJ can load multiples representations from the classpath, the idea behind is that different domain-specific libraries would be able to
+ * independently register representations for their respective domain. AssertJ aggregate them in a {@link CompositeRepresentation} which loops over
+ * the different representations and use the first non null representation value of the variable to display. If multiples representations overlap the highest priority one wins (see {@link #getPriority()}).
  * The {@link StandardRepresentation} is the fallback option when all the registered representations returned a null representation of the value to display (meaning they did not know how to represent the value).
  * <p>
- * 
+ *
  * @author Mariusz Smykula
  */
 public interface Representation {
@@ -65,17 +65,32 @@ public interface Representation {
   String toStringOf(Object object);
 
   /**
-   * Override this method to return a {@code String} representation of the given object that is unambiguous so that it can 
+   * Override this method to return a {@code String} representation of the given object that is unambiguous so that it can
+   * be differentiated from other objects with the same {@link #toStringOf(Object)} representation.
+   * <p>
+   * The default implementation calls {@link #toStringOf(Object)} but the {@link StandardRepresentation} adds
+   * the object hexadecimal identity hash code.
+   *
+   * @param object          the object to represent.
+   * @param withPackageName if the object's representation includes the package name or not
+   * @return the unambiguous {@code toString} representation of the given object.
+   */
+  default String unambiguousToStringOf(Object object, boolean withPackageName) {
+    return toStringOf(object);
+  }
+
+  /**
+   * Override this method to return a {@code String} representation of the given object that is unambiguous so that it can
    * be differentiated from other objects with the same {@link #toStringOf(Object)} representation.
    * <p>
-   * The default implementation calls {@link #toStringOf(Object)} but the {@link StandardRepresentation} adds 
-   * the object hexadecimal identity hash code.   
+   * The default implementation calls {@link #toStringOf(Object)} but the {@link StandardRepresentation} adds
+   * the object hexadecimal identity hash code (but without the package).
    *
    * @param object the object to represent.
    * @return the unambiguous {@code toString} representation of the given object.
    */
   default String unambiguousToStringOf(Object object) {
-    return toStringOf(object);
+    return unambiguousToStringOf(object, false);
   }
 
   /**
@@ -85,7 +100,7 @@ public interface Representation {
    * The {@link StandardRepresentation} is the fallback option when all the registered representations returned a null representation of the value to display (meaning they did not know how to represent the value).
    * <p>
    * The default priority is 1.
-   * 
+   *
    * @return the representation priority.
    */
   default int getPriority() {
diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index c52203b90..f116a1376 100644
--- a/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -63,11 +63,11 @@ import java.util.concurrent.atomic.AtomicStampedReference;
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Function;
 
+import org.assertj.core.api.comparisonstrategy.ComparatorBasedComparisonStrategy;
 import org.assertj.core.configuration.Configuration;
 import org.assertj.core.configuration.ConfigurationProvider;
 import org.assertj.core.data.MapEntry;
 import org.assertj.core.groups.Tuple;
-import org.assertj.core.api.comparisonstrategy.ComparatorBasedComparisonStrategy;
 import org.assertj.core.util.Closeables;
 import org.assertj.core.util.diff.ChangeDelta;
 import org.assertj.core.util.diff.DeleteDelta;
@@ -303,14 +303,16 @@ public class StandardRepresentation implements Representation {
    * Returns the {@code String} representation of the given object with its type and hexadecimal identity hash code so that
    * it can be differentiated from other objects with the same {@link #toStringOf(Object)} representation.
    *
-   * @param obj the object to represent.
+   * @param obj                            the object to represent.
+   * @param withPackageName              if the object's representation includes the package or not
    * @return the unambiguous {@code toString} representation of the given object.
    */
   @Override
-  public String unambiguousToStringOf(Object obj) {
+  public String unambiguousToStringOf(Object obj, boolean withPackageName) {
     // some types have already an unambiguous toString, no need to double down
     if (hasAlreadyAnUnambiguousToStringOf(obj)) return toStringOf(obj);
-    return obj == null ? null : "%s (%s@%s)".formatted(toStringOf(obj), classNameOf(obj), identityHexCodeOf(obj));
+    return obj == null ? null
+        : "%s (%s@%s)".formatted(toStringOf(obj), classNameOf(obj, withPackageName), identityHexCodeOf(obj));
   }
 
   @Override
@@ -759,10 +761,18 @@ public class StandardRepresentation implements Representation {
     return toHexString(System.identityHashCode(obj));
   }
 
-  private static Object classNameOf(Object obj) {
+  private static String classNameOf(Object obj) {
     return obj.getClass().isAnonymousClass() ? obj.getClass().getName() : obj.getClass().getSimpleName();
   }
 
+  private static String classNameOf(Object obj, boolean shouldKeepPackage) {
+    return shouldKeepPackage ? packageAndClassNameOf(obj) : classNameOf(obj);
+  }
+
+  private static String packageAndClassNameOf(Object obj) {
+    return "%s.%s".formatted(obj.getClass().getPackage().getName(), classNameOf(obj));
+  }
+
   private String defaultToStringWithClassNameDisambiguation(Object o) {
     return o.toString() + classNameDisambiguation(o);
   }
diff --git a/assertj-core/src/main/java/org/assertj/core/util/introspection/ClassUtils.java b/assertj-core/src/main/java/org/assertj/core/util/introspection/ClassUtils.java
index 790a4de0d..585bc2ad1 100644
--- a/assertj-core/src/main/java/org/assertj/core/util/introspection/ClassUtils.java
+++ b/assertj-core/src/main/java/org/assertj/core/util/introspection/ClassUtils.java
@@ -80,7 +80,7 @@ public class ClassUtils {
   /**
    * Get the interfaces for the specified class.
    *
-   * @param cls the class to look up, may be {@code null}
+   * @param cls             the class to look up, may be {@code null}
    * @param interfacesFound the {@code Set} of interfaces for the class
    */
   static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {
@@ -107,7 +107,7 @@ public class ClassUtils {
    *
    * @param type The class to query or null.
    * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},
-   *         {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}, {@link Void}).
+   * {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}, {@link Void}).
    * @since 3.24.0
    */
   public static boolean isPrimitiveOrWrapper(final Class<?> type) {
@@ -125,7 +125,7 @@ public class ClassUtils {
    *
    * @param type The class to query or null.
    * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Optional}, {@link OptionalInt},
-   *              {@link OptionalLong}, {@link OptionalDouble}).
+   * {@link OptionalLong}, {@link OptionalDouble}).
    * @since 3.24.0
    */
   public static boolean isOptionalOrPrimitiveOptional(final Class<?> type) {
@@ -145,4 +145,21 @@ public class ClassUtils {
   public static boolean isInJavaLangPackage(final Class<?> type) {
     return type != null && type.getName().startsWith("java.lang");
   }
+
+  /**
+   * Returns whether the given objects types have the same name but are located in different packages
+   *
+   * @param object1 first object to compare
+   * @param object2 the object to compare to
+   * @return true if the given {@code object1} types have the same name as {@code object2} but is
+   * in a different package
+   */
+  public static boolean haveSameClassNameInDifferentPackages(Object object1, Object object2) {
+    if (object1 != null && object2 != null) {
+      Class<?> type1 = object1.getClass();
+      Class<?> type2 = object2.getClass();
+      return type1.getSimpleName().equals(type2.getSimpleName()) && !type1.getPackageName().equals(type2.getPackageName());
+    }
+    return false;
+  }
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/error/ShouldBeEqual_Test.java b/assertj-core/src/test/java/org/assertj/core/error/ShouldBeEqual_Test.java
index 8a788977d..5b9ff89a5 100644
--- a/assertj-core/src/test/java/org/assertj/core/error/ShouldBeEqual_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/error/ShouldBeEqual_Test.java
@@ -22,6 +22,7 @@ import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.Lists.list;
 
 import java.util.Objects;
+
 import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.testkit.CaseInsensitiveStringComparator;
 import org.junit.jupiter.api.Disabled;
@@ -77,6 +78,18 @@ class ShouldBeEqual_Test {
                                         "%n but was: \"\"test\" (String".formatted());
   }
 
+  @Test
+  void should_display_packages_for_classes_with_the_same_name_when_objects_representation_are_the_same() {
+    // GIVEN
+    Object actual = new org.assertj.core.internal.objects.pkg1.Foo("foo");
+    Object expected = new org.assertj.core.internal.objects.pkg2.Foo("foo");
+    // WHEN
+    var error = expectAssertionError(() -> then(actual).isEqualTo(expected));
+    // THEN
+    then(error).hasMessageContainingAll("expected: \"Foo[name=foo] (org.assertj.core.internal.objects.pkg2.Foo",
+                                        " but was: \"Foo[name=foo] (org.assertj.core.internal.objects.pkg1.Foo");
+  }
+
   @Test
   void should_display_multiline_values_nicely() {
     // GIVEN
diff --git a/assertj-core/src/test/java/org/assertj/core/internal/UnambiguousRepresentation_Test.java b/assertj-core/src/test/java/org/assertj/core/internal/UnambiguousRepresentation_Test.java
index 8d7fed571..8394a3c89 100644
--- a/assertj-core/src/test/java/org/assertj/core/internal/UnambiguousRepresentation_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/internal/UnambiguousRepresentation_Test.java
@@ -12,7 +12,9 @@
  */
 package org.assertj.core.internal;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
 import static org.mockito.BDDMockito.given;
 
 import org.assertj.core.presentation.Representation;
@@ -47,14 +49,14 @@ class UnambiguousRepresentation_Test {
   }
 
   @Test
-  void should_use_unambiguousToStringOf_whe_toStringOf_are_equal() {
+  void should_use_unambiguousToStringOf_when_toStringOf_are_equal() {
     // GIVEN
     Object actual = new Object();
     Object expected = new Object();
     given(representation.toStringOf(actual)).willReturn("representation");
     given(representation.toStringOf(expected)).willReturn("representation");
-    given(representation.unambiguousToStringOf(actual)).willReturn("actual");
-    given(representation.unambiguousToStringOf(expected)).willReturn("expected");
+    given(representation.unambiguousToStringOf(actual, false)).willReturn("actual");
+    given(representation.unambiguousToStringOf(expected, false)).willReturn("expected");
     // WHEN
     UnambiguousRepresentation actualRepresentation = new UnambiguousRepresentation(representation, actual, expected);
     // THEN
@@ -62,4 +64,17 @@ class UnambiguousRepresentation_Test {
     then(actualRepresentation.getExpected()).isEqualTo("expected");
   }
 
+  @Test
+  void unambiguousToStringOf_should_include_package_if_classes_have_the_same_name() {
+    // GIVEN
+    Object actual = new org.assertj.core.internal.objects.pkg1.Foo("foo");
+    Object expected = new org.assertj.core.internal.objects.pkg2.Foo("foo");
+    assertThat(STANDARD_REPRESENTATION.toStringOf(actual)).isEqualTo(STANDARD_REPRESENTATION.toStringOf(expected));
+    // WHEN
+    var unambiguousRepresentation = new UnambiguousRepresentation(STANDARD_REPRESENTATION, actual, expected);
+    // THEN
+    then(unambiguousRepresentation.getActual()).contains("Foo[name=foo] (org.assertj.core.internal.objects.pkg1.Foo@");
+    then(unambiguousRepresentation.getExpected()).contains("Foo[name=foo] (org.assertj.core.internal.objects.pkg2.Foo@");
+  }
+
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/internal/objects/pkg1/Foo.java b/assertj-core/src/test/java/org/assertj/core/internal/objects/pkg1/Foo.java
new file mode 100644
index 000000000..61c9de620
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/internal/objects/pkg1/Foo.java
@@ -0,0 +1,16 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.internal.objects.pkg1;
+
+public record Foo(String name) {
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/internal/objects/pkg2/Foo.java b/assertj-core/src/test/java/org/assertj/core/internal/objects/pkg2/Foo.java
new file mode 100644
index 000000000..61fdb24b2
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/internal/objects/pkg2/Foo.java
@@ -0,0 +1,16 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.internal.objects.pkg2;
+
+public record Foo(String name) {
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/util/introspection/ClassUtils_haveSameClassNameInDifferentPackages_Test.java b/assertj-core/src/test/java/org/assertj/core/util/introspection/ClassUtils_haveSameClassNameInDifferentPackages_Test.java
new file mode 100644
index 000000000..ee731c29a
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/util/introspection/ClassUtils_haveSameClassNameInDifferentPackages_Test.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.util.introspection;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.introspection.ClassUtils.haveSameClassNameInDifferentPackages;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.Date;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class ClassUtils_haveSameClassNameInDifferentPackages_Test {
+
+  @ParameterizedTest
+  @MethodSource
+  void should_return_true(Object object1, Object object2) {
+    assertThat(haveSameClassNameInDifferentPackages(object1, object2)).isTrue();
+  }
+
+  static Stream<Arguments> should_return_true() {
+    return Stream.of(arguments(new Date(123), new java.sql.Date(123)),
+                     arguments(new org.assertj.core.internal.objects.pkg1.Foo("foo"),
+                               new org.assertj.core.internal.objects.pkg2.Foo("foo")));
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_return_false(Object object1, Object object2) {
+    assertThat(haveSameClassNameInDifferentPackages(object1, object2)).isFalse();
+  }
+
+  static Stream<Arguments> should_return_false() {
+    return Stream.of(arguments(new Date(123), new Date(123)),
+                     arguments(new Date(123), "foo"),
+                     arguments(null, "foo"),
+                     arguments("foo", null),
+                     arguments(null, null));
+  }
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/presentation/CompositeRepresentation_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/presentation/CompositeRepresentation_Test.java
index c4b752b98..4b7a2baa3 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/presentation/CompositeRepresentation_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/presentation/CompositeRepresentation_Test.java
@@ -88,7 +88,7 @@ class CompositeRepresentation_Test extends AbstractBaseRepresentationTest {
       }
 
       @Override
-      public String unambiguousToStringOf(Object object) {
+      public String unambiguousToStringOf(Object object, boolean withPackageName) {
         return "" + getPriority();
       }
 
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java
index 1da0f94c9..68ba40c8a 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java
@@ -41,6 +41,7 @@ import java.util.concurrent.atomic.AtomicMarkableReference;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.concurrent.atomic.AtomicStampedReference;
+
 import org.assertj.core.data.MapEntry;
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.presentation.StandardRepresentation;
@@ -519,6 +520,30 @@ class StandardRepresentation_unambiguousToStringOf_Test extends AbstractBaseRepr
                .hasMessageContaining(unambiguousToStringOf(ambiguous2));
   }
 
+  @Test
+  void should_get_unambiguous_representation_with_package() {
+    // GIVEN
+    boolean withPackageName = true;
+    // WHEN
+    String unambiguousRepresentation = STANDARD_REPRESENTATION.unambiguousToStringOf(new Person(), withPackageName);
+    // THEN
+    then(unambiguousRepresentation).contains("Person [name=null, age=0, account=0] (org.assertj.tests.core.presentation.Person@");
+  }
+
+  @Test
+  void should_get_unambiguous_representation_without_package() {
+    // GIVEN
+    boolean withPackageName = false;
+    // WHEN
+    String unambiguousRepresentation = STANDARD_REPRESENTATION.unambiguousToStringOf(new Person(), withPackageName);
+    // THEN
+    then(unambiguousRepresentation).contains("Person [name=null, age=0, account=0] (Person@");
+  }
+
+  private static String removeHashCode(String representation) {
+    return representation.replaceAll("(@\\w+)", "");
+  }
+
   private static String unambiguousToStringOf(Object o) {
     return STANDARD_REPRESENTATION.unambiguousToStringOf(o);
   }
