diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 2023cb3c1..de6327862 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -798,7 +798,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   /**
    * Verifies that the actual {@link Iterable} contains at least one of the given values.
    * <p>
-   * Example :
+   * Example:
    * <pre><code class='java'> Iterable&lt;String&gt; abc = Arrays.asList("a", "b", "c");
    *
    * // assertions will pass
@@ -829,7 +829,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   /**
    * Verifies that the {@link Iterable} under test contains at least one of the given {@link Iterable} elements.
    * <p>
-   * Example :
+   * Example:
    * <pre><code class='java'> Iterable&lt;String&gt; abc = Arrays.asList("a", "b", "c");
    *
    * // assertions will pass
@@ -861,9 +861,9 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * Iterable becoming the Iterable under test.
    * <p>
    * It allows you to test a property/field of the Iterable's elements instead of testing the elements themselves, which
-   * can be be much less work !
+   * can be be much less work!
    * <p>
-   * Let's take a look at an example to make things clearer :
+   * Let's take a look at an example to make things clearer:
    * <pre><code class='java'> // build a list of TolkienCharacters: a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
@@ -877,13 +877,13 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
    *
-   * // let's verify the names of the TolkienCharacters in fellowshipOfTheRing :
+   * // let's verify the names of the TolkienCharacters in fellowshipOfTheRing:
    *
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;)
    *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
    *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
    *
-   * // you can extract nested properties/fields like the name of the race :
+   * // you can extract nested properties/fields like the name of the race:
    *
    * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;)
    *                                .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
@@ -953,8 +953,8 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * is especially useful for classes that do not conform to the Java Bean's getter specification (i.e. public String
    * toString() or public String status() instead of public String getStatus()).
    * <p>
-   * Let's take a look at an example to make things clearer :
-   * <pre><code class='java'> // Build a array of WesterosHouse, a WesterosHouse has a method: public String sayTheWords()
+   * Let's take a look at an example to make things clearer:
+   * <pre><code class='java'> // Build an array of WesterosHouse, a WesterosHouse has a method: public String sayTheWords()
    *
    * List&lt;WesterosHouse&gt; greatHouses = new ArrayList&lt;WesterosHouse&gt;();
    * greatHouses.add(new WesterosHouse(&quot;Stark&quot;, &quot;Winter is Coming&quot;));
@@ -1001,8 +1001,8 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * is especially useful for classes that do not conform to the Java Bean's getter specification (i.e. public String
    * toString() or public String status() instead of public String getStatus()).
    * <p>
-   * Let's take an example to make things clearer :
-   * <pre><code class='java'> // Build a array of WesterosHouse, a WesterosHouse has a method: public String sayTheWords()
+   * Let's take an example to make things clearer:
+   * <pre><code class='java'> // Build an array of WesterosHouse, a WesterosHouse has a method: public String sayTheWords()
    * List&lt;WesterosHouse&gt; greatHouses = new ArrayList&lt;WesterosHouse&gt;();
    * greatHouses.add(new WesterosHouse(&quot;Stark&quot;, &quot;Winter is Coming&quot;));
    * greatHouses.add(new WesterosHouse(&quot;Lannister&quot;, &quot;Hear Me Roar!&quot;));
@@ -1049,9 +1049,9 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * Iterable becoming the Iterable under test.
    * <p>
    * It allows you to test a property/field of the Iterable's elements instead of testing the elements themselves,
-   * which can be much less work !
+   * which can be much less work!
    * <p>
-   * Let's take an example to make things clearer :
+   * Let's take an example to make things clearer:
    * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
@@ -1065,12 +1065,12 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
    *
-   * // let's verify the names of TolkienCharacter in fellowshipOfTheRing :
+   * // let's verify the names of TolkienCharacter in fellowshipOfTheRing:
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;, String.class)
    *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
    *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
    *
-   * // you can extract nested property/field like the name of Race :
+   * // you can extract nested property/field like the name of Race:
    * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;, String.class)
    *                                .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
    *                                .doesNotContain(&quot;Orc&quot;);</code></pre>
@@ -1146,7 +1146,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * extract "id", "name" and "email" then each Tuple data will be composed of id, name and email extracted from the
    * element of the initial Iterable (the Tuple's data order is the same as the given fields/properties order).
    * <p>
-   * Let's take an example to make things clearer :
+   * Let's take an example to make things clearer:
    * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
@@ -1160,14 +1160,14 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
    *
-   * // let's verify 'name' and 'age' of some TolkienCharacter in fellowshipOfTheRing :
+   * // let's verify 'name' and 'age' of some TolkienCharacter in fellowshipOfTheRing:
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;, &quot;age&quot;)
    *                                .contains(tuple(&quot;Boromir&quot;, 37),
    *                                          tuple(&quot;Sam&quot;, 38),
    *                                          tuple(&quot;Legolas&quot;, 1000));
    *
    *
-   * // extract 'name', 'age' and Race name values :
+   * // extract 'name', 'age' and Race name values:
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;, &quot;age&quot;, &quot;race.name&quot;)
    *                                .contains(tuple(&quot;Boromir&quot;, 37, &quot;Man&quot;),
    *                                          tuple(&quot;Sam&quot;, 38, &quot;Hobbit&quot;),
@@ -1229,12 +1229,12 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
 
   /**
    * Extract the values from Iterable's elements under test by applying an extracting function on them. The returned
-   * iterable becomes a new object under test.
+   * iterable becomes the instance under test.
    * <p>
    * It allows to test values from the elements more safely than by using {@link #extracting(String)}, as it
    * doesn't utilize introspection.
    * <p>
-   * Let's have a look at an example :
+   * Let's have a look at an example:
    * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
@@ -1252,8 +1252,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * assertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getRace).contains(HOBBIT);</code></pre>
    *
    * Note that the order of extracted property/field values is consistent with the iteration order of the Iterable under
-   * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions on the extracted values
-   * order.
+   * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions on the extracted values order.
    *
    * @param <V> the type of elements extracted.
    * @param extractor the object transforming input object to desired one
@@ -1261,20 +1260,58 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    */
   @CheckReturnValue
   public <V> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> extracting(Function<? super ELEMENT, V> extractor) {
+    return internalExtracting(extractor);
+  }
+
+  private <V> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> internalExtracting(Function<? super ELEMENT, V> extractor) {
     List<V> values = FieldsOrPropertiesExtractor.extract(actual, extractor);
     return newListAssertInstanceForMethodsChangingElementType(values);
   }
 
+  /**
+   * Maps the Iterable's elements under test by applying a mapping function, the resulting list becomes the instance under test.
+   * <p>
+   * This allows to test values from the elements more safely than by using {@link #extracting(String)}.
+   * <p>
+   * Let's have a look at an example:
+   * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
+   * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
+   *
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Legolas&quot;, 1000, ELF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Pippin&quot;, 28, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
+   *
+   * // fellowship has hobbitses, right, my precioussss?
+   * assertThat(fellowshipOfTheRing).map(TolkienCharacter::getRace)
+   *                                .contains(HOBBIT);</code></pre>
+   *
+   * Note that the order of mapped values is consistent with the order of the Iterable under test, for example if
+   * it's a {@link HashSet}, you won't be able to make any assumptions on the extracted values order.
+   *
+   * @param <V> the type of elements resulting of the map operation.
+   * @param mapper the {@link Function} transforming input object to desired one
+   * @return a new assertion object whose object under test is the list of values extracted
+   * @since 3.19.0
+   */
+  public <V> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> map(Function<? super ELEMENT, V> mapper) {
+    return internalExtracting(mapper);
+  }
+
   /**
    * Extract the values from Iterable's elements under test by applying an extracting function (which might throw an
-   * exception) on them. The returned iterable becomes a new object under test.
+   * exception) on them. The returned iterable becomes the instance under test.
    * <p>
    * Any checked exception raised in the extractor is rethrown wrapped in a {@link RuntimeException}.
    * <p>
    * It allows to test values from the elements more safely than by using {@link #extracting(String)}, as it
    * doesn't utilize introspection.
    * <p>
-   * Let's have a look at an example :
+   * Let's have a look at an example:
    * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
@@ -1307,8 +1344,49 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    */
   @CheckReturnValue
   public <V, EXCEPTION extends Exception> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> extracting(ThrowingExtractor<? super ELEMENT, V, EXCEPTION> extractor) {
-    List<V> values = FieldsOrPropertiesExtractor.extract(actual, extractor);
-    return newListAssertInstanceForMethodsChangingElementType(values);
+    return internalExtracting(extractor);
+  }
+
+  /**
+   * Maps the Iterable's elements by applying the given mapping function (which might throw an exception), the returned list
+   * becomes the instance under test.
+   * <p>
+   * Any checked exception raised in the function is rethrown wrapped in a {@link RuntimeException}.
+   * <p>
+   * This allows to test values from the elements more safely than by using {@link #extracting(String)}.
+   * <p>
+   * Let's have a look at an example:
+   * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
+   * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
+   *
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Legolas&quot;, 1000, ELF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Pippin&quot;, 28, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
+   *
+   * assertThat(fellowshipOfTheRing).map(input -&gt; {
+   *   if (input.getAge() &lt; 20) {
+   *     throw new Exception("age &lt; 20");
+   *   }
+   *   return input.getName();
+   * }).contains("Frodo");</code></pre>
+   *
+   * Note that the order of mapped values is consistent with the order of the Iterable under test, for example if it's a
+   * {@link HashSet}, you won't be able to make any assumptions on the extracted values order.
+   *
+   * @param <EXCEPTION> the exception type of {@link ThrowingExtractor}
+   * @param <V> the type of elements extracted.
+   * @param mapper the function transforming input object to desired one
+   * @return a new assertion object whose object under test is the list of values extracted
+   * @since 3.19.0
+   */
+  @CheckReturnValue
+  public <V, EXCEPTION extends Exception> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> map(ThrowingExtractor<? super ELEMENT, V, EXCEPTION> mapper) {
+    return internalExtracting(mapper);
   }
 
   /*
@@ -1327,15 +1405,14 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   }
 
   /**
-   * Extract the Iterable values from Iterable's elements under test by applying an Iterable extracting function on them
-   * and concatenating the result lists. The returned iterable becomes a new object under test.
-   * <p>
-   * It allows testing the results of extracting values that are represented by Iterables.
+   * Extracts Iterable elements values by applying a function and concatenates the result into a list that becomes the instance
+   * under test.
    * <p>
-   * For example:
+   * Example:
    * <pre><code class='java'> CartoonCharacter bart = new CartoonCharacter("Bart Simpson");
    * CartoonCharacter lisa = new CartoonCharacter("Lisa Simpson");
    * CartoonCharacter maggie = new CartoonCharacter("Maggie Simpson");
+   *
    * CartoonCharacter homer = new CartoonCharacter("Homer Simpson");
    * homer.getChildren().add(bart);
    * homer.getChildren().add(lisa);
@@ -1351,13 +1428,11 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * assertThat(parents).flatExtracting(CartoonCharacter::getChildren)
    *                    .containsOnly(bart, lisa, maggie, pebbles);</code></pre>
    *
-   * The order of extracted values is consistent with both the order of the collection itself, as well as the extracted
-   * collections.
+   * The extracted values order is consistent with both the order of the iterable itself as well as the extracted collections.
    *
-   * @param <V> the type of elements extracted.
-   * @param extractor the object transforming input object to an {@code Iterable} of desired ones
+   * @param <V> the type of extracted elements.
+   * @param extractor the {@link Function} transforming input object to an {@code Iterable} of desired ones
    * @return a new assertion object whose object under test is the list of values extracted
-   * @throws NullPointerException if one of the {@code Iterable}'s element is null.
    */
   @CheckReturnValue
   public <V> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> flatExtracting(Function<? super ELEMENT, ? extends Collection<V>> extractor) {
@@ -1365,16 +1440,50 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   }
 
   /**
-   * Extract the Iterable values from Iterable's elements under test by applying an Iterable extracting function (which
-   * might throw a checked exception) on them and concatenating the result lists. The returned iterable becomes a new object
-   * under test.
+   * Maps the Iterable's elements under test by applying the given {@link Function} and flattens the resulting collections in a
+   * list becoming the object under test.
    * <p>
-   * It allows testing the results of extracting values that are represented by Iterables.
+   * Example:
+   * <pre><code class='java'> CartoonCharacter bart = new CartoonCharacter("Bart Simpson");
+   * CartoonCharacter lisa = new CartoonCharacter("Lisa Simpson");
+   * CartoonCharacter maggie = new CartoonCharacter("Maggie Simpson");
+   *
+   * CartoonCharacter homer = new CartoonCharacter("Homer Simpson");
+   * homer.getChildren().add(bart);
+   * homer.getChildren().add(lisa);
+   * homer.getChildren().add(maggie);
+   *
+   * CartoonCharacter pebbles = new CartoonCharacter("Pebbles Flintstone");
+   * CartoonCharacter fred = new CartoonCharacter("Fred Flintstone");
+   * fred.getChildren().add(pebbles);
+   *
+   * List&lt;CartoonCharacter&gt; parents = list(homer, fred);
+   *
+   * // check children property which is a List&lt;CartoonCharacter&gt;
+   * assertThat(parents).flatMap(CartoonCharacter::getChildren)
+   *                    .containsOnly(bart, lisa, maggie, pebbles);</code></pre>
+   *
+   * The mapped values order is consistent with both the order of the iterable itself as well as the mapped collections.
+   *
+   * @param <V> the type of mapped elements.
+   * @param mapper the {@link Function} transforming input object to an {@code Iterable} of desired ones
+   * @return a new assertion object whose object under test is the list of values extracted
+   * @since 3.19.0
+   */
+  @CheckReturnValue
+  public <V> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> flatMap(Function<? super ELEMENT, ? extends Collection<V>> mapper) {
+    return doFlatExtracting(mapper);
+  }
+
+  /**
+   * Extracts Iterable elements values by applying a function (which might throw a checked exception) on them and
+   * concatenates/flattens the result into a single list that becomes the instance under test.
    * <p>
-   * For example:
+   * Example:
    * <pre><code class='java'> CartoonCharacter bart = new CartoonCharacter("Bart Simpson");
    * CartoonCharacter lisa = new CartoonCharacter("Lisa Simpson");
    * CartoonCharacter maggie = new CartoonCharacter("Maggie Simpson");
+   *
    * CartoonCharacter homer = new CartoonCharacter("Homer Simpson");
    * homer.getChildren().add(bart);
    * homer.getChildren().add(lisa);
@@ -1390,14 +1499,12 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * assertThat(parents).flatExtracting(CartoonCharacter::getChildren)
    *                    .containsOnly(bart, lisa, maggie, pebbles);</code></pre>
    *
-   * The order of extracted values is consistent with both the order of the collection itself, as well as the extracted
-   * collections.
+   * The extracted values order is consistent with both the order of the iterable itself as well as the extracted collections.
    *
-   * @param <V> the type of elements extracted.
+   * @param <V> the type of extracted values.
    * @param <EXCEPTION> the exception type of {@link ThrowingExtractor}
    * @param extractor the object transforming input object to an {@code Iterable} of desired ones
    * @return a new assertion object whose object under test is the list of values extracted
-   * @throws NullPointerException if one of the {@code Iterable}'s element is null.
    * @since 3.7.0
    */
   @CheckReturnValue
@@ -1405,6 +1512,43 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return doFlatExtracting(extractor);
   }
 
+  /**
+   * Maps the Iterable's elements under test by applying a mapping function (which might throw a checked exception) and
+   * concatenates/flattens the result into a single list that becomes the instance under test.
+   * <p>
+   * Example:
+   * <pre><code class='java'> CartoonCharacter bart = new CartoonCharacter("Bart Simpson");
+   * CartoonCharacter lisa = new CartoonCharacter("Lisa Simpson");
+   * CartoonCharacter maggie = new CartoonCharacter("Maggie Simpson");
+   *
+   * CartoonCharacter homer = new CartoonCharacter("Homer Simpson");
+   * homer.getChildren().add(bart);
+   * homer.getChildren().add(lisa);
+   * homer.getChildren().add(maggie);
+   *
+   * CartoonCharacter pebbles = new CartoonCharacter("Pebbles Flintstone");
+   * CartoonCharacter fred = new CartoonCharacter("Fred Flintstone");
+   * fred.getChildren().add(pebbles);
+   *
+   * List&lt;CartoonCharacter&gt; parents = list(homer, fred);
+   *
+   * // check children property where getChildren() can throw an Exception!
+   * assertThat(parents).flatMap(CartoonCharacter::getChildren)
+   *                    .containsOnly(bart, lisa, maggie, pebbles);</code></pre>
+   *
+   * The mapped values order is consistent with both the order of the iterable itself as well as the mapped collections.
+   *
+   * @param <V> the type of mapped values.
+   * @param <EXCEPTION> the exception type of {@link ThrowingExtractor}
+   * @param mapper the object transforming input object to an {@code Iterable} of desired ones
+   * @return a new assertion object whose object under test is the list of values extracted
+   * @since 3.19.0
+   */
+  @CheckReturnValue
+  public <V, EXCEPTION extends Exception> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> flatMap(ThrowingExtractor<? super ELEMENT, ? extends Collection<V>, EXCEPTION> mapper) {
+    return doFlatExtracting(mapper);
+  }
+
   private <V> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> doFlatExtracting(Function<? super ELEMENT, ? extends Collection<V>> extractor) {
     List<V> result = FieldsOrPropertiesExtractor.extract(actual, extractor).stream()
                                                 .flatMap(Collection::stream)
@@ -1413,18 +1557,18 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   }
 
   /**
-   * Extract multiple values from each {@code Iterable}'s element according to the given {@code Function}s
-   * and concatenate/flatten the extracted values in a list that is used as the new object under test.
+   * Extracts multiple values from each {@code Iterable}'s element according to the given {@code Function}s and
+   * concatenates/flattens them in a list that becomes the instance under test.
    * <p>
-   * If extracted values were not flattened, instead of a simple list like (given 2 extractors) :
-   * <pre>element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
-   * we would get a list of list like :
-   * <pre>list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
+   * If extracted values were not flattened, instead of a simple list like (given 2 extractors):
+   * <pre>  element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
+   * we would get a list of list like:
+   * <pre>  list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
    * <p>
-   * Code example:
+   * Example:
    * <pre><code class='java'> // fellowshipOfTheRing is a List&lt;TolkienCharacter&gt;
    *
-   * // values are extracted in order and flattened : age1, name1, age2, name2, age3 ...
+   * // values are extracted in order and flattened: age1, name1, age2, name2, age3 ...
    * assertThat(fellowshipOfTheRing).flatExtracting(TolkienCharacter::getAge,
    *                                                TolkienCharacter::getName)
    *                                .contains(33 ,"Frodo",
@@ -1432,33 +1576,68 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *                                          87, "Aragorn");</code></pre>
    *
    * The resulting extracted values list is ordered by {@code Iterable}'s element first and then extracted values,
-   * this is why is in the example that age values come before names.
+   * this is why is in the example age values come before names.
    *
    * @param extractors all the extractors to apply on each actual {@code Iterable}'s elements
    * @return a new assertion object whose object under test is a flattened list of all extracted values.
    */
   @CheckReturnValue
   public AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> flatExtracting(@SuppressWarnings("unchecked") Function<? super ELEMENT, ?>... extractors) {
+    return doFlaExtracting(extractors);
+  }
+
+  /**
+   * Maps multiple values from each {@code Iterable}'s element according to the given {@code Function}s
+   * and concatenates/flattens them in a list that becomes the instance under test.
+   * <p>
+   * If mapped values were not flattened, instead of a simple list like (given 2 extractors):
+   * <pre>  element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
+   * we would get a list of list like:
+   * <pre>  list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
+   * <p>
+   * Example:
+   * <pre><code class='java'> // fellowshipOfTheRing is a List&lt;TolkienCharacter&gt;
+   *
+   * // values are extracted in order and flattened: age1, name1, age2, name2, age3 ...
+   * assertThat(fellowshipOfTheRing).flatMap(TolkienCharacter::getAge,
+   *                                         TolkienCharacter::getName)
+   *                                .contains(33 ,"Frodo",
+   *                                          1000, "Legolas",
+   *                                          87, "Aragorn");</code></pre>
+   *
+   * The resulting mapped values list is ordered by {@code Iterable}'s element first and then mapped values, this is why is
+   * in the example age values come before names.
+   *
+   * @param mappers all the mappers to apply on each actual {@code Iterable}'s elements
+   * @return a new assertion object whose object under test is a flattened list of all mapped values.
+   * @since 3.19.0
+   */
+  @CheckReturnValue
+  public AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> flatMap(@SuppressWarnings("unchecked") Function<? super ELEMENT, ?>... mappers) {
+    return doFlaExtracting(mappers);
+  }
+
+  @SafeVarargs
+  private final AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> doFlaExtracting(Function<? super ELEMENT, ?>... extractors) {
     Stream<? extends ELEMENT> actualStream = stream(actual.spliterator(), false);
-    List<Object> result = actualStream.flatMap(element -> Stream.of(extractors)
-                                                                .map(extractor -> extractor.apply(element)))
+    List<Object> result = actualStream.flatMap(element -> Stream.of(extractors).map(extractor -> extractor.apply(element)))
                                       .collect(toList());
     return newListAssertInstanceForMethodsChangingElementType(result);
   }
 
   /**
-   * Extract multiple values from each {@code Iterable}'s element according to the given {@link ThrowingExtractor}s
-   * and concatenate/flatten the extracted values in a list that is used as the new object under test.
+   * Extracts multiple values from each {@code Iterable}'s element according to the given {@link ThrowingExtractor}s
+   * and concatenates/flattens them in a list that becomes the object under test.
    * <p>
-   * If extracted values were not flattened, instead of a simple list like (given 2 extractors) :
-   * <pre>element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
-   * we would get a list of list like :
-   * <pre>list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
+   * If extracted values were not flattened, instead of a simple list like (given 2 extractors):
+   * <pre>  element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
+   * we would get a list of list like:
+   * <pre>  list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
    * <p>
-   * Code example:
+   * Example:
    * <pre><code class='java'> // fellowshipOfTheRing is a List&lt;TolkienCharacter&gt;
    *
-   * // values are extracted in order and flattened : age1, name1, age2, name2, age3 ...
+   * // values are extracted in order and flattened: age1, name1, age2, name2, age3 ...
    * assertThat(fellowshipOfTheRing).flatExtracting(input -&gt; {
    *   if (input.getAge() &lt; 20) {
    *     throw new Exception("age &lt; 20");
@@ -1474,7 +1653,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *     87, "Aragorn");</code></pre>
    *
    * The resulting extracted values list is ordered by {@code Iterable}'s element first and then extracted values,
-   * this is why is in the example that age values come before names.
+   * this is why is in the example age values come before names.
    *
    * @param <EXCEPTION> the exception type of {@link ThrowingExtractor}
    * @param extractors all the extractors to apply on each actual {@code Iterable}'s elements
@@ -1483,18 +1662,62 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    */
   @CheckReturnValue
   public <EXCEPTION extends Exception> AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> flatExtracting(@SuppressWarnings("unchecked") ThrowingExtractor<? super ELEMENT, ?, EXCEPTION>... extractors) {
+    return doFlatExtracting(extractors);
+  }
+
+  /**
+   * Maps multiple values from each {@code Iterable}'s element according to the given {@link ThrowingExtractor}s and
+   * concatenates/flattens them in a list that becomes the object under test.
+   * <p>
+   * If mapped values were not flattened, instead of a simple list like (given 2 mappers):
+   * <pre>  element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
+   * we would get a list of list like:
+   * <pre>  list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
+   * <p>
+   * Example:
+   * <pre><code class='java'> // fellowshipOfTheRing is a List&lt;TolkienCharacter&gt;
+   *
+   * // values are extracted in order and flattened: age1, name1, age2, name2, age3 ...
+   * assertThat(fellowshipOfTheRing).flatMap(input -&gt; {
+   *   if (input.getAge() &lt; 20) {
+   *     throw new Exception("age &lt; 20");
+   *   }
+   *   return input.getName();
+   * }, input2 -&gt; {
+   *   if (input2.getAge() &lt; 20) {
+   *     throw new Exception("age &lt; 20");
+   *   }
+   *   return input2.getAge();
+   * }).contains(33 ,"Frodo",
+   *     1000, "Legolas",
+   *     87, "Aragorn");</code></pre>
+   *
+   * The resulting mapped values list is ordered by {@code Iterable}'s element first and then mapped values, this is why is in
+   * the example age values come before names.
+   *
+   * @param <EXCEPTION> the exception type of {@link ThrowingExtractor}
+   * @param mappers all the mappers to apply on each actual {@code Iterable}'s elements
+   * @return a new assertion object whose object under test is a flattened list of all extracted values.
+   * @since 3.19.0
+   */
+  @CheckReturnValue
+  public <EXCEPTION extends Exception> AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> flatMap(@SuppressWarnings("unchecked") ThrowingExtractor<? super ELEMENT, ?, EXCEPTION>... mappers) {
+    return doFlatExtracting(mappers);
+  }
+
+  @SafeVarargs
+  private final <EXCEPTION extends Exception> AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> doFlatExtracting(ThrowingExtractor<? super ELEMENT, ?, EXCEPTION>... mappers) {
     Stream<? extends ELEMENT> actualStream = stream(actual.spliterator(), false);
-    List<Object> result = actualStream.flatMap(element -> Stream.of(extractors)
-                                                                .map(extractor -> extractor.apply(element)))
+    List<Object> result = actualStream.flatMap(element -> Stream.of(mappers).map(extractor -> extractor.apply(element)))
                                       .collect(toList());
     return newListAssertInstanceForMethodsChangingElementType(result);
   }
 
   /**
-   * Extract from Iterable's elements the Iterable/Array values corresponding to the given property/field name and
-   * concatenate them into a single list becoming the new object under test.
+   * Extract Iterable's elements values corresponding to the given property/field name and concatenates them into a list becoming
+   * the new instance under test.
    * <p>
-   * It allows testing the elements of extracting values that are represented by iterables or arrays.
+   * This allows testing the elements extracted values that are iterables or arrays.
    * <p>
    * For example:
    * <pre><code class='java'> CartoonCharacter bart = new CartoonCharacter("Bart Simpson");
@@ -1515,8 +1738,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * assertThat(parents).flatExtracting("children")
    *                    .containsOnly(bart, lisa, maggie, pebbles);</code></pre>
    *
-   * The order of extracted values is consisted with both the order of the collection itself, as well as the extracted
-   * collections.
+   * The order of extracted values is consisted with both the order of the iterable itself as well as the extracted collections.
    *
    * @param fieldOrPropertyName the object transforming input object to an Iterable of desired ones
    * @return a new assertion object whose object under test is the list of values extracted
@@ -1553,12 +1775,11 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * It allows you to test values from the {@link Iterable}'s elements instead of testing the elements themselves, which sometimes can be
    * much less work!
    * <p>
-   * The Tuple data corresponds to the extracted values from the Iterable's elements, for instance if you pass functions
+   * The {@link Tuple} data correspond to the extracted values from the Iterable's elements, for instance if you pass functions
    * extracting "id", "name" and "email" values then each Tuple data will be composed of an id, a name and an email
-   * extracted from the element of the initial Iterable (the Tuple's data order is the same as the given functions
-   * order).
+   * extracted from the element of the initial Iterable (the Tuple's data order is the same as the given functions order).
    * <p>
-   * Let's take a look at an example to make things clearer :
+   * Let's take a look at an example to make things clearer:
    * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
@@ -1572,7 +1793,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
    *
-   * // let's verify 'name', 'age' and Race of some TolkienCharacter in fellowshipOfTheRing :
+   * // let's verify 'name', 'age' and Race of some TolkienCharacter in fellowshipOfTheRing:
    * assertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getName,
    *                                            character -&gt; character.getAge(),
    *                                            TolkienCharacter::getRace)
@@ -1596,6 +1817,11 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    */
   @CheckReturnValue
   public AbstractListAssert<?, List<? extends Tuple>, Tuple, ObjectAssert<Tuple>> extracting(@SuppressWarnings("unchecked") Function<? super ELEMENT, ?>... extractors) {
+    return doExtracting(extractors);
+  }
+
+  @SafeVarargs
+  private final AbstractListAssert<?, List<? extends Tuple>, Tuple, ObjectAssert<Tuple>> doExtracting(Function<? super ELEMENT, ?>... extractors) {
     // combine all extractors into one function
     Function<ELEMENT, Tuple> tupleExtractor = objectToExtractValueFrom -> new Tuple(Stream.of(extractors)
                                                                                           .map(extractor -> extractor.apply(objectToExtractValueFrom))
@@ -1605,19 +1831,72 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return newListAssertInstanceForMethodsChangingElementType(tuples);
   }
 
+  /**
+   * Use the given {@link Function}s to map the {@link Iterable}'s elements into a {@link List} of {@link Tuple}s
+   * (a simple data structure containing the mapped values), this new list becoming the object under test.
+   * <p>
+   * This allows you to test values from the {@link Iterable}'s elements instead of testing the elements themselves, which
+   * sometimes can be much less work!
+   * <p>
+   * The {@link Tuple} data correspond to the extracted values from the Iterable's elements, for instance if you pass functions
+   * mapping "id", "name" and "email" values then each {@code Tuple} data will be composed of an id, a name and an email
+   * mapped from the element of the initial Iterable (the Tuple's data order is the same as the given functions order).
+   * <p>
+   * Let's take a look at an example to make things clearer:
+   * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
+   * // they can be public field or properties, both can be extracted.
+   * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
+   *
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Legolas&quot;, 1000, ELF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Pippin&quot;, 28, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
+   *
+   * // let's verify 'name', 'age' and Race of some TolkienCharacter in fellowshipOfTheRing:
+   * assertThat(fellowshipOfTheRing).map(TolkienCharacter::getName,
+   *                                     character -&gt; character.getAge(),
+   *                                     TolkienCharacter::getRace)
+   *                                .containsOnly(tuple(&quot;Frodo&quot;, 33, HOBBIT),
+   *                                              tuple(&quot;Sam&quot;, 38, HOBBIT),
+   *                                              tuple(&quot;Gandalf&quot;, 2020, MAIA),
+   *                                              tuple(&quot;Legolas&quot;, 1000, ELF),
+   *                                              tuple(&quot;Pippin&quot;, 28, HOBBIT),
+   *                                              tuple(&quot;Gimli&quot;, 139, DWARF),
+   *                                              tuple(&quot;Aragorn&quot;, 87, MAN),
+   *                                              tuple(&quot;Boromir&quot;, 37, MAN));</code></pre>
+   * You can use lambda expression or a method reference to extract the expected values.
+   * <p>
+   * Use {@link Tuple#tuple(Object...)} to initialize the expected values.
+   * <p>
+   * Note that the order of the extracted tuples list is consistent with the iteration order of the Iterable under test,
+   * for example if it's a {@link HashSet}, you won't be able to make any assumptions on the extracted tuples order.
+   *
+   * @param mappers the mapper functions to extract a value from an element of the Iterable under test.
+   * @return a new assertion object whose object under test is the list of Tuples containing the extracted values.
+   * @since 3.19.0
+   */
+  @CheckReturnValue
+  public AbstractListAssert<?, List<? extends Tuple>, Tuple, ObjectAssert<Tuple>> map(@SuppressWarnings("unchecked") Function<? super ELEMENT, ?>... mappers) {
+    return doExtracting(mappers);
+  }
+
   /**
    * Extract the given property/field values from each {@code Iterable}'s element and
    * flatten the extracted values in a list that is used as the new object under test.
    * <p>
-   * Given 2 properties, if the extracted values were not flattened, instead having a simple list like :
-   * <pre>element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
-   * ... we would get a list of list :
-   * <pre>list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
+   * Given 2 properties, if the extracted values were not flattened, instead having a simple list like:
+   * <pre>  element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
+   * ... we would get a list of list:
+   * <pre>  list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
    * <p>
-   * Code example:
+   * Example:
    * <pre><code class='java'> // fellowshipOfTheRing is a List&lt;TolkienCharacter&gt;
    *
-   * // values are extracted in order and flattened : age1, name1, age2, name2, age3 ...
+   * // values are extracted in order and flattened: age1, name1, age2, name2, age3 ...
    * assertThat(fellowshipOfTheRing).flatExtracting("age", "name")
    *                                .contains(33 ,"Frodo",
    *                                          1000, "Legolas",
@@ -2386,7 +2665,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * Filters the iterable under test keeping only elements having a property or field matching the filter expressed with
    * the {@link FilterOperator}, the property/field is specified by {@code propertyOrFieldName} parameter.
    * <p>
-   * The existing filters are :
+   * The existing filters are:
    * <ul>
    * <li> {@link Assertions#not(Object) not(Object)}</li>
    * <li> {@link Assertions#in(Object...) in(Object...)}</li>
@@ -2402,7 +2681,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
    * <p>
    *
-   * As an example, let's check stuff on some special employees :
+   * As an example, let's check stuff on some special employees:
    * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
@@ -2459,7 +2738,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <p>
    * If you prefer {@link Predicate} over {@link Condition}, use {@link #filteredOn(Predicate)}.
    * <p>
-   * Example : check old employees whose age &gt; 100:
+   * Example: check old employees whose age &gt; 100:
    * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
@@ -2533,7 +2812,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   /**
    * Filters the iterable under test keeping only elements matching the given assertions specified with a {@link Consumer}.
    * <p>
-   * Example : check young hobbits whose age &lt; 34:
+   * Example: check young hobbits whose age &lt; 34:
    *
    * <pre><code class='java'> TolkienCharacter pippin = new TolkienCharacter("Pippin", 28, HOBBIT);
    * TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
@@ -2986,7 +3265,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   /**
    * Filters the iterable under test keeping only elements matching the given {@link Predicate}.
    * <p>
-   * Example : check old employees whose age &gt; 100:
+   * Example: check old employees whose age &gt; 100:
    *
    * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
diff --git a/src/main/java/org/assertj/core/api/IterableAssert.java b/src/main/java/org/assertj/core/api/IterableAssert.java
index df940698f..5ce5d8a6d 100644
--- a/src/main/java/org/assertj/core/api/IterableAssert.java
+++ b/src/main/java/org/assertj/core/api/IterableAssert.java
@@ -137,16 +137,34 @@ public class IterableAssert<ELEMENT> extends
     return super.flatExtracting(extractors);
   }
 
+  @Override
+  @SafeVarargs
+  public final <EXCEPTION extends Exception> AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> flatMap(ThrowingExtractor<? super ELEMENT, ?, EXCEPTION>... mappers) {
+    return super.flatMap(mappers);
+  }
+
   @Override
   @SafeVarargs
   public final AbstractListAssert<?, List<?>, Object, ObjectAssert<Object>> flatExtracting(Function<? super ELEMENT, ?>... extractors) {
     return super.flatExtracting(extractors);
   }
-  
+
+  @Override
+  @SafeVarargs
+  public final AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> flatMap(Function<? super ELEMENT, ?>... mappers) {
+    return super.flatMap(mappers);
+  }
+
   @Override
   @SafeVarargs
   public final AbstractListAssert<?, List<? extends Tuple>, Tuple, ObjectAssert<Tuple>> extracting(Function<? super ELEMENT, ?>... extractors) {
     return super.extracting(extractors);
   }
 
+  @Override
+  @SafeVarargs
+  public final AbstractListAssert<?, List<? extends Tuple>, Tuple, ObjectAssert<Tuple>> map(Function<? super ELEMENT, ?>... mappers) {
+    return super.extracting(mappers);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/ListAssert.java b/src/main/java/org/assertj/core/api/ListAssert.java
index 06474e789..ce6ae7abb 100644
--- a/src/main/java/org/assertj/core/api/ListAssert.java
+++ b/src/main/java/org/assertj/core/api/ListAssert.java
@@ -329,16 +329,34 @@ public class ListAssert<ELEMENT> extends
     return super.extracting(extractors);
   }
 
+  @Override
+  @SafeVarargs
+  public final AbstractListAssert<?, List<? extends Tuple>, Tuple, ObjectAssert<Tuple>> map(Function<? super ELEMENT, ?>... mappers) {
+    return super.map(mappers);
+  }
+
   @Override
   @SafeVarargs
   public final <EXCEPTION extends Exception> AbstractListAssert<?, List<?>, Object, ObjectAssert<Object>> flatExtracting(ThrowingExtractor<? super ELEMENT, ?, EXCEPTION>... extractors) {
     return super.flatExtracting(extractors);
   }
 
+  @Override
+  @SafeVarargs
+  public final <EXCEPTION extends Exception> AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> flatMap(ThrowingExtractor<? super ELEMENT, ?, EXCEPTION>... mappers) {
+    return super.flatMap(mappers);
+  }
+
   @Override
   @SafeVarargs
   public final AbstractListAssert<?, List<?>, Object, ObjectAssert<Object>> flatExtracting(Function<? super ELEMENT, ?>... extractors) {
     return super.flatExtracting(extractors);
   }
 
+  @Override
+  @SafeVarargs
+  public final AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> flatMap(Function<? super ELEMENT, ?>... mappers) {
+    return super.flatMap(mappers);
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
index 1d5ca047f..c5e9076df 100644
--- a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
@@ -1141,9 +1141,40 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
           .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
           .as("filteredOn with consumer")
           .hasSize(5);
+    softly.then(characters)
+          .flatMap(childrenExtractor)
+          .as("using flatMap on Iterable")
+          .containsAnyOf(homer, fred);
+    softly.then(characters)
+          .flatMap(CartoonCharacter::getChildrenWithException)
+          .as("using flatMap on Iterable with exception")
+          .containsExactlyInAnyOrder(homer, fred);
+    softly.then(names)
+          .flatMap(firstNameFunction, lastNameFunction)
+          .as("flatMap with multiple Extractors")
+          .contains("John", "Jane", "Doe")
+          .contains("Sauron");
+    softly.then(names)
+          .flatMap(throwingFirstNameExtractor, throwingLastNameExtractor)
+          .as("flatMap with multiple ThrowingExtractors")
+          .contains("John", "Jane", "Doe")
+          .contains("Sauron");
+    softly.then(names)
+          .map(throwingFirstNameExtractor)
+          .as("map with ThrowingExtractor")
+          .contains("frodo");
+    softly.then(names)
+          .map(firstNameFunction)
+          .as("map with function")
+          .contains("sam");
+    softly.then(names)
+          .map(firstNameFunction, lastNameFunction)
+          .as("map with multiple functions")
+          .contains(tuple("John", "Doe"))
+          .contains(tuple("Frodo", "Baggins"));
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(33);
+    assertThat(errorsCollected).hasSize(40);
     assertThat(errorsCollected.get(0)).hasMessageContaining("gandalf");
     assertThat(errorsCollected.get(1)).hasMessageContaining("frodo");
     assertThat(errorsCollected.get(2)).hasMessageContaining("foo")
@@ -1178,6 +1209,13 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(30)).hasMessageContaining("using flatExtracting(String... fieldOrPropertyNames)");
     assertThat(errorsCollected.get(31)).hasMessageContaining("using flatExtracting(String fieldOrPropertyName)");
     assertThat(errorsCollected.get(32)).hasMessageContaining("filteredOn with consumer");
+    assertThat(errorsCollected.get(33)).hasMessageContaining("using flatMap on Iterable");
+    assertThat(errorsCollected.get(34)).hasMessageContaining("using flatMap on Iterable with exception");
+    assertThat(errorsCollected.get(35)).hasMessageContaining("flatMap with multiple Extractors");
+    assertThat(errorsCollected.get(36)).hasMessageContaining("flatMap with multiple ThrowingExtractors");
+    assertThat(errorsCollected.get(37)).hasMessageContaining("map with ThrowingExtractor");
+    assertThat(errorsCollected.get(38)).hasMessageContaining("map with function");
+    assertThat(errorsCollected.get(39)).hasMessageContaining("map with multiple functions");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
@@ -1295,9 +1333,40 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
           .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
           .as("filteredOn with consumer")
           .hasSize(5);
+    softly.then(names)
+          .flatMap(firstNameFunction, lastNameFunction)
+          .as("flatMap with multiple Extractors")
+          .contains("John", "Jane", "Doe")
+          .contains("Sauron");
+    softly.then(names)
+          .flatMap(throwingFirstNameExtractor, throwingLastNameExtractor)
+          .as("flatMap with multiple ThrowingExtractors")
+          .contains("John", "Jane", "Doe")
+          .contains("Sauron");
+    softly.then(characters)
+          .flatMap(CartoonCharacter::getChildren)
+          .as("using flatMap on Iterable")
+          .containsAnyOf(homer, fred);
+    softly.then(characters)
+          .flatMap(CartoonCharacter::getChildrenWithException)
+          .as("using flatMap on Iterable with exception")
+          .containsExactlyInAnyOrder(homer, fred);
+    softly.then(names)
+          .map(throwingFirstNameExtractor)
+          .as("using map with ThrowingExtractor")
+          .contains("frodo");
+    softly.then(names)
+          .map(firstNameFunction)
+          .as("map with function")
+          .contains("sam");
+    softly.then(names)
+          .map(firstNameFunction, lastNameFunction)
+          .as("map with multiple functions")
+          .contains(tuple("John", "Doe"))
+          .contains(tuple("Frodo", "Baggins"));
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(33);
+    assertThat(errorsCollected).hasSize(40);
     assertThat(errorsCollected.get(0)).hasMessageContaining("gandalf");
     assertThat(errorsCollected.get(1)).hasMessageContaining("frodo");
     assertThat(errorsCollected.get(2)).hasMessageContaining("foo")
@@ -1332,6 +1401,13 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(30)).hasMessageContaining("using flatExtracting(String... fieldOrPropertyNames)");
     assertThat(errorsCollected.get(31)).hasMessageContaining("using flatExtracting(String fieldOrPropertyName)");
     assertThat(errorsCollected.get(32)).hasMessageContaining("filteredOn with consumer");
+    assertThat(errorsCollected.get(33)).hasMessageContaining("flatMap with multiple Extractors");
+    assertThat(errorsCollected.get(34)).hasMessageContaining("flatMap with multiple ThrowingExtractors");
+    assertThat(errorsCollected.get(35)).hasMessageContaining("using flatMap on Iterable");
+    assertThat(errorsCollected.get(36)).hasMessageContaining("using flatMap on Iterable with exception");
+    assertThat(errorsCollected.get(37)).hasMessageContaining("using map with ThrowingExtractor");
+    assertThat(errorsCollected.get(38)).hasMessageContaining("map with function");
+    assertThat(errorsCollected.get(39)).hasMessageContaining("map with multiple functions");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index b286e1330..213e0edba 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -1413,9 +1413,45 @@ class SoftAssertionsTest extends BaseAssertionsTest {
           .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
           .as("filteredOn with consumer")
           .hasSize(5);
+    softly.assertThat(characters)
+          .as("using flatMap on Iterable")
+          .overridingErrorMessage("error message")
+          .flatMap(childrenExtractor)
+          .containsAnyOf(homer, fred);
+    softly.assertThat(characters)
+          .as("using flatMap on Iterable with exception")
+          .overridingErrorMessage("error message")
+          .flatMap(CartoonCharacter::getChildrenWithException)
+          .containsExactlyInAnyOrder(homer, fred);
+    softly.assertThat(names)
+          .overridingErrorMessage("error message")
+          .as("flatMap with multiple Extractors")
+          .flatMap(firstNameFunction, lastNameFunction)
+          .contains("John", "Jane", "Doe")
+          .contains("Sauron");
+    softly.assertThat(names)
+          .overridingErrorMessage("error message")
+          .as("flatMap with multiple ThrowingExtractors")
+          .flatMap(throwingFirstNameFunction, throwingLastNameFunction)
+          .contains("John", "Jane", "Doe")
+          .contains("Sauron");
+    softly.assertThat(names)
+          .as("map(throwingFirstNameFunction)")
+          .overridingErrorMessage("error message")
+          .map(throwingFirstNameFunction)
+          .contains("frodo");
+    softly.assertThat(names)
+          .as("map(firstNameFunction)")
+          .map(firstNameFunction)
+          .contains("sam");
+    softly.assertThat(names)
+          .map(firstNameFunction, lastNameFunction)
+          .as("map with multiple functions")
+          .contains(tuple("John", "Doe"))
+          .contains(tuple("Frodo", "Baggins"));
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(33);
+    assertThat(errorsCollected).hasSize(40);
     assertThat(errorsCollected.get(0)).hasMessage("[extracting(throwingFirstNameFunction)] error message");
     assertThat(errorsCollected.get(1)).hasMessage("[extracting(throwingFirstNameFunction)] error message");
     assertThat(errorsCollected.get(2)).hasMessage("[extracting(\"last\")] error message");
@@ -1449,6 +1485,13 @@ class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(30)).hasMessage("[using flatExtracting(String... fieldOrPropertyNames)] error message");
     assertThat(errorsCollected.get(31)).hasMessage("[using flatExtracting(String fieldOrPropertyName)] error message");
     assertThat(errorsCollected.get(32)).hasMessage("[filteredOn with consumer] error message");
+    assertThat(errorsCollected.get(33)).hasMessageContaining("using flatMap on Iterable");
+    assertThat(errorsCollected.get(34)).hasMessageContaining("using flatMap on Iterable with exception");
+    assertThat(errorsCollected.get(35)).hasMessageContaining("flatMap with multiple Extractors");
+    assertThat(errorsCollected.get(36)).hasMessageContaining("flatMap with multiple ThrowingExtractors");
+    assertThat(errorsCollected.get(37)).hasMessageContaining("map(throwingFirstNameFunction)");
+    assertThat(errorsCollected.get(38)).hasMessageContaining("map(firstNameFunction)");
+    assertThat(errorsCollected.get(39)).hasMessageContaining("map with multiple functions");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
@@ -1597,9 +1640,45 @@ class SoftAssertionsTest extends BaseAssertionsTest {
           .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
           .as("filteredOn with consumer")
           .hasSize(5);
+    softly.assertThat(names)
+          .overridingErrorMessage("error message")
+          .as("flatMap with multiple Extractors")
+          .flatMap(firstNameFunction, lastNameFunction)
+          .contains("John", "Jane", "Doe")
+          .contains("Sauron");
+    softly.assertThat(names)
+          .overridingErrorMessage("error message")
+          .as("flatMap with multiple ThrowingExtractors")
+          .flatMap(throwingFirstNameFunction, throwingLastNameFunction)
+          .contains("John", "Jane", "Doe")
+          .contains("Sauron");
+    softly.assertThat(characters)
+          .as("using flatMap on Iterable")
+          .overridingErrorMessage("error message")
+          .flatMap(childrenExtractor)
+          .containsAnyOf(homer, fred);
+    softly.assertThat(characters)
+          .as("using flatMap on Iterable with exception")
+          .overridingErrorMessage("error message")
+          .flatMap(CartoonCharacter::getChildrenWithException)
+          .containsExactlyInAnyOrder(homer, fred);
+    softly.assertThat(names)
+          .as("map(throwingFirstNameFunction)")
+          .overridingErrorMessage("error message")
+          .map(throwingFirstNameFunction)
+          .contains("frodo");
+    softly.assertThat(names)
+          .as("map(firstNameFunction)")
+          .map(firstNameFunction)
+          .contains("sam");
+    softly.assertThat(names)
+          .map(firstNameFunction, lastNameFunction)
+          .as("map with multiple functions")
+          .contains(tuple("John", "Doe"))
+          .contains(tuple("Frodo", "Baggins"));
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(33);
+    assertThat(errorsCollected).hasSize(40);
     assertThat(errorsCollected.get(0)).hasMessage("[extracting(throwingFirstNameFunction)] error message");
     assertThat(errorsCollected.get(1)).hasMessage("[extracting(throwingFirstNameFunction)] error message");
     assertThat(errorsCollected.get(2)).hasMessage("[extracting(\"last\")] error message");
@@ -1633,6 +1712,13 @@ class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(30)).hasMessage("[using flatExtracting(String... fieldOrPropertyNames)] error message");
     assertThat(errorsCollected.get(31)).hasMessage("[using flatExtracting(String fieldOrPropertyName)] error message");
     assertThat(errorsCollected.get(32)).hasMessage("[filteredOn with consumer] error message");
+    assertThat(errorsCollected.get(33)).hasMessageContaining("flatMap with multiple Extractors");
+    assertThat(errorsCollected.get(34)).hasMessageContaining("flatMap with multiple ThrowingExtractors");
+    assertThat(errorsCollected.get(35)).hasMessageContaining("using flatMap on Iterable");
+    assertThat(errorsCollected.get(36)).hasMessageContaining("using flatMap on Iterable with exception");
+    assertThat(errorsCollected.get(37)).hasMessageContaining("map(throwingFirstNameFunction)");
+    assertThat(errorsCollected.get(38)).hasMessageContaining("map(firstNameFunction)");
+    assertThat(errorsCollected.get(39)).hasMessageContaining("map with multiple functions");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
diff --git a/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_various_java_8_types_Test.java b/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_various_java_8_types_Test.java
index 823ae4de3..c548a6894 100644
--- a/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_various_java_8_types_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_various_java_8_types_Test.java
@@ -14,7 +14,6 @@ package org.assertj.core.api.assumptions;
 
 import static java.util.concurrent.CompletableFuture.completedFuture;
 import static org.assertj.core.api.Assertions.assertThatCode;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assumptions.assumeThat;
 import static org.assertj.core.api.Assumptions.assumeThatCode;
 import static org.assertj.core.util.AssertionsUtil.expectAssumptionNotMetException;
@@ -44,7 +43,6 @@ import java.util.stream.Stream;
 import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
-import org.opentest4j.TestAbortedException;
 
 class Assumptions_assumeThat_with_various_java_8_types_Test {
 
diff --git a/src/test/java/org/assertj/core/api/assumptions/BaseAssumptionsRunnerTest.java b/src/test/java/org/assertj/core/api/assumptions/BaseAssumptionsRunnerTest.java
index 47ac6452d..5cc2b6ef3 100644
--- a/src/test/java/org/assertj/core/api/assumptions/BaseAssumptionsRunnerTest.java
+++ b/src/test/java/org/assertj/core/api/assumptions/BaseAssumptionsRunnerTest.java
@@ -15,7 +15,6 @@ package org.assertj.core.api.assumptions;
 import static org.assertj.core.api.Assertions.assertThatCode;
 import static org.assertj.core.util.AssertionsUtil.expectAssumptionNotMetException;
 
-import java.util.Collection;
 import java.util.function.Function;
 
 import org.assertj.core.api.Assertions;
@@ -49,7 +48,6 @@ public abstract class BaseAssumptionsRunnerTest {
   protected static Function<? super TolkienCharacter, Integer> ageExtractor;
   protected static Function<TolkienCharacter, String> nameExtractorFunction;
   protected static Function<TolkienCharacter, Integer> ageExtractorFunction;
-  protected static Function<? super CartoonCharacter, ? extends Collection<CartoonCharacter>> childrenExtractor;
 
   private static void setupData() {
     bart = new CartoonCharacter("Bart Simpson");
@@ -74,7 +72,6 @@ public abstract class BaseAssumptionsRunnerTest {
 
     frodo = TolkienCharacter.of("Frodo", 33, Race.HOBBIT);
     sam = TolkienCharacter.of("Sam", 35, Race.HOBBIT);
-    childrenExtractor = CartoonCharacter::getChildren;
   }
 
   @ParameterizedTest
diff --git a/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java b/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
index 7d1868733..7c74a1e13 100644
--- a/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
@@ -33,6 +33,7 @@ import org.assertj.core.test.CartoonCharacter;
  */
 class Iterable_special_assertion_methods_in_assumptions_Test extends BaseAssumptionsRunnerTest {
 
+  @SuppressWarnings("unchecked")
   public static Stream<AssumptionRunner<?>> provideAssumptionsRunners() {
     return Stream.of(
                      // extracting methods
@@ -41,11 +42,21 @@ class Iterable_special_assertion_methods_in_assumptions_Test extends BaseAssumpt
                                                                 .contains("Frodo"),
                                       value -> assumeThat(value).extracting(throwingNameExtractor)
                                                                 .contains("Gandalf")),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).map(throwingNameExtractor)
+                                                                .contains("Frodo"),
+                                      value -> assumeThat(value).map(throwingNameExtractor)
+                                                                .contains("Gandalf")),
                      assumptionRunner(iterable(frodo, sam),
                                       value -> assumeThat(value).extracting(nameExtractor)
                                                                 .contains("Frodo", "Sam"),
                                       value -> assumeThat(value).extracting(nameExtractor)
                                                                 .contains("Gandalf", "Sam")),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).map(nameExtractor)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).map(nameExtractor)
+                                                                .contains("Gandalf", "Sam")),
                      assumptionRunner(iterable(frodo, sam),
                                       value -> assumeThat(value).extracting("name")
                                                                 .contains("Frodo", "Sam"),
@@ -66,11 +77,21 @@ class Iterable_special_assertion_methods_in_assumptions_Test extends BaseAssumpt
                                                                 .contains(tuple("Frodo", 33)),
                                       value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
                                                                 .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).map(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).map(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Gandalf", 1000))),
                      assumptionRunner(iterable(frodo, sam),
                                       value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
                                                                 .contains(tuple("Frodo", 33)),
                                       value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
                                                                 .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).map(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).map(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Gandalf", 1000))),
                      // extractingResultOf methods
                      assumptionRunner(iterable(frodo, sam),
                                       value -> assumeThat(value).extractingResultOf("getName")
@@ -89,14 +110,14 @@ class Iterable_special_assertion_methods_in_assumptions_Test extends BaseAssumpt
                                       value -> assumeThat(value).flatExtracting("children")
                                                                 .containsAnyOf(homer, fred)),
                      assumptionRunner(iterable(homer, fred),
-                                      value -> assumeThat(value).flatExtracting(childrenExtractor)
+                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
                                                                 .containsAnyOf(bart, lisa),
-                                      value -> assumeThat(value).flatExtracting(childrenExtractor)
+                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
                                                                 .containsAnyOf(homer, fred)),
                      assumptionRunner(iterable(homer, fred),
-                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
+                                      value -> assumeThat(value).flatMap(CartoonCharacter::getChildren)
                                                                 .containsAnyOf(bart, lisa),
-                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
+                                      value -> assumeThat(value).flatMap(CartoonCharacter::getChildren)
                                                                 .containsAnyOf(homer, fred)),
                      assumptionRunner(iterable(frodo, sam),
                                       value -> assumeThat(value).flatExtracting(throwingNameExtractor, throwingAgeExtractor)
@@ -108,6 +129,16 @@ class Iterable_special_assertion_methods_in_assumptions_Test extends BaseAssumpt
                                                                 .contains("Frodo", 33),
                                       value -> assumeThat(value).flatExtracting(nameExtractor, ageExtractor)
                                                                 .contains("Gandalf", 1000)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).flatMap(throwingNameExtractor, throwingAgeExtractor)
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatMap(throwingNameExtractor, throwingAgeExtractor)
+                                                                .contains("Gandalf", 1000)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).flatMap(nameExtractor, ageExtractor)
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatMap(nameExtractor, ageExtractor)
+                                                                .contains("Gandalf", 1000)),
                      assumptionRunner(iterable(frodo, sam),
                                       value -> assumeThat(value).flatExtracting("name", "age")
                                                                 .contains("Frodo", 33),
diff --git a/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java b/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java
index 285f26fd9..e8fd5a13c 100644
--- a/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java
@@ -20,181 +20,215 @@ import static org.assertj.core.api.Assumptions.assumeThat;
 import static org.assertj.core.api.assumptions.BaseAssumptionRunner.assumptionRunner;
 import static org.assertj.core.util.IterableUtil.iterable;
 
+import java.util.stream.Stream;
+
 import org.assertj.core.api.Condition;
 import org.assertj.core.api.ListAssert;
 import org.assertj.core.api.ProxyableListAssert;
 import org.assertj.core.data.TolkienCharacter;
 import org.assertj.core.test.CartoonCharacter;
 
-import java.util.stream.Stream;
-
 /**
  * verify that assertions final methods or methods changing the object under test in {@link ListAssert} work with assumptions
  * (i.e. that they are proxied correctly in {@link ProxyableListAssert}).
  */
 class List_special_assertion_methods_in_assumptions_Test extends BaseAssumptionsRunnerTest {
 
+  @SuppressWarnings("unchecked")
   public static Stream<AssumptionRunner<?>> provideAssumptionsRunners() {
     return Stream.of(
-        // extracting methods
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).extracting(throwingNameExtractor)
-                                      .contains("Frodo"),
-            value -> assumeThat(value).extracting(throwingNameExtractor)
-                                      .contains("Gandalf")),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).extracting(nameExtractor)
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extracting(nameExtractor)
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).extracting("name")
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extracting("name")
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).extracting("name", String.class)
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extracting("name", String.class)
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).extracting("name", "age")
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).extracting("name", "age")
-                                      .contains(tuple("Gandalf", 1000))),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
-                                      .contains(tuple("Gandalf", 1000))),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
-                                      .contains(tuple("Gandalf", 1000))),
-        // extractingResultOf methods
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).extractingResultOf("getName")
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extractingResultOf("getName")
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).extractingResultOf("getName", String.class)
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extractingResultOf("getName", String.class)
-                                      .contains("Gandalf", "Sam")),
-        // flatExtracting methods
-        assumptionRunner(asList(homer, fred),
-            value -> assumeThat(value).flatExtracting("children")
-                                      .containsAnyOf(bart, lisa),
-            value -> assumeThat(value).flatExtracting("children")
-                                      .containsAnyOf(homer, fred)),
-        assumptionRunner(asList(homer, fred),
-            value -> assumeThat(value).flatExtracting(childrenExtractor)
-                                      .containsAnyOf(bart, lisa),
-            value -> assumeThat(value).flatExtracting(childrenExtractor)
-                                      .containsAnyOf(homer, fred)),
-        assumptionRunner(asList(homer, fred),
-            value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
-                                      .containsAnyOf(bart, lisa),
-            value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
-                                      .containsAnyOf(homer, fred)),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).flatExtracting(throwingNameExtractor, throwingAgeExtractor)
-                                      .contains("Frodo", 33),
-            value -> assumeThat(value).flatExtracting(throwingNameExtractor, throwingAgeExtractor)
-                                      .contains("Gandalf", 1000)),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).flatExtracting(nameExtractor, ageExtractor)
-                                      .contains("Frodo", 33),
-            value -> assumeThat(value).flatExtracting(nameExtractor, ageExtractor)
-                                      .contains("Gandalf", 1000)),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).flatExtracting("name", "age")
-                                      .contains("Frodo", 33),
-            value -> assumeThat(value).flatExtracting("name", "age")
-                                      .contains("Gandalf", 1000)),
-        // filteredOn methods
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .contains(sam)),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName().startsWith("Fro"), "startsWith Fro"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName().startsWith("Fro"), "startsWith Fro"))
-                                      .contains(sam)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
-                                      .contains(sam)),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).filteredOn("name", "Frodo")
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn("name", "Frodo")
-                                      .contains(sam)),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).filteredOnNull("name")
-                                      .isEmpty(),
-            value -> assumeThat(value).filteredOnNull("name")
-                                      .contains(sam)),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
-                                      .contains(sam)),
-        assumptionRunner(asList(frodo, sam),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .extracting("name", "age")
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .extracting("name", "age")
-                                      .contains(tuple("Sam", 35))),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).contains(1, 2),
-            value -> assumeThat(value).contains(4)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).containsAnyOf(1, 10, 20),
-            value -> assumeThat(value).containsAnyOf(0, 5, 10)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).containsExactly(1, 2, 3),
-            value -> assumeThat(value).containsExactly(4)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).containsExactlyInAnyOrder(2, 1, 3),
-            value -> assumeThat(value).containsExactlyInAnyOrder(1, 2)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).containsOnly(2, 1, 3, 2),
-            value -> assumeThat(value).containsOnly(1, 2, 4)),
-        assumptionRunner(asList(2, 4, 2),
-            value -> assumeThat(value).containsOnlyOnce(4),
-            value -> assumeThat(value).containsOnlyOnce(2)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).containsSequence(1, 2),
-            value -> assumeThat(value).containsSequence(1, 3)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).containsSubsequence(1, 3),
-            value -> assumeThat(value).containsSubsequence(2, 1)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).doesNotContain(4, 5),
-            value -> assumeThat(value).doesNotContain(2, 1)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).doesNotContainSequence(1, 3),
-            value -> assumeThat(value).doesNotContainSequence(1, 2)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).doesNotContainSubsequence(2, 1),
-            value -> assumeThat(value).doesNotContainSubsequence(1, 3)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).isSubsetOf(1, 2, 3, 4),
-            value -> assumeThat(value).isSubsetOf(2, 4, 6)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).startsWith(1, 2),
-            value -> assumeThat(value).startsWith(2, 3)),
-        assumptionRunner(asList(1, 2, 3),
-            value -> assumeThat(value).endsWith(2, 3),
-            value -> assumeThat(value).endsWith(2, 4))
-    );
+                     // extracting methods
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).extracting(throwingNameExtractor)
+                                                                .contains("Frodo"),
+                                      value -> assumeThat(value).extracting(throwingNameExtractor)
+                                                                .contains("Gandalf")),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).map(throwingNameExtractor)
+                                                                .contains("Frodo"),
+                                      value -> assumeThat(value).map(throwingNameExtractor)
+                                                                .contains("Gandalf")),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).extracting(nameExtractor)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extracting(nameExtractor)
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).map(nameExtractor)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).map(nameExtractor)
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).extracting("name")
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extracting("name")
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).extracting("name", String.class)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extracting("name", String.class)
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).extracting("name", "age")
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).extracting("name", "age")
+                                                                .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).map(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).map(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).map(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).map(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Gandalf", 1000))),
+                     // extractingResultOf methods
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).extractingResultOf("getName")
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extractingResultOf("getName")
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).extractingResultOf("getName", String.class)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extractingResultOf("getName", String.class)
+                                                                .contains("Gandalf", "Sam")),
+                     // flatExtracting methods
+                     assumptionRunner(asList(homer, fred),
+                                      value -> assumeThat(value).flatExtracting("children")
+                                                                .containsAnyOf(bart, lisa),
+                                      value -> assumeThat(value).flatExtracting("children")
+                                                                .containsAnyOf(homer, fred)),
+                     assumptionRunner(asList(homer, fred),
+                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
+                                                                .containsAnyOf(bart, lisa),
+                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
+                                                                .containsAnyOf(homer, fred)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).flatExtracting(throwingNameExtractor, throwingAgeExtractor)
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatExtracting(throwingNameExtractor, throwingAgeExtractor)
+                                                                .contains("Gandalf", 1000)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).flatExtracting(nameExtractor, ageExtractor)
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatExtracting(nameExtractor, ageExtractor)
+                                                                .contains("Gandalf", 1000)),
+                     assumptionRunner(asList(homer, fred),
+                                      value -> assumeThat(value).flatMap(CartoonCharacter::getChildren)
+                                                                .containsAnyOf(bart, lisa),
+                                      value -> assumeThat(value).flatMap(CartoonCharacter::getChildren)
+                                                                .containsAnyOf(homer, fred)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).flatMap(throwingNameExtractor, throwingAgeExtractor)
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatMap(throwingNameExtractor, throwingAgeExtractor)
+                                                                .contains("Gandalf", 1000)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).flatMap(nameExtractor, ageExtractor)
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatMap(nameExtractor, ageExtractor)
+                                                                .contains("Gandalf", 1000)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).flatExtracting("name", "age")
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatExtracting("name", "age")
+                                                                .contains("Gandalf", 1000)),
+                     // filteredOn methods
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .contains(sam)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName()
+                                                                                                        .startsWith("Fro"),
+                                                                                            "startsWith Fro"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName()
+                                                                                                        .startsWith("Fro"),
+                                                                                            "startsWith Fro"))
+                                                                .contains(sam)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                                                .contains(sam)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).filteredOn("name", "Frodo")
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn("name", "Frodo")
+                                                                .contains(sam)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).filteredOnNull("name")
+                                                                .isEmpty(),
+                                      value -> assumeThat(value).filteredOnNull("name")
+                                                                .contains(sam)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
+                                                                .contains(sam)),
+                     assumptionRunner(asList(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Sam", 35))),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).contains(1, 2),
+                                      value -> assumeThat(value).contains(4)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).containsAnyOf(1, 10, 20),
+                                      value -> assumeThat(value).containsAnyOf(0, 5, 10)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).containsExactly(1, 2, 3),
+                                      value -> assumeThat(value).containsExactly(4)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).containsExactlyInAnyOrder(2, 1, 3),
+                                      value -> assumeThat(value).containsExactlyInAnyOrder(1, 2)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).containsOnly(2, 1, 3, 2),
+                                      value -> assumeThat(value).containsOnly(1, 2, 4)),
+                     assumptionRunner(asList(2, 4, 2),
+                                      value -> assumeThat(value).containsOnlyOnce(4),
+                                      value -> assumeThat(value).containsOnlyOnce(2)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).containsSequence(1, 2),
+                                      value -> assumeThat(value).containsSequence(1, 3)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).containsSubsequence(1, 3),
+                                      value -> assumeThat(value).containsSubsequence(2, 1)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).doesNotContain(4, 5),
+                                      value -> assumeThat(value).doesNotContain(2, 1)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).doesNotContainSequence(1, 3),
+                                      value -> assumeThat(value).doesNotContainSequence(1, 2)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).doesNotContainSubsequence(2, 1),
+                                      value -> assumeThat(value).doesNotContainSubsequence(1, 3)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).isSubsetOf(1, 2, 3, 4),
+                                      value -> assumeThat(value).isSubsetOf(2, 4, 6)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).startsWith(1, 2),
+                                      value -> assumeThat(value).startsWith(2, 3)),
+                     assumptionRunner(asList(1, 2, 3),
+                                      value -> assumeThat(value).endsWith(2, 3),
+                                      value -> assumeThat(value).endsWith(2, 4)));
   }
 
 }
