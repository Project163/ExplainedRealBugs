diff --git a/src/main/java/org/assertj/core/api/AbstractPathAssert.java b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
index 6d3f29bb2..adaca8663 100644
--- a/src/main/java/org/assertj/core/api/AbstractPathAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
@@ -1505,6 +1505,94 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
     return myself;
   }
 
+  /**
+   * Verify that the actual {@code Path} directory or any of its subdirectories (recursively) contains at least one file
+   * matching the given {@code String} interpreted as a path matcher (as per {@link FileSystem#getPathMatcher(String)}).
+   * <p>
+   * That methods performs the same assertion as {@link #isDirectoryContaining(String syntaxAndPattern)}  but recursively.
+   * <p>
+   * Note that the actual {@link Path} must exist and be a directory.
+   * <p>
+   * Examples given the following directory structure:
+   * <pre><code class="text"> root
+   * |—— foo
+   * |    |—— foobar
+   * |         |—— foo-file-1.ext
+   * |—— foo-file-2.ext</code>
+   * </pre>
+   *
+   * <pre><code class="java"> Path root = Paths.get("root");
+   *
+   * // The following assertions succeed:
+   * assertThat(root).isDirectoryRecursivelyContaining("glob:**foo")
+   *                 .isDirectoryRecursivelyContaining("glob:**ooba*")
+   *                 .isDirectoryRecursivelyContaining("glob:**file-1.ext")
+   *                 .isDirectoryRecursivelyContaining("regex:.*file-2.*")
+   *                 .isDirectoryRecursivelyContaining("glob:**.{ext,dummy}");
+   *
+   * // The following assertions fail:
+   * assertThat(root).isDirectoryRecursivelyContaining("glob:**fooba");
+   * assertThat(root).isDirectoryRecursivelyContaining("glob:**.bin");
+   * assertThat(root).isDirectoryRecursivelyContaining("glob:**.{java,class}"); </code></pre>
+   *
+   * @param syntaxAndPattern the syntax and pattern for {@link java.nio.file.PathMatcher} as described in {@link FileSystem#getPathMatcher(String)}.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given syntaxAndPattern is {@code null}.
+   * @throws AssertionError       if actual is {@code null}.
+   * @throws AssertionError       if actual does not exist.
+   * @throws AssertionError       if actual is not a directory.
+   * @throws AssertionError       if actual does not contain recursively any files matching the given path matcher.
+   * @see FileSystem#getPathMatcher(String)
+   * @since 3.16.0
+   */
+  public SELF isDirectoryRecursivelyContaining(String syntaxAndPattern) {
+    paths.assertIsDirectoryRecursivelyContaining(info, actual, syntaxAndPattern);
+    return myself;
+  }
+
+  /**
+   * Verify that the actual {@code Path} directory or any of its subdirectories (recursively) contains at least one file
+   * matching the given {@code Predicate<Path>}.
+   * <p>
+   * That methods performs the same assertion as {@link #isDirectoryContaining(Predicate filter)}  but recursively.
+   * <p>
+   * Note that the actual {@link Path} must exist and be a directory.
+   * <p>
+   * Examples given the following directory structure:
+   * <pre><code class="text"> root
+   * |—— foo
+   * |    |—— foobar
+   * |         |—— foo-file-1.ext
+   * |—— foo-file-2.ext</code>
+   * </pre>
+   *
+   * Here are some assertions examples:
+   * <pre><code class="java"> Path root = Paths.get("root");
+   *
+   * // The following assertions succeed:
+   * assertThat(root).isDirectoryRecursivelyContaining(file -&gt; file.getName().startsWith("foo-file-1"))
+   *                 .isDirectoryRecursivelyContaining(file -&gt; file.getName().endsWith("file-2.ext"))
+   *                 .isDirectoryRecursivelyContaining(file -&gt; file.getName().equals("foo"))
+   *                 .isDirectoryRecursivelyContaining(file -&gt; file.getParentFile().getName().equals("foo"))
+   *
+   * // The following assertions fail:
+   * assertThat(root).isDirectoryRecursivelyContaining(file -&gt; file.getName().equals("foo-file-1"))
+   * assertThat(root).isDirectoryRecursivelyContaining(file -&gt; file.getName().equals("foo/foobar")); </code></pre>
+   *
+   * @param filter the filter for files located inside {@code actual}'s directory.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given filter is {@code null}.
+   * @throws AssertionError       if actual is {@code null}.
+   * @throws AssertionError       if actual does not exist.
+   * @throws AssertionError       if actual is not a directory.
+   * @throws AssertionError       if actual does not contain recursively any files matching the given predicate.
+   * @since 3.16.0
+   */
+  public SELF isDirectoryRecursivelyContaining(Predicate<Path> filter) {
+    paths.assertIsDirectoryRecursivelyContaining(info, actual, filter);
+    return myself;
+  }
+
   /**
    * Verify that the actual {@code Path} is a directory that does not contain any files matching the given {@code Predicate<Path>}.
    * <p>
diff --git a/src/main/java/org/assertj/core/error/ShouldContainRecursively.java b/src/main/java/org/assertj/core/error/ShouldContainRecursively.java
index 26e212ef6..eab71a890 100644
--- a/src/main/java/org/assertj/core/error/ShouldContainRecursively.java
+++ b/src/main/java/org/assertj/core/error/ShouldContainRecursively.java
@@ -12,9 +12,8 @@
  */
 package org.assertj.core.error;
 
-import static org.assertj.core.util.Strings.escapePercent;
-
 import java.io.File;
+import java.nio.file.Path;
 import java.util.List;
 
 /**
@@ -25,18 +24,22 @@ import java.util.List;
  */
 public class ShouldContainRecursively extends BasicErrorMessageFactory {
 
-  public static ErrorMessageFactory directoryShouldContainRecursively(File actual, List<String> directoryContent,
+  public static ErrorMessageFactory directoryShouldContainRecursively(File actual, List<File> directoryContent,
+                                                                      String filterDescription) {
+    return new ShouldContainRecursively(actual, directoryContent, filterDescription);
+  }
+
+  public static ErrorMessageFactory directoryShouldContainRecursively(Path actual, List<Path> directoryContent,
                                                                       String filterDescription) {
     return new ShouldContainRecursively(actual, directoryContent, filterDescription);
   }
 
-  private ShouldContainRecursively(Object actual, List<String> directoryContent, String filterDescription) {
-    // not passing directoryContent and filterDescription as parameter to avoid AssertJ default String formatting
-    super("%nExpecting directory or any of its subdirectories(recursively):%n" +
-          "  <%s>%n" +
-          "to contain at least one file matching " + escapePercent(filterDescription) + " but there was none.%n" +
-          "The directory content was:%n  " + escapePercent(directoryContent.toString()),
-          actual);
+  private ShouldContainRecursively(Object actual, List<?> directoryContent, String filterDescription) {
+    super("%nExpecting directory or any of its subdirectories (recursively):%n" +
+          "   <%s>%n" +
+          "to contain at least one file matching %s but there was none.%n" +
+          "The directory content was:%n   %s",
+          actual, filterDescription, directoryContent);
   }
 
 }
diff --git a/src/main/java/org/assertj/core/internal/Files.java b/src/main/java/org/assertj/core/internal/Files.java
index 6926f736b..d939c44bb 100644
--- a/src/main/java/org/assertj/core/internal/Files.java
+++ b/src/main/java/org/assertj/core/internal/Files.java
@@ -507,18 +507,13 @@ public class Files {
     assertIsDirectoryNotContaining(info, actual, fileMatcher, format("the '%s' pattern", syntaxAndPattern));
   }
 
+  @VisibleForTesting
   public static List<String> toFileNames(List<File> files) {
     return files.stream()
                 .map(File::getName)
                 .collect(toList());
   }
 
-  public static List<String> toAbsolutePaths(List<File> files) {
-    return files.stream()
-                .map(File::getAbsolutePath)
-                .collect(toList());
-  }
-
   // non public section
 
   private List<File> filterDirectory(AssertionInfo info, File actual, Predicate<File> filter) {
@@ -551,22 +546,21 @@ public class Files {
     return toFileNames(directoryContent(info, actual));
   }
 
-  // BEGIN - recursively assertion private methods
   private boolean isDirectoryRecursivelyContaining(AssertionInfo info, File actual, Predicate<File> filter) {
     assertIsDirectory(info, actual);
-    try (Stream<File> fileStream = createRecursiveStreamOfFile(actual)) {
-      return fileStream.anyMatch(filter);
+    try (Stream<File> actualContent = recursiveContentOf(actual)) {
+      return actualContent.anyMatch(filter);
     }
   }
 
-  private List<File> directoryRecursiveContent(File actual) {
-    try (Stream<File> fileStream = createRecursiveStreamOfFile(actual)) {
+  private List<File> sortedRecursiveContent(File directory) {
+    try (Stream<File> fileStream = recursiveContentOf(directory)) {
       return fileStream.sorted(comparing(File::getAbsolutePath))
                        .collect(toList());
     }
   }
 
-  private Stream<File> createRecursiveStreamOfFile(File directory) {
+  private Stream<File> recursiveContentOf(File directory) {
     Path path = directory.toPath();
     try {
       return java.nio.file.Files.walk(path)
@@ -580,16 +574,10 @@ public class Files {
   private void assertIsDirectoryRecursivelyContaining(AssertionInfo info, File actual, Predicate<File> filter,
                                                       String filterPresentation) {
     if (!isDirectoryRecursivelyContaining(info, actual, filter)) {
-      throw failures.failure(info, directoryShouldContainRecursively(actual, directoryRecursiveContentDescription(actual),
-                                                                     filterPresentation));
+      throw failures.failure(info, directoryShouldContainRecursively(actual, sortedRecursiveContent(actual), filterPresentation));
     }
   }
 
-  private List<String> directoryRecursiveContentDescription(File actual) {
-    return toAbsolutePaths(directoryRecursiveContent(actual));
-  }
-  // END - recursively assertion private methods
-
   private static Predicate<File> fileMatcher(AssertionInfo info, File actual, String syntaxAndPattern) {
     assertNotNull(info, actual);
     PathMatcher pathMatcher = actual.toPath().getFileSystem().getPathMatcher(syntaxAndPattern);
diff --git a/src/main/java/org/assertj/core/internal/Paths.java b/src/main/java/org/assertj/core/internal/Paths.java
index 863355059..b1d621d11 100644
--- a/src/main/java/org/assertj/core/internal/Paths.java
+++ b/src/main/java/org/assertj/core/internal/Paths.java
@@ -14,6 +14,7 @@ package org.assertj.core.internal;
 
 import static java.lang.String.format;
 import static java.nio.file.Files.readAllBytes;
+import static java.nio.file.Files.walk;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.StreamSupport.stream;
@@ -29,6 +30,7 @@ import static org.assertj.core.error.ShouldBeRelativePath.shouldBeRelativePath;
 import static org.assertj.core.error.ShouldBeSymbolicLink.shouldBeSymbolicLink;
 import static org.assertj.core.error.ShouldBeWritable.shouldBeWritable;
 import static org.assertj.core.error.ShouldContain.directoryShouldContain;
+import static org.assertj.core.error.ShouldContainRecursively.directoryShouldContainRecursively;
 import static org.assertj.core.error.ShouldEndWithPath.shouldEndWith;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldExist.shouldExistNoFollowLinks;
@@ -57,6 +59,7 @@ import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.List;
 import java.util.function.Predicate;
+import java.util.stream.Stream;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.api.exception.PathsException;
@@ -371,6 +374,18 @@ public class Paths {
     assertIsDirectoryContaining(info, actual, pathMatcher::matches, format("the '%s' pattern", syntaxAndPattern));
   }
 
+  public void assertIsDirectoryRecursivelyContaining(AssertionInfo info, Path actual, String syntaxAndPattern) {
+    requireNonNull(syntaxAndPattern, "The syntax and pattern should not be null");
+    PathMatcher pathMatcher = pathMatcher(info, actual, syntaxAndPattern);
+    assertIsDirectoryRecursivelyContaining(info, actual, path -> pathMatcher.matches(path),
+                                           format("the '%s' pattern", syntaxAndPattern));
+  }
+
+  public void assertIsDirectoryRecursivelyContaining(AssertionInfo info, Path actual, Predicate<Path> filter) {
+    requireNonNull(filter, "The files filter should not be null");
+    assertIsDirectoryRecursivelyContaining(info, actual, filter, "the given filter");
+  }
+
   public void assertIsDirectoryNotContaining(AssertionInfo info, Path actual, Predicate<Path> filter) {
     requireNonNull(filter, "The paths filter should not be null");
     assertIsDirectoryNotContaining(info, actual, filter, "the given filter");
@@ -392,7 +407,7 @@ public class Paths {
     if (isEmptyDirectory) throw failures.failure(info, shouldNotBeEmpty());
   }
 
-  public static List<String> toFileNames(List<Path> files) {
+  public static List<String> toPathNames(List<Path> files) {
     return files.stream()
                 .map(Path::toString)
                 .collect(toList());
@@ -420,16 +435,44 @@ public class Paths {
     }
   }
 
+  private boolean isDirectoryRecursivelyContaining(AssertionInfo info, Path actual, Predicate<Path> filter) {
+    assertIsDirectory(info, actual);
+    try (Stream<Path> actualContent = recursiveContentOf(actual)) {
+      return actualContent.anyMatch(filter);
+    }
+  }
+
+  private List<Path> sortedRecursiveContent(Path path) {
+    try (Stream<Path> pathContent = recursiveContentOf(path)) {
+      return pathContent.sorted().collect(toList());
+    }
+  }
+
+  private Stream<Path> recursiveContentOf(Path directory) {
+    try {
+      return walk(directory).filter(p -> !p.equals(directory));
+    } catch (IOException e) {
+      throw new UncheckedIOException(format("Unable to walk recursively the directory :<%s>", directory), e);
+    }
+  }
+
+  private void assertIsDirectoryRecursivelyContaining(AssertionInfo info, Path actual, Predicate<Path> filter,
+                                                      String filterPresentation) {
+    if (!isDirectoryRecursivelyContaining(info, actual, filter)) {
+      throw failures.failure(info, directoryShouldContainRecursively(actual, sortedRecursiveContent(actual), filterPresentation));
+    }
+  }
+
   private void assertIsDirectoryNotContaining(AssertionInfo info, Path actual, Predicate<Path> filter,
                                               String filterPresentation) {
-    List<Path> matchingFiles = filterDirectory(info, actual, filter);
-    if (matchingFiles.size() > 0) {
-      throw failures.failure(info, directoryShouldNotContain(actual, toFileNames(matchingFiles), filterPresentation));
+    List<Path> matchingPaths = filterDirectory(info, actual, filter);
+    if (matchingPaths.size() > 0) {
+      throw failures.failure(info, directoryShouldNotContain(actual, toPathNames(matchingPaths), filterPresentation));
     }
   }
 
   private List<String> directoryContentDescription(AssertionInfo info, Path actual) {
-    return toFileNames(directoryContent(info, actual));
+    return toPathNames(directoryContent(info, actual));
   }
 
   private PathMatcher pathMatcher(AssertionInfo info, Path actual, String syntaxAndPattern) {
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isDirectoryRecursivelyContaining_Predicate_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isDirectoryRecursivelyContaining_Predicate_Test.java
new file mode 100644
index 000000000..64e378e90
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isDirectoryRecursivelyContaining_Predicate_Test.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+import java.util.function.Predicate;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+/**
+ * Tests for <code>{@link PathAssert#isDirectoryRecursivelyContaining(Predicate)}</code>
+ *
+ * @author David Haccoun
+ */
+public class PathAssert_isDirectoryRecursivelyContaining_Predicate_Test extends PathAssertBaseTest {
+
+  private final Predicate<Path> anyFilter = path -> true;
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.isDirectoryRecursivelyContaining(anyFilter);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertIsDirectoryRecursivelyContaining(getInfo(assertions), getActual(assertions), anyFilter);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
new file mode 100644
index 000000000..f148da5d3
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+/**
+ * Tests for <code>{@link PathAssert#isDirectoryRecursivelyContaining(String)}</code>
+ *
+ * @author David Haccoun
+ */
+public class PathAssert_isDirectoryRecursivelyContaining_SyntaxAndPattern_Test extends PathAssertBaseTest {
+
+  private final String syntaxAndPattern = "glob:*.java";
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.isDirectoryRecursivelyContaining(syntaxAndPattern);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertIsDirectoryRecursivelyContaining(getInfo(assertions), getActual(assertions), syntaxAndPattern);
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldContainRecursively_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainRecursively_create_Test.java
new file mode 100644
index 000000000..04e6ea599
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldContainRecursively_create_Test.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContainRecursively.directoryShouldContainRecursively;
+import static org.assertj.core.util.Lists.list;
+
+import java.io.File;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+import org.assertj.core.description.TextDescription;
+import org.junit.jupiter.api.Test;
+
+public class ShouldContainRecursively_create_Test {
+
+  @Test
+  public void should_create_error_message_for_files() {
+    // GIVEN
+    File root = new File("root");
+    File foo = new File(root, "foo");
+    File bar = new File(root, "b%%ar% %s %n");
+    ErrorMessageFactory factory = directoryShouldContainRecursively(root, list(foo, bar), "regex:.*txt");
+    // WHEN
+    String message = factory.create(new TextDescription("Test"));
+    // THEN
+    // we can't put the concrete message as root, foo and bar will have different absolute path on different machines.
+    then(message).startsWith(format("[Test] %nExpecting directory or any of its subdirectories (recursively):%n"))
+                 .containsSubsequence(root.toString(),
+                                      "to contain at least one file matching \"regex:.*txt\" but there was none.",
+                                      "The directory content was:",
+                                      foo.toString(),
+                                      bar.toString());
+  }
+
+  @Test
+  public void should_create_error_message_for_paths() {
+    // GIVEN
+    Path root = Paths.get("root");
+    Path foo = root.resolve("foo");
+    Path bar = root.resolve("b%%ar% %s %n");
+    ErrorMessageFactory factory = directoryShouldContainRecursively(root, list(foo, bar), "regex:.*txt");
+    // WHEN
+    String message = factory.create(new TextDescription("Test"));
+    // THEN
+    // we can't put the concrete message as root, foo and bar will have different absolute path on different machines.
+    then(message).startsWith(format("[Test] %nExpecting directory or any of its subdirectories (recursively):%n"))
+                 .containsSubsequence(root.toString(),
+                                      "to contain at least one file matching \"regex:.*txt\" but there was none.",
+                                      "The directory content was:",
+                                      foo.toString(),
+                                      bar.toString());
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/PathsSimpleBaseTest.java b/src/test/java/org/assertj/core/internal/PathsSimpleBaseTest.java
new file mode 100644
index 000000000..ade4e4053
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/PathsSimpleBaseTest.java
@@ -0,0 +1,76 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static java.util.Arrays.stream;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.mockito.Mockito.spy;
+
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.nio.file.Path;
+
+import org.assertj.core.api.AssertionInfo;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.io.TempDir;
+
+/**
+ * New base class for testing <code>{@link Files}</code>.
+ * <p>That is a lighter alternative to {@link FilesBaseTest}.<br>
+ * Contrary to {@link FilesBaseTest}, {@link PathsSimpleBaseTest}  doesn't try to abstract and mock the filesystem API.
+ * <br>
+ * Please update that javadoc if the philosophy of that simple base test class evolves
+ *
+ * @author David Haccoun
+ */
+public abstract class PathsSimpleBaseTest {
+
+  protected static final AssertionInfo INFO = someInfo();
+
+  protected Path tempDir;
+
+  protected Paths paths;
+  protected Failures failures;
+
+  @BeforeEach
+  public void setUp(@TempDir Path tempDir) {
+    this.tempDir = tempDir;
+    failures = spy(new Failures());
+    paths = Paths.instance();
+    paths.failures = failures;
+  }
+
+  public Path createDirectory(Path parent, String name, String... files) {
+    Path directory = parent.resolve(name);
+    try {
+      java.nio.file.Files.createDirectory(directory);
+      stream(files).forEach(f -> createFile(directory, f));
+    } catch (IOException e) {
+      throw new UncheckedIOException("error during fixture directory creation", e);
+    }
+    return directory;
+  }
+
+  public Path createDirectoryWithDefaultParent(String name, String... files) {
+    return createDirectory(tempDir, name, files);
+  }
+
+  public void createFile(Path directory, String f) {
+    try {
+      java.nio.file.Files.createFile(directory.resolve(f));
+    } catch (IOException e) {
+      throw new UncheckedIOException("error during fixture file creation", e);
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_Predicate_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_Predicate_Test.java
index 8a1e4bee0..d81c26574 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_Predicate_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_Predicate_Test.java
@@ -14,7 +14,6 @@ package org.assertj.core.internal.files;
 
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldContainRecursively.directoryShouldContainRecursively;
-import static org.assertj.core.internal.Files.toAbsolutePaths;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.Lists.emptyList;
 import static org.assertj.core.util.Lists.list;
@@ -124,10 +123,10 @@ public class Files_assertIsDirectoryRecursivelyContaining_Predicate_Test extends
                                                                             f -> f.getName().equals("foo2")));
     // THEN
     verify(failures).failure(INFO, directoryShouldContainRecursively(tempDirAsFile,
-                                                                     toAbsolutePaths(list(new File(tempDirAsFile, "foo"),
-                                                                                          new File(tempDirAsFile,
-                                                                                                   "foo/foo2.data"),
-                                                                                          new File(tempDirAsFile, "foo/foo3"))),
+                                                                     list(new File(tempDirAsFile, "foo"),
+                                                                          new File(tempDirAsFile,
+                                                                                   "foo/foo2.data"),
+                                                                          new File(tempDirAsFile, "foo/foo3")),
                                                                      THE_GIVEN_FILTER_DESCRIPTION));
   }
 
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
index 0d9defdaf..5641a5661 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
@@ -15,7 +15,6 @@ package org.assertj.core.internal.files;
 import static java.lang.String.format;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldContainRecursively.directoryShouldContainRecursively;
-import static org.assertj.core.internal.Files.toAbsolutePaths;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.Lists.emptyList;
 import static org.assertj.core.util.Lists.list;
@@ -40,8 +39,7 @@ import org.junit.jupiter.params.provider.ValueSource;
 public class Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test extends FilesSimpleBaseTest {
 
   private static final String TXT_EXTENSION_PATTERN = "regex:.+\\.txt";
-  private static final String TXT_EXTENSION_PATTERN_DESCRIPTION = format("the '%s' pattern",
-                                                                         TXT_EXTENSION_PATTERN);
+  private static final String TXT_EXTENSION_PATTERN_DESCRIPTION = format("the '%s' pattern", TXT_EXTENSION_PATTERN);
 
   @ParameterizedTest
   @ValueSource(strings = { "regex:.+oo2\\.data", "regex:.+\\.json", "regex:.+bar2\\.json" })
@@ -90,8 +88,7 @@ public class Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test
     // GIVEN
     File notExistingFile = new File("foo/bar/doesnt-exist-file");
     // WHEN
-    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, notExistingFile,
-                                                                            TXT_EXTENSION_PATTERN));
+    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, notExistingFile, TXT_EXTENSION_PATTERN));
     // THEN
     verify(failures).failure(INFO, shouldBeDirectory(notExistingFile));
   }
@@ -101,8 +98,7 @@ public class Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test
     // GIVEN
     File existingFile = java.nio.file.Files.createFile(tempDir.resolve("FooFile.txt")).toFile();
     // WHEN
-    expectAssertionError(
-                         () -> files.assertIsDirectoryRecursivelyContaining(INFO, existingFile, TXT_EXTENSION_PATTERN));
+    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, existingFile, TXT_EXTENSION_PATTERN));
     // THEN
     verify(failures).failure(INFO, shouldBeDirectory(existingFile));
   }
@@ -110,11 +106,9 @@ public class Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test
   @Test
   void should_fail_if_actual_is_empty() {
     // WHEN
-    expectAssertionError(
-                         () -> files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, TXT_EXTENSION_PATTERN));
+    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, TXT_EXTENSION_PATTERN));
     // THEN
-    verify(failures)
-                    .failure(INFO,
+    verify(failures).failure(INFO,
                              directoryShouldContainRecursively(tempDirAsFile, emptyList(), TXT_EXTENSION_PATTERN_DESCRIPTION));
   }
 
@@ -124,16 +118,14 @@ public class Files_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test
     Path fooDir = createDirectory(tempDir, "foo", "foo2.data");
     createDirectory(fooDir, "foo3");
     // WHEN
-    expectAssertionError(
-                         () -> files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, TXT_EXTENSION_PATTERN));
+    expectAssertionError(() -> files.assertIsDirectoryRecursivelyContaining(INFO, tempDirAsFile, TXT_EXTENSION_PATTERN));
     // THEN
-    verify(failures)
-                    .failure(INFO,
-                             directoryShouldContainRecursively(tempDirAsFile, toAbsolutePaths(list(new File(tempDirAsFile, "foo"),
-                                                                                                   new File(tempDirAsFile,
-                                                                                                            "foo/foo2.data"),
-                                                                                                   new File(tempDirAsFile,
-                                                                                                            "foo/foo3"))),
+    verify(failures).failure(INFO,
+                             directoryShouldContainRecursively(tempDirAsFile, list(new File(tempDirAsFile, "foo"),
+                                                                                   new File(tempDirAsFile,
+                                                                                            "foo/foo2.data"),
+                                                                                   new File(tempDirAsFile,
+                                                                                            "foo/foo3")),
                                                                TXT_EXTENSION_PATTERN_DESCRIPTION));
   }
 
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_Predicate_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_Predicate_Test.java
index 8f57fdc01..9b268d16b 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_Predicate_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_Predicate_Test.java
@@ -18,7 +18,7 @@ import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldContain.directoryShouldContain;
 import static org.assertj.core.error.ShouldExist.shouldExist;
-import static org.assertj.core.internal.Paths.toFileNames;
+import static org.assertj.core.internal.Paths.toPathNames;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Lists.emptyList;
@@ -160,7 +160,7 @@ public class Paths_assertIsDirectoryContaining_Predicate_Test extends MockPathsB
     // WHEN
     expectAssertionError(() -> paths.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE));
     // THEN
-    verify(failures).failure(INFO, directoryShouldContain(actual, toFileNames(files), "the given filter"));
+    verify(failures).failure(INFO, directoryShouldContain(actual, toPathNames(files), "the given filter"));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
index eb57a3bd6..fdf68b192 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
@@ -19,7 +19,7 @@ import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldContain.directoryShouldContain;
 import static org.assertj.core.error.ShouldExist.shouldExist;
-import static org.assertj.core.internal.Paths.toFileNames;
+import static org.assertj.core.internal.Paths.toPathNames;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Lists.emptyList;
@@ -168,7 +168,7 @@ public class Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test extends Moc
     // WHEN
     expectAssertionError(() -> paths.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
-    verify(failures).failure(INFO, directoryShouldContain(actual, toFileNames(files), JAVA_SOURCE_PATTERN_DESCRIPTION));
+    verify(failures).failure(INFO, directoryShouldContain(actual, toPathNames(files), JAVA_SOURCE_PATTERN_DESCRIPTION));
   }
 
   static void mockPathMatcher(Path actual) {
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_Predicate_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_Predicate_Test.java
index c563148f9..ec2fa0dc9 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_Predicate_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_Predicate_Test.java
@@ -18,7 +18,7 @@ import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldNotContain.directoryShouldNotContain;
-import static org.assertj.core.internal.Paths.toFileNames;
+import static org.assertj.core.internal.Paths.toPathNames;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Lists.emptyList;
@@ -136,7 +136,7 @@ public class Paths_assertIsDirectoryNotContaining_Predicate_Test extends MockPat
     // WHEN
     expectAssertionError(() -> paths.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
-    verify(failures).failure(INFO, directoryShouldNotContain(actual, toFileNames(items), "the given filter"));
+    verify(failures).failure(INFO, directoryShouldNotContain(actual, toPathNames(items), "the given filter"));
   }
 
   @Test
@@ -149,7 +149,7 @@ public class Paths_assertIsDirectoryNotContaining_Predicate_Test extends MockPat
     // WHEN
     expectAssertionError(() -> paths.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
-    verify(failures).failure(INFO, directoryShouldNotContain(actual, toFileNames(items), "the given filter"));
+    verify(failures).failure(INFO, directoryShouldNotContain(actual, toPathNames(items), "the given filter"));
   }
 
   @Test
@@ -165,7 +165,7 @@ public class Paths_assertIsDirectoryNotContaining_Predicate_Test extends MockPat
     // WHEN
     expectAssertionError(() -> paths.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
-    verify(failures).failure(INFO, directoryShouldNotContain(actual, toFileNames(list(file2, file4)), "the given filter"));
+    verify(failures).failure(INFO, directoryShouldNotContain(actual, toPathNames(list(file2, file4)), "the given filter"));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
index e1c8b29ba..cc407ea41 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
@@ -20,7 +20,7 @@ import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldNotContain.directoryShouldNotContain;
-import static org.assertj.core.internal.Paths.toFileNames;
+import static org.assertj.core.internal.Paths.toPathNames;
 import static org.assertj.core.internal.paths.Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.mockPathMatcher;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
@@ -139,7 +139,7 @@ public class Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends
     // WHEN
     expectAssertionError(() -> paths.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
-    verify(failures).failure(INFO, directoryShouldNotContain(actual, toFileNames(items), JAVA_SOURCE_PATTERN_DESCRIPTION));
+    verify(failures).failure(INFO, directoryShouldNotContain(actual, toPathNames(items), JAVA_SOURCE_PATTERN_DESCRIPTION));
   }
 
   @Test
@@ -153,7 +153,7 @@ public class Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends
     // WHEN
     expectAssertionError(() -> paths.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
-    verify(failures).failure(INFO, directoryShouldNotContain(actual, toFileNames(items), JAVA_SOURCE_PATTERN_DESCRIPTION));
+    verify(failures).failure(INFO, directoryShouldNotContain(actual, toPathNames(items), JAVA_SOURCE_PATTERN_DESCRIPTION));
   }
 
   @Test
@@ -171,7 +171,7 @@ public class Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends
     expectAssertionError(() -> paths.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
     verify(failures).failure(INFO,
-                             directoryShouldNotContain(actual, toFileNames(list(file2, file4)), JAVA_SOURCE_PATTERN_DESCRIPTION));
+                             directoryShouldNotContain(actual, toPathNames(list(file2, file4)), JAVA_SOURCE_PATTERN_DESCRIPTION));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryRecursivelyContaining_Predicate_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryRecursivelyContaining_Predicate_Test.java
new file mode 100644
index 000000000..20c4a558c
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryRecursivelyContaining_Predicate_Test.java
@@ -0,0 +1,129 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
+import static org.assertj.core.error.ShouldContainRecursively.directoryShouldContainRecursively;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Lists.emptyList;
+import static org.assertj.core.util.Lists.list;
+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+import java.util.List;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Paths;
+import org.assertj.core.internal.PathsSimpleBaseTest;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests for <code>{@link Paths#assertIsDirectoryRecursivelyContaining(AssertionInfo, Path, java.util.function.Predicate)}</code>
+ *
+ * @author David Haccoun
+ */
+public class Paths_assertIsDirectoryRecursivelyContaining_Predicate_Test extends PathsSimpleBaseTest {
+
+  private static final String THE_GIVEN_FILTER_DESCRIPTION = "the given filter";
+
+  @TestInstance(PER_CLASS)
+  @Nested
+  class Actual_matches {
+
+    @BeforeEach
+    void createFixturePaths() {
+      // @format:off
+      // The layout:
+      //  root
+      //  |—— foo
+      //  |    |—— foobar
+      //  |         |—— foobar1.data
+      //  |         |—— foobar2.json
+      //  |—— foo2.data
+      // @format:on
+      Path rootDir = createDirectoryWithDefaultParent("root", "foo2.data");
+      Path fooDir = createDirectory(rootDir, "foo");
+      createDirectory(fooDir, "foobar", "foobar1.data", "foobar2.json");
+    }
+
+    @ParameterizedTest
+    @MethodSource("foundMatchProvider")
+    void should_pass_if_actual_contains_any_paths_matching_the_given_predicate(Predicate<Path> predicate) {
+      paths.assertIsDirectoryRecursivelyContaining(INFO, tempDir, predicate);
+    }
+
+    private Stream<Predicate<Path>> foundMatchProvider() {
+      return Stream.of(path -> path.toString().contains("bar2"), // one match
+                       path -> path.toString().endsWith("foobar2.json"), // one match
+                       path -> path.toString().contains("foobar"), // 3 matches
+                       path -> path.getParent().toString().endsWith("foobar"), // one match
+                       path -> path.toString().contains("foo")); // all matches
+    }
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_exist() {
+    // GIVEN
+    Path notExistingPath = tempDir.resolve("doesnt-exist-file");
+    Predicate<Path> anyPredicate = f -> true;
+    // WHEN
+    expectAssertionError(() -> paths.assertIsDirectoryRecursivelyContaining(INFO, notExistingPath, anyPredicate));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(notExistingPath));
+  }
+
+  @Test
+  void should_fail_if_actual_exists_but_is_not_a_directory() {
+    // GIVEN
+    Path rootDir = createDirectoryWithDefaultParent("root", "foo2.data");
+    Path existingPath = rootDir.resolve("foo2.data");
+    Predicate<Path> alwaysTrue = f -> true;
+    // WHEN
+    expectAssertionError(() -> paths.assertIsDirectoryRecursivelyContaining(INFO, existingPath, alwaysTrue));
+    // THEN
+    verify(failures).failure(INFO, shouldBeDirectory(existingPath));
+  }
+
+  @Test
+  void should_fail_if_actual_is_empty() {
+    // GIVEN
+    Predicate<Path> alwaysTrue = f -> true;
+    // WHEN
+    expectAssertionError(() -> paths.assertIsDirectoryRecursivelyContaining(INFO, tempDir, alwaysTrue));
+    // THEN
+    verify(failures).failure(INFO, directoryShouldContainRecursively(tempDir, emptyList(), THE_GIVEN_FILTER_DESCRIPTION));
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_any_paths_matching_the_given_predicate() {
+    // GIVEN
+    Path fooDir = createDirectory(tempDir, "foo", "foo2.data");
+    createDirectory(fooDir, "foo3");
+    Predicate<Path> alwaysFalse = f -> false;
+    // WHEN
+    expectAssertionError(() -> paths.assertIsDirectoryRecursivelyContaining(INFO, tempDir, alwaysFalse));
+    // THEN
+    List<Path> fooDirContent = list(fooDir, fooDir.resolve("foo2.data"), fooDir.resolve("foo3"));
+    verify(failures).failure(INFO, directoryShouldContainRecursively(tempDir, fooDirContent, THE_GIVEN_FILTER_DESCRIPTION));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
new file mode 100644
index 000000000..1b72eeea7
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test.java
@@ -0,0 +1,128 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static java.lang.String.format;
+import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
+import static org.assertj.core.error.ShouldContainRecursively.directoryShouldContainRecursively;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Lists.emptyList;
+import static org.assertj.core.util.Lists.list;
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+import java.util.List;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Paths;
+import org.assertj.core.internal.PathsSimpleBaseTest;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+/**
+ * Tests for <code>{@link Paths#assertIsDirectoryRecursivelyContaining(AssertionInfo, Path, String)}</code>
+ *
+ * @author David Haccoun
+ */
+public class Paths_assertIsDirectoryRecursivelyContaining_SyntaxAndPattern_Test extends PathsSimpleBaseTest {
+
+  private static final String TXT_EXTENSION_PATTERN = "regex:.+\\.txt";
+  private static final String TXT_EXTENSION_PATTERN_DESCRIPTION = format("the '%s' pattern",
+                                                                         TXT_EXTENSION_PATTERN);
+
+  @ParameterizedTest
+  @ValueSource(strings = { "regex:.+oo2\\.data", "regex:.+\\.json", "regex:.+bar2\\.json" })
+  void should_pass_if_actual_contains_one_file_matching_the_given_pathMatcherPattern(String pattern) {
+    // GIVEN
+    createDefaultFixturePaths();
+    // WHEN-THEN
+    paths.assertIsDirectoryRecursivelyContaining(INFO, tempDir, pattern);
+  }
+
+  @ParameterizedTest
+  @ValueSource(strings = { "regex:.+\\.data", "regex:.+foobar.*", "regex:.+root.+foo.*" })
+  void should_pass_if_actual_contains_some_paths_matching_the_given_pathMatcherPattern(String pattern) {
+    // GIVEN
+    createDefaultFixturePaths();
+    // WHEN-THEN
+    paths.assertIsDirectoryRecursivelyContaining(INFO, tempDir, pattern);
+  }
+
+  private void createDefaultFixturePaths() {
+    // @format:off
+    // The layout :
+    // root
+    // |—— foo
+    // |    |—— foobar
+    // |         |—— foobar1.data
+    // |         |—— foobar2.json
+    // |—— foo2.data
+    // @format:on
+    Path rootDir = createDirectoryWithDefaultParent("root", "foo2.data");
+    Path fooDir = createDirectory(rootDir, "foo");
+    createDirectory(fooDir, "foobar", "foobar1.data", "foobar2.json");
+  }
+
+  @Test
+  void should_pass_if_all_actual_paths_matching_the_given_pathMatcherPattern() {
+    // GIVEN
+    Path fooDir = createDirectory(tempDir, "foo", "foo2.data");
+    createDirectory(fooDir, "foo3");
+    // WHEN-THEN
+    paths.assertIsDirectoryRecursivelyContaining(INFO, tempDir, "regex:.*foo.*|.*tmp");
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_exist() {
+    // GIVEN
+    Path notExistingPath = tempDir.resolve("doesnt-exist-file");
+    // WHEN
+    expectAssertionError(() -> paths.assertIsDirectoryRecursivelyContaining(INFO, notExistingPath, TXT_EXTENSION_PATTERN));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(notExistingPath));
+  }
+
+  @Test
+  void should_fail_if_actual_exists_but_is_not_a_directory() {
+    // GIVEN
+    Path rootDir = createDirectoryWithDefaultParent("root", "foo2.data");
+    Path existingPath = rootDir.resolve("foo2.data");
+    // WHEN
+    expectAssertionError(() -> paths.assertIsDirectoryRecursivelyContaining(INFO, existingPath, TXT_EXTENSION_PATTERN));
+    // THEN
+    verify(failures).failure(INFO, shouldBeDirectory(existingPath));
+  }
+
+  @Test
+  void should_fail_if_actual_is_empty() {
+    // WHEN
+    expectAssertionError(() -> paths.assertIsDirectoryRecursivelyContaining(INFO, tempDir, TXT_EXTENSION_PATTERN));
+    // THEN
+    verify(failures).failure(INFO, directoryShouldContainRecursively(tempDir, emptyList(), TXT_EXTENSION_PATTERN_DESCRIPTION));
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_any_paths_matching_the_given_pathMatcherPattern() {
+    // GIVEN
+    Path fooDir = createDirectory(tempDir, "foo", "foo2.data");
+    createDirectory(fooDir, "foo3");
+    // WHEN
+    expectAssertionError(() -> paths.assertIsDirectoryRecursivelyContaining(INFO, tempDir, TXT_EXTENSION_PATTERN));
+    // THEN
+    List<Path> fooDirContent = list(fooDir, fooDir.resolve("foo2.data"), fooDir.resolve("foo3"));
+    verify(failures).failure(INFO, directoryShouldContainRecursively(tempDir, fooDirContent, TXT_EXTENSION_PATTERN_DESCRIPTION));
+  }
+
+}
