diff --git a/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java b/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java
index 71e594d33..def7a6237 100644
--- a/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java
+++ b/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java
@@ -12,19 +12,14 @@
  */
 package org.assertj.core.api;
 
-import static java.lang.String.format;
 import static java.util.Collections.synchronizedList;
 import static java.util.Collections.unmodifiableList;
-import static java.util.stream.Collectors.toList;
-import static org.assertj.core.extractor.Extractors.byName;
 
-import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
-import java.util.stream.Stream;
 
-import org.assertj.core.util.introspection.IntrospectionError;
+import org.assertj.core.util.Throwables;
 
 public class DefaultAssertionErrorCollector implements AssertionErrorCollector {
 
@@ -143,111 +138,7 @@ public class DefaultAssertionErrorCollector implements AssertionErrorCollector {
    * @return decorated list
   */
   protected <T extends Throwable> List<T> decorateErrorsCollected(List<? extends T> errors) {
-    return addLineNumberToErrorMessages(errors);
-  }
-
-  private static <T extends Throwable> List<T> addLineNumberToErrorMessages(List<? extends T> errors) {
-    return errors.stream()
-                 .map(DefaultAssertionErrorCollector::addLineNumberToErrorMessage)
-                 .collect(toList());
-  }
-
-  private static <T extends Throwable> T addLineNumberToErrorMessage(T error) {
-    StackTraceElement testStackTraceElement = getFirstStackTraceElementFromTest(error.getStackTrace());
-    if (testStackTraceElement != null) {
-      try {
-        return createNewInstanceWithLineNumberInErrorMessage(error, testStackTraceElement);
-      } catch (@SuppressWarnings("unused") SecurityException | ReflectiveOperationException ignored) {}
-    }
-    return error;
-  }
-
-  private static <T extends Throwable> T createNewInstanceWithLineNumberInErrorMessage(T error,
-                                                                                       StackTraceElement testStackTraceElement) throws ReflectiveOperationException {
-    T errorWithLineNumber = isOpentest4jAssertionFailedError(error)
-        ? buildOpentest4jAssertionFailedErrorWithLineNumbers(error, testStackTraceElement)
-        : buildAssertionErrorWithLineNumbersButNoActualOrExpectedValues(error, testStackTraceElement);
-    errorWithLineNumber.setStackTrace(error.getStackTrace());
-    Stream.of(error.getSuppressed()).forEach(suppressed -> errorWithLineNumber.addSuppressed(suppressed));
-    return errorWithLineNumber;
-  }
-
-  private static <T extends Throwable> boolean isOpentest4jAssertionFailedError(T error) {
-    return "org.opentest4j.AssertionFailedError".equals(error.getClass().getName());
-  }
-
-  private static <T extends Throwable> T buildAssertionErrorWithLineNumbersButNoActualOrExpectedValues(T error,
-                                                                                                       StackTraceElement testStackTraceElement) throws ReflectiveOperationException {
-    @SuppressWarnings("unchecked")
-    Constructor<? extends T> constructor = (Constructor<? extends T>) error.getClass().getConstructor(String.class,
-                                                                                                      Throwable.class);
-    return constructor.newInstance(buildErrorMessageWithLineNumber(error.getMessage(), testStackTraceElement), error.getCause());
-  }
-
-  private static <T extends Throwable> T buildOpentest4jAssertionFailedErrorWithLineNumbers(T error,
-                                                                                            StackTraceElement testStackTraceElement) throws ReflectiveOperationException {
-    // AssertionFailedError has actual and expected fields of type ValueWrapper
-    Object actualWrapper = byName("actual").apply(error);
-    Object expectedWrapper = byName("expected").apply(error);
-    if (actualWrapper != null && expectedWrapper != null) {
-      // try to call AssertionFailedError(String message, Object expected, Object actual, Throwable cause)
-      try {
-        Object actual = byName("value").apply(actualWrapper);
-        Object expected = byName("value").apply(expectedWrapper);
-        Constructor<? extends T> constructor = (Constructor<? extends T>) error.getClass().getConstructor(String.class,
-                                                                                                          Object.class,
-                                                                                                          Object.class,
-                                                                                                          Throwable.class);
-        return constructor.newInstance(buildErrorMessageWithLineNumber(error.getMessage(), testStackTraceElement),
-                                                        expected,
-                                                        actual,
-                                                        error.getCause());
-      } catch (IntrospectionError e) {
-        // fallback to AssertionFailedError(String message, Throwable cause) constructor
-      }
-    }
-    return buildAssertionErrorWithLineNumbersButNoActualOrExpectedValues(error, testStackTraceElement);
-  }
-
-  private static String buildErrorMessageWithLineNumber(String originalErrorMessage, StackTraceElement testStackTraceElement) {
-    String testClassName = simpleClassNameOf(testStackTraceElement);
-    String testName = testStackTraceElement.getMethodName();
-    int lineNumber = testStackTraceElement.getLineNumber();
-    return format("%s%nat %s.%s(%s.java:%s)", originalErrorMessage, testClassName, testName, testClassName, lineNumber);
-  }
-
-  private static String simpleClassNameOf(StackTraceElement testStackTraceElement) {
-    String className = testStackTraceElement.getClassName();
-    return className.substring(className.lastIndexOf('.') + 1);
-  }
-
-  private static StackTraceElement getFirstStackTraceElementFromTest(StackTraceElement[] stacktrace) {
-    for (StackTraceElement element : stacktrace) {
-      String className = element.getClassName();
-      if (isProxiedAssertionClass(className)
-          || className.startsWith("sun.reflect")
-          || className.startsWith("jdk.internal.reflect")
-          || className.startsWith("java.")
-          || className.startsWith("javax.")
-          || className.startsWith("org.junit.")
-          || className.startsWith("org.eclipse.jdt.internal.junit.")
-          || className.startsWith("org.eclipse.jdt.internal.junit4.")
-          || className.startsWith("org.eclipse.jdt.internal.junit5.")
-          || className.startsWith("com.intellij.junit5.")
-          || className.startsWith("com.intellij.rt.execution.junit.")
-          || className.startsWith("com.intellij.rt.junit.") // since IntelliJ IDEA build 193.2956.37
-          || className.startsWith("org.apache.maven.surefire")
-          || className.startsWith("org.pitest.")
-          || className.startsWith("org.assertj")) {
-        continue;
-      }
-      return element;
-    }
-    return null;
-  }
-
-  private static boolean isProxiedAssertionClass(String className) {
-    return className.contains("$ByteBuddy$");
+    return Throwables.addLineNumberToErrorMessages(errors);
   }
 
 }
diff --git a/src/main/java/org/assertj/core/error/AssertJMultipleFailuresError.java b/src/main/java/org/assertj/core/error/AssertJMultipleFailuresError.java
index 130147e54..a0f538ad2 100644
--- a/src/main/java/org/assertj/core/error/AssertJMultipleFailuresError.java
+++ b/src/main/java/org/assertj/core/error/AssertJMultipleFailuresError.java
@@ -13,6 +13,7 @@
 package org.assertj.core.error;
 
 import static java.lang.String.format;
+import static org.assertj.core.util.Throwables.addLineNumberToErrorMessages;
 
 import java.util.List;
 
@@ -46,9 +47,10 @@ public class AssertJMultipleFailuresError extends MultipleFailuresError {
                                                   .append(failureCount).append(" ")
                                                   .append(pluralize(failureCount, "failure", "failures"))
                                                   .append(")");
+    List<Throwable> failuresWithLineNumbers = addLineNumberToErrorMessages(failures);
     for (int i = 0; i < failureCount; i++) {
       builder.append(errorSeparator(i + 1));
-      String message = nullSafeMessage(failures.get(i));
+      String message = nullSafeMessage(failuresWithLineNumbers.get(i));
       // when we have a description, we add a line before for readability
       if (hasDescription(message)) builder.append(EOL);
       builder.append(message);
diff --git a/src/main/java/org/assertj/core/util/Throwables.java b/src/main/java/org/assertj/core/util/Throwables.java
index 642b1a6c3..dc84538c0 100644
--- a/src/main/java/org/assertj/core/util/Throwables.java
+++ b/src/main/java/org/assertj/core/util/Throwables.java
@@ -15,14 +15,20 @@ package org.assertj.core.util;
 import static java.lang.String.format;
 import static java.util.Arrays.stream;
 import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.extractor.Extractors.byName;
 import static org.assertj.core.groups.FieldsOrPropertiesExtractor.extract;
 import static org.assertj.core.util.Lists.newArrayList;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.util.introspection.IntrospectionError;
 
 /**
  * Utility methods related to <code>{@link Throwable}</code>s.
@@ -35,6 +41,8 @@ public final class Throwables {
   private static final String JAVA_LANG_REFLECT_CONSTRUCTOR = "java.lang.reflect.Constructor";
   private static final String ORG_ASSERTJ = "org.assert";
 
+  private Throwables() {}
+
   private static final Function<Throwable, String> ERROR_DESCRIPTION_EXTRACTOR = throwable -> {
     Throwable cause = throwable.getCause();
     if (cause == null) return throwable.getMessage();
@@ -173,6 +181,112 @@ public final class Throwables {
     }
   }
 
-  private Throwables() {}
+  public static <T extends Throwable> List<T> addLineNumberToErrorMessages(List<? extends T> errors) {
+    return errors.stream()
+                 .map(Throwables::addLineNumberToErrorMessage)
+                 .collect(toList());
+  }
+
+  public static StackTraceElement getFirstStackTraceElementFromTest(StackTraceElement[] stacktrace) {
+    for (StackTraceElement element : stacktrace) {
+      String className = element.getClassName();
+      if (isProxiedAssertionClass(className)
+          || className.startsWith("sun.reflect")
+          || className.startsWith("jdk.internal.reflect")
+          || className.startsWith("java.")
+          || className.startsWith("javax.")
+          || className.startsWith("org.junit.")
+          || className.startsWith("org.eclipse.jdt.internal.junit.")
+          || className.startsWith("org.eclipse.jdt.internal.junit4.")
+          || className.startsWith("org.eclipse.jdt.internal.junit5.")
+          || className.startsWith("com.intellij.junit5.")
+          || className.startsWith("com.intellij.rt.execution.junit.")
+          || className.startsWith("com.intellij.rt.junit.") // since IntelliJ IDEA build 193.2956.37
+          || className.startsWith("org.apache.maven.surefire")
+          || className.startsWith("org.pitest.")
+          || className.startsWith("org.assertj")) {
+        continue;
+      }
+      return element;
+    }
+    return null;
+  }
+
+  private static boolean isProxiedAssertionClass(String className) {
+    return className.contains("$ByteBuddy$");
+  }
+
+  private static <T extends Throwable> T addLineNumberToErrorMessage(T error) {
+    StackTraceElement testStackTraceElement = Throwables.getFirstStackTraceElementFromTest(error.getStackTrace());
+    if (testStackTraceElement != null) {
+      try {
+        return createNewInstanceWithLineNumberInErrorMessage(error, testStackTraceElement);
+      } catch (@SuppressWarnings("unused") SecurityException | ReflectiveOperationException ignored) {}
+    }
+    return error;
+  }
+
+  private static <T extends Throwable> T createNewInstanceWithLineNumberInErrorMessage(T error,
+                                                                                       StackTraceElement testStackTraceElement) throws ReflectiveOperationException {
+    T errorWithLineNumber = isOpentest4jAssertionFailedError(error)
+        ? buildOpentest4jAssertionFailedErrorWithLineNumbers(error, testStackTraceElement)
+        : buildAssertionErrorWithLineNumbersButNoActualOrExpectedValues(error, testStackTraceElement);
+    errorWithLineNumber.setStackTrace(error.getStackTrace());
+    Stream.of(error.getSuppressed()).forEach(suppressed -> errorWithLineNumber.addSuppressed(suppressed));
+    return errorWithLineNumber;
+  }
+
+  private static <T extends Throwable> boolean isOpentest4jAssertionFailedError(T error) {
+    return "org.opentest4j.AssertionFailedError".equals(error.getClass().getName());
+  }
+
+  private static <T extends Throwable> T buildAssertionErrorWithLineNumbersButNoActualOrExpectedValues(T error,
+                                                                                                       StackTraceElement testStackTraceElement) throws ReflectiveOperationException {
+    @SuppressWarnings("unchecked")
+    Constructor<? extends T> constructor = (Constructor<? extends T>) error.getClass().getConstructor(String.class,
+                                                                                                      Throwable.class);
+    return constructor.newInstance(buildErrorMessageWithLineNumber(error.getMessage(), testStackTraceElement), error.getCause());
+  }
+
+  private static <T extends Throwable> T buildOpentest4jAssertionFailedErrorWithLineNumbers(T error,
+                                                                                            StackTraceElement testStackTraceElement) throws ReflectiveOperationException {
+    // AssertionFailedError has actual and expected fields of type ValueWrapper
+    Object actualWrapper = byName("actual").apply(error);
+    Object expectedWrapper = byName("expected").apply(error);
+    if (actualWrapper != null && expectedWrapper != null) {
+      // try to call AssertionFailedError(String message, Object expected, Object actual, Throwable cause)
+      try {
+        Object actual = byName("value").apply(actualWrapper);
+        Object expected = byName("value").apply(expectedWrapper);
+        Constructor<? extends T> constructor = (Constructor<? extends T>) error.getClass().getConstructor(String.class,
+                                                                                                          Object.class,
+                                                                                                          Object.class,
+                                                                                                          Throwable.class);
+        return constructor.newInstance(buildErrorMessageWithLineNumber(error.getMessage(), testStackTraceElement),
+                                       expected,
+                                       actual,
+                                       error.getCause());
+      } catch (IntrospectionError e) {
+        // fallback to AssertionFailedError(String message, Throwable cause) constructor
+      }
+    }
+    return buildAssertionErrorWithLineNumbersButNoActualOrExpectedValues(error, testStackTraceElement);
+  }
+
+  private static String buildErrorMessageWithLineNumber(String originalErrorMessage, StackTraceElement testStackTraceElement) {
+    String testClassName = simpleClassNameOf(testStackTraceElement);
+    String testName = testStackTraceElement.getMethodName();
+    int lineNumber = testStackTraceElement.getLineNumber();
+    String atLineNumber = format("at %s.%s(%s.java:%s)", testClassName, testName, testClassName, lineNumber);
+    if (originalErrorMessage.contains(atLineNumber)) {
+      return originalErrorMessage;
+    }
+    return format(originalErrorMessage.endsWith(format("%n")) ? "%s%s" : "%s%n%s", originalErrorMessage, atLineNumber);
+  }
+
+  private static String simpleClassNameOf(StackTraceElement testStackTraceElement) {
+    String className = testStackTraceElement.getClassName();
+    return className.substring(className.lastIndexOf('.') + 1);
+  }
 
 }
diff --git a/src/test/java/org/example/test/AssertJMultipleFailuresError_getMessage_Test.java b/src/test/java/org/example/test/AssertJMultipleFailuresError_getMessage_Test.java
index 9faae0deb..daf98de1f 100644
--- a/src/test/java/org/example/test/AssertJMultipleFailuresError_getMessage_Test.java
+++ b/src/test/java/org/example/test/AssertJMultipleFailuresError_getMessage_Test.java
@@ -20,11 +20,9 @@ import static org.assertj.core.util.Lists.list;
 
 import org.assertj.core.api.SoftAssertions;
 import org.assertj.core.error.AssertJMultipleFailuresError;
-import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
 // this is not in an assertj package as we want to check the stack trace and we filter the element in assertj
-@DisplayName("AssertJMultipleFailuresError getMessage")
 class AssertJMultipleFailuresError_getMessage_Test {
 
   @Test
@@ -39,7 +37,7 @@ class AssertJMultipleFailuresError_getMessage_Test {
   }
 
   @Test
-  void should_include_errors_count_and_clearly_separate_error_messages() {
+  void should_include_errors_count_and_clearly_separate_error_messages_in_soft_assertions_context() {
     // GIVEN
     SoftAssertions softly = new SoftAssertions();
     softly.assertThat(list("")).isEmpty();
@@ -103,8 +101,10 @@ class AssertJMultipleFailuresError_getMessage_Test {
                                         format("  [\"a\"]%n"));
   }
 
+  // also verifies that we don't add stack trace line numbers twice (in soft assertion
+  // DefaultAssertionErrorCollector.decorateErrorsCollected and AssertJMultipleFailuresError
   @Test
-  void should_include_stack_trace_allowing_to_navigate_to_the_failing_assertion_in_test() {
+  void should_include_stack_trace_allowing_to_navigate_to_the_failing_test_assertion_line_in_soft_assertions_context() {
     // GIVEN
     SoftAssertions softly = new SoftAssertions();
     softly.assertThat(list("")).isEmpty();
@@ -114,18 +114,44 @@ class AssertJMultipleFailuresError_getMessage_Test {
     AssertionError error = expectAssertionError(() -> softly.assertAll());
     // THEN
     // @format:off
-    then(error).hasMessage(format("%nMultiple Failures (3 failures)%n" +
+    then(error).isInstanceOf(AssertJMultipleFailuresError.class)
+               .hasMessage(format("%nMultiple Failures (3 failures)%n" +
                                   "-- failure 1 --%n" +
                                   "Expecting empty but was: [\"\"]%n" +
-                                  "at AssertJMultipleFailuresError_getMessage_Test.should_include_stack_trace_allowing_to_navigate_to_the_failing_assertion_in_test(AssertJMultipleFailuresError_getMessage_Test.java:110)%n"                                  +
+                                  "at AssertJMultipleFailuresError_getMessage_Test.should_include_stack_trace_allowing_to_navigate_to_the_failing_test_assertion_line_in_soft_assertions_context(AssertJMultipleFailuresError_getMessage_Test.java:110)%n" +
                                   "-- failure 2 --%n" +
                                   "[isEmpty string] %n" +
                                   "Expecting empty but was: \"abc\"%n" +
-                                  "at AssertJMultipleFailuresError_getMessage_Test.should_include_stack_trace_allowing_to_navigate_to_the_failing_assertion_in_test(AssertJMultipleFailuresError_getMessage_Test.java:111)%n"                                  +
+                                  "at AssertJMultipleFailuresError_getMessage_Test.should_include_stack_trace_allowing_to_navigate_to_the_failing_test_assertion_line_in_soft_assertions_context(AssertJMultipleFailuresError_getMessage_Test.java:111)%n" +
                                   "-- failure 3 --"
                                   + shouldBeEqualMessage("\"abc\"", "\"bcd\"") + "%n" +
-                                  "at AssertJMultipleFailuresError_getMessage_Test.should_include_stack_trace_allowing_to_navigate_to_the_failing_assertion_in_test(AssertJMultipleFailuresError_getMessage_Test.java:112)"));
+                                  "at AssertJMultipleFailuresError_getMessage_Test.should_include_stack_trace_allowing_to_navigate_to_the_failing_test_assertion_line_in_soft_assertions_context(AssertJMultipleFailuresError_getMessage_Test.java:112)"));
     // @format:on
   }
 
+  @Test
+  void should_include_stack_trace_allowing_to_navigate_to_the_failing_test_assertion_line_in_satisfies_assertion() {
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then("abc").satisfies(value -> then(list(value)).isEmpty(),
+                                                                            value -> then(value).as("isEmpty string").isEmpty(),
+                                                                            value -> then(value).isEqualTo("bcd")));
+    // THEN
+    // @format:off
+    then(error).isInstanceOf(AssertJMultipleFailuresError.class)
+               .hasMessageContainingAll("AssertJMultipleFailuresError_getMessage_Test.java:135)",
+                                        "AssertJMultipleFailuresError_getMessage_Test.java:136)",
+                                        "AssertJMultipleFailuresError_getMessage_Test.java:137)");
+    // @format:on
+  }
+
+  @Test
+  void should_include_line_numbers() {
+    // GIVEN
+    AssertionError assertionError = new AssertionError("boom");
+    // WHEN
+    AssertJMultipleFailuresError error = new AssertJMultipleFailuresError("", list(assertionError));
+    // THEN
+    then(error).hasStackTraceContaining("AssertJMultipleFailuresError_getMessage_Test.java:150");
+  }
+
 }
diff --git a/src/test/java/org/example/test/Throwables_addLineNumberToErrorMessages_Test.java b/src/test/java/org/example/test/Throwables_addLineNumberToErrorMessages_Test.java
new file mode 100644
index 000000000..187eda578
--- /dev/null
+++ b/src/test/java/org/example/test/Throwables_addLineNumberToErrorMessages_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.example.test;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Throwables.addLineNumberToErrorMessages;
+
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+
+class Throwables_addLineNumberToErrorMessages_Test {
+
+  @Test
+  void should_add_the_line_where_the_error_was_thrown() {
+    // GIVEN
+    Throwable throwable1 = new Throwable("boom 1");
+    Throwable throwable2 = new Throwable("boom 2");
+    List<Throwable> errors = list(throwable1, throwable2);
+    // WHEN
+    List<Throwable> errorsWithLineNumber = addLineNumberToErrorMessages(errors);
+    // THEN
+    then(errorsWithLineNumber.get(0)).hasMessage(format("boom 1%nat Throwables_addLineNumberToErrorMessages_Test.should_add_the_line_where_the_error_was_thrown(Throwables_addLineNumberToErrorMessages_Test.java:29)"));
+    then(errorsWithLineNumber.get(1)).hasMessage(format("boom 2%nat Throwables_addLineNumberToErrorMessages_Test.should_add_the_line_where_the_error_was_thrown(Throwables_addLineNumberToErrorMessages_Test.java:30)"));
+  }
+
+}
diff --git a/src/test/java/org/example/test/Throwables_getFirstStackTraceElementFromTest_Test.java b/src/test/java/org/example/test/Throwables_getFirstStackTraceElementFromTest_Test.java
new file mode 100644
index 000000000..e670593c5
--- /dev/null
+++ b/src/test/java/org/example/test/Throwables_getFirstStackTraceElementFromTest_Test.java
@@ -0,0 +1,79 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.example.test;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.Throwables.getFirstStackTraceElementFromTest;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class Throwables_getFirstStackTraceElementFromTest_Test {
+
+  @Test
+  void should_return_first_stack_trace_element_from_test() {
+    // GIVEN
+    StackTraceElement[] stackTraceElements = new Throwable().getStackTrace();
+    // WHEN
+    StackTraceElement firstStackTraceElementFromTest = getFirstStackTraceElementFromTest(stackTraceElements);
+    // THEN
+    then(firstStackTraceElementFromTest).hasToString("org.example.test.Throwables_getFirstStackTraceElementFromTest_Test.should_return_first_stack_trace_element_from_test(Throwables_getFirstStackTraceElementFromTest_Test.java:32)");
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_ignore_test_frameworks_ides_build_tool_and_jdk_stack_traces(String[] fullQualifiedClassNames,
+                                                                          String expectedStackTraceElement) {
+    // GIVEN
+    StackTraceElement[] stackTraceElements = buildStackTraceFrom(fullQualifiedClassNames);
+    // WHEN
+    StackTraceElement firstStackTraceElementFromTest = getFirstStackTraceElementFromTest(stackTraceElements);
+    // THEN
+    then(firstStackTraceElementFromTest).hasToString(expectedStackTraceElement);
+  }
+
+  private StackTraceElement[] buildStackTraceFrom(String[] fullQualifiedClassNames) {
+    StackTraceElement[] stackTraceElements = new StackTraceElement[fullQualifiedClassNames.length];
+    for (int i = 0; i < fullQualifiedClassNames.length; i++) {
+      stackTraceElements[i] = new StackTraceElement(fullQualifiedClassNames[i], "foo", "Foo.java", i + 1);
+    }
+    return stackTraceElements;
+  }
+
+  private static Stream<Arguments> should_ignore_test_frameworks_ides_build_tool_and_jdk_stack_traces() {
+    return Stream.of(arguments(array("com.foo.Foo", "sun.reflect", "org.assertj.core.api"), "com.foo.Foo.foo(Foo.java:1)"),
+                     arguments(array("sun.reflect", "com.foo.Foo", "org.assertj.core.api"), "com.foo.Foo.foo(Foo.java:2)"),
+                     arguments(array("sun.reflect", "org.assertj.core.api", "com.foo.Foo"), "com.foo.Foo.foo(Foo.java:3)"),
+                     arguments(array("jdk.internal.reflect",
+                                     "java.",
+                                     "javax.",
+                                     "org.junit.",
+                                     "org.eclipse.jdt.internal.junit.",
+                                     "org.eclipse.jdt.internal.junit4.",
+                                     "org.eclipse.jdt.internal.junit5.",
+                                     "com.intellij.junit5.",
+                                     "com.intellij.rt.execution.junit.",
+                                     "com.intellij.rt.junit.",
+                                     "org.apache.maven.surefire",
+                                     "org.pitest.",
+                                     "org.assertj",
+                                     "com.foo.Foo"),
+                               "com.foo.Foo.foo(Foo.java:14)"));
+  }
+}
