diff --git a/pom.xml b/pom.xml
index 325446af8..87a0c5b03 100644
--- a/pom.xml
+++ b/pom.xml
@@ -158,6 +158,12 @@
       <version>3.12.0</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.apache.commons</groupId>
+      <artifactId>commons-collections4</artifactId>
+      <version>4.4</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>commons-io</groupId>
       <artifactId>commons-io</artifactId>
@@ -176,6 +182,12 @@
       <version>3.16.200</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.springframework</groupId>
+      <artifactId>spring-core</artifactId>
+      <version>5.3.6</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
@@ -234,6 +246,7 @@
         <executions>
           <!-- STEP 2: execute maven shade to rename bytebuddy -->
           <execution>
+            <id>bytebuddy</id>
             <phase>package</phase>
             <goals>
               <goal>shade</goal>
@@ -692,7 +705,9 @@
         <jdk>[16,)</jdk>
       </activation>
       <properties>
-        <argLine>-Dnet.bytebuddy.experimental=true --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.math=ALL-UNNAMED --add-opens=java.base/sun.nio.fs=ALL-UNNAMED</argLine>
+        <argLine>-Dnet.bytebuddy.experimental=true --add-opens=java.base/java.lang=ALL-UNNAMED
+          --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.math=ALL-UNNAMED
+          --add-opens=java.base/sun.nio.fs=ALL-UNNAMED</argLine>
       </properties>
     </profile>
     <profile>
diff --git a/src/main/java/org/assertj/core/api/AbstractMapAssert.java b/src/main/java/org/assertj/core/api/AbstractMapAssert.java
index 1459a55fb..5250ef0b4 100644
--- a/src/main/java/org/assertj/core/api/AbstractMapAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractMapAssert.java
@@ -1136,7 +1136,11 @@ public abstract class AbstractMapAssert<SELF extends AbstractMapAssert<SELF, ACT
 
   /**
    * Verifies that the actual map contains only the given keys and nothing else, in any order.
-   *
+   * <p>
+   * The verification tries to honor the key comparison semantic of the underlying map implementation.
+   * The map under test has to be cloned to identify unexpected elements, but depending on the map implementation
+   * this may not always be possible. In case it is not possible, a regular map is used and the key comparison strategy
+   * may not be the same as the map under test.
    * <p>
    * Examples :
    * <pre><code class='java'> Map&lt;Ring, TolkienCharacter&gt; ringBearers = new HashMap&lt;&gt;();
@@ -1173,7 +1177,11 @@ public abstract class AbstractMapAssert<SELF extends AbstractMapAssert<SELF, ACT
 
   /**
    * Verifies that the actual map contains only the given keys and nothing else, in any order.
-   *
+   * <p>
+   * The verification tries to honor the key comparison semantic of the underlying map implementation.
+   * The map under test has to be cloned to identify unexpected elements, but depending on the map implementation
+   * this may not always be possible. In case it is not possible, a regular map is used and the key comparison strategy
+   * may not be the same as the map under test.
    * <p>
    * Examples :
    * <pre><code class='java'> Map&lt;Ring, TolkienCharacter&gt; ringBearers = new HashMap&lt;&gt;();
@@ -1298,7 +1306,11 @@ public abstract class AbstractMapAssert<SELF extends AbstractMapAssert<SELF, ACT
 
   /**
    * Verifies that the actual map contains only the given entries and nothing else, in any order.
-   *
+   * <p>
+   * The verification tries to honor the key comparison semantic of the underlying map implementation.
+   * The map under test has to be cloned to identify unexpected elements, but depending on the map implementation
+   * this may not always be possible. In case it is not possible, a regular map is used and the key comparison strategy
+   * may not be the same as the map under test.
    * <p>
    * Examples :
    * <pre><code class='java'> Map&lt;Ring, TolkienCharacter&gt; ringBearers = new HashMap&lt;&gt;();
diff --git a/src/main/java/org/assertj/core/internal/Maps.java b/src/main/java/org/assertj/core/internal/Maps.java
index a5bbbf09e..d4ce2a939 100644
--- a/src/main/java/org/assertj/core/internal/Maps.java
+++ b/src/main/java/org/assertj/core/internal/Maps.java
@@ -12,6 +12,7 @@
  */
 package org.assertj.core.internal;
 
+import static java.util.Objects.deepEquals;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toList;
 import static org.assertj.core.data.MapEntry.entry;
@@ -53,6 +54,7 @@ import static org.assertj.core.util.IterableUtil.toArray;
 import static org.assertj.core.util.Objects.areEqual;
 import static org.assertj.core.util.Preconditions.checkArgument;
 
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -66,6 +68,7 @@ import java.util.function.Consumer;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.api.Condition;
+import org.assertj.core.data.MapEntry;
 import org.assertj.core.error.UnsatisfiedRequirement;
 import org.assertj.core.util.VisibleForTesting;
 
@@ -323,12 +326,7 @@ public class Maps {
 
   public <K, V> void assertContainsKeys(AssertionInfo info, Map<K, V> actual, K[] keys) {
     assertNotNull(info, actual);
-    Set<K> notFound = new LinkedHashSet<>();
-    for (K key : keys) {
-      if (!actual.containsKey(key)) {
-        notFound.add(key);
-      }
-    }
+    Set<K> notFound = getNotFoundKeys(actual, keys);
     if (notFound.isEmpty()) return;
     throw failures.failure(info, shouldContainKeys(actual, notFound));
   }
@@ -344,12 +342,8 @@ public class Maps {
 
   public <K, V> void assertDoesNotContainKeys(AssertionInfo info, Map<K, V> actual, K[] keys) {
     assertNotNull(info, actual);
-    Set<K> found = new LinkedHashSet<>();
-    for (K key : keys) {
-      if (key != null && actual.containsKey(key)) {
-        found.add(key);
-      }
-    }
+    requireNonNull(keys, keysToLookForIsNull("array of keys"));
+    Set<K> found = getFoundKeys(actual, keys);
     if (!found.isEmpty()) throw failures.failure(info, shouldNotContainKeys(actual, found));
   }
 
@@ -364,21 +358,76 @@ public class Maps {
 
   private <K, V> void assertContainsOnlyKeys(AssertionInfo info, Map<K, V> actual, String placeholderForErrorMessages, K[] keys) {
     assertNotNull(info, actual);
-    failIfNull(keys, keysToLookForIsNull(placeholderForErrorMessages));
+    requireNonNull(keys, keysToLookForIsNull(placeholderForErrorMessages));
     if (actual.isEmpty() && keys.length == 0) {
       return;
     }
     failIfEmpty(keys, keysToLookForIsEmpty(placeholderForErrorMessages));
 
-    Set<K> notFound = new LinkedHashSet<>();
-    Set<K> notExpected = new LinkedHashSet<>();
-
-    compareActualMapAndExpectedKeys(actual, keys, notExpected, notFound);
+    Set<K> notFound = getNotFoundKeys(actual, keys);
+    Set<K> notExpected = getNotExpectedKeys(actual, keys);
 
     if (!notFound.isEmpty() || !notExpected.isEmpty())
       throw failures.failure(info, shouldContainOnlyKeys(actual, keys, notFound, notExpected));
   }
 
+  private static <K> Set<K> getFoundKeys(Map<K, ?> actual, K[] expectedKeys) {
+    // Stream API avoided for performance reasons
+    Set<K> found = new LinkedHashSet<>();
+    for (K expectedKey : expectedKeys) {
+      if (actual.containsKey(expectedKey)) found.add(expectedKey);
+    }
+    return found;
+  }
+
+  private static <K> Set<K> getNotFoundKeys(Map<K, ?> actual, K[] expectedKeys) {
+    // Stream API avoided for performance reasons
+    Set<K> notFound = new LinkedHashSet<>();
+    for (K expectedKey : expectedKeys) {
+      if (!actual.containsKey(expectedKey)) notFound.add(expectedKey);
+    }
+    return notFound;
+  }
+
+  private static <K> Set<K> getNotExpectedKeys(Map<K, ?> actual, K[] expectedKeys) {
+    // Stream API avoided for performance reasons
+    try {
+      Map<K, ?> clonedMap = clone(actual);
+      for (K expectedKey : expectedKeys) {
+        clonedMap.remove(expectedKey);
+      }
+      return clonedMap.keySet();
+    } catch (NoSuchMethodException | UnsupportedOperationException e) {
+      // actual cannot be cloned or is unmodifiable, falling back to LinkedHashMap
+      Map<K, ?> copiedMap = new LinkedHashMap<>(actual);
+      for (K expectedKey : expectedKeys) {
+        copiedMap.remove(expectedKey);
+      }
+      return copiedMap.keySet();
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <K, V> Map<K, V> clone(Map<K, V> map) throws NoSuchMethodException {
+    try {
+      if (map instanceof Cloneable) {
+        return (Map<K, V>) map.getClass().getMethod("clone").invoke(map);
+      }
+
+      try {
+        // try with copying constructor
+        return map.getClass().getConstructor(Map.class).newInstance(map);
+      } catch (NoSuchMethodException e) {
+        // try with default constructor
+        Map<K, V> newMap = map.getClass().getConstructor().newInstance();
+        newMap.putAll(map);
+        return newMap;
+      }
+    } catch (IllegalAccessException | InvocationTargetException | InstantiationException e) {
+      throw new IllegalStateException(e);
+    }
+  }
+
   public <K, V> void assertContainsValue(AssertionInfo info, Map<K, V> actual, V value) {
     assertNotNull(info, actual);
     if (!actual.containsValue(value)) throw failures.failure(info, shouldContainValue(actual, value));
@@ -406,13 +455,51 @@ public class Maps {
     if (actual.isEmpty() && entries.length == 0) return;
     failIfEntriesIsEmptyEmptySinceActualIsNotEmpty(info, actual, entries);
 
-    Set<Entry<? extends K, ? extends V>> notFound = new LinkedHashSet<>();
-    Set<Entry<? extends K, ? extends V>> notExpected = new LinkedHashSet<>();
-    compareActualMapAndExpectedEntries(actual, entries, notExpected, notFound);
-    if (!notFound.isEmpty() || !notExpected.isEmpty())
+    Set<Entry<? extends K, ? extends V>> notFound = getNotFoundEntries(actual, entries);
+    Set<Entry<K, V>> notExpected = getNotExpectedEntries(actual, entries);
+
+    if (!(notFound.isEmpty() && notExpected.isEmpty()))
       throw failures.failure(info, shouldContainOnly(actual, entries, notFound, notExpected));
   }
 
+  private static <K, V> Set<Entry<? extends K, ? extends V>> getNotFoundEntries(Map<K, V> actual,
+                                                                                Entry<? extends K, ? extends V>[] entries) {
+    // Stream API avoided for performance reasons
+    Set<Entry<? extends K, ? extends V>> notFound = new LinkedHashSet<>();
+    for (Entry<? extends K, ? extends V> entry : entries) {
+      if (!containsEntry(actual, entry)) notFound.add(entry);
+    }
+    return notFound;
+  }
+
+  private static <K, V> Set<Entry<K, V>> getNotExpectedEntries(Map<K, V> actual, Entry<? extends K, ? extends V>[] entries) {
+    // Stream API avoided for performance reasons
+    Set<Entry<K, V>> notExpected = new LinkedHashSet<>();
+    for (Entry<K, V> entry : mapWithoutExpectedEntries(actual, entries).entrySet()) {
+      MapEntry<K, V> mapEntry = entry(entry.getKey(), entry.getValue());
+      notExpected.add(mapEntry);
+    }
+    return notExpected;
+  }
+
+  private static <K, V> Map<K, V> mapWithoutExpectedEntries(Map<K, V> actual, Entry<? extends K, ? extends V>[] expectedEntries) {
+    // Stream API avoided for performance reasons
+    try {
+      Map<K, V> clonedMap = clone(actual);
+      for (Entry<? extends K, ? extends V> expectedEntry : expectedEntries) {
+        clonedMap.remove(expectedEntry.getKey(), expectedEntry.getValue());
+      }
+      return clonedMap;
+    } catch (NoSuchMethodException | UnsupportedOperationException e) {
+      // actual cannot be cloned or is unmodifiable, falling back to LinkedHashMap
+      Map<K, V> copiedMap = new LinkedHashMap<>(actual);
+      for (Entry<? extends K, ? extends V> expectedEntry : expectedEntries) {
+        copiedMap.remove(expectedEntry.getKey(), expectedEntry.getValue());
+      }
+      return copiedMap;
+    }
+  }
+
   public <K, V> void assertContainsExactly(AssertionInfo info, Map<K, V> actual, Entry<? extends K, ? extends V>[] entries) {
     doCommonContainsCheck(info, actual, entries);
     if (actual.isEmpty() && entries.length == 0) return;
@@ -441,22 +528,6 @@ public class Maps {
     throw failures.failure(info, shouldContainExactly(actual, asList(entries), notFound, notExpected));
   }
 
-  private <K, V> void compareActualMapAndExpectedKeys(Map<K, V> actual, K[] keys, Set<K> notExpected, Set<K> notFound) {
-
-    Map<K, V> actualEntries = new LinkedHashMap<>(actual);
-    for (K key : keys) {
-      if (actualEntries.containsKey(key)) {
-        // this is an expected key
-        actualEntries.remove(key);
-      } else {
-        // this is a not found key
-        notFound.add(key);
-      }
-    }
-    // All remaining keys from actual copy are not expected entries.
-    notExpected.addAll(actualEntries.keySet());
-  }
-
   private <K, V> void compareActualMapAndExpectedEntries(Map<K, V> actual, Entry<? extends K, ? extends V>[] entries,
                                                          Set<Entry<? extends K, ? extends V>> notExpected,
                                                          Set<Entry<? extends K, ? extends V>> notFound) {
@@ -512,10 +583,6 @@ public class Maps {
     failIfEmpty(entries);
   }
 
-  private static <K> void failIfNull(K[] keys, String errorMessage) {
-    requireNonNull(keys, errorMessage);
-  }
-
   private static <K, V> void failIfNull(Entry<? extends K, ? extends V>[] entries) {
     requireNonNull(entries, ErrorMessages.entriesToLookForIsNull());
   }
@@ -524,9 +591,9 @@ public class Maps {
     requireNonNull(map, ErrorMessages.mapOfEntriesToLookForIsNull());
   }
 
-  private <K, V> boolean containsEntry(Map<K, V> actual, Entry<? extends K, ? extends V> entry) {
+  private static <K, V> boolean containsEntry(Map<K, V> actual, Entry<? extends K, ? extends V> entry) {
     requireNonNull(entry, ErrorMessages.entryToLookForIsNull());
-    return actual.containsKey(entry.getKey()) && areEqual(actual.get(entry.getKey()), entry.getValue());
+    return actual.containsKey(entry.getKey()) && deepEquals(actual.get(entry.getKey()), entry.getValue());
   }
 
   private void assertNotNull(AssertionInfo info, Map<?, ?> actual) {
diff --git a/src/main/java/org/assertj/core/util/Lists.java b/src/main/java/org/assertj/core/util/Lists.java
index 860681df6..d15356bd0 100644
--- a/src/main/java/org/assertj/core/util/Lists.java
+++ b/src/main/java/org/assertj/core/util/Lists.java
@@ -20,13 +20,19 @@ import java.util.Iterator;
 import java.util.List;
 
 /**
- * Utility methods related to {@code java.util.List}s.
+ * Utility methods related to {@link List}s.
  *
  * @author Yvonne Wang
  * @author Alex Ruiz
  * @author Joel Costigliola
  */
 public final class Lists {
+
+  @SafeVarargs
+  public static <T> List<T> list(T... elements) {
+    return newArrayList(elements);
+  }
+
   /**
    * Creates a <em>mutable</em> {@link ArrayList} containing the given elements.
    *
@@ -44,16 +50,6 @@ public final class Lists {
     return list;
   }
 
-  @SafeVarargs
-  public static <T> List<T> list(T... elements) {
-    if (elements == null) {
-      return null;
-    }
-    ArrayList<T> list = newArrayList();
-    Collections.addAll(list, elements);
-    return list;
-  }
-
   /**
    * Creates a <em>mutable</em> {@link ArrayList} containing the given elements.
    *
@@ -100,6 +96,5 @@ public final class Lists {
     return Collections.emptyList();
   }
 
-  private Lists() {
-  }
+  private Lists() {}
 }
diff --git a/src/main/java/org/assertj/core/util/Sets.java b/src/main/java/org/assertj/core/util/Sets.java
index 8e4dd2b5e..ec9536445 100644
--- a/src/main/java/org/assertj/core/util/Sets.java
+++ b/src/main/java/org/assertj/core/util/Sets.java
@@ -22,9 +22,22 @@ import java.util.TreeSet;
 /**
  * Utility methods related to {@link Set}s.
  *
- * @author alruiz
+ * @author Alex Ruiz
  */
 public final class Sets {
+
+  /**
+   * Creates a <em>mutable</em> {@link HashSet} containing the given elements.
+   *
+   * @param <T> the generic type of the {@code HashSet} to create.
+   * @param elements the elements to store in the {@code HashSet}.
+   * @return the created {@code HashSet}, or {@code null} if the given array of elements is {@code null}.
+   */
+  @SafeVarargs
+  public static <T> Set<T> set(T... elements) {
+    return newLinkedHashSet(elements);
+  }
+
   /**
    * Creates a <em>mutable</em> {@code HashSet}.
    *
diff --git a/src/test/java/org/assertj/core/internal/MapsBaseTest.java b/src/test/java/org/assertj/core/internal/MapsBaseTest.java
index 915514747..38f8e14bc 100644
--- a/src/test/java/org/assertj/core/internal/MapsBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/MapsBaseTest.java
@@ -24,7 +24,6 @@ import org.assertj.core.data.MapEntry;
 import org.assertj.core.test.WithPlayerData;
 import org.junit.jupiter.api.BeforeEach;
 
-
 /**
  * Base class for {@link Maps} unit tests
  * <p>
@@ -42,7 +41,7 @@ public class MapsBaseTest extends WithPlayerData {
   protected AssertionInfo info;
 
   @BeforeEach
-  public void setUp() {
+  protected void setUp() {
     actual = mapOf(entry("name", "Yoda"), entry("color", "green"));
     failures = spy(new Failures());
     maps = new Maps();
@@ -54,8 +53,9 @@ public class MapsBaseTest extends WithPlayerData {
   protected static MapEntry[] emptyEntries() {
     return new MapEntry[0];
   }
-  
+
   protected static String[] emptyKeys() {
     return new String[0];
   }
-}
\ No newline at end of file
+
+}
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsKey_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsKey_Test.java
index 9cbedcd12..ea6ff6f45 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsKey_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsKey_Test.java
@@ -33,7 +33,7 @@ import org.junit.jupiter.api.Test;
 
 /**
  * Tests for <code>{@link Maps#assertContainsKey(AssertionInfo, Map, Object)}</code>.
- * 
+ *
  * @author Nicolas Fran√ßois
  * @author Joel Costigliola
  */
@@ -72,4 +72,5 @@ class Maps_assertContainsKey_Test extends MapsBaseTest {
     assertThat(error).isInstanceOf(AssertionError.class);
     verify(failures).failure(info, shouldContainKeys(actual, newLinkedHashSet(key)));
   }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsOnlyKeys_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsOnlyKeys_Test.java
index 533245afe..c0226dd5a 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsOnlyKeys_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsOnlyKeys_Test.java
@@ -12,10 +12,14 @@
  */
 package org.assertj.core.internal.maps;
 
+import static java.lang.String.CASE_INSENSITIVE_ORDER;
 import static java.util.Collections.emptyMap;
 import static java.util.Collections.emptySet;
-import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static java.util.Collections.singletonMap;
+import static java.util.Collections.unmodifiableMap;
+import static org.assertj.core.api.Assertions.assertThatNoException;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.MapEntry.entry;
 import static org.assertj.core.error.ShouldContainOnlyKeys.shouldContainOnlyKeys;
 import static org.assertj.core.internal.ErrorMessages.keysToLookForIsEmpty;
@@ -23,101 +27,208 @@ import static org.assertj.core.internal.ErrorMessages.keysToLookForIsNull;
 import static org.assertj.core.test.Maps.mapOf;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
-import static org.assertj.core.util.AssertionsUtil.assertThatAssertionErrorIsThrownBy;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.mockito.Mockito.verify;
+import static org.assertj.core.util.Sets.set;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
 
-import java.util.HashSet;
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
 
+import org.apache.commons.collections4.map.CaseInsensitiveMap;
+import org.apache.commons.collections4.map.SingletonMap;
+import org.apache.commons.lang3.ArrayUtils;
 import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.assertj.core.internal.Maps;
 import org.assertj.core.internal.MapsBaseTest;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+import org.springframework.util.LinkedCaseInsensitiveMap;
+
+import com.google.common.collect.ImmutableMap;
 
 /**
- * Tests for
- * <code>{@link org.assertj.core.internal.Maps#assertContainsOnlyKeys(AssertionInfo, Map, Object[])}</code>
- * .
+ * Tests for <code>{@link Maps#assertContainsOnlyKeys(AssertionInfo, Map, Object[])}</code>.
  *
  * @author Christopher Arnott
  */
+@DisplayName("Maps assertContainsOnlyKeys(Object[])")
 class Maps_assertContainsOnlyKeys_Test extends MapsBaseTest {
 
+  private static final Supplier<Map<String, String>> CASE_INSENSITIVE_TREE_MAP = () -> new TreeMap<>(CASE_INSENSITIVE_ORDER);
+
+  @SuppressWarnings("unchecked")
+  private static final Supplier<Map<String, String>>[] CASE_INSENSITIVE_MAPS = new Supplier[] {
+      // org.apache.commons.collections4.map.CaseInsensitiveMap not included due to slightly different behavior
+      LinkedCaseInsensitiveMap::new,
+      CASE_INSENSITIVE_TREE_MAP
+  };
+
+  @SuppressWarnings("unchecked")
+  private static final Supplier<Map<String, String>>[] MODIFIABLE_MAPS = ArrayUtils.addAll(CASE_INSENSITIVE_MAPS,
+                                                                                           CaseInsensitiveMap::new,
+                                                                                           HashMap::new,
+                                                                                           IdentityHashMap::new,
+                                                                                           LinkedHashMap::new);
+
   private static final String ARRAY_OF_KEYS = "array of keys";
 
   @Test
   void should_fail_if_actual_is_null() {
     // GIVEN
-    actual = null;
+    String[] keys = { "name" };
     // WHEN
-    ThrowingCallable code = () -> maps.assertContainsOnlyKeys(someInfo(), null, array("name"));
+    AssertionError error = expectAssertionError(() -> maps.assertContainsOnlyKeys(someInfo(), null, keys));
     // THEN
-    assertThatAssertionErrorIsThrownBy(code).withMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_given_keys_array_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> maps.assertContainsOnlyKeys(someInfo(), actual, (String[]) null))
-                                    .withMessage(keysToLookForIsNull(ARRAY_OF_KEYS));
+    // GIVEN
+    String[] keys = null;
+    // WHEN
+    Throwable thrown = catchThrowable(() -> maps.assertContainsOnlyKeys(someInfo(), actual, keys));
+    // THEN
+    then(thrown).isInstanceOf(NullPointerException.class).hasMessage(keysToLookForIsNull(ARRAY_OF_KEYS));
   }
 
   @Test
   void should_fail_if_given_keys_array_is_empty() {
-    assertThatIllegalArgumentException().isThrownBy(() -> maps.assertContainsOnlyKeys(someInfo(), actual, emptyKeys()))
-                                        .withMessage(keysToLookForIsEmpty(ARRAY_OF_KEYS));
+    // GIVEN
+    String[] keys = emptyKeys();
+    // WHEN
+    Throwable thrown = catchThrowable(() -> maps.assertContainsOnlyKeys(someInfo(), actual, keys));
+    // THEN
+    then(thrown).isInstanceOf(IllegalArgumentException.class).hasMessage(keysToLookForIsEmpty(ARRAY_OF_KEYS));
   }
 
-  @Test
-  void should_pass_if_actual_and_given_keys_are_empty() {
-    maps.assertContainsOnlyKeys(someInfo(), emptyMap(), emptyKeys());
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsSuccessfulTestCases",
+      "modifiableMapsSuccessfulTestCases",
+      "caseInsensitiveMapsSuccessfulTestCases",
+  })
+  void should_pass(Map<String, String> actual, String[] expected) {
+    // WHEN/THEN
+    assertThatNoException().as(actual.getClass().getName())
+                           .isThrownBy(() -> maps.assertContainsOnlyKeys(info, actual, expected));
   }
 
-  @Test
-  void should_pass_if_actual_contains_only_expected_keys() {
-    maps.assertContainsOnlyKeys(someInfo(), actual, array("color", "name"));
-    maps.assertContainsOnlyKeys(someInfo(), actual, array("name", "color"));
+  private static Stream<Arguments> unmodifiableMapsSuccessfulTestCases() {
+    return Stream.of(arguments(emptyMap(), emptyKeys()),
+                     arguments(singletonMap("name", "Yoda"), array("name")),
+                     arguments(new SingletonMap<>("name", "Yoda"), array("name")),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))), array("name", "job")),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))), array("job", "name")),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"), array("name", "job")),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"), array("job", "name")));
   }
 
-  @Test
-  void should_fail_if_actual_contains_an_unexpected_key() {
-    // GIVEN
-    AssertionInfo info = someInfo();
-    String[] expectedKeys = { "name" };
-    // WHEN
-    expectAssertionError(() -> maps.assertContainsOnlyKeys(info, actual, expectedKeys));
-    // THEN
-    verify(failures).failure(info, shouldContainOnlyKeys(actual, expectedKeys, emptySet(), set("color")));
+  private static Stream<Arguments> modifiableMapsSuccessfulTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array("name", "job")),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array("job", "name"))));
   }
 
-  @Test
-  void should_fail_if_actual_does_not_contains_all_expected_keys() {
-    // GIVEN
-    AssertionInfo info = someInfo();
-    String[] expectedKeys = { "name", "color" };
-    Map<String, String> underTest = mapOf(entry("name", "Yoda"));
-    // WHEN
-    expectAssertionError(() -> maps.assertContainsOnlyKeys(info, underTest, expectedKeys));
-    // THEN
-    verify(failures).failure(info, shouldContainOnlyKeys(underTest, expectedKeys, set("color"), emptySet()));
+  private static Stream<Arguments> caseInsensitiveMapsSuccessfulTestCases() {
+    return Stream.of(ArrayUtils.add(CASE_INSENSITIVE_MAPS, CaseInsensitiveMap::new))
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array("name", "job")),
+                                                arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array("job", "name")),
+                                                arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array("Name", "Job")),
+                                                arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array("Job", "Name"))));
   }
 
-  @Test
-  void should_fail_if_actual_does_not_contains_all_expected_keys_and_contains_unexpected_one() {
-    // GIVEN
-    AssertionInfo info = someInfo();
-    String[] expectedKeys = { "name", "color" };
-    Map<String, String> underTest = mapOf(entry("name", "Yoda"), entry("job", "Jedi"));
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsFailureTestCases",
+      "modifiableMapsFailureTestCases",
+      "caseInsensitiveMapsFailureTestCases",
+      "commonsCollectionsCaseInsensitiveMapFailureTestCases",
+  })
+  void should_fail(Map<String, String> actual, String[] expected, Set<String> notFound, Set<String> notExpected) {
     // WHEN
-    expectAssertionError(() -> maps.assertContainsOnlyKeys(info, underTest, expectedKeys));
+    AssertionError error = expectAssertionError(() -> maps.assertContainsOnlyKeys(info, actual, expected));
     // THEN
-    verify(failures).failure(info, shouldContainOnlyKeys(underTest, expectedKeys, set("color"), set("job")));
+    then(error).as(actual.getClass().getName())
+               .hasMessage(shouldContainOnlyKeys(actual, expected, notFound, notExpected).create());
   }
 
-  private static HashSet<String> set(String entry) {
-    HashSet<String> set = new HashSet<>();
-    set.add(entry);
-    return set;
+  private static Stream<Arguments> unmodifiableMapsFailureTestCases() {
+    return Stream.of(arguments(emptyMap(),
+                               array("name"),
+                               set("name"),
+                               emptySet()),
+                     arguments(singletonMap("name", "Yoda"),
+                               array("color"),
+                               set("color"),
+                               set("name")),
+                     arguments(new SingletonMap<>("name", "Yoda"),
+                               array("color"),
+                               set("color"),
+                               set("name")),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))),
+                               array("name", "color"),
+                               set("color"),
+                               set("job")),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"),
+                               array("name", "color"),
+                               set("color"),
+                               set("job")));
   }
+
+  private static Stream<Arguments> modifiableMapsFailureTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda")),
+                                                          array("name", "color"),
+                                                          set("color"),
+                                                          emptySet()),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array("name"),
+                                                          emptySet(),
+                                                          set("job")),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array("name", "color"),
+                                                          set("color"),
+                                                          set("job"))));
+  }
+
+  private static Stream<Arguments> caseInsensitiveMapsFailureTestCases() {
+    return Stream.of(CASE_INSENSITIVE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array("name", "color"),
+                                                          set("color"),
+                                                          set("Job")),
+                                                arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array("Name", "Color"),
+                                                          set("Color"),
+                                                          set("Job"))));
+  }
+
+  private static Stream<Arguments> commonsCollectionsCaseInsensitiveMapFailureTestCases() {
+    return Stream.of(arguments(mapOf(CaseInsensitiveMap::new, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                               array("name", "color"),
+                               set("color"),
+                               set("job")), // internal keys are always lowercase
+                     arguments(mapOf(CaseInsensitiveMap::new, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                               array("Name", "Color"),
+                               set("Color"),
+                               set("job"))); // internal keys are always lowercase
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsOnly_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsOnly_Test.java
index e8dd40c3d..e0a2edc6c 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsOnly_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsOnly_Test.java
@@ -12,45 +12,78 @@
  */
 package org.assertj.core.internal.maps;
 
+import static java.lang.String.CASE_INSENSITIVE_ORDER;
 import static java.util.Collections.emptyMap;
 import static java.util.Collections.emptySet;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static java.util.Collections.singletonMap;
+import static java.util.Collections.unmodifiableMap;
+import static org.assertj.core.api.Assertions.assertThatNoException;
+import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.MapEntry.entry;
 import static org.assertj.core.error.ShouldBeEmpty.shouldBeEmpty;
 import static org.assertj.core.error.ShouldContainOnly.shouldContainOnly;
 import static org.assertj.core.internal.ErrorMessages.entriesToLookForIsNull;
+import static org.assertj.core.test.Maps.mapOf;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.mockito.Mockito.verify;
+import static org.assertj.core.util.Sets.set;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
 
-import java.util.HashSet;
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
 
+import org.apache.commons.collections4.map.CaseInsensitiveMap;
+import org.apache.commons.collections4.map.SingletonMap;
+import org.apache.commons.lang3.ArrayUtils;
 import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.data.MapEntry;
 import org.assertj.core.internal.MapsBaseTest;
-import org.assertj.core.test.Maps;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+import org.springframework.util.LinkedCaseInsensitiveMap;
+
+import com.google.common.collect.ImmutableMap;
 
 /**
- * Tests for
- * <code>{@link org.assertj.core.internal.Maps#assertContainsOnly(org.assertj.core.api.AssertionInfo, java.util.Map, org.assertj.core.data.MapEntry...)}</code>
- * .
+ * Tests for <code>{@link org.assertj.core.internal.Maps#assertContainsOnly(AssertionInfo, Map, Entry[])}</code>.
  *
  * @author Jean-Christophe Gay
  */
 class Maps_assertContainsOnly_Test extends MapsBaseTest {
 
+  private static final Supplier<Map<String, String>> CASE_INSENSITIVE_TREE_MAP = () -> new TreeMap<>(CASE_INSENSITIVE_ORDER);
+
+  @SuppressWarnings("unchecked")
+  private static final Supplier<Map<String, String>>[] CASE_INSENSITIVE_MAPS = new Supplier[] {
+      // org.apache.commons.collections4.map.CaseInsensitiveMap not included due to slightly different behavior
+      LinkedCaseInsensitiveMap::new,
+      CASE_INSENSITIVE_TREE_MAP
+  };
+
+  @SuppressWarnings("unchecked")
+  private static final Supplier<Map<String, String>>[] MODIFIABLE_MAPS = ArrayUtils.addAll(CASE_INSENSITIVE_MAPS,
+                                                                                           CaseInsensitiveMap::new,
+                                                                                           HashMap::new,
+                                                                                           IdentityHashMap::new,
+                                                                                           LinkedHashMap::new);
+
   @Test
   void should_fail_if_actual_is_null() {
     // GIVEN
-    actual = null;
-    MapEntry<String, String>[] expected = array(entry("name", "Yoda"));
+    Entry<String, String>[] entries = array(entry("name", "Yoda"));
     // WHEN
-    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsOnly(someInfo(), actual, expected));
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsOnly(someInfo(), null, entries));
     // THEN
     then(assertionError).hasMessage(actualIsNull());
   }
@@ -58,85 +91,156 @@ class Maps_assertContainsOnly_Test extends MapsBaseTest {
   @Test
   void should_fail_if_given_entries_array_is_null() {
     // GIVEN
-    MapEntry<String, String>[] entries = null;
-    // WHEN/THEN
-    assertThatNullPointerException().isThrownBy(() -> maps.assertContainsOnly(someInfo(), actual, entries))
-                                    .withMessage(entriesToLookForIsNull());
+    Entry<String, String>[] entries = null;
+    // WHEN
+    Throwable thrown = catchThrowable(() -> maps.assertContainsOnly(someInfo(), actual, entries));
+    // THEN
+    then(thrown).isInstanceOf(NullPointerException.class).hasMessage(entriesToLookForIsNull());
   }
 
+  @SuppressWarnings("unchecked")
   @Test
   void should_fail_if_given_entries_array_is_empty() {
     // GIVEN
-    AssertionInfo info = someInfo();
-    MapEntry<String, String>[] expected = emptyEntries();
+    Entry<String, String>[] entries = emptyEntries();
     // WHEN
-    expectAssertionError(() -> maps.assertContainsOnly(info, actual, expected));
+    AssertionError error = expectAssertionError(() -> maps.assertContainsOnly(someInfo(), actual, entries));
     // THEN
-    verify(failures).failure(info, shouldBeEmpty(actual));
+    then(error).hasMessage(shouldBeEmpty(actual).create());
   }
 
-  @Test
-  void should_pass_if_actual_and_entries_are_empty() {
-    maps.assertContainsOnly(someInfo(), emptyMap(), array());
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsSuccessfulTestCases",
+      "modifiableMapsSuccessfulTestCases",
+      "caseInsensitiveMapsSuccessfulTestCases",
+  })
+  void should_pass(Map<String, String> actual, Entry<String, String>[] expected) {
+    // WHEN/THEN
+    assertThatNoException().as(actual.getClass().getName())
+                           .isThrownBy(() -> maps.assertContainsOnly(info, actual, expected));
   }
 
-  @Test
-  void should_pass_if_actual_contains_only_expected_entries() {
-    maps.assertContainsOnly(someInfo(), actual, array(entry("name", "Yoda"), entry("color", "green")));
+  private static Stream<Arguments> unmodifiableMapsSuccessfulTestCases() {
+    return Stream.of(arguments(emptyMap(), emptyEntries()),
+                     arguments(singletonMap("name", "Yoda"),
+                               array(entry("name", "Yoda"))),
+                     arguments(new SingletonMap<>("name", "Yoda"),
+                               array(entry("name", "Yoda"))),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))),
+                               array(entry("name", "Yoda"), entry("job", "Jedi"))),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))),
+                               array(entry("job", "Jedi"), entry("name", "Yoda"))),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"),
+                               array(entry("name", "Yoda"), entry("job", "Jedi"))),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"),
+                               array(entry("job", "Jedi"), entry("name", "Yoda"))));
   }
 
-  @Test
-  void should_fail_if_actual_contains_unexpected_entry() {
-    // GIVEN
-    AssertionInfo info = someInfo();
-    MapEntry<String, String>[] expected = array(entry("name", "Yoda"));
-    // WHEN
-    expectAssertionError(() -> maps.assertContainsOnly(info, actual, expected));
-    // THEN
-    verify(failures).failure(info, shouldContainOnly(actual, expected, emptySet(), set(entry("color", "green"))));
+  private static Stream<Arguments> modifiableMapsSuccessfulTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array(entry("name", "Yoda"), entry("job", "Jedi"))),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array(entry("job", "Jedi"), entry("name", "Yoda")))));
   }
 
-  @Test
-  void should_fail_if_actual_does_not_contains_every_expected_entries() {
-    // GIVEN
-    AssertionInfo info = someInfo();
-    MapEntry<String, String>[] expected = array(entry("name", "Yoda"), entry("color", "green"));
-    Map<String, String> underTest = Maps.mapOf(entry("name", "Yoda"));
-    // WHEN
-    expectAssertionError(() -> maps.assertContainsOnly(info, underTest, expected));
-    // THEN
-    verify(failures).failure(info, shouldContainOnly(underTest, expected, set(entry("color", "green")), emptySet()));
+  private static Stream<Arguments> caseInsensitiveMapsSuccessfulTestCases() {
+    return Stream.of(ArrayUtils.add(CASE_INSENSITIVE_MAPS, CaseInsensitiveMap::new))
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array(entry("name", "Yoda"), entry("job", "Jedi"))),
+                                                arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array(entry("job", "Jedi"), entry("name", "Yoda"))),
+                                                arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array(entry("Name", "Yoda"), entry("Job", "Jedi"))),
+                                                arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array(entry("Job", "Jedi"), entry("Name", "Yoda")))));
   }
 
-  @Test
-  void should_fail_if_actual_does_not_contains_every_expected_entries_and_contains_unexpected_one() {
-    // GIVEN
-    AssertionInfo info = someInfo();
-    MapEntry<String, String>[] expected = array(entry("name", "Yoda"), entry("color", "green"));
-    Map<String, String> underTest = Maps.mapOf(entry("name", "Yoda"), entry("job", "Jedi"));
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsFailureTestCases",
+      "modifiableMapsFailureTestCases",
+      "caseInsensitiveMapsFailureTestCases",
+      "commonsCollectionsCaseInsensitiveMapFailureTestCases",
+      "orderDependentFailureTestCases",
+  })
+  void should_fail(Map<String, String> actual, Entry<String, String>[] expected,
+                   Set<Entry<String, String>> notFound, Set<Entry<String, String>> notExpected) {
     // WHEN
-    expectAssertionError(() -> maps.assertContainsOnly(info, underTest, expected));
+    AssertionError error = expectAssertionError(() -> maps.assertContainsOnly(info, actual, expected));
     // THEN
-    verify(failures).failure(info,
-                             shouldContainOnly(underTest, expected, set(entry("color", "green")), set(entry("job", "Jedi"))));
+    then(error).as(actual.getClass().getName())
+               .hasMessage(shouldContainOnly(actual, expected, notFound, notExpected).create());
   }
 
-  @Test
-  void should_fail_if_actual_contains_entry_key_with_different_value() {
-    // GIVEN
-    AssertionInfo info = someInfo();
-    MapEntry<String, String>[] expectedEntries = array(entry("name", "Yoda"), entry("color", "yellow"));
-    // WHEN
-    expectAssertionError(() -> maps.assertContainsOnly(info, actual, expectedEntries));
-    // THEN
-    verify(failures).failure(info, shouldContainOnly(actual, expectedEntries, set(entry("color", "yellow")),
-                                                     set(entry("color", "green"))));
+  private static Stream<Arguments> unmodifiableMapsFailureTestCases() {
+    return Stream.of(arguments(emptyMap(),
+                               array(entry("name", "Yoda")),
+                               set(entry("name", "Yoda")),
+                               emptySet()),
+                     arguments(singletonMap("name", "Yoda"),
+                               array(entry("color", "Green")),
+                               set(entry("color", "Green")),
+                               set(entry("name", "Yoda"))),
+                     arguments(new SingletonMap<>("name", "Yoda"),
+                               array(entry("color", "Green")),
+                               set(entry("color", "Green")),
+                               set(entry("name", "Yoda"))),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))),
+                               array(entry("name", "Yoda"), entry("color", "Green")),
+                               set(entry("color", "Green")),
+                               set(entry("job", "Jedi"))),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"),
+                               array(entry("name", "Yoda"), entry("color", "Green")),
+                               set(entry("color", "Green")),
+                               set(entry("job", "Jedi"))));
+  }
+
+  private static Stream<Arguments> modifiableMapsFailureTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda")),
+                                                          array(entry("name", "Yoda"), entry("color", "Green")),
+                                                          set(entry("color", "Green")),
+                                                          emptySet()),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array(entry("name", "Yoda")),
+                                                          emptySet(),
+                                                          set(entry("job", "Jedi"))),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array(entry("name", "Yoda"), entry("color", "Green")),
+                                                          set(entry("color", "Green")),
+                                                          set(entry("job", "Jedi")))));
+  }
+
+  private static Stream<Arguments> caseInsensitiveMapsFailureTestCases() {
+    return Stream.of(CASE_INSENSITIVE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array(entry("name", "Yoda"), entry("color", "Green")),
+                                                          set(entry("color", "Green")),
+                                                          set(entry("Job", "Jedi"))),
+                                                arguments(mapOf(supplier, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                                                          array(entry("Name", "Yoda"), entry("Color", "Green")),
+                                                          set(entry("Color", "Green")),
+                                                          set(entry("Job", "Jedi")))));
+  }
+
+  private static Stream<Arguments> commonsCollectionsCaseInsensitiveMapFailureTestCases() {
+    return Stream.of(arguments(mapOf(CaseInsensitiveMap::new, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                               array(entry("name", "Yoda"), entry("color", "Green")),
+                               set(entry("color", "Green")),
+                               set(entry("job", "Jedi"))),  // internal keys are always lowercase
+                     arguments(mapOf(CaseInsensitiveMap::new, entry("NAME", "Yoda"), entry("Job", "Jedi")),
+                               array(entry("Name", "Yoda"), entry("Color", "Green")),
+                               set(entry("Color", "Green")),
+                               set(entry("job", "Jedi"))));  // internal keys are always lowercase
   }
 
-  private static <K, V> HashSet<MapEntry<K, V>> set(MapEntry<K, V> entry) {
-    HashSet<MapEntry<K, V>> set = new HashSet<>();
-    set.add(entry);
-    return set;
+  private static Stream<Arguments> orderDependentFailureTestCases() {
+    return Stream.of(arguments(mapOf(LinkedHashMap::new, entry("name", "Yoda"), entry("job", "Jedi")),
+                               array(entry("name", "Jedi"), entry("job", "Yoda")),
+                               set(entry("name", "Jedi"), entry("job", "Yoda")),
+                               set(entry("name", "Yoda"), entry("job", "Jedi"))));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainKeys_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainKeys_Test.java
index e752b2fef..787001787 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainKeys_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainKeys_Test.java
@@ -12,32 +12,41 @@
  */
 package org.assertj.core.internal.maps;
 
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldNotContainKeys.shouldNotContainKeys;
+import static org.assertj.core.internal.ErrorMessages.keysToLookForIsNull;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.assertj.core.util.Sets.newLinkedHashSet;
-import static org.mockito.Mockito.verify;
+import static org.assertj.core.util.Sets.set;
+
+import java.util.Map;
 
 import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Maps;
 import org.assertj.core.internal.MapsBaseTest;
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.NullSource;
+import org.junit.jupiter.params.provider.ValueSource;
 
 /**
- * Tests for <code>{@link org.assertj.core.internal.Maps#assertDoesNotContainKeys(AssertionInfo, java.util.Map, Object[])}</code>.
+ * Tests for <code>{@link Maps#assertDoesNotContainKeys(AssertionInfo, Map, Object[])}</code>.
  *
  * @author dorzey
  */
+@DisplayName("Maps assertDoesNotContainKeys")
 class Maps_assertDoesNotContainKeys_Test extends MapsBaseTest {
 
+  private static final String ARRAY_OF_KEYS = "array of keys";
+
   @Override
   @BeforeEach
-  public void setUp() {
+  protected void setUp() {
     super.setUp();
     actual.put(null, null);
   }
@@ -50,39 +59,43 @@ class Maps_assertDoesNotContainKeys_Test extends MapsBaseTest {
   @Test
   void should_fail_if_actual_is_null() {
     // GIVEN
-    actual = null;
+    String[] keys = { "name" };
     // WHEN
-    AssertionError assertionError = expectAssertionError(() -> maps.assertDoesNotContainKeys(someInfo(), null,
-                                                                                             array("name", "color")));
+    AssertionError error = expectAssertionError(() -> maps.assertDoesNotContainKeys(someInfo(), null, keys));
     // THEN
-    then(assertionError).hasMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
-  void should_pass_if_key_is_null() {
-    maps.assertDoesNotContainKeys(someInfo(), actual, new String[] { null });
+  void should_fail_if_given_keys_array_is_null() {
+    // GIVEN
+    String[] keys = null;
+    // WHEN
+    Throwable thrown = catchThrowable(() -> maps.assertDoesNotContainKeys(someInfo(), actual, keys));
+    // THEN
+    then(thrown).isInstanceOf(NullPointerException.class).hasMessage(keysToLookForIsNull(ARRAY_OF_KEYS));
   }
 
-  @Test
-  void should_fail_if_actual_contains_key() {
-    AssertionInfo info = someInfo();
-    String key = "name";
-
-    Throwable error = catchThrowable(() -> maps.assertDoesNotContainKeys(info, actual, new String[] { key }));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldNotContainKeys(actual, newLinkedHashSet(key)));
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "name", "color" })
+  void should_fail_if_actual_contains_key(String key) {
+    // GIVEN
+    String[] keys = { key };
+    // WHEN
+    AssertionError error = expectAssertionError(() -> maps.assertDoesNotContainKeys(someInfo(), actual, keys));
+    // THEN
+    then(error).hasMessage(shouldNotContainKeys(actual, set(key)).create());
   }
 
   @Test
   void should_fail_if_actual_contains_keys() {
-    AssertionInfo info = someInfo();
-    String key1 = "name";
-    String key2 = "color";
-
-    Throwable error = catchThrowable(() -> maps.assertDoesNotContainKeys(info, actual, new String[] { key1, key2 }));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldNotContainKeys(actual, newLinkedHashSet(key1, key2)));
+    // GIVEN
+    String[] keys = { "name", "color" };
+    // WHEN
+    AssertionError error = expectAssertionError(() -> maps.assertDoesNotContainKeys(someInfo(), actual, keys));
+    // THEN
+    then(error).hasMessage(shouldNotContainKeys(actual, set("name", "color")).create());
   }
+
 }
diff --git a/src/test/java/org/assertj/core/test/Maps.java b/src/test/java/org/assertj/core/test/Maps.java
index d02a1ce18..485866643 100644
--- a/src/test/java/org/assertj/core/test/Maps.java
+++ b/src/test/java/org/assertj/core/test/Maps.java
@@ -13,7 +13,9 @@
 package org.assertj.core.test;
 
 import java.util.LinkedHashMap;
+import java.util.Map;
 import java.util.TreeMap;
+import java.util.function.Supplier;
 
 import org.assertj.core.data.MapEntry;
 
@@ -24,18 +26,19 @@ public final class Maps {
 
   @SafeVarargs
   public static <K, V> LinkedHashMap<K, V> mapOf(MapEntry<K, V>... entries) {
-    LinkedHashMap<K, V> map = new LinkedHashMap<>();
-    for (MapEntry<K, V> entry : entries) {
-      map.put(entry.key, entry.value);
-    }
-    return map;
+    return mapOf(LinkedHashMap::new, entries);
   }
 
   @SafeVarargs
   public static <K extends Comparable<? super K>, V> TreeMap<K, V> treeMapOf(MapEntry<K, V>... entries) {
-    TreeMap<K, V> map = new TreeMap<>();
-    for (MapEntry<K, V> entry : entries) {
-      map.put(entry.key, entry.value);
+    return mapOf(TreeMap::new, entries);
+  }
+
+  @SafeVarargs
+  public static <K, V, M extends Map<K, V>> M mapOf(Supplier<M> supplier, Map.Entry<K, V>... entries) {
+    M map = supplier.get();
+    for (Map.Entry<K, V> entry : entries) {
+      map.put(entry.getKey(), entry.getValue());
     }
     return map;
   }
