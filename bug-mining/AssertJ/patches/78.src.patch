diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 1817d5219..102800a5e 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -626,16 +626,31 @@ public class Assertions {
   }
 
   /**
-   * Globally set whether <code>{@link org.assertj.core.api.AbstractIterableAssert#extracting(String) IterableAssert#extracting(String)}</code> and
+   * Globally sets whether <code>{@link org.assertj.core.api.AbstractIterableAssert#extracting(String) IterableAssert#extracting(String)}</code> and
    * <code>{@link org.assertj.core.api.AbstractObjectArrayAssert#extracting(String) ObjectArrayAssert#extracting(String)}</code>
    * should be allowed to extract private fields, if not and they try it fails with exception.
    *
    * @param allowExtractingPrivateFields allow private fields extraction. Default {@code true}.
    */
   public static void setAllowExtractingPrivateFields(boolean allowExtractingPrivateFields) {
-    FieldSupport.setAllowExtractingPrivateFields(allowExtractingPrivateFields);
+    FieldSupport.extraction().setAllowUsingPrivateFields(allowExtractingPrivateFields);
   }
 
+  /**
+   * Globally sets whether the use of private fields is allowed for comparison.
+   * The following (incomplete) list of methods will be impacted by this change :
+   * <ul>
+   *   <li><code><code>{@link org.assertj.core.api.AbstractIterableAssert#usingElementComparatorOnFields(java.lang.String...)}</code></li>
+   *   <li><code>{@link org.assertj.core.api.AbstractObjectAssert#isEqualToComparingFieldByField(A)}</code></li>
+   * </ul>
+   *
+   * If the value is <code>false</code> and these methods try to compare private fields, it will fail with an exception.
+   *
+   * @param allowComparingPrivateFields allow private fields comparison. Default {@code true}.
+   */
+  public static void setAllowComparingPrivateFields(boolean allowComparingPrivateFields) {
+    FieldSupport.comparison().setAllowUsingPrivateFields(allowComparingPrivateFields);
+  }
   // ------------------------------------------------------------------------------------------------------
   // Data utility methods : not assertions but here to have a single entry point to all AssertJ features.
   // ------------------------------------------------------------------------------------------------------
diff --git a/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java b/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
index 06ece984d..7b1009b96 100644
--- a/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
+++ b/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
@@ -29,7 +29,7 @@ class ByNameSingleExtractor<T> implements Extractor<T, Object> {
     } catch (IntrospectionError fieldIntrospectionError) {
       // no luck with properties, let's try fields
       try {
-        return FieldSupport.instance().fieldValue(propertyOrFieldName, Object.class, input);
+        return FieldSupport.extraction().fieldValue(propertyOrFieldName, Object.class, input);
       } catch (IntrospectionError propertyIntrospectionError) {
         // no field nor property found with given name, it is considered as an error
         String message = format(
diff --git a/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java b/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java
index af77323fc..3bc5d7865 100644
--- a/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java
+++ b/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java
@@ -2,8 +2,11 @@ package org.assertj.core.internal;
 
 import java.util.Comparator;
 
+import org.assertj.core.api.Assertions;
+
 /**
- * Compare Object field by field
+ * Compare Object field by field including private fields unless
+ * {@link Assertions#setAllowComparingPrivateFields(boolean)}has been called with false.
  */
 public class FieldByFieldComparator implements Comparator<Object> {
 
diff --git a/src/main/java/org/assertj/core/internal/Objects.java b/src/main/java/org/assertj/core/internal/Objects.java
index 8535f7c7c..4bda55eac 100644
--- a/src/main/java/org/assertj/core/internal/Objects.java
+++ b/src/main/java/org/assertj/core/internal/Objects.java
@@ -67,8 +67,7 @@ public class Objects {
   private final ComparisonStrategy comparisonStrategy;
   @VisibleForTesting
   Failures failures = Failures.instance();
-  // field support not reading private fields
-  private FieldSupport fieldSupport = new FieldSupport(false);
+  private final FieldSupport fieldSupport = FieldSupport.comparison();
 
   /**
    * Returns the singleton instance of this class based on {@link StandardComparisonStrategy}.
@@ -539,11 +538,11 @@ public class Objects {
 	List<String> nullFields = new LinkedList<String>();
 	for (Field field : getDeclaredFieldsIncludingInherited(actual.getClass())) {
 	  try {
-		Object otherFieldValue = getFieldOrPropertyValue(other, field);
+		Object otherFieldValue = getFieldOrPropertyValue(other, field.getName());
 		if (otherFieldValue == null) {
 		  nullFields.add(field.getName());
 		} else {
-		  Object actualFieldValue = getFieldOrPropertyValue(actual, field);
+		  Object actualFieldValue = getFieldOrPropertyValue(actual, field.getName());
 		  if (!otherFieldValue.equals(actualFieldValue)) {
 			fieldsNames.add(field.getName());
 			rejectedValues.add(actualFieldValue);
@@ -588,8 +587,8 @@ public class Objects {
 	List<Object> expectedValues = new LinkedList<Object>();
 	List<Object> rejectedValues = new LinkedList<Object>();
 	for (String fieldName : fields) {
-	  Object actualFieldValue = getNestedFieldOrPropertyValue(actual, fieldName);
-	  Object otherFieldValue = getNestedFieldOrPropertyValue(other, fieldName);
+	  Object actualFieldValue = getFieldOrPropertyValue(actual, fieldName);
+	  Object otherFieldValue = getFieldOrPropertyValue(other, fieldName);
 	  if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
 		rejectedFieldsNames.add(fieldName);
 		expectedValues.add(otherFieldValue);
@@ -631,23 +630,25 @@ public class Objects {
 	List<Object> rejectedValues = new LinkedList<Object>();
 	Set<String> ignoredFields = newLinkedHashSet(givenIgnoredFields);
 	for (Field field : declaredFieldsIncludingInherited) {
-	  try {
-		if (!ignoredFields.contains(field.getName())) {
-		  Object actualFieldValue = getFieldOrPropertyValue(actual, field);
-		  Object otherFieldValue = getFieldOrPropertyValue(other, field);
-		  if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
-			fieldsNames.add(field.getName());
-			rejectedValues.add(actualFieldValue);
-			expectedValues.add(otherFieldValue);
-		  }
-		}
-	  } catch (IntrospectionError e) {
-		// Not readable field, skip.
+	  // ignore private field if user has decided not to use them in comparison
+	  if (ignoredFields.contains(field.getName()) || !canReadFieldValue(field, actual)) {
+		continue;
+	  }
+	  Object actualFieldValue = getFieldOrPropertyValue(actual, field.getName());
+	  Object otherFieldValue = getFieldOrPropertyValue(other, field.getName());
+	  if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
+		fieldsNames.add(field.getName());
+		rejectedValues.add(actualFieldValue);
+		expectedValues.add(otherFieldValue);
 	  }
 	}
 	return new ByFieldsComparison(fieldsNames, expectedValues, rejectedValues);
   }
 
+  private <A> boolean canReadFieldValue(Field field, A actual) {
+	return fieldSupport.isAllowedToRead(field) || propertySupport.publicGetterExistsFor(field.getName(), actual);
+  }
+
   private <A> void verifyIgnoredFieldsExist(A actual, Set<Field> declaredFields, String[] ignoredFields) {
 	Set<String> ignoredFieldsNotDefined = newLinkedHashSet(ignoredFields);
 	for (Field f : declaredFields) {
@@ -655,39 +656,22 @@ public class Objects {
 	}
 	if (!ignoredFieldsNotDefined.isEmpty()) {
 	  throw new IllegalArgumentException(format("Fields to ignore <%s> not defined for type <%s>",
-	                                            ignoredFieldsNotDefined, actual.getClass().getCanonicalName()));
-	}
-  }
-
-  /**
-   * Get field value first and in case of error try its value from property getter (property name being field name)
-   *
-   * @param a the object to get field value from
-   * @param field Field to read
-   * @param <A> the type of object a
-   * @return field value or property value if field was not accessible.
-   * @throws IntrospectionError is field value can't get retrieved.
-   */
-  private <A> Object getFieldOrPropertyValue(A a, Field field) {
-	try {
-	  // read field value
-	  return field.get(a);
-	} catch (IllegalAccessException e) {
-	  // field is not accessible, let's try to get its value from its getter if any.
-	  return propertySupport.propertyValue(field.getName(), Object.class, a);
+		                                        ignoredFieldsNotDefined, actual.getClass().getCanonicalName()));
 	}
   }
 
   /**
-   * Get nested field value first and in case of error try its value from property getter (property name being field
+   * Get field value first and in case of error try its value from property getter (property name being field
    * name)
+   * <p>
+   * This method supports nested field/property (e.g. "address.street.number").
    *
    * @param a the object to get field value from
    * @param fieldName Field name to read, can be nested
    * @return (nested) field value or property value if field was not accessible.
    * @throws IntrospectionError is field value can't get retrieved.
    */
-  private <A> Object getNestedFieldOrPropertyValue(A a, String fieldName) {
+  private <A> Object getFieldOrPropertyValue(A a, String fieldName) {
 	try {
 	  return fieldSupport.fieldValue(fieldName, Object.class, a);
 	} catch (IntrospectionError e) {
diff --git a/src/main/java/org/assertj/core/internal/PropertySupport.java b/src/main/java/org/assertj/core/internal/PropertySupport.java
index eff080edf..98d1ffed7 100644
--- a/src/main/java/org/assertj/core/internal/PropertySupport.java
+++ b/src/main/java/org/assertj/core/internal/PropertySupport.java
@@ -195,4 +195,13 @@ public class PropertySupport {
     return propertyValues(fieldOrPropertyName, Object.class, objects);
   }
 
+  public boolean publicGetterExistsFor(String fieldName, Object actual) {
+	try {
+	  getProperty(fieldName, actual);
+    } catch (IntrospectionError e) {
+      return false;
+    }
+	return true;
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
index 06aaac00b..a9b8359a4 100644
--- a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
+++ b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
@@ -15,63 +15,93 @@
 package org.assertj.core.util.introspection;
 
 import static java.lang.String.format;
+import static java.lang.reflect.Modifier.isPublic;
 import static java.util.Collections.emptyList;
 import static java.util.Collections.unmodifiableList;
 import static org.assertj.core.util.ArrayWrapperList.wrap;
 import static org.assertj.core.util.Iterables.isNullOrEmpty;
 
+import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Utility methods for fields access.
- * 
+ *
  * @author Joel Costigliola
  */
-public class FieldSupport {
+public enum FieldSupport {
 
-  private static final String SEPARATOR = ".";
+  EXTRACTION(true),
+  COMPARISON(true);
 
-  private static final FieldSupport INSTANCE = new FieldSupport(true);
+  private static final String SEPARATOR = ".";
 
-  private boolean allowExtractingPrivateFields;
+  private boolean allowUsingPrivateFields;
 
   /**
-   * Returns the singleton instance of this class.
-   * 
-   * @return the singleton instance of this class.
+   * Returns the instance dedicated to extraction of fields.
+   *
+   * @return the instance dedicated to extraction of fields.
    */
-  public static FieldSupport instance() {
-	return INSTANCE;
+  public static FieldSupport extraction() {
+	return EXTRACTION;
   }
 
+  /**
+   * Returns the instance dedicated to comparison of fields.
+   *
+   * @return the instance dedicated to comparison of fields.
+   */
+  public static FieldSupport comparison() {
+	return COMPARISON;
+  }
+  
   /**
    * Build a new {@link FieldSupport}
-   * 
-   * @param allowExtractingPrivateFields wether to read private fields or not.
+   *
+   * @param allowUsingPrivateFields whether to read private fields or not.
    */
-  public FieldSupport(boolean allowExtractingPrivateFields) {
-	this.allowExtractingPrivateFields = allowExtractingPrivateFields;
+  FieldSupport(boolean allowUsingPrivateFields) {
+	this.allowUsingPrivateFields = allowUsingPrivateFields;
+  }
+  
+  public boolean isAllowedToUsePrivateFields() {
+	return allowUsingPrivateFields;
   }
 
   /**
-   * Globally set whether
+   * Globally sets whether
    * <code>{@link org.assertj.core.api.AbstractIterableAssert#extracting(String) IterableAssert#extracting(String)}</code>
    * and
    * <code>{@link org.assertj.core.api.AbstractObjectArrayAssert#extracting(String) ObjectArrayAssert#extracting(String)}</code>
    * should be allowed to extract private fields, if not and they try it fails with exception.
    *
    * @param allowExtractingPrivateFields allow private fields extraction. Default {@code true}.
+   *
+   * @deprecated Use {@link #setAllowUsingPrivateFields(boolean)} instead
    */
+  @Deprecated
   public static void setAllowExtractingPrivateFields(boolean allowExtractingPrivateFields) {
-	FieldSupport.INSTANCE.allowExtractingPrivateFields = allowExtractingPrivateFields;
+	EXTRACTION.setAllowUsingPrivateFields(allowExtractingPrivateFields);
+  }
+
+
+  /**
+   * Sets whether the use of private fields is allowed.
+   * If a method tries to extract/compare private fields and is not allowed to, it will fail with an exception.
+   *
+   * @param allowUsingPrivateFields allow private fields extraction and comparison. Default {@code true}.
+   */
+  public void setAllowUsingPrivateFields(boolean allowUsingPrivateFields) {
+	this.allowUsingPrivateFields = allowUsingPrivateFields;
   }
 
   /**
    * Returns a <code>{@link List}</code> containing the values of the given field name, from the elements of the given
    * <code>{@link Iterable}</code>. If the given {@code Iterable} is empty or {@code null}, this method will return an
    * empty {@code List}. This method supports nested fields (e.g. "address.street.number").
-   * 
+   *
    * @param fieldName the name of the field. It may be a nested field. It is left to the clients to validate for
    *          {@code null} or empty.
    * @param fieldClass the expected type of the given field.
@@ -100,7 +130,7 @@ public class FieldSupport {
    * Returns a <code>{@link List}</code> containing the values of the given field name, from the elements of the given
    * <code>{@link Iterable}</code>. If the given {@code Iterable} is empty or {@code null}, this method will return an
    * empty {@code List}. This method supports nested fields (e.g. "address.street.number").
-   * 
+   *
    * @param fieldName the name of the field. It may be a nested field. It is left to the clients to validate for
    *          {@code null} or empty.
    * @param fieldClass the expected type of the given field.
@@ -182,7 +212,7 @@ public class FieldSupport {
 
   private <T> T readSimpleField(String fieldName, Class<T> clazz, Object target) {
 	try {
-	  Object readField = FieldUtils.readField(target, fieldName, allowExtractingPrivateFields);
+	  Object readField = FieldUtils.readField(target, fieldName, allowUsingPrivateFields);
 	  return clazz.cast(readField);
 	} catch (ClassCastException e) {
 	  String msg = format("Unable to obtain the value of the field <'%s'> from <%s> - wrong field type specified <%s>",
@@ -198,4 +228,10 @@ public class FieldSupport {
 	}
   }
 
+  public boolean isAllowedToRead(Field field) {
+	if (allowUsingPrivateFields) return true;
+	// only read public field
+    return isPublic(field.getModifiers()); 
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/FieldByFieldComparator_compareTo_Test.java b/src/test/java/org/assertj/core/internal/FieldByFieldComparator_compareTo_Test.java
index 0c7b86b80..ef8d1744a 100644
--- a/src/test/java/org/assertj/core/internal/FieldByFieldComparator_compareTo_Test.java
+++ b/src/test/java/org/assertj/core/internal/FieldByFieldComparator_compareTo_Test.java
@@ -4,6 +4,7 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.ExpectedException.none;
 
 import org.assertj.core.test.ExpectedException;
+import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -47,7 +48,7 @@ public class FieldByFieldComparator_compareTo_Test {
 
   @Test
   public void should_throw_exception_if_Objects_have_not_the_same_properties() {
-	thrown.expect(IllegalArgumentException.class);
+	thrown.expect(IntrospectionError.class);
 	assertThat(fieldByFieldComparator.compare(new JarJar("Yoda"), 2)).isNotZero();
   }
 
diff --git a/src/test/java/org/assertj/core/internal/IgnoringFieldsComparator_compareTo_Test.java b/src/test/java/org/assertj/core/internal/IgnoringFieldsComparator_compareTo_Test.java
index a4f03a95b..5ec1b0a4d 100644
--- a/src/test/java/org/assertj/core/internal/IgnoringFieldsComparator_compareTo_Test.java
+++ b/src/test/java/org/assertj/core/internal/IgnoringFieldsComparator_compareTo_Test.java
@@ -4,6 +4,7 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.ExpectedException.none;
 
 import org.assertj.core.test.ExpectedException;
+import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -49,7 +50,7 @@ public class IgnoringFieldsComparator_compareTo_Test {
 
   @Test
   public void should_throw_exception_if_Objects_have_not_the_same_properties() {
-	thrown.expect(IllegalArgumentException.class);
+	thrown.expect(IntrospectionError.class);
 	assertThat(ignoringFieldsComparator.compare(new DarthVader("I like you", "I'll kill you"), 2)).isNotZero();
   }
 
diff --git a/src/test/java/org/assertj/core/internal/ObjectsBaseTest.java b/src/test/java/org/assertj/core/internal/ObjectsBaseTest.java
index 3c68183af..1389157fb 100644
--- a/src/test/java/org/assertj/core/internal/ObjectsBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/ObjectsBaseTest.java
@@ -20,10 +20,7 @@ import static org.mockito.Mockito.spy;
 
 import java.util.Comparator;
 
-import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
-import org.assertj.core.internal.Failures;
-import org.assertj.core.internal.Objects;
-import org.assertj.core.internal.StandardComparisonStrategy;
+import org.assertj.core.api.Assertions;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.util.CaseInsensitiveStringComparator;
 import org.junit.Before;
@@ -61,6 +58,7 @@ public class ObjectsBaseTest {
     customComparisonStrategy = new ComparatorBasedComparisonStrategy(comparatorForCustomComparisonStrategy());
     objectsWithCustomComparisonStrategy = new Objects(customComparisonStrategy);
     objectsWithCustomComparisonStrategy.failures = failures;
+    Assertions.setAllowComparingPrivateFields(true); //reverts to default value
   }
 
   protected Comparator<?> comparatorForCustomComparisonStrategy() {
diff --git a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
index b60247d42..780898b1d 100644
--- a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
+++ b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
@@ -14,23 +14,23 @@
  */
 package org.assertj.core.internal;
 
-import static junit.framework.Assert.*;
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertSame;
 import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.introspection.Introspection.getProperty;
-
 import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import java.beans.PropertyDescriptor;
-import java.util.*;
-
+import java.util.Collection;
+import java.util.List;
 
-import org.assertj.core.internal.JavaBeanDescriptor;
-import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.test.Name;
 import org.assertj.core.util.introspection.IntrospectionError;
-
-import org.junit.*;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
 
 /**
  * Tests for <code>{@link PropertySupport#propertyValues(String, Collection)}</code>.
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java
index 3c3bacc13..08d903f64 100644
--- a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java
@@ -25,11 +25,13 @@ import static org.mockito.Mockito.verify;
 import java.util.List;
 
 import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.api.Assertions;
 import org.assertj.core.internal.ObjectsBaseTest;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.Jedi;
 import org.assertj.core.test.Name;
 import org.assertj.core.test.Player;
+import org.assertj.core.util.introspection.FieldSupport;
 import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.Test;
 
@@ -138,14 +140,24 @@ public class Objects_assertIsEqualToComparingOnlyGivenFields_Test extends Object
 	Jedi other = new Jedi("Yoda", "Blue");
 	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "age");
   }
-
+  
   @Test
-  public void should_fail_when_selected_field_is_not_accessible() {
+  public void should_fail_when_selected_field_is_not_accessible_and_private_field_use_is_forbidden() {
+	boolean allowedToUsePrivateFields = FieldSupport.comparison().isAllowedToUsePrivateFields();
+    Assertions.setAllowComparingPrivateFields(false);
 	thrown.expect(IntrospectionError.class,
 		"Unable to obtain the value of <'strangeNotReadablePrivateField'> field/property from <Yoda the Jedi>, expecting a public field or getter");
 	Jedi actual = new Jedi("Yoda", "Green");
 	Jedi other = new Jedi("Yoda", "Blue");
 	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "strangeNotReadablePrivateField");
+    Assertions.setAllowComparingPrivateFields(allowedToUsePrivateFields);
+  }
+
+  @Test
+  public void should_pass_when_selected_field_is_private_and_private_field_use_is_allowed() {
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Yoda", "Blue");
+	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "strangeNotReadablePrivateField");
   }
   
 }
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByIgnoringFields_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByIgnoringFields_Test.java
index de50d71af..f793dad9a 100644
--- a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByIgnoringFields_Test.java
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByIgnoringFields_Test.java
@@ -14,23 +14,24 @@
  */
 package org.assertj.core.internal.objects;
 
-import static org.assertj.core.error.ShouldBeInstance.shouldBeInstance;
 import static org.assertj.core.error.ShouldBeEqualToIgnoringFields.shouldBeEqualToIgnoringGivenFields;
+import static org.assertj.core.error.ShouldBeInstance.shouldBeInstance;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Lists.newArrayList;
-
-
 import static org.mockito.Mockito.verify;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.api.Assertions;
 import org.assertj.core.internal.ObjectsBaseTest;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.Jedi;
+import org.assertj.core.test.TestClassWithRandomId;
+import org.assertj.core.util.introspection.FieldSupport;
 import org.junit.Test;
 
 
@@ -46,6 +47,7 @@ public class Objects_assertIsLenientEqualsToByIgnoringFields_Test extends Object
   public void should_pass_when_fields_are_equal() {
     Jedi actual = new Jedi("Yoda", "Green");
     Jedi other = new Jedi("Yoda", "Green");
+	// strangeNotReadablePrivateField fields are compared and are null in both actual and other
     objects.assertIsEqualToIgnoringGivenFields(someInfo(), actual, other);
   }
 
@@ -53,6 +55,7 @@ public class Objects_assertIsLenientEqualsToByIgnoringFields_Test extends Object
   public void should_pass_when_not_ignored_fields_are_equal() {
     Jedi actual = new Jedi("Yoda", "Green");
     Jedi other = new Jedi("Yoda", "Blue");
+	// strangeNotReadablePrivateField fields are compared and are null in both actual and other
     objects.assertIsEqualToIgnoringGivenFields(someInfo(), actual, other, "lightSaberColor");
   }
 
@@ -142,6 +145,16 @@ public class Objects_assertIsLenientEqualsToByIgnoringFields_Test extends Object
     failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
+  @Test
+  public void should_fail_when_asked_to_ignore_non_existent_fields() {
+	thrown.expect(RuntimeException.class,
+	              "Fields to ignore <[field1, field2]> not defined for type <org.assertj.core.test.Jedi>");
+	AssertionInfo info = someInfo();
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Yoda", "Green");
+	objects.assertIsEqualToIgnoringGivenFields(info, actual, other, "field1", "field2");
+  }
+  
   @Test
   public void should_fail_when_some_field_value_is_null_on_one_object_only() {
     AssertionInfo info = someInfo();
@@ -159,4 +172,16 @@ public class Objects_assertIsLenientEqualsToByIgnoringFields_Test extends Object
     failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
+  @Test
+  public void should_pass_when_private_fields_differ_but_are_not_compared_or_are_ignored() {
+	boolean allowedToUsePrivateFields = FieldSupport.comparison().isAllowedToUsePrivateFields();
+    Assertions.setAllowComparingPrivateFields(false);
+	TestClassWithRandomId actual = new TestClassWithRandomId("1", 1);
+	TestClassWithRandomId other = new TestClassWithRandomId("1", 2);
+	// 
+	objects.assertIsEqualToIgnoringGivenFields(someInfo(), actual, other, "n");
+	// reset
+	Assertions.setAllowComparingPrivateFields(allowedToUsePrivateFields);
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByIgnoringNullFields_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByIgnoringNullFields_Test.java
index 4e2fcfbb3..a73ef1fa6 100644
--- a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByIgnoringNullFields_Test.java
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByIgnoringNullFields_Test.java
@@ -1,13 +1,16 @@
 /*
  * Created on Apr 8, 2012
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the
  * License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
+ * language
  * governing permissions and limitations under the License.
  * 
  * Copyright @2012 the original author or authors.
@@ -20,19 +23,17 @@ import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Lists.newArrayList;
-
-
 import static org.mockito.Mockito.verify;
 
-import java.util.List;
-
 import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.api.Assertions;
 import org.assertj.core.internal.ObjectsBaseTest;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.Jedi;
+import org.assertj.core.test.TestClassWithRandomId;
+import org.assertj.core.util.introspection.FieldSupport;
 import org.junit.Test;
 
-
 /**
  * Tests for <code>{@link Objects#assertIsLenientEqualsToByIgnoringNull(AssertionInfo, Object, Object)</code>.
  *
@@ -43,81 +44,85 @@ public class Objects_assertIsLenientEqualsToByIgnoringNullFields_Test extends Ob
 
   @Test
   public void should_pass_when_fields_are_equal() {
-    Jedi actual = new Jedi("Yoda", "Green");
-    Jedi other = new Jedi("Yoda", "Green");
-    objects.assertIsLenientEqualsToIgnoringNullFields(someInfo(), actual, other);
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Yoda", "Green");
+	objects.assertIsLenientEqualsToIgnoringNullFields(someInfo(), actual, other);
   }
 
   @Test
   public void should_pass_when_some_other_field_is_null_but_not_actual() {
-    Jedi actual = new Jedi("Yoda", "Green");
-    Jedi other = new Jedi("Yoda", null);
-    objects.assertIsLenientEqualsToIgnoringNullFields(someInfo(), actual, other);
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Yoda", null);
+	objects.assertIsLenientEqualsToIgnoringNullFields(someInfo(), actual, other);
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    thrown.expectAssertionError(actualIsNull());
-    Jedi other = new Jedi("Yoda", "Green");
-    objects.assertIsLenientEqualsToIgnoringNullFields(someInfo(), null, other);
+	thrown.expectAssertionError(actualIsNull());
+	Jedi other = new Jedi("Yoda", "Green");
+	objects.assertIsLenientEqualsToIgnoringNullFields(someInfo(), null, other);
   }
 
   @Test
   public void should_fail_when_some_actual_field_is_null_but_not_other() {
-    AssertionInfo info = someInfo();
-    Jedi actual = new Jedi("Yoda", null);
-    Jedi other = new Jedi("Yoda", "Green");
-    try {
-      objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
-    } catch (AssertionError err) {
-      List<String> emptyList = newArrayList();
-      verify(failures).failure(info,
-          shouldBeEqualToIgnoringGivenFields(actual, newArrayList("lightSaberColor"), newArrayList((Object) null),
-              newArrayList((Object) "Green"), emptyList));
-      return;
-    }
-    failBecauseExpectedAssertionErrorWasNotThrown();
+	AssertionInfo info = someInfo();
+	Jedi actual = new Jedi("Yoda", null);
+	Jedi other = new Jedi("Yoda", "Green");
+	try {
+	  objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
+	} catch (AssertionError err) {
+	  verify(failures).failure(info,
+		                       shouldBeEqualToIgnoringGivenFields(actual, newArrayList("lightSaberColor"),
+		                                                          newArrayList((Object) null),
+		                                                          newArrayList((Object) "Green"),
+		                                                          newArrayList("strangeNotReadablePrivateField")));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
   public void should_fail_when_a_field_differ() {
-    AssertionInfo info = someInfo();
-    Jedi actual = new Jedi("Yoda", "Green");
-    Jedi other = new Jedi("Soda", "Green");
-    try {
-      objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
-    } catch (AssertionError err) {
-      List<String> emptyList = newArrayList();
-      verify(failures).failure(info,
-          shouldBeEqualToIgnoringGivenFields(actual, newArrayList("name"), newArrayList((Object) "Yoda"), newArrayList((Object) "Soda"),
-              emptyList));
-      return;
-    }
-    failBecauseExpectedAssertionErrorWasNotThrown();
+	AssertionInfo info = someInfo();
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Soda", "Green");
+	try {
+	  objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
+	} catch (AssertionError err) {
+	  verify(failures).failure(info,
+		                       shouldBeEqualToIgnoringGivenFields(actual, newArrayList("name"),
+		                                                          newArrayList((Object) "Yoda"),
+		                                                          newArrayList((Object) "Soda"),
+		                                                          newArrayList("strangeNotReadablePrivateField")));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
   public void should_fail_when_objects_to_compare_are_of_different_types() {
-    AssertionInfo info = someInfo();
-    Jedi actual = new Jedi("Yoda", "Green");
-    Employee other = new Employee();
-    try {
-      objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
-    } catch (AssertionError err) {
-      verify(failures).failure(info, shouldBeInstance(other, actual.getClass()));
-      return;
-    }
-    failBecauseExpectedAssertionErrorWasNotThrown();
+	AssertionInfo info = someInfo();
+	Jedi actual = new Jedi("Yoda", "Green");
+	Employee other = new Employee();
+	try {
+	  objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
+	} catch (AssertionError err) {
+	  verify(failures).failure(info, shouldBeInstance(other, actual.getClass()));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
-  public void should_fail_when_asked_to_ignore_non_existent_fields() {
-    thrown.expect(RuntimeException.class, "Fields to ignore <[field1, field2]> not defined for type <org.assertj.core.test.Jedi>");
-
-    AssertionInfo info = someInfo();
-    Jedi actual = new Jedi("Yoda", "Green");
-    Jedi other = new Jedi("Yoda", "Green");
-    objects.assertIsEqualToIgnoringGivenFields(info, actual, other, "field1", "field2");
+  public void should_pass_when_private_fields_differ_but_are_not_compared() {
+	boolean allowedToUsePrivateFields = FieldSupport.comparison().isAllowedToUsePrivateFields();
+    Assertions.setAllowComparingPrivateFields(false);
+	TestClassWithRandomId actual = new TestClassWithRandomId("1", 1);
+	TestClassWithRandomId other = new TestClassWithRandomId(null, 1);
+	// s field is ignored because null in other, and id also because it is private without public getter
+	objects.assertIsLenientEqualsToIgnoringNullFields(someInfo(), actual, other);
+	// reset
+	Assertions.setAllowComparingPrivateFields(allowedToUsePrivateFields);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/test/TestClassWithRandomId.java b/src/test/java/org/assertj/core/test/TestClassWithRandomId.java
new file mode 100644
index 000000000..a7e06da60
--- /dev/null
+++ b/src/test/java/org/assertj/core/test/TestClassWithRandomId.java
@@ -0,0 +1,48 @@
+/*
+ * Created on Mar 19, 2012
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2012 the original author or authors.
+ */
+package org.assertj.core.test;
+
+/**
+ * Object for test with a private inaccessible field set a unique value.
+ */
+public class TestClassWithRandomId {
+
+  private final long id;
+  public final String s;
+  public final int n;
+
+  public TestClassWithRandomId(String s, final int n) {
+	this.s = s;
+	this.n = n;
+	this.id = System.currentTimeMillis();
+	// sleep to avoid creating two objects with same id
+	try {
+	  Thread.sleep(5);
+	} catch (InterruptedException e) {
+	  // nothing to do
+	}
+  }
+
+  @Override
+  public String toString() {
+	return "id=" + id;
+  }
+
+  @SuppressWarnings("unused")
+  private long getId() {
+	return id;
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
index 32545876d..0561131dd 100644
--- a/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
@@ -40,7 +40,7 @@ public class FieldSupport_fieldValues_Test {
   private Employee yoda;
   private Employee luke;
   private List<Employee> employees;
-  private FieldSupport fieldSupport = FieldSupport.instance();
+  private FieldSupport fieldSupport = FieldSupport.extraction();
 
   @Before
   public void setUpOnce() {
@@ -104,14 +104,14 @@ public class FieldSupport_fieldValues_Test {
   }
 
   @Test
-  public void should_throw_error_if_field_not_public_and_allowExtractingPrivateFields_set_to_false() {
-	FieldSupport.setAllowExtractingPrivateFields(false);
+  public void should_throw_error_if_field_is_not_public_and_allowExtractingPrivateFields_set_to_false() {
+	FieldSupport.EXTRACTION.setAllowUsingPrivateFields(false);
 	try {
 	  thrown.expect(IntrospectionError.class,
 		            "Unable to obtain the value of the field <'age'> from <Employee[id=1, name=Name[first='Yoda', last='null'], age=800]>, check that field is public.");
 	  fieldSupport.fieldValues("age", Integer.class, employees);
 	} finally { // back to default value
-	  FieldSupport.setAllowExtractingPrivateFields(true);
+	  FieldSupport.EXTRACTION.setAllowUsingPrivateFields(true);
 	}
   }
 
diff --git a/src/test/java/org/assertj/core/util/introspection/FieldSupport_isAllowedToReadField_Test.java b/src/test/java/org/assertj/core/util/introspection/FieldSupport_isAllowedToReadField_Test.java
new file mode 100644
index 000000000..de6e610ef
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/introspection/FieldSupport_isAllowedToReadField_Test.java
@@ -0,0 +1,47 @@
+/*
+ * Created on Feb 22, 2011
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2011 the original author or authors.
+ */
+package org.assertj.core.util.introspection;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.assertj.core.test.Jedi;
+import org.junit.Test;
+
+public class FieldSupport_isAllowedToReadField_Test {
+
+  private FieldSupport fieldSupport = FieldSupport.comparison();
+
+  @Test
+  public void fieldSupport_should_be_allowed_to_read_public_field_only() throws Exception {
+	boolean allowedToUsePrivateFields = fieldSupport.isAllowedToUsePrivateFields();
+	fieldSupport.setAllowUsingPrivateFields(false);
+	assertThat(fieldSupport.isAllowedToRead(Jedi.class.getField("lightSaberColor"))).isTrue();
+	assertThat(fieldSupport.isAllowedToRead(Jedi.class.getDeclaredField("strangeNotReadablePrivateField"))).isFalse();
+	// reset
+	fieldSupport.setAllowUsingPrivateFields(allowedToUsePrivateFields);
+  }
+
+  @Test
+  public void fieldSupport_should_be_allowed_to_read_whatever_field_when_allowedToUsePrivateFields_flag_is_true()
+	  throws Exception {
+	boolean allowedToUsePrivateFields = fieldSupport.isAllowedToUsePrivateFields();
+	fieldSupport.setAllowUsingPrivateFields(true);
+	assertThat(fieldSupport.isAllowedToRead(Jedi.class.getField("lightSaberColor"))).isTrue();
+	assertThat(fieldSupport.isAllowedToRead(Jedi.class.getDeclaredField("strangeNotReadablePrivateField"))).isTrue();
+	// reset
+	fieldSupport.setAllowUsingPrivateFields(allowedToUsePrivateFields);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/util/introspection/MethodSupport_methodResultFor_Test.java b/src/test/java/org/assertj/core/util/introspection/MethodSupport_methodResultFor_Test.java
index 69795b07d..aa200e610 100644
--- a/src/test/java/org/assertj/core/util/introspection/MethodSupport_methodResultFor_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/MethodSupport_methodResultFor_Test.java
@@ -97,29 +97,4 @@ public class MethodSupport_methodResultFor_Test {
     MethodSupport.methodResultFor(batman, "trueIdentity");
   }
 
-  public static class SuperHero extends Person {
-
-    private final Person trueIdentity;
-    private final Person archenemy;
-
-    public SuperHero(String name, Person trueIdentity, Person archenemy) {
-      super(name);
-      this.trueIdentity = trueIdentity;
-      this.archenemy = archenemy;
-    }
-
-    public Person archenemy() {
-      return archenemy;
-    }
-
-    public void saveTheDay() {
-      // do some superheroic stuff
-    }
-
-    @SuppressWarnings("unused")
-    private Person trueIdentity() {
-      return trueIdentity;
-    }
-  }
-
 }
diff --git a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java b/src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_Test.java
similarity index 98%
rename from src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
rename to src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_Test.java
index 4c27d7dfa..b9f66e408 100644
--- a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_Test.java
@@ -12,7 +12,7 @@
  * 
  * Copyright @2011 the original author or authors.
  */
-package org.assertj.core.internal;
+package org.assertj.core.util.introspection;
 
 import static java.util.Collections.emptySet;
 import static junit.framework.Assert.assertEquals;
@@ -23,6 +23,7 @@ import static org.assertj.core.util.Lists.newArrayList;
 import java.util.Collection;
 import java.util.List;
 
+import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
diff --git a/src/test/java/org/assertj/core/util/introspection/PropertySupport_publicGetterExistsFor_Test.java b/src/test/java/org/assertj/core/util/introspection/PropertySupport_publicGetterExistsFor_Test.java
new file mode 100644
index 000000000..eb94126d4
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/introspection/PropertySupport_publicGetterExistsFor_Test.java
@@ -0,0 +1,51 @@
+/*
+ * Created on Feb 22, 2011
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2011 the original author or authors.
+ */
+package org.assertj.core.util.introspection;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.assertj.core.internal.PropertySupport;
+import org.assertj.core.test.Person;
+import org.junit.Before;
+import org.junit.Test;
+
+public class PropertySupport_publicGetterExistsFor_Test {
+
+  private PropertySupport propertySupport  = PropertySupport.instance();
+  private Person bruceWayne;
+  private Person joker;
+  private SuperHero batman;
+
+  @Before
+  public void setUp() {
+    bruceWayne = new Person("Bruce Wayne");
+    joker = new Person("Joker");
+    batman = new SuperHero("Batman", bruceWayne, joker);
+  }
+  @Test
+  public void should_return_true_if_public_getter_exists_for_field() {
+	assertThat(propertySupport.publicGetterExistsFor("archenemy", batman)).as("check archenemy").isTrue();
+	// with inherited public getter
+	assertThat(propertySupport.publicGetterExistsFor("name", batman)).as("check name").isTrue();
+  }
+
+  @Test
+  public void should_return_false_if_public_getter_does_not_exist() {
+	// getter exists but is package visible
+	assertThat(propertySupport.publicGetterExistsFor("trueIdentity", batman)).as("package visible getter").isFalse();
+	assertThat(propertySupport.publicGetterExistsFor("realJob", batman)).as("with non existing getter").isFalse();
+  }
+  
+}
diff --git a/src/test/java/org/assertj/core/util/introspection/SuperHero.java b/src/test/java/org/assertj/core/util/introspection/SuperHero.java
new file mode 100644
index 000000000..94f3657a0
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/introspection/SuperHero.java
@@ -0,0 +1,36 @@
+package org.assertj.core.util.introspection;
+
+import org.assertj.core.test.Person;
+
+public class SuperHero extends Person {
+
+  private final Person trueIdentity;
+  private final Person archenemy;
+
+  public SuperHero(String name, Person trueIdentity, Person archenemy) {
+    super(name);
+    this.trueIdentity = trueIdentity;
+    this.archenemy = archenemy;
+  }
+
+  public Person archenemy() {
+    return archenemy;
+  }
+  
+  public Person getArchenemy() {
+	return archenemy;
+  }
+
+  public void saveTheDay() {
+    // do some superheroic stuff
+  }
+
+  @SuppressWarnings("unused")
+  private Person trueIdentity() {
+    return trueIdentity;
+  }
+  
+  Person getTrueIdentity() {
+	return trueIdentity;
+  }
+}
\ No newline at end of file
