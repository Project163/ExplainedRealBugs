diff --git a/src/main/java/org/assertj/core/api/ErrorCollector.java b/src/main/java/org/assertj/core/api/ErrorCollector.java
index acf435272..2710c0c2c 100644
--- a/src/main/java/org/assertj/core/api/ErrorCollector.java
+++ b/src/main/java/org/assertj/core/api/ErrorCollector.java
@@ -12,17 +12,21 @@
  */
 package org.assertj.core.api;
 
-import net.sf.cglib.proxy.MethodInterceptor;
-import net.sf.cglib.proxy.MethodProxy;
-
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
+import net.sf.cglib.proxy.MethodInterceptor;
+import net.sf.cglib.proxy.MethodProxy;
+
 /** Collects error messages of all AssertionErrors thrown by the proxied method. */
 public class ErrorCollector implements MethodInterceptor {
 
+  private static final String INTERCEPT_METHOD_NAME = "intercept";
+
+  private static final String CLASS_NAME = ErrorCollector.class.getName();
+
   // scope : the current softassertion object
   private final List<Throwable> errors = new ArrayList<>();
   // scope : the last assertion call (might be nested)
@@ -30,14 +34,19 @@ public class ErrorCollector implements MethodInterceptor {
 
   @Override
   public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
+    Object result = obj;
     try {
-      proxy.invokeSuper(obj, args);
+      result = proxy.invokeSuper(obj, args);
       lastResult.setSuccess(true);
     } catch (AssertionError e) {
+      if (isNestedErrorCollectorProxyCall()) {
+        // let the most outer call handle the assertion error
+        throw e;
+      }
       lastResult.setSuccess(false);
       errors.add(e);
     }
-    return obj;
+    return result;
   }
 
   public List<Throwable> errors() {
@@ -48,6 +57,20 @@ public class ErrorCollector implements MethodInterceptor {
     return lastResult.wasSuccess();
   }
 
+  private boolean isNestedErrorCollectorProxyCall() {
+    return countErrorCollectorProxyCalls() > 1;
+  }
+
+  private static int countErrorCollectorProxyCalls() {
+    int nbCalls = 0;
+    for (StackTraceElement stackTraceElement : Thread.currentThread().getStackTrace()) {
+      if (CLASS_NAME.equals(stackTraceElement.getClassName())
+          && INTERCEPT_METHOD_NAME.equals(stackTraceElement.getMethodName()))
+        nbCalls++;
+    }
+    return nbCalls;
+  }
+
   private static class LastResult {
     private boolean wasSuccess = true;
     private boolean errorFound = false;
@@ -68,7 +91,7 @@ public class ErrorCollector implements MethodInterceptor {
       // The overall last result success should not be true as one of the nested calls was not a success.
       errorFound |= !success;
 
-      if (resolvingOutermostNestedCall()) {
+      if (resolvingOutermostErrorCollectorProxyNestedCall()) {
         // we are resolving the last nested call (if any), we can set a relevant value for wasSuccess
         wasSuccess = !errorFound;
         // need to reset errorFound for the next soft assertion
@@ -76,12 +99,8 @@ public class ErrorCollector implements MethodInterceptor {
       }
     }
 
-    private boolean resolvingOutermostNestedCall() {
-      int nbCalls = 0;
-      for (StackTraceElement e : Thread.currentThread().getStackTrace()) {
-        if (e.getClassName().equals(ErrorCollector.class.getName())) nbCalls++;
-      }
-      return nbCalls == 1;
+    private boolean resolvingOutermostErrorCollectorProxyNestedCall() {
+      return countErrorCollectorProxyCalls() == 1;
     }
 
     @Override
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index 29939f5f9..4b8b00a82 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -29,6 +29,7 @@ import java.net.URISyntaxException;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 
 import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.api.iterable.Extractor;
@@ -572,6 +573,14 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
                                  .containsExactlyInAnyOrder(thenMethods);
   }
 
+  @Test
+  public void should_propagate_AssertionError_from_nested_proxied_calls() {
+    // the nested proxied call to isNotEmpty() throw an Assertion error that must be propagated to the caller.
+    softly.assertThat(asList()).first();
+    // it must be caught by softly.assertAll()
+    assertThat(softly.errorsCollected()).hasSize(1);
+  }
+
   private static Name name(String first, String last) {
     return new Name(first, last);
   }
@@ -586,4 +595,71 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
       return input.getChildren();
     }
   }
+
+  // bug #447
+
+  public class TolkienCharacter {
+    String name;
+    int age;
+  }
+
+
+  @Test
+  public void check_477_bugfix() {
+    // GIVEN
+    TolkienCharacter frodo = new TolkienCharacter();
+    TolkienCharacter samnullGamgee = null;
+    TolkienSoftAssertions softly = new TolkienSoftAssertions();
+    // WHEN
+    softly.assertThat(frodo).hasAge(10); // Expect failure - age will be 0 due to not being initialized.
+    softly.assertThat(samnullGamgee).hasAge(11); // Expect failure - argument is null.
+    // THEN
+    assertThat(softly.errorsCollected()).hasSize(2);
+  }
+
+
+  public static class TolkienCharacterAssert extends AbstractAssert<TolkienCharacterAssert, TolkienCharacter> {
+
+    public TolkienCharacterAssert(TolkienCharacter actual) {
+      super(actual, TolkienCharacterAssert.class);
+    }
+
+    public static TolkienCharacterAssert assertThat(TolkienCharacter actual) {
+      return new TolkienCharacterAssert(actual);
+    }
+
+    // 4 - a specific assertion !
+    public TolkienCharacterAssert hasName(String name) {
+      // check that actual TolkienCharacter we want to make assertions on is not null.
+      isNotNull();
+
+      // check condition
+      if (!Objects.equals(actual.name, name)) {
+        failWithMessage("Expected character's name to be <%s> but was <%s>", name, actual.name);
+      }
+
+      // return the current assertion for method chaining
+      return this;
+    }
+
+    // 4 - another specific assertion !
+    public TolkienCharacterAssert hasAge(int age) {
+      // check that actual TolkienCharacter we want to make assertions on is not null.
+      isNotNull();
+
+      // check condition
+      if (actual.age != age) {
+        failWithMessage("Expected character's age to be <%s> but was <%s>", age, actual.age);
+      }
+
+      // return the current assertion for method chaining
+      return this;
+    }
+  }
+  public static class TolkienSoftAssertions extends SoftAssertions {
+
+    public TolkienCharacterAssert assertThat(TolkienCharacter actual) {
+      return proxy(TolkienCharacterAssert.class, TolkienCharacter.class, actual);
+    }
+  }
 }
