diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 3ff7fed11..267aab307 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -2514,6 +2514,45 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return usingRecursiveFieldByFieldElementComparator(recursiveComparisonConfiguration);
   }
 
+  /**
+   * In the recursive comparison, allows to ignore non-existent fields in the object under test when using
+   * {@link #usingRecursiveFieldByFieldElementComparatorOnFields(String...)}.
+   * <p>
+   * This is useful when comparing collections of polymorphic objects where some fields might not exist in all subtypes.
+   * <p>
+   * Example:
+   * <pre><code class='java'> class BaseClass {
+   *   String common = "same";
+   * }
+   *
+   * class SubType1 extends BaseClass {
+   *   // No 'inSubType2' field
+   *   String inSubType1 = "type1";
+   * }
+   *
+   * class SubType2 extends SubType1 {
+   *   String inSubType2 = "type2";
+   * }
+   *
+   * List&lt;BaseClass&gt; list1 = List.of(new SubType1(), new SubType2());
+   * List&lt;BaseClass&gt; list2 = List.of(new SubType1(), new SubType2());
+   *
+   * // Without ignoringNonExistentComparedFields(), this would fail with an IllegalArgumentException
+   * // indicating that 'inSubType2' field doesn't exist in SubType1.
+   * assertThat(list1).usingRecursiveFieldByFieldElementComparatorOnFields("common", "inSubType1", "inSubType2")
+   *                  .ignoringNonExistentComparedFields()
+   *                  .containsAll(list2); </code></pre>
+   *
+   * @return {@code this} assertion object.
+   */
+  @CheckReturnValue
+  public SELF ignoringNonExistentComparedFields() {
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = RecursiveComparisonConfiguration.builder()
+                                                                                                        .withIgnoreNonExistentComparedFields(true)
+                                                                                                        .build();
+    return usingRecursiveFieldByFieldElementComparator(recursiveComparisonConfiguration);
+  }
+
   /**
    * Enable hexadecimal representation of Iterable elements instead of standard representation in error messages.
    * <p>
diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index ff375e4b6..47a6c31ec 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -649,6 +649,49 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * In the recursive comparison, allows to ignore non-existent fields in the object under test when using
+   * {@link #comparingOnlyFields(String...)}.
+   * <p>
+   * This is useful when comparing polymorphic objects where some fields might not exist in all subtypes.
+   * <p>
+   * Example:
+   * <pre><code class='java'> class BaseClass {
+   *   String commonField = "common";
+   * }
+   *
+   * class SubType1 extends BaseClass {
+   *   // No 'inSubType2' field
+   *   String inSubType1 = "type1";
+   * }
+   *
+   * class SubType2 extends SubType1 {
+   *   String inSubType2 = "type2";
+   * }
+   *
+   * SubType1 actual = new SubType1();
+   * SubType2 expected = new SubType2();
+   *
+   * // this fails due to field existence check with an IllegalArgumentException
+   * // indicating that 'inSubType2' field doesn't exist in SubType1.
+   * assertThat(actual).usingRecursiveComparison()
+   *                   .comparingOnlyFields("common", "inSubType1", "inSubType2")
+   *                   .isEqualTo(expected);
+   *
+   * // Using ignoringNonExistentComparedFields() makes it pass
+   * assertThat(actual).usingRecursiveComparison()
+   *                   .comparingOnlyFields("common", "inSubType1", "inSubType2")
+   *                   .ignoringNonExistentComparedFields()
+   *                   .isEqualTo(expected); </code></pre>
+   *
+   * @return this {@link RecursiveComparisonAssert} to allow fluent chaining.
+   */
+  @CheckReturnValue
+  public SELF ignoringNonExistentComparedFields() {
+    recursiveComparisonConfiguration.setIgnoreNonExistentComparedFields(true);
+    return myself;
+  }
+
   /**
    * Makes the recursive comparison to ignore all <b>expected null fields</b>.
    * <p>
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index eb43a983f..1adfd9cd1 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -57,6 +57,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   private boolean ignoreAllActualNullFields = false;
   private boolean ignoreAllActualEmptyOptionalFields = false;
   private boolean ignoreAllExpectedNullFields = false;
+  private boolean ignoreNonExistentComparedFields = false;
 
   // fields to compare (no other field will be)
   private Set<FieldLocation> comparedFields = new LinkedHashSet<>();
@@ -102,6 +103,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     this.ignoreAllActualEmptyOptionalFields = builder.ignoreAllActualEmptyOptionalFields;
     this.strictTypeChecking = builder.strictTypeChecking;
     this.ignoreAllExpectedNullFields = builder.ignoreAllExpectedNullFields;
+    this.ignoreNonExistentComparedFields = builder.ignoreNonExistentComparedFields;
     this.comparedFields = newLinkedHashSet(builder.comparedFields);
     this.comparedTypes = newLinkedHashSet(builder.comparedTypes);
     ignoreOverriddenEqualsForTypes(builder.ignoredOverriddenEqualsForTypes);
@@ -189,6 +191,10 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return ignoreAllExpectedNullFields;
   }
 
+  public boolean getIgnoreNonExistentComparedFields() {
+    return ignoreNonExistentComparedFields;
+  }
+
   public boolean getIgnoreAllOverriddenEquals() {
     return ignoreAllOverriddenEquals;
   }
@@ -230,6 +236,19 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     this.ignoreAllExpectedNullFields = ignoreAllExpectedNullFields;
   }
 
+  /**
+   * Sets whether fields that don't exist in the object should be ignored in the recursive comparison.
+   * <p>
+   * This is useful when comparing polymorphic objects where some fields might not exist in all subtypes.
+   * <p>
+   * See {@link RecursiveComparisonAssert#ignoringNonExistentComparedFields()} for code examples.
+   *
+   * @param ignoreNonExistentComparedFields whether to ignore non-existent fields in the recursive comparison
+   */
+  public void setIgnoreNonExistentComparedFields(boolean ignoreNonExistentComparedFields) {
+    this.ignoreNonExistentComparedFields = ignoreNonExistentComparedFields;
+  }
+
   /**
    * Adds the given fields and their subfields to the set of fields from the object under test to compare (no other fields will be compared).
    * <p>
@@ -644,7 +663,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   @Override
   public int hashCode() {
     return java.util.Objects.hash(fieldComparators, ignoreAllActualEmptyOptionalFields, ignoreAllActualNullFields,
-                                  ignoreAllExpectedNullFields, ignoreAllOverriddenEquals, ignoreCollectionOrder,
+                                  ignoreAllExpectedNullFields, ignoreNonExistentComparedFields, ignoreAllOverriddenEquals,
+                                  ignoreCollectionOrder,
                                   ignoredCollectionOrderInFields, ignoredCollectionOrderInFieldsMatchingRegexes,
                                   getIgnoredFields(), getIgnoredFieldsRegexes(), ignoredOverriddenEqualsForFields,
                                   ignoredOverriddenEqualsForTypes, ignoredOverriddenEqualsForFieldsMatchingRegexes,
@@ -662,6 +682,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
            && ignoreAllActualEmptyOptionalFields == other.ignoreAllActualEmptyOptionalFields
            && ignoreAllActualNullFields == other.ignoreAllActualNullFields
            && ignoreAllExpectedNullFields == other.ignoreAllExpectedNullFields
+           && ignoreNonExistentComparedFields == other.ignoreNonExistentComparedFields
            && ignoreAllOverriddenEquals == other.ignoreAllOverriddenEquals
            && ignoreCollectionOrder == other.ignoreCollectionOrder
            && ignoreArrayOrder == other.ignoreArrayOrder
@@ -688,6 +709,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     describeIgnoreAllActualNullFields(description);
     describeIgnoreAllActualEmptyOptionalFields(description);
     describeIgnoreAllExpectedNullFields(description);
+    describeIgnoreNonExistentFields(description);
     describeComparedFields(description);
     describeComparedTypes(description);
     describeIgnoredFields(description);
@@ -878,6 +900,11 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
       description.append("- all expected null fields were ignored in the comparison%n".formatted());
   }
 
+  private void describeIgnoreNonExistentFields(StringBuilder description) {
+    if (ignoreNonExistentComparedFields)
+      description.append("- when using compared fields, fields that do not exist in the actual object were ignored in the comparison%n".formatted());
+  }
+
   private void describeOverriddenEqualsMethodsUsage(StringBuilder description, Representation representation) {
     String header = ignoreAllOverriddenEquals
         ? "- no equals methods were used in the comparison EXCEPT for java JDK types since introspecting JDK types is forbidden in java 17+ (use withEqualsForType to register a specific way to compare a JDK type if you need it)"
@@ -1132,6 +1159,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   }
 
   void checkComparedFieldsExist(Object actual) {
+    if (ignoreNonExistentComparedFields) return;
     Map<FieldLocation, String> unknownComparedFields = new TreeMap<>();
     for (FieldLocation comparedField : comparedFields) {
       checkComparedFieldExists(actual,
@@ -1207,6 +1235,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     private boolean ignoreAllActualNullFields;
     private boolean ignoreAllActualEmptyOptionalFields;
     private boolean ignoreAllExpectedNullFields;
+    private boolean ignoreNonExistentComparedFields;
     private FieldLocation[] comparedFields = {};
     private Class<?>[] comparedTypes = {};
     private Class<?>[] ignoredOverriddenEqualsForTypes = {};
@@ -1292,6 +1321,19 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
       return this;
     }
 
+    /**
+     * Sets whether the field existence check should be ignored during recursive comparison.
+     * <p>
+     * This is useful when comparing polymorphic objects where some fields might not exist in all subtypes.
+     *
+     * @param ignoreNonExistentComparedFields whether to ignore the field existence check
+     * @return this builder.
+     */
+    public Builder withIgnoreNonExistentComparedFields(boolean ignoreNonExistentComparedFields) {
+      this.ignoreNonExistentComparedFields = ignoreNonExistentComparedFields;
+      return this;
+    }
+
     /**
      * Adds the given fields to the set of fields from the object under test to compare in the recursive comparison.
      * <p>
diff --git a/assertj-core/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparatorOnFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparatorOnFields_Test.java
index 92d750de2..b2a15dd0a 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparatorOnFields_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparatorOnFields_Test.java
@@ -12,9 +12,14 @@
  */
 package org.assertj.core.api.iterable;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchIllegalArgumentException;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
 
+import java.math.BigDecimal;
+import java.util.List;
+
 import org.assertj.core.api.ConcreteIterableAssert;
 import org.assertj.core.api.IterableAssertBaseTest;
 import org.assertj.core.api.comparisonstrategy.ComparatorBasedComparisonStrategy;
@@ -27,6 +32,7 @@ import org.assertj.core.testkit.Player;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
+@SuppressWarnings({ "unused", "FieldCanBeLocal" })
 class IterableAssert_usingRecursiveFieldByFieldElementComparatorOnFields_Test extends IterableAssertBaseTest {
 
   private Iterables iterablesBefore;
@@ -47,9 +53,9 @@ class IterableAssert_usingRecursiveFieldByFieldElementComparatorOnFields_Test ex
     then(iterablesBefore).isNotSameAs(iterables);
     then(iterables.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
     then(getObjects(assertions).getComparisonStrategy()).isInstanceOf(IterableElementComparisonStrategy.class);
-    RecursiveComparisonConfiguration recursiveComparisonConfiguration = RecursiveComparisonConfiguration.builder()
-                                                                                                        .withComparedFields("field")
-                                                                                                        .build();
+    var recursiveComparisonConfiguration = RecursiveComparisonConfiguration.builder()
+                                                                           .withComparedFields("field")
+                                                                           .build();
     ConfigurableRecursiveFieldByFieldComparator expectedComparator = new ConfigurableRecursiveFieldByFieldComparator(recursiveComparisonConfiguration);
     then(iterables.getComparator()).isEqualTo(expectedComparator);
     then(getObjects(assertions).getComparisonStrategy()).extracting("elementComparator").isEqualTo(expectedComparator);
@@ -67,4 +73,90 @@ class IterableAssert_usingRecursiveFieldByFieldElementComparatorOnFields_Test ex
                     .contains(jalen);
   }
 
+  // https://github.com/assertj/assertj/issues/3806
+  static abstract class AppliedExemptionResponse {
+    private final String exemptionCode;
+    private final String description;
+    private final String chargeItemCode;
+
+    public AppliedExemptionResponse(String exemptionCode, String description, String chargeItemCode) {
+      this.exemptionCode = exemptionCode;
+      this.description = description;
+      this.chargeItemCode = chargeItemCode;
+    }
+  }
+
+  static class AppliedPartialExemptionResponse extends AppliedExemptionResponse {
+    private final BigDecimal value;
+    private final String type;
+
+    public AppliedPartialExemptionResponse(String exemptionCode, String description, String chargeItemCode,
+                                           BigDecimal value, String type) {
+      super(exemptionCode, description, chargeItemCode);
+      this.value = value;
+      this.type = type;
+    }
+  }
+
+  static class AppliedTotalExemptionResponse extends AppliedExemptionResponse {
+    public AppliedTotalExemptionResponse(String exemptionCode, String description, String chargeItemCode) {
+      super(exemptionCode, description, chargeItemCode);
+    }
+  }
+
+  @Test
+  void should_pass_when_comparing_polymorphic_objects_with_ignoring_non_existent_fields() {
+    // GIVEN
+    List<AppliedExemptionResponse> actual = List.of(new AppliedTotalExemptionResponse("E1", "E1 Desc", "T1"),
+                                                    new AppliedPartialExemptionResponse("E2", "E2 Desc", "T2",
+                                                                                        new BigDecimal("1"), "type_0011"));
+
+    List<AppliedExemptionResponse> expected = List.of(new AppliedTotalExemptionResponse("E1", "E1 Desc", "T1"),
+                                                      new AppliedPartialExemptionResponse("E2", "E2 Desc", "T2",
+                                                                                          new BigDecimal("1"), "type_0011"));
+
+    // WHEN/THEN
+    then(actual).usingRecursiveFieldByFieldElementComparatorOnFields("exemptionCode", "description", "chargeItemCode", "value")
+                .ignoringNonExistentComparedFields()
+                .containsExactlyInAnyOrderElementsOf(expected);
+  }
+
+  static class BaseClass {
+    private final String common = "same";
+  }
+
+  static class SubType1 extends BaseClass {
+    // No 'inSubType2' field
+    private final String inSubType1 = "type1";
+  }
+
+  static class SubType2 extends SubType1 {
+    private final String inSubType2 = "type2";
+  }
+
+  @Test
+  void should_pass_when_actual_does_not_have_all_compared_fields_and_ignoringNonExistentComparedFields_is_enabled() {
+    // GIVEN
+    List<BaseClass> actual = List.of(new SubType1(), new SubType2());
+    List<BaseClass> expected = List.of(new SubType1(), new SubType2());
+    // WHEN/THEN
+    then(actual).usingRecursiveFieldByFieldElementComparatorOnFields("common", "inSubType1", "inSubType2")
+                .ignoringNonExistentComparedFields()
+                .containsAll(expected);
+  }
+
+  @Test
+  void should_fail_when_actual_does_not_have_all_compared_fields() {
+    // GIVEN
+    List<BaseClass> actual = List.of(new SubType1(), new SubType2());
+    List<BaseClass> expected = List.of(new SubType1(), new SubType2());
+    // WHEN
+    var exception = catchIllegalArgumentException(() -> assertThat(actual).usingRecursiveFieldByFieldElementComparatorOnFields("common",
+                                                                                                                               "inSubType1",
+                                                                                                                               "inSubType2")
+                                                                          .containsAll(expected));
+    // THEN
+    then(exception).hasMessage("The following fields don't exist: {inSubType2}");
+  }
+
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
index a1e87d116..84c652c98 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
@@ -397,6 +397,24 @@ class RecursiveComparisonConfiguration_builder_Test {
     then(recursiveComparisonConfiguration.getRepresentation()).isSameAs(STANDARD_REPRESENTATION);
   }
 
+  @Test
+  void should_set_ignoreNonExistentFields() {
+    // GIVEN
+    boolean value = RandomUtils.secure().randomBoolean();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = configBuilder().withIgnoreNonExistentComparedFields(value).build();
+    // THEN
+    then(configuration.getIgnoreNonExistentComparedFields()).isEqualTo(value);
+  }
+
+  @Test
+  void should_set_ignoreNonExistentFields_with_shortcut_method() {
+    // WHEN
+    RecursiveComparisonConfiguration configuration = configBuilder().build();
+    // THEN
+    then(configuration.getIgnoreNonExistentComparedFields()).isFalse();
+  }
+
   private static Builder configBuilder() {
     return RecursiveComparisonConfiguration.builder();
   }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index 4db114c15..de629dcea 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -338,6 +338,7 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
     recursiveComparisonConfiguration.setIgnoreAllActualEmptyOptionalFields(true);
     recursiveComparisonConfiguration.setIgnoreAllExpectedNullFields(true);
+    recursiveComparisonConfiguration.setIgnoreNonExistentComparedFields(true);
     recursiveComparisonConfiguration.compareOnlyFields("name", "address.number");
     recursiveComparisonConfiguration.compareOnlyFieldsOfTypes(String.class, Integer.class);
     recursiveComparisonConfiguration.ignoreFields("foo", "bar", "foo.bar");
@@ -364,6 +365,7 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
                "- all actual null fields were ignored in the comparison%n" +
                "- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)%n" +
                "- all expected null fields were ignored in the comparison%n" +
+               "- when using compared fields, fields that do not exist in the actual object were ignored in the comparison%n" +
                "- the comparison was performed on the following fields: name, address.number%n" +
                "- the comparison was performed on any fields with types: java.lang.String, java.lang.Integer%n" +
                "- the following fields were ignored in the comparison: foo, bar, foo.bar%n" +
@@ -373,7 +375,7 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
                "  - the following fields: foo, baz, foo.baz%n" +
                "  - the following types: java.lang.String, com.google.common.collect.Multimap%n" +
                "  - the fields matching the following regexes: .*oo, .ar, oo.ba%n" +
-                 "- array order was ignored in all fields in the comparison%n" +
+               "- array order was ignored in all fields in the comparison%n" +
                "- collection order was ignored in all fields in the comparison%n" +
                "- collection order was ignored in the following fields in the comparison: foo, bar, foo.bar%n" +
                "- collection order was ignored in the fields matching the following regexes in the comparison: f.*, ba., foo.*%n" +
@@ -388,7 +390,7 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
                "  - foo -> AlwaysEqualComparator%n" +
                "- field comparators take precedence over type comparators.%n"+
                "- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).%n" +
-                 "- the introspection strategy used was: comparing fields%n" +
+               "- the introspection strategy used was: comparing fields%n" +
                "- enums can be compared against strings (and vice versa), e.g. Color.RED and \"RED\" are considered equal%n"));
     // @format:on
   }
@@ -423,6 +425,17 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     then(multiLineDescription).contains("- enums can be compared against strings (and vice versa), e.g. Color.RED and \"RED\" are considered equal");
   }
 
+  @Test
+  void should_show_ignoreNonExistentFields_in_the_description() {
+    // GIVEN
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+    recursiveComparisonConfiguration.setIgnoreNonExistentComparedFields(true);
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    then(multiLineDescription).contains("- when using compared fields, fields that do not exist in the actual object were ignored in the comparison");
+  }
+
   // just to test the description does not fail when given a comparator with various String.format reserved flags
   private static class PercentageComparator implements Comparator<Double> {
 
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
index 3f1ee9bda..92011a009 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
@@ -37,6 +37,7 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
+@SuppressWarnings("unused")
 class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends WithComparingFieldsIntrospectionStrategyBaseTest {
 
   @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
@@ -444,4 +445,43 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends WithC
                    .comparingOnlyFields("friends.name")
                    .isEqualTo(sherlock2);
   }
+
+  static class BaseClass {
+    final String common = "same";
+  }
+
+  static class SubType1 extends BaseClass {
+    // No 'inSubType2' field
+    final String inSubType1 = "type1";
+  }
+
+  static class SubType2 extends SubType1 {
+    final String inSubType2 = "type2";
+  }
+
+  @Test
+  void should_pass_when_actual_does_not_have_all_compared_fields_and_ignoringNonExistentComparedFields_is_enabled() {
+    // GIVEN
+    BaseClass actual = new SubType1();
+    BaseClass expected = new SubType2();
+    // WHEN
+    then(actual).usingRecursiveComparison()
+                .comparingOnlyFields("common", "inSubType1", "inSubType2")
+                .ignoringNonExistentComparedFields()
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_fail_when_actual_does_not_have_all_compared_fields() {
+    // GIVEN
+    BaseClass actual = new SubType1();
+    BaseClass expected = new SubType2();
+    // WHEN
+    var exception = catchIllegalArgumentException(() -> assertThat(actual).usingRecursiveComparison()
+                                                                          .comparingOnlyFields("common", "inSubType1",
+                                                                                               "inSubType2")
+                                                                          .isEqualTo(expected));
+    // THEN
+    then(exception).hasMessage("The following fields don't exist: {inSubType2}");
+  }
 }
