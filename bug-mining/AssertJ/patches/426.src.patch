diff --git a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index 363bc7b86..4e5b4193c 100644
--- a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -213,9 +213,13 @@ public class StandardRepresentation implements Representation {
     if (object instanceof OffsetDateTime) return toStringOf((OffsetDateTime) object);
     if (object instanceof ZonedDateTime) return toStringOf((ZonedDateTime) object);
     if (object instanceof LongAdder) return toStringOf((LongAdder) object);
-    if (object instanceof AtomicReference) return toStringOf((AtomicReference<?>) object);
-    if (object instanceof AtomicMarkableReference) return toStringOf((AtomicMarkableReference<?>) object);
-    if (object instanceof AtomicStampedReference) return toStringOf((AtomicStampedReference<?>) object);
+    // if object was a subtype of any atomic type overriding toString, use it as it's more relevant than our generic
+    // representation, if that's not the case (e.g. an AtomicReference subclass not overriding String) we use our representation.
+    if (isInstanceOfNotOverridingToString(object, AtomicReference.class)) return toStringOf((AtomicReference<?>) object);
+    if (isInstanceOfNotOverridingToString(object, AtomicMarkableReference.class))
+      return toStringOf((AtomicMarkableReference<?>) object);
+    if (isInstanceOfNotOverridingToString(object, AtomicStampedReference.class))
+      return toStringOf((AtomicStampedReference<?>) object);
     if (object instanceof AtomicIntegerFieldUpdater) return AtomicIntegerFieldUpdater.class.getSimpleName();
     if (object instanceof AtomicLongFieldUpdater) return AtomicLongFieldUpdater.class.getSimpleName();
     if (object instanceof AtomicReferenceFieldUpdater) return AtomicReferenceFieldUpdater.class.getSimpleName();
@@ -239,7 +243,7 @@ public class StandardRepresentation implements Representation {
     // Only format Iterables that are not collections and have not overridden toString
     // ex: JsonNode is an Iterable that is best formatted with its own String
     // Path is another example but we can deal with it specifically as it is part of the JDK.
-    if (object instanceof Iterable<?> && !hasOverriddenToString((Iterable<?>) object)) return smartFormat((Iterable<?>) object);
+    if (object instanceof Iterable<?> && !hasOverriddenToString(object.getClass())) return smartFormat((Iterable<?>) object);
     if (object instanceof AtomicInteger) return toStringOf((AtomicInteger) object);
     if (object instanceof AtomicBoolean) return toStringOf((AtomicBoolean) object);
     if (object instanceof AtomicLong) return toStringOf((AtomicLong) object);
@@ -248,18 +252,40 @@ public class StandardRepresentation implements Representation {
     return fallbackToStringOf(object);
   }
 
-  private static boolean hasOverriddenToString(Iterable<?> iterable) {
+  private static boolean isInstanceOfNotOverridingToString(Object object, Class<?> type) {
+    return type.isInstance(object) && !hasOverriddenToStringInSubclassOf(object.getClass(), type);
+  }
+
+  private static boolean hasOverriddenToString(Class<?> clazz) {
     try {
-      Method method = iterable.getClass().getMethod("toString");
-      Class<?> declaringClass = method.getDeclaringClass();
-      return !Object.class.equals(declaringClass);
+      Class<?> classDeclaringToString = clazz.getMethod("toString").getDeclaringClass();
+      return !Object.class.equals(classDeclaringToString);
     } catch (NoSuchMethodException | SecurityException e) {
       // NoSuchMethodException should not occur as toString is always defined.
-      // if SecurityException occurs, returning false will lead to format iterable
+      // if SecurityException occurs, returning false to use our own representation 
       return false;
     }
   }
 
+  // this method assumes that objectClass is a subclass of clazz, it checks that toString is not
+  // declared in clazz or any superclass of clazz.
+  // this typically used to check whether an AtomicReference subclass has overridden toString.
+  private static boolean hasOverriddenToStringInSubclassOf(Class<?> objectClass, Class<?> clazz) {
+    try {
+      Class<?> classDeclaringToString = objectClass.getMethod("toString").getDeclaringClass();
+      // check if any classes between objectClass and clazz (excluded) have overridden toString 
+      Class<?> classToCheck = objectClass;
+      while (!classToCheck.equals(clazz)) {
+        if (classDeclaringToString.equals(classToCheck)) return true;
+        classToCheck = classToCheck.getSuperclass();
+      }
+    } catch (NoSuchMethodException | SecurityException e) {
+      // NoSuchMethodException should not occur as toString is always defined.
+      // if SecurityException occurs, returning false to use our own representation 
+    }
+    return false;
+  }
+
   @Override
   public String unambiguousToStringOf(Object obj) {
     // some types have already an unambiguous toString, no need to double down
@@ -480,16 +506,18 @@ public class StandardRepresentation implements Representation {
   }
 
   protected String toStringOf(AtomicReference<?> atomicReference) {
-    return String.format("AtomicReference[%s]", toStringOf(atomicReference.get()));
+    return String.format("%s[%s]", atomicReference.getClass().getSimpleName(), toStringOf(atomicReference.get()));
   }
 
   protected String toStringOf(AtomicMarkableReference<?> atomicMarkableReference) {
-    return String.format("AtomicMarkableReference[marked=%s, reference=%s]", atomicMarkableReference.isMarked(),
+    return String.format("%s[marked=%s, reference=%s]", atomicMarkableReference.getClass().getSimpleName(),
+                         atomicMarkableReference.isMarked(),
                          toStringOf(atomicMarkableReference.getReference()));
   }
 
   protected String toStringOf(AtomicStampedReference<?> atomicStampedReference) {
-    return String.format("AtomicStampedReference[stamp=%s, reference=%s]", atomicStampedReference.getStamp(),
+    return String.format("%s[stamp=%s, reference=%s]", atomicStampedReference.getClass().getSimpleName(),
+                         atomicStampedReference.getStamp(),
                          toStringOf(atomicStampedReference.getReference()));
   }
 
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_AtomicReferences_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_AtomicReferences_Test.java
new file mode 100644
index 000000000..86fca62f3
--- /dev/null
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_AtomicReferences_Test.java
@@ -0,0 +1,273 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicMarkableReference;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicStampedReference;
+
+import org.junit.Test;
+
+@SuppressWarnings({ "serial", "unused" })
+public class StandardRepresentation_toStringOf_AtomicReferences_Test {
+
+  @Test
+  public void should_use_overridden_toString_in_AtomicReference_subclass() {
+    class MyData extends AtomicReference<String> {
+      private String description;
+
+      MyData(String description) {
+        this.description = description;
+      }
+
+      @Override
+      public String toString() {
+        return "MyData[" + description + "]";
+      }
+    }
+    // GIVEN
+    Object myData = new MyData("Description");
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myData);
+    // THEN
+    then(stringOf).isEqualTo("MyData[Description]");
+  }
+
+  @Test
+  public void should_use_the_last_overridden_toString_in_AtomicReference_subclasses() {
+    class MyData extends AtomicReference<String> {
+      protected String description;
+
+      MyData(String description) {
+        this.description = description;
+      }
+
+      @Override
+      public String toString() {
+        return "MyData[" + description + "]";
+      }
+    }
+    class MySubData extends MyData {
+
+      MySubData(String description) {
+        super(description);
+      }
+
+      @Override
+      public String toString() {
+        return "SubMyData[" + description + "]";
+      }
+    }
+    // GIVEN
+    Object myData = new MySubData("Description");
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myData);
+    // THEN
+    then(stringOf).isEqualTo("SubMyData[Description]");
+  }
+
+  @Test
+  public void should_use_overridden_toString_in_AtomicReference_intermediate_subclass() {
+    class MyData extends AtomicReference<String> {
+      protected String description;
+
+      MyData(String description) {
+        this.description = description;
+      }
+
+      @Override
+      public String toString() {
+        return "MyData[" + description + "]";
+      }
+    }
+    class MySubData extends MyData {
+
+      MySubData(String description) {
+        super(description);
+      }
+      
+      // no toString => use MyData.toString
+    }
+    // GIVEN
+    Object myData = new MySubData("Description");
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myData);
+    // THEN
+    then(stringOf).isEqualTo("MyData[Description]");
+  }
+
+  @Test
+  public void should_use_assertj_AtomicReference_representation_as_toString_was_not_overridden_in_AtomicReference_subclass() {
+    class MyData extends AtomicReference<String> {
+
+      MyData(String value) {
+        super(value);
+      }
+
+      // no overridden toString => use assertj representation
+    }
+    // GIVEN
+    Object myData = new MyData("value");
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myData);
+    // THEN
+    then(stringOf).isEqualTo("MyData[\"value\"]");
+  }
+
+  @Test
+  public void should_use_overridden_toString_in_AtomicMarkableReference_subclass() {
+    class MyData extends AtomicMarkableReference<String> {
+      private String description;
+
+      MyData(String description) {
+        super(description, true);
+        this.description = description;
+      }
+
+      @Override
+      public String toString() {
+        return "MyData[" + description + "]";
+      }
+    }
+    // GIVEN
+    Object myData = new MyData("Description");
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myData);
+    // THEN
+    then(stringOf).isEqualTo("MyData[Description]");
+  }
+
+  @Test
+  public void should_use_assertj_AtomicMarkableReference_representation_as_toString_was_not_overridden_in_AtomicMarkableReference_subclass() {
+    class MyData extends AtomicMarkableReference<String> {
+      private String description;
+
+      MyData(String description) {
+        super(description, true);
+        this.description = description;
+      }
+
+      // has no overridden toString, use the predefined one which gives "%s[marked=%s, reference=%s]"
+    }
+    // GIVEN
+    Object myData = new MyData("Description");
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myData);
+    // THEN
+    then(stringOf).isEqualTo("MyData[marked=true, reference=\"Description\"]");
+  }
+
+  @Test
+  public void should_use_overridden_toString_AtomicStampedReference() {
+    class MyData extends AtomicStampedReference<String> {
+      private String description;
+
+      MyData(String description) {
+        super(description, 0);
+        this.description = description;
+      }
+
+      @Override
+      public String toString() {
+        return "MyData[" + description + "]";
+      }
+    }
+    // GIVEN
+    Object myData = new MyData("Description");
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myData);
+    // THEN
+    then(stringOf).isEqualTo("MyData[Description]");
+  }
+
+  @Test
+  public void should_use_predefined_toString_AtomicStampedReference() {
+    class MyData extends AtomicStampedReference<String> {
+      private String description;
+
+      MyData(String description) {
+        super(description, 0);
+        this.description = description;
+      }
+
+      // has no overridden toString, use the predefined one which gives "%s[stamp=%s, reference=%s]"
+    }
+    // GIVEN
+    Object myData = new MyData("Description");
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myData);
+    // THEN
+    then(stringOf).isEqualTo("MyData[stamp=0, reference=\"Description\"]");
+  }
+
+  @Test
+  public void should_use_smartFormat() {
+    class MyIterable implements Iterable<String> {
+      ArrayList<String> arrayList;
+
+      public MyIterable(String[] strings) {
+        arrayList = new ArrayList<>(Arrays.asList(strings));
+      }
+
+      @Override
+      public Iterator<String> iterator() {
+        return arrayList.iterator();
+      }
+
+      // has no overridden toString
+    }
+    // GIVEN
+    String[] strings = { "A", "B", "C" };
+    MyIterable myIterable = new MyIterable(strings);
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myIterable);
+    // THEN
+    then(stringOf).isEqualTo("[\"A\", \"B\", \"C\"]");
+  }
+
+  @Test
+  public void should_use_overridden_toString() {
+    class MyIterable implements Iterable<String> {
+      List<String> arrayList;
+
+      public MyIterable(String[] strings) {
+        arrayList = list(strings);
+      }
+
+      @Override
+      public Iterator<String> iterator() {
+        return arrayList.iterator();
+      }
+
+      @Override
+      public String toString() {
+        return "MyIterable: " + arrayList;
+      }
+    }
+    // GIVEN
+    String[] strings = { "A", "B", "C" };
+    MyIterable myIterable = new MyIterable(strings);
+    // WHEN
+    String stringOf = STANDARD_REPRESENTATION.toStringOf(myIterable);
+    // THEN
+    then(stringOf).isEqualTo("MyIterable: [A, B, C]");
+  }
+}
