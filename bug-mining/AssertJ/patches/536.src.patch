diff --git a/assertj-core/src/main/java/org/assertj/core/internal/Objects.java b/assertj-core/src/main/java/org/assertj/core/internal/Objects.java
index 948221309..36042f9d3 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/Objects.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/Objects.java
@@ -229,7 +229,8 @@ public class Objects {
   }
 
   public void assertNull(AssertionInfo info, Object actual) {
-    if (actual != null) throw failures.failure(info, shouldBeEqual(actual, null, comparisonStrategy, info.representation()));
+    if (actual != null)
+      throw failures.failure(info, shouldBeEqual(actual, null, comparisonStrategy, info.representation()));
   }
 
   public void assertNotNull(AssertionInfo info, Object actual) {
@@ -525,6 +526,8 @@ public class Objects {
     try {
       extractPropertyOrField(actual, name);
     } catch (IntrospectionError error) {
+      error.getterInvocationException()
+           .ifPresent(this::throwAsRuntime);
       throw failures.failure(info, shouldHavePropertyOrField(actual, name));
     }
   }
@@ -568,7 +571,8 @@ public class Objects {
   public <A> void assertDoesNotHaveSameHashCodeAs(AssertionInfo info, A actual, Object other) {
     assertNotNull(info, actual);
     requireNonNull(other, "The object used to compare actual's hash code with should not be null");
-    if (actual.hashCode() == other.hashCode()) throw failures.failure(info, shouldNotHaveSameHashCode(actual, other));
+    if (actual.hashCode() == other.hashCode())
+      throw failures.failure(info, shouldNotHaveSameHashCode(actual, other));
   }
 
   private static class ByFieldsComparison {
@@ -595,4 +599,10 @@ public class Objects {
 
   }
 
+  private void throwAsRuntime(Throwable ex) {
+    if (ex instanceof RuntimeException) {
+      throw (RuntimeException) ex;
+    }
+    throw new RuntimeException(ex);
+  }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/util/introspection/Introspection.java b/assertj-core/src/main/java/org/assertj/core/util/introspection/Introspection.java
index 085ab061d..89bde5189 100644
--- a/assertj-core/src/main/java/org/assertj/core/util/introspection/Introspection.java
+++ b/assertj-core/src/main/java/org/assertj/core/util/introspection/Introspection.java
@@ -19,6 +19,7 @@ import static java.util.Objects.requireNonNull;
 import static org.assertj.core.util.Preconditions.checkNotNullOrEmpty;
 import static org.assertj.core.util.Strings.quote;
 
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.Map;
@@ -48,12 +49,12 @@ public final class Introspection {
    * Returns the getter {@link Method} for a property matching the given name in the given object.
    *
    * @param propertyName the given property name.
-   * @param target the given object.
+   * @param target       the given object.
    * @return the getter {@code Method} for a property matching the given name in the given object.
-   * @throws NullPointerException if the given property name is {@code null}.
+   * @throws NullPointerException     if the given property name is {@code null}.
    * @throws IllegalArgumentException if the given property name is empty.
-   * @throws NullPointerException if the given object is {@code null}.
-   * @throws IntrospectionError if the getter for the matching property cannot be found or accessed.
+   * @throws NullPointerException     if the given object is {@code null}.
+   * @throws IntrospectionError       if the getter for the matching property cannot be found or accessed.
    */
   public static Method getPropertyGetter(String propertyName, Object target) {
     checkNotNullOrEmpty(propertyName);
@@ -69,15 +70,19 @@ public final class Introspection {
       // force access for static class with public getter
       getter.setAccessible(true);
       getter.invoke(target);
+    } catch (InvocationTargetException ex) {
+      String message = format("Unable to invoke getter %s in %s, exception: %s",
+                              getter.getName(), target.getClass().getSimpleName(), ex.getTargetException());
+      throw new IntrospectionError(message, ex, ex.getTargetException());
     } catch (Exception t) {
       throw new IntrospectionError(propertyNotFoundErrorMessage("Unable to find property %s in %s", propertyName, target), t);
     }
     return getter;
   }
 
-  public static void setExtractBareNamePropertyMethods(boolean barenamePropertyMethods) {
+  public static void setExtractBareNamePropertyMethods(boolean bareNamePropertyMethods) {
     ConfigurationProvider.loadRegisteredConfiguration();
-    bareNamePropertyMethods = barenamePropertyMethods;
+    Introspection.bareNamePropertyMethods = bareNamePropertyMethods;
   }
 
   @VisibleForTesting
diff --git a/assertj-core/src/main/java/org/assertj/core/util/introspection/IntrospectionError.java b/assertj-core/src/main/java/org/assertj/core/util/introspection/IntrospectionError.java
index b1e062c32..63cd3e35c 100644
--- a/assertj-core/src/main/java/org/assertj/core/util/introspection/IntrospectionError.java
+++ b/assertj-core/src/main/java/org/assertj/core/util/introspection/IntrospectionError.java
@@ -12,6 +12,8 @@
  */
 package org.assertj.core.util.introspection;
 
+import java.util.Optional;
+
 /**
  * Error that occurred when using <a href="http://java.sun.com/docs/books/tutorial/javabeans/introspection/index.html">JavaBeans
  * Introspection</a>.
@@ -22,12 +24,20 @@ public class IntrospectionError extends RuntimeException {
 
   private static final long serialVersionUID = 1L;
 
+  /**
+   * This (nullable) field holds the original Exception thrown by the tested code
+   * during the invocation of a getter/accessor method. This allows us to reference
+   * or rethrow it if alternative means of resolving the field are unsuccessful.
+   */
+  private final Throwable getterInvocationException;
+
   /**
    * Creates a new <code>{@link IntrospectionError}</code>.
    * @param message the detail message.
    */
   public IntrospectionError(String message) {
     super(message);
+    this.getterInvocationException = null;
   }
 
   /**
@@ -36,6 +46,21 @@ public class IntrospectionError extends RuntimeException {
    * @param cause the original cause.
    */
   public IntrospectionError(String message, Throwable cause) {
+    this(message, cause, null);
+  }
+
+  /**
+   * Creates a new <code>{@link IntrospectionError}</code>.
+   * @param message the detail message.
+   * @param cause the original cause.
+   * @param getterInvocationException the original exception thrown by the tested code.
+   */
+  public IntrospectionError(String message, Throwable cause, Throwable getterInvocationException) {
     super(message, cause);
+    this.getterInvocationException = getterInvocationException;
+  }
+
+  public Optional<Throwable> getterInvocationException() {
+    return Optional.ofNullable(getterInvocationException);
   }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java b/assertj-core/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java
index 9ace10309..9caef452e 100644
--- a/assertj-core/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java
+++ b/assertj-core/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java
@@ -80,6 +80,12 @@ public class PropertyOrFieldSupport {
           if (map.containsKey(name)) return map.get(name);
         }
 
+        // if the getter invocation throws exception and there's no field present,
+        // we'll propagate the IntrospectionError containing the original exception
+        if (propertyIntrospectionError.getterInvocationException().isPresent()) {
+          throw propertyIntrospectionError;
+        }
+
         // no value found with given name, it is considered as an error
         String message = format("%nCan't find any field or property with name '%s'.%n" +
                                 "Error when introspecting properties was :%n" +
diff --git a/assertj-core/src/test/java/org/assertj/core/internal/objects/Objects_assertHasFieldOrPropertyWithValue_Test.java b/assertj-core/src/test/java/org/assertj/core/internal/objects/Objects_assertHasFieldOrPropertyWithValue_Test.java
index 2ba742486..1ef414288 100644
--- a/assertj-core/src/test/java/org/assertj/core/internal/objects/Objects_assertHasFieldOrPropertyWithValue_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/internal/objects/Objects_assertHasFieldOrPropertyWithValue_Test.java
@@ -12,8 +12,9 @@
  */
 package org.assertj.core.internal.objects;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.Assertions.catchIllegalArgumentException;
+import static org.assertj.core.api.Assertions.catchRuntimeException;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldHavePropertyOrField.shouldHavePropertyOrField;
 import static org.assertj.core.error.ShouldHavePropertyOrFieldWithValue.shouldHavePropertyOrFieldWithValue;
 import static org.assertj.core.testkit.TestData.someInfo;
@@ -51,7 +52,7 @@ class Objects_assertHasFieldOrPropertyWithValue_Test extends ObjectsBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> objects.assertHasFieldOrPropertyWithValue(INFO, actual, "field1", 123));
     // THEN
-    assertThat(error).hasMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
@@ -62,7 +63,7 @@ class Objects_assertHasFieldOrPropertyWithValue_Test extends ObjectsBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> objects.assertHasFieldOrPropertyWithValue(INFO, actual, fieldName, "baz"));
     // THEN
-    assertThat(error).hasMessage(shouldHavePropertyOrFieldWithValue(actual, fieldName, "baz", "foo").create());
+    then(error).hasMessage(shouldHavePropertyOrFieldWithValue(actual, fieldName, "baz", "foo").create());
   }
 
   @Test
@@ -73,7 +74,7 @@ class Objects_assertHasFieldOrPropertyWithValue_Test extends ObjectsBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> objects.assertHasFieldOrPropertyWithValue(INFO, actual, fieldName, "foo"));
     // THEN
-    assertThat(error).hasMessage(shouldHavePropertyOrField(actual, fieldName).create());
+    then(error).hasMessage(shouldHavePropertyOrField(actual, fieldName).create());
   }
 
   @Test
@@ -84,7 +85,7 @@ class Objects_assertHasFieldOrPropertyWithValue_Test extends ObjectsBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> objects.assertHasFieldOrPropertyWithValue(INFO, actual, fieldName, "foo"));
     // THEN
-    assertThat(error).hasMessage(shouldHavePropertyOrField(actual, fieldName).create());
+    then(error).hasMessage(shouldHavePropertyOrField(actual, fieldName).create());
   }
 
   @Test
@@ -92,16 +93,41 @@ class Objects_assertHasFieldOrPropertyWithValue_Test extends ObjectsBaseTest {
     // GIVEN
     Object actual = new Data();
     String fieldName = null;
+    // WHEN
+    RuntimeException exception = catchIllegalArgumentException(() -> objects.assertHasFieldOrPropertyWithValue(INFO, actual,
+                                                                                                               fieldName, 12));
+    // THEN
+    then(exception).hasMessage("The name of the property/field to read should not be null");
+  }
+
+  @Test
+  void should_use_field_if_getters_throws_exception() {
+    // GIVEN
+    Object actual = new Data();
+    String fieldName = "fieldWithGetterThrowing";
     // WHEN/THEN
-    assertThatIllegalArgumentException().isThrownBy(() -> objects.assertHasFieldOrPropertyWithValue(INFO, actual, fieldName, 12))
-                                        .withMessage("The name of the property/field to read should not be null");
+    objects.assertHasFieldOrPropertyWithValue(INFO, actual, fieldName, "dummy");
+  }
+
+  @Test
+  void should_rethrow_getter_exception_if_field_is_missing() {
+    // GIVEN
+    Object actual = new Data();
+    String fieldName = "unknownFieldWithGetterThrowing";
+    // WHEN
+    RuntimeException exception = catchRuntimeException(() -> objects.assertHasFieldOrPropertyWithValue(INFO, actual, fieldName,
+                                                                                                       "foo"));
+    // THEN
+    then(exception).hasMessage("some dummy exception");
+
   }
 
   @SuppressWarnings("unused")
   private static class Data {
 
-    private Object field1 = "foo";
+    private final Object field1 = "foo";
     private Object field2;
+    private final Object fieldWithGetterThrowing = "dummy";
     private static Object staticField;
 
     @Override
@@ -113,5 +139,13 @@ class Objects_assertHasFieldOrPropertyWithValue_Test extends ObjectsBaseTest {
       return "bar";
     }
 
+    public Object getUnknownFieldWithGetterThrowing() {
+      throw new RuntimeException("some dummy exception");
+    }
+
+    public Object getFieldWithGetterThrowing() {
+      throw new RuntimeException("some dummy exception");
+
+    }
   }
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/internal/objects/Objects_assertHasFieldOrProperty_Test.java b/assertj-core/src/test/java/org/assertj/core/internal/objects/Objects_assertHasFieldOrProperty_Test.java
index c09e28723..6a5cc9eaf 100644
--- a/assertj-core/src/test/java/org/assertj/core/internal/objects/Objects_assertHasFieldOrProperty_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/internal/objects/Objects_assertHasFieldOrProperty_Test.java
@@ -12,8 +12,9 @@
  */
 package org.assertj.core.internal.objects;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.Assertions.catchIllegalArgumentException;
+import static org.assertj.core.api.Assertions.catchRuntimeException;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldHavePropertyOrField.shouldHavePropertyOrField;
 import static org.assertj.core.testkit.TestData.someInfo;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
@@ -50,7 +51,7 @@ class Objects_assertHasFieldOrProperty_Test extends ObjectsBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> objects.assertHasFieldOrProperty(INFO, actual, "field1"));
     // THEN
-    assertThat(error).hasMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
@@ -61,7 +62,7 @@ class Objects_assertHasFieldOrProperty_Test extends ObjectsBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> objects.assertHasFieldOrProperty(INFO, actual, fieldName));
     // THEN
-    assertThat(error).hasMessage(shouldHavePropertyOrField(actual, fieldName).create());
+    then(error).hasMessage(shouldHavePropertyOrField(actual, fieldName).create());
   }
 
   @Test
@@ -72,7 +73,7 @@ class Objects_assertHasFieldOrProperty_Test extends ObjectsBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> objects.assertHasFieldOrProperty(INFO, actual, fieldName));
     // THEN
-    assertThat(error).hasMessage(shouldHavePropertyOrField(actual, fieldName).create());
+    then(error).hasMessage(shouldHavePropertyOrField(actual, fieldName).create());
   }
 
   @Test
@@ -80,9 +81,30 @@ class Objects_assertHasFieldOrProperty_Test extends ObjectsBaseTest {
     // GIVEN
     Object actual = new Data();
     String fieldName = null;
+    // WHEN
+    RuntimeException exception = catchIllegalArgumentException(() -> objects.assertHasFieldOrProperty(INFO, actual, fieldName));
+    // THEN
+    then(exception).hasMessage("The name of the property/field to read should not be null");
+  }
+
+  @Test
+  void should_use_field_if_getters_throws_exception() {
+    // GIVEN
+    Object actual = new Data();
+    String fieldName = "fieldWithGetterThrowing";
     // WHEN/THEN
-    assertThatIllegalArgumentException().isThrownBy(() -> objects.assertHasFieldOrProperty(INFO, actual, fieldName))
-                                        .withMessage("The name of the property/field to read should not be null");
+    objects.assertHasFieldOrProperty(INFO, actual, fieldName);
+  }
+
+  @Test
+  void should_rethrow_getter_exception_if_field_is_missing() {
+    // GIVEN
+    Object actual = new Data();
+    String fieldName = "unknownFieldWithGetterThrowing";
+    // WHEN
+    RuntimeException exception = catchRuntimeException(() -> objects.assertHasFieldOrProperty(INFO, actual, fieldName));
+    // THEN
+    then(exception).hasMessage("some dummy exception");
   }
 
   @SuppressWarnings("unused")
@@ -90,6 +112,7 @@ class Objects_assertHasFieldOrProperty_Test extends ObjectsBaseTest {
 
     private Object field1;
     private Object field2;
+    private Object fieldWithGetterThrowing;
     private static Object staticField;
 
     @Override
@@ -101,5 +124,13 @@ class Objects_assertHasFieldOrProperty_Test extends ObjectsBaseTest {
       return null;
     }
 
+    public Object getUnknownFieldWithGetterThrowing() {
+      throw new RuntimeException("some dummy exception");
+    }
+
+    public Object getFieldWithGetterThrowing() {
+      throw new RuntimeException("some dummy exception");
+    }
   }
+
 }
