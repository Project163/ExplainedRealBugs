diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 3033269ec..334ca02a0 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -3375,6 +3375,12 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return myself;
   }
 
+  @Override
+  public SELF satisfiesExactlyInAnyOrder(@SuppressWarnings("unchecked") Consumer<? super ELEMENT>... requirements) {
+    iterables.assertSatisfiesExactlyInAnyOrder(info, actual, requirements);
+    return myself;
+  }
+
   // override methods to avoid compilation error when chaining an AbstractAssert method with a AbstractIterableAssert
   // one on raw types.
 
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index 0d0ccb569..8974dbc3e 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -2942,6 +2942,12 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
     return myself;
   }
 
+  @Override
+  public SELF satisfiesExactlyInAnyOrder(@SuppressWarnings("unchecked") Consumer<? super ELEMENT>... consumers) {
+    iterables.assertSatisfiesExactlyInAnyOrder(info, newArrayList(actual), consumers);
+    return myself;
+  }
+
   /**
    * Verifies that the actual array contains at least one of the given values.
    * <p>
diff --git a/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java b/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
index fb4042a4b..0ece4e19d 100644
--- a/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
@@ -3047,7 +3047,7 @@ public class AtomicReferenceArrayAssert<T>
     return myself;
   }
 
-  /*
+  /**
    * {@inheritDoc}
    */
   @Override
@@ -3062,6 +3062,12 @@ public class AtomicReferenceArrayAssert<T>
     return myself;
   }
 
+  @Override
+  public AtomicReferenceArrayAssert<T> satisfiesExactlyInAnyOrder(@SuppressWarnings("unchecked") Consumer<? super T>... consumers) {
+    iterables.assertSatisfiesExactlyInAnyOrder(info, newArrayList(array), consumers);
+    return myself;
+  }
+
   /**
    * Verifies that the actual AtomicReferenceArray contains at least one of the given values.
    * <p>
diff --git a/src/main/java/org/assertj/core/api/IterableAssert.java b/src/main/java/org/assertj/core/api/IterableAssert.java
index 3b5d0d9cd..51b76fd2d 100644
--- a/src/main/java/org/assertj/core/api/IterableAssert.java
+++ b/src/main/java/org/assertj/core/api/IterableAssert.java
@@ -174,4 +174,9 @@ public class IterableAssert<ELEMENT> extends
     return super.satisfiesExactly(requirements);
   }
 
+  @Override
+  @SafeVarargs
+  public final IterableAssert<ELEMENT> satisfiesExactlyInAnyOrder(Consumer<? super ELEMENT>... requirements) {
+    return super.satisfiesExactlyInAnyOrder(requirements);
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/ListAssert.java b/src/main/java/org/assertj/core/api/ListAssert.java
index f6aa718e2..4c7b61e33 100644
--- a/src/main/java/org/assertj/core/api/ListAssert.java
+++ b/src/main/java/org/assertj/core/api/ListAssert.java
@@ -366,4 +366,10 @@ public class ListAssert<ELEMENT> extends
     return super.satisfiesExactly(requirements);
   }
 
+  @Override
+  @SafeVarargs
+  public final ListAssert<ELEMENT> satisfiesExactlyInAnyOrder(Consumer<? super ELEMENT>... requirements) {
+    return super.satisfiesExactlyInAnyOrder(requirements);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/ObjectArrayAssert.java b/src/main/java/org/assertj/core/api/ObjectArrayAssert.java
index c9b13fba2..37a19abac 100644
--- a/src/main/java/org/assertj/core/api/ObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/ObjectArrayAssert.java
@@ -140,4 +140,10 @@ public class ObjectArrayAssert<ELEMENT> extends AbstractObjectArrayAssert<Object
     return super.satisfiesExactly(requirements);
   }
 
+  @Override
+  @SafeVarargs
+  public final ObjectArrayAssert<ELEMENT> satisfiesExactlyInAnyOrder(Consumer<? super ELEMENT>... requirements) {
+    return super.satisfiesExactlyInAnyOrder(requirements);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java b/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
index 875f84058..7325f7a55 100644
--- a/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
+++ b/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
@@ -1311,11 +1311,65 @@ public interface ObjectEnumerableAssert<SELF extends ObjectEnumerableAssert<SELF
    * @return {@code this} to chain assertions.
    * @throws NullPointerException if given requirements is null.
    * @throws AssertionError if any element does not satisfy the requirements at the same index
-   * @throws AssertionError if there is not as many requirements as there are iterable elements.
+   * @throws AssertionError if there are not as many requirements as there are iterable elements.
    * @since 3.19.0
    */
   SELF satisfiesExactly(@SuppressWarnings("unchecked") Consumer<? super ELEMENT>... allRequirements);
 
+  /**
+   * Verifies that at least one combination of iterable elements exists that satisfies the consumers in order (there must be as
+   * many consumers as iterable elements and once a consumer is matched it cannot be reused to match other elements).
+   * <p>
+   * This is a variation of {@link #satisfiesExactly(Consumer...)} where order does not matter.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> List&lt;String&gt; starWarsCharacterNames = list("Luke", "Leia", "Yoda");
+   *
+   * // these assertions succeed:
+   * assertThat(starWarsCharacterNames).satisfiesExactlyInAnyOrder(name -&gt; assertThat(name).contains("Y"), // matches "Yoda"
+   *                                                               name -&gt; assertThat(name).contains("L"), // matches "Luke" and "Leia"
+   *                                                               name -&gt; {
+   *                                                                 assertThat(name).hasSize(4);
+   *                                                                 assertThat(name).doesNotContain("a"); // matches "Luke" but not "Leia"
+   *                                                               })
+   *                                   .satisfiesExactlyInAnyOrder(name -&gt; assertThat(name).contains("Yo"),
+   *                                                               name -&gt; assertThat(name).contains("Lu"),
+   *                                                               name -&gt; assertThat(name).contains("Le"))
+   *                                   .satisfiesExactlyInAnyOrder(name -&gt; assertThat(name).contains("Le"),
+   *                                                               name -&gt; assertThat(name).contains("Yo"),
+   *                                                               name -&gt; assertThat(name).contains("Lu"));
+   *
+   * // this assertion fails as 3 consumer/requirements are expected
+   * assertThat(starWarsCharacterNames).satisfiesExactlyInAnyOrder(name -&gt; assertThat(name).contains("Y"),
+   *                                                               name -&gt; assertThat(name).contains("L"));
+   *
+   * // this assertion fails as no element contains "Han" (first consumer/requirements can't be met)
+   * assertThat(starWarsCharacterNames).satisfiesExactlyInAnyOrder(name -&gt; assertThat(name).contains("Han"),
+   *                                                               name -&gt; assertThat(name).contains("L"),
+   *                                                               name -&gt; assertThat(name).contains("Y"));
+   *
+   * // this assertion fails as "Yoda" element can't satisfy any consumers/requirements (even though all consumers/requirements are met)
+   * assertThat(starWarsCharacterNames).satisfiesExactlyInAnyOrder(name -&gt; assertThat(name).contains("L"),
+   *                                                               name -&gt; assertThat(name).contains("L"),
+   *                                                               name -&gt; assertThat(name).contains("L"));
+   *
+   * // this assertion fails as no combination of elements can satisfy the consumers in order
+   * // the problem is if the last consumer is matched by Leia then no other consumer can match Luke (and vice versa)
+   * assertThat(starWarsCharacterNames).satisfiesExactlyInAnyOrder(name -&gt; assertThat(name).contains("Y"),
+   *                                                               name -&gt; assertThat(name).contains("o"),
+   *                                                               name -&gt; assertThat(name).contains("L"));</code></pre>
+   *
+   *
+   * @param allRequirements the consumers that are expected to be satisfied by the elements of the given {@code Iterable}.
+   * @return this assertion object.
+   * @throws NullPointerException if the given consumers array or any consumer is {@code null}.
+   * @throws AssertionError if there is no permutation of elements that satisfies the individual consumers in order
+   * @throws AssertionError if there are not as many requirements as there are iterable elements.
+   *
+   * @since 3.19.0
+   */
+  SELF satisfiesExactlyInAnyOrder(@SuppressWarnings("unchecked") Consumer<? super ELEMENT>... allRequirements);
+
   /**
    * Verifies whether any elements match the provided {@link Predicate}.
    * <p>
diff --git a/src/main/java/org/assertj/core/error/ShouldSatisfy.java b/src/main/java/org/assertj/core/error/ShouldSatisfy.java
index 7f658c398..697dd898a 100644
--- a/src/main/java/org/assertj/core/error/ShouldSatisfy.java
+++ b/src/main/java/org/assertj/core/error/ShouldSatisfy.java
@@ -12,15 +12,43 @@
  */
 package org.assertj.core.error;
 
+import java.util.function.Consumer;
+
 import org.assertj.core.api.Condition;
+import org.assertj.core.util.VisibleForTesting;
 
+/**
+ * Creates an error message indicating that an assertion that verifies that a {@link Condition} or a list of {@link Consumer}s cannot
+ * be satisfied.
+ */
 public class ShouldSatisfy extends BasicErrorMessageFactory {
 
+  @VisibleForTesting
+  public static final String CONDITION_SHOULD_BE_SATISFIED = "%nExpecting:%n  <%s>%nto satisfy:%n  <%s>";
+  @VisibleForTesting
+  public static final String CONSUMERS_SHOULD_BE_SATISFIED_IN_ANY_ORDER = "%nExpecting:%n  <%s>%nto satisfy all the consumers in any order.";
+  @VisibleForTesting
+  public static final String CONSUMERS_SHOULD_NOT_BE_NULL = "The Consumer<? super E>... expressing the assertions consumers must not be null";
+
   public static <T> ErrorMessageFactory shouldSatisfy(T actual, Condition<? super T> condition) {
     return new ShouldSatisfy(actual, condition);
   }
 
+  /**
+   * Creates a new <code>{@link ShouldSatisfy}</code>.
+   *
+   * @param actual the actual iterable in the failed assertion.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static <E> ErrorMessageFactory shouldSatisfyExactlyInAnyOrder(Iterable<E> actual) {
+    return new ShouldSatisfy(actual);
+  }
+
   private ShouldSatisfy(Object actual, Condition<?> condition) {
-    super("%nExpecting:%n  <%s>%nto satisfy:%n  <%s>", actual, condition);
+    super(CONDITION_SHOULD_BE_SATISFIED, actual, condition);
+  }
+
+  private <E> ShouldSatisfy(Iterable<E> actual) {
+    super(CONSUMERS_SHOULD_BE_SATISFIED_IN_ANY_ORDER, actual);
   }
 }
diff --git a/src/main/java/org/assertj/core/internal/ElementsSatisfyingConsumer.java b/src/main/java/org/assertj/core/internal/ElementsSatisfyingConsumer.java
new file mode 100644
index 000000000..e1a341ec9
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/ElementsSatisfyingConsumer.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.internal.Iterables.byPassingAssertions;
+import static org.assertj.core.util.Streams.stream;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+
+/**
+ * Wrapper for the list of elements that satisfy certain requirements (expressed as a <code>Consumer</code>).
+ *
+ * @author Michael Grafl
+ *
+ * @param <E> element type
+ */
+class ElementsSatisfyingConsumer<E> {
+  private final List<E> elements;
+
+  ElementsSatisfyingConsumer(Iterable<? extends E> actual, Consumer<? super E> assertions) {
+    this(filterByPassingAssertions(actual, assertions));
+  }
+
+  private ElementsSatisfyingConsumer(List<E> elements) {
+    this.elements = elements;
+  }
+
+  List<E> getElements() {
+    return elements;
+  }
+
+  /**
+   * New <code>ElementsSatisfyingConsumer</code> containing all elements except the (first occurrence of the) given element.
+   *
+   * <p> This instance is not modified.
+   *
+   * @param element the element to remove from the result
+   * @return all except the given element
+   */
+  ElementsSatisfyingConsumer<E> withoutElement(E element) {
+    ArrayList<E> listWithoutElement = new ArrayList<>(elements);
+    listWithoutElement.remove(element);
+    return new ElementsSatisfyingConsumer<>(listWithoutElement);
+  }
+
+  private static <E> List<E> filterByPassingAssertions(Iterable<? extends E> actual, Consumer<? super E> assertions) {
+    return stream(actual).filter(byPassingAssertions(assertions)).collect(toList());
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Iterables.java b/src/main/java/org/assertj/core/internal/Iterables.java
index 2068b41ff..06412935a 100644
--- a/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/src/main/java/org/assertj/core/internal/Iterables.java
@@ -56,6 +56,7 @@ import static org.assertj.core.error.ShouldNotContainNull.shouldNotContainNull;
 import static org.assertj.core.error.ShouldNotContainSequence.shouldNotContainSequence;
 import static org.assertj.core.error.ShouldNotContainSubsequence.shouldNotContainSubsequence;
 import static org.assertj.core.error.ShouldNotHaveDuplicates.shouldNotHaveDuplicates;
+import static org.assertj.core.error.ShouldSatisfy.shouldSatisfyExactlyInAnyOrder;
 import static org.assertj.core.error.ShouldStartWith.shouldStartWith;
 import static org.assertj.core.error.ZippedElementsShouldSatisfy.zippedElementsShouldSatisfy;
 import static org.assertj.core.internal.Arrays.assertIsArray;
@@ -81,8 +82,10 @@ import static org.assertj.core.util.IterableUtil.sizeOf;
 import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.Streams.stream;
 
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Comparator;
+import java.util.Deque;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
@@ -90,6 +93,7 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
+import java.util.Queue;
 import java.util.Set;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
@@ -1156,7 +1160,8 @@ public class Iterables {
     return Optional.empty();
   }
 
-  public <E> void assertSatisfiesExactly(AssertionInfo info, Iterable<? extends E> actual, Consumer<? super E>... allRequirements) {
+  public <E> void assertSatisfiesExactly(AssertionInfo info, Iterable<? extends E> actual,
+                                         @SuppressWarnings("unchecked") Consumer<? super E>... allRequirements) {
     assertNotNull(info, actual);
     assertHasSameSizeAs(info, actual, allRequirements); // TODO
     List<E> actualAsList = newArrayList(actual);
@@ -1172,6 +1177,54 @@ public class Iterables {
 
   }
 
+  @SafeVarargs
+  public final <E> void assertSatisfiesExactlyInAnyOrder(AssertionInfo info, Iterable<? extends E> actual,
+                                                         @SuppressWarnings("unchecked") Consumer<? super E>... consumers) {
+    assertNotNull(info, actual);
+    requireNonNull(consumers, "The Consumer<? super E>... expressing the assertions must not be null");
+    for (Consumer<? super E> consumer : consumers)
+      requireNonNull(consumer, "Elements in the Consumer<? super E>... expressing the assertions must not be null");
+
+    checkSizes(actual, sizeOf(actual), consumers.length, info);
+    Deque<ElementsSatisfyingConsumer<E>> satisfiedElementsPerConsumer = satisfiedElementsPerConsumer(actual, consumers);
+    // fail fast check
+    boolean someRequirementsAreNotMet = satisfiedElementsPerConsumer.stream().anyMatch(e -> e.getElements().isEmpty());
+    if (someRequirementsAreNotMet) throw failures.failure(info, shouldSatisfyExactlyInAnyOrder(actual));
+
+    if (!areAllConsumersSatisfied(satisfiedElementsPerConsumer))
+      throw failures.failure(info, shouldSatisfyExactlyInAnyOrder(actual));
+  }
+
+  @SafeVarargs
+  private static <E> Deque<ElementsSatisfyingConsumer<E>> satisfiedElementsPerConsumer(Iterable<? extends E> actual,
+                                                                                       Consumer<? super E>... consumers) {
+    return stream(consumers).map(consumer -> new ElementsSatisfyingConsumer<E>(actual, consumer))
+                            .collect(toCollection(ArrayDeque::new));
+  }
+
+  private static <E> boolean areAllConsumersSatisfied(Queue<ElementsSatisfyingConsumer<E>> satisfiedElementsPerConsumer) {
+    // recursively test whether we can find any specific matching permutation that can meet the requirements
+    if (satisfiedElementsPerConsumer.isEmpty()) return true; // all consumers have been satisfied
+
+    // pop the head (i.e, elements satisfying the current consumer), process the tail (i.e., remaining consumers)...
+    ElementsSatisfyingConsumer<E> head = satisfiedElementsPerConsumer.remove();
+    List<E> elementsSatisfyingCurrentConsumer = head.getElements();
+    if (elementsSatisfyingCurrentConsumer.isEmpty()) return false;   // no element satisfies current consumer
+    // if we remove an element satisfying the current consumer from all remaining consumers, will other elements still satisfy
+    // the remaining consumers?
+    return elementsSatisfyingCurrentConsumer.stream()
+                                            .map(element -> removeElement(satisfiedElementsPerConsumer, element))
+                                            .anyMatch(Iterables::areAllConsumersSatisfied);
+  }
+
+  private static <E> Queue<ElementsSatisfyingConsumer<E>> removeElement(Queue<ElementsSatisfyingConsumer<E>> satisfiedElementsPerConsumer,
+                                                                        E element) {
+    // new Queue of ElementsSatisfyingConsumer without the given element, original ElementsSatisfyingConsumer are not modified.
+    return satisfiedElementsPerConsumer.stream()
+                                       .map(elementsSatisfyingConsumer -> elementsSatisfyingConsumer.withoutElement(element))
+                                       .collect(toCollection(ArrayDeque::new));
+  }
+
   public <ACTUAL_ELEMENT, OTHER_ELEMENT> void assertZipSatisfy(AssertionInfo info,
                                                                Iterable<? extends ACTUAL_ELEMENT> actual,
                                                                Iterable<OTHER_ELEMENT> other,
diff --git a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
index e837f1ea7..3196b6617 100644
--- a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
@@ -1176,9 +1176,13 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
           .as("satisfiesExactly")
           .satisfiesExactly(name -> assertThat(name).isNull(),
                             name -> assertThat(name).isNotNull());
+    softly.then(names)
+          .as("satisfiesExactlyInAnyOrder")
+          .satisfiesExactlyInAnyOrder(name -> assertThat(name).isNull(),
+                                      name -> assertThat(name).isNotNull());
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(41);
+    assertThat(errorsCollected).hasSize(42);
     assertThat(errorsCollected.get(0)).hasMessageContaining("gandalf");
     assertThat(errorsCollected.get(1)).hasMessageContaining("frodo");
     assertThat(errorsCollected.get(2)).hasMessageContaining("foo")
@@ -1221,6 +1225,7 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(38)).hasMessageContaining("map with function");
     assertThat(errorsCollected.get(39)).hasMessageContaining("map with multiple functions");
     assertThat(errorsCollected.get(40)).hasMessageContaining("satisfiesExactly");
+    assertThat(errorsCollected.get(41)).hasMessageContaining("satisfiesExactlyInAnyOrder");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
@@ -1373,9 +1378,13 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
           .as("satisfiesExactly")
           .satisfiesExactly(name -> assertThat(name).isNull(),
                             name -> assertThat(name).isNotNull());
+    softly.then(names)
+          .as("satisfiesExactlyInAnyOrder")
+          .satisfiesExactlyInAnyOrder(name -> assertThat(name).isNull(),
+                                      name -> assertThat(name).isNotNull());
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(41);
+    assertThat(errorsCollected).hasSize(42);
     assertThat(errorsCollected.get(0)).hasMessageContaining("gandalf");
     assertThat(errorsCollected.get(1)).hasMessageContaining("frodo");
     assertThat(errorsCollected.get(2)).hasMessageContaining("foo")
@@ -1418,6 +1427,7 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(38)).hasMessageContaining("map with function");
     assertThat(errorsCollected.get(39)).hasMessageContaining("map with multiple functions");
     assertThat(errorsCollected.get(40)).hasMessageContaining("satisfiesExactly");
+    assertThat(errorsCollected.get(41)).hasMessageContaining("satisfiesExactlyInAnyOrder");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index 1791834c5..2597aca62 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -1453,9 +1453,13 @@ class SoftAssertionsTest extends BaseAssertionsTest {
           .as("satisfiesExactly")
           .satisfiesExactly(name -> assertThat(name).isNull(),
                             name -> assertThat(name).isNotNull());
+    softly.assertThat(names)
+          .as("satisfiesExactlyInAnyOrder")
+          .satisfiesExactlyInAnyOrder(name -> assertThat(name).isNull(),
+                                      name -> assertThat(name).isNotNull());
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(41);
+    assertThat(errorsCollected).hasSize(42);
     assertThat(errorsCollected.get(0)).hasMessage("[extracting(throwingFirstNameFunction)] error message");
     assertThat(errorsCollected.get(1)).hasMessage("[extracting(throwingFirstNameFunction)] error message");
     assertThat(errorsCollected.get(2)).hasMessage("[extracting(\"last\")] error message");
@@ -1497,6 +1501,7 @@ class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(38)).hasMessageContaining("map(firstNameFunction)");
     assertThat(errorsCollected.get(39)).hasMessageContaining("map with multiple functions");
     assertThat(errorsCollected.get(40)).hasMessageContaining("satisfiesExactly");
+    assertThat(errorsCollected.get(41)).hasMessageContaining("satisfiesExactlyInAnyOrder");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
@@ -1685,9 +1690,13 @@ class SoftAssertionsTest extends BaseAssertionsTest {
           .as("satisfiesExactly")
           .satisfiesExactly(name -> assertThat(name).isNull(),
                             name -> assertThat(name).isNotNull());
+    softly.assertThat(names)
+          .as("satisfiesExactlyInAnyOrder")
+          .satisfiesExactlyInAnyOrder(name -> assertThat(name).isNull(),
+                                      name -> assertThat(name).isNotNull());
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(41);
+    assertThat(errorsCollected).hasSize(42);
     assertThat(errorsCollected.get(0)).hasMessage("[extracting(throwingFirstNameFunction)] error message");
     assertThat(errorsCollected.get(1)).hasMessage("[extracting(throwingFirstNameFunction)] error message");
     assertThat(errorsCollected.get(2)).hasMessage("[extracting(\"last\")] error message");
@@ -1729,6 +1738,7 @@ class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(38)).hasMessageContaining("map(firstNameFunction)");
     assertThat(errorsCollected.get(39)).hasMessageContaining("map with multiple functions");
     assertThat(errorsCollected.get(40)).hasMessageContaining("satisfiesExactly");
+    assertThat(errorsCollected.get(41)).hasMessageContaining("satisfiesExactlyInAnyOrder");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
diff --git a/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java b/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
index a23d94055..603e4e777 100644
--- a/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
@@ -240,7 +240,12 @@ class Iterable_special_assertion_methods_in_assumptions_Test extends BaseAssumpt
                                       value -> assumeThat(value).satisfiesExactly(i -> assertThat(i).isOdd(),
                                                                                   i -> assertThat(i).isEven()),
                                       value -> assumeThat(value).satisfiesExactly(i -> assertThat(i).isOdd(),
-                                                                                  i -> assertThat(i).isOdd())));
+                                                                                  i -> assertThat(i).isOdd())),
+                     assumptionRunner(iterable(1, 2),
+                                      value -> assumeThat(value).satisfiesExactlyInAnyOrder(i -> assertThat(i).isEven(),
+                                                                                            i -> assertThat(i).isOdd()),
+                                      value -> assumeThat(value).satisfiesExactlyInAnyOrder(i -> assertThat(i).isOdd(),
+                                                                                            i -> assertThat(i).isOdd())));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java b/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java
index 9b959b373..7f13d81ff 100644
--- a/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java
@@ -233,7 +233,12 @@ class List_special_assertion_methods_in_assumptions_Test extends BaseAssumptions
                                       value -> assumeThat(value).satisfiesExactly(i -> assertThat(i).isOdd(),
                                                                                   i -> assertThat(i).isEven()),
                                       value -> assumeThat(value).satisfiesExactly(i -> assertThat(i).isOdd(),
-                                                                                  i -> assertThat(i).isOdd())));
+                                                                                  i -> assertThat(i).isOdd())),
+                     assumptionRunner(iterable(1, 2),
+                                      value -> assumeThat(value).satisfiesExactlyInAnyOrder(i -> assertThat(i).isEven(),
+                                                                                            i -> assertThat(i).isOdd()),
+                                      value -> assumeThat(value).satisfiesExactlyInAnyOrder(i -> assertThat(i).isOdd(),
+                                                                                            i -> assertThat(i).isOdd())));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_satisfiesExactlyInAnyOrder_Test.java b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_satisfiesExactlyInAnyOrder_Test.java
new file mode 100644
index 000000000..7ec8d47e7
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_satisfiesExactlyInAnyOrder_Test.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.atomic.referencearray;
+
+import static org.assertj.core.util.Lists.list;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.util.function.Consumer;
+
+import org.assertj.core.api.AtomicReferenceArrayAssert;
+import org.assertj.core.api.AtomicReferenceArrayAssertBaseTest;
+
+/**
+ * Tests for <code>{@link AtomicReferenceArrayAssert#satisfiesExactlyInAnyOrder(Consumer...)}</code>.
+ *
+ * @author Michael Grafl
+ */
+@SuppressWarnings("unchecked")
+class AtomicReferenceArrayAssert_satisfiesExactlyInAnyOrder_Test extends AtomicReferenceArrayAssertBaseTest {
+
+  private Consumer<Object> consumer = mock(Consumer.class);
+
+  @Override
+  protected AtomicReferenceArrayAssert<Object> create_assertions() {
+    return new AtomicReferenceArrayAssert<>(atomicArrayOf(new Object()));
+  }
+
+  @Override
+  protected AtomicReferenceArrayAssert<Object> invoke_api_method() {
+    return assertions.satisfiesExactlyInAnyOrder(consumer);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertSatisfiesExactlyInAnyOrder(info(), list(internalArray()), consumer);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_satisfiesExactlyInAnyOrder_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_satisfiesExactlyInAnyOrder_Test.java
new file mode 100644
index 000000000..10b9ed695
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_satisfiesExactlyInAnyOrder_Test.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.util.Lists.list;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.util.function.Consumer;
+
+import org.assertj.core.api.ConcreteIterableAssert;
+import org.assertj.core.api.IterableAssertBaseTest;
+
+/**
+ * Tests for <code>{@link org.assertj.core.api.AbstractIterableAssert#satisfiesExactlyInAnyOrder(Consumer...)}</code>.
+ *
+ * @author Michael Grafl
+ */
+@SuppressWarnings("unchecked")
+class IterableAssert_satisfiesExactlyInAnyOrder_Test extends IterableAssertBaseTest {
+
+  private Consumer<Object> consumer = mock(Consumer.class);
+
+  @Override
+  protected ConcreteIterableAssert<Object> create_assertions() {
+    return new ConcreteIterableAssert<>(list(new Object()));
+  }
+
+  @Override
+  protected ConcreteIterableAssert<Object> invoke_api_method() {
+    return assertions.satisfiesExactlyInAnyOrder(consumer);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertSatisfiesExactlyInAnyOrder(getInfo(assertions), getActual(assertions), consumer);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_satisfiesExactlyInAnyOrder_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_satisfiesExactlyInAnyOrder_Test.java
new file mode 100644
index 000000000..6487496e5
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_satisfiesExactlyInAnyOrder_Test.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.objectarray;
+
+import static org.assertj.core.test.ObjectArrays.arrayOf;
+import static org.assertj.core.util.Lists.list;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.util.function.Consumer;
+
+import org.assertj.core.api.ObjectArrayAssert;
+import org.assertj.core.api.ObjectArrayAssertBaseTest;
+
+/**
+ * Tests for <code>{@link ObjectArrayAssert#satisfiesExactlyInAnyOrder(Consumer...)}</code>.
+ *
+ * @author Michael Grafl
+ */
+@SuppressWarnings("unchecked")
+class ObjectArrayAssert_satisfiesExactlyInAnyOrder_Test extends ObjectArrayAssertBaseTest {
+
+  private Consumer<Object> consumer = mock(Consumer.class);
+
+  @Override
+  protected ObjectArrayAssert<Object> create_assertions() {
+    return new ObjectArrayAssert<>(arrayOf(new Object()));
+  }
+
+  @Override
+  protected ObjectArrayAssert<Object> invoke_api_method() {
+    return assertions.satisfiesExactlyInAnyOrder(consumer);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertSatisfiesExactlyInAnyOrder(getInfo(assertions), list(getActual(assertions)), consumer);
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldSatisfy_create_Test.java b/src/test/java/org/assertj/core/error/ShouldSatisfy_create_Test.java
index f34f1ca3a..7b6aae3a7 100644
--- a/src/test/java/org/assertj/core/error/ShouldSatisfy_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldSatisfy_create_Test.java
@@ -15,16 +15,24 @@ package org.assertj.core.error;
 import static java.lang.String.format;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldSatisfy.shouldSatisfy;
+import static org.assertj.core.error.ShouldSatisfy.shouldSatisfyExactlyInAnyOrder;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.Lists.newArrayList;
 
 import org.assertj.core.api.TestCondition;
+import org.assertj.core.description.Description;
 import org.assertj.core.description.TextDescription;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
+/**
+ * Tests for <code>{@link ShouldSatisfy#create(Description)}</code>.
+ */
+@DisplayName("ShouldSatisfy create")
 class ShouldSatisfy_create_Test {
 
   @Test
-  void should_create_error_message() {
+  void should_create_error_message_if_condition_is_not_satisfied() {
     // GIVEN
     ErrorMessageFactory factory = shouldSatisfy("Yoda", new TestCondition<>("green lightsaber bearer"));
     // WHEN
@@ -36,4 +44,17 @@ class ShouldSatisfy_create_Test {
                                    + "to satisfy:%n"
                                    + "  <green lightsaber bearer>"));
   }
+
+  @Test
+  void should_create_error_message_if_consumers_are_not_all_satisfied() {
+    // GIVEN
+    ErrorMessageFactory factory = shouldSatisfyExactlyInAnyOrder(newArrayList("Luke", "Leia", "Yoda"));
+    // WHEN
+    String message = factory.create(new TextDescription("Test"), STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n"
+                                   + "Expecting:%n"
+                                   + "  <[\"Luke\", \"Leia\", \"Yoda\"]>%n"
+                                   + "to satisfy all the consumers in any order."));
+  }
 }
diff --git a/src/test/java/org/assertj/core/internal/iterables/Iterables_assertSatisfiesExactlyInAnyOrder_Test.java b/src/test/java/org/assertj/core/internal/iterables/Iterables_assertSatisfiesExactlyInAnyOrder_Test.java
new file mode 100644
index 000000000..94ca566f3
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/iterables/Iterables_assertSatisfiesExactlyInAnyOrder_Test.java
@@ -0,0 +1,179 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal.iterables;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldHaveSize.shouldHaveSize;
+import static org.assertj.core.error.ShouldSatisfy.shouldSatisfyExactlyInAnyOrder;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.util.List;
+import java.util.function.Consumer;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Iterables;
+import org.assertj.core.internal.IterablesBaseTest;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for <code>{@link Iterables#assertSatisfiesExactlyInAnyOrder(AssertionInfo, Iterable, Consumer[])}</code>.
+ *
+ * @author Ting Sun
+ */
+@DisplayName("Iterables assertSatisfiesExactlyInAnyOrder")
+class Iterables_assertSatisfiesExactlyInAnyOrder_Test extends IterablesBaseTest {
+
+  private List<String> actual = newArrayList("Luke", "Leia", "Yoda");
+
+  @Test
+  void should_pass_if_all_consumers_are_satisfied_by_different_elements_in_order() {
+    // GIVEN
+    Consumer<String> consumer1 = s -> assertThat(s).contains("Luk");
+    Consumer<String> consumer2 = s -> assertThat(s).contains("Lei");
+    Consumer<String> consumer3 = s -> {
+      assertThat(s).hasSize(4);
+      assertThat(s).doesNotContain("L");
+    }; // Matches "Yoda"
+
+    // WHEN/THEN
+    iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer1, consumer2, consumer3);
+  }
+
+  @Test
+  void should_pass_if_all_consumers_are_satisfied_by_different_elements_in_any_order() {
+    // GIVEN
+    Consumer<String> consumer1 = s -> assertThat(s).contains("Y"); // Matches "Yoda"
+    Consumer<String> consumer2 = s -> assertThat(s).contains("L"); // Matches "Luke" and "Leia"
+    Consumer<String> consumer3 = s -> assertThat(s).doesNotContain("a"); // Matches "Luke"
+
+    // WHEN/THEN
+    iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer1, consumer2, consumer3);
+    iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer1, consumer3, consumer2);
+    iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer2, consumer1, consumer3);
+    iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer2, consumer3, consumer1);
+    iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer3, consumer2, consumer1);
+    iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer3, consumer1, consumer2);
+  }
+
+  @Test
+  void should_fail_if_one_of_the_consumer_cannot_be_satisfied() {
+    // GIVEN
+    Consumer<String> consumer1 = s -> assertThat(s).hasSize(5);
+    Consumer<String> consumer2 = s -> assertThat(s).hasSize(4);
+    Consumer<String> consumer3 = s -> assertThat(s).hasSize(4);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer1,
+                                                                                                          consumer2, consumer3));
+    // THEN
+    then(assertionError).hasMessage(shouldSatisfyExactlyInAnyOrder(actual).create());
+  }
+
+  @Test
+  void should_fail_if_no_combination_of_consumers_can_be_satisfied() {
+    // GIVEN
+    Consumer<String> consumer1 = s -> assertThat(s).contains("Y"); // Matches "Yoda"
+    Consumer<String> consumer2 = s -> assertThat(s).contains("o"); // Matches "Yoda"
+    Consumer<String> consumer3 = s -> assertThat(s).contains("L"); // Matches "Luke" or "Leia"
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer1,
+                                                                                                          consumer2, consumer3));
+    // THEN
+    then(assertionError).hasMessage(shouldSatisfyExactlyInAnyOrder(actual).create());
+  }
+
+  @Test
+  void should_fail_if_one_of_the_requirements_cannot_be_satisfied() {
+    // GIVEN
+    Consumer<String> consumer1 = s -> assertThat(s).isNotEmpty(); // all elements satisfy this
+    Consumer<String> consumer2 = s -> assertThat(s).isNotEmpty(); // all elements satisfy this
+    Consumer<String> consumer3 = s -> assertThat(s).isBlank(); // no elements satisfy this
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer1,
+                                                                                                          consumer2, consumer3));
+    // THEN
+    then(assertionError).hasMessage(shouldSatisfyExactlyInAnyOrder(actual).create());
+  }
+
+  @Test
+  void should_pass_if_iterable_contains_multiple_equal_elements() {
+    // GIVEN
+    List<String> names = newArrayList("Luke", "Luke");
+    Consumer<String> consumer1 = s -> assertThat(s).contains("L");
+    Consumer<String> consumer2 = s -> assertThat(s).contains("u");
+
+    // WHEN/THEN
+    iterables.assertSatisfiesExactlyInAnyOrder(info, names, consumer1, consumer2);
+  }
+
+  @Test
+  void should_pass_if_both_are_empty() {
+    // WHEN/THEN
+    iterables.assertSatisfiesExactlyInAnyOrder(info, newArrayList());
+  }
+
+  @Test
+  void should_fail_if_there_are_too_few_consumers() {
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> iterables.assertSatisfiesExactlyInAnyOrder(info, actual));
+    // THEN
+    then(assertionError).hasMessage(shouldHaveSize(actual, 3, 0).create());
+  }
+
+  @Test
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    actual = null;
+    Consumer<String> consumer = s -> assertThat(s).hasSize(4);
+
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).satisfiesExactlyInAnyOrder(consumer));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+  @Test
+  void should_throw_error_if_consumer_array_is_null() {
+    // GIVEN
+    Consumer<String>[] consumers = null;
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(() -> assertThat(actual).satisfiesExactlyInAnyOrder(consumers))
+                                    .withMessage("The Consumer<? super E>... expressing the assertions must not be null");
+  }
+
+  @Test
+  void should_fail_if_consumer_var_arg_is_null() {
+    // GIVEN
+    Consumer<String> consumer = null;
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(() -> assertThat(actual).satisfiesExactlyInAnyOrder(consumer))
+                                    .withMessage("Elements in the Consumer<? super E>... expressing the assertions must not be null");
+  }
+
+  @Test
+  void should_fail_if_there_are_too_many_consumers() {
+    // GIVEN
+    Consumer<String> consumer = s -> assertThat(s).doesNotContain("z");
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumer,
+                                                                                                          consumer, consumer,
+                                                                                                          consumer));
+    // THEN
+    then(assertionError).hasMessage(shouldHaveSize(actual, 3, 4).create());
+  }
+
+}
