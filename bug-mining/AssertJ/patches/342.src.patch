diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
index fe2d2bde8..5802eaadc 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
@@ -137,4 +137,8 @@ final class DualValue {
   public boolean isEnum() {
     return expected.getClass().isEnum();
   }
+
+  public boolean isActualFieldAnEnum() {
+    return actual.getClass().isEnum();
+  }
 }
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 93e0f562b..ebe19dc28 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -205,9 +205,7 @@ public class RecursiveComparisonDifferenceCalculator {
       }
 
       if (dualValue.isEnum()) {
-        // avoid comparing enum recursively since they contain static fields which are ignored in recursive comparison
-        // this would make different field enum value to be considered the same!
-        if (dualValue.actual != dualValue.expected) comparisonState.addDifference(dualValue);
+        compareAsEnums(dualValue, comparisonState, recursiveComparisonConfiguration);
         continue;
       }
       // TODO move hasFieldTypesDifference check into each compareXXX
@@ -219,7 +217,8 @@ public class RecursiveComparisonDifferenceCalculator {
 
       // we compare ordered collections specifically as to be matching, each pair of elements at a given index must match.
       // concretely we compare: (col1[0] vs col2[0]), (col1[1] vs col2[1])...(col1[n] vs col2[n])
-      if (dualValue.isExpectedFieldAnOrderedCollection() && !recursiveComparisonConfiguration.shouldIgnoreCollectionOrder(dualValue)) {
+      if (dualValue.isExpectedFieldAnOrderedCollection()
+          && !recursiveComparisonConfiguration.shouldIgnoreCollectionOrder(dualValue)) {
         compareOrderedCollections(dualValue, comparisonState);
         continue;
       }
@@ -289,6 +288,27 @@ public class RecursiveComparisonDifferenceCalculator {
     return comparisonState.getDifferences();
   }
 
+  // avoid comparing enum recursively since they contain static fields which are ignored in recursive comparison
+  // this would make different field enum value to be considered the same!
+  private static void compareAsEnums(final DualValue dualValue,
+                                     ComparisonState comparisonState,
+                                     RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
+    if (recursiveComparisonConfiguration.isInStrictTypeCheckingMode()) {
+      // we can use == for comparison which checks both actual and expected values and types are the same
+      if (dualValue.actual != dualValue.expected) comparisonState.addDifference(dualValue);
+      return;
+    }
+    if (!dualValue.isActualFieldAnEnum()) {
+      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an enum"));
+      return;
+    }
+    // both actual and expected are enums
+    Enum<?> actualEnum = (Enum<?>) dualValue.actual;
+    Enum<?> expectedEnum = (Enum<?>) dualValue.expected;
+    // we must only compare actual and expected enum by value but not by type
+    if (actualEnum.name() != expectedEnum.name()) comparisonState.addDifference(dualValue);
+  }
+
   private static boolean hasCustomComparator(DualValue dualValue,
                                              RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
     String fieldName = dualValue.getConcatenatedPath();
@@ -488,8 +508,6 @@ public class RecursiveComparisonDifferenceCalculator {
 
   private static void compareOptional(DualValue dualValue, ComparisonState comparisonState) {
     if (!dualValue.isActualFieldAnOptional()) {
-      // at the moment we only allow comparing arrays with arrays but we might allow comparing to collections later on
-      // but only if we are not in strict type mode.
       comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an Optional"));
       return;
     }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/Color.java b/src/test/java/org/assertj/core/api/recursive/comparison/Color.java
new file mode 100644
index 000000000..7e2c658f7
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/Color.java
@@ -0,0 +1,17 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+enum Color {
+  RED, GREEN, BLUE
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/ColorDto.java b/src/test/java/org/assertj/core/api/recursive/comparison/ColorDto.java
new file mode 100644
index 000000000..3f3bb6fa9
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/ColorDto.java
@@ -0,0 +1,17 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+enum ColorDto {
+  RED, GREEN, BLUE, UNKNOWN
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isEnum_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_enumValues_Test.java
similarity index 69%
rename from src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isEnum_Test.java
rename to src/test/java/org/assertj/core/api/recursive/comparison/DualValue_enumValues_Test.java
index 3deec4af0..3f0e0f70a 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isEnum_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_enumValues_Test.java
@@ -13,15 +13,15 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.recursive.comparison.DualValue_isEnum_Test.Color.BLUE;
-import static org.assertj.core.api.recursive.comparison.DualValue_isEnum_Test.Color.RED;
+import static org.assertj.core.api.recursive.comparison.DualValue_enumValues_Test.Color.BLUE;
+import static org.assertj.core.api.recursive.comparison.DualValue_enumValues_Test.Color.RED;
 import static org.assertj.core.util.Lists.list;
 
 import java.util.List;
 
 import org.junit.jupiter.api.Test;
 
-public class DualValue_isEnum_Test {
+public class DualValue_enumValues_Test {
 
   private static final List<String> PATH = list("foo", "bar");
 
@@ -45,6 +45,26 @@ public class DualValue_isEnum_Test {
     assertThat(expectedFieldIsEnum).isFalse();
   }
 
+  @Test
+  public void isActualFieldAnEnum_should_return_true_when_actual_is_an_enum() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, BLUE, "");
+    // WHEN
+    boolean actualFieldIsEnum = dualValue.isActualFieldAnEnum();
+    // THEN
+    assertThat(actualFieldIsEnum).isTrue();
+  }
+
+  @Test
+  public void isActualFieldAnEnum_should_return_false_when_expected_is_not_an_enum() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", RED);
+    // WHEN
+    boolean actualFieldIsEnum = dualValue.isActualFieldAnEnum();
+    // THEN
+    assertThat(actualFieldIsEnum).isFalse();
+  }
+
   enum Color {
     RED, BLUE, GREEN
   }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/Light.java b/src/test/java/org/assertj/core/api/recursive/comparison/Light.java
new file mode 100644
index 000000000..8615920c5
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/Light.java
@@ -0,0 +1,22 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+class Light {
+  public Color color;
+
+  public Light(Color value) {
+    this.color = value;
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/LightDto.java b/src/test/java/org/assertj/core/api/recursive/comparison/LightDto.java
new file mode 100644
index 000000000..e451f4930
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/LightDto.java
@@ -0,0 +1,22 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+class LightDto {
+  public ColorDto color;
+
+  public LightDto(ColorDto color) {
+    this.color = color;
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
index 3b99e7af0..027bbc2a3 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
@@ -14,6 +14,9 @@ package org.assertj.core.api.recursive.comparison;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.comparison.Color.BLUE;
+import static org.assertj.core.api.recursive.comparison.Color.GREEN;
 import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
 import static org.assertj.core.error.ShouldNotBeNull.shouldNotBeNull;
 import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
@@ -34,11 +37,13 @@ import org.assertj.core.internal.objects.data.FriendlyPerson;
 import org.assertj.core.internal.objects.data.Giant;
 import org.assertj.core.internal.objects.data.Human;
 import org.assertj.core.internal.objects.data.Person;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
+@DisplayName("RecursiveComparisonAssert isEqualTo")
 public class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert_isEqualTo_BaseTest {
 
   @Test
@@ -337,34 +342,43 @@ public class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveCompariso
   @Test
   public void should_not_compare_enum_recursively() {
     // GIVEN
-    Check actual = new Check(A.B);
-    Check expected = new Check(A.C);
+    Light actual = new Light(GREEN);
+    Light expected = new Light(BLUE);
     // WHEN
     compareRecursivelyFailsAsExpected(actual, expected);
     // THEN
-    ComparisonDifference missingFieldDifference = diff("value", actual.value, expected.value);
-    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, missingFieldDifference);
+    ComparisonDifference difference = diff("color", actual.color, expected.color);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
   }
 
   @Test
-  public void should_compare_enum_by_value() {
+  public void should_compare_enum_by_value_only_when_strictTypeChecking_mode_is_disabled() {
     // GIVEN
-    Check actual = new Check(A.B);
-    Check expected = new Check(A.B);
+    Light actual = new Light(GREEN);
+    LightDto expected = new LightDto(ColorDto.GREEN);
     // WHEN-THEN
-    assertThat(actual).usingRecursiveComparison()
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison()
+                .isEqualTo(expected);
   }
 
-  enum A {
-    B, C
+  @Test
+  public void should_fail_when_expected_is_an_enum_and_actual_is_not() {
+    // GIVEN
+    LightString actual = new LightString("GREEN");
+    Light expected = new Light(GREEN);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", "GREEN", GREEN,
+                                           "expected field is an enum but actual field is not (java.lang.String)");
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
   }
 
-  static class Check {
-    public A value;
+  static class LightString {
+    public String color;
 
-    public Check(A value) {
-      this.value = value;
+    public LightString(String value) {
+      this.color = value;
     }
 
   }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_strictTypeCheck_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_strictTypeCheck_Test.java
index 25183a6fb..c81e8d9fb 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_strictTypeCheck_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_strictTypeCheck_Test.java
@@ -13,6 +13,8 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.comparison.Color.GREEN;
 
 import java.util.Date;
 
@@ -21,8 +23,10 @@ import org.assertj.core.internal.objects.data.Giant;
 import org.assertj.core.internal.objects.data.Person;
 import org.assertj.core.internal.objects.data.PersonDto;
 import org.assertj.core.internal.objects.data.PersonDtoWithPersonNeighbour;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
+@DisplayName("RecursiveComparisonAssert isEqualTo in strictTypeChecking mode")
 public class RecursiveComparisonAssert_isEqualTo_strictTypeCheck_Test
     extends RecursiveComparisonAssert_isEqualTo_BaseTest {
 
@@ -133,6 +137,29 @@ public class RecursiveComparisonAssert_isEqualTo_strictTypeCheck_Test
     verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(withA, withB, valueDifference);
   }
 
+  @Test
+  public void should_pass_when_enums_have_same_value_and_types() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    Light expected = new Light(GREEN);
+    // WHEN-THEN
+    then(actual).usingRecursiveComparison()
+                .withStrictTypeChecking()
+                .isEqualTo(expected);
+  }
+
+  @Test
+  public void should_fail_when_enums_have_same_value_but_different_types() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    LightDto expected = new LightDto(ColorDto.RED);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", GREEN, ColorDto.RED);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
   private static class Something {
     Inner inner;  // can be A or B
 
