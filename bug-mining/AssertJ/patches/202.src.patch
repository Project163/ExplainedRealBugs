diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 816af354e..377dca96b 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -33,6 +33,8 @@ import java.util.List;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import org.assertj.core.api.filter.FilterOperator;
 import org.assertj.core.api.filter.Filters;
@@ -942,11 +944,12 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * assertThat(parent).flatExtracting(CartoonCharacter::getChildren)
    *                   .containsOnly(bart, lisa, maggie, pebbles);</code></pre>
    * 
-   * The order of extracted values is consisted with both the order of the collection itself, as well as the extracted
+   * The order of extracted values is consistent with both the order of the collection itself, as well as the extracted
    * collections.
    * 
-   * @param extractor the object transforming input object to an Iterable of desired ones
+   * @param extractor the object transforming input object to an {@code Iterable} of desired ones
    * @return a new assertion object whose object under test is the list of values extracted
+   * @throws NullPointerException if one of the {@code Iterable}'s element is null.
    */
   public <V> ListAssert<V> flatExtracting(Extractor<? super ELEMENT, ? extends Collection<V>> extractor) {
     List<V> result = newArrayList();
@@ -959,6 +962,40 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return new ListAssert<>(result);
   }
 
+  /**
+   * Extract multiple values from each {@code Iterable}'s element according to the given {@code Extractor}s
+   * and concatenate/flatten the extracted values in a list that is used as the new object under test.
+   * <p>
+   * If extracted values were not flattened, instead of a simple list like (given 2 extractors) : 
+   * <pre>element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
+   * we would get a list of list like : 
+   * <pre>list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
+   * <p>
+   * Code example:
+   * <pre><code class='java'> // fellowshipOfTheRing is a List&lt;TolkienCharacter&gt;
+   * 
+   * // values are extracted in order and flattened : age1, name1, age2, name2, age3 ...  
+   * assertThat(fellowshipOfTheRing).flatExtracting(TolkienCharacter::getAge, 
+   *                                                TolkienCharacter::getName)
+   *                                .contains(33 ,"Frodo", 
+   *                                          1000, "Legolas",
+   *                                          87, "Aragorn");</code></pre>
+   * 
+   * The resulting extracted values list is ordered by {@code Iterable}'s element first and then extracted values, 
+   * this is why is in the example that age values come before names.
+   * 
+   * @param extractors all the extractors to apply on each actual {@code Iterable}'s elements
+   * @return a new assertion object whose object under test is a flattened list of all extracted values. 
+   */
+  @SafeVarargs
+  public final ListAssert<Object> flatExtracting(Extractor<? super ELEMENT, ? extends Object>... extractors) {
+    Stream<? extends ELEMENT> actualStream = stream(actual.spliterator(), false);
+    List<Object> result = actualStream.flatMap(element -> Stream.of(extractors)
+                                                                .map(extractor -> extractor.extract(element)))
+                                      .collect(Collectors.toList());
+    return new ListAssert<>(result);
+  }
+
   /**
    * Extract from Iterable's elements the Iterable/Array values corresponding to the given property/field name and
    * concatenate them into a single list becoming the new object under test.
@@ -1724,7 +1761,6 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return (SELF) new ListAssert<>(stream(actual.spliterator(), false).filter(predicate).collect(toList()));
   }
 
-
   /**
    * {@inheritDoc}
    */
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_with_multiple_extractors_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_with_multiple_extractors_Test.java
index 39a0ae7de..9298c930c 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_with_multiple_extractors_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_with_multiple_extractors_Test.java
@@ -13,6 +13,11 @@
 package org.assertj.core.api.iterable;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.TolkienCharacter.Race.DWARF;
+import static org.assertj.core.data.TolkienCharacter.Race.ELF;
+import static org.assertj.core.data.TolkienCharacter.Race.HOBBIT;
+import static org.assertj.core.data.TolkienCharacter.Race.MAIA;
+import static org.assertj.core.data.TolkienCharacter.Race.MAN;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -30,42 +35,48 @@ public class IterableAssert_flatExtracting_with_multiple_extractors_Test {
 
   private final List<TolkienCharacter> fellowshipOfTheRing = new ArrayList<>();
 
+  private static final Extractor<TolkienCharacter, String> name = new Extractor<TolkienCharacter, String>() {
+    @Override
+    public String extract(TolkienCharacter input) {
+      return input.getName();
+    }
+  };
+
+  private static final Extractor<TolkienCharacter, Integer> age = new Extractor<TolkienCharacter, Integer>() {
+    @Override
+    public Integer extract(TolkienCharacter input) {
+      return input.getAge();
+    }
+  };
+
   @Before
   public void setUp() {
-    fellowshipOfTheRing.add(TolkienCharacter.of("Frodo", 33, TolkienCharacter.Race.HOBBIT));
-    fellowshipOfTheRing.add(TolkienCharacter.of("Sam", 38, TolkienCharacter.Race.HOBBIT));
-    fellowshipOfTheRing.add(TolkienCharacter.of("Gandalf", 2020, TolkienCharacter.Race.MAIA));
-    fellowshipOfTheRing.add(TolkienCharacter.of("Legolas", 1000, TolkienCharacter.Race.ELF));
-    fellowshipOfTheRing.add(TolkienCharacter.of("Pippin", 28, TolkienCharacter.Race.HOBBIT));
-    fellowshipOfTheRing.add(TolkienCharacter.of("Gimli", 139, TolkienCharacter.Race.DWARF));
-    fellowshipOfTheRing.add(TolkienCharacter.of("Aragorn", 87, TolkienCharacter.Race.MAN));
-    fellowshipOfTheRing.add(TolkienCharacter.of("Boromir", 37, TolkienCharacter.Race.MAN));
+    fellowshipOfTheRing.add(TolkienCharacter.of("Frodo", 33, HOBBIT));
+    fellowshipOfTheRing.add(TolkienCharacter.of("Sam", 38, HOBBIT));
+    fellowshipOfTheRing.add(TolkienCharacter.of("Gandalf", 2020, MAIA));
+    fellowshipOfTheRing.add(TolkienCharacter.of("Legolas", 1000, ELF));
+    fellowshipOfTheRing.add(TolkienCharacter.of("Pippin", 28, HOBBIT));
+    fellowshipOfTheRing.add(TolkienCharacter.of("Gimli", 139, DWARF));
+    fellowshipOfTheRing.add(TolkienCharacter.of("Aragorn", 87, MAN));
+    fellowshipOfTheRing.add(TolkienCharacter.of("Boromir", 37, MAN));
   }
 
   @Test
   public void should_allow_assertions_on_multiple_extracted_values_flattened_in_a_single_list() {
-    assertThat(fellowshipOfTheRing).flatExtracting("age", "name")
+    assertThat(fellowshipOfTheRing).flatExtracting(age, name)
                                    .as("extract ages and names")
-                                   .containsSequence(33, "Frodo", 38, "Sam");
+                                   .contains(33, "Frodo", 38, "Sam");
   }
 
   @Test
-  public void should_throw_IllegalArgumentException_when_no_fields_or_properties_are_specified() {
-    thrown.expect(IllegalArgumentException.class);
-    assertThat(fellowshipOfTheRing).flatExtracting();
+  public void should_return_empty_list_if_no_extractors_are_specified() {
+    assertThat(fellowshipOfTheRing).flatExtracting().isEmpty();
   }
 
   @Test
-  public void should_throw_IllegalArgumentException_when_null_fields_or_properties_vararg() {
-    thrown.expect(IllegalArgumentException.class);
-    String[] fields = null;
-    assertThat(fellowshipOfTheRing).flatExtracting(fields);
-  }
-  
-  @Test
-  public void should_throw_IllegalArgumentException_when_extracting_from_null() {
-    thrown.expect(IllegalArgumentException.class);
+  public void should_throw_null_pointer_exception_when_extracting_from_null() {
+    thrown.expect(NullPointerException.class);
     fellowshipOfTheRing.add(null);
-    assertThat(fellowshipOfTheRing).flatExtracting("age", "name");
+    assertThat(fellowshipOfTheRing).flatExtracting(age, name);
   }
 }
