diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 6b878577b..62a0d91e0 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -1704,6 +1704,43 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Allows the recursive comparison to compare an enum field against a String field and vice versa.
+   * <p>
+   * Example:
+   * <pre><code class='java'> LightString actual = new LightString("GREEN");
+   * Light expected = new Light(GREEN);
+   *
+   * // compares "GREEN" to GREEN
+   * assertThat(actual).usingRecursiveComparison()
+   *                   .withEnumStringComparison()
+   *                   .isEqualTo(expected);
+   *
+   * // compares GREEN to "GREEN"
+   * assertThat(expected).usingRecursiveComparison()
+   *                     .withEnumStringComparison()
+   *                     .isEqualTo(actual);</code></pre>
+   * where {@code Light} and {@code LightString} are defined as:
+   * <pre><code class='java'> class Light {
+   *   Color color;
+   *   Light(Color value) {
+   *     this.color = value;
+   *   }
+   * }
+   * 
+   * class LightString {
+   *   String color;
+   *   LightString(String value) {
+   *     this.color = value;
+   *   }
+   * }</code></pre>
+   */
+  @CheckReturnValue
+  public SELF withEnumStringComparison() {
+    recursiveComparisonConfiguration.allowComparingEnumAgainstString(true);
+    return myself;
+  }
+
   SELF withTypeComparators(TypeComparators typeComparators) {
     Optional.ofNullable(typeComparators)
             .map(TypeComparators::comparatorByTypes)
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
index 0544b6c8d..6bde4f1ba 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
@@ -303,7 +303,7 @@ public final class DualValue {
   }
 
   public boolean isExpectedAnEnum() {
-    return expected.getClass().isEnum();
+    return expected != null && expected.getClass().isEnum();
   }
 
   public boolean isActualAnEnum() {
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index c2c2f6bbb..83e13f6bc 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -84,6 +84,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   private RecursiveComparisonIntrospectionStrategy introspectionStrategy = DEFAULT_RECURSIVE_COMPARISON_INTROSPECTION_STRATEGY;
 
+  private boolean compareEnumAgainstString = false;
+
   private RecursiveComparisonConfiguration(Builder builder) {
     super(builder);
     this.ignoreAllActualNullFields = builder.ignoreAllActualNullFields;
@@ -575,6 +577,21 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     this.introspectionStrategy = introspectionStrategy;
   }
 
+  /**
+   * Allows the recursive comparison to compare an enum field against a string field.
+   * <p>
+   * See {@link RecursiveComparisonAssert#withEnumStringComparison()} for code examples.
+   *
+   * @param compareEnumAgainstString whether to allow the recursive comparison to compare enum field against string field.
+   */
+  public void allowComparingEnumAgainstString(boolean compareEnumAgainstString) {
+    this.compareEnumAgainstString = compareEnumAgainstString;
+  }
+
+  public boolean isComparingEnumAgainstStringAllowed() {
+    return this.compareEnumAgainstString;
+  }
+
   @Override
   public String toString() {
     return multiLineDescription(CONFIGURATION_PROVIDER.representation());
@@ -585,11 +602,10 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return java.util.Objects.hash(fieldComparators, ignoreAllActualEmptyOptionalFields, ignoreAllActualNullFields,
                                   ignoreAllExpectedNullFields, ignoreAllOverriddenEquals, ignoreCollectionOrder,
                                   ignoredCollectionOrderInFields, ignoredCollectionOrderInFieldsMatchingRegexes,
-                                  getIgnoredFields(),
-                                  getIgnoredFieldsRegexes(), ignoredOverriddenEqualsForFields,
-                                  ignoredOverriddenEqualsForTypes,
-                                  ignoredOverriddenEqualsForFieldsMatchingRegexes, getIgnoredTypes(), strictTypeChecking,
-                                  typeComparators, comparedFields, comparedTypes, fieldMessages, typeMessages);
+                                  getIgnoredFields(), getIgnoredFieldsRegexes(), ignoredOverriddenEqualsForFields,
+                                  ignoredOverriddenEqualsForTypes, ignoredOverriddenEqualsForFieldsMatchingRegexes,
+                                  getIgnoredTypes(), strictTypeChecking, typeComparators, comparedFields, comparedTypes,
+                                  fieldMessages, typeMessages, compareEnumAgainstString);
   }
 
   @Override
@@ -642,6 +658,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     describeRegisteredErrorMessagesForFields(description);
     describeRegisteredErrorMessagesForTypes(description);
     describeIntrospectionStrategy(description);
+    describeCompareEnumAgainstString(description);
     return description.toString();
   }
 
@@ -839,6 +856,11 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     description.append(format("- the introspection strategy used was: %s%n", introspectionStrategy.getDescription()));
   }
 
+  private void describeCompareEnumAgainstString(StringBuilder description) {
+    if (compareEnumAgainstString)
+      description.append(format("- enums can be compared against strings (and vice versa), e.g. Color.RED and \"RED\" are considered equal%n"));
+  }
+
   private boolean matchesAnIgnoredOverriddenEqualsRegex(FieldLocation fieldLocation) {
     if (ignoredOverriddenEqualsForFieldsMatchingRegexes.isEmpty()) return false; // shortcut
     String pathToUseInRules = fieldLocation.getPathToUseInRules();
@@ -1022,6 +1044,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return new Builder();
   }
 
+
   /**
    * Builder to build {@link RecursiveComparisonConfiguration}.
    */
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 848f72743..00e8ffc60 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -57,6 +57,7 @@ import org.assertj.core.internal.DeepDifference;
 public class RecursiveComparisonDifferenceCalculator {
 
   private static final String DIFFERENT_ACTUAL_AND_EXPECTED_FIELD_TYPES = "expected field is %s but actual field is not (%s)";
+  private static final String ACTUAL_IS_AN_ENUM_WHILE_EXPECTED_IS_NOT = "expected field is a %s but actual field is an enum";
   private static final String ACTUAL_NOT_ORDERED_COLLECTION = "expected field is an ordered collection but actual field is not (%s), ordered collections are: "
                                                               + describeOrderedCollectionTypes();
 
@@ -244,6 +245,10 @@ public class RecursiveComparisonDifferenceCalculator {
         compareAsEnums(dualValue, comparisonState, recursiveComparisonConfiguration);
         continue;
       }
+      if (dualValue.isActualAnEnum()) {
+        compareAsEnums(dualValue, comparisonState, recursiveComparisonConfiguration);
+        continue;
+      }
       // TODO move hasFieldTypesDifference check into each compareXXX
 
       if (dualValue.isExpectedFieldAnArray()) {
@@ -358,23 +363,44 @@ public class RecursiveComparisonDifferenceCalculator {
 
   // avoid comparing enum recursively since they contain static fields which are ignored in recursive comparison
   // this would make different field enum value to be considered the same!
-  private static void compareAsEnums(final DualValue dualValue,
-                                     ComparisonState comparisonState,
+  private static void compareAsEnums(final DualValue dualValue, ComparisonState comparisonState,
                                      RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
     if (recursiveComparisonConfiguration.isInStrictTypeCheckingMode()) {
-      // we can use == for comparison which checks both actual and expected values and types are the same
+      // use == to check that both actual and expected values and types are the same
       if (dualValue.actual != dualValue.expected) comparisonState.addDifference(dualValue);
       return;
     }
-    if (!dualValue.isActualAnEnum()) {
-      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an enum"));
+    if (dualValue.isActualAnEnum() && dualValue.isExpectedAnEnum()) {
+      Enum<?> expectedEnum = (Enum<?>) dualValue.expected;
+      Enum<?> actualEnum = (Enum<?>) dualValue.actual;
+      // we must only compare actual and expected enum by value but not by type
+      if (!actualEnum.name().equals(expectedEnum.name())) comparisonState.addDifference(dualValue);
       return;
     }
-    // both actual and expected are enums
-    Enum<?> actualEnum = (Enum<?>) dualValue.actual;
-    Enum<?> expectedEnum = (Enum<?>) dualValue.expected;
-    // we must only compare actual and expected enum by value but not by type
-    if (!actualEnum.name().equals(expectedEnum.name())) comparisonState.addDifference(dualValue);
+    if (!recursiveComparisonConfiguration.isComparingEnumAgainstStringAllowed()) {
+      // either actual or expected is not an enum, not ok as we haven't allowed comparing enums to strings fields
+      enumComparedToDifferentTypeError(dualValue, comparisonState);
+      return;
+    }
+    if (dualValue.isExpectedAnEnum() && dualValue.actual instanceof String) {
+      Enum<?> expectedEnum = (Enum<?>) dualValue.expected;
+      if (!expectedEnum.name().equals(dualValue.actual.toString())) comparisonState.addDifference(dualValue);
+      return;
+    }
+    if (dualValue.isActualAnEnum() && dualValue.expected instanceof String) {
+      Enum<?> actualEnum = (Enum<?>) dualValue.actual;
+      if (!actualEnum.name().equals(dualValue.expected.toString())) comparisonState.addDifference(dualValue);
+      return;
+    }
+    // either actual or expected is not an enum and the other type is not a string so invalid type
+    enumComparedToDifferentTypeError(dualValue, comparisonState);
+  }
+
+  private static void enumComparedToDifferentTypeError(DualValue dualValue, ComparisonState comparisonState) {
+    String typeErrorMessage = dualValue.isExpectedAnEnum()
+        ? differentTypeErrorMessage(dualValue, "an enum")
+        : format(ACTUAL_IS_AN_ENUM_WHILE_EXPECTED_IS_NOT, dualValue.expected.getClass().getCanonicalName());
+    comparisonState.addDifference(dualValue, typeErrorMessage);
   }
 
   private static boolean shouldHonorEquals(DualValue dualValue,
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_enumValues_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_enumValues_Test.java
index 9e89ea59b..e8224d09b 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_enumValues_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_enumValues_Test.java
@@ -12,7 +12,7 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.recursive.comparison.Color.BLUE;
 import static org.assertj.core.api.recursive.comparison.Color.RED;
 import static org.assertj.core.util.Lists.list;
@@ -32,7 +32,7 @@ class DualValue_enumValues_Test {
     // WHEN
     boolean expectedFieldIsEnum = dualValue.isExpectedAnEnum();
     // THEN
-    assertThat(expectedFieldIsEnum).isTrue();
+    then(expectedFieldIsEnum).isTrue();
   }
 
   @Test
@@ -42,17 +42,17 @@ class DualValue_enumValues_Test {
     // WHEN
     boolean expectedFieldIsEnum = dualValue.isExpectedAnEnum();
     // THEN
-    assertThat(expectedFieldIsEnum).isFalse();
+    then(expectedFieldIsEnum).isFalse();
   }
 
   @Test
   void isExpectedAnEnum_should_return_false_when_expected_is_null() {
     // GIVEN
-    DualValue dualValue = new DualValue(PATH, null, "");
+    DualValue dualValue = new DualValue(PATH, RED, null);
     // WHEN
     boolean expectedFieldIsEnum = dualValue.isExpectedAnEnum();
     // THEN
-    assertThat(expectedFieldIsEnum).isFalse();
+    then(expectedFieldIsEnum).isFalse();
   }
 
   @Test
@@ -62,7 +62,7 @@ class DualValue_enumValues_Test {
     // WHEN
     boolean actualFieldIsEnum = dualValue.isActualAnEnum();
     // THEN
-    assertThat(actualFieldIsEnum).isTrue();
+    then(actualFieldIsEnum).isTrue();
   }
 
   @Test
@@ -72,7 +72,7 @@ class DualValue_enumValues_Test {
     // WHEN
     boolean actualFieldIsEnum = dualValue.isActualAnEnum();
     // THEN
-    assertThat(actualFieldIsEnum).isFalse();
+    then(actualFieldIsEnum).isFalse();
   }
 
   @Test
@@ -82,7 +82,7 @@ class DualValue_enumValues_Test {
     // WHEN
     boolean actualIsEnum = dualValue.isActualAnEnum();
     // THEN
-    assertThat(actualIsEnum).isFalse();
+    then(actualIsEnum).isFalse();
   }
 
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
index de17c15ef..ee64b31f6 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
@@ -17,10 +17,7 @@ import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
-import static org.assertj.core.api.recursive.comparison.Color.BLUE;
-import static org.assertj.core.api.recursive.comparison.Color.GREEN;
 import static org.assertj.core.api.recursive.comparison.ColorWithCode.RED;
-import static org.assertj.core.api.recursive.comparison.RecursiveComparisonAssert_isEqualTo_Test.EmployeeDTO.JobTitle.QA_ENGINEER;
 import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
 import static org.assertj.core.error.ShouldNotBeNull.shouldNotBeNull;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
@@ -313,55 +310,6 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
     verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, missingFieldDifference);
   }
 
-  @Test
-  void should_not_compare_enum_recursively() {
-    // GIVEN
-    Light actual = new Light(GREEN);
-    Light expected = new Light(BLUE);
-    // WHEN
-    compareRecursivelyFailsAsExpected(actual, expected);
-    // THEN
-    ComparisonDifference difference = diff("color", actual.color, expected.color);
-    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
-  }
-
-  @Test
-  void should_compare_enum_by_value_only_when_strictTypeChecking_mode_is_disabled() {
-    // GIVEN
-    Light actual = new Light(GREEN);
-    LightDto expected = new LightDto(ColorDto.GREEN);
-    // WHEN-THEN
-    then(actual).usingRecursiveComparison()
-                .isEqualTo(expected);
-  }
-
-  @Test
-  void should_fail_when_expected_is_an_enum_and_actual_is_not() {
-    // GIVEN
-    LightString actual = new LightString("GREEN");
-    Light expected = new Light(GREEN);
-    // WHEN
-    compareRecursivelyFailsAsExpected(actual, expected);
-    // THEN
-    ComparisonDifference difference = diff("color", "GREEN", GREEN,
-                                           "expected field is an enum but actual field is not (java.lang.String)");
-    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
-  }
-
-  @Test
-  void should_fail_when_actual_is_an_enum_and_expected_is_not() {
-    // GIVEN
-    Employee devPerson = new Employee("Example Name", "SOFTWARE_DEVELOPER");
-    BlogPost devBlogPost = new BlogPost(devPerson);
-    EmployeeDTO qaPersonDTO = new EmployeeDTO("Example Name", QA_ENGINEER);
-    BlogPostDTO qaBlogPostDTO = new BlogPostDTO(qaPersonDTO);
-    // WHEN
-    compareRecursivelyFailsAsExpected(qaBlogPostDTO, devBlogPost);
-    // THEN
-    ComparisonDifference difference = diff("author.jobTitle", QA_ENGINEER, "SOFTWARE_DEVELOPER");
-    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(qaBlogPostDTO, devBlogPost, difference);
-  }
-
   static class LightString {
     public String color;
 
@@ -516,46 +464,6 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
     }
   }
 
-  public static class BlogPost {
-    Employee author;
-
-    public BlogPost(Employee author) {
-      this.author = author;
-    }
-
-  }
-  public static class BlogPostDTO {
-    EmployeeDTO author;
-
-    public BlogPostDTO(EmployeeDTO author) {
-      this.author = author;
-    }
-
-  }
-  public static class Employee {
-    String name;
-    String jobTitle;
-
-    public Employee(String name, String jobTitle) {
-      this.name = name;
-      this.jobTitle = jobTitle;
-    }
-
-  }
-  public static class EmployeeDTO {
-    String name;
-    JobTitle jobTitle;
-
-    public EmployeeDTO(String name, JobTitle jobTitle) {
-      this.name = name;
-      this.jobTitle = jobTitle;
-    }
-
-    public enum JobTitle {
-      SOFTWARE_DEVELOPER, QA_ENGINEER
-    }
-  }
-
   // https://github.com/assertj/assertj/issues/2928
   @ParameterizedTest(name = "class: {2}")
   @MethodSource
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_enums_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_enums_Test.java
new file mode 100644
index 000000000..ad17feb0d
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_enums_Test.java
@@ -0,0 +1,256 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.comparison.Color.BLUE;
+import static org.assertj.core.api.recursive.comparison.Color.GREEN;
+import static org.assertj.core.api.recursive.comparison.Color.RED;
+import static org.assertj.core.api.recursive.comparison.RecursiveComparisonAssert_isEqualTo_with_enums_Test.EmployeeDTO.JobTitle.QA_ENGINEER;
+
+import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
+import org.junit.jupiter.api.Test;
+
+class RecursiveComparisonAssert_isEqualTo_with_enums_Test extends RecursiveComparisonAssert_isEqualTo_BaseTest {
+
+  @Test
+  void should_not_compare_enum_recursively() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    Light expected = new Light(BLUE);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", actual.color, expected.color);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
+  @Test
+  void should_compare_enum_by_reference_in_strictTypeChecking_mode() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    Light expected = new Light(GREEN);
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withStrictTypeChecking()
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_fail_when_enum_are_not_the_same_in_strictTypeChecking_mode() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    Light expected = new Light(RED);
+    recursiveComparisonConfiguration.strictTypeChecking(true);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", GREEN, RED);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
+  @Test
+  void should_compare_enum_by_name_by_default() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    LightDto expected = new LightDto(ColorDto.GREEN);
+    // WHEN-THEN
+    then(actual).usingRecursiveComparison()
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_fail_when_enum_names_are_not_equals() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    Light expected = new Light(RED);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", GREEN, RED);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
+  @Test
+  void should_pass_when_enum_matches_string_when_allowing_to_compare_enum_with_string() {
+    // GIVEN
+    LightString actual = new LightString("GREEN");
+    Light expected = new Light(GREEN);
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEnumStringComparison()
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_when_string_matches_enum_when_allowing_to_compare_enum_with_string() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    LightString expected = new LightString("GREEN");
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEnumStringComparison()
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_fail_when_enum_does_not_match_string_when_allowing_to_compare_enum_with_string() {
+    // GIVEN
+    LightString actual = new LightString("VERT");
+    Light expected = new Light(GREEN);
+    recursiveComparisonConfiguration.allowComparingEnumAgainstString(true);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", "VERT", GREEN);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_string_does_not_match_enum_when_allowing_to_compare_enum_with_string() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    LightString expected = new LightString("VERT");
+    recursiveComparisonConfiguration.allowComparingEnumAgainstString(true);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", GREEN, "VERT");
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_expected_is_an_enum_and_actual_is_not() {
+    // GIVEN
+    LightString actual = new LightString("GREEN");
+    Light expected = new Light(GREEN);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", "GREEN", GREEN,
+                                           "expected field is an enum but actual field is not (java.lang.String)");
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_actual_is_an_enum_and_expected_is_not() {
+    // GIVEN
+    Employee devPerson = new Employee("Example Name", "SOFTWARE_DEVELOPER");
+    BlogPost devBlogPost = new BlogPost(devPerson);
+    EmployeeDTO qaPersonDTO = new EmployeeDTO("Example Name", QA_ENGINEER);
+    BlogPostDTO qaBlogPostDTO = new BlogPostDTO(qaPersonDTO);
+    // WHEN
+    compareRecursivelyFailsAsExpected(qaBlogPostDTO, devBlogPost);
+    // THEN
+    ComparisonDifference difference = diff("author.jobTitle", QA_ENGINEER, "SOFTWARE_DEVELOPER",
+                                           "expected field is a java.lang.String but actual field is an enum");
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(qaBlogPostDTO, devBlogPost, difference);
+  }
+
+  @Test
+  void should_fail_when_expected_is_an_enum_and_actual_is_not_an_enum_or_a_string() {
+    // GIVEN
+    LightNumber actual = new LightNumber(123);
+    Light expected = new Light(GREEN);
+    recursiveComparisonConfiguration.allowComparingEnumAgainstString(true);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", 123, GREEN,
+                                           "expected field is an enum but actual field is not (java.lang.Integer)");
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_actual_is_an_enum_and_expected_is_not_an_enum_or_a_string() {
+    // GIVEN
+    Light actual = new Light(GREEN);
+    LightNumber expected = new LightNumber(123);
+    recursiveComparisonConfiguration.allowComparingEnumAgainstString(true);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("color", GREEN, 123,
+                                           "expected field is a java.lang.Integer but actual field is an enum");
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
+  static class LightString {
+    public String color;
+
+    public LightString(String value) {
+      this.color = value;
+    }
+
+    @Override
+    public String toString() {
+      return format("LightString[color=%s]", this.color);
+    }
+  }
+
+  static class LightNumber {
+    public int color;
+
+    public LightNumber(int value) {
+      this.color = value;
+    }
+
+    @Override
+    public String toString() {
+      return format("LightNumber[color=%s]", this.color);
+    }
+  }
+
+  public static class BlogPost {
+    Employee author;
+
+    public BlogPost(Employee author) {
+      this.author = author;
+    }
+
+  }
+  public static class BlogPostDTO {
+    EmployeeDTO author;
+
+    public BlogPostDTO(EmployeeDTO author) {
+      this.author = author;
+    }
+
+  }
+  public static class Employee {
+    String name;
+    String jobTitle;
+
+    public Employee(String name, String jobTitle) {
+      this.name = name;
+      this.jobTitle = jobTitle;
+    }
+
+  }
+  public static class EmployeeDTO {
+    String name;
+    JobTitle jobTitle;
+
+    public EmployeeDTO(String name, JobTitle jobTitle) {
+      this.name = name;
+      this.jobTitle = jobTitle;
+    }
+
+    public enum JobTitle
+    {
+      SOFTWARE_DEVELOPER, QA_ENGINEER
+    }
+  }
+
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index 8e40ef718..36169282e 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -343,6 +343,7 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     recursiveComparisonConfiguration.registerComparatorForType(AlwaysEqualComparator.ALWAYS_EQUALS_TUPLE, Tuple.class);
     recursiveComparisonConfiguration.registerComparatorForFields(ALWAYS_EQUALS_TUPLE, "foo");
     recursiveComparisonConfiguration.registerComparatorForFields(alwaysDifferent(), "bar.baz");
+    recursiveComparisonConfiguration.allowComparingEnumAgainstString(true);
     // WHEN
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
@@ -374,7 +375,8 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
                "  - foo -> AlwaysEqualComparator%n" +
                "- field comparators take precedence over type comparators.%n"+
                "- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).%n" +
-               "- the introspection strategy used was: DefaultRecursiveComparisonIntrospectionStrategy%n"));
+               "- the introspection strategy used was: DefaultRecursiveComparisonIntrospectionStrategy%n"+
+               "- enums can be compared against strings (and vice versa), e.g. Color.RED and \"RED\" are considered equal%n"));
     // @format:on
   }
 
@@ -398,6 +400,16 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     then(multiLineDescription).contains(format("- the comparison was performed on any fields with types: java.lang.String, java.lang.Integer%n"));
   }
 
+  @Test
+  void should_show_that_enum_can_be_compared_to_string() {
+    // GIVEN
+    recursiveComparisonConfiguration.allowComparingEnumAgainstString(true);
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    then(multiLineDescription).contains(format("- enums can be compared against strings (and vice versa), e.g. Color.RED and \"RED\" are considered equal"));
+  }
+
   // just to test the description does not fail when given a comparator with various String.format reserved flags
   private class PercentageComparator implements Comparator<Double> {
 
