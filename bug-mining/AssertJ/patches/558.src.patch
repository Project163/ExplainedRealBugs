diff --git a/assertj-core/src/main/java/module-info.java b/assertj-core/src/main/java/module-info.java
index b5eb4e701..1577a018e 100644
--- a/assertj-core/src/main/java/module-info.java
+++ b/assertj-core/src/main/java/module-info.java
@@ -23,6 +23,7 @@ module org.assertj.core {
   exports org.assertj.core.api.filter;
   exports org.assertj.core.api.iterable;
   exports org.assertj.core.api.junit.jupiter;
+  exports org.assertj.core.api.recursive;
   exports org.assertj.core.api.recursive.assertion;
   exports org.assertj.core.api.recursive.comparison;
   exports org.assertj.core.condition;
diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 4b0538800..6095fede1 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -943,6 +943,34 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Makes the recursive comparison to ignore <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Concepts.doc.html#18858">transient</a> fields.
+   * <p>
+   * Example:
+   * <pre><code class='java'> class Person {
+   *   String name;
+   *   transient double height;
+   * }
+   *
+   * Person sherlock = new Person("Sherlock", 1.80);
+   * Person cherlock = new Person("Sherlock", 1.81);
+   *
+   * // assertion succeeds as we ignore the height transient field:
+   * assertThat(sherlock).usingRecursiveComparison()
+   *                     .ignoreTransientFields()
+   *                     .isEqualTo(cherlock);
+   *
+   * // now this assertion fails as expected because the height field differs:
+   * assertThat(sherlock).usingRecursiveComparison()
+   *                     .isEqualTo(cherlock);</code></pre>
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   */
+  public RecursiveComparisonAssert<?> ignoringTransientFields() {
+    recursiveComparisonConfiguration.ignoreTransientFields();
+    return myself;
+  }
+
   /**
    * This method instructs the recursive comparison to compare recursively all fields including the one whose type have overridden equals,
    * <b>except fields with java types</b> (at some point we need to compare something!).
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/AbstractRecursiveComparisonIntrospectionStrategy.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/AbstractRecursiveComparisonIntrospectionStrategy.java
new file mode 100644
index 000000000..7d19464f1
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/AbstractRecursiveComparisonIntrospectionStrategy.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static java.util.Arrays.stream;
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toCollection;
+import static java.util.stream.Collectors.toSet;
+import static org.assertj.core.util.introspection.ClassUtils.isInJavaLangPackage;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.function.Predicate;
+
+public abstract class AbstractRecursiveComparisonIntrospectionStrategy implements RecursiveComparisonIntrospectionStrategy {
+
+  private boolean ignoreTransientFields = false;
+
+  public void ignoreTransientFields() {
+    ignoreTransientFields = true;
+  }
+
+  @Override
+  public boolean shouldIgnoreTransientFields() {
+    return ignoreTransientFields;
+  }
+
+  private Set<Field> getDeclaredFieldsIncludingInherited(Class<?> clazz) {
+    requireNonNull(clazz, "expecting Class parameter not to be null");
+    Set<Field> declaredFields = getDeclaredFields(clazz);
+    // get fields declared in superClass
+    Class<?> superClass = clazz.getSuperclass();
+    while (!isInJavaLangPackage(superClass)) {
+      declaredFields.addAll(getDeclaredFields(superClass));
+      superClass = superClass.getSuperclass();
+    }
+    return declaredFields;
+  }
+
+  protected Set<String> getFieldsNames(Class<?> clazz) {
+    return getDeclaredFieldsIncludingInherited(clazz).stream()
+                                                     .map(Field::getName)
+                                                     .collect(toSet());
+  }
+
+  private Set<Field> getDeclaredFields(Class<?> clazz) {
+    Field[] declaredFields = clazz.getDeclaredFields();
+    Predicate<Field> fieldPredicate = field -> !(field.isSynthetic() || Modifier.isStatic(field.getModifiers()));
+    if (ignoreTransientFields) {
+      fieldPredicate = fieldPredicate.and(field -> !Modifier.isTransient(field.getModifiers()));
+    }
+    return stream(declaredFields).filter(fieldPredicate)
+                                 .collect(toCollection(LinkedHashSet::new));
+  }
+
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingFields.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingFields.java
index 1ffdbba1a..49a46d7c5 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingFields.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingFields.java
@@ -17,14 +17,13 @@ import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.assertj.core.internal.Objects;
 import org.assertj.core.util.introspection.FieldSupport;
 
 /**
  * A {@link RecursiveComparisonIntrospectionStrategy} that introspects fields including inherited ones but ignores static and
  * synthetic fields.
  */
-public class ComparingFields implements RecursiveComparisonIntrospectionStrategy {
+public class ComparingFields extends AbstractRecursiveComparisonIntrospectionStrategy {
 
   public static final ComparingFields COMPARING_FIELDS = new ComparingFields();
 
@@ -34,7 +33,7 @@ public class ComparingFields implements RecursiveComparisonIntrospectionStrategy
   @Override
   public Set<String> getChildrenNodeNamesOf(Object node) {
     if (node == null) return new HashSet<>();
-    return fieldNamesPerClass.computeIfAbsent(node.getClass(), Objects::getFieldsNames);
+    return fieldNamesPerClass.computeIfAbsent(node.getClass(), this::getFieldsNames);
   }
 
   @Override
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingNormalizedFields.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingNormalizedFields.java
index 3b24b4603..26fe1d130 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingNormalizedFields.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingNormalizedFields.java
@@ -20,7 +20,7 @@ import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
-import org.assertj.core.internal.Objects;
+
 import org.assertj.core.util.introspection.IntrospectionError;
 
 /**
@@ -32,7 +32,7 @@ import org.assertj.core.util.introspection.IntrospectionError;
  *
  * @since 3.24.0
  */
-public abstract class ComparingNormalizedFields implements RecursiveComparisonIntrospectionStrategy {
+public abstract class ComparingNormalizedFields extends AbstractRecursiveComparisonIntrospectionStrategy {
 
   private static final String NO_FIELD_FOUND = "Unable to find field in %s, fields tried: %s and %s";
 
@@ -54,7 +54,7 @@ public abstract class ComparingNormalizedFields implements RecursiveComparisonIn
   public Set<String> getChildrenNodeNamesOf(Object node) {
     if (node == null) return new HashSet<>();
     Class<?> nodeClass = node.getClass();
-    Set<String> fieldsNames = Objects.getFieldsNames(nodeClass);
+    Set<String> fieldsNames = getFieldsNames(nodeClass);
     // we normalize fields so that we can compare actual and expected, for example if actual has a firstName field and expected
     // a first_name field, we won't find firstName in expected unless we normalize it
     // Note that normalize has side effects as it keeps track of the normalized name -> original name mapping
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingProperties.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingProperties.java
index 76e86e568..c348dd5f2 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingProperties.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/ComparingProperties.java
@@ -31,7 +31,7 @@ import org.assertj.core.util.introspection.PropertySupport;
  * A {@link RecursiveComparisonIntrospectionStrategy} that introspects properties by looking at public getters like
  * {@code getName()} or {@code isActive()}/{@code getActive()} for boolean properties.
  */
-public class ComparingProperties implements RecursiveComparisonIntrospectionStrategy {
+public class ComparingProperties extends AbstractRecursiveComparisonIntrospectionStrategy {
 
   public static final ComparingProperties COMPARING_PROPERTIES = new ComparingProperties();
 
@@ -57,6 +57,11 @@ public class ComparingProperties implements RecursiveComparisonIntrospectionStra
     return "comparing properties";
   }
 
+  @Override
+  public void ignoreTransientFields() {
+    throw new IllegalArgumentException("ignoringTransientFields is not supported since we are comparing properties");
+  }
+
   static Set<String> getPropertiesNamesOf(Class<?> clazz) {
     return gettersIncludingInheritedOf(clazz).stream()
                                              .map(Method::getName)
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/LegacyRecursiveComparisonIntrospectionStrategy.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/LegacyRecursiveComparisonIntrospectionStrategy.java
index 4beb4ecf7..fd0f56457 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/LegacyRecursiveComparisonIntrospectionStrategy.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/LegacyRecursiveComparisonIntrospectionStrategy.java
@@ -19,7 +19,6 @@ import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.assertj.core.internal.Objects;
 import org.assertj.core.util.introspection.PropertyOrFieldSupport;
 
 /**
@@ -28,7 +27,7 @@ import org.assertj.core.util.introspection.PropertyOrFieldSupport;
  * There is a bit of discrepancy in this strategy as it looks for fields to compare but gets the value in this order: property
  * first, then field and finally tries as map value if the instance is a map.
  */
-public class LegacyRecursiveComparisonIntrospectionStrategy implements RecursiveComparisonIntrospectionStrategy {
+public class LegacyRecursiveComparisonIntrospectionStrategy extends AbstractRecursiveComparisonIntrospectionStrategy {
 
   // use ConcurrentHashMap in case this strategy instance is used in a multi-thread context
   private final Map<Class<?>, Set<String>> fieldNamesPerClass = new ConcurrentHashMap<>();
@@ -38,7 +37,7 @@ public class LegacyRecursiveComparisonIntrospectionStrategy implements Recursive
     if (node == null) return new HashSet<>();
     // Caches the names after getting them for efficiency, a node can be introspected multiple times for example if
     // it belongs to an unordered collection as all actual elements are compared to all expected elements.
-    return fieldNamesPerClass.computeIfAbsent(node.getClass(), Objects::getFieldsNames);
+    return fieldNamesPerClass.computeIfAbsent(node.getClass(), this::getFieldsNames);
   }
 
   @Override
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 08173bd12..a2f68a311 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -121,6 +121,9 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     this.fieldMessages = builder.fieldMessages;
     this.typeMessages = builder.typeMessages;
     this.introspectionStrategy = builder.introspectionStrategy;
+    if (builder.ignoreTransientFields) {
+      this.introspectionStrategy.ignoreTransientFields();
+    }
     this.representation = builder.representation != null ? builder.representation : STANDARD_REPRESENTATION;
     this.treatNullAndEmptyIterablesAsEqual = builder.treatNullAndEmptyIterablesAsEqual;
   }
@@ -194,6 +197,20 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return ignoreNonExistentComparedFields;
   }
 
+  public boolean getIgnoreTransientFields() {
+    return introspectionStrategy.shouldIgnoreTransientFields();
+  }
+
+  /**
+   * Makes the recursive comparison to ignore <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Concepts.doc.html#18858">transient</a> fields.
+   * <p>
+   *
+   * See {@link RecursiveComparisonAssert#ignoringTransientFields()} for examples.
+   */
+  public void ignoreTransientFields() {
+    introspectionStrategy.ignoreTransientFields();
+  }
+
   public boolean getIgnoreAllOverriddenEquals() {
     return ignoreAllOverriddenEquals;
   }
@@ -676,7 +693,6 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   public int hashCode() {
     return java.util.Objects.hash(fieldComparators, ignoreAllActualEmptyOptionalFields, ignoreAllActualNullFields,
                                   ignoreAllExpectedNullFields, ignoreNonExistentComparedFields, ignoreAllOverriddenEquals,
-                                  ignoreCollectionOrder,
                                   ignoredCollectionOrderInFields, ignoredCollectionOrderInFieldsMatchingRegexes,
                                   getIgnoredFields(), getIgnoredFieldsRegexes(), ignoredOverriddenEqualsForFields,
                                   ignoredOverriddenEqualsForTypes, ignoredOverriddenEqualsForFieldsMatchingRegexes,
@@ -727,6 +743,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     describeIgnoredFields(description);
     describeIgnoredFieldsRegexes(description);
     describeIgnoredTypes(description);
+    describeIgnoreTransientFields(description);
     describeIgnoredTypesRegexes(description);
     describeOverriddenEqualsMethodsUsage(description, representation);
     describeIgnoreArrayOrder(description);
@@ -899,6 +916,11 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
                                                                                                                      describeRegexes(getIgnoredTypesRegexes())));
   }
 
+  private void describeIgnoreTransientFields(StringBuilder description) {
+    if (getIgnoreTransientFields())
+      description.append("- the transient fields were ignored%n".formatted());
+  }
+
   protected void describeIgnoreAllActualNullFields(StringBuilder description) {
     if (ignoreAllActualNullFields) description.append("- all actual null fields were ignored in the comparison%n".formatted());
   }
@@ -1254,6 +1276,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     private boolean ignoreAllActualEmptyOptionalFields;
     private boolean ignoreAllExpectedNullFields;
     private boolean ignoreNonExistentComparedFields;
+    private boolean ignoreTransientFields;
     private FieldLocation[] comparedFields = {};
     private Class<?>[] comparedTypes = {};
     private Class<?>[] ignoredOverriddenEqualsForTypes = {};
@@ -1673,6 +1696,17 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
       return this;
     }
 
+    /**
+     * Makes the recursive comparison to ignore <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Concepts.doc.html#18858">transient</a> fields.
+     * <p>
+     *
+     * See {@link RecursiveComparisonAssert#ignoringTransientFields()} for examples.
+     */
+    public Builder withIgnoredTransientFields() {
+      ignoreTransientFields = true;
+      return this;
+    }
+
     public Builder withTreatingNullAndEmptyIterablesAsEqual() {
       this.treatNullAndEmptyIterablesAsEqual = true;
       return this;
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonIntrospectionStrategy.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonIntrospectionStrategy.java
index 9e1e8049d..b5309c45c 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonIntrospectionStrategy.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonIntrospectionStrategy.java
@@ -15,6 +15,7 @@ package org.assertj.core.api.recursive.comparison;
 import java.util.Set;
 
 import org.assertj.core.annotations.Beta;
+import org.assertj.core.api.RecursiveComparisonAssert;
 
 /**
  * Defines how objects are introspected in the recursive comparison, the main operations it specifies are:
@@ -44,7 +45,7 @@ public interface RecursiveComparisonIntrospectionStrategy {
    * the implementation could consider the child node name to be a key of the map.
    *
    * @param childNodeName the child node identifier
-   * @param object the object to read the child node from
+   * @param object        the object to read the child node from
    * @return the object child node value
    */
   Object getChildNodeValue(String childNodeName, Object object);
@@ -59,4 +60,24 @@ public interface RecursiveComparisonIntrospectionStrategy {
   default String getDescription() {
     return this.getClass().getSimpleName();
   }
+
+  /**
+   * Makes the recursive comparison to ignore <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Concepts.doc.html#18858">transient</a> fields.
+   * <p>
+   * Inherits from {@link AbstractRecursiveComparisonIntrospectionStrategy} to benefit from the default implementation.
+   * <p>
+   * See {@link RecursiveComparisonAssert#ignoringTransientFields()} for examples.
+   */
+  default void ignoreTransientFields() {
+    // do nothing by default
+  }
+
+  /**
+   * Returns whether transient fields are ignored in the recursive comparison, this is false by default.
+   *
+   * @return whether transient fields are ignored in the recursive comparison.
+   */
+  default boolean shouldIgnoreTransientFields() {
+    return false;
+  }
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java
index dd714ed5d..e4fa57d25 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java
@@ -24,6 +24,7 @@ import java.util.HashSet;
 import java.util.Optional;
 import java.util.Set;
 
+import org.assertj.core.api.recursive.comparison.AbstractRecursiveComparisonIntrospectionStrategy;
 import org.assertj.core.api.recursive.comparison.ComparingNormalizedFields;
 import org.assertj.core.api.recursive.comparison.ComparingSnakeOrCamelCaseFields;
 import org.assertj.core.api.recursive.comparison.ComparisonDifference;
@@ -89,7 +90,7 @@ class RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test extends
     compareRecursivelyFailsWithDifferences(actual, expected, neighbourDateOfBirthDifference, phoneDifference);
   }
 
-  static class ComparingFieldsNameContaining_o implements RecursiveComparisonIntrospectionStrategy {
+  static class ComparingFieldsNameContaining_o extends AbstractRecursiveComparisonIntrospectionStrategy {
 
     @Override
     public Set<String> getChildrenNodeNamesOf(Object node) {
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
index 3a0324dda..ea3f294e6 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
@@ -165,6 +165,14 @@ class RecursiveComparisonConfiguration_builder_Test {
                                                  .containsExactly(values);
   }
 
+  @Test
+  void should_set_ignoreTransientFields() {
+    // WHEN
+    RecursiveComparisonConfiguration configuration = configBuilder().withIgnoredTransientFields().build();
+    // THEN
+    then(configuration.getIgnoreTransientFields()).isTrue();
+  }
+
   @Test
   void should_set_ignoredOverriddenEqualsForFields() {
     // GIVEN
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index e9f684fda..f3c3aa51c 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -342,6 +342,16 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     then(multiLineDescription).contains("- null and empty iterables were considered equal%n".formatted());
   }
 
+  @Test
+  void should_show_when_ignoreTransientFields_is_enabled() {
+    // GIVEN
+    recursiveComparisonConfiguration.ignoreTransientFields();
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    then(multiLineDescription).contains("- the transient fields were ignored%n".formatted());
+  }
+
   @Test
   void should_show_a_complete_multiline_description() {
     // GIVEN
@@ -354,6 +364,7 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     recursiveComparisonConfiguration.ignoreFields("foo", "bar", "foo.bar");
     recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("f.*", ".ba.", "..b%sr..");
     recursiveComparisonConfiguration.ignoreFieldsOfTypes(UUID.class, ZonedDateTime.class);
+    recursiveComparisonConfiguration.ignoreTransientFields();
     recursiveComparisonConfiguration.useOverriddenEquals();
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFieldsMatchingRegexes(".*oo", ".ar", "oo.ba");
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForTypes(String.class, Multimap.class);
@@ -382,6 +393,7 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
                "- the following fields were ignored in the comparison: foo, bar, foo.bar%n" +
                "- the fields matching the following regexes were ignored in the comparison: f.*, .ba., ..b%%sr..%n"+
                "- the following types were ignored in the comparison: java.util.UUID, java.time.ZonedDateTime%n" +
+               "- the transient fields were ignored%n" +
                "- equals methods were used in the comparison except for:%n" +
                "  - the following fields: foo, baz, foo.baz%n" +
                "  - the following types: java.lang.String, com.google.common.collect.Multimap%n" +
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/ComparingSnakeOrCamelCaseFieldsRecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/ComparingSnakeOrCamelCaseFieldsRecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java
new file mode 100644
index 000000000..fb5649cea
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/ComparingSnakeOrCamelCaseFieldsRecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.fields;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.ComparisonDifference;
+import org.assertj.tests.core.api.recursive.data.WithObject;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@SuppressWarnings("unused")
+class ComparingSnakeOrCamelCaseFieldsRecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test
+    extends WithComparingSnakeOrCamelCaseFieldsIntrospectionStrategyBaseTest {
+
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
+  @MethodSource
+  void should_pass_when_actual_transient_fields_are_ignored(Object actual, Object expected, String testDescription) {
+    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                      .ignoringTransientFields()
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> should_pass_when_actual_transient_fields_are_ignored() {
+    var actual1 = new WithTransientFields("Jack transient", "Jack");
+    var expected1 = new WithTransientFields("John transient", "Jack");
+    var actual2 = new WithObject(new WithTransientFields("Jack transient", "Jack"));
+    var expected2 = new WithObject(new WithTransientFields("John transient", "Jack"));
+
+    return Stream.of(arguments(actual1, expected1, "same data, except for transient fields"),
+                     arguments(actual1, expected1, "same data, except for nested transient fields"));
+  }
+
+  @Test
+  void should_fail_when_actual_differs_from_expected_even_when_all_transient_fields_are_ignored() {
+    // GIVEN
+    var actual = new WithTransientFields("Jack transient", "Jack");
+    var expected = new WithTransientFields("John transient", "Jeff");
+    recursiveComparisonConfiguration.ignoreTransientFields();
+    // WHEN/THEN
+    ComparisonDifference comparisonDifference = javaTypeDiff("name", "Jack", "Jeff");
+    compareRecursivelyFailsWithDifferences(actual, expected, comparisonDifference);
+  }
+
+  @SuppressWarnings("ClassCanBeRecord")
+  static class WithTransientFields {
+    final transient String transientName;
+    final String name;
+
+    WithTransientFields(String transientName, String name) {
+      this.transientName = transientName;
+      this.name = name;
+    }
+  }
+
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java
new file mode 100644
index 000000000..ce6331090
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.fields;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.ComparisonDifference;
+import org.assertj.tests.core.api.recursive.data.WithObject;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@SuppressWarnings("unused")
+class RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test extends WithComparingFieldsIntrospectionStrategyBaseTest {
+
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
+  @MethodSource
+  void should_pass_when_actual_transient_fields_are_ignored(Object actual, Object expected, String testDescription) {
+    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                      .ignoringTransientFields()
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> should_pass_when_actual_transient_fields_are_ignored() {
+    var actual1 = new WithTransientFields("Jack transient", "Jack");
+    var expected1 = new WithTransientFields("John transient", "Jack");
+    var actual2 = new WithObject(new WithTransientFields("Jack transient", "Jack"));
+    var expected2 = new WithObject(new WithTransientFields("John transient", "Jack"));
+
+    return Stream.of(arguments(actual1, expected1, "same data, except for transient fields"),
+                     arguments(actual1, expected1, "same data, except for nested transient fields"));
+  }
+
+  @Test
+  void should_fail_when_actual_differs_from_expected_even_when_all_transient_fields_are_ignored() {
+    // GIVEN
+    var actual = new WithTransientFields("Jack transient", "Jack");
+    var expected = new WithTransientFields("John transient", "Jeff");
+    recursiveComparisonConfiguration.ignoreTransientFields();
+    // WHEN/THEN
+    ComparisonDifference comparisonDifference = javaTypeDiff("name", "Jack", "Jeff");
+    compareRecursivelyFailsWithDifferences(actual, expected, comparisonDifference);
+  }
+
+  @SuppressWarnings("ClassCanBeRecord")
+  static class WithTransientFields {
+    final transient String transientName;
+    final String name;
+
+    WithTransientFields(String transientName, String name) {
+      this.transientName = transientName;
+      this.name = name;
+    }
+  }
+
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/WithComparingSnakeOrCamelCaseFieldsIntrospectionStrategyBaseTest.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/WithComparingSnakeOrCamelCaseFieldsIntrospectionStrategyBaseTest.java
new file mode 100644
index 000000000..9f9acbb6b
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/WithComparingSnakeOrCamelCaseFieldsIntrospectionStrategyBaseTest.java
@@ -0,0 +1,26 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.fields;
+
+import org.assertj.core.api.recursive.comparison.ComparingSnakeOrCamelCaseFields;
+import org.assertj.tests.core.api.recursive.comparison.RecursiveComparisonAssert_BaseTest;
+import org.junit.jupiter.api.BeforeEach;
+
+class WithComparingSnakeOrCamelCaseFieldsIntrospectionStrategyBaseTest extends RecursiveComparisonAssert_BaseTest {
+
+  @BeforeEach
+  public void beforeEachTest() {
+    super.beforeEachTest();
+    recursiveComparisonConfiguration.setIntrospectionStrategy(new ComparingSnakeOrCamelCaseFields());
+  }
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java
new file mode 100644
index 000000000..97b32f435
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.legacy;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.ComparisonDifference;
+import org.assertj.tests.core.api.recursive.data.WithObject;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@SuppressWarnings("unused")
+class RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test extends WithLegacyIntrospectionStrategyBaseTest {
+
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
+  @MethodSource
+  void should_pass_when_actual_transient_fields_are_ignored(Object actual, Object expected, String testDescription) {
+    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                      .ignoringTransientFields()
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> should_pass_when_actual_transient_fields_are_ignored() {
+    var actual1 = new WithTransientFields("Jack transient", "Jack");
+    var expected1 = new WithTransientFields("John transient", "Jack");
+    var actual2 = new WithObject(new WithTransientFields("Jack transient", "Jack"));
+    var expected2 = new WithObject(new WithTransientFields("John transient", "Jack"));
+
+    return Stream.of(arguments(actual1, expected1, "same data, except for transient fields"),
+                     arguments(actual1, expected1, "same data, except for nested transient fields"));
+  }
+
+  @Test
+  void should_fail_when_actual_differs_from_expected_even_when_all_transient_fields_are_ignored() {
+    // GIVEN
+    var actual = new WithTransientFields("Jack transient", "Jack");
+    var expected = new WithTransientFields("John transient", "Jeff");
+    recursiveComparisonConfiguration.ignoreTransientFields();
+    // WHEN/THEN
+    ComparisonDifference comparisonDifference = javaTypeDiff("name", "Jack", "Jeff");
+    compareRecursivelyFailsWithDifferences(actual, expected, comparisonDifference);
+  }
+
+  @SuppressWarnings("ClassCanBeRecord")
+  static class WithTransientFields {
+    final transient String transientName;
+    final String name;
+
+    WithTransientFields(String transientName, String name) {
+      this.transientName = transientName;
+      this.name = name;
+    }
+  }
+
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/properties/RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/properties/RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java
new file mode 100644
index 000000000..42b74a2c2
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/properties/RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.properties;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+
+import org.junit.jupiter.api.Test;
+
+@SuppressWarnings("unused")
+class RecursiveComparisonAssert_isEqualTo_ignoringTransientFields_Test
+    extends WithComparingPropertiesIntrospectionStrategyBaseTest {
+
+  @Test
+  void should_fail_since_ignoringTransientFields_does_not_make_sense_for_properties() {
+    // GIVEN
+    var actual = new WithTransientFields("Jack transient", "Jack");
+    var expected = new WithTransientFields("John transient", "Jeff");
+    // WHEN
+    var illegalArgumentException = catchIllegalArgumentException(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                                                                                         .ignoringTransientFields()
+                                                                                         .isEqualTo(expected));
+    // THEN
+    then(illegalArgumentException).hasMessage("ignoringTransientFields is not supported since we are comparing properties");
+  }
+
+  @SuppressWarnings("ClassCanBeRecord")
+  static class WithTransientFields {
+    final transient String transientName;
+    final String name;
+
+    WithTransientFields(String transientName, String name) {
+      this.transientName = transientName;
+      this.name = name;
+    }
+  }
+
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/properties/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/properties/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java
index 1e44c6c43..2107441bd 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/properties/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/properties/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java
@@ -23,6 +23,7 @@ import java.util.HashSet;
 import java.util.Optional;
 import java.util.Set;
 
+import org.assertj.core.api.recursive.comparison.AbstractRecursiveComparisonIntrospectionStrategy;
 import org.assertj.core.api.recursive.comparison.ComparisonDifference;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonIntrospectionStrategy;
 import org.assertj.core.internal.Objects;
@@ -89,7 +90,7 @@ class RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test
     compareRecursivelyFailsWithDifferences(actual, expected, neighbourDateOfBirthDifference, phoneDifference);
   }
 
-  static class ComparingFieldsNameContaining_o implements RecursiveComparisonIntrospectionStrategy {
+  static class ComparingFieldsNameContaining_o extends AbstractRecursiveComparisonIntrospectionStrategy {
 
     @Override
     public Set<String> getChildrenNodeNamesOf(Object node) {
