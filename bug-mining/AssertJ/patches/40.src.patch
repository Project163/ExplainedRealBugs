diff --git a/src/main/java/org/assertj/core/internal/Arrays.java b/src/main/java/org/assertj/core/internal/Arrays.java
index 9636246e7..2900e2003 100644
--- a/src/main/java/org/assertj/core/internal/Arrays.java
+++ b/src/main/java/org/assertj/core/internal/Arrays.java
@@ -15,7 +15,6 @@
 package org.assertj.core.internal;
 
 import static java.lang.reflect.Array.getLength;
-
 import static org.assertj.core.error.ConditionAndGroupGenericParameterTypeShouldBeTheSame.shouldBeSameGenericBetweenIterableAndCondition;
 import static org.assertj.core.error.ElementsShouldBe.elementsShouldBe;
 import static org.assertj.core.error.ElementsShouldBeAtLeast.elementsShouldBeAtLeast;
@@ -56,7 +55,7 @@ import static org.assertj.core.internal.CommonValidations.hasSameSizeAsCheck;
 import static org.assertj.core.util.ArrayWrapperList.wrap;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.Iterables.isNullOrEmpty;
-import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Lists.*;
 
 import java.lang.reflect.Array;
 import java.util.ArrayList;
@@ -190,13 +189,15 @@ class Arrays {
 
   void assertNotEmpty(AssertionInfo info, Failures failures, Object array) {
     assertNotNull(info, array);
-    if (isArrayEmpty(array)) throw failures.failure(info, shouldNotBeEmpty());
+    if (isArrayEmpty(array))
+      throw failures.failure(info, shouldNotBeEmpty());
   }
 
   void assertDoesNotContain(AssertionInfo info, Failures failures, Object array, Object value, Index index) {
     assertNotNull(info, array);
     checkIndexValueIsValid(index, Integer.MAX_VALUE);
-    if (index.value >= sizeOf(array)) return;
+    if (index.value >= sizeOf(array))
+      return;
     if (areEqual(Array.get(array, index.value), value))
       throw failures.failure(info, shouldNotContainAtIndex(array, value, index, comparisonStrategy));
   }
@@ -206,38 +207,34 @@ class Arrays {
       return;
     Set<Object> notExpected = asSetWithoutDuplicatesAccordingToComparisonStrategy(actual);
     Set<Object> notFound = containsOnly(notExpected, values);
-    if (notExpected.isEmpty() && notFound.isEmpty()) {
+    if (notExpected.isEmpty() && notFound.isEmpty())
       return;
-    }
     throw failures.failure(info, shouldContainOnly(actual, values, notFound, notExpected, comparisonStrategy));
   }
 
   void assertContainsOnlyOnce(AssertionInfo info, Failures failures, Object actual, Object values) {
     if (commonChecks(info, actual, values))
       return;
-    Set<?> expected = asTreeSetWithoutDuplicatesAccordingToComparisonStrategy(asList(values));
-    List<Object> actualList = asList(actual);
-    Set<?> actualSet = asTreeSetWithoutDuplicatesAccordingToComparisonStrategy(actualList);
-    Iterable<?> duplicates = comparisonStrategy.duplicatesFrom(actualList);
+    Iterable<?> actualDuplicates = comparisonStrategy.duplicatesFrom(asList(actual));
     Set<Object> notFound = new LinkedHashSet<Object>();
     Set<Object> notOnlyOnce = new LinkedHashSet<Object>();
-    for (Object element : expected) {
-      if (!actualSet.contains(element)) {
-        notFound.add(element);
-      } else if (collectionContains(duplicates, element)) {
-        notOnlyOnce.add(element);
+    for (Object expectedElement : asList(values)) {
+      if (!arrayContains(actual, expectedElement)) {
+        notFound.add(expectedElement);
+      } else if (iterableContains(actualDuplicates, expectedElement)) {
+        notOnlyOnce.add(expectedElement);
       }
     }
-    if (notFound.isEmpty() && notOnlyOnce.isEmpty()) {
-      return;
+    if (!notFound.isEmpty() || !notOnlyOnce.isEmpty()) {
+      throw failures.failure(info, shouldContainsOnlyOnce(actual, values, notFound, notOnlyOnce, comparisonStrategy));
     }
-    throw failures.failure(info, shouldContainsOnlyOnce(actual, values, notFound, notOnlyOnce, comparisonStrategy));
+    // assertion succeeded
   }
 
   private Set<Object> containsOnly(Set<Object> actual, Object values) {
     Set<Object> notFound = new LinkedHashSet<Object>();
     for (Object o : asSetWithoutDuplicatesAccordingToComparisonStrategy(values)) {
-      if (collectionContains(actual, o)) {
+      if (iterableContains(actual, o)) {
         collectionRemoves(actual, o);
       } else {
         notFound.add(o);
@@ -257,50 +254,17 @@ class Arrays {
     int size = sizeOf(array);
     for (int i = 0; i < size; i++) {
       Object element = Array.get(array, i);
-      if (!collectionContains(set, element)) {
+      if (!iterableContains(set, element)) {
         set.add(element);
       }
     }
     return set;
   }
 
-  /**
-   * build a TreeSet with that avoid duplicates <b>according to given comparison strategy</b>
-   * 
-   * @param iterable to feed the Set we want to build
-   * @return a Set without duplicates <b>according to given comparison strategy</b> and with {@code .contains} who use
-   *         the given comparison strategy.
-   */
-  private Set<Object> asTreeSetWithoutDuplicatesAccordingToComparisonStrategy(Iterable<Object> iterable) {
-    Set<Object> set = new TreeSet<Object>(getComparatorFromComparisonStrategy());
-    for (Object element : iterable) {
-      set.add(element);
-    }
-    return set;
-  }
-
-  private Comparator<Object> getComparatorFromComparisonStrategy() {
-    @SuppressWarnings("unchecked")
-    Comparator<Object> comparator = (Comparator<Object>) getComparator();
-    if (comparator == null) {
-      comparator = new Comparator<Object>() {
-        @Override
-        public int compare(Object o1, Object o2) {
-          if (comparisonStrategy.areEqual(o1, o2))
-            return 0;
-          if (comparisonStrategy.isGreaterThan(o1, o2))
-            return 1;
-          return -1;
-        }
-      };
-    }
-    return comparator;
-  }
-
   /**
    * Delegates to {@link ComparisonStrategy#iterableContains(Iterable, Object)}
    */
-  private boolean collectionContains(Iterable<?> actual, Object value) {
+  private boolean iterableContains(Iterable<?> actual, Object value) {
     return comparisonStrategy.iterableContains(actual, value);
   }
 
@@ -367,7 +331,6 @@ class Arrays {
     }
   }
 
-
   /**
    * Delegates to {@link ComparisonStrategy#areEqual(Object, Object)}
    */
@@ -409,7 +372,8 @@ class Arrays {
   }
 
   void assertStartsWith(AssertionInfo info, Failures failures, Object actual, Object sequence) {
-    if (commonChecks(info, actual, sequence)) return;
+    if (commonChecks(info, actual, sequence))
+      return;
     int sequenceSize = sizeOf(sequence);
     int arraySize = sizeOf(actual);
     if (arraySize < sequenceSize) {
@@ -437,10 +401,12 @@ class Arrays {
   }
 
   void assertEndsWith(AssertionInfo info, Failures failures, Object actual, Object sequence) {
-    if (commonChecks(info, actual, sequence)) return;
+    if (commonChecks(info, actual, sequence))
+      return;
     int sequenceSize = sizeOf(sequence);
     int arraySize = sizeOf(actual);
-    if (arraySize < sequenceSize) throw arrayDoesNotEndWithSequence(info, failures, actual, sequence);
+    if (arraySize < sequenceSize)
+      throw arrayDoesNotEndWithSequence(info, failures, actual, sequence);
     for (int i = 0; i < sequenceSize; i++) {
       int sequenceIndex = sequenceSize - (i + 1);
       int arrayIndex = arraySize - (i + 1);
@@ -458,7 +424,8 @@ class Arrays {
 
   void assertDoesNotContainNull(AssertionInfo info, Failures failures, Object array) {
     assertNotNull(info, array);
-    if (arrayContains(array, null)) throw failures.failure(info, shouldNotContainNull(array));
+    if (arrayContains(array, null))
+      throw failures.failure(info, shouldNotContainNull(array));
   }
 
   public <E> void assertAre(AssertionInfo info, Failures failures, Conditions conditions, Object array,
@@ -615,7 +582,8 @@ class Arrays {
     int arraySize = sizeOf(array);
     for (int i = 0; i < arraySize; i++) {
       Object o = Array.get(array, i);
-      if (!condition.matches((E) o)) elementsNotSatisfyingCondition.add((E) o);
+      if (!condition.matches((E) o))
+        elementsNotSatisfyingCondition.add((E) o);
     }
     return elementsNotSatisfyingCondition;
   }
@@ -626,7 +594,8 @@ class Arrays {
     int arraySize = sizeOf(array);
     for (int i = 0; i < arraySize; i++) {
       Object o = Array.get(array, i);
-      if (condition.matches((E) o)) elementsSatisfyingCondition.add((E) o);
+      if (condition.matches((E) o))
+        elementsSatisfyingCondition.add((E) o);
     }
     return elementsSatisfyingCondition;
   }
@@ -640,14 +609,16 @@ class Arrays {
       return;
     }
     // empty arrays are considered sorted even if component type is not sortable.
-    if (sizeOf(array) == 0) return;
+    if (sizeOf(array) == 0)
+      return;
     assertThatArrayComponentTypeIsSortable(info, failures, array);
     try {
       // sorted assertion is only relevant if array elements are Comparable
       // => we should be able to build a Comparable array
       Comparable<Object>[] comparableArray = arrayOfComparableItems(array);
       // array with 0 or 1 element are considered sorted.
-      if (comparableArray.length <= 1) return;
+      if (comparableArray.length <= 1)
+        return;
       for (int i = 0; i < comparableArray.length - 1; i++) {
         // array is sorted in ascending order iif element i is less or equal than element i+1
         if (comparableArray[i].compareTo(comparableArray[i + 1]) > 0)
@@ -663,11 +634,13 @@ class Arrays {
   static <T> void assertIsSortedAccordingToComparator(AssertionInfo info, Failures failures, Object array,
       Comparator<T> comparator) {
     assertNotNull(info, array);
-    if (comparator == null) throw new NullPointerException("The given comparator should not be null");
+    if (comparator == null)
+      throw new NullPointerException("The given comparator should not be null");
     try {
       List<T> arrayAsList = asList(array);
       // empty arrays are considered sorted even if comparator can't be applied to <T>.
-      if (arrayAsList.size() == 0) return;
+      if (arrayAsList.size() == 0)
+        return;
       if (arrayAsList.size() == 1) {
         // call compare to see if unique element is compatible with comparator.
         comparator.compare(arrayAsList.get(0), arrayAsList.get(0));
@@ -685,8 +658,10 @@ class Arrays {
 
   @SuppressWarnings("unchecked")
   private static <T> List<T> asList(Object array) {
-    if (array == null) return null;
-    if (!isArray(array)) throw new IllegalArgumentException("The object should be an array");
+    if (array == null)
+      return null;
+    if (!isArray(array))
+      throw new IllegalArgumentException("The object should be an array");
     int length = getLength(array);
     List<T> list = new ArrayList<T>(length);
     for (int i = 0; i < length; i++) {
@@ -708,7 +683,8 @@ class Arrays {
   private static void assertThatArrayComponentTypeIsSortable(AssertionInfo info, Failures failures, Object array) {
     ArrayWrapperList arrayAsList = wrap(array);
     Class<?> arrayComponentType = arrayAsList.getComponentType();
-    if (arrayComponentType.isPrimitive()) return;
+    if (arrayComponentType.isPrimitive())
+      return;
     if (!Comparable.class.isAssignableFrom(arrayComponentType))
       throw failures.failure(info, shouldHaveMutuallyComparableElements(array));
   }
@@ -716,14 +692,16 @@ class Arrays {
   // TODO manage empty values + empty actual
   private static void checkIsNotNullAndNotEmpty(Object values) {
     checkIsNotNull(values);
-    if (isArrayEmpty(values)) throw arrayOfValuesToLookForIsEmpty();
+    if (isArrayEmpty(values))
+      throw arrayOfValuesToLookForIsEmpty();
   }
 
   /**
    * @param values
    */
   private static void checkIsNotNull(Object values) {
-    if (values == null) throw arrayOfValuesToLookForIsNull();
+    if (values == null)
+      throw arrayOfValuesToLookForIsNull();
   }
 
   private static boolean isArrayEmpty(Object array) {
diff --git a/src/main/java/org/assertj/core/internal/Iterables.java b/src/main/java/org/assertj/core/internal/Iterables.java
index 1a2565a45..41e17f951 100644
--- a/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/src/main/java/org/assertj/core/internal/Iterables.java
@@ -48,9 +48,8 @@ import static org.assertj.core.internal.CommonValidations.failIfEmptySinceActual
 import static org.assertj.core.internal.CommonValidations.hasSameSizeAsCheck;
 import static org.assertj.core.util.Iterables.isNullOrEmpty;
 import static org.assertj.core.util.Iterables.sizeOf;
-import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Lists.*;
 
-import java.util.Arrays;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -58,7 +57,6 @@ import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
-import java.util.TreeSet;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.api.Condition;
@@ -76,6 +74,11 @@ import org.assertj.core.util.VisibleForTesting;
 public class Iterables {
 
   private static final Iterables INSTANCE = new Iterables();
+  private final ComparisonStrategy comparisonStrategy;
+  @VisibleForTesting
+  Failures failures = Failures.instance();
+  @VisibleForTesting
+  Conditions conditions = Conditions.instance();
 
   /**
    * Returns the singleton instance of this class based on {@link StandardComparisonStrategy}.
@@ -86,14 +89,6 @@ public class Iterables {
     return INSTANCE;
   }
 
-  private final ComparisonStrategy comparisonStrategy;
-
-  @VisibleForTesting
-  Failures failures = Failures.instance();
-
-  @VisibleForTesting
-  Conditions conditions = Conditions.instance();
-
   @VisibleForTesting
   Iterables() {
     this(StandardComparisonStrategy.instance());
@@ -213,12 +208,14 @@ public class Iterables {
    * @throws AssertionError if the given {@code Iterable} does not contain the given values.
    */
   public void assertContains(AssertionInfo info, Iterable<?> actual, Object[] values) {
-    if (commonCheckThatIterableAssertionSucceeds(info, actual, values)) return;
+    if (commonCheckThatIterableAssertionSucceeds(info, actual, values))
+      return;
     // check for elements in values that are missing in actual.
     assertIterableContainsGivenValues(actual, values, info);
   }
 
-  private void assertIterableContainsGivenValues(Iterable<?> actual, Object[] values, AssertionInfo info) {Set<Object> notFound = new LinkedHashSet<Object>();
+  private void assertIterableContainsGivenValues(Iterable<?> actual, Object[] values, AssertionInfo info) {
+    Set<Object> notFound = new LinkedHashSet<Object>();
     for (Object value : values) {
       if (!iterableContains(actual, value)) {
         notFound.add(value);
@@ -256,7 +253,8 @@ public class Iterables {
    *           {@code Iterable} contains values that are not in the given array.
    */
   public void assertContainsOnly(AssertionInfo info, Iterable<?> actual, Object[] values) {
-    if (commonCheckThatIterableAssertionSucceeds(info, actual, values)) return;
+    if (commonCheckThatIterableAssertionSucceeds(info, actual, values))
+      return;
     // check for elements in values that are missing in actual.
     Set<Object> notExpected = setFromIterable(actual);
     Set<Object> notFound = containsOnly(notExpected, values);
@@ -331,7 +329,8 @@ public class Iterables {
    *           {@code Iterable} contains values that are not in the given array.
    */
   public void assertContainsOnlyOnce(AssertionInfo info, Iterable<?> actual, Object[] values) {
-    if (commonCheckThatIterableAssertionSucceeds(info, actual, values)) return;
+    if (commonCheckThatIterableAssertionSucceeds(info, actual, values))
+      return;
     // check for elements in values that are missing in actual.
     Set<Object> notFound = new LinkedHashSet<Object>();
     Set<Object> notOnlyOnce = new LinkedHashSet<Object>();
@@ -343,10 +342,10 @@ public class Iterables {
         notOnlyOnce.add(expectedOnlyOnce);
       }
     }
-    if (notFound.isEmpty() && notOnlyOnce.isEmpty()) {
-      return;
+    if (!notFound.isEmpty() || !notOnlyOnce.isEmpty()) {
+      throw failures.failure(info, shouldContainsOnlyOnce(actual, values, notFound, notOnlyOnce, comparisonStrategy));
     }
-    throw failures.failure(info, shouldContainsOnlyOnce(actual, values, notFound, notOnlyOnce, comparisonStrategy));
+    // assertion succeeded
   }
 
   /**
@@ -362,7 +361,8 @@ public class Iterables {
    * @throws AssertionError if the given {@code Iterable} does not contain the given sequence of objects.
    */
   public void assertContainsSequence(AssertionInfo info, Iterable<?> actual, Object[] sequence) {
-    if (commonCheckThatIterableAssertionSucceeds(info, actual, sequence)) return;
+    if (commonCheckThatIterableAssertionSucceeds(info, actual, sequence))
+      return;
     // check for elements in values that are missing in actual.
     List<?> actualAsList = newArrayList(actual);
     for (int i = 0; i < actualAsList.size(); i++) {
@@ -556,11 +556,14 @@ public class Iterables {
    * @throws AssertionError if the given {@code Iterable} does not start with the given sequence of objects.
    */
   public void assertStartsWith(AssertionInfo info, Iterable<?> actual, Object[] sequence) {
-    if (commonCheckThatIterableAssertionSucceeds(info, actual, sequence)) return;
+    if (commonCheckThatIterableAssertionSucceeds(info, actual, sequence))
+      return;
     int i = 0;
     for (Object actualCurrentElement : actual) {
-      if (i >= sequence.length) break;
-      if (areEqual(actualCurrentElement, sequence[i++])) continue;
+      if (i >= sequence.length)
+        break;
+      if (areEqual(actualCurrentElement, sequence[i++]))
+        continue;
       throw actualDoesNotStartWithSequence(info, actual, sequence);
     }
     if (sequence.length > i) {
@@ -587,7 +590,8 @@ public class Iterables {
    * @throws AssertionError if the given {@code Iterable} does not end with the given sequence of objects.
    */
   public void assertEndsWith(AssertionInfo info, Iterable<?> actual, Object[] sequence) {
-    if (commonCheckThatIterableAssertionSucceeds(info, actual, sequence)) return;
+    if (commonCheckThatIterableAssertionSucceeds(info, actual, sequence))
+      return;
     int sizeOfActual = sizeOf(actual);
     if (sizeOfActual < sequence.length) {
       throw actualDoesNotEndWithSequence(info, actual, sequence);
@@ -595,8 +599,10 @@ public class Iterables {
     int start = sizeOfActual - sequence.length;
     int sequenceIndex = 0, indexOfActual = 0;
     for (Object actualElement : actual) {
-      if (indexOfActual++ < start) continue;
-      if (areEqual(actualElement, sequence[sequenceIndex++])) continue;
+      if (indexOfActual++ < start)
+        continue;
+      if (areEqual(actualElement, sequence[sequenceIndex++]))
+        continue;
       throw actualDoesNotEndWithSequence(info, actual, sequence);
     }
   }
@@ -605,7 +611,8 @@ public class Iterables {
     checkIsNotNull(sequence);
     assertNotNull(info, actual);
     // if both actual and values are empty, then assertion passes.
-    if (!actual.iterator().hasNext() && sequence.length == 0) return true;
+    if (!actual.iterator().hasNext() && sequence.length == 0)
+      return true;
     failIfEmptySinceActualIsNotEmpty(sequence);
     return false;
   }
@@ -753,14 +760,17 @@ public class Iterables {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
-      if (conditionIsSatisfiedAtLeastNTimes(actual, times, condition)) return;
+      if (conditionIsSatisfiedAtLeastNTimes(actual, times, condition))
+        return;
       throw failures.failure(info, elementsShouldBeAtLeast(actual, times, condition));
     } catch (ClassCastException e) {
       throw failures.failure(info, shouldBeSameGenericBetweenIterableAndCondition(actual, condition));
     }
   }
 
-  private <E> boolean conditionIsSatisfiedAtLeastNTimes(Iterable<? extends E> actual, int n, Condition<? super E> condition) {List<E> satisfiesCondition = satisfiesCondition(actual, condition);
+  private <E> boolean conditionIsSatisfiedAtLeastNTimes(Iterable<? extends E> actual, int n,
+      Condition<? super E> condition) {
+    List<E> satisfiesCondition = satisfiesCondition(actual, condition);
     if (satisfiesCondition.size() >= n) {
       return true;
     }
@@ -784,14 +794,17 @@ public class Iterables {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
-      if (conditionIsSatisfiedAtMostNTimes(actual, condition, n)) return;
+      if (conditionIsSatisfiedAtMostNTimes(actual, condition, n))
+        return;
       throw failures.failure(info, elementsShouldBeAtMost(actual, n, condition));
     } catch (ClassCastException e) {
       throw failures.failure(info, shouldBeSameGenericBetweenIterableAndCondition(actual, condition));
     }
   }
 
-  private <E> boolean conditionIsSatisfiedAtMostNTimes(Iterable<? extends E> actual, Condition<? super E> condition, int n) {List<E> satisfiesCondition = satisfiesCondition(actual, condition);
+  private <E> boolean conditionIsSatisfiedAtMostNTimes(Iterable<? extends E> actual, Condition<? super E> condition,
+      int n) {
+    List<E> satisfiesCondition = satisfiesCondition(actual, condition);
     return satisfiesCondition.size() <= n;
   }
 
@@ -812,14 +825,16 @@ public class Iterables {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
-      if (conditionIsSatisfiedNTimes(actual, condition, times)) return;
+      if (conditionIsSatisfiedNTimes(actual, condition, times))
+        return;
       throw failures.failure(info, elementsShouldBeExactly(actual, times, condition));
     } catch (ClassCastException e) {
       throw failures.failure(info, shouldBeSameGenericBetweenIterableAndCondition(actual, condition));
     }
   }
 
-  private <E> boolean conditionIsSatisfiedNTimes(Iterable<? extends E> actual, Condition<? super E> condition, int times) {List<E> satisfiesCondition = satisfiesCondition(actual, condition);
+  private <E> boolean conditionIsSatisfiedNTimes(Iterable<? extends E> actual, Condition<? super E> condition, int times) {
+    List<E> satisfiesCondition = satisfiesCondition(actual, condition);
     if (satisfiesCondition.size() == times) {
       return true;
     }
@@ -835,7 +850,8 @@ public class Iterables {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
-      if (conditionIsSatisfiedAtLeastNTimes(actual, times, condition)) return;
+      if (conditionIsSatisfiedAtLeastNTimes(actual, times, condition))
+        return;
       throw failures.failure(info, elementsShouldHaveAtLeast(actual, times, condition));
     } catch (ClassCastException e) {
       throw failures.failure(info, shouldBeSameGenericBetweenIterableAndCondition(actual, condition));
@@ -851,7 +867,8 @@ public class Iterables {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
-      if (conditionIsSatisfiedAtMostNTimes(actual, condition, times)) return;
+      if (conditionIsSatisfiedAtMostNTimes(actual, condition, times))
+        return;
       throw failures.failure(info, elementsShouldHaveAtMost(actual, times, condition));
     } catch (ClassCastException e) {
       throw failures.failure(info, shouldBeSameGenericBetweenIterableAndCondition(actual, condition));
@@ -867,7 +884,8 @@ public class Iterables {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
-      if (conditionIsSatisfiedNTimes(actual, condition, times)) return;
+      if (conditionIsSatisfiedNTimes(actual, condition, times))
+        return;
       throw failures.failure(info, elementsShouldHaveExactly(actual, times, condition));
     } catch (ClassCastException e) {
       throw failures.failure(info, shouldBeSameGenericBetweenIterableAndCondition(actual, condition));
diff --git a/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsOnlyOnce_Test.java b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsOnlyOnce_Test.java
index 2ea73ae0c..ff37e9bd6 100644
--- a/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsOnlyOnce_Test.java
+++ b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsOnlyOnce_Test.java
@@ -21,6 +21,7 @@ import static org.assertj.core.test.ObjectArrays.emptyArray;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
 import static org.mockito.Mockito.verify;
 
@@ -29,6 +30,8 @@ import org.assertj.core.internal.ObjectArrays;
 import org.assertj.core.internal.ObjectArraysBaseTest;
 import org.junit.Test;
 
+import java.awt.Rectangle;
+
 /**
  * Tests for <code>{@link ObjectArrays#assertContainsOnlyOnce(AssertionInfo, Object[], Object[])}</code>.
  * 
@@ -37,17 +40,25 @@ import org.junit.Test;
 public class ObjectArrays_assertContainsOnlyOnce_Test extends ObjectArraysBaseTest {
 
   @Test
-  public void should_pass_if_actual_contains_given_values_only() {
+  public void should_pass_if_actual_contains_given_values_only_once() {
     arrays.assertContainsOnlyOnce(someInfo(), actual, array("Luke", "Yoda", "Leia"));
   }
 
+  @Test
+  public void should_pass_if_actual_contains_given_values_only_once_even_if_actual_type_is_not_comparable() {
+    // Rectangle class does not implement Comparable
+    Rectangle r1 = new Rectangle(1, 1);
+    Rectangle r2 = new Rectangle(2, 2);
+    arrays.assertContainsOnlyOnce(someInfo(), array(r1, r2, r2), array(r1));
+  }
+
   @Test
   public void should_pass_if_actual_contains_given_values_only_in_different_order() {
     arrays.assertContainsOnlyOnce(someInfo(), actual, array("Leia", "Yoda", "Luke"));
   }
 
   @Test
-  public void should_fail_if_actual_contains_given_values_only_more_than_once() {
+  public void should_fail_if_actual_contains_given_values_more_than_once() {
     AssertionInfo info = someInfo();
     actual = array("Luke", "Yoda", "Han", "Luke", "Yoda", "Han", "Yoda", "Luke");
     String[] expected = { "Luke", "Yoda", "Leia" };
@@ -62,7 +73,7 @@ public class ObjectArrays_assertContainsOnlyOnce_Test extends ObjectArraysBaseTe
   }
 
   @Test
-  public void should_pass_if_actual_contains_given_values_only_even_if_duplicated() {
+  public void should_pass_if_actual_contains_given_values_only_once_even_if_duplicated() {
     arrays.assertContainsOnlyOnce(someInfo(), actual, array("Luke", "Yoda", "Leia", "Luke", "Yoda", "Leia"));
   }
 
@@ -91,7 +102,7 @@ public class ObjectArrays_assertContainsOnlyOnce_Test extends ObjectArraysBaseTe
   }
 
   @Test
-  public void should_fail_if_actual_does_not_contain_given_values_only() {
+  public void should_fail_if_actual_does_not_contain_all_given_values() {
     AssertionInfo info = someInfo();
     String[] expected = { "Luke", "Yoda", "Han" };
     try {
@@ -115,7 +126,7 @@ public class ObjectArrays_assertContainsOnlyOnce_Test extends ObjectArraysBaseTe
   }
 
   @Test
-  public void should_fail_if_actual_contains_given_values_only_more_than_once_according_to_custom_comparison_strategy() {
+  public void should_fail_if_actual_contains_given_values_more_than_once_according_to_custom_comparison_strategy() {
     AssertionInfo info = someInfo();
     actual = array("Luke", "yODA", "Han", "luke", "yoda", "Han", "YodA");
     String[] expected = { "Luke", "yOda", "Leia" };
@@ -132,7 +143,7 @@ public class ObjectArrays_assertContainsOnlyOnce_Test extends ObjectArraysBaseTe
   }
 
   @Test
-  public void should_pass_if_actual_contains_given_values_only_even_if_duplicated_according_to_custom_comparison_strategy() {
+  public void should_pass_if_actual_contains_given_values_only_once_according_to_custom_comparison_strategy_even_if_duplicated_() {
     arraysWithCustomComparisonStrategy.assertContainsOnlyOnce(someInfo(), actual,
         array("Luke", "Yoda", "Leia", "Luke", "yODA", "LeiA"));
   }
@@ -156,7 +167,7 @@ public class ObjectArrays_assertContainsOnlyOnce_Test extends ObjectArraysBaseTe
   }
 
   @Test
-  public void should_fail_if_actual_does_not_contain_given_values_only_according_to_custom_comparison_strategy() {
+  public void should_fail_if_actual_does_not_contain_all_given_values_only_once_according_to_custom_comparison_strategy() {
     AssertionInfo info = someInfo();
     String[] expected = { "Luke", "yoda", "han" };
     try {
