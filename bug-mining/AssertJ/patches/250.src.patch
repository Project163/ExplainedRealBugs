diff --git a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
index 90e5925de..06c25a21c 100644
--- a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
+++ b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
@@ -18,6 +18,7 @@ import static java.util.Collections.emptyList;
 import static java.util.Collections.unmodifiableList;
 import static org.assertj.core.util.ArrayWrapperList.wrap;
 import static org.assertj.core.util.IterableUtil.isNullOrEmpty;
+import static org.assertj.core.util.introspection.FieldUtils.readField;
 
 import java.lang.reflect.Field;
 import java.util.ArrayList;
@@ -32,6 +33,15 @@ public enum FieldSupport {
 
   EXTRACTION(true), EXTRACTION_OF_PUBLIC_FIELD_ONLY(false), COMPARISON(true);
 
+  private static final String CHAR = "char";
+  private static final String BOOLEAN = "boolean";
+  private static final String DOUBLE = "double";
+  private static final String FLOAT = "float";
+  private static final String LONG = "long";
+  private static final String INT = "int";
+  private static final String SHORT = "short";
+  private static final String BYTE = "byte";
+
   private static final String SEPARATOR = ".";
 
   private boolean allowUsingPrivateFields;
@@ -185,10 +195,39 @@ public enum FieldSupport {
     return readSimpleField(fieldName, fieldClass, target);
   }
 
+  @SuppressWarnings("unchecked")
   private <T> T readSimpleField(String fieldName, Class<T> clazz, Object target) {
     try {
-      Object readField = FieldUtils.readField(target, fieldName, allowUsingPrivateFields);
-      return clazz.cast(readField);
+      Object fieldValue = readField(target, fieldName, allowUsingPrivateFields);
+      if (clazz.isPrimitive()) {
+        switch (clazz.getSimpleName()) {
+        case BYTE:
+          Byte byteValue = (byte) fieldValue;
+          return (T) byteValue;
+        case SHORT:
+          Short shortValue = (short) fieldValue;
+          return (T) shortValue;
+        case INT:
+          Integer intValue = (int) fieldValue;
+          return (T) intValue;
+        case LONG:
+          Long longValue = (long) fieldValue;
+          return (T) longValue;
+        case FLOAT:
+          Float floatValue = (float) fieldValue;
+          return (T) floatValue;
+        case DOUBLE:
+          Double doubleValue = (double) fieldValue;
+          return (T) doubleValue;
+        case BOOLEAN:
+          Boolean booleanValue = (boolean) fieldValue;
+          return (T) booleanValue;
+        case CHAR:
+          Character charValue = (char) fieldValue;
+          return (T) charValue;
+        }
+      }
+      return clazz.cast(fieldValue);
     } catch (ClassCastException e) {
       String msg = format("Unable to obtain the value of the field <'%s'> from <%s> - wrong field type specified <%s>",
                           fieldName, target, clazz);
diff --git a/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
index 1a9f39911..aa5f8c85c 100644
--- a/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
@@ -140,4 +140,29 @@ public class FieldSupport_fieldValues_Test {
     List<Long> fieldValuesFromArray = fieldSupport.fieldValues("id", Long.class, employees.toArray(new Employee[0]));
     assertThat(fieldValuesFromArray).isEqualTo(fieldValuesFromIterable);
   }
+
+  @Test
+  public void should_extract_primitive_field() {
+    SampleObject object = new SampleObject();
+    assertThat(fieldSupport.fieldValue("sampleByte", byte.class, object)).isEqualTo(object.sampleByte);
+    assertThat(fieldSupport.fieldValue("sampleShort", short.class, object)).isEqualTo(object.sampleShort);
+    assertThat(fieldSupport.fieldValue("sampleInt", int.class, object)).isEqualTo(object.sampleInt);
+    assertThat(fieldSupport.fieldValue("sampleLong", long.class, object)).isEqualTo(object.sampleLong);
+    assertThat(fieldSupport.fieldValue("sampleFloat", float.class, object)).isEqualTo(object.sampleFloat);
+    assertThat(fieldSupport.fieldValue("sampleDouble", double.class, object)).isEqualTo(object.sampleDouble);
+    assertThat(fieldSupport.fieldValue("sampleBoolean", boolean.class, object)).isEqualTo(object.sampleBoolean);
+    assertThat(fieldSupport.fieldValue("sampleChar", char.class, object)).isEqualTo(object.sampleChar);
+  }
+
+  static class SampleObject {
+    final byte sampleByte = 1;
+    final short sampleShort = 1;
+    final int sampleInt = 1;
+    final long sampleLong = 1;
+    final float sampleFloat = 1;
+    final double sampleDouble = 1;
+    final boolean sampleBoolean = true;
+    final char sampleChar = 'a';
+  }
+
 }
