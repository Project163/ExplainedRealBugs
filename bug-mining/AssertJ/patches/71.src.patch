diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 1bc8e35f8..85c52c3da 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -916,8 +916,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * <p/>
    * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
    * (e.g. public) or fields with an accessible getter.<br/>
-   * Moreover comparison is <b>not</b> recursive, if one the field is an Object, it will be compared to the other field
-   * using its <code>equals</code> method.
+   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
+   * field using its <code>equals</code> method.
    *
    * <pre>
    * Example:
@@ -940,14 +940,14 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
   }
 
   /**
-   * Use field by field comparison on the <b>given fields only</b> (fields can be inherited fields) instead of relying on
-   * actual type A <code>equals</code> method to compare group elements for incoming assertion checks.
+   * Use field by field comparison on the <b>given fields only</b> (fields can be inherited fields) instead of relying
+   * on actual type A <code>equals</code> method to compare group elements for incoming assertion checks.
    * <p/>
    * This can be handy if <code>equals</code> method of the objects to compare does not suit you.
    * <p/>
    * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
    * (e.g. public) or fields with an accessible getter.<br/>
-   * Moreover comparison is <b>not</b> recursive, if one the field is an Object, it will be compared to the other field
+   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other field
    * using its <code>equals</code> method.
    *
    * <pre>
@@ -976,15 +976,15 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
   }
 
   /**
-   * Use field by field comparison on all fields <b>except</b> the given ones (fields can be inherited fields) instead of
-   * relying on actual type A <code>equals</code> method to compare group elements for incoming assertion checks.
+   * Use field by field comparison on all fields <b>except</b> the given ones (fields can be inherited fields) instead
+   * of relying on actual type A <code>equals</code> method to compare group elements for incoming assertion checks.
    * <p/>
    * This can be handy if <code>equals</code> method of the objects to compare does not suit you.
    * <p/>
    * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
    * (e.g. public) or fields with an accessible getter.<br/>
-   * Moreover comparison is <b>not</b> recursive, if one the field is an Object, it will be compared to the other field
-   * using its <code>equals</code> method.
+   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
+   * field using its <code>equals</code> method.
    *
    * <pre>
    * Example:
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
index a0f9bfb1f..1ed8630bb 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
@@ -33,7 +33,7 @@ import org.assertj.core.util.introspection.IntrospectionError;
 public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>, A> extends AbstractAssert<S, A> {
 
   protected AbstractObjectAssert(A actual, Class<?> selfType) {
-    super(actual, selfType);
+	super(actual, selfType);
   }
 
   /**
@@ -42,6 +42,11 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * <p>
    * It means that if an actual field is not null and the corresponding field in other is null, this field will be
    * ignored in comparison, but the opposite will make assertion fail (null field in actual, not null in other).
+   * <p/>
+   * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
+   * (e.g. public) or fields with an accessible getter. <br/>
+   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
+   * field using its <code>equals</code> method.
    * 
    * <pre>
    * Example:
@@ -63,26 +68,26 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * @throws AssertionError if the other object is not an instance of the actual type.
    */
   public S isEqualToIgnoringNullFields(A other) {
-    objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
-    return myself;
+	objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
+	return myself;
   }
 
   /**
    * @deprecated : use {@link #isEqualToIgnoringNullFields(Object)} instead.
    */
   public S isLenientEqualsToByIgnoringNullFields(A other) {
-    objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
-    return myself;
+	objects.assertIsLenientEqualsToIgnoringNullFields(info, actual, other);
+	return myself;
   }
 
   /**
-   * Assert that the actual object is equal to given one when doing a field by field comparison on the given fields only
-   * (fields can be inherited fields).
-   * 
-   * <p>
+   * Assert that the actual object is equal to given one using a field by field comparison on the given fields only
+   * (fields can be inherited fields or nested fields). This can be handy if <code>equals</code> implementation of objects to compare
+   * does not suit you.
+   * <p/>
    * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
    * (e.g. public) or fields with an accessible getter.
-   * </p>
+   * <p/>
    * 
    * Example:
    * 
@@ -93,6 +98,9 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * // frodo and sam both are hobbits, so they are equals when comparing only race
    * assertThat(frodo).isEqualToComparingOnlyGivenFields(sam, &quot;race&quot;); // OK
    * 
+   * // they are also equals when comparing only race name (nested field).
+   * assertThat(frodo).isEqualToComparingOnlyGivenFields(sam, &quot;race.name&quot;); // OK
+   * 
    * // ... but not when comparing both name and race
    * assertThat(frodo).isEqualToComparingOnlyGivenFields(sam, &quot;name&quot;, &quot;race&quot;); // FAIL
    * 
@@ -106,26 +114,27 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * @throws IntrospectionError if a field does not exist in actual.
    */
   public S isEqualToComparingOnlyGivenFields(A other, String... fieldsUsedInComparison) {
-    objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, fieldsUsedInComparison);
-    return myself;
+	objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, fieldsUsedInComparison);
+	return myself;
   }
 
   /**
    * @deprecated : use {@link #isEqualToComparingOnlyGivenFields(Object, String...)} instead.
    */
   public S isLenientEqualsToByAcceptingFields(A other, String... fields) {
-    objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, fields);
-    return myself;
+	objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, fields);
+	return myself;
   }
 
   /**
    * Assert that the actual object is equal to the given one by comparing their fields except for the given ones
-   * (inherited fields are taken into account).
-   * 
-   * <p>
+   * (inherited fields are taken into account). This can be handy if <code>equals</code> implementation of objects to
+   * compare does not suit you.
+   * <p/>
    * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
-   * (e.g. public) or fields with an accessible getter.
-   * </p>
+   * (e.g. public) or fields with an accessible getter. <br/>
+   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
+   * field using its <code>equals</code> method.
    * 
    * <pre>
    * Example:
@@ -148,28 +157,26 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * @throws AssertionError if the other object is not an instance of the actual type.
    */
   public S isEqualToIgnoringGivenFields(A other, String... fieldsToIgnore) {
-    objects.assertIsEqualToIgnoringGivenFields(info, actual, other, fieldsToIgnore);
-    return myself;
+	objects.assertIsEqualToIgnoringGivenFields(info, actual, other, fieldsToIgnore);
+	return myself;
   }
 
   /**
    * @deprecated : use {@link #isEqualToIgnoringGivenFields(Object, String...)} instead.
    */
   public S isLenientEqualsToByIgnoringFields(A other, String... fields) {
-    objects.assertIsEqualToIgnoringGivenFields(info, actual, other, fields);
-    return myself;
+	objects.assertIsEqualToIgnoringGivenFields(info, actual, other, fields);
+	return myself;
   }
 
   /**
    * Assert that the actual object is equal to the given object based on a field by field comparison (including
-   * inherited fields).
-   * <p>
-   * This can be handy if <code>equals</code> implementation of objects to compare does not suit you.
-   * </p>
-   * <p>
+   * inherited fields). This can be handy if <code>equals</code> implementation of objects to compare does not suit you.
+   * <p/>
    * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
-   * (e.g. public) or fields with an accessible getter.
-   * </p>
+   * (e.g. public) or fields with an accessible getter. <br/>
+   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
+   * field using its <code>equals</code> method.
    * 
    * <pre>
    * Example:
@@ -191,15 +198,15 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * @throws AssertionError if the other object is not an instance of the actual type.
    */
   public S isEqualToComparingFieldByField(A other) {
-    objects.assertIsEqualToIgnoringGivenFields(info, actual, other);
-    return myself;
+	objects.assertIsEqualToIgnoringGivenFields(info, actual, other);
+	return myself;
   }
 
   /**
    * @deprecated : use {@link #isEqualToComparingFieldByField(Object)} instead.
    */
   public S isEqualsToByComparingFields(A other) {
-    objects.assertIsEqualToIgnoringGivenFields(info, actual, other);
-    return myself;
+	objects.assertIsEqualToIgnoringGivenFields(info, actual, other);
+	return myself;
   }
 }
diff --git a/src/main/java/org/assertj/core/internal/Objects.java b/src/main/java/org/assertj/core/internal/Objects.java
index f6bb87016..4166e7f3a 100644
--- a/src/main/java/org/assertj/core/internal/Objects.java
+++ b/src/main/java/org/assertj/core/internal/Objects.java
@@ -48,6 +48,7 @@ import java.util.Set;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.util.VisibleForTesting;
+import org.assertj.core.util.introspection.FieldSupport;
 import org.assertj.core.util.introspection.IntrospectionError;
 
 /**
@@ -66,6 +67,8 @@ public class Objects {
   private final ComparisonStrategy comparisonStrategy;
   @VisibleForTesting
   Failures failures = Failures.instance();
+  // field support not reading private fields
+  private FieldSupport fieldSupport = new FieldSupport(false);
 
   /**
    * Returns the singleton instance of this class based on {@link StandardComparisonStrategy}.
@@ -552,9 +555,8 @@ public class Objects {
 	  }
 	}
 	if (!fieldsNames.isEmpty())
-	  throw failures.failure(info,
-	                         shouldBeEqualToIgnoringGivenFields(actual, fieldsNames, rejectedValues, expectedValues,
-	                                                            nullFields));
+	  throw failures.failure(info, shouldBeEqualToIgnoringGivenFields(actual, fieldsNames,
+	                                                                  rejectedValues, expectedValues, nullFields));
   }
 
   /**
@@ -585,13 +587,9 @@ public class Objects {
 	List<String> rejectedFieldsNames = new LinkedList<String>();
 	List<Object> expectedValues = new LinkedList<Object>();
 	List<Object> rejectedValues = new LinkedList<Object>();
-	final Set<Field> declaredFieldsIncludingInherited = getDeclaredFieldsIncludingInherited(actual.getClass());
 	for (String fieldName : fields) {
-	  Object actualFieldValue = getFieldOrPropertyValue(actual, findField(fieldName,
-		                                                                  declaredFieldsIncludingInherited,
-		                                                                  actual.getClass()));
-	  Object otherFieldValue = getFieldOrPropertyValue(other, findField(fieldName, declaredFieldsIncludingInherited,
-		                                                                other.getClass()));
+	  Object actualFieldValue = getNestedFieldOrPropertyValue(actual, fieldName);
+	  Object otherFieldValue = getNestedFieldOrPropertyValue(other, fieldName);
 	  if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
 		rejectedFieldsNames.add(fieldName);
 		expectedValues.add(otherFieldValue);
@@ -601,23 +599,6 @@ public class Objects {
 	return new ByFieldsComparison(rejectedFieldsNames, expectedValues, rejectedValues);
   }
 
-  /**
-   * Find field with given fieldName in fields of Class clazz.
-   * 
-   * @param fieldName the field name used to find field in fields
-   * @param fields Fields to look into
-   * @param clazz use for the exception to indicate to whihc class fields belonged.
-   * @return the field with given field name
-   * @throws IntrospectionError if no field with given fieldName can be found.
-   */
-  private Field findField(String fieldName, Set<Field> fields, Class<?> clazz) {
-	if (fieldName == null) return null;
-	for (Field field : fields) {
-	  if (fieldName.equals(field.getName())) return field;
-	}
-	throw new IntrospectionError(format("No field '%s' in %s", fieldName, clazz));
-  }
-
   /**
    * Assert that the given object is lenient equals to the other by comparing all fields (including inherited fields)
    * unless given ignored ones.
@@ -642,10 +623,6 @@ public class Objects {
 	                                                                  newArrayList(fields)));
   }
 
-  // public <A> ByFieldsComparison compareFieldByField(A actual, A other) {
-  // return isEqualToIgnoringGivenFields(actual, other, new String[0]);
-  // }
-
   private <A> ByFieldsComparison isEqualToIgnoringGivenFields(A actual, A other, String[] fields) {
 	List<String> fieldsNames = new LinkedList<String>();
 	List<Object> expectedValues = new LinkedList<Object>();
@@ -688,6 +665,31 @@ public class Objects {
 	}
   }
 
+  /**
+   * Get nested field value first and in case of error try its value from property getter (property name being field
+   * name)
+   *
+   * @param a the object to get field value from
+   * @param fieldName Field name to read, can be nested
+   * @return (nested) field value or property value if field was not accessible.
+   * @throws IntrospectionError is field value can't get retrieved.
+   */
+  private <A> Object getNestedFieldOrPropertyValue(A a, String fieldName) {
+	try {
+	  return fieldSupport.fieldValue(fieldName, Object.class, a);
+	} catch (IntrospectionError e) {
+	  try {
+		// field is not accessible, let's try to get its value from its getter if any.
+		return propertySupport.propertyValueOf(fieldName, Object.class, a);
+	  } catch (IntrospectionError e2) {
+		// this time, we really fail
+		String msg = format("Unable to obtain the value of <'%s'> field/property from <%s>, expecting a public field or getter",
+		                    fieldName, a);
+		throw new IntrospectionError(msg);
+	  }
+	}
+  }
+
   /**
    * Returns the declared fields of given class and its superclasses stopping at superclass in <code>java.lang</code>
    * package whose fields are not included.
diff --git a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
index 3043d1828..23b2e52c2 100644
--- a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
+++ b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
@@ -34,9 +34,9 @@ public class FieldSupport {
 
   private static final String SEPARATOR = ".";
 
-  private static final FieldSupport INSTANCE = new FieldSupport();
+  private static final FieldSupport INSTANCE = new FieldSupport(true);
 
-  private static boolean allowExtractingPrivateFields = true;
+  private boolean allowExtractingPrivateFields;
 
   /**
    * Returns the singleton instance of this class.
@@ -44,11 +44,16 @@ public class FieldSupport {
    * @return the singleton instance of this class.
    */
   public static FieldSupport instance() {
-    return INSTANCE;
+	return INSTANCE;
   }
 
-  @VisibleForTesting
-  FieldSupport() {
+  /**
+   * Build a new {@link FieldSupport}
+   * 
+   * @param allowExtractingPrivateFields wether to read private fields or not.
+   */
+  public FieldSupport(boolean allowExtractingPrivateFields) {
+	this.allowExtractingPrivateFields = allowExtractingPrivateFields;
   }
 
   /**
@@ -61,7 +66,7 @@ public class FieldSupport {
    * @param allowExtractingPrivateFields allow private fields extraction. Default {@code true}.
    */
   public static void setAllowExtractingPrivateFields(boolean allowExtractingPrivateFields) {
-    FieldSupport.allowExtractingPrivateFields = allowExtractingPrivateFields;
+	FieldSupport.INSTANCE.allowExtractingPrivateFields = allowExtractingPrivateFields;
   }
 
   /**
@@ -78,19 +83,19 @@ public class FieldSupport {
    * @throws IntrospectionError if an element in the given {@code Iterable} does not have a field with a matching name.
    */
   public <T> List<T> fieldValues(String fieldName, Class<T> fieldClass, Iterable<?> target) {
-    if (isNullOrEmpty(target)) return emptyList();
-
-    if (isNestedField(fieldName)) {
-      String firstFieldName = popFieldNameFrom(fieldName);
-      Iterable<Object> fieldValues = fieldValues(firstFieldName, Object.class, target);
-      // extract next sub-field values until reaching the last sub-field
-      return fieldValues(nextFieldNameFrom(fieldName), fieldClass, fieldValues);
-    }
-    return simpleFieldValues(fieldName, fieldClass, target);
+	if (isNullOrEmpty(target)) return emptyList();
+
+	if (isNestedField(fieldName)) {
+	  String firstFieldName = popFieldNameFrom(fieldName);
+	  Iterable<Object> fieldValues = fieldValues(firstFieldName, Object.class, target);
+	  // extract next sub-field values until reaching the last sub-field
+	  return fieldValues(nextFieldNameFrom(fieldName), fieldClass, fieldValues);
+	}
+	return simpleFieldValues(fieldName, fieldClass, target);
   }
 
   public List<Object> fieldValues(String fieldName, Iterable<?> target) {
-    return fieldValues(fieldName, Object.class, target);
+	return fieldValues(fieldName, Object.class, target);
   }
 
   /**
@@ -107,29 +112,29 @@ public class FieldSupport {
    * @throws IntrospectionError if an element in the given {@code Iterable} does not have a field with a matching name.
    */
   public <T> List<T> fieldValues(String fieldName, Class<T> fieldClass, Object[] target) {
-    return fieldValues(fieldName, fieldClass, wrap(target));
+	return fieldValues(fieldName, fieldClass, wrap(target));
   }
 
   private <T> List<T> simpleFieldValues(String fieldName, Class<T> clazz, Iterable<?> target) {
-    List<T> fieldValues = new ArrayList<T>();
-    for (Object e : target) {
-      fieldValues.add(e == null ? null : fieldValue(fieldName, clazz, e));
-    }
-    return unmodifiableList(fieldValues);
+	List<T> fieldValues = new ArrayList<T>();
+	for (Object e : target) {
+	  fieldValues.add(e == null ? null : fieldValue(fieldName, clazz, e));
+	}
+	return unmodifiableList(fieldValues);
   }
 
   private String popFieldNameFrom(String fieldNameChain) {
-    if (!isNestedField(fieldNameChain)) {
-      return fieldNameChain;
-    }
-    return fieldNameChain.substring(0, fieldNameChain.indexOf(SEPARATOR));
+	if (!isNestedField(fieldNameChain)) {
+	  return fieldNameChain;
+	}
+	return fieldNameChain.substring(0, fieldNameChain.indexOf(SEPARATOR));
   }
 
   private String nextFieldNameFrom(String fieldNameChain) {
-    if (!isNestedField(fieldNameChain)) {
-      return "";
-    }
-    return fieldNameChain.substring(fieldNameChain.indexOf(SEPARATOR) + 1);
+	if (!isNestedField(fieldNameChain)) {
+	  return "";
+	}
+	return fieldNameChain.substring(fieldNameChain.indexOf(SEPARATOR) + 1);
   }
 
   /**
@@ -146,7 +151,7 @@ public class FieldSupport {
    * </pre>
    */
   private boolean isNestedField(String fieldName) {
-    return fieldName.contains(SEPARATOR) && !fieldName.startsWith(SEPARATOR) && !fieldName.endsWith(SEPARATOR);
+	return fieldName.contains(SEPARATOR) && !fieldName.startsWith(SEPARATOR) && !fieldName.endsWith(SEPARATOR);
   }
 
   /**
@@ -166,33 +171,33 @@ public class FieldSupport {
    * @throws IntrospectionError if the given target does not have a field with a matching name.
    */
   public <T> T fieldValue(String fieldName, Class<T> fieldClass, Object target) {
-    if (target == null) return null;
-
-    if (isNestedField(fieldName)) {
-      String outerFieldName = popFieldNameFrom(fieldName);
-      Object outerFieldValue = readSimpleField(outerFieldName, Object.class, target);
-      // extract next sub-field values until reaching the last sub-field
-      return fieldValue(nextFieldNameFrom(fieldName), fieldClass, outerFieldValue);
-    }
-    return readSimpleField(fieldName, fieldClass, target);
+	if (target == null) return null;
+
+	if (isNestedField(fieldName)) {
+	  String outerFieldName = popFieldNameFrom(fieldName);
+	  Object outerFieldValue = readSimpleField(outerFieldName, Object.class, target);
+	  // extract next sub-field values until reaching the last sub-field
+	  return fieldValue(nextFieldNameFrom(fieldName), fieldClass, outerFieldValue);
+	}
+	return readSimpleField(fieldName, fieldClass, target);
   }
 
   private <T> T readSimpleField(String fieldName, Class<T> clazz, Object target) {
-    try {
-      Object readField = FieldUtils.readField(target, fieldName, allowExtractingPrivateFields);
-      return clazz.cast(readField);
-    } catch (ClassCastException e) {
-      String msg = format("Unable to obtain the value of the field <'%s'> from <%s> - wrong field type specified <%s>",
-                          fieldName, target, clazz);
-      throw new IntrospectionError(msg, e);
-    } catch (IllegalAccessException iae) {
-      String msg = format("Unable to obtain the value of the field <'%s'> from <%s>, check that field is public.",
-                          fieldName, target);
-      throw new IntrospectionError(msg, iae);
-    } catch (Throwable unexpected) {
-      String msg = format("Unable to obtain the value of the field <'%s'> from <%s>", fieldName, target);
-      throw new IntrospectionError(msg, unexpected);
-    }
+	try {
+	  Object readField = FieldUtils.readField(target, fieldName, allowExtractingPrivateFields);
+	  return clazz.cast(readField);
+	} catch (ClassCastException e) {
+	  String msg = format("Unable to obtain the value of the field <'%s'> from <%s> - wrong field type specified <%s>",
+		                  fieldName, target, clazz);
+	  throw new IntrospectionError(msg, e);
+	} catch (IllegalAccessException iae) {
+	  String msg = format("Unable to obtain the value of the field <'%s'> from <%s>, check that field is public.",
+		                  fieldName, target);
+	  throw new IntrospectionError(msg, iae);
+	} catch (Throwable unexpected) {
+	  String msg = format("Unable to obtain the value of the field <'%s'> from <%s>", fieldName, target);
+	  throw new IntrospectionError(msg, unexpected);
+	}
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/OnFieldsComparator_compare_Test.java b/src/test/java/org/assertj/core/internal/OnFieldsComparator_compare_Test.java
index f74290b5b..c7f6a3c1e 100644
--- a/src/test/java/org/assertj/core/internal/OnFieldsComparator_compare_Test.java
+++ b/src/test/java/org/assertj/core/internal/OnFieldsComparator_compare_Test.java
@@ -4,6 +4,7 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.ExpectedException.none;
 
 import org.assertj.core.test.ExpectedException;
+import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -51,7 +52,8 @@ public class OnFieldsComparator_compare_Test {
 
   @Test
   public void should_throw_exception_if_Objects_have_not_the_same_properties() {
-	thrown.expect(IllegalArgumentException.class);
+	thrown.expect(IntrospectionError.class,
+	              "Unable to obtain the value of <'telling'> field/property from <2>, expecting a public field or getter");
 	assertThat(onFieldsComparator.compare(new DarthVader("I like you", "I'll kill you"), 2)).isNotZero();
   }
 
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java
new file mode 100644
index 000000000..3c3bacc13
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java
@@ -0,0 +1,151 @@
+/*
+ * Created on Apr 8, 2012
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2012 the original author or authors.
+ */
+package org.assertj.core.internal.objects;
+
+import static org.assertj.core.error.ShouldBeEqualByComparingOnlyGivenFields.shouldBeEqualComparingOnlyGivenFields;
+import static org.assertj.core.error.ShouldBeInstance.shouldBeInstance;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Lists.newArrayList;
+import static org.mockito.Mockito.verify;
+
+import java.util.List;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.ObjectsBaseTest;
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.Jedi;
+import org.assertj.core.test.Name;
+import org.assertj.core.test.Player;
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class Objects_assertIsEqualToComparingOnlyGivenFields_Test extends ObjectsBaseTest {
+
+  @Test
+  public void should_pass_when_selected_fields_are_equal() {
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Yoda", "Green");
+	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "name", "lightSaberColor");
+  }
+
+  @Test
+  public void should_pass_when_selected_fields_and_nested_fields_accessed_with_getters_are_equal() {
+	Player rose = new Player(new Name("Derrick", "Rose"), "Chicago Bulls");
+	Player jalen = new Player(new Name("Derrick", "Coleman"), "Chicago Bulls");
+	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), rose, jalen, "team", "name.first");
+  }
+
+  @Test
+  public void should_pass_when_selected_fields_and_nested_public_fields_are_equal() {
+	Player rose = new Player(new Name("Derrick", "Rose"), "Chicago Bulls");
+	rose.nickname = new Name("Crazy", "Duncks");
+	Player jalen = new Player(new Name("Derrick", "Coleman"), "Chicago Bulls");
+	jalen.nickname = new Name("Crazy", "Defense");
+	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), rose, jalen, "team", "nickname.first");
+  }
+
+  @Test
+  public void should_pass_even_if_non_accepted_fields_differ() {
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Yoda", "Blue");
+	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "name");
+  }
+
+  @Test
+  public void should_pass_when_field_value_is_null() {
+	Jedi actual = new Jedi("Yoda", null);
+	Jedi other = new Jedi("Yoda", null);
+	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "name", "lightSaberColor");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	Jedi other = new Jedi("Yoda", "Green");
+	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), null, other, "name", "lightSaberColor");
+  }
+
+  @Test
+  public void should_fail_when_some_selected_field_values_differ() {
+	AssertionInfo info = someInfo();
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Yoda", "Blue");
+	try {
+	  objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, "name", "lightSaberColor");
+	} catch (AssertionError err) {
+	  List<Object> expected = newArrayList((Object) "Blue");
+	  List<Object> rejected = newArrayList((Object) "Green");
+	  verify(failures).failure(info,
+		                       shouldBeEqualComparingOnlyGivenFields(actual, newArrayList("lightSaberColor"), rejected,
+		                                                             expected,
+		                                                             newArrayList("name", "lightSaberColor")));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_when_some_inherited_field_values_differ() {
+	AssertionInfo info = someInfo();
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Luke", "Green");
+	try {
+	  objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, "name", "lightSaberColor");
+	} catch (AssertionError err) {
+	  List<Object> expected = newArrayList((Object) "Luke");
+	  List<Object> rejected = newArrayList((Object) "Yoda");
+	  verify(failures).failure(info,
+		                       shouldBeEqualComparingOnlyGivenFields(actual, newArrayList("name"), rejected, expected,
+		                                                             newArrayList("name", "lightSaberColor")));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_when_objects_to_compare_are_of_different_types() {
+	AssertionInfo info = someInfo();
+	Jedi actual = new Jedi("Yoda", "Green");
+	Employee other = new Employee();
+	try {
+	  objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, "name");
+	} catch (AssertionError err) {
+	  verify(failures).failure(info, shouldBeInstance(other, actual.getClass()));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_when_selected_field_does_not_exist() {
+	thrown.expect(IntrospectionError.class,
+	              "Unable to obtain the value of <'age'> field/property from <Yoda the Jedi>, expecting a public field or getter");
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Yoda", "Blue");
+	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "age");
+  }
+
+  @Test
+  public void should_fail_when_selected_field_is_not_accessible() {
+	thrown.expect(IntrospectionError.class,
+		"Unable to obtain the value of <'strangeNotReadablePrivateField'> field/property from <Yoda the Jedi>, expecting a public field or getter");
+	Jedi actual = new Jedi("Yoda", "Green");
+	Jedi other = new Jedi("Yoda", "Blue");
+	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "strangeNotReadablePrivateField");
+  }
+  
+}
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByAcceptingFields_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByAcceptingFields_Test.java
deleted file mode 100644
index 4a6241914..000000000
--- a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByAcceptingFields_Test.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Created on Apr 8, 2012
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- * 
- * Copyright @2012 the original author or authors.
- */
-package org.assertj.core.internal.objects;
-
-import static java.lang.String.format;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.error.ShouldBeInstance.shouldBeInstance;
-import static org.assertj.core.error.ShouldBeEqualByComparingOnlyGivenFields.shouldBeEqualComparingOnlyGivenFields;
-import static org.assertj.core.test.TestData.someInfo;
-import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
-import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.assertj.core.util.Lists.*;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.verify;
-
-import java.util.List;
-
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.ObjectsBaseTest;
-import org.assertj.core.test.Employee;
-import org.assertj.core.test.Jedi;
-import org.assertj.core.util.introspection.IntrospectionError;
-import org.junit.Test;
-
-
-/**
- * Tests for <code>{@link Objects#assertIsLenientEqualsToByAcceptingFields(AssertionInfo, Object, Object, String...)</code>.
- *
- * @author Nicolas Fran√ßois
- * @author Joel Costigliola
- */
-public class Objects_assertIsLenientEqualsToByAcceptingFields_Test extends ObjectsBaseTest {
-
-  @Test
-  public void should_pass_when_selected_fields_are_equal() {
-    Jedi actual = new Jedi("Yoda", "Green");
-    Jedi other = new Jedi("Yoda", "Green");
-    objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "name", "lightSaberColor");
-  }
-
-  @Test
-  public void should_pass_even_if_non_accepted_fields_differ() {
-    Jedi actual = new Jedi("Yoda", "Green");
-    Jedi other = new Jedi("Yoda", "Blue");
-    objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "name");
-  }
-
-  @Test
-  public void should_pass_when_field_value_is_null() {
-    Jedi actual = new Jedi("Yoda", null);
-    Jedi other = new Jedi("Yoda", null);
-    objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "name", "lightSaberColor");
-  }
-
-  @Test
-  public void should_fail_if_actual_is_null() {
-    thrown.expectAssertionError(actualIsNull());
-    Jedi other = new Jedi("Yoda", "Green");
-    objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), null, other, "name", "lightSaberColor");
-  }
-
-  @Test
-  public void should_fail_when_some_selected_field_values_differ() {
-    AssertionInfo info = someInfo();
-    Jedi actual = new Jedi("Yoda", "Green");
-    Jedi other = new Jedi("Yoda", "Blue");
-    try {
-      objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, "name", "lightSaberColor");
-    } catch (AssertionError err) {
-      List<Object> expected = newArrayList((Object) "Blue");
-      List<Object> rejected = newArrayList((Object) "Green");
-      verify(failures).failure(
-          info,
-          shouldBeEqualComparingOnlyGivenFields(actual, newArrayList("lightSaberColor"), rejected, expected,
-                                                newArrayList("name", "lightSaberColor")));
-      return;
-    }
-    failBecauseExpectedAssertionErrorWasNotThrown();
-  }
-
-  @Test
-  public void should_fail_when_some_inherited_field_values_differ() {
-    AssertionInfo info = someInfo();
-    Jedi actual = new Jedi("Yoda", "Green");
-    Jedi other = new Jedi("Luke", "Green");
-    try {
-      objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, "name", "lightSaberColor");
-    } catch (AssertionError err) {
-      List<Object> expected = newArrayList((Object) "Luke");
-      List<Object> rejected = newArrayList((Object) "Yoda");
-      verify(failures).failure(
-          info,
-          shouldBeEqualComparingOnlyGivenFields(actual, newArrayList("name"), rejected, expected,
-                                                newArrayList("name", "lightSaberColor")));
-      return;
-    }
-    failBecauseExpectedAssertionErrorWasNotThrown();
-  }
-
-  @Test
-  public void should_fail_when_objects_to_compare_are_of_different_types() {
-    AssertionInfo info = someInfo();
-    Jedi actual = new Jedi("Yoda", "Green");
-    Employee other = new Employee();
-    try {
-      objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, "name");
-    } catch (AssertionError err) {
-      verify(failures).failure(info, shouldBeInstance(other, actual.getClass()));
-      return;
-    }
-    failBecauseExpectedAssertionErrorWasNotThrown();
-  }
-
-  @Test
-  public void should_fail_when_selected_field_does_not_exist() {
-    AssertionInfo info = someInfo();
-    Jedi actual = new Jedi("Yoda", "Green");
-    Jedi other = new Jedi("Yoda", "Blue");
-    final String field = "age";
-    try {
-      objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, field);
-    } catch (IntrospectionError expected) {
-      assertThat(expected).hasMessage(format("No field '%s' in class %s", field, actual.getClass().getName()));
-      return;
-    }
-    fail("expecting an IntrospectionError to be thrown");
-  }
-
-}
diff --git a/src/test/java/org/assertj/core/test/Player.java b/src/test/java/org/assertj/core/test/Player.java
index 56e6768e9..f05ffb378 100644
--- a/src/test/java/org/assertj/core/test/Player.java
+++ b/src/test/java/org/assertj/core/test/Player.java
@@ -22,6 +22,7 @@ import static java.lang.String.format;
 public class Player {
 
   private Name name;
+  public Name nickname;
   private int pointsPerGame;
   private int assistsPerGame;
   private int reboundsPerGame;
diff --git a/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
index a5f6ef19c..3929ba988 100644
--- a/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
@@ -114,7 +114,9 @@ public class FieldSupport_fieldValues_Test {
   @Test
   public void should_extract_field() {
     Long id = FieldSupport.instance().fieldValue("id", Long.class, yoda);
-    assertEquals(Long.valueOf(1L), id);
+    assertThat(id).isEqualTo(1L);
+    Object idObject = FieldSupport.instance().fieldValue("id", Object.class, yoda);
+    assertThat(idObject).isInstanceOf(Long.class).isEqualTo(1L);
   }
 
   @Test
