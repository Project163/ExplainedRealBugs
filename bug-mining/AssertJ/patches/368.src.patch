diff --git a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index 4ff256f1f..eb65b3a55 100644
--- a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -19,9 +19,9 @@ import static java.util.stream.Collectors.toList;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.Arrays.isArrayTypePrimitive;
 import static org.assertj.core.util.Arrays.isObjectArray;
+import static org.assertj.core.util.Arrays.notAnArrayOfPrimitives;
 import static org.assertj.core.util.DateUtil.formatAsDatetime;
 import static org.assertj.core.util.DateUtil.formatAsDatetimeWithMs;
-import static org.assertj.core.util.IterableUtil.sizeOf;
 import static org.assertj.core.util.Preconditions.checkArgument;
 import static org.assertj.core.util.Streams.stream;
 import static org.assertj.core.util.Strings.concat;
@@ -30,6 +30,7 @@ import static org.assertj.core.util.Throwables.getStackTrace;
 
 import java.io.File;
 import java.lang.reflect.Method;
+import java.nio.file.Path;
 import java.text.SimpleDateFormat;
 import java.time.Duration;
 import java.time.LocalDate;
@@ -37,16 +38,13 @@ import java.time.LocalDateTime;
 import java.time.OffsetDateTime;
 import java.time.ZonedDateTime;
 import java.util.Calendar;
-import java.util.Collection;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.Set;
 import java.util.TreeMap;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
@@ -69,7 +67,6 @@ import org.assertj.core.configuration.ConfigurationProvider;
 import org.assertj.core.data.MapEntry;
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
-import org.assertj.core.util.Arrays;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.diff.ChangeDelta;
 import org.assertj.core.util.diff.DeleteDelta;
@@ -82,7 +79,7 @@ import org.assertj.core.util.diff.InsertDelta;
  */
 public class StandardRepresentation implements Representation {
 
-  private static final String ALREADY_VISITED = "(element already visited)";
+  private static final String NULL = "null";
 
   // can share this as StandardRepresentation has no state
   public static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
@@ -210,6 +207,7 @@ public class StandardRepresentation implements Representation {
     if (object instanceof AtomicReferenceFieldUpdater) return AtomicReferenceFieldUpdater.class.getSimpleName();
     if (object instanceof Number) return toStringOf((Number) object);
     if (object instanceof File) return toStringOf((File) object);
+    if (object instanceof Path) return fallbackToStringOf(object);
     if (object instanceof String) return toStringOf((String) object);
     if (object instanceof Character) return toStringOf((Character) object);
     if (object instanceof Comparator) return toStringOf((Comparator<?>) object);
@@ -217,7 +215,7 @@ public class StandardRepresentation implements Representation {
     if (object instanceof PredicateDescription) return toStringOf((PredicateDescription) object);
     if (object instanceof CompletableFuture) return toStringOf((CompletableFuture<?>) object);
     if (isArray(object)) return formatArray(object);
-    if (object instanceof Collection<?>) return smartFormat((Collection<?>) object);
+    if (object instanceof Iterable<?>) return smartFormat((Iterable<?>) object);
     if (object instanceof Map<?, ?>) return toStringOf((Map<?, ?>) object);
     if (object instanceof Tuple) return toStringOf((Tuple) object);
     if (object instanceof MapEntry) return toStringOf((MapEntry<?, ?>) object);
@@ -228,6 +226,18 @@ public class StandardRepresentation implements Representation {
     return fallbackToStringOf(object);
   }
 
+  @Override
+  public String unambiguousToStringOf(Object obj) {
+    // some types have already an unambiguous toString, no need to double down
+    if (hasAlreadyAnUnambiguousToStringOf(obj)) return toStringOf(obj);
+    return obj == null ? null : String.format("%s (%s@%s)", toStringOf(obj), classNameOf(obj), identityHexCodeOf(obj));
+  }
+
+  @Override
+  public String toString() {
+    return this.getClass().getSimpleName();
+  }
+
   @SuppressWarnings("unchecked")
   protected <T> String customFormat(T object) {
     if (object == null) return null;
@@ -239,13 +249,6 @@ public class StandardRepresentation implements Representation {
     return customFormatterByType.containsKey(object.getClass());
   }
 
-  @Override
-  public String unambiguousToStringOf(Object obj) {
-    // some types have already an unambiguous toString, no need to double down
-    if (hasAlreadyAnUnambiguousToStringOf(obj)) return toStringOf(obj);
-    return obj == null ? null : String.format("%s (%s@%s)", toStringOf(obj), classNameOf(obj), identityHexCodeOf(obj));
-  }
-
   /**
    * Determine whether the given object's type has a representation that is not ambiguous.
    * @param obj the object to check
@@ -353,10 +356,6 @@ public class StandardRepresentation implements Representation {
     return String.format(" (%s)", o.getClass().getName());
   }
 
-  private String defaultToStringWithClassNameDisambiguation(Object o) {
-    return o.toString() + classNameDisambiguation(o);
-  }
-
   protected String toStringOf(Float f) {
     return String.format("%sf", f);
   }
@@ -418,18 +417,6 @@ public class StandardRepresentation implements Representation {
     }
   }
 
-  private static Map<?, ?> toSortedMapIfPossible(Map<?, ?> map) {
-    try {
-      return new TreeMap<>(map);
-    } catch (ClassCastException | NullPointerException e) {
-      return map;
-    }
-  }
-
-  private String format(Map<?, ?> map, Object o) {
-    return o == map ? "(this Map)" : toStringOf(o);
-  }
-
   protected String toStringOf(AtomicReference<?> atomicReference) {
     return String.format("AtomicReference[%s]", toStringOf(atomicReference.get()));
   }
@@ -444,34 +431,27 @@ public class StandardRepresentation implements Representation {
                          toStringOf(atomicStampedReference.getReference()));
   }
 
-  private String toStringOf(ChangeDelta<?> changeDelta) {
-    return String.format("Changed content at line %s:%nexpecting:%n  %s%nbut was:%n  %s%n",
-                         changeDelta.lineNumber(),
-                         formatLines(changeDelta.getOriginal().getLines()),
-                         formatLines(changeDelta.getRevised().getLines()));
-  }
-
-  private String toStringOf(DeleteDelta<?> deleteDelta) {
-    return String.format("Missing content at line %s:%n  %s%n", deleteDelta.lineNumber(),
-                         formatLines(deleteDelta.getOriginal().getLines()));
-  }
-
-  private String toStringOf(InsertDelta<?> insertDelta) {
-    return String.format("Extra content at line %s:%n  %s%n", insertDelta.lineNumber(),
-                         formatLines(insertDelta.getRevised().getLines()));
-  }
-
-  private String toStringOf(Duration duration) {
-    return duration.toString().substring(2);
+  protected String multiLineFormat(Iterable<?> iterable) {
+    return format(iterable, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR_WITH_NEWLINE, INDENTATION_AFTER_NEWLINE, iterable);
   }
 
-  private String formatLines(List<?> lines) {
-    return format(lines, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR_WITH_NEWLINE, "   ");
+  protected String singleLineFormat(Iterable<?> iterable, String start, String end) {
+    return format(iterable, start, end, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, iterable);
   }
 
-  @Override
-  public String toString() {
-    return this.getClass().getSimpleName();
+  /**
+   * Returns the {@code String} representation of the given {@code Iterable}, or {@code null} if the given
+   * {@code Iterable} is {@code null}.
+   * <p>
+   * The {@code Iterable} will be formatted to a single line if it does not exceed 100 char, otherwise each elements
+   * will be formatted on a new line with 4 space indentation.
+   *
+   * @param iterable the {@code Iterable} to format.
+   * @return the {@code String} representation of the given {@code Iterable}.
+   */
+  protected String smartFormat(Iterable<?> iterable) {
+    String singleLineDescription = singleLineFormat(iterable, DEFAULT_START, DEFAULT_END);
+    return doesDescriptionFitOnSingleLine(singleLineDescription) ? singleLineDescription : multiLineFormat(iterable);
   }
 
   /**
@@ -486,69 +466,80 @@ public class StandardRepresentation implements Representation {
     return isObjectArray(o) ? smartFormat((Object[]) o) : formatPrimitiveArray(o);
   }
 
-  protected String multiLineFormat(Object[] array, Set<Object> alreadyVisited) {
-    return format(array, ELEMENT_SEPARATOR_WITH_NEWLINE, INDENTATION_AFTER_NEWLINE, alreadyVisited);
-  }
-
-  protected String singleLineFormat(Object[] array, Set<Object> alreadyVisited) {
-    return format(array, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, alreadyVisited);
-  }
-
   protected String smartFormat(Object[] array) {
-    Set<Object> alreadyVisited = new HashSet<>();
-    String description = singleLineFormat(array, alreadyVisited);
-    return doesDescriptionFitOnSingleLine(description) ? description : multiLineFormat(array, alreadyVisited);
+    String description = singleLineFormat(array, array);
+    return doesDescriptionFitOnSingleLine(description) ? description : multiLineFormat(array, array);
   }
 
-  protected String format(Object[] array, String elementSeparator, String indentation, Set<Object> alreadyVisited) {
-    if (array == null) return null;
-    if (array.length == 0) return DEFAULT_START + DEFAULT_END;
-
-    // deal with auto references to avoid infinite recursion
-    alreadyVisited.add(array);
-    List<String> list = Stream.of(array)
-                              .map(element -> alreadyVisited.contains(element) ? ALREADY_VISITED : toStringOf(element))
-                              .collect(toList());
-    return extracted(list, DEFAULT_START, DEFAULT_END, elementSeparator, indentation, list);
+  protected String formatPrimitiveArray(Object o) {
+    if (!isArray(o)) return null;
+    if (!isArrayTypePrimitive(o)) throw notAnArrayOfPrimitives(o);
+    Object[] array = toObjectArray(o);
+    return format(array, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, array);
   }
 
-  private String toStringOf(Object element, Set<Object> alreadyVisited) {
-    alreadyVisited.add(element);
-    return toStringOf(element);
+  protected String multiLineFormat(Object[] array, Object root) {
+    return format(array, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR_WITH_NEWLINE, INDENTATION_AFTER_NEWLINE, root);
   }
 
-  protected String formatPrimitiveArray(Object o) {
-    if (!isArray(o)) return null;
-    if (!isArrayTypePrimitive(o)) throw Arrays.notAnArrayOfPrimitives(o);
+  protected String singleLineFormat(Object[] array, Object root) {
+    return format(array, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, root);
+  }
 
-    int length = getLength(o);
-    Object[] array = new Object[length];
-    for (int i = 0; i < length; i++) {
-      array[i] = get(o, i);
-    }
-    return format(array, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, new HashSet<>());
+  protected String format(Object[] array, String start, String end, String elementSeparator, String indentation, Object root) {
+    if (array == null) return null;
+    // root is used to avoid infinite recursion in case one element refers to it.
+    List<String> representedElements = representElements(Stream.of(array), start, end, elementSeparator, indentation, root);
+    return representGroup(representedElements, start, end, elementSeparator, indentation);
   }
 
-  public String format(Iterable<?> iterable, String start, String end, String elementSeparator, String indentation) {
+  protected String format(Iterable<?> iterable, String start, String end, String elementSeparator, String indentation,
+                          Object root) {
     if (iterable == null) return null;
     Iterator<?> iterator = iterable.iterator();
     if (!iterator.hasNext()) return start + end;
-
-    // deal with auto references to avoid infinite recursion
-    List<String> list = stream(iterable).map(element -> element == iterable ? "(this iterable)" : toStringOf(element))
-                                        .collect(toList());
-    return extracted(iterable, start, end, elementSeparator, indentation, list);
-  }
-
-  private String extracted(Iterable<?> iterable, String start, String end, String elementSeparator, String indentation,
-                           List<String> list) {
-    int size = sizeOf(iterable);
+    // alreadyVisited is used to avoid infinite recursion when one element is a container already visited
+    List<String> representedElements = representElements(stream(iterable), start, end, elementSeparator, indentation, root);
+    return representGroup(representedElements, start, end, elementSeparator, indentation);
+  }
+
+  protected String safeStringOf(Object element, String start, String end, String elementSeparator, String indentation,
+                                Object root) {
+    if (element == root) return isArray(root) ? "(this array)" : "(this iterable)";
+    // primitive array elements can't cycle back to already represented containers
+    if (isArrayTypePrimitive(element)) return formatPrimitiveArray(element);
+    // object array/iterable elements can cycle back to root, we pass the latter to check for it
+    if (isArray(element)) return format((Object[]) element, start, end, elementSeparator, indentation, root);
+    if (element instanceof Iterable && !(element instanceof Path))
+      return format((Iterable) element, start, end, elementSeparator, indentation, root);
+    // Since potentially self referencing containers have been handled, it is reasonably safe to use toStringOf.
+    // What we don't track are cycles like A -> B -> A but that should be rare enough thus this solution is good enough
+    // To fully avoid all cycles we would need to track all visited elements but the issue is that:
+    // List<Object> innerList = list(1, 2, 3);
+    // List<Object> outerList = list(innerList, innerList);
+    // outerList would be represented as [[1, 2, 3], (already visited)] instead of [[1, 2, 3], [1, 2, 3]]
+    // Final word, the approach used here is the same as the toString implementation in AbstractCollection
+    return element == null ? NULL : toStringOf(element);
+  }
+
+  // private methods
+
+  private List<String> representElements(Stream<?> elements, String start, String end, String elementSeparator,
+                                         String indentation, Object root) {
+    return elements.map(element -> safeStringOf(element, start, end, elementSeparator, indentation, root))
+                   .collect(toList());
+  }
+
+  // this method only deals with max number of elements to display, the elements representation is already computed
+  private static String representGroup(List<String> representedElements, String start, String end, String elementSeparator,
+                                       String indentation) {
+    int size = representedElements.size();
     StringBuilder desc = new StringBuilder(start);
     if (size <= maxElementsForPrinting) {
       // display all elements
       for (int i = 0; i < size; i++) {
         if (i != 0) desc.append(indentation);
-        desc.append(list.get(i));
+        desc.append(representedElements.get(i));
         if (i != size - 1) desc.append(elementSeparator);
       }
       return desc.append(end).toString();
@@ -557,7 +548,7 @@ public class StandardRepresentation implements Representation {
     // if maxElementsForPrinting is odd, display one more first elements than last, ex: 9 => display 5 first elements and 4 last
     int maxFirstElementsToPrint = (maxElementsForPrinting + 1) / 2;
     for (int i = 0; i < maxFirstElementsToPrint; i++) {
-      desc.append(list.get(i)).append(elementSeparator).append(indentation);
+      desc.append(representedElements.get(i)).append(elementSeparator).append(indentation);
     }
     desc.append(DEFAULT_MAX_ELEMENTS_EXCEEDED);
     // we only append a new line if the separator had one ",\n"
@@ -577,32 +568,34 @@ public class StandardRepresentation implements Representation {
     int maxLastElementsToPrint = maxElementsForPrinting / 2;
     for (int i = size - maxLastElementsToPrint; i < size; i++) {
       if (i != size - maxLastElementsToPrint) desc.append(elementSeparator);
-      desc.append(indentation).append(list.get(i));
+      desc.append(indentation).append(representedElements.get(i));
     }
     return desc.append(end).toString();
   }
 
-  protected String multiLineFormat(Iterable<?> iterable) {
-    return format(iterable, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR_WITH_NEWLINE, INDENTATION_AFTER_NEWLINE);
+  private String toStringOf(ChangeDelta<?> changeDelta) {
+    return String.format("Changed content at line %s:%nexpecting:%n  %s%nbut was:%n  %s%n",
+                         changeDelta.lineNumber(),
+                         formatLines(changeDelta.getOriginal().getLines()),
+                         formatLines(changeDelta.getRevised().getLines()));
   }
 
-  protected String singleLineFormat(Iterable<?> iterable, String start, String end) {
-    return format(iterable, start, end, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE);
+  private String toStringOf(DeleteDelta<?> deleteDelta) {
+    return String.format("Missing content at line %s:%n  %s%n", deleteDelta.lineNumber(),
+                         formatLines(deleteDelta.getOriginal().getLines()));
   }
 
-  /**
-   * Returns the {@code String} representation of the given {@code Iterable}, or {@code null} if the given
-   * {@code Iterable} is {@code null}.
-   * <p>
-   * The {@code Iterable} will be formatted to a single line if it does not exceed 100 char, otherwise each elements
-   * will be formatted on a new line with 4 space indentation.
-   *
-   * @param iterable the {@code Iterable} to format.
-   * @return the {@code String} representation of the given {@code Iterable}.
-   */
-  protected String smartFormat(Iterable<?> iterable) {
-    String singleLineDescription = singleLineFormat(iterable, DEFAULT_START, DEFAULT_END);
-    return doesDescriptionFitOnSingleLine(singleLineDescription) ? singleLineDescription : multiLineFormat(iterable);
+  private String toStringOf(InsertDelta<?> insertDelta) {
+    return String.format("Extra content at line %s:%n  %s%n", insertDelta.lineNumber(),
+                         formatLines(insertDelta.getRevised().getLines()));
+  }
+
+  private String toStringOf(Duration duration) {
+    return duration.toString().substring(2);
+  }
+
+  private String formatLines(List<?> lines) {
+    return format(lines, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR_WITH_NEWLINE, "   ", lines);
   }
 
   private static boolean doesDescriptionFitOnSingleLine(String singleLineDescription) {
@@ -617,4 +610,29 @@ public class StandardRepresentation implements Representation {
     return obj.getClass().isAnonymousClass() ? obj.getClass().getName() : obj.getClass().getSimpleName();
   }
 
+  private String defaultToStringWithClassNameDisambiguation(Object o) {
+    return o.toString() + classNameDisambiguation(o);
+  }
+
+  private static Map<?, ?> toSortedMapIfPossible(Map<?, ?> map) {
+    try {
+      return new TreeMap<>(map);
+    } catch (ClassCastException | NullPointerException e) {
+      return map;
+    }
+  }
+
+  private String format(Map<?, ?> map, Object o) {
+    return o == map ? "(this Map)" : toStringOf(o);
+  }
+
+  private static Object[] toObjectArray(Object o) {
+    int length = getLength(o);
+    Object[] array = new Object[length];
+    for (int i = 0; i < length; i++) {
+      array[i] = get(o, i);
+    }
+    return array;
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/util/Arrays.java b/src/main/java/org/assertj/core/util/Arrays.java
index a0ed4029e..b5327af33 100644
--- a/src/main/java/org/assertj/core/util/Arrays.java
+++ b/src/main/java/org/assertj/core/util/Arrays.java
@@ -28,7 +28,7 @@ import java.util.concurrent.atomic.AtomicReferenceArray;
 
 /**
  * Utility methods related to arrays.
- * 
+ *
  * @author Alex Ruiz
  * @author Joel Costigliola
  * @author Florent Biville
@@ -37,7 +37,7 @@ public class Arrays {
 
   /**
    * Indicates whether the given object is not {@code null} and is an array.
-   * 
+   *
    * @param o the given object.
    * @return {@code true} if the given object is not {@code null} and is an array, otherwise {@code false}.
    */
@@ -47,7 +47,7 @@ public class Arrays {
 
   /**
    * Get the values of any array (primitive or not) into a {@code Object[]}.
-   * 
+   *
    * @param array array passed as an object to support both primitive and Object array
    * @return the values of the given Object as a {@code Object[]}.
    * @throws IllegalArgumentException it the given Object is not an array.
@@ -64,7 +64,7 @@ public class Arrays {
 
   /**
    * Get the values of any array (primitive or not) into a {@code List<Object>}.
-   * 
+   *
    * @param array array passed as an object to support both primitive and Object array
    * @return the values of the given Object as a {@code List<Object>}.
    * @throws IllegalArgumentException it the given Object is not an array.
@@ -75,7 +75,7 @@ public class Arrays {
 
   /**
    * Indicates whether the given array is {@code null} or empty.
-   * 
+   *
    * @param <T> the type of elements of the array.
    * @param array the array to check.
    * @return {@code true} if the given array is {@code null} or empty, otherwise {@code false}.
@@ -86,7 +86,7 @@ public class Arrays {
 
   /**
    * Returns an array containing the given arguments.
-   * 
+   *
    * @param <T> the type of the array to return.
    * @param values the values to store in the array.
    * @return an array containing the given arguments.
@@ -96,9 +96,9 @@ public class Arrays {
     return values;
   }
 
-  /** 
+  /**
    * Returns an int[] from the {@link AtomicIntegerArray}, null if the given atomic array is null.
-   * 
+   *
    * @param atomicIntegerArray the {@link AtomicIntegerArray} to convert to int[].
    * @return an int[].
    */
@@ -111,9 +111,9 @@ public class Arrays {
     return array;
   }
 
-  /** 
+  /**
    * Returns an long[] from the {@link AtomicLongArray}, null if the given atomic array is null.
-   * 
+   *
    * @param atomicLongArray the {@link AtomicLongArray} to convert to long[].
    * @return an long[].
    */
@@ -126,9 +126,9 @@ public class Arrays {
     return array;
   }
 
-  /** 
+  /**
    * Returns an T[] from the {@link AtomicReferenceArray}, null if the given atomic array is null.
-   * 
+   *
    * @param <T> the type of elements of the array.
    * @param atomicReferenceArray the {@link AtomicReferenceArray} to convert to T[].
    * @return an T[].
@@ -147,7 +147,7 @@ public class Arrays {
 
   /**
    * Returns all the non-{@code null} elements in the given array.
-   * 
+   *
    * @param <T> the type of elements of the array.
    * @param array the given array.
    * @return all the non-{@code null} elements in the given array. An empty list is returned if the given array is
@@ -161,7 +161,7 @@ public class Arrays {
   /**
    * Returns {@code true} if the given array has only {@code null} elements, {@code false} otherwise. If given array is
    * empty, this method returns {@code true}.
-   * 
+   *
    * @param <T> the type of elements of the array.
    * @param array the given array. <b>It must not be null</b>.
    * @return {@code true} if the given array has only {@code null} elements or is empty, {@code false} otherwise.
@@ -185,7 +185,7 @@ public class Arrays {
   }
 
   public static boolean isArrayTypePrimitive(Object o) {
-    return o != null && o.getClass().getComponentType().isPrimitive();
+    return o != null && isArray(o) && o.getClass().getComponentType().isPrimitive();
   }
 
   public static IllegalArgumentException notAnArrayOfPrimitives(Object o) {
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java
index 934d30686..9e2887e3d 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java
@@ -19,7 +19,6 @@ import static org.assertj.core.util.Strings.quote;
 
 import java.util.stream.Stream;
 
-import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
@@ -138,17 +137,27 @@ public class StandardRepresentation_array_format_Test extends AbstractBaseRepres
     then(formatted).isEqualTo("[\"Hello\", [true, false]]");
   }
 
-  @Disabled
   @Test
   public void should_format_Object_array_with_itself_as_element() {
     // GIVEN
-    Object[] array1 = { "Hello", "World" };
-    Object[] array2 = { array1 };
-    array1[1] = array2;
+    Object[] array = { "Hello", null };
+    array[1] = array;
     // WHEN
-    String formatted = STANDARD_REPRESENTATION.formatArray(array2);
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo("[\"Hello\", (this array)]");
+  }
+
+  @Test
+  public void should_format_self_referencing_Object_array() {
+    // GIVEN
+    Object[] array = { null, null };
+    array[0] = array;
+    array[1] = array;
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
     // THEN
-    then(formatted).isEqualTo("[[\"Hello\", (this array)]]");
+    then(formatted).isEqualTo("[(this array), (this array)]");
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
index 0e7fb7937..e3c4fce07 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
@@ -13,10 +13,8 @@
 package org.assertj.core.presentation;
 
 import static java.lang.String.format;
-import static java.util.Arrays.asList;
 import static java.util.Collections.emptyList;
 import static java.util.stream.Collectors.joining;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
 import static org.assertj.core.util.Lists.list;
@@ -24,7 +22,6 @@ import static org.assertj.core.util.Lists.list;
 import java.util.List;
 import java.util.stream.Stream;
 
-import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
@@ -76,9 +73,11 @@ public class StandardRepresentation_iterable_format_Test extends AbstractBaseRep
 
   @Test
   public void should_format_iterable_with_custom_start_and_end() {
-    List<? extends Object> list = asList("First", 3);
-    assertThat(STANDARD_REPRESENTATION.singleLineFormat(list, "{", "}")).isEqualTo("{\"First\", 3}");
-    assertThat(STANDARD_REPRESENTATION.singleLineFormat(asList(), "{", "}")).isEqualTo("{}");
+    // GIVEN
+    List<? extends Object> list = list("First", 3);
+    // THEN
+    then(STANDARD_REPRESENTATION.singleLineFormat(list, "{", "}")).isEqualTo("{\"First\", 3}");
+    then(STANDARD_REPRESENTATION.singleLineFormat(list(), "{", "}")).isEqualTo("{}");
   }
 
   @ParameterizedTest(name = "with printing {0} max, {1} should be formatted as {2}")
@@ -163,7 +162,7 @@ public class StandardRepresentation_iterable_format_Test extends AbstractBaseRep
     // GIVEN
     StandardRepresentation.setMaxElementsForPrinting(6);
     // WHEN
-    String formatted = STANDARD_REPRESENTATION.smartFormat(list("First", 3, 4, "foo", "bar", 5, "another", 6));
+    String formatted = STANDARD_REPRESENTATION.toStringOf(list("First", 3, 4, "foo", "bar", 5, "another", 6));
     // THEN
     then(formatted).isEqualTo(format("[\"First\", 3, 4, ... 5, \"another\", 6]"));
   }
@@ -173,34 +172,42 @@ public class StandardRepresentation_iterable_format_Test extends AbstractBaseRep
     // GIVEN
     List<Integer> list = list(1, 2, 3);
     // WHEN
-    String formatted = new HexadecimalRepresentation().multiLineFormat(list);
+    String formatted = new HexadecimalRepresentation().toStringOf(list);
     // THEN
-    String formattedAfterNewLine = "  <" + formatted + ">";
-    then(formattedAfterNewLine).isEqualTo(format("  <[0x0000_0001,%n" +
-                                                 "    0x0000_0002,%n" +
-                                                 "    0x0000_0003]>"));
+    then(formatted).isEqualTo("[0x0000_0001, 0x0000_0002, 0x0000_0003]");
   }
 
   @Test
   public void should_format_recursive_iterable() {
     // GIVEN
-    List<Object> list = list();
-    list.add(list);
-    list.add(list);
+    List<Object> selfReferencingList = list();
+    selfReferencingList.add(selfReferencingList);
+    selfReferencingList.add(selfReferencingList);
     // WHEN
-    String formatted = STANDARD_REPRESENTATION.multiLineFormat(list);
+    String formatted = STANDARD_REPRESENTATION.toStringOf(selfReferencingList);
     // THEN
-    then(formatted).isEqualTo(format("[(this iterable),%n" +
-                                     "    (this iterable)]"));
+    then(formatted).isEqualTo(format("[(this iterable), (this iterable)]"));
   }
 
-  @Disabled //
   @Test
   public void should_format_iterable_having_itself_as_element() {
-    List<Object> list1 = list("Hello", "World");
-    List<Object> list2 = list(list1);
-    list1.set(1, list2);
-    assertThat(STANDARD_REPRESENTATION.toStringOf(list1)).isEqualTo("[[\"Hello\", (this iterable)]]");
+    // GIVEN
+    List<Object> selfReferencingList = list("Hello");
+    selfReferencingList.add(selfReferencingList);
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.toStringOf(selfReferencingList);
+    // THEN
+    then(formatted).isEqualTo("[\"Hello\", (this iterable)]");
+  }
+
+  @Test
+  public void should_only_consider_root_object_for_cycles() {
+    List<Object> innerList = list(1, 2, 3);
+    List<Object> outerList = list(innerList, innerList);
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.toStringOf(outerList);
+    // THEN
+    then(formatted).isEqualTo("[[1, 2, 3], [1, 2, 3]]");
   }
 
   private static String stringOfLength(int length) {
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java
index 5663817fa..6ca913071 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java
@@ -23,7 +23,7 @@ import org.junit.jupiter.api.Test;
 
 /**
  * Tests for {@link StandardRepresentation#toStringOf(Map) StandardRepresentation#toStringOf(Map)}.
- * 
+ *
  * @author Yvonne Wang
  * @author Alex Ruiz
  * @author gabga
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
index 5a90f8215..f21847910 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
@@ -24,6 +24,8 @@ import static org.assertj.core.util.Lists.list;
 
 import java.io.File;
 import java.lang.reflect.Method;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.text.SimpleDateFormat;
 import java.time.Duration;
 import java.time.LocalDate;
@@ -94,6 +96,12 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
     assertThat(STANDARD_REPRESENTATION.toStringOf(o)).isEqualTo(path);
   }
 
+  @Test
+  public void should_return_toString_of_Path() {
+    final Path path = Paths.get("someFile.txt");
+    assertThat(STANDARD_REPRESENTATION.toStringOf(path)).isEqualTo("someFile.txt");
+  }
+
   @Test
   public void should_return_toString_of_Class_with_its_name() {
     assertThat(STANDARD_REPRESENTATION.toStringOf(Object.class)).isEqualTo("java.lang.Object");
diff --git a/src/test/java/org/assertj/core/util/Arrays_isArrayTypePrimitive_Test.java b/src/test/java/org/assertj/core/util/Arrays_isArrayTypePrimitive_Test.java
new file mode 100644
index 000000000..5d9f28275
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/Arrays_isArrayTypePrimitive_Test.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.util;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Arrays.isArrayTypePrimitive;
+
+import org.junit.jupiter.api.Test;
+
+public class Arrays_isArrayTypePrimitive_Test {
+
+  @Test
+  public void should_return_true_if_object_is_a_primitive_array() {
+    // GIVEN
+    int[] o = new int[0];
+    // WHEN
+    boolean isArrayTypePrimitive = isArrayTypePrimitive(o);
+    // THEN
+    then(isArrayTypePrimitive).isTrue();
+  }
+
+  @Test
+  public void should_return_false_if_object_is_an_object_array() {
+    // GIVEN
+    Object[] o = new Object[0];
+    // WHEN
+    boolean isArrayTypePrimitive = isArrayTypePrimitive(o);
+    // THEN
+    then(isArrayTypePrimitive).isFalse();
+  }
+
+  @Test
+  public void should_return_false_if_object_is_null() {
+    // GIVEN
+    Object o = null;
+    // WHEN
+    boolean isArrayTypePrimitive = isArrayTypePrimitive(o);
+    // THEN
+    then(isArrayTypePrimitive).isFalse();
+  }
+
+  @Test
+  public void should_return_false_if_object_is_not_an_array() {
+    // GIVEN
+    String string = "I'm not an array";
+    // WHEN
+    boolean isArrayTypePrimitive = isArrayTypePrimitive(string);
+    // THEN
+    then(isArrayTypePrimitive).isFalse();
+  }
+}
