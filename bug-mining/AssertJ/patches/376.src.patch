diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 7caa5344b..f6d769b6e 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -2494,6 +2494,41 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return newAbstractIterableAssert(filteredIterable).withAssertionState(myself);
   }
 
+  /**
+   * Filter the iterable under test keeping only elements for which the result of the {@code function} is equal to {@code expectedValue}.
+   * <p>
+   * It allows to filter elements in more safe way than by using {@link #filteredOn(String, Object)} as it doesn't utilize introspection.
+   * <p>
+   * As an example, let's check all employees 800 years old (yes, special employees):
+   * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   *
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   *
+   * assertThat(employees).filteredOn(Employee::getAge, 800)
+   *                      .containsOnly(yoda, obiwan);
+   *
+   * assertThat(employees).filteredOn(e -&gt; e.getName(), null)
+   *                      .containsOnly(noname);</code></pre>
+   *
+   * If you need more complex filter, use {@link #filteredOn(Predicate)} or {@link #filteredOn(Condition)}.
+   *
+   * @param <T> result type of the filter function
+   * @param function the filter function
+   * @param expectedValue the expected value of the filter function
+   * @return a new assertion object with the filtered iterable under test
+   * @throws IllegalArgumentException if the given function is {@code null}.
+   * @since 3.17.0
+   */
+  @CheckReturnValue
+  public <T> SELF filteredOn(Function<? super ELEMENT, T> function, T expectedValue) {
+    checkArgument(function != null, "The filter function should not be null");
+    // call internalFilteredOn to avoid double proxying in soft assertions
+    return internalFilteredOn(element -> java.util.Objects.equals(function.apply(element), expectedValue));
+  }
+
   /**
    * Filter the iterable under test keeping only elements matching the given assertions specified with a {@link Consumer}.
    * <p>
@@ -2956,9 +2991,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * @throws IllegalArgumentException if the given predicate is {@code null}.
    */
   public SELF filteredOn(Predicate<? super ELEMENT> predicate) {
-    checkArgument(predicate != null, "The filter predicate should not be null");
-    List<? extends ELEMENT> filteredIterable = stream(actual.spliterator(), false).filter(predicate).collect(toList());
-    return newAbstractIterableAssert(filteredIterable).withAssertionState(myself);
+    return internalFilteredOn(predicate);
   }
 
   /**
@@ -3319,4 +3352,9 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return myself;
   }
 
+  private SELF internalFilteredOn(Predicate<? super ELEMENT> predicate) {
+    checkArgument(predicate != null, "The filter predicate should not be null");
+    List<? extends ELEMENT> filteredIterable = stream(actual.spliterator(), false).filter(predicate).collect(toList());
+    return newAbstractIterableAssert(filteredIterable).withAssertionState(myself);
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index 59f6aeadb..46b62975d 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -2749,9 +2749,42 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
    * @throws IllegalArgumentException if the given predicate is {@code null}.
    */
   public SELF filteredOn(Predicate<? super ELEMENT> predicate) {
-    checkArgument(predicate != null, "The filter predicate should not be null");
-    List<ELEMENT> filteredList = stream(actual).filter(predicate).collect(toList());
-    return newObjectArrayAssert(filteredList);
+    return internalFilteredOn(predicate);
+  }
+
+  /**
+   * Filter the array under test into a list composed of the elements for which the result of the {@code function} is equal to {@code expectedValue}.
+   * <p>
+   * It allows to filter elements in more safe way than by using {@link #filteredOn(String, Object)} as it doesn't utilize introspection.
+   * <p>
+   * As an example, let's check all employees 800 years old (yes, special employees):
+   * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   *
+   * Employee[] employees = new Employee[] { yoda, luke, obiwan, noname };
+   *
+   * assertThat(employees).filteredOn(Employee::getAge, 800)
+   *                      .containsOnly(yoda, obiwan);
+   *
+   * assertThat(employees).filteredOn(e -&gt; e.getName(), null)
+   *                      .containsOnly(noname);</code></pre>
+   *
+   * If you need more complex filter, use {@link #filteredOn(Predicate)} or {@link #filteredOn(Condition)}.
+   *
+   * @param <T> result type of the filter function
+   * @param function the filter function
+   * @param expectedValue the expected value of the filter function
+   * @return a new assertion object with the filtered list under test
+   * @throws IllegalArgumentException if the given function is {@code null}.
+   * @since 3.17.0
+   */
+  @CheckReturnValue
+  public <T> SELF filteredOn(Function<? super ELEMENT, T> function, T expectedValue) {
+    checkArgument(function != null, "The filter function should not be null");
+    // call internalFilteredOn to avoid double proxying in soft assertions
+    return internalFilteredOn(element -> java.util.Objects.equals(function.apply(element), expectedValue));
   }
 
   /**
@@ -3160,4 +3193,9 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
     return filteredList.toArray(actualCopy);
   }
 
+  private SELF internalFilteredOn(Predicate<? super ELEMENT> predicate) {
+    checkArgument(predicate != null, "The filter predicate should not be null");
+    List<ELEMENT> filteredList = stream(actual).filter(predicate).collect(toList());
+    return newObjectArrayAssert(filteredList);
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java b/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
index d41a0a3ce..2c294350b 100644
--- a/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
@@ -12,6 +12,7 @@
  */
 package org.assertj.core.api;
 
+import static java.util.Arrays.stream;
 import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.filter.Filters.filter;
 import static org.assertj.core.description.Description.mostRelevantDescription;
@@ -26,6 +27,7 @@ import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.IterableUtil.toArray;
 import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Preconditions.checkArgument;
 import static org.assertj.core.util.Preconditions.checkNotNull;
 
 import java.lang.reflect.Array;
@@ -2678,8 +2680,7 @@ public class AtomicReferenceArrayAssert<T>
    */
   @CheckReturnValue
   public AtomicReferenceArrayAssert<T> filteredOn(String propertyOrFieldName, Object expectedValue) {
-    Iterable<? extends T> filteredIterable = filter(array).with(propertyOrFieldName, expectedValue).get();
-    return new AtomicReferenceArrayAssert<>(new AtomicReferenceArray<>(toArray(filteredIterable)));
+    return internalFilteredOn(propertyOrFieldName, expectedValue);
   }
 
   /**
@@ -2723,9 +2724,8 @@ public class AtomicReferenceArrayAssert<T>
    */
   @CheckReturnValue
   public AtomicReferenceArrayAssert<T> filteredOnNull(String propertyOrFieldName) {
-    // need to cast null to Object otherwise it calls :
-    // filteredOn(String propertyOrFieldName, FilterOperation<?> filterOperation)
-    return filteredOn(propertyOrFieldName, (Object) null);
+    // call internalFilteredOn to avoid double proxying in soft assertions
+    return internalFilteredOn(propertyOrFieldName, null);
   }
 
   /**
@@ -2785,8 +2785,8 @@ public class AtomicReferenceArrayAssert<T>
    *                                .filteredOn("name", not("Boromir"))
    *                                .containsOnly(aragorn);</code></pre>
    *
-   * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
-   * filter to apply.
+   * If you need more complex filter, use {@link #filteredOn(Condition)} or {@link #filteredOn(Predicate)} and
+   * provide a {@link Condition} or {@link Predicate} to specify the filter to apply.
    *
    * @param propertyOrFieldName the name of the property or field to read
    * @param filterOperator the filter operator to apply
@@ -2841,6 +2841,65 @@ public class AtomicReferenceArrayAssert<T>
     return new AtomicReferenceArrayAssert<>(new AtomicReferenceArray<>(toArray(filteredIterable)));
   }
 
+  /**
+   * Filter the array under test into a list composed of the elements matching the given {@link Predicate},
+   * allowing to perform assertions on the filtered list.
+   * <p>
+   * Example : check old employees whose age &gt; 100:
+   *
+   * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   *
+   * AtomicReferenceArray&lt;Employee&gt; employees = new AtomicReferenceArray&lt;&gt;(new Employee[]{ yoda, luke, obiwan, noname });
+   *
+   * assertThat(employees).filteredOn(employee -&gt; employee.getAge() &gt; 100)
+   *                      .containsOnly(yoda, obiwan);</code></pre>
+   *
+   * @param predicate the filter predicate
+   * @return a new assertion object with the filtered array under test
+   * @throws IllegalArgumentException if the given predicate is {@code null}.
+   * @since 3.16.0
+   */
+  public AtomicReferenceArrayAssert<T> filteredOn(Predicate<? super T> predicate) {
+    return internalFilteredOn(predicate);
+  }
+
+  /**
+   * Filter the array under test into a list composed of the elements for which the result of the {@code function} is equal to {@code expectedValue}.
+   * <p>
+   * It allows to filter elements in more safe way than by using {@link #filteredOn(String, Object)} as it doesn't utilize introspection.
+   * <p>
+   * As an example, let's check all employees 800 years old (yes, special employees):
+   * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   *
+   * AtomicReferenceArray&lt;Employee&gt; employees = new AtomicReferenceArray&lt;&gt;(new Employee[]{ yoda, luke, obiwan, noname });
+   *
+   * assertThat(employees).filteredOn(Employee::getAge, 800)
+   *                      .containsOnly(yoda, obiwan);
+   *
+   * assertThat(employees).filteredOn(e -&gt; e.getName(), null)
+   *                      .containsOnly(noname);</code></pre>
+   *
+   * If you need more complex filter, use {@link #filteredOn(Predicate)} or {@link #filteredOn(Condition)}.
+   *
+   * @param <U> result type of the filter function
+   * @param function the filter function
+   * @param expectedValue the expected value of the filter function
+   * @return a new assertion object with the filtered array under test
+   * @throws IllegalArgumentException if the given function is {@code null}.
+   * @since 3.17.0
+   */
+  @CheckReturnValue
+  public <U> AtomicReferenceArrayAssert<T> filteredOn(Function<? super T, U> function, U expectedValue) {
+    checkArgument(function != null, "The filter function should not be null");
+    // call internalFilteredOn to avoid double proxying in soft assertions
+    return internalFilteredOn(element -> java.util.Objects.equals(function.apply(element), expectedValue));
+  }
+
   /**
    * Verifies that all elements match the given {@link Predicate}.
    * <p>
@@ -3098,4 +3157,15 @@ public class AtomicReferenceArrayAssert<T>
     return comparatorsForElementPropertyOrFieldTypes;
   }
 
+  private AtomicReferenceArrayAssert<T> internalFilteredOn(String propertyOrFieldName, Object expectedValue) {
+    Iterable<? extends T> filteredIterable = filter(array).with(propertyOrFieldName, expectedValue).get();
+    return new AtomicReferenceArrayAssert<>(new AtomicReferenceArray<>(toArray(filteredIterable)));
+  }
+
+  private AtomicReferenceArrayAssert<T> internalFilteredOn(Predicate<? super T> predicate) {
+    checkArgument(predicate != null, "The filter predicate should not be null");
+    List<T> filteredList = stream(array).filter(predicate).collect(toList());
+    return new AtomicReferenceArrayAssert<>(new AtomicReferenceArray<>(toArray(filteredList)));
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index c1f4d5817..36c741b0d 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -211,7 +211,7 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errors.get(1)).hasMessageStartingWith(format("%nExpecting empty but was:<{\"54\"=\"55\"}>"));
   }
 
-  @SuppressWarnings({ "unchecked", "deprecation" })
+  @SuppressWarnings({ "unchecked" })
   @Test
   public void should_be_able_to_catch_exceptions_thrown_by_all_proxied_methods() throws MalformedURLException {
     try {
@@ -221,11 +221,11 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
       softly.assertThat(false).isTrue();
       softly.assertThat(new boolean[] { false }).isEqualTo(new boolean[] { true });
 
-      softly.assertThat(new Byte((byte) 0)).isEqualTo((byte) 1);
+      softly.assertThat(Byte.valueOf((byte) 0)).isEqualTo((byte) 1);
       softly.assertThat((byte) 2).inHexadecimal().isEqualTo((byte) 3);
       softly.assertThat(new byte[] { 4 }).isEqualTo(new byte[] { 5 });
 
-      softly.assertThat(new Character((char) 65)).isEqualTo(new Character((char) 66));
+      softly.assertThat(Character.valueOf((char) 65)).isEqualTo(Character.valueOf((char) 66));
       softly.assertThat((char) 67).isEqualTo((char) 68);
       softly.assertThat(new char[] { 69 }).isEqualTo(new char[] { 70 });
 
@@ -235,7 +235,7 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
 
       softly.assertThat(parseDatetime("1999-12-31T23:59:59")).isEqualTo(parseDatetime("2000-01-01T00:00:01"));
 
-      softly.assertThat(new Double(6.0d)).isEqualTo(new Double(7.0d));
+      softly.assertThat(Double.valueOf(6.0d)).isEqualTo(Double.valueOf(7.0d));
       softly.assertThat(8.0d).isEqualTo(9.0d);
       softly.assertThat(new double[] { 10.0d }).isEqualTo(new double[] { 11.0d });
 
@@ -243,14 +243,14 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
             .overridingErrorMessage(format("%nExpecting:%n <File(a)>%nto be equal to:%n <File(b)>%nbut was not."))
             .isEqualTo(new File("b"));
 
-      softly.assertThat(new Float(12f)).isEqualTo(new Float(13f));
+      softly.assertThat(Float.valueOf(12f)).isEqualTo(Float.valueOf(13f));
       softly.assertThat(14f).isEqualTo(15f);
       softly.assertThat(new float[] { 16f }).isEqualTo(new float[] { 17f });
 
       softly.assertThat(new ByteArrayInputStream(new byte[] { (byte) 65 }))
             .hasSameContentAs(new ByteArrayInputStream(new byte[] { (byte) 66 }));
 
-      softly.assertThat(new Integer(20)).isEqualTo(new Integer(21));
+      softly.assertThat(Integer.valueOf(20)).isEqualTo(Integer.valueOf(21));
       softly.assertThat(22).isEqualTo(23);
       softly.assertThat(new int[] { 24 }).isEqualTo(new int[] { 25 });
 
@@ -258,13 +258,13 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
       softly.assertThat(list("28").iterator()).isExhausted();
       softly.assertThat(list("30")).isEqualTo(Lists.newArrayList("31"));
 
-      softly.assertThat(new Long(32L)).isEqualTo(new Long(33L));
+      softly.assertThat(Long.valueOf(32L)).isEqualTo(Long.valueOf(33L));
       softly.assertThat(34L).isEqualTo(35L);
       softly.assertThat(new long[] { 36L }).isEqualTo(new long[] { 37L });
 
       softly.assertThat(mapOf(MapEntry.entry("38", "39"))).isEqualTo(mapOf(MapEntry.entry("40", "41")));
 
-      softly.assertThat(new Short((short) 42)).isEqualTo(new Short((short) 43));
+      softly.assertThat(Short.valueOf((short) 42)).isEqualTo(Short.valueOf((short) 43));
       softly.assertThat((short) 44).isEqualTo((short) 45);
       softly.assertThat(new short[] { (short) 46 }).isEqualTo(new short[] { (short) 47 });
 
@@ -749,33 +749,155 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
   @Test
   public void should_collect_all_errors_when_using_filtering() {
     // GIVEN
-    LinkedHashSet<CartoonCharacter> dads = newLinkedHashSet(homer, fred);
+    LinkedHashSet<CartoonCharacter> dadsList = newLinkedHashSet(homer, fred);
+    CartoonCharacter[] dadsArray = array(homer, fred);
+    AtomicReferenceArray<CartoonCharacter> atomicDadsArray = new AtomicReferenceArray<>(dadsArray);
     // WHEN
-    softly.assertThat(dads)
+    // iterables
+    softly.assertThat(dadsList)
           .filteredOn("name", "Homer Simpson")
+          .withFailMessage("list: property filter error 1")
           .hasSize(10)
+          .withFailMessage("list: property filter error 2")
           .isEmpty();
-    // THEN
-    List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(2);
-    assertThat(errorsCollected.get(0)).hasMessageStartingWith(format("%nExpected size:<10> but was:<1> in:%n<[CartoonCharacter [name=Homer Simpson]]>"));
-    assertThat(errorsCollected.get(1)).hasMessageStartingWith(format("%nExpecting empty but was:<[CartoonCharacter [name=Homer Simpson]]>"));
-  }
-
-  @Test
-  public void should_collect_all_errors_when_using_predicate_filtering() {
-    // GIVEN
-    LinkedHashSet<CartoonCharacter> dads = newLinkedHashSet(homer, fred);
-    // WHEN
-    softly.assertThat(dads)
+    softly.assertThat(dadsList)
+          .filteredOn("name", in("Homer Simpson"))
+          .withFailMessage("list: filter operator error 1")
+          .hasSize(10)
+          .withFailMessage("list: filter operator error 2")
+          .isEmpty();
+    softly.assertThat(dadsList)
+          .filteredOn(cartoonCharacter -> cartoonCharacter.getName().equals("Homer Simpson"))
+          .withFailMessage("list: predicate filter error 1")
+          .hasSize(10)
+          .withFailMessage("list: predicate filter error 2")
+          .isEmpty();
+    softly.assertThat(dadsList)
+          .filteredOn(CartoonCharacter::getName, "Homer Simpson")
+          .withFailMessage("list: function filter error 1")
+          .hasSize(10)
+          .withFailMessage("list: function filter error 2")
+          .isEmpty();
+    softly.assertThat(dadsList)
+          .filteredOn(new Condition<>(cartoonCharacter -> cartoonCharacter.getName().equals("Homer Simpson"), "startsWith Jo"))
+          .withFailMessage("list: Condition filter error 1")
+          .hasSize(10)
+          .withFailMessage("list: Condition filter error 2")
+          .isEmpty();
+    softly.assertThat(dadsList)
+          .filteredOnNull("name")
+          .withFailMessage("list: null filter error 1")
+          .hasSize(10)
+          .withFailMessage("list: null filter error 2")
+          .isNotEmpty();
+    softly.assertThat(dadsList)
+          .filteredOnAssertions(cartoonCharacter -> cartoonCharacter.getName().equals("Homer Simpson"))
+          .withFailMessage("list: assertion filter error 1")
+          .hasSize(10)
+          .withFailMessage("list: assertion filter error 2")
+          .isEmpty();
+    // array
+    softly.assertThat(dadsArray)
+          .filteredOn("name", "Homer Simpson")
+          .withFailMessage("array: property filter error 1")
+          .hasSize(10)
+          .withFailMessage("array: property filter error 2")
+          .isEmpty();
+    softly.assertThat(dadsArray)
+          .filteredOn("name", in("Homer Simpson"))
+          .withFailMessage("array: filter operator error 1")
+          .hasSize(10)
+          .withFailMessage("array: filter operator error 2")
+          .isEmpty();
+    softly.assertThat(dadsArray)
           .filteredOn(cartoonCharacter -> cartoonCharacter.getName().equals("Homer Simpson"))
+          .withFailMessage("array: predicate filter error 1")
           .hasSize(10)
+          .withFailMessage("array: predicate filter error 2")
           .isEmpty();
+    softly.assertThat(dadsArray)
+          .filteredOn(CartoonCharacter::getName, "Homer Simpson")
+          .withFailMessage("array: function filter error 1")
+          .hasSize(10)
+          .withFailMessage("array: function filter error 2")
+          .isEmpty();
+    softly.assertThat(dadsArray)
+          .filteredOn(new Condition<>(cartoonCharacter -> cartoonCharacter.getName().equals("Homer Simpson"), "startsWith Jo"))
+          .withFailMessage("array: Condition filter error 1")
+          .hasSize(10)
+          .withFailMessage("array: Condition filter error 2")
+          .isEmpty();
+    softly.assertThat(dadsArray)
+          .filteredOnNull("name")
+          .withFailMessage("array: null filter error 1")
+          .hasSize(10)
+          .withFailMessage("array: null filter error 2")
+          .isNotEmpty();
+    softly.assertThat(dadsArray)
+          .filteredOnAssertions(cartoonCharacter -> cartoonCharacter.getName().equals("Homer Simpson"))
+          .withFailMessage("array: assertion filter error 1")
+          .hasSize(10)
+          .withFailMessage("array: assertion filter error 2")
+          .isEmpty();
+    // atomic array
+    softly.assertThat(atomicDadsArray)
+          .filteredOn("name", "Homer Simpson")
+          .withFailMessage("atomic: property filter error 1")
+          .hasSize(10)
+          .withFailMessage("atomic: property filter error 2")
+          .isEmpty();
+    softly.assertThat(atomicDadsArray)
+          .filteredOn("name", in("Homer Simpson"))
+          .withFailMessage("atomic: filter operator error 1")
+          .hasSize(10)
+          .withFailMessage("atomic: filter operator error 2")
+          .isEmpty();
+    softly.assertThat(atomicDadsArray)
+          .filteredOn(cartoonCharacter -> cartoonCharacter.getName().equals("Homer Simpson"))
+          .withFailMessage("atomic: predicate filter error 1")
+          .hasSize(10)
+          .withFailMessage("atomic: predicate filter error 2")
+          .isEmpty();
+    softly.assertThat(atomicDadsArray)
+          .filteredOn(CartoonCharacter::getName, "Homer Simpson")
+          .withFailMessage("atomic: function filter error 1")
+          .hasSize(10)
+          .withFailMessage("atomic: function filter error 2")
+          .isEmpty();
+    softly.assertThat(atomicDadsArray)
+          .filteredOn(new Condition<>(cartoonCharacter -> cartoonCharacter.getName().equals("Homer Simpson"), "startsWith Jo"))
+          .withFailMessage("atomic: Condition filter error 1")
+          .hasSize(10)
+          .withFailMessage("atomic: Condition filter error 2")
+          .isEmpty();
+    softly.assertThat(atomicDadsArray)
+          .filteredOnNull("name")
+          .withFailMessage("atomic: null filter error 1")
+          .hasSize(10)
+          .withFailMessage("atomic: null filter error 2")
+          .isNotEmpty();
     // THEN
-    List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(2);
-    assertThat(errorsCollected.get(0)).hasMessageStartingWith(format("%nExpected size:<10> but was:<1> in:%n<[CartoonCharacter [name=Homer Simpson]]>"));
-    assertThat(errorsCollected.get(1)).hasMessageStartingWith(format("%nExpecting empty but was:<[CartoonCharacter [name=Homer Simpson]]>"));
+    assertThat(softly.errorsCollected()).extracting(Throwable::getMessage)
+                                        .containsExactly("list: property filter error 1", "list: property filter error 2",
+                                                         "list: filter operator error 1", "list: filter operator error 2",
+                                                         "list: predicate filter error 1", "list: predicate filter error 2",
+                                                         "list: function filter error 1", "list: function filter error 2",
+                                                         "list: Condition filter error 1", "list: Condition filter error 2",
+                                                         "list: null filter error 1", "list: null filter error 2",
+                                                         "list: assertion filter error 1", "list: assertion filter error 2",
+                                                         "array: property filter error 1", "array: property filter error 2",
+                                                         "array: filter operator error 1", "array: filter operator error 2",
+                                                         "array: predicate filter error 1", "array: predicate filter error 2",
+                                                         "array: function filter error 1", "array: function filter error 2",
+                                                         "array: Condition filter error 1", "array: Condition filter error 2",
+                                                         "array: null filter error 1", "array: null filter error 2",
+                                                         "array: assertion filter error 1", "array: assertion filter error 2",
+                                                         "atomic: property filter error 1", "atomic: property filter error 2",
+                                                         "atomic: filter operator error 1", "atomic: filter operator error 2",
+                                                         "atomic: predicate filter error 1", "atomic: predicate filter error 2",
+                                                         "atomic: function filter error 1", "atomic: function filter error 2",
+                                                         "atomic: Condition filter error 1", "atomic: Condition filter error 2",
+                                                         "atomic: null filter error 1", "atomic: null filter error 2");
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java b/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
index e42ed1dfc..bc8541d46 100644
--- a/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
@@ -19,14 +19,14 @@ import static org.assertj.core.api.Assumptions.assumeThat;
 import static org.assertj.core.api.assumptions.BaseAssumptionRunner.assumptionRunner;
 import static org.assertj.core.util.IterableUtil.iterable;
 
+import java.util.stream.Stream;
+
 import org.assertj.core.api.Condition;
 import org.assertj.core.api.IterableAssert;
 import org.assertj.core.api.ProxyableIterableAssert;
 import org.assertj.core.data.TolkienCharacter;
 import org.assertj.core.test.CartoonCharacter;
 
-import java.util.stream.Stream;
-
 /**
  * verify that assertions final methods or methods changing the object under test in {@link IterableAssert} work with assumptions
  * (i.e. that they are proxied correctly in {@link ProxyableIterableAssert}).
@@ -35,166 +35,176 @@ public class Iterable_special_assertion_methods_in_assumptions_Test extends Base
 
   public static Stream<AssumptionRunner<?>> provideAssumptionsRunners() {
     return Stream.of(
-        // extracting methods
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).extracting(throwingNameExtractor)
-                                      .contains("Frodo"),
-            value -> assumeThat(value).extracting(throwingNameExtractor)
-                                      .contains("Gandalf")),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).extracting(nameExtractor)
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extracting(nameExtractor)
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).extracting("name")
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extracting("name")
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).extracting("name", String.class)
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extracting("name", String.class)
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).extracting("name", "age")
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).extracting("name", "age")
-                                      .contains(tuple("Gandalf", 1000))),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
-                                      .contains(tuple("Gandalf", 1000))),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
-                                      .contains(tuple("Gandalf", 1000))),
-        // extractingResultOf methods
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).extractingResultOf("getName")
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extractingResultOf("getName")
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).extractingResultOf("getName", String.class)
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extractingResultOf("getName", String.class)
-                                      .contains("Gandalf", "Sam")),
-        // flatExtracting methods
-        assumptionRunner(iterable(homer, fred),
-            value -> assumeThat(value).flatExtracting("children")
-                                      .containsAnyOf(bart, lisa),
-            value -> assumeThat(value).flatExtracting("children")
-                                      .containsAnyOf(homer, fred)),
-        assumptionRunner(iterable(homer, fred),
-            value -> assumeThat(value).flatExtracting(childrenExtractor)
-                                      .containsAnyOf(bart, lisa),
-            value -> assumeThat(value).flatExtracting(childrenExtractor)
-                                      .containsAnyOf(homer, fred)),
-        assumptionRunner(iterable(homer, fred),
-            value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
-                                      .containsAnyOf(bart, lisa),
-            value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
-                                      .containsAnyOf(homer, fred)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).flatExtracting(throwingNameExtractor, throwingAgeExtractor)
-                                      .contains("Frodo", 33),
-            value -> assumeThat(value).flatExtracting(throwingNameExtractor, throwingAgeExtractor)
-                                      .contains("Gandalf", 1000)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).flatExtracting(nameExtractor, ageExtractor)
-                                      .contains("Frodo", 33),
-            value -> assumeThat(value).flatExtracting(nameExtractor, ageExtractor)
-                                      .contains("Gandalf", 1000)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).flatExtracting("name", "age")
-                                      .contains("Frodo", 33),
-            value -> assumeThat(value).flatExtracting("name", "age")
-                                      .contains("Gandalf", 1000)),
-        // filteredOn methods
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .contains(sam)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName().startsWith("Fro"), "startsWith Fro"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName().startsWith("Fro"), "startsWith Fro"))
-                                      .contains(sam)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
-                                      .contains(sam)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).filteredOn("name", "Frodo")
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn("name", "Frodo")
-                                      .contains(sam)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).filteredOnNull("name")
-                                      .isEmpty(),
-            value -> assumeThat(value).filteredOnNull("name")
-                                      .contains(sam)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
-                                      .contains(sam)),
-        assumptionRunner(iterable(frodo, sam),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .extracting("name", "age")
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .extracting("name", "age")
-                                      .contains(tuple("Sam", 35))),
-        // final methods
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).contains(1, 2),
-            value -> assumeThat(value).contains(4)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).containsAnyOf(1, 10, 20),
-            value -> assumeThat(value).containsAnyOf(0, 5, 10)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).containsExactly(1, 2, 3),
-            value -> assumeThat(value).containsExactly(4)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).containsExactlyInAnyOrder(2, 1, 3),
-            value -> assumeThat(value).containsExactlyInAnyOrder(1, 2)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).containsOnly(2, 1, 3, 2),
-            value -> assumeThat(value).containsOnly(1, 2, 4)),
-        assumptionRunner(iterable(2, 4, 2),
-            value -> assumeThat(value).containsOnlyOnce(4),
-            value -> assumeThat(value).containsOnlyOnce(2)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).containsSequence(1, 2),
-            value -> assumeThat(value).containsSequence(1, 3)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).containsSubsequence(1, 3),
-            value -> assumeThat(value).containsSubsequence(2, 1)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).doesNotContain(4, 5),
-            value -> assumeThat(value).doesNotContain(2, 1)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).doesNotContainSequence(1, 3),
-            value -> assumeThat(value).doesNotContainSequence(1, 2)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).doesNotContainSubsequence(2, 1),
-            value -> assumeThat(value).doesNotContainSubsequence(1, 3)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).isSubsetOf(1, 2, 3, 4),
-            value -> assumeThat(value).isSubsetOf(2, 4, 6)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).startsWith(1, 2),
-            value -> assumeThat(value).startsWith(2, 3)),
-        assumptionRunner(iterable(1, 2, 3),
-            value -> assumeThat(value).endsWith(2, 3),
-            value -> assumeThat(value).endsWith(2, 4))
-    );
+                     // extracting methods
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).extracting(throwingNameExtractor)
+                                                                .contains("Frodo"),
+                                      value -> assumeThat(value).extracting(throwingNameExtractor)
+                                                                .contains("Gandalf")),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).extracting(nameExtractor)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extracting(nameExtractor)
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).extracting("name")
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extracting("name")
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).extracting("name", String.class)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extracting("name", String.class)
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).extracting("name", "age")
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).extracting("name", "age")
+                                                                .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Gandalf", 1000))),
+                     // extractingResultOf methods
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).extractingResultOf("getName")
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extractingResultOf("getName")
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).extractingResultOf("getName", String.class)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extractingResultOf("getName", String.class)
+                                                                .contains("Gandalf", "Sam")),
+                     // flatExtracting methods
+                     assumptionRunner(iterable(homer, fred),
+                                      value -> assumeThat(value).flatExtracting("children")
+                                                                .containsAnyOf(bart, lisa),
+                                      value -> assumeThat(value).flatExtracting("children")
+                                                                .containsAnyOf(homer, fred)),
+                     assumptionRunner(iterable(homer, fred),
+                                      value -> assumeThat(value).flatExtracting(childrenExtractor)
+                                                                .containsAnyOf(bart, lisa),
+                                      value -> assumeThat(value).flatExtracting(childrenExtractor)
+                                                                .containsAnyOf(homer, fred)),
+                     assumptionRunner(iterable(homer, fred),
+                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
+                                                                .containsAnyOf(bart, lisa),
+                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
+                                                                .containsAnyOf(homer, fred)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).flatExtracting(throwingNameExtractor, throwingAgeExtractor)
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatExtracting(throwingNameExtractor, throwingAgeExtractor)
+                                                                .contains("Gandalf", 1000)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).flatExtracting(nameExtractor, ageExtractor)
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatExtracting(nameExtractor, ageExtractor)
+                                                                .contains("Gandalf", 1000)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).flatExtracting("name", "age")
+                                                                .contains("Frodo", 33),
+                                      value -> assumeThat(value).flatExtracting("name", "age")
+                                                                .contains("Gandalf", 1000)),
+                     // filteredOn methods
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .contains(sam)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName()
+                                                                                                        .startsWith("Fro"),
+                                                                                            "startsWith Fro"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName()
+                                                                                                        .startsWith("Fro"),
+                                                                                            "startsWith Fro"))
+                                                                .contains(sam)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                                                .contains(sam)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).filteredOn("name", "Frodo")
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn("name", "Frodo")
+                                                                .contains(sam)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).filteredOnNull("name")
+                                                                .isEmpty(),
+                                      value -> assumeThat(value).filteredOnNull("name")
+                                                                .contains(sam)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
+                                                                .contains(sam)),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Sam", 35))),
+                     assumptionRunner(iterable(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(TolkienCharacter::getName, "Frodo")
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName(), "Frodo")
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Sam", 35))),
+                     // final methods
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).contains(1, 2),
+                                      value -> assumeThat(value).contains(4)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).containsAnyOf(1, 10, 20),
+                                      value -> assumeThat(value).containsAnyOf(0, 5, 10)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).containsExactly(1, 2, 3),
+                                      value -> assumeThat(value).containsExactly(4)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).containsExactlyInAnyOrder(2, 1, 3),
+                                      value -> assumeThat(value).containsExactlyInAnyOrder(1, 2)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).containsOnly(2, 1, 3, 2),
+                                      value -> assumeThat(value).containsOnly(1, 2, 4)),
+                     assumptionRunner(iterable(2, 4, 2),
+                                      value -> assumeThat(value).containsOnlyOnce(4),
+                                      value -> assumeThat(value).containsOnlyOnce(2)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).containsSequence(1, 2),
+                                      value -> assumeThat(value).containsSequence(1, 3)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).containsSubsequence(1, 3),
+                                      value -> assumeThat(value).containsSubsequence(2, 1)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).doesNotContain(4, 5),
+                                      value -> assumeThat(value).doesNotContain(2, 1)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).doesNotContainSequence(1, 3),
+                                      value -> assumeThat(value).doesNotContainSequence(1, 2)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).doesNotContainSubsequence(2, 1),
+                                      value -> assumeThat(value).doesNotContainSubsequence(1, 3)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).isSubsetOf(1, 2, 3, 4),
+                                      value -> assumeThat(value).isSubsetOf(2, 4, 6)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).startsWith(1, 2),
+                                      value -> assumeThat(value).startsWith(2, 3)),
+                     assumptionRunner(iterable(1, 2, 3),
+                                      value -> assumeThat(value).endsWith(2, 3),
+                                      value -> assumeThat(value).endsWith(2, 4)));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/assumptions/ObjectArray_special_assertion_methods_in_assumptions_Test.java b/src/test/java/org/assertj/core/api/assumptions/ObjectArray_special_assertion_methods_in_assumptions_Test.java
index a9e6b7402..b297b11df 100644
--- a/src/test/java/org/assertj/core/api/assumptions/ObjectArray_special_assertion_methods_in_assumptions_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/ObjectArray_special_assertion_methods_in_assumptions_Test.java
@@ -19,165 +19,176 @@ import static org.assertj.core.api.Assumptions.assumeThat;
 import static org.assertj.core.api.assumptions.BaseAssumptionRunner.assumptionRunner;
 import static org.assertj.core.util.Arrays.array;
 
+import java.util.stream.Stream;
+
 import org.assertj.core.api.Condition;
 import org.assertj.core.api.ObjectArrayAssert;
 import org.assertj.core.api.ProxyableObjectArrayAssert;
 import org.assertj.core.data.TolkienCharacter;
 import org.assertj.core.test.CartoonCharacter;
 
-import java.util.stream.Stream;
-
 /**
  * verify that assertions final methods or methods changing the object under test in {@link ObjectArrayAssert} work with assumptions
  * (i.e. that they are proxied correctly in {@link ProxyableObjectArrayAssert}).
  */
 public class ObjectArray_special_assertion_methods_in_assumptions_Test extends BaseAssumptionsRunnerTest {
 
+  @SuppressWarnings("unchecked")
   public static Stream<AssumptionRunner<?>> provideAssumptionsRunners() {
     return Stream.of(
-        // extracting methods
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).extracting(throwingNameExtractor)
-                                      .contains("Frodo"),
-            value -> assumeThat(value).extracting(throwingNameExtractor)
-                                      .contains("Gandalf")),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).extracting(nameExtractor)
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extracting(nameExtractor)
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).extracting("name")
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extracting("name")
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).extracting("name", String.class)
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extracting("name", String.class)
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).extracting("name", "age")
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).extracting("name", "age")
-                                      .contains(tuple("Gandalf", 1000))),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
-                                      .contains(tuple("Gandalf", 1000))),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
-                                      .contains(tuple("Gandalf", 1000))),
-        // extractingResultOf methods
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).extractingResultOf("getName")
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extractingResultOf("getName")
-                                      .contains("Gandalf", "Sam")),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).extractingResultOf("getName", String.class)
-                                      .contains("Frodo", "Sam"),
-            value -> assumeThat(value).extractingResultOf("getName", String.class)
-                                      .contains("Gandalf", "Sam")),
-        // flatExtracting methods
-        assumptionRunner(array(homer, fred),
-            value -> assumeThat(value).flatExtracting("children")
-                                      .containsAnyOf(bart, lisa),
-            value -> assumeThat(value).flatExtracting("children")
-                                      .containsAnyOf(homer, fred)),
-        assumptionRunner(array(homer, fred),
-            value -> assumeThat(value).flatExtracting(childrenExtractor)
-                                      .containsAnyOf(bart, lisa),
-            value -> assumeThat(value).flatExtracting(childrenExtractor)
-                                      .containsAnyOf(homer, fred)),
-        assumptionRunner(array(homer, fred),
-            value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
-                                      .containsAnyOf(bart, lisa),
-            value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
-                                      .containsAnyOf(homer, fred)),
-        // filteredOn methods
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .contains(sam)),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName().startsWith("Fro"), "startsWith Fro"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName().startsWith("Fro"), "startsWith Fro"))
-                                      .contains(sam)),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).filteredOn("name", "Frodo")
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn("name", "Frodo")
-                                      .contains(sam)),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).filteredOnNull("name")
-                                      .isEmpty(),
-            value -> assumeThat(value).filteredOnNull("name")
-                                      .contains(sam)),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
-                                      .contains(sam)),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .extracting("name", "age")
-                                      .contains(tuple("Frodo", 33)),
-            value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
-                                      .extracting("name", "age")
-                                      .contains(tuple("Sam", 35))),
-        assumptionRunner(array(frodo, sam),
-            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
-                                      .contains(frodo),
-            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
-                                      .contains(sam)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).contains(1, 2),
-            value -> assumeThat(value).contains(4)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).containsAnyOf(1, 10, 20),
-            value -> assumeThat(value).containsAnyOf(0, 5, 10)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).containsExactly(1, 2, 3),
-            value -> assumeThat(value).containsExactly(4)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).containsExactlyInAnyOrder(2, 1, 3),
-            value -> assumeThat(value).containsExactlyInAnyOrder(1, 2)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).containsOnly(2, 1, 3, 2),
-            value -> assumeThat(value).containsOnly(1, 2, 4)),
-        assumptionRunner(array(2, 4, 2),
-            value -> assumeThat(value).containsOnlyOnce(4),
-            value -> assumeThat(value).containsOnlyOnce(2)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).containsSequence(1, 2),
-            value -> assumeThat(value).containsSequence(1, 3)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).containsSubsequence(1, 3),
-            value -> assumeThat(value).containsSubsequence(2, 1)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).doesNotContain(4, 5),
-            value -> assumeThat(value).doesNotContain(2, 1)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).doesNotContainSequence(1, 3),
-            value -> assumeThat(value).doesNotContainSequence(1, 2)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).doesNotContainSubsequence(2, 1),
-            value -> assumeThat(value).doesNotContainSubsequence(1, 3)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).isSubsetOf(1, 2, 3, 4),
-            value -> assumeThat(value).isSubsetOf(2, 4, 6)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).startsWith(1, 2),
-            value -> assumeThat(value).startsWith(2, 3)),
-        assumptionRunner(array(1, 2, 3),
-            value -> assumeThat(value).endsWith(2, 3),
-            value -> assumeThat(value).endsWith(2, 4))
-    );
+                     // extracting methods
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).extracting(throwingNameExtractor)
+                                                                .contains("Frodo"),
+                                      value -> assumeThat(value).extracting(throwingNameExtractor)
+                                                                .contains("Gandalf")),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).extracting(nameExtractor)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extracting(nameExtractor)
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).extracting("name")
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extracting("name")
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).extracting("name", String.class)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extracting("name", String.class)
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).extracting("name", "age")
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).extracting("name", "age")
+                                                                .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).extracting(nameExtractorFunction, ageExtractorFunction)
+                                                                .contains(tuple("Gandalf", 1000))),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).extracting(TolkienCharacter::getName, TolkienCharacter::getAge)
+                                                                .contains(tuple("Gandalf", 1000))),
+                     // extractingResultOf methods
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).extractingResultOf("getName")
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extractingResultOf("getName")
+                                                                .contains("Gandalf", "Sam")),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).extractingResultOf("getName", String.class)
+                                                                .contains("Frodo", "Sam"),
+                                      value -> assumeThat(value).extractingResultOf("getName", String.class)
+                                                                .contains("Gandalf", "Sam")),
+                     // flatExtracting methods
+                     assumptionRunner(array(homer, fred),
+                                      value -> assumeThat(value).flatExtracting("children")
+                                                                .containsAnyOf(bart, lisa),
+                                      value -> assumeThat(value).flatExtracting("children")
+                                                                .containsAnyOf(homer, fred)),
+                     assumptionRunner(array(homer, fred),
+                                      value -> assumeThat(value).flatExtracting(childrenExtractor)
+                                                                .containsAnyOf(bart, lisa),
+                                      value -> assumeThat(value).flatExtracting(childrenExtractor)
+                                                                .containsAnyOf(homer, fred)),
+                     assumptionRunner(array(homer, fred),
+                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
+                                                                .containsAnyOf(bart, lisa),
+                                      value -> assumeThat(value).flatExtracting(CartoonCharacter::getChildren)
+                                                                .containsAnyOf(homer, fred)),
+                     // filteredOn methods
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .contains(sam)),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName()
+                                                                                                        .startsWith("Fro"),
+                                                                                            "startsWith Fro"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName()
+                                                                                                        .startsWith("Fro"),
+                                                                                            "startsWith Fro"))
+                                                                .contains(sam)),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).filteredOn("name", "Frodo")
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn("name", "Frodo")
+                                                                .contains(sam)),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).filteredOnNull("name")
+                                                                .isEmpty(),
+                                      value -> assumeThat(value).filteredOnNull("name")
+                                                                .contains(sam)),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOn("name", in("John", "Frodo"))
+                                                                .contains(sam)),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Sam", 35))),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                                                .contains(frodo),
+                                      value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                                                .contains(sam)),
+                     assumptionRunner(array(frodo, sam),
+                                      value -> assumeThat(value).filteredOn(TolkienCharacter::getName, "Frodo")
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Frodo", 33)),
+                                      value -> assumeThat(value).filteredOn(hero -> hero.getName(), "Frodo")
+                                                                .extracting("name", "age")
+                                                                .contains(tuple("Sam", 35))),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).contains(1, 2),
+                                      value -> assumeThat(value).contains(4)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).containsAnyOf(1, 10, 20),
+                                      value -> assumeThat(value).containsAnyOf(0, 5, 10)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).containsExactly(1, 2, 3),
+                                      value -> assumeThat(value).containsExactly(4)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).containsExactlyInAnyOrder(2, 1, 3),
+                                      value -> assumeThat(value).containsExactlyInAnyOrder(1, 2)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).containsOnly(2, 1, 3, 2),
+                                      value -> assumeThat(value).containsOnly(1, 2, 4)),
+                     assumptionRunner(array(2, 4, 2),
+                                      value -> assumeThat(value).containsOnlyOnce(4),
+                                      value -> assumeThat(value).containsOnlyOnce(2)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).containsSequence(1, 2),
+                                      value -> assumeThat(value).containsSequence(1, 3)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).containsSubsequence(1, 3),
+                                      value -> assumeThat(value).containsSubsequence(2, 1)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).doesNotContain(4, 5),
+                                      value -> assumeThat(value).doesNotContain(2, 1)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).doesNotContainSequence(1, 3),
+                                      value -> assumeThat(value).doesNotContainSequence(1, 2)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).doesNotContainSubsequence(2, 1),
+                                      value -> assumeThat(value).doesNotContainSubsequence(1, 3)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).isSubsetOf(1, 2, 3, 4),
+                                      value -> assumeThat(value).isSubsetOf(2, 4, 6)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).startsWith(1, 2),
+                                      value -> assumeThat(value).startsWith(2, 3)),
+                     assumptionRunner(array(1, 2, 3),
+                                      value -> assumeThat(value).endsWith(2, 3),
+                                      value -> assumeThat(value).endsWith(2, 4)));
   }
 }
diff --git a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_Test.java b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_Test.java
index 96a845a6e..fd067b314 100644
--- a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_Test.java
+++ b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_Test.java
@@ -20,6 +20,7 @@ import static org.assertj.core.api.Assertions.in;
 import static org.assertj.core.api.Assertions.not;
 import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
 
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.jupiter.api.Test;
 
@@ -72,7 +73,7 @@ public class AtomicReferenceArrayAssert_filteredOn_Test extends AtomicReferenceA
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, 800))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, 800))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
@@ -91,17 +92,14 @@ public class AtomicReferenceArrayAssert_filteredOn_Test extends AtomicReferenceA
 
   @Test
   public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret",
-                                                                                                          "???"))
+    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret", "???"))
                                                        .withMessageContaining("Can't find any field or property with name 'secret'");
   }
 
   @Test
   public void should_fail_if_filter_operators_are_combined() {
-    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> assertThat(employees).filteredOn("age",
-                                                                                                                     not(in(800)))
-                                                                                                         .containsOnly(luke,
-                                                                                                                       noname))
+    ThrowingCallable code = () -> assertThat(employees).filteredOn("age", not(in(800))).containsOnly(luke, noname);
+    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(code)
                                                                   .withMessageStartingWith("Combining operator is not supported");
   }
 }
diff --git a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_condition_Test.java b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_condition_Test.java
index 13f7c5abb..4abadb2e6 100644
--- a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_condition_Test.java
+++ b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_condition_Test.java
@@ -49,7 +49,8 @@ public class AtomicReferenceArrayAssert_filteredOn_condition_Test extends Atomic
 
   @Test
   public void should_fail_if_given_condition_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null))
+    Condition<Employee> condition = null;
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(condition))
                                         .withMessage("The filter condition should not be null");
   }
 
diff --git a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_function_Test.java b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_function_Test.java
new file mode 100644
index 000000000..6d752ca8b
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_function_Test.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.atomic.referencearray;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
+import static org.assertj.core.test.Name.lastNameComparator;
+import static org.assertj.core.test.Name.name;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.function.Function;
+
+import org.assertj.core.api.IterableAssert;
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.Name;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("AtomicReferenceArrayAssert filteredOn function")
+class AtomicReferenceArrayAssert_filteredOn_function_Test extends AtomicReferenceArrayAssert_filtered_baseTest {
+
+  @Test
+  void should_filter_object_array_under_test_on_function_result_equals_to_given_value() {
+    assertThat(employees).filteredOn(Employee::getAge, 800)
+                         .containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  void should_filter_object_array_under_test_on_function_result_equals_to_null() {
+    assertThat(employees).filteredOn(Employee::getName, null)
+                         .containsOnly(noname);
+  }
+
+  @Test
+  void should_fail_if_given_function_is_null() {
+    // GIVEN
+    Function<? super Employee, String> function = null;
+    // WHEN/THEN
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(function, "Yoda"))
+                                        .withMessage("The filter function should not be null");
+  }
+
+  @Test
+  void should_pass_keep_assertion_state() {
+    // GIVEN
+    Iterable<Name> names = list(name("Manu", "Ginobili"), name("Magic", "Johnson"));
+    // WHEN
+    IterableAssert<Name> assertion = assertThat(names).as("test description")
+                                                      .withFailMessage("error message")
+                                                      .withRepresentation(UNICODE_REPRESENTATION)
+                                                      .usingElementComparator(lastNameComparator)
+                                                      .filteredOn(Name::getFirst, "Manu")
+                                                      .containsExactly(name("Whoever", "Ginobili"));
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_in_Test.java b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_in_Test.java
index c202f54cf..97c3fe891 100644
--- a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_in_Test.java
+++ b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_in_Test.java
@@ -71,7 +71,7 @@ public class AtomicReferenceArrayAssert_filteredOn_in_Test extends AtomicReferen
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, in(800)))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, in(800)))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
diff --git a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_notIn_Test.java b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_notIn_Test.java
index 4e548ca2b..5ee1e0a7b 100644
--- a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_notIn_Test.java
+++ b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_notIn_Test.java
@@ -74,7 +74,7 @@ public class AtomicReferenceArrayAssert_filteredOn_notIn_Test extends AtomicRefe
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, notIn(800)))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, notIn(800)))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
diff --git a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_not_Test.java b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_not_Test.java
index 842796bff..ad22187a4 100644
--- a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_not_Test.java
+++ b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_not_Test.java
@@ -50,9 +50,8 @@ public class AtomicReferenceArrayAssert_filteredOn_not_Test extends AtomicRefere
   public void should_fail_if_filter_is_on_private_field_and_reading_private_field_is_disabled() {
     setAllowExtractingPrivateFields(false);
     try {
-      assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> {
-        assertThat(employees).filteredOn("city", not("New York"));
-      });
+      assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("city",
+                                                                                                            not("New York")));
     } finally {
       setAllowExtractingPrivateFields(true);
     }
@@ -71,7 +70,7 @@ public class AtomicReferenceArrayAssert_filteredOn_not_Test extends AtomicRefere
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, not(800)))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, not(800)))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
@@ -90,8 +89,7 @@ public class AtomicReferenceArrayAssert_filteredOn_not_Test extends AtomicRefere
 
   @Test
   public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret",
-                                                                                                          not("???")))
+    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret", not("???")))
                                                        .withMessageContaining("Can't find any field or property with name 'secret'");
   }
 }
diff --git a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_predicate_Test.java b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_predicate_Test.java
new file mode 100644
index 000000000..dcd0ef188
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_filteredOn_predicate_Test.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.atomic.referencearray;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+
+import java.util.function.Predicate;
+
+import org.assertj.core.test.Employee;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("AtomicReferenceArrayAssert filteredOn predicate")
+class AtomicReferenceArrayAssert_filteredOn_predicate_Test extends AtomicReferenceArrayAssert_filtered_baseTest {
+
+  @Test
+  void should_filter_iterable_under_test_on_predicate() {
+    assertThat(employees).filteredOn(employee -> employee.getAge() > 100)
+                         .containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  void should_fail_if_given_predicate_is_null() {
+    Predicate<? super Employee> predicate = null;
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(predicate))
+                                        .withMessage("The filter predicate should not be null");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_Test.java
index 6308e7f7b..d53d56440 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_Test.java
@@ -28,6 +28,7 @@ import static org.assertj.core.util.Sets.newHashSet;
 import java.util.Set;
 
 import org.assertj.core.api.IterableAssert;
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.data.TolkienCharacter;
 import org.assertj.core.data.TolkienCharacterAssert;
 import org.assertj.core.data.TolkienCharacterAssertFactory;
@@ -98,7 +99,7 @@ public class IterableAssert_filteredOn_Test extends IterableAssert_filtered_base
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, 800))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, 800))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
@@ -117,17 +118,14 @@ public class IterableAssert_filteredOn_Test extends IterableAssert_filtered_base
 
   @Test
   public void should_fail_if_on_of_the_iterable_element_does_not_have_given_property_or_field() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret",
-                                                                                                          "???"))
+    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret", "???"))
                                                        .withMessageContaining("Can't find any field or property with name 'secret'");
   }
 
   @Test
   public void should_fail_if_filter_operators_are_combined() {
-    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> assertThat(employees).filteredOn("age",
-                                                                                                                     not(in(800)))
-                                                                                                         .containsOnly(luke,
-                                                                                                                       noname))
+    ThrowingCallable code = () -> assertThat(employees).filteredOn("age", not(in(800))).containsOnly(luke, noname);
+    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(code)
                                                                   .withMessageStartingWith("Combining operator is not supported");
   }
 
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_function_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_function_Test.java
new file mode 100644
index 000000000..2d8e9b78c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_function_Test.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
+import static org.assertj.core.test.Name.lastNameComparator;
+import static org.assertj.core.test.Name.name;
+import static org.assertj.core.util.Sets.newHashSet;
+
+import java.util.function.Function;
+
+import org.assertj.core.api.IterableAssert;
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.Name;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("IterableAssert filteredOn function")
+class IterableAssert_filteredOn_function_Test extends IterableAssert_filtered_baseTest {
+
+  @Test
+  void should_filter_object_array_under_test_on_function_result_equals_to_given_value() {
+    assertThat(employees).filteredOn(Employee::getAge, 800)
+                         .containsOnly(yoda, obiwan);
+    assertThat(newHashSet(employees)).filteredOn(Employee::getAge, 800)
+                                     .containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  void should_filter_object_array_under_test_on_function_result_equals_to_null() {
+    assertThat(employees).filteredOn(Employee::getName, null)
+                         .containsOnly(noname);
+  }
+
+  @Test
+  void should_fail_if_given_function_is_null() {
+    // GIVEN
+    Function<? super Employee, String> function = null;
+    // WHEN/THEN
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(function, "Yoda"))
+                                        .withMessage("The filter function should not be null");
+  }
+
+  @Test
+  void should_pass_keep_assertion_state() {
+    // GIVEN
+    Iterable<Name> names = asList(name("Manu", "Ginobili"), name("Magic", "Johnson"));
+    // WHEN
+    IterableAssert<Name> assertion = assertThat(names).as("test description")
+                                                      .withFailMessage("error message")
+                                                      .withRepresentation(UNICODE_REPRESENTATION)
+                                                      .usingElementComparator(lastNameComparator)
+                                                      .filteredOn(Name::getFirst, "Manu")
+                                                      .containsExactly(name("Whoever", "Ginobili"));
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_in_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_in_Test.java
index 030b7f022..673d8a69c 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_in_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_in_Test.java
@@ -80,7 +80,7 @@ public class IterableAssert_filteredOn_in_Test extends IterableAssert_filtered_b
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, in(800)))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, in(800)))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
@@ -92,8 +92,7 @@ public class IterableAssert_filteredOn_in_Test extends IterableAssert_filtered_b
 
   @Test
   public void should_fail_if_on_of_the_iterable_element_does_not_have_given_property_or_field() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret",
-                                                                                                          in("???")))
+    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret", in("???")))
                                                        .withMessageContaining("Can't find any field or property with name 'secret'");
   }
 
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_notIn_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_notIn_Test.java
index 91df9b3f5..a19f42c66 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_notIn_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_notIn_Test.java
@@ -80,7 +80,7 @@ public class IterableAssert_filteredOn_notIn_Test extends IterableAssert_filtere
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, notIn(800)))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, notIn(800)))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_not_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_not_Test.java
index 3bcef5cea..6fc2311ee 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_not_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_not_Test.java
@@ -83,7 +83,7 @@ public class IterableAssert_filteredOn_not_Test extends IterableAssert_filtered_
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, not(800)))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, not(800)))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
@@ -102,8 +102,7 @@ public class IterableAssert_filteredOn_not_Test extends IterableAssert_filtered_
 
   @Test
   public void should_fail_if_on_of_the_iterable_element_does_not_have_given_property_or_field() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret",
-                                                                                                          not("???")))
+    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret", not("???")))
                                                        .withMessageContaining("Can't find any field or property with name 'secret'");
   }
 
diff --git a/src/test/java/org/assertj/core/api/list/ListAssert_filteredOn_function_with_navigation_Test.java b/src/test/java/org/assertj/core/api/list/ListAssert_filteredOn_function_with_navigation_Test.java
new file mode 100644
index 000000000..1052c82ec
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/list/ListAssert_filteredOn_function_with_navigation_Test.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.list;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.assertj.core.data.TolkienCharacter;
+import org.assertj.core.data.TolkienCharacterAssert;
+import org.assertj.core.data.TolkienCharacterAssertFactory;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("ListAssert filteredOn function with navigation")
+class ListAssert_filteredOn_function_with_navigation_Test extends ListAssert_filteredOn_BaseTest {
+
+  @Test
+  void should_honor_AssertFactory_strongly_typed_navigation_assertions() {
+    // GIVEN
+    Iterable<TolkienCharacter> hobbits = hobbits();
+    TolkienCharacterAssertFactory tolkienCharacterAssertFactory = new TolkienCharacterAssertFactory();
+    // WHEN/THEN
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOn(TolkienCharacter::getName, "Frodo")
+                                                      .first()
+                                                      .hasAge(33);
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOn(TolkienCharacter::getName, "Frodo")
+                                                      .last()
+                                                      .hasAge(33);
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOn(TolkienCharacter::getName, "Frodo")
+                                                      .element(0)
+                                                      .hasAge(33);
+  }
+
+  @Test
+  void should_honor_class_based_strongly_typed_navigation_assertions() {
+    // GIVEN
+    Iterable<TolkienCharacter> hobbits = hobbits();
+    // WHEN/THEN
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOn(TolkienCharacter::getName, "Frodo")
+                                                     .first()
+                                                     .hasAge(33);
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOn(TolkienCharacter::getName, "Frodo")
+                                                     .last()
+                                                     .hasAge(33);
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOn(TolkienCharacter::getName, "Frodo")
+                                                     .element(0)
+                                                     .hasAge(33);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_Test.java
index 5335b1b46..4c283bbca 100644
--- a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_Test.java
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_Test.java
@@ -20,6 +20,7 @@ import static org.assertj.core.api.Assertions.in;
 import static org.assertj.core.api.Assertions.not;
 import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
 
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.jupiter.api.Test;
 
@@ -72,7 +73,7 @@ public class ObjectArrayAssert_filteredOn_Test extends ObjectArrayAssert_filtere
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, 800))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, 800))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
@@ -91,17 +92,14 @@ public class ObjectArrayAssert_filteredOn_Test extends ObjectArrayAssert_filtere
 
   @Test
   public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret",
-                                                                                                          "???"))
+    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret", "???"))
                                                        .withMessageContaining("Can't find any field or property with name 'secret'");
   }
 
   @Test
   public void should_fail_if_filter_operators_are_combined() {
-    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> assertThat(employees).filteredOn("age",
-                                                                                                                     not(in(800)))
-                                                                                                         .containsOnly(luke,
-                                                                                                                       noname))
+    ThrowingCallable code = () -> assertThat(employees).filteredOn("age", not(in(800))).containsOnly(luke, noname);
+    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(code)
                                                                   .withMessageStartingWith("Combining operator is not supported");
   }
 }
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_function_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_function_Test.java
new file mode 100644
index 000000000..15d738d2b
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_function_Test.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.objectarray;
+
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
+import static org.assertj.core.test.Name.lastNameComparator;
+import static org.assertj.core.test.Name.name;
+
+import java.util.function.Function;
+
+import org.assertj.core.api.IterableAssert;
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.Name;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("ObjectArrayAssert filteredOn function")
+class ObjectArrayAssert_filteredOn_function_Test extends ObjectArrayAssert_filtered_baseTest {
+
+  @Test
+  void should_filter_object_array_under_test_on_function_result_equals_to_given_value() {
+    assertThat(employees).filteredOn(Employee::getAge, 800)
+                         .containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  void should_filter_object_array_under_test_on_function_result_equals_to_null() {
+    assertThat(employees).filteredOn(Employee::getName, null)
+                         .containsOnly(noname);
+  }
+
+  @Test
+  void should_fail_if_given_function_is_null() {
+    // GIVEN
+    Function<? super Employee, String> function = null;
+    // WHEN/THEN
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(function, "Yoda"))
+                                        .withMessage("The filter function should not be null");
+  }
+
+  @Test
+  void should_pass_keep_assertion_state() {
+    // GIVEN
+    Iterable<Name> names = asList(name("Manu", "Ginobili"), name("Magic", "Johnson"));
+    // WHEN
+    IterableAssert<Name> assertion = assertThat(names).as("test description")
+                                                      .withFailMessage("error message")
+                                                      .withRepresentation(UNICODE_REPRESENTATION)
+                                                      .usingElementComparator(lastNameComparator)
+                                                      .filteredOn(Name::getFirst, "Manu")
+                                                      .containsExactly(name("Whoever", "Ginobili"));
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_in_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_in_Test.java
index d5b3507df..91cc1d3e3 100644
--- a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_in_Test.java
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_in_Test.java
@@ -71,7 +71,7 @@ public class ObjectArrayAssert_filteredOn_in_Test extends ObjectArrayAssert_filt
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, in(800)))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, in(800)))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
@@ -83,8 +83,7 @@ public class ObjectArrayAssert_filteredOn_in_Test extends ObjectArrayAssert_filt
 
   @Test
   public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret",
-                                                                                                          in("???")))
+    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret", in("???")))
                                                        .withMessageContaining("Can't find any field or property with name 'secret'");
   }
 
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_notIn_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_notIn_Test.java
index 5ba5e7727..7fa83d49f 100644
--- a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_notIn_Test.java
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_notIn_Test.java
@@ -74,7 +74,7 @@ public class ObjectArrayAssert_filteredOn_notIn_Test extends ObjectArrayAssert_f
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, notIn(800)))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, notIn(800)))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
@@ -86,8 +86,7 @@ public class ObjectArrayAssert_filteredOn_notIn_Test extends ObjectArrayAssert_f
 
   @Test
   public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret",
-                                                                                                          notIn("???")))
+    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret", notIn("???")))
                                                        .withMessageContaining("Can't find any field or property with name 'secret'");
   }
 
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_not_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_not_Test.java
index cb25e37db..30f40c330 100644
--- a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_not_Test.java
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_not_Test.java
@@ -71,7 +71,7 @@ public class ObjectArrayAssert_filteredOn_not_Test extends ObjectArrayAssert_fil
 
   @Test
   public void should_fail_if_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn(null, not(800)))
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(employees).filteredOn((String) null, not(800)))
                                         .withMessage("The property/field name to filter on should not be null or empty");
   }
 
@@ -90,8 +90,7 @@ public class ObjectArrayAssert_filteredOn_not_Test extends ObjectArrayAssert_fil
 
   @Test
   public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret",
-                                                                                                          not("???")))
+    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> assertThat(employees).filteredOn("secret", not("???")))
                                                        .withMessageContaining("Can't find any field or property with name 'secret'");
   }
 }
