diff --git a/src/main/java/org/assertj/core/api/AbstractPathAssert.java b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
index 68fca97f8..5764449a7 100644
--- a/src/main/java/org/assertj/core/api/AbstractPathAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
@@ -12,9 +12,12 @@
  */
 package org.assertj.core.api;
 
+import static java.lang.String.format;
+import static java.nio.file.Files.readAllBytes;
 import static java.util.Objects.requireNonNull;
 import static org.assertj.core.util.Preconditions.checkArgument;
 
+import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.nio.charset.Charset;
 import java.nio.file.ClosedFileSystemException;
@@ -1812,4 +1815,62 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
     return myself;
   }
 
+  /**
+   * Returns String assertions on the content of the actual {@code Path} read with the {@link Charset#defaultCharset() default charset}.
+   * <p>
+   * Example:
+   * <pre><code class='java'> Path xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes());
+   *
+   * // assertion succeeds (default charset is used to read xFile content):
+   * assertThat(xFile).content().startsWith("The Truth Is ");
+   *
+   * // assertion fails:
+   * assertThat(xFile).content().contains("Elsewhere");</code></pre>
+   *
+   * @return a StringAssert object with the content of the actual {@code Path} read with the default {@link Charset}.
+   * @throws AssertionError if the actual {@code Path} is not readable as per {@link Files#isReadable(Path)}.
+   * @throws UncheckedIOException when failing to read the actual {@code Path}.
+   * @since 3.21.0
+   */
+  public AbstractStringAssert<?> content() {
+    // does not call content(Charset.defaultCharset()) to avoid double proxying in soft assertions.
+    return internalContent(Charset.defaultCharset());
+  }
+
+  /**
+   * Returns String assertions on the content of the actual {@code Path} read with the given {@link Charset}.
+   * <p>
+   * Example:
+   * <pre><code class='java'> Path utf8Path = Files.write(Paths.get("utf8.txt"), "é à".getBytes());
+   *
+   * // assertion succeeds:
+   * assertThat(utf8Path).content(StandardCharsets.UTF_8).endsWith("é à");
+   *
+   * // assertion fails:
+   * assertThat(utf8Path).content(StandardCharsets.UTF_8).contains("e");</code></pre>
+   *
+   * @param charset the {@link Charset} to use to read the actual {@link Path}.
+   * @return a {@link StringAssert} object with the content of the actual {@code Path} read with the default {@link Charset}.
+   * @throws AssertionError if the actual {@code Path} is not readable as per {@link Files#isReadable(Path)}.
+   * @throws UncheckedIOException when failing to read the actual {@code Path}.
+   * @since 3.21.0
+   */
+  public AbstractStringAssert<?> content(Charset charset) {
+    return internalContent(charset);
+  }
+
+  // this method was introduced to avoid to avoid double proxying in soft assertions for content()
+  private AbstractStringAssert<?> internalContent(Charset charset) {
+    paths.assertIsReadable(info, actual);
+    String pathContent = readPath(charset);
+    return new StringAssert(pathContent);
+  }
+
+  private String readPath(Charset charset) {
+    try {
+      return new String(readAllBytes(actual), charset);
+    } catch (IOException e) {
+      throw new UncheckedIOException(format("Failed to read %s content with %s charset", actual, charset), e);
+    }
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/SoftProxies.java b/src/main/java/org/assertj/core/api/SoftProxies.java
index 08e0b2377..fe686edfa 100644
--- a/src/main/java/org/assertj/core/api/SoftProxies.java
+++ b/src/main/java/org/assertj/core/api/SoftProxies.java
@@ -46,6 +46,7 @@ class SoftProxies {
                                                                                                                                    "asList",
                                                                                                                                    "asString",
                                                                                                                                    "asHexString",
+                                                                                                                                   "content",
                                                                                                                                    "decodedAsBase64",
                                                                                                                                    "encodedAsBase64",
                                                                                                                                    "extracting",
diff --git a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
index c834d0e79..93295c309 100644
--- a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
@@ -13,6 +13,7 @@
 package org.assertj.core.api;
 
 import static java.lang.String.format;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.Collections.emptyList;
 import static java.util.Spliterators.emptySpliterator;
 import static java.util.stream.Collectors.toList;
@@ -23,6 +24,7 @@ import static org.assertj.core.api.Assertions.catchThrowableOfType;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.Assertions.in;
 import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.InstanceOfAssertFactories.STRING;
 import static org.assertj.core.api.InstanceOfAssertFactories.THROWABLE;
 import static org.assertj.core.api.SoftAssertions.assertSoftly;
@@ -42,6 +44,7 @@ import java.io.File;
 import java.math.BigDecimal;
 import java.net.MalformedURLException;
 import java.net.URI;
+import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.time.Duration;
 import java.time.Instant;
@@ -1845,4 +1848,26 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
     }
   }
 
+  @Test
+  void path_soft_assertions_should_report_errors_on_methods_that_switch_the_object_under_test() {
+    // GIVEN
+    Path path = new File("src/test/resources/actual_file.txt").toPath();
+    // WHEN
+    softly.then(path)
+          .overridingErrorMessage("error message")
+          .as("content()")
+          .content()
+          .startsWith("actual")
+          .startsWith("123");
+    softly.then(path)
+          .overridingErrorMessage("error message")
+          .as("content(UTF_8)")
+          .content(UTF_8)
+          .startsWith("actual")
+          .startsWith("123");
+    // THEN
+    then(softly.errorsCollected()).extracting(Throwable::getMessage)
+                                  .containsExactly("[content()] error message",
+                                                   "[content(UTF_8)] error message");
+  }
 }
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index 5ca83dfbf..c695cba57 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -13,6 +13,7 @@
 package org.assertj.core.api;
 
 import static java.lang.String.format;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.Collections.emptyList;
 import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.Assertions.as;
@@ -46,6 +47,7 @@ import java.io.File;
 import java.math.BigDecimal;
 import java.net.MalformedURLException;
 import java.net.URI;
+import java.nio.file.Path;
 import java.time.Duration;
 import java.time.LocalTime;
 import java.time.OffsetTime;
@@ -2500,4 +2502,28 @@ class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(0)).hasMessageContaining("not top level message");
     assertThat(errorsCollected.get(1)).hasMessageContaining("not root cause message");
   }
+
+  @Test
+  void path_soft_assertions_should_report_errors_on_methods_that_switch_the_object_under_test() {
+    // GIVEN
+    Path path = new File("src/test/resources/actual_file.txt").toPath();
+    // WHEN
+    softly.assertThat(path)
+          .overridingErrorMessage("error message")
+          .as("content()")
+          .content()
+          .startsWith("actual")
+          .startsWith("123");
+    softly.assertThat(path)
+          .overridingErrorMessage("error message")
+          .as("content(UTF_8)")
+          .content(UTF_8)
+          .startsWith("actual")
+          .startsWith("123");
+    // THEN
+    then(softly.errorsCollected()).extracting(Throwable::getMessage)
+                                  .containsExactly("[content()] error message",
+                                                   "[content(UTF_8)] error message");
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_content_Test.java b/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_content_Test.java
new file mode 100644
index 000000000..e94ce50f4
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_content_Test.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.assumptions;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assumptions.assumeThat;
+import static org.assertj.core.api.BDDAssertions.thenCode;
+import static org.assertj.core.util.AssertionsUtil.expectAssumptionNotMetException;
+
+import java.io.File;
+import java.nio.file.Path;
+
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.junit.jupiter.api.Test;
+
+class Assumptions_assumeThat_with_content_Test {
+
+  private static final Path PATH = new File("src/test/resources/actual_file.txt").toPath();
+
+  @Test
+  void should_run_test_when_assumption_using_path_content_succeeds() {
+    // WHEN
+    ThrowingCallable assumptionCode = () -> assumeThat(PATH).content().contains("actual");
+    // THEN
+    thenCode(assumptionCode).doesNotThrowAnyException();
+  }
+
+  @Test
+  void should_ignore_test_when_assumption_using_path_content_fails() {
+    // WHEN
+    ThrowingCallable assumptionCode = () -> assumeThat(PATH).content().contains("foo");
+    // THEN
+    expectAssumptionNotMetException(assumptionCode);
+  }
+  
+  @Test
+  void should_run_test_when_assumption_using_path_content_with_charset_succeeds() {
+    // WHEN
+    ThrowingCallable assumptionCode = () -> assumeThat(PATH).content(UTF_8).contains("actual");
+    // THEN
+    thenCode(assumptionCode).doesNotThrowAnyException();
+  }
+  
+  @Test
+  void should_ignore_test_when_assumption_using_path_content_with_charset_fails() {
+    // WHEN
+    ThrowingCallable assumptionCode = () -> assumeThat(PATH).content(UTF_8).contains("foo");
+    // THEN
+    expectAssumptionNotMetException(assumptionCode);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_content_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_content_Test.java
new file mode 100644
index 000000000..971ce58ef
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_content_Test.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.nio.file.Path;
+
+import org.assertj.core.api.AbstractStringAssert;
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.junit.jupiter.api.Test;
+
+class PathAssert_content_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    assertions.content();
+    return assertions;
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertIsReadable(getInfo(assertions), getActual(assertions));
+  }
+  
+  @Override
+  protected PathAssert create_assertions() {
+    return new PathAssert(new File("src/test/resources/actual_file.txt").toPath());
+  }
+
+  @Test
+  public void should_return_StringAssert_on_path_content() {
+    // GIVEN
+    Path path = new File("src/test/resources/actual_file.txt").toPath();
+    // WHEN
+    AbstractStringAssert<?> stringAssert = assertThat(path).content();
+    // THEN
+    stringAssert.isEqualTo("actual%n", "");
+  }
+  
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_content_with_charset_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_content_with_charset_Test.java
new file mode 100644
index 000000000..f0194c0a9
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_content_with_charset_Test.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.nio.file.Path;
+
+import org.assertj.core.api.AbstractStringAssert;
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.junit.jupiter.api.Test;
+
+class PathAssert_content_with_charset_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    assertions.content(UTF_8);
+    return assertions;
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertIsReadable(getInfo(assertions), getActual(assertions));
+  }
+  
+  @Override
+  protected PathAssert create_assertions() {
+    return new PathAssert(new File("src/test/resources/actual_file.txt").toPath());
+  }
+
+  @Test
+  public void should_return_StringAssert_on_path_content_with_given_charset() {
+    // GIVEN
+    Path path = new File("src/test/resources/utf8.txt").toPath();
+    // WHEN
+    AbstractStringAssert<?> stringAssert = assertThat(path).content(UTF_8); 
+    // THEN
+    stringAssert.contains("é à");
+  }
+  
+}
diff --git a/src/test/java/org/assertj/core/internal/PathsBaseTest.java b/src/test/java/org/assertj/core/internal/PathsBaseTest.java
index 8b5c9fbbb..613874ca4 100644
--- a/src/test/java/org/assertj/core/internal/PathsBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/PathsBaseTest.java
@@ -64,15 +64,15 @@ public abstract class PathsBaseTest {
 
   @BeforeEach
   public void setUp() {
-	failures = spy(new Failures());
-	nioFilesWrapper = mock(NioFilesWrapper.class);
-	paths = new Paths(nioFilesWrapper);
-	paths.failures = failures;
-	info = someInfo();
-	diff = mock(Diff.class);
-	paths.diff = diff;
-	binaryDiff = mock(BinaryDiff.class);
-	paths.binaryDiff = binaryDiff;
+    failures = spy(new Failures());
+    nioFilesWrapper = mock(NioFilesWrapper.class);
+    paths = new Paths(nioFilesWrapper);
+    paths.failures = failures;
+    info = someInfo();
+    diff = mock(Diff.class);
+    paths.diff = diff;
+    binaryDiff = mock(BinaryDiff.class);
+    paths.binaryDiff = binaryDiff;
   }
 
   /**
@@ -80,26 +80,26 @@ public abstract class PathsBaseTest {
    */
   public static class FileSystemResource {
 
-	private final FileSystem fs;
+    private final FileSystem fs;
 
-	public FileSystemResource() {
-	  try {
-		fs = MemoryFileSystemBuilder.newLinux().build("PathsTest");
-	  } catch (IOException e) {
-		throw new RuntimeException("failed to initialize filesystem", e);
-	  }
-	}
+    public FileSystemResource() {
+      try {
+        fs = MemoryFileSystemBuilder.newLinux().build("PathsTest");
+      } catch (IOException e) {
+        throw new RuntimeException("failed to initialize filesystem", e);
+      }
+    }
 
-	public FileSystem getFileSystem() {
-	  return fs;
-	}
+    public FileSystem getFileSystem() {
+      return fs;
+    }
 
-	public void close() {
-	  try {
-		fs.close();
-	  } catch (IOException e) {
-		throw new RuntimeException("failed to close filesystem", e);
-	  }
-	}
+    public void close() {
+      try {
+        fs.close();
+      } catch (IOException e) {
+        throw new RuntimeException("failed to close filesystem", e);
+      }
+    }
   }
 }
\ No newline at end of file
