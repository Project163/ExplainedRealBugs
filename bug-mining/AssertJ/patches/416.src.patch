diff --git a/src/main/java/org/assertj/core/api/AbstractMapAssert.java b/src/main/java/org/assertj/core/api/AbstractMapAssert.java
index 8f841ee8b..5e8afe2e3 100644
--- a/src/main/java/org/assertj/core/api/AbstractMapAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractMapAssert.java
@@ -564,10 +564,11 @@ public abstract class AbstractMapAssert<SELF extends AbstractMapAssert<SELF, ACT
    * elvesRingBearers.put(narya, gandalf);
    * elvesRingBearers.put(vilya, elrond);
    *
-   * // assertion will succeed
+   * // assertions succeed
    * assertThat(ringBearers).containsAllEntriesOf(elvesRingBearers);
+   * assertThat(ringBearers).containsAllEntriesOf(emptyMap);
    *
-   * // assertion will fail
+   * // assertion fails
    * assertThat(elvesRingBearers).containsAllEntriesOf(ringBearers);</code></pre>
    *
    * @param other the map with the given entries.
@@ -578,7 +579,7 @@ public abstract class AbstractMapAssert<SELF extends AbstractMapAssert<SELF, ACT
    * @throws AssertionError if the actual map does not contain the given entries.
    */
   public SELF containsAllEntriesOf(Map<? extends K, ? extends V> other) {
-    maps.assertContains(info, actual, toEntries(other));
+    maps.assertContainsAllEntriesOf(info, actual, other);
     return myself;
   }
 
diff --git a/src/main/java/org/assertj/core/internal/ErrorMessages.java b/src/main/java/org/assertj/core/internal/ErrorMessages.java
index 5dc99e2aa..16294c0f1 100644
--- a/src/main/java/org/assertj/core/internal/ErrorMessages.java
+++ b/src/main/java/org/assertj/core/internal/ErrorMessages.java
@@ -55,6 +55,10 @@ public final class ErrorMessages {
     return "The array of entries to look for should not be null";
   }
 
+  public static String mapOfEntriesToLookForIsNull() {
+    return "The map of entries to look for should not be null";
+  }
+
   public static String entryToLookForIsNull() {
     return "Entries to look for should not be null";
   }
diff --git a/src/main/java/org/assertj/core/internal/Maps.java b/src/main/java/org/assertj/core/internal/Maps.java
index 916322342..eb33b1f9a 100644
--- a/src/main/java/org/assertj/core/internal/Maps.java
+++ b/src/main/java/org/assertj/core/internal/Maps.java
@@ -22,6 +22,7 @@ import static org.assertj.core.error.NoElementsShouldSatisfy.noElementsShouldSat
 import static org.assertj.core.error.ShouldBeEmpty.shouldBeEmpty;
 import static org.assertj.core.error.ShouldBeNullOrEmpty.shouldBeNullOrEmpty;
 import static org.assertj.core.error.ShouldContain.shouldContain;
+import static org.assertj.core.error.ShouldContainAnyOf.shouldContainAnyOf;
 import static org.assertj.core.error.ShouldContainEntry.shouldContainEntry;
 import static org.assertj.core.error.ShouldContainExactly.elementsDifferAtIndex;
 import static org.assertj.core.error.ShouldContainExactly.shouldContainExactly;
@@ -63,7 +64,6 @@ import java.util.function.Consumer;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.api.Condition;
-import org.assertj.core.error.ShouldContainAnyOf;
 import org.assertj.core.error.UnsatisfiedRequirement;
 import org.assertj.core.util.VisibleForTesting;
 
@@ -349,12 +349,28 @@ public class Maps {
     // if both actual and values are empty, then assertion passes.
     if (actual.isEmpty() && entries.length == 0) return;
     failIfEmptySinceActualIsNotEmpty(entries);
-    Set<Map.Entry<? extends K, ? extends V>> notFound = new LinkedHashSet<>();
-    for (Map.Entry<? extends K, ? extends V> entry : entries) {
-      if (!containsEntry(actual, entry)) notFound.add(entry);
-    }
-    if (notFound.isEmpty()) return;
-    throw failures.failure(info, shouldContain(actual, entries, notFound));
+    failIfAnyEntryNotFoundInActualMap(info, actual, entries);
+  }
+
+  /**
+   * Asserts that the given {@code Map} contains the entries of the other {@code Map}, in any order.
+   *
+   * @param <K> key type
+   * @param <V> value type
+   * @param info contains information about the assertion.
+   * @param actual the given {@code Map}.
+   * @param other the {@code Map} of entries that are expected to be in the given {@code Map}.
+   * @throws NullPointerException if the other map is {@code null}.
+   * @throws AssertionError if the given {@code Map} is {@code null}.
+   * @throws AssertionError if the given {@code Map} does not contain the entries of the other {@code Map}.
+   */
+  public <K, V> void assertContainsAllEntriesOf(AssertionInfo info, Map<K, V> actual,
+                                                Map<? extends K, ? extends V> other) {
+    failIfNull(other);
+    assertNotNull(info, actual);
+    // assertion passes if other is empty since actual contains all other entries.
+    if (other.isEmpty()) return;
+    failIfAnyEntryNotFoundInActualMap(info, actual, other.entrySet().toArray(new Map.Entry[0]));
   }
 
   public <K, V> void assertContainsAnyOf(AssertionInfo info, Map<K, V> actual,
@@ -367,7 +383,7 @@ public class Maps {
     for (Map.Entry<? extends K, ? extends V> entry : entries) {
       if (containsEntry(actual, entry)) return;
     }
-    throw failures.failure(info, ShouldContainAnyOf.shouldContainAnyOf(actual, entries));
+    throw failures.failure(info, shouldContainAnyOf(actual, entries));
   }
 
   /**
@@ -843,6 +859,15 @@ public class Maps {
     failIfNull(entries);
   }
 
+  private <K, V> void failIfAnyEntryNotFoundInActualMap(AssertionInfo info, Map<K, V> actual,
+                                                        Map.Entry<? extends K, ? extends V>[] entries) {
+    Set<Map.Entry<? extends K, ? extends V>> notFound = new LinkedHashSet<>();
+    for (Map.Entry<? extends K, ? extends V> entry : entries) {
+      if (!containsEntry(actual, entry)) notFound.add(entry);
+    }
+    if (!notFound.isEmpty()) throw failures.failure(info, shouldContain(actual, entries, notFound));
+  }
+
   private static <K, V> Map<K, V> entriesToMap(Map.Entry<? extends K, ? extends V>[] entries) {
     Map<K, V> expectedEntries = new LinkedHashMap<>();
     for (Map.Entry<? extends K, ? extends V> entry : entries) {
@@ -872,8 +897,12 @@ public class Maps {
     requireNonNull(entries, ErrorMessages.entriesToLookForIsNull());
   }
 
+  private static <K, V> void failIfNull(Map<? extends K, ? extends V> map) {
+    requireNonNull(map, ErrorMessages.mapOfEntriesToLookForIsNull());
+  }
+
   private <K, V> boolean containsEntry(Map<K, V> actual, Map.Entry<? extends K, ? extends V> entry) {
-    requireNonNull(entry, "Entries to look for should not be null");
+    requireNonNull(entry, ErrorMessages.entryToLookForIsNull());
     return actual.containsKey(entry.getKey()) && areEqual(actual.get(entry.getKey()), entry.getValue());
   }
 
diff --git a/src/test/java/org/assertj/core/api/MapAssertBaseTest.java b/src/test/java/org/assertj/core/api/MapAssertBaseTest.java
index 6c3db7a3f..d2d99246d 100644
--- a/src/test/java/org/assertj/core/api/MapAssertBaseTest.java
+++ b/src/test/java/org/assertj/core/api/MapAssertBaseTest.java
@@ -13,16 +13,15 @@
 package org.assertj.core.api;
 
 import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonMap;
 import static org.mockito.Mockito.mock;
 
 import java.util.AbstractMap.SimpleImmutableEntry;
-import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
 import org.assertj.core.internal.Maps;
 
-
 /**
  * Base class for {@link MapAssert} tests.
  *
@@ -43,15 +42,15 @@ public abstract class MapAssertBaseTest extends BaseTestTemplate<MapAssert<Objec
     assertions.maps = maps;
   }
 
-  protected <K,V> Map.Entry<K, V> javaMapEntry(K key, V value) {
+  protected static <K, V> Map.Entry<K, V> javaMapEntry(K key, V value) {
     return new SimpleImmutableEntry<>(key, value);
   }
 
-  protected <K, V> Map<K, V> map(K key, V value) {
-    return Collections.singletonMap(key, value);
+  protected static <K, V> Map<K, V> map(K key, V value) {
+    return singletonMap(key, value);
   }
 
-  protected <K, V> Map<K, V> map(K k1, V v1, K k2, V v2) {
+  protected static <K, V> Map<K, V> map(K k1, V v1, K k2, V v2) {
     Map<K, V> map = new LinkedHashMap<>();
     map.put(k1, v1);
     map.put(k2, v2);
diff --git a/src/test/java/org/assertj/core/api/map/MapAssert_containsAllEntries_Test.java b/src/test/java/org/assertj/core/api/map/MapAssert_containsAllEntriesOf_Test.java
similarity index 68%
rename from src/test/java/org/assertj/core/api/map/MapAssert_containsAllEntries_Test.java
rename to src/test/java/org/assertj/core/api/map/MapAssert_containsAllEntriesOf_Test.java
index 7faac8233..de4da58ea 100644
--- a/src/test/java/org/assertj/core/api/map/MapAssert_containsAllEntries_Test.java
+++ b/src/test/java/org/assertj/core/api/map/MapAssert_containsAllEntriesOf_Test.java
@@ -12,8 +12,7 @@
  */
 package org.assertj.core.api.map;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.mockito.Mockito.verify;
 
 import java.util.Map;
@@ -22,10 +21,7 @@ import org.assertj.core.api.MapAssert;
 import org.assertj.core.api.MapAssertBaseTest;
 import org.junit.jupiter.api.Test;
 
-class MapAssert_containsAllEntries_Test extends MapAssertBaseTest {
-
-  final Map.Entry<String, String>[] entries = array(javaMapEntry("firstKey", "firstValue"),
-                                                    javaMapEntry("secondKey", "secondValue"));
+class MapAssert_containsAllEntriesOf_Test extends MapAssertBaseTest {
 
   @Override
   protected MapAssert<Object, Object> invoke_api_method() {
@@ -34,12 +30,15 @@ class MapAssert_containsAllEntries_Test extends MapAssertBaseTest {
 
   @Override
   protected void verify_internal_effects() {
-    verify(maps).assertContains(getInfo(assertions), getActual(assertions), entries);
+    verify(maps).assertContainsAllEntriesOf(getInfo(assertions), getActual(assertions),
+                                            map("firstKey", "firstValue", "secondKey", "secondValue"));
   }
 
   @Test
   void invoke_api_like_user() {
+    // GIVEN
     Map<String, String> actual = map("firstKey", "firstValue", "secondKey", "secondValue");
-    assertThat(actual).containsAllEntriesOf(map("secondKey", "secondValue", "firstKey", "firstValue"));
+    // WHEN/THEN
+    then(actual).containsAllEntriesOf(map("secondKey", "secondValue", "firstKey", "firstValue"));
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsAllEntriesOf_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsAllEntriesOf_Test.java
new file mode 100644
index 000000000..b5be90115
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsAllEntriesOf_Test.java
@@ -0,0 +1,92 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.internal.maps;
+
+import static java.util.Collections.emptyMap;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.MapEntry.entry;
+import static org.assertj.core.error.ShouldContain.shouldContain;
+import static org.assertj.core.internal.ErrorMessages.mapOfEntriesToLookForIsNull;
+import static org.assertj.core.test.Maps.mapOf;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.assertj.core.internal.MapsBaseTest;
+import org.junit.jupiter.api.Test;
+
+class Maps_assertContainsAllEntriesOf_Test extends MapsBaseTest {
+
+  @Test
+  void should_pass_if_actual_contains_given_map_entries() {
+    maps.assertContainsAllEntriesOf(someInfo(), actual, mapOf(entry("name", "Yoda")));
+  }
+
+  @Test
+  void should_pass_if_actual_contains_given_map_entries_in_different_order() {
+    maps.assertContainsAllEntriesOf(someInfo(), actual, mapOf(entry("color", "green"), entry("name", "Yoda")));
+  }
+
+  @Test
+  void should_pass_if_actual_contains_all_given_map_entries() {
+    maps.assertContainsAllEntriesOf(someInfo(), actual, mapOf(entry("name", "Yoda"), entry("color", "green")));
+  }
+
+  @Test
+  void should_pass_if_actual_and_given_map_are_empty() {
+    actual = emptyMap();
+    maps.assertContainsAllEntriesOf(someInfo(), actual, mapOf());
+  }
+
+  @Test
+  void should_pass_if_actual_is_not_empty_and_given_map_is_empty() {
+    maps.assertContainsAllEntriesOf(someInfo(), actual, emptyMap());
+  }
+
+  @Test
+  void should_throw_error_if_map_of_entries_to_look_for_is_null() {
+    // GIVEN
+    Map<String, String> other = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> maps.assertContainsAllEntriesOf(someInfo(), actual, other),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).isNotNull()
+             .hasMessage(mapOfEntriesToLookForIsNull());
+  }
+
+  @Test
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    Map<String, String> actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsAllEntriesOf(someInfo(), actual,
+                                                                                               mapOf(entry("name", "Yoda"))));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_map_entries() {
+    // GIVEN
+    LinkedHashMap<String, String> other = mapOf(entry("name", "Yoda"), entry("job", "Jedi"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsAllEntriesOf(info, actual, other));
+    // THEN
+    then(assertionError).hasMessage(shouldContain(actual, other.entrySet(), mapOf(entry("job", "Jedi")).entrySet()).create());
+  }
+}
