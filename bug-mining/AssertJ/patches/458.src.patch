diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 35926cad4..7fb5e46f7 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -712,7 +712,7 @@ public class RecursiveComparisonConfiguration {
     String fieldName = dualValue.getConcatenatedPath();
     if (hasComparatorForField(fieldName)) return true;
     if (dualValue.actual == null && dualValue.expected == null) return false;
-    // best effort assuming actual and expected have the same type (not 100% true as we can compare object of differennt types)
+    // best effort assuming actual and expected have the same type (not 100% true as we can compare object of different types)
     Class<?> valueType = dualValue.actual != null ? dualValue.actual.getClass() : dualValue.expected.getClass();
     return hasComparatorForType(valueType);
   }
@@ -720,7 +720,7 @@ public class RecursiveComparisonConfiguration {
   boolean shouldIgnoreOverriddenEqualsOf(DualValue dualValue) {
     // we must compare java basic types otherwise the recursive comparison loops infinitely!
     if (dualValue.isActualJavaType()) return false;
-    // enums don't have fields, comparing them field by field has no sense, we need to use equals which is overridden and final
+    // enums don't have fields, comparing them field by field makes no sense, we need to use equals which is overridden and final
     if (dualValue.isActualAnEnum()) return false;
     return ignoreAllOverriddenEquals
            || matchesAnIgnoredOverriddenEqualsField(dualValue.fieldLocation)
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 7f3f32ace..b674b77ea 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -113,9 +113,9 @@ public class RecursiveComparisonDifferenceCalculator {
       if (!visitedDualValues.contains(dualValue)) dualValuesToCompare.addFirst(dualValue);
     }
 
-    private void initDualValuesToCompare(Object actual, Object expected, FieldLocation fieldLocation, boolean isRootObject) {
+    private void initDualValuesToCompare(Object actual, Object expected, FieldLocation fieldLocation) {
       DualValue dualValue = new DualValue(fieldLocation, actual, expected);
-      boolean mustCompareFieldsRecursively = mustCompareFieldsRecursively(isRootObject, dualValue);
+      boolean mustCompareFieldsRecursively = mustCompareFieldsRecursively(dualValue);
       if (dualValue.hasNoNullValues() && dualValue.hasNoContainerValues() && mustCompareFieldsRecursively) {
         // disregard the equals method and start comparing fields
         Set<String> nonIgnoredActualFieldsNames = recursiveComparisonConfiguration.getNonIgnoredActualFieldNames(dualValue);
@@ -151,10 +151,9 @@ public class RecursiveComparisonDifferenceCalculator {
                                                                        .ifPresent(dualValuesToCompare::remove));
     }
 
-    private boolean mustCompareFieldsRecursively(boolean isRootObject, DualValue dualValue) {
-      boolean noCustomComparisonForDualValue = !recursiveComparisonConfiguration.hasCustomComparator(dualValue)
-                                               && !shouldHonorOverriddenEquals(dualValue, recursiveComparisonConfiguration);
-      return isRootObject || noCustomComparisonForDualValue;
+    private boolean mustCompareFieldsRecursively(DualValue dualValue) {
+      return !recursiveComparisonConfiguration.hasCustomComparator(dualValue)
+             && !shouldHonorOverriddenEquals(dualValue, recursiveComparisonConfiguration);
     }
 
     private String getCustomErrorMessage(DualValue dualValue) {
@@ -198,16 +197,16 @@ public class RecursiveComparisonDifferenceCalculator {
       return list(expectedAndActualTypeDifference(actual, expected));
     }
     List<DualValue> visited = list();
-    return determineDifferences(actual, expected, rootFieldLocation(), true, visited, recursiveComparisonConfiguration);
+    return determineDifferences(actual, expected, rootFieldLocation(), visited, recursiveComparisonConfiguration);
   }
 
   // TODO keep track of ignored fields in an RecursiveComparisonExecution class ?
 
   private static List<ComparisonDifference> determineDifferences(Object actual, Object expected, FieldLocation fieldLocation,
-                                                                 boolean isRootObject, List<DualValue> visited,
+                                                                 List<DualValue> visited,
                                                                  RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
     ComparisonState comparisonState = new ComparisonState(visited, recursiveComparisonConfiguration);
-    comparisonState.initDualValuesToCompare(actual, expected, fieldLocation, isRootObject);
+    comparisonState.initDualValuesToCompare(actual, expected, fieldLocation);
 
     while (comparisonState.hasDualValuesToCompare()) {
       final DualValue dualValue = comparisonState.pickDualValueToCompare();
@@ -434,7 +433,7 @@ public class RecursiveComparisonDifferenceCalculator {
         Object actualElement = actualIterator.next();
         // we need to get the currently visited dual values otherwise a cycle would cause an infinite recursion.
         List<ComparisonDifference> differences = determineDifferences(actualElement, expectedElement, dualValue.fieldLocation,
-                                                                      false, comparisonState.visitedDualValues,
+                                                                      comparisonState.visitedDualValues,
                                                                       comparisonState.recursiveComparisonConfiguration);
         if (differences.isEmpty()) {
           // found an element in actual matching expectedElement, remove it as it can't be used to match other expected elements
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_usingOverriddenEquals_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_usingOverriddenEquals_Test.java
new file mode 100644
index 000000000..4b73d243b
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_usingOverriddenEquals_Test.java
@@ -0,0 +1,181 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.Objects;
+import java.util.Optional;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
+import org.assertj.core.internal.objects.data.AlwaysDifferentPerson;
+import org.assertj.core.internal.objects.data.AlwaysEqualPerson;
+import org.assertj.core.internal.objects.data.Person;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+public class RecursiveComparisonAssert_isEqualTo_usingOverriddenEquals_Test
+    extends RecursiveComparisonAssert_isEqualTo_BaseTest implements PersonData {
+
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
+  @MethodSource
+  void should_fail_when_using_overridden_equals(Object actual, Object expected, String testDescription) {
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison()
+                                                                                 .usingOverriddenEquals()
+                                                                                 .isEqualTo(expected));
+    // THEN
+    then(assertionError).hasMessageContaining("- overridden equals methods were used in the comparison");
+  }
+
+  private static Stream<Arguments> should_fail_when_using_overridden_equals() {
+    Person person1 = new AlwaysDifferentPerson();
+    person1.neighbour = new Person("John");
+    Person person2 = new AlwaysDifferentPerson();
+    person2.neighbour = new Person("John");
+
+    Person person3 = new Person();
+    person3.neighbour = new AlwaysDifferentPerson();
+    person3.neighbour.name = "John";
+    Person person4 = new Person();
+    person4.neighbour = new AlwaysDifferentPerson();
+    person4.neighbour.name = "John";
+
+    return Stream.of(arguments(person1, person2, "root Person is AlwaysDifferentPerson"),
+                     arguments(person3, person4, "neighbour Person is AlwaysDifferentPerson"));
+  }
+
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
+  @MethodSource
+  void should_pass_when_using_overridden_equals(Object actual, Object expected, String testDescription) {
+    then(actual).usingRecursiveComparison()
+                .usingOverriddenEquals()
+                .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> should_pass_when_using_overridden_equals() {
+    Person person1 = new AlwaysEqualPerson();
+    person1.neighbour = new Person("John");
+    Person person2 = new AlwaysEqualPerson();
+    person2.neighbour = new Person("Jack");
+
+    Person person3 = new Person();
+    person3.neighbour = new AlwaysEqualPerson();
+    person3.neighbour.name = "John";
+    Person person4 = new Person();
+    person4.neighbour = new AlwaysEqualPerson();
+    person4.neighbour.name = "Jack";
+
+    return Stream.of(arguments(person1, person2, "root Person is AlwaysEqualPerson"),
+                     arguments(person3, person4, "neighbour Person is AlwaysEqualPerson"));
+  }
+
+  static class PersonWithOverriddenEquals {
+    String name;
+    String color;
+    Pet pet;
+
+    public PersonWithOverriddenEquals(String name, String color, Pet pet) {
+      this.name = name; // only name is used in equals
+      this.color = color;
+      this.pet = pet;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      PersonWithOverriddenEquals person = (PersonWithOverriddenEquals) o;
+      return Objects.equals(name, person.name);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(name, color);
+    }
+
+    @Override
+    public String toString() {
+      return String.format("Person [name=%s, color=%s]", name, color);
+    }
+  }
+
+  public static class Pet {
+    String name;
+    String type; // only type is used in equals
+
+    public Pet(String name, String type) {
+      this.name = name;
+      this.type = type;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      Pet pet = (Pet) o;
+      return type.equals(pet.type);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(type);
+    }
+  }
+
+  static class PersonWrapper {
+    PersonWithOverriddenEquals person;
+
+    public PersonWrapper(PersonWithOverriddenEquals person) {
+      this.person = person;
+    }
+
+  }
+
+  @Test
+  void should_pass_when_comparison_using_overriden_equals_on_root_objects() {
+    // GIVEN
+    PersonWithOverriddenEquals person1 = new PersonWithOverriddenEquals("John", "green", new Pet("Ducky", "Duck"));
+    PersonWithOverriddenEquals person2 = new PersonWithOverriddenEquals("John", "blue", new Pet("Mia", "Duck"));
+    // WHEN/THEN
+    then(person1).usingRecursiveComparison()
+                 .usingOverriddenEquals()
+                 .isEqualTo(person2);
+  }
+
+  @Test
+  void should_pass_when_comparison_using_overriden_equals_on_fields() {
+    // GIVEN
+    Optional<PersonWithOverriddenEquals> person1 = Optional.of(new PersonWithOverriddenEquals("John", "green",
+                                                                                              new Pet("Ducky", "Duck")));
+    Optional<PersonWithOverriddenEquals> person2 = Optional.of(new PersonWithOverriddenEquals("John", "green",
+                                                                                              new Pet("Mia", "Duck")));
+    // WHEN/THEN
+    then(person1).usingRecursiveComparison()
+                 .usingOverriddenEquals()
+                 .isEqualTo(person2);
+  }
+
+  @Test
+  void should_pass_when_comparison_using_overriden_equals_on_person_wrapper() {
+    // GIVEN
+    PersonWrapper person1 = new PersonWrapper(new PersonWithOverriddenEquals("John", "green", new Pet("Ducky", "Duck")));
+    PersonWrapper person2 = new PersonWrapper(new PersonWithOverriddenEquals("John", "green", new Pet("Mia", "Duck")));
+    // WHEN/THEN
+    then(person1).usingRecursiveComparison()
+                 .usingOverriddenEquals()
+                 .isEqualTo(person2);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
index 89ff3eaf0..430fa1e1c 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
@@ -49,7 +49,6 @@ import org.junit.jupiter.params.provider.MethodSource;
 class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     extends RecursiveComparisonAssert_isEqualTo_BaseTest {
 
-  @SuppressWarnings("unused")
   @ParameterizedTest(name = "{3}: actual={0} / expected={1} - comparatorsByType: {2}")
   @MethodSource("recursivelyEqualObjectsWhenUsingTypeComparators")
   void should_pass_for_objects_with_the_same_data_when_using_registered_comparator_by_types(Object actual,
@@ -65,7 +64,6 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
                       .isEqualTo(expected);
   }
 
-  @SuppressWarnings("unused")
   @ParameterizedTest(name = "{3}: actual={0} / expected={1} - comparatorsByType: {2}")
   @MethodSource("recursivelyEqualObjectsWhenUsingTypeComparators")
   void should_pass_for_objects_with_the_same_data_when_using_registered_equals_by_types(Object actual,
@@ -133,7 +131,6 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     expected.neighbour = new Person("Jack");
     expected.neighbour.home.address.number = 123;
     // register comparators for some type that will fail the comparison
-    recursiveComparisonConfiguration.registerComparatorForType(new AlwaysDifferentComparator<>(), Person.class);
     recursiveComparisonConfiguration.registerComparatorForType(new AlwaysDifferentComparator<>(), Date.class);
     recursiveComparisonConfiguration.registerEqualsForType((Address a1, Address a2) -> false, Address.class);
 
@@ -143,9 +140,10 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     // THEN
     ComparisonDifference dateOfBirthDifference = diff("dateOfBirth", actual.dateOfBirth, expected.dateOfBirth);
     ComparisonDifference addressDifference = diff("home.address", actual.home.address, expected.home.address);
-    ComparisonDifference neighbourDifference = diff("neighbour", actual.neighbour, expected.neighbour);
-    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected,
-                                                              dateOfBirthDifference, addressDifference, neighbourDifference);
+    ComparisonDifference neighbourAddressDifference = diff("neighbour.home.address", actual.neighbour.home.address,
+                                                           expected.neighbour.home.address);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, dateOfBirthDifference,
+                                                              addressDifference, neighbourAddressDifference);
   }
 
   @Test
