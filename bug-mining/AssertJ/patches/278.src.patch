diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index cd12f9953..8e9b11a0d 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -23,6 +23,7 @@ import static org.assertj.core.extractor.Extractors.extractedDescriptionOfMethod
 import static org.assertj.core.extractor.Extractors.resultOf;
 import static org.assertj.core.internal.CommonValidations.checkSequenceIsNotNull;
 import static org.assertj.core.internal.CommonValidations.checkSubsequenceIsNotNull;
+import static org.assertj.core.internal.Iterables.byPassingAssertions;
 import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.IterableUtil.toArray;
@@ -2187,6 +2188,32 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return newAbstractIterableAssert(filteredIterable).withAssertionState(myself);
   }
 
+  /**
+   * Filter the iterable under test keeping only elements matching the given assertions specified with a {@link Consumer}.
+   * <p>
+   * Example : check old employees whose age &gt; 100:
+   *
+   * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   *
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan);
+   *
+   * assertThat(employees).filteredOnAssertions(employee -&gt; assertThat(employee.getAge()).isGreaterThan(100))
+   *                      .containsOnly(yoda, obiwan);</code></pre>
+   *
+   * @param elementAssertions containing AssertJ assertions to filter on
+   * @return a new assertion object with the filtered iterable under test
+   * @throws IllegalArgumentException if the given predicate is {@code null}.
+   * @since 3.11.0
+   */
+  public SELF filteredOnAssertions(Consumer<? super ELEMENT> elementAssertions) {
+    checkArgument(elementAssertions != null, "The element assertions should not be null");
+    List<? extends ELEMENT> filteredIterable = stream(actual.spliterator(), false).filter(byPassingAssertions(elementAssertions))
+                                                                                  .collect(toList());
+    return newAbstractIterableAssert(filteredIterable).withAssertionState(myself);
+  }
+
   // navigable assertions
 
   /**
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index 4588ce8f1..cd81bbe4d 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -23,6 +23,7 @@ import static org.assertj.core.extractor.Extractors.extractedDescriptionOfMethod
 import static org.assertj.core.extractor.Extractors.resultOf;
 import static org.assertj.core.internal.CommonValidations.checkSequenceIsNotNull;
 import static org.assertj.core.internal.CommonValidations.checkSubsequenceIsNotNull;
+import static org.assertj.core.internal.Iterables.byPassingAssertions;
 import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.IterableUtil.toArray;
@@ -2635,6 +2636,31 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
     return newObjectArrayAssert(filteredList);
   }
 
+  /**
+   * Filter the array under test keeping only elements matching the given assertions specified with a {@link Consumer}.
+   * <p>
+   * Example : check old employees whose age &gt; 100:
+   *
+   * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   *
+   * Employee[] employees = new Employee[] { yoda, luke, obiwan };
+   *
+   * assertThat(employees).filteredOnAssertions(employee -&gt; assertThat(employee.getAge()).isGreaterThan(100))
+   *                      .containsOnly(yoda, obiwan);</code></pre>
+   *
+   * @param elementAssertions containing AssertJ assertions to filter on
+   * @return a new assertion object with the filtered iterable under test
+   * @throws IllegalArgumentException if the given predicate is {@code null}.
+   * @since 3.11.0
+   */
+  public SELF filteredOnAssertions(Consumer<? super ELEMENT> elementAssertions) {
+    checkArgument(elementAssertions != null, "The element assertions should not be null");
+    List<ELEMENT> filteredIterable = stream(actual).filter(byPassingAssertions(elementAssertions)).collect(toList());
+    return newObjectArrayAssert(filteredIterable).withAssertionState(myself);
+  }
+
   /**
    * Verifies that all elements match the given {@link Predicate}.
    * <p>
diff --git a/src/main/java/org/assertj/core/api/SoftProxies.java b/src/main/java/org/assertj/core/api/SoftProxies.java
index 62a5f2c1a..e18c547bd 100644
--- a/src/main/java/org/assertj/core/api/SoftProxies.java
+++ b/src/main/java/org/assertj/core/api/SoftProxies.java
@@ -39,6 +39,7 @@ class SoftProxies {
 
   private static final Junction<MethodDescription> METHODS_CHANGING_THE_OBJECT_UNDER_TEST = methodsNamed("extracting").or(named("filteredOn"))
                                                                                                                       .or(named("filteredOnNull"))
+                                                                                                                      .or(named("filteredOnAssertions"))
                                                                                                                       .or(named("map"))
                                                                                                                       .or(named("asString"))
                                                                                                                       .or(named("asList"))
diff --git a/src/main/java/org/assertj/core/internal/Iterables.java b/src/main/java/org/assertj/core/internal/Iterables.java
index 6e615dc4f..89911f638 100644
--- a/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/src/main/java/org/assertj/core/internal/Iterables.java
@@ -1193,6 +1193,17 @@ public class Iterables {
     return stream(actual).filter(o -> condition.matches(o)).collect(toList());
   }
 
+  public static <T> Predicate<T> byPassingAssertions(Consumer<? super T> assertions) {
+    return objectToTest -> {
+      try {
+        assertions.accept(objectToTest);
+        return true;
+      } catch (AssertionError e) {
+        return false;
+      }
+    };
+  }
+
   private static void checkIsNotEmptySequence(Object[] sequence) {
     if (sequence.length == 0) throw new IllegalArgumentException(emptySequence());
   }
diff --git a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
index d573aac33..b8548735b 100644
--- a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
@@ -1111,9 +1111,13 @@ public class BDDSoftAssertionsTest extends BaseAssertionsTest {
           .as("using flatExtracting(String fieldOrPropertyName)")
           .contains(bart, maggie)
           .contains("Sauron");
+    softly.then(names)
+          .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
+          .as("filteredOn with consumer")
+          .hasSize(5);
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(32);
+    assertThat(errorsCollected).hasSize(33);
     assertThat(errorsCollected.get(0)).hasMessageContaining("gandalf");
     assertThat(errorsCollected.get(1)).hasMessageContaining("frodo");
     assertThat(errorsCollected.get(2)).hasMessageContaining("foo")
@@ -1147,6 +1151,7 @@ public class BDDSoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(29)).hasMessageContaining("filteredOn firstName = null");
     assertThat(errorsCollected.get(30)).hasMessageContaining("using flatExtracting(String... fieldOrPropertyNames)");
     assertThat(errorsCollected.get(31)).hasMessageContaining("using flatExtracting(String fieldOrPropertyName)");
+    assertThat(errorsCollected.get(32)).hasMessageContaining("filteredOn with consumer");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
@@ -1260,9 +1265,13 @@ public class BDDSoftAssertionsTest extends BaseAssertionsTest {
           .as("using flatExtracting(String fieldOrPropertyName)")
           .contains(bart, maggie)
           .contains("Sauron");
+    softly.then(names)
+          .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
+          .as("filteredOn with consumer")
+          .hasSize(5);
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(32);
+    assertThat(errorsCollected).hasSize(33);
     assertThat(errorsCollected.get(0)).hasMessageContaining("gandalf");
     assertThat(errorsCollected.get(1)).hasMessageContaining("frodo");
     assertThat(errorsCollected.get(2)).hasMessageContaining("foo")
@@ -1296,6 +1305,7 @@ public class BDDSoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(29)).hasMessageContaining("filteredOn firstName = null");
     assertThat(errorsCollected.get(30)).hasMessageContaining("using flatExtracting(String... fieldOrPropertyNames)");
     assertThat(errorsCollected.get(31)).hasMessageContaining("using flatExtracting(String fieldOrPropertyName)");
+    assertThat(errorsCollected.get(32)).hasMessageContaining("filteredOn with consumer");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
@@ -1394,9 +1404,13 @@ public class BDDSoftAssertionsTest extends BaseAssertionsTest {
           .as("using flatExtracting(String fieldOrPropertyName)")
           .contains(bart, maggie)
           .contains("Sauron");
+    softly.then(names)
+          .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
+          .as("filteredOn with consumer")
+          .hasSize(5);
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(29);
+    assertThat(errorsCollected).hasSize(30);
     assertThat(errorsCollected.get(0)).hasMessageContaining("gandalf");
     assertThat(errorsCollected.get(1)).hasMessageContaining("frodo");
     assertThat(errorsCollected.get(2)).hasMessageContaining("foo")
@@ -1427,6 +1441,7 @@ public class BDDSoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(26)).hasMessageContaining("filteredOn firstName = John");
     assertThat(errorsCollected.get(27)).hasMessageContaining("filteredOn firstName = null");
     assertThat(errorsCollected.get(28)).hasMessageContaining("using flatExtracting(String fieldOrPropertyName)");
+    assertThat(errorsCollected.get(29)).hasMessageContaining("filteredOn with consumer");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index ce03c1d81..3eb6806e3 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -347,11 +347,11 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
       assertThat(errors.get(19)).contains("expected:<[1[7].0f]> but was:<[1[6].0f]>");
 
       assertThat(errors.get(20)).contains(format("%nInputStreams do not have same content:%n%n"
-                                                   + "Changed content at line 1:%n"
-                                                   + "expecting:%n"
-                                                   + "  [\"B\"]%n"
-                                                   + "but was:%n"
-                                                   + "  [\"A\"]%n"));
+                                                 + "Changed content at line 1:%n"
+                                                 + "expecting:%n"
+                                                 + "  [\"B\"]%n"
+                                                 + "but was:%n"
+                                                 + "  [\"A\"]%n"));
 
       assertThat(errors.get(21)).contains("expected:<2[1]> but was:<2[0]>");
       assertThat(errors.get(22)).contains("expected:<2[3]> but was:<2[2]>");
@@ -359,11 +359,11 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
 
       assertThat(errors.get(24)).contains("expected:<[\"2[7]\"]> but was:<[\"2[6]\"]>");
       assertThat(errors.get(25)).contains(format("%nExpecting:%n" +
-                                                   " <[\"28\"]>%n" +
-                                                   "to contain:%n" +
-                                                   " <[\"29\"]>%n" +
-                                                   "but could not find:%n" +
-                                                   " <[\"29\"]>%n"));
+                                                 " <[\"28\"]>%n" +
+                                                 "to contain:%n" +
+                                                 " <[\"29\"]>%n" +
+                                                 "but could not find:%n" +
+                                                 " <[\"29\"]>%n"));
       assertThat(errors.get(26)).contains("expected:<[\"3[1]\"]> but was:<[\"3[0]\"]>");
 
       assertThat(errors.get(27)).contains("expected:<3[3]L> but was:<3[2]L>");
@@ -381,19 +381,19 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
       assertThat(errors.get(35)).contains("expected:<5[1]> but was:<5[0]>");
       assertThat(errors.get(36)).contains("expected:<[5[3]]> but was:<[5[2]]>");
       assertThat(errors.get(37)).contains(format("%nExpecting message:%n"
-                                                   + " <\"NullPointerException message\">%n"
-                                                   + "but was:%n"
-                                                   + " <\"IllegalArgumentException message\">"));
+                                                 + " <\"NullPointerException message\">%n"
+                                                 + "but was:%n"
+                                                 + " <\"IllegalArgumentException message\">"));
       assertThat(errors.get(38)).contains(format("%nExpecting message:%n"
-                                                   + " <\"something was good\">%n"
-                                                   + "but was:%n"
-                                                   + " <\"something was wrong\">"));
+                                                 + " <\"something was good\">%n"
+                                                 + "but was:%n"
+                                                 + " <\"something was wrong\">"));
       assertThat(errors.get(39)).contains(format("%nExpecting:%n"
-                                                   + " <{\"54\"=\"55\"}>%n"
-                                                   + "to contain:%n"
-                                                   + " <[MapEntry[key=\"1\", value=\"2\"]]>%n"
-                                                   + "but could not find:%n"
-                                                   + " <[MapEntry[key=\"1\", value=\"2\"]]>%n"));
+                                                 + " <{\"54\"=\"55\"}>%n"
+                                                 + "to contain:%n"
+                                                 + " <[MapEntry[key=\"1\", value=\"2\"]]>%n"
+                                                 + "but could not find:%n"
+                                                 + " <[MapEntry[key=\"1\", value=\"2\"]]>%n"));
 
       assertThat(errors.get(40)).contains("expected:<1[3]:00> but was:<1[2]:00>");
       assertThat(errors.get(41)).contains("expected:<1[3]:00Z> but was:<1[2]:00Z>");
@@ -405,15 +405,15 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
       assertThat(errors.get(46)).contains("Expecting port of");
       assertThat(errors.get(47)).contains("to have failed");
       assertThat(errors.get(48)).contains(format("%nExpecting:%n  <given predicate>%n"
-                                                   + "to accept <\"something else\"> but it did not."));
+                                                 + "to accept <\"something else\"> but it did not."));
 
       assertThat(errors.get(49)).contains(format("%nExpecting:%n  <given predicate>%n"
-                                                   + "to accept <2> but it did not."));
+                                                 + "to accept <2> but it did not."));
 
       assertThat(errors.get(50)).contains(format("%nExpecting:%n  <given predicate>%n"
-                                                   + "to accept <2L> but it did not."));
+                                                 + "to accept <2L> but it did not."));
       assertThat(errors.get(51)).contains(format("%nExpecting:%n  <given predicate>%n"
-                                                   + "to accept <2.0> but it did not."));
+                                                 + "to accept <2.0> but it did not."));
     }
   }
 
@@ -1161,9 +1161,14 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
           .flatExtracting("children")
           .contains(bart, maggie)
           .contains("Sauron");
+    softly.assertThat(names)
+          .overridingErrorMessage("error message")
+          .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
+          .as("filteredOn with consumer")
+          .hasSize(5);
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(32);
+    assertThat(errorsCollected).hasSize(33);
     assertThat(errorsCollected.get(0)).hasMessage("[extracting(throwingFirstNameExtractor)] error message");
     assertThat(errorsCollected.get(1)).hasMessage("[extracting(throwingFirstNameExtractor)] error message");
     assertThat(errorsCollected.get(2)).hasMessage("[extracting(\"last\")] error message");
@@ -1196,6 +1201,7 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(29)).hasMessage("[filteredOn firstName = null] error message");
     assertThat(errorsCollected.get(30)).hasMessage("[using flatExtracting(String... fieldOrPropertyNames)] error message");
     assertThat(errorsCollected.get(31)).hasMessage("[using flatExtracting(String fieldOrPropertyName)] error message");
+    assertThat(errorsCollected.get(32)).hasMessage("[filteredOn with consumer] error message");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
@@ -1339,9 +1345,14 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
           .flatExtracting("children")
           .contains(bart, maggie)
           .contains("Sauron");
+    softly.assertThat(names)
+          .overridingErrorMessage("error message")
+          .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
+          .as("filteredOn with consumer")
+          .hasSize(5);
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(32);
+    assertThat(errorsCollected).hasSize(33);
     assertThat(errorsCollected.get(0)).hasMessage("[extracting(throwingFirstNameExtractor)] error message");
     assertThat(errorsCollected.get(1)).hasMessage("[extracting(throwingFirstNameExtractor)] error message");
     assertThat(errorsCollected.get(2)).hasMessage("[extracting(\"last\")] error message");
@@ -1374,6 +1385,7 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(29)).hasMessage("[filteredOn firstName = null] error message");
     assertThat(errorsCollected.get(30)).hasMessage("[using flatExtracting(String... fieldOrPropertyNames)] error message");
     assertThat(errorsCollected.get(31)).hasMessage("[using flatExtracting(String fieldOrPropertyName)] error message");
+    assertThat(errorsCollected.get(32)).hasMessage("[filteredOn with consumer] error message");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
@@ -1499,9 +1511,13 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
           .flatExtracting("children")
           .contains(bart, maggie)
           .contains("Sauron");
+    softly.assertThat(names)
+          .filteredOnAssertions(name -> assertThat(name.first).startsWith("Jo"))
+          .as("filteredOn with consumer")
+          .hasSize(5);
     // THEN
     List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(29);
+    assertThat(errorsCollected).hasSize(30);
     assertThat(errorsCollected.get(0)).hasMessage("[extracting(Name::getFirst)] error message");
     assertThat(errorsCollected.get(1)).hasMessage("[extracting(Name::getFirst)] error message");
     assertThat(errorsCollected.get(2)).hasMessage("[extracting(\"last\")] error message")
@@ -1532,6 +1548,7 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errorsCollected.get(26)).hasMessage("[filteredOn firstName = John] error message");
     assertThat(errorsCollected.get(27)).hasMessage("[filteredOn firstName = null] error message");
     assertThat(errorsCollected.get(28)).hasMessage("[using flatExtracting(String fieldOrPropertyName)] error message");
+    assertThat(errorsCollected.get(29)).hasMessageContaining("filteredOn with consumer");
   }
 
   // the test would fail if any method was not proxyable as the assertion error would not be softly caught
@@ -1792,6 +1809,11 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
           .usingElementComparator(CaseInsensitiveStringComparator.instance)
           .filteredOn(new Condition<>(string -> string.startsWith("Ma"), "starts with Ma"))
           .containsExactly("MANU", "MAGIC");
+    softly.assertThat(names)
+          .extracting(firstNameExtractor)
+          .usingElementComparator(CaseInsensitiveStringComparator.instance)
+          .filteredOnAssertions(string -> assertThat(string).startsWith("Ma"))
+          .containsExactly("MANU", "MAGIC");
     softly.assertThat(names)
           .usingElementComparator(lastNameComparator)
           .filteredOn("first", "Manu")
@@ -1824,6 +1846,11 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
           .usingElementComparator(CaseInsensitiveStringComparator.instance)
           .filteredOn(new Condition<>(string -> string.startsWith("Ma"), "starts with Ma"))
           .containsExactly("MANU", "MAGIC");
+    softly.assertThat(names)
+          .extracting(firstNameExtractor)
+          .usingElementComparator(CaseInsensitiveStringComparator.instance)
+          .filteredOnAssertions(string -> assertThat(string).startsWith("Ma"))
+          .containsExactly("MANU", "MAGIC");
     softly.assertThat(names)
           .usingElementComparator(lastNameComparator)
           .filteredOn("first", "Manu")
@@ -1856,6 +1883,11 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
           .usingElementComparator(CaseInsensitiveStringComparator.instance)
           .filteredOn(new Condition<>(string -> string.startsWith("Ma"), "starts with Ma"))
           .containsExactly("MANU", "MAGIC");
+    softly.assertThat(names)
+          .extracting(firstNameExtractor)
+          .usingElementComparator(CaseInsensitiveStringComparator.instance)
+          .filteredOnAssertions(string -> assertThat(string).startsWith("Ma"))
+          .containsExactly("MANU", "MAGIC");
     softly.assertThat(names)
           .usingElementComparator(lastNameComparator)
           .filteredOn("first", "Manu")
diff --git a/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java b/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
index 8193c8b06..292cae775 100644
--- a/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/Iterable_special_assertion_methods_in_assumptions_Test.java
@@ -30,7 +30,7 @@ import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
 /**
- * verify that assertions final methods or methods changing the object under test in {@link IterableAssert} work with assumptions 
+ * verify that assertions final methods or methods changing the object under test in {@link IterableAssert} work with assumptions
  * (i.e. that they are proxied correctly in {@link ProxyableIterableAssert}).
  */
 @RunWith(Parameterized.class)
@@ -140,6 +140,11 @@ public class Iterable_special_assertion_methods_in_assumptions_Test extends Base
                                       .contains(frodo),
             value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName().startsWith("Fro"), "startsWith Fro"))
                                       .contains(sam)),
+        run(iterable(frodo, sam),
+            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                      .contains(frodo),
+            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                      .contains(sam)),
         run(iterable(frodo, sam),
             value -> assumeThat(value).filteredOn("name", "Frodo")
                                       .contains(frodo),
diff --git a/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java b/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java
index cca5d7783..7182a8355 100644
--- a/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/List_special_assertion_methods_in_assumptions_Test.java
@@ -18,6 +18,7 @@ import static org.assertj.core.api.Assertions.in;
 import static org.assertj.core.api.Assertions.tuple;
 import static org.assertj.core.api.Assumptions.assumeThat;
 import static org.assertj.core.api.assumptions.BaseAssumptionRunner.run;
+import static org.assertj.core.util.IterableUtil.iterable;
 
 import org.assertj.core.api.Condition;
 import org.assertj.core.api.ListAssert;
@@ -30,7 +31,7 @@ import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
 /**
- * verify that assertions final methods or methods changing the object under test in {@link ListAssert} work with assumptions 
+ * verify that assertions final methods or methods changing the object under test in {@link ListAssert} work with assumptions
  * (i.e. that they are proxied correctly in {@link ProxyableListAssert}).
  */
 @RunWith(Parameterized.class)
@@ -140,6 +141,11 @@ public class List_special_assertion_methods_in_assumptions_Test extends BaseAssu
                                       .contains(frodo),
             value -> assumeThat(value).filteredOn(new Condition<>(hero -> hero.getName().startsWith("Fro"), "startsWith Fro"))
                                       .contains(sam)),
+        run(iterable(frodo, sam),
+            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                      .contains(frodo),
+            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                      .contains(sam)),
         run(asList(frodo, sam),
             value -> assumeThat(value).filteredOn("name", "Frodo")
                                       .contains(frodo),
diff --git a/src/test/java/org/assertj/core/api/assumptions/ObjectArray_special_assertion_methods_in_assumptions_Test.java b/src/test/java/org/assertj/core/api/assumptions/ObjectArray_special_assertion_methods_in_assumptions_Test.java
index 8c889a8d6..b3ca50edb 100644
--- a/src/test/java/org/assertj/core/api/assumptions/ObjectArray_special_assertion_methods_in_assumptions_Test.java
+++ b/src/test/java/org/assertj/core/api/assumptions/ObjectArray_special_assertion_methods_in_assumptions_Test.java
@@ -30,7 +30,7 @@ import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
 /**
- * verify that assertions final methods or methods changing the object under test in {@link ObjectArrayAssert} work with assumptions 
+ * verify that assertions final methods or methods changing the object under test in {@link ObjectArrayAssert} work with assumptions
  * (i.e. that they are proxied correctly in {@link ProxyableObjectArrayAssert}).
  */
 @RunWith(Parameterized.class)
@@ -147,6 +147,11 @@ public class ObjectArray_special_assertion_methods_in_assumptions_Test extends B
             value -> assumeThat(value).filteredOn(hero -> hero.getName().startsWith("Fro"))
                                       .extracting("name", "age")
                                       .contains(tuple("Sam", 35))),
+        run(array(frodo, sam),
+            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                      .contains(frodo),
+            value -> assumeThat(value).filteredOnAssertions(hero -> assertThat(hero.getName()).startsWith("Fro"))
+                                      .contains(sam)),
         run(array(1, 2, 3),
             value -> assumeThat(value).contains(1, 2),
             value -> assumeThat(value).contains(4)),
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_consumer_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_consumer_Test.java
new file mode 100644
index 000000000..dc12375ab
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_consumer_Test.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
+import static org.assertj.core.util.Sets.newHashSet;
+
+import java.util.function.Consumer;
+
+import org.assertj.core.api.IterableAssert;
+import org.assertj.core.data.TolkienCharacter;
+import org.assertj.core.data.TolkienCharacterAssert;
+import org.assertj.core.data.TolkienCharacterAssertFactory;
+import org.assertj.core.test.Employee;
+import org.assertj.core.util.CaseInsensitiveStringComparator;
+import org.junit.Test;
+
+public class IterableAssert_filteredOn_consumer_Test extends IterableAssert_filtered_baseTest {
+
+  private static Consumer<? super TolkienCharacter> nameStartingWithFro = hobbit -> assertThat(hobbit.getName()).startsWith("Fro");
+
+  @Test
+  public void should_filter_iterable_under_test_verifying_given_assertions() {
+    assertThat(employees).filteredOnAssertions(employee -> assertThat(employee.getAge()).isGreaterThan(100))
+                         .containsOnly(yoda, obiwan);
+    assertThat(newHashSet(employees)).filteredOnAssertions(employee -> assertThat(employee.getAge()).isGreaterThan(100))
+                                     .containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_fail_if_given_consumer_is_null() {
+    assertThatIllegalArgumentException().isThrownBy(() -> {
+      Consumer<? super Employee> consumer = null;
+      assertThat(employees).filteredOnAssertions(consumer);
+    }).withMessage("The element assertions should not be null");
+  }
+
+  @Test
+  public void shoul_honor_AssertFactory_strongly_typed_navigation_assertions() {
+    // GIVEN
+    Iterable<TolkienCharacter> hobbits = hobbits();
+    TolkienCharacterAssertFactory tolkienCharacterAssertFactory = new TolkienCharacterAssertFactory();
+    // THEN
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOnAssertions(nameStartingWithFro)
+                                                      .first()
+                                                      .hasAge(33);
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOnAssertions(nameStartingWithFro)
+                                                      .last()
+                                                      .hasAge(33);
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOnAssertions(nameStartingWithFro)
+                                                      .element(0)
+                                                      .hasAge(33);
+  }
+
+  @Test
+  public void shoul_honor_ClassBased_strongly_typed_navigation_assertions() {
+    // GIVEN
+    Iterable<TolkienCharacter> hobbits = hobbits();
+    // THEN
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOnAssertions(nameStartingWithFro)
+                                                     .first()
+                                                     .hasAge(33);
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOnAssertions(nameStartingWithFro)
+                                                     .last()
+                                                     .hasAge(33);
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOnAssertions(nameStartingWithFro)
+                                                     .element(0)
+                                                     .hasAge(33);
+  }
+
+  @Test
+  public void should_keep_assertion_state() {
+    // GIVEN
+    Iterable<String> names = asList("John", "Doe", "Jane", "Doe");
+    // WHEN
+    IterableAssert<String> assertion = assertThat(names).as("test description")
+                                                        .withFailMessage("error message")
+                                                        .withRepresentation(UNICODE_REPRESENTATION)
+                                                        .usingElementComparator(CaseInsensitiveStringComparator.instance)
+                                                        .filteredOnAssertions(string -> assertThat(string.length()).isEqualTo(4))
+                                                        .containsExactly("JOHN", "JANE");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/list/ListAssert_filteredOn_consumer_with_navigation_Test.java b/src/test/java/org/assertj/core/api/list/ListAssert_filteredOn_consumer_with_navigation_Test.java
new file mode 100644
index 000000000..e4a87f7ee
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/list/ListAssert_filteredOn_consumer_with_navigation_Test.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.list;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.function.Consumer;
+
+import org.assertj.core.data.TolkienCharacter;
+import org.assertj.core.data.TolkienCharacterAssert;
+import org.assertj.core.data.TolkienCharacterAssertFactory;
+import org.junit.Test;
+
+public class ListAssert_filteredOn_consumer_with_navigation_Test extends ListAssert_filteredOn_BaseTest {
+
+  private static Consumer<? super TolkienCharacter> nameStartingWithFro = hobbit -> assertThat(hobbit.getName()).startsWith("Fro");
+  @Test
+  public void shoul_honor_AssertFactory_strongly_typed_navigation_assertions() {
+    // GIVEN
+    Iterable<TolkienCharacter> hobbits = hobbits();
+    TolkienCharacterAssertFactory tolkienCharacterAssertFactory = new TolkienCharacterAssertFactory();
+    // THEN
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOnAssertions(nameStartingWithFro)
+                                                      .first()
+                                                      .hasAge(33);
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOnAssertions(nameStartingWithFro)
+                                                      .last()
+                                                      .hasAge(33);
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOnAssertions(nameStartingWithFro)
+                                                      .element(0)
+                                                      .hasAge(33);
+  }
+
+  @Test
+  public void shoul_honor_ClassBased_strongly_typed_navigation_assertions() {
+    // GIVEN
+    Iterable<TolkienCharacter> hobbits = hobbits();
+    // THEN
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOnAssertions(nameStartingWithFro)
+                                                     .first()
+                                                     .hasAge(33);
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOnAssertions(nameStartingWithFro)
+                                                     .last()
+                                                     .hasAge(33);
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOnAssertions(nameStartingWithFro)
+                                                     .element(0)
+                                                     .hasAge(33);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOnAssertions_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOnAssertions_Test.java
new file mode 100644
index 000000000..41d04b85e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOnAssertions_Test.java
@@ -0,0 +1,115 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.objectarray;
+
+import static java.util.Arrays.asList;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+
+import java.util.function.Consumer;
+
+import org.assertj.core.api.IterableAssert;
+import org.assertj.core.data.TolkienCharacter;
+import org.assertj.core.data.TolkienCharacterAssert;
+import org.assertj.core.data.TolkienCharacterAssertFactory;
+import org.assertj.core.test.Employee;
+import org.assertj.core.util.CaseInsensitiveStringComparator;
+import org.junit.Test;
+
+public class ObjectArrayAssert_filteredOnAssertions_Test extends ObjectArrayAssert_filtered_baseTest {
+
+  private static Consumer<? super TolkienCharacter> nameStartingWithFro = hobbit -> assertThat(hobbit.getName()).startsWith("Fro");
+
+  @Test
+  public void should_filter_iterable_under_test_verifying_given_assertions() {
+    assertThat(employees).filteredOnAssertions(employee -> assertThat(employee.getAge()).isGreaterThan(100))
+                         .containsOnly(yoda, obiwan);
+    assertThat(newLinkedHashSet(employees)).filteredOnAssertions(employee -> assertThat(employee.getAge()).isGreaterThan(100))
+                                           .containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_fail_if_given_consumer_is_null() {
+    assertThatIllegalArgumentException().isThrownBy(() -> {
+      Consumer<? super Employee> consumer = null;
+      assertThat(employees).filteredOnAssertions(consumer);
+    }).withMessage("The element assertions should not be null");
+  }
+
+  @Test
+  public void shoul_honor_AssertFactory_strongly_typed_navigation_assertions() {
+    // GIVEN
+    Iterable<TolkienCharacter> hobbits = hobbits();
+    TolkienCharacterAssertFactory tolkienCharacterAssertFactory = new TolkienCharacterAssertFactory();
+    // THEN
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOnAssertions(nameStartingWithFro)
+                                                      .first()
+                                                      .hasAge(33);
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOnAssertions(nameStartingWithFro)
+                                                      .last()
+                                                      .hasAge(33);
+    assertThat(hobbits, tolkienCharacterAssertFactory).filteredOnAssertions(nameStartingWithFro)
+                                                      .element(0)
+                                                      .hasAge(33);
+  }
+
+  @Test
+  public void shoul_honor_ClassBased_strongly_typed_navigation_assertions() {
+    // GIVEN
+    Iterable<TolkienCharacter> hobbits = hobbits();
+    // THEN
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOnAssertions(nameStartingWithFro)
+                                                     .first()
+                                                     .hasAge(33);
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOnAssertions(nameStartingWithFro)
+                                                     .last()
+                                                     .hasAge(33);
+    assertThat(hobbits, TolkienCharacterAssert.class).filteredOnAssertions(nameStartingWithFro)
+                                                     .element(0)
+                                                     .hasAge(33);
+  }
+
+  @Test
+  public void should_keep_assertion_state() {
+    // GIVEN
+    Iterable<String> names = asList("John", "Doe", "Jane", "Doe");
+    // WHEN
+    IterableAssert<String> assertion = assertThat(names).as("test description")
+                                                        .withFailMessage("error message")
+                                                        .withRepresentation(UNICODE_REPRESENTATION)
+                                                        .usingElementComparator(CaseInsensitiveStringComparator.instance)
+                                                        .filteredOnAssertions(string -> assertThat(string.length()).isEqualTo(4))
+                                                        .containsExactly("JOHN", "JANE");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filtered_baseTest.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filtered_baseTest.java
index 517d0eee3..8b43b6919 100644
--- a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filtered_baseTest.java
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filtered_baseTest.java
@@ -13,6 +13,10 @@
 package org.assertj.core.api.objectarray;
 
 
+import static java.util.Arrays.asList;
+import static org.assertj.core.data.TolkienCharacter.Race.HOBBIT;
+
+import org.assertj.core.data.TolkienCharacter;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.Name;
 import org.junit.Before;
@@ -37,4 +41,10 @@ public class ObjectArrayAssert_filtered_baseTest {
     super();
   }
 
+  protected static Iterable<TolkienCharacter> hobbits() {
+    TolkienCharacter frodo = TolkienCharacter.of("Frodo", 33, HOBBIT);
+    TolkienCharacter sam = TolkienCharacter.of("Sam", 35, HOBBIT);
+    return asList(frodo, sam);
+  }
+
 }
\ No newline at end of file
