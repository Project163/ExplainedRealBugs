diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index b56f656bd..ff375e4b6 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -1207,7 +1207,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * Makes the recursive comparison to ignore collection order in all fields in the object under test.
+   * Makes the recursive comparison to ignore collection order in all fields of the object under test.
    * <p>
    * <b>Important:</b> ignoring collection order has a high performance cost because each element of the actual collection must
    * be compared to each element of the expected collection which is an O(n&sup2;) operation. For example with a collection of 100
@@ -1244,6 +1244,47 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Makes the recursive comparison to ignore array order in all fields of the object under test.
+   * <p>
+   * <b>Important:</b> ignoring array order has a high performance cost because each element of the actual array must
+   * be compared to each element of the expected array which is an O(n&sup2;) operation. For example with a array of 100
+   * elements, the number of comparisons is 100x100 = 10 000!
+   * <p>
+   * Example:
+   * <pre><code class='java'> class Person {
+   *   String name;
+   *   Person[] friends = new Person[0];
+   *   void add(FriendlyPerson newFriend) {
+   *     // ... add newFriend to friends array
+   *   }
+   * }
+   *
+   * Person sherlock1 = new Person("Sherlock Holmes");
+   * sherlock1.add(new Person("Dr. John Watson"));
+   * sherlock1.add(new Person("Molly Hooper"));
+   *
+   * Person sherlock2 = new Person("Sherlock Holmes");
+   * sherlock2.add(new Person("Molly Hooper"));
+   * sherlock2.add(new Person("Dr. John Watson"));
+   *
+   * // assertion succeeds as all fields array order is ignored in the comparison
+   * assertThat(sherlock1).usingRecursiveComparison()
+   *                      .ignoringArrayOrder()
+   *                      .isEqualTo(sherlock2);
+   *
+   * // assertion fails as fields array order is not ignored in the comparison
+   * assertThat(sherlock1).usingRecursiveComparison()
+   *                      .isEqualTo(sherlock2);</code></pre>
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   */
+  @CheckReturnValue
+  public SELF ignoringArrayOrder() {
+    recursiveComparisonConfiguration.ignoreArrayOrder(true);
+    return myself;
+  }
+
   /**
    * Makes the recursive comparison to ignore collection order in the object under test specified fields. Nested fields can be specified like this: {@code home.address.street}.
    * <p>
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 6f59d4742..eb43a983f 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -72,6 +72,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   // ignore order in collections section
   private boolean ignoreCollectionOrder = false;
+  private boolean ignoreArrayOrder = false;
   private Set<String> ignoredCollectionOrderInFields = new LinkedHashSet<>();
   private final List<Pattern> ignoredCollectionOrderInFieldsMatchingRegexes = new ArrayList<>();
 
@@ -108,6 +109,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     ignoreOverriddenEqualsForFieldsMatchingRegexes(builder.ignoredOverriddenEqualsForFieldsMatchingRegexes);
     this.ignoreAllOverriddenEquals = builder.ignoreAllOverriddenEquals;
     this.ignoreCollectionOrder = builder.ignoreCollectionOrder;
+    this.ignoreArrayOrder = builder.ignoreArrayOrder;
     this.ignoredCollectionOrderInFields = newLinkedHashSet(builder.ignoredCollectionOrderInFields);
     ignoreCollectionOrderInFieldsMatchingRegexes(builder.ignoredCollectionOrderInFieldsMatchingRegexes);
     this.typeComparators = builder.typeComparators;
@@ -348,6 +350,21 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return ignoreCollectionOrder;
   }
 
+  /**
+   * Sets whether to ignore array order in the comparison.
+   * <p>
+   * <b>Important:</b> ignoring array order has a high performance cost because each element of the actual array must
+   * be compared to each element of the expected array which is a O(n&sup2;) operation. For example with a array of 100
+   * elements, the number of comparisons is 100x100 = 10 000!
+   * <p>
+   * See {@link RecursiveComparisonAssert#ignoringArrayOrder()} for code examples.
+   *
+   * @param ignoreArrayOrder whether to ignore array order in the comparison.
+   */
+  public void ignoreArrayOrder(boolean ignoreArrayOrder) {
+    this.ignoreArrayOrder = ignoreArrayOrder;
+  }
+
   /**
    * Sets whether to ignore collection order in the comparison.
    * <p>
@@ -632,7 +649,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
                                   getIgnoredFields(), getIgnoredFieldsRegexes(), ignoredOverriddenEqualsForFields,
                                   ignoredOverriddenEqualsForTypes, ignoredOverriddenEqualsForFieldsMatchingRegexes,
                                   getIgnoredTypes(), strictTypeChecking, typeComparators, comparedFields, comparedTypes,
-                                  fieldMessages, typeMessages, compareEnumAgainstString);
+                                  fieldMessages, typeMessages, compareEnumAgainstString, ignoreArrayOrder);
   }
 
   @Override
@@ -647,6 +664,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
            && ignoreAllExpectedNullFields == other.ignoreAllExpectedNullFields
            && ignoreAllOverriddenEquals == other.ignoreAllOverriddenEquals
            && ignoreCollectionOrder == other.ignoreCollectionOrder
+           && ignoreArrayOrder == other.ignoreArrayOrder
            && java.util.Objects.equals(ignoredCollectionOrderInFields, other.ignoredCollectionOrderInFields)
            && java.util.Objects.equals(getIgnoredFields(), other.getIgnoredFields())
            && java.util.Objects.equals(comparedFields, other.comparedFields)
@@ -677,6 +695,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     describeIgnoredTypes(description);
     describeIgnoredTypesRegexes(description);
     describeOverriddenEqualsMethodsUsage(description, representation);
+    describeIgnoreArrayOrder(description);
     describeIgnoreCollectionOrder(description);
     describeIgnoredCollectionOrderInFields(description);
     describeIgnoredCollectionOrderInFieldsMatchingRegexes(description);
@@ -820,6 +839,10 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
            || matchesAnIgnoredCollectionOrderInFieldRegex(fieldLocation);
   }
 
+  public boolean shouldIgnoreArrayOrder() {
+    return ignoreArrayOrder;
+  }
+
   private void describeComparedFields(StringBuilder description) {
     if (!comparedFields.isEmpty())
       description.append("- the comparison was performed on the following fields: %s%n".formatted(describeComparedFields()));
@@ -891,8 +914,13 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return join(ignoredOverriddenEqualsForFields);
   }
 
+  private void describeIgnoreArrayOrder(StringBuilder description) {
+    if (ignoreArrayOrder) description.append("- array order was ignored in all fields in the comparison%n".formatted());
+  }
+
   private void describeIgnoreCollectionOrder(StringBuilder description) {
-    if (ignoreCollectionOrder) description.append("- collection order was ignored in all fields in the comparison%n".formatted());
+    if (ignoreCollectionOrder)
+      description.append("- collection order was ignored in all fields in the comparison%n".formatted());
   }
 
   private void describeIgnoredCollectionOrderInFields(StringBuilder description) {
@@ -1186,6 +1214,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     private String[] ignoredOverriddenEqualsForFieldsMatchingRegexes = {};
     private boolean ignoreAllOverriddenEquals = DEFAULT_IGNORE_ALL_OVERRIDDEN_EQUALS;
     private boolean ignoreCollectionOrder;
+    private boolean ignoreArrayOrder;
     private String[] ignoredCollectionOrderInFields = {};
     private String[] ignoredCollectionOrderInFieldsMatchingRegexes = {};
     private final TypeComparators typeComparators = defaultTypeComparators();
@@ -1355,6 +1384,19 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
       return this;
     }
 
+    /**
+     * Sets whether to ignore array order in the comparison.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringArrayOrder()} for code examples.
+     *
+     * @param ignoreArrayOrder whether to ignore array order in the comparison.
+     * @return this builder.
+     */
+    public Builder withIgnoreArrayOrder(boolean ignoreArrayOrder) {
+      this.ignoreArrayOrder = ignoreArrayOrder;
+      return this;
+    }
+
     /**
      * Adds the given fields to the list fields from the object under test to ignore collection order in the recursive comparison.
      * <p>
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 20309c7b3..b20ee2319 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -307,7 +307,11 @@ public class RecursiveComparisonDifferenceCalculator {
       // TODO move hasFieldTypesDifference check into each compareXXX
 
       if (dualValue.isExpectedFieldAnArray()) {
-        compareArrays(dualValue, comparisonState);
+        if (recursiveComparisonConfiguration.shouldIgnoreArrayOrder()) {
+          compareUnorderedArrays(dualValue, comparisonState);
+        } else {
+          compareArrays(dualValue, comparisonState);
+        }
         continue;
       }
 
@@ -487,7 +491,7 @@ public class RecursiveComparisonDifferenceCalculator {
 
   private static void compareArrays(DualValue dualValue, ComparisonState comparisonState) {
     if (!dualValue.isActualFieldAnArray()) {
-      // at the moment we only allow comparing arrays with arrays but we might allow comparing to collections later on
+      // at the moment we only allow comparing arrays with arrays, but we might allow comparing to collections later on
       // but only if we are not in strict type mode.
       comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an array"));
       return;
@@ -510,6 +514,35 @@ public class RecursiveComparisonDifferenceCalculator {
     }
   }
 
+  private static void compareUnorderedArrays(DualValue dualValue, ComparisonState comparisonState) {
+    if (!dualValue.isActualFieldAnArray()) {
+      // at the moment we only allow comparing arrays with arrays, but we might allow comparing to collections later on
+      // but only if we are not in strict type mode.
+      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an array"));
+      return;
+    }
+    // both values in dualValue are arrays
+    int actualArrayLength = Array.getLength(dualValue.actual);
+    int expectedArrayLength = Array.getLength(dualValue.expected);
+    if (actualArrayLength != expectedArrayLength) {
+      comparisonState.addDifference(dualValue, DIFFERENT_SIZE_ERROR.formatted("arrays", actualArrayLength, expectedArrayLength));
+      // no need to inspect elements, arrays are not equal as they don't have the same size
+      return;
+    }
+    // convert to iterables to reuse the compared unordered iterables algorithm
+    Iterable<Object> actual = asIterable(dualValue.actual, actualArrayLength);
+    Iterable<Object> expected = asIterable(dualValue.expected, expectedArrayLength);
+    doCompareUnorderedIterables(dualValue, actual, expected, comparisonState);
+  }
+
+  private static Iterable<Object> asIterable(Object array, int arrayLength) {
+    List<Object> list = new ArrayList<>(arrayLength);
+    for (int i = 0; i < arrayLength; i++) {
+      list.add(Array.get(array, i));
+    }
+    return list;
+  }
+
   /*
    * Deeply compare two Collections that must be same length and in same order.
    */
@@ -541,8 +574,7 @@ public class RecursiveComparisonDifferenceCalculator {
   }
 
   private static String differentTypeErrorMessage(DualValue dualValue, String actualTypeDescription) {
-    return DIFFERENT_ACTUAL_AND_EXPECTED_FIELD_TYPES.formatted(
-                                                               actualTypeDescription,
+    return DIFFERENT_ACTUAL_AND_EXPECTED_FIELD_TYPES.formatted(actualTypeDescription,
                                                                dualValue.actual.getClass().getCanonicalName());
   }
 
@@ -561,6 +593,11 @@ public class RecursiveComparisonDifferenceCalculator {
       // no need to inspect elements, iterables are not equal as they don't have the same size
       return;
     }
+    doCompareUnorderedIterables(dualValue, actual, expected, comparisonState);
+  }
+
+  private static void doCompareUnorderedIterables(DualValue dualValue, Iterable<?> actual, Iterable<?> expected,
+                                                  ComparisonState comparisonState) {
     List<Object> expectedElementsNotFound = list();
     for (Object expectedElement : expected) {
       boolean expectedElementMatched = false;
@@ -591,9 +628,8 @@ public class RecursiveComparisonDifferenceCalculator {
       }
     }
     if (!expectedElementsNotFound.isEmpty()) {
-      String unmatched = "The following expected elements were not matched in the actual %s:%n  %s".formatted(
-                                                                                                              actual.getClass()
-                                                                                                                    .getSimpleName(),
+      String type = actual.getClass().getSimpleName();
+      String unmatched = "The following expected elements were not matched in the actual %s:%n  %s".formatted(type,
                                                                                                               comparisonState.toStringOf(expectedElementsNotFound));
       comparisonState.addDifference(dualValue, unmatched);
       // TODO could improve the error by listing the actual elements not in expected but that would need
@@ -680,8 +716,8 @@ public class RecursiveComparisonDifferenceCalculator {
     Set<?> expectedKeysNotFound = new LinkedHashSet<>(expectedMap.keySet());
     expectedKeysNotFound.removeAll(actualMap.keySet());
     if (!expectedKeysNotFound.isEmpty()) {
-      comparisonState.addDifference(dualValue, "The following keys were not found in the actual map value:%n  %s".formatted(
-                                                                                                                            comparisonState.toStringOf(expectedKeysNotFound)));
+      comparisonState.addDifference(dualValue,
+                                    "The following keys were not found in the actual map value:%n  %s".formatted(comparisonState.toStringOf(expectedKeysNotFound)));
       return;
     }
     // actual and expected maps have the same keys, we need now to compare their values
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
index b23b39ca7..a1e87d116 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
@@ -45,7 +45,7 @@ class RecursiveComparisonConfiguration_builder_Test {
   @Test
   void should_set_ignoreAllActualNullFields() {
     // GIVEN
-    boolean value = RandomUtils.nextBoolean();
+    boolean value = RandomUtils.secure().randomBoolean();
     // WHEN
     RecursiveComparisonConfiguration configuration = configBuilder().withIgnoreAllActualNullFields(value).build();
     // THEN
@@ -55,7 +55,7 @@ class RecursiveComparisonConfiguration_builder_Test {
   @Test
   void should_set_ignoreAllActualEmptyOptionalFields() {
     // GIVEN
-    boolean value = RandomUtils.nextBoolean();
+    boolean value = RandomUtils.secure().randomBoolean();
     // WHEN
     RecursiveComparisonConfiguration configuration = configBuilder().withIgnoreAllActualEmptyOptionalFields(value).build();
     // THEN
@@ -65,7 +65,7 @@ class RecursiveComparisonConfiguration_builder_Test {
   @Test
   void should_set_ignoreAllExpectedNullFields() {
     // GIVEN
-    boolean value = RandomUtils.nextBoolean();
+    boolean value = RandomUtils.secure().randomBoolean();
     // WHEN
     RecursiveComparisonConfiguration configuration = configBuilder().withIgnoreAllExpectedNullFields(value).build();
     // THEN
@@ -75,7 +75,7 @@ class RecursiveComparisonConfiguration_builder_Test {
   @Test
   void should_set_ignoreAllOverriddenEquals() {
     // GIVEN
-    boolean value = RandomUtils.nextBoolean();
+    boolean value = RandomUtils.secure().randomBoolean();
     // WHEN
     RecursiveComparisonConfiguration configuration = configBuilder().withIgnoreAllOverriddenEquals(value).build();
     // THEN
@@ -85,13 +85,23 @@ class RecursiveComparisonConfiguration_builder_Test {
   @Test
   void should_set_ignoreCollectionOrder() {
     // GIVEN
-    boolean value = RandomUtils.nextBoolean();
+    boolean value = RandomUtils.secure().randomBoolean();
     // WHEN
     RecursiveComparisonConfiguration configuration = configBuilder().withIgnoreCollectionOrder(value).build();
     // THEN
     then(configuration.getIgnoreCollectionOrder()).isEqualTo(value);
   }
 
+  @Test
+  void should_set_ignoreArrayOrder() {
+    // GIVEN
+    boolean value = RandomUtils.secure().randomBoolean();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = configBuilder().withIgnoreArrayOrder(value).build();
+    // THEN
+    then(configuration.shouldIgnoreArrayOrder()).isEqualTo(value);
+  }
+
   @Test
   void should_set_ignoreCollectionOrderInFields() {
     // GIVEN
@@ -190,7 +200,7 @@ class RecursiveComparisonConfiguration_builder_Test {
   @Test
   void should_set_strictTypeCheckingMode() {
     // GIVEN
-    boolean value = RandomUtils.nextBoolean();
+    boolean value = RandomUtils.secure().randomBoolean();
     // WHEN
     RecursiveComparisonConfiguration configuration = configBuilder().withStrictTypeChecking(value).build();
     // THEN
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index e90d35e73..4db114c15 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -347,6 +347,7 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFieldsMatchingRegexes(".*oo", ".ar", "oo.ba");
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForTypes(String.class, Multimap.class);
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFields("foo", "baz", "foo.baz");
+    recursiveComparisonConfiguration.ignoreArrayOrder(true);
     recursiveComparisonConfiguration.ignoreCollectionOrder(true);
     recursiveComparisonConfiguration.ignoreCollectionOrderInFields("foo", "bar", "foo.bar");
     recursiveComparisonConfiguration.ignoreCollectionOrderInFieldsMatchingRegexes("f.*", "ba.", "foo.*");
@@ -372,6 +373,7 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
                "  - the following fields: foo, baz, foo.baz%n" +
                "  - the following types: java.lang.String, com.google.common.collect.Multimap%n" +
                "  - the fields matching the following regexes: .*oo, .ar, oo.ba%n" +
+                 "- array order was ignored in all fields in the comparison%n" +
                "- collection order was ignored in all fields in the comparison%n" +
                "- collection order was ignored in the following fields in the comparison: foo, bar, foo.bar%n" +
                "- collection order was ignored in the fields matching the following regexes in the comparison: f.*, ba., foo.*%n" +
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_shouldIgnoreArrayOrder_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_shouldIgnoreArrayOrder_Test.java
new file mode 100644
index 000000000..9613ccb45
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_shouldIgnoreArrayOrder_Test.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.configuration;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+class RecursiveComparisonConfiguration_shouldIgnoreArrayOrder_Test {
+
+  @ParameterizedTest(name = "{0} array order should be ignored")
+  @ValueSource(booleans = { true, false })
+  void should_ignore_array_order(boolean ignoreArrayOrder) {
+    // GIVEN
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+    recursiveComparisonConfiguration.ignoreArrayOrder(ignoreArrayOrder);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldIgnoreArrayOrder();
+    // THEN
+    assertThat(ignored).as("array order should be ignored").isEqualTo(ignoreArrayOrder);
+  }
+
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_fluent_API_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_fluent_API_Test.java
index 11fe509e1..e2d12a3e2 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_fluent_API_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_fluent_API_Test.java
@@ -205,6 +205,16 @@ class RecursiveComparisonAssert_fluent_API_Test extends WithComparingFieldsIntro
     then(currentConfiguration.getIgnoreCollectionOrder()).isTrue();
   }
 
+  @Test
+  void should_allow_to_ignore_array_order() {
+    // WHEN
+    var currentConfiguration = assertThat(ACTUAL).usingRecursiveComparison(recursiveComparisonConfiguration)
+                                                 .ignoringArrayOrder()
+                                                 .getRecursiveComparisonConfiguration();
+    // THEN
+    then(currentConfiguration.shouldIgnoreArrayOrder()).isTrue();
+  }
+
   @Test
   void should_allow_to_ignore_collection_order_in_fields() {
     // GIVEN
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_ignoringArrayOrder_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_ignoringArrayOrder_Test.java
new file mode 100644
index 000000000..e9daf5afd
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_ignoringArrayOrder_Test.java
@@ -0,0 +1,338 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.fields;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.registerFormatterForType;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.tests.core.api.recursive.comparison.fields.RecursiveComparisonAssert_isEqualTo_ignoringArrayOrder_Test.FriendlyPerson.friend;
+import static org.assertj.tests.core.api.recursive.comparison.fields.RecursiveComparisonAssert_isEqualTo_ignoringArrayOrder_Test.Type.FIRST;
+import static org.assertj.tests.core.api.recursive.comparison.fields.RecursiveComparisonAssert_isEqualTo_ignoringArrayOrder_Test.Type.SECOND;
+import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.Objects;
+import java.util.stream.Stream;
+
+import org.assertj.tests.core.api.recursive.data.Person;
+import org.assertj.tests.core.api.recursive.data.WithObject;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class RecursiveComparisonAssert_isEqualTo_ignoringArrayOrder_Test extends WithComparingFieldsIntrospectionStrategyBaseTest {
+
+  static class FriendlyPerson extends Person {
+    public FriendlyPerson[] friends;
+
+    public FriendlyPerson(String name, FriendlyPerson... friends) {
+      super(name);
+      this.friends = friends;
+    }
+
+    public static FriendlyPerson friend(String name) {
+      return new FriendlyPerson(name);
+    }
+
+  }
+
+  @ParameterizedTest(name = "{0}: actual={1} / expected={2}")
+  @MethodSource
+  @SuppressWarnings("unused")
+  void should_pass_for_objects_with_the_same_data_when_array_order_is_ignored(String description,
+                                                                              Object actual,
+                                                                              Object expected) {
+    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                      .ignoringArrayOrder()
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> should_pass_for_objects_with_the_same_data_when_array_order_is_ignored() {
+    var sherlock1 = new FriendlyPerson("Sherlock Holmes", friend("Dr. John Watson"), friend("Molly Hooper"));
+    var sherlock1Clone = new FriendlyPerson("Sherlock Holmes", friend("Dr. John Watson"), friend("Molly Hooper"));
+    var sherlock2 = new FriendlyPerson("Sherlock Holmes", friend("Molly Hooper"), friend("Dr. John Watson"));
+
+    FriendlyPerson watson1 = new FriendlyPerson("Dr. John Watson", friend("D.I. Greg Lestrade"), friend("Mrs. Hudson"));
+    FriendlyPerson watson2 = new FriendlyPerson("Dr. John Watson", friend("Mrs. Hudson"), friend("D.I. Greg Lestrade"));
+    FriendlyPerson sherlock3 = new FriendlyPerson("Sherlock Holmes", watson1, friend("Molly Hooper"));
+    FriendlyPerson sherlock4 = new FriendlyPerson("Sherlock Holmes", friend("Molly Hooper"), watson2);
+
+    return Stream.of(arguments("same data", sherlock1, sherlock1Clone),
+                     arguments("same data except friends order", sherlock1, sherlock2),
+                     arguments("same data except friends order in subfield", sherlock3, sherlock4));
+  }
+
+  @Test
+  void should_fail_when_actual_differs_from_expected_even_when_collection_order_is_ignored() {
+    // GIVEN
+    var actual = new FriendlyPerson("Sherlock Holmes", friend("Dr. John Watson"), friend("Molly Hooper"));
+    actual.home.address.number = 1;
+    var expected = new FriendlyPerson("Sherlock Holmes", friend("Molly Hooper"), friend("Dr. John Watson"));
+    expected.home.address.number = 2;
+    // WHEN
+    recursiveComparisonConfiguration.ignoreArrayOrder(true);
+    // THEN
+    compareRecursivelyFailsWithDifferences(actual, expected, javaTypeDiff("home.address.number", 1, 2));
+  }
+
+  /**
+   * This test shows that we can't track all visited values, only the one with potential cycles.
+   * <p>
+   * Let's run it step by step with tracking all visited values:<br>
+   * array(arrayA, arrayB) vs array(arrayAReverse, arrayBReverse) means trying to find<br>
+   * - arrayA in array(arrayAReverse, arrayBReverse) and then arrayB
+   * <p>
+   * After comparing possible pairs (arrayA element, arrayAReverse element) we conclude that arrayA matches arrayAReverse<br>
+   * - here are the pairs (1, 2), (1, 1), (2, 2), we add them to the visited ones<br>
+   * <p>
+   * We now try to find arrayB in array(arrayBReverse) - arrayAReverse must not be taken into account as it had already been matched<br>
+   * - we would like to try (1, 2), (1, 1), (2, 2) but they have already been visited, so we skip them.<br>
+   * at this point, we know arrayB won't be found because (1, 1), (2, 2) won't be considered.<br>
+   * We compare dual values but not the location since to track cycles we want to find the same objects at different locations
+   * <p>
+   * Comparing dualValues actual and expected with == does not solve the issue because Java does not always create different objects
+   * for primitive wrapping the same basic value, i.e. {@code new Integer(1) == new Integer(1)}.
+   * <p>
+   * The solution is to avoid adding all pairs to visited values. <br>
+   * Visited values are here to track cycles, a pair of wrapped primitive types can't cycle back to itself, we thus can and must ignore them.
+   * <p>
+   * For good measure we don't track pair that include any java.lang values.
+   * <p>
+   * If arrayA and arrayB contained non wrapped basic types then == is enough to differentiate them.
+   */
+  @Test
+  void should_fix_1854_minimal_test() {
+    // GIVEN
+    Integer[] arrayA = array(1, 2);
+    Integer[] arrayB = array(1, 2);
+    WithObject actual = new WithObject(array(arrayA, arrayB));
+    WithObject actualClone = new WithObject(array(arrayA, arrayB));
+    // Reversed arrays
+    Integer[] reversedArrayA = array(2, 1);
+    Integer[] reversedArrayB = array(2, 1);
+    WithObject expected = new WithObject(array(reversedArrayA, reversedArrayB));
+    // WHEN - THEN
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .ignoringArrayOrder()
+                .isEqualTo(expected)
+                .isEqualTo(actualClone);
+  }
+
+  @Test
+  void should_fix_1854_with_non_wrapped_basic_types() {
+    // GIVEN
+    FriendlyPerson p1 = friend("Sherlock Holmes");
+    FriendlyPerson p2 = friend("Watson");
+    FriendlyPerson p3 = friend("Sherlock Holmes");
+    FriendlyPerson p4 = friend("Watson");
+    FriendlyPerson[] arrayA = array(p1, p2);
+    FriendlyPerson[] arrayB = array(p1, p2);
+    WithObject actual = new WithObject(array(arrayA, arrayB));
+    // Reversed lists
+    FriendlyPerson[] reversedArrayA = array(p4, p3);
+    FriendlyPerson[] reversedArrayB = array(p4, p3);
+    WithObject expected = new WithObject(array(reversedArrayA, reversedArrayB));
+    // WHEN - THEN
+    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                      .ignoringArrayOrder()
+                      .isEqualTo(expected);
+  }
+
+  enum Type {
+    FIRST, SECOND,
+  }
+
+  static class PersonWithEnum {
+    String name;
+    Type type;
+
+    PersonWithEnum(String name, Type type) {
+      this.name = name;
+      this.type = type;
+    }
+
+    @Override
+    public String toString() {
+      return "Person [name=%s, type=%s]".formatted(name, type);
+    }
+
+  }
+
+  static class PersonWithInt {
+    String name;
+    int type;
+
+    PersonWithInt(String name, int type) {
+      this.name = name;
+      this.type = type;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+      PersonWithInt that = (PersonWithInt) o;
+      return type == that.type && Objects.equals(name, that.name);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(name, type);
+    }
+
+    @Override
+    public String toString() {
+      return "Person [name=%s, type=%s]".formatted(name, type);
+    }
+
+  }
+
+  @ParameterizedTest(name = "{0}: actual={1} / expected={2}")
+  @MethodSource
+  @SuppressWarnings("unused")
+  public void should_not_remove_already_visited_dual_values_that_cant_produce_cycles(String description,
+                                                                                     WithObject actual,
+                                                                                     WithObject expected) {
+    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                      .ignoringArrayOrder()
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> should_not_remove_already_visited_dual_values_that_cant_produce_cycles() {
+    WithObject actualWithEnum = new WithObject(array(new PersonWithEnum("name-1", FIRST),
+                                                     new PersonWithEnum("name-2", FIRST),
+                                                     new PersonWithEnum("name-2", SECOND)));
+    WithObject expectedWithEnum = new WithObject(array(new PersonWithEnum("name-2", SECOND),
+                                                       new PersonWithEnum("name-2", FIRST),
+                                                       new PersonWithEnum("name-1", FIRST)));
+    WithObject actualWithInt = new WithObject(array(new PersonWithInt("name-1", 1),
+                                                    new PersonWithInt("name-2", 1),
+                                                    new PersonWithInt("name-2", 2)));
+    WithObject expectedWithInt = new WithObject(array(new PersonWithInt("name-2", 2),
+                                                      new PersonWithInt("name-2", 1),
+                                                      new PersonWithInt("name-1", 1)));
+    return Stream.of(arguments("with enums", actualWithEnum, expectedWithEnum),
+                     arguments("with ints", actualWithInt, expectedWithInt));
+  }
+
+  // https://github.com/assertj/assertj/issues/2954 but for arrays
+
+  static class DataStore {
+    Data[] field1;
+    Data[] field2;
+
+    @Override
+    public String toString() {
+      return "DataStore[field1=%s, field2=%s]".formatted(field1, field2);
+    }
+  }
+
+  record Data(String text) {
+  }
+
+  private static DataStore createDataStore(Data d1, Data d2) {
+    DataStore dataStore = new DataStore();
+    dataStore.field1 = array(d1, d2);
+    dataStore.field2 = array(d1, d2);
+    return dataStore;
+  }
+
+  @Test
+  void evaluating_visited_dual_values_should_check_location() {
+    // GIVEN
+    Data d1 = new Data("111");
+    Data d2 = new Data("222");
+    DataStore dataStore1 = createDataStore(d1, d2);
+    DataStore dataStore2 = createDataStore(d2, d1);
+    // WHEN/THEN
+    then(dataStore1).usingRecursiveComparison(recursiveComparisonConfiguration)
+                    .withEqualsForType((data1, data2) -> data1.text.equals(data2.text), Data.class)
+                    .ignoringArrayOrder()
+                    .isEqualTo(dataStore2);
+  }
+
+  // related to https://github.com/assertj/assertj/issues/3598 but for arrays
+
+  static class Outer {
+    public Inner inner;
+
+    public Outer(Inner inner) {
+      this.inner = inner;
+    }
+
+    public String toString() {
+      return "O" + inner;
+    }
+  }
+
+  static class Inner {
+    public int val;
+
+    public Inner(int val) {
+      this.val = val;
+    }
+
+    public String toString() {
+      return "I" + val;
+    }
+  }
+
+  @Test
+  public void should_fix_3598() {
+    // GIVEN
+    Inner i1 = new Inner(1);
+    Inner i2 = new Inner(2);
+    Inner i3 = new Inner(3);
+
+    Outer o1A = new Outer(i1);
+    Outer o2A = new Outer(i2);
+    Outer o3A = new Outer(i3);
+    Outer o1B = new Outer(i1);
+    Outer o2B = new Outer(i2);
+    Outer o3B = new Outer(i3);
+
+    Outer[] arrayA = array(o1A, o2A, o3A);
+    Outer[] arrayB = array(o2B, o1B, o3B);
+    Outer[] arrayACopy = array(o1A, o2A, o3A);
+    Outer[] arrayBCopy = array(o2B, o1B, o3B);
+
+    WithObject actual = new WithObject(array(arrayA, arrayACopy));
+    WithObject expected = new WithObject(array(arrayB, arrayBCopy));
+
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .ignoringArrayOrder()
+                .isEqualTo(expected);
+  }
+
+  record Item(String name, int quantity) {
+  }
+
+  @Test
+  void should_honor_representation_in_unmatched_elements_when_comparing_iterables_ignoring_order() {
+    // GIVEN
+    WithObject actual = new WithObject(array(new Item("Pants", 3), new Item("Loafers", 1)));
+    WithObject expected = new WithObject(array(new Item("Shoes", 2), new Item("Pants", 3)));
+    registerFormatterForType(Item.class, item -> "Item(%s, %d)".formatted(item.name(), item.quantity()));
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                                                                      .ignoringArrayOrder()
+                                                                      .isEqualTo(expected));
+    // THEN
+    then(assertionError).hasMessageContaining(format("The following expected elements were not matched in the actual ArrayList:%n"
+                                                     + "  [Item(Shoes, 2)]"));
+  }
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/FriendlyPerson.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/FriendlyPerson.java
index 41efef62f..f28691663 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/FriendlyPerson.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/FriendlyPerson.java
@@ -20,6 +20,7 @@ import java.util.Set;
 public class FriendlyPerson extends Person {
   public List<FriendlyPerson> friends = new ArrayList<>();
   public Set<FriendlyPerson> otherFriends = new HashSet<>();
+  public FriendlyPerson[] arrayFriends = new FriendlyPerson[0];
 
   public FriendlyPerson() {
     super();
@@ -32,4 +33,9 @@ public class FriendlyPerson extends Person {
   public static FriendlyPerson friend(String name) {
     return new FriendlyPerson(name);
   }
+
+  public void add(FriendlyPerson friend) {
+    friends.add(friend);
+    arrayFriends = friends.toArray(new FriendlyPerson[0]);
+  }
 }
