diff --git a/assertj-core/src/main/java/org/assertj/core/api/Assertions.java b/assertj-core/src/main/java/org/assertj/core/api/Assertions.java
index 630aacfc5..edcb98e49 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/Assertions.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/Assertions.java
@@ -12,6 +12,7 @@
  */
 package org.assertj.core.api;
 
+import static java.util.Objects.requireNonNull;
 import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION_PROVIDER;
 import static org.assertj.core.data.Percentage.withPercentage;
 
@@ -36,6 +37,7 @@ import java.time.OffsetTime;
 import java.time.Period;
 import java.time.YearMonth;
 import java.time.ZonedDateTime;
+import java.time.temporal.ChronoUnit;
 import java.time.temporal.Temporal;
 import java.time.temporal.TemporalUnit;
 import java.util.Collection;
@@ -2454,6 +2456,24 @@ public class Assertions implements InstanceOfAssertFactories {
     return Offset.offset(value);
   }
 
+  /**
+   * Assertions entry point for {@link Duration} with less than or equal condition to use with isCloseTo temporal assertions.
+   * <p>
+   * Typical usage:
+   * <pre><code class='java'> LocalTime _07_10 = LocalTime.of(7, 10);
+   * LocalTime _07_12 = LocalTime.of(7, 12);
+   * assertThat(_07_10).isCloseTo(_07_12, within(Duration.ofMinutes(5)));</code></pre>
+   *
+   * @param duration the {@link Duration} of the offset
+   * @return the created {@code Offset}.
+   * @since 3.27.0
+   * @see #byLessThan(Duration)
+   */
+  public static TemporalUnitOffset within(Duration duration) {
+    requireNonNull(duration, "non null duration expected");
+    return new TemporalUnitWithinOffset(duration.toNanos(), ChronoUnit.NANOS);
+  }
+
   /**
    * Assertions entry point for {@link TemporalUnitOffset} with less than or equal condition
    * to use with isCloseTo temporal assertions.
@@ -2662,6 +2682,24 @@ public class Assertions implements InstanceOfAssertFactories {
     return Offset.strictOffset(value);
   }
 
+  /**
+   * Assertions entry point for {@link Duration} with strict less than condition to use with {@code isCloseTo} temporal assertions.
+   * <p>
+   * Typical usage:
+   * <pre><code class='java'> LocalTime _07_10 = LocalTime.of(7, 10);
+   * LocalTime _07_12 = LocalTime.of(7, 12);
+   * assertThat(_07_10).isCloseTo(_07_12, byLessThan(Duration.ofMinutes(5)));</code></pre>
+   *
+   * @param duration the {@link Duration} of the offset.
+   * @return the created {@code Offset}.
+   * @since 3.27.0
+   * @see #within(Duration)
+   */
+  public static TemporalUnitOffset byLessThan(Duration duration) {
+    requireNonNull(duration, "non null duration expected");
+    return new TemporalUnitLessThanOffset(duration.toNanos(), ChronoUnit.NANOS);
+  }
+
   /**
    * Assertions entry point for {@link TemporalUnitOffset} with strict less than condition
    * to use with {@code isCloseTo} temporal assertions.
diff --git a/assertj-core/src/main/java/org/assertj/core/api/BDDAssertions.java b/assertj-core/src/main/java/org/assertj/core/api/BDDAssertions.java
index 0faf1032a..e6c761dfb 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/BDDAssertions.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/BDDAssertions.java
@@ -2965,6 +2965,23 @@ public class BDDAssertions extends Assertions {
     return Assertions.within(value, unit);
   }
 
+  /**
+   * Assertions entry point for {@link Duration} with less than or equal condition to use with isCloseTo temporal assertions.
+   * <p>
+   * Typical usage:
+   * <pre><code class='java'> LocalTime _07_10 = LocalTime.of(7, 10);
+   * LocalTime _07_12 = LocalTime.of(7, 12);
+   * then(_07_10).isCloseTo(_07_12, within(Duration.ofMinutes(5)));</code></pre>
+   *
+   * @param duration the {@link Duration} of the offset
+   * @return the created {@code Offset}.
+   * @since 3.27.0
+   * @see #byLessThan(Duration)
+   */
+  public static TemporalUnitOffset within(Duration duration) {
+    return Assertions.within(duration);
+  }
+
   /**
    * Syntactic sugar method to use with {@link AbstractDurationAssert#isCloseTo(Duration, Duration)} assertion.
    * <p>
@@ -3196,6 +3213,23 @@ public class BDDAssertions extends Assertions {
     return Assertions.byLessThan(value, unit);
   }
 
+  /**
+   * Assertions entry point for {@link Duration} with strict less than condition to use with {@code isCloseTo} temporal assertions.
+   * <p>
+   * Typical usage:
+   * <pre><code class='java'> LocalTime _07_10 = LocalTime.of(7, 10);
+   * LocalTime _07_12 = LocalTime.of(7, 12);
+   * then(_07_10).isCloseTo(_07_12, byLessThan(Duration.ofMinutes(5)));</code></pre>
+   *
+   * @param duration the {@link Duration} of the offset.
+   * @return the created {@code Offset}.
+   * @since 3.27.0
+   * @see #within(Duration)
+   */
+  public static TemporalUnitOffset byLessThan(Duration duration) {
+    return Assertions.byLessThan(duration);
+  }
+
   /**
    * A syntax sugar to write fluent assertion using {@link ObjectAssert#returns(Object, Function)} and
    * {@link ObjectAssert#doesNotReturn(Object, Function)}.
diff --git a/assertj-core/src/main/java/org/assertj/core/api/WithAssertions.java b/assertj-core/src/main/java/org/assertj/core/api/WithAssertions.java
index 1c96f5485..1e4c02f9b 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/WithAssertions.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/WithAssertions.java
@@ -102,13 +102,13 @@ import org.assertj.core.util.CheckReturnValue;
 
 /**
  * A unified entry point to all non-deprecated assertions from both the new Java 8 core API and the pre-Java 8 core API.
- *
+ * <p>
  * As a convenience, the methods are defined in an interface so that no static imports are necessary if the test class
  * implements this interface.
- *
+ * <p>
  * Based on an idea by David Gageot :
- *
- * http://blog.javabien.net/2014/04/23/what-if-assertj-used-java-8/
+ * <p>
+ * <a href="http://blog.javabien.net/2014/04/23/what-if-assertj-used-java-8/">http://blog.javabien.net/2014/04/23/what-if-assertj-used-java-8/</a>
  *
  * @author Alan Rothkopf
  *
@@ -1810,6 +1810,23 @@ public interface WithAssertions extends InstanceOfAssertFactories {
     return Assertions.within(value, unit);
   }
 
+  /**
+   * Assertions entry point for {@link Duration} with less than or equal condition to use with isCloseTo temporal assertions.
+   * <p>
+   * Typical usage:
+   * <pre><code class='java'> LocalTime _07_10 = LocalTime.of(7, 10);
+   * LocalTime _07_12 = LocalTime.of(7, 12);
+   * assertThat(_07_10).isCloseTo(_07_12, within(Duration.ofMinutes(5)));</code></pre>
+   *
+   * @param duration the {@link Duration} of the offset
+   * @return the created {@code Offset}.
+   * @since 3.27.0
+   * @see #byLessThan(Duration)
+   */
+  default TemporalUnitOffset within(Duration duration) {
+    return Assertions.within(duration);
+  }
+
   /**
    * Syntactic sugar method to use with {@link AbstractDurationAssert#isCloseTo(Duration, Duration)} assertion.
    * <p>
@@ -2020,6 +2037,23 @@ public interface WithAssertions extends InstanceOfAssertFactories {
     return Assertions.byLessThan(value, unit);
   }
 
+  /**
+   * Assertions entry point for {@link Duration} with strict less than condition to use with {@code isCloseTo} temporal assertions.
+   * <p>
+   * Typical usage:
+   * <pre><code class='java'> LocalTime _07_10 = LocalTime.of(7, 10);
+   * LocalTime _07_12 = LocalTime.of(7, 12);
+   * assertThat(_07_10).isCloseTo(_07_12, byLessThan(Duration.ofMinutes(5)));</code></pre>
+   *
+   * @param duration the {@link Duration} of the offset.
+   * @return the created {@code Offset}.
+   * @since 3.27.0
+   * @see #within(Duration)
+   */
+  default TemporalUnitOffset byLessThan(Duration duration) {
+    return Assertions.byLessThan(duration);
+  }
+
   /**
    * A syntax sugar to write fluent assertion using {@link ObjectAssert#returns(Object, Function)} and
    * {@link ObjectAssert#doesNotReturn(Object, Function)}.
diff --git a/assertj-core/src/test/java/org/assertj/core/api/AbstractTemporalAssert_isCloseTo_Test.java b/assertj-core/src/test/java/org/assertj/core/api/AbstractTemporalAssert_isCloseTo_Test.java
index 0636d4cb1..4f779b8d3 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/AbstractTemporalAssert_isCloseTo_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/AbstractTemporalAssert_isCloseTo_Test.java
@@ -27,16 +27,18 @@ import static java.time.temporal.ChronoUnit.MILLIS;
 import static java.time.temporal.ChronoUnit.MINUTES;
 import static java.time.temporal.ChronoUnit.WEEKS;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
 import static org.assertj.core.api.Assertions.assertThatTemporal;
 import static org.assertj.core.api.Assertions.byLessThan;
 import static org.assertj.core.api.Assertions.within;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.BDDAssertions.thenExceptionOfType;
 import static org.assertj.core.api.BDDAssertions.thenTemporal;
+import static org.assertj.core.error.ShouldBeCloseTo.shouldBeCloseTo;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
+import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDate;
 import java.time.LocalDateTime;
@@ -54,6 +56,7 @@ import java.util.stream.Stream;
 
 import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.data.TemporalUnitOffset;
+import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 import org.junit.jupiter.params.provider.MethodSource;
@@ -62,6 +65,23 @@ class AbstractTemporalAssert_isCloseTo_Test {
 
   private static final ZoneId NEW_YORK_ZONE = ZoneId.of("America/New_York");
 
+  private static final Instant _2017_Mar_12_07_10_Instant = Instant.parse("2017-03-12T07:10:00.00Z");
+  private static final Instant _2017_Mar_12_07_12_Instant = Instant.parse("2017-03-12T07:12:00.00Z");
+  private static final Instant _2017_Mar_08_07_10_Instant = Instant.parse("2017-03-08T07:10:00.00Z");
+  private static final LocalDate _2017_Mar_10 = LocalDate.of(2017, Month.MARCH, 10);
+  private static final LocalDate _2017_Mar_12 = LocalDate.of(2017, Month.MARCH, 12);
+  private static final LocalDate _2017_Mar_27 = LocalDate.of(2017, Month.MARCH, 27);
+  private static final LocalDate _2017_Mar_08 = LocalDate.of(2017, Month.MARCH, 8);
+  private static final LocalTime _07_10 = LocalTime.of(7, 10);
+  private static final LocalTime _07_11 = LocalTime.of(7, 11);
+  private static final LocalTime _07_12 = LocalTime.of(7, 12);
+  private static final LocalTime _07_23 = LocalTime.of(7, 23);
+  private static final LocalDateTime _2017_Mar_12_07_10 = LocalDateTime.of(_2017_Mar_12, _07_10);
+  private static final LocalDateTime _2017_Mar_12_07_12 = LocalDateTime.of(_2017_Mar_12, _07_12);
+  private static final LocalDateTime _2017_Mar_10_07_12 = LocalDateTime.of(_2017_Mar_10, _07_12);
+  private static final LocalDateTime _2017_Mar_12_07_23 = LocalDateTime.of(_2017_Mar_12, _07_23);
+  private static final LocalDateTime _2017_Mar_08_07_10 = LocalDateTime.of(_2017_Mar_08, _07_10);
+
   private static final AbstractTemporalAssert<?, ?>[] nullAsserts = {
       assertThat((Instant) null),
       assertThat((Instant) null),
@@ -73,13 +93,6 @@ class AbstractTemporalAssert_isCloseTo_Test {
       assertThat((OffsetTime) null)
   };
 
-  private static final Instant _2017_Mar_12_07_10_Instant = Instant.parse("2017-03-12T07:10:00.00Z");
-  private static final LocalDate _2017_Mar_10 = LocalDate.of(2017, Month.MARCH, 10);
-  private static final LocalDate _2017_Mar_12 = LocalDate.of(2017, Month.MARCH, 12);
-  private static final LocalDate _2017_Mar_27 = LocalDate.of(2017, Month.MARCH, 27);
-  private static final LocalTime _07_10 = LocalTime.of(7, 10);
-  private static final LocalDateTime _2017_Mar_12_07_10 = LocalDateTime.of(_2017_Mar_12, _07_10);
-
   private static final AbstractTemporalAssert<?, ?>[] temporalAsserts = {
       assertThat(_2017_Mar_12_07_10_Instant),
       assertThat(_2017_Mar_12_07_10_Instant),
@@ -91,11 +104,6 @@ class AbstractTemporalAssert_isCloseTo_Test {
       assertThat(OffsetTime.of(_07_10, UTC))
   };
 
-  private static final Instant _2017_Mar_12_07_12_Instant = Instant.parse("2017-03-12T07:12:00.00Z");
-  private static final LocalTime _07_12 = LocalTime.of(7, 12);
-  private static final LocalDateTime _2017_Mar_12_07_12 = LocalDateTime.of(_2017_Mar_12, _07_12);
-  private static final LocalDateTime _2017_Mar_10_07_12 = LocalDateTime.of(_2017_Mar_10, _07_12);
-
   private static final Temporal[] closeTemporals = {
       _2017_Mar_12_07_12_Instant,
       _2017_Mar_12_07_10_Instant.plusMillis(1L),
@@ -107,12 +115,6 @@ class AbstractTemporalAssert_isCloseTo_Test {
       OffsetTime.of(_07_12, UTC)
   };
 
-  private static final Instant _2017_Mar_08_07_10_Instant = Instant.parse("2017-03-08T07:10:00.00Z");
-  private static final LocalTime _07_23 = LocalTime.of(7, 23);
-  private static final LocalDate _2017_Mar_08 = LocalDate.of(2017, Month.MARCH, 8);
-  private static final LocalDateTime _2017_Mar_12_07_23 = LocalDateTime.of(_2017_Mar_12, _07_23);
-  private static final LocalDateTime _2017_Mar_08_07_10 = LocalDateTime.of(_2017_Mar_08, _07_10);
-
   private static final Temporal[] farTemporals = new Temporal[] {
       _2017_Mar_08_07_10_Instant,
       Instant.MIN,
@@ -165,7 +167,8 @@ class AbstractTemporalAssert_isCloseTo_Test {
         ISO_LOCAL_DATE,
         ISO_LOCAL_TIME,
         ISO_OFFSET_DATE_TIME,
-        ISO_ZONED_DATE_TIME, ISO_TIME
+        ISO_ZONED_DATE_TIME,
+        ISO_TIME
     };
 
     int assertsLength = nullAsserts.length; // same as temporalAsserts.length
@@ -259,9 +262,9 @@ class AbstractTemporalAssert_isCloseTo_Test {
     ThrowingCallable code = () -> temporalAssert(args).isCloseTo(closeTemporal(args), inapplicableOffset);
     // THEN
     if (inapplicableOffset != null) {
-      assertThatExceptionOfType(UnsupportedTemporalTypeException.class).isThrownBy(code)
-                                                                       .withMessage("Unsupported unit: "
-                                                                                    + inapplicableOffset.getUnit());
+      thenExceptionOfType(UnsupportedTemporalTypeException.class).isThrownBy(code)
+                                                                 .withMessage("Unsupported unit: "
+                                                                              + inapplicableOffset.getUnit());
     }
   }
 
@@ -290,10 +293,9 @@ class AbstractTemporalAssert_isCloseTo_Test {
   @MethodSource("parameters")
   void should_fail_when_temporal_passed_as_string_is_outside_offset(ArgumentsAccessor args) {
     // WHEN
-    AssertionError assertionError = expectAssertionError(() -> temporalAssert(args).isCloseTo(farTemporalAsString(args),
-                                                                                              offset(args)));
+    AssertionError error = expectAssertionError(() -> temporalAssert(args).isCloseTo(farTemporalAsString(args), offset(args)));
     // THEN
-    then(assertionError).hasMessage(differenceMessage(args));
+    then(error).hasMessage(differenceMessage(args));
   }
 
   @ParameterizedTest
@@ -303,7 +305,52 @@ class AbstractTemporalAssert_isCloseTo_Test {
     thenTemporal(now).isCloseTo(now, within(1, ChronoUnit.SECONDS));
   }
 
-  public static Stream<Temporal> should_support_base_temporal_type_assertions() {
+  static Stream<Temporal> should_support_base_temporal_type_assertions() {
     return Stream.of(Instant.now(), ZonedDateTime.now(), OffsetDateTime.now());
   }
+
+  @ParameterizedTest
+  @MethodSource("within_duration")
+  void should_support_within_duration(LocalTime closeTime) {
+    assertThat(_07_10).isCloseTo(closeTime, within(Duration.ofMinutes(2)));
+  }
+
+  static Stream<LocalTime> within_duration() {
+    return Stream.of(_07_10, _07_11, _07_12.minusNanos(1), _07_12);
+  }
+
+  @Test
+  void should_fail_when_not_within_duration() {
+    // GIVEN
+    LocalTime actual = _07_10;
+    LocalTime other = _07_12;
+    TemporalUnitOffset offset = within(Duration.ofMinutes(1));
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(actual).isCloseTo(other, offset));
+    // THEN
+    then(error).hasMessage(shouldBeCloseTo(actual, other, offset.getBeyondOffsetDifferenceDescription(actual, other)).create());
+  }
+
+  @ParameterizedTest
+  @MethodSource("by_less_than_duration")
+  void should_support_less_than_with_duration(LocalTime closeTime) {
+    assertThat(_07_10).isCloseTo(closeTime, byLessThan(Duration.ofMinutes(2)));
+  }
+
+  static Stream<LocalTime> by_less_than_duration() {
+    return Stream.of(_07_10, _07_11, _07_12.minusNanos(1));
+  }
+
+  @Test
+  void should_fail_when_not_less_than_duration() {
+    // GIVEN
+    LocalTime actual = _07_10;
+    LocalTime other = _07_12;
+    TemporalUnitOffset offset = byLessThan(Duration.ofMinutes(2));
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(actual).isCloseTo(other, offset));
+    // THEN
+    then(error).hasMessage(shouldBeCloseTo(actual, other, offset.getBeyondOffsetDifferenceDescription(actual, other)).create());
+  }
+
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/EntryPointAssertions_byLessThan_Test.java b/assertj-core/src/test/java/org/assertj/core/api/EntryPointAssertions_byLessThan_Test.java
index f4aef3ebf..4de50b734 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/EntryPointAssertions_byLessThan_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/EntryPointAssertions_byLessThan_Test.java
@@ -12,11 +12,13 @@
  */
 package org.assertj.core.api;
 
+import static org.assertj.core.api.Assertions.catchNullPointerException;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.Offset.strictOffset;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.time.Duration;
 import java.time.temporal.ChronoUnit;
 import java.time.temporal.TemporalUnit;
 import java.util.function.BiFunction;
@@ -26,11 +28,9 @@ import java.util.stream.Stream;
 import org.assertj.core.data.Offset;
 import org.assertj.core.data.TemporalUnitLessThanOffset;
 import org.assertj.core.data.TemporalUnitOffset;
-import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 
-@DisplayName("EntryPoint assertions byLessThan method")
 class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest {
 
   @ParameterizedTest
@@ -39,9 +39,9 @@ class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest
     // GIVEN
     BigDecimal offsetValue = BigDecimal.ONE;
     // WHEN
-    Offset<BigDecimal> index = offsetFactory.apply(offsetValue);
+    Offset<BigDecimal> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(strictOffset(offsetValue));
+    then(offset).isEqualTo(strictOffset(offsetValue));
   }
 
   private static Stream<Function<BigDecimal, Offset<BigDecimal>>> bigDecimalOffsetFactories() {
@@ -54,9 +54,9 @@ class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest
     // GIVEN
     BigInteger offsetValue = BigInteger.ONE;
     // WHEN
-    Offset<BigInteger> index = offsetFactory.apply(offsetValue);
+    Offset<BigInteger> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(strictOffset(offsetValue));
+    then(offset).isEqualTo(strictOffset(offsetValue));
   }
 
   private static Stream<Function<BigInteger, Offset<BigInteger>>> bigIntegerOffsetFactories() {
@@ -69,9 +69,9 @@ class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest
     // GIVEN
     Byte offsetValue = Byte.MAX_VALUE;
     // WHEN
-    Offset<Byte> index = offsetFactory.apply(offsetValue);
+    Offset<Byte> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(strictOffset(offsetValue));
+    then(offset).isEqualTo(strictOffset(offsetValue));
   }
 
   private static Stream<Function<Byte, Offset<Byte>>> byteOffsetFactories() {
@@ -84,9 +84,9 @@ class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest
     // GIVEN
     Double offsetValue = Double.MAX_VALUE;
     // WHEN
-    Offset<Double> index = offsetFactory.apply(offsetValue);
+    Offset<Double> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(strictOffset(offsetValue));
+    then(offset).isEqualTo(strictOffset(offsetValue));
   }
 
   private static Stream<Function<Double, Offset<Double>>> doubleOffsetFactories() {
@@ -99,9 +99,9 @@ class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest
     // GIVEN
     Float offsetValue = Float.MAX_VALUE;
     // WHEN
-    Offset<Float> index = offsetFactory.apply(offsetValue);
+    Offset<Float> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(strictOffset(offsetValue));
+    then(offset).isEqualTo(strictOffset(offsetValue));
   }
 
   private static Stream<Function<Float, Offset<Float>>> floatOffsetFactories() {
@@ -114,9 +114,9 @@ class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest
     // GIVEN
     Integer offsetValue = Integer.MAX_VALUE;
     // WHEN
-    Offset<Integer> index = offsetFactory.apply(offsetValue);
+    Offset<Integer> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(strictOffset(offsetValue));
+    then(offset).isEqualTo(strictOffset(offsetValue));
   }
 
   private static Stream<Function<Integer, Offset<Integer>>> integerOffsetFactories() {
@@ -129,9 +129,9 @@ class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest
     // GIVEN
     Long offsetValue = Long.MAX_VALUE;
     // WHEN
-    Offset<Long> index = offsetFactory.apply(offsetValue);
+    Offset<Long> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(strictOffset(offsetValue));
+    then(offset).isEqualTo(strictOffset(offsetValue));
   }
 
   private static Stream<Function<Long, Offset<Long>>> longOffsetFactories() {
@@ -139,18 +139,44 @@ class EntryPointAssertions_byLessThan_Test extends EntryPointAssertionsBaseTest
   }
 
   @ParameterizedTest
-  @MethodSource("temporalOffsetFactories")
+  @MethodSource
   void should_create_temporal_strictOffset(BiFunction<Long, TemporalUnit, TemporalUnitOffset> offsetFactory) {
     // GIVEN
-    Long value = Long.MAX_VALUE;
+    long value = Long.MAX_VALUE;
     TemporalUnit temporalUnit = ChronoUnit.MINUTES;
     // WHEN
-    TemporalUnitOffset index = offsetFactory.apply(value, temporalUnit);
+    TemporalUnitOffset offset = offsetFactory.apply(value, temporalUnit);
+    // THEN
+    then(offset).isEqualTo(new TemporalUnitLessThanOffset(value, temporalUnit));
+  }
+
+  private static Stream<BiFunction<Long, TemporalUnit, TemporalUnitOffset>> should_create_temporal_strictOffset() {
+    return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
+  }
+
+  @ParameterizedTest
+  @MethodSource("temporal_strictOffset_from_duration")
+  void should_create_temporal_strictOffset_from_duration(Function<Duration, TemporalUnitOffset> offsetFactory) {
+    // GIVEN
+    Duration duration = Duration.ofNanos(123);
+    // WHEN
+    TemporalUnitOffset offset = offsetFactory.apply(duration);
+    // THEN
+    then(offset).isEqualTo(new TemporalUnitLessThanOffset(123, ChronoUnit.NANOS));
+  }
+
+  @ParameterizedTest
+  @MethodSource("temporal_strictOffset_from_duration")
+  void should_fail_if_duration_is_null(Function<Duration, TemporalUnitOffset> offsetFactory) {
+    // GIVEN
+    Duration duration = null;
+    // WHEN
+    NullPointerException npe = catchNullPointerException(() -> offsetFactory.apply(duration));
     // THEN
-    then(index).isEqualTo(new TemporalUnitLessThanOffset(value, temporalUnit));
+    then(npe).hasMessage("non null duration expected");
   }
 
-  private static Stream<BiFunction<Long, TemporalUnit, TemporalUnitOffset>> temporalOffsetFactories() {
+  private static Stream<Function<Duration, TemporalUnitOffset>> temporal_strictOffset_from_duration() {
     return Stream.of(Assertions::byLessThan, BDDAssertions::byLessThan, withAssertions::byLessThan);
   }
 
diff --git a/assertj-core/src/test/java/org/assertj/core/api/EntryPointAssertions_within_Test.java b/assertj-core/src/test/java/org/assertj/core/api/EntryPointAssertions_within_Test.java
index 98bedc5c1..dc8681e0a 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/EntryPointAssertions_within_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/EntryPointAssertions_within_Test.java
@@ -12,11 +12,13 @@
  */
 package org.assertj.core.api;
 
+import static org.assertj.core.api.Assertions.catchNullPointerException;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.Offset.offset;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.time.Duration;
 import java.time.temporal.ChronoUnit;
 import java.time.temporal.TemporalUnit;
 import java.util.function.BiFunction;
@@ -39,9 +41,9 @@ class EntryPointAssertions_within_Test extends EntryPointAssertionsBaseTest {
     // GIVEN
     BigDecimal offsetValue = BigDecimal.ONE;
     // WHEN
-    Offset<BigDecimal> index = offsetFactory.apply(offsetValue);
+    Offset<BigDecimal> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(offset(offsetValue));
+    then(offset).isEqualTo(offset(offsetValue));
   }
 
   private static Stream<Function<BigDecimal, Offset<BigDecimal>>> bigDecimalOffsetFactories() {
@@ -54,9 +56,9 @@ class EntryPointAssertions_within_Test extends EntryPointAssertionsBaseTest {
     // GIVEN
     BigInteger offsetValue = BigInteger.ONE;
     // WHEN
-    Offset<BigInteger> index = offsetFactory.apply(offsetValue);
+    Offset<BigInteger> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(offset(offsetValue));
+    then(offset).isEqualTo(offset(offsetValue));
   }
 
   private static Stream<Function<BigInteger, Offset<BigInteger>>> bigIntegerOffsetFactories() {
@@ -69,9 +71,9 @@ class EntryPointAssertions_within_Test extends EntryPointAssertionsBaseTest {
     // GIVEN
     Byte offsetValue = Byte.MAX_VALUE;
     // WHEN
-    Offset<Byte> index = offsetFactory.apply(offsetValue);
+    Offset<Byte> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(offset(offsetValue));
+    then(offset).isEqualTo(offset(offsetValue));
   }
 
   private static Stream<Function<Byte, Offset<Byte>>> byteOffsetFactories() {
@@ -84,9 +86,9 @@ class EntryPointAssertions_within_Test extends EntryPointAssertionsBaseTest {
     // GIVEN
     Double offsetValue = Double.MAX_VALUE;
     // WHEN
-    Offset<Double> index = offsetFactory.apply(offsetValue);
+    Offset<Double> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(offset(offsetValue));
+    then(offset).isEqualTo(offset(offsetValue));
   }
 
   private static Stream<Function<Double, Offset<Double>>> doubleOffsetFactories() {
@@ -99,9 +101,9 @@ class EntryPointAssertions_within_Test extends EntryPointAssertionsBaseTest {
     // GIVEN
     Float offsetValue = Float.MAX_VALUE;
     // WHEN
-    Offset<Float> index = offsetFactory.apply(offsetValue);
+    Offset<Float> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(offset(offsetValue));
+    then(offset).isEqualTo(offset(offsetValue));
   }
 
   private static Stream<Function<Float, Offset<Float>>> floatOffsetFactories() {
@@ -114,9 +116,9 @@ class EntryPointAssertions_within_Test extends EntryPointAssertionsBaseTest {
     // GIVEN
     Integer offsetValue = Integer.MAX_VALUE;
     // WHEN
-    Offset<Integer> index = offsetFactory.apply(offsetValue);
+    Offset<Integer> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(offset(offsetValue));
+    then(offset).isEqualTo(offset(offsetValue));
   }
 
   private static Stream<Function<Integer, Offset<Integer>>> integerOffsetFactories() {
@@ -129,9 +131,9 @@ class EntryPointAssertions_within_Test extends EntryPointAssertionsBaseTest {
     // GIVEN
     Long offsetValue = Long.MAX_VALUE;
     // WHEN
-    Offset<Long> index = offsetFactory.apply(offsetValue);
+    Offset<Long> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(offset(offsetValue));
+    then(offset).isEqualTo(offset(offsetValue));
   }
 
   private static Stream<Function<Long, Offset<Long>>> longOffsetFactories() {
@@ -142,27 +144,53 @@ class EntryPointAssertions_within_Test extends EntryPointAssertionsBaseTest {
   @MethodSource("temporalOffsetFactories")
   void should_create_temporal_offset(BiFunction<Long, TemporalUnit, TemporalUnitOffset> offsetFactory) {
     // GIVEN
-    Long value = Long.MAX_VALUE;
+    long value = Long.MAX_VALUE;
     TemporalUnit temporalUnit = ChronoUnit.MINUTES;
     // WHEN
-    TemporalUnitOffset index = offsetFactory.apply(value, temporalUnit);
+    TemporalUnitOffset offset = offsetFactory.apply(value, temporalUnit);
     // THEN
-    then(index).isEqualTo(new TemporalUnitWithinOffset(value, temporalUnit));
+    then(offset).isEqualTo(new TemporalUnitWithinOffset(value, temporalUnit));
   }
 
   private static Stream<BiFunction<Long, TemporalUnit, TemporalUnitOffset>> temporalOffsetFactories() {
     return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
   }
 
+  @ParameterizedTest
+  @MethodSource("temporal_offset_from_duration")
+  void should_create_temporal_strictOffset_from_duration(Function<Duration, TemporalUnitOffset> offsetFactory) {
+    // GIVEN
+    Duration duration = Duration.ofNanos(123);
+    // WHEN
+    TemporalUnitOffset offset = offsetFactory.apply(duration);
+    // THEN
+    then(offset).isEqualTo(new TemporalUnitWithinOffset(123, ChronoUnit.NANOS));
+  }
+
+  @ParameterizedTest
+  @MethodSource("temporal_offset_from_duration")
+  void should_fail_if_duration_is_null(Function<Duration, TemporalUnitOffset> offsetFactory) {
+    // GIVEN
+    Duration duration = null;
+    // WHEN
+    NullPointerException npe = catchNullPointerException(() -> offsetFactory.apply(duration));
+    // THEN
+    then(npe).hasMessage("non null duration expected");
+  }
+
+  private static Stream<Function<Duration, TemporalUnitOffset>> temporal_offset_from_duration() {
+    return Stream.of(Assertions::within, BDDAssertions::within, withAssertions::within);
+  }
+
   @ParameterizedTest
   @MethodSource("shortOffsetFactories")
   void should_create_Short_offset(Function<Short, Offset<Short>> offsetFactory) {
     // GIVEN
     Short offsetValue = Short.MAX_VALUE;
     // WHEN
-    Offset<Short> index = offsetFactory.apply(offsetValue);
+    Offset<Short> offset = offsetFactory.apply(offsetValue);
     // THEN
-    then(index).isEqualTo(offset(offsetValue));
+    then(offset).isEqualTo(offset(offsetValue));
   }
 
   private static Stream<Function<Short, Offset<Short>>> shortOffsetFactories() {
